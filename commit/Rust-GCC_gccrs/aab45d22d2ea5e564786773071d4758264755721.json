{"sha": "aab45d22d2ea5e564786773071d4758264755721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFiNDVkMjJkMmVhNWU1NjQ3ODY3NzMwNzFkNDc1ODI2NDc1NTcyMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:35:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T13:35:06Z"}, "message": "[multiple changes]\n\n2013-04-12  Robert Dewar  <dewar@adacore.com>\n\n\t* einfo.adb (Has_Dynamic_Predicate_Aspect): New flag.\n\t(Has_Static_Predicate_Aspect): New flag.\n\t* einfo.ads (Has_Dynamic_Predicate_Aspect): New flag.\n\t(Has_Static_Predicate_Aspect): New flag.\n\t* exp_ch9.adb: Minor reformatting.\n\t* exp_util.adb (Make_Invariant_Call): Check_Enabled now handles\n\tsynonyms.\n\t* gnat1drv.adb: Remove setting of Debug_Pragmas_Enabled,\n\tsince this switch is gone and control of Debug is done with\n\tAssertions_Enabled.\n\t* gnat_rm.texi: Update documentation for Assertion_Policy and\n\tCheck_Policy pragmas.\n\t* opt.adb (Debug_Pragmas_Disabled[_Config]): Removed\n\t(Debug_Pragmas_Enabled[_Config]): Removed Since debug now\n\tcontrolled by Assertion_Enabled.\n\t* opt.ads (Debug_Pragmas_Disabled[_Config]): Removed\n\t(Debug_Pragmas_Enabled[_Config]): Removed Since debug now\n\tcontrolled by Assertion_Enabled.\n\t* par-ch2.adb (Scan_Pragma_Argument_Association): Allow new\n\t'Class forms.\n\t* sem_attr.adb: Minor reformatting.\n\t* sem_ch13.adb (Analyze_Aspect_Specification): Disable aspect\n\tif DISABLE policy applies.\n\t* sem_ch6.adb (Grab_PPC): Check original name of aspect for\n\taspect from pragma (Process_PPCs): Properly check assertion policy.\n\t* sem_prag.adb (Check_Enabled): Rewritten for new Assertion_Policy\n\t(Check_Appicable_Policy): New procedure.\n\t(Is_Valid_Assertion_Kind): New function.\n\t(Rewrite_Assertion_Kind): New procedure.\n\t(Analyze_Pragma): Handle case of disabled assertion pragma.\n\t(Analyze_Pragma, case Assertion_Policy): Rewritten for Ada 2012.\n\t(Analyze_Pragma, case Check): Deal with 'Class possibilities.\n\t(Analyze_Pragma, case Check_Policy): Deal with 'Class possibilities.\n\t(Analyze_Pragma, case Contract_Class): New handling of ignored pragma.\n\t(Analyze_Pragma, case Debug): New control with Assertion_Policy.\n\t(Analyze_Pragma, case Debug_Policy): Now consistent with\n\tAssertion_Policy.\n\t(Analyze_Pragma, case Loop_Invariant): New handling of ignored\n\tpragma.\n\t(Analyze_Pragma, case Loop_Variant): New handling of ignored pragma.\n\t(Analyze_Pragma, case Precondition): Use proper name for Check pragma.\n\t(Analyze_Pragma, case Check_Enabled): Rewritten for new policy stuff.\n\t* sem_prag.ads (Check_Enabled): Rewritten for new\n\tAssertion_Policy stuff.\n\t(Check_Appicable_Policy): New procedure.\n\t* sinfo.adb (Is_Disabled): New flag.\n\t(Is_Ignored): New flag.\n\t* sinfo.ads (Is_Disabled): New flag.\n\t(Is_Ignored): New flag.\n\t(N_Pragma_Argument_Association): New 'Class forms.\n\t* snames.ads-tmpl: New names Name_uPre, Name_uPost,\n\tName_uType_Invariant, Name_uInvariant.\n\t* switch-c.adb: Remove setting of Debug_Pragmas_Enabled for -gnata.\n\t* tree_io.ads (ASIS_Version_Number): Updated (remove\n\tread write of obsolete flags Debug_Pragmas_Disabled and\n\tDebug_Pragmas_Enabled.\n\n2013-04-12  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Get_Explicit_Discriminant_Value): Subsidiary\n\tof Build_Record_Aggr_Code, used to retrieve explicit values\n\tfor inherited discriminants in an extension aggregate, when the\n\tancestor type is unconstrained.\n\nFrom-SVN: r197915", "tree": {"sha": "1a9201953396433c912575f685057fb0d68ffec1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a9201953396433c912575f685057fb0d68ffec1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aab45d22d2ea5e564786773071d4758264755721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab45d22d2ea5e564786773071d4758264755721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aab45d22d2ea5e564786773071d4758264755721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aab45d22d2ea5e564786773071d4758264755721/comments", "author": null, "committer": null, "parents": [{"sha": "beaa97abbff424d43e37b2efee127499386ad0ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beaa97abbff424d43e37b2efee127499386ad0ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beaa97abbff424d43e37b2efee127499386ad0ad"}], "stats": {"total": 1314, "additions": 1017, "deletions": 297}, "files": [{"sha": "258e97c389180430c1ff57f36e03297572d864e4", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1,3 +1,69 @@\n+2013-04-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* einfo.adb (Has_Dynamic_Predicate_Aspect): New flag.\n+\t(Has_Static_Predicate_Aspect): New flag.\n+\t* einfo.ads (Has_Dynamic_Predicate_Aspect): New flag.\n+\t(Has_Static_Predicate_Aspect): New flag.\n+\t* exp_ch9.adb: Minor reformatting.\n+\t* exp_util.adb (Make_Invariant_Call): Check_Enabled now handles\n+\tsynonyms.\n+\t* gnat1drv.adb: Remove setting of Debug_Pragmas_Enabled,\n+\tsince this switch is gone and control of Debug is done with\n+\tAssertions_Enabled.\n+\t* gnat_rm.texi: Update documentation for Assertion_Policy and\n+\tCheck_Policy pragmas.\n+\t* opt.adb (Debug_Pragmas_Disabled[_Config]): Removed\n+\t(Debug_Pragmas_Enabled[_Config]): Removed Since debug now\n+\tcontrolled by Assertion_Enabled.\n+\t* opt.ads (Debug_Pragmas_Disabled[_Config]): Removed\n+\t(Debug_Pragmas_Enabled[_Config]): Removed Since debug now\n+\tcontrolled by Assertion_Enabled.\n+\t* par-ch2.adb (Scan_Pragma_Argument_Association): Allow new\n+\t'Class forms.\n+\t* sem_attr.adb: Minor reformatting.\n+\t* sem_ch13.adb (Analyze_Aspect_Specification): Disable aspect\n+\tif DISABLE policy applies.\n+\t* sem_ch6.adb (Grab_PPC): Check original name of aspect for\n+\taspect from pragma (Process_PPCs): Properly check assertion policy.\n+\t* sem_prag.adb (Check_Enabled): Rewritten for new Assertion_Policy\n+\t(Check_Appicable_Policy): New procedure.\n+\t(Is_Valid_Assertion_Kind): New function.\n+\t(Rewrite_Assertion_Kind): New procedure.\n+\t(Analyze_Pragma): Handle case of disabled assertion pragma.\n+\t(Analyze_Pragma, case Assertion_Policy): Rewritten for Ada 2012.\n+\t(Analyze_Pragma, case Check): Deal with 'Class possibilities.\n+\t(Analyze_Pragma, case Check_Policy): Deal with 'Class possibilities.\n+\t(Analyze_Pragma, case Contract_Class): New handling of ignored pragma.\n+\t(Analyze_Pragma, case Debug): New control with Assertion_Policy.\n+\t(Analyze_Pragma, case Debug_Policy): Now consistent with\n+\tAssertion_Policy.\n+\t(Analyze_Pragma, case Loop_Invariant): New handling of ignored\n+\tpragma.\n+\t(Analyze_Pragma, case Loop_Variant): New handling of ignored pragma.\n+\t(Analyze_Pragma, case Precondition): Use proper name for Check pragma.\n+\t(Analyze_Pragma, case Check_Enabled): Rewritten for new policy stuff.\n+\t* sem_prag.ads (Check_Enabled): Rewritten for new\n+\tAssertion_Policy stuff.\n+\t(Check_Appicable_Policy): New procedure.\n+\t* sinfo.adb (Is_Disabled): New flag.\n+\t(Is_Ignored): New flag.\n+\t* sinfo.ads (Is_Disabled): New flag.\n+\t(Is_Ignored): New flag.\n+\t(N_Pragma_Argument_Association): New 'Class forms.\n+\t* snames.ads-tmpl: New names Name_uPre, Name_uPost,\n+\tName_uType_Invariant, Name_uInvariant.\n+\t* switch-c.adb: Remove setting of Debug_Pragmas_Enabled for -gnata.\n+\t* tree_io.ads (ASIS_Version_Number): Updated (remove\n+\tread write of obsolete flags Debug_Pragmas_Disabled and\n+\tDebug_Pragmas_Enabled.\n+\n+2013-04-12  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_aggr.adb (Get_Explicit_Discriminant_Value): Subsidiary\n+\tof Build_Record_Aggr_Code, used to retrieve explicit values\n+\tfor inherited discriminants in an extension aggregate, when the\n+\tancestor type is unconstrained.\n+\n 2013-04-12  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_attr.adb (Check_Stream_Attribute): If restriction"}, {"sha": "789a420704daa3d5637d13d50e308be90e226196", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -546,9 +546,9 @@ package body Einfo is\n    --    Is_Predicate_Function           Flag255\n    --    Is_Predicate_Function_M         Flag256\n    --    Is_Invariant_Procedure          Flag257\n+   --    Has_Dynamic_Predicate_Aspect    Flag258\n+   --    Has_Static_Predicate_Aspect     Flag259\n \n-   --    (unused)                        Flag258\n-   --    (unused)                        Flag259\n    --    (unused)                        Flag260\n \n    --    (unused)                        Flag261\n@@ -1395,6 +1395,12 @@ package body Einfo is\n       return Flag220 (Id);\n    end Has_Dispatch_Table;\n \n+   function Has_Dynamic_Predicate_Aspect (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag258 (Id);\n+   end Has_Dynamic_Predicate_Aspect;\n+\n    function Has_Enumeration_Rep_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -1670,6 +1676,12 @@ package body Einfo is\n       return Flag211 (Id);\n    end Has_Static_Discriminants;\n \n+   function Has_Static_Predicate_Aspect (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag259 (Id);\n+   end Has_Static_Predicate_Aspect;\n+\n    function Has_Storage_Size_Clause (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n@@ -3967,6 +3979,12 @@ package body Einfo is\n       Set_Flag220 (Id, V);\n    end Set_Has_Dispatch_Table;\n \n+   procedure Set_Has_Dynamic_Predicate_Aspect (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag258 (Id, V);\n+   end Set_Has_Dynamic_Predicate_Aspect;\n+\n    procedure Set_Has_Enumeration_Rep_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Enumeration_Type (Id));\n@@ -4251,6 +4269,12 @@ package body Einfo is\n       Set_Flag211 (Id, V);\n    end Set_Has_Static_Discriminants;\n \n+   procedure Set_Has_Static_Predicate_Aspect (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag259 (Id, V);\n+   end Set_Has_Static_Predicate_Aspect;\n+\n    procedure Set_Has_Storage_Size_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n@@ -7759,6 +7783,8 @@ package body Einfo is\n       W (\"Has_Delayed_Aspects\",             Flag200 (Id));\n       W (\"Has_Delayed_Freeze\",              Flag18  (Id));\n       W (\"Has_Discriminants\",               Flag5   (Id));\n+      W (\"Has_Dispatch_Table\",              Flag220 (Id));\n+      W (\"Has_Dynamic_Predicate_Aspect\",    Flag258 (Id));\n       W (\"Has_Enumeration_Rep_Clause\",      Flag66  (Id));\n       W (\"Has_Exit\",                        Flag47  (Id));\n       W (\"Has_External_Tag_Rep_Clause\",     Flag110 (Id));\n@@ -7808,6 +7834,7 @@ package body Einfo is\n       W (\"Has_Specified_Stream_Read\",       Flag192 (Id));\n       W (\"Has_Specified_Stream_Write\",      Flag193 (Id));\n       W (\"Has_Static_Discriminants\",        Flag211 (Id));\n+      W (\"Has_Static_Predicate_Aspect\",     Flag259 (Id));\n       W (\"Has_Storage_Size_Clause\",         Flag23  (Id));\n       W (\"Has_Stream_Size_Clause\",          Flag184 (Id));\n       W (\"Has_Task\",                        Flag30  (Id));"}, {"sha": "62ae8bf5d0e01e17ffa483cdc86ed9722146a6a3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1487,6 +1487,14 @@ package Einfo is\n --       of the table); otherwise the code that builds the table is added at\n --       the end of the list of declarations of the package.\n \n+--    Has_Dynamic_Predicate_Aspect (Flag258)\n+--       Defined in all types and subtypes. Set if a Dynamic_Predicate aspect\n+--       applies to the type. Note that we can tell if a dynamic predicate is\n+--       present by looking at Has_Predicates and Static_Predicate, but that\n+--       could have come from a Predicate aspect or pragma, and we need to\n+--       record the difference so that we can use the right set of check\n+--       policies to figure out if the predicate is active.\n+\n --    Has_Entries (synthesized)\n --       Applies to concurrent types. True if any entries are declared\n --       within the task or protected definition for the type.\n@@ -1817,6 +1825,14 @@ package Einfo is\n --       case of a variant record, the component list can be trimmed down to\n --       include only the components corresponding to these discriminants.\n \n+--    Has_Static_Predicate_Aspect (Flag259)\n+--       Defined in all types and subtypes. Set if a Dynamic_Predicate aspect\n+--       applies to the type. Note that we can tell if a static predicate is\n+--       present by looking at Has_Predicates and Static_Predicate, but that\n+--       could have come from a Predicate aspect or pragma, and we need to\n+--       record the difference so that we can use the right set of check\n+--       policies to figure out if the predicate is active.\n+\n --    Has_Storage_Size_Clause (Flag23) [implementation base type only]\n --       Defined in task types and access types. It is set if a Storage_Size\n --       clause is present for the type. Used to prevent multiple clauses for\n@@ -4980,6 +4996,7 @@ package Einfo is\n    --    Has_Controlled_Component            (Flag43)   (base type only)\n    --    Has_Default_Aspect                  (Flag39)   (base type only)\n    --    Has_Discriminants                   (Flag5)\n+   --    Has_Dynamic_Predicate_Aspect        (Flag258)\n    --    Has_Independent_Components          (Flag34)   (base type only)\n    --    Has_Inheritable_Invariants          (Flag248)\n    --    Has_Invariants                      (Flag232)\n@@ -4995,6 +5012,7 @@ package Einfo is\n    --    Has_Specified_Stream_Output         (Flag191)\n    --    Has_Specified_Stream_Read           (Flag192)\n    --    Has_Specified_Stream_Write          (Flag193)\n+   --    Has_Static_Predicate_Aspect         (Flag259)\n    --    Has_Task                            (Flag30)   (base type only)\n    --    Has_Unchecked_Union                 (Flag123)  (base type only)\n    --    Has_Volatile_Components             (Flag87)   (base type only)\n@@ -6247,6 +6265,7 @@ package Einfo is\n    function Has_Delayed_Freeze                  (Id : E) return B;\n    function Has_Discriminants                   (Id : E) return B;\n    function Has_Dispatch_Table                  (Id : E) return B;\n+   function Has_Dynamic_Predicate_Aspect        (Id : E) return B;\n    function Has_Enumeration_Rep_Clause          (Id : E) return B;\n    function Has_Exit                            (Id : E) return B;\n    function Has_External_Tag_Rep_Clause         (Id : E) return B;\n@@ -6285,6 +6304,7 @@ package Einfo is\n    function Has_Predicates                      (Id : E) return B;\n    function Has_Primitive_Operations            (Id : E) return B;\n    function Has_Private_Ancestor                (Id : E) return B;\n+   function Has_Private_Declaration             (Id : E) return B;\n    function Has_Qualified_Name                  (Id : E) return B;\n    function Has_RACW                            (Id : E) return B;\n    function Has_Record_Rep_Clause               (Id : E) return B;\n@@ -6297,6 +6317,7 @@ package Einfo is\n    function Has_Specified_Stream_Read           (Id : E) return B;\n    function Has_Specified_Stream_Write          (Id : E) return B;\n    function Has_Static_Discriminants            (Id : E) return B;\n+   function Has_Static_Predicate_Aspect         (Id : E) return B;\n    function Has_Storage_Size_Clause             (Id : E) return B;\n    function Has_Stream_Size_Clause              (Id : E) return B;\n    function Has_Task                            (Id : E) return B;\n@@ -6608,7 +6629,6 @@ package Einfo is\n    function Has_Attach_Handler                  (Id : E) return B;\n    function Has_Entries                         (Id : E) return B;\n    function Has_Foreign_Convention              (Id : E) return B;\n-   function Has_Private_Declaration             (Id : E) return B;\n    function Implementation_Base_Type            (Id : E) return E;\n    function Is_Base_Type                        (Id : E) return B;\n    function Is_Boolean_Type                     (Id : E) return B;\n@@ -6853,6 +6873,7 @@ package Einfo is\n    procedure Set_Has_Delayed_Freeze              (Id : E; V : B := True);\n    procedure Set_Has_Discriminants               (Id : E; V : B := True);\n    procedure Set_Has_Dispatch_Table              (Id : E; V : B := True);\n+   procedure Set_Has_Dynamic_Predicate_Aspect    (Id : E; V : B := True);\n    procedure Set_Has_Enumeration_Rep_Clause      (Id : E; V : B := True);\n    procedure Set_Has_Exit                        (Id : E; V : B := True);\n    procedure Set_Has_External_Tag_Rep_Clause     (Id : E; V : B := True);\n@@ -6903,6 +6924,7 @@ package Einfo is\n    procedure Set_Has_Specified_Stream_Read       (Id : E; V : B := True);\n    procedure Set_Has_Specified_Stream_Write      (Id : E; V : B := True);\n    procedure Set_Has_Static_Discriminants        (Id : E; V : B := True);\n+   procedure Set_Has_Static_Predicate_Aspect     (Id : E; V : B := True);\n    procedure Set_Has_Storage_Size_Clause         (Id : E; V : B := True);\n    procedure Set_Has_Stream_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Task                        (Id : E; V : B := True);\n@@ -7550,6 +7572,7 @@ package Einfo is\n    pragma Inline (Has_Delayed_Freeze);\n    pragma Inline (Has_Discriminants);\n    pragma Inline (Has_Dispatch_Table);\n+   pragma Inline (Has_Dynamic_Predicate_Aspect);\n    pragma Inline (Has_Enumeration_Rep_Clause);\n    pragma Inline (Has_Exit);\n    pragma Inline (Has_External_Tag_Rep_Clause);\n@@ -7600,6 +7623,7 @@ package Einfo is\n    pragma Inline (Has_Specified_Stream_Read);\n    pragma Inline (Has_Specified_Stream_Write);\n    pragma Inline (Has_Static_Discriminants);\n+   pragma Inline (Has_Static_Predicate_Aspect);\n    pragma Inline (Has_Storage_Size_Clause);\n    pragma Inline (Has_Stream_Size_Clause);\n    pragma Inline (Has_Task);\n@@ -8005,6 +8029,7 @@ package Einfo is\n    pragma Inline (Set_Has_Delayed_Freeze);\n    pragma Inline (Set_Has_Discriminants);\n    pragma Inline (Set_Has_Dispatch_Table);\n+   pragma Inline (Set_Has_Dynamic_Predicate_Aspect);\n    pragma Inline (Set_Has_Enumeration_Rep_Clause);\n    pragma Inline (Set_Has_Exit);\n    pragma Inline (Set_Has_External_Tag_Rep_Clause);\n@@ -8055,6 +8080,7 @@ package Einfo is\n    pragma Inline (Set_Has_Specified_Stream_Read);\n    pragma Inline (Set_Has_Specified_Stream_Write);\n    pragma Inline (Set_Has_Static_Discriminants);\n+   pragma Inline (Set_Has_Static_Predicate_Aspect);\n    pragma Inline (Set_Has_Storage_Size_Clause);\n    pragma Inline (Set_Has_Stream_Size_Clause);\n    pragma Inline (Set_Has_Task);"}, {"sha": "3303636db81bdbe0414a8ba77182b206d3ec5ec1", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1841,6 +1841,11 @@ package body Exp_Aggr is\n       --  these discriminants are not components of the aggregate, and must be\n       --  initialized. The assignments are appended to List.\n \n+      function Get_Explicit_Discriminant_Value (D : Entity_Id)  return Node_Id;\n+      --  If the ancestor part is an unconstrained type and further ancestors\n+      --  do not provide discriminants for it, check aggregate components for\n+      --  values of the discriminants.\n+\n       function Is_Int_Range_Bounds (Bounds : Node_Id) return Boolean;\n       --  Check whether Bounds is a range node and its lower and higher bounds\n       --  are integers literals.\n@@ -2059,6 +2064,35 @@ package body Exp_Aggr is\n          return Empty;\n       end Get_Constraint_Association;\n \n+      -------------------------------------\n+      -- Get_Explicit_Discriminant_Value --\n+      -------------------------------------\n+\n+      function Get_Explicit_Discriminant_Value (D : Entity_Id)  return Node_Id\n+      is\n+         Assoc  : Node_Id;\n+         Choice : Node_Id;\n+         Val    : Node_Id;\n+\n+      begin\n+         --  The aggregate has been normalized and all associations have a\n+         --  single choice.\n+\n+         Assoc := First (Component_Associations (N));\n+         while Present (Assoc) loop\n+            Choice := First (Choices (Assoc));\n+            if Chars (Choice) = Chars (D) then\n+               Val := Expression (Assoc);\n+               Remove (Assoc);\n+               return Val;\n+            end if;\n+\n+            Next (Assoc);\n+         end loop;\n+\n+         return Empty;\n+      end Get_Explicit_Discriminant_Value;\n+\n       -------------------------------\n       -- Init_Hidden_Discriminants --\n       -------------------------------\n@@ -2296,6 +2330,15 @@ package body Exp_Aggr is\n                      Discrim := First_Discriminant (Anc_Typ);\n                      while Present (Discrim) loop\n                         Disc_Value := Ancestor_Discriminant_Value (Discrim);\n+\n+                        --  If no usable discriminant in ancestors, check\n+                        --  whether aggregate has an explicit value for it.\n+\n+                        if No (Disc_Value) then\n+                           Disc_Value :=\n+                             Get_Explicit_Discriminant_Value (Discrim);\n+                        end if;\n+\n                         Append_To (Anc_Constr, Disc_Value);\n                         Next_Discriminant (Discrim);\n                      end loop;"}, {"sha": "6d35eb1d56f902cd4157e68585ff59e6215a5745", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1934,7 +1934,8 @@ package body Exp_Ch9 is\n \n          while Present (P) loop\n             if Pragma_Name (P) = Name_Precondition\n-              or else Pragma_Name (P) = Name_Postcondition\n+                 or else\n+               Pragma_Name (P) = Name_Postcondition\n             then\n                Append (Relocate_Node (P), Decls);\n                Set_Analyzed (Last (Decls), False);"}, {"sha": "190d76e1d7a33782ef4b41dc55019c2b173281d0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -5458,10 +5458,7 @@ package body Exp_Util is\n       pragma Assert\n         (Has_Invariants (Typ) and then Present (Invariant_Procedure (Typ)));\n \n-      if Check_Enabled (Name_Invariant)\n-           or else\n-         Check_Enabled (Name_Assertion)\n-      then\n+      if Check_Enabled (Name_Invariant) then\n          return\n            Make_Procedure_Call_Statement (Loc,\n              Name                   =>\n@@ -5590,14 +5587,26 @@ package body Exp_Util is\n       Expr : Node_Id) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n+      Nam : Name_Id;\n \n    begin\n+      --  Compute proper name to use, we need to get this right so that the\n+      --  right set of check policies apply to the CHeck pragma we are making.\n+\n+      if Has_Dynamic_Predicate_Aspect (Typ) then\n+         Nam := Name_Dynamic_Predicate;\n+      elsif Has_Static_Predicate_Aspect (Typ) then\n+         Nam := Name_Static_Predicate;\n+      else\n+         Nam := Name_Predicate;\n+      end if;\n+\n       return\n         Make_Pragma (Loc,\n           Pragma_Identifier            => Make_Identifier (Loc, Name_Check),\n           Pragma_Argument_Associations => New_List (\n             Make_Pragma_Argument_Association (Loc,\n-              Expression => Make_Identifier (Loc, Name_Predicate)),\n+              Expression => Make_Identifier (Loc, Nam)),\n             Make_Pragma_Argument_Association (Loc,\n               Expression => Make_Predicate_Call (Typ, Expr))));\n    end Make_Predicate_Check;"}, {"sha": "10ad1e907d31807c364034de3cd124559a720355", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -240,11 +240,9 @@ procedure Gnat1drv is\n \n          Generate_SCIL := True;\n \n-         --  Enable assertions and debug pragmas, since they give CodePeer\n-         --  valuable extra information.\n+         --  Enable assertions, since they give CodePeer valuable extra info\n \n          Assertions_Enabled    := True;\n-         Debug_Pragmas_Enabled := True;\n \n          --  Disable all simple value propagation. This is an optimization\n          --  which is valuable for code optimization, and also for generation\n@@ -401,11 +399,10 @@ procedure Gnat1drv is\n \n          Use_Expression_With_Actions := False;\n \n-         --  Enable assertions and debug pragmas, since they give valuable\n-         --  extra information for formal verification.\n+         --  Enable assertions, since they give valuable extra information for\n+         --  formal verification.\n \n-         Assertions_Enabled    := True;\n-         Debug_Pragmas_Enabled := True;\n+         Assertions_Enabled := True;\n \n          --  Turn off style check options since we are not interested in any\n          --  front-end warnings when we are getting Alfa output."}, {"sha": "ce5a35d1b639bf386a5feb138e97ac0acfad3e8d", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 91, "deletions": 76, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1229,47 +1229,69 @@ addition.\n \n @node Pragma Assertion_Policy\n @unnumberedsec Pragma Assertion_Policy\n-@findex Debug_Policy\n+@findex Assertion_Policy\n @noindent\n Syntax:\n-\n @smallexample @c ada\n pragma Assertion_Policy (CHECK | DISABLE | IGNORE);\n+\n+Pragma Assertion_Policy (\n+    ASSERTION_KIND => POLICY_IDENTIFIER\n+ @{, ASSERTION_KIND => POLICY_IDENTIFIER@});\n+\n+ASSERTION_KIND ::= RM_ASSERTION_KIND | ID_ASSERTION_KIND\n+\n+RM_ASSERTION_KIND ::= Assert               |\n+                      Static_Predicate     |\n+                      Dynamic_Predicate    |\n+                      Pre                  |\n+                      Pre'Class            |\n+                      Post                 |\n+                      Post'Class           |\n+                      Type_Invariant       |\n+                      Type_Invariant'Class\n+\n+ID_ASSERTION_KIND ::= Assert_And_Cut       |\n+                      Assume               |\n+                      Contract_Cases       |\n+                      Debug                |\n+                      Invariant            |\n+                      Invariant'Class      |\n+                      Loop_Invariant       |\n+                      Loop_Variant         |\n+                      Postcondition        |\n+                      Precondition         |\n+                      Predicate\n+\n+POLICY_IDENTIFIER ::= Check | Disable | Ignore\n @end smallexample\n \n @noindent\n-This is a standard Ada 2005 pragma that is available as an\n+This is a standard Ada 2012 pragma that is available as an\n implementation-defined pragma in earlier versions of Ada.\n-\n-If the argument is @code{CHECK}, then assertions are enabled.\n-If the argument is @code{IGNORE}, then assertions are ignored.\n+The assertion kinds @code{RM_ASSERTION_KIND} are those defined in\n+the Ada standard. The assertion kinds @code{ID_ASSERTION_KIND}\n+are implementation defined additions recognized by the GNAT compiler.\n+\n+The pragma applies in both cases to pragmas and aspects with matching\n+names, e.g. @code{Pre} applies to the Pre aspect, and @code{Precondition}\n+applies to both the @code{Precondition} pragma\n+and the aspect @code{Precondition}.\n+\n+If the policy is @code{CHECK}, then assertions are enabled, i.e.\n+the corresponding pragma or aspect is activated.\n+If the policy is @code{IGNORE}, then assertions are ignored, i.e.\n+the corresponding pragma or aspect is deactivated.\n This pragma overrides the effect of the @option{-gnata} switch on the\n command line.\n \n-Assertions are of three kinds:\n-\n-@itemize @bullet\n-@item\n-Pragma @code{Assert}.\n-@item\n-In Ada 2012, all assertions defined in the RM as aspects: preconditions,\n-postconditions, type invariants and (sub)type predicates.\n-@item\n-Corresponding pragmas for type invariants and (sub)type predicates.\n-@end itemize\n-\n The implementation defined policy @code{DISABLE} is like\n @code{IGNORE} except that it completely disables semantic\n-checking of the argument to @code{pragma Assert}. This may\n-be useful when the pragma argument references subprograms\n+checking of the corresponding pragma or aspect. This is\n+useful when the pragma or aspect argument references subprograms\n in a with'ed package which is replaced by a dummy package\n for the final build.\n \n-Note: this is a standard language-defined pragma in versions\n-of Ada from 2005 on. In GNAT, it is implemented in all versions\n-of Ada, and the DISABLE policy is an implementation-defined\n-addition.\n-\n @node Pragma Assume_No_Invalid_Values\n @unnumberedsec Pragma Assume_No_Invalid_Values\n @findex Assume_No_Invalid_Values\n@@ -1416,20 +1438,20 @@ passing mechanisms on a parameter by parameter basis.\n Syntax:\n @smallexample @c ada\n pragma Check (\n-     [Name    =>] Identifier,\n+     [Name    =>] CHECK_KIND,\n      [Check   =>] Boolean_EXPRESSION\n   [, [Message =>] string_EXPRESSION] );\n+\n+CHECK_KIND ::= IDENTIFIER |\n+               Pre'Class | Post'Class | Type_Invariant'Class\n @end smallexample\n \n @noindent\n This pragma is similar to the predefined pragma @code{Assert} except that an\n extra identifier argument is present. In conjunction with pragma\n @code{Check_Policy}, this can be used to define groups of assertions that can\n be independently controlled. The identifier @code{Assertion} is special, it\n-refers to the normal set of pragma @code{Assert} statements. The identifiers\n-@code{Precondition} and @code{Postcondition} correspond to the pragmas of these\n-names, so these three names would normally not be used directly in a pragma\n-@code{Check}.\n+refers to the normal set of pragma @code{Assert} statements.\n \n Checks introduced by this pragma are normally deactivated by default. They can\n be activated either by the command line option @option{-gnata}, which turns on\n@@ -1532,60 +1554,60 @@ switches (in particular -gnatp) in the usual manner.\n Syntax:\n @smallexample @c ada\n pragma Check_Policy\n- ([Name   =>] Identifier,\n+ ([Name   =>] CHECK_KIND,\n   [Policy =>] POLICY_IDENTIFIER);\n \n+CHECK_KIND ::= IDENTIFIER |\n+                   Pre'Class | Post'Class | Type_Invariant'Class\n+\n POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE\n @end smallexample\n \n @noindent\n-This pragma is similar to the predefined pragma @code{Assertion_Policy},\n-except that it controls sets of named assertions introduced using the\n-@code{Check} pragmas. It can be used as a configuration pragma or (unlike\n-@code{Assertion_Policy}) can be used within a declarative part, in which case\n-it controls the status to the end of the corresponding construct (in a manner\n-identical to pragma @code{Suppress)}.\n+This pragma is used to set the checking policy for assertions (specified\n+by aspects of pragmas), the @code{Debug} pragma, or additional checks\n+to be checked using the @code{Check} pragma. It may appear either as\n+a configuration pragma, or within a declarative part of package. In the\n+latter case, it applies from the point where it appears to the end of\n+the declarative region (like pragma @code{Suppress}).\n \n-The identifier given as the first argument corresponds to a name used in\n-associated @code{Check} pragmas. For example, if the pragma:\n+The @code{Check_Policy} pragma is similar to the\n+predefined @code{Assertion_Policy} pragma,\n+and if the first argument corresponds to one of the assertion kinds that\n+are allowed by @code{Assertion_Policy}, then the effect is identical.\n+The identifiers @code{Precondition} and @code{Postcondition} are allowed\n+synonyms for @code{Pre} and @code{Post}.\n+\n+If the first argument is Debug, then the policy applies to Debug pragmas,\n+disabling their effect if the policy is @code{Off}, @code{Disable}, or\n+@code{Ignore}, and allowing them to execute with normal semantics if\n+the policy is @code{On} or @code{Check}. In addition if the policy is\n+@code{Disable}, then the procedure call in @code{Debug} pragmas will\n+be totally ignored and not analyzed semanticslly.\n+\n+Finally the first argument may be some other identifier than the above\n+posibilities, in which case it controls a set of named assertions\n+that can be checked using pragma @code{Check}. For example, if the pragma:\n \n @smallexample @c ada\n pragma Check_Policy (Critical_Error, OFF);\n @end smallexample\n \n @noindent\n is given, then subsequent @code{Check} pragmas whose first argument is also\n-@code{Critical_Error} will be disabled. The special identifier @code{Assertion}\n-controls the behavior of normal assertions (thus a pragma\n-@code{Check_Policy} with this identifier is similar to the normal\n-@code{Assertion_Policy} pragma except that it can appear within a\n-declarative part).\n-\n-The special identifiers @code{Precondition} and @code{Postcondition} control\n-the status of preconditions and postconditions given as pragmas.\n-If a @code{Precondition} pragma\n-is encountered, it is ignored if turned off by a @code{Check_Policy} specifying\n-that @code{Precondition} checks are @code{Off} or @code{Ignored}. Similarly use\n-of the name @code{Postcondition} controls whether @code{Postcondition} pragmas\n-are recognized. Note that preconditions and postconditions given as aspects\n-are controlled differently, either by the @code{Assertion_Policy} pragma or\n-by the @code{Check_Policy} pragma with identifier @code{Assertion}.\n+@code{Critical_Error} will be disabled.\n \n The check policy is @code{OFF} to turn off corresponding checks, and @code{ON}\n to turn on corresponding checks. The default for a set of checks for which no\n @code{Check_Policy} is given is @code{OFF} unless the compiler switch\n @option{-gnata} is given, which turns on all checks by default.\n \n-The check policy settings @code{CHECK} and @code{IGNORE} are also recognized\n+The check policy settings @code{CHECK} and @code{IGNORE} are recognized\n as synonyms for @code{ON} and @code{OFF}. These synonyms are provided for\n-compatibility with the standard @code{Assertion_Policy} pragma.\n-\n-The implementation defined policy @code{DISABLE} is like\n-@code{OFF} except that it completely disables semantic\n-checking of the argument to the corresponding class of\n-pragmas. This may be useful when the pragma arguments reference\n-subprograms in a with'ed package which is replaced by a dummy package\n-for the final build.\n+compatibility with the standard @code{Assertion_Policy} pragma. The check\n+policy setting @code{DISABLE} is also synonymous with @code{OFF} in this\n+context, but does not have any other significance for check\n+names other than assertion kinds.\n \n @node Pragma Comment\n @unnumberedsec Pragma Comment\n@@ -2113,7 +2135,8 @@ corresponding to the argument with a terminating semicolon. Pragmas are\n permitted in sequences of declarations, so you can use pragma @code{Debug} to\n intersperse calls to debug procedures in the middle of declarations. Debug\n pragmas can be enabled either by use of the command line switch @option{-gnata}\n-or by use of the configuration pragma @code{Debug_Policy}.\n+or by use of the pragma @code{Check_Policy} with a first argument of\n+@code{Debug}.\n \n @node Pragma Debug_Policy\n @unnumberedsec Pragma Debug_Policy\n@@ -2122,21 +2145,13 @@ or by use of the configuration pragma @code{Debug_Policy}.\n Syntax:\n \n @smallexample @c ada\n-pragma Debug_Policy (CHECK | DISABLE | IGNORE);\n+pragma Debug_Policy (CHECK | DISABLE | IGNORE | ON | OFF);\n @end smallexample\n \n @noindent\n-If the argument is @code{CHECK}, then pragma @code{DEBUG} is enabled.\n-If the argument is @code{IGNORE}, then pragma @code{DEBUG} is ignored.\n-This pragma overrides the effect of the @option{-gnata} switch on the\n-command line.\n-\n-The implementation defined policy @code{DISABLE} is like\n-@code{IGNORE} except that it completely disables semantic\n-checking of the argument to @code{pragma Debug}. This may\n-be useful when the pragma argument references subprograms\n-in a with'ed package which is replaced by a dummy package\n-for the final build.\n+This pragma is equivalent to a corresponding @code{Check_Policy} pragma\n+with a first argument of @code{Debug}. It is retained for historical\n+compatibility reasons.\n \n @node Pragma Default_Storage_Pool\n @unnumberedsec Pragma Default_Storage_Pool"}, {"sha": "136fb5f2d7b882755347371964e276a97a7af8ab", "filename": "gcc/ada/opt.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fopt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fopt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -59,8 +59,6 @@ package body Opt is\n       Assume_No_Invalid_Values_Config       := Assume_No_Invalid_Values;\n       Check_Float_Overflow_Config           := Check_Float_Overflow;\n       Check_Policy_List_Config              := Check_Policy_List;\n-      Debug_Pragmas_Disabled_Config         := Debug_Pragmas_Disabled;\n-      Debug_Pragmas_Enabled_Config          := Debug_Pragmas_Enabled;\n       Default_Pool_Config                   := Default_Pool;\n       Dynamic_Elaboration_Checks_Config     := Dynamic_Elaboration_Checks;\n       Exception_Locations_Suppressed_Config := Exception_Locations_Suppressed;\n@@ -94,8 +92,6 @@ package body Opt is\n       Assume_No_Invalid_Values       := Save.Assume_No_Invalid_Values;\n       Check_Float_Overflow           := Save.Check_Float_Overflow;\n       Check_Policy_List              := Save.Check_Policy_List;\n-      Debug_Pragmas_Disabled         := Save.Debug_Pragmas_Disabled;\n-      Debug_Pragmas_Enabled          := Save.Debug_Pragmas_Enabled;\n       Default_Pool                   := Save.Default_Pool;\n       Dynamic_Elaboration_Checks     := Save.Dynamic_Elaboration_Checks;\n       Exception_Locations_Suppressed := Save.Exception_Locations_Suppressed;\n@@ -131,8 +127,6 @@ package body Opt is\n       Save.Assume_No_Invalid_Values       := Assume_No_Invalid_Values;\n       Save.Check_Float_Overflow           := Check_Float_Overflow;\n       Save.Check_Policy_List              := Check_Policy_List;\n-      Save.Debug_Pragmas_Disabled         := Debug_Pragmas_Disabled;\n-      Save.Debug_Pragmas_Enabled          := Debug_Pragmas_Enabled;\n       Save.Default_Pool                   := Default_Pool;\n       Save.Dynamic_Elaboration_Checks     := Dynamic_Elaboration_Checks;\n       Save.Exception_Locations_Suppressed := Exception_Locations_Suppressed;\n@@ -183,14 +177,10 @@ package body Opt is\n          if Main_Unit then\n             Assertions_Enabled       := Assertions_Enabled_Config;\n             Assume_No_Invalid_Values := Assume_No_Invalid_Values_Config;\n-            Debug_Pragmas_Disabled   := Debug_Pragmas_Disabled_Config;\n-            Debug_Pragmas_Enabled    := Debug_Pragmas_Enabled_Config;\n             Check_Policy_List        := Check_Policy_List_Config;\n          else\n             Assertions_Enabled       := False;\n             Assume_No_Invalid_Values := False;\n-            Debug_Pragmas_Disabled   := False;\n-            Debug_Pragmas_Enabled    := False;\n             Check_Policy_List        := Empty;\n          end if;\n \n@@ -203,8 +193,6 @@ package body Opt is\n          Assume_No_Invalid_Values    := Assume_No_Invalid_Values_Config;\n          Check_Float_Overflow        := Check_Float_Overflow_Config;\n          Check_Policy_List           := Check_Policy_List_Config;\n-         Debug_Pragmas_Disabled      := Debug_Pragmas_Disabled_Config;\n-         Debug_Pragmas_Enabled       := Debug_Pragmas_Enabled_Config;\n          Dynamic_Elaboration_Checks  := Dynamic_Elaboration_Checks_Config;\n          Extensions_Allowed          := Extensions_Allowed_Config;\n          External_Name_Exp_Casing    := External_Name_Exp_Casing_Config;\n@@ -261,8 +249,6 @@ package body Opt is\n       Tree_Read_Bool (Assertions_Enabled);\n       Tree_Read_Bool (Check_Float_Overflow);\n       Tree_Read_Int  (Int (Check_Policy_List));\n-      Tree_Read_Bool (Debug_Pragmas_Disabled);\n-      Tree_Read_Bool (Debug_Pragmas_Enabled);\n       Tree_Read_Int  (Int (Default_Pool));\n       Tree_Read_Bool (Full_List);\n \n@@ -328,8 +314,6 @@ package body Opt is\n       Tree_Write_Bool (Assertions_Enabled);\n       Tree_Write_Bool (Check_Float_Overflow);\n       Tree_Write_Int  (Int (Check_Policy_List));\n-      Tree_Write_Bool (Debug_Pragmas_Disabled);\n-      Tree_Write_Bool (Debug_Pragmas_Enabled);\n       Tree_Write_Int  (Int (Default_Pool));\n       Tree_Write_Bool (Full_List);\n       Tree_Write_Int  (Int (Version_String'Length));"}, {"sha": "0d39573aae74129204e7f46bdc78aacf6a3cde38", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -341,7 +341,7 @@ package Opt is\n    --  Modified by use of -gnatwu/U.\n \n    CodePeer_Mode : Boolean := False;\n-   --  GNAT, GNATBIND\n+   --  GNAT, GNATBIND, GPRBUILD\n    --  Enable full CodePeer mode (SCIL generation, disable switches that\n    --  interact badly with it, etc...).\n \n@@ -388,14 +388,6 @@ package Opt is\n    --  Set to True (-C switch) to indicate that the compiler will be invoked\n    --  with a mapping file (-gnatem compiler switch).\n \n-   Debug_Pragmas_Enabled : Boolean := False;\n-   --  GNAT\n-   --  Enable debug statements from pragma Debug\n-\n-   Debug_Pragmas_Disabled : Boolean := False;\n-   --  GNAT\n-   --  Debug pragmas completely disabled (no semantic checking)\n-\n    subtype Debug_Level_Value is Nat range 0 .. 3;\n    Debugger_Level : Debug_Level_Value := 0;\n    --  GNATBIND\n@@ -1785,17 +1777,6 @@ package Opt is\n    --  terminated by Empty. The order is most recently processed first. This\n    --  list includes only those pragmas in configuration pragma files.\n \n-   Debug_Pragmas_Disabled_Config : Boolean;\n-   --  GNAT\n-   --  This is the value of the configuration switch for debug pragmas disabled\n-   --  mode, as possibly set by use of the configuration pragma Debug_Policy.\n-\n-   Debug_Pragmas_Enabled_Config : Boolean;\n-   --  GNAT\n-   --  This is the value of the configuration switch for debug pragmas enabled\n-   --  mode, as possibly set by the command line switch -gnata and possibly\n-   --  modified by the use of the configuration pragma Debug_Policy.\n-\n    Default_Pool_Config : Node_Id := Empty;\n    --  GNAT\n    --  Same as Default_Pool above, except this is only for Default_Storage_Pool\n@@ -2042,8 +2023,6 @@ private\n       Assume_No_Invalid_Values       : Boolean;\n       Check_Float_Overflow           : Boolean;\n       Check_Policy_List              : Node_Id;\n-      Debug_Pragmas_Disabled         : Boolean;\n-      Debug_Pragmas_Enabled          : Boolean;\n       Default_Pool                   : Node_Id;\n       Dynamic_Elaboration_Checks     : Boolean;\n       Exception_Locations_Suppressed : Boolean;"}, {"sha": "37fe454c7928076137056d37096d3d99d3082c56", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 81, "deletions": 9, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -40,6 +40,12 @@ package body Ch2 is\n    --  the scanned association has an identifier (this is used to check the\n    --  rule that no associations without identifiers can follow an association\n    --  which has an identifier). The result is returned in Association.\n+   --\n+   --  Note: We allow attribute forms Pre'Class, Post'Class, Invariant'Class,\n+   --  Type_Invariant'Class in place of a pragma argument identifier. Rather\n+   --  than handle this case specially, we replace such references with\n+   --  one of the special internal identifiers _Pre, _Post, _Invariant, or\n+   --  _Type_Invariant, and this procedure is where this replacement occurs.\n \n    ---------------------\n    -- 2.3  Identifier --\n@@ -448,6 +454,24 @@ package body Ch2 is\n    --    [pragma_argument_IDENTIFIER =>] NAME\n    --  | [pragma_argument_IDENTIFIER =>] EXPRESSION\n \n+   --  In Ada 2012, there are two more possibilities:\n+\n+   --  PRAGMA_ARGUMENT_ASSOCIATION ::=\n+   --    [pragma_argument_ASPECT_MARK =>] NAME\n+   --  | [pragma_argument_ASPECT_MARK =>] EXPRESSION\n+\n+   --  where the interesting allowed cases (which do not fit the syntax of the\n+   --  first alternative above are\n+\n+   --  ASPECT_MARK ::=\n+   --    Pre'Class | Post'Class | Invariant'Class | Type_Invariant'Class\n+\n+   --  We allow this special usage in all Ada modes, but it would be a pain to\n+   --  allow these aspects to pervade the pragma syntax, and the representation\n+   --  of pragma nodes internally. So what we do is to replace these\n+   --  ASPECT_MARK forms with identifiers whose name is one of the special\n+   --  internal names _Pre, _Post, _Invariant, or _Type_Invariant.\n+\n    --  Error recovery: cannot raise Error_Resync\n \n    procedure Scan_Pragma_Argument_Association\n@@ -461,6 +485,7 @@ package body Ch2 is\n    begin\n       Association := New_Node (N_Pragma_Argument_Association, Token_Ptr);\n       Set_Chars (Association, No_Name);\n+      Id_Present := False;\n \n       --  Argument starts with identifier\n \n@@ -470,22 +495,69 @@ package body Ch2 is\n          Scan; -- past Identifier\n \n          if Token = Tok_Arrow then\n-            Identifier_Seen := True;\n             Scan; -- past arrow\n-            Set_Chars (Association, Chars (Identifier_Node));\n             Id_Present := True;\n \n-         --  Case of argument with no identifier\n+         --  Case of one of the special aspect forms\n \n-         else\n-            Restore_Scan_State (Scan_State); -- to Identifier\n-            Id_Present := False;\n+         elsif Token = Tok_Apostrophe then\n+            Scan; -- past apostrophe\n+\n+            --  We have apostrophe, so check for identifier'Class\n+\n+            if Token /= Tok_Identifier or else Token_Name /= Name_Class then\n+               null;\n+\n+            --  We have identifier'Class, check for arrow\n+\n+            else\n+               Scan; -- Past Class\n+\n+               if Token /= Tok_Arrow then\n+                  null;\n+\n+               --  Here we have scanned identifier'Class =>\n+\n+               else\n+                  Id_Present := True;\n+                  Scan; -- past arrow\n+\n+                  case Chars (Identifier_Node) is\n+                     when Name_Pre =>\n+                        Set_Chars (Identifier_Node, Name_uPre);\n+\n+                     when Name_Post =>\n+                        Set_Chars (Identifier_Node, Name_uPost);\n+\n+                     when Name_Type_Invariant =>\n+                        Set_Chars (Identifier_Node, Name_uType_Invariant);\n+\n+                     when Name_Invariant =>\n+                        Set_Chars (Identifier_Node, Name_uInvariant);\n+\n+                     --  If it is X'Class => for some invalid X, we will give\n+                     --  an error, and forget that 'Class was present, which\n+                     --  will give better error recovery. We could do a spell\n+                     --  check here, but it seems too much work.\n+\n+                     when others =>\n+                        Error_Msg_SC (\"invalid aspect id for pragma\");\n+                  end case;\n+               end if;\n+            end if;\n          end if;\n \n-      --  Argument does not start with identifier\n+         --  Identifier was present\n \n-      else\n-         Id_Present := False;\n+         if Id_Present then\n+            Set_Chars (Association, Chars (Identifier_Node));\n+            Identifier_Seen := True;\n+\n+         --  Identifier not present after all\n+\n+         else\n+            Restore_Scan_State (Scan_State); -- to Identifier\n+         end if;\n       end if;\n \n       --  Diagnose error of \"positional\" argument for pragma appearing after"}, {"sha": "808ec968c935fadb3d01ea8e870f8668010edeea", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -4345,11 +4345,10 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n-         --  Either the attribute reference is generated for a Requires\n-         --  clause, in which case no expressions follow, or it is a\n-         --  primary. In that case, if expressions follow, the attribute\n-         --  reference is an indexable object, so rewrite the node\n-         --  accordingly.\n+         --  If the attribute reference is generated for a Requires clause,\n+         --  then no expressions follow. Otherwise it is a primary, in which\n+         --  case, if expressions follow, the attribute reference must be\n+         --  an indexable object, so rewrite the node accordingly.\n \n          if Present (E1) then\n             Rewrite (N,"}, {"sha": "aa633f574ffc57902463169ede2cc3253a95eab5", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -51,6 +51,7 @@ with Sem_Ch9;  use Sem_Ch9;\n with Sem_Dim;  use Sem_Dim;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n@@ -947,11 +948,11 @@ package body Sem_Ch13 is\n       --  Some special cases don't require delay analysis, thus the aspect is\n       --  analyzed right now.\n \n-      --  Note that there is a special handling for\n-      --  Pre/Post/Test_Case/Contract_Case aspects. In this case, we do not\n-      --  have to worry about delay issues, since the pragmas themselves deal\n-      --  with delay of visibility for the expression analysis. Thus, we just\n-      --  insert the pragma after the node N.\n+      --  Note that there is a special handling for Pre, Post, Test_Case,\n+      --  Contract_Case aspects. In these cases, we do not have to worry\n+      --  about delay issues, since the pragmas themselves deal with delay\n+      --  of visibility for the expression analysis. Thus, we just insert\n+      --  the pragma after the node N.\n \n    begin\n       pragma Assert (Present (L));\n@@ -1007,7 +1008,7 @@ package body Sem_Ch13 is\n \n                   if No (A) then\n                      Error_Msg_N\n-                       (\"Missing Import/Export for Link/External name\",\n+                       (\"missing Import/Export for Link/External name\",\n                          Aspect);\n                   end if;\n                end;\n@@ -1021,7 +1022,7 @@ package body Sem_Ch13 is\n             begin\n                if not Is_Type (E) or else not Has_Discriminants (E) then\n                   Error_Msg_N\n-                    (\"Aspect must apply to a type with discriminants\", N);\n+                    (\"aspect must apply to a type with discriminants\", N);\n \n                else\n                   declare\n@@ -1057,6 +1058,15 @@ package body Sem_Ch13 is\n                goto Continue;\n             end if;\n \n+            --  Skip looking at aspect if it is totally disabled. Just mark\n+            --  it as such for later reference in the tree.\n+\n+            Check_Applicable_Policy (Aspect);\n+\n+            if Is_Disabled (Aspect) then\n+               goto Continue;\n+            end if;\n+\n             --  Set the source location of expression, used in the case of\n             --  a failed precondition/postcondition or invariant. Note that\n             --  the source location of the expression is not usually the best\n@@ -1080,7 +1090,7 @@ package body Sem_Ch13 is\n \n             Check_Restriction_No_Specification_Of_Aspect (Aspect);\n \n-            --  Analyze this aspect\n+            --  Analyze this aspect (actual analysis is delayed till later)\n \n             Set_Analyzed (Aspect);\n             Set_Entity (Aspect, E);\n@@ -1202,7 +1212,7 @@ package body Sem_Ch13 is\n                       Chars      => Chars (Id),\n                       Expression => Relocate_Node (Expr));\n \n-               --  Case 2: Aspects cooresponding to pragmas\n+               --  Case 2: Aspects corresponding to pragmas\n \n                --  Case 2a: Aspects corresponding to pragmas with two\n                --  arguments, where the first argument is a local name\n@@ -1212,8 +1222,6 @@ package body Sem_Ch13 is\n                when Aspect_Suppress   |\n                     Aspect_Unsuppress =>\n \n-                  --  Construct the pragma\n-\n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n@@ -1264,7 +1272,8 @@ package body Sem_Ch13 is\n                     Aspect_Static_Predicate  =>\n \n                   --  Construct the pragma (always a pragma Predicate, with\n-                  --  flags recording whether it is static/dynamic).\n+                  --  flags recording whether it is static/dynamic). We also\n+                  --  set flags recording this in the type itself.\n \n                   Aitem :=\n                     Make_Pragma (Loc,\n@@ -1277,16 +1286,33 @@ package body Sem_Ch13 is\n                       Pragma_Identifier            =>\n                         Make_Identifier (Sloc (Id), Name_Predicate));\n \n+                  --  Mark type has predicates, and remember what kind of\n+                  --  aspect lead to this predicate (we need this to access\n+                  --  the right set of check policies later on).\n+\n+                  Set_Has_Predicates (E);\n+\n+                  if A_Id = Aspect_Dynamic_Predicate then\n+                     Set_Has_Dynamic_Predicate_Aspect (E);\n+                  elsif A_Id = Aspect_Static_Predicate then\n+                     Set_Has_Static_Predicate_Aspect (E);\n+                  end if;\n+\n                   --  If the type is private, indicate that its completion\n                   --  has a freeze node, because that is the one that will be\n                   --  visible at freeze time.\n \n-                  Set_Has_Predicates (E);\n-\n                   if Is_Private_Type (E)\n                     and then Present (Full_View (E))\n                   then\n                      Set_Has_Predicates (Full_View (E));\n+\n+                     if A_Id = Aspect_Dynamic_Predicate then\n+                        Set_Has_Dynamic_Predicate_Aspect (Full_View (E));\n+                     elsif A_Id = Aspect_Static_Predicate then\n+                        Set_Has_Static_Predicate_Aspect (Full_View (E));\n+                     end if;\n+\n                      Set_Has_Delayed_Aspects (Full_View (E));\n                      Ensure_Freeze_Node (Full_View (E));\n                   end if;\n@@ -1379,6 +1405,7 @@ package body Sem_Ch13 is\n                when Aspect_CPU                |\n                     Aspect_Interrupt_Priority |\n                     Aspect_Priority           =>\n+\n                   if Nkind (N) = N_Subprogram_Body then\n                      Aitem :=\n                        Make_Pragma (Loc,\n@@ -1396,9 +1423,6 @@ package body Sem_Ch13 is\n                   end if;\n \n                when Aspect_Warnings =>\n-\n-                  --  Construct the pragma\n-\n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n@@ -1429,8 +1453,6 @@ package body Sem_Ch13 is\n                   --  an invariant must apply to a private type, or appear in\n                   --  the private part of a spec and apply to a completion.\n \n-                  --  Construct the pragma\n-\n                   Aitem :=\n                     Make_Pragma (Loc,\n                       Pragma_Argument_Associations => New_List (\n@@ -1440,7 +1462,7 @@ package body Sem_Ch13 is\n                           Expression => Relocate_Node (Expr))),\n                       Class_Present                => Class_Present (Aspect),\n                       Pragma_Identifier            =>\n-                        Make_Identifier (Sloc (Id), Name_Invariant));\n+                                 Make_Identifier (Sloc (Id), Name_Invariant));\n \n                   --  Add message unless exception messages are suppressed\n \n@@ -1572,6 +1594,7 @@ package body Sem_Ch13 is\n                   goto Continue;\n \n                --  Case 4: Special handling for aspects\n+\n                --  Pre/Post/Test_Case/Contract_Case whose corresponding pragmas\n                --  take care of the delay.\n \n@@ -5716,7 +5739,7 @@ package body Sem_Ch13 is\n       --  predicate being considered dynamic even if it looks static\n \n       Static_Predicate_Present : Node_Id := Empty;\n-      --  Set to N_Pragma node for a static predicate if one is encountered.\n+      --  Set to N_Pragma node for a static predicate if one is encountered\n \n       --------------\n       -- Add_Call --"}, {"sha": "7a6536f1163b0db33439333828b686f17bc02bfb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -490,8 +490,6 @@ package body Sem_Ch6 is\n       Func_Nam : constant Node_Id := Name (N);\n       Actual   : Node_Id;\n \n-   --  Start of processing for Analyze_Function_Call\n-\n    begin\n       Analyze (Func_Nam);\n \n@@ -7217,9 +7215,8 @@ package body Sem_Ch6 is\n          Prag := Spec_CTC_List (Contract (Spec));\n          loop\n             if Pragma_Name (Prag) = Name_Contract_Cases then\n-\n-               Aggr := Expression (First\n-                         (Pragma_Argument_Associations (Prag)));\n+               Aggr :=\n+                 Expression (First (Pragma_Argument_Associations (Prag)));\n \n                Post_Case := First (Component_Associations (Aggr));\n                while Present (Post_Case) loop\n@@ -11885,6 +11882,12 @@ package body Sem_Ch6 is\n          Map : Elist_Id;\n          CP  : Node_Id;\n \n+         Ename : Name_Id;\n+         --  Effective name of pragma (maybe Pre/Post rather than Precondition/\n+         --  Postcodition if the pragma came from a Pre/Post aspect). We need\n+         --  the name right when we generate the Check pragma, since we want\n+         --  the right set of check policies to apply.\n+\n       begin\n          --  Prepare map if this is the case where we have to map entities of\n          --  arguments in the overridden subprogram to corresponding entities\n@@ -11936,11 +11939,19 @@ package body Sem_Ch6 is\n             return CP;\n          end if;\n \n+         --  Get effective name of aspect\n+\n+         if Present (Corresponding_Aspect (Prag)) then\n+            Ename := Chars (Identifier (Corresponding_Aspect (Prag)));\n+         else\n+            Ename := Nam;\n+         end if;\n+\n          --  Change copy of pragma into corresponding pragma Check\n \n          Prepend_To (Pragma_Argument_Associations (CP),\n            Make_Pragma_Argument_Association (Sloc (Prag),\n-             Expression => Make_Identifier (Loc, Nam)));\n+             Expression => Make_Identifier (Loc, Ename)));\n          Set_Pragma_Identifier (CP, Make_Identifier (Sloc (Prag), Name_Check));\n \n          --  If this is inherited case and the current message starts with\n@@ -12249,11 +12260,12 @@ package body Sem_Ch6 is\n          Prag := First (Declarations (N));\n          while Present (Prag) loop\n             if Nkind (Prag) = N_Pragma then\n+               Check_Applicable_Policy (Prag);\n \n                --  If pragma, capture if postconditions enabled, else ignore\n \n                if Pragma_Name (Prag) = Name_Postcondition\n-                 and then Check_Enabled (Name_Postcondition)\n+                 and then not Is_Ignored (Prag)\n                then\n                   if Plist = No_List then\n                      Plist := Empty_List;"}, {"sha": "af5c1280da1da89d4e0aea1529a9c13832f8b223", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 423, "deletions": 91, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -181,11 +181,24 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n+   function Is_Valid_Assertion_Kind (Nam : Name_Id) return Boolean;\n+   --  Returns True if Nam is one of the names recognized as a valid assertion\n+   --  kind by the Assertion_Policy pragma. Note that the 'Class cases are\n+   --  represented by the corresponding special names Name_uPre, Name_uPost,\n+   --  Name_uInviarnat, and Name_uType_Invariant (_Pre, _Post, _Invariant,\n+   --  and _Type_Invariant).\n+\n    procedure Preanalyze_CTC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n    --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n    --  of a Contract_Case or Test_Case pragma if present (possibly Empty). We\n    --  treat these as spec expressions (i.e. similar to a default expression).\n \n+   procedure Rewrite_Assertion_Kind (N : Node_Id);\n+   --  If N is Pre'Class, Post'Class, Invariant'Class, or Type_Invariant'Class,\n+   --  then it is rewritten as an identifier with the corresponding special\n+   --  name _Pre, _Post, _Invariant, or _Type_Invariant. Used by pragmas\n+   --  Check, Check_Policy.\n+\n    procedure rv;\n    --  This is a dummy function called by the processing for pragma Reviewable.\n    --  It is there for assisting front end debugging. By placing a Reviewable\n@@ -294,7 +307,8 @@ package body Sem_Prag is\n       --  expressions (i.e. similar to a default expression).\n \n       if Pragma_Name (N) = Name_Test_Case\n-        or else Pragma_Name (N) = Name_Contract_Case\n+           or else\n+         Pragma_Name (N) = Name_Contract_Case\n       then\n          Preanalyze_CTC_Args\n            (N,\n@@ -308,9 +322,7 @@ package body Sem_Prag is\n          --  In ASIS mode, for a pragma generated from a source aspect, also\n          --  analyze the original aspect expression.\n \n-         if ASIS_Mode\n-           and then Present (Corresponding_Aspect (N))\n-         then\n+         if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n             Analyze_Contract_Cases (Expression (Corresponding_Aspect (N)));\n          end if;\n       end if;\n@@ -1212,6 +1224,7 @@ package body Sem_Prag is\n                OK   : Boolean;\n                Ent  : constant Entity_Id := Entity (Argx);\n                Scop : constant Entity_Id := Scope (Ent);\n+\n             begin\n                --  Case of a pragma applied to a compilation unit: pragma must\n                --  occur immediately after the program unit in the compilation.\n@@ -6768,6 +6781,12 @@ package body Sem_Prag is\n          Pname := Chars (Identifier (Corresponding_Aspect (N)));\n       end if;\n \n+      Check_Applicable_Policy (N);\n+\n+      if Is_Disabled (N) then\n+         raise Pragma_Exit;\n+      end if;\n+\n       --  Preset arguments\n \n       Arg_Count := 0;\n@@ -7446,41 +7465,174 @@ package body Sem_Prag is\n          -- Assertion_Policy --\n          ----------------------\n \n-         --  pragma Assertion_Policy (Check | Disable | Ignore)\n+         --  pragma Assertion_Policy (POLICY_IDENTIFIER);\n+\n+         --  The following form is Ada 2012 only, but we allow it in all modes\n+\n+         --  Pragma Assertion_Policy (\n+         --      ASSERTION_KIND => POLICY_IDENTIFIER\n+         --   {, ASSERTION_KIND => POLICY_IDENTIFIER});\n+\n+         --  ASSERTION_KIND ::= RM_ASSERTION_KIND | ID_ASSERTION_KIND\n+\n+         --  RM_ASSERTION_KIND ::= Assert               |\n+         --                        Static_Predicate     |\n+         --                        Dynamic_Predicate    |\n+         --                        Pre                  |\n+         --                        Pre'Class            |\n+         --                        Post                 |\n+         --                        Post'Class           |\n+         --                        Type_Invariant       |\n+         --                        Type_Invariant'Class\n+\n+         --  ID_ASSERTION_KIND ::= Assert_And_Cut       }\n+         --                        Assume               |\n+         --                        Contract_Cases       |\n+         --                        Debug                |\n+         --                        Loop_Invariant       |\n+         --                        Loop_Variant         |\n+         --                        Postcondition        |\n+         --                        Precondition         |\n+         --                        Predicate\n+         --\n+         --  Note: The RM_ASSERTION_KIND list is language-defined, and the\n+         --  ID_ASSERTION_KIND list contains implementation-defined additions\n+         --  recognized by GNAT. The effect is to control the behavior of\n+         --  identically named aspects and pragmas, depending on the specified\n+         --  policy identifier:\n+\n+         --  POLICY_IDENTIFIER ::= Check | Disable | Ignore\n+\n+         --  Note: Check and Ignore are language-defined. Disable is a GNAT\n+         --  implementation defined addition that results in totally ignoring\n+         --  the corresponding assertion. If Disable is specified, then the\n+         --  argument of the assertion is not even analyzed. This is useful\n+         --  when the aspect/pragma argument references entities in a with'ed\n+         --  packaqe that is replaced by a dummy package in the final build.\n+\n+         --  Note: the attribute forms Pre'Class, Post'Class, Invariant'Class,\n+         --  and Type_Invariant'Class were recognized by the parser and\n+         --  transformed into referencea to the special internal identifiers\n+         --  _Pre, _Post, _Invariant, and _Type_Invariant, so no special\n+         --  processing is required here.\n \n          when Pragma_Assertion_Policy => Assertion_Policy : declare\n+            LocP   : Source_Ptr;\n             Policy : Node_Id;\n+            Arg    : Node_Id;\n+            Kind   : Name_Id;\n+            Prag   : Node_Id;\n \n          begin\n             Ada_2005_Pragma;\n-            Check_Valid_Configuration_Pragma;\n-            Check_Arg_Count (1);\n-            Check_No_Identifiers;\n-            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Disable, Name_Ignore);\n \n-            --  We treat pragma Assertion_Policy as equivalent to:\n+            --  This can always appear as a configuration pragma\n \n-            --    pragma Check_Policy (Assertion, policy)\n+            if Is_Configuration_Pragma then\n+               null;\n \n-            --  So rewrite the pragma in that manner and link on to the chain\n-            --  of Check_Policy pragmas, marking the pragma as analyzed.\n+            --  It can also appear in a declaration or package spec in Ada\n+            --  2012 mode. We allow this in other modes, but in that case\n+            --  we consider that we have an Ada 2012 pragma on our hands.\n \n-            Policy := Get_Pragma_Arg (Arg1);\n+            else\n+               Check_Is_In_Decl_Part_Or_Package_Spec;\n+               Ada_2012_Pragma;\n+            end if;\n \n-            Rewrite (N,\n-              Make_Pragma (Loc,\n-                Chars                        => Name_Check_Policy,\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Make_Identifier (Loc, Name_Assertion)),\n+            --  One argument case with no identifier (first form above)\n \n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression =>\n-                      Make_Identifier (Sloc (Policy), Chars (Policy))))));\n+            if Arg_Count = 1\n+              and then (Nkind (Arg1) /= N_Pragma_Argument_Association\n+                         or else Chars (Arg1) = No_Name)\n+            then\n+               Check_Arg_Is_One_Of\n+                 (Arg1, Name_Check, Name_Disable, Name_Ignore);\n \n-            Set_Analyzed (N);\n-            Set_Next_Pragma (N, Opt.Check_Policy_List);\n-            Opt.Check_Policy_List := N;\n+               --  Treat one argument Assertion_Policy as equivalent to:\n+\n+               --    pragma Check_Policy (Assertion, policy)\n+\n+               --  So rewrite pragma in that manner and link on to the chain\n+               --  of Check_Policy pragmas, marking the pragma as analyzed.\n+\n+               Policy := Get_Pragma_Arg (Arg1);\n+\n+               Rewrite (N,\n+                 Make_Pragma (Loc,\n+                   Chars                        => Name_Check_Policy,\n+                   Pragma_Argument_Associations => New_List (\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression => Make_Identifier (Loc, Name_Assertion)),\n+\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression =>\n+                         Make_Identifier (Sloc (Policy), Chars (Policy))))));\n+\n+               Set_Analyzed (N);\n+               Set_Next_Pragma (N, Opt.Check_Policy_List);\n+               Opt.Check_Policy_List := N;\n+\n+            --  Here if we have two or more arguments\n+\n+            else\n+               Check_At_Least_N_Arguments (1);\n+               Ada_2012_Pragma;\n+\n+               --  Loop through arguments\n+\n+               Arg := Arg1;\n+               while Present (Arg) loop\n+                  LocP := Sloc (Arg);\n+\n+                  --  Kind must be specified\n+\n+                  if Nkind (Arg) /= N_Pragma_Argument_Association\n+                    or else Chars (Arg) = No_Name\n+                  then\n+                     Error_Pragma_Arg\n+                       (\"missing assertion kind for pragma%\", Arg);\n+                  end if;\n+\n+                  --  Check Kind and Policy have allowed forms\n+\n+                  Kind := Chars (Arg);\n+\n+                  if not Is_Valid_Assertion_Kind (Kind) then\n+                     Error_Pragma_Arg\n+                       (\"invalid assertion kind for pragma%\", Arg);\n+                  end if;\n+\n+                  Check_Arg_Is_One_Of\n+                    (Arg, Name_Check, Name_Disable, Name_Ignore);\n+\n+                  --  We rewrite the Assertion_Policy pragma as a series of\n+                  --  Check_Policy pragmas:\n+\n+                  --    Check_Policy (Kind, Policy);\n+\n+                  Prag :=\n+                    Make_Pragma (LocP,\n+                      Chars                        => Name_Check_Policy,\n+                      Pragma_Argument_Associations => New_List (\n+                         Make_Pragma_Argument_Association (LocP,\n+                           Expression => Make_Identifier (LocP, Kind)),\n+                         Make_Pragma_Argument_Association (LocP,\n+                           Expression => Get_Pragma_Arg (Arg))));\n+\n+                  Set_Analyzed (Prag);\n+                  Set_Next_Pragma (Prag, Opt.Check_Policy_List);\n+                  Opt.Check_Policy_List := Prag;\n+                  Insert_Action (N, Prag);\n+\n+                  Arg := Next (Arg);\n+               end loop;\n+\n+               --  Rewrite the Assertion_Policy pragma as null since we have\n+               --  now inserted all the equivalent Check pragmas.\n+\n+               Rewrite (N, Make_Null_Statement (Loc));\n+            end if;\n          end Assertion_Policy;\n \n          ------------\n@@ -7930,10 +8082,16 @@ package body Sem_Prag is\n          -- Check --\n          -----------\n \n-         --  pragma Check ([Name    =>] IDENTIFIER,\n+         --  pragma Check ([Name    =>] CHECK_KIND,\n          --                [Check   =>] Boolean_EXPRESSION\n          --              [,[Message =>] String_EXPRESSION]);\n \n+         --  CHECK_KIND ::= IDENTIFIER           |\n+         --                 Pre'Class            |\n+         --                 Post'Class           |\n+         --                 Invariant'Class      |\n+         --                 Type_Invariant'Class\n+\n          when Pragma_Check => Check : declare\n             Expr  : Node_Id;\n             Eloc  : Source_Ptr;\n@@ -7955,6 +8113,7 @@ package body Sem_Prag is\n                Str := Get_Pragma_Arg (Arg3);\n             end if;\n \n+            Rewrite_Assertion_Kind (Get_Pragma_Arg (Arg1));\n             Check_Arg_Is_Identifier (Arg1);\n             Cname := Chars (Get_Pragma_Arg (Arg1));\n             Check_On := Check_Enabled (Cname);\n@@ -8094,19 +8253,21 @@ package body Sem_Prag is\n          -- Check_Policy --\n          ------------------\n \n-         --  pragma Check_Policy (\n-         --    [Name   =>] IDENTIFIER,\n-         --    [Policy =>] POLICY_IDENTIFIER);\n+         --  pragma Check_Policy ([Name   =>] CHECK_KIND\n+         --                       [Policy =>] POLICY_IDENTIFIER);\n \n-         --  POLICY_IDENTIFIER ::= ON | OFF | CHECK | DISABLE | IGNORE\n+         --  POLICY_IDENTIFIER ::= On | Off | Check | Disable | Ignore\n \n-         --  Note: this is a configuration pragma, but it is allowed to appear\n-         --  anywhere else.\n+         --  CHECK_KIND ::= IDENTIFIER |\n+         --                 Pre'Class | Post'Class | Identifier'Class\n \n-         when Pragma_Check_Policy =>\n+         when Pragma_Check_Policy => Check_Policy :\n+         begin\n             GNAT_Pragma;\n             Check_Arg_Count (2);\n             Check_Optional_Identifier (Arg1, Name_Name);\n+            Rewrite_Assertion_Kind (Get_Pragma_Arg (Arg1));\n+            Check_Arg_Is_Identifier (Arg1);\n             Check_Optional_Identifier (Arg2, Name_Policy);\n             Check_Arg_Is_One_Of\n               (Arg2, Name_On, Name_Off, Name_Check, Name_Disable, Name_Ignore);\n@@ -8122,6 +8283,7 @@ package body Sem_Prag is\n \n             Set_Next_Pragma (N, Opt.Check_Policy_List);\n             Opt.Check_Policy_List := N;\n+         end Check_Policy;\n \n          ---------------------\n          -- CIL_Constructor --\n@@ -8438,9 +8600,9 @@ package body Sem_Prag is\n             S14_Pragma;\n             Check_Arg_Count (1);\n \n-            --  Completely ignore if disabled\n+            --  Completely ignore if not enabled\n \n-            if not Check_Enabled (Pname) then\n+            if Is_Ignored (N) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -8873,20 +9035,16 @@ package body Sem_Prag is\n          begin\n             GNAT_Pragma;\n \n-            --  Skip analysis if disabled\n-\n-            if Debug_Pragmas_Disabled then\n-               Rewrite (N, Make_Null_Statement (Loc));\n-               Analyze (N);\n-               return;\n-            end if;\n+            --  The condition for executing the call is that the expander\n+            --  is active and that we are not ignoring this debug pragma.\n \n             Cond :=\n               New_Occurrence_Of\n-                (Boolean_Literals (Debug_Pragmas_Enabled and Expander_Active),\n+                (Boolean_Literals\n+                  (Expander_Active and then not Is_Ignored (N)),\n                  Loc);\n \n-            if Debug_Pragmas_Enabled then\n+            if not Is_Ignored (N) then\n                Set_SCO_Pragma_Enabled (Loc);\n             end if;\n \n@@ -8965,16 +9123,29 @@ package body Sem_Prag is\n          -- Debug_Policy --\n          ------------------\n \n-         --  pragma Debug_Policy (Check | Ignore)\n+         --  pragma Debug_Policy (On | Off | Check | Disable | Ignore)\n \n          when Pragma_Debug_Policy =>\n             GNAT_Pragma;\n             Check_Arg_Count (1);\n-            Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Disable, Name_Ignore);\n-            Debug_Pragmas_Enabled :=\n-              Chars (Get_Pragma_Arg (Arg1)) = Name_Check;\n-            Debug_Pragmas_Disabled :=\n-              Chars (Get_Pragma_Arg (Arg1)) = Name_Disable;\n+            Check_No_Identifiers;\n+            Check_Arg_Is_Identifier (Arg1);\n+\n+            --  Exactly equivalent to pragma Check_Policy (Debug, arg), so\n+            --  rewrite it that way, and let the rest of the checking come\n+            --  from analyzing the rewritten pragma.\n+\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars                        => Name_Check_Policy,\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Make_Identifier (Loc, Name_Debug)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression => Get_Pragma_Arg (Arg1)))));\n+\n+            Analyze (N);\n \n          -------------\n          -- Depends --\n@@ -12778,10 +12949,10 @@ package body Sem_Prag is\n             end if;\n \n             --  Note that the type has at least one invariant, and also that\n-            --  it has inheritable invariants if we have Invariant'Class.\n-            --  Build the corresponding invariant procedure declaration, so\n-            --  that calls to it can be generated before the body is built\n-            --  (for example wihin an expression function).\n+            --  it has inheritable invariants if we have Invariant'Class\n+            --  or Type_Invariant'Class. Build the corresponding invariant\n+            --  procedure declaration, so that calls to it can be generated\n+            --  before the body is built (e.g. within an expression function).\n \n             PDecl := Build_Invariant_Procedure_Declaration (Typ);\n             Insert_After (N, PDecl);\n@@ -13591,9 +13762,9 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n             Check_Loop_Pragma_Placement;\n \n-            --  Completely ignore if disabled\n+            --  Completely ignore if not enabled\n \n-            if not Check_Enabled (Pname) then\n+            if Is_Ignored (N) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -13662,9 +13833,9 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (1);\n             Check_Loop_Pragma_Placement;\n \n-            --  Completely ignore if disabled\n+            --  Completely ignore if not enabled\n \n-            if not Check_Enabled (Pname) then\n+            if Is_Ignored (N) then\n                Rewrite (N, Make_Null_Statement (Loc));\n                Analyze (N);\n                return;\n@@ -14762,7 +14933,7 @@ package body Sem_Prag is\n \n             Check_Precondition_Postcondition (In_Body);\n \n-            --  When the pragma is a source contruct and appears inside a body,\n+            --  When the pragma is a source construct appearing inside a body,\n             --  preanalyze the boolean_expression to detect illegal forward\n             --  references:\n \n@@ -14793,18 +14964,28 @@ package body Sem_Prag is\n             Check_Precondition_Postcondition (In_Body);\n \n             --  If in spec, nothing more to do. If in body, then we convert the\n-            --  pragma to pragma Check (Precondition, cond [, msg]). Note we do\n-            --  this whether or not precondition checks are enabled. That works\n-            --  fine since pragma Check will do this check, and will also\n-            --  analyze the condition itself in the proper context.\n+            --  pragma to an equivalent pragam Check. Note we do this whether\n+            --  or not precondition checks are enabled. That works fine since\n+            --  pragma Check will do this check, and will also analyze the\n+            --  condition itself in the proper context.\n+\n+            --  The form of the pragma Check is either:\n+\n+            --    pragma Check (Precondition, cond [, msg])\n+            --       or\n+            --    pragma Check (Pre, cond [, msg])\n+\n+            --  We use the Pre form if this pragma derived from a Pre aspect.\n+            --  This is needed to make sure that the right set of Policy\n+            --  pragmas are checked.\n \n             if In_Body then\n                Rewrite (N,\n                  Make_Pragma (Loc,\n                    Chars                        => Name_Check,\n                    Pragma_Argument_Associations => New_List (\n                      Make_Pragma_Argument_Association (Loc,\n-                       Expression => Make_Identifier (Loc, Name_Precondition)),\n+                       Expression => Make_Identifier (Loc, Pname)),\n \n                      Make_Pragma_Argument_Association (Sloc (Arg1),\n                        Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n@@ -17591,39 +17772,123 @@ package body Sem_Prag is\n       --  Loop through entries in check policy list\n \n       PP := Opt.Check_Policy_List;\n-      loop\n-         --  If there are no specific entries that matched, then we let the\n-         --  setting of assertions govern. Note that this provides the needed\n-         --  compatibility with the RM for the cases of assertion, invariant,\n-         --  precondition, predicate, and postcondition.\n+      while Present (PP) loop\n+         declare\n+            PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+            Pnm : constant Name_Id := Chars (Get_Pragma_Arg (First (PPA)));\n \n-         if No (PP) then\n-            return Assertions_Enabled;\n+         begin\n+            if Nam = Pnm\n+              or else (Is_Valid_Assertion_Kind (Nam)\n+                        and then Pnm = Name_Assertion)\n+            then\n+               case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n+                  when Name_On | Name_Check =>\n+                     return True;\n+                  when Name_Off | Name_Disable | Name_Ignore =>\n+                     return False;\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n \n-         --  Here we have an entry see if it matches\n+            else\n+               PP := Next_Pragma (PP);\n+            end if;\n+         end;\n+      end loop;\n \n-         else\n-            declare\n-               PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+      --  If there are no specific entries that matched, then we let the\n+      --  setting of assertions govern. Note that this provides the needed\n+      --  compatibility with the RM for the cases of assertion, invariant,\n+      --  precondition, predicate, and postcondition.\n \n-            begin\n-               if Nam = Chars (Get_Pragma_Arg (First (PPA))) then\n-                  case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n-                     when Name_On | Name_Check =>\n-                        return True;\n-                     when Name_Off | Name_Disable | Name_Ignore =>\n-                        return False;\n-                     when others =>\n-                        raise Program_Error;\n-                  end case;\n+      return Assertions_Enabled;\n+   end Check_Enabled;\n \n-               else\n-                  PP := Next_Pragma (PP);\n-               end if;\n-            end;\n+   -----------------------------\n+   -- Check_Applicable_Policy --\n+   -----------------------------\n+\n+   procedure Check_Applicable_Policy (N : Node_Id) is\n+      PP     : Node_Id;\n+      Policy : Name_Id;\n+\n+      Ename : Name_Id;\n+      --  Effective name of aspect or pragma, this is simply the name of\n+      --  the aspect or pragma, except in the case of a pragma derived from\n+      --  an aspect, in which case it is the name of the aspect (which may be\n+      --  different, e.g. Pre aspect generating Precondition pragma). It also\n+      --  deals with the 'Class cases for an aspect.\n+\n+   begin\n+      if Nkind (N) = N_Pragma then\n+         if Present (Corresponding_Aspect (N)) then\n+            Ename := Chars (Identifier (Corresponding_Aspect (N)));\n+         else\n+            Ename := Chars (Pragma_Identifier (N));\n+         end if;\n+\n+      else\n+         pragma Assert (Nkind (N) = N_Aspect_Specification);\n+         Ename := Chars (Identifier (N));\n+\n+         if Class_Present (N) then\n+            case Ename is\n+               when Name_Invariant      => Ename := Name_uInvariant;\n+               when Name_Pre            => Ename := Name_uPre;\n+               when Name_Post           => Ename := Name_uPost;\n+               when Name_Type_Invariant => Ename := Name_uType_Invariant;\n+               when others           => raise Program_Error;\n+            end case;\n          end if;\n+      end if;\n+\n+      --  No effect if not valid assertion kind name\n+\n+      if not Is_Valid_Assertion_Kind (Ename) then\n+         return;\n+      end if;\n+\n+      --  Loop through entries in check policy list\n+\n+      PP := Opt.Check_Policy_List;\n+      while Present (PP) loop\n+         declare\n+            PPA : constant List_Id := Pragma_Argument_Associations (PP);\n+            Pnm : constant Name_Id := Chars (Get_Pragma_Arg (First (PPA)));\n+\n+         begin\n+            if Ename = Pnm or else Pnm = Name_Assertion then\n+               Policy := Chars (Get_Pragma_Arg (Last (PPA)));\n+\n+               case Policy is\n+                  when Name_Off | Name_Ignore =>\n+                     Set_Is_Ignored (N, True);\n+\n+                  when Name_Disable =>\n+                     Set_Is_Ignored (N, True);\n+                     Set_Is_Disabled (N, True);\n+\n+                  when others =>\n+                     null;\n+               end case;\n+\n+               return;\n+            end if;\n+\n+            PP := Next_Pragma (PP);\n+         end;\n       end loop;\n-   end Check_Enabled;\n+\n+      --  If there are no specific entries that matched, then we let the\n+      --  setting of assertions govern. Note that this provides the needed\n+      --  compatibility with the RM for the cases of assertion, invariant,\n+      --  precondition, predicate, and postcondition.\n+\n+      if not Assertions_Enabled then\n+         Set_Is_Ignored (N);\n+      end if;\n+   end Check_Applicable_Policy;\n \n    ---------------------------------\n    -- Delay_Config_Pragma_Analyze --\n@@ -18076,6 +18341,44 @@ package body Sem_Prag is\n       end if;\n    end Is_Pragma_String_Literal;\n \n+   -----------------------------\n+   -- Is_Valid_Assertion_Kind --\n+   -----------------------------\n+\n+   function Is_Valid_Assertion_Kind (Nam : Name_Id) return Boolean is\n+   begin\n+      case Nam is\n+         when\n+            --  RM defined\n+\n+            Name_Assert            |\n+            Name_Static_Predicate  |\n+            Name_Dynamic_Predicate |\n+            Name_Pre               |\n+            Name_uPre              |\n+            Name_Post              |\n+            Name_uPost             |\n+            Name_Type_Invariant    |\n+            Name_uType_Invariant   |\n+\n+            --  Impl defined\n+\n+            Name_Assert_And_Cut    |\n+            Name_Assume            |\n+            Name_Contract_Cases    |\n+            Name_Debug             |\n+            Name_Invariant         |\n+            Name_uInvariant        |\n+            Name_Loop_Invariant    |\n+            Name_Loop_Variant      |\n+            Name_Postcondition     |\n+            Name_Precondition      |\n+            Name_Predicate         => return True;\n+\n+         when others               => return False;\n+      end case;\n+   end Is_Valid_Assertion_Kind;\n+\n    -----------------------------------------\n    -- Make_Aspect_For_PPC_In_Gen_Sub_Decl --\n    -----------------------------------------\n@@ -18215,6 +18518,35 @@ package body Sem_Prag is\n \n    end Process_Compilation_Unit_Pragmas;\n \n+   ----------------------------\n+   -- Rewrite_Assertion_Kind --\n+   ----------------------------\n+\n+   procedure Rewrite_Assertion_Kind (N : Node_Id) is\n+      Nam : Name_Id;\n+\n+   begin\n+      if Nkind (N) = N_Attribute_Reference\n+        and then Attribute_Name (N) = Name_Class\n+        and then Nkind (Prefix (N)) = N_Identifier\n+      then\n+         case Chars (Prefix (N)) is\n+            when Name_Pre =>\n+               Nam := Name_uPre;\n+            when Name_Post =>\n+               Nam := Name_uPost;\n+            when Name_Type_Invariant =>\n+               Nam := Name_uType_Invariant;\n+            when Name_Invariant =>\n+               Nam := Name_uInvariant;\n+            when others =>\n+               return;\n+         end case;\n+\n+         Rewrite (N, Make_Identifier (Sloc (N), Chars => Nam));\n+      end if;\n+   end Rewrite_Assertion_Kind;\n+\n    --------\n    -- rv --\n    --------"}, {"sha": "f1e06b3fecfcd774b3c41dd13e6c68d7fef214cc", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -56,13 +56,45 @@ package Sem_Prag is\n \n    function Check_Enabled (Nam : Name_Id) return Boolean;\n    --  This function is used in connection with pragmas Assertion, Check,\n-   --  Precondition, and Postcondition, to determine if Check pragmas (or\n-   --  corresponding Assert, Precondition, or Postcondition pragmas) are\n-   --  currently active, as determined by the presence of -gnata on the\n-   --  command line (which sets the default), and the appearance of pragmas\n-   --  Check_Policy and Assertion_Policy as configuration pragmas either in\n-   --  a configuration pragma file, or at the start of the current unit.\n+   --  and assertion aspects and pragmas, to determine if Check pragmas\n+   --  (or corresponding assertion aspects or pragmas) are currently active\n+   --  as determined by the presence of -gnata on the command line (which\n+   --  sets the default), and the appearance of pragmas Check_Policy and\n+   --  Assertion_Policy as configuration pragmas either in a configuration\n+   --  pragma file, or at the start of the current unit, or locally given\n+   --  Check_Policy and Assertion_Policy pragmas that are currently active.\n    --  True is returned if the specified check is enabled.\n+   --\n+   --  This function knows about all relevant synonyms (e.g. Precondition or\n+   --  Pre can be used to refer to the Pre aspect or Precondition pragma, and\n+   --  Predicate refers to both static and dynamic predicates, and Assertion\n+   --  applies to all assertion aspects and pragmas).\n+   --\n+   --  Note: for assertion kinds Pre'Class, Post'Class, Type_Invariant'Class,\n+   --  the name passed is Name_uPre, Name_uPost, Name_uType_Invariant, which\n+   --  corresponds to _Pre, _Post, _Type_Invariant, which are special names\n+   --  used in identifiers to represent these attribute references.\n+\n+   procedure Check_Applicable_Policy (N : Node_Id);\n+   --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n+   --  the name of the aspect or pragma is not one of those recognized as a\n+   --  assertion kind by an Assertion_Kind pragma, then the call has no effect.\n+   --  Note that in the case of a pragma derived from an aspect, the name\n+   --  we use for the purpose of this procedure is the aspect name, which may\n+   --  be different from the pragma name (e.g. Precondition for Pre aspect).\n+   --  In addition, 'Class aspects are recognized (and the corresponding\n+   --  special names used in the processing.\n+   --\n+   --  If the name is valid assertion_Kind name, then the Check_Policy pragma\n+   --  chain is checked for a matching entry (or for an Assertion entry which\n+   --  matches all possibilities). If a matching entry is found then the policy\n+   --  is checked. If it is Off, Ignore, or Disable, then the Is_Ignored flag\n+   --  is set in the aspect or pragma node. Additionally for policy Disable,\n+   --  the Is_Disabled flag is set.\n+   --\n+   --  If no matching Check_Policy pragma is found then the effect depends on\n+   --  whether -gnata was used, if so, then the call has no effect, otherwise\n+   --  Is_Ignored (but not Is_Disabled) is set True.\n \n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;\n    --  N is a pragma appearing in a configuration pragma file. Most such"}, {"sha": "dc7d973867f51ef7f5821a55a545fd6788d6f14b", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1740,6 +1740,15 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Controlling_Actual;\n \n+   function Is_Disabled\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag15 (N);\n+   end Is_Disabled;\n+\n    function Is_Delayed_Aspect\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1798,6 +1807,15 @@ package body Sinfo is\n       return Flag4 (N);\n    end Is_Folded_In_Parser;\n \n+   function Is_Ignored\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag9 (N);\n+   end Is_Ignored;\n+\n    function Is_In_Discriminant_Check\n       (N : Node_Id) return Boolean is\n    begin\n@@ -4832,6 +4850,15 @@ package body Sinfo is\n       Set_Flag14 (N, Val);\n    end Set_Is_Delayed_Aspect;\n \n+   procedure Set_Is_Disabled\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag15 (N, Val);\n+   end Set_Is_Disabled;\n+\n    procedure Set_Is_Dynamic_Coextension\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4880,6 +4907,15 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_Is_Folded_In_Parser;\n \n+   procedure Set_Is_Ignored\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Aspect_Specification\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag9 (N, Val);\n+   end Set_Is_Ignored;\n+\n    procedure Set_Is_In_Discriminant_Check\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "49188c7d3ad25684ca9a95989b8552477ba965da", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 87, "deletions": 24, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -1286,6 +1286,14 @@ package Sinfo is\n    --    a dispatching call. It is off in all other cases. See Sem_Disp for\n    --    details of its use.\n \n+   --  Is_Disabled (Flag15-Sem)\n+   --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n+   --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n+   --    a Debug_Policy pragma that resulted in totally disabling the flagged\n+   --    aspect or policy as a result of using the GNAT-defined policy DISABLE.\n+   --    If this flag is set, the aspect or policy is not analyzed for semantic\n+   --    correctness, so any expressions etc will not be marked as analyzed.\n+\n    --  Is_Dynamic_Coextension (Flag18-Sem)\n    --    Present in allocator nodes, to indicate that this is an allocator\n    --    for an access discriminant of a dynamically allocated object. The\n@@ -1308,6 +1316,20 @@ package Sinfo is\n    --    objects. The wrapper prevents interference between exception handlers\n    --    and At_End handlers.\n \n+   --  Is_Ignored (Flag9-Sem)\n+   --    A flag set in an N_Aspect_Specification or N_Pragma node if there was\n+   --    a Check_Policy or Assertion_Policy (or in the case of a Debug_Pragma)\n+   --    a Debug_Policy pragma that specified a policy of IGNORE, DISABLE, or\n+   --    OFF, for the pragma/aspect. If there was a Policy pragma specifying\n+   --    a Policy of ON or CHECK, then this flag is reset. If no Policy pragma\n+   --    gives a policy for the aspect or pragma, then there are two cases. For\n+   --    an assertion aspect or pragma (one of the assertion kinds allowed in\n+   --    an Assertion_Policy pragma), then Is_Ignored is set if assertions are\n+   --    ignored because of the use of a -gnata switch. For any other aspects\n+   --    or pragmas, the flag is off. If this flag is set, the aspect/pragma\n+   --    is fully analyzed and checked for other syntactic/semantic errors,\n+   --    but it does not have any semantic effect.\n+\n    --  Is_In_Discriminant_Check (Flag11-Sem)\n    --    This flag is present in a selected component, and is used to indicate\n    --    that the reference occurs within a discriminant check. The\n@@ -2085,11 +2107,13 @@ package Sinfo is\n       --  Corresponding_Aspect (Node3-Sem) (set to Empty if not present)\n       --  Pragma_Identifier (Node4)\n       --  Next_Rep_Item (Node5-Sem)\n+      --  Class_Present (Flag6) set if from Aspect with 'Class\n       --  From_Aspect_Specification (Flag13-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n+      --  Is_Disabled (Flag15-Sem)\n+      --  Is_Ignored (Flag9-Sem)\n       --  Import_Interface_Present (Flag16-Sem)\n       --  Split_PPC (Flag17) set if corresponding aspect had Split_PPC set\n-      --  Class_Present (Flag6) set if from Aspect with 'Class\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma\n@@ -2112,6 +2136,27 @@ package Sinfo is\n       --    [pragma_argument_IDENTIFIER =>] NAME\n       --  | [pragma_argument_IDENTIFIER =>] EXPRESSION\n \n+      --  In Ada 2012, there are two more possibilities:\n+\n+      --  PRAGMA_ARGUMENT_ASSOCIATION ::=\n+      --    [pragma_argument_ASPECT_MARK =>] NAME\n+      --  | [pragma_argument_ASPECT_MARK =>] EXPRESSION\n+\n+      --  where the interesting allowed cases (which do not fit the syntax of\n+      --  the first alternative above) are\n+\n+      --  ASPECT_MARK => Pre'Class | Post'Class | Type_Invariant'Class\n+\n+      --  We allow this special usage in all Ada modes, but it would be a\n+      --  pain to allow these aspects to pervade the pragma syntax, and the\n+      --  representation of pragma nodes internally. So what we do is to\n+      --  replace these ASPECT_MARK forms with identifiers whose name is one\n+      --  of the special internal names _Pre, _Post or _Type_Invariant.\n+\n+      --  We do a similar replacement of these Aspect_Mark forms in the\n+      --  Expression of a pragma argument association for the cases of\n+      --  the first arguments of any Check pragmas and Check_Policy pragmas\n+\n       --  N_Pragma_Argument_Association\n       --  Sloc points to first token in association\n       --  Chars (Name1) (set to No_Name if no pragma argument identifier)\n@@ -6712,6 +6757,8 @@ package Sinfo is\n       --  Split_PPC (Flag17) Set if split pre/post attribute\n       --  Is_Boolean_Aspect (Flag16-Sem)\n       --  Is_Delayed_Aspect (Flag14-Sem)\n+      --  Is_Disabled (Flag15-Sem)\n+      --  Is_Ignored (Flag9-Sem)\n \n       --  Note: Aspect_Specification is an Ada 2012 feature\n \n@@ -8667,6 +8714,9 @@ package Sinfo is\n    function Is_Delayed_Aspect\n      (N : Node_Id) return Boolean;    -- Flag14\n \n+   function Is_Disabled\n+     (N : Node_Id) return Boolean;    -- Flag15\n+\n    function Is_Dynamic_Coextension\n      (N : Node_Id) return Boolean;    -- Flag18\n \n@@ -8685,6 +8735,9 @@ package Sinfo is\n    function Is_Folded_In_Parser\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function Is_Ignored\n+     (N : Node_Id) return Boolean;    -- Flag9\n+\n    function Is_In_Discriminant_Check\n      (N : Node_Id) return Boolean;    -- Flag11\n \n@@ -9648,6 +9701,12 @@ package Sinfo is\n    procedure Set_Is_Delayed_Aspect\n      (N : Node_Id; Val : Boolean := True);    -- Flag14\n \n+   procedure Set_Is_Disabled\n+     (N : Node_Id; Val : Boolean := True);    -- Flag15\n+\n+   procedure Set_Is_Ignored\n+     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+\n    procedure Set_Is_Dynamic_Coextension\n      (N : Node_Id; Val : Boolean := True);    -- Flag18\n \n@@ -12020,12 +12079,14 @@ package Sinfo is\n    pragma Inline (Is_Component_Right_Opnd);\n    pragma Inline (Is_Controlling_Actual);\n    pragma Inline (Is_Delayed_Aspect);\n+   pragma Inline (Is_Disabled);\n    pragma Inline (Is_Dynamic_Coextension);\n    pragma Inline (Is_Elsif);\n    pragma Inline (Is_Entry_Barrier_Function);\n    pragma Inline (Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Is_Finalization_Wrapper);\n    pragma Inline (Is_Folded_In_Parser);\n+   pragma Inline (Is_Ignored);\n    pragma Inline (Is_In_Discriminant_Check);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n@@ -12186,20 +12247,20 @@ package Sinfo is\n    pragma Inline (Set_All_Present);\n    pragma Inline (Set_Alternatives);\n    pragma Inline (Set_Ancestor_Part);\n-   pragma Inline (Set_Atomic_Sync_Required);\n    pragma Inline (Set_Array_Aggregate);\n    pragma Inline (Set_Aspect_Rep_Item);\n    pragma Inline (Set_Assignment_OK);\n    pragma Inline (Set_Associated_Node);\n    pragma Inline (Set_At_End_Proc);\n+   pragma Inline (Set_Atomic_Sync_Required);\n    pragma Inline (Set_Attribute_Name);\n    pragma Inline (Set_Aux_Decls_Node);\n    pragma Inline (Set_Backwards_OK);\n    pragma Inline (Set_Bad_Is_Detected);\n-   pragma Inline (Set_Body_To_Inline);\n    pragma Inline (Set_Body_Required);\n-   pragma Inline (Set_By_Ref);\n+   pragma Inline (Set_Body_To_Inline);\n    pragma Inline (Set_Box_Present);\n+   pragma Inline (Set_By_Ref);\n    pragma Inline (Set_Char_Literal_Value);\n    pragma Inline (Set_Chars);\n    pragma Inline (Set_Check_Address_Alignment);\n@@ -12225,8 +12286,8 @@ package Sinfo is\n    pragma Inline (Set_Context_Items);\n    pragma Inline (Set_Context_Pending);\n    pragma Inline (Set_Controlling_Argument);\n-   pragma Inline (Set_Convert_To_Return_False);\n    pragma Inline (Set_Conversion_OK);\n+   pragma Inline (Set_Convert_To_Return_False);\n    pragma Inline (Set_Corresponding_Aspect);\n    pragma Inline (Set_Corresponding_Body);\n    pragma Inline (Set_Corresponding_Formal_Spec);\n@@ -12237,8 +12298,8 @@ package Sinfo is\n    pragma Inline (Set_Dcheck_Function);\n    pragma Inline (Set_Declarations);\n    pragma Inline (Set_Default_Expression);\n-   pragma Inline (Set_Default_Storage_Pool);\n    pragma Inline (Set_Default_Name);\n+   pragma Inline (Set_Default_Storage_Pool);\n    pragma Inline (Set_Defining_Identifier);\n    pragma Inline (Set_Defining_Unit_Name);\n    pragma Inline (Set_Delay_Alternative);\n@@ -12254,16 +12315,16 @@ package Sinfo is\n    pragma Inline (Set_Discriminant_Type);\n    pragma Inline (Set_Do_Accessibility_Check);\n    pragma Inline (Set_Do_Discriminant_Check);\n-   pragma Inline (Set_Do_Length_Check);\n    pragma Inline (Set_Do_Division_Check);\n+   pragma Inline (Set_Do_Length_Check);\n    pragma Inline (Set_Do_Overflow_Check);\n    pragma Inline (Set_Do_Range_Check);\n    pragma Inline (Set_Do_Storage_Check);\n    pragma Inline (Set_Do_Tag_Check);\n-   pragma Inline (Set_Elaborate_Present);\n    pragma Inline (Set_Elaborate_All_Desirable);\n    pragma Inline (Set_Elaborate_All_Present);\n    pragma Inline (Set_Elaborate_Desirable);\n+   pragma Inline (Set_Elaborate_Present);\n    pragma Inline (Set_Elaboration_Boolean);\n    pragma Inline (Set_Else_Actions);\n    pragma Inline (Set_Else_Statements);\n@@ -12310,13 +12371,14 @@ package Sinfo is\n    pragma Inline (Set_Has_Created_Identifier);\n    pragma Inline (Set_Has_Dereference_Action);\n    pragma Inline (Set_Has_Dynamic_Length_Check);\n+   pragma Inline (Set_Has_Dynamic_Range_Check);\n    pragma Inline (Set_Has_Init_Expression);\n    pragma Inline (Set_Has_Local_Raise);\n-   pragma Inline (Set_Has_Dynamic_Range_Check);\n    pragma Inline (Set_Has_No_Elaboration_Code);\n    pragma Inline (Set_Has_Pragma_Suppress_All);\n    pragma Inline (Set_Has_Private_View);\n    pragma Inline (Set_Has_Relative_Deadline_Pragma);\n+   pragma Inline (Set_Has_Self_Reference);\n    pragma Inline (Set_Has_Storage_Size_Pragma);\n    pragma Inline (Set_Has_Wide_Character);\n    pragma Inline (Set_Has_Wide_Wide_Character);\n@@ -12325,52 +12387,53 @@ package Sinfo is\n    pragma Inline (Set_High_Bound);\n    pragma Inline (Set_Identifier);\n    pragma Inline (Set_Implicit_With);\n-   pragma Inline (Set_Includes_Infinities);\n-   pragma Inline (Set_Interface_List);\n-   pragma Inline (Set_Interface_Present);\n    pragma Inline (Set_Import_Interface_Present);\n    pragma Inline (Set_In_Assertion_Expression);\n    pragma Inline (Set_In_Present);\n+   pragma Inline (Set_Includes_Infinities);\n    pragma Inline (Set_Inherited_Discriminant);\n    pragma Inline (Set_Instance_Spec);\n+   pragma Inline (Set_Interface_List);\n+   pragma Inline (Set_Interface_Present);\n    pragma Inline (Set_Intval);\n-   pragma Inline (Set_Iterator_Specification);\n    pragma Inline (Set_Is_Accessibility_Actual);\n    pragma Inline (Set_Is_Asynchronous_Call_Block);\n    pragma Inline (Set_Is_Boolean_Aspect);\n    pragma Inline (Set_Is_Component_Left_Opnd);\n    pragma Inline (Set_Is_Component_Right_Opnd);\n    pragma Inline (Set_Is_Controlling_Actual);\n    pragma Inline (Set_Is_Delayed_Aspect);\n+   pragma Inline (Set_Is_Disabled);\n    pragma Inline (Set_Is_Dynamic_Coextension);\n    pragma Inline (Set_Is_Elsif);\n    pragma Inline (Set_Is_Entry_Barrier_Function);\n    pragma Inline (Set_Is_Expanded_Build_In_Place_Call);\n    pragma Inline (Set_Is_Finalization_Wrapper);\n    pragma Inline (Set_Is_Folded_In_Parser);\n+   pragma Inline (Set_Is_Ignored);\n    pragma Inline (Set_Is_In_Discriminant_Check);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n    pragma Inline (Set_Is_Overloaded);\n    pragma Inline (Set_Is_Power_Of_2_For_Shift);\n    pragma Inline (Set_Is_Prefixed_Call);\n    pragma Inline (Set_Is_Protected_Subprogram_Body);\n-   pragma Inline (Set_Has_Self_Reference);\n    pragma Inline (Set_Is_Static_Coextension);\n    pragma Inline (Set_Is_Static_Expression);\n    pragma Inline (Set_Is_Subprogram_Descriptor);\n    pragma Inline (Set_Is_Task_Allocation_Block);\n    pragma Inline (Set_Is_Task_Master);\n    pragma Inline (Set_Iteration_Scheme);\n+   pragma Inline (Set_Iterator_Specification);\n    pragma Inline (Set_Itype);\n    pragma Inline (Set_Kill_Range_Check);\n+   pragma Inline (Set_Label_Construct);\n    pragma Inline (Set_Last_Bit);\n    pragma Inline (Set_Last_Name);\n-   pragma Inline (Set_Library_Unit);\n-   pragma Inline (Set_Label_Construct);\n    pragma Inline (Set_Left_Opnd);\n-   pragma Inline (Set_Limited_View_Installed);\n+   pragma Inline (Set_Library_Unit);\n    pragma Inline (Set_Limited_Present);\n+   pragma Inline (Set_Limited_View_Installed);\n    pragma Inline (Set_Literals);\n    pragma Inline (Set_Local_Raise_Not_OK);\n    pragma Inline (Set_Local_Raise_Statements);\n@@ -12398,9 +12461,9 @@ package Sinfo is\n    pragma Inline (Set_No_Initialization);\n    pragma Inline (Set_No_Minimize_Eliminate);\n    pragma Inline (Set_No_Truncation);\n-   pragma Inline (Set_Null_Present);\n    pragma Inline (Set_Null_Exclusion_Present);\n    pragma Inline (Set_Null_Exclusion_In_Return_Present);\n+   pragma Inline (Set_Null_Present);\n    pragma Inline (Set_Null_Record_Present);\n    pragma Inline (Set_Object_Definition);\n    pragma Inline (Set_Of_Present);\n@@ -12409,8 +12472,8 @@ package Sinfo is\n    pragma Inline (Set_Others_Discrete_Choices);\n    pragma Inline (Set_Out_Present);\n    pragma Inline (Set_Parameter_Associations);\n-   pragma Inline (Set_Parameter_Specifications);\n    pragma Inline (Set_Parameter_List_Truncated);\n+   pragma Inline (Set_Parameter_Specifications);\n    pragma Inline (Set_Parameter_Type);\n    pragma Inline (Set_Parent_Spec);\n    pragma Inline (Set_Position);\n@@ -12453,38 +12516,38 @@ package Sinfo is\n    pragma Inline (Set_Selector_Names);\n    pragma Inline (Set_Shift_Count_OK);\n    pragma Inline (Set_Source_Type);\n-   pragma Inline (Set_Spec_PPC_List);\n    pragma Inline (Set_Spec_CTC_List);\n+   pragma Inline (Set_Spec_PPC_List);\n    pragma Inline (Set_Specification);\n    pragma Inline (Set_Split_PPC);\n    pragma Inline (Set_Statements);\n    pragma Inline (Set_Storage_Pool);\n-   pragma Inline (Set_Subpool_Handle_Name);\n    pragma Inline (Set_Strval);\n+   pragma Inline (Set_Subpool_Handle_Name);\n    pragma Inline (Set_Subtype_Indication);\n    pragma Inline (Set_Subtype_Mark);\n    pragma Inline (Set_Subtype_Marks);\n    pragma Inline (Set_Suppress_Assignment_Checks);\n    pragma Inline (Set_Suppress_Loop_Warnings);\n    pragma Inline (Set_Synchronized_Present);\n+   pragma Inline (Set_TSS_Elist);\n    pragma Inline (Set_Tagged_Present);\n    pragma Inline (Set_Target_Type);\n    pragma Inline (Set_Task_Definition);\n    pragma Inline (Set_Task_Present);\n    pragma Inline (Set_Then_Actions);\n    pragma Inline (Set_Then_Statements);\n+   pragma Inline (Set_Treat_Fixed_As_Integer);\n    pragma Inline (Set_Triggering_Alternative);\n    pragma Inline (Set_Triggering_Statement);\n-   pragma Inline (Set_Treat_Fixed_As_Integer);\n-   pragma Inline (Set_TSS_Elist);\n    pragma Inline (Set_Type_Definition);\n    pragma Inline (Set_Unit);\n    pragma Inline (Set_Unknown_Discriminants_Present);\n    pragma Inline (Set_Unreferenced_In_Spec);\n+   pragma Inline (Set_Used_Operations);\n    pragma Inline (Set_Variant_Part);\n    pragma Inline (Set_Variants);\n    pragma Inline (Set_Visible_Declarations);\n-   pragma Inline (Set_Used_Operations);\n    pragma Inline (Set_Was_Originally_Stub);\n    pragma Inline (Set_Withed_Body);\n "}, {"sha": "43e902f2e174e9837ab5e52791507b3828dfbf1a", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -165,9 +165,12 @@ package Snames is\n    Name_uFinalizer                     : constant Name_Id := N + $;\n    Name_uIdepth                        : constant Name_Id := N + $;\n    Name_uInit                          : constant Name_Id := N + $;\n+   Name_uInvariant                     : constant Name_Id := N + $;\n    Name_uMaster                        : constant Name_Id := N + $;\n    Name_uObject                        : constant Name_Id := N + $;\n+   Name_uPost                          : constant Name_Id := N + $;\n    Name_uPostconditions                : constant Name_Id := N + $;\n+   Name_uPre                           : constant Name_Id := N + $;\n    Name_uPriority                      : constant Name_Id := N + $;\n    Name_uProcess_ATSD                  : constant Name_Id := N + $;\n    Name_uRelative_Deadline             : constant Name_Id := N + $;\n@@ -182,6 +185,7 @@ package Snames is\n    Name_uTask_Info                     : constant Name_Id := N + $;\n    Name_uTask_Name                     : constant Name_Id := N + $;\n    Name_uTrace_Sp                      : constant Name_Id := N + $;\n+   Name_uType_Invariant                : constant Name_Id := N + $;\n \n    --  Names of predefined primitives used in the expansion of dispatching\n    --  requeue and select statements, Abort, 'Callable and 'Terminated."}, {"sha": "96416a5e546d6b0535fe14acf2b72e4ac7ee9937", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -283,7 +283,6 @@ package body Switch.C is\n             when 'a' =>\n                Ptr := Ptr + 1;\n                Assertions_Enabled := True;\n-               Debug_Pragmas_Enabled := True;\n \n             --  -gnatA (disregard gnat.adc)\n "}, {"sha": "25e24c3c2db04b52e853ad066e80ba6a7f8654af", "filename": "gcc/ada/tree_io.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Ftree_io.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aab45d22d2ea5e564786773071d4758264755721/gcc%2Fada%2Ftree_io.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_io.ads?ref=aab45d22d2ea5e564786773071d4758264755721", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,7 +47,7 @@ package Tree_IO is\n    Tree_Format_Error : exception;\n    --  Raised if a format error is detected in the input file\n \n-   ASIS_Version_Number : constant := 30;\n+   ASIS_Version_Number : constant := 31;\n    --  ASIS Version. This is used to check for consistency between the compiler\n    --  used to generate trees and an ASIS application that is reading the\n    --  trees. It must be incremented whenever a change is made to the tree\n@@ -59,6 +59,7 @@ package Tree_IO is\n    --  29  Changes in Sem_Ch3 (tree copying in case of discriminant constraint\n    --      for concurrent types).\n    --  30  Add Check_Float_Overflow boolean to tree file\n+   --  31  Remove read/write of Debug_Pragmas_Disabled/Debug_Pragmas_Enabled\n \n    procedure Tree_Read_Initialize (Desc : File_Descriptor);\n    --  Called to initialize reading of a tree file. This call must be made"}]}