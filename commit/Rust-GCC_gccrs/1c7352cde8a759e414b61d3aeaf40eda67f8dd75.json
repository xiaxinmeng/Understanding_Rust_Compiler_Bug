{"sha": "1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3MzUyY2RlOGE3NTllNDE0YjYxZDNhZWFmNDBlZGE2N2Y4ZGQ3NQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@panix.com", "date": "2006-01-23T15:15:05Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2006-01-23T15:15:05Z"}, "message": "r110123@banpei: zack | 2006-01-22 14:44:34 -0800\n\n r110123@banpei:  zack | 2006-01-22 14:44:34 -0800\n \t* genconditions.c (condition_table, add_condition): Delete.\n \t(write_conditions): Don't emit n_insn_conditions nor\n \tinsn_elision_unavailable.  Issue the gcc version #ifdef here,\n \tinside the table, with no #else clause ...\n \t(write_header): ...not here.\n \t(write_writer): New function.\n \t(main): Don't initialize condition_table.  Use add_c_test.\n \tCall write_writer.\n \t* gensupport.c (init_md_reader_args_cb): Handle multiple input\n \tfiles on the command line.\n \t(maybe_eval_c_test): Don't check insn_elision_unavailable.\n \tReturn -1 if there is no entry in the table, don't abort.\n \t(add_c_test, traverse_c_tests): New functions.\n \t* gensupport.h (insn_elision_unavailable, insn_conditions)\n \t(n_insn_conditions): Delete declarations.\n \t(add_c_test, traverse_c_tests): Declare.\n \t* read-rtl.c: Include gensupport.h.\n \t(read_conditions): New function.\n \t(read_rtx): If read_rtx_1 returns 0, treat as EOF.\n \t(read_rtx_1): If we get EOF when we were looking for an initial\n \topen paren, return 0.  Call read_conditions when appropriate.\n \t* Makefile.in: Kill BUILD_EARLY_SUPPORT and all references to\n \tdummy-conditions.o.  Eliminate references to insn-conditions.o,\n \tor change them to build/gencondmd.o, as appropriate.  Remove\n \tinsn-constants.h from $(simple_generated_h) and insn-conditions.c\n \tfrom $(simple_generated_c).  For all files remaining in those\n \ttwo lists, add insn-conditions.md to the generator command line.\n \tGive insn-constants.h/s-constants their own rules.  Add rules\n \tfor build/gencondmd.c, s-conditions, insn-conditions.md, s-condmd.\n \t(build/read-rtl.o): Depend on gensupport.h.\n \t(genprognormal): Include preds.\n \t(genprogearly): Rename genprognoprint; only difference is now that\n \tthey don't link with $(BUILD_PRINT).\n \t* dummy-conditions.c: Delete.\n\nFrom-SVN: r110119", "tree": {"sha": "4239faf09e39683b3cf8286950be3b1832fd451b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4239faf09e39683b3cf8286950be3b1832fd451b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/comments", "author": {"login": "zackw", "id": 325899, "node_id": "MDQ6VXNlcjMyNTg5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/325899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackw", "html_url": "https://github.com/zackw", "followers_url": "https://api.github.com/users/zackw/followers", "following_url": "https://api.github.com/users/zackw/following{/other_user}", "gists_url": "https://api.github.com/users/zackw/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackw/subscriptions", "organizations_url": "https://api.github.com/users/zackw/orgs", "repos_url": "https://api.github.com/users/zackw/repos", "events_url": "https://api.github.com/users/zackw/events{/privacy}", "received_events_url": "https://api.github.com/users/zackw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "245fc6392879dd2493d4be97cbd01c64d0a61adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245fc6392879dd2493d4be97cbd01c64d0a61adf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245fc6392879dd2493d4be97cbd01c64d0a61adf"}], "stats": {"total": 531, "additions": 343, "deletions": 188}, "files": [{"sha": "6b723cc965bd0733e75825cc77a964559e039f97", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -1,3 +1,40 @@\n+2006-01-22  Zack Weinberg  <zackw@panix.com>\n+\n+\t* genconditions.c (condition_table, add_condition): Delete.\n+\t(write_conditions): Don't emit n_insn_conditions nor\n+\tinsn_elision_unavailable.  Issue the gcc version #ifdef here,\n+\tinside the table, with no #else clause ...\n+\t(write_header): ...not here.\n+\t(write_writer): New function.\n+\t(main): Don't initialize condition_table.  Use add_c_test.\n+\tCall write_writer.\n+\t* gensupport.c (init_md_reader_args_cb): Handle multiple input\n+\tfiles on the command line.\n+\t(maybe_eval_c_test): Don't check insn_elision_unavailable.\n+\tReturn -1 if there is no entry in the table, don't abort.\n+\t(add_c_test, traverse_c_tests): New functions.\n+\t* gensupport.h (insn_elision_unavailable, insn_conditions)\n+\t(n_insn_conditions): Delete declarations.\n+\t(add_c_test, traverse_c_tests): Declare.\n+\t* read-rtl.c: Include gensupport.h.\n+\t(read_conditions): New function.\n+\t(read_rtx): If read_rtx_1 returns 0, treat as EOF.\n+\t(read_rtx_1): If we get EOF when we were looking for an initial\n+\topen paren, return 0.  Call read_conditions when appropriate.\n+\t* Makefile.in: Kill BUILD_EARLY_SUPPORT and all references to\n+\tdummy-conditions.o.  Eliminate references to insn-conditions.o,\n+\tor change them to build/gencondmd.o, as appropriate.  Remove\n+\tinsn-constants.h from $(simple_generated_h) and insn-conditions.c\n+\tfrom $(simple_generated_c).  For all files remaining in those\n+\ttwo lists, add insn-conditions.md to the generator command line.\n+\tGive insn-constants.h/s-constants their own rules.  Add rules\n+\tfor build/gencondmd.c, s-conditions, insn-conditions.md, s-condmd.\n+\t(build/read-rtl.o): Depend on gensupport.h.\n+\t(genprognormal): Include preds.\n+\t(genprogearly): Rename genprognoprint; only difference is now that\n+\tthey don't link with $(BUILD_PRINT).\n+\t* dummy-conditions.c: Delete.\n+\n 2006-01-22  Zack Weinberg  <zackw@panix.com>\n \n \t* genextract.c: Don't include insn-config.h.  Do include vec.h."}, {"sha": "c6eec9832c16ba3318f5852719a454cd00c8e166", "filename": "gcc/Makefile.in", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -198,7 +198,7 @@ GCC_WARN_CFLAGS = $(LOOSE_WARN) $($(@D)-warn) $(NOCOMMON_FLAG) $($@-warn)\n # These files are to have -Werror bypassed in stage2:\n # These are very hard to completely clean due to target complexities.\n gcc.o-warn = -Wno-error\n-build/insn-conditions.o-warn = -Wno-error\n+build/gencondmd.o-warn = -Wno-error\n # Bison-1.75 output often yields (harmless) -Wtraditional warnings\n build/gengtype-yacc.o-warn = -Wno-error\n # flex output may yield harmless \"no previous prototype\" warnings\n@@ -840,9 +840,7 @@ BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o \\\n \t    build/min-insn-modes.o\n-BUILD_SUPPORT = build/gensupport.o build/insn-conditions.o\n-BUILD_EARLY_SUPPORT = build/gensupport.o build/dummy-conditions.o\n-\n+BUILD_SUPPORT = build/gensupport.o\n BUILD_PRINT = build/print-rtl.o\n BUILD_ERRORS = build/errors.o\n BUILD_VARRAY = build/varray.o\n@@ -1019,7 +1017,7 @@ STAGECOPYSTUFF = insn-flags.h insn-config.h insn-codes.h \\\n  insn-output.c insn-recog.c insn-emit.c insn-extract.c insn-peep.c \\\n  insn-attr.h insn-attrtab.c insn-opinit.c insn-preds.c insn-constants.h \\\n  tm-preds.h \\\n- tree-check.h insn-conditions.c min-insn-modes.c insn-modes.c insn-modes.h \\\n+ tree-check.h min-insn-modes.c insn-modes.c insn-modes.h \\\n  genrtl.c genrtl.h gt-*.h gtype-*.h gtype-desc.c gtyp-gen.h\n \n # Files to be moved away after each stage in building.\n@@ -2678,26 +2676,38 @@ insn-recog.o : insn-recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h\t\t\\\n # The \"; @true\" construct forces Make to recheck the timestamp on the\n # target file.\n \n-simple_generated_h = insn-attr.h insn-codes.h insn-config.h\t\\\n-\t\t     insn-constants.h insn-flags.h \n+simple_generated_h = insn-attr.h insn-codes.h insn-config.h insn-flags.h \n \n-simple_generated_c = insn-attrtab.c insn-conditions.c insn-emit.c \\\n-\t\t     insn-extract.c insn-opinit.c insn-output.c \\\n-\t\t     insn-peep.c insn-recog.c\n+simple_generated_c = insn-attrtab.c insn-emit.c insn-extract.c\t\\\n+\t\t     insn-opinit.c insn-output.c insn-peep.c\t\\\n+\t\t     insn-recog.c\n \n $(simple_generated_h): insn-%.h: s-%; @true\n \n-$(simple_generated_h:insn-%.h=s-%): s-%: $(MD_DEPS) build/gen%$(build_exeext)\n-\t$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) > tmp-$*.h\n+$(simple_generated_h:insn-%.h=s-%): s-%: build/gen%$(build_exeext) \\\n+  $(MD_DEPS) insn-conditions.md\n+\t$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) \\\n+\t  insn-conditions.md > tmp-$*.h\n \t$(SHELL) $(srcdir)/../move-if-change tmp-$*.h insn-$*.h\n \t$(STAMP) s-$*\n \n $(simple_generated_c): insn-%.c: s-%; @true\n-$(simple_generated_c:insn-%.c=s-%): s-%: $(MD_DEPS) build/gen%$(build_exeext)\n-\t$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) > tmp-$*.c\n+$(simple_generated_c:insn-%.c=s-%): s-%: build/gen%$(build_exeext) \\\n+  $(MD_DEPS) insn-conditions.md\n+\t$(RUN_GEN) build/gen$*$(build_exeext) $(md_file) \\\n+\t  insn-conditions.md > tmp-$*.c\n \t$(SHELL) $(srcdir)/../move-if-change tmp-$*.c insn-$*.c\n \t$(STAMP) s-$*\n \n+# genconstants needs to run before insn-conditions.md is available\n+# (because the constants may be used in the conditions).\n+insn-constants.h: s-constants; @true\n+s-constants: build/genconstants$(build_exeext) $(MD_DEPS)\n+\t$(RUN_GEN) build/genconstants$(build_exeext) $(md_file) \\\n+\t  > tmp-constants.h\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-constants.h insn-constants.h\n+\t$(STAMP) s-constants\n+\n # gencheck doesn't read the machine description, and the file produced\n # doesn't use the insn-* convention.\n tree-check.h: s-check ; @true\n@@ -2706,6 +2716,20 @@ s-check : build/gencheck$(build_exeext)\n \t$(SHELL) $(srcdir)/../move-if-change tmp-check.h tree-check.h\n \t$(STAMP) s-check\n \n+# gencondmd doesn't use the standard naming convention.\n+build/gencondmd.c: s-conditions; @true\n+s-conditions: $(MD_DEPS) build/genconditions$(build_exeext)\n+\t$(RUN_GEN) build/genconditions$(build_exeext) $(md_file) > tmp-condmd.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-condmd.c build/gencondmd.c\n+\t$(STAMP) s-conditions\n+\n+insn-conditions.md: s-condmd; @true\n+s-condmd: build/gencondmd$(build_exeext)\n+\t$(RUN_GEN) build/gencondmd$(build_exeext) > tmp-cond.md\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-cond.md insn-conditions.md\n+\t$(STAMP) s-condmd\n+\n+\n # These files are generated by running the same generator more than\n # once with different options, so they have custom rules.  The\n # stampfile idiom is the same.\n@@ -2859,7 +2883,6 @@ build/%.o :  # dependencies provided by explicit rule later\n \n # Header dependencies for the programs that generate source code.\n # These are library modules...\n-build/dummy-conditions.o : dummy-conditions.c\n build/errors.o : errors.c $(BCONFIG_H) $(SYSTEM_H) errors.h\n build/gensupport.o: gensupport.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) errors.h $(HASHTAB_H)\t\t\\\n@@ -2871,16 +2894,16 @@ build/min-insn-modes.o : min-insn-modes.c $(BCONFIG_H) $(SYSTEM_H)\t\\\n build/print-rtl.o: print-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n   $(GTM_H) $(RTL_BASE_H)\n build/read-rtl.o: read-rtl.c $(BCONFIG_H) $(SYSTEM_H) coretypes.h\t\\\n-  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H)\n+  $(GTM_H) $(RTL_BASE_H) $(OBSTACK_H) $(HASHTAB_H) gensupport.h\n build/rtl.o: rtl.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(RTL_H) real.h $(GGC_H) errors.h\n build/varray.o: varray.c $(BCONFIG_H) coretypes.h $(GTM_H) $(SYSTEM_H)\t\\\n   $(VARRAY_H) $(RTL_BASE_H) $(GGC_H) $(TREE_H) bitmap.h errors.h\n build/vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) coretypes.h vec.h \\\n    $(GGC_H) toplev.h\n-build/insn-conditions.o : insn-conditions.c $(CONFIG_H) $(SYSTEM_H)\t\\\n-  $(GTM_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) $(RECOG_H) real.h\t\\\n-  output.h $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) toplev.h reload.h\t\\\n+build/gencondmd.o : build/gencondmd.c $(CONFIG_H) $(SYSTEM_H) $(GTM_H)\t\\\n+  $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) $(RECOG_H) real.h output.h\t\\\n+  $(FLAGS_H) hard-reg-set.h $(RESOURCE_H) toplev.h reload.h\t\t\\\n   gensupport.h insn-constants.h coretypes.h\n \n # ...these are the programs themselves.\n@@ -2942,15 +2965,16 @@ build/gen%$(build_exeext): build/gen%.o $(BUILD_LIBDEPS)\n \t    $(filter-out $(BUILD_LIBDEPS), $^) $(BUILD_LIBS)\n \n # All these programs have the same additional dependency set.\n-genprognormal = attr codes config emit extract flags opinit output peep recog\n+genprognormal = attr codes config emit extract flags opinit output peep recog \\\n+\t\tpreds\n $(genprognormal:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_SUPPORT) \\\n   $(BUILD_PRINT) $(BUILD_ERRORS)\n \n-# And all of these, but it's a different set.\n-genprogearly = mddeps constants conditions preds\n-$(genprogearly:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_ERRORS) \\\n-  $(BUILD_EARLY_SUPPORT)\n-build/genpreds$(build_exeext) : $(BUILD_PRINT)\n+# These don't have the glue to link with print-rtl.o.\n+genprognoprint = mddeps constants conditions\n+$(genprognoprint:%=build/gen%$(build_exeext)): $(BUILD_RTL) $(BUILD_SUPPORT) \\\n+  $(BUILD_ERRORS)\n+\n \n build/gengenrtl$(build_exeext) : $(BUILD_ERRORS)\n build/genmodes$(build_exeext) : $(BUILD_ERRORS)"}, {"sha": "14a28b628e75d1399d6904f850f6800a701aed4c", "filename": "gcc/dummy-conditions.c", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2Fdummy-conditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245fc6392879dd2493d4be97cbd01c64d0a61adf/gcc%2Fdummy-conditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdummy-conditions.c?ref=245fc6392879dd2493d4be97cbd01c64d0a61adf", "patch": "@@ -1,42 +0,0 @@\n-/* Support for calculating constant conditions.\n-   Copyright (C) 2002, 2004 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to\n-   the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-   Boston, MA 02110-1301, USA.  */\n-\n-#include <stddef.h>  /* for size_t */\n-\n-/* MD generators that are run before insn-conditions.c exists should\n-   link against this file instead.  Currently that is genconditions\n-   and genconstants.  */\n-\n-/* In order to avoid dragging in all the headers that are needed to\n-   declare things that gensupport.h uses, we duplicate the declaration\n-   of struct c_test here.  (In particular we do not want to have to\n-   include tm.h nor rtl.h in this file.)  */\n-struct c_test\n-{\n-  const char *expr;\n-  int value;\n-};\n-\n-/* Empty conditions table to prevent link errors.  */\n-const struct c_test insn_conditions[1] = { { 0, 0 } };\n-const size_t n_insn_conditions = 0;\n-\n-/* Disable insn elision, since it is currently impossible.  */\n-const int insn_elision_unavailable = 1;"}, {"sha": "10dfc5896b487f5ae4940c14b434eb727ec192ac", "filename": "gcc/genconditions.c", "status": "modified", "additions": 29, "deletions": 39, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgenconditions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgenconditions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconditions.c?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -38,31 +38,10 @@\n /* so we can include except.h in the generated file.  */\n static int saw_eh_return;\n \n-static htab_t condition_table;\n-\n-static void add_condition\t(const char *);\n static void write_header\t(void);\n static void write_conditions\t(void);\n static int write_one_condition\t(void **, void *);\n \n-/* Record the C test expression EXPR in the condition_table.\n-   Duplicates clobber previous entries, which leaks memory, but\n-   we don't care for this application.  */\n-\n-static void\n-add_condition (const char *expr)\n-{\n-  struct c_test *test;\n-\n-  if (expr[0] == 0)\n-    return;\n-\n-  test = XNEW (struct c_test);\n-  test->expr = expr;\n-\n-  *(htab_find_slot (condition_table, test, INSERT)) = test;\n-}\n-\n /* Generate the header for insn-conditions.c.  */\n \n static void\n@@ -86,13 +65,6 @@ write_header (void)\n \n   puts (\"\\\n #include \\\"system.h\\\"\\n\\\n-/* If we don't have __builtin_constant_p, or it's not acceptable in array\\n\\\n-   initializers, fall back to assuming that all conditions potentially\\n\\\n-   vary at run time.  It works in 3.0.1 and later; 3.0 only when not\\n\\\n-   optimizing.  */\\n\\\n-#if GCC_VERSION < 3001\\n\\\n-#include \\\"dummy-conditions.c\\\"\\n\\\n-#else\\n\\\n #include \\\"coretypes.h\\\"\\n\\\n #include \\\"tm.h\\\"\\n\\\n #include \\\"rtl.h\\\"\\n\\\n@@ -172,15 +144,35 @@ write_conditions (void)\n    Each condition is mapped to its truth value (0 or 1), or -1 if that\\n\\\n    cannot be calculated at compile time. */\\n\\\n \\n\\\n-const struct c_test insn_conditions[] = {\");\n+static const struct c_test insn_conditions[] = {\\n\t\t\t\\\n+/* If we don't have __builtin_constant_p, or it's not acceptable in array\\n\\\n+   initializers, fall back to assuming that all conditions potentially\\n\\\n+   vary at run time.  It works in 3.0.1 and later; 3.0 only when not\\n\\\n+   optimizing.  */\\n\\\n+#if GCC_VERSION >= 3001\");\n \n-  htab_traverse (condition_table, write_one_condition, 0);\n+  traverse_c_tests (write_one_condition, 0);\n \n-  puts (\"};\\n\");\n+  puts (\"#endif\\n};\\n\");\n+}\n \n-  printf (\"const size_t n_insn_conditions = %lu;\\n\",\n-\t  (unsigned long) htab_elements (condition_table));\n-  puts (\"const int insn_elision_unavailable = 0;\\n#endif\");\n+/* Emit code which will convert the C-format table to a\n+   (define_conditions) form, which the MD reader can understand.\n+   The result will be added to the set of files scanned by\n+   'downstream' generators.  */\n+static void\n+write_writer (void)\n+{\n+  puts (\"int\\nmain(void)\\n{\\n\\\n+  unsigned int i;\\n\\\n+\\n\\\n+  puts (\\\"(define_conditions [\\\");\\n\\\n+  for (i = 0; i < ARRAY_SIZE (insn_conditions); i++)\\n\\\n+    printf (\\\"  (%d \\\\\\\"%s\\\\\\\")\\\\n\\\",\\n\\\n+\t    insn_conditions[i].value, insn_conditions[i].expr);\\n\\\n+  puts (\\\"])\\\");\\n\\\n+  fflush (stdout);\\n\\\n+  return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);\\n}\");\n }\n \n int\n@@ -195,10 +187,7 @@ main (int argc, char **argv)\n   if (init_md_reader_args (argc, argv) != SUCCESS_EXIT_CODE)\n     return (FATAL_EXIT_CODE);\n \n-  condition_table = htab_create (1000, hash_c_test, cmp_c_test, NULL);\n-\n   /* Read the machine description.  */\n-\n   while (1)\n     {\n       desc = read_md_rtx (&pattern_lineno, &code);\n@@ -214,7 +203,7 @@ main (int argc, char **argv)\n \n \tcase DEFINE_INSN:\n \tcase DEFINE_EXPAND:\n-\t  add_condition (XSTR (desc, 2));\n+\t  add_c_test (XSTR (desc, 2), -1);\n \t  /* except.h needs to know whether there is an eh_return\n \t     pattern in the machine description.  */\n \t  if (!strcmp (XSTR (desc, 0), \"eh_return\"))\n@@ -224,13 +213,14 @@ main (int argc, char **argv)\n \tcase DEFINE_SPLIT:\n \tcase DEFINE_PEEPHOLE:\n \tcase DEFINE_PEEPHOLE2:\n-\t  add_condition (XSTR (desc, 1));\n+\t  add_c_test (XSTR (desc, 1), -1);\n \t  break;\n \t}\n     }\n \n   write_header ();\n   write_conditions ();\n+  write_writer ();\n \n   fflush (stdout);\n   return (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);"}, {"sha": "94d27aca975303ecc38bdccaae511526841ab425", "filename": "gcc/gensupport.c", "status": "modified", "additions": 150, "deletions": 70, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -901,93 +901,148 @@ int\n init_md_reader_args_cb (int argc, char **argv, bool (*parse_opt)(const char *))\n {\n   FILE *input_file;\n-  int i, lineno;\n-  size_t ix;\n+  int c, i, lineno;\n   char *lastsl;\n   rtx desc;\n+  bool no_more_options;\n+  bool already_read_stdin;\n \n   /* Unlock the stdio streams.  */\n   unlock_std_streams ();\n \n+  /* First we loop over all the options.  */\n   for (i = 1; i < argc; i++)\n     {\n       if (argv[i][0] != '-')\n+\tcontinue;\n+      \n+      c = argv[i][1];\n+      switch (c)\n \t{\n-\t  if (in_fname)\n-\t    fatal (\"too many input files\");\n+\tcase 'I':\t\t/* Add directory to path for includes.  */\n+\t  {\n+\t    struct file_name_list *dirtmp;\n+\n+\t    dirtmp = XNEW (struct file_name_list);\n+\t    dirtmp->next = 0;\t/* New one goes on the end */\n+\t    if (first_dir_md_include == 0)\n+\t      first_dir_md_include = dirtmp;\n+\t    else\n+\t      last_dir_md_include->next = dirtmp;\n+\t    last_dir_md_include = dirtmp;\t/* Tail follows the last one */\n+\t    if (argv[i][1] == 'I' && argv[i][2] != 0)\n+\t      dirtmp->fname = argv[i] + 2;\n+\t    else if (i + 1 == argc)\n+\t      fatal (\"directory name missing after -I option\");\n+\t    else\n+\t      dirtmp->fname = argv[++i];\n+\t    if (strlen (dirtmp->fname) > max_include_len)\n+\t      max_include_len = strlen (dirtmp->fname);\n+\t  }\n+\t  break;\n \n-\t  in_fname = argv[i];\n-\t}\n-      else\n-\t{\n-\t  int c = argv[i][1];\n-\t  switch (c)\n-\t    {\n-\t    case 'I':\t\t/* Add directory to path for includes.  */\n-\t      {\n-\t\tstruct file_name_list *dirtmp;\n-\n-\t\tdirtmp = XNEW (struct file_name_list);\n-\t\tdirtmp->next = 0;\t/* New one goes on the end */\n-\t\tif (first_dir_md_include == 0)\n-\t\t  first_dir_md_include = dirtmp;\n-\t\telse\n-\t\t  last_dir_md_include->next = dirtmp;\n-\t\tlast_dir_md_include = dirtmp;\t/* Tail follows the last one */\n-\t\tif (argv[i][1] == 'I' && argv[i][2] != 0)\n-\t\t  dirtmp->fname = argv[i] + 2;\n-\t\telse if (i + 1 == argc)\n-\t\t  fatal (\"directory name missing after -I option\");\n-\t\telse\n-\t\t  dirtmp->fname = argv[++i];\n-\t\tif (strlen (dirtmp->fname) > max_include_len)\n-\t\t  max_include_len = strlen (dirtmp->fname);\n-\t      }\n-\t      break;\n-\t    default:\n-\t      /* The program may have provided a callback so it can\n-\t\t accept its own options.  */\n-\t      if (parse_opt && parse_opt (argv[i]))\n-\t\tbreak;\n-\n-\t      fatal (\"invalid option `%s'\", argv[i]);\n-\t    }\n-\t}\n-    }\n+\tcase '\\0':\n+\t  /* An argument consisting of exactly one dash is a request to\n+\t     read stdin.  This will be handled in the second loop.  */\n+\t  continue;\n \n-  if (!in_fname)\n-    fatal (\"no input file name\");\n+\tcase '-':\n+\t  /* An argument consisting of just two dashes causes option\n+\t     parsing to cease.  */\n+\t  if (argv[i][2] == '\\0')\n+\t    goto stop_parsing_options;\n \n-  lastsl = strrchr (in_fname, '/');\n-  if (lastsl != NULL)\n-    base_dir = save_string (in_fname, lastsl - in_fname + 1 );\n+\tdefault:\n+\t  /* The program may have provided a callback so it can\n+\t     accept its own options.  */\n+\t  if (parse_opt && parse_opt (argv[i]))\n+\t    break;\n \n-  read_rtx_filename = in_fname;\n-  input_file = fopen (in_fname, \"r\");\n-  if (input_file == 0)\n-    {\n-      perror (in_fname);\n-      return FATAL_EXIT_CODE;\n+\t  fatal (\"invalid option `%s'\", argv[i]);\n+\t}\n     }\n \n-  /* Initialize the table of insn conditions.  */\n-  condition_table = htab_create (n_insn_conditions,\n-\t\t\t\t hash_c_test, cmp_c_test, NULL);\n-\n-  for (ix = 0; ix < n_insn_conditions; ix++)\n-    *(htab_find_slot (condition_table, &insn_conditions[ix], INSERT))\n-      = (void *) &insn_conditions[ix];\n+ stop_parsing_options:\n \n+  /* Prepare to read input.  */\n+  condition_table = htab_create (500, hash_c_test, cmp_c_test, NULL);\n   init_predicate_table ();\n-\n   obstack_init (rtl_obstack);\n   errors = 0;\n   sequence_num = 0;\n+  no_more_options = false;\n+  already_read_stdin = false;\n \n-  /* Read the entire file.  */\n-  while (read_rtx (input_file, &desc, &lineno))\n-    process_rtx (desc, lineno);\n-  fclose (input_file);\n+\n+  /* Now loop over all input files.  */\n+  for (i = 1; i < argc; i++)\n+    {\n+      if (argv[i][0] == '-')\n+\t{\n+\t  if (argv[i][1] == '\\0')\n+\t    {\n+\t      /* Read stdin.  */\n+\t      if (already_read_stdin)\n+\t\tfatal (\"cannot read standard input twice\");\n+\t      \n+\t      base_dir = NULL;\n+\t      read_rtx_filename = in_fname = \"<stdin>\";\n+\t      read_rtx_lineno = 1;\n+\t      input_file = stdin;\n+\t      already_read_stdin = true;\n+\n+\t      while (read_rtx (input_file, &desc, &lineno))\n+\t\tprocess_rtx (desc, lineno);\n+\t      fclose (input_file);\n+\t      continue;\n+\t    }\n+\t  else if (argv[i][1] == '-' && argv[i][2] == '\\0')\n+\t    {\n+\t      /* No further arguments are to be treated as options.  */\n+\t      no_more_options = true;\n+\t      continue;\n+\t    }\n+\t  else if (!no_more_options)\n+\t    continue;\n+\t}\n+\n+      /* If we get here we are looking at a non-option argument, i.e.\n+\t a file to be processed.  */\n+\n+      in_fname = argv[i];\n+      lastsl = strrchr (in_fname, '/');\n+      if (lastsl != NULL)\n+\tbase_dir = save_string (in_fname, lastsl - in_fname + 1 );\n+      else\n+\tbase_dir = NULL;\n+\n+      read_rtx_filename = in_fname;\n+      read_rtx_lineno = 1;\n+      input_file = fopen (in_fname, \"r\");\n+      if (input_file == 0)\n+\t{\n+\t  perror (in_fname);\n+\t  return FATAL_EXIT_CODE;\n+\t}\n+\n+      while (read_rtx (input_file, &desc, &lineno))\n+\tprocess_rtx (desc, lineno);\n+      fclose (input_file);\n+    }\n+\n+  /* If we get to this point without having seen any files to process,\n+     read standard input now.  */\n+  if (!in_fname)\n+    {\n+      base_dir = NULL;\n+      read_rtx_filename = in_fname = \"<stdin>\";\n+      read_rtx_lineno = 1;\n+      input_file = stdin;\n+\n+      while (read_rtx (input_file, &desc, &lineno))\n+\tprocess_rtx (desc, lineno);\n+      fclose (input_file);\n+    }\n \n   /* Process define_cond_exec patterns.  */\n   if (define_cond_exec_queue != NULL)\n@@ -1119,16 +1174,41 @@ maybe_eval_c_test (const char *expr)\n   if (expr[0] == 0)\n     return 1;\n \n-  if (insn_elision_unavailable)\n-    return -1;\n-\n   dummy.expr = expr;\n   test = (const struct c_test *)htab_find (condition_table, &dummy);\n-  gcc_assert (test);\n-\n+  if (!test)\n+    return -1;\n   return test->value;\n }\n \n+/* Record the C test expression EXPR in the condition_table, with\n+   value VAL.  Duplicates clobber previous entries.  */\n+\n+void\n+add_c_test (const char *expr, int value)\n+{\n+  struct c_test *test;\n+\n+  if (expr[0] == 0)\n+    return;\n+\n+  test = XNEW (struct c_test);\n+  test->expr = expr;\n+  test->value = value;\n+\n+  *(htab_find_slot (condition_table, test, INSERT)) = test;\n+}\n+\n+/* For every C test, call CALLBACK with two arguments: a pointer to\n+   the condition structure and INFO.  Stops when CALLBACK returns zero.  */\n+void\n+traverse_c_tests (htab_trav callback, void *info)\n+{\n+  if (condition_table)\n+    htab_traverse (condition_table, callback, info);\n+}\n+\n+\n /* Given a string, return the number of comma-separated elements in it.\n    Return 0 for the null string.  */\n int"}, {"sha": "53cbdc23b6ea6cf06b04a7a8250dfd737fdab0fb", "filename": "gcc/gensupport.h", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -37,31 +37,27 @@ extern void message_with_line (int, const char *, ...)\n    Must be set before calling init_md_reader.  */\n extern int insn_elision;\n \n-/* If this is 1, the insn elision table doesn't even exist yet;\n-   maybe_eval_c_test will always return -1.  This is distinct from\n-   insn_elision because genflags and gencodes need to see all the\n-   patterns, but treat elided patterns differently.  */\n-extern const int insn_elision_unavailable;\n-\n /* If the C test passed as the argument can be evaluated at compile\n    time, return its truth value; else return -1.  The test must have\n    appeared somewhere in the machine description when genconditions\n    was run.  */\n extern int maybe_eval_c_test (const char *);\n \n-/* This table should not be accessed directly; use maybe_eval_c_test.  */\n+/* Add an entry to the table of conditions.  Used by genconditions and\n+   by read-rtl.c.  */\n+extern void add_c_test (const char *, int);\n+\n+/* This structure is used internally by gensupport.c and genconditions.c.  */\n struct c_test\n {\n   const char *expr;\n   int value;\n };\n \n-extern const struct c_test insn_conditions[];\n-extern const size_t n_insn_conditions;\n-\n #ifdef __HASHTAB_H__\n extern hashval_t hash_c_test (const void *);\n extern int cmp_c_test (const void *, const void *);\n+extern void traverse_c_tests (htab_trav, void *);\n #endif\n \n extern int n_comma_elts\t(const char *);"}, {"sha": "b4b105108eb52c5da384b76171e5a165ceaaf2d8", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7352cde8a759e414b61d3aeaf40eda67f8dd75/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=1c7352cde8a759e414b61d3aeaf40eda67f8dd75", "patch": "@@ -31,6 +31,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"rtl.h\"\n #include \"obstack.h\"\n #include \"hashtab.h\"\n+#include \"gensupport.h\"\n \n static htab_t md_constants;\n \n@@ -138,6 +139,7 @@ static void read_escape (FILE *);\n static hashval_t def_hash (const void *);\n static int def_name_eq_p (const void *, const void *);\n static void read_constants (FILE *infile, char *tmp_char);\n+static void read_conditions (FILE *infile, char *tmp_char);\n static void validate_const_int (FILE *, const char *);\n static int find_macro (struct macro_group *, const char *, FILE *);\n static struct mapping *read_mapping (struct macro_group *, htab_t, FILE *);\n@@ -1205,6 +1207,58 @@ traverse_md_constants (htab_trav callback, void *info)\n   if (md_constants)\n     htab_traverse (md_constants, callback, info);\n }\n+\f\n+/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer\n+   suitable to read a name or number into.  Process a\n+   define_conditions directive, starting with the optional space after\n+   the \"define_conditions\".  The directive looks like this:\n+\n+     (define_conditions [\n+        (number \"string\")\n+        (number \"string\")\n+        ...\n+     ])\n+\n+   It's not intended to appear in machine descriptions.  It is\n+   generated by (the program generated by) genconditions.c, and\n+   slipped in at the beginning of the sequence of MD files read by\n+   most of the other generators.  */\n+static void\n+read_conditions (FILE *infile, char *tmp_char)\n+{\n+  int c;\n+\n+  c = read_skip_spaces (infile);\n+  if (c != '[')\n+    fatal_expected_char (infile, '[', c);\n+\n+  while ( (c = read_skip_spaces (infile)) != ']')\n+    {\n+      char *expr;\n+      int value;\n+\n+      if (c != '(')\n+\tfatal_expected_char (infile, '(', c);\n+\n+      read_name (tmp_char, infile);\n+      validate_const_int (infile, tmp_char);\n+      value = atoi (tmp_char);\n+\n+      c = read_skip_spaces (infile);\n+      if (c != '\"')\n+\tfatal_expected_char (infile, '\"', c);\n+      expr = read_quoted_string (infile);\n+\n+      c = read_skip_spaces (infile);\n+      if (c != ')')\n+\tfatal_expected_char (infile, ')', c);\n+\n+      add_c_test (expr, value);\n+    }\n+  c = read_skip_spaces (infile);\n+  if (c != ')')\n+    fatal_expected_char (infile, ')', c);\n+}\n \n static void\n validate_const_int (FILE *infile, const char *string)\n@@ -1354,16 +1408,23 @@ read_rtx (FILE *infile, rtx *x, int *lineno)\n     {\n       struct map_value *mode_maps;\n       struct macro_traverse_data mtd;\n+      rtx from_file;\n \n       c = read_skip_spaces (infile);\n       if (c == EOF)\n \treturn false;\n       ungetc (c, infile);\n \n-      queue_next = queue_head;\n       queue_lineno = read_rtx_lineno;\n       mode_maps = 0;\n-      XEXP (queue_next, 0) = read_rtx_1 (infile, &mode_maps);\n+      from_file = read_rtx_1 (infile, &mode_maps);\n+      if (from_file == 0)\n+\treturn false;  /* This confuses a top level (nil) with end of\n+\t\t\t  file, but a top level (nil) would have\n+\t\t\t  crashed our caller anyway.  */\n+\n+      queue_next = queue_head;\n+      XEXP (queue_next, 0) = from_file;\n       XEXP (queue_next, 1) = 0;\n \n       mtd.queue = queue_next;\n@@ -1412,6 +1473,10 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n \n  again:\n   c = read_skip_spaces (infile); /* Should be open paren.  */\n+\n+  if (c == EOF)\n+    return 0;\n+  \n   if (c != '(')\n     fatal_expected_char (infile, '(', c);\n \n@@ -1429,6 +1494,11 @@ read_rtx_1 (FILE *infile, struct map_value **mode_maps)\n       read_constants (infile, tmp_char);\n       goto again;\n     }\n+  if (strcmp (tmp_char, \"define_conditions\") == 0)\n+    {\n+      read_conditions (infile, tmp_char);\n+      goto again;\n+    }\n   if (strcmp (tmp_char, \"define_mode_attr\") == 0)\n     {\n       read_mapping (&modes, modes.attrs, infile);"}]}