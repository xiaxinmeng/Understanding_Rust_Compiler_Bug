{"sha": "af13f02d367c94057d747afc4c30c56930f07e3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYxM2YwMmQzNjdjOTQwNTdkNzQ3YWZjNGMzMGM1NjkzMGYwN2UzYw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T20:56:04Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-12-31T20:56:04Z"}, "message": "(strict_low_part_peephole_ok): New function.\n\nFrom-SVN: r3016", "tree": {"sha": "81f0c3648927fdc7386f0322edc93d4809dcb07f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81f0c3648927fdc7386f0322edc93d4809dcb07f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af13f02d367c94057d747afc4c30c56930f07e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af13f02d367c94057d747afc4c30c56930f07e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af13f02d367c94057d747afc4c30c56930f07e3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af13f02d367c94057d747afc4c30c56930f07e3c/comments", "author": null, "committer": null, "parents": [{"sha": "ed359ebc317acbf7e2d948232f11e98a701277d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed359ebc317acbf7e2d948232f11e98a701277d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed359ebc317acbf7e2d948232f11e98a701277d0"}], "stats": {"total": 59, "additions": 59, "deletions": 0}, "files": [{"sha": "8e75d8ee8d2d5be492b70a38bad7bec850cc365e", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af13f02d367c94057d747afc4c30c56930f07e3c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af13f02d367c94057d747afc4c30c56930f07e3c/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=af13f02d367c94057d747afc4c30c56930f07e3c", "patch": "@@ -1971,3 +1971,62 @@ print_operand_address (file, addr)\n \tbreak;\n     }\n }\n+\f\n+/* Check for cases where a clr insns can be omitted from code using\n+   strict_low_part sets.  For example, the second clrl here is not needed:\n+   clrl d0; movw a0@+,d0; use d0; clrl d0; movw a0@+; use d0; ...\n+\n+   MODE is the mode of this STRICT_LOW_PART set.  FIRST_INSN is the clear\n+   insn we are checking for redundancy.  TARGET is the register set by the\n+   clear insn.  */\n+\n+int\n+strict_low_part_peephole_ok (mode, first_insn, target)\n+     enum machine_mode mode;\n+     rtx first_insn;\n+     rtx target;\n+{\n+  rtx p;\n+\n+  p = prev_nonnote_insn (first_insn);\n+\n+  while (p)\n+    {\n+      /* If it isn't an insn, then give up.  */\n+      if (GET_CODE (p) != INSN)\n+\treturn 0;\n+\n+      if (reg_set_p (target, p))\n+\t{\n+\t  rtx set = single_set (p);\n+\t  rtx dest;\n+\n+\t  /* If it isn't an easy to recognize insn, then give up.  */\n+\t  if (! set)\n+\t    return 0;\n+\n+\t  dest = SET_DEST (set);\n+\n+\t  /* If this sets the entire target register to zero, then our\n+\t     first_insn is redundant.  */\n+\t  if (rtx_equal_p (dest, target)\n+\t      && SET_SRC (set) == const0_rtx)\n+\t    return 1;\n+\t  else if (GET_CODE (dest) == STRICT_LOW_PART\n+\t\t   && GET_CODE (XEXP (dest, 0)) == REG\n+\t\t   && REGNO (XEXP (dest, 0)) == REGNO (target)\n+\t\t   && (GET_MODE_SIZE (GET_MODE (XEXP (dest, 0)))\n+\t\t       <= GET_MODE_SIZE (mode)))\n+\t    /* This is a strict low part set which modifies less than\n+\t       we are using, so it is safe.  */\n+\t    ;\n+\t  else\n+\t    return 0;\n+\t}\n+\n+      p = prev_nonnote_insn (p);\n+\n+    }\n+\n+  return 0;\n+}"}]}