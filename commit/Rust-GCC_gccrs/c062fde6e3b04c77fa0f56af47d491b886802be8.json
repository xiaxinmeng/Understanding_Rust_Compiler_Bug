{"sha": "c062fde6e3b04c77fa0f56af47d491b886802be8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA2MmZkZTZlM2IwNGM3N2ZhMGY1NmFmNDdkNDkxYjg4NjgwMmJlOA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-24T05:19:21Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-24T05:19:21Z"}, "message": "Initial revision\n\nFrom-SVN: r237", "tree": {"sha": "0b454c79ec968d688a67ae953d28fdb931b8daf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b454c79ec968d688a67ae953d28fdb931b8daf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c062fde6e3b04c77fa0f56af47d491b886802be8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c062fde6e3b04c77fa0f56af47d491b886802be8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c062fde6e3b04c77fa0f56af47d491b886802be8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c062fde6e3b04c77fa0f56af47d491b886802be8/comments", "author": null, "committer": null, "parents": [{"sha": "15a63be14c54f9caf5f70ff4949186c7de2eb04c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a63be14c54f9caf5f70ff4949186c7de2eb04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15a63be14c54f9caf5f70ff4949186c7de2eb04c"}], "stats": {"total": 153, "additions": 153, "deletions": 0}, "files": [{"sha": "46a1eaa24d9ed5017841a45fef9a4be87ff7aaed", "filename": "gcc/config/i386/sysv4.h", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c062fde6e3b04c77fa0f56af47d491b886802be8/gcc%2Fconfig%2Fi386%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c062fde6e3b04c77fa0f56af47d491b886802be8/gcc%2Fconfig%2Fi386%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsysv4.h?ref=c062fde6e3b04c77fa0f56af47d491b886802be8", "patch": "@@ -0,0 +1,153 @@\n+/* Target definitions for GNU compiler for Intel 80386 running System V.4\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Written by Ron Guilmette (rfg@ncd.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i386.h\"\t/* Base i386 target machine definitions */\n+#include \"att386.h\"\t/* Use the i386 AT&T assembler syntax */\n+#include \"svr4.h\"\t/* Definitions common to all SVR4 targets */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386 System V Release 4)\");\n+\n+/* By default, target has a 80387.  */\n+\n+#define TARGET_DEFAULT 1\n+\n+/* Machines that use the AT&T assembler syntax\n+   also return floating point values in an FP register.  */\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#define VALUE_REGNO(MODE) \\\n+  (((MODE) == SFmode || (MODE) == DFmode) ? FIRST_FLOAT_REG : 0)\n+\n+/* 1 if N is a possible register number for a function value. */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N)== FIRST_FLOAT_REG)\n+\n+/* The svr4 ABI for the i386 says that records and unions are returned\n+   in memory.  */\n+\n+#undef RETURN_IN_MEMORY\n+#define RETURN_IN_MEMORY(TYPE) \\\n+  (TREE_CODE (TYPE) == RECORD_TYPE || TREE_CODE(TYPE) == UNION_TYPE)\n+\n+/* Define which macros to predefine.  __svr4__ is our extension.  */\n+/* This used to define X86, but james@bigtex.cactus.org says that\n+   is supposed to be defined optionally by user programs--not by default.  */\n+#define CPP_PREDEFINES \\\n+  \"-Di386 -Dunix -D__svr4__ -Asystem(unix) -Acpu(i386) -Amachine(i386)\"\n+\n+/* Output at beginning of assembler file.  */\n+/* The .file command should always begin the output.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+\toutput_file_directive (FILE, main_input_filename);\t\t\\\n+\tfprintf (FILE, \"\\t.version\\t\\\"01.01\\\"\\n\");\t\t\t\\\n+  } while (0)\n+\n+/* Define the register numbers to be used in Dwarf debugging information.\n+   The SVR4 reference port C compiler uses the following register numbers\n+   in its Dwarf output code:\n+\n+\t0 for %eax (regno = 0)\n+\t1 for %ecx (regno = 2)\n+\t2 for %edx (regno = 1)\n+\t3 for %ebx (regno = 3)\n+\t4 for %esp (regno = 7)\n+\t5 for %ebp (regno = 6)\n+\t6 for %esi (regno = 4)\n+\t7 for %edi (regno = 5)\n+\n+\t8  for FP_REGS[tos]   (regno = 8)\n+\t9  for FP_REGS[tos-1] (regno = 9)\n+\t10 for FP_REGS[tos-2] (regno = 10)\n+\t11 for FP_REGS[tos-3] (regno = 11)\n+\t12 for FP_REGS[tos-4] (regno = 12)\n+\t13 for FP_REGS[tos-5] (regno = 13)\n+\t14 for FP_REGS[tos-6] (regno = 14)\n+\t15 for FP_REGS[tos-7] (regno = 15)\n+*/\n+\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+((n) == 0 ? 0 \\\n+ : (n) == 1 ? 2 \\\n+ : (n) == 2 ? 1 \\\n+ : (n) == 3 ? 3 \\\n+ : (n) == 4 ? 6 \\\n+ : (n) == 5 ? 7 \\\n+ : (n) == 6 ? 5 \\\n+ : (n) == 7 ? 4 \\\n+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n) \\\n+ : (abort (), 0))\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register unsigned char *_ascii_bytes = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = _ascii_bytes + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register unsigned char *p;\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 64)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= STRING_LIMIT)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fputc ('\\n', (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"\\t.byte\\t\");\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfputc (',', (FILE));\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"0x%02x\", *_ascii_bytes);\t\t\\\n+\t      bytes_in_chunk += 5;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\n\");\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)"}]}