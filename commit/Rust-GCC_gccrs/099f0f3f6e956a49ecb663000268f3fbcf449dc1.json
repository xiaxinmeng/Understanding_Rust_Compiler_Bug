{"sha": "099f0f3f6e956a49ecb663000268f3fbcf449dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDk5ZjBmM2Y2ZTk1NmE0OWVjYjY2MzAwMDI2OGYzZmJjZjQ0OWRjMQ==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-12T04:09:43Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-12T04:09:43Z"}, "message": "loop.h (total_biv_increment): Constify iv_class pointer.\n\n\t* loop.h (total_biv_increment): Constify iv_class pointer.\n\t(struct induction): Replace `mem_mode' with `mem' rtx.\n\t* unroll.c (total_biv_increment): Constify iv_class pointer.\n\t* loop.c (loop_giv_reduce_benefit): Derive mem mode from mem rtx.\n\t(find_mem_givs, combine_givs_p): Likewise.\n\t(debug_ivs, debug_iv_class, loop_ivs_dump, loop_iv_class_dump): New.\n\nFrom-SVN: r38933", "tree": {"sha": "841c6f7f5a681573914b47a1f9d98af2f35d31ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/841c6f7f5a681573914b47a1f9d98af2f35d31ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/099f0f3f6e956a49ecb663000268f3fbcf449dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099f0f3f6e956a49ecb663000268f3fbcf449dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/099f0f3f6e956a49ecb663000268f3fbcf449dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/099f0f3f6e956a49ecb663000268f3fbcf449dc1/comments", "author": null, "committer": null, "parents": [{"sha": "69e905c854d301b0cbc0723a6fd232b2b3bc6e35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69e905c854d301b0cbc0723a6fd232b2b3bc6e35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69e905c854d301b0cbc0723a6fd232b2b3bc6e35"}], "stats": {"total": 138, "additions": 129, "deletions": 9}, "files": [{"sha": "078f431ac6ffed6c0510e0f4bf209f00c6c16e53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=099f0f3f6e956a49ecb663000268f3fbcf449dc1", "patch": "@@ -1,3 +1,12 @@\n+2001-01-12  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* loop.h (total_biv_increment): Constify iv_class pointer.\n+\t(struct induction): Replace `mem_mode' with `mem' rtx.\n+\t* unroll.c (total_biv_increment): Constify iv_class pointer.\n+\t* loop.c (loop_giv_reduce_benefit): Derive mem mode from mem rtx.\n+\t(find_mem_givs, combine_givs_p): Likewise.\n+\t(debug_ivs, debug_iv_class, loop_ivs_dump, loop_iv_class_dump): New.\n+\n 2001-01-10  Thomas Pfaff <tpfaff@gmx.net>\n \n \t* gthr-win32.h (__gthread_objc_thread_get_data): Save and restore Win32"}, {"sha": "37f0f260754da77e693369e791dd76a5e3aa8b9d", "filename": "gcc/loop.c", "status": "modified", "additions": 116, "deletions": 6, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=099f0f3f6e956a49ecb663000268f3fbcf449dc1", "patch": "@@ -199,6 +199,8 @@ static void record_biv PARAMS ((struct loop *, struct induction *,\n \t\t\t\tint, int));\n static void check_final_value PARAMS ((const struct loop *,\n \t\t\t\t       struct induction *));\n+static void loop_ivs_dump PARAMS((const struct loop *, FILE *, int));\n+static void loop_iv_class_dump PARAMS((const struct iv_class *, FILE *, int));\n static void loop_biv_dump PARAMS((const struct induction *, FILE *, int));\n static void loop_giv_dump PARAMS((const struct induction *, FILE *, int));\n static void record_giv PARAMS ((const struct loop *, struct induction *,\n@@ -256,6 +258,8 @@ static rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block,\n static rtx loop_insn_sink_or_swim PARAMS((const struct loop *, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n+void debug_ivs PARAMS ((const struct loop *));\n+void debug_iv_class PARAMS ((const struct iv_class *));\n void debug_biv PARAMS ((const struct induction *));\n void debug_giv PARAMS ((const struct induction *));\n void debug_loop PARAMS ((const struct loop *));\n@@ -4131,16 +4135,16 @@ loop_giv_reduce_benefit (loop, bl, v, test_reg)\n       && GET_CODE (v->mult_val) == CONST_INT)\n     {\n       if (HAVE_POST_INCREMENT\n-\t  && INTVAL (v->mult_val) == GET_MODE_SIZE (v->mem_mode))\n+\t  && INTVAL (v->mult_val) == GET_MODE_SIZE (GET_MODE (v->mem)))\n \tbenefit += add_cost * bl->biv_count;\n       else if (HAVE_PRE_INCREMENT\n-\t       && INTVAL (v->mult_val) == GET_MODE_SIZE (v->mem_mode))\n+\t       && INTVAL (v->mult_val) == GET_MODE_SIZE (GET_MODE (v->mem)))\n \tbenefit += add_cost * bl->biv_count;\n       else if (HAVE_POST_DECREMENT\n-\t       && -INTVAL (v->mult_val) == GET_MODE_SIZE (v->mem_mode))\n+\t       && -INTVAL (v->mult_val) == GET_MODE_SIZE (GET_MODE (v->mem)))\n \tbenefit += add_cost * bl->biv_count;\n       else if (HAVE_PRE_DECREMENT\n-\t       && -INTVAL (v->mult_val) == GET_MODE_SIZE (v->mem_mode))\n+\t       && -INTVAL (v->mult_val) == GET_MODE_SIZE (GET_MODE (v->mem)))\n \tbenefit += add_cost * bl->biv_count;\n     }\n #endif\n@@ -4718,7 +4722,7 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n \t\t\tadd_val, ext_val, benefit, DEST_ADDR,\n \t\t\tnot_every_iteration, maybe_multiple, &XEXP (x, 0));\n \n-\t    v->mem_mode = GET_MODE (x);\n+\t    v->mem = x;\n \t  }\n       }\n       return;\n@@ -6446,7 +6450,7 @@ combine_givs_p (g1, g2)\n      the expression of G2 in terms of G1 can be used.  */\n   if (ret != NULL_RTX\n       && g2->giv_type == DEST_ADDR\n-      && memory_address_p (g2->mem_mode, ret)\n+      && memory_address_p (GET_MODE (g2->mem), ret)\n       /* ??? Looses, especially with -fforce-addr, where *g2->location\n \t will always be a register, and so anything more complicated\n \t gets discarded.  */\n@@ -9506,6 +9510,96 @@ loop_insn_sink_or_swim (loop, pattern)\n     return loop_insn_sink (loop, pattern);\n }\n \f\n+static void\n+loop_ivs_dump (loop, file, verbose)\n+     const struct loop *loop;\n+     FILE *file;\n+     int verbose;\n+{\n+  struct iv_class *bl;\n+  int iv_num = 0;\n+\n+  if (! loop || ! file)\n+    return;\n+\n+  for (bl = LOOP_IVS (loop)->list; bl; bl = bl->next)\n+    iv_num++;\n+\n+  fprintf (file, \"Loop %d: %d IV classes\\n\", loop->num, iv_num);\n+\n+  for (bl = LOOP_IVS (loop)->list; bl; bl = bl->next)\n+    {\n+      loop_iv_class_dump (bl, file, verbose);\n+      fputc ('\\n', file);\n+    }\n+}\n+\n+\n+static void\n+loop_iv_class_dump (bl, file, verbose)\n+     const struct iv_class *bl;\n+     FILE *file;\n+     int verbose ATTRIBUTE_UNUSED;\n+{\n+  struct induction *v;\n+  rtx incr;\n+  int i;\n+\n+  if (! bl || ! file)\n+    return;\n+\n+  fprintf (file, \"IV class for reg %d, benefit %d\\n\",\n+\t   bl->regno, bl->total_benefit);\n+\n+  fprintf (file, \" Init insn %d\", INSN_UID (bl->init_insn));\n+  if (bl->initial_value)\n+    {\n+      fprintf (file, \", init val: \");\n+      print_simple_rtl (file, bl->initial_value);\n+    }\n+  if (bl->initial_test)\n+    {\n+      fprintf (file, \", init test: \");\n+      print_simple_rtl (file, bl->initial_test);\n+    }\n+  fputc ('\\n', file);\n+\n+  if (bl->final_value)\n+    {\n+      fprintf (file, \" Final val: \");\n+      print_simple_rtl (file, bl->final_value);\n+      fputc ('\\n', file);\n+    }\n+\n+  if ((incr = biv_total_increment (bl)))\n+    {\n+      fprintf (file, \" Total increment: \");\n+      print_simple_rtl (file, incr);\n+      fputc ('\\n', file);\n+    }\n+\n+  /* List the increments.  */\n+  for (i = 0, v = bl->biv; v; v = v->next_iv, i++)\n+    {\n+      fprintf (file, \" Inc%d: insn %d, incr: \", i, INSN_UID (v->insn));\n+      print_simple_rtl (file, v->add_val);\n+      fputc ('\\n', file);\n+    }\n+\n+  /* List the givs.  */\n+  for (i = 0, v = bl->giv; v; v = v->next_iv, i++)\n+    {\n+      fprintf (file, \" Giv%d: insn %d, benefit %d, \", \n+\t       i, INSN_UID (v->insn), v->benefit);\n+      if (v->giv_type == DEST_ADDR)\n+\t  print_simple_rtl (file, v->mem);\n+      else\n+\t  print_simple_rtl (file, single_set (v->insn));\n+      fputc ('\\n', file);\n+    }\n+}\n+\n+\n static void\n loop_biv_dump (v, file, verbose)\n      const struct induction *v;\n@@ -9596,6 +9690,22 @@ loop_giv_dump (v, file, verbose)\n }\n \n \n+void\n+debug_ivs (loop)\n+     const struct loop *loop;\n+{\n+  loop_ivs_dump (loop, stderr, 1);\n+}\n+\n+\n+void\n+debug_iv_class (bl)\n+     const struct iv_class *bl;\n+{\n+  loop_iv_class_dump (bl, stderr, 1);\n+}\n+\n+\n void\n debug_biv (v)\n      const struct induction *v;"}, {"sha": "1b4f24f1cdc04f928ba1ce2ec9b57ff7aeb6bb81", "filename": "gcc/loop.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=099f0f3f6e956a49ecb663000268f3fbcf449dc1", "patch": "@@ -87,7 +87,7 @@ struct induction\n \t\t\t\t/* For a biv, this is the place where add_val\n \t\t\t\t   was found.  */\n   enum machine_mode mode;\t/* The mode of this biv or giv */\n-  enum machine_mode mem_mode;\t/* For DEST_ADDR, mode of the memory object.  */\n+  rtx mem;\t\t\t/* For DEST_ADDR, the memory object.  */\n   rtx mult_val;\t\t\t/* Multiplicative factor for src_reg.  */\n   rtx add_val;\t\t\t/* Additive constant for that product.  */\n   int benefit;\t\t\t/* Gain from eliminating this insn.  */\n@@ -398,7 +398,7 @@ rtx express_from PARAMS ((struct induction *, struct induction *));\n rtx extend_value_for_giv PARAMS ((struct induction *, rtx));\n \n void unroll_loop PARAMS ((struct loop *, int, int));\n-rtx biv_total_increment PARAMS ((struct iv_class *));\n+rtx biv_total_increment PARAMS ((const struct iv_class *));\n unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n int precondition_loop_p PARAMS ((const struct loop *,\n \t\t\t\t rtx *, rtx *, rtx *,\n@@ -416,3 +416,4 @@ rtx loop_insn_hoist PARAMS((const struct loop *, rtx));\n \n /* Forward declarations for non-static functions declared in doloop.c.  */\n int doloop_optimize PARAMS ((const struct loop *));\n+rtx doloop_condition_get PARAMS ((rtx));"}, {"sha": "11be66d89cc15359c075ec50a6cffbb58e34a2a9", "filename": "gcc/unroll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/099f0f3f6e956a49ecb663000268f3fbcf449dc1/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=099f0f3f6e956a49ecb663000268f3fbcf449dc1", "patch": "@@ -2377,7 +2377,7 @@ fold_rtx_mult_add (mult1, mult2, add1, mode)\n \n rtx\n biv_total_increment (bl)\n-     struct iv_class *bl;\n+     const struct iv_class *bl;\n {\n   struct induction *v;\n   rtx result;"}]}