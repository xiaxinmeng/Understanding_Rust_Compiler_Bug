{"sha": "0038aea6483e8378c4aadcac6876c73fc3eeb01d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAzOGFlYTY0ODNlODM3OGM0YWFkY2FjNjg3NmM3M2ZjM2VlYjAxZA==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:55:52Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1993-10-03T23:55:52Z"}, "message": "(LONG_DOUBLE_TYPE_SIZE): Define as 96.\n\n(FIXED_REGISTERS): If XFmode enabled, hard reg st7 is fixed.\n(ASM_OUTPUT_DOUBLE): Use REAL_VALUE_... macros.\n(ASM_OUTPUT_FLOAT): Likewise.\n(ASM_OUTPUT_LONG_DOUBLE): New macro.\n(PRINT_REG):  Add size case 12.\n(DEBUG_PRINT_REG):  Likewise.\n\nFrom-SVN: r5572", "tree": {"sha": "6daaccd523320005b9ec87ea753b8253cc735906", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6daaccd523320005b9ec87ea753b8253cc735906"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0038aea6483e8378c4aadcac6876c73fc3eeb01d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0038aea6483e8378c4aadcac6876c73fc3eeb01d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0038aea6483e8378c4aadcac6876c73fc3eeb01d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0038aea6483e8378c4aadcac6876c73fc3eeb01d/comments", "author": null, "committer": null, "parents": [{"sha": "5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f1ec3e625e734ce2d9f8d9f91c458c7766102eb"}], "stats": {"total": 57, "additions": 48, "deletions": 9}, "files": [{"sha": "4b17b48db841cda8cd67db4fd12f25581e5dcdec", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0038aea6483e8378c4aadcac6876c73fc3eeb01d/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0038aea6483e8378c4aadcac6876c73fc3eeb01d/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=0038aea6483e8378c4aadcac6876c73fc3eeb01d", "patch": "@@ -130,6 +130,15 @@ extern int target_flags;\n \f\n /* target machine storage layout */\n \n+/* Define for XFmode extended real floating point support.\n+   This will automatically cause REAL_ARITHMETIC to be defined.  */\n+#define LONG_DOUBLE_TYPE_SIZE 96\n+\n+/* Define if you don't want extended real, but do want to use the\n+   software floating point emulator for REAL_ARITHMETIC and\n+   decimal <-> binary conversion. */\n+/* #define REAL_ARITHMETIC */\n+\n /* Define this if most significant byte of a word is the lowest numbered.  */\n /* That is true on the 80386.  */\n \n@@ -229,9 +238,18 @@ extern int target_flags;\n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer. */\n+#if LONG_DOUBLE_TYPE_SIZE == 96\n+/* In XFmode, operands have to be loaded into an fp register.\n+ * The easy way to handle this is to declare one register not\n+ * available.  */\n+#define FIXED_REGISTERS \\\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/       \\\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  1,  1 }\n+#else\n #define FIXED_REGISTERS \\\n /*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg*/       \\\n {  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1 }\n+#endif\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -288,7 +306,7 @@ extern int target_flags;\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((REGNO) < 2 ? 1\t\t\t\t\t\t\\\n    : (REGNO) < 4 ? 1\t\t\t\t\t\t\\\n-   : FP_REGNO_P ((REGNO))\t\t\t\t\t\\\n+   : FP_REGNO_P (REGNO)\t\t\t\t\t\t\\\n    ? (((int) GET_MODE_CLASS (MODE) == (int) MODE_FLOAT\t\t\\\n        || (int) GET_MODE_CLASS (MODE) == (int) MODE_COMPLEX_FLOAT)\t\\\n       && GET_MODE_UNIT_SIZE (MODE) <= 12)\t\t\t\\\n@@ -1372,19 +1390,38 @@ number as al, and ax.\n \n /* This is how to output an assembler line defining a `double' constant.  */\n \n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"%s %.22e\\n\", ASM_DOUBLE, (VALUE))\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\t\\\n+do { long l[2];\t\t\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%x,0x%x\\n\", ASM_LONG, l[0], l[1]);\t\t\\\n+     else\t\t\t\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1]);\t\\\n+   } while (0)\n \n+/* This is how to output a `long double' extended real constant. */\n+\n+#undef ASM_OUTPUT_LONG_DOUBLE\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)  \t\t\\\n+do { long l[3];\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\\\n+       fprintf (FILE, \"%s 0x%x,0x%x,0x%x\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+     else\t\t\t\t\t\t\\\n+       fprintf (FILE, \"%s 0x%lx,0x%lx,0x%lx\\n\", ASM_LONG, l[0], l[1], l[2]); \\\n+   } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n \n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-do { union { float f; long l;} tem;\t\t\t\\\n-     tem.f = (VALUE);\t\t\t\t\t\\\n-     fprintf((FILE), \"%s 0x%x\\n\", ASM_LONG, tem.l);\t\\\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+do { long l;\t\t\t\t\t\t\\\n+     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\\\n+     if (sizeof (int) == sizeof (long))\t\t\t\\\n+       fprintf ((FILE), \"%s 0x%x\\n\", ASM_LONG, l);\t\\\n+     else\t\t\t\t\t\t\\\n+       fprintf ((FILE), \"%s 0x%lx\\n\", ASM_LONG, l);\t\\\n    } while (0)\n \n-\n /* Store in OUTPUT a string (made with alloca) containing\n    an assembler-name for a local static variable named NAME.\n    LABELNO is an integer which is different for each call.  */\n@@ -1478,7 +1515,7 @@ do { union { float f; long l;} tem;\t\t\t\\\n \n    On the 80386, we use several such letters:\n    f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n-   L,W,B,Q,S -- print the opcode suffix for specified size of operand.\n+   L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    * -- print a star (in certain assembler syntax)\n@@ -1519,6 +1556,7 @@ extern char *qi_high_reg_name[];\n \t     }\t\t\t\t\t\t\\\n \t case 4:\t\t\t\t\t\\\n \t case 8:\t\t\t\t\t\\\n+\t case 12:\t\t\t\t\t\\\n \t   if (! FP_REG_P (X)) fputs (\"e\", FILE);\t\\\n \t case 2:\t\t\t\t\t\\\n \t   fputs (hi_reg_name[REGNO (X)], FILE);\t\\\n@@ -1553,6 +1591,7 @@ extern char *qi_high_reg_name[];\n \t { fputs (\"st(0)\", FILE); break; }\t\t\\\n        switch (GET_MODE_SIZE (GET_MODE (X)))\t\t\\\n \t {\t\t\t\t\t\t\\\n+\t case 12:\t\t\t\t\t\\\n \t case 8:\t\t\t\t\t\\\n \t case 4:\t\t\t\t\t\\\n \t   if (! FP_REG_P (X)) fputs (\"e\", FILE);\t\\"}]}