{"sha": "01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiYmY3NzdkM2QyMGYzM2NhOTg5ZmYxNjY1ZGVkOWY1OWNlY2E1ZA==", "commit": {"author": {"name": "Andreas Schwab", "email": "schwab@suse.de", "date": "2004-02-08T23:30:49Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2004-02-08T23:30:49Z"}, "message": "m68k.h (REGISTER_NAMES): Prefix each name with REGISTER_PREFIX.\n\n\t* config/m68k/m68k.h (REGISTER_NAMES): Prefix each name with\n\tREGISTER_PREFIX.\n\t* (M68K_FP_REG_NAME): New macro to specify an alternate name for the\n\tframe pointer register, overridable by OS targets.\n\t* (M68K_REGNAME): Macro to obtain register name for asm output,\n\teventually replacing %a6 with M68K_FP_REG_NAME.\n\t* config/m68k/coff.h (REGISTER_NAMES): Don't redefine.\n\t* config/m68k/linux.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/m68kelf.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/netbsd-elf.h (REGISTER_NAMES): Likewise.\n\t* config/m68k/m68k.c: Use M68K_REGNAME(x) in place of reg_names[x].\n\nCo-Authored-By: Bernardo Innocenti <bernie@develer.com>\n\nFrom-SVN: r77510", "tree": {"sha": "743f1a91400069b289ddf12cc75ac96ce6e17564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/743f1a91400069b289ddf12cc75ac96ce6e17564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/comments", "author": {"login": "andreas-schwab", "id": 2175493, "node_id": "MDQ6VXNlcjIxNzU0OTM=", "avatar_url": "https://avatars.githubusercontent.com/u/2175493?v=4", "gravatar_id": "", "url": "https://api.github.com/users/andreas-schwab", "html_url": "https://github.com/andreas-schwab", "followers_url": "https://api.github.com/users/andreas-schwab/followers", "following_url": "https://api.github.com/users/andreas-schwab/following{/other_user}", "gists_url": "https://api.github.com/users/andreas-schwab/gists{/gist_id}", "starred_url": "https://api.github.com/users/andreas-schwab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/andreas-schwab/subscriptions", "organizations_url": "https://api.github.com/users/andreas-schwab/orgs", "repos_url": "https://api.github.com/users/andreas-schwab/repos", "events_url": "https://api.github.com/users/andreas-schwab/events{/privacy}", "received_events_url": "https://api.github.com/users/andreas-schwab/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f934561e186242fa50b310db4e883f7c56bde18a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f934561e186242fa50b310db4e883f7c56bde18a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f934561e186242fa50b310db4e883f7c56bde18a"}], "stats": {"total": 181, "additions": 75, "deletions": 106}, "files": [{"sha": "081055e9b2a16d7bed7670ad794a8e2b164827c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -1,3 +1,18 @@\n+2004-02-08  Andreas Schwab  <schwab@suse.de>\n+            Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k.h (REGISTER_NAMES): Prefix each name with\n+\tREGISTER_PREFIX.\n+\t* (M68K_FP_REG_NAME): New macro to specify an alternate name for the\n+\tframe pointer register, overridable by OS targets.\n+\t* (M68K_REGNAME): Macro to obtain register name for asm output,\n+\teventually replacing %a6 with M68K_FP_REG_NAME.\n+\t* config/m68k/coff.h (REGISTER_NAMES): Don't redefine.\n+\t* config/m68k/linux.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/m68kelf.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/netbsd-elf.h (REGISTER_NAMES): Likewise.\n+\t* config/m68k/m68k.c: Use M68K_REGNAME(x) in place of reg_names[x].\n+\n 2004-02-08  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* target-def.h (TARGET_STRUCT_VALUE_RTX): Define as"}, {"sha": "c2502c1497de1fd907385b19cc5a9cda873987a9", "filename": "gcc/config/m68k/coff.h", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcoff.h?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler.\n    m68k series COFF object files and debugging, version.\n-   Copyright (C) 1994, 1996, 1997, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1994, 1996, 1997, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -68,14 +68,6 @@ Boston, MA 02111-1307, USA.  */\n       return \"jmp %%pc@(2,%0:w)\";\t\t\t\\\n   } while (0)\n \n-/* Here are the new register names.  */\n-\n-#undef REGISTER_NAMES\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\",\t\\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\",\t\\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \"argptr\" }\n-\n #define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n \n /* If defined, a C expression whose value is a string containing the"}, {"sha": "88d75f6d6927970184216abefdc6aae414e3f8eb", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for Motorola 68k running Linux-based GNU systems with\n    ELF format.\n-   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -59,17 +59,6 @@ Boston, MA 02111-1307, USA.  */\n \n #define ASM_COMMENT_START \"|\"\n \n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number.\n-   Motorola format uses different register names than defined in m68k.h.  */\n-\n-#undef REGISTER_NAMES\n-\n-#define REGISTER_NAMES \\\n-{\"%d0\", \"%d1\", \"%d2\", \"%d3\", \"%d4\", \"%d5\", \"%d6\", \"%d7\", \\\n- \"%a0\", \"%a1\", \"%a2\", \"%a3\", \"%a4\", \"%a5\", \"%a6\", \"%sp\", \\\n- \"%fp0\", \"%fp1\", \"%fp2\", \"%fp3\", \"%fp4\", \"%fp5\", \"%fp6\", \"%fp7\", \"argptr\" }\n-\n #undef SIZE_TYPE\n #define SIZE_TYPE \"unsigned int\"\n  "}, {"sha": "9f545f81cd904318c2a19ed313f6d6eaedba88f9", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -499,25 +499,25 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \tfprintf (stream, MOTOROLA ?\n \t\t\t   \"\\tpea (%s)\\n\\tmove.l %s,%s\\n\" :\n \t\t\t   \"\\tpea %s@\\n\\tmovel %s,%s\\n\",\n-\t\t reg_names[FRAME_POINTER_REGNUM],\n-\t\t reg_names[STACK_POINTER_REGNUM],\n-\t\t reg_names[FRAME_POINTER_REGNUM]);\n+\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t M68K_REGNAME(STACK_POINTER_REGNUM),\n+\t\t M68K_REGNAME(FRAME_POINTER_REGNUM));\n       else if (fsize_with_regs < 0x8000)\n \tasm_fprintf (stream, \"\\tlink\" ASM_DOTW \" %s,%I%wd\\n\",\n-\t\t     reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n+\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n       else if (TARGET_68020)\n \tasm_fprintf (stream, \"\\tlink\" ASM_DOTL \" %s,%I%wd\\n\",\n-\t\t     reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n+\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n       else\n \t/* Adding negative number is faster on the 68040.  */\n \tasm_fprintf (stream, \"\\tlink\" ASM_DOTW \" %s,%I0\\n\"\n \t\t\t     \"\\tadd\" ASM_DOT \"l %I%wd,%Rsp\\n\",\n-\t\t     reg_names[FRAME_POINTER_REGNUM], -fsize_with_regs);\n+\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM), -fsize_with_regs);\n \n       if (dwarf2out_do_frame ())\n \t{\n \t  char *l;\n-          l = (char *) dwarf2out_cfi_label ();   \n+          l = (char *) dwarf2out_cfi_label ();\n \t  cfa_offset += 4;\n \t  dwarf2out_reg_save (l, FRAME_POINTER_REGNUM, -cfa_offset);\n \t  dwarf2out_def_cfa (l, FRAME_POINTER_REGNUM, cfa_offset);\n@@ -585,17 +585,17 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t}\n     }\n \n-  /* If the stack limit is not a symbol, check it here.  \n+  /* If the stack limit is not a symbol, check it here.\n      This has the disadvantage that it may be too late...  */\n   if (current_function_limit_stack)\n     {\n       if (REG_P (stack_limit_rtx))\n \tasm_fprintf (stream, \"\\tcmp\" ASM_DOT \"l %s,%Rsp\\n\\ttrapcs\\n\",\n-\t\t     reg_names[REGNO (stack_limit_rtx)]);\n+\t\t     M68K_REGNAME(REGNO (stack_limit_rtx)));\n       else if (GET_CODE (stack_limit_rtx) != SYMBOL_REF)\n \twarning (\"stack limit expression is not supported\");\n     }\n-  \n+\n   if (current_frame.reg_no <= 2)\n     {\n       /* Store each separately in the same order moveml uses.\n@@ -611,22 +611,22 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t    asm_fprintf (stream, MOTOROLA ?\n \t\t\t\t   \"\\t%Omove.l %s,-(%Rsp)\\n\" :\n \t\t\t\t   \"\\tmovel %s,%Rsp@-\\n\",\n-\t\t\t reg_names[15 - i]);\n+\t\t\t M68K_REGNAME(15 - i));\n \t    if (dwarf2out_do_frame ())\n \t      {\n \t\tchar *l = (char *) dwarf2out_cfi_label ();\n \n \t\tcfa_offset += 4;\n- \t\tif (! frame_pointer_needed)\n- \t\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n- \t\tdwarf2out_reg_save (l, 15 - i, -cfa_offset);\n+\t\tif (! frame_pointer_needed)\n+\t\t  dwarf2out_def_cfa (l, STACK_POINTER_REGNUM, cfa_offset);\n+\t\tdwarf2out_reg_save (l, 15 - i, -cfa_offset);\n \t      }\n \t  }\n     }\n   else if (current_frame.reg_rev_mask)\n     {\n       if (TARGET_COLDFIRE)\n-\t/* The ColdFire does not support the predecrement form of the \n+\t/* The ColdFire does not support the predecrement form of the\n \t   MOVEM instruction, so we must adjust the stack pointer and\n \t   then use the plain address register indirect mode.\n \t   The required register save space was combined earlier with\n@@ -661,22 +661,22 @@ m68k_output_function_prologue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n       if (TARGET_ID_SHARED_LIBRARY)\n \t{\n \t  asm_fprintf (stream, \"\\tmovel %s@(%s), %s\\n\",\n-\t\t       reg_names[PIC_OFFSET_TABLE_REGNUM],\n+\t\t       M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM),\n \t\t       m68k_library_id_string,\n-\t\t       reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t\t       M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n \t}\n       else\n \t{\n \t  if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\t%Olea (%Rpc, %U_GLOBAL_OFFSET_TABLE_@GOTPC), %s\\n\",\n-\t    \t\t reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t\t\t M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n \t  else\n \t    {\n \t      asm_fprintf (stream, \"\\tmovel %I%U_GLOBAL_OFFSET_TABLE_, %s\\n\",\n-\t\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n \t      asm_fprintf (stream, \"\\tlea %Rpc@(0,%s:l),%s\\n\",\n-\t\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM],\n-\t\t\t   reg_names[PIC_OFFSET_TABLE_REGNUM]);\n+\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM),\n+\t\t\t   M68K_REGNAME(PIC_OFFSET_TABLE_REGNUM));\n \t    }\n \t}\n     }\n@@ -779,31 +779,31 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t\tif (MOTOROLA)\n \t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s,%Ra1.l),%s\\n\",\n \t\t\t       offset,\n-\t\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t       reg_names[i]);\n+\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME(i));\n \t\telse\n \t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd,%Ra1:l),%s\\n\",\n-\t\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t       offset,\n-\t\t\t       reg_names[i]);\n+\t\t\t       M68K_REGNAME(i));\n \t      }\n             else if (restore_from_sp)\n \t      asm_fprintf (stream, MOTOROLA ?\n \t\t\t\t     \"\\t%Omove.l (%Rsp)+,%s\\n\" :\n \t\t\t\t     \"\\tmovel %Rsp@+,%s\\n\",\n-\t\t\t   reg_names[i]);\n+\t\t\t   M68K_REGNAME(i));\n             else\n \t      {\n \t        if (MOTOROLA)\n \t\t  asm_fprintf (stream, \"\\t%Omove.l -%wd(%s),%s\\n\",\n \t\t\t       offset,\n-\t\t\t       reg_names[FRAME_POINTER_REGNUM],\n-\t\t\t       reg_names[i]);\n+\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n+\t\t\t       M68K_REGNAME(i));\n \t\telse\n \t\t  asm_fprintf (stream, \"\\tmovel %s@(-%wd),%s\\n\",\n-\t\t\t       reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t       M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t       offset,\n-\t\t\t       reg_names[i]);\n+\t\t\t       M68K_REGNAME(i));\n \t      }\n             offset -= 4;\n           }\n@@ -816,7 +816,7 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n           if (big)\n             {\n               asm_fprintf (stream, \"\\tadd\" ASM_DOT \"l %s,%Ra1\\n\",\n-\t      \t\t   reg_names[FRAME_POINTER_REGNUM]);\n+\t\t\t   M68K_REGNAME(FRAME_POINTER_REGNUM));\n               asm_fprintf (stream, MOTOROLA ?\n \t\t\t\t     \"\\tmovm.l (%Ra1),%I0x%x\\n\" :\n \t\t\t\t     \"\\tmoveml %Ra1@,%I0x%x\\n\",\n@@ -832,11 +832,11 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n@@ -848,11 +848,11 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s,%Ra1.l),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n@@ -868,11 +868,11 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t      if (MOTOROLA)\n \t\tasm_fprintf (stream, \"\\tmovm.l -%wd(%s),%I0x%x\\n\",\n \t\t\t     current_frame.offset + fsize,\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.reg_mask);\n \t      else\n \t\tasm_fprintf (stream, \"\\tmoveml %s@(-%wd),%I0x%x\\n\",\n-\t\t\t     reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t     M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t     current_frame.offset + fsize,\n \t\t\t     current_frame.reg_mask);\n \t    }\n@@ -885,11 +885,11 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t  if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s,%Ra1.l),%I0x%x\\n\",\n \t\t         current_frame.foffset + fsize,\n-\t\t         reg_names[FRAME_POINTER_REGNUM],\n+\t\t         M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t         current_frame.fpu_rev_mask);\n \t  else\n \t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd,%Ra1:l),%I0x%x\\n\",\n-\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t current_frame.foffset + fsize,\n \t\t\t current_frame.fpu_rev_mask);\n \t}\n@@ -907,18 +907,17 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n \t  if (MOTOROLA)\n \t    asm_fprintf (stream, \"\\tfmovm -%wd(%s),%I0x%x\\n\",\n \t\t\t current_frame.foffset + fsize,\n-\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t current_frame.fpu_rev_mask);\n \t  else\n \t    asm_fprintf (stream, \"\\tfmovem %s@(-%wd),%I0x%x\\n\",\n-\t\t\t reg_names[FRAME_POINTER_REGNUM],\n+\t\t\t M68K_REGNAME(FRAME_POINTER_REGNUM),\n \t\t\t current_frame.foffset + fsize,\n \t\t\t current_frame.fpu_rev_mask);\n \t}\n     }\n   if (frame_pointer_needed)\n-    fprintf (stream, \"\\tunlk %s\\n\",\n-\t     reg_names[FRAME_POINTER_REGNUM]);\n+    fprintf (stream, \"\\tunlk %s\\n\", M68K_REGNAME(FRAME_POINTER_REGNUM));\n   else if (fsize_with_regs)\n     {\n       if (fsize_with_regs <= 8)\n@@ -2707,7 +2706,7 @@ print_operand (FILE *file, rtx op, int letter)\n     {\n       /* This is only for direct addresses with TARGET_PCREL */\n       if (GET_CODE (op) != MEM || GET_CODE (XEXP (op, 0)) != SYMBOL_REF\n-          || !TARGET_PCREL) \n+          || !TARGET_PCREL)\n \tabort ();\n       output_addr_const (file, XEXP (op, 0));\n     }\n@@ -2716,9 +2715,9 @@ print_operand (FILE *file, rtx op, int letter)\n       if (letter == 'R')\n \t/* Print out the second register name of a register pair.\n \t   I.e., R (6) => 7.  */\n-\tfputs (reg_names[REGNO (op) + 1], file);\n+\tfputs (M68K_REGNAME(REGNO (op) + 1), file);\n       else\n-\tfputs (reg_names[REGNO (op)], file);\n+\tfputs (M68K_REGNAME(REGNO (op)), file);\n     }\n   else if (GET_CODE (op) == MEM)\n     {\n@@ -2816,15 +2815,15 @@ print_operand_address (FILE *file, rtx addr)\n   switch (GET_CODE (addr))\n     {\n       case REG:\n-\tfprintf (file, MOTOROLA ? \"(%s)\" : \"%s@\", reg_names[REGNO (addr)]);\n+\tfprintf (file, MOTOROLA ? \"(%s)\" : \"%s@\", M68K_REGNAME(REGNO (addr)));\n \tbreak;\n       case PRE_DEC:\n \tfprintf (file, MOTOROLA ? \"-(%s)\" : \"%s@-\",\n-\t         reg_names[REGNO (XEXP (addr, 0))]);\n+\t         M68K_REGNAME(REGNO (XEXP (addr, 0))));\n \tbreak;\n       case POST_INC:\n \tfprintf (file, MOTOROLA ? \"(%s)+\" : \"%s@+\",\n-\t\t reg_names[REGNO (XEXP (addr, 0))]);\n+\t\t M68K_REGNAME(REGNO (XEXP (addr, 0))));\n \tbreak;\n       case PLUS:\n \treg1 = reg2 = ireg = breg = offset = 0;\n@@ -2933,14 +2932,14 @@ print_operand_address (FILE *file, rtx addr)\n \t      {\n \t\tASM_OUTPUT_CASE_FETCH (file,\n \t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (XEXP (ireg, 0))]);\n+\t\t\t     M68K_REGNAME(REGNO (XEXP (ireg, 0))));\n \t\tfprintf (file, \"w\");\n \t      }\n \t    else\n \t      {\n \t\tASM_OUTPUT_CASE_FETCH (file,\n \t\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t     reg_names[REGNO (ireg)]);\n+\t\t\t     M68K_REGNAME(REGNO (ireg)));\n \t\tfprintf (file, \"l\");\n \t      }\n \t    if (scale != 1)\n@@ -2953,7 +2952,7 @@ print_operand_address (FILE *file, rtx addr)\n \t  {\n \t    ASM_OUTPUT_CASE_FETCH (file,\n \t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (breg)]);\n+\t\t\t M68K_REGNAME(REGNO (breg)));\n \t    fprintf (file, \"l)\");\n \t    break;\n \t  }\n@@ -2980,13 +2979,13 @@ print_operand_address (FILE *file, rtx addr)\n \t\t\t  fprintf (file, \".w\");\n \t\t      }\n \t\t  }\n-\t\tfprintf (file, \"(%s\", reg_names[REGNO (breg)]);\n+\t\tfprintf (file, \"(%s\", M68K_REGNAME(REGNO (breg)));\n \t\tif (ireg != 0)\n \t\t  putc (',', file);\n \t      }\n \t    else /* !MOTOROLA */\n \t      {\n-\t\tfprintf (file, \"%s@(\", reg_names[REGNO (breg)]);\n+\t\tfprintf (file, \"%s@(\", M68K_REGNAME(REGNO (breg)));\n \t\tif (addr != 0)\n \t\t  {\n \t\t    output_addr_const (file, addr);\n@@ -3011,21 +3010,21 @@ print_operand_address (FILE *file, rtx addr)\n \t      }\n \t    if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\n \t      fprintf (file, MOTOROLA ? \"%s.w\" : \"%s:w\",\n-\t\t       reg_names[REGNO (XEXP (ireg, 0))]);\n+\t\t       M68K_REGNAME(REGNO (XEXP (ireg, 0))));\n \t    else if (ireg != 0)\n \t      fprintf (file, MOTOROLA ? \"%s.l\" : \"%s:l\",\n-\t\t       reg_names[REGNO (ireg)]);\n+\t\t       M68K_REGNAME(REGNO (ireg)));\n \t    if (scale != 1)\n \t      fprintf (file, MOTOROLA ? \"*%d\" : \":%d\", scale);\n \t    putc (')', file);\n \t    break;\n \t  }\n \telse if (reg1 != 0 && GET_CODE (addr) == LABEL_REF\n-\t\t && ! (flag_pic && reg1 == pic_offset_table_rtx))\t\n+\t\t && ! (flag_pic && reg1 == pic_offset_table_rtx))\n \t  {\n \t    ASM_OUTPUT_CASE_FETCH (file,\n \t\t\t CODE_LABEL_NUMBER (XEXP (addr, 0)),\n-\t\t\t reg_names[REGNO (reg1)]);\n+\t\t\t M68K_REGNAME(REGNO (reg1)));\n \t    fprintf (file, \"l)\");\n \t    break;\n \t  }"}, {"sha": "b65315efc32acd9c53a89e6b6ff947ba29ed8976", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -1,5 +1,4 @@\n-/* Definitions of target machine for GNU compiler.\n-   Sun 68000/68020 version.\n+/* Definitions of target machine for GCC for Motorola 680x0/ColdFire.\n    Copyright (C) 1987, 1988, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n    2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n "}, {"sha": "2ac5ceb16068015c6abade70b1a33464c8da9d82", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -78,18 +78,6 @@ Boston, MA 02111-1307, USA.  */\n       return \"jmp %%pc@(2,%0:w)\";\t\t\t\\\n   } while (0)\n \n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number.\n-   Motorola format uses different register names than defined \n-   in m68k.h.  */\n-\n-#undef REGISTER_NAMES\n-\n-#define REGISTER_NAMES \\\n-{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t     \\\n- \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%a6\",   \"%sp\",\t     \\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\", \"argptr\" }\n-\n /* This is how to output an assembler line that says to advance the\n    location counter to a multiple of 2**LOG bytes.  */\n "}, {"sha": "ecb1469f995f83b318caac3ed3c0e8fee9312752", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01bbf777d3d20f33ca989ff1665ded9f59ceca5d/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=01bbf777d3d20f33ca989ff1665ded9f59ceca5d", "patch": "@@ -175,19 +175,6 @@ while (0)\n #define ASM_COMMENT_START \"|\"\n \n \n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number.\n-   Motorola format uses different register names than defined in m68k.h.\n-   We also take this chance to convert 'a6' to 'fp' */\n-\n-#undef REGISTER_NAMES\n-\n-#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n-{\"%d0\",   \"%d1\",   \"%d2\",   \"%d3\",   \"%d4\",   \"%d5\",   \"%d6\",   \"%d7\",\t\\\n- \"%a0\",   \"%a1\",   \"%a2\",   \"%a3\",   \"%a4\",   \"%a5\",   \"%fp\",   \"%sp\",\t\\\n- \"%fp0\",  \"%fp1\",  \"%fp2\",  \"%fp3\",  \"%fp4\",  \"%fp5\",  \"%fp6\",  \"%fp7\", \"argptr\" }\n-\n-\n /* Currently, JUMP_TABLES_IN_TEXT_SECTION must be defined in order to\n    keep switch tables in the text section.  */\n "}]}