{"sha": "c97e511d3174ec7aef16040f5325c6d14fb36f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzk3ZTUxMWQzMTc0ZWM3YWVmMTYwNDBmNTMyNWM2ZDE0ZmIzNmY0OA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-12-09T16:57:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-12-09T16:57:27Z"}, "message": "re GNATS libgcj/117 (_Jv_PthreadCheckMonitor test is not portable.)\n\n\t* include/posix-threads.h (_Jv_PthreadCheckMonitor): Handle case\n\twhere no recursive mutexes exist.  Fixes PR libgcj/117.\n\nFrom-SVN: r30847", "tree": {"sha": "4231bf239e6de9f15ba3e4439ad11be8daa49b95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4231bf239e6de9f15ba3e4439ad11be8daa49b95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c97e511d3174ec7aef16040f5325c6d14fb36f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97e511d3174ec7aef16040f5325c6d14fb36f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c97e511d3174ec7aef16040f5325c6d14fb36f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c97e511d3174ec7aef16040f5325c6d14fb36f48/comments", "author": null, "committer": null, "parents": [{"sha": "47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47841d1be3e21d53cf85ba05acc1e2cc2e9c6069"}], "stats": {"total": 24, "additions": 22, "deletions": 2}, "files": [{"sha": "36559ba87062d8fb1e44131c422219ca74eabee0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97e511d3174ec7aef16040f5325c6d14fb36f48/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97e511d3174ec7aef16040f5325c6d14fb36f48/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c97e511d3174ec7aef16040f5325c6d14fb36f48", "patch": "@@ -1,3 +1,8 @@\n+1999-12-08  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* include/posix-threads.h (_Jv_PthreadCheckMonitor): Handle case\n+\twhere no recursive mutexes exist.  Fixes PR libgcj/117.\n+\n 1999-12-05  Anthony Green  <green@cygnus.com>\n \n \t* include/jvm.h: Declare many functions with"}, {"sha": "4785ff8e96ae7fc0b5914ab8653976d4fdbfca24", "filename": "libjava/include/posix-threads.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c97e511d3174ec7aef16040f5325c6d14fb36f48/libjava%2Finclude%2Fposix-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c97e511d3174ec7aef16040f5325c6d14fb36f48/libjava%2Finclude%2Fposix-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fposix-threads.h?ref=c97e511d3174ec7aef16040f5325c6d14fb36f48", "patch": "@@ -99,14 +99,18 @@ _Jv_PthreadGetMutex (_Jv_Mutex_t *mu)\n // This is a convenience function used only by the pthreads thread\n // implementation.  This is slow, but that's too bad -- we need to do\n // the checks for correctness.  It might be nice to be able to compile\n-// this out.\n+// this out.  Returns 0 if the lock is held by the current thread, and\n+// 1 otherwise.\n inline int\n _Jv_PthreadCheckMonitor (_Jv_Mutex_t *mu)\n {\n-  pthread_mutex_t *pmu = _Jv_PthreadGetMutex (mu);\n+  pthread_mutex_t *pmu;\n+#ifdef HAVE_RECURSIVE_MUTEX\n+  pmu = _Jv_PthreadGetMutex (mu);\n   // See if the mutex is locked by this thread.\n   if (pthread_mutex_trylock (pmu))\n     return 1;\n+\n #if defined (PTHREAD_MUTEX_HAVE_M_COUNT)\n   // On Linux we exploit knowledge of the implementation.\n   int r = pmu->m_count == 1;\n@@ -117,6 +121,17 @@ _Jv_PthreadCheckMonitor (_Jv_Mutex_t *mu)\n #else\n   int r = mu->count == 0;\n #endif\n+\n+#else /* HAVE_RECURSIVE_MUTEX */\n+  // In this case we must lock our structure and then see if this\n+  // thread owns the mutex.\n+  pmu = &mu->mutex;\n+  if (pthread_mutex_lock (pmu))\n+    return 1;\n+\n+  int r = mu->thread != pthread_self () || mu->count == 0;\n+#endif /* HAVE_RECURSIVE_MUTEX */\n+\n   pthread_mutex_unlock (pmu);\n   return r;\n }"}]}