{"sha": "9af66e5830a1888d76709605008c8e102cf478f8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmNjZlNTgzMGExODg4ZDc2NzA5NjA1MDA4YzhlMTAyY2Y0NzhmOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-05-13T10:32:04Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-05-13T10:32:04Z"}, "message": "arm.md (compare_scc): Use shorter sequence for EQ case.\n\n* arm.md (compare_scc): Use shorter sequence for EQ case.\n(ior_scc_scc_cmp, and_scc_scc_cmp): New insn-and-split patterns.\n(and_scc_scc): Ensure split only applies when there is a dominance\nof the comparisons.\n(and_scc_scc_nodom): New insn-and-split pattern.\n\nFrom-SVN: r66757", "tree": {"sha": "5340c931833e6415a66bc6a9caebf64a016905f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5340c931833e6415a66bc6a9caebf64a016905f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af66e5830a1888d76709605008c8e102cf478f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af66e5830a1888d76709605008c8e102cf478f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af66e5830a1888d76709605008c8e102cf478f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af66e5830a1888d76709605008c8e102cf478f8/comments", "author": null, "committer": null, "parents": [{"sha": "c6f824e248c6552e593590be4107633e1cf266c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f824e248c6552e593590be4107633e1cf266c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f824e248c6552e593590be4107633e1cf266c7"}], "stats": {"total": 124, "additions": 117, "deletions": 7}, "files": [{"sha": "1dcd80d57743e548a2b585c61c387cb3a9b0d402", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af66e5830a1888d76709605008c8e102cf478f8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af66e5830a1888d76709605008c8e102cf478f8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9af66e5830a1888d76709605008c8e102cf478f8", "patch": "@@ -1,3 +1,11 @@\n+2003-05-13  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.md (compare_scc): Use shorter sequence for EQ case.\n+\t(ior_scc_scc_cmp, and_scc_scc_cmp): New insn-and-split patterns.\n+\t(and_scc_scc): Ensure split only applies when there is a dominance\n+\tof the comparisons.\n+\t(and_scc_scc_nodom): New insn-and-split pattern.\n+\n 2003-05-13  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* unwind-dw2.c (uw_init_context_1): Don't pass &outer_cfa directly"}, {"sha": "6fb75d0d93dbe059ee018dd7506020a6958073ca", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 109, "deletions": 7, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af66e5830a1888d76709605008c8e102cf478f8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af66e5830a1888d76709605008c8e102cf478f8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=9af66e5830a1888d76709605008c8e102cf478f8", "patch": "@@ -6517,11 +6517,17 @@\n    (clobber (reg:CC CC_REGNUM))]\n   \"TARGET_ARM\"\n   \"*\n-    if (GET_CODE (operands[1]) == LT && operands[3] == const0_rtx)\n-      return \\\"mov\\\\t%0, %2, lsr #31\\\";\n+    if (operands[3] == const0_rtx)\n+      {\n+\tif (GET_CODE (operands[1]) == LT)\n+\t  return \\\"mov\\\\t%0, %2, lsr #31\\\";\n+\n+\tif (GET_CODE (operands[1]) == GE)\n+\t  return \\\"mvn\\\\t%0, %2\\;mov\\\\t%0, %0, lsr #31\\\";\n \n-    if (GET_CODE (operands[1]) == GE && operands[3] == const0_rtx)\n-      return \\\"mvn\\\\t%0, %2\\;mov\\\\t%0, %0, lsr #31\\\";\n+\tif (GET_CODE (operands[1]) == EQ)\n+\t  return \\\"rsbs\\\\t%0, %2, #1\\;movcc\\\\t%0, #0\\\";\n+      }\n \n     if (GET_CODE (operands[1]) == NE)\n       {\n@@ -6776,7 +6782,37 @@\n   \"operands[7]\n      = gen_rtx_REG (arm_select_dominance_cc_mode (operands[3], operands[6],\n \t\t\t\t\t\t  DOM_CC_X_OR_Y),\n-\t\t    CC_REGNUM);\")\n+\t\t    CC_REGNUM);\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"16\")])\n+\n+; If the above pattern is followed by a CMP insn, then the compare is \n+; redundant, since we can rework the conditional instruction that follows.\n+(define_insn_and_split \"*ior_scc_scc_cmp\"\n+  [(set (match_operand 0 \"dominant_cc_register\" \"\")\n+\t(compare (ior:SI (match_operator:SI 3 \"arm_comparison_operator\"\n+\t\t\t  [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"arm_add_operand\" \"rIL\")])\n+\t\t\t (match_operator:SI 6 \"arm_comparison_operator\"\n+\t\t\t  [(match_operand:SI 4 \"s_register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 5 \"arm_add_operand\" \"rIL\")]))\n+\t\t (const_int 0)))\n+   (set (match_operand:SI 7 \"s_register_operand\" \"=r\")\n+\t(ior:SI (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t\t(match_op_dup 6 [(match_dup 4) (match_dup 5)])))]\n+  \"TARGET_ARM\"\n+  \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 0)\n+\t(compare\n+\t (ior:SI\n+\t  (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t  (match_op_dup 6 [(match_dup 4) (match_dup 5)]))\n+\t (const_int 0)))\n+   (set (match_dup 7) (ne:SI (match_dup 0) (const_int 0)))]\n+  \"\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"16\")])\n \n (define_insn_and_split \"*and_scc_scc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n@@ -6791,7 +6827,9 @@\n    && (arm_select_dominance_cc_mode (operands[3], operands[6], DOM_CC_X_AND_Y)\n        != CCmode)\"\n   \"#\"\n-  \"TARGET_ARM && reload_completed\"\n+  \"TARGET_ARM && reload_completed\n+   && (arm_select_dominance_cc_mode (operands[3], operands[6], DOM_CC_X_AND_Y)\n+       != CCmode)\"\n   [(set (match_dup 7)\n \t(compare\n \t (and:SI\n@@ -6802,7 +6840,71 @@\n   \"operands[7]\n      = gen_rtx_REG (arm_select_dominance_cc_mode (operands[3], operands[6],\n \t\t\t\t\t\t  DOM_CC_X_AND_Y),\n-\t\t    CC_REGNUM);\")\n+\t\t    CC_REGNUM);\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"16\")])\n+\n+; If the above pattern is followed by a CMP insn, then the compare is \n+; redundant, since we can rework the conditional instruction that follows.\n+(define_insn_and_split \"*and_scc_scc_cmp\"\n+  [(set (match_operand 0 \"dominant_cc_register\" \"\")\n+\t(compare (and:SI (match_operator:SI 3 \"arm_comparison_operator\"\n+\t\t\t  [(match_operand:SI 1 \"s_register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"arm_add_operand\" \"rIL\")])\n+\t\t\t (match_operator:SI 6 \"arm_comparison_operator\"\n+\t\t\t  [(match_operand:SI 4 \"s_register_operand\" \"r\")\n+\t\t\t   (match_operand:SI 5 \"arm_add_operand\" \"rIL\")]))\n+\t\t (const_int 0)))\n+   (set (match_operand:SI 7 \"s_register_operand\" \"=r\")\n+\t(and:SI (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t\t(match_op_dup 6 [(match_dup 4) (match_dup 5)])))]\n+  \"TARGET_ARM\"\n+  \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 0)\n+\t(compare\n+\t (and:SI\n+\t  (match_op_dup 3 [(match_dup 1) (match_dup 2)])\n+\t  (match_op_dup 6 [(match_dup 4) (match_dup 5)]))\n+\t (const_int 0)))\n+   (set (match_dup 7) (ne:SI (match_dup 0) (const_int 0)))]\n+  \"\"\n+  [(set_attr \"conds\" \"set\")\n+   (set_attr \"length\" \"16\")])\n+\n+;; If there is no dominance in the comparison, then we can still save an\n+;; instruction in the AND case, since we can know that the second compare\n+;; need only zero the value if false (if true, then the value is already\n+;; correct).\n+(define_insn_and_split \"*and_scc_scc_nodom\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=&r,&r,&r\")\n+\t(and:SI (match_operator:SI 3 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 1 \"s_register_operand\" \"r,r,0\")\n+\t\t  (match_operand:SI 2 \"arm_add_operand\" \"rIL,0,rIL\")])\n+\t\t(match_operator:SI 6 \"arm_comparison_operator\"\n+\t\t [(match_operand:SI 4 \"s_register_operand\" \"r,r,r\")\n+\t\t  (match_operand:SI 5 \"arm_add_operand\" \"rIL,rIL,rIL\")])))\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\n+   && (arm_select_dominance_cc_mode (operands[3], operands[6], DOM_CC_X_AND_Y)\n+       == CCmode)\"\n+  \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_op_dup 3 [(match_dup 1) (match_dup 2)]))\n+\t      (clobber (reg:CC CC_REGNUM))])\n+   (set (match_dup 7) (match_op_dup 8 [(match_dup 4) (match_dup 5)]))\n+   (set (match_dup 0)\n+\t(if_then_else:SI (match_op_dup 6 [(match_dup 7) (const_int 0)])\n+\t\t\t (match_dup 0)\n+\t\t\t (const_int 0)))]\n+  \"operands[7] = gen_rtx_REG (SELECT_CC_MODE (GET_CODE (operands[6]),\n+\t\t\t\t\t      operands[4], operands[5]),\n+\t\t\t      CC_REGNUM);\n+   operands[8] = gen_rtx_COMPARE (GET_MODE (operands[7]), operands[4],\n+\t\t\t\t  operands[5]);\"\n+  [(set_attr \"conds\" \"clob\")\n+   (set_attr \"length\" \"20\")])\n \n (define_insn \"*negscc\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")"}]}