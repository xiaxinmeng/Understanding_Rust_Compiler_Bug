{"sha": "7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YwZTRjZGI1NWU5NmE3Y2E0ZWQ5YjM5YjY4ODFmMjdkZTU2ZTZlNw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2007-12-13T10:32:45Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:32:45Z"}, "message": "sem_util.ads, [...] (Is_Concurrent_Interface): New routine.\n\n2007-12-06  Bob Duff  <duff@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.ads, sem_util.adb (Is_Concurrent_Interface): New routine.\n\t(Set_Convention): New procedure to set the Convention flag, and in\n\taddition make sure the Favor_Top_Level flag is kept in sync (all\n\tforeign-language conventions require Favor_Top_Level = True).\n\t(Collect_Abstract_Interfaces): Update occurrences of Related_Interface\n\tto Related_Type.\n\t(Collect_Interfaces_Info): Minor update to handle the two secondary\n\tdispatch tables. Update occurrence of Related_Interface to Related_Type.\n\t(Generate_Parent_Ref): Add parameter to specify entity to check\n\t(Is_Preelaborable_Expression): Allow the name of a discriminant to\n\tinitialize a component of a type with preelaborable initialization.\n\tThis includes the case of a discriminal used in such a context.\n\t(Is_Dependent_Component_Of_Mutable_Object): Take into account the\n\tlatest Ada 2005 rules about renaming and 'Access of\n\tdiscriminant-dependent components.\n\t(Check_Nested_Access): Add handling when there are no enclosing\n\tsubprograms (e.g. case of a package body).\n\t(Find_Parameter_Type): Factor routine from several other compiler files.\n\tRemove routine from Find_Overridden_Synchronized_Primitive.\n\nFrom-SVN: r130859", "tree": {"sha": "1b6450116869c22df2006efe2c83a2616fcc69e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b6450116869c22df2006efe2c83a2616fcc69e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8a4444e804f8c9a55a12ae2b98e6394a6a4d8ba1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4444e804f8c9a55a12ae2b98e6394a6a4d8ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a4444e804f8c9a55a12ae2b98e6394a6a4d8ba1"}], "stats": {"total": 459, "additions": 287, "deletions": 172}, "files": [{"sha": "e38d5ab1f08297dcbffd4cef8b44292335e9b3af", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 255, "deletions": 161, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "patch": "@@ -50,7 +50,6 @@ with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n-with Snames;   use Snames;\n with Stand;    use Stand;\n with Style;\n with Stringt;  use Stringt;\n@@ -61,8 +60,6 @@ with Uname;    use Uname;\n \n package body Sem_Util is\n \n-   use Nmake;\n-\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -133,9 +130,11 @@ package body Sem_Util is\n \n       elsif Ekind (Typ) = E_Record_Subtype_With_Private then\n \n-         --  Recurse, because parent may still be a private extension\n+         --  Recurse, because parent may still be a private extension. Also\n+         --  note that the full view of the subtype or the full view of its\n+         --  base type may (both) be unavailable.\n \n-         return Abstract_Interface_List (Etype (Full_View (Typ)));\n+         return Abstract_Interface_List (Etype (Typ));\n \n       else pragma Assert ((Ekind (Typ)) = E_Record_Type);\n          if Nkind (Parent (Typ)) = N_Formal_Type_Declaration then\n@@ -327,11 +326,19 @@ package body Sem_Util is\n       else\n          Constraints := New_List;\n \n-         if Is_Private_Type (T) and then No (Full_View (T)) then\n+         --  Type T is a generic derived type, inherit the discriminants from\n+         --  the parent type.\n+\n+         if Is_Private_Type (T)\n+           and then No (Full_View (T))\n \n-            --  Type is a generic derived type. Inherit discriminants from\n-            --  Parent type.\n+            --  T was flagged as an error if it was declared as a formal\n+            --  derived type with known discriminants. In this case there\n+            --  is no need to look at the parent type since T already carries\n+            --  its own discriminants.\n \n+           and then not Error_Posted (T)\n+         then\n             Disc_Type := Etype (Base_Type (T));\n          else\n             Disc_Type := T;\n@@ -516,13 +523,14 @@ package body Sem_Util is\n          while Present (Id) loop\n             Indx_Type := Underlying_Type (Etype (Id));\n \n-            if Denotes_Discriminant (Type_Low_Bound  (Indx_Type)) or else\n+            if Denotes_Discriminant (Type_Low_Bound  (Indx_Type))\n+                 or else\n                Denotes_Discriminant (Type_High_Bound (Indx_Type))\n             then\n                Remove_Side_Effects (P);\n                return\n-                 Build_Component_Subtype (\n-                   Build_Actual_Array_Constraint, Loc, Base_Type (T));\n+                 Build_Component_Subtype\n+                   (Build_Actual_Array_Constraint, Loc, Base_Type (T));\n             end if;\n \n             Next_Index (Id);\n@@ -1031,6 +1039,7 @@ package body Sem_Util is\n    procedure Check_Nested_Access (Ent : Entity_Id) is\n       Scop         : constant Entity_Id := Current_Scope;\n       Current_Subp : Entity_Id;\n+      Enclosing    : Entity_Id;\n \n    begin\n       --  Currently only enabled for VM back-ends for efficiency, should we\n@@ -1054,7 +1063,11 @@ package body Sem_Util is\n             Current_Subp := Current_Subprogram;\n          end if;\n \n-         if Enclosing_Subprogram (Ent) /= Current_Subp then\n+         Enclosing := Enclosing_Subprogram (Ent);\n+\n+         if Enclosing /= Empty\n+           and then Enclosing /= Current_Subp\n+         then\n             Set_Has_Up_Level_Access (Ent, True);\n          end if;\n       end if;\n@@ -1328,7 +1341,7 @@ package body Sem_Util is\n \n          Tag_Comp := Next_Tag_Component (First_Tag_Component (Typ));\n          while Present (Tag_Comp) loop\n-            pragma Assert (Present (Related_Interface (Tag_Comp)));\n+            pragma Assert (Present (Related_Type (Tag_Comp)));\n             Append_Elmt (Tag_Comp, Components_List);\n \n             Tag_Comp := Next_Tag_Component (Tag_Comp);\n@@ -1376,8 +1389,10 @@ package body Sem_Util is\n          ADT := Next_Elmt (First_Elmt (Access_Disp_Table (T)));\n          while Present (ADT)\n             and then Ekind (Node (ADT)) = E_Constant\n-            and then Related_Interface (Node (ADT)) /= Iface\n+            and then Related_Type (Node (ADT)) /= Iface\n          loop\n+            --  Skip the two secondary dispatch tables of Iface\n+            Next_Elmt (ADT);\n             Next_Elmt (ADT);\n          end loop;\n \n@@ -1414,7 +1429,7 @@ package body Sem_Util is\n          else\n             Comp_Elmt := First_Elmt (Comps_List);\n             while Present (Comp_Elmt) loop\n-               Comp_Iface := Related_Interface (Node (Comp_Elmt));\n+               Comp_Iface := Related_Type (Node (Comp_Elmt));\n \n                if Comp_Iface = Iface\n                  or else Is_Parent (Iface, Comp_Iface)\n@@ -2632,17 +2647,16 @@ package body Sem_Util is\n       end if;\n    end Explain_Limited_Type;\n \n-   ----------------------\n-   -- Find_Actual_Mode --\n-   ----------------------\n+   -----------------\n+   -- Find_Actual --\n+   -----------------\n \n-   procedure Find_Actual_Mode\n-     (N    : Node_Id;\n-      Kind : out Entity_Kind;\n-      Call : out Node_Id)\n+   procedure Find_Actual\n+     (N        : Node_Id;\n+      Formal   : out Entity_Id;\n+      Call     : out Node_Id)\n    is\n       Parnt  : constant Node_Id := Parent (N);\n-      Formal : Entity_Id;\n       Actual : Node_Id;\n \n    begin\n@@ -2651,7 +2665,7 @@ package body Sem_Util is\n           Nkind (Parnt) = N_Selected_Component)\n         and then N = Prefix (Parnt)\n       then\n-         Find_Actual_Mode (Parnt, Kind, Call);\n+         Find_Actual (Parnt, Formal, Call);\n          return;\n \n       elsif Nkind (Parnt) = N_Parameter_Association\n@@ -2663,24 +2677,26 @@ package body Sem_Util is\n          Call := Parnt;\n \n       else\n-         Kind := E_Void;\n-         Call := Empty;\n+         Formal := Empty;\n+         Call   := Empty;\n          return;\n       end if;\n \n-      --  If we have a call to a subprogram look for the parametere\n+      --  If we have a call to a subprogram look for the parameter. Note that\n+      --  we exclude overloaded calls, since we don't know enough to be sure\n+      --  of giving the right answer in this case.\n \n       if Is_Entity_Name (Name (Call))\n         and then Present (Entity (Name (Call)))\n         and then Is_Overloadable (Entity (Name (Call)))\n+        and then not Is_Overloaded (Name (Call))\n       then\n          --  Fall here if we are definitely a parameter\n \n          Actual := First_Actual (Call);\n          Formal := First_Formal (Entity (Name (Call)));\n          while Present (Formal) and then Present (Actual) loop\n             if Actual = N then\n-               Kind := Ekind (Formal);\n                return;\n             else\n                Actual := Next_Actual (Actual);\n@@ -2691,9 +2707,9 @@ package body Sem_Util is\n \n       --  Fall through here if we did not find matching actual\n \n-      Kind := E_Void;\n-      Call := Empty;\n-   end Find_Actual_Mode;\n+      Formal := Empty;\n+      Call   := Empty;\n+   end Find_Actual;\n \n    -------------------------------------\n    -- Find_Corresponding_Discriminant --\n@@ -2816,10 +2832,6 @@ package body Sem_Util is\n       Subp      : Entity_Id := Empty;\n       Tag_Typ   : Entity_Id;\n \n-      function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n-      --  Return the type of a formal parameter as determined by its\n-      --  specification.\n-\n       function Has_Correct_Formal_Mode (Subp : Entity_Id) return Boolean;\n       --  For an overridden subprogram Subp, check whether the mode of its\n       --  first parameter is correct depending on the kind of Tag_Typ.\n@@ -2832,22 +2844,6 @@ package body Sem_Util is\n       --  Iface_Params. Also determine if the type of first parameter of\n       --  Iface_Params is an implemented interface.\n \n-      -------------------------\n-      -- Find_Parameter_Type --\n-      -------------------------\n-\n-      function Find_Parameter_Type (Param : Node_Id) return Entity_Id is\n-      begin\n-         pragma Assert (Nkind (Param) = N_Parameter_Specification);\n-\n-         if Nkind (Parameter_Type (Param)) = N_Access_Definition then\n-            return Etype (Subtype_Mark (Parameter_Type (Param)));\n-\n-         else\n-            return Etype (Parameter_Type (Param));\n-         end if;\n-      end Find_Parameter_Type;\n-\n       -----------------------------\n       -- Has_Correct_Formal_Mode --\n       -----------------------------\n@@ -3118,6 +3114,23 @@ package body Sem_Util is\n       return Candidate;\n    end Find_Overridden_Synchronized_Primitive;\n \n+   -------------------------\n+   -- Find_Parameter_Type --\n+   -------------------------\n+\n+   function Find_Parameter_Type (Param : Node_Id) return Entity_Id is\n+   begin\n+      if Nkind (Param) /= N_Parameter_Specification then\n+         return Empty;\n+\n+      elsif Nkind (Parameter_Type (Param)) = N_Access_Definition then\n+         return Etype (Subtype_Mark (Parameter_Type (Param)));\n+\n+      else\n+         return Etype (Parameter_Type (Param));\n+      end if;\n+   end Find_Parameter_Type;\n+\n    -----------------------------\n    -- Find_Static_Alternative --\n    -----------------------------\n@@ -4531,13 +4544,26 @@ package body Sem_Util is\n             elsif Nkind (N) = N_Null then\n                return True;\n \n-            elsif Nkind (N) = N_Attribute_Reference\n+            --  Attributes are allowed in general, even if their prefix is a\n+            --  formal type. (It seems that certain attributes known not to be\n+            --  static might not be allowed, but there are no rules to prevent\n+            --  them.)\n+\n+            elsif Nkind (N) = N_Attribute_Reference then\n+               return True;\n+\n+            --  The name of a discriminant evaluated within its parent type is\n+            --  defined to be preelaborable (10.2.1(8)). Note that we test for\n+            --  names that denote discriminals as well as discriminants to\n+            --  catch references occurring within init procs.\n+\n+            elsif Is_Entity_Name (N)\n               and then\n-                (Attribute_Name (N) = Name_Access\n-                   or else\n-                 Attribute_Name (N) = Name_Unchecked_Access\n-                   or else\n-                 Attribute_Name (N) = Name_Unrestricted_Access)\n+                (Ekind (Entity (N)) = E_Discriminant\n+                  or else\n+                    ((Ekind (Entity (N)) = E_Constant\n+                       or else Ekind (Entity (N)) = E_In_Parameter)\n+                     and then Present (Discriminal_Link (Entity (N)))))\n             then\n                return True;\n \n@@ -5433,6 +5459,20 @@ package body Sem_Util is\n           and then not Is_Static_Coextension (N);\n    end Is_Coextension_Root;\n \n+   -----------------------------\n+   -- Is_Concurrent_Interface --\n+   -----------------------------\n+\n+   function Is_Concurrent_Interface (T : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Is_Interface (T)\n+          and then\n+            (Is_Protected_Interface (T)\n+               or else Is_Synchronized_Interface (T)\n+               or else Is_Task_Interface (T));\n+   end Is_Concurrent_Interface;\n+\n    --------------------------------------\n    -- Is_Controlling_Limited_Procedure --\n    --------------------------------------\n@@ -5554,7 +5594,24 @@ package body Sem_Util is\n \n             elsif Ada_Version >= Ada_05 then\n                if Is_Access_Type (Prefix_Type) then\n-                  Prefix_Type := Designated_Type (Prefix_Type);\n+\n+                  --  If the access type is pool-specific, and there is no\n+                  --  constrained partial view of the designated type, then the\n+                  --  designated object is known to be constrained.\n+\n+                  if Ekind (Prefix_Type) = E_Access_Type\n+                    and then not Has_Constrained_Partial_View\n+                                   (Designated_Type (Prefix_Type))\n+                  then\n+                     return False;\n+\n+                  --  Otherwise (general access type, or there is a constrained\n+                  --  partial view of the designated type), we need to check\n+                  --  based on the designated type.\n+\n+                  else\n+                     Prefix_Type := Designated_Type (Prefix_Type);\n+                  end if;\n                end if;\n             end if;\n \n@@ -7317,8 +7374,8 @@ package body Sem_Util is\n                end loop;\n             end;\n \n-         --  Test for appearing in a conversion that itself appears\n-         --  in an lvalue context, since this should be an lvalue.\n+         --  Test for appearing in a conversion that itself appears in an\n+         --  lvalue context, since this should be an lvalue.\n \n          when N_Type_Conversion =>\n             return May_Be_Lvalue (P);\n@@ -7477,14 +7534,14 @@ package body Sem_Util is\n       N  : Node_Id;\n \n    begin\n-      --  If we are pointing at a positional parameter, it is a member of\n-      --  a node list (the list of parameters), and the next parameter\n-      --  is the next node on the list, unless we hit a parameter\n-      --  association, in which case we shift to using the chain whose\n-      --  head is the First_Named_Actual in the parent, and then is\n-      --  threaded using the Next_Named_Actual of the Parameter_Association.\n-      --  All this fiddling is because the original node list is in the\n-      --  textual call order, and what we need is the declaration order.\n+      --  If we are pointing at a positional parameter, it is a member of a\n+      --  node list (the list of parameters), and the next parameter is the\n+      --  next node on the list, unless we hit a parameter association, then\n+      --  we shift to using the chain whose head is the First_Named_Actual in\n+      --  the parent, and then is threaded using the Next_Named_Actual of the\n+      --  Parameter_Association. All this fiddling is because the original node\n+      --  list is in the textual call order, and what we need is the\n+      --  declaration order.\n \n       if Is_List_Member (Actual_Id) then\n          N := Next (Actual_Id);\n@@ -7675,9 +7732,9 @@ package body Sem_Util is\n       Formal := First_Formal (S);\n       while Present (Formal) loop\n \n-         --  Match the formals in order. If the corresponding actual\n-         --  is positional,  nothing to do. Else scan the list of named\n-         --  actuals to find the one with the right name.\n+         --  Match the formals in order. If the corresponding actual is\n+         --  positional, nothing to do. Else scan the list of named actuals\n+         --  to find the one with the right name.\n \n          if Present (Actual)\n            and then Nkind (Actual) /= N_Parameter_Association\n@@ -7919,22 +7976,21 @@ package body Sem_Util is\n    function Object_Access_Level (Obj : Node_Id) return Uint is\n       E : Entity_Id;\n \n-   --  Returns the static accessibility level of the view denoted\n-   --  by Obj. Note that the value returned is the result of a\n-   --  call to Scope_Depth. Only scope depths associated with\n-   --  dynamic scopes can actually be returned. Since only\n-   --  relative levels matter for accessibility checking, the fact\n-   --  that the distance between successive levels of accessibility\n-   --  is not always one is immaterial (invariant: if level(E2) is\n-   --  deeper than level(E1), then Scope_Depth(E1) < Scope_Depth(E2)).\n+   --  Returns the static accessibility level of the view denoted by Obj. Note\n+   --  that the value returned is the result of a call to Scope_Depth. Only\n+   --  scope depths associated with dynamic scopes can actually be returned.\n+   --  Since only relative levels matter for accessibility checking, the fact\n+   --  that the distance between successive levels of accessibility is not\n+   --  always one is immaterial (invariant: if level(E2) is deeper than\n+   --  level(E1), then Scope_Depth(E1) < Scope_Depth(E2)).\n \n       function Reference_To (Obj : Node_Id) return Node_Id;\n-      --  An explicit dereference is created when removing side-effects\n-      --  from expressions for constraint checking purposes. In this case\n-      --  a local access type is created for it. The correct access level\n-      --  is that of the original source node. We detect this case by\n-      --  noting that the prefix of the dereference is created by an object\n-      --  declaration whose initial expression is a reference.\n+      --  An explicit dereference is created when removing side-effects from\n+      --  expressions for constraint checking purposes. In this case a local\n+      --  access type is created for it. The correct access level is that of\n+      --  the original source node. We detect this case by noting that the\n+      --  prefix of the dereference is created by an object declaration whose\n+      --  initial expression is a reference.\n \n       ------------------\n       -- Reference_To --\n@@ -7960,11 +8016,10 @@ package body Sem_Util is\n       if Is_Entity_Name (Obj) then\n          E := Entity (Obj);\n \n-         --  If E is a type then it denotes a current instance.\n-         --  For this case we add one to the normal accessibility\n-         --  level of the type to ensure that current instances\n-         --  are treated as always being deeper than than the level\n-         --  of any visible named access type (see 3.10.2(21)).\n+         --  If E is a type then it denotes a current instance. For this case\n+         --  we add one to the normal accessibility level of the type to ensure\n+         --  that current instances are treated as always being deeper than\n+         --  than the level of any visible named access type (see 3.10.2(21)).\n \n          if Is_Type (E) then\n             return Type_Access_Level (E) +  1;\n@@ -8004,10 +8059,9 @@ package body Sem_Util is\n \n       elsif Nkind (Obj) = N_Explicit_Dereference then\n \n-         --  If the prefix is a selected access discriminant then\n-         --  we make a recursive call on the prefix, which will\n-         --  in turn check the level of the prefix object of\n-         --  the selected discriminant.\n+         --  If the prefix is a selected access discriminant then we make a\n+         --  recursive call on the prefix, which will in turn check the level\n+         --  of the prefix object of the selected discriminant.\n \n          if Nkind (Prefix (Obj)) = N_Selected_Component\n            and then Ekind (Etype (Prefix (Obj))) = E_Anonymous_Access_Type\n@@ -8036,9 +8090,9 @@ package body Sem_Util is\n       then\n          return Object_Access_Level (Expression (Obj));\n \n-      --  Function results are objects, so we get either the access level\n-      --  of the function or, in the case of an indirect call, the level of\n-      --  of the access-to-subprogram type.\n+      --  Function results are objects, so we get either the access level of\n+      --  the function or, in the case of an indirect call, the level of of the\n+      --  access-to-subprogram type.\n \n       elsif Nkind (Obj) = N_Function_Call then\n          if Is_Entity_Name (Name (Obj)) then\n@@ -8102,9 +8156,9 @@ package body Sem_Util is\n               and then Is_Record_Type (Full_View (Btype))\n               and then not Is_Frozen (Btype)\n             then\n-               --  To indicate that the ancestor depends on a private type,\n-               --  the current Btype is sufficient. However, to check for\n-               --  circular definition we must recurse on the full view.\n+               --  To indicate that the ancestor depends on a private type, the\n+               --  current Btype is sufficient. However, to check for circular\n+               --  definition we must recurse on the full view.\n \n                Candidate := Trace_Components (Full_View (Btype), True);\n \n@@ -8166,75 +8220,57 @@ package body Sem_Util is\n    is\n       Loc  : Source_Ptr;\n       Nam  : Node_Id;\n+      Scop : Entity_Id;\n \n       Label_Ref : Boolean;\n       --  Set True if reference to end label itself is required\n \n       Endl : Node_Id;\n-      --  Gets set to the operator symbol or identifier that references\n-      --  the entity Ent. For the child unit case, this is the identifier\n-      --  from the designator. For other cases, this is simply Endl.\n+      --  Gets set to the operator symbol or identifier that references the\n+      --  entity Ent. For the child unit case, this is the identifier from the\n+      --  designator. For other cases, this is simply Endl.\n \n-      procedure Generate_Parent_Ref (N : Node_Id);\n-      --  N is an identifier node that appears as a parent unit reference\n-      --  in the case where Ent is a child unit. This procedure generates\n-      --  an appropriate cross-reference entry.\n+      procedure Generate_Parent_Ref (N : Node_Id; E : Entity_Id);\n+      --  N is an identifier node that appears as a parent unit reference in\n+      --  the case where Ent is a child unit. This procedure generates an\n+      --  appropriate cross-reference entry. E is the corresponding entity.\n \n       -------------------------\n       -- Generate_Parent_Ref --\n       -------------------------\n \n-      procedure Generate_Parent_Ref (N : Node_Id) is\n-         Parent_Ent : Entity_Id;\n-\n+      procedure Generate_Parent_Ref (N : Node_Id; E : Entity_Id) is\n       begin\n-         --  Search up scope stack. The reason we do this is that normal\n-         --  visibility analysis would not work for two reasons. First in\n-         --  some subunit cases, the entry for the parent unit may not be\n-         --  visible, and in any case there can be a local entity that\n-         --  hides the scope entity.\n-\n-         Parent_Ent := Current_Scope;\n-         while Present (Parent_Ent) loop\n-            if Chars (Parent_Ent) = Chars (N) then\n-\n-               --  Generate the reference. We do NOT consider this as a\n-               --  reference for unreferenced symbol purposes, but we do\n-               --  force a cross-reference even if the end line does not\n-               --  come from source (the caller already generated the\n-               --  appropriate Typ for this situation).\n-\n-               Generate_Reference\n-                 (Parent_Ent, N, 'r', Set_Ref => False, Force => True);\n-               Style.Check_Identifier (N, Parent_Ent);\n-               return;\n-            end if;\n+         --  If names do not match, something weird, skip reference\n \n-            Parent_Ent := Scope (Parent_Ent);\n-         end loop;\n+         if Chars (E) = Chars (N) then\n \n-         --  Fall through means entity was not found -- that's odd, but\n-         --  the appropriate thing is simply to ignore and not generate\n-         --  any cross-reference for this entry.\n+            --  Generate the reference. We do NOT consider this as a reference\n+            --  for unreferenced symbol purposes.\n \n-         return;\n+            Generate_Reference (E, N, 'r', Set_Ref => False, Force => True);\n+\n+            if Style_Check then\n+               Style.Check_Identifier (N, E);\n+            end if;\n+         end if;\n       end Generate_Parent_Ref;\n \n    --  Start of processing for Process_End_Label\n \n    begin\n-      --  If no node, ignore. This happens in some error situations,\n-      --  and also for some internally generated structures where no\n-      --  end label references are required in any case.\n+      --  If no node, ignore. This happens in some error situations, and\n+      --  also for some internally generated structures where no end label\n+      --  references are required in any case.\n \n       if No (N) then\n          return;\n       end if;\n \n       --  Nothing to do if no End_Label, happens for internally generated\n-      --  constructs where we don't want an end label reference anyway.\n-      --  Also nothing to do if Endl is a string literal, which means\n-      --  there was some prior error (bad operator symbol)\n+      --  constructs where we don't want an end label reference anyway. Also\n+      --  nothing to do if Endl is a string literal, which means there was\n+      --  some prior error (bad operator symbol)\n \n       Endl := End_Label (N);\n \n@@ -8246,19 +8282,19 @@ package body Sem_Util is\n \n       if not In_Extended_Main_Source_Unit (N) then\n \n-         --  Generally we do not collect references except for the\n-         --  extended main source unit. The one exception is the 'e'\n-         --  entry for a package spec, where it is useful for a client\n-         --  to have the ending information to define scopes.\n+         --  Generally we do not collect references except for the extended\n+         --  main source unit. The one exception is the 'e' entry for a\n+         --  package spec, where it is useful for a client to have the\n+         --  ending information to define scopes.\n \n          if Typ /= 'e' then\n             return;\n \n          else\n             Label_Ref := False;\n \n-            --  For this case, we can ignore any parent references,\n-            --  but we need the package name itself for the 'e' entry.\n+            --  For this case, we can ignore any parent references, but we\n+            --  need the package name itself for the 'e' entry.\n \n             if Nkind (Endl) = N_Designator then\n                Endl := Identifier (Endl);\n@@ -8274,17 +8310,23 @@ package body Sem_Util is\n \n          if Nkind (Endl) = N_Designator then\n \n-            --  Generate references for the prefix if the END line comes\n-            --  from source (otherwise we do not need these references)\n+            --  Generate references for the prefix if the END line comes from\n+            --  source (otherwise we do not need these references) We climb the\n+            --  scope stack to find the expected entities.\n \n             if Comes_From_Source (Endl) then\n-               Nam := Name (Endl);\n+               Nam  := Name (Endl);\n+               Scop := Current_Scope;\n                while Nkind (Nam) = N_Selected_Component loop\n-                  Generate_Parent_Ref (Selector_Name (Nam));\n+                  Scop := Scope (Scop);\n+                  exit when No (Scop);\n+                  Generate_Parent_Ref (Selector_Name (Nam), Scop);\n                   Nam := Prefix (Nam);\n                end loop;\n \n-               Generate_Parent_Ref (Nam);\n+               if Present (Scop) then\n+                  Generate_Parent_Ref (Nam, Scope (Scop));\n+               end if;\n             end if;\n \n             Endl := Identifier (Endl);\n@@ -8300,21 +8342,22 @@ package body Sem_Util is\n          return;\n       end if;\n \n-      --  If label was really there, then generate a normal reference\n-      --  and then adjust the location in the end label to point past\n-      --  the name (which should almost always be the semicolon).\n+      --  If label was really there, then generate a normal reference and then\n+      --  adjust the location in the end label to point past the name (which\n+      --  should almost always be the semicolon).\n \n       Loc := Sloc (Endl);\n \n       if Comes_From_Source (Endl) then\n \n-         --  If a label reference is required, then do the style check\n-         --  and generate an l-type cross-reference entry for the label\n+         --  If a label reference is required, then do the style check and\n+         --  generate an l-type cross-reference entry for the label\n \n          if Label_Ref then\n             if Style_Check then\n                Style.Check_Identifier (Endl, Ent);\n             end if;\n+\n             Generate_Reference (Ent, Endl, 'l', Set_Ref => False);\n          end if;\n \n@@ -8858,6 +8901,21 @@ package body Sem_Util is\n       return False;\n    end Scope_Within_Or_Same;\n \n+   --------------------\n+   -- Set_Convention --\n+   --------------------\n+\n+   procedure Set_Convention (E : Entity_Id; Val : Snames.Convention_Id) is\n+   begin\n+      Basic_Set_Convention (E, Val);\n+      if Is_Type (E)\n+        and then Ekind (Base_Type (E)) in Access_Subprogram_Type_Kind\n+        and then Has_Foreign_Convention (E)\n+      then\n+         Set_Can_Use_Internal_Rep (E, False);\n+      end if;\n+   end Set_Convention;\n+\n    ------------------------\n    -- Set_Current_Entity --\n    ------------------------\n@@ -8988,6 +9046,42 @@ package body Sem_Util is\n       end if;\n    end Set_Public_Status;\n \n+   -----------------------------\n+   -- Set_Referenced_Modified --\n+   -----------------------------\n+\n+   procedure Set_Referenced_Modified (N : Node_Id; Out_Param : Boolean) is\n+      Pref : Node_Id;\n+\n+   begin\n+      --  Deal with indexed or selected component where prefix is modified\n+\n+      if Nkind (N) = N_Indexed_Component\n+           or else\n+         Nkind (N) = N_Selected_Component\n+      then\n+         Pref := Prefix (N);\n+\n+         --  If prefix is access type, then it is the designated object that is\n+         --  being modified, which means we have no entity to set the flag on.\n+\n+         if No (Etype (Pref)) or else Is_Access_Type (Etype (Pref)) then\n+            return;\n+\n+            --  Otherwise chase the prefix\n+\n+         else\n+            Set_Referenced_Modified (Pref, Out_Param);\n+         end if;\n+\n+      --  Otherwise see if we have an entity name (only other case to process)\n+\n+      elsif Is_Entity_Name (N) and then Present (Entity (N)) then\n+         Set_Referenced_As_LHS           (Entity (N), not Out_Param);\n+         Set_Referenced_As_Out_Parameter (Entity (N), Out_Param);\n+      end if;\n+   end Set_Referenced_Modified;\n+\n    ----------------------------\n    -- Set_Scope_Is_Transient --\n    ----------------------------\n@@ -9092,8 +9186,8 @@ package body Sem_Util is\n \n          Write_Str (Msg);\n          Write_Name (Chars (E));\n-         Write_Str (\"   line \");\n-         Write_Int (Int (Get_Logical_Line_Number (Sloc (N))));\n+         Write_Str (\" from \");\n+         Write_Location (Sloc (N));\n          Write_Eol;\n       end if;\n    end Trace_Scope;"}, {"sha": "58dbb536bb153cf7d0690da4291e7397990cca10", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7f0e4cdb55e96a7ca4ed9b39b6881f27de56e6e7", "patch": "@@ -27,7 +27,8 @@\n \n with Einfo;  use Einfo;\n with Namet;  use Namet;\n-with Nmake;\n+with Nmake;  use Nmake;\n+with Snames; use Snames;\n with Types;  use Types;\n with Uintp;  use Uintp;\n with Urealp; use Urealp;\n@@ -283,16 +284,16 @@ package Sem_Util is\n    --  adds additional continuation lines to the message explaining\n    --  why type T is limited. Messages are placed at node N.\n \n-   procedure Find_Actual_Mode\n-     (N    : Node_Id;\n-      Kind : out Entity_Kind;\n-      Call : out Node_Id);\n+   procedure Find_Actual\n+     (N      : Node_Id;\n+      Formal : out Entity_Id;\n+      Call   : out Node_Id);\n    --  Determines if the node N is an actual parameter of a procedure call. If\n-   --  so, then Kind is E_In_Parameter, E_Out_Parameter, E_In_Out_Parameter on\n-   --  return as appropriate, and Call is set to the node for the corresponding\n-   --  call. If the node N is not an actual parameter, then Kind = E_Void, Call\n-   --  = Empty. Note that this only applies to procedure calls, for function\n-   --  calls, the result is always E_Void.\n+   --  so, then Formal points to the entity for the formal (whose Ekind is one\n+   --  of E_In_Parameter, E_Out_Parameter, E_In_Out_Parameter) and Call is set\n+   --  to the node for the corresponding call. If the node N is not an actual\n+   --  parameter, or is an actual parameter of a function call, then Formal and\n+   --  Call are set to Empty.\n \n    function Find_Corresponding_Discriminant\n      (Id   : Node_Id;\n@@ -322,6 +323,10 @@ package Sem_Util is\n    --  declared inside the scope of the synchronized type or after. Return\n    --  the overridden entity or Empty.\n \n+   function Find_Parameter_Type (Param : Node_Id) return Entity_Id;\n+   --  Return the type of formal parameter Param as determined by its\n+   --  specification.\n+\n    function Find_Static_Alternative (N : Node_Id) return Node_Id;\n    --  N is a case statement whose expression is a compile-time value.\n    --  Determine the alternative chosen, so that the code of non-selected\n@@ -626,6 +631,10 @@ package Sem_Util is\n    --  This is the RM definition, a type is a descendent of another type if it\n    --  is the same type or is derived from a descendent of the other type.\n \n+   function Is_Concurrent_Interface (T : Entity_Id) return Boolean;\n+   --  First determine whether type T is an interface and then check whether\n+   --  it is of protected, synchronized or task kind.\n+\n    function Is_False (U : Uint) return Boolean;\n    --  The argument is a Uint value which is the Boolean'Pos value of a\n    --  Boolean operand (i.e. is either 0 for False, or 1 for True). This\n@@ -802,7 +811,7 @@ package Sem_Util is\n    function Make_Simple_Return_Statement\n      (Sloc       : Source_Ptr;\n       Expression : Node_Id := Empty) return Node_Id\n-     renames Nmake.Make_Return_Statement;\n+     renames Make_Return_Statement;\n    --  See Sinfo. We rename Make_Return_Statement to the correct Ada 2005\n    --  terminology here. Clients should use Make_Simple_Return_Statement.\n \n@@ -1010,6 +1019,11 @@ package Sem_Util is\n    --  Like Scope_Within_Or_Same, except that this function returns\n    --  False in the case where Scope1 and Scope2 are the same scope.\n \n+   procedure Set_Convention (E : Entity_Id; Val : Convention_Id);\n+   --  Same as Basic_Set_Convention, but with an extra check for access types.\n+   --  In particular, if E is an access-to-subprogram type, and Val is a\n+   --  foreign convention, then we set Can_Use_Internal_Rep to False on E.\n+\n    procedure Set_Current_Entity (E : Entity_Id);\n    --  Establish the entity E as the currently visible definition of its\n    --  associated name (i.e. the Node_Id associated with its name)\n@@ -1035,6 +1049,13 @@ package Sem_Util is\n    --  package, or a package that is itself public, then this subprogram\n    --  labels the entity public as well.\n \n+   procedure Set_Referenced_Modified (N : Node_Id; Out_Param : Boolean);\n+   --  N is the node for either a left hand side (Out_Param set to False),\n+   --  or an Out or In_Out parameter (Out_Param set to True). If there is\n+   --  an assignable entity being referenced, then the appropriate flag\n+   --  (Referenced_As_LHS if Out_Param is False, Referenced_As_Out_Parameter\n+   --  if Out_Param is True) is set True, and the other flag set False.\n+\n    procedure Set_Scope_Is_Transient (V : Boolean := True);\n    --  Set the flag Is_Transient of the current scope\n "}]}