{"sha": "74a35b2b7d4acd85a5c08c0b52cbe479bbed7167", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRhMzViMmI3ZDRhY2Q4NWE1YzA4YzBiNTJjYmU0NzliYmVkNzE2Nw==", "commit": {"author": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1995-05-12T21:28:15Z"}, "committer": {"name": "Ken Raeburn", "email": "raeburn@gcc.gnu.org", "date": "1995-05-12T21:28:15Z"}, "message": "(__IMMEDIATE_PREFIX__): Default to #.\n\n(IMM): New macro.\n(all code): Use IMM macro instead of hardcoding # for immediate operands.\n\nFrom-SVN: r9667", "tree": {"sha": "dd21df66fd14b7a4eed33d9d97301e052bf3e82e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd21df66fd14b7a4eed33d9d97301e052bf3e82e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167/comments", "author": null, "committer": null, "parents": [{"sha": "31e033e928414b405196bd99ee06b45f3b498a0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e033e928414b405196bd99ee06b45f3b498a0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e033e928414b405196bd99ee06b45f3b498a0f"}], "stats": {"total": 1060, "additions": 534, "deletions": 526}, "files": [{"sha": "922df8f8a3ea606065a2dc37e777c8a6c2eb9ba7", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 534, "deletions": 526, "changes": 1060, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74a35b2b7d4acd85a5c08c0b52cbe479bbed7167/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=74a35b2b7d4acd85a5c08c0b52cbe479bbed7167", "patch": "@@ -45,6 +45,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define __REGISTER_PREFIX__\n #endif\n \n+#ifndef __IMMEDIATE_PREFIX__\n+#define __IMMEDIATE_PREFIX__ #\n+#endif\n+\n /* ANSI concatenation macros.  */\n \n #define CONCAT1(a, b) CONCAT2(a, b)\n@@ -58,6 +62,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define REG(x) CONCAT1 (__REGISTER_PREFIX__, x)\n \n+/* Use the right prefix for immediate values.  */\n+\n+#define IMM(x) CONCAT1 (__IMMEDIATE_PREFIX__, x)\n+\n #define d0 REG (d0)\n #define d1 REG (d1)\n #define d2 REG (d2)\n@@ -203,7 +211,7 @@ TRUNCDFSF    = 7\n | void __clear_sticky_bits(void);\n SYM (__clear_sticky_bit):\t\t\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@(STICK)\n+\tmovew\tIMM (0),a0@(STICK)\n \trts\n \n |=============================================================================\n@@ -238,7 +246,7 @@ $_exception_handler:\n \tmovew\td5,a0@(LASTO)\t| and __last_operation\n \n | Now put the operands in place:\n-\tcmpw\t#SINGLE_FLOAT,d6\n+\tcmpw\tIMM (SINGLE_FLOAT),d6\n \tbeq\t1f\n \tmovel\ta6@(8),a0@(OPER1)\n \tmovel\ta6@(12),a0@(OPER1+4)\n@@ -252,7 +260,7 @@ $_exception_handler:\n \tandw\ta0@(TRAPE),d7\t| is exception trap-enabled?\n \tbeq\t1f\t\t| no, exit\n \tpea\tSYM (_fpCCR)\t| yes, push address of _fpCCR\n-\ttrap\t#FPTRAP\t\t| and trap\n+\ttrap\tIMM (FPTRAP)\t| and trap\n 1:\tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n@@ -286,7 +294,7 @@ SYM (__udivsi3):\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tmovel\tsp@(8), d0\t/* d0 = dividend */\n \n-\tcmpl\t#0x10000, d1\t/* divisor >= 2 ^ 16 ?   */\n+\tcmpl\tIMM (0x10000), d1 /* divisor >= 2 ^ 16 ?   */\n \tjcc\tL3\t\t/* then try next algorithm */\n \tmovel\td0, d2\n \tclrw\td2\n@@ -300,12 +308,12 @@ SYM (__udivsi3):\n \tjra\tL6\n \n L3:\tmovel\td1, d2\t\t/* use d2 as divisor backup */\n-L4:\tlsrl\t#1, d1\t\t/* shift divisor */\n-\tlsrl\t#1, d0\t\t/* shift dividend */\n-\tcmpl\t#0x10000, d1\t/* still divisor >= 2 ^ 16 ?  */\n+L4:\tlsrl\tIMM (1), d1\t/* shift divisor */\n+\tlsrl\tIMM (1), d0\t/* shift dividend */\n+\tcmpl\tIMM (0x10000), d1 /* still divisor >= 2 ^ 16 ?  */\n \tjcc\tL4\n \tdivu\td1, d0\t\t/* now we have 16 bit divisor */\n-\tandl\t#0xffff, d0\t/* mask out divisor, ignore remainder */\n+\tandl\tIMM (0xffff), d0 /* mask out divisor, ignore remainder */\n \n /* Muliply the 16 bit tentative quotient with the 32 bit divisor.  Because of\n    the operand ranges, this might give a 33 bit product.  If this product is\n@@ -315,13 +323,13 @@ L4:\tlsrl\t#1, d1\t\t/* shift divisor */\n \tswap\td2\n \tmulu\td0, d2\t\t/* high part, at most 17 bits */\n \tswap\td2\t\t/* align high part with low part */\n-\tbtst\t#0, d2\t\t/* high part 17 bits? */\n+\tbtst\tIMM (0), d2\t/* high part 17 bits? */\n \tjne\tL5\t\t/* if 17 bits, quotient was too large */\n \taddl\td2, d1\t\t/* add parts */\n \tjcs\tL5\t\t/* if sum is 33 bits, quotient was too large */\n \tcmpl\tsp@(8), d1\t/* compare the sum with the dividend */\n \tjls\tL6\t\t/* if sum > dividend, quotient was too large */\n-L5:\tsubql\t#1, d0\t\t/* adjust quotient */\n+L5:\tsubql\tIMM (1), d0\t/* adjust quotient */\n \n L6:\tmovel\tsp@+, d2\n \trts\n@@ -334,7 +342,7 @@ L6:\tmovel\tsp@+, d2\n SYM (__divsi3):\n \tmovel\td2, sp@-\n \n-\tmoveb\t#1, d2\t\t/* sign of result stored in d2 (=1 or =-1) */\n+\tmoveb\tIMM (1), d2\t/* sign of result stored in d2 (=1 or =-1) */\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tjpl\tL1\n \tnegl\td1\n@@ -347,7 +355,7 @@ L1:\tmovel\tsp@(8), d0\t/* d0 = dividend */\n L2:\tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__udivsi3)\t/* divide abs(dividend) by abs(divisor) */\n-\taddql\t#8, sp\n+\taddql\tIMM (8), sp\n \n \ttstb\td2\n \tjpl\tL3\n@@ -367,12 +375,12 @@ SYM (__umodsi3):\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__udivsi3)\n-\taddql\t#8, sp\n+\taddql\tIMM (8), sp\n \tmovel\tsp@(8), d1\t/* d1 = divisor */\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__mulsi3)\t/* d0 = (a/b)*b */\n-\taddql\t#8, sp\n+\taddql\tIMM (8), sp\n \tmovel\tsp@(4), d1\t/* d1 = dividend */\n \tsubl\td0, d1\t\t/* d1 = a - (a/b)*b */\n \tmovel\td1, d0\n@@ -389,12 +397,12 @@ SYM (__modsi3):\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__divsi3)\n-\taddql\t#8, sp\n+\taddql\tIMM (8), sp\n \tmovel\tsp@(8), d1\t/* d1 = divisor */\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__mulsi3)\t/* d0 = (a/b)*b */\n-\taddql\t#8, sp\n+\taddql\tIMM (8), sp\n \tmovel\tsp@(4), d1\t/* d1 = dividend */\n \tsubl\td0, d1\t\t/* d1 = a - (a/b)*b */\n \tmovel\td1, d0\n@@ -455,48 +463,48 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity\n Ld$den:\n | Return and signal a denormalized number\n \torl\td7,d0\n-\tmovew\t#UNDERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#DOUBLE_FLOAT,d6\n+\tmovew\tIMM (UNDERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$infty:\n Ld$overflow:\n | Return a properly signed INFINITY and set the exception flags \n-\tmovel\t#0x7ff00000,d0\n-\tmovel\t#0,d1\n+\tmovel\tIMM (0x7ff00000),d0\n+\tmovel\tIMM (0),d1\n \torl\td7,d0\n-\tmovew\t#OVERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#DOUBLE_FLOAT,d6\n+\tmovew\tIMM (OVERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$underflow:\n | Return 0 and set the exception flags \n-\tmovel\t#0,d0\n+\tmovel\tIMM (0),d0\n \tmovel\td0,d1\n-\tmovew\t#UNDERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#DOUBLE_FLOAT,d6\n+\tmovew\tIMM (UNDERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$inop:\n | Return a quiet NaN and set the exception flags\n-\tmovel\t#QUIET_NaN,d0\n+\tmovel\tIMM (QUIET_NaN),d0\n \tmovel\td0,d1\n-\tmovew\t#INVALID_OPERATION,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#DOUBLE_FLOAT,d6\n+\tmovew\tIMM (INVALID_OPERATION),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Ld$div$0:\n | Return a properly signed INFINITY and set the exception flags\n-\tmovel\t#0x7ff00000,d0\n-\tmovel\t#0,d1\n+\tmovel\tIMM (0x7ff00000),d0\n+\tmovel\tIMM (0),d1\n \torl\td7,d0\n-\tmovew\t#DIVIDE_BY_ZERO,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#DOUBLE_FLOAT,d6\n+\tmovew\tIMM (DIVIDE_BY_ZERO),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (DOUBLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n |=============================================================================\n@@ -525,15 +533,15 @@ Ld$div$0:\n \n | double __subdf3(double, double);\n SYM (__subdf3):\n-\tbchg\t#31,sp@(12)\t| change sign of second operand\n+\tbchg\tIMM (31),sp@(12) | change sign of second operand\n \t\t\t\t| and fall through, so we always add\n |=============================================================================\n |                              __adddf3\n |=============================================================================\n \n | double __adddf3(double, double);\n SYM (__adddf3):\n-\tlink\ta6,#0\t\t| everything will be done in registers\n+\tlink\ta6,IMM (0)\t| everything will be done in registers\n \tmoveml\td2-d7,sp@-\t| save all data registers and a2 (but d0-d1)\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t| \n@@ -550,9 +558,9 @@ SYM (__adddf3):\n \taddxl\td2,d2\t\t| extra precision\n \tbeq\tLadddf$a\t| if zero return first operand\n \n-\tandl\t#0x80000000,d7\t| isolate a's sign bit '\n+\tandl\tIMM (0x80000000),d7 | isolate a's sign bit '\n         swap\td6\t\t| and also b's sign bit '\n-\tandw\t#0x8000,d6\t|\n+\tandw\tIMM (0x8000),d6\t|\n \torw\td6,d7\t\t| and combine them into d7, so that a's sign '\n \t\t\t\t| bit is in the high word and b's is in the '\n \t\t\t\t| low word, so d6 is free to be used\n@@ -561,8 +569,8 @@ SYM (__adddf3):\n \n | Get the exponents and check for denormalized and/or infinity.\n \n-\tmovel\t#0x001fffff,d6\t| mask for the fraction\n-\tmovel\t#0x00200000,d7\t| mask to put hidden bit back\n+\tmovel\tIMM (0x001fffff),d6 | mask for the fraction\n+\tmovel\tIMM (0x00200000),d7 | mask to put hidden bit back\n \n \tmovel\td0,d4\t\t| \n \tandl\td6,d0\t\t| get fraction in d0\n@@ -574,7 +582,7 @@ SYM (__adddf3):\n \torl\td7,d0\t\t| and put hidden bit back\n Ladddf$1:\n \tswap\td4\t\t| shift right exponent so that it starts\n-\tlsrw\t#5,d4\t\t| in bit 0 and not bit 20\n+\tlsrw\tIMM (5),d4\t| in bit 0 and not bit 20\n | Now we have a's exponent in d4 and fraction in d0-d1 '\n \tmovel\td2,d5\t\t| save b to get exponent\n \tandl\td6,d5\t\t| get exponent in d5\n@@ -586,7 +594,7 @@ Ladddf$1:\n \torl\td7,d2\t\t| and put hidden bit back\n Ladddf$2:\n \tswap\td5\t\t| shift right exponent so that it starts\n-\tlsrw\t#5,d5\t\t| in bit 0 and not bit 20\n+\tlsrw\tIMM (5),d5\t| in bit 0 and not bit 20\n \n | Now we have b's exponent in d5 and fraction in d2-d3. '\n \n@@ -602,7 +610,7 @@ Ladddf$2:\n \tmovel\td4,a2\t\t| save the exponents\n \tmovel\td5,a3\t\t| \n \n-\tmovel\t#0,d7\t\t| and move the numbers around\n+\tmovel\tIMM (0),d7\t| and move the numbers around\n \tmovel\td7,d6\t\t|\n \tmovel\td3,d5\t\t|\n \tmovel\td2,d4\t\t|\n@@ -624,28 +632,28 @@ Ladddf$2:\n \texg\td4,a2\t\t| get back the longs we saved\n \texg\td5,a3\t\t|\n | if difference is too large we don't shift (actually, we can just exit) '\n-\tcmpw\t#DBL_MANT_DIG+2,d2\n+\tcmpw\tIMM (DBL_MANT_DIG+2),d2\n \tbge\tLadddf$b$small\n-\tcmpw\t#32,d2\t\t| if difference >= 32, shift by longs\n+\tcmpw\tIMM (32),d2\t| if difference >= 32, shift by longs\n \tbge\t5f\n-2:\tcmpw\t#16,d2\t\t| if difference >= 16, shift by words\t\n+2:\tcmpw\tIMM (16),d2\t| if difference >= 16, shift by words\t\n \tbge\t6f\n \tbra\t3f\t\t| enter dbra loop\n \n-4:\tlsrl\t#1,d4\n-\troxrl\t#1,d5\n-\troxrl\t#1,d6\n-\troxrl\t#1,d7\n+4:\tlsrl\tIMM (1),d4\n+\troxrl\tIMM (1),d5\n+\troxrl\tIMM (1),d6\n+\troxrl\tIMM (1),d7\n 3:\tdbra\td2,4b\n-\tmovel\t#0,d2\n+\tmovel\tIMM (0),d2\n \tmovel\td2,d3\t\n \tbra\tLadddf$4\n 5:\n \tmovel\td6,d7\n \tmovel\td5,d6\n \tmovel\td4,d5\n-\tmovel\t#0,d4\n-\tsubw\t#32,d2\n+\tmovel\tIMM (0),d4\n+\tsubw\tIMM (32),d2\n \tbra\t2b\n 6:\n \tmovew\td6,d7\n@@ -654,9 +662,9 @@ Ladddf$2:\n \tswap\td6\n \tmovew\td4,d5\n \tswap\td5\n-\tmovew\t#0,d4\n+\tmovew\tIMM (0),d4\n \tswap\td4\n-\tsubw\t#16,d2\n+\tsubw\tIMM (16),d2\n \tbra\t3b\n \t\n 9:\texg\td4,d5\n@@ -665,28 +673,28 @@ Ladddf$2:\n \texg\td4,a2\n \texg\td5,a3\n | if difference is too large we don't shift (actually, we can just exit) '\n-\tcmpw\t#DBL_MANT_DIG+2,d6\n+\tcmpw\tIMM (DBL_MANT_DIG+2),d6\n \tbge\tLadddf$a$small\n-\tcmpw\t#32,d6\t\t| if difference >= 32, shift by longs\n+\tcmpw\tIMM (32),d6\t| if difference >= 32, shift by longs\n \tbge\t5f\n-2:\tcmpw\t#16,d6\t\t| if difference >= 16, shift by words\t\n+2:\tcmpw\tIMM (16),d6\t| if difference >= 16, shift by words\t\n \tbge\t6f\n \tbra\t3f\t\t| enter dbra loop\n \n-4:\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n+4:\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n 3:\tdbra\td6,4b\n-\tmovel\t#0,d7\n+\tmovel\tIMM (0),d7\n \tmovel\td7,d6\n \tbra\tLadddf$4\n 5:\n \tmovel\td2,d3\n \tmovel\td1,d2\n \tmovel\td0,d1\n-\tmovel\t#0,d0\n-\tsubw\t#32,d6\n+\tmovel\tIMM (0),d0\n+\tsubw\tIMM (32),d6\n \tbra\t2b\n 6:\n \tmovew\td2,d3\n@@ -695,9 +703,9 @@ Ladddf$2:\n \tswap\td2\n \tmovew\td0,d1\n \tswap\td1\n-\tmovew\t#0,d0\n+\tmovew\tIMM (0),d0\n \tswap\td0\n-\tsubw\t#16,d6\n+\tsubw\tIMM (16),d6\n \tbra\t3b\n Ladddf$3:\n \texg\td4,a2\t\n@@ -710,9 +718,9 @@ Ladddf$4:\n \texg\td7,a0\t\t| get the signs \n \texg\td6,a3\t\t| a3 is free to be used\n \tmovel\td7,d6\t\t|\n-\tmovew\t#0,d7\t        | get a's sign in d7 '\n+\tmovew\tIMM (0),d7\t| get a's sign in d7 '\n \tswap\td6              |\n-\tmovew\t#0,d6           | and b's sign in d6 '\n+\tmovew\tIMM (0),d6\t| and b's sign in d6 '\n \teorl\td7,d6\t\t| compare the signs\n \tbmi\tLsubdf$0\t| if the signs are different we have \n \t\t\t\t| to substract\n@@ -725,42 +733,42 @@ Ladddf$4:\n \n \tmovel\ta2,d4\t\t| return exponent to d4\n \tmovel\ta0,d7\t\t| \n-\tandl\t#0x80000000,d7\t| d7 now has the sign\n+\tandl\tIMM (0x80000000),d7 | d7 now has the sign\n \n \tmoveml\tsp@+,a2-a3\t\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the substraction!) we could have set \n | one more bit we check this:\n-\tbtst\t#DBL_MANT_DIG+1,d0\t\n+\tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n-\taddw\t#1,d4\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n+\taddw\tIMM (1),d4\n 1:\n \tlea\tLadddf$5,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Ladddf$5:\n | Put back the exponent and check for overflow\n-\tcmpw\t#0x7ff,d4\t| is the exponent big?\n+\tcmpw\tIMM (0x7ff),d4\t| is the exponent big?\n \tbge\t1f\n-\tbclr\t#DBL_MANT_DIG-1,d0\n-\tlslw\t#4,d4\t\t| put exponent back into position\n+\tbclr\tIMM (DBL_MANT_DIG-1),d0\n+\tlslw\tIMM (4),d4\t| put exponent back into position\n \tswap\td0\t\t| \n \torw\td4,d0\t\t|\n \tswap\td0\t\t|\n \tbra\tLadddf$ret\n 1:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n \tbra\tLd$overflow\n \n Lsubdf$0:\n@@ -774,7 +782,7 @@ Lsubdf$0:\n \tbeq\tLadddf$ret$1\t| if zero just exit\n \tbpl\t1f\t\t| if positive skip the following\n \texg\td7,a0\t\t|\n-\tbchg\t#31,d7\t\t| change sign bit in d7\n+\tbchg\tIMM (31),d7\t| change sign bit in d7\n \texg\td7,a0\t\t|\n \tnegl\td3\t\t|\n \tnegxl\td2\t\t|\n@@ -783,33 +791,33 @@ Lsubdf$0:\n 1:\t\n \tmovel\ta2,d4\t\t| return exponent to d4\n \tmovel\ta0,d7\n-\tandl\t#0x80000000,d7\t| isolate sign bit\n+\tandl\tIMM (0x80000000),d7 | isolate sign bit\n \tmoveml\tsp@+,a2-a3\t|\n \n | Before rounding normalize so bit #DBL_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the substraction!) we could have set \n | one more bit we check this:\n-\tbtst\t#DBL_MANT_DIG+1,d0\t\n+\tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n-\taddw\t#1,d4\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n+\taddw\tIMM (1),d4\n 1:\n \tlea\tLsubdf$1,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Lsubdf$1:\n | Put back the exponent and sign (we don't have overflow). '\n-\tbclr\t#DBL_MANT_DIG-1,d0\t\n-\tlslw\t#4,d4\t\t| put exponent back into position\n+\tbclr\tIMM (DBL_MANT_DIG-1),d0\t\n+\tlslw\tIMM (4),d4\t| put exponent back into position\n \tswap\td0\t\t| \n \torw\td4,d0\t\t|\n \tswap\td0\t\t|\n@@ -823,7 +831,7 @@ Ladddf$a$small:\n \tmovel\ta6@(16),d0\n \tmovel\ta6@(20),d1\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n@@ -833,7 +841,7 @@ Ladddf$b$small:\n \tmovel\ta6@(8),d0\n \tmovel\ta6@(12),d1\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n@@ -856,54 +864,54 @@ Ladddf$a:\n \tmovel\ta6@(8),d0\n \tmovel\ta6@(12),d1\n 1:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n | Check for NaN and +/-INFINITY.\n-\tmovel\td0,d7         \t|\n-\tandl\t#0x80000000,d7  |\n-\tbclr\t#31,d0\t\t|\n-\tcmpl\t#0x7ff00000,d0\t|\n-\tbge\t2f\t\t|\n-\tmovel\td0,d0           | check for zero, since we don't  '\n-\tbne\tLadddf$ret\t| want to return -0 by mistake\n-\tbclr\t#31,d7\t\t|\n-\tbra\tLadddf$ret\t|\n+\tmovel\td0,d7         \t\t|\n+\tandl\tIMM (0x80000000),d7\t|\n+\tbclr\tIMM (31),d0\t\t|\n+\tcmpl\tIMM (0x7ff00000),d0\t|\n+\tbge\t2f\t\t\t|\n+\tmovel\td0,d0           \t| check for zero, since we don't  '\n+\tbne\tLadddf$ret\t\t| want to return -0 by mistake\n+\tbclr\tIMM (31),d7\t\t|\n+\tbra\tLadddf$ret\t\t|\n 2:\n-\tandl\t#0x000fffff,d0\t| check for NaN (nonzero fraction)\n-\torl\td1,d0\t\t|\n-\tbne\tLd$inop         |\n-\tbra\tLd$infty\t|\n+\tandl\tIMM (0x000fffff),d0\t| check for NaN (nonzero fraction)\n+\torl\td1,d0\t\t\t|\n+\tbne\tLd$inop         \t|\n+\tbra\tLd$infty\t\t|\n \t\n Ladddf$ret$1:\n \tmoveml\tsp@+,a2-a3\t| restore regs and exit\n \n Ladddf$ret:\n | Normal exit.\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \torl\td7,d0\t\t| put sign bit back\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n \n Ladddf$ret$den:\n | Return a denormalized number.\n-\tlsrl\t#1,d0\t\t| shift right once more\n-\troxrl\t#1,d1           |\n+\tlsrl\tIMM (1),d0\t| shift right once more\n+\troxrl\tIMM (1),d1\t|\n \tbra\tLadddf$ret\n \n Ladddf$nf:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n | This could be faster but it is not worth the effort, since it is not\n | executed very often. We sacrifice speed for clarity here.\n \tmovel\ta6@(8),d0\t| get the numbers back (remember that we\n \tmovel\ta6@(12),d1\t| did some processing already)\n \tmovel\ta6@(16),d2\t| \n \tmovel\ta6@(20),d3\t| \n-\tmovel\t#0x7ff00000,d4\t| useful constant (INFINITY)\n+\tmovel\tIMM (0x7ff00000),d4 | useful constant (INFINITY)\n \tmovel\td0,d7\t\t| save sign bits\n \tmovel\td2,d6\t\t| \n-\tbclr\t#31,d0\t\t| clear sign bits\n-\tbclr\t#31,d2\t\t| \n+\tbclr\tIMM (31),d0\t| clear sign bits\n+\tbclr\tIMM (31),d2\t| \n | We know that one of them is either NaN of +/-INFINITY\n | Check for NaN (if either one is NaN return NaN)\n \tcmpl\td4,d0\t\t| check first a (d0)\n@@ -922,7 +930,7 @@ Ladddf$nf:\n | are adding or substracting them.\n \teorl\td7,d6\t\t| to check sign bits\n \tbmi\t1f\n-\tandl\t#0x80000000,d7\t| get (common) sign bit\n+\tandl\tIMM (0x80000000),d7 | get (common) sign bit\n \tbra\tLd$infty\n 1:\n | We know one (or both) are infinite, so we test for equality between the\n@@ -933,10 +941,10 @@ Ladddf$nf:\n \tcmpl\td3,d1\t\t| if d0 == d2 test d3 and d1\n \tbeq\tLd$inop\t\t| if equal return NaN\n 1:\t\n-\tandl\t#0x80000000,d7\t| get a's sign bit '\n+\tandl\tIMM (0x80000000),d7 | get a's sign bit '\n \tcmpl\td4,d0\t\t| test now for infinity\n \tbeq\tLd$infty\t| if a is INFINITY return with this sign\n-\tbchg\t#31,d7\t\t| else we know b is INFINITY and has\n+\tbchg\tIMM (31),d7\t| else we know b is INFINITY and has\n \tbra\tLd$infty\t| the opposite sign\n \n |=============================================================================\n@@ -945,53 +953,53 @@ Ladddf$nf:\n \n | double __muldf3(double, double);\n SYM (__muldf3):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n-\tmovel\ta6@(8),d0\t| get a into d0-d1\n-\tmovel\ta6@(12),d1\t| \n-\tmovel\ta6@(16),d2\t| and b into d2-d3\n-\tmovel\ta6@(20),d3\t|\n-\tmovel\td0,d7\t\t| d7 will hold the sign of the product\n-\teorl\td2,d7\t\t|\n-\tandl\t#0x80000000,d7\t|\n-\tmovel\td7,a0\t\t| save sign bit into a0 \n-\tmovel\t#0x7ff00000,d7\t| useful constant (+INFINITY)\n-\tmovel\td7,d6\t\t| another (mask for fraction)\n-\tnotl\td6\t\t| \n-\tbclr\t#31,d0\t\t| get rid of a's sign bit '\n-\tmovel\td0,d4\t\t| \n-\torl\td1,d4\t\t| \n-\tbeq\tLmuldf$a$0\t| branch if a is zero\n-\tmovel\td0,d4\t\t| \n-\tbclr\t#31,d2\t\t| get rid of b's sign bit '\n-\tmovel\td2,d5\t\t| \n-\torl\td3,d5\t\t| \n-\tbeq\tLmuldf$b$0\t| branch if b is zero\n-\tmovel\td2,d5\t\t| \n-\tcmpl\td7,d0\t\t| is a big?\n-\tbhi\tLmuldf$inop\t| if a is NaN return NaN\n-\tbeq\tLmuldf$a$nf\t| we still have to check d1 and b ...\n-\tcmpl\td7,d2\t\t| now compare b with INFINITY\n-\tbhi\tLmuldf$inop\t| is b NaN?\n-\tbeq\tLmuldf$b$nf \t| we still have to check d3 ...\n+\tmovel\ta6@(8),d0\t\t| get a into d0-d1\n+\tmovel\ta6@(12),d1\t\t| \n+\tmovel\ta6@(16),d2\t\t| and b into d2-d3\n+\tmovel\ta6@(20),d3\t\t|\n+\tmovel\td0,d7\t\t\t| d7 will hold the sign of the product\n+\teorl\td2,d7\t\t\t|\n+\tandl\tIMM (0x80000000),d7\t|\n+\tmovel\td7,a0\t\t\t| save sign bit into a0 \n+\tmovel\tIMM (0x7ff00000),d7\t| useful constant (+INFINITY)\n+\tmovel\td7,d6\t\t\t| another (mask for fraction)\n+\tnotl\td6\t\t\t|\n+\tbclr\tIMM (31),d0\t\t| get rid of a's sign bit '\n+\tmovel\td0,d4\t\t\t| \n+\torl\td1,d4\t\t\t| \n+\tbeq\tLmuldf$a$0\t\t| branch if a is zero\n+\tmovel\td0,d4\t\t\t|\n+\tbclr\tIMM (31),d2\t\t| get rid of b's sign bit '\n+\tmovel\td2,d5\t\t\t|\n+\torl\td3,d5\t\t\t| \n+\tbeq\tLmuldf$b$0\t\t| branch if b is zero\n+\tmovel\td2,d5\t\t\t| \n+\tcmpl\td7,d0\t\t\t| is a big?\n+\tbhi\tLmuldf$inop\t\t| if a is NaN return NaN\n+\tbeq\tLmuldf$a$nf\t\t| we still have to check d1 and b ...\n+\tcmpl\td7,d2\t\t\t| now compare b with INFINITY\n+\tbhi\tLmuldf$inop\t\t| is b NaN?\n+\tbeq\tLmuldf$b$nf \t\t| we still have to check d3 ...\n | Here we have both numbers finite and nonzero (and with no sign bit).\n | Now we get the exponents into d4 and d5.\n-\tandl\td7,d4\t\t| isolate exponent in d4\n-\tbeq\tLmuldf$a$den\t| if exponent is zero we have a denormalized\n-\tandl\td6,d0\t\t| isolate fraction\n-\torl\t#0x00100000,d0\t| and put hidden bit back\n-\tswap\td4\t\t| I like exponents in the first byte\n-\tlsrw\t#4,d4\t\t| \n+\tandl\td7,d4\t\t\t| isolate exponent in d4\n+\tbeq\tLmuldf$a$den\t\t| if exponent zero, have denormalized\n+\tandl\td6,d0\t\t\t| isolate fraction\n+\torl\tIMM (0x00100000),d0\t| and put hidden bit back\n+\tswap\td4\t\t\t| I like exponents in the first byte\n+\tlsrw\tIMM (4),d4\t\t| \n Lmuldf$1:\t\t\t\n-\tandl\td7,d5\t\t|\n-\tbeq\tLmuldf$b$den\t|\n-\tandl\td6,d2\t\t|\n-\torl\t#0x00100000,d2\t| and put hidden bit back\n-\tswap\td5\t\t|\n-\tlsrw\t#4,d5\t\t|\n-Lmuldf$2:\t\t\t|\n-\taddw\td5,d4\t\t| add exponents\n-\tsubw\t#D_BIAS+1,d4\t| and substract bias (plus one)\n+\tandl\td7,d5\t\t\t|\n+\tbeq\tLmuldf$b$den\t\t|\n+\tandl\td6,d2\t\t\t|\n+\torl\tIMM (0x00100000),d2\t| and put hidden bit back\n+\tswap\td5\t\t\t|\n+\tlsrw\tIMM (4),d5\t\t|\n+Lmuldf$2:\t\t\t\t|\n+\taddw\td5,d4\t\t\t| add exponents\n+\tsubw\tIMM (D_BIAS+1),d4\t| and substract bias (plus one)\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit 52 ( bit 20 of d0 and d2) set (even if they were \n@@ -1004,30 +1012,30 @@ Lmuldf$2:\t\t\t|\n | some intermediate data.\n \n \tmoveml\ta2-a3,sp@-\t| save a2 and a3 for temporary use\n-\tmovel\t#0,a2\t\t| a2 is a null register\n+\tmovel\tIMM (0),a2\t| a2 is a null register\n \tmovel\td4,a3\t\t| and a3 will preserve the exponent\n \n | First, shift d2-d3 so bit 20 becomes bit 31:\n-\trorl\t#5,d2\t\t| rotate d2 5 places right\n+\trorl\tIMM (5),d2\t| rotate d2 5 places right\n \tswap\td2\t\t| and swap it\n-\trorl\t#5,d3\t\t| do the same thing with d3\n+\trorl\tIMM (5),d3\t| do the same thing with d3\n \tswap\td3\t\t|\n \tmovew\td3,d6\t\t| get the rightmost 11 bits of d3\n-\tandw\t#0x07ff,d6\t|\n+\tandw\tIMM (0x07ff),d6\t|\n \torw\td6,d2\t\t| and put them into d2\n-\tandw\t#0xf800,d3\t| clear those bits in d3\n+\tandw\tIMM (0xf800),d3\t| clear those bits in d3\n \n \tmovel\td2,d6\t\t| move b into d6-d7\n \tmovel\td3,d7           | move a into d4-d5\n \tmovel\td0,d4           | and clear d0-d1-d2-d3 (to put result)\n \tmovel\td1,d5           |\n-\tmovel\t#0,d3           |\n+\tmovel\tIMM (0),d3\t|\n \tmovel\td3,d2           |\n \tmovel\td3,d1           |\n \tmovel\td3,d0\t        |\n \n | We use a1 as counter:\t\n-\tmovel\t#DBL_MANT_DIG-1,a1\t\t\n+\tmovel\tIMM (DBL_MANT_DIG-1),a1\t\t\n \texg\td7,a1\n \n 1:\texg\td7,a1\t\t| put counter back in a1\n@@ -1060,44 +1068,44 @@ Lmuldf$2:\t\t\t|\n \tmovew\td2,d1\n \tswap\td3\n \tmovew\td3,d2\n-\tmovew\t#0,d3\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n+\tmovew\tIMM (0),d3\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n \t\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \n-\tbtst\t#DBL_MANT_DIG+1-32,d0\n+\tbtst\tIMM (DBL_MANT_DIG+1-32),d0\n \tbeq\tLround$exit\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\taddw\t#1,d4\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\taddw\tIMM (1),d4\n \tbra\tLround$exit\n \n Lmuldf$inop:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \tbra\tLd$inop\n \n Lmuldf$b$nf:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n \ttstl\td3\t\t| we know d2 == 0x7ff00000, so check d3\n \tbne\tLd$inop\t\t| if d3 <> 0 b is NaN\n \tbra\tLd$overflow\t| else we have overflow (since a is finite)\n \n Lmuldf$a$nf:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \tmovel\ta0,d7\t\t| get sign bit back into d7\n \ttstl\td1\t\t| we know d0 == 0x7ff00000, so check d1\n \tbne\tLd$inop\t\t| if d1 <> 0 a is NaN\n@@ -1106,18 +1114,18 @@ Lmuldf$a$nf:\n | If either number is zero return zero, unless the other is +/-INFINITY or\n | NaN, in which case we return NaN.\n Lmuldf$b$0:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \texg\td2,d0\t\t| put b (==0) into d0-d1\n \texg\td3,d1\t\t| and a (with sign bit cleared) into d2-d3\n \tbra\t1f\n Lmuldf$a$0:\n \tmovel\ta6@(16),d2\t| put b into d2-d3 again\n \tmovel\ta6@(20),d3\t|\n-\tbclr\t#31,d2\t\t| clear sign bit\n-1:\tcmpl\t#0x7ff00000,d2\t| check for non-finiteness\n+\tbclr\tIMM (31),d2\t| clear sign bit\n+1:\tcmpl\tIMM (0x7ff00000),d2 | check for non-finiteness\n \tbge\tLd$inop\t\t| in case NaN or +/-INFINITY return NaN\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n@@ -1127,22 +1135,22 @@ Lmuldf$a$0:\n | (the hidden bit) is set, adjusting the exponent accordingly. We do this\n | to ensure that the product of the fractions is close to 1.\n Lmuldf$a$den:\n-\tmovel\t#1,d4\n+\tmovel\tIMM (1),d4\n \tandl\td6,d0\n 1:\taddl\td1,d1           | shift a left until bit 20 is set\n \taddxl\td0,d0\t\t|\n-\tsubw\t#1,d4\t\t| and adjust exponent\n-\tbtst\t#20,d0          |\n+\tsubw\tIMM (1),d4\t| and adjust exponent\n+\tbtst\tIMM (20),d0\t|\n \tbne\tLmuldf$1        |\n \tbra\t1b\n \n Lmuldf$b$den:\n-\tmovel\t#1,d5\n+\tmovel\tIMM (1),d5\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\t\t|\n-\tsubw\t#1,d5\t\t| and adjust exponent\n-\tbtst\t#20,d2\t\t|\n+\tsubw\tIMM (1),d5\t| and adjust exponent\n+\tbtst\tIMM (20),d2\t|\n \tbne\tLmuldf$2\t|\n \tbra\t1b\n \n@@ -1153,25 +1161,25 @@ Lmuldf$b$den:\n \n | double __divdf3(double, double);\n SYM (__divdf3):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n \tmovel\ta6@(8),d0\t| get a into d0-d1\n \tmovel\ta6@(12),d1\t| \n \tmovel\ta6@(16),d2\t| and b into d2-d3\n \tmovel\ta6@(20),d3\t|\n \tmovel\td0,d7\t\t| d7 will hold the sign of the result\n \teorl\td2,d7\t\t|\n-\tandl\t#0x80000000,d7\t| \n+\tandl\tIMM (0x80000000),d7\n \tmovel\td7,a0\t\t| save sign into a0\n-\tmovel\t#0x7ff00000,d7\t| useful constant (+INFINITY)\n+\tmovel\tIMM (0x7ff00000),d7 | useful constant (+INFINITY)\n \tmovel\td7,d6\t\t| another (mask for fraction)\n \tnotl\td6\t\t|\n-\tbclr\t#31,d0\t\t| get rid of a's sign bit '\n+\tbclr\tIMM (31),d0\t| get rid of a's sign bit '\n \tmovel\td0,d4\t\t|\n \torl\td1,d4\t\t|\n \tbeq\tLdivdf$a$0\t| branch if a is zero\n \tmovel\td0,d4\t\t|\n-\tbclr\t#31,d2\t\t| get rid of b's sign bit '\n+\tbclr\tIMM (31),d2\t| get rid of b's sign bit '\n \tmovel\td2,d5\t\t|\n \torl\td3,d5\t\t|\n \tbeq\tLdivdf$b$0\t| branch if b is zero\n@@ -1191,19 +1199,19 @@ SYM (__divdf3):\n \tandl\td7,d4\t\t| and isolate exponent in d4\n \tbeq\tLdivdf$a$den\t| if exponent is zero we have a denormalized\n \tandl\td6,d0\t\t| and isolate fraction\n-\torl\t#0x00100000,d0\t| and put hidden bit back\n+\torl\tIMM (0x00100000),d0 | and put hidden bit back\n \tswap\td4\t\t| I like exponents in the first byte\n-\tlsrw\t#4,d4\t\t| \n+\tlsrw\tIMM (4),d4\t| \n Ldivdf$1:\t\t\t| \n \tandl\td7,d5\t\t|\n \tbeq\tLdivdf$b$den\t|\n \tandl\td6,d2\t\t|\n-\torl\t#0x00100000,d2\t|\n+\torl\tIMM (0x00100000),d2\n \tswap\td5\t\t|\n-\tlsrw\t#4,d5\t\t|\n+\tlsrw\tIMM (4),d5\t|\n Ldivdf$2:\t\t\t|\n \tsubw\td5,d4\t\t| substract exponents\n-\taddw\t#D_BIAS,d4\t| and add bias\n+\taddw\tIMM (D_BIAS),d4\t| and add bias\n \n | We are now ready to do the division. We have prepared things in such a way\n | that the ratio of the fractions will be less than 2 but greater than 1/2.\n@@ -1220,11 +1228,11 @@ Ldivdf$2:\t\t\t|\n | I did), but use a sticky bit to preserve information about the \n | fractional part. Note that we can keep that info in a1, which is not\n | used.\n-\tmovel\t#0,d6\t\t| d6-d7 will hold the result\n+\tmovel\tIMM (0),d6\t| d6-d7 will hold the result\n \tmovel\td6,d7\t\t| \n-\tmovel\t#0,a1\t\t| and a1 will hold the sticky bit\n+\tmovel\tIMM (0),a1\t| and a1 will hold the sticky bit\n \n-\tmovel\t#DBL_MANT_DIG-32+1,d5\t\n+\tmovel\tIMM (DBL_MANT_DIG-32+1),d5\t\n \t\n 1:\tcmpl\td0,d2\t\t| is a < b?\n \tbhi\t3f\t\t| if b > a skip the following\n@@ -1241,7 +1249,7 @@ Ldivdf$2:\t\t\t|\n \tbra\t2b\t\t| else go do it\n 5:\n | Here we have to start setting the bits in the second long.\n-\tmovel\t#31,d5\t\t| again d5 is counter\n+\tmovel\tIMM (31),d5\t| again d5 is counter\n \n 1:\tcmpl\td0,d2\t\t| is a < b?\n \tbhi\t3f\t\t| if b > a skip the following\n@@ -1258,102 +1266,102 @@ Ldivdf$2:\t\t\t|\n \tbra\t2b\t\t| else go do it\n 5:\n | Now go ahead checking until we hit a one, which we store in d2.\n-\tmovel\t#DBL_MANT_DIG,d5\n+\tmovel\tIMM (DBL_MANT_DIG),d5\n 1:\tcmpl\td2,d0\t\t| is a < b?\n \tbhi\t4f\t\t| if b < a, exit\n \tbeq\t3f\t\t| if d0==d2 check d1 and d3\n 2:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n \tdbra\td5,1b\t\t| and branch back\n-\tmovel\t#0,d2\t\t| here no sticky bit was found\n+\tmovel\tIMM (0),d2\t| here no sticky bit was found\n \tmovel\td2,d3\n \tbra\t5f\t\t\t\n 3:\tcmpl\td1,d3\t\t| here d0==d2, so check d1 and d3\n \tbhi\t2b\t\t| if d1 > d2 go back\n 4:\n | Here put the sticky bit in d2-d3 (in the position which actually corresponds\n | to it; if you don't do this the algorithm loses in some cases). '\n-\tmovel\t#0,d2\n+\tmovel\tIMM (0),d2\n \tmovel\td2,d3\n-\tsubw\t#DBL_MANT_DIG,d5\n-\taddw\t#63,d5\n-\tcmpw\t#31,d5\n+\tsubw\tIMM (DBL_MANT_DIG),d5\n+\taddw\tIMM (63),d5\n+\tcmpw\tIMM (31),d5\n \tbhi\t2f\n 1:\tbset\td5,d3\n \tbra\t5f\n-\tsubw\t#32,d5\n+\tsubw\tIMM (32),d5\n 2:\tbset\td5,d2\n 5:\n | Finally we are finished! Move the longs in the address registers to\n | their final destination:\n \tmovel\td6,d0\n \tmovel\td7,d1\n-\tmovel\t#0,d3\n+\tmovel\tIMM (0),d3\n \n | Here we have finished the division, with the result in d0-d1-d2-d3, with\n | 2^21 <= d6 < 2^23. Thus bit 23 is not set, but bit 22 could be set.\n | If it is not, then definitely bit 21 is set. Normalize so bit 22 is\n | not set:\n-\tbtst\t#DBL_MANT_DIG-32+1,d0\n+\tbtst\tIMM (DBL_MANT_DIG-32+1),d0\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\troxrl\t#1,d2\n-\troxrl\t#1,d3\n-\taddw\t#1,d4\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\troxrl\tIMM (1),d2\n+\troxrl\tIMM (1),d3\n+\taddw\tIMM (1),d4\n 1:\n | Now round, check for over- and underflow, and exit.\n \tmovel\ta0,d7\t\t| restore sign bit to d7\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLround$exit\n \n Ldivdf$inop:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLd$inop\n \n Ldivdf$a$0:\n | If a is zero check to see whether b is zero also. In that case return\n | NaN; then check if b is NaN, and return NaN also in that case. Else\n | return zero.\n-\tmovew\t#DIVIDE,d5\n-\tbclr\t#31,d2\t\t|\n+\tmovew\tIMM (DIVIDE),d5\n+\tbclr\tIMM (31),d2\t|\n \tmovel\td2,d4\t\t| \n \torl\td3,d4\t\t| \n \tbeq\tLd$inop\t\t| if b is also zero return NaN\n-\tcmpl\t#0x7ff00000,d2\t| check for NaN\n+\tcmpl\tIMM (0x7ff00000),d2 | check for NaN\n \tbhi\tLd$inop\t\t| \n \tblt\t1f\t\t|\n \ttstl\td3\t\t|\n \tbne\tLd$inop\t\t|\n-1:\tmovel\t#0,d0\t\t| else return zero\n+1:\tmovel\tIMM (0),d0\t| else return zero\n \tmovel\td0,d1\t\t| \n \tlea\tSYM (_fpCCR),a0\t| clear exception flags\n-\tmovew\t#0,a0@\t\t|\n+\tmovew\tIMM (0),a0@\t|\n \tmoveml\tsp@+,d2-d7\t| \n \tunlk\ta6\t\t| \n \trts\t\t\t| \t\n \n Ldivdf$b$0:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If we got here a is not zero. Check if a is NaN; in that case return NaN,\n | else return +/-INFINITY. Remember that a is in d0 with the sign bit \n | cleared already.\n \tmovel\ta0,d7\t\t| put a's sign bit back in d7 '\n-\tcmpl\t#0x7ff00000,d0\t| compare d0 with INFINITY\n+\tcmpl\tIMM (0x7ff00000),d0 | compare d0 with INFINITY\n \tbhi\tLd$inop\t\t| if larger it is NaN\n \ttstl\td1\t\t| \n \tbne\tLd$inop\t\t| \n \tbra\tLd$div$0\t| else signal DIVIDE_BY_ZERO\n \n Ldivdf$b$nf:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If d2 == 0x7ff00000 we have to check d3.\n \ttstl\td3\t\t|\n \tbne\tLd$inop\t\t| if d3 <> 0, b is NaN\n \tbra\tLd$underflow\t| else b is +/-INFINITY, so signal underflow\n \n Ldivdf$a$nf:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If d0 == 0x7ff00000 we have to check d1.\n \ttstl\td1\t\t|\n \tbne\tLd$inop\t\t| if d1 <> 0, a is NaN\n@@ -1367,22 +1375,22 @@ Ldivdf$a$nf:\n | If a number is denormalized we put an exponent of 1 but do not put the \n | bit back into the fraction.\n Ldivdf$a$den:\n-\tmovel\t#1,d4\n+\tmovel\tIMM (1),d4\n \tandl\td6,d0\n 1:\taddl\td1,d1\t\t| shift a left until bit 20 is set\n \taddxl\td0,d0\n-\tsubw\t#1,d4\t\t| and adjust exponent\n-\tbtst\t#DBL_MANT_DIG-32-1,d0\n+\tsubw\tIMM (1),d4\t| and adjust exponent\n+\tbtst\tIMM (DBL_MANT_DIG-32-1),d0\n \tbne\tLdivdf$1\n \tbra\t1b\n \n Ldivdf$b$den:\n-\tmovel\t#1,d5\n+\tmovel\tIMM (1),d5\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\n-\tsubw\t#1,d5\t\t| and adjust exponent\n-\tbtst\t#DBL_MANT_DIG-32-1,d2\n+\tsubw\tIMM (1),d5\t| and adjust exponent\n+\tbtst\tIMM (DBL_MANT_DIG-32-1),d2\n \tbne\tLdivdf$2\n \tbra\t1b\n \n@@ -1392,25 +1400,25 @@ Lround$exit:\n | so that 2^21 <= d0 < 2^22, and the exponent is in the lower byte of d4.\n \n | First check for underlow in the exponent:\n-\tcmpw\t#-DBL_MANT_DIG-1,d4\t\t\n+\tcmpw\tIMM (-DBL_MANT_DIG-1),d4\t\t\n \tblt\tLd$underflow\t\n | It could happen that the exponent is less than 1, in which case the \n | number is denormalized. In this case we shift right and adjust the \n | exponent until it becomes 1 or the fraction is zero (in the latter case \n | we signal underflow and return zero).\n \tmovel\td7,a0\t\t|\n-\tmovel\t#0,d6\t\t| use d6-d7 to collect bits flushed right\n+\tmovel\tIMM (0),d6\t| use d6-d7 to collect bits flushed right\n \tmovel\td6,d7\t\t| use d6-d7 to collect bits flushed right\n-\tcmpw\t#1,d4\t\t| if the exponent is less than 1 we \n+\tcmpw\tIMM (1),d4\t| if the exponent is less than 1 we \n \tbge\t2f\t\t| have to shift right (denormalize)\n-1:\taddw\t#1,d4\t\t| adjust the exponent\n-\tlsrl\t#1,d0\t\t| shift right once \n-\troxrl\t#1,d1\t\t|\n-\troxrl\t#1,d2\t\t|\n-\troxrl\t#1,d3\t\t|\n-\troxrl\t#1,d6\t\t| \n-\troxrl\t#1,d7\t\t|\n-\tcmpw\t#1,d4\t\t| is the exponent 1 already?\n+1:\taddw\tIMM (1),d4\t| adjust the exponent\n+\tlsrl\tIMM (1),d0\t| shift right once \n+\troxrl\tIMM (1),d1\t|\n+\troxrl\tIMM (1),d2\t|\n+\troxrl\tIMM (1),d3\t|\n+\troxrl\tIMM (1),d6\t| \n+\troxrl\tIMM (1),d7\t|\n+\tcmpw\tIMM (1),d4\t| is the exponent 1 already?\n \tbeq\t2f\t\t| if not loop back\n \tbra\t1b              |\n \tbra\tLd$underflow\t| safety check, shouldn't execute '\n@@ -1422,7 +1430,7 @@ Lround$exit:\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n@@ -1434,22 +1442,22 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 0x7ff).\n-\tcmpw\t#0x07ff,d4\n+\tcmpw\tIMM (0x07ff),d4\n \tbge\tLd$overflow\n | Now check for a denormalized number (exponent==0):\n \tmovew\td4,d4\n \tbeq\tLd$den\n 1:\n | Put back the exponents and sign and return.\n-\tlslw\t#4,d4\t\t| exponent back to fourth byte\n-\tbclr\t#DBL_MANT_DIG-32-1,d0\n+\tlslw\tIMM (4),d4\t| exponent back to fourth byte\n+\tbclr\tIMM (DBL_MANT_DIG-32-1),d0\n \tswap\td0\t\t| and put back exponent\n \torw\td4,d0\t\t| \n \tswap\td0\t\t|\n \torl\td7,d0\t\t| and sign also\n \n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n@@ -1460,31 +1468,31 @@ Lround$0:\n \n | double __negdf2(double, double);\n SYM (__negdf2):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n-\tmovew\t#NEGATE,d5\n+\tmovew\tIMM (NEGATE),d5\n \tmovel\ta6@(8),d0\t| get number to negate in d0-d1\n \tmovel\ta6@(12),d1\t|\n-\tbchg\t#31,d0\t\t| negate\n+\tbchg\tIMM (31),d0\t| negate\n \tmovel\td0,d2\t\t| make a positive copy (for the tests)\n-\tbclr\t#31,d2\t\t|\n+\tbclr\tIMM (31),d2\t|\n \tmovel\td2,d4\t\t| check for zero\n \torl\td1,d4\t\t|\n \tbeq\t2f\t\t| if zero (either sign) return +zero\n-\tcmpl\t#0x7ff00000,d2\t| compare to +INFINITY\n+\tcmpl\tIMM (0x7ff00000),d2 | compare to +INFINITY\n \tblt\t1f\t\t| if finite, return\n \tbhi\tLd$inop\t\t| if larger (fraction not zero) is NaN\n \ttstl\td1\t\t| if d2 == 0x7ff00000 check d1\n \tbne\tLd$inop\t\t|\n \tmovel\td0,d7\t\t| else get sign and return INFINITY\n-\tandl\t#0x80000000,d7\n+\tandl\tIMM (0x80000000),d7\n \tbra\tLd$infty\t\t\n 1:\tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n-2:\tbclr\t#31,d0\n+2:\tbclr\tIMM (31),d0\n \tbra\t1b\n \n |=============================================================================\n@@ -1497,27 +1505,27 @@ EQUAL   =  0\n \n | int __cmpdf2(double, double);\n SYM (__cmpdf2):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@- \t| save registers\n-\tmovew\t#COMPARE,d5\n+\tmovew\tIMM (COMPARE),d5\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t|\n \tmovel\ta6@(16),d2\t| get second operand\n \tmovel\ta6@(20),d3\t|\n | First check if a and/or b are (+/-) zero and in that case clear\n | the sign bit.\n \tmovel\td0,d6\t\t| copy signs into d6 (a) and d7(b)\n-\tbclr\t#31,d0\t\t| and clear signs in d0 and d2\n+\tbclr\tIMM (31),d0\t| and clear signs in d0 and d2\n \tmovel\td2,d7\t\t|\n-\tbclr\t#31,d2\t\t|\n-\tcmpl\t#0x7fff0000,d0\t| check for a == NaN\n+\tbclr\tIMM (31),d2\t|\n+\tcmpl\tIMM (0x7fff0000),d0 | check for a == NaN\n \tbhi\tLd$inop\t\t| if d0 > 0x7ff00000, a is NaN\n \tbeq\tLcmpdf$a$nf\t| if equal can be INFINITY, so check d1\n \tmovel\td0,d4\t\t| copy into d4 to test for zero\n \torl\td1,d4\t\t|\n \tbeq\tLcmpdf$a$0\t|\n Lcmpdf$0:\n-\tcmpl\t#0x7fff0000,d2\t| check for b == NaN\n+\tcmpl\tIMM (0x7fff0000),d2 | check for b == NaN\n \tbhi\tLd$inop\t\t| if d2 > 0x7ff00000, b is NaN\n \tbeq\tLcmpdf$b$nf\t| if equal can be INFINITY, so check d3\n \tmovel\td2,d4\t\t|\n@@ -1549,26 +1557,26 @@ Lcmpdf$1:\n \tbhi\tLcmpdf$b$gt$a\t| |b| > |a|\n \tbne\tLcmpdf$a$gt$b\t| |b| < |a|\n | If we got here a == b.\n-\tmovel\t#EQUAL,d0\n+\tmovel\tIMM (EQUAL),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n Lcmpdf$a$gt$b:\n-\tmovel\t#GREATER,d0\n+\tmovel\tIMM (GREATER),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n Lcmpdf$b$gt$a:\n-\tmovel\t#LESS,d0\n+\tmovel\tIMM (LESS),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n \n Lcmpdf$a$0:\t\n-\tbclr\t#31,d6\n+\tbclr\tIMM (31),d6\n \tbra\tLcmpdf$0\n Lcmpdf$b$0:\n-\tbclr\t#31,d7\n+\tbclr\tIMM (31),d7\n \tbra\tLcmpdf$1\n \n Lcmpdf$a$nf:\n@@ -1597,12 +1605,12 @@ Lround$to$nearest:\n | before entering the rounding routine), but the number could be denormalized.\n \n | Check for denormalized numbers:\n-1:\tbtst\t#DBL_MANT_DIG-32,d0\n+1:\tbtst\tIMM (DBL_MANT_DIG-32),d0\n \tbne\t2f\t\t| if set the number is normalized\n | Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -D_BIAS+1).\n-\tcmpw\t#1,d4\t\t| remember that the exponent is at least one\n+\tcmpw\tIMM (1),d4\t| remember that the exponent is at least one\n  \tbeq\t2f\t\t| an exponent of one means denormalized\n \taddl\td3,d3\t\t| else shift and adjust the exponent\n \taddxl\td2,d2\t\t|\n@@ -1615,38 +1623,38 @@ Lround$to$nearest:\n | If delta < 1, do nothing. If delta > 1, add 1 to f. \n | If delta == 1, we make sure the rounded number will be even (odd?) \n | (after shifting).\n-\tbtst\t#0,d1\t\t| is delta < 1?\n+\tbtst\tIMM (0),d1\t| is delta < 1?\n \tbeq\t2f\t\t| if so, do not do anything\n \torl\td2,d3\t\t| is delta == 1?\n \tbne\t1f\t\t| if so round to even\n \tmovel\td1,d3\t\t| \n-\tandl\t#2,d3\t\t| bit 1 is the last significant bit\n-\tmovel\t#0,d2\t\t|\n+\tandl\tIMM (2),d3\t| bit 1 is the last significant bit\n+\tmovel\tIMM (0),d2\t|\n \taddl\td3,d1\t\t|\n \taddxl\td2,d0\t\t|\n \tbra\t2f\t\t| \n-1:\tmovel\t#1,d3\t\t| else add 1 \n-\tmovel\t#0,d2\t\t|\n+1:\tmovel\tIMM (1),d3\t| else add 1 \n+\tmovel\tIMM (0),d2\t|\n \taddl\td3,d1\t\t|\n \taddxl\td2,d0\n | Shift right once (because we used bit #DBL_MANT_DIG-32!).\n-2:\tlsrl\t#1,d0\n-\troxrl\t#1,d1\t\t\n+2:\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\t\t\n \n | Now check again bit #DBL_MANT_DIG-32 (rounding could have produced a\n | 'fraction overflow' ...).\n-\tbtst\t#DBL_MANT_DIG-32,d0\t\n+\tbtst\tIMM (DBL_MANT_DIG-32),d0\t\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\taddw\t#1,d4\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\taddw\tIMM (1),d4\n 1:\n | If bit #DBL_MANT_DIG-32-1 is clear we have a denormalized number, so we \n | have to put the exponent to zero and return a denormalized number.\n-\tbtst\t#DBL_MANT_DIG-32-1,d0\n+\tbtst\tIMM (DBL_MANT_DIG-32-1),d0\n \tbeq\t1f\n \tjmp\ta0@\n-1:\tmovel\t#0,d4\n+1:\tmovel\tIMM (0),d4\n \tjmp\ta0@\n \n Lround$to$zero:\n@@ -1710,44 +1718,44 @@ ROUND_TO_MINUS    = 3 | round result towards minus infinity\n Lf$den:\n | Return and signal a denormalized number\n \torl\td7,d0\n-\tmovew\t#UNDERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#SINGLE_FLOAT,d6\n+\tmovew\tIMM (UNDERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$infty:\n Lf$overflow:\n | Return a properly signed INFINITY and set the exception flags \n-\tmovel\t#INFINITY,d0\n+\tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n-\tmovew\t#OVERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#SINGLE_FLOAT,d6\n+\tmovew\tIMM (OVERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$underflow:\n | Return 0 and set the exception flags \n-\tmovel\t#0,d0\n-\tmovew\t#UNDERFLOW,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#SINGLE_FLOAT,d6\n+\tmovel\tIMM (0),d0\n+\tmovew\tIMM (UNDERFLOW),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$inop:\n | Return a quiet NaN and set the exception flags\n-\tmovel\t#QUIET_NaN,d0\n-\tmovew\t#INVALID_OPERATION,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#SINGLE_FLOAT,d6\n+\tmovel\tIMM (QUIET_NaN),d0\n+\tmovew\tIMM (INVALID_OPERATION),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n Lf$div$0:\n | Return a properly signed INFINITY and set the exception flags\n-\tmovel\t#INFINITY,d0\n+\tmovel\tIMM (INFINITY),d0\n \torl\td7,d0\n-\tmovew\t#DIVIDE_BY_ZERO,d7\n-\torw\t#INEXACT_RESULT,d7\n-\tmovew\t#SINGLE_FLOAT,d6\n+\tmovew\tIMM (DIVIDE_BY_ZERO),d7\n+\torw\tIMM (INEXACT_RESULT),d7\n+\tmovew\tIMM (SINGLE_FLOAT),d6\n \tjmp\t$_exception_handler\n \n |=============================================================================\n@@ -1776,15 +1784,15 @@ Lf$div$0:\n \n | float __subsf3(float, float);\n SYM (__subsf3):\n-\tbchg\t#31,sp@(8)\t| change sign of second operand\n+\tbchg\tIMM (31),sp@(8)\t| change sign of second operand\n \t\t\t\t| and fall through\n |=============================================================================\n |                              __addsf3\n |=============================================================================\n \n | float __addsf3(float, float);\n SYM (__addsf3):\n-\tlink\ta6,#0\t\t| everything will be done in registers\n+\tlink\ta6,IMM (0)\t| everything will be done in registers\n \tmoveml\td2-d7,sp@-\t| save all data registers but d0-d1\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t| get second operand\n@@ -1800,8 +1808,8 @@ SYM (__addsf3):\n \n | Get the exponents and check for denormalized and/or infinity.\n \n-\tmovel\t#0x00ffffff,d4\t| mask to get fraction\n-\tmovel\t#0x01000000,d5\t| mask to put hidden bit back\n+\tmovel\tIMM (0x00ffffff),d4\t| mask to get fraction\n+\tmovel\tIMM (0x01000000),d5\t| mask to put hidden bit back\n \n \tmovel\td0,d6\t\t| save a to get exponent\n \tandl\td4,d0\t\t| get fraction in d0\n@@ -1832,7 +1840,7 @@ Laddsf$2:\n \n \tmovel\td1,d2\t\t| move b to d2, since we want to use\n \t\t\t\t| two registers to do the sum\n-\tmovel\t#0,d1\t\t| and clear the new ones\n+\tmovel\tIMM (0),d1\t| and clear the new ones\n \tmovel\td1,d3\t\t|\n \n | Here we shift the numbers in registers d0 and d1 so the exponents are the\n@@ -1845,48 +1853,48 @@ Laddsf$2:\n 1:\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\n-\tlsrw\t#8,d7\t\t| put difference in lower byte\n+\tlsrw\tIMM (8),d7\t| put difference in lower byte\n | if difference is too large we don't shift (actually, we can just exit) '\n-\tcmpw\t#FLT_MANT_DIG+2,d7\t\t\n+\tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n \tbge\tLaddsf$b$small\n-\tcmpw\t#16,d7\t\t| if difference >= 16 swap\n+\tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n \tbge\t4f\n 2:\n-\tsubw\t#1,d7\n-3:\tlsrl\t#1,d2\t\t| shift right second operand\n-\troxrl\t#1,d3\n+\tsubw\tIMM (1),d7\n+3:\tlsrl\tIMM (1),d2\t| shift right second operand\n+\troxrl\tIMM (1),d3\n \tdbra\td7,3b\n \tbra\tLaddsf$3\n 4:\n \tmovew\td2,d3\n \tswap\td3\n \tmovew\td3,d2\n \tswap\td2\n-\tsubw\t#16,d7\n+\tsubw\tIMM (16),d7\n \tbne\t2b\t\t| if still more bits, go back to normal case\n \tbra\tLaddsf$3\n 5:\n \texg\td6,d7\t\t| exchange the exponents\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\t\t|\n-\tlsrw\t#8,d7\t\t| put difference in lower byte\n+\tlsrw\tIMM (8),d7\t| put difference in lower byte\n | if difference is too large we don't shift (and exit!) '\n-\tcmpw\t#FLT_MANT_DIG+2,d7\t\t\n+\tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n \tbge\tLaddsf$a$small\n-\tcmpw\t#16,d7\t\t| if difference >= 16 swap\n+\tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n \tbge\t8f\n 6:\n-\tsubw\t#1,d7\n-7:\tlsrl\t#1,d0\t\t| shift right first operand\n-\troxrl\t#1,d1\n+\tsubw\tIMM (1),d7\n+7:\tlsrl\tIMM (1),d0\t| shift right first operand\n+\troxrl\tIMM (1),d1\n \tdbra\td7,7b\n \tbra\tLaddsf$3\n 8:\n \tmovew\td0,d1\n \tswap\td1\n \tmovew\td1,d0\n \tswap\td0\n-\tsubw\t#16,d7\n+\tsubw\tIMM (16),d7\n \tbne\t6b\t\t| if still more bits, go back to normal case\n \t\t\t\t| otherwise we fall through\n \n@@ -1905,7 +1913,7 @@ Laddsf$3:\n | Here we have both positive or both negative\n \texg\td6,a0\t\t| now we have the exponent in d6\n \tmovel\ta0,d7\t\t| and sign in d7\n-\tandl\t#0x80000000,d7\t|\n+\tandl\tIMM (0x80000000),d7\n | Here we do the addition.\n \taddl\td3,d1\n \taddxl\td2,d0\n@@ -1914,55 +1922,55 @@ Laddsf$3:\n | Put the exponent, in the first byte, in d2, to use the \"standard\" rounding\n | routines:\n \tmovel\td6,d2\n-\tlsrw\t#8,d2\n+\tlsrw\tIMM (8),d2\n \n | Before rounding normalize so bit #FLT_MANT_DIG is set (we will consider\n | the case of denormalized numbers in the rounding routine itself).\n | As in the addition (not in the substraction!) we could have set \n | one more bit we check this:\n-\tbtst\t#FLT_MANT_DIG+1,d0\t\n+\tbtst\tIMM (FLT_MANT_DIG+1),d0\t\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\taddl\t#1,d2\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\taddl\tIMM (1),d2\n 1:\n \tlea\tLaddsf$4,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Laddsf$4:\n | Put back the exponent, but check for overflow.\n-\tcmpw\t#0xff,d2\n+\tcmpw\tIMM (0xff),d2\n \tbhi\t1f\n-\tbclr\t#FLT_MANT_DIG-1,d0\n-\tlslw\t#7,d2\n+\tbclr\tIMM (FLT_MANT_DIG-1),d0\n+\tlslw\tIMM (7),d2\n \tswap\td2\n \torl\td2,d0\n \tbra\tLaddsf$ret\n 1:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n \tbra\tLf$overflow\n \n Lsubsf$0:\n | We are here if a > 0 and b < 0 (sign bits cleared).\n | Here we do the substraction.\n \tmovel\td6,d7\t\t| put sign in d7\n-\tandl\t#0x80000000,d7\t|\n+\tandl\tIMM (0x80000000),d7\n \n \tsubl\td3,d1\t\t| result in d0-d1\n \tsubxl\td2,d0\t\t|\n \tbeq\tLaddsf$ret\t| if zero just exit\n \tbpl\t1f\t\t| if positive skip the following\n-\tbchg\t#31,d7\t\t| change sign bit in d7\n+\tbchg\tIMM (31),d7\t| change sign bit in d7\n \tnegl\td1\n \tnegxl\td0\n 1:\n \texg\td2,a0\t\t| now we have the exponent in d2\n-\tlsrw\t#8,d2\t\t| put it in the first byte\n+\tlsrw\tIMM (8),d2\t| put it in the first byte\n \n | Now d0-d1 is positive and the sign bit is in d7.\n \n@@ -1973,14 +1981,14 @@ Lsubsf$0:\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n Lsubsf$1:\n | Put back the exponent (we can't have overflow!). '\n-\tbclr\t#FLT_MANT_DIG-1,d0\n-\tlslw\t#7,d2\n+\tbclr\tIMM (FLT_MANT_DIG-1),d0\n+\tlslw\tIMM (7),d2\n \tswap\td2\n \torl\td2,d0\n \tbra\tLaddsf$ret\n@@ -1991,15 +1999,15 @@ Lsubsf$1:\n Laddsf$a$small:\n \tmovel\ta6@(12),d0\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n \n Laddsf$b$small:\n \tmovel\ta6@(8),d0\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n@@ -2029,36 +2037,36 @@ Laddsf$a:\n | Return a (if b is zero).\n \tmovel\ta6@(8),d0\n 1:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n | We have to check for NaN and +/-infty.\n \tmovel\td0,d7\n-\tandl\t#0x80000000,d7\t| put sign in d7\n-\tbclr\t#31,d0\t\t| clear sign\n-\tcmpl\t#INFINITY,d0\t| check for infty or NaN\n+\tandl\tIMM (0x80000000),d7\t| put sign in d7\n+\tbclr\tIMM (31),d0\t\t| clear sign\n+\tcmpl\tIMM (INFINITY),d0\t| check for infty or NaN\n \tbge\t2f\n \tmovel\td0,d0\t\t| check for zero (we do this because we don't '\n \tbne\tLaddsf$ret\t| want to return -0 by mistake\n-\tbclr\t#31,d7\t\t| if zero be sure to clear sign\n+\tbclr\tIMM (31),d7\t| if zero be sure to clear sign\n \tbra\tLaddsf$ret\t| if everything OK just return\n 2:\n | The value to be returned is either +/-infty or NaN\n-\tandl\t#0x007fffff,d0\t| check for NaN\n-\tbne\tLf$inop\t\t| if mantissa not zero is NaN\n+\tandl\tIMM (0x007fffff),d0\t| check for NaN\n+\tbne\tLf$inop\t\t\t| if mantissa not zero is NaN\n \tbra\tLf$infty\n \n Laddsf$ret:\n | Normal exit (a and b nonzero, result is not NaN nor +/-infty).\n | We have to clear the exception flags (just the exception type).\n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \torl\td7,d0\t\t| put sign bit\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n \n Laddsf$ret$den:\n | Return a denormalized number (for addition we don't signal underflow) '\n-\tlsrl\t#1,d0\t\t| remember to shift right back once\n+\tlsrl\tIMM (1),d0\t| remember to shift right back once\n \tbra\tLaddsf$ret\t| and return\n \n | Note: when adding two floats of the same sign if either one is \n@@ -2069,16 +2077,16 @@ Laddsf$ret$den:\n | NaN, but if it is finite we return INFINITY with the corresponding sign.\n \n Laddsf$nf:\n-\tmovew\t#ADD,d5\n+\tmovew\tIMM (ADD),d5\n | This could be faster but it is not worth the effort, since it is not\n | executed very often. We sacrifice speed for clarity here.\n \tmovel\ta6@(8),d0\t| get the numbers back (remember that we\n \tmovel\ta6@(12),d1\t| did some processing already)\n-\tmovel\t#INFINITY,d4\t| useful constant (INFINITY)\n+\tmovel\tIMM (INFINITY),d4 | useful constant (INFINITY)\n \tmovel\td0,d2\t\t| save sign bits\n \tmovel\td1,d3\n-\tbclr\t#31,d0\t\t| clear sign bits\n-\tbclr\t#31,d1\n+\tbclr\tIMM (31),d0\t| clear sign bits\n+\tbclr\tIMM (31),d1\n | We know that one of them is either NaN of +/-INFINITY\n | Check for NaN (if either one is NaN return NaN)\n \tcmpl\td4,d0\t\t| check first a (d0)\n@@ -2091,7 +2099,7 @@ Laddsf$nf:\n \teorl\td3,d2\t\t| to check sign bits\n \tbmi\t1f\n \tmovel\td0,d7\n-\tandl\t#0x80000000,d7\t| get (common) sign bit\n+\tandl\tIMM (0x80000000),d7\t| get (common) sign bit\n \tbra\tLf$infty\n 1:\n | We know one (or both) are infinite, so we test for equality between the\n@@ -2101,10 +2109,10 @@ Laddsf$nf:\n \tbeq\tLf$inop\t\t| if so return NaN\n \n \tmovel\td0,d7\n-\tandl\t#0x80000000,d7\t| get a's sign bit '\n+\tandl\tIMM (0x80000000),d7 | get a's sign bit '\n \tcmpl\td4,d0\t\t| test now for infinity\n \tbeq\tLf$infty\t| if a is INFINITY return with this sign\n-\tbchg\t#31,d7\t\t| else we know b is INFINITY and has\n+\tbchg\tIMM (31),d7\t| else we know b is INFINITY and has\n \tbra\tLf$infty\t| the opposite sign\n \n |=============================================================================\n@@ -2113,21 +2121,21 @@ Laddsf$nf:\n \n | float __mulsf3(float, float);\n SYM (__mulsf3):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n \tmovel\ta6@(8),d0\t| get a into d0\n \tmovel\ta6@(12),d1\t| and b into d1\n \tmovel\td0,d7\t\t| d7 will hold the sign of the product\n \teorl\td1,d7\t\t|\n-\tandl\t#0x80000000,d7\t| \n-\tmovel\t#INFINITY,d6\t| useful constant (+INFINITY)\n-\tmovel\td6,d5\t\t| another (mask for fraction)\n-\tnotl\td5\t\t|\n-\tmovel\t#0x00800000,d4\t| this is to put hidden bit back\n-\tbclr\t#31,d0\t\t| get rid of a's sign bit '\n-\tmovel\td0,d2\t\t|\n-\tbeq\tLmulsf$a$0\t| branch if a is zero\n-\tbclr\t#31,d1\t\t| get rid of b's sign bit '\n+\tandl\tIMM (0x80000000),d7\n+\tmovel\tIMM (INFINITY),d6\t| useful constant (+INFINITY)\n+\tmovel\td6,d5\t\t\t| another (mask for fraction)\n+\tnotl\td5\t\t\t|\n+\tmovel\tIMM (0x00800000),d4\t| this is to put hidden bit back\n+\tbclr\tIMM (31),d0\t\t| get rid of a's sign bit '\n+\tmovel\td0,d2\t\t\t|\n+\tbeq\tLmulsf$a$0\t\t| branch if a is zero\n+\tbclr\tIMM (31),d1\t\t| get rid of b's sign bit '\n \tmovel\td1,d3\t\t|\n \tbeq\tLmulsf$b$0\t| branch if b is zero\n \tcmpl\td6,d0\t\t| is a big?\n@@ -2143,17 +2151,17 @@ SYM (__mulsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n-\tlsrw\t#7,d2\t\t| \n+\tlsrw\tIMM (7),d2\t| \n Lmulsf$1:\t\t\t| number\n \tandl\td6,d3\t\t|\n \tbeq\tLmulsf$b$den\t|\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n-\tlsrw\t#7,d3\t\t|\n+\tlsrw\tIMM (7),d3\t|\n Lmulsf$2:\t\t\t|\n \taddw\td3,d2\t\t| add exponents\n-\tsubw\t#F_BIAS+1,d2\t| and substract bias (plus one)\n+\tsubw\tIMM (F_BIAS+1),d2 | and substract bias (plus one)\n \n | We are now ready to do the multiplication. The situation is as follows:\n | both a and b have bit FLT_MANT_DIG-1 set (even if they were \n@@ -2164,18 +2172,18 @@ Lmulsf$2:\t\t\t|\n | To do the multiplication let us move the number a little bit around ...\n \tmovel\td1,d6\t\t| second operand in d6\n \tmovel\td0,d5\t\t| first operand in d4-d5\n-\tmovel\t#0,d4\n+\tmovel\tIMM (0),d4\n \tmovel\td4,d1\t\t| the sums will go in d0-d1\n \tmovel\td4,d0\n \n | now bit FLT_MANT_DIG-1 becomes bit 31:\n-\tlsll\t#31-FLT_MANT_DIG+1,d6\t\t\n+\tlsll\tIMM (31-FLT_MANT_DIG+1),d6\t\t\n \n | Start the loop (we loop #FLT_MANT_DIG times):\n-\tmovew\t#FLT_MANT_DIG-1,d3\t\n+\tmovew\tIMM (FLT_MANT_DIG-1),d3\t\n 1:\taddl\td1,d1\t\t| shift sum \n \taddxl\td0,d0\n-\tlsll\t#1,d6\t\t| get bit bn\n+\tlsll\tIMM (1),d6\t| get bit bn\n \tbcc\t2f\t\t| if not set skip sum\n \taddl\td5,d1\t\t| add a\n \taddxl\td4,d0\n@@ -2184,35 +2192,35 @@ Lmulsf$2:\t\t\t|\n | Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG\n | (mod 32) of d0 set. The first thing to do now is to normalize it so bit \n | FLT_MANT_DIG is set (to do the rounding).\n-\trorl\t#6,d1\n+\trorl\tIMM (6),d1\n \tswap\td1\n \tmovew\td1,d3\n-\tandw\t#0x03ff,d3\n-\tandw\t#0xfd00,d1\n-\tlsll\t#8,d0\n+\tandw\tIMM (0x03ff),d3\n+\tandw\tIMM (0xfd00),d1\n+\tlsll\tIMM (8),d0\n \taddl\td0,d0\n \taddl\td0,d0\n \torw\td3,d0\n \n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \t\n-\tbtst\t#FLT_MANT_DIG+1,d0\n+\tbtst\tIMM (FLT_MANT_DIG+1),d0\n \tbeq\tLround$exit\n-\tlsrl\t#1,d0\n-\troxrl\t#1,d1\n-\taddw\t#1,d2\n+\tlsrl\tIMM (1),d0\n+\troxrl\tIMM (1),d1\n+\taddw\tIMM (1),d2\n \tbra\tLround$exit\n \n Lmulsf$inop:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \tbra\tLf$inop\n \n Lmulsf$overflow:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n \tbra\tLf$overflow\n \n Lmulsf$inf:\n-\tmovew\t#MULTIPLY,d5\n+\tmovew\tIMM (MULTIPLY),d5\n | If either is NaN return NaN; else both are (maybe infinite) numbers, so\n | return INFINITY with the correct sign (which is in d7).\n \tcmpl\td6,d1\t\t| is b NaN?\n@@ -2228,11 +2236,11 @@ Lmulsf$b$0:\n \tbra\t1f\n Lmulsf$a$0:\n \tmovel\ta6@(12),d1\t| get b again to check for non-finiteness\n-1:\tbclr\t#31,d1\t\t| clear sign bit \n-\tcmpl\t#INFINITY,d1\t| and check for a large exponent\n+1:\tbclr\tIMM (31),d1\t| clear sign bit \n+\tcmpl\tIMM (INFINITY),d1 | and check for a large exponent\n \tbge\tLf$inop\t\t| if b is +/-INFINITY or NaN return NaN\n \tlea\tSYM (_fpCCR),a0\t| else return zero\n-\tmovew\t#0,a0@\t\t| \n+\tmovew\tIMM (0),a0@\t| \n \tmoveml\tsp@+,d2-d7\t| \n \tunlk\ta6\t\t| \n \trts\t\t\t| \n@@ -2242,20 +2250,20 @@ Lmulsf$a$0:\n | (the hidden bit) is set, adjusting the exponent accordingly. We do this\n | to ensure that the product of the fractions is close to 1.\n Lmulsf$a$den:\n-\tmovel\t#1,d2\n+\tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left (until bit 23 is set)\n-\tsubw\t#1,d2\t\t| and adjust exponent\n-\tbtst\t#FLT_MANT_DIG-1,d0\n+\tsubw\tIMM (1),d2\t| and adjust exponent\n+\tbtst\tIMM (FLT_MANT_DIG-1),d0\n \tbne\tLmulsf$1\t|\n \tbra\t1b\t\t| else loop back\n \n Lmulsf$b$den:\n-\tmovel\t#1,d3\n+\tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit 23 is set\n-\tsubw\t#1,d3\t\t| and adjust exponent\n-\tbtst\t#FLT_MANT_DIG-1,d1\n+\tsubw\tIMM (1),d3\t| and adjust exponent\n+\tbtst\tIMM (FLT_MANT_DIG-1),d1\n \tbne\tLmulsf$2\t|\n \tbra\t1b\t\t| else loop back\n \n@@ -2265,28 +2273,28 @@ Lmulsf$b$den:\n \n | float __divsf3(float, float);\n SYM (__divsf3):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n-\tmovel\ta6@(8),d0\t| get a into d0\n-\tmovel\ta6@(12),d1\t| and b into d1\n-\tmovel\td0,d7\t\t| d7 will hold the sign of the result\n-\teorl\td1,d7\t\t|\n-\tandl\t#0x80000000,d7\t| \n-\tmovel\t#INFINITY,d6\t| useful constant (+INFINITY)\n-\tmovel\td6,d5\t\t| another (mask for fraction)\n-\tnotl\td5\t\t|\n-\tmovel\t#0x00800000,d4\t| this is to put hidden bit back\n-\tbclr\t#31,d0\t\t| get rid of a's sign bit '\n-\tmovel\td0,d2\t\t|\n-\tbeq\tLdivsf$a$0\t| branch if a is zero\n-\tbclr\t#31,d1\t\t| get rid of b's sign bit '\n-\tmovel\td1,d3\t\t|\n-\tbeq\tLdivsf$b$0\t| branch if b is zero\n-\tcmpl\td6,d0\t\t| is a big?\n-\tbhi\tLdivsf$inop\t| if a is NaN return NaN\n-\tbeq\tLdivsf$inf\t| if a is INIFINITY we have to check b\n-\tcmpl\td6,d1\t\t| now compare b with INFINITY \n-\tbhi\tLdivsf$inop\t| if b is NaN return NaN\n+\tmovel\ta6@(8),d0\t\t| get a into d0\n+\tmovel\ta6@(12),d1\t\t| and b into d1\n+\tmovel\td0,d7\t\t\t| d7 will hold the sign of the result\n+\teorl\td1,d7\t\t\t|\n+\tandl\tIMM (0x80000000),d7\t| \n+\tmovel\tIMM (INFINITY),d6\t| useful constant (+INFINITY)\n+\tmovel\td6,d5\t\t\t| another (mask for fraction)\n+\tnotl\td5\t\t\t|\n+\tmovel\tIMM (0x00800000),d4\t| this is to put hidden bit back\n+\tbclr\tIMM (31),d0\t\t| get rid of a's sign bit '\n+\tmovel\td0,d2\t\t\t|\n+\tbeq\tLdivsf$a$0\t\t| branch if a is zero\n+\tbclr\tIMM (31),d1\t\t| get rid of b's sign bit '\n+\tmovel\td1,d3\t\t\t|\n+\tbeq\tLdivsf$b$0\t\t| branch if b is zero\n+\tcmpl\td6,d0\t\t\t| is a big?\n+\tbhi\tLdivsf$inop\t\t| if a is NaN return NaN\n+\tbeq\tLdivsf$inf\t\t| if a is INIFINITY we have to check b\n+\tcmpl\td6,d1\t\t\t| now compare b with INFINITY \n+\tbhi\tLdivsf$inop\t\t| if b is NaN return NaN\n \tbeq\tLdivsf$underflow\n | Here we have both numbers finite and nonzero (and with no sign bit).\n | Now we get the exponents into d2 and d3 and normalize the numbers to\n@@ -2297,17 +2305,17 @@ SYM (__divsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n-\tlsrw\t#7,d2\t\t| \n+\tlsrw\tIMM (7),d2\t| \n Ldivsf$1:\t\t\t| \n \tandl\td6,d3\t\t|\n \tbeq\tLdivsf$b$den\t|\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n-\tlsrw\t#7,d3\t\t|\n+\tlsrw\tIMM (7),d3\t|\n Ldivsf$2:\t\t\t|\n \tsubw\td3,d2\t\t| substract exponents\n- \taddw\t#F_BIAS,d2\t| and add bias\n+ \taddw\tIMM (F_BIAS),d2\t| and add bias\n  \n | We are now ready to do the division. We have prepared things in such a way\n | that the ratio of the fractions will be less than 2 but greater than 1/2.\n@@ -2318,10 +2326,10 @@ Ldivsf$2:\t\t\t|\n | d7\tholds the sign of the ratio\n | d4, d5, d6 hold some constants\n \tmovel\td7,a0\t\t| d6-d7 will hold the ratio of the fractions\n-\tmovel\t#0,d6\t\t| \n+\tmovel\tIMM (0),d6\t| \n \tmovel\td6,d7\n \n-\tmovew\t#FLT_MANT_DIG+1,d3\n+\tmovew\tIMM (FLT_MANT_DIG+1),d3\n 1:\tcmpl\td0,d1\t\t| is a < b?\n \tbhi\t2f\t\t|\n \tbset\td3,d6\t\t| set a bit in d6\n@@ -2331,16 +2339,16 @@ Ldivsf$2:\t\t\t|\n \tdbra\td3,1b\n \n | Now we keep going to set the sticky bit ...\n-\tmovew\t#FLT_MANT_DIG,d3\n+\tmovew\tIMM (FLT_MANT_DIG),d3\n 1:\tcmpl\td0,d1\n \tble\t2f\n \taddl\td0,d0\n \tdbra\td3,1b\n-\tmovel\t#0,d1\n+\tmovel\tIMM (0),d1\n \tbra\t3f\n-2:\tmovel\t#0,d1\n-\tsubw\t#FLT_MANT_DIG,d3\n-\taddw\t#31,d3\n+2:\tmovel\tIMM (0),d1\n+\tsubw\tIMM (FLT_MANT_DIG),d3\n+\taddw\tIMM (31),d3\n \tbset\td3,d1\n 3:\n \tmovel\td6,d0\t\t| put the ratio in d0-d1\n@@ -2349,97 +2357,97 @@ Ldivsf$2:\t\t\t|\n | Because of the normalization we did before we are guaranteed that \n | d0 is smaller than 2^26 but larger than 2^24. Thus bit 26 is not set,\n | bit 25 could be set, and if it is not set then bit 24 is necessarily set.\n-\tbtst\t#FLT_MANT_DIG+1,d0\t\t\n+\tbtst\tIMM (FLT_MANT_DIG+1),d0\t\t\n \tbeq\t1f              | if it is not set, then bit 24 is set\n-\tlsrl\t#1,d0           |\n-\taddw\t#1,d2           |\n+\tlsrl\tIMM (1),d0\t|\n+\taddw\tIMM (1),d2\t|\n 1:\n | Now round, check for over- and underflow, and exit.\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLround$exit\n \n Ldivsf$inop:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLf$inop\n \n Ldivsf$overflow:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLf$overflow\n \n Ldivsf$underflow:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n \tbra\tLf$underflow\n \n Ldivsf$a$0:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If a is zero check to see whether b is zero also. In that case return\n | NaN; then check if b is NaN, and return NaN also in that case. Else\n | return zero.\n-\tandl\t#0x7fffffff,d1\t| clear sign bit and test b\n-\tbeq\tLf$inop\t\t| if b is also zero return NaN\n-\tcmpl\t#INFINITY,d1\t| check for NaN\n-\tbhi\tLf$inop\t\t| \n-\tmovel\t#0,d0\t\t| else return zero\n-\tlea\tSYM (_fpCCR),a0\t|\n-\tmovew\t#0,a0@\t\t|\n-\tmoveml\tsp@+,d2-d7\t| \n-\tunlk\ta6\t\t| \n-\trts\t\t\t| \n+\tandl\tIMM (0x7fffffff),d1\t| clear sign bit and test b\n+\tbeq\tLf$inop\t\t\t| if b is also zero return NaN\n+\tcmpl\tIMM (INFINITY),d1\t| check for NaN\n+\tbhi\tLf$inop\t\t\t| \n+\tmovel\tIMM (0),d0\t\t| else return zero\n+\tlea\tSYM (_fpCCR),a0\t\t|\n+\tmovew\tIMM (0),a0@\t\t|\n+\tmoveml\tsp@+,d2-d7\t\t| \n+\tunlk\ta6\t\t\t| \n+\trts\t\t\t\t| \n \t\n Ldivsf$b$0:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If we got here a is not zero. Check if a is NaN; in that case return NaN,\n | else return +/-INFINITY. Remember that a is in d0 with the sign bit \n | cleared already.\n-\tcmpl\t#INFINITY,d0\t| compare d0 with INFINITY\n-\tbhi\tLf$inop\t\t| if larger it is NaN\n-\tbra\tLf$div$0\t| else signal DIVIDE_BY_ZERO\n+\tcmpl\tIMM (INFINITY),d0\t| compare d0 with INFINITY\n+\tbhi\tLf$inop\t\t\t| if larger it is NaN\n+\tbra\tLf$div$0\t\t| else signal DIVIDE_BY_ZERO\n \n Ldivsf$inf:\n-\tmovew\t#DIVIDE,d5\n+\tmovew\tIMM (DIVIDE),d5\n | If a is INFINITY we have to check b\n-\tcmpl\t#INFINITY,d1\t| compare b with INFINITY \n-\tbge\tLf$inop\t\t| if b is NaN or INFINITY return NaN\n-\tbra\tLf$overflow\t| else return overflow\n+\tcmpl\tIMM (INFINITY),d1\t| compare b with INFINITY \n+\tbge\tLf$inop\t\t\t| if b is NaN or INFINITY return NaN\n+\tbra\tLf$overflow\t\t| else return overflow\n \n | If a number is denormalized we put an exponent of 1 but do not put the \n | bit back into the fraction.\n Ldivsf$a$den:\n-\tmovel\t#1,d2\n+\tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left until bit FLT_MANT_DIG-1 is set\n-\tsubw\t#1,d2\t\t| and adjust exponent\n-\tbtst\t#FLT_MANT_DIG-1,d0\n+\tsubw\tIMM (1),d2\t| and adjust exponent\n+\tbtst\tIMM (FLT_MANT_DIG-1),d0\n \tbne\tLdivsf$1\n \tbra\t1b\n \n Ldivsf$b$den:\n-\tmovel\t#1,d3\n+\tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit FLT_MANT_DIG is set\n-\tsubw\t#1,d3\t\t| and adjust exponent\n-\tbtst\t#FLT_MANT_DIG-1,d1\n+\tsubw\tIMM (1),d3\t| and adjust exponent\n+\tbtst\tIMM (FLT_MANT_DIG-1),d1\n \tbne\tLdivsf$2\n \tbra\t1b\n \n Lround$exit:\n | This is a common exit point for __mulsf3 and __divsf3. \n \n | First check for underlow in the exponent:\n-\tcmpw\t#-FLT_MANT_DIG-1,d2\t\t\n+\tcmpw\tIMM (-FLT_MANT_DIG-1),d2\t\t\n \tblt\tLf$underflow\t\n | It could happen that the exponent is less than 1, in which case the \n | number is denormalized. In this case we shift right and adjust the \n | exponent until it becomes 1 or the fraction is zero (in the latter case \n | we signal underflow and return zero).\n-\tmovel\t#0,d6\t\t| d6 is used temporarily\n-\tcmpw\t#1,d2\t\t| if the exponent is less than 1 we \n+\tmovel\tIMM (0),d6\t| d6 is used temporarily\n+\tcmpw\tIMM (1),d2\t| if the exponent is less than 1 we \n \tbge\t2f\t\t| have to shift right (denormalize)\n-1:\taddw\t#1,d2\t\t| adjust the exponent\n-\tlsrl\t#1,d0\t\t| shift right once \n-\troxrl\t#1,d1\t\t|\n-\troxrl\t#1,d6\t\t| d6 collect bits we would lose otherwise\n-\tcmpw\t#1,d2\t\t| is the exponent 1 already?\n+1:\taddw\tIMM (1),d2\t| adjust the exponent\n+\tlsrl\tIMM (1),d0\t| shift right once \n+\troxrl\tIMM (1),d1\t|\n+\troxrl\tIMM (1),d6\t| d6 collect bits we would lose otherwise\n+\tcmpw\tIMM (1),d2\t| is the exponent 1 already?\n \tbeq\t2f\t\t| if not loop back\n \tbra\t1b              |\n \tbra\tLf$underflow\t| safety check, shouldn't execute '\n@@ -2450,7 +2458,7 @@ Lround$exit:\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-\tcmpw\t#ROUND_TO_PLUS,d6\n+\tcmpw\tIMM (ROUND_TO_PLUS),d6\n \tbhi\tLround$to$minus\n \tblt\tLround$to$zero\n \tbra\tLround$to$plus\n@@ -2462,22 +2470,22 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 255).\n-\tcmpw\t#0x00ff,d2\n+\tcmpw\tIMM (0x00ff),d2\n \tbge\tLf$overflow\n | Now check for a denormalized number (exponent==0).\n \tmovew\td2,d2\n \tbeq\tLf$den\n 1:\n | Put back the exponents and sign and return.\n-\tlslw\t#7,d2\t\t| exponent back to fourth byte\n-\tbclr\t#FLT_MANT_DIG-1,d0\n+\tlslw\tIMM (7),d2\t| exponent back to fourth byte\n+\tbclr\tIMM (FLT_MANT_DIG-1),d0\n \tswap\td0\t\t| and put back exponent\n \torw\td2,d0\t\t| \n \tswap\td0\t\t|\n \torl\td7,d0\t\t| and sign also\n \n \tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n@@ -2491,27 +2499,27 @@ Lround$0:\n \n | float __negsf2(float);\n SYM (__negsf2):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n-\tmovew\t#NEGATE,d5\n+\tmovew\tIMM (NEGATE),d5\n \tmovel\ta6@(8),d0\t| get number to negate in d0\n-\tbchg\t#31,d0\t\t| negate\n+\tbchg\tIMM (31),d0\t| negate\n \tmovel\td0,d1\t\t| make a positive copy\n-\tbclr\t#31,d1\t\t|\n+\tbclr\tIMM (31),d1\t|\n \ttstl\td1\t\t| check for zero\n \tbeq\t2f\t\t| if zero (either sign) return +zero\n-\tcmpl\t#INFINITY,d1\t| compare to +INFINITY\n+\tcmpl\tIMM (INFINITY),d1 | compare to +INFINITY\n \tblt\t1f\t\t|\n \tbhi\tLf$inop\t\t| if larger (fraction not zero) is NaN\n \tmovel\td0,d7\t\t| else get sign and return INFINITY\n-\tandl\t#0x80000000,d7\n+\tandl\tIMM (0x80000000),d7\n \tbra\tLf$infty\t\t\n 1:\tlea\tSYM (_fpCCR),a0\n-\tmovew\t#0,a0@\n+\tmovew\tIMM (0),a0@\n \tmoveml\tsp@+,d2-d7\n \tunlk\ta6\n \trts\n-2:\tbclr\t#31,d0\n+2:\tbclr\tIMM (31),d0\n \tbra\t1b\n \n |=============================================================================\n@@ -2524,24 +2532,24 @@ EQUAL   =  0\n \n | int __cmpsf2(float, float);\n SYM (__cmpsf2):\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@- \t| save registers\n-\tmovew\t#COMPARE,d5\n+\tmovew\tIMM (COMPARE),d5\n \tmovel\ta6@(8),d0\t| get first operand\n \tmovel\ta6@(12),d1\t| get second operand\n | Check if either is NaN, and in that case return garbage and signal\n | INVALID_OPERATION. Check also if either is zero, and clear the signs\n | if necessary.\n \tmovel\td0,d6\n-\tandl\t#0x7fffffff,d0\n+\tandl\tIMM (0x7fffffff),d0\n \tbeq\tLcmpsf$a$0\n-\tcmpl\t#0x7f800000,d0\n+\tcmpl\tIMM (0x7f800000),d0\n \tbhi\tLf$inop\n Lcmpsf$1:\n \tmovel\td1,d7\n-\tandl\t#0x7fffffff,d1\n+\tandl\tIMM (0x7fffffff),d1\n \tbeq\tLcmpsf$b$0\n-\tcmpl\t#0x7f800000,d1\n+\tcmpl\tIMM (0x7f800000),d1\n \tbhi\tLf$inop\n Lcmpsf$2:\n | Check the signs\n@@ -2564,26 +2572,26 @@ Lcmpsf$2:\n \tbhi\tLcmpsf$b$gt$a\t| |b| > |a|\n \tbne\tLcmpsf$a$gt$b\t| |b| < |a|\n | If we got here a == b.\n-\tmovel\t#EQUAL,d0\n+\tmovel\tIMM (EQUAL),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n Lcmpsf$a$gt$b:\n-\tmovel\t#GREATER,d0\n+\tmovel\tIMM (GREATER),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n Lcmpsf$b$gt$a:\n-\tmovel\t#LESS,d0\n+\tmovel\tIMM (LESS),d0\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n \tunlk\ta6\n \trts\n \n Lcmpsf$a$0:\t\n-\tbclr\t#31,d6\n+\tbclr\tIMM (31),d6\n \tbra\tLcmpsf$1\n Lcmpsf$b$0:\n-\tbclr\t#31,d7\n+\tbclr\tIMM (31),d7\n \tbra\tLcmpsf$2\n \n |=============================================================================\n@@ -2602,12 +2610,12 @@ Lround$to$nearest:\n | before entering the rounding routine), but the number could be denormalized.\n \n | Check for denormalized numbers:\n-1:\tbtst\t#FLT_MANT_DIG,d0\n+1:\tbtst\tIMM (FLT_MANT_DIG),d0\n \tbne\t2f\t\t| if set the number is normalized\n | Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -F_BIAS+1).\n-\tcmpw\t#1,d2\t\t| remember that the exponent is at least one\n+\tcmpw\tIMM (1),d2\t| remember that the exponent is at least one\n  \tbeq\t2f\t\t| an exponent of one means denormalized\n \taddl\td1,d1\t\t| else shift and adjust the exponent\n \taddxl\td0,d0\t\t|\n@@ -2618,31 +2626,31 @@ Lround$to$nearest:\n | If delta < 1, do nothing. If delta > 1, add 1 to f. \n | If delta == 1, we make sure the rounded number will be even (odd?) \n | (after shifting).\n-\tbtst\t#0,d0\t\t| is delta < 1?\n+\tbtst\tIMM (0),d0\t| is delta < 1?\n \tbeq\t2f\t\t| if so, do not do anything\n \ttstl\td1\t\t| is delta == 1?\n \tbne\t1f\t\t| if so round to even\n \tmovel\td0,d1\t\t| \n-\tandl\t#2,d1\t\t| bit 1 is the last significant bit\n+\tandl\tIMM (2),d1\t| bit 1 is the last significant bit\n \taddl\td1,d0\t\t| \n \tbra\t2f\t\t| \n-1:\tmovel\t#1,d1\t\t| else add 1 \n+1:\tmovel\tIMM (1),d1\t| else add 1 \n \taddl\td1,d0\t\t|\n | Shift right once (because we used bit #FLT_MANT_DIG!).\n-2:\tlsrl\t#1,d0\t\t\n+2:\tlsrl\tIMM (1),d0\t\t\n | Now check again bit #FLT_MANT_DIG (rounding could have produced a\n | 'fraction overflow' ...).\n-\tbtst\t#FLT_MANT_DIG,d0\t\n+\tbtst\tIMM (FLT_MANT_DIG),d0\t\n \tbeq\t1f\n-\tlsrl\t#1,d0\n-\taddw\t#1,d2\n+\tlsrl\tIMM (1),d0\n+\taddw\tIMM (1),d2\n 1:\n | If bit #FLT_MANT_DIG-1 is clear we have a denormalized number, so we \n | have to put the exponent to zero and return a denormalized number.\n-\tbtst\t#FLT_MANT_DIG-1,d0\n+\tbtst\tIMM (FLT_MANT_DIG-1),d0\n \tbeq\t1f\n \tjmp\ta0@\n-1:\tmovel\t#0,d2\n+1:\tmovel\tIMM (0),d2\n \tjmp\ta0@\n \n Lround$to$zero:\n@@ -2672,7 +2680,7 @@ LL0:\n \t.globl\tSYM (__eqdf2)\n SYM (__eqdf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2699,7 +2707,7 @@ LL0:\n \t.globl\tSYM (__nedf2)\n SYM (__nedf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2725,7 +2733,7 @@ SYM (__nedf2):\n \t.globl\tSYM (__gtdf2)\n SYM (__gtdf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2752,7 +2760,7 @@ LL0:\n \t.globl\tSYM (__gedf2)\n SYM (__gedf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2779,7 +2787,7 @@ LL0:\n \t.globl\tSYM (__ltdf2)\n SYM (__ltdf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2805,7 +2813,7 @@ SYM (__ltdf2):\n \t.globl\tSYM (__ledf2)\n SYM (__ledf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(20),sp@-\n \tmovl\ta6@(16),sp@-\n@@ -2834,7 +2842,7 @@ SYM (__ledf2):\n \t.globl\tSYM (__eqsf2)\n SYM (__eqsf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-\n@@ -2858,7 +2866,7 @@ SYM (__eqsf2):\n \t.globl\tSYM (__nesf2)\n SYM (__nesf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-\n@@ -2882,7 +2890,7 @@ SYM (__nesf2):\n \t.globl\tSYM (__gtsf2)\n SYM (__gtsf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-\n@@ -2906,7 +2914,7 @@ SYM (__gtsf2):\n \t.globl\tSYM (__gesf2)\n SYM (__gesf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-\n@@ -2930,7 +2938,7 @@ SYM (__gesf2):\n \t.globl\tSYM (__ltsf2)\n SYM (__ltsf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-\n@@ -2954,7 +2962,7 @@ SYM (__ltsf2):\n \t.globl\tSYM (__lesf2)\n SYM (__lesf2):\n |#PROLOGUE# 0\n-\tlink\ta6,#0\n+\tlink\ta6,IMM (0)\n |#PROLOGUE# 1\n \tmovl\ta6@(12),sp@-\n \tmovl\ta6@(8),sp@-"}]}