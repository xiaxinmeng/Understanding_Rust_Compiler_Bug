{"sha": "f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQxYmY1ODczNmI5NWVjMTdiNjQyZjRjYjljODAyZmFjZmMxYjdiYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-17T02:14:28Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-17T02:14:28Z"}, "message": "runtime: dropg before CAS g status to _Grunnable/_Gwaiting\n    \n    Currently, we dropg (which clears gp.m) after we CAS the g status\n    to _Grunnable or _Gwaiting. Immediately after CASing the g status,\n    another thread may CAS it to _Gscan status and scan its stack.\n    With precise stack scan, it accesses gp.m in order to switch to g\n    and back (in doscanstackswitch). This races with dropg. If\n    doscanstackswitch reads gp.m, then dropg runs, when we restore\n    the m at the end of the scan it will set to a stale value. Worse,\n    if dropg runs after doscanstackswitch sets the new m, gp will be\n    running with a nil m.\n    \n    To fix this, we do dropg before CAS g status to _Grunnable or\n    _Gwaiting. We can do this safely if we are CASing from _Grunning,\n    as we own the g when it is in _Grunning. There is one case where\n    we CAS from _Gsyscall to _Grunnable. It is not safe to dropg when\n    it is in _Gsyscall, as precise stack scan needs to read gp.m in\n    order to signal the m. So we need to introduce a transient state,\n    _Gexitingsyscall, between _Gsyscall and _Grunnable, where the GC\n    should not scan its stack.\n    \n    In is a little unfortunate that we have to add another g status.\n    We could reuse an existing one (e.g. _Gcopystack), but it is\n    clearer and safer to just use a new one, as Austin suggested.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/158157\n\nFrom-SVN: r268001", "tree": {"sha": "d5b0a5962676f38d7a1eaf75f6116cbef8f04456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5b0a5962676f38d7a1eaf75f6116cbef8f04456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/comments", "author": null, "committer": null, "parents": [{"sha": "63dfd55efc0add89bb537cf923fbe11fa195734e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63dfd55efc0add89bb537cf923fbe11fa195734e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63dfd55efc0add89bb537cf923fbe11fa195734e"}], "stats": {"total": 34, "additions": 23, "deletions": 11}, "files": [{"sha": "94604b270aeb98dfa8a3b70940b44c319eb0c0ed", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "patch": "@@ -1,4 +1,4 @@\n-ee94431c133a90ca5c3c5ebbebcb019c60258dac\n+d6576c83016d856217758c06d945bfc363ffb817\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "655d0a9c760642ccd19303b468d53b01e949aa4c", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "patch": "@@ -956,6 +956,10 @@ loop:\n \t\t\t\tbreak loop\n \t\t\t}\n \n+\t\tcase _Gexitingsyscall:\n+\t\t\t// This is a transient state during which we should not scan its stack.\n+\t\t\t// Try again.\n+\n \t\tcase _Gscanwaiting:\n \t\t\t// newstack is doing a scan for us right now. Wait.\n \n@@ -2635,8 +2639,8 @@ func park_m(gp *g) {\n \t\ttraceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)\n \t}\n \n-\tcasgstatus(gp, _Grunning, _Gwaiting)\n \tdropg()\n+\tcasgstatus(gp, _Grunning, _Gwaiting)\n \n \tif _g_.m.waitunlockf != nil {\n \t\tfn := *(*func(*g, unsafe.Pointer) bool)(unsafe.Pointer(&_g_.m.waitunlockf))\n@@ -2660,8 +2664,8 @@ func goschedImpl(gp *g) {\n \t\tdumpgstatus(gp)\n \t\tthrow(\"bad g status\")\n \t}\n-\tcasgstatus(gp, _Grunning, _Grunnable)\n \tdropg()\n+\tcasgstatus(gp, _Grunning, _Grunnable)\n \tlock(&sched.lock)\n \tglobrunqput(gp)\n \tunlock(&sched.lock)\n@@ -3054,8 +3058,9 @@ func exitsyscallfast_pidle() bool {\n func exitsyscall0(gp *g) {\n \t_g_ := getg()\n \n-\tcasgstatus(gp, _Gsyscall, _Grunnable)\n+\tcasgstatus(gp, _Gsyscall, _Gexitingsyscall)\n \tdropg()\n+\tcasgstatus(gp, _Gexitingsyscall, _Grunnable)\n \tlock(&sched.lock)\n \t_p_ := pidleget()\n \tif _p_ == nil {"}, {"sha": "0e9cf63c10dc52a04d463c4df94cf6b85b0e0657", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "patch": "@@ -70,6 +70,12 @@ const (\n \t// stack is owned by the goroutine that put it in _Gcopystack.\n \t_Gcopystack // 8\n \n+\t// _Gexitingsyscall means this goroutine is exiting from a\n+\t// system call. This is like _Gsyscall, but the GC should not\n+\t// scan its stack. Currently this is only used in exitsyscall0\n+\t// as a transient state when it drops the G.\n+\t_Gexitingsyscall // 9\n+\n \t// _Gscan combined with one of the above states other than\n \t// _Grunning indicates that GC is scanning the stack. The\n \t// goroutine is not executing user code and the stack is owned"}, {"sha": "72a83a5ab2d72ad8fc48286c3ab84c64591e82ac", "filename": "libgo/go/runtime/traceback_gccgo.go", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f41bf58736b95ec17b642f4cb9c802facfc1b7bc/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftraceback_gccgo.go?ref=f41bf58736b95ec17b642f4cb9c802facfc1b7bc", "patch": "@@ -122,13 +122,14 @@ func isExportedRuntime(name string) bool {\n }\n \n var gStatusStrings = [...]string{\n-\t_Gidle:      \"idle\",\n-\t_Grunnable:  \"runnable\",\n-\t_Grunning:   \"running\",\n-\t_Gsyscall:   \"syscall\",\n-\t_Gwaiting:   \"waiting\",\n-\t_Gdead:      \"dead\",\n-\t_Gcopystack: \"copystack\",\n+\t_Gidle:           \"idle\",\n+\t_Grunnable:       \"runnable\",\n+\t_Grunning:        \"running\",\n+\t_Gsyscall:        \"syscall\",\n+\t_Gwaiting:        \"waiting\",\n+\t_Gdead:           \"dead\",\n+\t_Gcopystack:      \"copystack\",\n+\t_Gexitingsyscall: \"exiting syscall\",\n }\n \n func goroutineheader(gp *g) {"}]}