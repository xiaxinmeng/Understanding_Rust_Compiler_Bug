{"sha": "c6036a37872de176b7d02fa9926bceb1ba0c28d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwMzZhMzc4NzJkZTE3NmI3ZDAyZmE5OTI2YmNlYjFiYTBjMjhkNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-14T10:45:38Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-14T10:45:38Z"}, "message": "i386.c (x86_accumulate_outgoing_args, [...]): New global variables.\n\n\n\t* i386.c (x86_accumulate_outgoing_args, x86_prologue_using_move,\n\tx86_epilogue_using_move): New global variables.\n\t(override_options): Enable ACCUMULATE_OUTGOING_ARGS if preferred.\n\t(ix86_emit_save_regs_using_mov): New static function.\n\t(ix86_expand_prologue, ix86_expand_epilogue): Use moves if preferred.\n\t* i386.h (MASK_MMX, MASK_SSE, MASK_SSE2, MASK_128BIT_LONG_DOUBLE,\n\tMASK_MIX_SSE_I387): Renumber.\n\t(MASK_NO_ACCUMULATE_OUTGOING_ARGS): New.\n\t(x86_accumulate_outgoing_args, x86_prologue_using_move,\n\tx86_epilogue_using_move): Declare.\n\t(TARGET_PROLOGUE_USING_MOVE, TARGET_EPILOGUE_USING_MOVE): New.\n\nFrom-SVN: r43366", "tree": {"sha": "18e0efea1d9df647584274565de0d4ac9d120c6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18e0efea1d9df647584274565de0d4ac9d120c6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6036a37872de176b7d02fa9926bceb1ba0c28d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6036a37872de176b7d02fa9926bceb1ba0c28d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6036a37872de176b7d02fa9926bceb1ba0c28d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6036a37872de176b7d02fa9926bceb1ba0c28d7/comments", "author": null, "committer": null, "parents": [{"sha": "1de9b82250ba0c6963e83993f6ed6f66d28fb8a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de9b82250ba0c6963e83993f6ed6f66d28fb8a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de9b82250ba0c6963e83993f6ed6f66d28fb8a3"}], "stats": {"total": 92, "additions": 81, "deletions": 11}, "files": [{"sha": "37211422f58fe6a111c1376084979cf7df789831", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6036a37872de176b7d02fa9926bceb1ba0c28d7", "patch": "@@ -1,3 +1,17 @@\n+Thu Jun 14 12:44:15 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (x86_accumulate_outgoing_args, x86_prologue_using_move,\n+\tx86_epilogue_using_move): New global variables.\n+\t(override_options): Enable ACCUMULATE_OUTGOING_ARGS if preferred.\n+\t(ix86_emit_save_regs_using_mov): New static function.\n+\t(ix86_expand_prologue, ix86_expand_epilogue): Use moves if preferred.\n+\t* i386.h (MASK_MMX, MASK_SSE, MASK_SSE2, MASK_128BIT_LONG_DOUBLE,\n+\tMASK_MIX_SSE_I387): Renumber.\n+\t(MASK_NO_ACCUMULATE_OUTGOING_ARGS): New.\n+\t(x86_accumulate_outgoing_args, x86_prologue_using_move,\n+\tx86_epilogue_using_move): Declare.\n+\t(TARGET_PROLOGUE_USING_MOVE, TARGET_EPILOGUE_USING_MOVE): New.\n+\n 2001-06-13  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* inclhack.def (hpux10_cpp_pow_inline): New hack."}, {"sha": "af765db8c80540df7c77ac63e0b154486f8c6201", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c6036a37872de176b7d02fa9926bceb1ba0c28d7", "patch": "@@ -313,6 +313,9 @@ const int x86_add_esp_8 = m_ATHLON | m_PPRO | m_K6 | m_386 | m_486 | m_PENT4;\n const int x86_integer_DFmode_moves = ~(m_ATHLON | m_PENT4);\n const int x86_partial_reg_dependency = m_ATHLON | m_PENT4;\n const int x86_memory_mismatch_stall = m_ATHLON | m_PENT4;\n+const int x86_accumulate_outgoing_args = m_ATHLON | m_PENT4 | m_PPRO;\n+const int x86_prologue_using_move = m_ATHLON | m_PENT4 | m_PPRO;\n+const int x86_epilogue_using_move = m_ATHLON | m_PENT4 | m_PPRO;\n \n #define AT_BP(mode) (gen_rtx_MEM ((mode), hard_frame_pointer_rtx))\n \n@@ -560,6 +563,7 @@ static int ix86_split_to_parts PARAMS ((rtx, rtx *, enum machine_mode));\n static int ix86_safe_length_prefix PARAMS ((rtx));\n static int ix86_nsaved_regs PARAMS((void));\n static void ix86_emit_save_regs PARAMS((void));\n+static void ix86_emit_save_regs_using_mov PARAMS ((rtx, HOST_WIDE_INT));\n static void ix86_emit_restore_regs_using_mov PARAMS ((rtx, int, int));\n static void ix86_set_move_mem_attrs_1 PARAMS ((rtx, rtx, rtx, rtx, rtx));\n static void ix86_sched_reorder_pentium PARAMS((rtx *, rtx *));\n@@ -835,6 +839,11 @@ override_options ()\n      on by -msse.  */\n   if (TARGET_SSE)\n     target_flags |= MASK_MMX;\n+\n+  if ((x86_accumulate_outgoing_args & CPUMASK)\n+      && !(target_flags & MASK_NO_ACCUMULATE_OUTGOING_ARGS)\n+      && !optimize_size)\n+    target_flags |= MASK_ACCUMULATE_OUTGOING_ARGS;\n }\n \f\n void\n@@ -2465,6 +2474,28 @@ ix86_emit_save_regs ()\n       }\n }\n \n+/* Emit code to save registers using MOV insns.  First register\n+   is restored from POINTER + OFFSET.  */\n+static void\n+ix86_emit_save_regs_using_mov (pointer, offset)\n+\trtx pointer;\n+\tHOST_WIDE_INT offset;\n+{\n+  int regno;\n+  rtx insn;\n+\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (ix86_save_reg (regno, true))\n+      {\n+\tinsn = emit_move_insn (adj_offsettable_operand (gen_rtx_MEM (Pmode,\n+\t\t\t\t\t\t\t\t     pointer),\n+\t\t\t\t\t\t\toffset),\n+\t\t\t       gen_rtx_REG (Pmode, regno));\n+\tRTX_FRAME_RELATED_P (insn) = 1;\n+\toffset += UNITS_PER_WORD;\n+      }\n+}\n+\n /* Expand the prologue into a bunch of separate insns.  */\n \n void\n@@ -2475,6 +2506,8 @@ ix86_expand_prologue ()\n \t\t\t\t  || current_function_uses_const_pool)\n \t\t      && !TARGET_64BIT);\n   struct ix86_frame frame;\n+  int use_mov = (TARGET_PROLOGUE_USING_MOVE && !optimize_size);\n+  HOST_WIDE_INT allocate;\n \n   ix86_compute_frame_layout (&frame);\n \n@@ -2490,9 +2523,18 @@ ix86_expand_prologue ()\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  ix86_emit_save_regs ();\n+  allocate = frame.to_allocate;\n+  /* In case we are dealing only with single register and empty frame,\n+     push is equivalent of the mov+add sequence.  */\n+  if (allocate == 0 && frame.nregs <= 1)\n+    use_mov = 0;\n \n-  if (frame.to_allocate == 0)\n+  if (!use_mov)\n+    ix86_emit_save_regs ();\n+  else\n+    allocate += frame.nregs * UNITS_PER_WORD;\n+\n+  if (allocate == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || frame.to_allocate < CHECK_STACK_LIMIT)\n     {\n@@ -2511,7 +2553,7 @@ ix86_expand_prologue ()\n \tabort();\n \n       arg0 = gen_rtx_REG (SImode, 0);\n-      emit_move_insn (arg0, GEN_INT (frame.to_allocate));\n+      emit_move_insn (arg0, GEN_INT (allocate));\n \n       sym = gen_rtx_MEM (FUNCTION_MODE,\n \t\t\t gen_rtx_SYMBOL_REF (Pmode, \"_alloca\"));\n@@ -2521,6 +2563,14 @@ ix86_expand_prologue ()\n \t= gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_USE (VOIDmode, arg0),\n \t\t\t     CALL_INSN_FUNCTION_USAGE (insn));\n     }\n+  if (use_mov)\n+    {\n+      if (!frame_pointer_needed || !frame.to_allocate)\n+        ix86_emit_save_regs_using_mov (stack_pointer_rtx, frame.to_allocate);\n+      else\n+        ix86_emit_save_regs_using_mov (hard_frame_pointer_rtx,\n+\t\t\t\t       -frame.nregs * UNITS_PER_WORD);\n+    }\n \n #ifdef SUBTARGET_PROLOGUE\n   SUBTARGET_PROLOGUE;\n@@ -2536,7 +2586,6 @@ ix86_expand_prologue ()\n     emit_insn (gen_blockage ());\n }\n \n-\n /* Emit code to restore saved registers using MOV insns.  First register\n    is restored from POINTER + OFFSET.  */\n static void\n@@ -2598,6 +2647,8 @@ ix86_expand_epilogue (style)\n      and there is exactly one register to pop. This heruistic may need some\n      tuning in future.  */\n   if ((!sp_valid && frame.nregs <= 1)\n+      || (TARGET_EPILOGUE_USING_MOVE && !optimize_size\n+\t  && (frame.nregs > 1 || frame.to_allocate))\n       || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE && !optimize_size\n \t  && frame.nregs == 1)"}, {"sha": "58d05cbf8a13b7b92f9c5fb6523d238b24198545", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6036a37872de176b7d02fa9926bceb1ba0c28d7/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=c6036a37872de176b7d02fa9926bceb1ba0c28d7", "patch": "@@ -114,13 +114,14 @@ extern int target_flags;\n #define MASK_INLINE_ALL_STROPS\t0x00002000\t/* Inline stringops in all cases */\n #define MASK_NO_PUSH_ARGS\t0x00004000\t/* Use push instructions */\n #define MASK_ACCUMULATE_OUTGOING_ARGS 0x00008000/* Accumulate outgoing args */\n-#define MASK_MMX\t\t0x00010000\t/* Support MMX regs/builtins */\n-#define MASK_SSE\t\t0x00020000\t/* Support SSE regs/builtins */\n-#define MASK_SSE2\t\t0x00040000\t/* Support SSE2 regs/builtins */\n-#define MASK_128BIT_LONG_DOUBLE 0x00080000\t/* long double size is 128bit */\n-#define MASK_MIX_SSE_I387\t0x00100000\t/* Mix SSE and i387 instructions */\n-#define MASK_64BIT\t\t0x00200000\t/* Produce 64bit code */\n-#define MASK_NO_RED_ZONE\t0x00400000\t/* Do not use red zone */\n+#define MASK_NO_ACCUMULATE_OUTGOING_ARGS 0x00010000\n+#define MASK_MMX\t\t0x00020000\t/* Support MMX regs/builtins */\n+#define MASK_SSE\t\t0x00040000\t/* Support SSE regs/builtins */\n+#define MASK_SSE2\t\t0x00080000\t/* Support SSE2 regs/builtins */\n+#define MASK_128BIT_LONG_DOUBLE 0x00100000\t/* long double size is 128bit */\n+#define MASK_MIX_SSE_I387\t0x00200000\t/* Mix SSE and i387 instructions */\n+#define MASK_64BIT\t\t0x00400000\t/* Produce 64bit code */\n+#define MASK_NO_RED_ZONE\t0x00800000\t/* Do not use red zone */\n \n /* Temporary codegen switches */\n #define MASK_INTEL_SYNTAX\t0x00000200\n@@ -212,6 +213,8 @@ extern const int x86_himode_math, x86_qimode_math, x86_promote_qi_regs;\n extern const int x86_promote_hi_regs, x86_integer_DFmode_moves;\n extern const int x86_add_esp_4, x86_add_esp_8, x86_sub_esp_4, x86_sub_esp_8;\n extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n+extern const int x86_accumulate_outgoing_args, x86_prologue_using_move;\n+extern const int x86_epilogue_using_move;\n \n #define TARGET_USE_LEAVE (x86_use_leave & CPUMASK)\n #define TARGET_PUSH_MEMORY (x86_push_memory & CPUMASK)\n@@ -247,6 +250,8 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n #define TARGET_INTEGER_DFMODE_MOVES (x86_integer_DFmode_moves & CPUMASK)\n #define TARGET_PARTIAL_REG_DEPENDENCY (x86_partial_reg_dependency & CPUMASK)\n #define TARGET_MEMORY_MISMATCH_STALL (x86_memory_mismatch_stall & CPUMASK)\n+#define TARGET_PROLOGUE_USING_MOVE (x86_prologue_using_move & CPUMASK)\n+#define TARGET_EPILOGUE_USING_MOVE (x86_epilogue_using_move & CPUMASK)\n \n #define TARGET_STACK_PROBE (target_flags & MASK_STACK_PROBE)\n "}]}