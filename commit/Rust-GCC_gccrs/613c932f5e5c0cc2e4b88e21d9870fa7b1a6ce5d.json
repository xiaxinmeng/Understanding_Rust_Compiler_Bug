{"sha": "613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEzYzkzMmY1ZTVjMGNjMmU0Yjg4ZTIxZDk4NzBmYTdiMWE2Y2U1ZA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-12T17:54:47Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-13T20:22:28Z"}, "message": "libstdc++: Implement ranges [specialized.algorithms]\n\nThis implements all the ranges members defined in [specialized.algorithms]:\n\n  ranges::uninitialized_default_construct\n  ranges::uninitialized_value_construct\n  ranges::uninitialized_copy\n  ranges::uninitialized_copy_n\n  ranges::uninitialized_move\n  ranges::uninitialized_move_n\n  ranges::uninitialized_fill\n  ranges::uninitialized_fill_n\n  ranges::construct_at\n  ranges::destroy_at\n  ranges::destroy\n\nIt also implements (hopefully correctly) the \"obvious\" optimizations for these\nalgos, namely that if the output range has a trivial value type and if the\nappropriate operation won't throw then we can dispatch to the standard ranges\nversion of the algorithm which will then potentially enable further\noptimizations.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add <bits/ranges_uninitialized.h>.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/ranges_uninitialized.h: New header.\n\t* include/std/memory: Include it.\n\t* testsuite/20_util/specialized_algorithms/destroy/constrained.cc: New\n\ttest.\n\t* .../uninitialized_copy/constrained.cc: New test.\n\t* .../uninitialized_default_construct/constrained.cc: New test.\n\t* .../uninitialized_fill/constrained.cc: New test.\n\t* .../uninitialized_move/constrained.cc: New test.\n\t* .../uninitialized_value_construct/constrained.cc: New test.", "tree": {"sha": "9114e54b284f671bb7177b24fb4959679c6afc78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9114e54b284f671bb7177b24fb4959679c6afc78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/comments", "author": null, "committer": null, "parents": [{"sha": "90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90fc7b3ce0ee24c08b1edd40c528467939ef9d4f"}], "stats": {"total": 1348, "additions": 1348, "deletions": 0}, "files": [{"sha": "d1e5aad1b68cdb9438ee6e39bb0f7779a642e195", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -1,5 +1,17 @@\n 2020-02-13  Patrick Palka  <ppalka@redhat.com>\n \n+\t* include/Makefile.am: Add <bits/ranges_uninitialized.h>.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/ranges_uninitialized.h: New header.\n+\t* include/std/memory: Include it.\n+\t* testsuite/20_util/specialized_algorithms/destroy/constrained.cc: New\n+\ttest.\n+\t* .../uninitialized_copy/constrained.cc: New test.\n+\t* .../uninitialized_default_construct/constrained.cc: New test.\n+\t* .../uninitialized_fill/constrained.cc: New test.\n+\t* .../uninitialized_move/constrained.cc: New test.\n+\t* .../uninitialized_value_construct/constrained.cc: New test.\n+\n \t* include/Makefile.am: Add bits/ranges_algobase.h\n \t* include/Makefile.in: Regenerate.\n \t* bits/ranges_algo.h: Include <bits/ranges_algobase.h> and refactor"}, {"sha": "e131ce04f8cae133b8f3880d2a52539b04017c12", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -159,6 +159,7 @@ bits_headers = \\\n \t${bits_srcdir}/range_cmp.h \\\n \t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n+\t${bits_srcdir}/ranges_uninitialized.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "ae20f6b1d212ab30cc1c34e787a6d2610e8540ea", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -504,6 +504,7 @@ bits_headers = \\\n \t${bits_srcdir}/range_cmp.h \\\n \t${bits_srcdir}/ranges_algobase.h \\\n \t${bits_srcdir}/ranges_algo.h \\\n+\t${bits_srcdir}/ranges_uninitialized.h \\\n \t${bits_srcdir}/refwrap.h \\\n \t${bits_srcdir}/regex.h \\\n \t${bits_srcdir}/regex.tcc \\"}, {"sha": "5ff2eaa1b3ab4d584d734263ec5aacfd8921438d", "filename": "libstdc++-v3/include/bits/ranges_uninitialized.h", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Franges_uninitialized.h?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,491 @@\n+// Raw memory manipulators -*- C++ -*-\n+\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/ranges_uninitialized.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _RANGES_UNINITIALIZED_H\n+#define _RANGES_UNINITIALIZED_H 1\n+\n+#if __cplusplus > 201703L\n+#if __cpp_lib_concepts\n+\n+#include <bits/ranges_algobase.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+namespace ranges\n+{\n+  namespace __detail\n+  {\n+    template<typename _Tp>\n+      constexpr void*\n+      __voidify(_Tp& __obj) noexcept\n+      {\n+\treturn const_cast<void*>\n+\t\t (static_cast<const volatile void*>(std::__addressof(__obj)));\n+      }\n+\n+    template<typename _Iter>\n+      concept __nothrow_input_iterator\n+\t= (input_iterator<_Iter>\n+\t   && is_lvalue_reference_v<iter_reference_t<_Iter>>\n+\t   && same_as<remove_cvref_t<iter_reference_t<_Iter>>,\n+\t\t      iter_value_t<_Iter>>);\n+\n+    template<typename _Sent, typename _Iter>\n+      concept __nothrow_sentinel = sentinel_for<_Sent, _Iter>;\n+\n+    template<typename _Range>\n+      concept __nothrow_input_range\n+\t= (range<_Range>\n+\t   && __nothrow_input_iterator<iterator_t<_Range>>\n+\t   && __nothrow_sentinel<sentinel_t<_Range>, iterator_t<_Range>>);\n+\n+    template<typename _Iter>\n+      concept __nothrow_forward_iterator\n+\t= (__nothrow_input_iterator<_Iter>\n+\t   && forward_iterator<_Iter>\n+\t   && __nothrow_sentinel<_Iter, _Iter>);\n+\n+    template<typename _Range>\n+      concept __nothrow_forward_range\n+\t= (__nothrow_input_range<_Range>\n+\t   && __nothrow_forward_iterator<iterator_t<_Range>>);\n+  } // namespace __detail\n+\n+  template<__detail::__nothrow_input_iterator _Iter,\n+\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n+    requires destructible<iter_value_t<_Iter>>\n+    constexpr _Iter\n+    destroy(_Iter __first, _Sent __last) noexcept;\n+\n+  namespace __detail\n+  {\n+    template<typename _Iter>\n+      requires destructible<iter_value_t<_Iter>>\n+      struct _DestroyGuard\n+      {\n+      private:\n+\t_Iter _M_first;\n+\tconst _Iter* _M_cur;\n+\n+      public:\n+\texplicit\n+\t_DestroyGuard(const _Iter* __iter)\n+\t  : _M_first(*__iter), _M_cur(__iter)\n+\t{ }\n+\n+\tvoid\n+\trelease() noexcept\n+\t{ _M_cur = nullptr; }\n+\n+\t~_DestroyGuard()\n+\t{\n+\t  if (_M_cur != nullptr)\n+\t    ranges::destroy(std::move(_M_first), *_M_cur);\n+\t}\n+      };\n+\n+    template<typename _Iter>\n+      requires destructible<iter_value_t<_Iter>>\n+\t&& is_trivially_destructible_v<iter_value_t<_Iter>>\n+      struct _DestroyGuard<_Iter>\n+      {\n+\texplicit\n+\t_DestroyGuard(const _Iter*)\n+\t{ }\n+\n+\tvoid\n+\trelease() noexcept\n+\t{ }\n+      };\n+  } // namespace __detail\n+\n+  template<__detail::__nothrow_forward_iterator _Iter,\n+\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n+    requires default_initializable<iter_value_t<_Iter>>\n+    _Iter\n+    uninitialized_default_construct(_Iter __first, _Sent __last)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivially_default_constructible_v<_ValueType>)\n+\treturn ranges::next(__first, __last);\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __first != __last; ++__first)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType;\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_forward_range _Range>\n+    requires default_initializable<range_value_t<_Range>>\n+    safe_iterator_t<_Range>\n+    uninitialized_default_construct(_Range&& __r)\n+    {\n+      return ranges::uninitialized_default_construct(ranges::begin(__r),\n+\t\t\t\t\t\t     ranges::end(__r));\n+    }\n+\n+  template<__detail::__nothrow_forward_iterator _Iter>\n+    requires default_initializable<iter_value_t<_Iter>>\n+    _Iter\n+    uninitialized_default_construct_n(_Iter __first,\n+\t\t\t\t      iter_difference_t<_Iter> __n)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivially_default_constructible_v<_ValueType>)\n+\treturn ranges::next(__first, __n);\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __n > 0; ++__first, (void) --__n)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType;\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_forward_iterator _Iter,\n+\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n+    requires default_initializable<iter_value_t<_Iter>>\n+    _Iter\n+    uninitialized_value_construct(_Iter __first, _Sent __last)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivial_v<_ValueType>\n+\t\t    && is_copy_assignable_v<_ValueType>)\n+\treturn ranges::fill(__first, __last, _ValueType());\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __first != __last; ++__first)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType();\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_forward_range _Range>\n+    requires default_initializable<range_value_t<_Range>>\n+    safe_iterator_t<_Range>\n+    uninitialized_value_construct(_Range&& __r)\n+    {\n+      return ranges::uninitialized_value_construct(ranges::begin(__r),\n+\t\t\t\t\t\t   ranges::end(__r));\n+    }\n+\n+  template<__detail::__nothrow_forward_iterator _Iter>\n+    requires default_initializable<iter_value_t<_Iter>>\n+    _Iter\n+    uninitialized_value_construct_n(_Iter __first, iter_difference_t<_Iter> __n)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivial_v<_ValueType>\n+\t\t    && is_copy_assignable_v<_ValueType>)\n+\treturn ranges::fill_n(__first, __n, _ValueType());\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __n > 0; ++__first, (void) --__n)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType();\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    using uninitialized_copy_result = copy_result<_Iter, _Out>;\n+\n+  template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n+\t   __detail::__nothrow_forward_iterator _Out,\n+\t   __detail::__nothrow_sentinel<_Out> _OSent>\n+    requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n+    uninitialized_copy_result<_Iter, _Out>\n+    uninitialized_copy(_Iter __ifirst, _ISent __ilast,\n+\t\t       _Out __ofirst, _OSent __olast)\n+    {\n+      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+      if constexpr (sized_sentinel_for<_ISent, _Iter>\n+\t\t    && sized_sentinel_for<_OSent, _Out>\n+\t\t    && is_trivial_v<_OutType>\n+\t\t    && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t       iter_reference_t<_Iter>>)\n+\t{\n+\t  auto __d1 = ranges::distance(__ifirst, __ilast);\n+\t  auto __d2 = ranges::distance(__ofirst, __olast);\n+\t  return ranges::copy_n(__ifirst, std::min(__d1, __d2), __ofirst);\n+\t}\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t  for (; __ifirst != __ilast && __ofirst != __olast;\n+\t       ++__ofirst, (void)++__ifirst)\n+\t    ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n+\t  __guard.release();\n+\t  return {__ifirst, __ofirst};\n+\t}\n+    }\n+\n+  template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n+    requires constructible_from<range_value_t<_ORange>,\n+\t\t\t\trange_reference_t<_IRange>>\n+    uninitialized_copy_result<safe_iterator_t<_IRange>,\n+\t\t\t      safe_iterator_t<_ORange>>\n+    uninitialized_copy(_IRange&& __inr, _ORange&& __outr)\n+    {\n+      return ranges::uninitialized_copy(ranges::begin(__inr),\n+\t\t\t\t\tranges::end(__inr),\n+\t\t\t\t\tranges::begin(__outr),\n+\t\t\t\t\tranges::end(__outr));\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    using uninitialized_copy_n_result = uninitialized_copy_result<_Iter, _Out>;\n+\n+    template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,\n+      __detail::__nothrow_sentinel<_Out> _Sent>\n+    requires constructible_from<iter_value_t<_Out>, iter_reference_t<_Iter>>\n+    uninitialized_copy_n_result<_Iter, _Out>\n+    uninitialized_copy_n(_Iter __ifirst, iter_difference_t<_Iter> __n,\n+\t\t\t _Out __ofirst, _Sent __olast)\n+    {\n+      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+      if constexpr (sized_sentinel_for<_Sent, _Out>\n+\t\t    && is_trivial_v<_OutType>\n+\t\t    && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t       iter_reference_t<_Iter>>)\n+\t{\n+\t  auto __d = ranges::distance(__ofirst, __olast);\n+\t  return ranges::copy_n(__ifirst, std::min(__n, __d), __ofirst);\n+\t}\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t  for (; __n > 0 && __ofirst != __olast;\n+\t       ++__ofirst, (void)++__ifirst, (void)--__n)\n+\t    ::new (__detail::__voidify(*__ofirst)) _OutType(*__ifirst);\n+\t  __guard.release();\n+\t  return {__ifirst, __ofirst};\n+\t}\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    using uninitialized_move_result = uninitialized_copy_result<_Iter, _Out>;\n+\n+  template<input_iterator _Iter, sentinel_for<_Iter> _ISent,\n+\t   __detail::__nothrow_forward_iterator _Out,\n+\t   __detail::__nothrow_sentinel<_Out> _OSent>\n+    requires constructible_from<iter_value_t<_Out>,\n+\t\t\t\titer_rvalue_reference_t<_Iter>>\n+    uninitialized_move_result<_Iter, _Out>\n+    uninitialized_move(_Iter __ifirst, _ISent __ilast,\n+\t\t       _Out __ofirst, _OSent __olast)\n+    {\n+      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+      if constexpr (sized_sentinel_for<_ISent, _Iter>\n+\t\t    && sized_sentinel_for<_OSent, _Out>\n+\t\t    && is_trivial_v<_OutType>\n+\t\t    && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t       iter_rvalue_reference_t<_Iter>>)\n+\t{\n+\t  auto __d1 = ranges::distance(__ifirst, __ilast);\n+\t  auto __d2 = ranges::distance(__ofirst, __olast);\n+\t  return ranges::copy_n(std::make_move_iterator(__ifirst),\n+\t\t\t\tstd::min(__d1, __d2), __ofirst);\n+\t}\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t  for (; __ifirst != __ilast && __ofirst != __olast;\n+\t       ++__ofirst, (void)++__ifirst)\n+\t    ::new (__detail::__voidify(*__ofirst))\n+\t\t  _OutType(ranges::iter_move(__ifirst));\n+\t  __guard.release();\n+\t  return {__ifirst, __ofirst};\n+\t}\n+    }\n+\n+  template<input_range _IRange, __detail::__nothrow_forward_range _ORange>\n+    requires constructible_from<range_value_t<_ORange>,\n+\t     range_rvalue_reference_t<_IRange>>\n+    uninitialized_move_result<safe_iterator_t<_IRange>,\n+\t\t\t      safe_iterator_t<_ORange>>\n+    uninitialized_move(_IRange&& __inr, _ORange&& __outr)\n+    {\n+      return ranges::uninitialized_move(ranges::begin(__inr),\n+\t\t\t\t\tranges::end(__inr),\n+\t\t\t\t\tranges::begin(__outr),\n+\t\t\t\t\tranges::end(__outr));\n+    }\n+\n+  template<typename _Iter, typename _Out>\n+    using uninitialized_move_n_result = uninitialized_copy_result<_Iter, _Out>;\n+\n+  template<input_iterator _Iter, __detail::__nothrow_forward_iterator _Out,\n+    __detail::__nothrow_sentinel<_Out> _Sent>\n+      requires constructible_from<iter_value_t<_Out>,\n+\t\t\t\t  iter_rvalue_reference_t<_Iter>>\n+    uninitialized_move_n_result<_Iter, _Out>\n+    uninitialized_move_n(_Iter __ifirst, iter_difference_t<_Iter> __n,\n+\t\t\t _Out __ofirst, _Sent __olast)\n+    {\n+      using _OutType = remove_reference_t<iter_reference_t<_Out>>;\n+      if constexpr (sized_sentinel_for<_Sent, _Out>\n+\t\t    && is_trivial_v<_OutType>\n+\t\t    && is_nothrow_assignable_v<_OutType,\n+\t\t\t\t\t       iter_rvalue_reference_t<_Iter>>)\n+\t{\n+\t  auto __d = ranges::distance(__ofirst, __olast);\n+\t  return ranges::copy_n(std::make_move_iterator(__ifirst),\n+\t\t\t\tstd::min(__n, __d), __ofirst);\n+\t}\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__ofirst);\n+\t  for (; __n > 0 && __ofirst != __olast;\n+\t       ++__ofirst, (void)++__ifirst, (void)--__n)\n+\t    ::new (__detail::__voidify(*__ofirst))\n+\t\t  _OutType(ranges::iter_move(__ifirst));\n+\t  __guard.release();\n+\t  return {__ifirst, __ofirst};\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_forward_iterator _Iter,\n+\t   __detail::__nothrow_sentinel<_Iter> _Sent, typename _Tp>\n+    requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n+    _Iter\n+    uninitialized_fill(_Iter __first, _Sent __last, const _Tp& __x)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivial_v<_ValueType>\n+\t\t    && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n+\treturn ranges::fill(__first, __last, __x);\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __first != __last; ++__first)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType(__x);\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_forward_range _Range, typename _Tp>\n+    requires constructible_from<range_value_t<_Range>, const _Tp&>\n+    safe_iterator_t<_Range>\n+    uninitialized_fill(_Range&& __r, const _Tp& __x)\n+    {\n+      return ranges::uninitialized_fill(ranges::begin(__r), ranges::end(__r),\n+\t\t\t\t\t__x);\n+    }\n+\n+  template<__detail::__nothrow_forward_iterator _Iter, typename _Tp>\n+    requires constructible_from<iter_value_t<_Iter>, const _Tp&>\n+    _Iter\n+    uninitialized_fill_n(_Iter __first, iter_difference_t<_Iter> __n,\n+\t\t\t const _Tp& __x)\n+    {\n+      using _ValueType = remove_reference_t<iter_reference_t<_Iter>>;\n+      if constexpr (is_trivial_v<_ValueType>\n+\t\t    && is_nothrow_assignable_v<_ValueType, const _Tp&>)\n+\treturn ranges::fill_n(__first, __n, __x);\n+      else\n+\t{\n+\t  auto __guard = __detail::_DestroyGuard(&__first);\n+\t  for (; __n > 0; ++__first, (void)--__n)\n+\t    ::new (__detail::__voidify(*__first)) _ValueType(__x);\n+\t  __guard.release();\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<typename _Tp, typename... _Args>\n+    requires requires { ::new (declval<void*>()) _Tp(declval<_Args>()...); }\n+    constexpr _Tp*\n+    construct_at(_Tp* __location, _Args&&... __args)\n+    {\n+      return ::new (__detail::__voidify(*__location))\n+\t\t   _Tp(std::forward<_Args>(__args)...);\n+    }\n+\n+  template<destructible _Tp>\n+    constexpr void\n+    destroy_at(_Tp* __location) noexcept\n+    {\n+      if constexpr (is_array_v<_Tp>)\n+\tranges::destroy(ranges::begin(*__location), ranges::end(*__location));\n+      else\n+\t__location->~_Tp();\n+    }\n+\n+  template<__detail::__nothrow_input_iterator _Iter,\n+\t   __detail::__nothrow_sentinel<_Iter> _Sent>\n+    requires destructible<iter_value_t<_Iter>>\n+    constexpr _Iter\n+    destroy(_Iter __first, _Sent __last) noexcept\n+    {\n+      if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)\n+\treturn ranges::next(__first, __last);\n+      else\n+\t{\n+\t  for (; __first != __last; ++__first)\n+\t    ranges::destroy_at(std::__addressof(*__first));\n+\t  return __first;\n+\t}\n+    }\n+\n+  template<__detail::__nothrow_input_range _Range>\n+    requires destructible<range_value_t<_Range>>\n+    constexpr safe_iterator_t<_Range>\n+    destroy(_Range&& __r) noexcept\n+    { return ranges::destroy(ranges::begin(__r), ranges::end(__r)); }\n+\n+  template<__detail::__nothrow_input_iterator _Iter>\n+    requires destructible<iter_value_t<_Iter>>\n+    constexpr _Iter\n+    destroy_n(_Iter __first, iter_difference_t<_Iter> __n) noexcept\n+    {\n+      if constexpr (is_trivially_destructible_v<iter_value_t<_Iter>>)\n+\treturn ranges::next(__first, __n);\n+      else\n+\t{\n+\t  for (; __n > 0; ++__first, (void)--__n)\n+\t    ranges::destroy_at(std::__addressof(*__first));\n+\t  return __first;\n+\t}\n+    }\n+}\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+#endif // concepts\n+#endif // C++20\n+#endif // _RANGES_UNINITIALIZED_H"}, {"sha": "823bd21a5ad74c1bbc08466b8236145463968911", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -66,6 +66,7 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_tempbuf.h>\n #include <bits/stl_raw_storage_iter.h>\n+#include <bits/ranges_uninitialized.h>\n \n #if __cplusplus >= 201103L\n #  include <exception>        \t  // std::exception"}, {"sha": "730625d9a21d62dc15f6de3fefa13cd33c0cf68a", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/destroy/constrained.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fdestroy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fdestroy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Fdestroy%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,76 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+\n+struct X\n+{\n+  X()\n+  { ++count; }\n+\n+  ~X()\n+  { --count; }\n+\n+  static inline int count = 0;\n+};\n+\n+void\n+test01()\n+{\n+  for (int k = 0; k < 3; k++)\n+    {\n+      constexpr int size = 1024;\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+      std::span<X> rx((X *)buffer.get(), size);\n+\n+      ranges::uninitialized_default_construct(rx);\n+      VERIFY( X::count == size );\n+\n+      auto i = rx.cbegin();\n+      if (k == 0)\n+\ti = ranges::destroy(rx);\n+      else if (k == 1)\n+\ti = ranges::destroy(rx.begin(), rx.end());\n+      else if (k == 2)\n+\ti = ranges::destroy_n(rx.begin(), size);\n+      else\n+\t__builtin_abort();\n+\n+      VERIFY( i == rx.cend() );\n+      VERIFY( X::count == 0 );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "948406432cba537916e3d5f629b22cabfab43bca", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_copy/constrained.cc", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_copy%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,166 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_input_range;\n+using __gnu_test::test_forward_range;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T>\n+void\n+test01(const std::vector<T> &ix)\n+{\n+  static_assert(std::copy_constructible<T>);\n+  static_assert(std::equality_comparable<T>);\n+\n+  for (int k = 0; k < 7; k++)\n+    {\n+      int size = ix.size();\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);\n+      std::span<T> rx((T *)buffer.get(), size);\n+\n+      ranges::uninitialized_copy_result res = {ix.cbegin(), rx.cbegin()};\n+      if (k == 0)\n+\tres = ranges::uninitialized_copy(ix.begin(), ix.end(),\n+\t\t\t\t\t rx.begin(), rx.end());\n+      else if (k == 1)\n+\tres = ranges::uninitialized_copy(ix, rx);\n+      else if (k == 2)\n+\tres = ranges::uninitialized_copy_n(ix.begin(), size,\n+\t\t\t\t\t   rx.begin(), rx.end());\n+      else if (k == 3)\n+\tres = ranges::uninitialized_copy(ix.begin(), ix.end(),\n+\t\t\t\t\t rx.cbegin(), rx.cend());\n+      else if (k == 4)\n+\tres = ranges::uninitialized_copy(ix, std::as_const(rx));\n+      else if (k == 5)\n+\tres = ranges::uninitialized_copy_n(ix.begin(), size,\n+\t\t\t\t\t   rx.cbegin(), rx.cend());\n+      else if (k == 6)\n+\tres = ranges::uninitialized_copy_n(ix.begin(), size/2,\n+\t\t\t\t\t   rx.cbegin(), rx.cend());\n+      else if (k == 7)\n+\tres = ranges::uninitialized_copy_n(ix.begin(), size,\n+\t\t\t\t\t   rx.cbegin(), rx.cbegin()+size/2);\n+      else\n+\t__builtin_abort();\n+\n+      if (k == 6 || k == 7)\n+\t{\n+\t  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );\n+\t  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );\n+\t  VERIFY( ranges::equal(ix.begin(), ix.begin()+size/2,\n+\t\t\t\trx.begin(), rx.begin()+size/2) );\n+\t  ranges::destroy(rx.begin(), rx.begin()+size/2);\n+\t}\n+      else\n+\t{\n+\t  VERIFY( res.in == ix.cend() );\n+\t  VERIFY( res.out == rx.cend() );\n+\t  VERIFY( ranges::equal(ix, rx) );\n+\t  ranges::destroy(rx);\n+\t}\n+    }\n+}\n+\n+struct X\n+{\n+  static constexpr int limit = 67;\n+  static inline int copy_construct_count = 0;\n+  static inline int destruct_count = 0;\n+\n+  struct exception {};\n+\n+  bool live = false;\n+\n+  X()\n+  { live = true; }\n+\n+  X& operator=(const X&) = delete;\n+\n+  X(const X&)\n+  {\n+    live = true;\n+    if (copy_construct_count >= limit)\n+      throw exception{};\n+    copy_construct_count++;\n+  }\n+\n+  ~X()\n+  {\n+    VERIFY( live );\n+    live = false;\n+    destruct_count++;\n+  }\n+};\n+\n+template<bool test_sized>\n+void\n+test02()\n+{\n+  constexpr int size = 100;\n+  X x[size];\n+  // FIXME: Should be test_input_range?\n+  test_forward_range<X> ix(x);\n+\n+  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);\n+  try\n+    {\n+      X::copy_construct_count = 0;\n+      X::destruct_count = 0;\n+      if constexpr (test_sized)\n+\tranges::uninitialized_copy_n(ix.begin(), size, rx.begin(), rx.end());\n+      else\n+\tranges::uninitialized_copy(ix, rx);\n+      VERIFY( false && \"exception not thrown\" );\n+    }\n+  catch (const X::exception&)\n+    {\n+      VERIFY( X::copy_construct_count == X::limit );\n+      VERIFY( X::destruct_count == X::limit );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<char>({1,2,3,4,5});\n+  test01<int>({1,2,3,4,5});\n+  test01<long long>({1,2,3,4,5});\n+  test01<float>({1.1,2.1,3.1,4.1});\n+  test01<double>({1.1,2.1,3.1,4.1});\n+  test01<std::vector<char>>({{'a','b'}, {'c','d'}, {'e','f'}});\n+  test01<std::string>({\"the\", \"quick\", \"brown\", \"fox\"});\n+\n+  test02<false>();\n+  test02<true>();\n+}"}, {"sha": "6ef24cc7ea07fc59a11cced82863e8707c272b1f", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_default_construct/constrained.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_construct%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_construct%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_default_construct%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,147 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_forward_range;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T>\n+void\n+test01()\n+{\n+  static_assert(std::default_initializable<T>);\n+  static_assert(std::equality_comparable<T>);\n+\n+  for (int k = 0; k < 6; k++)\n+    {\n+      constexpr int size = 1024;\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);\n+      std::span<T> rx((T *)buffer.get(), size);\n+\n+      T t;\n+      if constexpr (std::is_fundamental_v<T>)\n+\t{\n+\t  std::memset(&t, 0xCC, sizeof(t));\n+\t  ranges::fill(rx, t);\n+\t}\n+\n+      auto i = rx.cbegin();\n+      if (k == 0)\n+\ti = ranges::uninitialized_default_construct(rx.begin(), rx.end());\n+      else if (k == 1)\n+\ti = ranges::uninitialized_default_construct(rx);\n+      else if (k == 2)\n+\ti = ranges::uninitialized_default_construct_n(rx.begin(), 1024);\n+      else if constexpr (std::is_fundamental_v<T>)\n+\tcontinue;\n+      else if (k == 3)\n+\ti = ranges::uninitialized_default_construct(rx.cbegin(), rx.cend());\n+      else if (k == 4)\n+\ti = ranges::uninitialized_default_construct(std::as_const(rx));\n+      else if (k == 5)\n+\ti = ranges::uninitialized_default_construct_n(rx.cbegin(), 1024);\n+      else\n+\t__builtin_abort();\n+\n+      VERIFY( i == rx.cend() );\n+      VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );\n+\n+      ranges::destroy(rx);\n+    }\n+}\n+\n+struct X\n+{\n+  static constexpr int limit = 67;\n+  static inline int construct_count = 0;\n+  static inline int destruct_count = 0;\n+\n+  struct exception {};\n+\n+  bool live = false;\n+\n+  X()\n+  {\n+    if (construct_count >= limit)\n+      throw exception{};\n+    construct_count++;\n+    live = true;\n+  }\n+\n+  ~X()\n+  {\n+    VERIFY( live );\n+    live = false;\n+    destruct_count++;\n+  }\n+};\n+\n+template<bool test_sized>\n+void\n+test02()\n+{\n+  constexpr int size = 100;\n+  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);\n+  try\n+    {\n+      X::construct_count = 0;\n+      X::destruct_count = 0;\n+      if constexpr (test_sized)\n+\tranges::uninitialized_default_construct_n(rx.begin(), size);\n+      else\n+\tranges::uninitialized_default_construct(rx);\n+      VERIFY( false && \"exception not thrown\" );\n+    }\n+  catch (const X::exception&)\n+    {\n+      VERIFY( X::construct_count == X::limit );\n+      VERIFY( X::destruct_count == X::limit );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<char>();\n+  test01<int>();\n+  test01<long long>();\n+  test01<float>();\n+  test01<double>();\n+  test01<std::vector<char>>();\n+  test01<std::string>();\n+  test01<std::deque<double>>();\n+  test01<std::list<std::vector<std::deque<double>>>>();\n+  test01<std::unique_ptr<std::string>>();\n+\n+  test02<false>();\n+  test02<true>();\n+}"}, {"sha": "c95fd666942ea1ce7e0f8050bc2d8e949080c5ea", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_fill/constrained.cc", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_fill%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,137 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_forward_range;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T>\n+void\n+test01(const T& value)\n+{\n+  static_assert(std::equality_comparable<T>);\n+\n+  for (int k = 0; k < 6; k++)\n+    {\n+      constexpr int size = 1024;\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);\n+      std::span<T> rx((T *)buffer.get(), size);\n+\n+      auto i = rx.cbegin();\n+      if (k == 0)\n+\ti = ranges::uninitialized_fill(rx.begin(), rx.end(), value);\n+      else if (k == 1)\n+\ti = ranges::uninitialized_fill(rx, value);\n+      else if (k == 2)\n+\ti = ranges::uninitialized_fill_n(rx.begin(), 1024, value);\n+      else if (k == 3)\n+\ti = ranges::uninitialized_fill(rx.cbegin(), rx.cend(), value);\n+      else if (k == 4)\n+\ti = ranges::uninitialized_fill(std::as_const(rx), value);\n+      else if (k == 5)\n+\ti = ranges::uninitialized_fill_n(rx.cbegin(), 1024, value);\n+      else\n+\t__builtin_abort();\n+\n+      VERIFY( i == rx.cend() );\n+      VERIFY( ranges::find_if(rx, [&value](const T& v) { return value != v; }) == i );\n+\n+      ranges::destroy(rx);\n+    }\n+}\n+\n+struct X\n+{\n+  static constexpr int limit = 67;\n+  static inline int construct_count = 0;\n+  static inline int destruct_count = 0;\n+\n+  struct exception {};\n+\n+  bool live = false;\n+\n+  X(int)\n+  {\n+    if (construct_count >= limit)\n+      throw exception{};\n+    construct_count++;\n+    live = true;\n+  }\n+\n+  ~X()\n+  {\n+    VERIFY( live );\n+    live = false;\n+    destruct_count++;\n+  }\n+};\n+\n+template<bool test_sized>\n+void\n+test02()\n+{\n+  constexpr int size = 100;\n+  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);\n+  int value = 5;\n+  try\n+    {\n+      X::construct_count = 0;\n+      X::destruct_count = 0;\n+      if constexpr (test_sized)\n+\tranges::uninitialized_fill_n(rx.begin(), size, value);\n+      else\n+\tranges::uninitialized_fill(rx, value);\n+      VERIFY( false && \"exception not thrown\" );\n+    }\n+  catch (const X::exception&)\n+    {\n+      VERIFY( X::construct_count == X::limit );\n+      VERIFY( X::destruct_count == X::limit );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<char>(5);\n+  test01<int>(3);\n+  test01<long long>(17);\n+  test01<float>(2.18);\n+  test01<double>(3.98);\n+  test01<std::vector<char>>({'a', 'b', 'c', 'd'});\n+  test01<std::string>(\"hello\");\n+  test01<std::deque<double>>({1.1,2.1,3.1});\n+  test01<std::list<std::vector<std::deque<double>>>>({{{3.4},{1}},{{7.9}}});\n+\n+  test02<false>();\n+  test02<true>();\n+}"}, {"sha": "796c7ca8f4668bc60ef0ce4413a006cb8b9d8f9d", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_move/constrained.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_move%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_move%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_move%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,176 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_input_range;\n+using __gnu_test::test_forward_range;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T>\n+void\n+test01(std::vector<T> ix)\n+{\n+  static_assert(std::move_constructible<T>);\n+  static_assert(std::equality_comparable<T>);\n+\n+  const auto saved_ix = ix;\n+\n+  for (int k = 0; k < 7; k++)\n+    {\n+      ix = saved_ix;\n+\n+      int size = ix.size();\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);\n+      std::span<T> rx((T *)buffer.get(), size);\n+\n+      ranges::uninitialized_move_result res = {ix.cbegin(), rx.cbegin()};\n+      if (k == 0)\n+\tres = ranges::uninitialized_move(ix.begin(), ix.end(),\n+\t\t\t\t\t rx.begin(), rx.end());\n+      else if (k == 1)\n+\tres = ranges::uninitialized_move(ix, rx);\n+      else if (k == 2)\n+\tres = ranges::uninitialized_move_n(ix.begin(), size,\n+\t\t\t\t\t   rx.begin(), rx.end());\n+      else if (k == 3)\n+\tres = ranges::uninitialized_move(ix.begin(), ix.end(),\n+\t\t\t\t\t rx.cbegin(), rx.cend());\n+      else if (k == 4)\n+\tres = ranges::uninitialized_move(ix, std::as_const(rx));\n+      else if (k == 5)\n+\tres = ranges::uninitialized_move_n(ix.begin(), size,\n+\t\t\t\t\t   rx.cbegin(), rx.cend());\n+      else if (k == 6)\n+\tres = ranges::uninitialized_move_n(ix.begin(), size/2,\n+\t\t\t\t\t   rx.cbegin(), rx.cend());\n+      else if (k == 7)\n+\tres = ranges::uninitialized_move_n(ix.begin(), size,\n+\t\t\t\t\t   rx.cbegin(), rx.cbegin()+size/2);\n+      else\n+\t__builtin_abort();\n+\n+      if (k == 6 || k == 7)\n+\t{\n+\t  VERIFY( ranges::distance(ix.cbegin(), res.in) == size/2 );\n+\t  VERIFY( ranges::distance(rx.cbegin(), res.out) == size/2 );\n+\t  VERIFY( ranges::equal(saved_ix.begin(), saved_ix.begin()+size/2,\n+\t\t\t\trx.begin(), rx.begin()+size/2) );\n+\t  ranges::destroy(rx.begin(), rx.begin()+size/2);\n+\t}\n+      else\n+\t{\n+\t  VERIFY( res.in == ix.cend() );\n+\t  VERIFY( res.out == rx.cend() );\n+\t  VERIFY( ranges::equal(saved_ix, rx) );\n+\t  ranges::destroy(rx);\n+\t}\n+    }\n+}\n+\n+struct X\n+{\n+  static constexpr int limit = 67;\n+  static inline int move_construct_count = 0;\n+  static inline int destruct_count = 0;\n+\n+  struct exception {};\n+\n+  bool live = false;\n+  bool moved_from = false;\n+\n+  X()\n+  { live = true; moved_from = false; }\n+\n+  X& operator=(const X&) = delete;\n+  X(const X&) = delete;\n+\n+  X&& operator=(X&&) = delete;\n+\n+  X(X&& other)\n+  {\n+    VERIFY( !other.moved_from );\n+    other.moved_from = true;\n+    live = true;\n+    if (move_construct_count >= limit)\n+      throw exception{};\n+    move_construct_count++;\n+  }\n+\n+  ~X()\n+  {\n+    VERIFY( live );\n+    live = false;\n+    destruct_count++;\n+  }\n+};\n+\n+template<bool test_sized>\n+void\n+test02()\n+{\n+  constexpr int size = 100;\n+  X x[size];\n+  // FIXME: Should be test_input_range?\n+  test_forward_range<X> ix(x);\n+\n+  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);\n+  try\n+    {\n+      X::move_construct_count = 0;\n+      X::destruct_count = 0;\n+      if constexpr (test_sized)\n+\tranges::uninitialized_move_n(ix.begin(), size, rx.begin(), rx.end());\n+      else\n+\tranges::uninitialized_move(ix, rx);\n+      VERIFY( false && \"exception not thrown\" );\n+    }\n+  catch (const X::exception&)\n+    {\n+      VERIFY( X::move_construct_count == X::limit );\n+      VERIFY( X::destruct_count == X::limit );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<char>({1,2,3,4,5});\n+  test01<int>({1,2,3,4,5});\n+  test01<long long>({1,2,3,4,5});\n+  test01<float>({1.1,2.1,3.1,4.1});\n+  test01<double>({1.1,2.1,3.1,4.1});\n+  test01<std::vector<char>>({{'a','b'}, {'c','d'}, {'e','f'}});\n+  test01<std::string>({\"the\", \"quick\", \"brown\", \"fox\"});\n+\n+  test02<false>();\n+  test02<true>();\n+}"}, {"sha": "5928bc04c705315c7a1597007f51a3229d596b50", "filename": "libstdc++-v3/testsuite/20_util/specialized_algorithms/uninitialized_value_construct/constrained.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct%2Fconstrained.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct%2Fconstrained.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fspecialized_algorithms%2Funinitialized_value_construct%2Fconstrained.cc?ref=613c932f5e5c0cc2e4b88e21d9870fa7b1a6ce5d", "patch": "@@ -0,0 +1,140 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <cstring>\n+#include <deque>\n+#include <list>\n+#include <memory>\n+#include <span>\n+#include <string>\n+#include <vector>\n+\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_forward_range;\n+\n+namespace ranges = std::ranges;\n+\n+template<typename T>\n+void\n+test01()\n+{\n+  static_assert(std::default_initializable<T>);\n+  static_assert(std::equality_comparable<T>);\n+\n+  for (int k = 0; k < 6; k++)\n+    {\n+      constexpr int size = 1024;\n+      auto buffer = std::unique_ptr<char[]>(new char[sizeof(T)*size]);\n+      std::span<T> rx((T *)buffer.get(), size);\n+\n+      T t{};\n+\n+      auto i = rx.cbegin();\n+      if (k == 0)\n+\ti = ranges::uninitialized_value_construct(rx.begin(), rx.end());\n+      else if (k == 1)\n+\ti = ranges::uninitialized_value_construct(rx);\n+      else if (k == 2)\n+\ti = ranges::uninitialized_value_construct_n(rx.begin(), 1024);\n+      else if (k == 3)\n+\ti = ranges::uninitialized_value_construct(rx.cbegin(), rx.cend());\n+      else if (k == 4)\n+\ti = ranges::uninitialized_value_construct(std::as_const(rx));\n+      else if (k == 5)\n+\ti = ranges::uninitialized_value_construct_n(rx.cbegin(), 1024);\n+      else\n+\t__builtin_abort();\n+\n+      VERIFY( i == rx.cend() );\n+      VERIFY( ranges::find_if(rx, [&t](const T& v) { return t != v; }) == i );\n+\n+      ranges::destroy(rx);\n+    }\n+}\n+\n+struct X\n+{\n+  static constexpr int limit = 67;\n+  static inline int construct_count = 0;\n+  static inline int destruct_count = 0;\n+\n+  struct exception {};\n+\n+  bool live = false;\n+\n+  X()\n+  {\n+    if (construct_count >= limit)\n+      throw exception{};\n+    construct_count++;\n+    live = true;\n+  }\n+\n+  ~X()\n+  {\n+    VERIFY( live );\n+    live = false;\n+    destruct_count++;\n+  }\n+};\n+\n+template<bool test_sized>\n+void\n+test02()\n+{\n+  constexpr int size = 100;\n+  auto buffer = std::unique_ptr<char[]>(new char[sizeof(X)*size]);\n+  test_forward_range<X> rx((X *)buffer.get(), (X *)buffer.get() + size);\n+  try\n+    {\n+      X::construct_count = 0;\n+      X::destruct_count = 0;\n+      if constexpr (test_sized)\n+\tranges::uninitialized_value_construct_n(rx.begin(), size);\n+      else\n+\tranges::uninitialized_value_construct(rx);\n+      VERIFY( false && \"exception not thrown\" );\n+    }\n+  catch (const X::exception&)\n+    {\n+      VERIFY( X::construct_count == X::limit );\n+      VERIFY( X::destruct_count == X::limit );\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01<char>();\n+  test01<int>();\n+  test01<long long>();\n+  test01<float>();\n+  test01<double>();\n+  test01<std::vector<char>>();\n+  test01<std::string>();\n+  test01<std::deque<double>>();\n+  test01<std::list<std::vector<std::deque<double>>>>();\n+  test01<std::unique_ptr<std::string>>();\n+\n+  test02<false>();\n+  test02<true>();\n+}"}]}