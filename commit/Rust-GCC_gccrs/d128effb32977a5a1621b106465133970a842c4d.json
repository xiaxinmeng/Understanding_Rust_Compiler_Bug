{"sha": "d128effb32977a5a1621b106465133970a842c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyOGVmZmIzMjk3N2E1YTE2MjFiMTA2NDY1MTMzOTcwYTg0MmM0ZA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-26T08:39:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-26T08:39:00Z"}, "message": "gcse.c (is_too_expensive): New function.\n\n\t* gcse.c (is_too_expensive): New function.\n\t(gcse_main, delete_null_pointer_checks, bypass_jumps): Use it.\n\nFrom-SVN: r70801", "tree": {"sha": "4643dab8a64a84ed1ea2a0ea685465dcf2539342", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4643dab8a64a84ed1ea2a0ea685465dcf2539342"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d128effb32977a5a1621b106465133970a842c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d128effb32977a5a1621b106465133970a842c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d128effb32977a5a1621b106465133970a842c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d128effb32977a5a1621b106465133970a842c4d/comments", "author": null, "committer": null, "parents": [{"sha": "7e2055ec11ece615f17218f61ae8fd0b594bfba6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e2055ec11ece615f17218f61ae8fd0b594bfba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e2055ec11ece615f17218f61ae8fd0b594bfba6"}], "stats": {"total": 136, "additions": 57, "deletions": 79}, "files": [{"sha": "a39a54da3dda608f471ef7bc083a7787a97d7d2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d128effb32977a5a1621b106465133970a842c4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d128effb32977a5a1621b106465133970a842c4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d128effb32977a5a1621b106465133970a842c4d", "patch": "@@ -1,3 +1,8 @@\n+2003-08-26  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcse.c (is_too_expensive): New function.\n+\t(gcse_main, delete_null_pointer_checks, bypass_jumps): Use it.\n+\n 2003-08-25  Zack Weinberg  <zack@codesourcery.com>\n \n \t* config.gcc (hppa*-*-hpux11*, ia64*-*-hpux*): Remove"}, {"sha": "c7cd4857408eac63cd8d495b8f559fe140207c01", "filename": "gcc/gcse.c", "status": "modified", "additions": 52, "deletions": 79, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d128effb32977a5a1621b106465133970a842c4d/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d128effb32977a5a1621b106465133970a842c4d/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=d128effb32977a5a1621b106465133970a842c4d", "patch": "@@ -165,7 +165,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"params.h\"\n #include \"cselib.h\"\n-\n+#include \"intl.h\"\n #include \"obstack.h\"\n \n /* Propagate flow information through back edges and thus enable PRE's\n@@ -703,7 +703,9 @@ static void local_cprop_find_used_regs (rtx *, void *);\n static bool do_local_cprop (rtx, rtx, int, rtx*);\n static bool adjust_libcall_notes (rtx, rtx, rtx, rtx*);\n static void local_cprop_pass (int);\n+static bool is_too_expensive (const char *);\n \f\n+\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n \n@@ -737,39 +739,10 @@ gcse_main (rtx f, FILE *file)\n   if (file)\n     dump_flow_info (file);\n \n-  /* Return if there's nothing to do.  */\n-  if (n_basic_blocks <= 1)\n+  /* Return if there's nothing to do, or it is too expensive.  */\n+  if (n_basic_blocks <= 1 || is_too_expensive (_(\"GCSE disabled\")))\n     return 0;\n-\n-  /* Trying to perform global optimizations on flow graphs which have\n-     a high connectivity will take a long time and is unlikely to be\n-     particularly useful.\n-\n-     In normal circumstances a cfg should have about twice as many edges\n-     as blocks.  But we do not want to punish small functions which have\n-     a couple switch statements.  So we require a relatively large number\n-     of basic blocks and the ratio of edges to blocks to be high.  */\n-  if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n-    {\n-      if (warn_disabled_optimization)\n-\twarning (\"GCSE disabled: %d > 1000 basic blocks and %d >= 20 edges/basic block\",\n-\t\t n_basic_blocks, n_edges / n_basic_blocks);\n-      return 0;\n-    }\n-\n-  /* If allocating memory for the cprop bitmap would take up too much\n-     storage it's better just to disable the optimization.  */\n-  if ((n_basic_blocks\n-       * SBITMAP_SET_SIZE (max_gcse_regno)\n-       * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n-    {\n-      if (warn_disabled_optimization)\n-\twarning (\"GCSE disabled: %d basic blocks and %d registers\",\n-\t\t n_basic_blocks, max_gcse_regno);\n-\n-      return 0;\n-    }\n-\n+  \n   gcc_obstack_init (&gcse_obstack);\n   bytes_used = 0;\n \n@@ -5945,28 +5918,17 @@ delete_null_pointer_checks (rtx f ATTRIBUTE_UNUSED)\n   basic_block bb;\n   int reg;\n   int regs_per_pass;\n-  int max_reg;\n+  int max_reg = max_reg_num ();\n   struct null_pointer_info npi;\n   int something_changed = 0;\n \n-  /* If we have only a single block, then there's nothing to do.  */\n-  if (n_basic_blocks <= 1)\n-    return 0;\n-\n-  /* Trying to perform global optimizations on flow graphs which have\n-     a high connectivity will take a long time and is unlikely to be\n-     particularly useful.\n-\n-     In normal circumstances a cfg should have about twice as many edges\n-     as blocks.  But we do not want to punish small functions which have\n-     a couple switch statements.  So we require a relatively large number\n-     of basic blocks and the ratio of edges to blocks to be high.  */\n-  if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n+  /* If we have only a single block, or it is too expensive, give up.  */\n+  if (n_basic_blocks <= 1\n+      || is_too_expensive (_ (\"NULL pointer checks disabled\")))\n     return 0;\n \n   /* We need four bitmaps, each with a bit for each register in each\n      basic block.  */\n-  max_reg = max_reg_num ();\n   regs_per_pass = get_bitmap_width (4, last_basic_block, max_reg);\n \n   /* Allocate bitmaps to hold local and global properties.  */\n@@ -7704,39 +7666,10 @@ bypass_jumps (FILE *file)\n   if (file)\n     dump_flow_info (file);\n \n-  /* Return if there's nothing to do.  */\n-  if (n_basic_blocks <= 1)\n+  /* Return if there's nothing to do, or it is too expensive  */\n+  if (n_basic_blocks <= 1 || is_too_expensive (_ (\"jump bypassing disabled\")))\n     return 0;\n \n-  /* Trying to perform global optimizations on flow graphs which have\n-     a high connectivity will take a long time and is unlikely to be\n-     particularly useful.\n-\n-     In normal circumstances a cfg should have about twice as many edges\n-     as blocks.  But we do not want to punish small functions which have\n-     a couple switch statements.  So we require a relatively large number\n-     of basic blocks and the ratio of edges to blocks to be high.  */\n-  if (n_basic_blocks > 1000 && n_edges / n_basic_blocks >= 20)\n-    {\n-      if (warn_disabled_optimization)\n-        warning (\"BYPASS disabled: %d > 1000 basic blocks and %d >= 20 edges/basic block\",\n-                 n_basic_blocks, n_edges / n_basic_blocks);\n-      return 0;\n-    }\n-\n-  /* If allocating memory for the cprop bitmap would take up too much\n-     storage it's better just to disable the optimization.  */\n-  if ((n_basic_blocks\n-       * SBITMAP_SET_SIZE (max_gcse_regno)\n-       * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n-    {\n-      if (warn_disabled_optimization)\n-        warning (\"GCSE disabled: %d basic blocks and %d registers\",\n-                 n_basic_blocks, max_gcse_regno);\n-\n-      return 0;\n-    }\n-\n   gcc_obstack_init (&gcse_obstack);\n   bytes_used = 0;\n \n@@ -7777,4 +7710,44 @@ bypass_jumps (FILE *file)\n   return changed;\n }\n \n+/* Return true if the graph is too expensive to optimize. PASS is the\n+   optimization about to be performed.  */\n+\n+static bool\n+is_too_expensive (const char *pass)\n+{\n+  /* Trying to perform global optimizations on flow graphs which have\n+     a high connectivity will take a long time and is unlikely to be\n+     particularly useful.\n+     \n+     In normal circumstances a cfg should have about twice as many\n+     edges as blocks.  But we do not want to punish small functions\n+     which have a couple switch statements.  Rather than simply\n+     threshold the number of blocks, uses something with a more\n+     graceful degradation.  */\n+  if (n_edges > 20000 + n_basic_blocks * 4)\n+    {\n+      if (warn_disabled_optimization)\n+\twarning (\"%s: %d basic blocks and %d edges/basic block\",\n+\t\t pass, n_basic_blocks, n_edges / n_basic_blocks);\n+      \n+      return true;\n+    }\n+\n+  /* If allocating memory for the cprop bitmap would take up too much\n+     storage it's better just to disable the optimization.  */\n+  if ((n_basic_blocks\n+       * SBITMAP_SET_SIZE (max_reg_num ())\n+       * sizeof (SBITMAP_ELT_TYPE)) > MAX_GCSE_MEMORY)\n+    {\n+      if (warn_disabled_optimization)\n+\twarning (\"%s: %d basic blocks and %d registers\",\n+\t\t pass, n_basic_blocks, max_reg_num ());\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n #include \"gt-gcse.h\""}]}