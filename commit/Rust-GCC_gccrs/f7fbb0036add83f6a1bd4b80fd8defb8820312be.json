{"sha": "f7fbb0036add83f6a1bd4b80fd8defb8820312be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdmYmIwMDM2YWRkODNmNmExYmQ0YjgwZmQ4ZGVmYjg4MjAzMTJiZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-06-08T16:12:13Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-06-08T16:12:13Z"}, "message": "stl_algo.h (is_permutation): Add overloads from N3671.\n\n\t* include/bits/stl_algo.h (is_permutation): Add overloads from N3671.\n\t* include/bits/stl_algobase.h (equal, mismatch): Likewise.\n\t* testsuite/25_algorithms/equal/1.cc: Remove duplicate test case.\n\t* testsuite/25_algorithms/equal/2.cc: New.\n\t* testsuite/25_algorithms/equal/check_type2.cc: New.\n\t* testsuite/25_algorithms/is_permutationqual/2.cc: New.\n\t* testsuite/25_algorithms/is_permutationqual/check_type2.cc: New.\n\t* testsuite/25_algorithms/mismatch/2.cc: New.\n\t* testsuite/25_algorithms/mismatch/check_type2.cc: New.\n\t* testsuite/util/testsuite_iterators.h: Fix spelling.\n\nFrom-SVN: r199854", "tree": {"sha": "2f38fba2ba34dabdab8dacae50f6a8e640cce001", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f38fba2ba34dabdab8dacae50f6a8e640cce001"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7fbb0036add83f6a1bd4b80fd8defb8820312be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fbb0036add83f6a1bd4b80fd8defb8820312be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7fbb0036add83f6a1bd4b80fd8defb8820312be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7fbb0036add83f6a1bd4b80fd8defb8820312be/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db113eda6da16755879ae51d5b9c8f23e997779c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db113eda6da16755879ae51d5b9c8f23e997779c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db113eda6da16755879ae51d5b9c8f23e997779c"}], "stats": {"total": 1040, "additions": 1026, "deletions": 14}, "files": [{"sha": "55037c12db90e1fcc46f2dc7ce1bd5bc3c5f1320", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -1,3 +1,16 @@\n+2013-06-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\t* include/bits/stl_algo.h (is_permutation): Add overloads from N3671.\n+\t* include/bits/stl_algobase.h (equal, mismatch): Likewise.\n+\t* testsuite/25_algorithms/equal/1.cc: Remove duplicate test case.\n+\t* testsuite/25_algorithms/equal/2.cc: New.\n+\t* testsuite/25_algorithms/equal/check_type2.cc: New.\n+\t* testsuite/25_algorithms/is_permutationqual/2.cc: New.\n+\t* testsuite/25_algorithms/is_permutationqual/check_type2.cc: New.\n+\t* testsuite/25_algorithms/mismatch/2.cc: New.\n+\t* testsuite/25_algorithms/mismatch/check_type2.cc: New.\n+\t* testsuite/util/testsuite_iterators.h: Fix spelling.\n+\n 2013-06-08  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/std/type-traits (integral_constant::operator()): Implement"}, {"sha": "e61f22b66a87a48c67e1949e38e05f4996e3e49c", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -4371,6 +4371,140 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return true;\n     }\n \n+#if __cplusplus > 201103L\n+  /**\n+   *  @brief  Checks whether a permutaion of the second sequence is equal\n+   *          to the first sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  Start of first range.\n+   *  @param  __last1   End of first range.\n+   *  @param  __first2  Start of second range.\n+   *  @param  __last2   End of first range.\n+   *  @return true if there exists a permutation of the elements in the range\n+   *          [__first2, __last2), beginning with ForwardIterator2 begin,\n+   *          such that equal(__first1, __last1, begin) returns true;\n+   *          otherwise, returns false.\n+  */\n+  template<typename _ForwardIterator1, typename _ForwardIterator2>\n+    bool\n+    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t   _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n+    {\n+      using _Cat1\n+\t= typename iterator_traits<_ForwardIterator1>::iterator_category;\n+      using _Cat2\n+\t= typename iterator_traits<_ForwardIterator2>::iterator_category;\n+      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;\n+      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;\n+      if (_It1_is_RA() && _It1_is_RA())\n+\t{\n+\t  auto __d1 = std::distance(__first1, __last1);\n+\t  auto __d2 = std::distance(__first2, __last2);\n+\t  if (__d1 != __d2)\n+\t    return false;\n+\t}\n+\n+      // Efficiently compare identical prefixes:  O(N) if sequences\n+      // have the same elements in the same order.\n+      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+\tif (!(*__first1 == *__first2))\n+\t  break;\n+\n+      if (__first1 == __last1 && __first2 == __last2)\n+\treturn true;\n+\n+      if (std::distance(__first1, __last1) != std::distance(__first2, __last2))\n+\treturn false;\n+\n+      for (auto __scan = __first1; __scan != __last1; ++__scan)\n+\t{\n+\t  if (__scan != _GLIBCXX_STD_A::find(__first1, __scan, *__scan))\n+\t    continue; // We've seen this one before.\n+\n+\t  auto __matches = std::count(__first2, __last2, *__scan);\n+\t  if (0 == __matches\n+\t      || std::count(__scan, __last1, *__scan) != __matches)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+\n+  /**\n+   *  @brief  Checks whether a permutation of the second sequence is equal\n+   *          to the first sequence.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  Start of first range.\n+   *  @param  __last1   End of first range.\n+   *  @param  __first2  Start of second range.\n+   *  @param  __last2   End of first range.\n+   *  @param  __pred    A binary predicate.\n+   *  @return true if there exists a permutation of the elements in the range\n+   *          [__first2, __last2), beginning with ForwardIterator2 begin,\n+   *          such that equal(__first1, __last1, __begin, __pred) returns true;\n+   *          otherwise, returns false.\n+  */\n+  template<typename _ForwardIterator1, typename _ForwardIterator2,\n+\t   typename _BinaryPredicate>\n+    bool\n+    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n+\t\t   _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n+\t\t   _BinaryPredicate __pred)\n+    {\n+      using _Cat1\n+\t= typename iterator_traits<_ForwardIterator1>::iterator_category;\n+      using _Cat2\n+\t= typename iterator_traits<_ForwardIterator2>::iterator_category;\n+      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;\n+      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;\n+      constexpr bool __ra_iters = _It1_is_RA() && _It1_is_RA();\n+      if (__ra_iters)\n+\t{\n+\t  auto __d1 = std::distance(__first1, __last1);\n+\t  auto __d2 = std::distance(__first2, __last2);\n+\t  if (__d1 != __d2)\n+\t    return false;\n+\t}\n+\n+      // Efficiently compare identical prefixes:  O(N) if sequences\n+      // have the same elements in the same order.\n+      for (; __first1 != __last1; ++__first1, ++__first2)\n+\tif (!bool(__pred(*__first1, *__first2)))\n+\t  break;\n+\n+      if (__ra_iters)\n+\t{\n+\t  if (__first1 == __last1)\n+\t    return true;\n+\t}\n+      else\n+\t{\n+\t  auto __d1 = std::distance(__first1, __last1);\n+\t  auto __d2 = std::distance(__first2, __last2);\n+\t  if (__d1 == 0 && __d2 == 0)\n+\t    return true;\n+\t  if (__d1 != __d2)\n+\t    return false;\n+\t}\n+\n+      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)\n+\t{\n+\t  using std::placeholders::_1;\n+\n+\t  if (__scan != _GLIBCXX_STD_A::find_if(__first1, __scan,\n+\t\t\t\t\t\tstd::bind(__pred, _1, *__scan)))\n+\t    continue; // We've seen this one before.\n+\n+\t  auto __matches = std::count_if(__first2, __last2,\n+\t\t\t\t\t std::bind(__pred, _1, *__scan));\n+\t  if (0 == __matches\n+\t      || std::count_if(__scan, __last1,\n+\t\t\t       std::bind(__pred, _1, *__scan)) != __matches)\n+\t    return false;\n+\t}\n+      return true;\n+    }\n+#endif\n+\n #ifdef _GLIBCXX_USE_C99_STDINT_TR1\n   /**\n    *  @brief Shuffle the elements of a sequence using a uniform random"}, {"sha": "67f859b3602081d75cbfc0feaad768f8ac80d362", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -798,6 +798,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      return false;\n \t  return true;\n \t}\n+\n+#if __cplusplus > 201103L\n+      template<typename _II1, typename _II2>\n+        static bool\n+        equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+        {\n+\t  for (; __first1 != __last1 && __first2 != __last2;\n+\t      ++__first1, ++__first2)\n+\t    if (!(*__first1 == *__first2))\n+\t      return false;\n+\t  return true;\n+\t}\n+#endif\n     };\n \n   template<>\n@@ -810,6 +823,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)\n \t\t\t\t   * (__last1 - __first1));\n \t}\n+\n+#if __cplusplus > 201103L\n+      template<typename _Tp>\n+        static bool\n+        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2,\n+\t      const _Tp* __last2)\n+        {\n+\t  return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)\n+\t\t\t\t   * (__last1 - __first1));\n+\t}\n+#endif\n     };\n \n   template<typename _II1, typename _II2>\n@@ -827,6 +851,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return std::__equal<__simple>::equal(__first1, __last1, __first2);\n     }\n \n+#if __cplusplus > 201103L\n+  template<bool _BoolType>\n+    struct __equal2\n+    {\n+      template<typename _It>\n+\tusing _IterCat = typename iterator_traits<_It>::iterator_category;\n+      template<typename _It>\n+\tusing _IsRA = is_same<_IterCat<_It>, random_access_iterator_tag>;\n+\n+      template<typename _II1, typename _II2>\n+        static bool\n+        equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+        {\n+\t  constexpr bool __ra_iters = _IsRA<_II1>() && _IsRA<_II2>();\n+\t  if (__ra_iters)\n+\t    {\n+\t      auto __d1 = std::distance(__first1, __last1);\n+\t      auto __d2 = std::distance(__first2, __last2);\n+\t      if (__d1 != __d2)\n+\t\treturn false;\n+\t    }\n+\t  for (; __first1 != __last1 && __first2 != __last2;\n+\t       ++__first1, ++__first2)\n+\t    if (!(*__first1 == *__first2))\n+\t      return false;\n+\t  return __ra_iters || (__first1 == __last1 && __first2 == __last2);\n+\t}\n+    };\n+\n+  template<>\n+    struct __equal2<true>\n+    {\n+      template<typename _Tp>\n+        static bool\n+        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2,\n+\t      const _Tp* __last2)\n+        {\n+\t  if ((__last1 - __first1) != (__last2 - __first2))\n+\t    return false;\n+\t  return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)\n+\t\t\t\t   * (__last1 - __first1));\n+\t}\n+    };\n+\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    __equal2_aux(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+    {\n+      typedef typename iterator_traits<_II1>::value_type _ValueType1;\n+      typedef typename iterator_traits<_II2>::value_type _ValueType2;\n+      const bool __simple = ((__is_integer<_ValueType1>::__value\n+\t\t\t      || __is_pointer<_ValueType1>::__value)\n+\t                     && __is_pointer<_II1>::__value\n+\t                     && __is_pointer<_II2>::__value\n+\t\t\t     && __are_same<_ValueType1, _ValueType2>::__value);\n+\n+      return __equal2<__simple>::equal(__first1, __last1, __first2, __last2);\n+    }\n+#endif\n \n   template<typename, typename>\n     struct __lc_rai\n@@ -1064,6 +1147,86 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       return true;\n     }\n \n+#if __cplusplus > 201103L\n+  /**\n+   *  @brief Tests a range for element-wise equality.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  An input iterator.\n+   *  @param  __last1   An input iterator.\n+   *  @param  __first2  An input iterator.\n+   *  @param  __last2   An input iterator.\n+   *  @return   A boolean true or false.\n+   *\n+   *  This compares the elements of two ranges using @c == and returns true or\n+   *  false depending on whether all of the corresponding elements of the\n+   *  ranges are equal.\n+  */\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n+      __glibcxx_function_requires(_EqualOpConcept<\n+\t    typename iterator_traits<_II1>::value_type,\n+\t    typename iterator_traits<_II2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n+\n+      return std::__equal2_aux(std::__niter_base(__first1),\n+\t\t\t       std::__niter_base(__last1),\n+\t\t\t       std::__niter_base(__first2),\n+\t\t\t       std::__niter_base(__last2));\n+    }\n+\n+  /**\n+   *  @brief Tests a range for element-wise equality.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  An input iterator.\n+   *  @param  __last1   An input iterator.\n+   *  @param  __first2  An input iterator.\n+   *  @param  __last2   An input iterator.\n+   *  @param __binary_pred A binary predicate @link functors\n+   *                  functor@endlink.\n+   *  @return         A boolean true or false.\n+   *\n+   *  This compares the elements of two ranges using the binary_pred\n+   *  parameter, and returns true or\n+   *  false depending on whether all of the corresponding elements of the\n+   *  ranges are equal.\n+  */\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n+    inline bool\n+    equal(_IIter1 __first1, _IIter1 __last1,\n+\t  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_IIter1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_IIter2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n+\n+      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;\n+      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;\n+      using _IIter1_is_RA = is_same<_Cat1, random_access_iterator_tag>;\n+      using _IIter2_is_RA = is_same<_Cat2, random_access_iterator_tag>;\n+      constexpr bool __ra_iters = _IIter1_is_RA() && _IIter1_is_RA();\n+      if (__ra_iters)\n+\t{\n+\t  auto __d1 = std::distance(__first1, __last1);\n+\t  auto __d2 = std::distance(__first2, __last2);\n+\t  if (__d1 != __d2)\n+\t    return false;\n+\t}\n+\n+      for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n+\tif (!bool(__binary_pred(*__first1, *__first2)))\n+\t  return false;\n+      return __ra_iters || (__first1 == __last1 && __first2 == __last2);\n+    }\n+#endif\n+\n   /**\n    *  @brief Performs @b dictionary comparison on ranges.\n    *  @ingroup sorting_algorithms\n@@ -1211,6 +1374,84 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n     }\n \n+#if __cplusplus > 201103L\n+  /**\n+   *  @brief Finds the places in ranges which don't match.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  An input iterator.\n+   *  @param  __last1   An input iterator.\n+   *  @param  __first2  An input iterator.\n+   *  @param  __last2   An input iterator.\n+   *  @return   A pair of iterators pointing to the first mismatch.\n+   *\n+   *  This compares the elements of two ranges using @c == and returns a pair\n+   *  of iterators.  The first iterator points into the first range, the\n+   *  second iterator points into the second range, and the elements pointed\n+   *  to by the iterators are not equal.\n+  */\n+  template<typename _InputIterator1, typename _InputIterator2>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2, _InputIterator2 __last2)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_function_requires(_EqualOpConcept<\n+\t    typename iterator_traits<_InputIterator1>::value_type,\n+\t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n+\n+      while (__first1 != __last1 && __first2 != __last2\n+\t  && *__first1 == *__first2)\n+        {\n+\t  ++__first1;\n+\t  ++__first2;\n+        }\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n+\n+  /**\n+   *  @brief Finds the places in ranges which don't match.\n+   *  @ingroup non_mutating_algorithms\n+   *  @param  __first1  An input iterator.\n+   *  @param  __last1   An input iterator.\n+   *  @param  __first2  An input iterator.\n+   *  @param  __last2   An input iterator.\n+   *  @param __binary_pred A binary predicate @link functors\n+   *         functor@endlink.\n+   *  @return   A pair of iterators pointing to the first mismatch.\n+   *\n+   *  This compares the elements of two ranges using the binary_pred\n+   *  parameter, and returns a pair\n+   *  of iterators.  The first iterator points into the first range, the\n+   *  second iterator points into the second range, and the elements pointed\n+   *  to by the iterators are not equal.\n+  */\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n+    pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2, _InputIterator2 __last2,\n+\t     _BinaryPredicate __binary_pred)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n+      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n+\n+      while (__first1 != __last1 && __first2 != __last2\n+\t  && bool(__binary_pred(*__first1, *__first2)))\n+        {\n+\t  ++__first1;\n+\t  ++__first2;\n+        }\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+    }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_ALGO\n } // namespace std\n "}, {"sha": "f8c13550de3909d045bf687f19166dcf0ad628a8", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/1.cc", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F1.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -27,6 +27,8 @@ int array1[] = {0, 1};\n int array2[] = {1, 0};\n int array3[] = {1, 0};\n \n+bool __attribute__((unused)) test = false;\n+\n void test1()\n {\n   Container con1(array1, array1);\n@@ -42,20 +44,13 @@ void test2()\n }\n \n void test3()\n-{\n-  Container con1(array1, array1 + 2);\n-  Container con2(array2, array2 + 2);\n-  VERIFY( !std::equal(con2.begin(), con2.end(), con1.begin()) );\n-}\n-\n-void test4()\n {\n   Container con1(array1, array1 + 2);\n   Container con2(array2, array2 + 2);\n   VERIFY( !std::equal(con1.begin(), con1.end(), con2.begin()) );\n }\n \n-void test5()\n+void test4()\n {\n   Container con3(array3, array3 + 2);\n   Container con2(array2, array2 + 2);\n@@ -68,5 +63,4 @@ int main()\n   test2();\n   test3();\n   test4();\n-  test5();\n }"}, {"sha": "012609f7fe86e5c1e47ea12f37e7cc99d59d91a9", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/2.cc", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2F2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,193 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.11 [alg.equal]\n+\n+// { dg-options \"-std=gnu++1y\" }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+typedef test_container<int, input_iterator_wrapper> Container;\n+typedef test_container<int, random_access_iterator_wrapper> RA_Container;\n+int array1[] = {0, 1};\n+int array2[] = {1, 0};\n+int array3[] = {1, 0};\n+\n+struct equal_to\n+{\n+  static int count;\n+\n+  bool operator()(int l, int r)\n+  {\n+    ++count;\n+    return l == r;\n+  }\n+} eq;\n+\n+int equal_to::count = 0;\n+\n+bool __attribute__((unused)) test = false;\n+\n+void test1()\n+{\n+  const Container con1(array1, array1);\n+  const Container con2(array2, array2);\n+\n+  auto c1 = con1;\n+  auto c2 = con2;\n+  VERIFY( std::equal(c1.begin(), c1.end(), c2.begin(), c2.end()) );\n+  VERIFY( equal_to::count == 0 );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( std::equal(c1.begin(), c1.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+void test2()\n+{\n+  const Container con1(array1, array1 + 0);\n+  const Container con2(array2, array2 + 2);\n+\n+  auto c1 = con1;\n+  auto c2 = con2;\n+  VERIFY( !std::equal(c1.begin(), c1.end(), c2.begin(), c2.end()) );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c1.begin(), c1.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 0 );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c1.begin(), c1.end()) );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c1.begin(), c1.end(), eq) );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+void test3()\n+{\n+  const Container con1(array1, array1 + 2);\n+  const Container con2(array2, array2 + 2);\n+\n+  auto c1 = con1;\n+  auto c2 = con2;\n+  VERIFY( !std::equal(c1.begin(), c1.end(), c2.begin(), c2.end()) );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c1.begin(), c1.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 1 );\n+  equal_to::count = 0;\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c1.begin(), c1.end()) );\n+\n+  c1 = con1;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c1.begin(), c1.end(), eq) );\n+  VERIFY( equal_to::count == 1 );\n+  equal_to::count = 0;\n+}\n+\n+void test4()\n+{\n+  const Container con3(array3, array3 + 2);\n+  const Container con2(array2, array2 + 2);\n+\n+  auto c3 = con3;\n+  auto c2 = con2;\n+  VERIFY( std::equal(c3.begin(), c3.end(), c2.begin(), c2.end()) );\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( std::equal(c3.begin(), c3.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 2 );\n+  equal_to::count = 0;\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( std::equal(c2.begin(), c2.end(), c3.begin(), c3.end()) );\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( std::equal(c2.begin(), c2.end(), c3.begin(), c3.end(), eq) );\n+  VERIFY( equal_to::count == 2 );\n+  equal_to::count = 0;\n+}\n+\n+void test5()\n+{\n+  const Container con3(array3, array3 + 1);\n+  const Container con2(array2, array2 + 2);\n+\n+  auto c3 = con3;\n+  auto c2 = con2;\n+  VERIFY( !std::equal(c3.begin(), c3.end(), c2.begin(), c2.end()) );\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( !std::equal(c3.begin(), c3.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 1 );\n+  equal_to::count = 0;\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c3.begin(), c3.end()) );\n+\n+  c3 = con3;\n+  c2 = con2;\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c3.begin(), c3.end(), eq) );\n+  VERIFY( equal_to::count == 1 );\n+  equal_to::count = 0;\n+}\n+\n+void test6()\n+{\n+  RA_Container c3(array3, array3 + 1);\n+  RA_Container c2(array2, array2 + 2);\n+\n+  VERIFY( !std::equal(c3.begin(), c3.end(), c2.begin(), c2.end()) );\n+\n+  VERIFY( !std::equal(c3.begin(), c3.end(), c2.begin(), c2.end(), eq) );\n+  VERIFY( equal_to::count == 0 );\n+\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c3.begin(), c3.end()) );\n+\n+  VERIFY( !std::equal(c2.begin(), c2.end(), c3.begin(), c3.end(), eq) );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+int main()\n+{\n+  test1();\n+  test2();\n+  test3();\n+  test4();\n+  test5();\n+  test6();\n+}"}, {"sha": "c80cced592395ef4601305ecc12cca933f3541e4", "filename": "libstdc++-v3/testsuite/25_algorithms/equal/check_type2.cc", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fcheck_type2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fcheck_type2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fequal%2Fcheck_type2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,48 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.11 [alg.equal]\n+\n+// { dg-do compile }\n+// { dg-options \" -std=gnu++1y \" }\n+\n+#include <algorithm>\n+#include <testsuite_iterators.h>\n+using __gnu_test::input_iterator_wrapper;\n+\n+struct Lhs1 { };\n+\n+struct Rhs1 { };\n+\n+bool operator==(const Lhs1&, const Rhs1&) {return true;}\n+\n+struct Lhs2 { };\n+\n+struct Rhs2 { };\n+\n+bool \n+predicate(const Lhs2&, const Rhs2&) {return true;}\n+\n+bool \n+test1(input_iterator_wrapper<Lhs1>& lhs1,\n+      input_iterator_wrapper<Rhs1>& rhs1)\n+{ return std::equal(lhs1, lhs1, rhs1, rhs1); }\n+\n+bool \n+test2(input_iterator_wrapper<Lhs2>& lhs2,\n+      input_iterator_wrapper<Rhs2>& rhs2)\n+{ return std::equal(lhs2, lhs2, rhs2, rhs2, predicate); }"}, {"sha": "d573fa2c932f32ae4c0d3abb2f511b2b5482a701", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/2.cc", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2F2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,115 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [alg.is_permutation] Is permutation\n+\n+#include <algorithm>\n+#include <functional>\n+#include <testsuite_hooks.h>\n+\n+struct my_equal_to\n+{\n+  bool\n+  operator()(int __x, int __y) const\n+  { return __x % 10 == __y % 10; }\n+};\n+\n+const int arr0[] = { 11, 22, 33, 44, 55 };\n+\n+void\n+do_test(int arr1[5], bool np = true, unsigned N = 5)\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  do\n+    VERIFY( std::is_permutation(arr1, arr1 + 5, arr0, arr0 + N) == np );\n+  while (std::next_permutation(arr1, arr1 + 5));\n+}\n+\n+template<typename Predicate>\n+  void\n+  do_test(int arr1[5], Predicate pred, bool np = true, unsigned N = 5)\n+  {\n+    bool test __attribute__((unused)) = true;\n+\n+    do\n+      VERIFY( std::is_permutation(arr1, arr1 + 5, arr0, arr0 + N, pred) == np );\n+    while (std::next_permutation(arr1, arr1 + 5));\n+  }\n+\n+void test01()\n+{\n+  int arr1[] = { 11, 22, 33, 44, 55 };\n+  do_test(arr1);\n+  do_test(arr1, false, 4);\n+\n+  int arr2[] = { 11, 33, 33, 44, 55 };\n+  do_test(arr2, false);\n+\n+  int arr3[] = { 33, 33, 33, 44, 44 };\n+  do_test(arr3, false);\n+\n+  int arr4[] = { 11, 22, 33, 44, 55 };\n+  do_test(arr4, std::equal_to<int>());\n+  do_test(arr4, std::equal_to<int>(), false, 4);\n+\n+  int arr5[] = { 11, 33, 33, 44, 55 };\n+  do_test(arr5, std::equal_to<int>(), false);\n+\n+  int arr6[] = { 33, 33, 33, 44, 44 };\n+  do_test(arr6, std::equal_to<int>(), false);\n+\n+  int arr7[] = { 1, 2, 3, 4, 5 };\n+  do_test(arr7, my_equal_to());\n+  do_test(arr7, my_equal_to(), false, 4);\n+\n+  int arr8[] = { 1, 3, 3, 4, 5 };\n+  do_test(arr8, my_equal_to(), false);\n+\n+  int arr9[] = { 3, 3, 3, 4, 4 };\n+  do_test(arr9, my_equal_to(), false);\n+\n+  int arr10[] = { 111, 222, 333, 444, 555 };\n+  do_test(arr10, my_equal_to());\n+  do_test(arr10, my_equal_to(), false, 4);\n+\n+  int arr11[] = { 1, 222, 33, 4, 55 };\n+  do_test(arr11, my_equal_to());\n+\n+  int arr12[] = { 111, 333, 333, 444, 555 };\n+  do_test(arr12, my_equal_to(), false);\n+\n+  int arr13[] = { 333, 333, 333, 444, 444 };\n+  do_test(arr13, my_equal_to(), false);\n+}\n+\n+bool thrower(int, int) { throw 1; }\n+\n+void test02()\n+{\n+  int arr[] = { 11, 22, 33 };\n+  using namespace std;\n+  is_permutation(begin(arr0), end(arr0), begin(arr), end(arr), thrower);\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "9cdf87daf08415610bf26b24802b8df1272219e4", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/check_type2.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fcheck_type2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [alg.is_permutation] Is permutation\n+\n+// { dg-do compile }\n+// { dg-options \" -std=gnu++1y \" }\n+\n+#include <algorithm>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::forward_iterator_wrapper;\n+\n+struct X { };\n+bool operator==(const X&, const X) { return true; }\n+\n+struct Y { };\n+bool predicate(const Y&, const Y&) { return true; }\n+\n+bool\n+test1(forward_iterator_wrapper<X>& x1, \n+      forward_iterator_wrapper<X>& x2)\n+{\n+  return std::is_permutation(x1, x1, x2, x2);\n+}\n+\n+bool\n+test2(forward_iterator_wrapper<Y>& y1,\n+      forward_iterator_wrapper<Y>& y2)\n+{\n+  return std::is_permutation(y1, y1, y2, y2, predicate);\n+}"}, {"sha": "c70d778a14272d8836b933be69f9e804506fad57", "filename": "libstdc++-v3/testsuite/25_algorithms/mismatch/1.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F1.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -29,6 +29,8 @@ int array1[] = {0, 1};\n int array2[] = {1, 0};\n int array3[] = {1, 0, 1};\n \n+bool __attribute__((unused)) test = false;\n+\n void test1a()\n {\n   Container con1(array1, array1);"}, {"sha": "4eac4a9e3efb3eb21bfc648f75d0cb03756307d7", "filename": "libstdc++-v3/testsuite/25_algorithms/mismatch/2.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2F2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,175 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.10 [mismatch]\n+\n+// { dg-options \" -std=gnu++1y \" }\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+\n+typedef test_container<int, input_iterator_wrapper> Container;\n+\n+int array1[] = {0, 1};\n+int array2[] = {1, 0};\n+int array3[] = {1, 0, 1};\n+\n+struct equal_to\n+{\n+  static int count;\n+\n+  bool operator()(int l, int r)\n+  {\n+    ++count;\n+    return l == r;\n+  }\n+} eq;\n+\n+int equal_to::count = 0;\n+\n+bool __attribute__((unused)) test = false;\n+\n+void test1()\n+{\n+  // empty ranges\n+  Container con1(array1, array1);\n+  Container con2(array2, array2);\n+  auto res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+  res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+void test2()\n+{\n+  // first range empty, second non-empty\n+  Container con1(array1, array1);\n+  Container con2(array2, array2 + 2);\n+  auto res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+\n+  res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+void test3()\n+{\n+  // first range non-empty, second empty\n+  Container con1(array1, array1 + 2);\n+  Container con2(array2, array2);\n+  auto res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+\n+  res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+  VERIFY( equal_to::count == 0 );\n+}\n+\n+void test4()\n+{\n+  // non-empty, mismatching ranges\n+  Container con1(array1, array1 + 2);\n+  Container con2(array2, array2 + 2);\n+  auto res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+\n+  con1.bounds.first = array1;\n+  con2.bounds.first = array2;\n+  res = std::mismatch(con1.begin(), con1.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array1 );\n+  VERIFY( res.second.ptr == array2 );\n+  VERIFY( equal_to::count == 1 );\n+  equal_to::count = 0;\n+}\n+\n+void test5()\n+{\n+  // non-empty, matching ranges\n+  Container con3(array3, array3 + 2);\n+  Container con2(array2, array2 + 2);\n+  auto res = std::mismatch(con3.begin(), con3.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array3 + 2 );\n+  VERIFY( res.second.ptr == array2 + 2 );\n+\n+  con3.bounds.first = array3;\n+  con2.bounds.first = array2;\n+  res = std::mismatch(con3.begin(), con3.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array3 + 2 );\n+  VERIFY( res.second.ptr == array2 + 2 );\n+  VERIFY( equal_to::count == 2 );\n+  equal_to::count = 0;\n+}\n+\n+void test6()\n+{\n+  // non-empty, matching sub-ranges, first range longer\n+  Container con3(array3, array3 + 3);\n+  Container con2(array2, array2 + 2);\n+  auto res = std::mismatch(con3.begin(), con3.end(), con2.begin(), con2.end());\n+  VERIFY( res.first.ptr == array3 + 2 );\n+  VERIFY( res.second.ptr == array2 + 2 );\n+\n+  con3.bounds.first = array3;\n+  con2.bounds.first = array2;\n+  res = std::mismatch(con3.begin(), con3.end(), con2.begin(), con2.end(), eq);\n+  VERIFY( res.first.ptr == array3 + 2 );\n+  VERIFY( res.second.ptr == array2 + 2 );\n+  VERIFY( equal_to::count == 2 );\n+  equal_to::count = 0;\n+}\n+\n+void test7()\n+{\n+  // non-empty, matching sub-ranges, second range longer\n+  Container con3(array3, array3 + 3);\n+  Container con2(array2, array2 + 2);\n+  auto res = std::mismatch(con2.begin(), con2.end(), con3.begin(), con3.end());\n+  VERIFY( res.first.ptr == array2 + 2 );\n+  VERIFY( res.second.ptr == array3 + 2 );\n+\n+  con3.bounds.first = array3;\n+  con2.bounds.first = array2;\n+  res = std::mismatch(con2.begin(), con2.end(), con3.begin(), con3.end(), eq);\n+  VERIFY( res.first.ptr == array2 + 2 );\n+  VERIFY( res.second.ptr == array3 + 2 );\n+  VERIFY( equal_to::count == 2 );\n+  equal_to::count = 0;\n+}\n+\n+int main()\n+{\n+  test1();\n+  test2();\n+  test3();\n+  test4();\n+  test5();\n+  test6();\n+  test7();\n+}"}, {"sha": "3ec1f88401a22b3beddf9a8d20522df789a77690", "filename": "libstdc++-v3/testsuite/25_algorithms/mismatch/check_type2.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fcheck_type2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fcheck_type2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fmismatch%2Fcheck_type2.cc?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2005-2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.10 [mismatch]\n+\n+// { dg-options \" -std=gnu++1y \" }\n+// { dg-do compile }\n+\n+#include <algorithm>\n+#include <utility>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::input_iterator_wrapper;\n+\n+struct Lhs1 { };\n+\n+struct Rhs1 { };\n+\n+bool operator==(const Lhs1&, const Rhs1&) {return true;}\n+\n+struct Lhs2 { };\n+\n+struct Rhs2 { };\n+\n+bool predicate(const Lhs2&, const Rhs2&) {return true;}\n+\n+std::pair<input_iterator_wrapper<Lhs1>, input_iterator_wrapper<Rhs1> >\n+test1(input_iterator_wrapper<Lhs1>& lhs1, input_iterator_wrapper<Rhs1>& rhs1)\n+{\n+  return std::mismatch(lhs1, lhs1, rhs1, rhs1);\n+}\n+\n+std::pair<input_iterator_wrapper<Lhs2>, input_iterator_wrapper<Rhs2> >\n+test2(input_iterator_wrapper<Lhs2>& lhs2, input_iterator_wrapper<Rhs2>& rhs2)\n+{\n+  return std::mismatch(lhs2, lhs2, rhs2, rhs2, predicate);\n+}"}, {"sha": "9bb5858865137e39d341b06c99a5c51ea73c0293", "filename": "libstdc++-v3/testsuite/util/testsuite_iterators.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7fbb0036add83f6a1bd4b80fd8defb8820312be/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_iterators.h?ref=f7fbb0036add83f6a1bd4b80fd8defb8820312be", "patch": "@@ -116,7 +116,7 @@ namespace __gnu_test\n    * \n    * This class takes a pointer and wraps it to provide exactly\n    * the requirements of a output_iterator. It should not be\n-   * instansiated directly, but generated from a test_container\n+   * instantiated directly, but generated from a test_container\n    */\n   template<class T>\n   struct output_iterator_wrapper\n@@ -177,7 +177,7 @@ namespace __gnu_test\n    * \n    * This class takes a pointer and wraps it to provide exactly\n    * the requirements of a input_iterator. It should not be\n-   * instansiated directly, but generated from a test_container\n+   * instantiated directly, but generated from a test_container\n    */\n   template<class T>\n   class input_iterator_wrapper\n@@ -259,7 +259,7 @@ namespace __gnu_test\n    * \n    * This class takes a pointer and wraps it to provide exactly\n    * the requirements of a forward_iterator. It should not be\n-   * instansiated directly, but generated from a test_container\n+   * instantiated directly, but generated from a test_container\n    */\n   template<class T>\n   struct forward_iterator_wrapper : public input_iterator_wrapper<T>\n@@ -313,7 +313,7 @@ namespace __gnu_test\n    * \n    * This class takes a pointer and wraps it to provide exactly\n    * the requirements of a forward_iterator. It should not be\n-   * instansiated directly, but generated from a test_container\n+   * instantiated directly, but generated from a test_container\n    */\n   template<class T>\n   struct bidirectional_iterator_wrapper : public forward_iterator_wrapper<T>\n@@ -377,7 +377,7 @@ namespace __gnu_test\n    * \n    * This class takes a pointer and wraps it to provide exactly\n    * the requirements of a forward_iterator. It should not be\n-   * instansiated directly, but generated from a test_container\n+   * instantiated directly, but generated from a test_container\n    */\n   template<class T>\n   struct random_access_iterator_wrapper "}]}