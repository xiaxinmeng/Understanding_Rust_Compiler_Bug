{"sha": "ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2UxOGVmY2I1NGZmNWQzZGU4YjAzNWFhMmNkMzRkYjQ3MTViOGJmZA==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-09-02T18:54:25Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-09-02T18:54:25Z"}, "message": "invoke.texi (-fsched-pressure): Document it.\n\n2009-09-02  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* doc/invoke.texi (-fsched-pressure): Document it.\n\t(-fsched-reg-pressure-heuristic): Remove it.\n\t\n\t* reload.c (ira.h): Include.\n\t(find_reloads): Add choosing reload on number of small spilled\n\tclasses.\n\t\n\t* haifa-sched.c (ira.h): Include.\n\t(sched_pressure_p, sched_regno_cover_class, curr_reg_pressure,\n\tsaved_reg_pressure, curr_reg_live, saved_reg_live,\n\tregion_ref_regs): New variables.\n\t(sched_init_region_reg_pressure_info, mark_regno_birth_or_death,\n\tinitiate_reg_pressure_info, setup_ref_regs,\n\tinitiate_bb_reg_pressure_info, save_reg_pressure,\n\trestore_reg_pressure, dying_use_p, print_curr_reg_pressure): New\n\tfunctions.\n\t(setup_insn_reg_pressure_info): New function.\n\t(rank_for_schedule): Add pressure checking and insn issue time.\n\tRemove comparison of insn reg weights.\n\t(ready_sort): Set insn reg pressure info.\n\t(update_register_pressure, setup_insn_max_reg_pressure,\n\tupdate_reg_and_insn_max_reg_pressure,\n\tsched_setup_bb_reg_pressure_info): New functions.\n\t(schedule_insn): Add code for printing and updating reg pressure\n\tinfo.\n\t(find_set_reg_weight, find_insn_reg_weight): Remove.\n\t(ok_for_early_queue_removal): Do nothing if pressure_only_p.\n\t(debug_ready_list): Print reg pressure info.\n\t(schedule_block): Ditto.  Check insn issue time.\n\t(sched_init): Set up sched_pressure_p.  Allocate and set up some\n\treg pressure related info.\n\t(sched_finish): Free some reg pressure related info.\n\t(fix_tick_ready): Make insn always ready if pressure_p.\n\t(init_h_i_d): Don't call find_insn_reg_weight.\n\t(haifa_finish_h_i_d): Free insn reg pressure info.\n\t\n\t* ira-int.h (ira_hard_regno_cover_class, ira_reg_class_nregs,\n\tira_memory_move_cost, ira_class_hard_regs,\n\tira_class_hard_regs_num, ira_no_alloc_regs,\n\tira_available_class_regs, ira_reg_class_cover_size,\n\tira_reg_class_cover, ira_class_translate): Move to ira.h.\n\n\t* ira-lives.c (single_reg_class): Check mode to find how many\n\tregisters are necessary for operand.\n\t(ira_implicitly_set_insn_hard_regs): New.\n\n\t* common.opt (fsched-pressure): New options.\n\t(fsched-reg-pressure-heuristic): Remove.\n\n\t* ira.c (setup_eliminable_regset): Rename to\n\tira_setup_eliminable_regset.  Make it external.\n\t(expand_reg_info): Pass cover class to setup_reg_classes.\n\t(ira): Call resize_reg_info instead of allocate_reg_info.\n\n\t* sched-deps.c: Include ira.h.\n\t(implicit_reg_pending_clobbers, implicit_reg_pending_uses): New.\n\t(create_insn_reg_use, create_insn_reg_set, setup_insn_reg_uses,\n\treg_pressure_info, insn_use_p, mark_insn_pseudo_birth,\n\tmark_insn_hard_regno_birth, mark_insn_reg_birth,\n\tmark_pseudo_death, mark_hard_regno_death, mark_reg_death,\n\tmark_insn_reg_store, mark_insn_reg_clobber,\n\tsetup_insn_reg_pressure_info): New.\n\t(sched_analyze_1): Update implicit_reg_pending_uses.\n\t(sched_analyze_insn): Find implicit sets, uses, clobbers of regs.\n\tUse them to create dependencies.  Set insn reg uses and pressure\n\tinfo.  Process reg_pending_uses in one place.\n\t(free_deps): Free implicit sets.\n\t(remove_from_deps): Remove implicit sets if necessary.  Check\n\timplicit sets when clearing reg_last_in_use.\n\t(init_deps_global): Clear implicit_reg_pending_clobbers and\n\timplicit_reg_pending_uses.\n\t\n\t* ira.h (ira_hard_regno_cover_class, ira_reg_class_nregs,\n\tira_memory_move_cost, ira_class_hard_regs,\n\tira_class_hard_regs_num, ira_no_alloc_regs,\n\tira_available_class_regs, ira_reg_class_cover_size,\n\tira_reg_class_cover, ira_class_translate): Move from ira-int.h.\n\t(ira_setup_eliminable_regset, ira_set_pseudo_classes,\n\tira_implicitly_set_insn_hard_regs): New prototypes.\n\t\n\t* ira-costs.c (pseudo_classes_defined_p, allocno_p,\n\tcost_elements_num): New variables.\n\t(allocno_costs, total_costs): Rename to costs and\n\ttotal_allocno_costs.\n\t(COSTS_OF_ALLOCNO): Rename to COSTS.\n\t(allocno_pref): Rename to pref.\n\t(allocno_pref_buffer): Rename to pref_buffer.\n\t(common_classes): Rename to regno_cover_class.\n\t(COST_INDEX): New.\n\t(record_reg_classes): Set allocno attributes only if allocno_p.\n\t(record_address_regs): Ditto.  Use COST_INDEX instead of\n\tALLOCNO_NUM.\n\t(scan_one_insn): Use COST_INDEX and COSTS instead of ALLOCNO_NUM\n\tand COSTS_OF_ALLOCNO.\n\t(print_costs): Rename to print_allocno_costs.\n\t(print_pseudo_costs): New.\n\t(process_bb_node_for_costs): Split into 2 functions with new\n\tfunction process_bb_for_costs.  Pass BB to process_bb_for_costs.\n\t(find_allocno_class_costs): Rename to find_costs_and_classes.  Add\n\tnew parameter dump_file.  Use cost_elements_num instead of\n\tira_allocnos_num.  Make one iteration if preferred classes were\n\talready calculated for scheduler.  Make 2 versions of code\n\tdepending on allocno_p.\n\t(setup_allocno_cover_class_and_costs): Check allocno_p.  Use\n\tregno_cover_class and COSTS instead of common_classes and\n\tCOSTS_OF_ALLOCNO.\n\t(init_costs, finish_costs): New.\n\t(ira_costs): Set up allocno_p and cost_elements_num.  Call\n\tinit_costs and finish_costs.\n\t(ira_set_pseudo_classes): New.\n\n\t* rtl.h (allocate_reg_info): Remove.\n\t(resize_reg_info): Change return type.\n\t(reg_cover_class): New.\n\t(setup_reg_classes): Add new parameter.\n\t\n\t* sched-int.h (struct deps_reg): New member implicit_sets.\n\t(sched_pressure_p, sched_regno_cover_class): New external\n\tdefinitions.\n\t(INCREASE_BITS): New macro.\n\t(struct reg_pressure_data, struct reg_use_data): New.\n\t(struct _haifa_insn_data): Remove reg_weight.  Add members\n\treg_pressure, reg_use_list, reg_set_list, and\n\treg_pressure_excess_cost_change.\n\t(struct deps): New member implicit_sets.\n\t(pressure_p): New variable.\n\t(COVER_CLASS_BITS, INCREASE_BITS): New macros.\n\t(struct reg_pressure_data, struct reg_use_data): New.\n\t(INSN_REG_WEIGHT): Remove.\n\t(INSN_REG_PRESSURE, INSN_MAX_REG_PRESSURE, INSN_REG_USE_LIST,\n\tINSN_REG_SET_LIST, INSN_REG_PRESSURE_EXCESS_COST_CHANGE): New\n\tmacros.\n\t(sched_init_region_reg_pressure_info,\n\tsched_setup_bb_reg_pressure_info): New prototypes.\n\t\n        * reginfo.c (struct reg_pref): New member coverclass.\n\t(reg_cover_class): New function.\n\t(reginfo_init, pass_reginfo_init): Move after free_reg_info.\n\t(reg_info_size): New variable.\n\t(allocate_reg_info): Make static.  Setup reg_info_size.\n\t(resize_reg_info): Use reg_info_size.  Return flag of resizing.\n\t(setup_reg_classes): Add a new parameter.  Setup cover class too.\n\n\t* Makefile.in (reload.o, haifa-sched.o, sched-deps.o): Add ira.h to the\n\tdependencies.\n\n\t* sched-rgn.c (deps_join): Set up implicit_sets.\n\t(schedule_region): Set up region and basic blocks pressure\n\trelative info.\n\t\n\t* passes.c (init_optimization_passes): Move\n\tpass_subregs_of_mode_init before pass_sched.\n\nFrom-SVN: r151348", "tree": {"sha": "4fff239f690be40be173f6b04a6883338c271d49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fff239f690be40be173f6b04a6883338c271d49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8563a3ba77cb002cf22d1c74715340a96fb404e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8563a3ba77cb002cf22d1c74715340a96fb404e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8563a3ba77cb002cf22d1c74715340a96fb404e"}], "stats": {"total": 2344, "additions": 1819, "deletions": 525}, "files": [{"sha": "ba50cb0e1024d60f3b565f08e46640cb9060b4e6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -1,3 +1,158 @@\n+2009-09-02  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* doc/invoke.texi (-fsched-pressure): Document it.\n+\t(-fsched-reg-pressure-heuristic): Remove it.\n+\t\n+\t* reload.c (ira.h): Include.\n+\t(find_reloads): Add choosing reload on number of small spilled\n+\tclasses.\n+\t\n+\t* haifa-sched.c (ira.h): Include.\n+\t(sched_pressure_p, sched_regno_cover_class, curr_reg_pressure,\n+\tsaved_reg_pressure, curr_reg_live, saved_reg_live,\n+\tregion_ref_regs): New variables.\n+\t(sched_init_region_reg_pressure_info, mark_regno_birth_or_death,\n+\tinitiate_reg_pressure_info, setup_ref_regs,\n+\tinitiate_bb_reg_pressure_info, save_reg_pressure,\n+\trestore_reg_pressure, dying_use_p, print_curr_reg_pressure): New\n+\tfunctions.\n+\t(setup_insn_reg_pressure_info): New function.\n+\t(rank_for_schedule): Add pressure checking and insn issue time.\n+\tRemove comparison of insn reg weights.\n+\t(ready_sort): Set insn reg pressure info.\n+\t(update_register_pressure, setup_insn_max_reg_pressure,\n+\tupdate_reg_and_insn_max_reg_pressure,\n+\tsched_setup_bb_reg_pressure_info): New functions.\n+\t(schedule_insn): Add code for printing and updating reg pressure\n+\tinfo.\n+\t(find_set_reg_weight, find_insn_reg_weight): Remove.\n+\t(ok_for_early_queue_removal): Do nothing if pressure_only_p.\n+\t(debug_ready_list): Print reg pressure info.\n+\t(schedule_block): Ditto.  Check insn issue time.\n+\t(sched_init): Set up sched_pressure_p.  Allocate and set up some\n+\treg pressure related info.\n+\t(sched_finish): Free some reg pressure related info.\n+\t(fix_tick_ready): Make insn always ready if pressure_p.\n+\t(init_h_i_d): Don't call find_insn_reg_weight.\n+\t(haifa_finish_h_i_d): Free insn reg pressure info.\n+\t\n+\t* ira-int.h (ira_hard_regno_cover_class, ira_reg_class_nregs,\n+\tira_memory_move_cost, ira_class_hard_regs,\n+\tira_class_hard_regs_num, ira_no_alloc_regs,\n+\tira_available_class_regs, ira_reg_class_cover_size,\n+\tira_reg_class_cover, ira_class_translate): Move to ira.h.\n+\n+\t* ira-lives.c (single_reg_class): Check mode to find how many\n+\tregisters are necessary for operand.\n+\t(ira_implicitly_set_insn_hard_regs): New.\n+\n+\t* common.opt (fsched-pressure): New options.\n+\t(fsched-reg-pressure-heuristic): Remove.\n+\n+\t* ira.c (setup_eliminable_regset): Rename to\n+\tira_setup_eliminable_regset.  Make it external.\n+\t(expand_reg_info): Pass cover class to setup_reg_classes.\n+\t(ira): Call resize_reg_info instead of allocate_reg_info.\n+\n+\t* sched-deps.c: Include ira.h.\n+\t(implicit_reg_pending_clobbers, implicit_reg_pending_uses): New.\n+\t(create_insn_reg_use, create_insn_reg_set, setup_insn_reg_uses,\n+\treg_pressure_info, insn_use_p, mark_insn_pseudo_birth,\n+\tmark_insn_hard_regno_birth, mark_insn_reg_birth,\n+\tmark_pseudo_death, mark_hard_regno_death, mark_reg_death,\n+\tmark_insn_reg_store, mark_insn_reg_clobber,\n+\tsetup_insn_reg_pressure_info): New.\n+\t(sched_analyze_1): Update implicit_reg_pending_uses.\n+\t(sched_analyze_insn): Find implicit sets, uses, clobbers of regs.\n+\tUse them to create dependencies.  Set insn reg uses and pressure\n+\tinfo.  Process reg_pending_uses in one place.\n+\t(free_deps): Free implicit sets.\n+\t(remove_from_deps): Remove implicit sets if necessary.  Check\n+\timplicit sets when clearing reg_last_in_use.\n+\t(init_deps_global): Clear implicit_reg_pending_clobbers and\n+\timplicit_reg_pending_uses.\n+\t\n+\t* ira.h (ira_hard_regno_cover_class, ira_reg_class_nregs,\n+\tira_memory_move_cost, ira_class_hard_regs,\n+\tira_class_hard_regs_num, ira_no_alloc_regs,\n+\tira_available_class_regs, ira_reg_class_cover_size,\n+\tira_reg_class_cover, ira_class_translate): Move from ira-int.h.\n+\t(ira_setup_eliminable_regset, ira_set_pseudo_classes,\n+\tira_implicitly_set_insn_hard_regs): New prototypes.\n+\t\n+\t* ira-costs.c (pseudo_classes_defined_p, allocno_p,\n+\tcost_elements_num): New variables.\n+\t(allocno_costs, total_costs): Rename to costs and\n+\ttotal_allocno_costs.\n+\t(COSTS_OF_ALLOCNO): Rename to COSTS.\n+\t(allocno_pref): Rename to pref.\n+\t(allocno_pref_buffer): Rename to pref_buffer.\n+\t(common_classes): Rename to regno_cover_class.\n+\t(COST_INDEX): New.\n+\t(record_reg_classes): Set allocno attributes only if allocno_p.\n+\t(record_address_regs): Ditto.  Use COST_INDEX instead of\n+\tALLOCNO_NUM.\n+\t(scan_one_insn): Use COST_INDEX and COSTS instead of ALLOCNO_NUM\n+\tand COSTS_OF_ALLOCNO.\n+\t(print_costs): Rename to print_allocno_costs.\n+\t(print_pseudo_costs): New.\n+\t(process_bb_node_for_costs): Split into 2 functions with new\n+\tfunction process_bb_for_costs.  Pass BB to process_bb_for_costs.\n+\t(find_allocno_class_costs): Rename to find_costs_and_classes.  Add\n+\tnew parameter dump_file.  Use cost_elements_num instead of\n+\tira_allocnos_num.  Make one iteration if preferred classes were\n+\talready calculated for scheduler.  Make 2 versions of code\n+\tdepending on allocno_p.\n+\t(setup_allocno_cover_class_and_costs): Check allocno_p.  Use\n+\tregno_cover_class and COSTS instead of common_classes and\n+\tCOSTS_OF_ALLOCNO.\n+\t(init_costs, finish_costs): New.\n+\t(ira_costs): Set up allocno_p and cost_elements_num.  Call\n+\tinit_costs and finish_costs.\n+\t(ira_set_pseudo_classes): New.\n+\n+\t* rtl.h (allocate_reg_info): Remove.\n+\t(resize_reg_info): Change return type.\n+\t(reg_cover_class): New.\n+\t(setup_reg_classes): Add new parameter.\n+\t\n+\t* sched-int.h (struct deps_reg): New member implicit_sets.\n+\t(sched_pressure_p, sched_regno_cover_class): New external\n+\tdefinitions.\n+\t(INCREASE_BITS): New macro.\n+\t(struct reg_pressure_data, struct reg_use_data): New.\n+\t(struct _haifa_insn_data): Remove reg_weight.  Add members\n+\treg_pressure, reg_use_list, reg_set_list, and\n+\treg_pressure_excess_cost_change.\n+\t(struct deps): New member implicit_sets.\n+\t(pressure_p): New variable.\n+\t(COVER_CLASS_BITS, INCREASE_BITS): New macros.\n+\t(struct reg_pressure_data, struct reg_use_data): New.\n+\t(INSN_REG_WEIGHT): Remove.\n+\t(INSN_REG_PRESSURE, INSN_MAX_REG_PRESSURE, INSN_REG_USE_LIST,\n+\tINSN_REG_SET_LIST, INSN_REG_PRESSURE_EXCESS_COST_CHANGE): New\n+\tmacros.\n+\t(sched_init_region_reg_pressure_info,\n+\tsched_setup_bb_reg_pressure_info): New prototypes.\n+\t\n+        * reginfo.c (struct reg_pref): New member coverclass.\n+\t(reg_cover_class): New function.\n+\t(reginfo_init, pass_reginfo_init): Move after free_reg_info.\n+\t(reg_info_size): New variable.\n+\t(allocate_reg_info): Make static.  Setup reg_info_size.\n+\t(resize_reg_info): Use reg_info_size.  Return flag of resizing.\n+\t(setup_reg_classes): Add a new parameter.  Setup cover class too.\n+\n+\t* Makefile.in (reload.o, haifa-sched.o, sched-deps.o): Add ira.h to the\n+\tdependencies.\n+\n+\t* sched-rgn.c (deps_join): Set up implicit_sets.\n+\t(schedule_region): Set up region and basic blocks pressure\n+\trelative info.\n+\t\n+\t* passes.c (init_optimization_passes): Move\n+\tpass_subregs_of_mode_init before pass_sched.\n+\t\n 2009-09-02  Martin Jambor  <mjambor@suse.cz>\n \n \t* tree-sra.c (struct access): New field grp_hint."}, {"sha": "78499bead89f35bd725dafff61d63ebb4e6e050e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -3030,7 +3030,7 @@ vec.o : vec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h vec.h $(GGC_H) \\\n reload.o : reload.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) output.h $(EXPR_H) $(OPTABS_H) reload.h $(RECOG_H) \\\n    hard-reg-set.h insn-config.h $(REGS_H) $(FUNCTION_H) real.h $(TOPLEV_H) \\\n-   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H) $(DF_H)\n+   addresses.h $(TM_P_H) $(PARAMS_H) $(TARGET_H) $(REAL_H) $(DF_H) ira.h\n reload1.o : reload1.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(EXPR_H) $(OPTABS_H) reload.h $(REGS_H) hard-reg-set.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(RECOG_H) output.h $(FUNCTION_H) $(TOPLEV_H) $(TM_P_H) \\\n@@ -3126,11 +3126,11 @@ modulo-sched.o : modulo-sched.c $(DDG_H) $(CONFIG_H) $(CONFIG_H) $(SYSTEM_H) \\\n haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(FUNCTION_H) \\\n    $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) $(TARGET_H) output.h \\\n-   $(PARAMS_H) $(DBGCNT_H)\n+   $(PARAMS_H) $(DBGCNT_H) ira.h\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) cselib.h \\\n-   $(PARAMS_H) $(TM_P_H)\n+   ira.h $(PARAMS_H) $(TM_P_H) ira.h\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\"}, {"sha": "5426aed11391288fe114a5eae1f927d05ae33c2f", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -982,6 +982,10 @@ fsched-interblock\n Common Report Var(flag_schedule_interblock) Init(1) Optimization\n Enable scheduling across basic blocks\n \n+fsched-pressure\n+Common Report Var(flag_sched_pressure) Init(0) Optimization\n+Enable register pressure sensitive insn scheduling\n+\n fsched-spec\n Common Report Var(flag_schedule_speculative) Init(1) Optimization\n Allow speculative motion of non-loads\n@@ -1071,10 +1075,6 @@ fsched-spec-insn-heuristic\n Common Report Var(flag_sched_spec_insn_heuristic) Init(1) Optimization\n Enable the speculative instruction heuristic in the scheduler\n \n-fsched-reg-pressure-heuristic\n-Common Report Var(flag_sched_reg_pressure_heuristic) Init(1) Optimization\n-Enable the register pressure heuristic in the scheduler\n-\n fsched-rank-heuristic\n Common Report Var(flag_sched_rank_heuristic) Init(1) Optimization\n Enable the rank heuristic in the scheduler"}, {"sha": "6c9da5ebd25e6fb834c093bbd919d4e02e93636c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -365,12 +365,12 @@ Objective-C and Objective-C++ Dialects}.\n -freorder-blocks-and-partition -freorder-functions @gol\n -frerun-cse-after-loop -freschedule-modulo-scheduled-loops @gol\n -frounding-math -fsched2-use-superblocks @gol\n--fsched2-use-traces -fsched-spec-load -fsched-spec-load-dangerous @gol\n+-fsched2-use-traces -fsched-pressure @gol\n+-fsched-spec-load -fsched-spec-load-dangerous @gol\n -fsched-stalled-insns-dep[=@var{n}] -fsched-stalled-insns[=@var{n}] @gol\n -fsched-group-heuristic -fsched-critical-path-heuristic @gol\n--fsched-spec-insn-heuristic -fsched-reg-pressure-heuristic @gol\n--fsched-rank-heuristic -fsched-last-insn-heuristic @gol\n--fsched-dep-count-heuristic @gol\n+-fsched-spec-insn-heuristic -fsched-rank-heuristic @gol\n+-fsched-last-insn-heuristic -fsched-dep-count-heuristic @gol\n -fschedule-insns -fschedule-insns2 -fsection-anchors @gol\n -fselective-scheduling -fselective-scheduling2 @gol\n -fsel-sched-pipelining -fsel-sched-pipelining-outer-loops @gol\n@@ -6226,6 +6226,16 @@ Don't allow speculative motion of non-load instructions.  This is normally\n enabled by default when scheduling before register allocation, i.e.@:\n with @option{-fschedule-insns} or at @option{-O2} or higher.\n \n+@item -fsched-pressure\n+@opindex fsched-pressure\n+Enable register pressure sensitive insn scheduling before the register\n+allocation.  This only makes sense when scheduling before register\n+allocation is enabled, i.e.@: with @option{-fschedule-insns} or at\n+@option{-O2} or higher.  Usage of this option can improve the\n+generated code and decrease its size by preventing register pressure\n+increase above the number of available hard registers and as a\n+consequence register spills in the register allocation.\n+\n @item -fsched-spec-load\n @opindex fsched-spec-load\n Allow speculative motion of some load instructions.  This only makes\n@@ -6294,13 +6304,6 @@ This is enabled by default when scheduling is enabled, i.e.@:\n with @option{-fschedule-insns} or @option{-fschedule-insns2} \n or at @option{-O2} or higher.\n \n-@item -fsched-reg-pressure-heuristic\n-@opindex fsched-reg-pressure-heuristic\n-Enable the register pressure heuristic in the scheduler.  This heuristic\n-favors the instruction with smaller contribution to register pressure.  \n-This only makes sense when scheduling before register allocation, i.e.@: \n-with @option{-fschedule-insns} or at @option{-O2} or higher.\n-\n @item -fsched-rank-heuristic\n @opindex fsched-rank-heuristic\n Enable the rank heuristic in the scheduler.  This heuristic favors "}, {"sha": "dc0791f6f2fd234f876a70fa3cdc2fa81be6a54b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 459, "deletions": 78, "changes": 537, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -147,6 +147,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n #include \"dbgcnt.h\"\n #include \"cfgloop.h\"\n+#include \"ira.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -507,8 +508,6 @@ static int rank_for_schedule (const void *, const void *);\n static void swap_sort (rtx *, int);\n static void queue_insn (rtx, int);\n static int schedule_insn (rtx);\n-static int find_set_reg_weight (const_rtx);\n-static void find_insn_reg_weight (const_rtx);\n static void adjust_priority (rtx);\n static void advance_one_cycle (void);\n static void extend_h_i_d (void);\n@@ -588,6 +587,210 @@ schedule_insns (void)\n }\n #else\n \n+/* Do register pressure sensitive insn scheduling if the flag is set\n+   up.  */\n+bool sched_pressure_p;\n+\n+/* Map regno -> its cover class.  The map defined only when\n+   SCHED_PRESSURE_P is true.  */\n+enum reg_class *sched_regno_cover_class;\n+\n+/* The current register pressure.  Only elements corresponding cover\n+   classes are defined.  */\n+static int curr_reg_pressure[N_REG_CLASSES];\n+\n+/* Saved value of the previous array.  */\n+static int saved_reg_pressure[N_REG_CLASSES];\n+\n+/* Register living at given scheduling point.  */\n+static bitmap curr_reg_live;\n+\n+/* Saved value of the previous array.  */\n+static bitmap saved_reg_live;\n+\n+/* Registers mentioned in the current region.  */\n+static bitmap region_ref_regs;\n+\n+/* Initiate register pressure relative info for scheduling the current\n+   region.  Currently it is only clearing register mentioned in the\n+   current region.  */\n+void\n+sched_init_region_reg_pressure_info (void)\n+{\n+  bitmap_clear (region_ref_regs);\n+}\n+\n+/* Update current register pressure related info after birth (if\n+   BIRTH_P) or death of register REGNO.  */\n+static void\n+mark_regno_birth_or_death (int regno, bool birth_p)\n+{\n+  enum reg_class cover_class;\n+\n+  cover_class = sched_regno_cover_class[regno];\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    {\n+      if (cover_class != NO_REGS)\n+\t{\n+\t  if (birth_p)\n+\t    {\n+\t      bitmap_set_bit (curr_reg_live, regno);\n+\t      curr_reg_pressure[cover_class]\n+\t\t+= ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n+\t    }\n+\t  else\n+\t    {\n+\t      bitmap_clear_bit (curr_reg_live, regno);\n+\t      curr_reg_pressure[cover_class]\n+\t\t-= ira_reg_class_nregs[cover_class][PSEUDO_REGNO_MODE (regno)];\n+\t    }\n+\t}\n+    }\n+  else if (cover_class != NO_REGS\n+\t   && ! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n+    {\n+      if (birth_p)\n+\t{\n+\t  bitmap_set_bit (curr_reg_live, regno);\n+\t  curr_reg_pressure[cover_class]++;\n+\t}\n+      else\n+\t{\n+\t  bitmap_clear_bit (curr_reg_live, regno);\n+\t  curr_reg_pressure[cover_class]--;\n+\t}\n+    }\n+}\n+\n+/* Initiate current register pressure related info from living\n+   registers given by LIVE.  */\n+static void\n+initiate_reg_pressure_info (bitmap live)\n+{\n+  int i;\n+  unsigned int j;\n+  bitmap_iterator bi;\n+\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    curr_reg_pressure[ira_reg_class_cover[i]] = 0;\n+  bitmap_clear (curr_reg_live);\n+  EXECUTE_IF_SET_IN_BITMAP (live, 0, j, bi)\n+    if (current_nr_blocks == 1 || bitmap_bit_p (region_ref_regs, j))\n+      mark_regno_birth_or_death (j, true);\n+}\n+\n+/* Mark registers in X as mentioned in the current region.  */\n+static void\n+setup_ref_regs (rtx x)\n+{\n+  int i, j, regno;\n+  const RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n+\n+  if (REG_P (x))\n+    {\n+      regno = REGNO (x);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\tbitmap_set_bit (region_ref_regs, REGNO (x));\n+      else\n+\tfor (i = hard_regno_nregs[regno][GET_MODE (x)] - 1; i >= 0; i--)\n+\t  bitmap_set_bit (region_ref_regs, regno + i);\n+      return;\n+    }\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    if (fmt[i] == 'e')\n+      setup_ref_regs (XEXP (x, i));\n+    else if (fmt[i] == 'E')\n+      {\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  setup_ref_regs (XVECEXP (x, i, j));\n+      }\n+}\n+\n+/* Initiate current register pressure related info at the start of\n+   basic block BB.  */\n+static void\n+initiate_bb_reg_pressure_info (basic_block bb)\n+{\n+  unsigned int i;\n+  rtx insn;\n+\n+  if (current_nr_blocks > 1)\n+    FOR_BB_INSNS (bb, insn)\n+      if (INSN_P (insn))\n+\tsetup_ref_regs (PATTERN (insn));\n+  initiate_reg_pressure_info (df_get_live_in (bb));\n+#ifdef EH_RETURN_DATA_REGNO\n+  if (bb_has_eh_pred (bb))\n+    for (i = 0; ; ++i)\n+      {\n+\tunsigned int regno = EH_RETURN_DATA_REGNO (i);\n+\t\n+\tif (regno == INVALID_REGNUM)\n+\t  break;\n+\tif (! bitmap_bit_p (df_get_live_in (bb), regno))\n+\t  mark_regno_birth_or_death (regno, true);\n+      }\n+#endif\n+}\n+\n+/* Save current register pressure related info.  */\n+static void\n+save_reg_pressure (void)\n+{\n+  int i;\n+  \n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    saved_reg_pressure[ira_reg_class_cover[i]]\n+      = curr_reg_pressure[ira_reg_class_cover[i]];\n+  bitmap_copy (saved_reg_live, curr_reg_live);\n+}\n+\n+/* Restore saved register pressure related info.  */\n+static void\n+restore_reg_pressure (void)\n+{\n+  int i;\n+  \n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    curr_reg_pressure[ira_reg_class_cover[i]]\n+      = saved_reg_pressure[ira_reg_class_cover[i]];\n+  bitmap_copy (curr_reg_live, saved_reg_live);\n+}\n+\n+/* Return TRUE if the register is dying after its USE.  */\n+static bool\n+dying_use_p (struct reg_use_data *use)\n+{\n+  struct reg_use_data *next;\n+\n+  for (next = use->next_regno_use; next != use; next = next->next_regno_use)\n+    if (QUEUE_INDEX (next->insn) != QUEUE_SCHEDULED)\n+      return false;\n+  return true;\n+}\n+\n+/* Print info about the current register pressure and its excess for\n+   each cover class.  */\n+static void\n+print_curr_reg_pressure (void)\n+{\n+  int i;\n+  enum reg_class cl;\n+\n+  fprintf (sched_dump, \";;\\t\");\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cl = ira_reg_class_cover[i];\n+      gcc_assert (curr_reg_pressure[cl] >= 0);\n+      fprintf (sched_dump, \"  %s:%d(%d)\", reg_class_names[cl],\n+\t       curr_reg_pressure[cl],\n+\t       curr_reg_pressure[cl] - ira_available_class_regs[cl]);\n+    }\n+  fprintf (sched_dump, \"\\n\");\n+}\n+\n /* Pointer to the last instruction scheduled.  Used by rank_for_schedule,\n    so that insns independent of the last scheduled insn will be preferred\n    over dependent instructions.  */\n@@ -657,7 +860,8 @@ dep_cost_1 (dep_t link, dw_t dw)\n \n   /* A USE insn should never require the value used to be computed.\n      This allows the computation of a function's result and parameter\n-     values to overlap the return and call.  */\n+     values to overlap the return and call.  We don't care about the\n+     the dependence cost when only decreasing register pressure.  */\n   if (recog_memoized (used) < 0)\n     {\n       cost = 0;\n@@ -686,10 +890,8 @@ dep_cost_1 (dep_t link, dw_t dw)\n \t\n \n       if (targetm.sched.adjust_cost_2)\n-\t{\n-\t  cost = targetm.sched.adjust_cost_2 (used, (int) dep_type, insn, cost,\n-\t\t\t\t\t      dw);\n-\t}\n+\tcost = targetm.sched.adjust_cost_2 (used, (int) dep_type, insn, cost,\n+\t\t\t\t\t    dw);\n       else if (targetm.sched.adjust_cost != NULL)\n \t{\n \t  /* This variable is used for backward compatibility with the\n@@ -906,6 +1108,53 @@ do { if ((N_READY) == 2)\t\t\t\t             \\\n          qsort (READY, N_READY, sizeof (rtx), rank_for_schedule); }  \\\n while (0)\n \n+/* Setup info about the current register pressure impact of scheduling\n+   INSN at the current scheduling point.  */\n+static void\n+setup_insn_reg_pressure_info (rtx insn)\n+{\n+  int i, change, before, after, hard_regno;\n+  int excess_cost_change;\n+  enum machine_mode mode;\n+  enum reg_class cl;\n+  struct reg_pressure_data *pressure_info;\n+  int *max_reg_pressure;\n+  struct reg_use_data *use;\n+  static int death[N_REG_CLASSES];\n+\n+  excess_cost_change = 0;\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    death[ira_reg_class_cover[i]] = 0;\n+  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n+    if (dying_use_p (use))\n+      {\n+\tcl = sched_regno_cover_class[use->regno];\n+\tif (use->regno < FIRST_PSEUDO_REGISTER)\n+\t  death[cl]++;\n+\telse\n+\t  death[cl] += ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (use->regno)];\n+      }\n+  pressure_info = INSN_REG_PRESSURE (insn);\n+  max_reg_pressure = INSN_MAX_REG_PRESSURE (insn);\n+  gcc_assert (pressure_info != NULL && max_reg_pressure != NULL);\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cl = ira_reg_class_cover[i];\n+      gcc_assert (curr_reg_pressure[cl] >= 0);\n+      change = (int) pressure_info[i].set_increase - death[cl];\n+      before = MAX (0, max_reg_pressure[i] - ira_available_class_regs[cl]);\n+      after = MAX (0, max_reg_pressure[i] + change\n+\t\t   - ira_available_class_regs[cl]);\n+      hard_regno = ira_class_hard_regs[cl][0];\n+      gcc_assert (hard_regno >= 0);\n+      mode = reg_raw_mode[hard_regno];\n+      excess_cost_change += ((after - before)\n+\t\t\t     * (ira_memory_move_cost[mode][cl][0]\n+\t\t\t\t+ ira_memory_move_cost[mode][cl][1]));\n+    }\n+  INSN_REG_PRESSURE_EXCESS_COST_CHANGE (insn) = excess_cost_change;\n+}\n+\n /* Returns a positive value if x is preferred; returns a negative value if\n    y is preferred.  Should never return 0, since that will make the sort\n    unstable.  */\n@@ -917,7 +1166,7 @@ rank_for_schedule (const void *x, const void *y)\n   rtx tmp2 = *(const rtx *) x;\n   rtx last;\n   int tmp_class, tmp2_class;\n-  int val, priority_val, weight_val, info_val;\n+  int val, priority_val, info_val;\n \n   if (MAY_HAVE_DEBUG_INSNS)\n     {\n@@ -936,12 +1185,38 @@ rank_for_schedule (const void *x, const void *y)\n   /* Make sure that priority of TMP and TMP2 are initialized.  */\n   gcc_assert (INSN_PRIORITY_KNOWN (tmp) && INSN_PRIORITY_KNOWN (tmp2));\n \n+  if (sched_pressure_p)\n+    {\n+      int diff;\n+\n+      /* Prefer insn whose scheduling results in the smallest register\n+\t pressure excess.  */\n+      if ((diff = (INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp)\n+\t\t   + (INSN_TICK (tmp) > clock_var\n+\t\t      ? INSN_TICK (tmp) - clock_var : 0)\n+\t\t   - INSN_REG_PRESSURE_EXCESS_COST_CHANGE (tmp2)\n+\t\t   - (INSN_TICK (tmp2) > clock_var\n+\t\t      ? INSN_TICK (tmp2) - clock_var : 0))) != 0)\n+\treturn diff;\n+    }\n+\n+\n+  if (sched_pressure_p\n+      && (INSN_TICK (tmp2) > clock_var || INSN_TICK (tmp) > clock_var))\n+    {\n+      if (INSN_TICK (tmp) <= clock_var)\n+\treturn -1;\n+      else if (INSN_TICK (tmp2) <= clock_var)\n+\treturn 1;\n+      else\n+\treturn INSN_TICK (tmp) - INSN_TICK (tmp2);\n+    }\n   /* Prefer insn with higher priority.  */\n   priority_val = INSN_PRIORITY (tmp2) - INSN_PRIORITY (tmp);\n \n   if (flag_sched_critical_path_heuristic && priority_val)\n     return priority_val;\n-\n+    \n   /* Prefer speculative insn with greater dependencies weakness.  */\n   if (flag_sched_spec_insn_heuristic && spec_info)\n     {\n@@ -966,11 +1241,6 @@ rank_for_schedule (const void *x, const void *y)\n \treturn dw;\n     }\n \n-  /* Prefer an insn with smaller contribution to registers-pressure.  */\n-  if (flag_sched_reg_pressure_heuristic && !reload_completed &&\n-      (weight_val = INSN_REG_WEIGHT (tmp) - INSN_REG_WEIGHT (tmp2)))\n-    return weight_val;\n-\n   info_val = (*current_sched_info->rank) (tmp, tmp2);\n   if(flag_sched_rank_heuristic && info_val)\n     return info_val;\n@@ -1222,7 +1492,14 @@ ready_remove_insn (rtx insn)\n void\n ready_sort (struct ready_list *ready)\n {\n+  int i;\n   rtx *first = ready_lastpos (ready);\n+\n+  if (sched_pressure_p)\n+    {\n+      for (i = 0; i < ready->n_ready; i++)\n+\tsetup_insn_reg_pressure_info (first[i]);\n+    }\n   SCHED_SORT (first, ready->n_ready);\n }\n \n@@ -1278,6 +1555,93 @@ advance_one_cycle (void)\n /* Clock at which the previous instruction was issued.  */\n static int last_clock_var;\n \n+/* Update register pressure after scheduling INSN.  */\n+static void\n+update_register_pressure (rtx insn)\n+{\n+  struct reg_use_data *use;\n+  struct reg_set_data *set;\n+\n+  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n+    if (dying_use_p (use) && bitmap_bit_p (curr_reg_live, use->regno))\n+      mark_regno_birth_or_death (use->regno, false);\n+  for (set = INSN_REG_SET_LIST (insn); set != NULL; set = set->next_insn_set)\n+    mark_regno_birth_or_death (set->regno, true);\n+}\n+\n+/* Set up or update (if UPDATE_P) max register pressure (see its\n+   meaning in sched-int.h::_haifa_insn_data) for all current BB insns\n+   after insn AFTER.  */\n+static void\n+setup_insn_max_reg_pressure (rtx after, bool update_p)\n+{\n+  int i, p;\n+  bool eq_p;\n+  rtx insn;\n+  static int max_reg_pressure[N_REG_CLASSES];\n+\n+  save_reg_pressure ();\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    max_reg_pressure[ira_reg_class_cover[i]]\n+      = curr_reg_pressure[ira_reg_class_cover[i]];\n+  for (insn = NEXT_INSN (after);\n+       insn != NULL_RTX && BLOCK_FOR_INSN (insn) == BLOCK_FOR_INSN (after);\n+       insn = NEXT_INSN (insn))\n+    if (NONDEBUG_INSN_P (insn))\n+      {\n+\teq_p = true;\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n+\t  {\n+\t    p = max_reg_pressure[ira_reg_class_cover[i]];\n+\t    if (INSN_MAX_REG_PRESSURE (insn)[i] != p)\n+\t      {\n+\t\teq_p = false;\n+\t\tINSN_MAX_REG_PRESSURE (insn)[i]\n+\t\t  = max_reg_pressure[ira_reg_class_cover[i]];\n+\t      }\n+\t  }\n+\tif (update_p && eq_p)\n+\t  break;\n+\tupdate_register_pressure (insn);\n+\tfor (i = 0; i < ira_reg_class_cover_size; i++)\n+\t  if (max_reg_pressure[ira_reg_class_cover[i]]\n+\t      < curr_reg_pressure[ira_reg_class_cover[i]])\n+\t    max_reg_pressure[ira_reg_class_cover[i]]\n+\t      = curr_reg_pressure[ira_reg_class_cover[i]];\n+      }\n+  restore_reg_pressure ();\n+}\n+\n+/* Update the current register pressure after scheduling INSN.  Update\n+   also max register pressure for unscheduled insns of the current\n+   BB.  */\n+static void\n+update_reg_and_insn_max_reg_pressure (rtx insn)\n+{\n+  int i;\n+  int before[N_REG_CLASSES];\n+\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    before[i] = curr_reg_pressure[ira_reg_class_cover[i]];\n+  update_register_pressure (insn);\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    if (curr_reg_pressure[ira_reg_class_cover[i]] != before[i])\n+      break;\n+  if (i < ira_reg_class_cover_size)\n+    setup_insn_max_reg_pressure (insn, true);\n+}\n+\n+/* Set up register pressure at the beginning of basic block BB whose\n+   insns starting after insn AFTER.  Set up also max register pressure\n+   for all insns of the basic block.  */\n+void\n+sched_setup_bb_reg_pressure_info (basic_block bb, rtx after)\n+{\n+  gcc_assert (sched_pressure_p);\n+  initiate_bb_reg_pressure_info (bb);\n+  setup_insn_max_reg_pressure (after, false);\n+}\n+\n /* INSN is the \"currently executing insn\".  Launch each insn which was\n    waiting on INSN.  READY is the ready list which contains the insns\n    that are ready to fire.  CLOCK is the current cycle.  The function\n@@ -1289,10 +1653,12 @@ schedule_insn (rtx insn)\n {\n   sd_iterator_def sd_it;\n   dep_t dep;\n+  int i;\n   int advance = 0;\n \n   if (sched_verbose >= 1)\n     {\n+      struct reg_pressure_data *pressure_info;\n       char buf[2048];\n \n       print_insn (buf, insn, 0);\n@@ -1303,9 +1669,21 @@ schedule_insn (rtx insn)\n \tfprintf (sched_dump, \"nothing\");\n       else\n \tprint_reservation (sched_dump, insn);\n+      pressure_info = INSN_REG_PRESSURE (insn);\n+      if (pressure_info != NULL)\n+\t{\n+\t  fputc (':', sched_dump);\n+\t  for (i = 0; i < ira_reg_class_cover_size; i++)\n+\t    fprintf (sched_dump, \"%s%+d(%d)\",\n+\t\t     reg_class_names[ira_reg_class_cover[i]],\n+\t\t     pressure_info[i].set_increase, pressure_info[i].change);\n+\t}\n       fputc ('\\n', sched_dump);\n     }\n \n+  if (sched_pressure_p)\n+    update_reg_and_insn_max_reg_pressure (insn);\n+\n   /* Scheduling instruction should have all its dependencies resolved and\n      should have been removed from the ready list.  */\n   gcc_assert (sd_lists_empty_p (insn, SD_LIST_BACK));\n@@ -1614,66 +1992,6 @@ restore_other_notes (rtx head, basic_block head_bb)\n   return head;\n }\n \n-/* Functions for computation of registers live/usage info.  */\n-\n-/* This function looks for a new register being defined.\n-   If the destination register is already used by the source,\n-   a new register is not needed.  */\n-static int\n-find_set_reg_weight (const_rtx x)\n-{\n-  if (GET_CODE (x) == CLOBBER\n-      && register_operand (SET_DEST (x), VOIDmode))\n-    return 1;\n-  if (GET_CODE (x) == SET\n-      && register_operand (SET_DEST (x), VOIDmode))\n-    {\n-      if (REG_P (SET_DEST (x)))\n-\t{\n-\t  if (!reg_mentioned_p (SET_DEST (x), SET_SRC (x)))\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Calculate INSN_REG_WEIGHT for INSN.  */\n-static void\n-find_insn_reg_weight (const_rtx insn)\n-{\n-  int reg_weight = 0;\n-  rtx x;\n-  \n-  /* Handle register life information.  */\n-  if (! INSN_P (insn))\n-    return;\n-  \n-  /* Increment weight for each register born here.  */\n-  x = PATTERN (insn);\n-  reg_weight += find_set_reg_weight (x);\n-  if (GET_CODE (x) == PARALLEL)\n-    {\n-      int j;\n-      for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n-\t{\n-\t  x = XVECEXP (PATTERN (insn), 0, j);\n-\t  reg_weight += find_set_reg_weight (x);\n-\t}\n-    }\n-  /* Decrement weight for each register that dies here.  */\n-  for (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n-    {\n-      if (REG_NOTE_KIND (x) == REG_DEAD\n-\t  || REG_NOTE_KIND (x) == REG_UNUSED)\n-\treg_weight--;\n-    }\n-  \n-  INSN_REG_WEIGHT (insn) = reg_weight;\n-}\n-\n /* Move insns that became ready to fire from queue to ready list.  */\n \n static void\n@@ -1943,7 +2261,18 @@ debug_ready_list (struct ready_list *ready)\n \n   p = ready_lastpos (ready);\n   for (i = 0; i < ready->n_ready; i++)\n-    fprintf (sched_dump, \"  %s\", (*current_sched_info->print_insn) (p[i], 0));\n+    {\n+      fprintf (sched_dump, \"  %s:%d\",\n+\t       (*current_sched_info->print_insn) (p[i], 0),\n+\t       INSN_LUID (p[i]));\n+      if (sched_pressure_p)\n+\tfprintf (sched_dump, \"(cost=%d\",\n+\t\t INSN_REG_PRESSURE_EXCESS_COST_CHANGE (p[i]));\n+      if (INSN_TICK (p[i]) > clock_var)\n+\tfprintf (sched_dump, \":delay=%d\", INSN_TICK (p[i]) - clock_var);\n+      if (sched_pressure_p)\n+\tfprintf (sched_dump, \")\");\n+    }\n   fprintf (sched_dump, \"\\n\");\n }\n \n@@ -2666,6 +2995,8 @@ schedule_block (basic_block *target_bb)\n \t      fprintf (sched_dump, \";;\\tReady list (t = %3d):  \",\n \t\t       clock_var);\n \t      debug_ready_list (&ready);\n+\t      if (sched_pressure_p)\n+\t\tprint_curr_reg_pressure ();\n \t    }\n \n \t  if (ready.n_ready == 0 \n@@ -2708,6 +3039,13 @@ schedule_block (basic_block *target_bb)\n \t  else\n \t    insn = ready_remove_first (&ready);\n \n+\t  if (sched_pressure_p && INSN_TICK (insn) > clock_var)\n+\t    {\n+\t      ready_add (&ready, insn, true);\n+\t      advance = 1;\n+\t      break;\n+\t    }\n+\n \t  if (targetm.sched.dfa_new_cycle\n \t      && targetm.sched.dfa_new_cycle (sched_dump, sched_verbose,\n \t\t\t\t\t      insn, last_clock_var,\n@@ -2745,6 +3083,8 @@ schedule_block (basic_block *target_bb)\n \t\t   fatal error for unrecognizable insns.  */\n \t\tcost = 0;\n \t    }\n+\t  else if (sched_pressure_p)\n+\t    cost = 0;\n \t  else\n \t    {\n \t      cost = state_transition (temp_state, insn);\n@@ -2826,7 +3166,6 @@ schedule_block (basic_block *target_bb)\n \t  else if (GET_CODE (PATTERN (insn)) != USE\n \t\t   && GET_CODE (PATTERN (insn)) != CLOBBER)\n \t    can_issue_more--;\n-\n \t  advance = schedule_insn (insn);\n \n \t  /* After issuing an asm insn we should start a new cycle.  */\n@@ -3033,6 +3372,11 @@ sched_init (void)\n   flag_schedule_speculative_load = 0;\n #endif\n \n+  sched_pressure_p = (flag_sched_pressure && ! reload_completed\n+\t\t      && common_sched_info->sched_pass_id == SCHED_RGN_PASS);\n+  if (sched_pressure_p)\n+    ira_setup_eliminable_regset ();\n+\n   /* Initialize SPEC_INFO.  */\n   if (targetm.sched.set_sched_flags)\n     {\n@@ -3108,6 +3452,23 @@ sched_init (void)\n     targetm.sched.md_init_global (sched_dump, sched_verbose,\n \t\t\t\t  get_max_uid () + 1);\n \n+  if (sched_pressure_p)\n+    {\n+      int i, max_regno = max_reg_num ();\n+\n+      ira_set_pseudo_classes (sched_verbose ? sched_dump : NULL);\n+      sched_regno_cover_class\n+\t= (enum reg_class *) xmalloc (max_regno * sizeof (enum reg_class));\n+      for (i = 0; i < max_regno; i++)\n+\tsched_regno_cover_class[i]\n+\t  = (i < FIRST_PSEUDO_REGISTER\n+\t     ? ira_class_translate[REGNO_REG_CLASS (i)]\n+\t     : reg_cover_class (i));\n+      curr_reg_live = BITMAP_ALLOC (NULL);\n+      saved_reg_live = BITMAP_ALLOC (NULL);\n+      region_ref_regs = BITMAP_ALLOC (NULL);\n+    }\n+  \n   curr_state = xmalloc (dfa_state_size);\n }\n \n@@ -3205,6 +3566,13 @@ void\n sched_finish (void)\n {\n   haifa_finish_h_i_d ();\n+  if (sched_pressure_p)\n+    {\n+      free (sched_regno_cover_class);\n+      BITMAP_FREE (region_ref_regs);\n+      BITMAP_FREE (saved_reg_live);\n+      BITMAP_FREE (curr_reg_live);\n+    }\n   free (curr_state);\n \n   if (targetm.sched.md_finish_global)\n@@ -3514,7 +3882,7 @@ fix_tick_ready (rtx next)\n   INSN_TICK (next) = tick;\n \n   delay = tick - clock_var;\n-  if (delay <= 0)\n+  if (delay <= 0 || sched_pressure_p)\n     delay = QUEUE_READY;\n \n   change_queue_index (next, delay);\n@@ -5091,7 +5459,6 @@ init_h_i_d (rtx insn)\n   if (INSN_LUID (insn) > 0)\n     {\n       INSN_COST (insn) = -1;\n-      find_insn_reg_weight (insn);\n       QUEUE_INDEX (insn) = QUEUE_NOWHERE;\n       INSN_TICK (insn) = INVALID_TICK;\n       INTER_TICK (insn) = INVALID_TICK;\n@@ -5118,6 +5485,20 @@ haifa_init_h_i_d (bb_vec_t bbs, basic_block bb, insn_vec_t insns, rtx insn)\n void\n haifa_finish_h_i_d (void)\n {\n+  int i;\n+  haifa_insn_data_t data;\n+  struct reg_use_data *use, *next;\n+\n+  for (i = 0; VEC_iterate (haifa_insn_data_def, h_i_d, i, data); i++)\n+    {\n+      if (data->reg_pressure != NULL)\n+\tfree (data->reg_pressure);\n+      for (use = data->reg_use_list; use != NULL; use = next)\n+\t{\n+\t  next = use->next_insn_use;\n+\t  free (use);\n+\t}\n+    }\n   VEC_free (haifa_insn_data_def, heap, h_i_d);\n }\n "}, {"sha": "fd756f6de73ebf1f90dcd38f30ed49a71d1fe87c", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 299, "deletions": 177, "changes": 476, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -1,4 +1,4 @@\n-/* IRA hard register and memory cost calculation for allocnos.\n+/* IRA hard register and memory cost calculation for allocnos or pseudos.\n    Copyright (C) 2006, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Contributed by Vladimir Makarov <vmakarov@redhat.com>.\n@@ -38,18 +38,25 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"ira-int.h\"\n \n-/* The file contains code is similar to one in regclass but the code\n-   works on the allocno basis.  */\n+/* The flags is set up every time when we calculate pseudo register\n+   classes through function ira_set_pseudo_classes.  */\n+static bool pseudo_classes_defined_p = false;\n+\n+/* TRUE if we work with allocnos.  Otherwise we work with pseudos.  */\n+static bool allocno_p;\n+\n+/* Number of elements in arrays `in_inc_dec' and `costs'.  */\n+static int cost_elements_num;\n \n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-/* Indexed by n, is TRUE if allocno with number N is used in an\n-   auto-inc or auto-dec context.  */\n+/* Indexed by n, is TRUE if allocno or pseudo with number N is used in\n+   an auto-inc or auto-dec context.  */\n static bool *in_inc_dec;\n #endif\n \n /* The `costs' struct records the cost of using hard registers of each\n    class considered for the calculation and of using memory for each\n-   allocno.  */\n+   allocno or pseudo.  */\n struct costs\n {\n   int mem_cost;\n@@ -74,8 +81,11 @@ static struct costs *temp_costs;\n static struct costs *op_costs[MAX_RECOG_OPERANDS];\n static struct costs *this_op_costs[MAX_RECOG_OPERANDS];\n \n-/* Original and accumulated costs of each class for each allocno.  */\n-static struct costs *allocno_costs, *total_costs;\n+/* Costs of each class for each allocno or pseudo.  */\n+static struct costs *costs;\n+\n+/* Accumulated costs of each class for each allocno.  */\n+static struct costs *total_allocno_costs;\n \n /* Classes used for cost calculation.  They may be different on\n    different iterations of the cost calculations or in different\n@@ -92,21 +102,26 @@ static int cost_class_nums[N_REG_CLASSES];\n /* It is the current size of struct costs.  */\n static int struct_costs_size;\n \n-/* Return pointer to structure containing costs of allocno with given\n-   NUM in array ARR.  */\n-#define COSTS_OF_ALLOCNO(arr, num) \\\n+/* Return pointer to structure containing costs of allocno or pseudo\n+   with given NUM in array ARR.  */\n+#define COSTS(arr, num) \\\n   ((struct costs *) ((char *) (arr) + (num) * struct_costs_size))\n \n-/* Record register class preferences of each allocno.  Null value\n-   means no preferences.  It happens on the 1st iteration of the cost\n-   calculation.  */\n-static enum reg_class *allocno_pref;\n+/* Return index in COSTS when processing reg with REGNO.  */\n+#define COST_INDEX(regno) (allocno_p \t\t\t\t\t      \\\n+                           ? ALLOCNO_NUM (ira_curr_regno_allocno_map[regno])  \\\n+\t\t\t   : (int) regno)\n \n-/* Allocated buffers for allocno_pref.  */\n-static enum reg_class *allocno_pref_buffer;\n+/* Record register class preferences of each allocno or pseudo.  Null\n+   value means no preferences.  It happens on the 1st iteration of the\n+   cost calculation.  */\n+static enum reg_class *pref;\n \n-/* Record register class of each allocno with the same regno.  */\n-static enum reg_class *common_classes;\n+/* Allocated buffers for pref.  */\n+static enum reg_class *pref_buffer;\n+\n+/* Record cover register class of each allocno with the same regno.  */\n+static enum reg_class *regno_cover_class;\n \n /* Execution frequency of the current insn.  */\n static int frequency;\n@@ -189,7 +204,7 @@ static void\n record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t    enum machine_mode *modes, const char **constraints,\n \t\t    rtx insn, struct costs **op_costs,\n-\t\t    enum reg_class *allocno_pref)\n+\t\t    enum reg_class *pref)\n {\n   int alt;\n   int i, j, k;\n@@ -320,12 +335,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     were not in the appropriate class.  We could use\n \t\t     cover class here but it is less accurate\n \t\t     approximation.  */\n-\t\t  if (allocno_pref)\n+\t\t  if (pref)\n \t\t    {\n-\t\t      enum reg_class pref_class\n-\t\t\t= allocno_pref[ALLOCNO_NUM\n-\t\t\t\t       (ira_curr_regno_allocno_map\n-\t\t\t\t\t[REGNO (op)])];\n+\t\t      enum reg_class pref_class = pref[COST_INDEX (REGNO (op))];\n \n \t\t      if (pref_class == NO_REGS)\n \t\t\talt_cost\n@@ -564,12 +576,9 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t\t     were not in the appropriate class.  We could use\n \t\t     cover class here but it is less accurate\n \t\t     approximation.  */\n-\t\t  if (allocno_pref)\n+\t\t  if (pref)\n \t\t    {\n-\t\t      enum reg_class pref_class\n-\t\t\t= allocno_pref[ALLOCNO_NUM\n-\t\t\t\t       (ira_curr_regno_allocno_map\n-\t\t\t\t\t[REGNO (op)])];\n+\t\t      enum reg_class pref_class = pref[COST_INDEX (REGNO (op))];\n \n \t\t      if (pref_class == NO_REGS)\n \t\t\talt_cost\n@@ -637,17 +646,18 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n \t  }\n     }\n \n-  for (i = 0; i < n_ops; i++)\n-    {\n-      ira_allocno_t a;\n-      rtx op = ops[i];\n-\n-      if (! REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n-\tcontinue;\n-      a = ira_curr_regno_allocno_map [REGNO (op)];\n-      if (! ALLOCNO_BAD_SPILL_P (a) && insn_allows_mem[i] == 0)\n-\tALLOCNO_BAD_SPILL_P (a) = true;\n-    }\n+  if (allocno_p)\n+    for (i = 0; i < n_ops; i++)\n+      {\n+\tira_allocno_t a;\n+\trtx op = ops[i];\n+\t\n+\tif (! REG_P (op) || REGNO (op) < FIRST_PSEUDO_REGISTER)\n+\t  continue;\n+\ta = ira_curr_regno_allocno_map [REGNO (op)];\n+\tif (! ALLOCNO_BAD_SPILL_P (a) && insn_allows_mem[i] == 0)\n+\t  ALLOCNO_BAD_SPILL_P (a) = true;\n+      }\n \n   /* If this insn is a single set copying operand 1 to operand 0 and\n      one operand is an allocno with the other a hard reg or an allocno\n@@ -877,8 +887,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n       if (REG_P (XEXP (x, 0))\n \t  && REGNO (XEXP (x, 0)) >= FIRST_PSEUDO_REGISTER)\n-\tin_inc_dec[ALLOCNO_NUM (ira_curr_regno_allocno_map\n-\t\t\t\t[REGNO (XEXP (x, 0))])] = true;\n+\tin_inc_dec[COST_INDEX (REGNO (XEXP (x, 0)))] = true;\n #endif\n       record_address_regs (mode, XEXP (x, 0), 0, code, SCRATCH, 2 * scale);\n       break;\n@@ -892,10 +901,9 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \tif (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t  break;\n \n-\tALLOCNO_BAD_SPILL_P (ira_curr_regno_allocno_map[REGNO (x)]) = true;\n-\tpp = COSTS_OF_ALLOCNO (allocno_costs,\n-\t\t\t       ALLOCNO_NUM (ira_curr_regno_allocno_map\n-\t\t\t\t\t    [REGNO (x)]));\n+\tif (allocno_p)\n+\t  ALLOCNO_BAD_SPILL_P (ira_curr_regno_allocno_map[REGNO (x)]) = true;\n+\tpp = COSTS (costs, COST_INDEX (REGNO (x)));\n \tpp->mem_cost += (ira_memory_move_cost[Pmode][rclass][1] * scale) / 2;\n \tfor (k = 0; k < cost_classes_num; k++)\n \t  {\n@@ -922,8 +930,7 @@ record_address_regs (enum machine_mode mode, rtx x, int context,\n \n /* Calculate the costs of insn operands.  */\n static void\n-record_operand_costs (rtx insn, struct costs **op_costs,\n-\t\t      enum reg_class *allocno_pref)\n+record_operand_costs (rtx insn, struct costs **op_costs, enum reg_class *pref)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   enum machine_mode modes[MAX_RECOG_OPERANDS];\n@@ -976,11 +983,11 @@ record_operand_costs (rtx insn, struct costs **op_costs,\n \txconstraints[i+1] = constraints[i];\n \trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n \t\t\t    recog_data.operand, modes,\n-\t\t\t    xconstraints, insn, op_costs, allocno_pref);\n+\t\t\t    xconstraints, insn, op_costs, pref);\n       }\n   record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n \t\t      recog_data.operand, modes,\n-\t\t      constraints, insn, op_costs, allocno_pref);\n+\t\t      constraints, insn, op_costs, pref);\n }\n \n \f\n@@ -1015,17 +1022,17 @@ scan_one_insn (rtx insn)\n     {\n       enum reg_class cl = GENERAL_REGS;\n       rtx reg = SET_DEST (set);\n-      int num = ALLOCNO_NUM (ira_curr_regno_allocno_map[REGNO (reg)]);\n+      int num = COST_INDEX (REGNO (reg));\n \n-      if (allocno_pref)\n-\tcl = allocno_pref[num];\n-      COSTS_OF_ALLOCNO (allocno_costs, num)->mem_cost\n+      if (pref)\n+\tcl = pref[num];\n+      COSTS (costs, num)->mem_cost\n \t-= ira_memory_move_cost[GET_MODE (reg)][cl][1] * frequency;\n       record_address_regs (GET_MODE (SET_SRC (set)), XEXP (SET_SRC (set), 0),\n \t\t\t   0, MEM, SCRATCH, frequency * 2);\n     }\n \n-  record_operand_costs (insn, op_costs, allocno_pref);\n+  record_operand_costs (insn, op_costs, pref);\n \n   /* Now add the cost for each operand to the total costs for its\n      allocno.  */\n@@ -1034,9 +1041,7 @@ scan_one_insn (rtx insn)\n \t&& REGNO (recog_data.operand[i]) >= FIRST_PSEUDO_REGISTER)\n       {\n \tint regno = REGNO (recog_data.operand[i]);\n-\tstruct costs *p\n-\t  = COSTS_OF_ALLOCNO (allocno_costs,\n-\t\t\t      ALLOCNO_NUM (ira_curr_regno_allocno_map[regno]));\n+\tstruct costs *p = COSTS (costs, COST_INDEX (regno));\n \tstruct costs *q = op_costs[i];\n \n \tp->mem_cost += q->mem_cost;\n@@ -1051,12 +1056,13 @@ scan_one_insn (rtx insn)\n \n /* Print allocnos costs to file F.  */\n static void\n-print_costs (FILE *f)\n+print_allocno_costs (FILE *f)\n {\n   int k;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n+  ira_assert (allocno_p);\n   fprintf (f, \"\\n\");\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n@@ -1085,57 +1091,114 @@ print_costs (FILE *f)\n \t      )\n \t    {\n \t      fprintf (f, \" %s:%d\", reg_class_names[rclass],\n-\t\t       COSTS_OF_ALLOCNO (allocno_costs, i)->cost[k]);\n+\t\t       COSTS (costs, i)->cost[k]);\n \t      if (flag_ira_region == IRA_REGION_ALL\n \t\t  || flag_ira_region == IRA_REGION_MIXED)\n-\t\tfprintf (f, \",%d\", COSTS_OF_ALLOCNO (total_costs, i)->cost[k]);\n+\t\tfprintf (f, \",%d\", COSTS (total_allocno_costs, i)->cost[k]);\n \t    }\n \t}\n-      fprintf (f, \" MEM:%i\\n\", COSTS_OF_ALLOCNO (allocno_costs, i)->mem_cost);\n+      fprintf (f, \" MEM:%i\\n\", COSTS (costs, i)->mem_cost);\n+    }\n+}\n+\n+/* Print pseudo costs to file F.  */\n+static void\n+print_pseudo_costs (FILE *f)\n+{\n+  int regno, k;\n+  int rclass;\n+\n+  ira_assert (! allocno_p);\n+  fprintf (f, \"\\n\");\n+  for (regno = max_reg_num () - 1; regno >= FIRST_PSEUDO_REGISTER; regno--)\n+    {\n+      if (regno_reg_rtx[regno] == NULL_RTX)\n+\tcontinue;\n+      fprintf (f, \"  r%d costs:\", regno);\n+      for (k = 0; k < cost_classes_num; k++)\n+\t{\n+\t  rclass = cost_classes[k];\n+\t  if (contains_reg_of_mode[rclass][PSEUDO_REGNO_MODE (regno)]\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\t      && (! in_inc_dec[regno] || ! forbidden_inc_dec_class[rclass])\n+#endif\n+#ifdef CANNOT_CHANGE_MODE_CLASS\n+\t      && ! invalid_mode_change_p (regno, (enum reg_class) rclass,\n+\t\t\t\t\t  PSEUDO_REGNO_MODE (regno))\n+#endif\n+\t      )\n+\t    fprintf (f, \" %s:%d\", reg_class_names[rclass],\n+\t\t     COSTS (costs, regno)->cost[k]);\n+\t}\n+      fprintf (f, \" MEM:%i\\n\", COSTS (costs, regno)->mem_cost);\n     }\n }\n \n /* Traverse the BB represented by LOOP_TREE_NODE to update the allocno\n    costs.  */\n static void\n-process_bb_node_for_costs (ira_loop_tree_node_t loop_tree_node)\n+process_bb_for_costs (basic_block bb)\n {\n-  basic_block bb;\n   rtx insn;\n \n-  bb = loop_tree_node->bb;\n-  if (bb == NULL)\n-    return;\n   frequency = REG_FREQ_FROM_BB (bb);\n   if (frequency == 0)\n     frequency = 1;\n   FOR_BB_INSNS (bb, insn)\n     insn = scan_one_insn (insn);\n }\n \n-/* Find costs of register classes and memory for allocnos and their\n-   best costs. */\n+/* Traverse the BB represented by LOOP_TREE_NODE to update the allocno\n+   costs.  */\n static void\n-find_allocno_class_costs (void)\n+process_bb_node_for_costs (ira_loop_tree_node_t loop_tree_node)\n {\n-  int i, k;\n+  basic_block bb;\n+\n+  bb = loop_tree_node->bb;\n+  if (bb != NULL)\n+    process_bb_for_costs (bb);\n+}\n+\n+/* Find costs of register classes and memory for allocnos or pseudos\n+   and their best costs.  Set up preferred, alternative and cover\n+   classes for pseudos.  */\n+static void\n+find_costs_and_classes (FILE *dump_file)\n+{\n+  int i, k, start;\n   int pass;\n   basic_block bb;\n \n   init_recog ();\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-  in_inc_dec = ira_allocate (sizeof (bool) * ira_allocnos_num);\n+  in_inc_dec = ira_allocate (sizeof (bool) * cost_elements_num);\n #endif /* FORBIDDEN_INC_DEC_CLASSES */\n-  allocno_pref = NULL;\n+  pref = NULL;\n+  start = 0;\n+  if (!resize_reg_info () && allocno_p && pseudo_classes_defined_p)\n+    {\n+      ira_allocno_t a;\n+      ira_allocno_iterator ai;\n+      \n+      pref = pref_buffer;\n+      FOR_EACH_ALLOCNO (a, ai)\n+\tpref[ALLOCNO_NUM (a)] = reg_preferred_class (ALLOCNO_REGNO (a));\n+      if (flag_expensive_optimizations)\n+\tstart = 1;\n+    }\n+  if (allocno_p)\n+    /* Clear the flag for the next compiled function.  */\n+    pseudo_classes_defined_p = false;\n   /* Normally we scan the insns once and determine the best class to\n      use for each allocno.  However, if -fexpensive-optimizations are\n      on, we do so twice, the second time using the tentative best\n      classes to guide the selection.  */\n-  for (pass = 0; pass <= flag_expensive_optimizations; pass++)\n+  for (pass = start; pass <= flag_expensive_optimizations; pass++)\n     {\n-      if (internal_flag_ira_verbose > 0 && ira_dump_file)\n-\tfprintf (ira_dump_file, \"\\nPass %i for finding allocno costs\\n\\n\",\n-\t\t pass);\n+      if ((!allocno_p || internal_flag_ira_verbose > 0) && dump_file)\n+\tfprintf (dump_file,\n+\t\t \"\\nPass %i for finding pseudo/allocno costs\\n\\n\", pass);\n       /* We could use only cover classes.  Unfortunately it does not\n \t work well for some targets where some subclass of cover class\n \t is costly and wrong cover class is chosen.  */\n@@ -1154,20 +1217,31 @@ find_allocno_class_costs (void)\n \t= sizeof (struct costs) + sizeof (int) * (cost_classes_num - 1);\n       /* Zero out our accumulation of the cost of each class for each\n \t allocno.  */\n-      memset (allocno_costs, 0, ira_allocnos_num * struct_costs_size);\n+      memset (costs, 0, cost_elements_num * struct_costs_size);\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-      memset (in_inc_dec, 0, ira_allocnos_num * sizeof (bool));\n+      memset (in_inc_dec, 0, cost_elements_num * sizeof (bool));\n #endif\n \n-      /* Scan the instructions and record each time it would save code\n-\t to put a certain allocno in a certain class.  */\n-      ira_traverse_loop_tree (true, ira_loop_tree_root,\n-\t\t\t      process_bb_node_for_costs, NULL);\n+      if (allocno_p)\n+\t{\n+\t  /* Scan the instructions and record each time it would save code\n+\t     to put a certain allocno in a certain class.  */\n+\t  ira_traverse_loop_tree (true, ira_loop_tree_root,\n+\t\t\t\t  process_bb_node_for_costs, NULL);\n+\n+\t  memcpy (total_allocno_costs, costs,\n+\t\t  max_struct_costs_size * ira_allocnos_num);\n+\t}\n+      else\n+\t{\n+\t  basic_block bb;\n+\n+\t  FOR_EACH_BB (bb)\n+\t    process_bb_for_costs (bb);\n+\t}\n \n-      memcpy (total_costs, allocno_costs,\n-\t      max_struct_costs_size * ira_allocnos_num);\n       if (pass == 0)\n-\tallocno_pref = allocno_pref_buffer;\n+\tpref = pref_buffer;\n \n       /* Now for each allocno look at how desirable each class is and\n \t find which class is preferred.  */\n@@ -1182,41 +1256,52 @@ find_allocno_class_costs (void)\n \t  int inc_dec_p = false;\n #endif\n \n-\t  if (ira_regno_allocno_map[i] == NULL)\n-\t    continue;\n-\t  memset (temp_costs, 0, struct_costs_size);\n-\t  /* Find cost of all allocnos with the same regno.  */\n-\t  for (a = ira_regno_allocno_map[i];\n-\t       a != NULL;\n-\t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n+\t  if (! allocno_p)\n \t    {\n-\t      a_num = ALLOCNO_NUM (a);\n-\t      if ((flag_ira_region == IRA_REGION_ALL\n-\t\t   || flag_ira_region == IRA_REGION_MIXED)\n-\t\t  && (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) != NULL\n-\t\t  && (parent_a = parent->regno_allocno_map[i]) != NULL\n-\t\t  /* There are no caps yet.  */\n-\t\t  && bitmap_bit_p (ALLOCNO_LOOP_TREE_NODE (a)->border_allocnos,\n-\t\t\t\t   ALLOCNO_NUM (a)))\n+\t      if (regno_reg_rtx[i] == NULL_RTX)\n+\t\tcontinue;\n+#ifdef FORBIDDEN_INC_DEC_CLASSES\n+\t      inc_dec_p = in_inc_dec[i];\n+#endif\n+\t      memcpy (temp_costs, COSTS (costs, i), struct_costs_size);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (ira_regno_allocno_map[i] == NULL)\n+\t\tcontinue;\n+\t      memset (temp_costs, 0, struct_costs_size);\n+\t      /* Find cost of all allocnos with the same regno.  */\n+\t      for (a = ira_regno_allocno_map[i];\n+\t\t   a != NULL;\n+\t\t   a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t\t{\n-\t\t  /* Propagate costs to upper levels in the region\n-\t\t     tree.  */\n-\t\t  parent_a_num = ALLOCNO_NUM (parent_a);\n+\t\t  a_num = ALLOCNO_NUM (a);\n+\t\t  if ((flag_ira_region == IRA_REGION_ALL\n+\t\t       || flag_ira_region == IRA_REGION_MIXED)\n+\t\t      && (parent = ALLOCNO_LOOP_TREE_NODE (a)->parent) != NULL\n+\t\t      && (parent_a = parent->regno_allocno_map[i]) != NULL\n+\t\t      /* There are no caps yet.  */\n+\t\t      && bitmap_bit_p (ALLOCNO_LOOP_TREE_NODE\n+\t\t\t\t       (a)->border_allocnos,\n+\t\t\t\t       ALLOCNO_NUM (a)))\n+\t\t    {\n+\t\t      /* Propagate costs to upper levels in the region\n+\t\t\t tree.  */\n+\t\t      parent_a_num = ALLOCNO_NUM (parent_a);\n+\t\t      for (k = 0; k < cost_classes_num; k++)\n+\t\t\tCOSTS (total_allocno_costs, parent_a_num)->cost[k]\n+\t\t\t  += COSTS (total_allocno_costs, a_num)->cost[k];\n+\t\t      COSTS (total_allocno_costs, parent_a_num)->mem_cost\n+\t\t\t+= COSTS (total_allocno_costs, a_num)->mem_cost;\n+\t\t    }\n \t\t  for (k = 0; k < cost_classes_num; k++)\n-\t\t    COSTS_OF_ALLOCNO (total_costs, parent_a_num)->cost[k]\n-\t\t      += COSTS_OF_ALLOCNO (total_costs, a_num)->cost[k];\n-\t\t  COSTS_OF_ALLOCNO (total_costs, parent_a_num)->mem_cost\n-\t\t    += COSTS_OF_ALLOCNO (total_costs, a_num)->mem_cost;\n-\t\t}\n-\t      for (k = 0; k < cost_classes_num; k++)\n-\t\ttemp_costs->cost[k]\n-\t\t  += COSTS_OF_ALLOCNO (allocno_costs, a_num)->cost[k];\n-\t      temp_costs->mem_cost\n-\t\t+= COSTS_OF_ALLOCNO (allocno_costs, a_num)->mem_cost;\n+\t\t    temp_costs->cost[k] += COSTS (costs, a_num)->cost[k];\n+\t\t  temp_costs->mem_cost += COSTS (costs, a_num)->mem_cost;\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t      if (in_inc_dec[a_num])\n-\t\tinc_dec_p = true;\n+\t\t  if (in_inc_dec[a_num])\n+\t\t    inc_dec_p = true;\n #endif\n+\t\t}\n \t    }\n \t  best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n \t  best = ALL_REGS;\n@@ -1252,35 +1337,42 @@ find_allocno_class_costs (void)\n \t\talt_class = reg_class_subunion[alt_class][rclass];\n \t    }\n \t  alt_class = ira_class_translate[alt_class];\n-\t  if (pass == flag_expensive_optimizations)\n-\t    {\n-\t      if (best_cost > temp_costs->mem_cost)\n-\t\tbest = alt_class = NO_REGS;\n-\t      else if (best == alt_class)\n-\t\talt_class = NO_REGS;\n-\t      setup_reg_classes (i, best, alt_class);\n-\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n-\t\tfprintf (ira_dump_file,\n-\t\t\t \"    r%d: preferred %s, alternative %s\\n\",\n-\t\t\t i, reg_class_names[best], reg_class_names[alt_class]);\n-\t    }\n \t  if (best_cost > temp_costs->mem_cost)\n-\t    common_classes[i] = NO_REGS;\n+\t    regno_cover_class[i] = NO_REGS;\n \t  else if (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY)\n \t    /* Make the common class the biggest class of best and\n \t       alt_class.  */\n-\t    common_classes[i] = alt_class == NO_REGS ? best : alt_class;\n+\t    regno_cover_class[i] = alt_class == NO_REGS ? best : alt_class;\n \t  else\n \t    /* Make the common class a cover class.  Remember all\n \t       allocnos with the same regno should have the same cover\n \t       class.  */\n-\t    common_classes[i] = ira_class_translate[best];\n+\t    regno_cover_class[i] = ira_class_translate[best];\n+\t  if (pass == flag_expensive_optimizations)\n+\t    {\n+\t      if (best_cost > temp_costs->mem_cost)\n+\t\tbest = alt_class = NO_REGS;\n+\t      else if (best == alt_class)\n+\t\talt_class = NO_REGS;\n+\t      setup_reg_classes (i, best, alt_class, regno_cover_class[i]);\n+\t      if ((!allocno_p || internal_flag_ira_verbose > 2)\n+\t\t  && dump_file != NULL)\n+\t\tfprintf (dump_file,\n+\t\t\t \"    r%d: preferred %s, alternative %s, cover %s\\n\",\n+\t\t\t i, reg_class_names[best], reg_class_names[alt_class],\n+\t\t\t reg_class_names[regno_cover_class[i]]);\n+\t    }\n+\t  if (! allocno_p)\n+\t    {\n+\t      pref[i] = best_cost > temp_costs->mem_cost ? NO_REGS : best;\n+\t      continue;\n+\t    }\n \t  for (a = ira_regno_allocno_map[i];\n \t       a != NULL;\n \t       a = ALLOCNO_NEXT_REGNO_ALLOCNO (a))\n \t    {\n \t      a_num = ALLOCNO_NUM (a);\n-\t      if (common_classes[i] == NO_REGS)\n+\t      if (regno_cover_class[i] == NO_REGS)\n \t\tbest = NO_REGS;\n \t      else\n \t\t{\t      \n@@ -1292,7 +1384,7 @@ find_allocno_class_costs (void)\n \t\t  for (k = 0; k < cost_classes_num; k++)\n \t\t    {\n \t\t      rclass = cost_classes[k];\n-\t\t      if (! ira_class_subset_p[rclass][common_classes[i]])\n+\t\t      if (! ira_class_subset_p[rclass][regno_cover_class[i]])\n \t\t\tcontinue;\n \t\t      /* Ignore classes that are too small for this\n \t\t\t operand or invalid for an operand that was\n@@ -1307,50 +1399,50 @@ find_allocno_class_costs (void)\n #endif\n \t\t\t  )\n \t\t\t;\n-\t\t      else if (COSTS_OF_ALLOCNO (total_costs, a_num)->cost[k]\n+\t\t      else if (COSTS (total_allocno_costs, a_num)->cost[k]\n \t\t\t       < best_cost)\n \t\t\t{\n \t\t\t  best_cost\n-\t\t\t    = COSTS_OF_ALLOCNO (total_costs, a_num)->cost[k];\n-\t\t\t  allocno_cost\n-\t\t\t    = COSTS_OF_ALLOCNO (allocno_costs, a_num)->cost[k];\n+\t\t\t    = COSTS (total_allocno_costs, a_num)->cost[k];\n+\t\t\t  allocno_cost = COSTS (costs, a_num)->cost[k];\n \t\t\t  best = (enum reg_class) rclass;\n \t\t\t}\n-\t\t      else if (COSTS_OF_ALLOCNO (total_costs, a_num)->cost[k]\n+\t\t      else if (COSTS (total_allocno_costs, a_num)->cost[k]\n \t\t\t       == best_cost)\n \t\t\t{\n \t\t\t  best = ira_reg_class_union[best][rclass];\n \t\t\t  allocno_cost\n-\t\t\t    = MAX (allocno_cost,\n-\t\t\t\t   COSTS_OF_ALLOCNO (allocno_costs,\n-\t\t\t\t\t\t     a_num)->cost[k]);\n+\t\t\t    = MAX (allocno_cost, COSTS (costs, a_num)->cost[k]);\n \t\t\t}\n \t\t    }\n \t\t  ALLOCNO_COVER_CLASS_COST (a) = allocno_cost;\n \t\t}\n \t      ira_assert (flag_ira_algorithm == IRA_ALGORITHM_PRIORITY\n-\t\t\t  || ira_class_translate[best] == common_classes[i]);\n-\t      if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL\n-\t\t  && (pass == 0 || allocno_pref[a_num] != best))\n+\t\t\t  || ira_class_translate[best] == regno_cover_class[i]);\n+\t      if (internal_flag_ira_verbose > 2 && dump_file != NULL\n+\t\t  && (pass == 0 || pref[a_num] != best))\n \t\t{\n-\t\t  fprintf (ira_dump_file, \"    a%d (r%d,\", a_num, i);\n+\t\t  fprintf (dump_file, \"    a%d (r%d,\", a_num, i);\n \t\t  if ((bb = ALLOCNO_LOOP_TREE_NODE (a)->bb) != NULL)\n-\t\t    fprintf (ira_dump_file, \"b%d\", bb->index);\n+\t\t    fprintf (dump_file, \"b%d\", bb->index);\n \t\t  else\n-\t\t    fprintf (ira_dump_file, \"l%d\",\n+\t\t    fprintf (dump_file, \"l%d\",\n \t\t\t     ALLOCNO_LOOP_TREE_NODE (a)->loop->num);\n-\t\t  fprintf (ira_dump_file, \") best %s, cover %s\\n\",\n+\t\t  fprintf (dump_file, \") best %s, cover %s\\n\",\n \t\t\t   reg_class_names[best],\n-\t\t\t   reg_class_names[common_classes[i]]);\n+\t\t\t   reg_class_names[regno_cover_class[i]]);\n \t\t}\n-\t      allocno_pref[a_num] = best;\n+\t      pref[a_num] = best;\n \t    }\n \t}\n       \n-      if (internal_flag_ira_verbose > 4 && ira_dump_file)\n+      if (internal_flag_ira_verbose > 4 && dump_file)\n \t{\n-\t  print_costs (ira_dump_file);\n-\t  fprintf (ira_dump_file,\"\\n\");\n+\t  if (allocno_p)\n+\t    print_allocno_costs (dump_file);\n+\t  else\n+\t    print_pseudo_costs (dump_file);\n+\t  fprintf (dump_file,\"\\n\");\n \t}\n     }\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n@@ -1443,31 +1535,30 @@ setup_allocno_cover_class_and_costs (void)\n   int *reg_costs;\n   enum reg_class cover_class, rclass;\n   enum machine_mode mode;\n-  HARD_REG_SET *pref;\n   ira_allocno_t a;\n   ira_allocno_iterator ai;\n \n+  ira_assert (allocno_p);\n   FOR_EACH_ALLOCNO (a, ai)\n     {\n       i = ALLOCNO_NUM (a);\n       mode = ALLOCNO_MODE (a);\n-      cover_class = common_classes[ALLOCNO_REGNO (a)];\n-      ira_assert (allocno_pref[i] == NO_REGS || cover_class != NO_REGS);\n-      ALLOCNO_MEMORY_COST (a) = COSTS_OF_ALLOCNO (allocno_costs, i)->mem_cost;\n+      cover_class = regno_cover_class[ALLOCNO_REGNO (a)];\n+      ira_assert (pref[i] == NO_REGS || cover_class != NO_REGS);\n+      ALLOCNO_MEMORY_COST (a) = COSTS (costs, i)->mem_cost;\n       ira_set_allocno_cover_class (a, cover_class);\n       if (cover_class == NO_REGS)\n \tcontinue;\n       ALLOCNO_AVAILABLE_REGS_NUM (a) = ira_available_class_regs[cover_class];\n-      pref = &reg_class_contents[allocno_pref[i]];\n-      if (optimize && ALLOCNO_COVER_CLASS (a) != allocno_pref[i])\n+      if (optimize && ALLOCNO_COVER_CLASS (a) != pref[i])\n \t{\n \t  n = ira_class_hard_regs_num[cover_class];\n \t  ALLOCNO_HARD_REG_COSTS (a)\n \t    = reg_costs = ira_allocate_cost_vector (cover_class);\n \t  for (j = n - 1; j >= 0; j--)\n \t    {\n \t      regno = ira_class_hard_regs[cover_class][j];\n-\t      if (TEST_HARD_REG_BIT (*pref, regno))\n+\t      if (TEST_HARD_REG_BIT (reg_class_contents[pref[i]], regno))\n \t\treg_costs[j] = ALLOCNO_COVER_CLASS_COST (a);\n \t      else\n \t\t{\n@@ -1482,7 +1573,7 @@ setup_allocno_cover_class_and_costs (void)\n \t\t\t\t  == cover_class);\n \t\t      num = cost_class_nums[cover_class];\n \t\t    }\n-\t\t  reg_costs[j] = COSTS_OF_ALLOCNO (allocno_costs, i)->cost[num];\n+\t\t  reg_costs[j] = COSTS (costs, i)->cost[num];\n \t\t}\n \t    }\n \t}\n@@ -1569,27 +1660,58 @@ ira_finish_costs_once (void)\n \n \f\n \n+/* Common initialization function for ira_costs and\n+   ira_set_pseudo_classes.  */\n+static void\n+init_costs (void)\n+{\n+  costs = (struct costs *) ira_allocate (max_struct_costs_size\n+\t\t\t\t\t * cost_elements_num);\n+  pref_buffer\n+    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n+\t\t\t\t       * cost_elements_num);\n+  regno_cover_class\n+    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n+\t\t\t\t       * max_reg_num ());\n+}\n+\n+/* Common finalization function for ira_costs and\n+   ira_set_pseudo_classes.  */\n+static void\n+finish_costs (void)\n+{\n+  ira_free (regno_cover_class);\n+  ira_free (pref_buffer);\n+  ira_free (costs);\n+}\n+\n /* Entry function which defines cover class, memory and hard register\n    costs for each allocno.  */\n void\n ira_costs (void)\n {\n-  allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size\n-\t\t\t\t\t       * ira_allocnos_num);\n-  total_costs = (struct costs *) ira_allocate (max_struct_costs_size\n-\t\t\t\t\t       * ira_allocnos_num);\n-  allocno_pref_buffer\n-    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n-\t\t\t\t       * ira_allocnos_num);\n-  common_classes\n-    = (enum reg_class *) ira_allocate (sizeof (enum reg_class)\n-\t\t\t\t       * max_reg_num ());\n-  find_allocno_class_costs ();\n+  allocno_p = true;\n+  cost_elements_num = ira_allocnos_num;\n+  init_costs ();\n+  total_allocno_costs = (struct costs *) ira_allocate (max_struct_costs_size\n+\t\t\t\t\t\t       * ira_allocnos_num);\n+  find_costs_and_classes (ira_dump_file);\n   setup_allocno_cover_class_and_costs ();\n-  ira_free (common_classes);\n-  ira_free (allocno_pref_buffer);\n-  ira_free (total_costs);\n-  ira_free (allocno_costs);\n+  finish_costs ();\n+  ira_free (total_allocno_costs);\n+}\n+\n+/* Entry function which defines classes for pseudos.  */\n+void\n+ira_set_pseudo_classes (FILE *dump_file)\n+{\n+  allocno_p = false;\n+  internal_flag_ira_verbose = flag_ira_verbose;\n+  cost_elements_num = max_reg_num ();\n+  init_costs ();\n+  find_costs_and_classes (dump_file);\n+  pseudo_classes_defined_p = true;\n+  finish_costs ();\n }\n \n \f"}, {"sha": "1327f9451495e6f50967438e55a9a2babc06d2be", "filename": "gcc/ira-int.h", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -565,18 +565,7 @@ extern int ira_reg_cost, ira_mem_cost;\n extern int ira_load_cost, ira_store_cost, ira_shuffle_cost;\n extern int ira_move_loops_num, ira_additional_jumps_num;\n \n-/* Map: hard register number -> cover class it belongs to.  If the\n-   corresponding class is NO_REGS, the hard register is not available\n-   for allocation.  */\n-extern enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n-\n-/* Map: register class x machine mode -> number of hard registers of\n-   given class needed to store value of given mode.  If the number for\n-   some hard-registers of the register class is different, the size\n-   will be negative.  */\n-extern int ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n-\n-/* Maximal value of the previous array elements.  */\n+/* Maximal value of element of array ira_reg_class_nregs.  */\n extern int ira_max_nregs;\n \n /* The number of bits in each element of array used to implement a bit\n@@ -730,10 +719,9 @@ ira_allocno_set_iter_next (ira_allocno_set_iterator *i)\n extern HARD_REG_SET ira_reg_mode_hard_regset\n                     [FIRST_PSEUDO_REGISTER][NUM_MACHINE_MODES];\n \n-/* Arrays analogous to macros MEMORY_MOVE_COST and REGISTER_MOVE_COST.\n-   Don't use ira_register_move_cost directly.  Use function of\n+/* Array analogous to macro REGISTER_MOVE_COST.  Don't use\n+   ira_register_move_cost directly.  Use function of\n    ira_get_may_move_cost instead.  */\n-extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n extern move_table *ira_register_move_cost[MAX_MACHINE_MODE];\n \n /* Similar to may_move_in_cost but it is calculated in IRA instead of\n@@ -755,29 +743,12 @@ extern move_table *ira_may_move_out_cost[MAX_MACHINE_MODE];\n    allocation.  */\n extern int ira_class_subset_p[N_REG_CLASSES][N_REG_CLASSES];\n \n-/* Array of number of hard registers of given class which are\n-   available for the allocation.  The order is defined by the\n-   allocation order.  */\n-extern short ira_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n-\n-/* The number of elements of the above array for given register\n-   class.  */\n-extern int ira_class_hard_regs_num[N_REG_CLASSES];\n-\n /* Index (in ira_class_hard_regs) for given register class and hard\n    register (in general case a hard register can belong to several\n    register classes).  The index is negative for hard registers\n    unavailable for the allocation. */\n extern short ira_class_hard_reg_index[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n \n-/* Function specific hard registers can not be used for the register\n-   allocation.  */\n-extern HARD_REG_SET ira_no_alloc_regs;\n-\n-/* Number of given class hard registers available for the register\n-   allocation for given classes.  */\n-extern int ira_available_class_regs[N_REG_CLASSES];\n-\n /* Array whose values are hard regset of hard registers available for\n    the allocation of given register class whose HARD_REGNO_MODE_OK\n    values for given mode are zero.  */\n@@ -789,16 +760,6 @@ extern HARD_REG_SET prohibited_class_mode_regs\n    prohibited.  */\n extern HARD_REG_SET ira_prohibited_mode_move_regs[NUM_MACHINE_MODES];\n \n-/* Number of cover classes.  Cover classes is non-intersected register\n-   classes containing all hard-registers available for the\n-   allocation.  */\n-extern int ira_reg_class_cover_size;\n-\n-/* The array containing cover classes (see also comments for macro\n-   IRA_COVER_CLASSES).  Only first IRA_REG_CLASS_COVER_SIZE elements are\n-   used for this.  */\n-extern enum reg_class ira_reg_class_cover[N_REG_CLASSES];\n-\n /* The value is number of elements in the subsequent array.  */\n extern int ira_important_classes_num;\n \n@@ -812,11 +773,6 @@ extern enum reg_class ira_important_classes[N_REG_CLASSES];\n    classes.  */\n extern int ira_important_class_nums[N_REG_CLASSES];\n \n-/* Map of all register classes to corresponding cover class containing\n-   the given class.  If given class is not a subset of a cover class,\n-   we translate it into the cheapest cover class.  */\n-extern enum reg_class ira_class_translate[N_REG_CLASSES];\n-\n /* The biggest important class inside of intersection of the two\n    classes (that is calculated taking only hard registers available\n    for allocation into account).  If the both classes contain no hard"}, {"sha": "57a953bad59fdd3546c527bf4d1f958a5bbd122c", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 62, "deletions": 3, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -702,7 +702,8 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t\t     ? GENERAL_REGS\n \t\t     : REG_CLASS_FROM_CONSTRAINT (c, constraints));\n \t  if ((cl != NO_REGS && next_cl != cl)\n-\t      || ira_available_class_regs[next_cl] > 1)\n+\t      || (ira_available_class_regs[next_cl]\n+\t\t  > ira_reg_class_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -712,8 +713,10 @@ single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n \t  next_cl\n \t    = single_reg_class (recog_data.constraints[c - '0'],\n \t\t\t\trecog_data.operand[c - '0'], NULL_RTX);\n-\t  if ((cl != NO_REGS && next_cl != cl) || next_cl == NO_REGS\n-\t      || ira_available_class_regs[next_cl] > 1)\n+\t  if ((cl != NO_REGS && next_cl != cl)\n+\t      || next_cl == NO_REGS\n+\t      || (ira_available_class_regs[next_cl]\n+\t\t  > ira_reg_class_nregs[next_cl][GET_MODE (op)]))\n \t    return NO_REGS;\n \t  cl = next_cl;\n \t  break;\n@@ -736,6 +739,62 @@ single_reg_operand_class (int op_num)\n \t\t\t   recog_data.operand[op_num], NULL_RTX);\n }\n \n+/* The function sets up hard register set *SET to hard registers which\n+   might be used by insn reloads because the constraints are too\n+   strict.  */\n+void\n+ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n+{\n+  int i, c, regno;\n+  bool ignore_p;\n+  enum reg_class cl;\n+  rtx op;\n+  enum machine_mode mode;\n+\n+  CLEAR_HARD_REG_SET (*set);\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    {\n+      op = recog_data.operand[i];\n+\n+      if (GET_CODE (op) == SUBREG)\n+\top = SUBREG_REG (op);\n+      \n+      if (GET_CODE (op) == SCRATCH\n+\t  || (REG_P (op) && (regno = REGNO (op)) >= FIRST_PSEUDO_REGISTER))\n+\t{\n+\t  const char *p = recog_data.constraints[i];\n+\n+\t  mode = (GET_CODE (op) == SCRATCH\n+\t\t  ? GET_MODE (op) : PSEUDO_REGNO_MODE (regno));\n+\t  cl = NO_REGS;\n+\t  for (ignore_p = false; (c = *p); p += CONSTRAINT_LEN (c, p))\n+\t    if (c == '#')\n+\t      ignore_p = true;\n+\t    else if (c == ',')\n+\t      ignore_p = false;\n+\t    else if (! ignore_p)\n+\t      switch (c)\n+\t\t{\n+\t\tcase 'r':\n+\t\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\t\tcase 'h': case 'j': case 'k': case 'l':\n+\t\tcase 'q': case 't': case 'u':\n+\t\tcase 'v': case 'w': case 'x': case 'y': case 'z':\n+\t\tcase 'A': case 'B': case 'C': case 'D':\n+\t\tcase 'Q': case 'R': case 'S': case 'T': case 'U':\n+\t\tcase 'W': case 'Y': case 'Z':\n+\t\t  cl = (c == 'r'\n+\t\t\t? GENERAL_REGS\n+\t\t\t: REG_CLASS_FROM_CONSTRAINT (c, p));\n+\t\t  if (cl != NO_REGS\n+\t\t      && (ira_available_class_regs[cl]\n+\t\t\t  <= ira_reg_class_nregs[cl][mode]))\n+\t\t    IOR_HARD_REG_SET (*set, reg_class_contents[cl]);\n+\t\t  break;\n+\t\t}\n+\t}\n+    }\n+}\n /* Processes input operands, if IN_P, or output operands otherwise of\n    the current insn with FREQ to find allocno which can use only one\n    hard register and makes other currently living allocnos conflicting"}, {"sha": "b960f769534a490188d588eab762488364df6394", "filename": "gcc/ira.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -1422,8 +1422,8 @@ compute_regs_asm_clobbered (char *regs_asm_clobbered)\n \n \n /* Set up ELIMINABLE_REGSET, IRA_NO_ALLOC_REGS, and REGS_EVER_LIVE.  */\n-static void\n-setup_eliminable_regset (void)\n+void\n+ira_setup_eliminable_regset (void)\n {\n   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n      asm.  Unlike regs_ever_live, elements of this array corresponding\n@@ -1827,7 +1827,8 @@ setup_preferred_alternate_classes_for_new_pseudos (int start)\n       old_regno = ORIGINAL_REGNO (regno_reg_rtx[i]);\n       ira_assert (i != old_regno); \n       setup_reg_classes (i, reg_preferred_class (old_regno),\n-\t\t\t reg_alternate_class (old_regno));\n+\t\t\t reg_alternate_class (old_regno),\n+\t\t\t reg_cover_class (old_regno));\n       if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n \tfprintf (ira_dump_file,\n \t\t \"    New r%d: setting preferred %s, alternative %s\\n\",\n@@ -1848,10 +1849,7 @@ expand_reg_info (int old_size)\n \n   resize_reg_info ();\n   for (i = old_size; i < size; i++)\n-    {\n-      reg_renumber[i] = -1;\n-      setup_reg_classes (i, GENERAL_REGS, ALL_REGS);\n-    }\n+    setup_reg_classes (i, GENERAL_REGS, ALL_REGS, GENERAL_REGS);\n }\n \n /* Return TRUE if there is too high register pressure in the function.\n@@ -3160,8 +3158,8 @@ ira (FILE *f)\n     }\n \n   max_regno_before_ira = allocated_reg_info_size = max_reg_num ();\n-  allocate_reg_info ();\n-  setup_eliminable_regset ();\n+  resize_reg_info ();\n+  ira_setup_eliminable_regset ();\n       \n   ira_overall_cost = ira_reg_cost = ira_mem_cost = 0;\n   ira_load_cost = ira_store_cost = ira_shuffle_cost = 0;"}, {"sha": "9688f7485dce382fce11683fe81ed339a6589943", "filename": "gcc/ira.h", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -20,14 +20,63 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* Number of given class hard registers available for the register\n+   allocation for given classes.  */\n+extern int ira_available_class_regs[N_REG_CLASSES];\n+\n+/* Map: hard register number -> cover class it belongs to.  If the\n+   corresponding class is NO_REGS, the hard register is not available\n+   for allocation.  */\n+extern enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n+\n+/* Number of cover classes.  Cover classes is non-intersected register\n+   classes containing all hard-registers available for the\n+   allocation.  */\n+extern int ira_reg_class_cover_size;\n+\n+/* The array containing cover classes (see also comments for macro\n+   IRA_COVER_CLASSES).  Only first IRA_REG_CLASS_COVER_SIZE elements are\n+   used for this.  */\n+extern enum reg_class ira_reg_class_cover[N_REG_CLASSES];\n+\n+/* Map of all register classes to corresponding cover class containing\n+   the given class.  If given class is not a subset of a cover class,\n+   we translate it into the cheapest cover class.  */\n+extern enum reg_class ira_class_translate[N_REG_CLASSES];\n+\n+/* Map: register class x machine mode -> number of hard registers of\n+   given class needed to store value of given mode.  If the number for\n+   some hard-registers of the register class is different, the size\n+   will be negative.  */\n+extern int ira_reg_class_nregs[N_REG_CLASSES][MAX_MACHINE_MODE];\n+\n+/* Function specific hard registers can not be used for the register\n+   allocation.  */\n+extern HARD_REG_SET ira_no_alloc_regs;\n+\n /* True if we have allocno conflicts.  It is false for non-optimized\n    mode or when the conflict table is too big.  */\n extern bool ira_conflicts_p;\n \n+/* Array analogous to macro MEMORY_MOVE_COST.  */\n+extern short ira_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n+\n+/* Array of number of hard registers of given class which are\n+   available for the allocation.  The order is defined by the\n+   allocation order.  */\n+extern short ira_class_hard_regs[N_REG_CLASSES][FIRST_PSEUDO_REGISTER];\n+\n+/* The number of elements of the above array for given register\n+   class.  */\n+extern int ira_class_hard_regs_num[N_REG_CLASSES];\n+\n extern void ira_init_once (void);\n extern void ira_init (void);\n extern void ira_finish_once (void);\n+extern void ira_setup_eliminable_regset (void);\n extern rtx ira_eliminate_regs (rtx, enum machine_mode);\n+extern void ira_set_pseudo_classes (FILE *);\n+extern void ira_implicitly_set_insn_hard_regs (HARD_REG_SET *);\n \n extern void ira_sort_regnos_for_alter_reg (int *, int, unsigned int *);\n extern void ira_mark_allocation_change (int);"}, {"sha": "7731da600fb9ab02ac86b7c5cca368412afab808", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -776,8 +776,8 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_mode_switching);\n       NEXT_PASS (pass_match_asm_constraints);\n       NEXT_PASS (pass_sms);\n-      NEXT_PASS (pass_sched);\n       NEXT_PASS (pass_subregs_of_mode_init);\n+      NEXT_PASS (pass_sched);\n       NEXT_PASS (pass_ira);\n       NEXT_PASS (pass_subregs_of_mode_finish);\n       NEXT_PASS (pass_postreload);"}, {"sha": "9842dc14f77e2915c8fdd05b335cd03bc9cce12d", "filename": "gcc/reginfo.c", "status": "modified", "additions": 70, "deletions": 44, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -898,6 +898,10 @@ struct reg_pref\n      but since it is recommended that there be a class corresponding to the\n      union of most major pair of classes, that generality is not required.  */\n   char altclass;\n+\n+  /* coverclass is a register class that IRA uses for allocating\n+     the pseudo.  */\n+  char coverclass;\n };\n \n /* Record preferences of each pseudo.  This is available after RA is\n@@ -925,65 +929,51 @@ reg_alternate_class (int regno)\n   return (enum reg_class) reg_pref[regno].altclass;\n }\n \n-/* Initialize some global data for this pass.  */\n-static unsigned int \n-reginfo_init (void)\n+/* Return the reg_class which is used by IRA for its allocation.  */\n+enum reg_class\n+reg_cover_class (int regno)\n {\n-  if (df)\n-    df_compute_regs_ever_live (true);\n-\n-  /* This prevents dump_flow_info from losing if called\n-     before reginfo is run.  */\n-  reg_pref = NULL;\n+  if (reg_pref == 0)\n+    return NO_REGS;\n \n-  /* No more global register variables may be declared.  */\n-  no_global_reg_vars = 1;\n-  return 1;\n+  return (enum reg_class) reg_pref[regno].coverclass;\n }\n \n-struct rtl_opt_pass pass_reginfo_init =\n-{\n- {\n-  RTL_PASS,\n-  \"reginfo\",                            /* name */\n-  NULL,                                 /* gate */\n-  reginfo_init,                         /* execute */\n-  NULL,                                 /* sub */\n-  NULL,                                 /* next */\n-  0,                                    /* static_pass_number */\n-  TV_NONE,                              /* tv_id */\n-  0,                                    /* properties_required */\n-  0,                                    /* properties_provided */\n-  0,                                    /* properties_destroyed */\n-  0,                                    /* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n- }\n-};\n-\n \f\n \n+/* Current size of reg_info.  */\n+static int reg_info_size;\n+\n /* Allocate space for reg info.  */\n-void\n+static void\n allocate_reg_info (void)\n {\n-  int size = max_reg_num ();\n-\n+  reg_info_size = max_reg_num ();\n   gcc_assert (! reg_pref && ! reg_renumber);\n-  reg_renumber = XNEWVEC (short, size);\n-  reg_pref = XCNEWVEC (struct reg_pref, size);\n-  memset (reg_renumber, -1, size * sizeof (short));\n+  reg_renumber = XNEWVEC (short, reg_info_size);\n+  reg_pref = XCNEWVEC (struct reg_pref, reg_info_size);\n+  memset (reg_renumber, -1, reg_info_size * sizeof (short));\n }\n \n \n /* Resize reg info. The new elements will be uninitialized.  */\n-void\n+bool\n resize_reg_info (void)\n {\n-  int size = max_reg_num ();\n+  int old;\n \n+  gcc_assert (reg_pref != NULL);\n+  if (reg_info_size == max_reg_num ())\n+    return false;\n+  old = reg_info_size;\n+  reg_info_size = max_reg_num ();\n   gcc_assert (reg_pref && reg_renumber);\n-  reg_renumber = XRESIZEVEC (short, reg_renumber, size);\n-  reg_pref = XRESIZEVEC (struct reg_pref, reg_pref, size);\n+  reg_renumber = XRESIZEVEC (short, reg_renumber, reg_info_size);\n+  reg_pref = XRESIZEVEC (struct reg_pref, reg_pref, reg_info_size);\n+  memset (reg_pref + old, -1,\n+\t  (reg_info_size - old) * sizeof (struct reg_pref));\n+  memset (reg_renumber + old, -1, (reg_info_size - old) * sizeof (short));\n+  return true;\n }\n \n \n@@ -1004,19 +994,55 @@ free_reg_info (void)\n     }\n }\n \n+/* Initialize some global data for this pass.  */\n+static unsigned int \n+reginfo_init (void)\n+{\n+  if (df)\n+    df_compute_regs_ever_live (true);\n+\n+  /* This prevents dump_flow_info from losing if called\n+     before reginfo is run.  */\n+  reg_pref = NULL;\n+  allocate_reg_info ();\n+  /* No more global register variables may be declared.  */\n+  no_global_reg_vars = 1;\n+  return 1;\n+}\n+\n+struct rtl_opt_pass pass_reginfo_init =\n+{\n+ {\n+  RTL_PASS,\n+  \"reginfo\",                            /* name */\n+  NULL,                                 /* gate */\n+  reginfo_init,                         /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_NONE,                                    /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  0                                     /* todo_flags_finish */\n+ }\n+};\n \n \f\n \n-/* Set up preferred and alternate classes for REGNO as PREFCLASS and\n-   ALTCLASS.  */\n+/* Set up preferred, alternate, and cover classes for REGNO as\n+   PREFCLASS, ALTCLASS, and COVERCLASS.  */\n void\n setup_reg_classes (int regno,\n-\t\t   enum reg_class prefclass, enum reg_class altclass)\n+\t\t   enum reg_class prefclass, enum reg_class altclass,\n+\t\t   enum reg_class coverclass)\n {\n   if (reg_pref == NULL)\n     return;\n   reg_pref[regno].prefclass = prefclass;\n   reg_pref[regno].altclass = altclass;\n+  reg_pref[regno].coverclass = coverclass;\n }\n \n \f"}, {"sha": "1435945d62cbf806c6698ae0519fcf8b810bee09", "filename": "gcc/reload.c", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -112,6 +112,7 @@ a register with any other reload.  */\n #include \"params.h\"\n #include \"target.h\"\n #include \"df.h\"\n+#include \"ira.h\"\n \n /* True if X is a constant that can be forced into the constant pool.  */\n #define CONST_POOL_OK_P(X)\t\t\t\\\n@@ -2589,6 +2590,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n   char goal_alternative_earlyclobber[MAX_RECOG_OPERANDS];\n   int goal_alternative_swapped;\n   int best;\n+  int best_small_class_operands_num;\n   int commutative;\n   char operands_match[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n   rtx substed_operand[MAX_RECOG_OPERANDS];\n@@ -2914,6 +2916,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n      all the operands together against the register constraints.  */\n \n   best = MAX_RECOG_OPERANDS * 2 + 600;\n+  best_small_class_operands_num = 0;\n \n   swapped = 0;\n   goal_alternative_swapped = 0;\n@@ -3697,22 +3700,48 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n       /* If this alternative can be made to work by reloading,\n \t and it needs less reloading than the others checked so far,\n \t record it as the chosen goal for reloading.  */\n-      if (! bad && best > losers)\n+      if (! bad)\n \t{\n-\t  for (i = 0; i < noperands; i++)\n+\t  bool change_p = false;\n+\t  int small_class_operands_num = 0;\n+\n+\t  if (best >= losers)\n \t    {\n-\t      goal_alternative[i] = this_alternative[i];\n-\t      goal_alternative_win[i] = this_alternative_win[i];\n-\t      goal_alternative_match_win[i] = this_alternative_match_win[i];\n-\t      goal_alternative_offmemok[i] = this_alternative_offmemok[i];\n-\t      goal_alternative_matches[i] = this_alternative_matches[i];\n-\t      goal_alternative_earlyclobber[i]\n-\t\t= this_alternative_earlyclobber[i];\n+\t      for (i = 0; i < noperands; i++)\n+\t\tsmall_class_operands_num\n+\t\t  += SMALL_REGISTER_CLASS_P (this_alternative[i]) ? 1 : 0;\n+\t      if (best > losers\n+\t\t  || (best == losers\n+\t\t      /* If the cost of the reloads is the same,\n+\t\t\t prefer alternative which requires minimal\n+\t\t\t number of small register classes for the\n+\t\t\t operands.  This improves chances of reloads\n+\t\t\t for insn requiring small register\n+\t\t\t classes.  */\n+\t\t      && (small_class_operands_num\n+\t\t\t  < best_small_class_operands_num)))\n+\t\tchange_p = true;\n+\t    }\n+\t  if (change_p)\n+\t    {\n+\t      for (i = 0; i < noperands; i++)\n+\t\t{\n+\t\t  goal_alternative[i] = this_alternative[i];\n+\t\t  goal_alternative_win[i] = this_alternative_win[i];\n+\t\t  goal_alternative_match_win[i]\n+\t\t    = this_alternative_match_win[i];\n+\t\t  goal_alternative_offmemok[i]\n+\t\t    = this_alternative_offmemok[i];\n+\t\t  goal_alternative_matches[i] = this_alternative_matches[i];\n+\t\t  goal_alternative_earlyclobber[i]\n+\t\t    = this_alternative_earlyclobber[i];\n+\t\t}\n+\t      goal_alternative_swapped = swapped;\n+\t      best = losers;\n+\t      best_small_class_operands_num = small_class_operands_num;\n+\t      goal_alternative_number = this_alternative_number;\n+\t      goal_earlyclobber = this_earlyclobber;\n \t    }\n-\t  goal_alternative_swapped = swapped;\n-\t  best = losers;\n-\t  goal_alternative_number = this_alternative_number;\n-\t  goal_earlyclobber = this_earlyclobber;\n \t}\n     }\n "}, {"sha": "172afd0244dc4a7f37ccbe97d2ec172febc17ad1", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -1898,10 +1898,8 @@ extern rtx remove_free_EXPR_LIST_node (rtx *);\n \n /* Initialize may_move_cost and friends for mode M.  */\n extern void init_move_cost (enum machine_mode);\n-/* Allocate register info memory.  */\n-extern void allocate_reg_info (void);\n /* Resize reg info.  */\n-extern void resize_reg_info (void);\n+extern bool resize_reg_info (void);\n /* Free up register info memory.  */\n extern void free_reg_info (void);\n \n@@ -1912,7 +1910,9 @@ extern const char *decode_asm_operands (rtx, rtx *, rtx **, const char **,\n \n extern enum reg_class reg_preferred_class (int);\n extern enum reg_class reg_alternate_class (int);\n-extern void setup_reg_classes (int, enum reg_class, enum reg_class);\n+extern enum reg_class reg_cover_class (int);\n+extern void setup_reg_classes (int, enum reg_class, enum reg_class,\n+\t\t\t       enum reg_class);\n \n extern void split_all_insns (void);\n extern unsigned int split_all_insns_noflow (void);"}, {"sha": "25f03d26b57a287d30fa0cdd095ecb51fb3d2e52", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 535, "deletions": 124, "changes": 659, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"sched-int.h\"\n #include \"params.h\"\n #include \"cselib.h\"\n+#include \"ira.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -396,6 +397,15 @@ static regset reg_pending_clobbers;\n static regset reg_pending_uses;\n static enum reg_pending_barrier_mode reg_pending_barrier;\n \n+/* Hard registers implicitly clobbered or used (or may be implicitly\n+   clobbered or used) by the currently analyzed insn.  For example,\n+   insn in its constraint has one register class.  Even if there is\n+   currently no hard register in the insn, the particular hard\n+   register will be in the insn after reload pass because the\n+   constraint requires it.  */\n+static HARD_REG_SET implicit_reg_pending_clobbers;\n+static HARD_REG_SET implicit_reg_pending_uses;\n+\n /* To speed up the test for duplicate dependency links we keep a\n    record of dependencies created by add_dependence when the average\n    number of instructions in a basic block is very large.\n@@ -417,8 +427,8 @@ static int cache_size;\n \n static int deps_may_trap_p (const_rtx);\n static void add_dependence_list (rtx, rtx, int, enum reg_note);\n-static void add_dependence_list_and_free (struct deps *, rtx, \n-                                          rtx *, int, enum reg_note);\n+static void add_dependence_list_and_free (struct deps *, rtx,\n+\t\t\t\t\t  rtx *, int, enum reg_note);\n static void delete_all_dependences (rtx);\n static void fixup_sched_groups (rtx);\n \n@@ -1367,7 +1377,7 @@ add_dependence_list (rtx insn, rtx list, int uncond, enum reg_note dep_type)\n    is not readonly.  */\n \n static void\n-add_dependence_list_and_free (struct deps *deps, rtx insn, rtx *listp, \n+add_dependence_list_and_free (struct deps *deps, rtx insn, rtx *listp,\n                               int uncond, enum reg_note dep_type)\n {\n   rtx list, next;\n@@ -1625,7 +1635,7 @@ haifa_note_mem_dep (rtx mem, rtx pending_mem, rtx pending_insn, ds_t ds)\n   {\n     dep_def _dep, *dep = &_dep;\n     \n-    init_dep_1 (dep, pending_insn, cur_insn, ds_to_dt (ds), \n+    init_dep_1 (dep, pending_insn, cur_insn, ds_to_dt (ds),\n                 current_sched_info->flags & USE_DEPS_LIST ? ds : -1);\n     maybe_add_or_update_dep_1 (dep, false, pending_mem, mem);\n   }\n@@ -1691,6 +1701,327 @@ ds_to_dt (ds_t ds)\n       return REG_DEP_ANTI;\n     }\n }\n+\n+\f\n+\n+/* Functions for computation of info needed for register pressure\n+   sensitive insn scheduling.  */\n+\n+\n+/* Allocate and return reg_use_data structure for REGNO and INSN.  */\n+static struct reg_use_data *\n+create_insn_reg_use (int regno, rtx insn)\n+{\n+  struct reg_use_data *use;\n+\n+  use = (struct reg_use_data *) xmalloc (sizeof (struct reg_use_data));\n+  use->regno = regno;\n+  use->insn = insn;\n+  use->next_insn_use = INSN_REG_USE_LIST (insn);\n+  INSN_REG_USE_LIST (insn) = use;\n+  return use;\n+}\n+\n+/* Allocate and return reg_set_data structure for REGNO and INSN.  */\n+static struct reg_set_data *\n+create_insn_reg_set (int regno, rtx insn)\n+{\n+  struct reg_set_data *set;\n+\n+  set = (struct reg_set_data *) xmalloc (sizeof (struct reg_set_data));\n+  set->regno = regno;\n+  set->insn = insn;\n+  set->next_insn_set = INSN_REG_SET_LIST (insn);\n+  INSN_REG_SET_LIST (insn) = set;\n+  return set;\n+}\n+\n+/* Set up insn register uses for INSN and dependency context DEPS.  */\n+static void\n+setup_insn_reg_uses (struct deps *deps, rtx insn)\n+{\n+  unsigned i;\n+  reg_set_iterator rsi;\n+  rtx list;\n+  struct reg_use_data *use, *use2, *next;\n+  struct deps_reg *reg_last;\n+\n+  EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n+    {\n+      if (i < FIRST_PSEUDO_REGISTER\n+\t  && TEST_HARD_REG_BIT (ira_no_alloc_regs, i))\n+\tcontinue;\n+\n+      if (find_regno_note (insn, REG_DEAD, i) == NULL_RTX\n+\t  && ! REGNO_REG_SET_P (reg_pending_sets, i)\n+\t  && ! REGNO_REG_SET_P (reg_pending_clobbers, i))\n+\t/* Ignore use which is not dying.  */\n+\tcontinue;\n+\n+      use = create_insn_reg_use (i, insn);\n+      use->next_regno_use = use;\n+      reg_last = &deps->reg_last[i];\n+      \n+      /* Create the cycle list of uses.  */\n+      for (list = reg_last->uses; list; list = XEXP (list, 1))\n+\t{\n+\t  use2 = create_insn_reg_use (i, XEXP (list, 0));\n+\t  next = use->next_regno_use;\n+\t  use->next_regno_use = use2;\n+\t  use2->next_regno_use = next;\n+\t}\n+    }\n+}\n+\n+/* Register pressure info for the currently processed insn.  */\n+static struct reg_pressure_data reg_pressure_info[N_REG_CLASSES];\n+\n+/* Return TRUE if INSN has the use structure for REGNO.  */\n+static bool\n+insn_use_p (rtx insn, int regno)\n+{\n+  struct reg_use_data *use;\n+\n+  for (use = INSN_REG_USE_LIST (insn); use != NULL; use = use->next_insn_use)\n+    if (use->regno == regno)\n+      return true;\n+  return false;\n+}\n+\n+/* Update the register pressure info after birth of pseudo register REGNO\n+   in INSN.  Arguments CLOBBER_P and UNUSED_P say correspondingly that\n+   the register is in clobber or unused after the insn.  */\n+static void\n+mark_insn_pseudo_birth (rtx insn, int regno, bool clobber_p, bool unused_p)\n+{\n+  int incr, new_incr;\n+  enum reg_class cl;\n+\n+  gcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n+  cl = sched_regno_cover_class[regno];\n+  if (cl != NO_REGS)\n+    {\n+      incr = ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n+      if (clobber_p)\n+\t{\n+\t  new_incr = reg_pressure_info[cl].clobber_increase + incr;\n+\t  reg_pressure_info[cl].clobber_increase = new_incr;\n+\t}\n+      else if (unused_p)\n+\t{\n+\t  new_incr = reg_pressure_info[cl].unused_set_increase + incr;\n+\t  reg_pressure_info[cl].unused_set_increase = new_incr;\n+\t}\n+      else\n+\t{\n+\t  new_incr = reg_pressure_info[cl].set_increase + incr;\n+\t  reg_pressure_info[cl].set_increase = new_incr;\n+\t  if (! insn_use_p (insn, regno))\n+\t    reg_pressure_info[cl].change += incr;\n+\t  create_insn_reg_set (regno, insn);\n+\t}\n+      gcc_assert (new_incr < (1 << INCREASE_BITS));\n+    }\n+}\n+\n+/* Like mark_insn_pseudo_regno_birth except that NREGS saying how many\n+   hard registers involved in the birth.  */\n+static void\n+mark_insn_hard_regno_birth (rtx insn, int regno, int nregs,\n+\t\t\t    bool clobber_p, bool unused_p)\n+{\n+  enum reg_class cl;\n+  int new_incr, last = regno + nregs;\n+  \n+  while (regno < last)\n+    {\n+      gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n+      if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n+\t{\n+\t  cl = sched_regno_cover_class[regno];\n+\t  if (cl != NO_REGS)\n+\t    {\n+\t      if (clobber_p)\n+\t\t{\n+\t\t  new_incr = reg_pressure_info[cl].clobber_increase + 1;\n+\t\t  reg_pressure_info[cl].clobber_increase = new_incr;\n+\t\t}\n+\t      else if (unused_p)\n+\t\t{\n+\t\t  new_incr = reg_pressure_info[cl].unused_set_increase + 1;\n+\t\t  reg_pressure_info[cl].unused_set_increase = new_incr;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  new_incr = reg_pressure_info[cl].set_increase + 1;\n+\t\t  reg_pressure_info[cl].set_increase = new_incr;\n+\t\t  if (! insn_use_p (insn, regno))\n+\t\t    reg_pressure_info[cl].change += 1;\n+\t\t  create_insn_reg_set (regno, insn);\n+\t\t}\n+\t      gcc_assert (new_incr < (1 << INCREASE_BITS));\n+\t    }\n+\t}\n+      regno++;\n+    }\n+}\n+\n+/* Update the register pressure info after birth of pseudo or hard\n+   register REG in INSN.  Arguments CLOBBER_P and UNUSED_P say\n+   correspondingly that the register is in clobber or unused after the\n+   insn.  */\n+static void\n+mark_insn_reg_birth (rtx insn, rtx reg, bool clobber_p, bool unused_p)\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (! REG_P (reg))\n+    return;\n+\n+  regno = REGNO (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    mark_insn_hard_regno_birth (insn, regno,\n+\t\t\t\thard_regno_nregs[regno][GET_MODE (reg)],\n+\t\t\t\tclobber_p, unused_p);\n+  else\n+    mark_insn_pseudo_birth (insn, regno, clobber_p, unused_p);\n+}\n+\n+/* Update the register pressure info after death of pseudo register\n+   REGNO.  */\n+static void\n+mark_pseudo_death (int regno)\n+{\n+  int incr;\n+  enum reg_class cl;\n+\n+  gcc_assert (regno >= FIRST_PSEUDO_REGISTER);\n+  cl = sched_regno_cover_class[regno];\n+  if (cl != NO_REGS)\n+    {\n+      incr = ira_reg_class_nregs[cl][PSEUDO_REGNO_MODE (regno)];\n+      reg_pressure_info[cl].change -= incr;\n+    }\n+}\n+\n+/* Like mark_pseudo_death except that NREGS saying how many hard\n+   registers involved in the death.  */\n+static void\n+mark_hard_regno_death (int regno, int nregs)\n+{\n+  enum reg_class cl;\n+  int last = regno + nregs;\n+  \n+  while (regno < last)\n+    {\n+      gcc_assert (regno < FIRST_PSEUDO_REGISTER);\n+      if (! TEST_HARD_REG_BIT (ira_no_alloc_regs, regno))\n+\t{\n+\t  cl = sched_regno_cover_class[regno];\n+\t  if (cl != NO_REGS)\n+\t    reg_pressure_info[cl].change -= 1;\n+\t}\n+      regno++;\n+    }\n+}\n+\n+/* Update the register pressure info after death of pseudo or hard\n+   register REG.  */\n+static void\n+mark_reg_death (rtx reg)\n+{\n+  int regno;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  if (! REG_P (reg))\n+    return;\n+\n+  regno = REGNO (reg);\n+  if (regno < FIRST_PSEUDO_REGISTER)\n+    mark_hard_regno_death (regno, hard_regno_nregs[regno][GET_MODE (reg)]);\n+  else\n+    mark_pseudo_death (regno);\n+}\n+\n+/* Process SETTER of REG.  DATA is an insn containing the setter.  */\n+static void\n+mark_insn_reg_store (rtx reg, const_rtx setter, void *data)\n+{\n+  if (setter != NULL_RTX && GET_CODE (setter) != SET)\n+    return;\n+  mark_insn_reg_birth\n+    ((rtx) data, reg, false,\n+     find_reg_note ((const_rtx) data, REG_UNUSED, reg) != NULL_RTX);\n+}\n+\n+/* Like mark_insn_reg_store except notice just CLOBBERs; ignore SETs.  */\n+static void\n+mark_insn_reg_clobber (rtx reg, const_rtx setter, void *data)\n+{\n+  if (GET_CODE (setter) == CLOBBER)\n+    mark_insn_reg_birth ((rtx) data, reg, true, false);\n+}\n+\n+/* Set up reg pressure info related to INSN.  */\n+static void\n+setup_insn_reg_pressure_info (rtx insn)\n+{\n+  int i, len;\n+  enum reg_class cl;\n+  static struct reg_pressure_data *pressure_info;\n+  rtx link;\n+\n+  gcc_assert (sched_pressure_p);\n+\n+  if (! INSN_P (insn))\n+    return;\n+\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cl = ira_reg_class_cover[i];\n+      reg_pressure_info[cl].clobber_increase = 0;\n+      reg_pressure_info[cl].set_increase = 0;\n+      reg_pressure_info[cl].unused_set_increase = 0;\n+      reg_pressure_info[cl].change = 0;\n+    }\n+  \n+  note_stores (PATTERN (insn), mark_insn_reg_clobber, insn);\n+\t  \n+  note_stores (PATTERN (insn), mark_insn_reg_store, insn);\n+  \n+#ifdef AUTO_INC_DEC\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == REG_INC)\n+      mark_insn_reg_store (XEXP (link, 0), NULL_RTX, insn);\n+#endif\n+\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) == REG_DEAD)\n+      mark_reg_death (XEXP (link, 0));\n+\t\n+  len = sizeof (struct reg_pressure_data) * ira_reg_class_cover_size;\n+  pressure_info\n+    = INSN_REG_PRESSURE (insn) = (struct reg_pressure_data *) xmalloc (len);\n+  INSN_MAX_REG_PRESSURE (insn) = (int *) xmalloc (ira_reg_class_cover_size\n+\t\t\t\t\t\t  * sizeof (int));\n+  for (i = 0; i < ira_reg_class_cover_size; i++)\n+    {\n+      cl = ira_reg_class_cover[i];\n+      pressure_info[i].clobber_increase\n+\t= reg_pressure_info[cl].clobber_increase;\n+      pressure_info[i].set_increase = reg_pressure_info[cl].set_increase;\n+      pressure_info[i].unused_set_increase\n+\t= reg_pressure_info[cl].unused_set_increase;\n+      pressure_info[i].change = reg_pressure_info[cl].change;\n+    }\n+}\n+\n+\n \f\n \n /* Internal variable for sched_analyze_[12] () functions.\n@@ -1905,10 +2236,16 @@ sched_analyze_1 (struct deps *deps, rtx x, rtx insn)\n       /* Treat all writes to a stack register as modifying the TOS.  */\n       if (regno >= FIRST_STACK_REG && regno <= LAST_STACK_REG)\n \t{\n+\t  int nregs;\n+\n \t  /* Avoid analyzing the same register twice.  */\n \t  if (regno != FIRST_STACK_REG)\n \t    sched_analyze_reg (deps, FIRST_STACK_REG, mode, code, insn);\n-\t  sched_analyze_reg (deps, FIRST_STACK_REG, mode, USE, insn);\n+\n+\t  nregs = hard_regno_nregs[FIRST_STACK_REG][mode];\n+\t  while (--nregs >= 0)\n+\t    SET_HARD_REG_BIT (implicit_reg_pending_uses,\n+\t\t\t      FIRST_STACK_REG + nregs);\n \t}\n #endif\n     }\n@@ -2243,6 +2580,16 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n   unsigned i;\n   reg_set_iterator rsi;\n \n+  if (! reload_completed)\n+    {\n+      HARD_REG_SET temp;\n+\n+      extract_insn (insn);\n+      preprocess_constraints ();\n+      ira_implicitly_set_insn_hard_regs (&temp);\n+      IOR_HARD_REG_SET (implicit_reg_pending_clobbers, temp);\n+    }\n+\n   can_start_lhs_rhs_p = (NONJUMP_INSN_P (insn)\n \t\t\t && code == SET);\n \n@@ -2263,7 +2610,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t and others know that a value is dead.  Depend on the last call\n \t instruction so that reg-stack won't get confused.  */\n       if (code == CLOBBER)\n-\tadd_dependence_list (insn, deps->last_function_call, 1, REG_DEP_OUTPUT);\n+\tadd_dependence_list (insn, deps->last_function_call, 1,\n+\t\t\t     REG_DEP_OUTPUT);\n     }\n   else if (code == PARALLEL)\n     {\n@@ -2326,6 +2674,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n                 {\n                   struct deps_reg *reg_last = &deps->reg_last[i];\n                   add_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);\n+                  add_dependence_list (insn, reg_last->implicit_sets,\n+\t\t\t\t       0, REG_DEP_ANTI);\n                   add_dependence_list (insn, reg_last->clobbers, 0,\n \t\t\t\t       REG_DEP_ANTI);\n \n@@ -2381,6 +2731,12 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n       || (NONJUMP_INSN_P (insn) && control_flow_insn_p (insn)))\n     reg_pending_barrier = MOVE_BARRIER;\n \n+  if (sched_pressure_p)\n+    {\n+      setup_insn_reg_uses (deps, insn);\n+      setup_insn_reg_pressure_info (insn);\n+    }\n+\n   /* Add register dependencies for insn.  */\n   if (DEBUG_INSN_P (insn))\n     {\n@@ -2421,119 +2777,160 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n       if (prev && NONDEBUG_INSN_P (prev))\n \tadd_dependence (insn, prev, REG_DEP_ANTI);\n     }\n-  /* If the current insn is conditional, we can't free any\n-     of the lists.  */\n-  else if (sched_has_condition_p (insn))\n-    {\n-      EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n-          add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n-              \n-          if (!deps->readonly)\n-            {\n-              reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n-              reg_last->uses_length++;\n-            }\n-        }\n-      EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n-          add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n-\n-          if (!deps->readonly)\n-            {\n-              reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n-              reg_last->clobbers_length++;\n-            }\n-        }\n-      EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n-          add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_OUTPUT);\n-          add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n-\n-          if (!deps->readonly)\n-            {\n-              reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n-              SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n-            }\n-        }\n-    }\n   else\n     {\n       EXECUTE_IF_SET_IN_REG_SET (reg_pending_uses, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n-          add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n-\n-          if (!deps->readonly)\n-            {\n-              reg_last->uses_length++;\n-              reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n-            }\n-        }\n-      EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          if (reg_last->uses_length > MAX_PENDING_LIST_LENGTH\n-              || reg_last->clobbers_length > MAX_PENDING_LIST_LENGTH)\n-            {\n-              add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n-                                            REG_DEP_OUTPUT);\n-              add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,\n-                                            REG_DEP_ANTI);\n-              add_dependence_list_and_free (deps, insn, &reg_last->clobbers, 0,\n-                                            REG_DEP_OUTPUT);\n-\n-              if (!deps->readonly)\n-                {\n-                  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n-                  reg_last->clobbers_length = 0;\n-                  reg_last->uses_length = 0;\n-                }\n-            }\n-          else\n-            {\n-              add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n-              add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n-            }\n-\n-          if (!deps->readonly)\n-            {\n-              reg_last->clobbers_length++;\n-              reg_last->clobbers = alloc_INSN_LIST (insn, reg_last->clobbers);\n-            }\n-        }\n-      EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n-        {\n-          struct deps_reg *reg_last = &deps->reg_last[i];\n-          add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n-                                        REG_DEP_OUTPUT);\n-          add_dependence_list_and_free (deps, insn, &reg_last->clobbers, 0,\n-                                        REG_DEP_OUTPUT);\n-          add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,\n-                                        REG_DEP_ANTI);\n+\t{\n+\t  struct deps_reg *reg_last = &deps->reg_last[i];\n+\t  add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n+\t  add_dependence_list (insn, reg_last->implicit_sets, 0, REG_DEP_ANTI);\n+\t  add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n+\t  \n+\t  if (!deps->readonly)\n+\t    {\n+\t      reg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n+\t      reg_last->uses_length++;\n+\t    }\n+\t}\n+      \n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (implicit_reg_pending_uses, i))\n+\t  {\n+\t    struct deps_reg *reg_last = &deps->reg_last[i];\n+\t    add_dependence_list (insn, reg_last->sets, 0, REG_DEP_TRUE);\n+\t    add_dependence_list (insn, reg_last->implicit_sets, 0,\n+\t\t\t\t REG_DEP_ANTI);\n+\t    add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_TRUE);\n+\t    \n+\t    if (!deps->readonly)\n+\t      {\n+\t\treg_last->uses = alloc_INSN_LIST (insn, reg_last->uses);\n+\t\treg_last->uses_length++;\n+\t      }\n+\t  }\n \n-          if (!deps->readonly)\n-            {\n-              reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n-              reg_last->uses_length = 0;\n-              reg_last->clobbers_length = 0;\n-              CLEAR_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n-            }\n-        }\n+      /* If the current insn is conditional, we can't free any\n+\t of the lists.  */\n+      if (sched_has_condition_p (insn))\n+\t{\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->implicit_sets, 0,\n+\t\t\t\t   REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n+\t      \n+\t      if (!deps->readonly)\n+\t\t{\n+\t\t  reg_last->clobbers\n+\t\t    = alloc_INSN_LIST (insn, reg_last->clobbers);\n+\t\t  reg_last->clobbers_length++;\n+\t\t}\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->implicit_sets, 0,\n+\t\t\t\t   REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_OUTPUT);\n+\t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n+\t      \n+\t      if (!deps->readonly)\n+\t\t{\n+\t\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n+\t\t  SET_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      if (reg_last->uses_length > MAX_PENDING_LIST_LENGTH\n+\t\t  || reg_last->clobbers_length > MAX_PENDING_LIST_LENGTH)\n+\t\t{\n+\t\t  add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n+\t\t\t\t\t\tREG_DEP_OUTPUT);\n+\t\t  add_dependence_list_and_free (deps, insn,\n+\t\t\t\t\t\t&reg_last->implicit_sets, 0,\n+\t\t\t\t\t\tREG_DEP_ANTI);\n+\t\t  add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,\n+\t\t\t\t\t\tREG_DEP_ANTI);\n+\t\t  add_dependence_list_and_free\n+\t\t    (deps, insn, &reg_last->clobbers, 0, REG_DEP_OUTPUT);\n+\t\t  \n+\t\t  if (!deps->readonly)\n+\t\t    {\n+\t\t      reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n+\t\t      reg_last->clobbers_length = 0;\n+\t\t      reg_last->uses_length = 0;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  add_dependence_list (insn, reg_last->sets, 0, REG_DEP_OUTPUT);\n+\t\t  add_dependence_list (insn, reg_last->implicit_sets, 0,\n+\t\t\t\t       REG_DEP_ANTI);\n+\t\t  add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n+\t\t}\n+\t      \n+\t      if (!deps->readonly)\n+\t\t{\n+\t\t  reg_last->clobbers_length++;\n+\t\t  reg_last->clobbers\n+\t\t    = alloc_INSN_LIST (insn, reg_last->clobbers);\n+\t\t}\n+\t    }\n+\t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_sets, 0, i, rsi)\n+\t    {\n+\t      struct deps_reg *reg_last = &deps->reg_last[i];\n+\t      \n+\t      add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n+\t\t\t\t\t    REG_DEP_OUTPUT);\n+\t      add_dependence_list_and_free (deps, insn,\n+\t\t\t\t\t    &reg_last->implicit_sets,\n+\t\t\t\t\t    0, REG_DEP_ANTI);\n+\t      add_dependence_list_and_free (deps, insn, &reg_last->clobbers, 0,\n+\t\t\t\t\t    REG_DEP_OUTPUT);\n+\t      add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,\n+\t\t\t\t\t    REG_DEP_ANTI);\n+\t      \n+\t      if (!deps->readonly)\n+\t\t{\n+\t\t  reg_last->sets = alloc_INSN_LIST (insn, reg_last->sets);\n+\t\t  reg_last->uses_length = 0;\n+\t\t  reg_last->clobbers_length = 0;\n+\t\t  CLEAR_REGNO_REG_SET (&deps->reg_conditional_sets, i);\n+\t\t}\n+\t    }\n+\t}\n     }\n \n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (implicit_reg_pending_clobbers, i))\n+      {\n+\tstruct deps_reg *reg_last = &deps->reg_last[i];\n+\tadd_dependence_list (insn, reg_last->sets, 0, REG_DEP_ANTI);\n+\tadd_dependence_list (insn, reg_last->clobbers, 0, REG_DEP_ANTI);\n+\tadd_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n+\t\n+\tif (!deps->readonly)\n+\t  reg_last->implicit_sets\n+\t    = alloc_INSN_LIST (insn, reg_last->implicit_sets);\n+      }\n+\n   if (!deps->readonly)\n     {\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_uses);\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_clobbers);\n       IOR_REG_SET (&deps->reg_last_in_use, reg_pending_sets);\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (implicit_reg_pending_uses, i)\n+\t    || TEST_HARD_REG_BIT (implicit_reg_pending_clobbers, i))\n+\t  SET_REGNO_REG_SET (&deps->reg_last_in_use, i);\n \n       /* Set up the pending barrier found.  */\n       deps->last_reg_pending_barrier = reg_pending_barrier;\n@@ -2542,6 +2939,8 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n   CLEAR_REG_SET (reg_pending_uses);\n   CLEAR_REG_SET (reg_pending_clobbers);\n   CLEAR_REG_SET (reg_pending_sets);\n+  CLEAR_HARD_REG_SET (implicit_reg_pending_clobbers);\n+  CLEAR_HARD_REG_SET (implicit_reg_pending_uses);\n \n   /* Add dependencies if a scheduling barrier was found.  */\n   if (reg_pending_barrier)\n@@ -2554,12 +2953,14 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list (insn, reg_last->uses, 0, REG_DEP_ANTI);\n-\t      add_dependence_list\n-\t\t(insn, reg_last->sets, 0,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n-\t      add_dependence_list\n-\t\t(insn, reg_last->clobbers, 0,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->sets, 0,\n+\t\t\t\t   reg_pending_barrier == TRUE_BARRIER\n+\t\t\t\t   ? REG_DEP_TRUE : REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->implicit_sets, 0,\n+\t\t\t\t   REG_DEP_ANTI);\n+\t      add_dependence_list (insn, reg_last->clobbers, 0,\n+\t\t\t\t   reg_pending_barrier == TRUE_BARRIER\n+\t\t\t\t   ? REG_DEP_TRUE : REG_DEP_ANTI);\n \t    }\n \t}\n       else\n@@ -2569,12 +2970,15 @@ sched_analyze_insn (struct deps *deps, rtx x, rtx insn)\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n \t      add_dependence_list_and_free (deps, insn, &reg_last->uses, 0,\n \t\t\t\t\t    REG_DEP_ANTI);\n-\t      add_dependence_list_and_free\n-\t\t(deps, insn, &reg_last->sets, 0,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n-\t      add_dependence_list_and_free\n-\t\t(deps, insn, &reg_last->clobbers, 0,\n-\t\t reg_pending_barrier == TRUE_BARRIER ? REG_DEP_TRUE : REG_DEP_ANTI);\n+\t      add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n+\t\t\t\t\t    reg_pending_barrier == TRUE_BARRIER\n+\t\t\t\t\t    ? REG_DEP_TRUE : REG_DEP_ANTI);\n+\t      add_dependence_list_and_free (deps, insn,\n+\t\t\t\t\t    &reg_last->implicit_sets, 0,\n+\t\t\t\t\t    REG_DEP_ANTI);\n+\t      add_dependence_list_and_free (deps, insn, &reg_last->clobbers, 0,\n+\t\t\t\t\t    reg_pending_barrier == TRUE_BARRIER\n+\t\t\t\t\t    ? REG_DEP_TRUE : REG_DEP_ANTI);\n \n               if (!deps->readonly)\n                 {\n@@ -2750,7 +3154,7 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n             if (global_regs[i])\n               {\n                 SET_REGNO_REG_SET (reg_pending_sets, i);\n-                SET_REGNO_REG_SET (reg_pending_uses, i);\n+                SET_HARD_REG_BIT (implicit_reg_pending_uses, i);\n               }\n           /* Other call-clobbered hard regs may be clobbered.\n              Since we only have a choice between 'might be clobbered'\n@@ -2763,7 +3167,7 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n              by the function, but it is certain that the stack pointer\n              is among them, but be conservative.  */\n             else if (fixed_regs[i])\n-              SET_REGNO_REG_SET (reg_pending_uses, i);\n+\t      SET_HARD_REG_BIT (implicit_reg_pending_uses, i);\n           /* The frame pointer is normally not used by the function\n              itself, but by the debugger.  */\n           /* ??? MIPS o32 is an exception.  It uses the frame pointer\n@@ -2772,7 +3176,7 @@ deps_analyze_insn (struct deps *deps, rtx insn)\n             else if (i == FRAME_POINTER_REGNUM\n                      || (i == HARD_FRAME_POINTER_REGNUM\n                          && (! reload_completed || frame_pointer_needed)))\n-              SET_REGNO_REG_SET (reg_pending_uses, i);\n+\t      SET_HARD_REG_BIT (implicit_reg_pending_uses, i);\n         }\n \n       /* For each insn which shouldn't cross a call, add a dependence\n@@ -2988,6 +3392,8 @@ free_deps (struct deps *deps)\n \tfree_INSN_LIST_list (&reg_last->uses);\n       if (reg_last->sets)\n \tfree_INSN_LIST_list (&reg_last->sets);\n+      if (reg_last->implicit_sets)\n+\tfree_INSN_LIST_list (&reg_last->implicit_sets);\n       if (reg_last->clobbers)\n \tfree_INSN_LIST_list (&reg_last->clobbers);\n     }\n@@ -3025,9 +3431,12 @@ remove_from_deps (struct deps *deps, rtx insn)\n \tremove_from_dependence_list (insn, &reg_last->uses);\n       if (reg_last->sets)\n \tremove_from_dependence_list (insn, &reg_last->sets);\n+      if (reg_last->implicit_sets)\n+\tremove_from_dependence_list (insn, &reg_last->implicit_sets);\n       if (reg_last->clobbers)\n \tremove_from_dependence_list (insn, &reg_last->clobbers);\n-      if (!reg_last->uses && !reg_last->sets && !reg_last->clobbers)\n+      if (!reg_last->uses && !reg_last->sets && !reg_last->implicit_sets\n+\t  && !reg_last->clobbers)\n         CLEAR_REGNO_REG_SET (&deps->reg_last_in_use, i);\n     }\n \n@@ -3167,6 +3576,8 @@ sched_deps_finish (void)\n void\n init_deps_global (void)\n {\n+  CLEAR_HARD_REG_SET (implicit_reg_pending_clobbers);\n+  CLEAR_HARD_REG_SET (implicit_reg_pending_uses);\n   reg_pending_sets = ALLOC_REG_SET (&reg_obstack);\n   reg_pending_clobbers = ALLOC_REG_SET (&reg_obstack);\n   reg_pending_uses = ALLOC_REG_SET (&reg_obstack);"}, {"sha": "de780e5e395cabdc5a755f0eb6bc260015ecec8f", "filename": "gcc/sched-int.h", "status": "modified", "additions": 84, "deletions": 5, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-int.h?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -441,6 +441,7 @@ struct deps_reg\n {\n   rtx uses;\n   rtx sets;\n+  rtx implicit_sets;\n   rtx clobbers;\n   int uses_length;\n   int clobbers_length;\n@@ -642,6 +643,14 @@ extern spec_info_t spec_info;\n \n extern struct haifa_sched_info *current_sched_info;\n \n+/* Do register pressure sensitive insn scheduling if the flag is set\n+   up.  */\n+extern bool sched_pressure_p;\n+\n+/* Map regno -> its cover class.  The map defined only when\n+   SCHED_PRESSURE_P is true.  */\n+extern enum reg_class *sched_regno_cover_class;\n+\n /* Indexed by INSN_UID, the collection of all data associated with\n    a single instruction.  */\n \n@@ -687,6 +696,52 @@ struct _haifa_deps_insn_data\n   unsigned int cant_move : 1;\n };\n \n+/* Bits used for storing values of the fields in the following\n+   structure.  */\n+#define INCREASE_BITS 8\n+\n+/* The structure describes how the corresponding insn increases the\n+   register pressure for each cover class.  */\n+struct reg_pressure_data\n+{\n+  /* Pressure increase for given class because of clobber.  */\n+  unsigned int clobber_increase : INCREASE_BITS;\n+  /* Increase in register pressure for given class because of register\n+     sets. */\n+  unsigned int set_increase : INCREASE_BITS;\n+  /* Pressure increase for given class because of unused register\n+     set.  */\n+  unsigned int unused_set_increase : INCREASE_BITS;\n+  /* Pressure change: #sets - #deaths.  */\n+  int change : INCREASE_BITS;\n+};\n+\n+/* The following structure describes usage of registers by insns.  */\n+struct reg_use_data\n+{\n+  /* Regno used in the insn.  */\n+  int regno;\n+  /* Insn using the regno.  */\n+  rtx insn;\n+  /* Cyclic list of elements with the same regno.  */\n+  struct reg_use_data *next_regno_use;\n+  /* List of elements with the same insn.  */\n+  struct reg_use_data *next_insn_use;\n+};\n+\n+/* The following structure describes used sets of registers by insns.\n+   Registers are pseudos whose cover class is not NO_REGS or hard\n+   registers available for allocations.  */\n+struct reg_set_data\n+{\n+  /* Regno used in the insn.  */\n+  int regno;\n+  /* Insn setting the regno.  */\n+  rtx insn;\n+  /* List of elements with the same insn.  */\n+  struct reg_set_data *next_insn_set;\n+};\n+\n struct _haifa_insn_data\n {\n   /* We can't place 'struct _deps_list' into h_i_d instead of deps_list_t\n@@ -712,10 +767,6 @@ struct _haifa_insn_data\n \n   short cost;\n \n-  /* This weight is an estimation of the insn's contribution to\n-     register pressure.  */\n-  short reg_weight;\n-\n   /* Set if there's DEF-USE dependence between some speculatively\n      moved load insn and this one.  */\n   unsigned int fed_by_spec_load : 1;\n@@ -740,6 +791,26 @@ struct _haifa_insn_data\n \n   /* Original pattern of the instruction.  */\n   rtx orig_pat;\n+\n+  /* The following array contains info how the insn increases register\n+     pressure.  There is an element for each cover class of pseudos\n+     referenced in insns.  */\n+  struct reg_pressure_data *reg_pressure;\n+  /* The following array contains maximal reg pressure between last\n+     scheduled insn and given insn.  There is an element for each\n+     cover class of pseudos referenced in insns.  This info updated\n+     after scheduling each insn for each insn between the two\n+     mentioned insns.  */\n+  int *max_reg_pressure;\n+  /* The following list contains info about used pseudos and hard\n+     registers available for allocation.  */\n+  struct reg_use_data *reg_use_list;\n+  /* The following list contains info about set pseudos and hard\n+     registers available for allocation.  */\n+  struct reg_set_data *reg_set_list;\n+  /* Info about how scheduling the insn changes cost of register\n+     pressure excess (between source and target).  */\n+  int reg_pressure_excess_cost_change;\n };\n \n typedef struct _haifa_insn_data haifa_insn_data_def;\n@@ -755,7 +826,12 @@ extern VEC(haifa_insn_data_def, heap) *h_i_d;\n /* Accessor macros for h_i_d.  There are more in haifa-sched.c and\n    sched-rgn.c.  */\n #define INSN_PRIORITY(INSN) (HID (INSN)->priority)\n-#define INSN_REG_WEIGHT(INSN) (HID (INSN)->reg_weight)\n+#define INSN_REG_PRESSURE(INSN) (HID (INSN)->reg_pressure)\n+#define INSN_MAX_REG_PRESSURE(INSN) (HID (INSN)->max_reg_pressure)\n+#define INSN_REG_USE_LIST(INSN) (HID (INSN)->reg_use_list)\n+#define INSN_REG_SET_LIST(INSN) (HID (INSN)->reg_set_list)\n+#define INSN_REG_PRESSURE_EXCESS_COST_CHANGE(INSN) \\\n+  (HID (INSN)->reg_pressure_excess_cost_change)\n #define INSN_PRIORITY_STATUS(INSN) (HID (INSN)->priority_status)\n \n typedef struct _haifa_deps_insn_data haifa_deps_insn_data_def;\n@@ -1153,7 +1229,9 @@ extern void extend_dependency_caches (int, bool);\n \n extern void debug_ds (ds_t);\n \n+\n /* Functions in haifa-sched.c.  */\n+extern void sched_init_region_reg_pressure_info (void);\n extern int haifa_classify_insn (const_rtx);\n extern void get_ebb_head_tail (basic_block, basic_block, rtx *, rtx *);\n extern int no_real_insns_p (const_rtx, const_rtx);\n@@ -1163,6 +1241,7 @@ extern int dep_cost_1 (dep_t, dw_t);\n extern int dep_cost (dep_t);\n extern int set_priorities (rtx, rtx);\n \n+extern void sched_setup_bb_reg_pressure_info (basic_block, rtx);\n extern void schedule_block (basic_block *);\n \n extern int cycle_issued_insns;"}, {"sha": "ff559adcda53fa685b4c734d6de3ea67c9bfdee3", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=ce18efcb54ff5d3de8b035aa2cd34db4715b8bfd", "patch": "@@ -2613,6 +2613,8 @@ deps_join (struct deps *succ_deps, struct deps *pred_deps)\n \n       succ_rl->uses = concat_INSN_LIST (pred_rl->uses, succ_rl->uses);\n       succ_rl->sets = concat_INSN_LIST (pred_rl->sets, succ_rl->sets);\n+      succ_rl->implicit_sets\n+\t= concat_INSN_LIST (pred_rl->implicit_sets, succ_rl->implicit_sets);\n       succ_rl->clobbers = concat_INSN_LIST (pred_rl->clobbers,\n                                             succ_rl->clobbers);\n       succ_rl->uses_length += pred_rl->uses_length;\n@@ -2690,12 +2692,14 @@ propagate_deps (int bb, struct deps *pred_deps)\n    bb's successors.\n \n    Specifically for reg-reg data dependences, the block insns are\n-   scanned by sched_analyze () top-to-bottom.  Two lists are\n+   scanned by sched_analyze () top-to-bottom.  Three lists are\n    maintained by sched_analyze (): reg_last[].sets for register DEFs,\n-   and reg_last[].uses for register USEs.\n+   reg_last[].implicit_sets for implicit hard register DEFs, and\n+   reg_last[].uses for register USEs.\n \n    When analysis is completed for bb, we update for its successors:\n    ;  - DEFS[succ] = Union (DEFS [succ], DEFS [bb])\n+   ;  - IMPLICIT_DEFS[succ] = Union (IMPLICIT_DEFS [succ], IMPLICIT_DEFS [bb])\n    ;  - USES[succ] = Union (USES [succ], DEFS [bb])\n \n    The mechanism for computing mem-mem data dependence is very\n@@ -2934,6 +2938,28 @@ schedule_region (int rgn)\n \n   sched_extend_ready_list (rgn_n_insns);\n \n+  if (sched_pressure_p)\n+    {\n+      sched_init_region_reg_pressure_info ();\n+      for (bb = 0; bb < current_nr_blocks; bb++)\n+\t{\n+\t  basic_block first_bb, last_bb;\n+\t  rtx head, tail;\n+\t  \n+\t  first_bb = EBB_FIRST_BB (bb);\n+\t  last_bb = EBB_LAST_BB (bb);\n+\t  \n+\t  get_ebb_head_tail (first_bb, last_bb, &head, &tail);\n+\t  \n+\t  if (no_real_insns_p (head, tail))\n+\t    {\n+\t      gcc_assert (first_bb == last_bb);\n+\t      continue;\n+\t    }\n+\t  sched_setup_bb_reg_pressure_info (first_bb, PREV_INSN (head));\n+\t}\n+    }\n+\n   /* Now we can schedule all blocks.  */\n   for (bb = 0; bb < current_nr_blocks; bb++)\n     {"}]}