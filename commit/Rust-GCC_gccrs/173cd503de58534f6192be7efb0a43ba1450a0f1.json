{"sha": "173cd503de58534f6192be7efb0a43ba1450a0f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTczY2Q1MDNkZTU4NTM0ZjYxOTJiZTdlZmIwYTQzYmExNDUwYTBmMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-24T02:55:16Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-24T02:55:16Z"}, "message": "x\n\nFrom-SVN: r13974", "tree": {"sha": "d2ead87e504f550cbdfbdf0d0fa9f6c7e39bcc7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2ead87e504f550cbdfbdf0d0fa9f6c7e39bcc7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/173cd503de58534f6192be7efb0a43ba1450a0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173cd503de58534f6192be7efb0a43ba1450a0f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/173cd503de58534f6192be7efb0a43ba1450a0f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/173cd503de58534f6192be7efb0a43ba1450a0f1/comments", "author": null, "committer": null, "parents": [{"sha": "4c7428133bb93c325331630f92728172de304493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c7428133bb93c325331630f92728172de304493", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c7428133bb93c325331630f92728172de304493"}], "stats": {"total": 33, "additions": 25, "deletions": 8}, "files": [{"sha": "696479a93b4053291c131da27257962d2f5cfd18", "filename": "gcc/calls.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=173cd503de58534f6192be7efb0a43ba1450a0f1", "patch": "@@ -1025,22 +1025,26 @@ expand_call (exp, target, ignore)\n #endif\n \t  )\n \t{\n+\t  /* If we're compiling a thunk, pass through invisible\n+             references instead of making a copy.  */\n+\t  if (current_function_is_thunk\n #ifdef FUNCTION_ARG_CALLEE_COPIES\n-\t  if (FUNCTION_ARG_CALLEE_COPIES (args_so_far, TYPE_MODE (type), type,\n-\t\t\t\t\t  argpos < n_named_args)\n-\t      /* If it's in a register, we must make a copy of it too.  */\n-\t      /* ??? Is this a sufficient test?  Is there a better one? */\n-\t      && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n-\t\t   && REG_P (DECL_RTL (args[i].tree_value)))\n-\t      && ! TREE_ADDRESSABLE (type))\n+\t      || (FUNCTION_ARG_CALLEE_COPIES (args_so_far, TYPE_MODE (type),\n+\t\t\t\t\t     type, argpos < n_named_args)\n+\t\t  /* If it's in a register, we must make a copy of it too.  */\n+\t\t  /* ??? Is this a sufficient test?  Is there a better one? */\n+\t\t  && !(TREE_CODE (args[i].tree_value) == VAR_DECL\n+\t\t       && REG_P (DECL_RTL (args[i].tree_value)))\n+\t\t  && ! TREE_ADDRESSABLE (type))\n+#endif\n+\t      )\n \t    {\n \t      args[i].tree_value = build1 (ADDR_EXPR,\n \t\t\t\t\t   build_pointer_type (type),\n \t\t\t\t\t   args[i].tree_value);\n \t      type = build_pointer_type (type);\n \t    }\n \t  else\n-#endif\n \t    {\n \t      /* We make a copy of the object and pass the address to the\n \t\t function being called.  */"}, {"sha": "94decda09d540e6c9be278d1180989ab26fc883e", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=173cd503de58534f6192be7efb0a43ba1450a0f1", "patch": "@@ -392,3 +392,7 @@ extern int current_function_has_nonlocal_label;\n    function.  */\n \n extern int current_function_has_nonlocal_goto;\n+\n+/* Nonzero if the current function is a thunk, so we should try to cut\n+   corners where we can.  */\n+int current_function_is_thunk;"}, {"sha": "750f33396dbbc545a1093c78aaf167a242813c44", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=173cd503de58534f6192be7efb0a43ba1450a0f1", "patch": "@@ -132,6 +132,11 @@ int current_function_has_nonlocal_goto;\n \n int current_function_contains_functions;\n \n+/* Nonzero if the current function is a thunk (a lightweight function that\n+   just adjusts one of its arguments and forwards to another function), so\n+   we should try to cut corners where we can.  */\n+int current_function_is_thunk;\n+\n /* Nonzero if function being compiled can call alloca,\n    either as a subroutine or builtin.  */\n \n@@ -489,6 +494,7 @@ push_function_context_to (context)\n   p->has_nonlocal_label = current_function_has_nonlocal_label;\n   p->has_nonlocal_goto = current_function_has_nonlocal_goto;\n   p->contains_functions = current_function_contains_functions;\n+  p->is_thunk = current_function_is_thunk;\n   p->args_size = current_function_args_size;\n   p->pretend_args_size = current_function_pretend_args_size;\n   p->arg_offset_rtx = current_function_arg_offset_rtx;\n@@ -568,6 +574,7 @@ pop_function_context_from (context)\n   current_function_calls_alloca = p->calls_alloca;\n   current_function_has_nonlocal_label = p->has_nonlocal_label;\n   current_function_has_nonlocal_goto = p->has_nonlocal_goto;\n+  current_function_is_thunk = p->is_thunk;\n   current_function_args_size = p->args_size;\n   current_function_pretend_args_size = p->pretend_args_size;\n   current_function_arg_offset_rtx = p->arg_offset_rtx;\n@@ -4971,6 +4978,7 @@ init_function_start (subr, filename, line)\n   current_function_has_nonlocal_label = 0;\n   current_function_has_nonlocal_goto = 0;\n   current_function_contains_functions = 0;\n+  current_function_is_thunk = 0;\n \n   current_function_returns_pcc_struct = 0;\n   current_function_returns_struct = 0;"}, {"sha": "f54622fa71d1340a9a480e411fddfec45bf84189", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/173cd503de58534f6192be7efb0a43ba1450a0f1/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=173cd503de58534f6192be7efb0a43ba1450a0f1", "patch": "@@ -78,6 +78,7 @@ struct function\n   int has_nonlocal_label;\n   int has_nonlocal_goto;\n   int contains_functions;\n+  int is_thunk;\n   rtx nonlocal_goto_handler_slot;\n   rtx nonlocal_goto_stack_level;\n   tree nonlocal_labels;"}]}