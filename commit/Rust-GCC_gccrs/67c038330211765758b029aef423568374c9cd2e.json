{"sha": "67c038330211765758b029aef423568374c9cd2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdjMDM4MzMwMjExNzY1NzU4YjAyOWFlZjQyMzU2ODM3NGM5Y2QyZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-12-18T19:53:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-12-18T19:53:10Z"}, "message": "re PR c++/12253 ([tree-ssa] ICE on conversion to std::string inside array initialization)\n\n        PR c++/12253\n        * init.c (build_vec_init): Initialization of an element from\n        an initializer list is also a full-expression.\n\n        * parser.c, pt.c, semantics.c: Rename constant_expression_p\n        to integral_constant_expression_p.\n\nFrom-SVN: r74790", "tree": {"sha": "1a1f043dc430c24f12ce79de3e35296f79a7c965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a1f043dc430c24f12ce79de3e35296f79a7c965"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67c038330211765758b029aef423568374c9cd2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67c038330211765758b029aef423568374c9cd2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67c038330211765758b029aef423568374c9cd2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67c038330211765758b029aef423568374c9cd2e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d11994a8c39186392711d06554dc5baab5dc3b72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d11994a8c39186392711d06554dc5baab5dc3b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d11994a8c39186392711d06554dc5baab5dc3b72"}], "stats": {"total": 201, "additions": 106, "deletions": 95}, "files": [{"sha": "78d4ee2bde3a1afe9dd58fadf2b425b7cb9da53c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=67c038330211765758b029aef423568374c9cd2e", "patch": "@@ -1,3 +1,12 @@\n+2003-12-18  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/12253\n+\t* init.c (build_vec_init): Initialization of an element from\n+\tan initializer list is also a full-expression.\n+\n+\t* parser.c, pt.c, semantics.c: Rename constant_expression_p\n+\tto integral_constant_expression_p.\n+\n 2003-12-18  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/13262"}, {"sha": "55990b542cb8efc29a1ccd1f889f08b01a50c993", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=67c038330211765758b029aef423568374c9cd2e", "patch": "@@ -2603,11 +2603,13 @@ build_vec_init (tree base, tree maxindex, tree init, int from_array)\n \n \t  num_initialized_elts++;\n \n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (IS_AGGR_TYPE (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    finish_expr_stmt (build_aggr_init (baseref, elt, 0));\n \t  else\n \t    finish_expr_stmt (build_modify_expr (baseref, NOP_EXPR,\n \t\t\t\t\t\t elt));\n+\t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n \t  finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n \t  finish_expr_stmt (build_unary_op (PREDECREMENT_EXPR, iterator, 0));"}, {"sha": "d2f60544377e878694ea385a6f673d9aa96ff0d0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=67c038330211765758b029aef423568374c9cd2e", "patch": "@@ -1218,17 +1218,17 @@ typedef struct cp_parser GTY(())\n   \n   /* TRUE if we are parsing an integral constant-expression.  See\n      [expr.const] for a precise definition.  */\n-  bool constant_expression_p;\n+  bool integral_constant_expression_p;\n \n   /* TRUE if we are parsing an integral constant-expression -- but a\n      non-constant expression should be permitted as well.  This flag\n      is used when parsing an array bound so that GNU variable-length\n      arrays are tolerated.  */\n-  bool allow_non_constant_expression_p;\n+  bool allow_non_integral_constant_expression_p;\n \n   /* TRUE if ALLOW_NON_CONSTANT_EXPRESSION_P is TRUE and something has\n      been seen that makes the expression non-constant.  */\n-  bool non_constant_expression_p;\n+  bool non_integral_constant_expression_p;\n \n   /* TRUE if we are parsing the argument to \"__offsetof__\".  */\n   bool in_offsetof_p;\n@@ -1712,7 +1712,7 @@ static void cp_parser_check_for_definition_in_return_type\n   (tree, int);\n static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree);\n-static tree cp_parser_non_constant_expression\n+static tree cp_parser_non_integral_constant_expression\n   (const char *);\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n@@ -1915,7 +1915,7 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n    constant-expression.  Returns ERROR_MARK_NODE.  */\n \n static tree\n-cp_parser_non_constant_expression (const char *thing)\n+cp_parser_non_integral_constant_expression (const char *thing)\n {\n   error (\"%s cannot appear in a constant-expression\", thing);\n   return error_mark_node;\n@@ -2229,9 +2229,9 @@ cp_parser_new (void)\n   parser->default_arg_ok_p = true;\n   \n   /* We are not parsing a constant-expression.  */\n-  parser->constant_expression_p = false;\n-  parser->allow_non_constant_expression_p = false;\n-  parser->non_constant_expression_p = false;\n+  parser->integral_constant_expression_p = false;\n+  parser->allow_non_integral_constant_expression_p = false;\n+  parser->non_integral_constant_expression_p = false;\n \n   /* We are not parsing offsetof.  */\n   parser->in_offsetof_p = false;\n@@ -2458,11 +2458,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n-\t  if (parser->constant_expression_p)\n+\t  if (parser->integral_constant_expression_p)\n \t    {\n-\t      if (!parser->allow_non_constant_expression_p)\n-\t\treturn cp_parser_non_constant_expression (\"`this'\");\n-\t      parser->non_constant_expression_p = true;\n+\t      if (!parser->allow_non_integral_constant_expression_p)\n+\t\treturn cp_parser_non_integral_constant_expression (\"`this'\");\n+\t      parser->non_integral_constant_expression_p = true;\n \t    }\n \t  return finish_this_expr ();\n \n@@ -2505,11 +2505,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n-\t    if (parser->constant_expression_p)\n+\t    if (parser->integral_constant_expression_p)\n \t      {\n-\t\tif (!parser->allow_non_constant_expression_p)\n-\t\t  return cp_parser_non_constant_expression (\"`va_arg'\");\n-\t\tparser->non_constant_expression_p = true;\n+\t\tif (!parser->allow_non_integral_constant_expression_p)\n+\t\t  return cp_parser_non_integral_constant_expression (\"`va_arg'\");\n+\t\tparser->non_integral_constant_expression_p = true;\n \t      }\n \t    return build_x_va_arg (expression, type);\n \t  }\n@@ -2613,9 +2613,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\n \tdecl = finish_id_expression (id_expression, decl, parser->scope, \n \t\t\t\t     idk, qualifying_class,\n-\t\t\t\t     parser->constant_expression_p,\n-\t\t\t\t     parser->allow_non_constant_expression_p,\n-\t\t\t\t     &parser->non_constant_expression_p,\n+\t\t\t\t     parser->integral_constant_expression_p,\n+\t\t\t\t     parser->allow_non_integral_constant_expression_p,\n+\t\t\t\t     &parser->non_integral_constant_expression_p,\n \t\t\t\t     &error_msg);\n \tif (error_msg)\n \t  cp_parser_error (parser, error_msg);\n@@ -3426,18 +3426,18 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t/* Only type conversions to integral or enumeration types\n \t   can be used in constant-expressions.  */\n-\tif (parser->constant_expression_p\n+\tif (parser->integral_constant_expression_p\n \t    && !dependent_type_p (type)\n \t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n \t    /* A cast to pointer or reference type is allowed in the\n \t       implementation of \"offsetof\".  */\n \t    && !(parser->in_offsetof_p && POINTER_TYPE_P (type)))\n \t  {\n-\t    if (!parser->allow_non_constant_expression_p)\n-\t      return (cp_parser_non_constant_expression \n+\t    if (!parser->allow_non_integral_constant_expression_p)\n+\t      return (cp_parser_non_integral_constant_expression \n \t\t      (\"a cast to a type other than an integral or \"\n \t\t       \"enumeration type\"));\n-\t    parser->non_constant_expression_p = true;\n+\t    parser->non_integral_constant_expression_p = true;\n \t  }\n \n \tswitch (keyword)\n@@ -3676,12 +3676,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    idk = CP_ID_KIND_NONE;\n \t    /* Array references are not permitted in\n \t       constant-expressions.  */\n-\t    if (parser->constant_expression_p)\n+\t    if (parser->integral_constant_expression_p)\n \t      {\n-\t\tif (!parser->allow_non_constant_expression_p)\n+\t\tif (!parser->allow_non_integral_constant_expression_p)\n \t\t  postfix_expression \n-\t\t    = cp_parser_non_constant_expression (\"an array reference\");\n-\t\tparser->non_constant_expression_p = true;\n+\t\t    = cp_parser_non_integral_constant_expression (\"an array reference\");\n+\t\tparser->non_integral_constant_expression_p = true;\n \t      }\n \t  }\n \t  break;\n@@ -3701,15 +3701,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    \n \t    /* Function calls are not permitted in\n \t       constant-expressions.  */\n-\t    if (parser->constant_expression_p)\n+\t    if (parser->integral_constant_expression_p)\n \t      {\n-\t\tif (!parser->allow_non_constant_expression_p)\n+\t\tif (!parser->allow_non_integral_constant_expression_p)\n \t\t  {\n \t\t    postfix_expression \n-\t\t      = cp_parser_non_constant_expression (\"a function call\");\n+\t\t      = cp_parser_non_integral_constant_expression (\"a function call\");\n \t\t    break;\n \t\t  }\n-\t\tparser->non_constant_expression_p = true;\n+\t\tparser->non_integral_constant_expression_p = true;\n \t      }\n \n \t    koenig_p = false;\n@@ -3891,16 +3891,16 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t       operator.  */\n \t    parser->context->object_type = NULL_TREE;\n \t    /* These operators may not appear in constant-expressions.  */\n-\t    if (parser->constant_expression_p\n+\t    if (parser->integral_constant_expression_p\n \t\t/* The \"->\" operator is allowed in the implementation\n \t\t   of \"offsetof\".  */\n \t\t&& !(parser->in_offsetof_p && token_type == CPP_DEREF))\n \t      {\n-\t\tif (!parser->allow_non_constant_expression_p)\n+\t\tif (!parser->allow_non_integral_constant_expression_p)\n \t\t  postfix_expression \n-\t\t    = (cp_parser_non_constant_expression \n+\t\t    = (cp_parser_non_integral_constant_expression \n \t\t       (token_type == CPP_DEREF ? \"'->'\" : \"`.'\"));\n-\t\tparser->non_constant_expression_p = true;\n+\t\tparser->non_integral_constant_expression_p = true;\n \t      }\n \t  }\n \t  break;\n@@ -3914,12 +3914,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTINCREMENT_EXPR);\n \t  /* Increments may not appear in constant-expressions.  */\n-\t  if (parser->constant_expression_p)\n+\t  if (parser->integral_constant_expression_p)\n \t    {\n-\t      if (!parser->allow_non_constant_expression_p)\n+\t      if (!parser->allow_non_integral_constant_expression_p)\n \t\tpostfix_expression \n-\t\t  = cp_parser_non_constant_expression (\"an increment\");\n-\t      parser->non_constant_expression_p = true;\n+\t\t  = cp_parser_non_integral_constant_expression (\"an increment\");\n+\t      parser->non_integral_constant_expression_p = true;\n \t    }\n \t  idk = CP_ID_KIND_NONE;\n \t  break;\n@@ -3933,12 +3933,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    = finish_increment_expr (postfix_expression, \n \t\t\t\t     POSTDECREMENT_EXPR);\n \t  /* Decrements may not appear in constant-expressions.  */\n-\t  if (parser->constant_expression_p)\n+\t  if (parser->integral_constant_expression_p)\n \t    {\n-\t      if (!parser->allow_non_constant_expression_p)\n+\t      if (!parser->allow_non_integral_constant_expression_p)\n \t\tpostfix_expression \n-\t\t  = cp_parser_non_constant_expression (\"a decrement\");\n-\t      parser->non_constant_expression_p = true;\n+\t\t  = cp_parser_non_integral_constant_expression (\"a decrement\");\n+\t      parser->non_integral_constant_expression_p = true;\n \t    }\n \t  idk = CP_ID_KIND_NONE;\n \t  break;\n@@ -4323,11 +4323,11 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  abort ();\n \t}\n \n-      if (non_constant_p && parser->constant_expression_p)\n+      if (non_constant_p && parser->integral_constant_expression_p)\n \t{\n-\t  if (!parser->allow_non_constant_expression_p)\n-\t    return cp_parser_non_constant_expression (non_constant_p);\n-\t  parser->non_constant_expression_p = true;\n+\t  if (!parser->allow_non_integral_constant_expression_p)\n+\t    return cp_parser_non_integral_constant_expression (non_constant_p);\n+\t  parser->non_integral_constant_expression_p = true;\n \t}\n \n       return expression;\n@@ -4740,15 +4740,15 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \n \t  /* Only type conversions to integral or enumeration types\n \t     can be used in constant-expressions.  */\n-\t  if (parser->constant_expression_p\n+\t  if (parser->integral_constant_expression_p\n \t      && !dependent_type_p (type)\n \t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n \t    {\n-\t      if (!parser->allow_non_constant_expression_p)\n-\t\treturn (cp_parser_non_constant_expression \n+\t      if (!parser->allow_non_integral_constant_expression_p)\n+\t\treturn (cp_parser_non_integral_constant_expression \n \t\t\t(\"a casts to a type other than an integral or \"\n \t\t\t \"enumeration type\"));\n-\t      parser->non_constant_expression_p = true;\n+\t      parser->non_integral_constant_expression_p = true;\n \t    }\n \t  /* Perform the cast.  */\n \t  expr = build_c_cast (type, expr);\n@@ -5102,11 +5102,11 @@ cp_parser_assignment_expression (cp_parser* parser)\n \t      rhs = cp_parser_assignment_expression (parser);\n \t      /* An assignment may not appear in a\n \t\t constant-expression.  */\n-\t      if (parser->constant_expression_p)\n+\t      if (parser->integral_constant_expression_p)\n \t\t{\n-\t\t  if (!parser->allow_non_constant_expression_p)\n-\t\t    return cp_parser_non_constant_expression (\"an assignment\");\n-\t\t  parser->non_constant_expression_p = true;\n+\t\t  if (!parser->allow_non_integral_constant_expression_p)\n+\t\t    return cp_parser_non_integral_constant_expression (\"an assignment\");\n+\t\t  parser->non_integral_constant_expression_p = true;\n \t\t}\n \t      /* Build the assignment expression.  */\n \t      expr = build_x_modify_expr (expr, \n@@ -5245,12 +5245,12 @@ cp_parser_expression (cp_parser* parser)\n       /* Consume the `,'.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* A comma operator cannot appear in a constant-expression.  */\n-      if (parser->constant_expression_p)\n+      if (parser->integral_constant_expression_p)\n \t{\n-\t  if (!parser->allow_non_constant_expression_p)\n+\t  if (!parser->allow_non_integral_constant_expression_p)\n \t    expression \n-\t      = cp_parser_non_constant_expression (\"a comma operator\");\n-\t  parser->non_constant_expression_p = true;\n+\t      = cp_parser_non_integral_constant_expression (\"a comma operator\");\n+\t  parser->non_integral_constant_expression_p = true;\n \t}\n     }\n \n@@ -5272,9 +5272,9 @@ cp_parser_constant_expression (cp_parser* parser,\n \t\t\t       bool allow_non_constant_p,\n \t\t\t       bool *non_constant_p)\n {\n-  bool saved_constant_expression_p;\n-  bool saved_allow_non_constant_expression_p;\n-  bool saved_non_constant_expression_p;\n+  bool saved_integral_constant_expression_p;\n+  bool saved_allow_non_integral_constant_expression_p;\n+  bool saved_non_integral_constant_expression_p;\n   tree expression;\n \n   /* It might seem that we could simply parse the\n@@ -5295,14 +5295,14 @@ cp_parser_constant_expression (cp_parser* parser,\n      will fold this operation to an INTEGER_CST for `3'.  */\n \n   /* Save the old settings.  */\n-  saved_constant_expression_p = parser->constant_expression_p;\n-  saved_allow_non_constant_expression_p \n-    = parser->allow_non_constant_expression_p;\n-  saved_non_constant_expression_p = parser->non_constant_expression_p;\n+  saved_integral_constant_expression_p = parser->integral_constant_expression_p;\n+  saved_allow_non_integral_constant_expression_p \n+    = parser->allow_non_integral_constant_expression_p;\n+  saved_non_integral_constant_expression_p = parser->non_integral_constant_expression_p;\n   /* We are now parsing a constant-expression.  */\n-  parser->constant_expression_p = true;\n-  parser->allow_non_constant_expression_p = allow_non_constant_p;\n-  parser->non_constant_expression_p = false;\n+  parser->integral_constant_expression_p = true;\n+  parser->allow_non_integral_constant_expression_p = allow_non_constant_p;\n+  parser->non_integral_constant_expression_p = false;\n   /* Although the grammar says \"conditional-expression\", we parse an\n      \"assignment-expression\", which also permits \"throw-expression\"\n      and the use of assignment operators.  In the case that\n@@ -5314,12 +5314,12 @@ cp_parser_constant_expression (cp_parser* parser,\n      constant.  */\n   expression = cp_parser_assignment_expression (parser);\n   /* Restore the old settings.  */\n-  parser->constant_expression_p = saved_constant_expression_p;\n-  parser->allow_non_constant_expression_p \n-    = saved_allow_non_constant_expression_p;\n+  parser->integral_constant_expression_p = saved_integral_constant_expression_p;\n+  parser->allow_non_integral_constant_expression_p \n+    = saved_allow_non_integral_constant_expression_p;\n   if (allow_non_constant_p)\n-    *non_constant_p = parser->non_constant_expression_p;\n-  parser->non_constant_expression_p = saved_non_constant_expression_p;\n+    *non_constant_p = parser->non_integral_constant_expression_p;\n+  parser->non_integral_constant_expression_p = saved_non_integral_constant_expression_p;\n \n   return expression;\n }\n@@ -14419,7 +14419,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   static const char *format;\n   tree expr = NULL_TREE;\n   const char *saved_message;\n-  bool saved_constant_expression_p;\n+  bool saved_integral_constant_expression_p;\n \n   /* Initialize FORMAT the first time we get here.  */\n   if (!format)\n@@ -14438,8 +14438,8 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n \n   /* The restrictions on constant-expressions do not apply inside\n      sizeof expressions.  */\n-  saved_constant_expression_p = parser->constant_expression_p;\n-  parser->constant_expression_p = false;\n+  saved_integral_constant_expression_p = parser->integral_constant_expression_p;\n+  parser->integral_constant_expression_p = false;\n \n   /* Do not actually evaluate the expression.  */\n   ++skip_evaluation;\n@@ -14486,7 +14486,7 @@ cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n   free ((char *) parser->type_definition_forbidden_message);\n   /* And restore the old one.  */\n   parser->type_definition_forbidden_message = saved_message;\n-  parser->constant_expression_p = saved_constant_expression_p;\n+  parser->integral_constant_expression_p = saved_integral_constant_expression_p;\n \n   return expr;\n }"}, {"sha": "9fbaa901519e266a3069141ddfeae28340b5d74c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=67c038330211765758b029aef423568374c9cd2e", "patch": "@@ -8052,7 +8052,7 @@ tsubst_copy_and_build (tree t,\n \ttree decl;\n \tcp_id_kind idk;\n \ttree qualifying_class;\n-\tbool non_constant_expression_p;\n+\tbool non_integral_constant_expression_p;\n \tconst char *error_msg;\n \n \tif (IDENTIFIER_TYPENAME_P (t))\n@@ -8072,9 +8072,9 @@ tsubst_copy_and_build (tree t,\n \tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n \t\t\t\t     &qualifying_class,\n-\t\t\t\t     /*constant_expression_p=*/false,\n-\t\t\t\t     /*allow_non_constant_expression_p=*/false,\n-\t\t\t\t     &non_constant_expression_p,\n+\t\t\t\t     /*integral_constant_expression_p=*/false,\n+\t\t\t\t     /*allow_non_integral_constant_expression_p=*/false,\n+\t\t\t\t     &non_integral_constant_expression_p,\n \t\t\t\t     &error_msg);\n \tif (error_msg)\n \t  error (error_msg);"}, {"sha": "6462c7087b91fa4ed59d5cf40aead5f9ffcf023c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67c038330211765758b029aef423568374c9cd2e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=67c038330211765758b029aef423568374c9cd2e", "patch": "@@ -2324,9 +2324,9 @@ finish_id_expression (tree id_expression,\n \t\t      tree scope,\n \t\t      cp_id_kind *idk,\n \t\t      tree *qualifying_class,\n-\t\t      bool constant_expression_p,\n-\t\t      bool allow_non_constant_expression_p,\n-\t\t      bool *non_constant_expression_p,\n+\t\t      bool integral_constant_expression_p,\n+\t\t      bool allow_non_integral_constant_expression_p,\n+\t\t      bool *non_integral_constant_expression_p,\n \t\t      const char **error_msg)\n {\n   /* Initialize the output parameters.  */\n@@ -2399,14 +2399,14 @@ finish_id_expression (tree id_expression,\n       *idk = CP_ID_KIND_NONE;\n       if (TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n \tdecl = TEMPLATE_PARM_DECL (decl);\n-      if (constant_expression_p \n+      if (integral_constant_expression_p \n \t  && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))) \n \t{\n-\t  if (!allow_non_constant_expression_p)\n+\t  if (!allow_non_integral_constant_expression_p)\n \t    error (\"template parameter `%D' of type `%T' is not allowed in \"\n \t\t   \"an integral constant expression because it is not of \"\n \t\t   \"integral or enumeration type\", decl, TREE_TYPE (decl));\n-\t  *non_constant_expression_p = true;\n+\t  *non_integral_constant_expression_p = true;\n \t}\n       return DECL_INITIAL (decl);\n     }\n@@ -2510,8 +2510,8 @@ finish_id_expression (tree id_expression,\n \t      /* Since this name was dependent, the expression isn't\n \t\t constant -- yet.  No error is issued because it might\n \t\t be constant when things are instantiated.  */\n-\t      if (constant_expression_p)\n-\t\t*non_constant_expression_p = true;\n+\t      if (integral_constant_expression_p)\n+\t\t*non_integral_constant_expression_p = true;\n \t      if (TYPE_P (scope) && dependent_type_p (scope))\n \t\treturn build_nt (SCOPE_REF, scope, id_expression);\n \t      else if (TYPE_P (scope) && DECL_P (decl))\n@@ -2527,16 +2527,16 @@ finish_id_expression (tree id_expression,\n \t  /* Since this name was dependent, the expression isn't\n \t     constant -- yet.  No error is issued because it might be\n \t     constant when things are instantiated.  */\n-\t  if (constant_expression_p)\n-\t    *non_constant_expression_p = true;\n+\t  if (integral_constant_expression_p)\n+\t    *non_integral_constant_expression_p = true;\n \t  *idk = CP_ID_KIND_UNQUALIFIED_DEPENDENT;\n \t  return id_expression;\n \t}\n \n       /* Only certain kinds of names are allowed in constant\n        expression.  Enumerators and template parameters \n        have already been handled above.  */\n-      if (constant_expression_p)\n+      if (integral_constant_expression_p)\n \t{\n \t    /* Const variables or static data members of integral or\n \t      enumeration types initialized with constant expressions\n@@ -2548,12 +2548,12 @@ finish_id_expression (tree id_expression,\n \t    ;\n \t  else\n \t    {\n-\t      if (!allow_non_constant_expression_p)\n+\t      if (!allow_non_integral_constant_expression_p)\n \t\t{\n \t\t  error (\"`%D' cannot appear in a constant-expression\", decl);\n \t\t  return error_mark_node;\n \t\t}\n-\t      *non_constant_expression_p = true;\n+\t      *non_integral_constant_expression_p = true;\n \t    }\n \t}\n       "}]}