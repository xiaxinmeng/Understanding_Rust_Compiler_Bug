{"sha": "8008b228017883a466865c19bc34ef261f7bb088", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwOGIyMjgwMTc4ODNhNDY2ODY1YzE5YmMzNGVmMjYxZjdiYjA4OA==", "commit": {"author": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-01-10T20:12:31Z"}, "committer": {"name": "Paul Eggert", "email": "eggert@gnu.org", "date": "1993-01-10T20:12:31Z"}, "message": "# Fix misspellings in comments.\n\nFrom-SVN: r3181", "tree": {"sha": "b4f2704adde3928fdd212b8b3b3dd90a2997aef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4f2704adde3928fdd212b8b3b3dd90a2997aef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8008b228017883a466865c19bc34ef261f7bb088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8008b228017883a466865c19bc34ef261f7bb088", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8008b228017883a466865c19bc34ef261f7bb088", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8008b228017883a466865c19bc34ef261f7bb088/comments", "author": null, "committer": null, "parents": [{"sha": "0e6bbe31e8932000e823fad27f174f1bb2624c04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6bbe31e8932000e823fad27f174f1bb2624c04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6bbe31e8932000e823fad27f174f1bb2624c04"}], "stats": {"total": 22, "additions": 11, "deletions": 11}, "files": [{"sha": "b70a467ca947d1b6dafec59862843a892d5fd440", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=8008b228017883a466865c19bc34ef261f7bb088", "patch": "@@ -1851,7 +1851,7 @@ field_byte_offset (decl)\n      for the declared type of the field) which it can possibly use, subject\n      to the condition that there is still enough available space remaining\n      in the containing object (when allocated at the selected point) to\n-     fully accomodate all of the bits of the bit-field itself.\n+     fully accommodate all of the bits of the bit-field itself.\n \n      This simple rule makes it obvious why GCC allocates 8 bytes for each\n      object of the structure type shown above.  When looking for a place to\n@@ -1932,16 +1932,16 @@ location_attribute (rtl)\n      don't do that.  Instead we output a zero-length location descriptor\n      value as part of the location attribute.\n \n-     A variable which has been optimized out of existance will have a\n+     A variable which has been optimized out of existence will have a\n      DECL_RTL value which denotes a pseudo-reg.\n \n      Currently, in some rare cases, variables can have DECL_RTL values\n      which look like (MEM (REG pseudo-reg#)).  These cases are due to\n      bugs elsewhere in the compiler.  We treat such cases\n-     as if the variable(s) in question had been optimized out of existance.\n+     as if the variable(s) in question had been optimized out of existence.\n \n      Note that in all cases where we wish to express the fact that a\n-     variable has been optimized out of existance, we do not simply\n+     variable has been optimized out of existence, we do not simply\n      suppress the generation of the entire location attribute because\n      the absence of a location attribute in certain kinds of DIEs is\n      used to indicate something else entirely... i.e. that the DIE"}, {"sha": "d2519c6e6e0e2c9a4f25665a3c3eec9f258009c2", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=8008b228017883a466865c19bc34ef261f7bb088", "patch": "@@ -31,7 +31,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n /* Return an rtx for the sum of X and the integer C.\n \n-   This fucntion should be used via the `plus_constant' macro.  */\n+   This function should be used via the `plus_constant' macro.  */\n \n rtx\n plus_constant_wide (x, c)"}, {"sha": "990da71476d504931095a87b76232767a9788ee2", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=8008b228017883a466865c19bc34ef261f7bb088", "patch": "@@ -1357,7 +1357,7 @@ emit_block_move (x, y, size, align)\n \t  if (code != CODE_FOR_nothing\n \t      /* We don't need MODE to be narrower than BITS_PER_HOST_WIDE_INT\n \t\t here because if SIZE is less than the mode mask, as it is\n-\t\t returned by the macro, it will definately be less than the\n+\t\t returned by the macro, it will definitely be less than the\n \t\t actual mode mask.  */\n \t      && (unsigned) INTVAL (size) <= GET_MODE_MASK (mode)\n \t      && (insn_operand_predicate[(int) code][0] == 0\n@@ -3122,7 +3122,7 @@ force_operand (value, target)\n       return expand_binop (GET_MODE (value), binoptab, tmp,\n \t\t\t   force_operand (op2, NULL_RTX),\n \t\t\t   target, 0, OPTAB_LIB_WIDEN);\n-      /* We give UNSIGNEP = 0 to expand_binop\n+      /* We give UNSIGNEDP = 0 to expand_binop\n \t because the only operations we are expanding here are signed ones.  */\n     }\n   return value;\n@@ -3974,7 +3974,7 @@ expand_expr (exp, target, tmode, modifier)\n \top0 = expand_expr (tem, NULL_RTX, VOIDmode, EXPAND_SUM);\n \n \t/* If this is a constant, put it into a register if it is a\n-\t   legimate constant and memory if it isn't.  */\n+\t   legitimate constant and memory if it isn't.  */\n \tif (CONSTANT_P (op0))\n \t  {\n \t    enum machine_mode mode = TYPE_MODE (TREE_TYPE (tem));\n@@ -7139,7 +7139,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n      unsigned comparison since zero-extension is cheaper than sign\n      extension and comparisons with zero are done as unsigned.  This is\n      the case even on machines that can do fast sign extension, since\n-     zero-extension is easier to combinen with other operations than\n+     zero-extension is easier to combine with other operations than\n      sign-extension is.  If we are comparing against a constant, we must\n      convert it to what it would look like unsigned.  */\n   if ((code == EQ || code == NE) && ! unsignedp"}, {"sha": "7238899f7732c45a2fa869a5092c249c33f069b7", "filename": "gcc/flags.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=8008b228017883a466865c19bc34ef261f7bb088", "patch": "@@ -237,7 +237,7 @@ extern int flag_fast_math;\n extern int flag_inline_functions;\n \n /* Nonzero for -fkeep-inline-functions: even if we make a function\n-   go inline everywhere, keep its defintion around for debugging\n+   go inline everywhere, keep its definition around for debugging\n    purposes.  */\n \n extern int flag_keep_inline_functions;"}, {"sha": "35c464c847707cf6f0668493579efeac28d188d5", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8008b228017883a466865c19bc34ef261f7bb088/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=8008b228017883a466865c19bc34ef261f7bb088", "patch": "@@ -2021,7 +2021,7 @@ instantiate_decls_1 (let, valid_only)\n     instantiate_decls_1 (t, valid_only);\n }\n \n-/* Subroutine of the preceeding procedures: Given RTL representing a\n+/* Subroutine of the preceding procedures: Given RTL representing a\n    decl and the size of the object, do any instantiation required.\n \n    If VALID_ONLY is non-zero, it means that the RTL should only be"}]}