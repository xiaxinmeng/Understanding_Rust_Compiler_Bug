{"sha": "df206c6e77551b7eebfa1b7995b2556ac369f4fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYyMDZjNmU3NzU1MWI3ZWViZmExYjc5OTViMjU1NmFjMzY5ZjRmZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-07-21T18:27:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-07-21T18:27:35Z"}, "message": "runtime: don't use runtime_lock in __go_get_backtrace_state\n    \n    If getSiginfo does not know how to determine the PC, it will call\n    runtime_callers. That can happen in a thread that was started by\n    non-Go code, in which case the TLS variable g will not be set, in\n    which case runtime_lock will crash.\n    \n    Avoid the problem by using atomic operations for the lock. This is OK\n    since creating a backtrace state is fast and never blocks.\n    \n    The test case is TestCgoExternalThreadSIGPROF in the runtime package\n    on a system that getSiginfo doesn't handle specially.\n    \n    Updates golang/go#20931\n    \n    Reviewed-on: https://go-review.googlesource.com/50650\n\nFrom-SVN: r250439", "tree": {"sha": "ac8824d9cde261316f55212382c6ca9eb2255bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac8824d9cde261316f55212382c6ca9eb2255bd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df206c6e77551b7eebfa1b7995b2556ac369f4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df206c6e77551b7eebfa1b7995b2556ac369f4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df206c6e77551b7eebfa1b7995b2556ac369f4fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df206c6e77551b7eebfa1b7995b2556ac369f4fd/comments", "author": null, "committer": null, "parents": [{"sha": "2401ffc3fe5f79e7a1087d8f98f5e3b8bbb1e379", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2401ffc3fe5f79e7a1087d8f98f5e3b8bbb1e379", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2401ffc3fe5f79e7a1087d8f98f5e3b8bbb1e379"}], "stats": {"total": 16, "additions": 12, "deletions": 4}, "files": [{"sha": "efb2dd474c18fd76154b0046b4d58aa1b53bdaba", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df206c6e77551b7eebfa1b7995b2556ac369f4fd/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df206c6e77551b7eebfa1b7995b2556ac369f4fd/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=df206c6e77551b7eebfa1b7995b2556ac369f4fd", "patch": "@@ -1,4 +1,4 @@\n-a9f1aeced86691de891fbf2a8c97e848faf1962e\n+b712bacd939466e66972337744983e180849c535\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "360bae695940a97c17690f8a167643de770cdc7b", "filename": "libgo/runtime/go-caller.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df206c6e77551b7eebfa1b7995b2556ac369f4fd/libgo%2Fruntime%2Fgo-caller.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df206c6e77551b7eebfa1b7995b2556ac369f4fd/libgo%2Fruntime%2Fgo-caller.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-caller.c?ref=df206c6e77551b7eebfa1b7995b2556ac369f4fd", "patch": "@@ -74,7 +74,7 @@ static void *back_state;\n \n /* A lock to control creating back_state.  */\n \n-static Lock back_state_lock;\n+static uint32 back_state_lock;\n \n /* The program arguments.  */\n \n@@ -85,7 +85,15 @@ extern Slice runtime_get_args(void);\n struct backtrace_state *\n __go_get_backtrace_state ()\n {\n-  runtime_lock (&back_state_lock);\n+  uint32 set;\n+\n+  /* We may not have a g here, so we can't use runtime_lock.  */\n+  set = 0;\n+  while (!__atomic_compare_exchange_n (&back_state_lock, &set, 1, false, __ATOMIC_ACQUIRE, __ATOMIC_RELAXED))\n+    {\n+      runtime_osyield ();\n+      set = 0;\n+    }\n   if (back_state == NULL)\n     {\n       Slice args;\n@@ -113,7 +121,7 @@ __go_get_backtrace_state ()\n \n       back_state = backtrace_create_state (filename, 1, error_callback, NULL);\n     }\n-  runtime_unlock (&back_state_lock);\n+  __atomic_store_n (&back_state_lock, 0, __ATOMIC_RELEASE);\n   return back_state;\n }\n "}]}