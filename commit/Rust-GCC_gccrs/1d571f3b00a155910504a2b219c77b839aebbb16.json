{"sha": "1d571f3b00a155910504a2b219c77b839aebbb16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1NzFmM2IwMGExNTU5MTA1MDRhMmIyMTljNzdiODM5YWViYmIxNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:56:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-11-19T10:56:37Z"}, "message": "einfo.ads, einfo.adb: Remove Is_Psected flag, no longer used\n\n\t* einfo.ads, einfo.adb: Remove Is_Psected flag, no longer used\n\t(Has_Rep_Pragma): New function\n\t(Has_Attribute_Definition_Clause): New function\n\t(Record_Rep_Pragma): Moved here from sem_ch13.adb\n\t(Get_Rep_Pragma): Remove junk kludge for Stream_Convert pragma\n\n\t* sem_ch13.ads, sem_ch13.adb (Record_Rep_Pragma): Moved to einfo.adb\n\n\t* exp_prag.adb: (Expand_Pragma_Common_Object): New procedure\n\t(Expand_Pragma_Psect_Object): New procedure\n\tThese procedures contain the revised and cleaned up processing for\n\tthese two pragmas. This processing was formerly in Sem_Prag, but\n\tis more appropriately moved here. The cleanup involves making sure\n\tthat the pragmas are properly attached to the tree, and that no\n\tnodes are improperly shared.\n\n\t* sem_prag.adb: Move expansion of Common_Object and Psect_Object\n\tpragmas to Exp_Prag, which is more appropriate.\n\tAttach these two pragmas to the Rep_Item chain Use Rep_Item chain to\n\tcheck for duplicates Remove use of Is_Psected flag, no longer needed.\n\tUse new Make_String_Literal function with string.\n\n\t* exp_attr.adb (Expand_Fpt_Attribute): The floating-point attributes\n\tthat are functions return universal values, that have to be converted\n\tto the context type.\n\tUse new Make_String_Literal function with string.\n\t(Get_Stream_Convert_Pragma): New function, replaces the use of\n\tGet_Rep_Pragma, which had to be kludged to work in this case.\n\n\t* freeze.adb: Use new Has_Rep_Pragma function\n\n\t* exp_intr.adb, exp_ch3.adb, sem_attr.adb: Use new Make_String_Literal\n\tfunction with string.\n\tUse new Has_Rep_Pragma function.\n\n\t* tbuild.ads, tbuild.adb (Make_String_Literal): New function, takes\n\tstring argument.\n\nFrom-SVN: r90904", "tree": {"sha": "d53ac18b77b5d4de0e5e3bfaf29a5eaf3873c86d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d53ac18b77b5d4de0e5e3bfaf29a5eaf3873c86d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d571f3b00a155910504a2b219c77b839aebbb16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d571f3b00a155910504a2b219c77b839aebbb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d571f3b00a155910504a2b219c77b839aebbb16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d571f3b00a155910504a2b219c77b839aebbb16/comments", "author": null, "committer": null, "parents": [{"sha": "1735e55db99c4dac8a4c93f6f637bce55cb3008a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1735e55db99c4dac8a4c93f6f637bce55cb3008a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1735e55db99c4dac8a4c93f6f637bce55cb3008a"}], "stats": {"total": 669, "additions": 373, "deletions": 296}, "files": [{"sha": "85af819efb202c1ab1b3583c552402e91f6d8292", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -386,7 +386,6 @@ package body Einfo is\n \n    --    Vax_Float                      Flag151\n    --    Entry_Accepted                 Flag152\n-   --    Is_Psected                     Flag153\n    --    Has_Per_Object_Constraint      Flag154\n    --    Has_Private_Declaration        Flag155\n    --    Referenced                     Flag156\n@@ -421,7 +420,7 @@ package body Einfo is\n    --    Has_Xref_Entry                 Flag182\n    --    Must_Be_On_Byte_Boundary       Flag183\n \n-   --   Note: there are no unused flags currently!\n+   --    (unused)                       Flag153\n \n    --------------------------------\n    -- Attribute Access Functions --\n@@ -1587,11 +1586,6 @@ package body Einfo is\n       return Flag53 (Id);\n    end Is_Private_Descendant;\n \n-   function Is_Psected (Id : E) return B is\n-   begin\n-      return Flag153 (Id);\n-   end Is_Psected;\n-\n    function Is_Public (Id : E) return B is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -3547,11 +3541,6 @@ package body Einfo is\n       Set_Flag53 (Id, V);\n    end Set_Is_Private_Descendant;\n \n-   procedure Set_Is_Psected (Id : E; V : B := True) is\n-   begin\n-      Set_Flag153 (Id, V);\n-   end Set_Is_Psected;\n-\n    procedure Set_Is_Public (Id : E; V : B := True) is\n    begin\n       pragma Assert (Nkind (Id) in N_Entity);\n@@ -4806,14 +4795,17 @@ package body Einfo is\n       --  Scans the Discriminants to see whether any are Completely_Hidden\n       --  (the mechanism for describing non-specified stored discriminants)\n \n+      ----------------------------------------\n+      -- Has_Completely_Hidden_Discriminant --\n+      ----------------------------------------\n+\n       function Has_Completely_Hidden_Discriminant (Id : E) return Boolean is\n          Ent : Entity_Id := Id;\n \n       begin\n          pragma Assert (Ekind (Id) = E_Discriminant);\n \n          while Present (Ent) and then Ekind (Ent) = E_Discriminant loop\n-\n             if Is_Completely_Hidden (Ent) then\n                return True;\n             end if;\n@@ -4921,9 +4913,8 @@ package body Einfo is\n    -------------------------------------\n \n    function Get_Attribute_Definition_Clause\n-     (E    : Entity_Id;\n-      Id   : Attribute_Id)\n-      return Node_Id\n+     (E  : Entity_Id;\n+      Id : Attribute_Id) return Node_Id\n    is\n       N : Node_Id;\n \n@@ -4947,40 +4938,16 @@ package body Einfo is\n    --------------------\n \n    function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id is\n-      N   : Node_Id;\n-      Typ : Entity_Id;\n+      N : Node_Id;\n \n    begin\n       N := First_Rep_Item (E);\n-\n       while Present (N) loop\n          if Nkind (N) = N_Pragma and then Chars (N) = Nam then\n-\n-            if Nam = Name_Stream_Convert then\n-\n-               --  For tagged types this pragma is not inherited, so we\n-               --  must verify that it is defined for the given type and\n-               --  not an ancestor.\n-\n-               Typ := Entity (Expression\n-                       (First (Pragma_Argument_Associations (N))));\n-\n-               if not Is_Tagged_Type (E)\n-                 or else E = Typ\n-                 or else (Is_Private_Type (Typ)\n-                           and then E = Full_View (Typ))\n-               then\n-                  return N;\n-               else\n-                  Next_Rep_Item (N);\n-               end if;\n-\n-            else\n-               return N;\n-            end if;\n-         else\n-            Next_Rep_Item (N);\n+            return N;\n          end if;\n+\n+         Next_Rep_Item (N);\n       end loop;\n \n       return Empty;\n@@ -5010,6 +4977,18 @@ package body Einfo is\n       return False;\n    end Has_Attach_Handler;\n \n+   -------------------------------------\n+   -- Has_Attribute_Definition_Clause --\n+   -------------------------------------\n+\n+   function Has_Attribute_Definition_Clause\n+     (E  : Entity_Id;\n+      Id : Attribute_Id) return Boolean\n+   is\n+   begin\n+      return Present (Get_Attribute_Definition_Clause (E, Id));\n+   end Has_Attribute_Definition_Clause;\n+\n    -----------------\n    -- Has_Entries --\n    -----------------\n@@ -5020,8 +4999,8 @@ package body Einfo is\n \n    begin\n       pragma Assert (Is_Concurrent_Type (Id));\n-      Ent := First_Entity (Id);\n \n+      Ent := First_Entity (Id);\n       while Present (Ent) loop\n          if Is_Entry (Ent) then\n             Result := True;\n@@ -5089,6 +5068,15 @@ package body Einfo is\n       end loop;\n    end Has_Private_Ancestor;\n \n+   --------------------\n+   -- Has_Rep_Pragma --\n+   --------------------\n+\n+   function Has_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Boolean is\n+   begin\n+      return Present (Get_Rep_Pragma (E, Nam));\n+   end Has_Rep_Pragma;\n+\n    ------------------------------\n    -- Implementation_Base_Type --\n    ------------------------------\n@@ -5127,7 +5115,6 @@ package body Einfo is\n \n    begin\n       Item := First_Rep_Item (Id);\n-\n       while Present (Item) loop\n          if Nkind (Item) = N_Pragma\n            and then Get_Pragma_Id (Chars (Item)) = Pragma_Inline_Always\n@@ -5206,9 +5193,10 @@ package body Einfo is\n \n          else\n             declare\n-               C : Entity_Id := First_Component (Btype);\n+               C : Entity_Id;\n \n             begin\n+               C := First_Component (Btype);\n                while Present (C) loop\n                   if Is_By_Reference_Type (Etype (C))\n                     or else Is_Volatile (Etype (C))\n@@ -5376,9 +5364,10 @@ package body Einfo is\n \n          else\n             declare\n-               C : E := First_Component (Btype);\n+               C : E;\n \n             begin\n+               C := First_Component (Btype);\n                while Present (C) loop\n                   if Is_Limited_Type (Etype (C)) then\n                      return True;\n@@ -5464,9 +5453,10 @@ package body Einfo is\n \n          else\n             declare\n-               C : Entity_Id := First_Component (Btype);\n+               C : Entity_Id;\n \n             begin\n+               C := First_Component (Btype);\n                while Present (C) loop\n                   if Is_Return_By_Reference_Type (Etype (C)) then\n                      return True;\n@@ -5529,7 +5519,6 @@ package body Einfo is\n \n    begin\n       Comp_Id := Next_Entity (Id);\n-\n       while Present (Comp_Id) loop\n          exit when Ekind (Comp_Id) = E_Component;\n          Comp_Id := Next_Entity (Comp_Id);\n@@ -5664,7 +5653,6 @@ package body Einfo is\n       else\n          N := 0;\n          T := First_Index (Id);\n-\n          while Present (T) loop\n             N := N + 1;\n             T := Next (T);\n@@ -5685,7 +5673,6 @@ package body Einfo is\n    begin\n       N := 0;\n       Discr := First_Discriminant (Id);\n-\n       while Present (Discr) loop\n          N := N + 1;\n          Discr := Next_Discriminant (Discr);\n@@ -5704,9 +5691,9 @@ package body Einfo is\n \n    begin\n       pragma Assert (Is_Concurrent_Type (Id));\n+\n       N := 0;\n       Ent := First_Entity (Id);\n-\n       while Present (Ent) loop\n          if Is_Entry (Ent) then\n             N := N + 1;\n@@ -5729,7 +5716,6 @@ package body Einfo is\n    begin\n       N := 0;\n       Formal := First_Formal (Id);\n-\n       while Present (Formal) loop\n          N := N + 1;\n          Formal := Next_Formal (Formal);\n@@ -5747,6 +5733,16 @@ package body Einfo is\n       return Ekind (Id);\n    end Parameter_Mode;\n \n+   ---------------------\n+   -- Record_Rep_Item --\n+   ---------------------\n+\n+   procedure Record_Rep_Item (E : Entity_Id; N : Node_Id) is\n+   begin\n+      Set_Next_Rep_Item (N, First_Rep_Item (E));\n+      Set_First_Rep_Item (E, N);\n+   end Record_Rep_Item;\n+\n    ---------------\n    -- Root_Type --\n    ---------------\n@@ -5804,9 +5800,10 @@ package body Einfo is\n    -----------------\n \n    function Scope_Depth (Id : E) return Uint is\n-      Scop : Entity_Id := Id;\n+      Scop : Entity_Id;\n \n    begin\n+      Scop := Id;\n       while Is_Record_Type (Scop) loop\n          Scop := Scope (Scop);\n       end loop;\n@@ -6246,7 +6243,6 @@ package body Einfo is\n       W (\"Is_Preelaborated\",              Flag59  (Id));\n       W (\"Is_Private_Composite\",          Flag107 (Id));\n       W (\"Is_Private_Descendant\",         Flag53  (Id));\n-      W (\"Is_Psected\",                    Flag153 (Id));\n       W (\"Is_Public\",                     Flag10  (Id));\n       W (\"Is_Pure\",                       Flag44  (Id));\n       W (\"Is_Remote_Call_Interface\",      Flag62  (Id));\n@@ -6372,14 +6368,13 @@ package body Einfo is\n                Index : E;\n \n             begin\n-               Write_Attribute (\"   Component Type    \",\n-                                                   Component_Type (Id));\n+               Write_Attribute\n+                 (\"   Component Type    \", Component_Type (Id));\n                Write_Eol;\n                Write_Str (Prefix);\n                Write_Str (\"   Indices \");\n \n                Index := First_Index (Id);\n-\n                while Present (Index) loop\n                   Write_Attribute (\" \", Etype (Index));\n                   Index := Next_Index (Index);"}, {"sha": "d77f811ec574a0993cc5e7e997eb1fd9ef2ed8d1", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -2191,10 +2191,6 @@ package Einfo is\n --    Is_Protected_Type (synthesized)\n --       Applies to all entities, true for protected types and subtypes\n \n---    Is_Psected (Flag153)\n---       Present in entities for objects, true if a valid Psect_Object\n---       pragma applies to the object. Used to detect duplicate pragmas.\n-\n --    Is_Public (Flag10)\n --       Present in all entities. Set to indicate that an entity defined in\n --       one compilation unit can be referenced from other compilation units.\n@@ -4167,7 +4163,6 @@ package Einfo is\n    --    Has_Volatile_Components       (Flag87)\n    --    Is_Atomic                     (Flag85)\n    --    Is_Eliminated                 (Flag124)\n-   --    Is_Psected                    (Flag153)\n    --    Is_True_Constant              (Flag163)\n    --    Is_Volatile                   (Flag16)\n    --    Never_Set_In_Source           (Flag115)\n@@ -4746,7 +4741,6 @@ package Einfo is\n    --    Has_Volatile_Components       (Flag87)\n    --    Is_Atomic                     (Flag85)\n    --    Is_Eliminated                 (Flag124)\n-   --    Is_Psected                    (Flag153)\n    --    Is_Shared_Passive             (Flag60)\n    --    Is_True_Constant              (Flag163)\n    --    Is_Volatile                   (Flag16)\n@@ -5186,7 +5180,6 @@ package Einfo is\n    function Is_Preelaborated                   (Id : E) return B;\n    function Is_Private_Composite               (Id : E) return B;\n    function Is_Private_Descendant              (Id : E) return B;\n-   function Is_Psected                         (Id : E) return B;\n    function Is_Public                          (Id : E) return B;\n    function Is_Pure                            (Id : E) return B;\n    function Is_Remote_Call_Interface           (Id : E) return B;\n@@ -5662,7 +5655,6 @@ package Einfo is\n    procedure Set_Is_Preelaborated              (Id : E; V : B := True);\n    procedure Set_Is_Private_Composite          (Id : E; V : B := True);\n    procedure Set_Is_Private_Descendant         (Id : E; V : B := True);\n-   procedure Set_Is_Psected                    (Id : E; V : B := True);\n    procedure Set_Is_Public                     (Id : E; V : B := True);\n    procedure Set_Is_Pure                       (Id : E; V : B := True);\n    procedure Set_Is_Remote_Call_Interface      (Id : E; V : B := True);\n@@ -5868,26 +5860,56 @@ package Einfo is\n    procedure Next_Stored_Discriminant (N : in out Node_Id)\n      renames Proc_Next_Stored_Discriminant;\n \n-   -------------------------------\n-   -- Miscellaneous Subprograms --\n-   -------------------------------\n+   ----------------------------------------------\n+   -- Subprograms for Accessing Rep Item Chain --\n+   ----------------------------------------------\n \n-   procedure Append_Entity (Id : Entity_Id; V : Entity_Id);\n-   --  Add an entity to the list of entities declared in the scope V\n+   --  The First_Rep_Item field of every entity points to a linked list\n+   --  (linked through Next_Rep_Item) of representation pragmas and\n+   --  attribute definition clauses that apply to the item. Note that\n+   --  in the case of types, it is assumed that any such rep items for\n+   --  a base type also apply to all subtypes. This is implemented by\n+   --  having the chain for subtypes link onto the chain for the base\n+   --  type, so that any new entries for the subtype are added at the\n+   --  start of the chain.\n+\n+   function Get_Attribute_Definition_Clause\n+     (E  : Entity_Id;\n+      Id : Attribute_Id) return Node_Id;\n+   --  Searches the Rep_Item chain for a given entity E, for an instance\n+   --  of an attribute definition clause with the given attibute Id Id. If\n+   --  found, the value returned is the N_Attribute_Definition_Clause node,\n+   --  otherwise Empty is returned.\n \n    function Get_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Node_Id;\n    --  Searches the Rep_Item chain for the given entity E, for an instance\n    --  of a representation pragma with the given name Nam. If found then\n    --  the value returned is the N_Pragma node, otherwise Empty is returned.\n \n-   function Get_Attribute_Definition_Clause\n-     (E    : Entity_Id;\n-      Id   : Attribute_Id)\n-      return Node_Id;\n+   function Has_Rep_Pragma (E : Entity_Id; Nam : Name_Id) return Boolean;\n+   --  Searches the Rep_Item chain for the given entity E, for an instance\n+   --  of representation pragma with the given name Nam. If found then True\n+   --  is returned, otherwise False indicates that no matching entry was found.\n+\n+   function Has_Attribute_Definition_Clause\n+     (E  : Entity_Id;\n+      Id : Attribute_Id) return Boolean;\n    --  Searches the Rep_Item chain for a given entity E, for an instance\n    --  of an attribute definition clause with the given attibute Id Id. If\n-   --  found, the value returned is the N_Attribute_Definition_Clause node,\n-   --  otherwise Empty is returned.\n+   --  found, True is returned, otherwise False indicates that no matching\n+   --  entry was found.\n+\n+   procedure Record_Rep_Item (E : Entity_Id; N : Node_Id);\n+   --  N is the node for either a representation pragma or an attribute\n+   --  definition clause that applies to entity E. This procedure links\n+   --  the node N onto the Rep_Item chain for entity E.\n+\n+   -------------------------------\n+   -- Miscellaneous Subprograms --\n+   -------------------------------\n+\n+   procedure Append_Entity (Id : Entity_Id; V : Entity_Id);\n+   --  Add an entity to the list of entities declared in the scope V\n \n    function Is_Entity_Name (N : Node_Id) return Boolean;\n    --  Test if the node N is the name of an entity (i.e. is an identifier,\n@@ -6183,7 +6205,6 @@ package Einfo is\n    pragma Inline (Is_Private_Descendant);\n    pragma Inline (Is_Private_Type);\n    pragma Inline (Is_Protected_Type);\n-   pragma Inline (Is_Psected);\n    pragma Inline (Is_Public);\n    pragma Inline (Is_Pure);\n    pragma Inline (Is_Real_Type);\n@@ -6499,7 +6520,6 @@ package Einfo is\n    pragma Inline (Set_Is_Preelaborated);\n    pragma Inline (Set_Is_Private_Composite);\n    pragma Inline (Set_Is_Private_Descendant);\n-   pragma Inline (Set_Is_Psected);\n    pragma Inline (Set_Is_Public);\n    pragma Inline (Set_Is_Pure);\n    pragma Inline (Set_Is_Remote_Call_Interface);"}, {"sha": "ae9a5cb09841396addca1a1fd13a4e9f86e4dfbe", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -138,6 +138,11 @@ package body Exp_Attr is\n    --  defining it, is returned. In both cases, inheritance of representation\n    --  aspects is thus taken into account.\n \n+   function Get_Stream_Convert_Pragma (T : Entity_Id) return Node_Id;\n+   --  Given a type, find a corresponding stream convert pragma that applies to\n+   --  the implementation base type of this type (Typ). If found, return the\n+   --  pragma node, otherwise return Empty if no pragma is found.\n+\n    function Is_Constrained_Packed_Array (Typ : Entity_Id) return Boolean;\n    --  Utility for array attributes, returns true on packed constrained\n    --  arrays, and on access to same.\n@@ -297,9 +302,11 @@ package body Exp_Attr is\n \n       --  The generated call is given the provided set of parameters, and then\n       --  wrapped in a conversion which converts the result to the target type\n+      --  We use the base type as the target because a range check may be\n+      --  required.\n \n       Rewrite (N,\n-        Unchecked_Convert_To (Etype (N),\n+        Unchecked_Convert_To (Base_Type (Etype (N)),\n           Make_Function_Call (Loc,\n             Name => Fnm,\n             Parameter_Associations => Args)));\n@@ -909,12 +916,9 @@ package body Exp_Attr is\n          if Pent = Standard_Standard\n            or else Pent = Standard_ASCII\n          then\n-            Name_Buffer (1 .. Verbose_Library_Version'Length) :=\n-              Verbose_Library_Version;\n-            Name_Len := Verbose_Library_Version'Length;\n             Rewrite (N,\n               Make_String_Literal (Loc,\n-                Strval => String_From_Name_Buffer));\n+                Strval => Verbose_Library_Version));\n \n          --  All other cases\n \n@@ -1804,9 +1808,7 @@ package body Exp_Attr is\n             --  from which it is derived. The extra conversion is required\n             --  for the derived case.\n \n-            Prag :=\n-              Get_Rep_Pragma\n-                (Implementation_Base_Type (P_Type), Name_Stream_Convert);\n+            Prag := Get_Stream_Convert_Pragma (P_Type);\n \n             if Present (Prag) then\n                Arg2  := Next (First (Pragma_Argument_Associations (Prag)));\n@@ -2380,9 +2382,7 @@ package body Exp_Attr is\n             --  it is derived to type strmtyp. The conversion to acttyp is\n             --  required for the derived case.\n \n-            Prag :=\n-              Get_Rep_Pragma\n-                (Implementation_Base_Type (P_Type), Name_Stream_Convert);\n+            Prag := Get_Stream_Convert_Pragma (P_Type);\n \n             if Present (Prag) then\n                Arg3 :=\n@@ -2795,9 +2795,7 @@ package body Exp_Attr is\n             --  where Itemx is the expression of the type conversion (i.e.\n             --  the actual object), and typex is the type of Itemx.\n \n-            Prag :=\n-              Get_Rep_Pragma\n-                (Implementation_Base_Type (P_Type), Name_Stream_Convert);\n+            Prag := Get_Stream_Convert_Pragma (P_Type);\n \n             if Present (Prag) then\n                Arg2  := Next (First (Pragma_Argument_Associations (Prag)));\n@@ -4017,9 +4015,7 @@ package body Exp_Attr is\n             --  it is derived to type strmtyp. The conversion to acttyp is\n             --  required for the derived case.\n \n-            Prag :=\n-              Get_Rep_Pragma\n-                (Implementation_Base_Type (P_Type), Name_Stream_Convert);\n+            Prag := Get_Stream_Convert_Pragma (P_Type);\n \n             if Present (Prag) then\n                Arg3 :=\n@@ -4326,6 +4322,46 @@ package body Exp_Attr is\n       return Etype (Indx);\n    end Get_Index_Subtype;\n \n+   -------------------------------\n+   -- Get_Stream_Convert_Pragma --\n+   -------------------------------\n+\n+   function Get_Stream_Convert_Pragma (T : Entity_Id) return Node_Id is\n+      Typ : Entity_Id;\n+      N   : Node_Id;\n+\n+   begin\n+      --  Note: we cannot use Get_Rep_Pragma here because of the peculiarity\n+      --  that a stream convert pragma for a tagged type is not inherited from\n+      --  its parent. Probably what is wrong here is that it is basically\n+      --  incorrect to consider a stream convert pragma to be a representation\n+      --  pragma at all ???\n+\n+      N := First_Rep_Item (Implementation_Base_Type (T));\n+      while Present (N) loop\n+         if Nkind (N) = N_Pragma and then Chars (N) = Name_Stream_Convert then\n+\n+            --  For tagged types this pragma is not inherited, so we\n+            --  must verify that it is defined for the given type and\n+            --  not an ancestor.\n+\n+            Typ :=\n+              Entity (Expression (First (Pragma_Argument_Associations (N))));\n+\n+            if not Is_Tagged_Type (T)\n+              or else T = Typ\n+              or else (Is_Private_Type (Typ) and then T = Full_View (Typ))\n+            then\n+               return N;\n+            end if;\n+         end if;\n+\n+         Next_Rep_Item (N);\n+      end loop;\n+\n+      return Empty;\n+   end Get_Stream_Convert_Pragma;\n+\n    ---------------------------------\n    -- Is_Constrained_Packed_Array --\n    ---------------------------------"}, {"sha": "0d3d72d35fd9f345250bb57c2853a3311192cee0", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -57,7 +57,6 @@ with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Stand;    use Stand;\n-with Stringt;  use Stringt;\n with Snames;   use Snames;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -1118,15 +1117,10 @@ package body Exp_Ch3 is\n          --  This is just a workaround that must be improved later???\n \n          if With_Default_Init then\n-            declare\n-               S           : String_Id;\n-               Null_String : Node_Id;\n-            begin\n-               Start_String;\n-               S := End_String;\n-               Null_String := Make_String_Literal (Loc, Strval => S);\n-               Append_To (Args, Null_String);\n-            end;\n+            Append_To (Args,\n+              Make_String_Literal (Loc,\n+                Strval => \"\"));\n+\n          else\n             Decls := Build_Task_Image_Decls (Loc, Id_Ref, Enclos_Type);\n             Decl  := Last (Decls);"}, {"sha": "7f99eb5ad0bddd65849a1683654a990e20aa305e", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -110,21 +110,18 @@ package body Exp_Intr is\n       Loc : constant Source_Ptr := Sloc (N);\n       P   : Node_Id;\n       E   : Entity_Id;\n-      S   : String_Id;\n \n    begin\n       --  Climb up parents to see if we are in exception handler\n \n       P := Parent (N);\n       loop\n-         --  Case of not in exception handler\n+         --  Case of not in exception handler, replace by null string\n \n          if No (P) then\n-            Start_String;\n-            S := End_String;\n             Rewrite (N,\n               Make_String_Literal (Loc,\n-                Strval => S));\n+                Strval => \"\"));\n             exit;\n \n          --  Case of in exception handler"}, {"sha": "cbaef5b5a157b2b1fea2fc1ea75e2fa09d9dfdff", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 157, "deletions": 7, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -58,31 +58,55 @@ package body Exp_Prag is\n \n    function Arg1 (N : Node_Id) return Node_Id;\n    function Arg2 (N : Node_Id) return Node_Id;\n-   --  Obtain specified Pragma_Argument_Association\n+   --  Obtain specified pragma argument expression\n \n    procedure Expand_Pragma_Abort_Defer             (N : Node_Id);\n    procedure Expand_Pragma_Assert                  (N : Node_Id);\n+   procedure Expand_Pragma_Common_Object           (N : Node_Id);\n    procedure Expand_Pragma_Import                  (N : Node_Id);\n    procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n+   procedure Expand_Pragma_Psect_Object            (N : Node_Id);\n \n    ----------\n    -- Arg1 --\n    ----------\n \n    function Arg1 (N : Node_Id) return Node_Id is\n+      Arg : constant Node_Id := First (Pragma_Argument_Associations (N));\n    begin\n-      return First (Pragma_Argument_Associations (N));\n+      if Present (Arg)\n+        and then Nkind (Arg) = N_Pragma_Argument_Association\n+      then\n+         return Expression (Arg);\n+      else\n+         return Arg;\n+      end if;\n    end Arg1;\n \n    ----------\n    -- Arg2 --\n    ----------\n \n    function Arg2 (N : Node_Id) return Node_Id is\n+      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n    begin\n-      return Next (Arg1 (N));\n+      if No (Arg1) then\n+         return Empty;\n+      else\n+         declare\n+            Arg : constant Node_Id := Next (Arg1);\n+         begin\n+            if Present (Arg)\n+              and then Nkind (Arg) = N_Pragma_Argument_Association\n+            then\n+               return Expression (Arg);\n+            else\n+               return Arg;\n+            end if;\n+         end;\n+      end if;\n    end Arg2;\n \n    ---------------------\n@@ -105,6 +129,9 @@ package body Exp_Prag is\n             when Pragma_Assert =>\n                Expand_Pragma_Assert (N);\n \n+            when Pragma_Common_Object =>\n+               Expand_Pragma_Common_Object (N);\n+\n             when Pragma_Export_Exception =>\n                Expand_Pragma_Import_Export_Exception (N);\n \n@@ -120,6 +147,9 @@ package body Exp_Prag is\n             when Pragma_Interrupt_Priority =>\n                Expand_Pragma_Interrupt_Priority (N);\n \n+            when Pragma_Psect_Object =>\n+               Expand_Pragma_Psect_Object (N);\n+\n             --  All other pragmas need no expander action\n \n             when others => null;\n@@ -195,7 +225,7 @@ package body Exp_Prag is\n \n    procedure Expand_Pragma_Assert (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n-      Cond : constant Node_Id    := Expression (Arg1 (N));\n+      Cond : constant Node_Id    := Arg1 (N);\n       Msg  : String_Id;\n \n    begin\n@@ -222,7 +252,7 @@ package body Exp_Prag is\n       --  First, we need to prepare the character literal\n \n       if Present (Arg2 (N)) then\n-         Msg := Strval (Expr_Value_S (Expression (Arg2 (N))));\n+         Msg := Strval (Expr_Value_S (Arg2 (N)));\n       else\n          Build_Location_String (Loc);\n          Msg := String_From_Name_Buffer;\n@@ -265,6 +295,114 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Assert;\n \n+   ---------------------------------\n+   -- Expand_Pragma_Common_Object --\n+   ---------------------------------\n+\n+   --  Add series of pragmas to replicate semantic effect in DEC Ada\n+\n+   --    pragma Linker_Section (internal_name, external_name);\n+   --    pragma Machine_Attribute (internal_name, \"overlaid\");\n+   --    pragma Machine_Attribute (internal_name, \"global\");\n+   --    pragma Machine_Attribute (internal_name, \"initialize\");\n+\n+   --  For now we do nothing with the size attribute ???\n+\n+   --  Really this expansion would be much better in the back end. The\n+   --  front end should not need to know about target dependent, back end\n+   --  dependent semantics ???\n+\n+   procedure Expand_Pragma_Common_Object (N : Node_Id) is\n+      Loc : constant Source_Ptr := Sloc (N);\n+\n+      Internal : constant Node_Id := Arg1 (N);\n+      External : constant Node_Id := Arg2 (N);\n+\n+      Psect : Node_Id;\n+      --  Psect value upper cased as string literal\n+\n+      Iloc : constant Source_Ptr := Sloc (Internal);\n+      Eloc : constant Source_Ptr := Sloc (External);\n+      Ploc : Source_Ptr;\n+\n+   begin\n+      --  Acquire Psect value and fold to upper case\n+\n+      if Present (External) then\n+         if Nkind (External) = N_String_Literal then\n+            String_To_Name_Buffer (Strval (External));\n+         else\n+            Get_Name_String (Chars (External));\n+         end if;\n+\n+         Set_All_Upper_Case;\n+\n+         Psect :=\n+           Make_String_Literal (Eloc,\n+             Strval => String_From_Name_Buffer);\n+\n+      else\n+         Get_Name_String (Chars (Internal));\n+         Set_All_Upper_Case;\n+         Psect :=\n+           Make_String_Literal (Iloc,\n+             Strval => String_From_Name_Buffer);\n+      end if;\n+\n+      Ploc := Sloc (Psect);\n+\n+      --  Insert pragmas\n+\n+      Insert_List_After_And_Analyze (N, New_List (\n+\n+         --  The Linker_Section pragma ensures the correct section\n+\n+         Make_Pragma (Loc,\n+           Chars => Name_Linker_Section,\n+           Pragma_Argument_Associations => New_List (\n+             Make_Pragma_Argument_Association (Iloc,\n+               Expression => New_Copy_Tree (Internal)),\n+             Make_Pragma_Argument_Association (Ploc,\n+               Expression => New_Copy_Tree (Psect)))),\n+\n+         --  Machine_Attribute \"overlaid\" ensures that this section\n+         --  overlays any other sections of the same name.\n+\n+         Make_Pragma (Loc,\n+           Chars => Name_Machine_Attribute,\n+           Pragma_Argument_Associations => New_List (\n+             Make_Pragma_Argument_Association (Iloc,\n+               Expression => New_Copy_Tree (Internal)),\n+             Make_Pragma_Argument_Association (Eloc,\n+               Expression =>\n+                 Make_String_Literal (Sloc => Ploc,\n+                   Strval => \"overlaid\")))),\n+\n+         --  Machine_Attribute \"global\" ensures that section is visible\n+\n+         Make_Pragma (Loc,\n+           Chars => Name_Machine_Attribute,\n+           Pragma_Argument_Associations => New_List (\n+             Make_Pragma_Argument_Association (Iloc,\n+               Expression => New_Copy_Tree (Internal)),\n+             Make_Pragma_Argument_Association (Eloc,\n+               Expression =>\n+                 Make_String_Literal (Sloc => Ploc,\n+                   Strval => \"global\")))),\n+\n+         --  Machine_Attribute \"initialize\" ensures section is demand zeroed\n+\n+         Make_Pragma (Loc,\n+           Chars => Name_Machine_Attribute,\n+           Pragma_Argument_Associations => New_List (\n+             Make_Pragma_Argument_Association (Iloc,\n+               Expression => New_Copy_Tree (Internal)),\n+             Make_Pragma_Argument_Association (Eloc,\n+               Expression =>\n+                 Make_String_Literal (Sloc => Ploc,\n+                   Strval => \"initialize\"))))));\n+   end Expand_Pragma_Common_Object;\n+\n    --------------------------\n    -- Expand_Pragma_Import --\n    --------------------------\n@@ -281,7 +419,7 @@ package body Exp_Prag is\n    --  seen (i.e. this elaboration cannot be deferred to the freeze point).\n \n    procedure Expand_Pragma_Import (N : Node_Id) is\n-      Def_Id    : constant Entity_Id := Entity (Expression (Arg2 (N)));\n+      Def_Id    : constant Entity_Id := Entity (Arg2 (N));\n       Typ       : Entity_Id;\n       Init_Call : Node_Id;\n \n@@ -340,7 +478,7 @@ package body Exp_Prag is\n       end if;\n \n       declare\n-         Id     : constant Entity_Id := Entity (Expression (Arg1 (N)));\n+         Id     : constant Entity_Id := Entity (Arg1 (N));\n          Call   : constant Node_Id := Register_Exception_Call (Id);\n          Loc    : constant Source_Ptr := Sloc (N);\n \n@@ -579,4 +717,16 @@ package body Exp_Prag is\n       end if;\n    end Expand_Pragma_Interrupt_Priority;\n \n+   --------------------------------\n+   -- Expand_Pragma_Psect_Object --\n+   --------------------------------\n+\n+   --  Convert to Common_Object, and expand the resulting pragma\n+\n+   procedure Expand_Pragma_Psect_Object (N : Node_Id) is\n+   begin\n+      Set_Chars (N, Name_Common_Object);\n+      Expand_Pragma_Common_Object (N);\n+   end Expand_Pragma_Psect_Object;\n+\n end Exp_Prag;"}, {"sha": "e49ec85e4c65103019ddfc4de4c2d0d33f91c74a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -2235,17 +2235,17 @@ package body Freeze is\n                --  inherited the indication from elsewhere (e.g. an address\n                --  clause, which is not good enough in RM terms!)\n \n-               if Present (Get_Rep_Pragma (E, Name_Atomic))\n+               if Has_Rep_Pragma (E, Name_Atomic)\n                     or else\n-                  Present (Get_Rep_Pragma (E, Name_Atomic_Components))\n+                  Has_Rep_Pragma (E, Name_Atomic_Components)\n                then\n                   Error_Msg_N\n                     (\"stand alone atomic constant must be \" &\n                      \"imported ('R'M 'C.6(13))\", E);\n \n-               elsif Present (Get_Rep_Pragma (E, Name_Volatile))\n+               elsif Has_Rep_Pragma (E, Name_Volatile)\n                        or else\n-                     Present (Get_Rep_Pragma (E, Name_Volatile_Components))\n+                     Has_Rep_Pragma (E, Name_Volatile_Components)\n                then\n                   Error_Msg_N\n                     (\"stand alone volatile constant must be \" &"}, {"sha": "57c06a599a1c3fbb48495af73dabcbd91d444b1e", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -1232,7 +1232,7 @@ package body Sem_Attr is\n          if Is_Limited_Type (P_Type)\n            and then Comes_From_Source (N)\n            and then not Present (TSS (Btyp, Nam))\n-           and then No (Get_Rep_Pragma (Btyp, Name_Stream_Convert))\n+           and then not Has_Rep_Pragma (Btyp, Name_Stream_Convert)\n          then\n             Error_Msg_Name_1 := Aname;\n             Error_Msg_NE\n@@ -3480,22 +3480,21 @@ package body Sem_Attr is\n \n       when Attribute_Target_Name => Target_Name : declare\n          TN : constant String := Sdefault.Target_Name.all;\n-         TL : Integer := TN'Last;\n+         TL : Natural;\n \n       begin\n          Check_Standard_Prefix;\n          Check_E0;\n-         Start_String;\n+\n+         TL := TN'Last;\n \n          if TN (TL) = '/' or else TN (TL) = '\\' then\n             TL := TL - 1;\n          end if;\n \n-         Store_String_Chars (TN (TN'First .. TL));\n-\n          Rewrite (N,\n            Make_String_Literal (Loc,\n-             Strval => End_String));\n+             Strval => TN (TN'First .. TL)));\n          Analyze_And_Resolve (N, Standard_String);\n       end Target_Name;\n "}, {"sha": "3ece55021e778860c947096b2286b37426de5bb7", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -3411,16 +3411,6 @@ package body Sem_Ch13 is\n       end if;\n    end New_Stream_Procedure;\n \n-   ---------------------\n-   -- Record_Rep_Item --\n-   ---------------------\n-\n-   procedure Record_Rep_Item (T : Entity_Id; N : Node_Id) is\n-   begin\n-      Set_Next_Rep_Item (N, First_Rep_Item (T));\n-      Set_First_Rep_Item (T, N);\n-   end Record_Rep_Item;\n-\n    ------------------------\n    -- Rep_Item_Too_Early --\n    ------------------------"}, {"sha": "2a296b6cf28ff2635f564aeb92a20306fae3b817", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -90,11 +90,6 @@ package Sem_Ch13 is\n    --  If the size is too small, and an error message is given, then both\n    --  Esize and RM_Size are reset to the allowed minimum value in T.\n \n-   procedure Record_Rep_Item (T : Entity_Id; N : Node_Id);\n-   --  N is the node for either a representation pragma or an attribute\n-   --  definition clause that applies to type T. This procedure links\n-   --  the node N onto the Rep_Item chain for the type T.\n-\n    function Rep_Item_Too_Early (T : Entity_Id; N : Node_Id) return Boolean;\n    --  Called at the start of processing a representation clause or a\n    --  representation pragma. Used to check that the representation item"}, {"sha": "e21038f054d2bfde45fce5a88d0567cee276b2e3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 30, "deletions": 152, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -875,13 +875,11 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_String_Literal (Arg : Node_Id) is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n-\n       begin\n          if Nkind (Argx) /= N_String_Literal then\n             Error_Pragma_Arg\n               (\"argument for pragma% must be string literal\", Argx);\n          end if;\n-\n       end Check_Arg_Is_String_Literal;\n \n       ------------------------------------------\n@@ -917,7 +915,6 @@ package body Sem_Prag is\n \n       procedure Check_At_Most_N_Arguments (N : Nat) is\n          Arg : Node_Id;\n-\n       begin\n          if Arg_Count > N then\n             Arg := Arg1;\n@@ -997,7 +994,6 @@ package body Sem_Prag is\n \n       procedure Check_First_Subtype (Arg : Node_Id) is\n          Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n-\n       begin\n          if not Is_First_Subtype (Entity (Argx)) then\n             Error_Pragma_Arg\n@@ -1198,11 +1194,9 @@ package body Sem_Prag is\n \n       procedure Check_No_Identifiers is\n          Arg_Node : Node_Id;\n-\n       begin\n          if Arg_Count > 0 then\n             Arg_Node := Arg1;\n-\n             while Present (Arg_Node) loop\n                Check_No_Identifier (Arg_Node);\n                Next (Arg_Node);\n@@ -1280,8 +1274,9 @@ package body Sem_Prag is\n \n             when N_Index_Or_Discriminant_Constraint =>\n                declare\n-                  IDC : Entity_Id := First (Constraints (Constr));\n+                  IDC : Entity_Id;\n                begin\n+                  IDC := First (Constraints (Constr));\n                   while Present (IDC) loop\n                      Check_Static_Constraint (IDC);\n                      Next (IDC);\n@@ -1476,10 +1471,8 @@ package body Sem_Prag is\n \n          Comp := First (Component_Items (Clist));\n          while Present (Comp) loop\n-\n             Check_Component (Comp);\n             Next (Comp);\n-\n          end loop;\n       end Check_Variant;\n \n@@ -2280,9 +2273,12 @@ package body Sem_Prag is\n               (\"pragma% must designate an object\", Arg_Internal);\n          end if;\n \n-         if Is_Psected (Def_Id) then\n+         if Has_Rep_Pragma (Def_Id, Name_Common_Object)\n+              or else\n+            Has_Rep_Pragma (Def_Id, Name_Psect_Object)\n+         then\n             Error_Pragma_Arg\n-              (\"previous Psect_Object applies, pragma % not permitted\",\n+              (\"previous Common/Psect_Object applies, pragma % not permitted\",\n                Arg_Internal);\n          end if;\n \n@@ -2463,12 +2459,12 @@ package body Sem_Prag is\n \n       begin\n          Process_Extended_Import_Export_Internal_Arg (Arg_Internal);\n-         Hom_Id := Entity (Arg_Internal);\n          Ent := Empty;\n          Ambiguous := False;\n \n-         --  Loop through homonyms (overloadings) of Hom_Id\n+         --  Loop through homonyms (overloadings) of the entity\n \n+         Hom_Id := Entity (Arg_Internal);\n          while Present (Hom_Id) loop\n             Def_Id := Get_Base_Subprogram (Hom_Id);\n \n@@ -4064,7 +4060,6 @@ package body Sem_Prag is\n          else\n             Bad_Class;\n          end if;\n-\n       end Set_Mechanism_Value;\n \n       ---------------------------\n@@ -8401,13 +8396,7 @@ package body Sem_Prag is\n             External : Node_Id renames Args (2);\n             Size     : Node_Id renames Args (3);\n \n-            R_Internal : Node_Id;\n-            R_External : Node_Id;\n-\n-            MA       : Node_Id;\n-            Str      : String_Id;\n-\n-            Def_Id   : Entity_Id;\n+            Def_Id : Entity_Id;\n \n             procedure Check_Too_Long (Arg : Node_Id);\n             --  Posts message if the argument is an identifier with more\n@@ -8451,9 +8440,7 @@ package body Sem_Prag is\n             Gather_Associations (Names, Args);\n             Process_Extended_Import_Export_Internal_Arg (Internal);\n \n-            R_Internal := Relocate_Node (Internal);\n-\n-            Def_Id := Entity (R_Internal);\n+            Def_Id := Entity (Internal);\n \n             if Ekind (Def_Id) /= E_Constant\n               and then Ekind (Def_Id) /= E_Variable\n@@ -8462,38 +8449,39 @@ package body Sem_Prag is\n                  (\"pragma% must designate an object\", Internal);\n             end if;\n \n-            Check_Too_Long (R_Internal);\n+            Check_Too_Long (Internal);\n \n             if Is_Imported (Def_Id) or else Is_Exported (Def_Id) then\n                Error_Pragma_Arg\n                  (\"cannot use pragma% for imported/exported object\",\n-                  R_Internal);\n+                  Internal);\n             end if;\n \n-            if Is_Concurrent_Type (Etype (R_Internal)) then\n+            if Is_Concurrent_Type (Etype (Internal)) then\n                Error_Pragma_Arg\n                  (\"cannot specify pragma % for task/protected object\",\n-                  R_Internal);\n+                  Internal);\n             end if;\n \n-            if Is_Psected (Def_Id) then\n-               Error_Msg_N (\"?duplicate Psect_Object pragma\", N);\n-            else\n-               Set_Is_Psected (Def_Id);\n+            if Has_Rep_Pragma (Def_Id, Name_Common_Object)\n+                 or else\n+               Has_Rep_Pragma (Def_Id, Name_Psect_Object)\n+            then\n+               Error_Msg_N (\"?duplicate Common/Psect_Object pragma\", N);\n             end if;\n \n             if Ekind (Def_Id) = E_Constant then\n                Error_Pragma_Arg\n-                 (\"cannot specify pragma % for a constant\", R_Internal);\n+                 (\"cannot specify pragma % for a constant\", Internal);\n             end if;\n \n-            if Is_Record_Type (Etype (R_Internal)) then\n+            if Is_Record_Type (Etype (Internal)) then\n                declare\n                   Ent  : Entity_Id;\n                   Decl : Entity_Id;\n \n                begin\n-                  Ent := First_Entity (Etype (R_Internal));\n+                  Ent := First_Entity (Etype (Internal));\n                   while Present (Ent) loop\n                      Decl := Declaration_Node (Ent);\n \n@@ -8503,7 +8491,7 @@ package body Sem_Prag is\n                        and then Warn_On_Export_Import\n                      then\n                         Error_Msg_N\n-                          (\"?object for pragma % has defaults\", R_Internal);\n+                          (\"?object for pragma % has defaults\", Internal);\n                         exit;\n \n                      else\n@@ -8517,120 +8505,13 @@ package body Sem_Prag is\n                Check_Too_Long (Size);\n             end if;\n \n-            --  Make Psect case-insensitive.\n-\n             if Present (External) then\n                Check_Too_Long (External);\n-\n-               if Nkind (External) = N_String_Literal then\n-                  String_To_Name_Buffer (Strval (External));\n-               else\n-                  Get_Name_String (Chars (External));\n-               end if;\n-\n-               Set_All_Upper_Case;\n-               Start_String;\n-               Store_String_Chars (Name_Buffer (1 .. Name_Len));\n-               Str := End_String;\n-               R_External := Make_String_Literal\n-                 (Sloc => Sloc (External), Strval => Str);\n-            else\n-               Get_Name_String (Chars (Internal));\n-               Set_All_Upper_Case;\n-               Start_String;\n-               Store_String_Chars (Name_Buffer (1 .. Name_Len));\n-               Str := End_String;\n-               R_External := Make_String_Literal\n-                 (Sloc => Sloc (Internal), Strval => Str);\n             end if;\n \n-            --  Transform into pragma Linker_Section, add attributes to\n-            --  match what DEC Ada does. Ignore size for now?\n-\n-            Rewrite (N,\n-               Make_Pragma\n-                 (Sloc (N),\n-                  Name_Linker_Section,\n-                  New_List\n-                    (Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_Internal),\n-                        Expression => R_Internal),\n-                     Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_External),\n-                        Expression => R_External))));\n-\n-            Analyze (N);\n-\n-            --  Add Machine_Attribute of \"overlaid\", so the section overlays\n-            --  other sections of the same name.\n-\n-            Start_String;\n-            Store_String_Chars (\"overlaid\");\n-            Str := End_String;\n-\n-            MA :=\n-               Make_Pragma\n-                 (Sloc (N),\n-                  Name_Machine_Attribute,\n-                  New_List\n-                    (Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_Internal),\n-                        Expression => R_Internal),\n-                     Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_External),\n-                        Expression =>\n-                          Make_String_Literal\n-                            (Sloc => Sloc (R_External),\n-                             Strval => Str))));\n-            Analyze (MA);\n-\n-            --  Add Machine_Attribute of \"global\", so the section is visible\n-            --  everywhere\n-\n-            Start_String;\n-            Store_String_Chars (\"global\");\n-            Str := End_String;\n-\n-            MA :=\n-               Make_Pragma\n-                 (Sloc (N),\n-                  Name_Machine_Attribute,\n-                  New_List\n-                    (Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_Internal),\n-                        Expression => R_Internal),\n-\n-                     Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_External),\n-                        Expression =>\n-                          Make_String_Literal\n-                            (Sloc => Sloc (R_External),\n-                             Strval => Str))));\n-            Analyze (MA);\n-\n-            --  Add Machine_Attribute of \"initialize\", so the section is\n-            --  demand zeroed.\n-\n-            Start_String;\n-            Store_String_Chars (\"initialize\");\n-            Str := End_String;\n-\n-            MA :=\n-               Make_Pragma\n-                 (Sloc (N),\n-                  Name_Machine_Attribute,\n-                  New_List\n-                    (Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_Internal),\n-                        Expression => R_Internal),\n+            --  If all error tests pass, link pragma on to the rep item chain\n \n-                     Make_Pragma_Argument_Association\n-                       (Sloc => Sloc (R_External),\n-                        Expression =>\n-                          Make_String_Literal\n-                            (Sloc => Sloc (R_External),\n-                             Strval => Str))));\n-            Analyze (MA);\n+            Record_Rep_Item (Def_Id, N);\n          end Psect_Object;\n \n          ----------\n@@ -9830,12 +9711,11 @@ package body Sem_Prag is\n                end if;\n \n                Vpart := Variant_Part (Clist);\n+\n                Variant := First (Variants (Vpart));\n                while Present (Variant) loop\n-\n                   Check_Variant (Variant);\n                   Next (Variant);\n-\n                end loop;\n             end if;\n \n@@ -9921,7 +9801,6 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (1);\n \n             Arg_Node := Arg1;\n-\n             while Present (Arg_Node) loop\n                Check_No_Identifier (Arg_Node);\n \n@@ -10117,9 +9996,9 @@ package body Sem_Prag is\n \n                         if Is_Enumeration_Type (E) then\n                            declare\n-                              Lit : Entity_Id := First_Literal (E);\n-\n+                              Lit : Entity_Id;\n                            begin\n+                              Lit := First_Literal (E);\n                               while Present (Lit) loop\n                                  Set_Warnings_Off (Lit);\n                                  Next_Literal (Lit);\n@@ -10201,10 +10080,9 @@ package body Sem_Prag is\n       Result : Entity_Id;\n \n    begin\n-      Result := Def_Id;\n-\n       --  Follow subprogram renaming chain\n \n+      Result := Def_Id;\n       while Is_Subprogram (Result)\n         and then\n           (Is_Generic_Instance (Result)"}, {"sha": "046826f617ad2baeee00ee29ddb1c94f7982d239", "filename": "gcc/ada/tbuild.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ftbuild.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ftbuild.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.adb?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -35,6 +35,7 @@ with Rident;   use Rident;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with Stringt;  use Stringt;\n with Uintp;    use Uintp;\n \n package body Tbuild is\n@@ -334,6 +335,22 @@ package body Tbuild is\n             UI_From_Int (RT_Exception_Code'Pos (Reason)));\n    end Make_Raise_Storage_Error;\n \n+   -------------------------\n+   -- Make_String_Literal --\n+   -------------------------\n+\n+   function Make_String_Literal\n+     (Sloc   : Source_Ptr;\n+      Strval : String) return Node_Id\n+   is\n+   begin\n+      Start_String;\n+      Store_String_Chars (Strval);\n+      return\n+        Make_String_Literal (Sloc,\n+          Strval => End_String);\n+   end Make_String_Literal;\n+\n    ---------------------------\n    -- Make_Unsuppress_Block --\n    ---------------------------"}, {"sha": "e96d22a060195c725273dfad23cb677402e2f68d", "filename": "gcc/ada/tbuild.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ftbuild.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d571f3b00a155910504a2b219c77b839aebbb16/gcc%2Fada%2Ftbuild.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftbuild.ads?ref=1d571f3b00a155910504a2b219c77b839aebbb16", "patch": "@@ -156,6 +156,12 @@ package Tbuild is\n    --  A convenient form of Make_Raise_Storage_Error where the Reason\n    --  is given simply as an enumeration value, rather than a Uint code.\n \n+   function Make_String_Literal\n+     (Sloc   : Source_Ptr;\n+      Strval : String) return Node_Id;\n+   --  A convenient form of Make_String_Literal, where the string value\n+   --  is given as a normal string instead of a String_Id value.\n+\n    function Make_Unsuppress_Block\n      (Loc   : Source_Ptr;\n       Check : Name_Id;"}]}