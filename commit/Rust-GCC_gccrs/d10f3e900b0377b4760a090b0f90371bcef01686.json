{"sha": "d10f3e900b0377b4760a090b0f90371bcef01686", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwZjNlOTAwYjAzNzdiNDc2MGEwOTBiMGY5MDM3MWJjZWYwMTY4Ng==", "commit": {"author": {"name": "qing zhao", "email": "qinzhao@gcc.gnu.org", "date": "2020-10-30T19:41:38Z"}, "committer": {"name": "qing zhao", "email": "qinzhao@gcc.gnu.org", "date": "2020-10-30T19:41:38Z"}, "message": "Add -fzero-call-used-regs option and zero_call_used_regs function attributes.\n\nThis new feature causes the compiler to zero a  subset of all call-used\nregisters at function return.  This is used to increase program security\nby either mitigating Return-Oriented Programming (ROP) attacks or\npreventing information leakage through registers.\n\ngcc/ChangeLog:\n\n2020-10-30  Qing Zhao  <qing.zhao@oracle.com>\n\t    H.J.Lu  <hjl.tools@gmail.com>\n\n\t* common.opt: Add new option -fzero-call-used-regs\n\t* config/i386/i386.c (zero_call_used_regno_p): New function.\n\t(zero_call_used_regno_mode): Likewise.\n\t(zero_all_vector_registers): Likewise.\n\t(zero_all_st_registers): Likewise.\n\t(zero_all_mm_registers): Likewise.\n\t(ix86_zero_call_used_regs): Likewise.\n\t(TARGET_ZERO_CALL_USED_REGS): Define.\n\t* df-scan.c (df_epilogue_uses_p): New function.\n\t(df_get_exit_block_use_set): Replace EPILOGUE_USES with\n\tdf_epilogue_uses_p.\n\t* df.h (df_epilogue_uses_p): Declare.\n\t* doc/extend.texi: Document the new zero_call_used_regs attribute.\n\t* doc/invoke.texi: Document the new -fzero-call-used-regs option.\n\t* doc/tm.texi: Regenerate.\n\t* doc/tm.texi.in (TARGET_ZERO_CALL_USED_REGS): New hook.\n\t* emit-rtl.h (struct rtl_data): New field must_be_zero_on_return.\n\t* flag-types.h (namespace zero_regs_flags): New namespace.\n\t* function.c (gen_call_used_regs_seq): New function.\n\t(class pass_zero_call_used_regs): New class.\n\t(pass_zero_call_used_regs::execute): New function.\n\t(make_pass_zero_call_used_regs): New function.\n\t* optabs.c (expand_asm_reg_clobber_mem_blockage): New function.\n\t* optabs.h (expand_asm_reg_clobber_mem_blockage): Declare.\n\t* opts.c (zero_call_used_regs_opts): New structure array\n\tinitialization.\n\t(parse_zero_call_used_regs_options): New function.\n\t(common_handle_option): Handle -fzero-call-used-regs.\n\t* opts.h (zero_call_used_regs_opts): New structure array.\n\t* passes.def: Add new pass pass_zero_call_used_regs.\n\t* recog.c (valid_insn_p): New function.\n\t* recog.h (valid_insn_p): Declare.\n\t* resource.c (init_resource_info): Replace EPILOGUE_USES with\n\tdf_epilogue_uses_p.\n\t* target.def (zero_call_used_regs): New hook.\n\t* targhooks.c (default_zero_call_used_regs): New function.\n\t* targhooks.h (default_zero_call_used_regs): Declare.\n\t* tree-pass.h (make_pass_zero_call_used_regs): Declare.\n\ngcc/c-family/ChangeLog:\n\n2020-10-30  Qing Zhao  <qing.zhao@oracle.com>\n\t    H.J.Lu  <hjl.tools@gmail.com>\n\n\t* c-attribs.c (c_common_attribute_table): Add new attribute\n\tzero_call_used_regs.\n\t(handle_zero_call_used_regs_attribute): New function.\n\ngcc/testsuite/ChangeLog:\n\n2020-10-30  Qing Zhao  <qing.zhao@oracle.com>\n\t    H.J.Lu  <hjl.tools@gmail.com>\n\n\t* c-c++-common/zero-scratch-regs-1.c: New test.\n\t* c-c++-common/zero-scratch-regs-10.c: New test.\n\t* c-c++-common/zero-scratch-regs-11.c: New test.\n\t* c-c++-common/zero-scratch-regs-2.c: New test.\n\t* c-c++-common/zero-scratch-regs-3.c: New test.\n\t* c-c++-common/zero-scratch-regs-4.c: New test.\n\t* c-c++-common/zero-scratch-regs-5.c: New test.\n\t* c-c++-common/zero-scratch-regs-6.c: New test.\n\t* c-c++-common/zero-scratch-regs-7.c: New test.\n\t* c-c++-common/zero-scratch-regs-8.c: New test.\n\t* c-c++-common/zero-scratch-regs-9.c: New test.\n\t* c-c++-common/zero-scratch-regs-attr-usages.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-1.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-10.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-11.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-12.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-13.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-14.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-15.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-16.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-17.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-18.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-19.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-2.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-20.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-21.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-22.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-23.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-24.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-25.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-26.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-27.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-28.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-29.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-30.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-31.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-3.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-4.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-5.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-6.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-7.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-8.c: New test.\n\t* gcc.target/i386/zero-scratch-regs-9.c: New test.", "tree": {"sha": "f78af058a8e7a4a1c04d601dbda48821a4eaa2e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f78af058a8e7a4a1c04d601dbda48821a4eaa2e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d10f3e900b0377b4760a090b0f90371bcef01686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10f3e900b0377b4760a090b0f90371bcef01686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d10f3e900b0377b4760a090b0f90371bcef01686", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d10f3e900b0377b4760a090b0f90371bcef01686/comments", "author": null, "committer": null, "parents": [{"sha": "44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44fbc9c6e02ca5b8f98f25b514ed7588e7ba733d"}], "stats": {"total": 1558, "additions": 1551, "deletions": 7}, "files": [{"sha": "65cba5074e5c18a4766d779b6e148410e0fa26ed", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -140,6 +140,8 @@ static tree handle_target_clones_attribute (tree *, tree, tree, int, bool *);\n static tree handle_optimize_attribute (tree *, tree, tree, int, bool *);\n static tree ignore_attribute (tree *, tree, tree, int, bool *);\n static tree handle_no_split_stack_attribute (tree *, tree, tree, int, bool *);\n+static tree handle_zero_call_used_regs_attribute (tree *, tree, tree, int,\n+\t\t\t\t\t\t  bool *);\n static tree handle_argspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_fnspec_attribute (tree *, tree, tree, int, bool *);\n static tree handle_warn_unused_attribute (tree *, tree, tree, int, bool *);\n@@ -451,6 +453,8 @@ const struct attribute_spec c_common_attribute_table[] =\n \t\t\t      ignore_attribute, NULL },\n   { \"no_split_stack\",\t      0, 0, true,  false, false, false,\n \t\t\t      handle_no_split_stack_attribute, NULL },\n+  { \"zero_call_used_regs\",    1, 1, true, false, false, false,\n+\t\t\t      handle_zero_call_used_regs_attribute, NULL },\n   /* For internal use only (marking of function arguments).\n      The name contains a space to prevent its usage in source code.  */\n   { \"arg spec\",\t\t      1, -1, true, false, false, false,\n@@ -4994,6 +4998,53 @@ handle_no_split_stack_attribute (tree *node, tree name,\n   return NULL_TREE;\n }\n \n+/* Handle a \"zero_call_used_regs\" attribute; arguments as in\n+   struct attribute_spec.handler.  */\n+\n+static tree\n+handle_zero_call_used_regs_attribute (tree *node, tree name, tree args,\n+\t\t\t\t      int ARG_UNUSED (flags),\n+\t\t\t\t      bool *no_add_attrs)\n+{\n+  tree decl = *node;\n+  tree id = TREE_VALUE (args);\n+\n+  if (TREE_CODE (decl) != FUNCTION_DECL)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE attribute applies only to functions\", name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (id) != STRING_CST)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"%qE argument not a string\", name);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  bool found = false;\n+  for (unsigned int i = 0; zero_call_used_regs_opts[i].name != NULL; ++i)\n+    if (strcmp (TREE_STRING_POINTER (id),\n+\t\tzero_call_used_regs_opts[i].name) == 0)\n+      {\n+\tfound = true;\n+\tbreak;\n+      }\n+\n+  if (!found)\n+    {\n+      error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t\"unrecognized %qE attribute argument %qs\",\n+\t\tname, TREE_STRING_POINTER (id));\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Handle a \"returns_nonnull\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n "}, {"sha": "d4cbb2f86a554fa2f87e52b2b6cbd1de27ddaa31", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -228,6 +228,10 @@ unsigned int flag_sanitize_coverage\n Variable\n bool dump_base_name_prefixed = false\n \n+; What subset of registers should be zeroed on function return\n+Variable\n+unsigned int flag_zero_call_used_regs\n+\n ###\n Driver\n \n@@ -3111,6 +3115,10 @@ fzero-initialized-in-bss\n Common Report Var(flag_zero_initialized_in_bss) Init(1)\n Put zero initialized data in the bss section.\n \n+fzero-call-used-regs=\n+Common Report RejectNegative Joined\n+Clear call-used registers upon function return.\n+\n g\n Common Driver RejectNegative JoinedOrMissing\n Generate debug information in default format."}, {"sha": "f5f25eb95c946d92f1b35b57cf1cdc2f7f2e17e0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -3551,6 +3551,297 @@ ix86_function_value_regno_p (const unsigned int regno)\n   return false;\n }\n \n+/* Check whether the register REGNO should be zeroed on X86.\n+   When ALL_SSE_ZEROED is true, all SSE registers have been zeroed\n+   together, no need to zero it again.\n+   When NEED_ZERO_MMX is true, MMX registers should be cleared.  */\n+\n+static bool\n+zero_call_used_regno_p (const unsigned int regno,\n+\t\t\tbool all_sse_zeroed,\n+\t\t\tbool need_zero_mmx)\n+{\n+  return GENERAL_REGNO_P (regno)\n+\t || (!all_sse_zeroed && SSE_REGNO_P (regno))\n+\t || MASK_REGNO_P (regno)\n+\t || (need_zero_mmx && MMX_REGNO_P (regno));\n+}\n+\n+/* Return the machine_mode that is used to zero register REGNO.  */\n+\n+static machine_mode\n+zero_call_used_regno_mode (const unsigned int regno)\n+{\n+  /* NB: We only need to zero the lower 32 bits for integer registers\n+     and the lower 128 bits for vector registers since destination are\n+     zero-extended to the full register width.  */\n+  if (GENERAL_REGNO_P (regno))\n+    return SImode;\n+  else if (SSE_REGNO_P (regno))\n+    return V4SFmode;\n+  else if (MASK_REGNO_P (regno))\n+    return HImode;\n+  else if (MMX_REGNO_P (regno))\n+    return V4HImode;\n+  else\n+    gcc_unreachable ();\n+}\n+\n+/* Generate a rtx to zero all vector registers together if possible,\n+   otherwise, return NULL.  */\n+\n+static rtx\n+zero_all_vector_registers (HARD_REG_SET need_zeroed_hardregs)\n+{\n+  if (!TARGET_AVX)\n+    return NULL;\n+\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((IN_RANGE (regno, FIRST_SSE_REG, LAST_SSE_REG)\n+\t || (TARGET_64BIT\n+\t     && (REX_SSE_REGNO_P (regno)\n+\t\t || (TARGET_AVX512F && EXT_REX_SSE_REGNO_P (regno)))))\n+\t&& !TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+      return NULL;\n+\n+  return gen_avx_vzeroall ();\n+}\n+\n+/* Generate insns to zero all st registers together.\n+   Return true when zeroing instructions are generated.\n+   Assume the number of st registers that are zeroed is num_of_st,\n+   we will emit the following sequence to zero them together:\n+\t\t  fldz;\t\t\\\n+\t\t  fldz;\t\t\\\n+\t\t  ...\n+\t\t  fldz;\t\t\\\n+\t\t  fstp %%st(0);\t\\\n+\t\t  fstp %%st(0);\t\\\n+\t\t  ...\n+\t\t  fstp %%st(0);\n+   i.e., num_of_st fldz followed by num_of_st fstp to clear the stack\n+   mark stack slots empty.\n+\n+   How to compute the num_of_st:\n+   There is no direct mapping from stack registers to hard register\n+   numbers.  If one stack register needs to be cleared, we don't know\n+   where in the stack the value remains.  So, if any stack register\n+   needs to be cleared, the whole stack should be cleared.  However,\n+   x87 stack registers that hold the return value should be excluded.\n+   x87 returns in the top (two for complex values) register, so\n+   num_of_st should be 7/6 when x87 returns, otherwise it will be 8.  */\n+\n+\n+static bool\n+zero_all_st_registers (HARD_REG_SET need_zeroed_hardregs)\n+{\n+  unsigned int num_of_st = 0;\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((STACK_REGNO_P (regno) || MMX_REGNO_P (regno))\n+\t&& TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+      {\n+\tnum_of_st++;\n+\tbreak;\n+      }\n+\n+  if (num_of_st == 0)\n+    return false;\n+\n+  bool return_with_x87 = false;\n+  return_with_x87 = (crtl->return_rtx\n+\t\t     && (STACK_REG_P (crtl->return_rtx)));\n+\n+  bool complex_return = false;\n+  complex_return = (crtl->return_rtx\n+\t\t    && COMPLEX_MODE_P (GET_MODE (crtl->return_rtx)));\n+\n+  if (return_with_x87)\n+    if (complex_return)\n+      num_of_st = 6;\n+    else\n+      num_of_st = 7;\n+  else\n+    num_of_st = 8;\n+\n+  rtx st_reg = gen_rtx_REG (XFmode, FIRST_STACK_REG);\n+  for (unsigned int i = 0; i < num_of_st; i++)\n+    emit_insn (gen_rtx_SET (st_reg, CONST0_RTX (XFmode)));\n+\n+  for (unsigned int i = 0; i < num_of_st; i++)\n+    {\n+      rtx insn;\n+      insn = emit_insn (gen_rtx_SET (st_reg, st_reg));\n+      add_reg_note (insn, REG_DEAD, st_reg);\n+    }\n+  return true;\n+}\n+\n+\n+/* When the routine exit in MMX mode, if any ST register needs\n+   to be zeroed, we should clear all MMX registers except the\n+   RET_MMX_REGNO that holds the return value.  */\n+static bool\n+zero_all_mm_registers (HARD_REG_SET need_zeroed_hardregs,\n+\t\t       unsigned int ret_mmx_regno)\n+{\n+  bool need_zero_all_mm = false;\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (STACK_REGNO_P (regno)\n+\t&& TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+      {\n+\tneed_zero_all_mm = true;\n+\tbreak;\n+      }\n+\n+  if (!need_zero_all_mm)\n+    return false;\n+\n+  rtx zero_mmx = NULL_RTX;\n+  machine_mode mode = V4HImode;\n+  for (unsigned int regno = FIRST_MMX_REG; regno <= LAST_MMX_REG; regno++)\n+    if (regno != ret_mmx_regno)\n+      {\n+\trtx reg = gen_rtx_REG (mode, regno);\n+\tif (zero_mmx == NULL_RTX)\n+\t  {\n+\t    zero_mmx = reg;\n+\t    emit_insn (gen_rtx_SET (reg, CONST0_RTX (mode)));\n+\t  }\n+\telse\n+\t  emit_move_insn (reg, zero_mmx);\n+      }\n+  return true;\n+}\n+\n+/* TARGET_ZERO_CALL_USED_REGS.  */\n+/* Generate a sequence of instructions that zero registers specified by\n+   NEED_ZEROED_HARDREGS.  Return the ZEROED_HARDREGS that are actually\n+   zeroed.  */\n+static HARD_REG_SET\n+ix86_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n+{\n+  HARD_REG_SET zeroed_hardregs;\n+  bool all_sse_zeroed = false;\n+  bool all_st_zeroed = false;\n+  bool all_mm_zeroed = false;\n+\n+  CLEAR_HARD_REG_SET (zeroed_hardregs);\n+\n+  /* first, let's see whether we can zero all vector registers together.  */\n+  rtx zero_all_vec_insn = zero_all_vector_registers (need_zeroed_hardregs);\n+  if (zero_all_vec_insn)\n+    {\n+      emit_insn (zero_all_vec_insn);\n+      all_sse_zeroed = true;\n+    }\n+\n+  /* mm/st registers are shared registers set, we should follow the following\n+     rules to clear them:\n+\t\t\tMMX exit mode\t      x87 exit mode\n+\t-------------|----------------------|---------------\n+\tuses x87 reg | clear all MMX\t    | clear all x87\n+\tuses MMX reg | clear individual MMX | clear all x87\n+\tx87 + MMX    | clear all MMX\t    | clear all x87\n+\n+     first, we should decide which mode (MMX mode or x87 mode) the function\n+     exit with.  */\n+\n+  bool exit_with_mmx_mode = (crtl->return_rtx\n+\t\t\t     && (MMX_REG_P (crtl->return_rtx)));\n+\n+  if (!exit_with_mmx_mode)\n+    /* x87 exit mode, we should zero all st registers together.  */\n+    {\n+      all_st_zeroed = zero_all_st_registers (need_zeroed_hardregs);\n+      if (all_st_zeroed)\n+\tSET_HARD_REG_BIT (zeroed_hardregs, FIRST_STACK_REG);\n+    }\n+  else\n+    /* MMX exit mode, check whether we can zero all mm registers.  */\n+    {\n+      unsigned int exit_mmx_regno = REGNO (crtl->return_rtx);\n+      all_mm_zeroed = zero_all_mm_registers (need_zeroed_hardregs,\n+\t\t\t\t\t     exit_mmx_regno);\n+      if (all_mm_zeroed)\n+\tfor (unsigned int regno = FIRST_MMX_REG; regno <= LAST_MMX_REG; regno++)\n+\t  if (regno != exit_mmx_regno)\n+\t    SET_HARD_REG_BIT (zeroed_hardregs, regno);\n+    }\n+\n+  /* Now, generate instructions to zero all the other registers.  */\n+\n+  rtx zero_gpr = NULL_RTX;\n+  rtx zero_vector = NULL_RTX;\n+  rtx zero_mask = NULL_RTX;\n+  rtx zero_mmx = NULL_RTX;\n+\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (!TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+\tcontinue;\n+      if (!zero_call_used_regno_p (regno, all_sse_zeroed,\n+\t\t\t\t   exit_with_mmx_mode && !all_mm_zeroed))\n+\tcontinue;\n+\n+      SET_HARD_REG_BIT (zeroed_hardregs, regno);\n+\n+      rtx reg, tmp, zero_rtx;\n+      machine_mode mode = zero_call_used_regno_mode (regno);\n+\n+      reg = gen_rtx_REG (mode, regno);\n+      zero_rtx = CONST0_RTX (mode);\n+\n+      if (mode == SImode)\n+\tif (zero_gpr == NULL_RTX)\n+\t  {\n+\t    zero_gpr = reg;\n+\t    tmp = gen_rtx_SET (reg, zero_rtx);\n+\t    if (!TARGET_USE_MOV0 || optimize_insn_for_size_p ())\n+\t      {\n+\t\trtx clob = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t    gen_rtx_REG (CCmode,\n+\t\t\t\t\t\t\t FLAGS_REG));\n+\t\ttmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2,\n+\t\t\t\t\t\t\t     tmp,\n+\t\t\t\t\t\t\t     clob));\n+\t      }\n+\t    emit_insn (tmp);\n+\t  }\n+\telse\n+\t  emit_move_insn (reg, zero_gpr);\n+      else if (mode == V4SFmode)\n+\tif (zero_vector == NULL_RTX)\n+\t  {\n+\t    zero_vector = reg;\n+\t    tmp = gen_rtx_SET (reg, zero_rtx);\n+\t    emit_insn (tmp);\n+\t  }\n+\telse\n+\t  emit_move_insn (reg, zero_vector);\n+      else if (mode == HImode)\n+\tif (zero_mask == NULL_RTX)\n+\t  {\n+\t    zero_mask = reg;\n+\t    tmp = gen_rtx_SET (reg, zero_rtx);\n+\t    emit_insn (tmp);\n+\t  }\n+\telse\n+\t  emit_move_insn (reg, zero_mask);\n+      else if (mode == V4HImode)\n+\tif (zero_mmx == NULL_RTX)\n+\t  {\n+\t    zero_mmx = reg;\n+\t    tmp = gen_rtx_SET (reg, zero_rtx);\n+\t    emit_insn (tmp);\n+\t  }\n+\telse\n+\t  emit_move_insn (reg, zero_mmx);\n+      else\n+\tgcc_unreachable ();\n+    }\n+  return zeroed_hardregs;\n+}\n+\n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n@@ -23310,6 +23601,9 @@ ix86_run_selftests (void)\n #undef TARGET_FUNCTION_VALUE_REGNO_P\n #define TARGET_FUNCTION_VALUE_REGNO_P ix86_function_value_regno_p\n \n+#undef TARGET_ZERO_CALL_USED_REGS\n+#define TARGET_ZERO_CALL_USED_REGS ix86_zero_call_used_regs\n+\n #undef TARGET_PROMOTE_FUNCTION_MODE\n #define TARGET_PROMOTE_FUNCTION_MODE ix86_promote_function_mode\n "}, {"sha": "9e75c13ccc615edebe250502c0cb6eabd74c246c", "filename": "gcc/df-scan.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -3614,6 +3614,14 @@ df_update_entry_block_defs (void)\n }\n \n \n+/* Return true if REGNO is used by the epilogue.  */\n+bool\n+df_epilogue_uses_p (unsigned int regno)\n+{\n+  return (EPILOGUE_USES (regno)\n+\t  || TEST_HARD_REG_BIT (crtl->must_be_zero_on_return, regno));\n+}\n+\n /* Set the bit for regs that are considered being used at the exit. */\n \n static void\n@@ -3661,7 +3669,7 @@ df_get_exit_block_use_set (bitmap exit_block_uses)\n      epilogue as being live at the end of the function since they\n      may be referenced by our caller.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (global_regs[i] || EPILOGUE_USES (i))\n+    if (global_regs[i] || df_epilogue_uses_p (i))\n       bitmap_set_bit (exit_block_uses, i);\n \n   if (targetm.have_epilogue () && epilogue_completed)\n@@ -3802,7 +3810,6 @@ df_hard_reg_init (void)\n   initialized = true;\n }\n \n-\n /* Recompute the parts of scanning that are based on regs_ever_live\n    because something changed in that array.  */\n \n@@ -3862,7 +3869,6 @@ df_regs_ever_live_p (unsigned int regno)\n   return regs_ever_live[regno];\n }\n \n-\n /* Set regs_ever_live[REGNO] to VALUE.  If this cause regs_ever_live\n    to change, schedule that change for the next update.  */\n "}, {"sha": "0f098d726d398d61b375b1b14ed1b3e03650d7d8", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -1085,6 +1085,7 @@ extern void df_update_entry_exit_and_calls (void);\n extern bool df_hard_reg_used_p (unsigned int);\n extern unsigned int df_hard_reg_used_count (unsigned int);\n extern bool df_regs_ever_live_p (unsigned int);\n+extern bool df_epilogue_uses_p (unsigned int);\n extern void df_set_regs_ever_live (unsigned int, bool);\n extern void df_compute_regs_ever_live (bool);\n extern void df_scan_verify (void);"}, {"sha": "f14772f7d3820cd0d0a155438c3333cbf4522a8c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -3996,6 +3996,92 @@ performing a link with relocatable output (i.e.@: @code{ld -r}) on them.\n A declaration to which @code{weakref} is attached and that is associated\n with a named @code{target} must be @code{static}.\n \n+@item zero_call_used_regs (\"@var{choice}\")\n+@cindex @code{zero_call_used_regs} function attribute\n+\n+The @code{zero_call_used_regs} attribute causes the compiler to zero\n+a subset of all call-used registers@footnote{A ``call-used'' register\n+is a register whose contents can be changed by a function call;\n+therefore, a caller cannot assume that the register has the same contents\n+on return from the function as it had before calling the function.  Such\n+registers are also called ``call-clobbered'', ``caller-saved'', or\n+``volatile''.} at function return.\n+This is used to increase program security by either mitigating\n+Return-Oriented Programming (ROP) attacks or preventing information leakage\n+through registers.\n+\n+In order to satisfy users with different security needs and control the\n+run-time overhead at the same time, the @var{choice} parameter provides a\n+flexible way to choose the subset of the call-used registers to be zeroed.\n+The three basic values of @var{choice} are:\n+\n+@itemize @bullet\n+@item\n+@samp{skip} doesn't zero any call-used registers.\n+\n+@item\n+@samp{used} only zeros call-used registers that are used in the function.\n+A ``used'' register is one whose content has been set or referenced in\n+the function.\n+\n+@item\n+@samp{all} zeros all call-used registers.\n+@end itemize\n+\n+In addition to these three basic choices, it is possible to modify\n+@samp{used} or @samp{all} as follows:\n+\n+@itemize @bullet\n+@item\n+Adding @samp{-gpr} restricts the zeroing to general-purpose registers.\n+\n+@item\n+Adding @samp{-arg} restricts the zeroing to registers that can sometimes\n+be used to pass function arguments.  This includes all argument registers\n+defined by the platform's calling conversion, regardless of whether the\n+function uses those registers for function arguments or not.\n+@end itemize\n+\n+The modifiers can be used individually or together.  If they are used\n+together, they must appear in the order above.\n+\n+The full list of @var{choice}s is therefore:\n+\n+@table @code\n+@item skip\n+doesn't zero any call-used register.\n+\n+@item used\n+only zeros call-used registers that are used in the function.\n+\n+@item used-gpr\n+only zeros call-used general purpose registers that are used in the function.\n+\n+@item used-arg\n+only zeros call-used registers that are used in the function and pass arguments.\n+\n+@item used-gpr-arg\n+only zeros call-used general purpose registers that are used in the function\n+and pass arguments.\n+\n+@item all\n+zeros all call-used registers.\n+\n+@item all-gpr\n+zeros all call-used general purpose registers.\n+\n+@item all-arg\n+zeros all call-used registers that pass arguments.\n+\n+@item all-gpr-arg\n+zeros all call-used general purpose registers that pass\n+arguments.\n+@end table\n+\n+Of this list, @samp{used-arg}, @samp{used-gpr-arg}, @samp{all-arg},\n+and @samp{all-gpr-arg} are mainly used for ROP mitigation.\n+\n+The default for the attribute is controlled by @option{-fzero-call-used-regs}.\n @end table\n \n @c This is the end of the target-independent attribute table"}, {"sha": "492b7dcdf10d852b342a8f6767908b0b8af39126", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -554,7 +554,7 @@ Objective-C and Objective-C++ Dialects}.\n -funit-at-a-time  -funroll-all-loops  -funroll-loops @gol\n -funsafe-math-optimizations  -funswitch-loops @gol\n -fipa-ra  -fvariable-expansion-in-unroller  -fvect-cost-model  -fvpt @gol\n--fweb  -fwhole-program  -fwpa  -fuse-linker-plugin @gol\n+-fweb  -fwhole-program  -fwpa  -fuse-linker-plugin -fzero-call-used-regs @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os  -Ofast  -Og}\n \n@@ -12648,6 +12648,19 @@ int foo (void)\n \n Not all targets support this option.\n \n+@item -fzero-call-used-regs=@var{choice}\n+@opindex fzero-call-used-regs\n+Zero call-used registers at function return to increase program\n+security by either mitigating Return-Oriented Programming (ROP)\n+attacks or preventing information leakage through registers.\n+\n+The possible values of @var{choice} are the same as for the\n+@code{zero_call_used_regs} attribute (@pxref{Function Attributes}).\n+The default is @samp{skip}.\n+\n+You can control this behavior for a specific function by using the function\n+attribute @code{zero_call_used_regs} (@pxref{Function Attributes}).\n+\n @item --param @var{name}=@var{value}\n @opindex param\n In some places, GCC uses various constants to control the amount of"}, {"sha": "833320ba7bfbea332d41cd38641c19ed9593366d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -12046,6 +12046,18 @@ argument list due to stack realignment.  Return @code{NULL} if no DRAP\n is needed.\n @end deftypefn\n \n+@deftypefn {Target Hook} HARD_REG_SET TARGET_ZERO_CALL_USED_REGS (HARD_REG_SET @var{selected_regs})\n+This target hook emits instructions to zero the subset of @var{selected_regs}\n+that could conceivably contain values that are useful to an attacker.\n+Return the set of registers that were actually cleared.\n+\n+The default implementation uses normal move instructions to zero\n+all the registers in @var{selected_regs}.  Define this hook if the\n+target has more efficient ways of zeroing certain registers,\n+or if you believe that certain registers would never contain\n+values that are useful to an attacker.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS (void)\n When optimization is disabled, this hook indicates whether or not\n arguments should be allocated to stack slots.  Normally, GCC allocates"}, {"sha": "58109be36932d89085240557da7be5664605946a", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -8109,6 +8109,8 @@ and the associated definitions of those functions.\n \n @hook TARGET_GET_DRAP_RTX\n \n+@hook TARGET_ZERO_CALL_USED_REGS\n+\n @hook TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\n \n @hook TARGET_CONST_ANCHOR"}, {"sha": "4658c4aa3fd1bee8c47ed7f31f76fdd183d62694", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -310,6 +310,9 @@ struct GTY(()) rtl_data {\n      sets them.  */\n   HARD_REG_SET asm_clobbers;\n \n+  /* All hard registers that need to be zeroed at the return of the routine.  */\n+  HARD_REG_SET must_be_zero_on_return;\n+\n   /* The highest address seen during shorten_branches.  */\n   int max_insn_address;\n };"}, {"sha": "a887c75cfc792030661c3b004c9569e6816cde8f", "filename": "gcc/flag-types.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_FLAG_TYPES_H\n #define GCC_FLAG_TYPES_H\n \n+#if !defined(IN_LIBGCC2) && !defined(IN_TARGET_LIBS) && !defined(IN_RTS)\n+\n enum debug_info_type\n {\n   NO_DEBUG,\t    /* Write no debug info.  */\n@@ -285,6 +287,24 @@ enum sanitize_code {\n \t\t\t\t  | SANITIZE_BOUNDS_STRICT\n };\n \n+/* Different settings for zeroing subset of registers.  */\n+namespace zero_regs_flags {\n+  const unsigned int UNSET = 0;\n+  const unsigned int SKIP = 1UL << 0;\n+  const unsigned int ONLY_USED = 1UL << 1;\n+  const unsigned int ONLY_GPR = 1UL << 2;\n+  const unsigned int ONLY_ARG = 1UL << 3;\n+  const unsigned int ENABLED = 1UL << 4;\n+  const unsigned int USED_GPR_ARG = ENABLED | ONLY_USED | ONLY_GPR | ONLY_ARG;\n+  const unsigned int USED_GPR = ENABLED | ONLY_USED | ONLY_GPR;\n+  const unsigned int USED_ARG = ENABLED | ONLY_USED | ONLY_ARG;\n+  const unsigned int USED = ENABLED | ONLY_USED;\n+  const unsigned int ALL_GPR_ARG = ENABLED | ONLY_GPR | ONLY_ARG;\n+  const unsigned int ALL_GPR = ENABLED | ONLY_GPR;\n+  const unsigned int ALL_ARG = ENABLED | ONLY_ARG;\n+  const unsigned int ALL = ENABLED;\n+}\n+\n /* Settings of flag_incremental_link.  */\n enum incremental_link {\n   INCREMENTAL_LINK_NONE,\n@@ -395,4 +415,6 @@ enum evrp_mode\n   EVRP_MODE_RVRP_DEBUG = EVRP_MODE_RVRP_ONLY | EVRP_MODE_DEBUG\n };\n \n+#endif\n+\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "004fa389207b366e01920b108cab78c1d7609179", "filename": "gcc/function.c", "status": "modified", "additions": 189, "deletions": 1, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -46,10 +46,12 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"expmed.h\"\n #include \"optabs.h\"\n+#include \"opts.h\"\n #include \"regs.h\"\n #include \"emit-rtl.h\"\n #include \"recog.h\"\n #include \"rtl-error.h\"\n+#include \"hard-reg-set.h\"\n #include \"alias.h\"\n #include \"fold-const.h\"\n #include \"stor-layout.h\"\n@@ -5815,6 +5817,103 @@ make_prologue_seq (void)\n   return seq;\n }\n \n+/* Emit a sequence of insns to zero the call-used registers before RET\n+   according to ZERO_REGS_TYPE.  */\n+\n+static void\n+gen_call_used_regs_seq (rtx_insn *ret, unsigned int zero_regs_type)\n+{\n+  bool only_gpr = true;\n+  bool only_used = true;\n+  bool only_arg = true;\n+\n+  /* No need to zero call-used-regs in main ().  */\n+  if (MAIN_NAME_P (DECL_NAME (current_function_decl)))\n+    return;\n+\n+  /* No need to zero call-used-regs if __builtin_eh_return is called\n+     since it isn't a normal function return.  */\n+  if (crtl->calls_eh_return)\n+    return;\n+\n+  /* If only_gpr is true, only zero call-used registers that are\n+     general-purpose registers; if only_used is true, only zero\n+     call-used registers that are used in the current function;\n+     if only_arg is true, only zero call-used registers that pass\n+     parameters defined by the flatform's calling conversion.  */\n+\n+  using namespace zero_regs_flags;\n+\n+  only_gpr = zero_regs_type & ONLY_GPR;\n+  only_used = zero_regs_type & ONLY_USED;\n+  only_arg = zero_regs_type & ONLY_ARG;\n+\n+  /* For each of the hard registers, we should zero it if:\n+\t    1. it is a call-used register;\n+\tand 2. it is not a fixed register;\n+\tand 3. it is not live at the return of the routine;\n+\tand 4. it is general registor if only_gpr is true;\n+\tand 5. it is used in the routine if only_used is true;\n+\tand 6. it is a register that passes parameter if only_arg is true.  */\n+\n+  /* First, prepare the data flow information.  */\n+  basic_block bb = BLOCK_FOR_INSN (ret);\n+  auto_bitmap live_out;\n+  bitmap_copy (live_out, df_get_live_out (bb));\n+  df_simulate_initialize_backwards (bb, live_out);\n+  df_simulate_one_insn_backwards (bb, ret, live_out);\n+\n+  HARD_REG_SET selected_hardregs;\n+  CLEAR_HARD_REG_SET (selected_hardregs);\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    {\n+      if (!crtl->abi->clobbers_full_reg_p (regno))\n+\tcontinue;\n+      if (fixed_regs[regno])\n+\tcontinue;\n+      if (REGNO_REG_SET_P (live_out, regno))\n+\tcontinue;\n+      if (only_gpr\n+\t  && !TEST_HARD_REG_BIT (reg_class_contents[GENERAL_REGS], regno))\n+\tcontinue;\n+      if (only_used && !df_regs_ever_live_p (regno))\n+\tcontinue;\n+      if (only_arg && !FUNCTION_ARG_REGNO_P (regno))\n+\tcontinue;\n+\n+      /* Now this is a register that we might want to zero.  */\n+      SET_HARD_REG_BIT (selected_hardregs, regno);\n+    }\n+\n+  if (hard_reg_set_empty_p (selected_hardregs))\n+    return;\n+\n+  /* Now that we have a hard register set that needs to be zeroed, pass it to\n+     target to generate zeroing sequence.  */\n+  HARD_REG_SET zeroed_hardregs;\n+  start_sequence ();\n+  zeroed_hardregs = targetm.calls.zero_call_used_regs (selected_hardregs);\n+  rtx_insn *seq = get_insns ();\n+  end_sequence ();\n+  if (seq)\n+    {\n+      /* Emit the memory blockage and register clobber asm volatile before\n+\t the whole sequence.  */\n+      start_sequence ();\n+      expand_asm_reg_clobber_mem_blockage (zeroed_hardregs);\n+      rtx_insn *seq_barrier = get_insns ();\n+      end_sequence ();\n+\n+      emit_insn_before (seq_barrier, ret);\n+      emit_insn_before (seq, ret);\n+\n+      /* Update the data flow information.  */\n+      crtl->must_be_zero_on_return |= zeroed_hardregs;\n+      df_set_bb_dirty (EXIT_BLOCK_PTR_FOR_FN (cfun));\n+    }\n+}\n+\n+\n /* Return a sequence to be used as the epilogue for the current function,\n    or NULL.  */\n \n@@ -6486,7 +6585,96 @@ make_pass_thread_prologue_and_epilogue (gcc::context *ctxt)\n {\n   return new pass_thread_prologue_and_epilogue (ctxt);\n }\n-\f\n+\n+namespace {\n+\n+const pass_data pass_data_zero_call_used_regs =\n+{\n+  RTL_PASS, /* type */\n+  \"zero_call_used_regs\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  0, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_zero_call_used_regs: public rtl_opt_pass\n+{\n+public:\n+  pass_zero_call_used_regs (gcc::context *ctxt)\n+    : rtl_opt_pass (pass_data_zero_call_used_regs, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_zero_call_used_regs\n+\n+unsigned int\n+pass_zero_call_used_regs::execute (function *fun)\n+{\n+  using namespace zero_regs_flags;\n+  unsigned int zero_regs_type = UNSET;\n+\n+  tree attr_zero_regs = lookup_attribute (\"zero_call_used_regs\",\n+\t\t\t\t\t  DECL_ATTRIBUTES (fun->decl));\n+\n+  /* Get the type of zero_call_used_regs from function attribute.\n+     We have filtered out invalid attribute values already at this point.  */\n+  if (attr_zero_regs)\n+    {\n+      /* The TREE_VALUE of an attribute is a TREE_LIST whose TREE_VALUE\n+\t is the attribute argument's value.  */\n+      attr_zero_regs = TREE_VALUE (attr_zero_regs);\n+      gcc_assert (TREE_CODE (attr_zero_regs) == TREE_LIST);\n+      attr_zero_regs = TREE_VALUE (attr_zero_regs);\n+      gcc_assert (TREE_CODE (attr_zero_regs) == STRING_CST);\n+\n+      for (unsigned int i = 0; zero_call_used_regs_opts[i].name != NULL; ++i)\n+\tif (strcmp (TREE_STRING_POINTER (attr_zero_regs),\n+\t\t     zero_call_used_regs_opts[i].name) == 0)\n+\t  {\n+\t    zero_regs_type = zero_call_used_regs_opts[i].flag;\n+ \t    break;\n+\t  }\n+    }\n+\n+  if (!zero_regs_type)\n+    zero_regs_type = flag_zero_call_used_regs;\n+\n+  /* No need to zero call-used-regs when no user request is present.  */\n+  if (!(zero_regs_type & ENABLED))\n+    return 0;\n+\n+  edge_iterator ei;\n+  edge e;\n+\n+  /* This pass needs data flow information.  */\n+  df_analyze ();\n+\n+  /* Iterate over the function's return instructions and insert any\n+     register zeroing required by the -fzero-call-used-regs command-line\n+     option or the \"zero_call_used_regs\" function attribute.  */\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+    {\n+      rtx_insn *insn = BB_END (e->src);\n+      if (JUMP_P (insn) && ANY_RETURN_P (JUMP_LABEL (insn)))\n+\tgen_call_used_regs_seq (insn, zero_regs_type);\n+    }\n+\n+  return 0;\n+}\n+\n+} // anon namespace\n+\n+rtl_opt_pass *\n+make_pass_zero_call_used_regs (gcc::context *ctxt)\n+{\n+  return new pass_zero_call_used_regs (ctxt);\n+}\n \n /* If CONSTRAINT is a matching constraint, then return its number.\n    Otherwise, return -1.  */"}, {"sha": "1820b91877acede9c7be9e0805f0cdc56174ddb8", "filename": "gcc/optabs.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -6484,6 +6484,48 @@ expand_memory_blockage (void)\n     expand_asm_memory_blockage ();\n }\n \n+/* Generate asm volatile(\"\" : : : \"memory\") as a memory blockage, at the\n+   same time clobbering the register set specified by REGS.  */\n+\n+void\n+expand_asm_reg_clobber_mem_blockage (HARD_REG_SET regs)\n+{\n+  rtx asm_op, clob_mem;\n+\n+  unsigned int num_of_regs = 0;\n+  for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    if (TEST_HARD_REG_BIT (regs, i))\n+      num_of_regs++;\n+\n+  asm_op = gen_rtx_ASM_OPERANDS (VOIDmode, \"\", \"\", 0,\n+\t\t\t\t rtvec_alloc (0), rtvec_alloc (0),\n+\t\t\t\t rtvec_alloc (0), UNKNOWN_LOCATION);\n+  MEM_VOLATILE_P (asm_op) = 1;\n+\n+  rtvec v = rtvec_alloc (num_of_regs + 2);\n+\n+  clob_mem = gen_rtx_SCRATCH (VOIDmode);\n+  clob_mem = gen_rtx_MEM (BLKmode, clob_mem);\n+  clob_mem = gen_rtx_CLOBBER (VOIDmode, clob_mem);\n+\n+  RTVEC_ELT (v, 0) = asm_op;\n+  RTVEC_ELT (v, 1) = clob_mem;\n+\n+  if (num_of_regs > 0)\n+    {\n+      unsigned int j = 2;\n+      for (unsigned int i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\tif (TEST_HARD_REG_BIT (regs, i))\n+\t  {\n+\t    RTVEC_ELT (v, j) = gen_rtx_CLOBBER (VOIDmode, regno_reg_rtx[i]);\n+ \t    j++;\n+\t  }\n+      gcc_assert (j == (num_of_regs + 2));\n+    }\n+\n+  emit_insn (gen_rtx_PARALLEL (VOIDmode, v));\n+}\n+\n /* This routine will either emit the mem_thread_fence pattern or issue a \n    sync_synchronize to generate a fence for memory model MEMMODEL.  */\n "}, {"sha": "bfa10c8f71b54eea667d5a743ef8486822e72e92", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -345,6 +345,8 @@ rtx expand_atomic_store (rtx, rtx, enum memmodel, bool);\n rtx expand_atomic_fetch_op (rtx, rtx, rtx, enum rtx_code, enum memmodel, \n \t\t\t      bool);\n \n+extern void expand_asm_reg_clobber_mem_blockage (HARD_REG_SET);\n+\n extern bool insn_operand_matches (enum insn_code icode, unsigned int opno,\n \t\t\t\t  rtx operand);\n extern bool valid_multiword_target_p (rtx);"}, {"sha": "96291e89a49dd1cf25a0cacc5a62413d120fa24d", "filename": "gcc/opts.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -1776,6 +1776,24 @@ const struct sanitizer_opts_s coverage_sanitizer_opts[] =\n   { NULL, 0U, 0UL, false }\n };\n \n+/* -fzero-call-used-regs= suboptions.  */\n+const struct zero_call_used_regs_opts_s zero_call_used_regs_opts[] =\n+{\n+#define ZERO_CALL_USED_REGS_OPT(name, flags) \\\n+    { #name, flags }\n+  ZERO_CALL_USED_REGS_OPT (skip, zero_regs_flags::SKIP),\n+  ZERO_CALL_USED_REGS_OPT (used-gpr-arg, zero_regs_flags::USED_GPR_ARG),\n+  ZERO_CALL_USED_REGS_OPT (used-gpr, zero_regs_flags::USED_GPR),\n+  ZERO_CALL_USED_REGS_OPT (used-arg, zero_regs_flags::USED_ARG),\n+  ZERO_CALL_USED_REGS_OPT (used, zero_regs_flags::USED),\n+  ZERO_CALL_USED_REGS_OPT (all-gpr-arg, zero_regs_flags::ALL_GPR_ARG),\n+  ZERO_CALL_USED_REGS_OPT (all-gpr, zero_regs_flags::ALL_GPR),\n+  ZERO_CALL_USED_REGS_OPT (all-arg, zero_regs_flags::ALL_ARG),\n+  ZERO_CALL_USED_REGS_OPT (all, zero_regs_flags::ALL),\n+#undef ZERO_CALL_USED_REGS_OPT\n+  {NULL, 0U}\n+};\n+\n /* A struct for describing a run of chars within a string.  */\n \n class string_fragment\n@@ -1970,6 +1988,27 @@ parse_no_sanitize_attribute (char *value)\n   return flags;\n }\n \n+/* Parse -fzero-call-used-regs suboptions from ARG, return the FLAGS.  */\n+\n+unsigned int\n+parse_zero_call_used_regs_options (const char *arg)\n+{\n+  unsigned int flags = 0;\n+\n+  /* Check to see if the string matches a sub-option name.  */\n+  for (unsigned int i = 0; zero_call_used_regs_opts[i].name != NULL; ++i)\n+    if (strcmp (arg, zero_call_used_regs_opts[i].name) == 0)\n+      {\n+\tflags = zero_call_used_regs_opts[i].flag;\n+\tbreak;\n+      }\n+\n+  if (!flags)\n+    error (\"unrecognized argument to %<-fzero-call-used-regs=%>: %qs\", arg);\n+\n+  return flags;\n+}\n+\n /* Parse -falign-NAME format for a FLAG value.  Return individual\n    parsed integer values into RESULT_VALUES array.  If REPORT_ERROR is\n    set, print error message at LOC location.  */\n@@ -2596,6 +2635,11 @@ common_handle_option (struct gcc_options *opts,\n       /* Automatically sets -ftree-loop-vectorize and\n \t -ftree-slp-vectorize.  Nothing more to do here.  */\n       break;\n+    case OPT_fzero_call_used_regs_:\n+      opts->x_flag_zero_call_used_regs\n+\t= parse_zero_call_used_regs_options (arg);\n+      break;\n+\n     case OPT_fshow_column:\n       dc->show_column = value;\n       break;"}, {"sha": "7d1e126f217cbe80a19feaa5cc5434b9839529d1", "filename": "gcc/opts.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -444,6 +444,12 @@ extern const struct sanitizer_opts_s\n   bool can_recover;\n } sanitizer_opts[];\n \n+extern const struct zero_call_used_regs_opts_s\n+{\n+  const char *const name;\n+  unsigned int flag;\n+} zero_call_used_regs_opts[];\n+\n extern vec<const char *> help_option_arguments;\n \n extern void add_misspelling_candidates (auto_vec<char *> *candidates,"}, {"sha": "4ca04de3a7425b06ada4fda3c9dc22dd897625db", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -491,6 +491,7 @@ along with GCC; see the file COPYING3.  If not see\n       POP_INSERT_PASSES ()\n       NEXT_PASS (pass_late_compilation);\n       PUSH_INSERT_PASSES_WITHIN (pass_late_compilation)\n+\t  NEXT_PASS (pass_zero_call_used_regs);\n \t  NEXT_PASS (pass_compute_alignments);\n \t  NEXT_PASS (pass_variable_tracking);\n \t  NEXT_PASS (pass_free_cfg);"}, {"sha": "45a52e284e1c6cbbedaaedc13d5bd66750d0002a", "filename": "gcc/recog.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -922,7 +922,23 @@ validate_simplify_insn (rtx_insn *insn)\n       }\n   return ((num_changes_pending () > 0) && (apply_change_group () > 0));\n }\n-\f\n+\n+/* Check whether INSN matches a specific alternative of an .md pattern.  */\n+\n+bool\n+valid_insn_p (rtx_insn *insn)\n+{\n+  recog_memoized (insn);\n+  if (INSN_CODE (insn) < 0)\n+    return false;\n+  extract_insn (insn);\n+  /* We don't know whether the insn will be in code that is optimized\n+     for size or speed, so consider all enabled alternatives.  */\n+  if (!constrain_operands (1, get_enabled_alternatives (insn)))\n+    return false;\n+  return true;\n+}\n+\n /* Return 1 if OP is a valid general operand for machine mode MODE.\n    This is either a register reference, a memory reference,\n    or a constant.  In the case of a memory reference, the address"}, {"sha": "d87456c257f519fe842c52f383d73609ae16050a", "filename": "gcc/recog.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -113,6 +113,7 @@ extern void validate_replace_src_group (rtx, rtx, rtx_insn *);\n extern bool validate_simplify_insn (rtx_insn *insn);\n extern int num_changes_pending (void);\n extern bool reg_fits_class_p (const_rtx, reg_class_t, int, machine_mode);\n+extern bool valid_insn_p (rtx_insn *);\n \n extern int offsettable_memref_p (rtx);\n extern int offsettable_nonstrict_memref_p (rtx);"}, {"sha": "90cf091652b8f89f06452745f5bbf11e3ef847d1", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -1186,7 +1186,7 @@ init_resource_info (rtx_insn *epilogue_insn)\n \t\t\t       &end_of_function_needs, true);\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (global_regs[i] || EPILOGUE_USES (i))\n+    if (global_regs[i] || df_epilogue_uses_p (i))\n       SET_HARD_REG_BIT (end_of_function_needs.regs, i);\n \n   /* The registers required to be live at the end of the function are"}, {"sha": "b916635be1816ee05327736e3ac4631a1214fba9", "filename": "gcc/target.def", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -5080,6 +5080,21 @@ argument list due to stack realignment.  Return @code{NULL} if no DRAP\\n\\\n is needed.\",\n  rtx, (void), NULL)\n \n+/* Generate instruction sequence to zero call used registers.  */\n+DEFHOOK\n+(zero_call_used_regs,\n+ \"This target hook emits instructions to zero the subset of @var{selected_regs}\\n\\\n+that could conceivably contain values that are useful to an attacker.\\n\\\n+Return the set of registers that were actually cleared.\\n\\\n+\\n\\\n+The default implementation uses normal move instructions to zero\\n\\\n+all the registers in @var{selected_regs}.  Define this hook if the\\n\\\n+target has more efficient ways of zeroing certain registers,\\n\\\n+or if you believe that certain registers would never contain\\n\\\n+values that are useful to an attacker.\",\n+ HARD_REG_SET, (HARD_REG_SET selected_regs),\n+default_zero_call_used_regs)\n+\n /* Return true if all function parameters should be spilled to the\n    stack.  */\n DEFHOOK"}, {"sha": "4e4d100c5470bc48d6347fcd501aeb03b1d7d851", "filename": "gcc/targhooks.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -56,6 +56,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-alias.h\"\n #include \"gimple-expr.h\"\n #include \"memmodel.h\"\n+#include \"backend.h\"\n+#include \"emit-rtl.h\"\n+#include \"df.h\"\n #include \"tm_p.h\"\n #include \"stringpool.h\"\n #include \"tree-vrp.h\"\n@@ -987,6 +990,35 @@ default_function_value_regno_p (const unsigned int regno ATTRIBUTE_UNUSED)\n #endif\n }\n \n+/* The default hook for TARGET_ZERO_CALL_USED_REGS.  */\n+\n+HARD_REG_SET\n+default_zero_call_used_regs (HARD_REG_SET need_zeroed_hardregs)\n+{\n+  gcc_assert (!hard_reg_set_empty_p (need_zeroed_hardregs));\n+\n+  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if (TEST_HARD_REG_BIT (need_zeroed_hardregs, regno))\n+      {\n+\trtx_insn *last_insn = get_last_insn ();\n+\tmachine_mode mode = GET_MODE (regno_reg_rtx[regno]);\n+\trtx zero = CONST0_RTX (mode);\n+\trtx_insn *insn = emit_move_insn (regno_reg_rtx[regno], zero);\n+\tif (!valid_insn_p (insn))\n+\t  {\n+\t    static bool issued_error;\n+\t    if (!issued_error)\n+\t      {\n+\t\tissued_error = true;\n+\t\tsorry (\"%qs not supported on this target\",\n+\t\t\t\"-fzero-call-used_regs\");\n+\t      }\n+\t    delete_insns_since (last_insn);\n+\t  }\n+      }\n+  return need_zeroed_hardregs;\n+}\n+\n rtx\n default_internal_arg_pointer (void)\n {"}, {"sha": "e0a925fa2bee2e73f82d244fe4364afc87eff7d2", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -160,6 +160,7 @@ extern unsigned int default_function_arg_round_boundary (machine_mode,\n \t\t\t\t\t\t\t const_tree);\n extern bool hook_bool_const_rtx_commutative_p (const_rtx, int);\n extern rtx default_function_value (const_tree, const_tree, bool);\n+extern HARD_REG_SET default_zero_call_used_regs (HARD_REG_SET);\n extern rtx default_libcall_value (machine_mode, const_rtx);\n extern bool default_function_value_regno_p (const unsigned int);\n extern rtx default_internal_arg_pointer (void);"}, {"sha": "2463353a12eebab7fb07eb97fd27df2443330e5b", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-1.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+volatile int result = 0;\n+int \n+__attribute__((noipa))\n+foo (int x)\n+{\n+  return x;\n+}\n+int main()\n+{\n+  result = foo (2);\n+  return 0;\n+}"}, {"sha": "bdaf8e7decbf31fe8c3fc8945b741e8e810271b7", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-10.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-10.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+\n+#include <assert.h>\n+int result = 0;\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"skip\")))\n+foo1 (int x)\n+{\n+  return (x + 1);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"used-gpr-arg\")))\n+foo2 (int x)\n+{\n+  return (x + 2);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"used-gpr\")))\n+foo3 (int x)\n+{\n+  return (x + 3);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"used-arg\")))\n+foo4 (int x)\n+{\n+  return (x + 4);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"used\")))\n+foo5 (int x)\n+{\n+  return (x + 5);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"all-gpr-arg\")))\n+foo6 (int x)\n+{\n+  return (x + 6);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"all-gpr\")))\n+foo7 (int x)\n+{\n+  return (x + 7);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"all-arg\")))\n+foo8 (int x)\n+{\n+  return (x + 8);\n+}\n+\n+int \n+__attribute__((noipa))\n+__attribute__ ((zero_call_used_regs(\"all\")))\n+foo9 (int x)\n+{\n+  return (x + 9);\n+}\n+\n+int main()\n+{\n+  result = foo1 (1);\n+  result += foo2 (1);\n+  result += foo3 (1);\n+  result += foo4 (1);\n+  result += foo5 (1);\n+  result += foo6 (1);\n+  result += foo7 (1);\n+  result += foo8 (1);\n+  result += foo9 (1);\n+  assert (result == 54);\n+  return 0;\n+}"}, {"sha": "7721e395e52bb3c169e51fd59c1363d1daca9e49", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-11.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-11.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all\" } */\n+\n+#include \"zero-scratch-regs-10.c\""}, {"sha": "25891acbe42dd7ffec8f56eda28ebb306c8ae9af", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-2.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-2.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-gpr-arg\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "7c3d286d772ce04ebb3187b5001bd864674b35e8", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-3.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-3.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-gpr\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "ba28c06c584bd8152d9013abc9fb7f0cb802d745", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-4.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-4.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-arg\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "26679a4a3962999b9a97c5925b38359ee55932db", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-5.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-5.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "80f5bbb632a6796895e62972208048f4b2c26a8c", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-6.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-6.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr-arg\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "159f35cb047506cd1ccbd330a0c987a89d8e5364", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-7.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-7.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "c1faaf0f43a501bc615b0aed8aee466b11ebca8e", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-8.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-8.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-arg\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "3f14bac67c02d7e06771de2e3a663f7d56e65d4a", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-9.c", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-9.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,4 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all\" } */\n+\n+#include \"zero-scratch-regs-1.c\""}, {"sha": "1e757952ada566964cab3d83883a7cf31402d50a", "filename": "gcc/testsuite/c-c++-common/zero-scratch-regs-attr-usages.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-attr-usages.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-attr-usages.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fzero-scratch-regs-attr-usages.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+int result __attribute__ ((zero_call_used_regs(\"all\"))); /* { dg-error \"attribute applies only to functions\" } */\n+int\n+__attribute__ ((zero_call_used_regs(\"gpr-arg-all\")))\n+foo1 (int x) /* { dg-error \"unrecognized 'zero_call_used_regs' attribute argument\" } */\n+{\n+  return (x + 1);\n+}\n+int\n+__attribute__ ((zero_call_used_regs(1)))\n+foo2 (int x) /* { dg-error \"argument not a string\" } */\n+{\n+  return (x + 2);\n+}"}, {"sha": "9f61dc4c863277856e5acad158f36a8c68817b6c", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-1.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "09048e57f9460890d0766a6cb58bfd053adbb2ec", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-10.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-10.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+extern int foo (int) __attribute__ ((zero_call_used_regs(\"all-gpr\")));\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edx, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "4862688996550c39afa8e1369528194e4bff80d6", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-11.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-11.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-gpr\" } */\n+\n+struct S { int i; };\n+__attribute__((const, noinline, noclone))\n+struct S foo (int x)\n+{\n+  struct S s;\n+  s.i = x;\n+  return s;\n+}\n+\n+int a[2048], b[2048], c[2048], d[2048];\n+struct S e[2048];\n+\n+__attribute__((noinline, noclone)) void\n+bar (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      e[i] = foo (i);\n+      a[i+2] = a[i] + a[i+1];\n+      b[10] = b[10] + i;\n+      c[i] = c[2047 - i];\n+      d[i] = d[i + 1];\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  bar ();\n+  for (i = 0; i < 1024; i++)\n+    if (e[i].i != i)\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "500251b450f508489faae85274b7d189420bd1eb", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-12.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-12.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr\" } */\n+\n+struct S { int i; };\n+__attribute__((const, noinline, noclone))\n+struct S foo (int x)\n+{\n+  struct S s;\n+  s.i = x;\n+  return s;\n+}\n+\n+int a[2048], b[2048], c[2048], d[2048];\n+struct S e[2048];\n+\n+__attribute__((noinline, noclone)) void\n+bar (void)\n+{\n+  int i;\n+  for (i = 0; i < 1024; i++)\n+    {\n+      e[i] = foo (i);\n+      a[i+2] = a[i] + a[i+1];\n+      b[10] = b[10] + i;\n+      c[i] = c[2047 - i];\n+      d[i] = d[i + 1];\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+  bar ();\n+  for (i = 0; i < 1024; i++)\n+    if (e[i].i != i)\n+      __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "8b058e35540d3d08a6958c7f7282c2f08e7bff0a", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-13.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-13.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all -march=corei7\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm0, %xmm0\" } } */\n+/* { dg-final { scan-assembler-times \"movaps\\[ \\t\\]*%xmm0, %xmm\\[0-9\\]+\" 7 { target { ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movaps\\[ \\t\\]*%xmm0, %xmm\\[0-9\\]+\" 15 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "d4eaaf7f383eb556e15aeec07753f0e595f97a9c", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-14.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-14.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all -march=corei7 -mavx\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-times \"vzeroall\" 1 } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "dd3bb90aa7dd39e277276c27439526ab4ec6e92b", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-15.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-15.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+extern void foo (void) __attribute__ ((zero_call_used_regs(\"used\")));\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "e2274f66a5ef769e62aa5c0cb6f4652919669e62", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-16.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-16.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all\" } */\n+\n+extern void foo (void) __attribute__ ((zero_call_used_regs(\"skip\")));\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "7f5d153088f1cba62a21a23c3c11a8c722f6304e", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-17.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-17.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used\" } */\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edi, %edi\" { target { ! ia32 } } } } */"}, {"sha": "fe13d2b4f133eaf353eb6534ab5d1d6ad1617f53", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-18.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-18.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used -march=corei7\" } */\n+\n+float\n+foo (float z, float y, float x)\n+{\n+  return x + y;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm1, %xmm1\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm1, %xmm2\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */"}, {"sha": "205a5323c560c5c2a5f784b986d1c67882410514", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-19.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-19.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used -march=corei7\" } */\n+\n+float\n+foo (float z, float y, float x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm2, %xmm2\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */"}, {"sha": "e046684dc78351a264a6c15213a14af80d46d436", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-2.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "4be8ff6e65a1dd05948818a4841dfd6e493121d4", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-20.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-20.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all -march=corei7\" } */\n+\n+float\n+foo (float z, float y, float x)\n+{\n+  return x + y;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm0, %xmm0\" { target { ia32 } } } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm1, %xmm1\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movaps\\[ \\t\\]*%xmm0, %xmm\\[0-9\\]+\" 7 { target { ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"movaps\\[ \\t\\]*%xmm1, %xmm\\[0-9\\]+\" 14 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "0eb34e086dbede1c7684989deaa84d61463d8d52", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-21.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-21.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip -march=corei7\" } */\n+\n+__attribute__ ((zero_call_used_regs(\"used\")))\n+float\n+foo (float z, float y, float x)\n+{\n+  return x + y;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm1, %xmm1\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm1, %xmm2\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */"}, {"sha": "0258c707a8627852b54f6b074b25693a15cfd4d1", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-22.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-22.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all -march=corei7 -mavx\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-times \"fldz\" 8 } } */\n+/* { dg-final { scan-assembler-times \"fstp\" 8 } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "0625eb534b8a578a006e5064cb96e5294a175c64", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-23.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-23.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-23.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-23.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all -march=corei7 -mavx512f\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-times \"fldz\" 8 } } */\n+/* { dg-final { scan-assembler-times \"fstp\" 8 } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kxorw\\[ \\t\\]*%k0, %k0, %k0\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k1\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k2\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k3\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k4\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k5\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k6\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"kmovw\\[ \\t\\]*%k0, %k7\" { target { ! ia32 } } } } */"}, {"sha": "208633e8d9dab212f1735911759b39fab600c1e4", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-24.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-24.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-gpr-arg\" } */\n+\n+int \n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edi, %edi\" } } */"}, {"sha": "21e82c6d3c9619b7dddb6f5799c487c602c0bba7", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-25.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-25.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-arg\" } */\n+\n+int \n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edi, %edi\" } } */"}, {"sha": "293d2fec7f7a6e700f36abd62e4372e932a17d49", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-26.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-26.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-arg\" } */\n+\n+int \n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edx, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %esi\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %edi\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r8d\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r9d\" } } */\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%xmm0, %xmm0\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm1\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm2\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm3\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm4\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm5\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm6\" } } */\n+/* { dg-final { scan-assembler \"movaps\\[ \\t\\]*%xmm0, %xmm7\" } } */"}, {"sha": "c34e6af21634e17e92a0efd694ebbf494745eb3f", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-27.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-27.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-27.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-27.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr-arg\" } */\n+\n+int \n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edx, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %esi\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %edi\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r8d\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r9d\" } } */"}, {"sha": "48b1f019a28291632d221879d3d70decad6f0bdc", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-28.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-28.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mmmx -fzero-call-used-regs=all\" } */\n+/* { dg-require-effective-target ia32 } */\n+\n+__v2si ret_mmx (void)\n+{\n+  return (__v2si) { 123, 345 };\n+}\n+\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%mm1, %mm1\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm2\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm3\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm4\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm5\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm6\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm7\" } } */"}, {"sha": "8b5e1cd16027a8176de2196333c312c886893355", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-29.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-29.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all\" } */\n+\n+long double ret_x87 (void)\n+{\n+  return 1.1L;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fldz\" 7 } } */\n+/* { dg-final { scan-assembler-times \"fstp\" 7 } } */"}, {"sha": "de71223bb58b806741627db5bf8a79f9764a6140", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-3.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-3.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "2a6f38f366320a9600c243b5a2f8128d88c02b34", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-30.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-30.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2  -fzero-call-used-regs=all\" } */\n+\n+_Complex long double ret_x87_cplx (void)\n+{\n+  return 1.1L + 1.2iL;\n+}\n+\n+/* { dg-final { scan-assembler-times \"fldz\" 8 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"fstp\" 8 { target ia32 } } } */\n+/* { dg-final { scan-assembler-times \"fldz\" 6 { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler-times \"fstp\" 6 { target { ! ia32 } } } } */"}, {"sha": "df712860f504a010d83e3429abb280b0e04d5b0a", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-31.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-31.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -mmmx -fzero-call-used-regs=all-arg\" } */\n+/* { dg-require-effective-target ia32 } */\n+\n+__v2si ret_mmx (void)\n+{\n+  return (__v2si) { 123, 345 };\n+}\n+\n+/* { dg-final { scan-assembler \"pxor\\[ \\t\\]*%mm1, %mm1\" } } */\n+/* { dg-final { scan-assembler \"movq\\[ \\t\\]*%mm1, %mm2\" } } */\n+/* { dg-final { scan-assembler-not \"movq\\[ \\t\\]*%mm1, %mm\\[34567\\]\" } } */"}, {"sha": "ccfa441bea03f719008df0496ed8c91356f078de", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-4.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+extern void foo (void) __attribute__ ((zero_call_used_regs(\"used-gpr\")));\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "6b46ca39a8d968a210b5b51783880cf6d2d2efd3", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-5.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-5.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+__attribute__ ((zero_call_used_regs(\"all-gpr\")))\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%eax, %eax\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%eax, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "0680f38c68dc490a5a4f356b9aa21998b809d60a", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-6.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr\" } */\n+\n+extern void foo (void) __attribute__ ((zero_call_used_regs(\"skip\")));\n+\n+void\n+foo (void)\n+{\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" } } */\n+/* { dg-final { scan-assembler-not \"movl\\[ \\t\\]*%\" } } */"}, {"sha": "534defae162c3fadec5e4cb3f477966ce0464289", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-7.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=used-gpr\" } */\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edi, %edi\" { target { ! ia32 } } } } */"}, {"sha": "477bb192d0c1baf5c5aac5912a73da42498bffc8", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-8.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=all-gpr\" } */\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edx, %edx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %ecx\" } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %esi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %edi\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r8d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r9d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r10d\" { target { ! ia32 } } } } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]*%edx, %r11d\" { target { ! ia32 } } } } */"}, {"sha": "a305a60deacd9138165a4f48d6eacfc8102d897f", "filename": "gcc/testsuite/gcc.target/i386/zero-scratch-regs-9.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzero-scratch-regs-9.c?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target *-*-linux* } } */\n+/* { dg-options \"-O2 -fzero-call-used-regs=skip\" } */\n+\n+extern int foo (int) __attribute__ ((zero_call_used_regs(\"used-gpr\")));\n+\n+int\n+foo (int x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-not \"vzeroall\" } } */\n+/* { dg-final { scan-assembler-not \"%xmm\" } } */\n+/* { dg-final { scan-assembler-not \"xorl\\[ \\t\\]*%\" { target ia32 } } } */\n+/* { dg-final { scan-assembler \"xorl\\[ \\t\\]*%edi, %edi\" { target { ! ia32 } } } } */"}, {"sha": "3410ca9bc02208a38e7e56b2d4277b8d6fb6748d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d10f3e900b0377b4760a090b0f90371bcef01686/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=d10f3e900b0377b4760a090b0f90371bcef01686", "patch": "@@ -590,6 +590,7 @@ extern rtl_opt_pass *make_pass_gcse2 (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_split_after_reload (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_thread_prologue_and_epilogue (gcc::context\n \t\t\t\t\t\t\t     *ctxt);\n+extern rtl_opt_pass *make_pass_zero_call_used_regs (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_stack_adjustments (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_sched_fusion (gcc::context *ctxt);\n extern rtl_opt_pass *make_pass_peephole2 (gcc::context *ctxt);"}]}