{"sha": "21ed44440fc2b6148425eb156452507629018b18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFlZDQ0NDQwZmMyYjYxNDg0MjVlYjE1NjQ1MjUwNzYyOTAxOGIxOA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2012-06-01T05:49:16Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2012-06-01T05:49:16Z"}, "message": "Add CRIS atomic patterns for 1, 2, and 4 bytes.\n\n\t* config/cris/cris.c (cris_emit_trap_for_misalignment): New function.\n\t* config/cris/cris-protos.h: Declare it.\n\t* config/cris/cris.h [!TARGET_DEFAULT, TARGET_CPU_DEFAULT == 32] \n\t(TARGET_DEFAULT): Add alignment by 32.\n\t[!TARGET_DEFAULT, TARGET_CPU_DEFAULT == 10] (TARGET_DEFAULT): New\n\tcase, as TARGET_CPU_DEFAULT == 0 but with alignment as for\n\tTARGET_CPU_DEFAULT == 32. \n\t(TARGET_TRAP_UNALIGNED_ATOMIC): New macro.\n\t* config/cris/cris.md: Include sync.md.  Avoid allocating specific\n\tnumbers by replacing the define_constants for all UNSPECs with the\n\tequivalent define_c_enum construct.\n\t* config/cris/cris.opt (mtrap-unaligned-atomic): New option.\n\t* config/cris/sync.md: New file.\n\nFrom-SVN: r188096", "tree": {"sha": "3748c4b19fefbeba9a6320eb38c3640e4c85681f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3748c4b19fefbeba9a6320eb38c3640e4c85681f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21ed44440fc2b6148425eb156452507629018b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ed44440fc2b6148425eb156452507629018b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21ed44440fc2b6148425eb156452507629018b18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21ed44440fc2b6148425eb156452507629018b18/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "183d6a7e728f6c53827ac48060e7a4fb0529b09f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/183d6a7e728f6c53827ac48060e7a4fb0529b09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/183d6a7e728f6c53827ac48060e7a4fb0529b09f"}], "stats": {"total": 393, "additions": 379, "deletions": 14}, "files": [{"sha": "6f3460290589d32907f8d95abaade5e4cef18b96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -1,3 +1,20 @@\n+2012-06-01  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tAdd CRIS atomic patterns for 1, 2, and 4 bytes.\n+\t* config/cris/cris.c (cris_emit_trap_for_misalignment): New function.\n+\t* config/cris/cris-protos.h: Declare it.\n+\t* config/cris/cris.h [!TARGET_DEFAULT, TARGET_CPU_DEFAULT == 32] \n+\t(TARGET_DEFAULT): Add alignment by 32.\n+\t[!TARGET_DEFAULT, TARGET_CPU_DEFAULT == 10] (TARGET_DEFAULT): New\n+\tcase, as TARGET_CPU_DEFAULT == 0 but with alignment as for\n+\tTARGET_CPU_DEFAULT == 32. \n+\t(TARGET_TRAP_UNALIGNED_ATOMIC): New macro.\n+\t* config/cris/cris.md: Include sync.md.  Avoid allocating specific\n+\tnumbers by replacing the define_constants for all UNSPECs with the\n+\tequivalent define_c_enum construct.\n+\t* config/cris/cris.opt (mtrap-unaligned-atomic): New option.\n+\t* config/cris/sync.md: New file.\n+\n 2012-05-31  Matt Turner  <mattst88@gmail.com>\n \n \t* config/mips/4600.md (r4600_imul_si): Rename from r4600_imul."}, {"sha": "8d2d59cbc5c557001ddf64391477371d85fa6b83", "filename": "gcc/config/cris/cris-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -49,6 +49,7 @@ extern rtx cris_gen_movem_load (rtx, rtx, int);\n extern rtx cris_emit_movem_store (rtx, rtx, int, bool);\n extern void cris_expand_pic_call_address (rtx *);\n extern void cris_order_for_addsi3 (rtx *, int);\n+extern void cris_emit_trap_for_misalignment (rtx);\n #endif /* RTX_CODE */\n extern void cris_asm_output_label_ref (FILE *, char *);\n extern void cris_target_asm_named_section (const char *, unsigned int, tree);"}, {"sha": "947a6a5141650523ddb20c75fee03f068cf1593b", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -1922,6 +1922,39 @@ cris_simple_epilogue (void)\n   return true;\n }\n \n+/* Emit checking that MEM is aligned for an access in MODE, failing\n+   that, executing a \"break 8\" (or call to abort, if \"break 8\" is\n+   disabled).  */\n+\n+void\n+cris_emit_trap_for_misalignment (rtx mem)\n+{\n+  rtx addr, reg, ok_label, and, jmp;\n+  int natural_alignment;\n+  gcc_assert (MEM_P (mem));\n+\n+  natural_alignment = GET_MODE_SIZE (GET_MODE (mem));\n+  addr = XEXP (mem, 0);\n+  reg = force_reg (Pmode, addr);\n+  ok_label = gen_label_rtx ();\n+\n+  /* This will yield a btstq without a separate register used, usually -\n+     with the exception for PRE hoisting the \"and\" but not the branch\n+     around the trap: see gcc.dg/target/cris/sync-3s.c.  */\n+  and = gen_rtx_AND (Pmode, reg, GEN_INT (natural_alignment - 1));\n+  emit_cmp_and_jump_insns (force_reg (SImode, and), const0_rtx, EQ,\n+\t\t\t   NULL_RTX, Pmode, 1, ok_label);\n+  jmp = get_last_insn ();\n+  gcc_assert (JUMP_P (jmp));\n+\n+  /* While this isn't mudflap, it is a similar kind of assertion.\n+     If PRED_MUDFLAP stops working, use something else or introduce a\n+     more suitable assertion predication type.  */\n+  predict_insn_def (jmp, PRED_MUDFLAP, TAKEN);\n+  expand_builtin_trap ();\n+  emit_label (ok_label);\n+}\n+\n /* Expand a return insn (just one insn) marked as using SRP or stack\n    slot depending on parameter ON_STACK.  */\n "}, {"sha": "0660b494a4939ed84e9ab78b57ec0518f93d2861", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -286,15 +286,25 @@ extern int cris_cpu_version;\n #define TARGET_CPU_DEFAULT CRIS_CPU_BASE\n #endif\n \n-/* Default target_flags if no switches specified.  */\n+/* Default target_flags if no switches specified.\n+   The alignment-by-32 is to make builtin atomic support for v10 and v32\n+   work for *-elf for types without specified alignment (like plain\n+   \"int\").  See top comment in sync.md.  */\n #ifndef TARGET_DEFAULT\n # if TARGET_CPU_DEFAULT == 32\n #  define TARGET_DEFAULT \\\n  (MASK_STACK_ALIGN \\\n   + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n+  + MASK_ALIGN_BY_32 \\\n   + MASK_PROLOGUE_EPILOGUE)\n-# else  /* 10 */\n-# define TARGET_DEFAULT \\\n+# elif TARGET_CPU_DEFAULT == 10\n+#  define TARGET_DEFAULT \\\n+ (MASK_SIDE_EFFECT_PREFIXES + MASK_STACK_ALIGN \\\n+  + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n+  + MASK_ALIGN_BY_32 \\\n+  + MASK_PROLOGUE_EPILOGUE + MASK_MUL_BUG)\n+# else  /* 0 */\n+#  define TARGET_DEFAULT \\\n  (MASK_SIDE_EFFECT_PREFIXES + MASK_STACK_ALIGN \\\n   + MASK_CONST_ALIGN + MASK_DATA_ALIGN \\\n   + MASK_PROLOGUE_EPILOGUE + MASK_MUL_BUG)\n@@ -314,6 +324,16 @@ extern int cris_cpu_version;\n #define TARGET_TRAP_USING_BREAK8 \\\n  (cris_trap_using_break8 == 2 ? TARGET_HAS_BREAK : cris_trap_using_break8)\n \n+/* The < v10 atomics turn off interrupts, so they don't need alignment.\n+   Incidentally, by default alignment is off there causing variables to\n+   be default unaligned all over, so we'd have to make support\n+   libraries use a proper atomic type (instead of \"int\"), one we'd\n+   specify as aligned.  */\n+#define TARGET_TRAP_UNALIGNED_ATOMIC\t\t\\\n+ (cris_trap_unaligned_atomic == 2\t\t\\\n+  ? (TARGET_V32 || cris_cpu_version == 10)\t\\\n+  : cris_trap_unaligned_atomic)\n+\n /* Node: Storage Layout */\n \n #define BITS_BIG_ENDIAN 0"}, {"sha": "4b9d4c3986db9ee47d129b45084db22137950f89", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -55,46 +55,46 @@\n ;; The movsi for a gotless symbol could be split (post reload).\n \f\n \n-(define_constants\n+(define_c_enum \"\"\n   [\n    ;; PLT reference from call expansion: operand 0 is the address,\n    ;; the mode is VOIDmode.  Always wrapped in CONST.\n    ;; The value is relative to the GOT.\n-   (CRIS_UNSPEC_PLT_GOTREL 0)\n+   CRIS_UNSPEC_PLT_GOTREL\n \n    ;; PLT reference from call expansion: operand 0 is the address,\n    ;; the mode is VOIDmode.  Always wrapped in CONST.\n    ;; The value is relative to the PC.  It's arch-dependent whether\n    ;; the offset counts from the start or the end of the current item.\n-   (CRIS_UNSPEC_PLT_PCREL 1)\n+   CRIS_UNSPEC_PLT_PCREL\n \n    ;; The address of the global offset table as a source operand.\n-   (CRIS_UNSPEC_GOT 2)\n+   CRIS_UNSPEC_GOT\n \n    ;; The offset from the global offset table to the operand.\n-   (CRIS_UNSPEC_GOTREL 3)\n+   CRIS_UNSPEC_GOTREL\n \n    ;; The PC-relative offset to the operand.  It's arch-dependent whether\n    ;; the offset counts from the start or the end of the current item.\n-   (CRIS_UNSPEC_PCREL 4)\n+   CRIS_UNSPEC_PCREL\n \n    ;; The index into the global offset table of a symbol, while\n    ;; also generating a GOT entry for the symbol.\n-   (CRIS_UNSPEC_GOTREAD 5)\n+   CRIS_UNSPEC_GOTREAD\n \n    ;; Similar to CRIS_UNSPEC_GOTREAD, but also generating a PLT entry.\n-   (CRIS_UNSPEC_PLTGOTREAD 6)\n+   CRIS_UNSPEC_PLTGOTREAD\n \n    ;; Condition for v32 casesi jump, since it needs to have if_then_else\n    ;; form with register as one branch and default label as other.\n    ;; Operand 0 is const_int 0.\n-   (CRIS_UNSPEC_CASESI 7)\n+   CRIS_UNSPEC_CASESI\n \n    ;; Stack frame deallocation barrier.\n-   (CRIS_UNSPEC_FRAME_DEALLOC 8)\n+   CRIS_UNSPEC_FRAME_DEALLOC\n \n    ;; Swap all 32 bits of the operand; 31 <=> 0, 30 <=> 1...\n-   (CRIS_UNSPEC_SWAP_BITS 9)\n+   CRIS_UNSPEC_SWAP_BITS\n   ])\n \n ;; Register numbers.\n@@ -4165,6 +4165,8 @@\n \t 3 [(match_dup 0)\n \t    (match_dup 1)]))]\n   \"\")\n+\n+(include \"sync.md\")\n \f\n ;; Splits for all cases in side-effect insns where (possibly after reload\n ;; and register allocation) rx and ry in [rx=ry+i] are equal."}, {"sha": "ebbddaa422eb3f0f346a3905bb94c27e191caa68", "filename": "gcc/config/cris/cris.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fcris.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.opt?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -179,6 +179,10 @@ mtrap-using-break8\n Target Report Var(cris_trap_using_break8) Init(2)\n Emit traps as \\\"break 8\\\", default for CRIS v3 and up.  If disabled, calls to abort() are used.\n \n+mtrap-unaligned-atomic\n+Target Report Var(cris_trap_unaligned_atomic) Init(2)\n+Emit checks causing \\\"break 8\\\" instructions to execute when applying atomic builtins on misaligned memory\n+\n ; TARGET_SVINTO: Currently this just affects alignment.  FIXME:\n ; Redundant with TARGET_ALIGN_BY_32, or put machine stuff here?\n ; This and the others below could just as well be variables and"}, {"sha": "6acd2b611584b236f4bdda74915ecf96e6aeb26c", "filename": "gcc/config/cris/sync.md", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21ed44440fc2b6148425eb156452507629018b18/gcc%2Fconfig%2Fcris%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fsync.md?ref=21ed44440fc2b6148425eb156452507629018b18", "patch": "@@ -0,0 +1,288 @@\n+;; GCC machine description for CRIS atomic memory sequences.\n+;; Copyright (C) 2012\n+;; Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; The CRIS atomic support yields code in three flavors, depending on\n+;; the CPU for which code is generated:\n+;;\n+;; - Plain old CRIS v0 (..v8)\n+;; - CRIS v10 (as used in ETRAX 100 LX)\n+;; - CRIS v32 (as used in ETRAX FS)\n+;;\n+;; The last two alternatives are similar, of LL/SC type.  They may\n+;; fail for other reasons; an exception, a cache miss or a bus request\n+;; from other parts of the system.  The difference between them is\n+;; just in what condition-codes are used to track LL and success or\n+;; failure for the store.  See the chapter on integral read-write\n+;; operations, chapter 1.13 in \"ETRAX 100LX Programmers Manual\",\n+;; <http://www.axis.com/files/tech_notes/etrax_100lx_prog_man-050519.pdf>\n+;; and chapter 2.1 in \"ETRAX FS Designer's reference\",\n+;; <http://www.axis.com/files/manuals/etrax_fs_des_ref-070821.pdf>.\n+;; Note that the datum being stored has to be contained fully within a\n+;; cache-line to be integral.  A failure to store the data integrally\n+;; will be flagged, but the store may still have happened in part,\n+;; which translates most usefully into the data having to be\n+;; \"naturally aligned\" to work.  Natural alignment is verified in the\n+;; generated code and will by default cause for unaligned pointers a\n+;; \"break 8\" to be executed or optionally a call to abort().  Beware\n+;; that options -m16bit and -m8bit may cause data to be unaligned\n+;; where it was otherwise aligned.  Data has a better chance of being\n+;; aligned if it is declared with e.g. __attribute__ ((__align__ (4))).\n+;;\n+;; The \"plain old v0..v8 flavor\" just assumes there's a single CPU in\n+;; the system, that no other parts of the system have access to memory\n+;; used for atomic accesses and since there's no user mode without\n+;; access to interrupt flags (another assumption), it just turns off\n+;; interrupts while doing the access.  Here, alignment is neither\n+;; required nor asserted.\n+\n+(define_c_enum \"\"\n+  [\n+   CRIS_UNSPEC_ATOMIC_OP\n+   CRIS_UNSPEC_ATOMIC_SWAP_MEM\n+   CRIS_UNSPEC_ATOMIC_SWAP_BOOL\n+  ])\n+\n+(define_constants [(CRIS_CCR_INTERRUPT_BIT 5)])\n+\n+;; We use \"mult\" as a placeholder for \"nand\" (which does not have a\n+;; separate binary rtx operation) so we can use an iterator in the\n+;; define_expand and define_insn and avoid having a separate\n+;; mostly-identical copy.  You will see the \"mult\" operator in rtl\n+;; dumps, but it shouldn't matter as its use has one of its operands\n+;; inside an unspec_volatile.\n+\n+(define_code_iterator atomic_op [plus minus ior and xor mult])\n+\n+(define_code_attr atomic_op_name\n+ [(plus \"add\") (minus \"sub\") (and \"and\") (ior \"or\") (xor \"xor\") (mult \"nand\")])\n+\n+;; Pairs of these are used to insert the \"not\" after the \"and\" for nand.\n+(define_code_attr atomic_op_mnem_pre ;; Upper-case only to sinplify testing.\n+ [(plus \"Add.d\") (minus \"Sub.d\") (and \"And.d\") (ior \"Or.d\") (xor \"Xor\")\n+  (mult \"aNd.d\")])\n+(define_code_attr atomic_op_mnem_post_op3\n+ [(plus \"\") (minus \"\") (and \"\") (ior \"\") (xor \"\") (mult \"not %3\\;\")])\n+\n+(define_expand \"atomic_fetch_<atomic_op_name><mode>\"\n+  [(match_operand:BWD 0 \"register_operand\")\n+   (match_operand:BWD 1 \"memory_operand\")\n+   (match_operand:BWD 2 \"register_operand\")\n+   (match_operand 3)\n+   (atomic_op:BWD (match_dup 0) (match_dup 1))]\n+  \"\"\n+{\n+  if (<MODE>mode != QImode && TARGET_TRAP_UNALIGNED_ATOMIC)\n+    cris_emit_trap_for_misalignment (operands[1]);\n+\n+  expand_mem_thread_fence (INTVAL (operands[3]));\n+  emit_insn (gen_cris_atomic_fetch_<atomic_op_name><mode>_1 (operands[0],\n+\t\t\t\t\t\t\t     operands[1],\n+\t\t\t\t\t\t\t     operands[2]));\n+  expand_mem_thread_fence (INTVAL (operands[3]));\n+  DONE;\n+})\n+\n+(define_insn \"cris_atomic_fetch_<atomic_op_name><mode>_1\"\n+  [(set (match_operand:BWD 1 \"memory_operand\" \"+Q\")\n+\t(atomic_op:BWD\n+\t (unspec_volatile:BWD [(match_dup 1)] CRIS_UNSPEC_ATOMIC_OP)\n+\t ;; FIXME: relax this for plus, minus, and, ior.\n+\t (match_operand:BWD 2 \"register_operand\" \"r\")))\n+   (set (match_operand:BWD 0 \"register_operand\" \"=&r\")\n+\t(match_dup 1))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n+  \"\"\n+{\n+  /* Can't be too sure; better ICE if this happens.  */\n+  gcc_assert (!reg_overlap_mentioned_p (operands[2], operands[1]));\n+\n+  if (TARGET_V32)\n+    return\n+      \"clearf p\\n\"\n+      \".Lsync.%=:\\;\"\n+      \"move<m> %1,%0\\;\"\n+      \"move.d %0,%3\\;\"\n+      \"<atomic_op_mnem_pre> %2,%3\\;<atomic_op_mnem_post_op3>\"\n+      \"ax\\;\"\n+      \"move<m> %3,%1\\;\"\n+      \"bcs .Lsync.%=\\;\"\n+      \"clearf p\";\n+  else if (cris_cpu_version == 10)\n+    return\n+      \"clearf\\n\"\n+      \".Lsync.%=:\\;\"\n+      \"move<m> %1,%0\\;\"\n+      \"move.d %0,%3\\;\"\n+      \"<atomic_op_mnem_pre> %2,%3\\;<atomic_op_mnem_post_op3>\"\n+      \"ax\\;\"\n+      \"move<m> %3,%1\\;\"\n+      \"bwf .Lsync.%=\\;\"\n+      \"clearf\";\n+  else\n+    {\n+      /* This one is for CRIS versions without load-locked-store-conditional\n+\t machinery; assume single-core-non-shared-memory without user\n+\t mode/supervisor mode distinction, and just disable interrupts\n+\t while performing the operation.\n+\t Rather than making this pattern more complex by freeing another\n+\t register or stack position to save condition codes (the value\n+\t of the interrupt-enabled bit), we check whether interrupts were\n+\t enabled before we disabled them and branch to a version\n+\t with/without afterwards re-enabling them.  */\n+      rtx ops[5];\n+\n+      /* We have no available macro to stringify CRIS_CCR_INTERRUPT_BIT.  */\n+      memcpy (ops, operands, sizeof(ops));\n+      ops[4] = GEN_INT (CRIS_CCR_INTERRUPT_BIT);\n+\n+      output_asm_insn (\"move $ccr,%3\\;\"\n+\t\t       \"di\\;\"\n+\t\t       \"move<m> %1,%0\\;\"\n+\t\t       \"btstq %4,%3\",\n+\t\t       ops);\n+      return\n+\t\"bmi .Lsync.irqon.%=\\;\"\n+\t\"move.d %0,%3\\;\"\n+\n+\t\"<atomic_op_mnem_pre> %2,%3\\;<atomic_op_mnem_post_op3>\"\n+\t\"ba .Lsync.irqoff.%=\\;\"\n+\t\"move<m> %3,%1\\n\"\n+\n+\t\".Lsync.irqon.%=:\\;\"\n+\t\"<atomic_op_mnem_pre> %2,%3\\;<atomic_op_mnem_post_op3>\"\n+\t\"move<m> %3,%1\\;\"\n+\t\"ei\\n\"\n+\t\".Lsync.irqoff.%=:\";\n+    }\n+})\n+\n+;; This pattern is more-or-less assumed to always exist if any of the\n+;; other atomic patterns exist (see e.g.  comment at the\n+;; can_compare_and_swap_p call in omp-low.c, 4.8 era).  We'd slightly\n+;; prefer atomic_exchange<mode> over this, but having both would be\n+;; redundant.\n+(define_expand \"atomic_compare_and_swap<mode>\"\n+  [(match_operand:SI 0 \"register_operand\")\n+   (match_operand:BWD 1 \"register_operand\")\n+   (match_operand:BWD 2 \"memory_operand\")\n+   (match_operand:BWD 3 \"general_operand\")\n+   (match_operand:BWD 4 \"register_operand\")\n+   (match_operand 5)\n+   (match_operand 6)\n+   (match_operand 7)]\n+  \"\"\n+{\n+  if (<MODE>mode != QImode && TARGET_TRAP_UNALIGNED_ATOMIC)\n+    cris_emit_trap_for_misalignment (operands[2]);\n+\n+  expand_mem_thread_fence (INTVAL (operands[6]));\n+  emit_insn (gen_cris_atomic_compare_and_swap<mode>_1 (operands[0],\n+\t\t\t\t\t\t       operands[1],\n+\t\t\t\t\t\t       operands[2],\n+\t\t\t\t\t\t       operands[3],\n+\t\t\t\t\t\t       operands[4]));\n+  expand_mem_thread_fence (INTVAL (operands[6]));\n+  DONE;\n+})\n+\n+(define_insn \"cris_atomic_compare_and_swap<mode>_1\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:SI\n+\t [(match_operand:BWD 2 \"memory_operand\" \"+Q\")\n+\t  (match_operand:BWD 3 \"general_operand\" \"g\")]\n+\t CRIS_UNSPEC_ATOMIC_SWAP_BOOL))\n+   (set (match_operand:BWD 1 \"register_operand\" \"=&r\") (match_dup 2))\n+   (set (match_dup 2)\n+\t(unspec_volatile:BWD\n+\t [(match_dup 2)\n+\t  (match_dup 3)\n+\t  (match_operand:BWD 4 \"register_operand\" \"r\")]\n+\t CRIS_UNSPEC_ATOMIC_SWAP_MEM))]\n+  \"\"\n+{\n+  if (TARGET_V32)\n+    return\n+      \"clearf p\\n\"\n+      \".Lsync.repeat.%=:\\;\"\n+      \"move<m> %2,%1\\;\"\n+      \"cmp<m> %3,%1\\;\"\n+      \"bne .Lsync.after.%=\\;\"\n+      \"seq %0\\;\"\n+\n+      \"ax\\;\"\n+      \"move<m> %4,%2\\;\"\n+      \"bcs .Lsync.repeat.%=\\;\"\n+      \"clearf p\\n\"\n+      \".Lsync.after.%=:\";\n+  else if (cris_cpu_version == 10)\n+    return\n+      \"clearf\\n\"\n+      \".Lsync.repeat.%=:\\;\"\n+      \"move<m> %2,%1\\;\"\n+      \"cmp<m> %3,%1\\;\"\n+      \"bne .Lsync.after.%=\\;\"\n+      \"seq %0\\;\"\n+\n+      \"ax\\;\"\n+      \"move<m> %4,%2\\;\"\n+      \"bwf .Lsync.repeat.%=\\;\"\n+      \"clearf\\n\"\n+      \".Lsync.after.%=:\";\n+  else\n+    {\n+      /* This one is for CRIS versions without load-locked-store-conditional\n+\t machinery; assume single-core-non-shared-memory without user\n+\t mode/supervisor mode distinction, and just disable interrupts\n+\t while performing the operation.\n+\t Rather than making this pattern more complex by freeing another\n+\t register or stack position to save condition codes (the value\n+\t of the interrupt-enabled bit), we check whether interrupts were\n+\t enabled before we disabled them and branch to a version\n+\t with/without afterwards re-enabling them.  */\n+      rtx ops[4];\n+\n+      /* We have no available macro to stringify CRIS_CCR_INTERRUPT_BIT.  */\n+      memcpy (ops, operands, sizeof(ops));\n+      ops[3] = GEN_INT (CRIS_CCR_INTERRUPT_BIT);\n+\n+      output_asm_insn (\"move $ccr,%0\\;\"\n+\t\t       \"di\\;\"\n+\t\t       \"move<m> %2,%1\\;\"\n+\t\t       \"btstq %3,%0\",\n+\t\t       ops);\n+      return\n+\t\"bmi .Lsync.irqon.%=\\;\"\n+\t\"nop\\;\"\n+\n+\t\"cmp<m> %3,%1\\;\"\n+\t\"bne .Lsync.after.%=\\;\"\n+\t\"seq %0\\;\"\n+\t\"ba .Lsync.after.%=\\;\"\n+\t\"move<m> %4,%2\\n\"\n+\n+\t\".Lsync.irqon.%=:\\;\"\n+\t\"cmp<m> %3,%1\\;\"\n+\t\"bne .Lsync.after.%=\\;\"\n+\t\"seq %0\\;\"\n+\t\"move<m> %4,%2\\;\"\n+\t\"ei\\n\"\n+\t\".Lsync.after.%=:\";\n+    }\n+})"}]}