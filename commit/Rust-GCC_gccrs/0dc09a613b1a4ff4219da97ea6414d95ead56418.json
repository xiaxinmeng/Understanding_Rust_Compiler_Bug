{"sha": "0dc09a613b1a4ff4219da97ea6414d95ead56418", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRjMDlhNjEzYjFhNGZmNDIxOWRhOTdlYTY0MTRkOTVlYWQ1NjQxOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-05T01:42:22Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-05T01:42:22Z"}, "message": "ir.texi: Correct typo.\n\n\t* ir.texi: Correct typo.\n\t* mangle.c (write_expression): Handle non-type template arguments\n\twith reference type.\n\t* method.c (build_overload_value): Likewise.\n\t* pt.c (convert_nontype_argument): Explicitly represent conversion\n\tto a reference with an ADDR_EXPR.\n\t(unify): Always unify arguments in left-to-right order.\n\nFrom-SVN: r34396", "tree": {"sha": "c8ba1303a4b4ab14ee0ab13b8add847158bee027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8ba1303a4b4ab14ee0ab13b8add847158bee027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dc09a613b1a4ff4219da97ea6414d95ead56418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc09a613b1a4ff4219da97ea6414d95ead56418", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dc09a613b1a4ff4219da97ea6414d95ead56418", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dc09a613b1a4ff4219da97ea6414d95ead56418/comments", "author": null, "committer": null, "parents": [{"sha": "f5579898360cab241826dcdc2b22d0ce9d354f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5579898360cab241826dcdc2b22d0ce9d354f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5579898360cab241826dcdc2b22d0ce9d354f06"}], "stats": {"total": 76, "additions": 63, "deletions": 13}, "files": [{"sha": "87cea7059bcd3cd028dea55a332d0018ff2230bc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -1,3 +1,13 @@\n+2000-06-04  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* ir.texi: Correct typo.\n+\t* mangle.c (write_expression): Handle non-type template arguments\n+\twith reference type.\n+\t* method.c (build_overload_value): Likewise.\n+\t* pt.c (convert_nontype_argument): Explicitly represent conversion\n+\tto a reference with an ADDR_EXPR.\n+\t(unify): Always unify arguments in left-to-right order.\n+\n 2000-06-03  Alex Samuel    <samuel@codesourcery.com>\n \t    Mark Mitchell  <mark@codesourcery.com>\n "}, {"sha": "429c155411266138f4d063b2fd3f640496bc8c5c", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -1675,7 +1675,7 @@ that of the result, will be either integral, boolean, or floating-point.\n \n @item ADDR_EXPR\n These nodes are used to represent the address of an object.  (These\n-expression will always have pointer or reference type.)  The operand may\n+expressions will always have pointer or reference type.)  The operand may\n be another expression, or it may be a declaration.\n \n As an extension, G++ allows users to take the address of a label.  In"}, {"sha": "2bba09f518b7114877b8d044bd37d504ac1b45de", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -1557,6 +1557,15 @@ write_expression (expr)\n \t  code = TREE_CODE (expr);\n \t}\n \n+      /* When we bind a variable or function to a non-type template\n+\t argument with reference type, we create an ADDR_EXPR to show\n+\t the fact that the entity's address has been taken.  But, we\n+\t don't actually want to output a mangling code for the `&'.  */\n+      if (TREE_CODE (expr) == ADDR_EXPR\n+\t  && TREE_TYPE (expr)\n+\t  && TREE_CODE (TREE_TYPE (expr)) == REFERENCE_TYPE)\n+\texpr = TREE_OPERAND (expr, 0);\n+\n       /* If it wasn't any of those, recursively expand the expression.  */\n       write_string (operator_name_info[(int) code].mangled_name);\n "}, {"sha": "495c47b3d5d9f3a67aa68c6136f8ebbfedb3fbc0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -827,6 +827,9 @@ build_overload_value (type, value, flags)\n       /* Fall through.  */\n \n     case REFERENCE_TYPE:\n+      if (TREE_CODE (value) == ADDR_EXPR)\n+\tvalue = TREE_OPERAND (value, 0);\n+\n       if (TREE_CODE (value) == VAR_DECL)\n \t{\n \t  my_friendly_assert (DECL_NAME (value) != 0, 245);"}, {"sha": "48df27f3815ad509a77d37fec47e6c0c5fd89659", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -2762,8 +2762,9 @@ convert_nontype_argument (type, expr)\n       tree e = expr;\n       STRIP_NOPS (e);\n \n-      if (TREE_CODE (type) == REFERENCE_TYPE\n-\t  || TREE_CODE (expr_type) == ARRAY_TYPE)\n+      if (TREE_CODE (expr_type) == ARRAY_TYPE\n+\t  || (TREE_CODE (type) == REFERENCE_TYPE\n+\t      && TREE_CODE (e) != ADDR_EXPR))\n \treferent = e;\n       else\n \t{\n@@ -2950,24 +2951,32 @@ convert_nontype_argument (type, expr)\n       {\n \ttree type_referred_to = TREE_TYPE (type);\n \n+\t/* If this expression already has reference type, get the\n+\t   underling object.  */\n+\tif (TREE_CODE (expr_type) == REFERENCE_TYPE) \n+\t  {\n+\t    my_friendly_assert (TREE_CODE (expr) == ADDR_EXPR, 20000604);\n+\t    expr = TREE_OPERAND (expr, 0);\n+\t    expr_type = TREE_TYPE (expr);\n+\t  }\n+\n \tif (TREE_CODE (type_referred_to) == FUNCTION_TYPE)\n \t  {\n \t    /* For a non-type template-parameter of type reference to\n \t       function, no conversions apply.  If the\n \t       template-argument represents a set of overloaded\n \t       functions, the matching function is selected from the\n \t       set (_over.over_).  */\n-\t    tree fns = expr;\n \t    tree fn;\n \n-\t    fn = instantiate_type (type_referred_to, fns, 0);\n+\t    fn = instantiate_type (type_referred_to, expr, 0);\n \n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n \n \t    if (!TREE_PUBLIC (fn))\n \t      {\n-\t\tif (really_overloaded_fn (fns))\n+\t\tif (really_overloaded_fn (expr))\n \t\t  /* Don't issue an error here; we might get a different\n \t\t     function if the overloading had worked out\n \t\t     differently.  */\n@@ -2980,7 +2989,7 @@ convert_nontype_argument (type, expr)\n \t\t\t\t\t     TREE_TYPE (fn)),\n \t\t\t\t0);\n \n-\t    return fn;\n+\t    expr = fn;\n \t  }\n \telse\n \t  {\n@@ -2990,15 +2999,16 @@ convert_nontype_argument (type, expr)\n \t       identical) type of the template-argument.  The\n \t       template-parameter is bound directly to the\n \t       template-argument, which must be an lvalue.  */\n-\t    if ((TYPE_MAIN_VARIANT (expr_type)\n-\t\t != TYPE_MAIN_VARIANT (type_referred_to))\n+\t    if (!same_type_p (TYPE_MAIN_VARIANT (expr_type),\n+\t\t\t      TYPE_MAIN_VARIANT (type_referred_to))\n \t\t|| !at_least_as_qualified_p (type_referred_to,\n \t\t\t\t\t     expr_type)\n \t\t|| !real_lvalue_p (expr))\n-\t      return error_mark_node;\n-\t    else\n-\t      return expr;\n+\t      expr = error_mark_node;\n \t  }\n+\n+\tmark_addressable (expr);\n+\treturn build1 (ADDR_EXPR, type, expr);\n       }\n       break;\n \n@@ -8589,7 +8599,7 @@ unify (tparms, targs, parm, arg, strict)\n \t  return 1;\n \tif (TREE_VEC_LENGTH (parm) != TREE_VEC_LENGTH (arg))\n \t  return 1;\n-\tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n+\tfor (i = 0; i < TREE_VEC_LENGTH (parm); ++i)\n \t  if (unify (tparms, targs,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n \t\t     UNIFY_ALLOW_NONE))"}, {"sha": "22f00739c8761f527c824abd007cef93cc9f2b04", "filename": "gcc/testsuite/g++.old-deja/g++.pt/infinite1.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finfinite1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finfinite1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finfinite1.C?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -6,6 +6,12 @@ template <int i> void f()\n   f<i+1>();\t\t\t// ERROR - excessive recursion\n }\n \n+// We should never need this specialization because we should issue an\n+// error first about the recursive template instantions.  But, in case\n+// the compiler fails to catch the error, this will keep it from\n+// running forever instantiating more and more templates.\n+template <> void f<100>();\n+\n int main()\n {\n   f<0>();\t\t\t// ERROR - starting here"}, {"sha": "ee684981e704e6bd7aea25d9b3f28047066e4373", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ref2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dc09a613b1a4ff4219da97ea6414d95ead56418/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fref2.C?ref=0dc09a613b1a4ff4219da97ea6414d95ead56418", "patch": "@@ -0,0 +1,12 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+\n+template <class T, T&>\n+class C;\n+\n+template <int& I>\n+class C<int, I> {};\n+\n+int i;\n+\n+C<int, i> c;"}]}