{"sha": "9074519dd453b59f727b83dfe9169ccc5ae73778", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA3NDUxOWRkNDUzYjU5ZjcyN2I4M2RmZTkxNjljY2M1YWU3Mzc3OA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-11-01T14:23:53Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-11-01T14:23:53Z"}, "message": "Add comments explaining what thumb_expand_prologue() does.\n\nFrom-SVN: r30321", "tree": {"sha": "4b67ec2110e11576cdcfb82a01c505cb06582b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b67ec2110e11576cdcfb82a01c505cb06582b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9074519dd453b59f727b83dfe9169ccc5ae73778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9074519dd453b59f727b83dfe9169ccc5ae73778", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9074519dd453b59f727b83dfe9169ccc5ae73778", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9074519dd453b59f727b83dfe9169ccc5ae73778/comments", "author": null, "committer": null, "parents": [{"sha": "da2c02192bfb2849b893b0c71e1b007db6426b7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2c02192bfb2849b893b0c71e1b007db6426b7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2c02192bfb2849b893b0c71e1b007db6426b7c"}], "stats": {"total": 78, "additions": 56, "deletions": 22}, "files": [{"sha": "fa08e92c8be1ef8d62e9cc6188c260da944b62c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9074519dd453b59f727b83dfe9169ccc5ae73778/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9074519dd453b59f727b83dfe9169ccc5ae73778/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9074519dd453b59f727b83dfe9169ccc5ae73778", "patch": "@@ -1,3 +1,8 @@\n+Mon Nov  1 14:22:51 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/thumb.c (thumb_expand_prologue): Add comments\n+\texplaining what is goin on in this function.\n+\n Mon Nov  1 08:03:15 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* regclass.c (record_reg_classes): In matching case, recompute"}, {"sha": "b549e0f593e889c2873f9076d6aeef0ca8afc9b1", "filename": "gcc/config/arm/thumb.c", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9074519dd453b59f727b83dfe9169ccc5ae73778/gcc%2Fconfig%2Farm%2Fthumb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9074519dd453b59f727b83dfe9169ccc5ae73778/gcc%2Fconfig%2Farm%2Fthumb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb.c?ref=9074519dd453b59f727b83dfe9169ccc5ae73778", "patch": "@@ -1515,9 +1515,6 @@ thumb_expand_prologue ()\n {\n   HOST_WIDE_INT amount = (get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n-  int regno;\n-  int live_regs_mask;\n-\n #ifdef THUMB_PE\n   /* Naked functions don't have prologues.  */\n   if (arm_naked_function_p (current_function_decl))\n@@ -1526,34 +1523,66 @@ thumb_expand_prologue ()\n   \n   if (amount)\n     {\n-      live_regs_mask = 0;\n-      for (regno = 0; regno < 8; regno++)\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno]\n-\t    && ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n-\t  live_regs_mask |= 1 << regno;\n-\n       if (amount < 512)\n \temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t       GEN_INT (-amount)));\n+\t\t\t       GEN_INT (- amount)));\n       else\n \t{\n-\t  rtx reg, spare;\n+\t  int regno;\n+\t  rtx reg;\n+\n+\t  /* The stack decrement is too big for an immediate value in a single\n+\t     insn.  In theory we could issue multiple subtracts, but after\n+\t     three of them it becomes more space efficient to place the full\n+\t     value in the constant pool and load into a register.  (Also the\n+\t     ARM debugger really likes to see only one stack decrement per\n+\t     function).  So instead we look for a scratch register into which\n+\t     we can load the decrement, and then we subtract this from the\n+\t     stack pointer.  Unfortunately on the thumb the only available\n+\t     scratch registers are the argument registers, and we cannot use\n+\t     these as they may hold arguments to the function.  Instead we\n+\t     attempt to locate a call preserved register which is used by this\n+\t     function.  If we can find one, then we know that it will have\n+\t     been pushed at the start of the prologue and so we can corrupt\n+\t     it now.  */\n+\t  for (regno = 4; regno < 8; regno++)\n+\t    if (regs_ever_live[regno]\n+\t\t&& ! call_used_regs[regno] /* Paranoia */\n+\t\t&& ! (TARGET_SINGLE_PIC_BASE && (regno == thumb_pic_register)))\n+\t      break;\n \n-\t  if ((live_regs_mask & 0xff) == 0) /* Very unlikely */\n-\t    emit_insn (gen_movsi (spare = gen_rtx (REG, SImode, 12),\n-\t\t\t\t  reg = gen_rtx (REG, SImode, 4)));\n+\t  if (regno == 8) /* Very unlikely */\n+\t    {\n+\t      rtx spare = gen_rtx (REG, SImode, 12);\n+\n+\t      /* Choose an arbitary, non-argument low register.  */\n+\t      reg = gen_rtx (REG, SImode, 4);\n+\n+\t      /* Save it by copying it into a high, scratch register.  */\n+\t      emit_insn (gen_movsi (spare, reg));\n+\n+\t      /* Decrement the stack.  */\n+\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     reg));\n+\n+\t      /* Restore the low register's original value.  */\n+\t      emit_insn (gen_movsi (reg, spare));\n+\t      \n+\t      /* Emit a USE of the restored scratch register, so that flow\n+\t\t analysis will not consider the restore redundant.  The\n+\t\t register won't be used again in this function and isn't\n+\t\t restored by the epilogue.  */\n+\t      emit_insn (gen_rtx_USE (VOIDmode, reg));\n+\t    }\n \t  else\n \t    {\n-\t      for (regno = 0; regno < 8; regno++)\n-\t\tif (live_regs_mask & (1 << regno))\n-\t\t  break;\n \t      reg = gen_rtx (REG, SImode, regno);\n-\t    }\n \n-\t  emit_insn (gen_movsi (reg, GEN_INT (-amount)));\n-\t  emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, reg));\n-\t  if ((live_regs_mask & 0xff) == 0)\n-\t    emit_insn (gen_movsi (reg, spare));\n+\t      emit_insn (gen_movsi (reg, GEN_INT (- amount)));\n+\t      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t     reg));\n+\t    }\n \t}\n     }\n "}]}