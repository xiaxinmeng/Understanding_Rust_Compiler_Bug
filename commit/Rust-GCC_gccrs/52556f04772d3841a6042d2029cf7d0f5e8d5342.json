{"sha": "52556f04772d3841a6042d2029cf7d0f5e8d5342", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI1NTZmMDQ3NzJkMzg0MWE2MDQyZDIwMjljZjdkMGY1ZThkNTM0Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-04-28T00:29:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-04-28T00:29:23Z"}, "message": "compiler: Use less memory for array/slice literals.\n\nFixes issue 8 in gofrontend issues list.\n\nFrom-SVN: r186926", "tree": {"sha": "6cd3efeec694a8a537dd90bc29442c57b48d7401", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd3efeec694a8a537dd90bc29442c57b48d7401"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52556f04772d3841a6042d2029cf7d0f5e8d5342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52556f04772d3841a6042d2029cf7d0f5e8d5342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52556f04772d3841a6042d2029cf7d0f5e8d5342", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52556f04772d3841a6042d2029cf7d0f5e8d5342/comments", "author": null, "committer": null, "parents": [{"sha": "cd5cec4abf3ab26813662409660849f4be8d9ac0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5cec4abf3ab26813662409660849f4be8d9ac0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5cec4abf3ab26813662409660849f4be8d9ac0"}], "stats": {"total": 274, "additions": 177, "deletions": 97}, "files": [{"sha": "6bd00a88b092b4e53b970930051e06dac3313dd7", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 177, "deletions": 97, "changes": 274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52556f04772d3841a6042d2029cf7d0f5e8d5342/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52556f04772d3841a6042d2029cf7d0f5e8d5342/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=52556f04772d3841a6042d2029cf7d0f5e8d5342", "patch": "@@ -6,6 +6,8 @@\n \n #include \"go-system.h\"\n \n+#include <algorithm>\n+\n #include <gmp.h>\n \n #ifndef ENABLE_BUILD_WITH_CXX\n@@ -11392,11 +11394,12 @@ class Array_construction_expression : public Expression\n {\n  protected:\n   Array_construction_expression(Expression_classification classification,\n-\t\t\t\tType* type, Expression_list* vals,\n-\t\t\t\tLocation location)\n+\t\t\t\tType* type,\n+\t\t\t\tconst std::vector<unsigned long>* indexes,\n+\t\t\t\tExpression_list* vals, Location location)\n     : Expression(classification, location),\n-      type_(type), vals_(vals)\n-  { }\n+      type_(type), indexes_(indexes), vals_(vals)\n+  { go_assert(indexes == NULL || indexes->size() == vals->size()); }\n \n  public:\n   // Return whether this is a constant initializer.\n@@ -11425,6 +11428,11 @@ class Array_construction_expression : public Expression\n   void\n   do_export(Export*) const;\n \n+  // The indexes.\n+  const std::vector<unsigned long>*\n+  indexes()\n+  { return this->indexes_; }\n+\n   // The list of values.\n   Expression_list*\n   vals()\n@@ -11440,7 +11448,10 @@ class Array_construction_expression : public Expression\n  private:\n   // The type of the array to construct.\n   Type* type_;\n-  // The list of values.\n+  // The list of indexes into the array, one for each value.  This may\n+  // be NULL, in which case the indexes start at zero and increment.\n+  const std::vector<unsigned long>* indexes_;\n+  // The list of values.  This may be NULL if there are no values.\n   Expression_list* vals_;\n };\n \n@@ -11523,18 +11534,6 @@ Array_construction_expression::do_check_types(Gogo*)\n \t  this->set_is_error();\n \t}\n     }\n-\n-  Expression* length = at->length();\n-  Numeric_constant nc;\n-  unsigned long val;\n-  if (length != NULL\n-      && !length->is_error_expression()\n-      && length->numeric_constant_value(&nc)\n-      && nc.to_unsigned_long(&val) == Numeric_constant::NC_UL_VALID)\n-    {\n-      if (this->vals_->size() > val)\n-\tthis->report_error(_(\"too many elements in composite literal\"));\n-    }\n }\n \n // Get a constructor tree for the array values.\n@@ -11552,12 +11551,22 @@ Array_construction_expression::get_constructor_tree(Translate_context* context,\n   if (this->vals_ != NULL)\n     {\n       size_t i = 0;\n+      std::vector<unsigned long>::const_iterator pi;\n+      if (this->indexes_ != NULL)\n+\tpi = this->indexes_->begin();\n       for (Expression_list::const_iterator pv = this->vals_->begin();\n \t   pv != this->vals_->end();\n \t   ++pv, ++i)\n \t{\n+\t  if (this->indexes_ != NULL)\n+\t    go_assert(pi != this->indexes_->end());\n \t  constructor_elt* elt = VEC_quick_push(constructor_elt, values, NULL);\n-\t  elt->index = size_int(i);\n+\n+\t  if (this->indexes_ == NULL)\n+\t    elt->index = size_int(i);\n+\t  else\n+\t    elt->index = size_int(*pi);\n+\n \t  if (*pv == NULL)\n \t    {\n \t      Gogo* gogo = context->gogo();\n@@ -11578,7 +11587,11 @@ Array_construction_expression::get_constructor_tree(Translate_context* context,\n \t    return error_mark_node;\n \t  if (!TREE_CONSTANT(elt->value))\n \t    is_constant = false;\n+\t  if (this->indexes_ != NULL)\n+\t    ++pi;\n \t}\n+      if (this->indexes_ != NULL)\n+\tgo_assert(pi == this->indexes_->end());\n     }\n \n   tree ret = build_constructor(type_tree, values);\n@@ -11596,13 +11609,28 @@ Array_construction_expression::do_export(Export* exp) const\n   exp->write_type(this->type_);\n   if (this->vals_ != NULL)\n     {\n+      std::vector<unsigned long>::const_iterator pi;\n+      if (this->indexes_ != NULL)\n+\tpi = this->indexes_->begin();\n       for (Expression_list::const_iterator pv = this->vals_->begin();\n \t   pv != this->vals_->end();\n \t   ++pv)\n \t{\n \t  exp->write_c_string(\", \");\n+\n+\t  if (this->indexes_ != NULL)\n+\t    {\n+\t      char buf[100];\n+\t      snprintf(buf, sizeof buf, \"%lu\", *pi);\n+\t      exp->write_c_string(buf);\n+\t      exp->write_c_string(\":\");\n+\t    }\n+\n \t  if (*pv != NULL)\n \t    (*pv)->export_expression(exp);\n+\n+\t  if (this->indexes_ != NULL)\n+\t    ++pi;\n \t}\n     }\n   exp->write_c_string(\")\");\n@@ -11614,8 +11642,7 @@ void\n Array_construction_expression::do_dump_expression(\n     Ast_dump_context* ast_dump_context) const\n {\n-  Expression* length = this->type_->array_type() != NULL ?\n-\t\t\t this->type_->array_type()->length() : NULL;\n+  Expression* length = this->type_->array_type()->length();\n \n   ast_dump_context->ostream() << \"[\" ;\n   if (length != NULL)\n@@ -11625,7 +11652,22 @@ Array_construction_expression::do_dump_expression(\n   ast_dump_context->ostream() << \"]\" ;\n   ast_dump_context->dump_type(this->type_);\n   ast_dump_context->ostream() << \"{\" ;\n-  ast_dump_context->dump_expression_list(this->vals_);\n+  if (this->indexes_ == NULL)\n+    ast_dump_context->dump_expression_list(this->vals_);\n+  else\n+    {\n+      Expression_list::const_iterator pv = this->vals_->begin();\n+      for (std::vector<unsigned long>::const_iterator pi =\n+\t     this->indexes_->begin();\n+\t   pi != this->indexes_->end();\n+\t   ++pi, ++pv)\n+\t{\n+\t  if (pi != this->indexes_->begin())\n+\t    ast_dump_context->ostream() << \", \";\n+\t  ast_dump_context->ostream() << *pi << ':';\n+\t  ast_dump_context->dump_expression(*pv);\n+\t}\n+    }\n   ast_dump_context->ostream() << \"}\" ;\n \n }\n@@ -11636,20 +11678,19 @@ class Fixed_array_construction_expression :\n   public Array_construction_expression\n {\n  public:\n-  Fixed_array_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t      Location location)\n+  Fixed_array_construction_expression(Type* type,\n+\t\t\t\t      const std::vector<unsigned long>* indexes,\n+\t\t\t\t      Expression_list* vals, Location location)\n     : Array_construction_expression(EXPRESSION_FIXED_ARRAY_CONSTRUCTION,\n-\t\t\t\t    type, vals, location)\n-  {\n-    go_assert(type->array_type() != NULL\n-\t       && type->array_type()->length() != NULL);\n-  }\n+\t\t\t\t    type, indexes, vals, location)\n+  { go_assert(type->array_type() != NULL && !type->is_slice_type()); }\n \n  protected:\n   Expression*\n   do_copy()\n   {\n     return new Fixed_array_construction_expression(this->type(),\n+\t\t\t\t\t\t   this->indexes(),\n \t\t\t\t\t\t   (this->vals() == NULL\n \t\t\t\t\t\t    ? NULL\n \t\t\t\t\t\t    : this->vals()->copy()),\n@@ -11658,9 +11699,6 @@ class Fixed_array_construction_expression :\n \n   tree\n   do_get_tree(Translate_context*);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*);\n };\n \n // Return a tree for constructing a fixed array.\n@@ -11673,35 +11711,17 @@ Fixed_array_construction_expression::do_get_tree(Translate_context* context)\n   return this->get_constructor_tree(context, type_to_tree(btype));\n }\n \n-// Dump ast representation of an array construction expressin.\n-\n-void\n-Fixed_array_construction_expression::do_dump_expression(\n-    Ast_dump_context* ast_dump_context)\n-{\n-\n-  ast_dump_context->ostream() << \"[\";\n-  ast_dump_context->dump_expression (this->type()->array_type()->length());\n-  ast_dump_context->ostream() << \"]\";\n-  ast_dump_context->dump_type(this->type());\n-  ast_dump_context->ostream() << \"{\";\n-  ast_dump_context->dump_expression_list(this->vals());\n-  ast_dump_context->ostream() << \"}\";\n-\n-}\n // Construct an open array.\n \n class Open_array_construction_expression : public Array_construction_expression\n {\n  public:\n-  Open_array_construction_expression(Type* type, Expression_list* vals,\n-\t\t\t\t     Location location)\n+  Open_array_construction_expression(Type* type,\n+\t\t\t\t     const std::vector<unsigned long>* indexes,\n+\t\t\t\t     Expression_list* vals, Location location)\n     : Array_construction_expression(EXPRESSION_OPEN_ARRAY_CONSTRUCTION,\n-\t\t\t\t    type, vals, location)\n-  {\n-    go_assert(type->array_type() != NULL\n-\t       && type->array_type()->length() == NULL);\n-  }\n+\t\t\t\t    type, indexes, vals, location)\n+  { go_assert(type->is_slice_type()); }\n \n  protected:\n   // Note that taking the address of an open array literal is invalid.\n@@ -11710,6 +11730,7 @@ class Open_array_construction_expression : public Array_construction_expression\n   do_copy()\n   {\n     return new Open_array_construction_expression(this->type(),\n+\t\t\t\t\t\t  this->indexes(),\n \t\t\t\t\t\t  (this->vals() == NULL\n \t\t\t\t\t\t   ? NULL\n \t\t\t\t\t\t   : this->vals()->copy()),\n@@ -11761,13 +11782,19 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n     }\n   else\n     {\n-      tree max = size_int(this->vals()->size() - 1);\n+      unsigned long max_index;\n+      if (this->indexes() == NULL)\n+\tmax_index = this->vals()->size() - 1;\n+      else\n+\tmax_index = *std::max_element(this->indexes()->begin(),\n+\t\t\t\t      this->indexes()->end());\n+      tree max_tree = size_int(max_index);\n       tree constructor_type = build_array_type(element_type_tree,\n-\t\t\t\t\t       build_index_type(max));\n+\t\t\t\t\t       build_index_type(max_tree));\n       if (constructor_type == error_mark_node)\n \treturn error_mark_node;\n       values = this->get_constructor_tree(context, constructor_type);\n-      length_tree = size_int(this->vals()->size());\n+      length_tree = size_int(max_index + 1);\n     }\n \n   if (values == error_mark_node)\n@@ -11875,7 +11902,7 @@ Expression::make_slice_composite_literal(Type* type, Expression_list* vals,\n \t\t\t\t\t Location location)\n {\n   go_assert(type->is_slice_type());\n-  return new Open_array_construction_expression(type, vals, location);\n+  return new Open_array_construction_expression(type, NULL, vals, location);\n }\n \n // Construct a map.\n@@ -12229,7 +12256,7 @@ class Composite_literal_expression : public Parser_expression\n   lower_array(Type*);\n \n   Expression*\n-  make_array(Type*, Expression_list*);\n+  make_array(Type*, const std::vector<unsigned long>*, Expression_list*);\n \n   Expression*\n   lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n@@ -12518,10 +12545,12 @@ Composite_literal_expression::lower_array(Type* type)\n {\n   Location location = this->location();\n   if (this->vals_ == NULL || !this->has_keys_)\n-    return this->make_array(type, this->vals_);\n+    return this->make_array(type, NULL, this->vals_);\n \n-  std::vector<Expression*> vals;\n-  vals.reserve(this->vals_->size());\n+  std::vector<unsigned long>* indexes = new std::vector<unsigned long>;\n+  indexes->reserve(this->vals_->size());\n+  Expression_list* vals = new Expression_list();\n+  vals->reserve(this->vals_->size());\n   unsigned long index = 0;\n   Expression_list::const_iterator p = this->vals_->begin();\n   while (p != this->vals_->end())\n@@ -12534,8 +12563,19 @@ Composite_literal_expression::lower_array(Type* type)\n \n       ++p;\n \n-      if (index_expr != NULL)\n+      if (index_expr == NULL)\n+\t{\n+\t  if (!indexes->empty())\n+\t    indexes->push_back(index);\n+\t}\n+      else\n \t{\n+\t  if (indexes->empty() && !vals->empty())\n+\t    {\n+\t      for (size_t i = 0; i < vals->size(); ++i)\n+\t\tindexes->push_back(i);\n+\t    }\n+\n \t  Numeric_constant nc;\n \t  if (!index_expr->numeric_constant_value(&nc))\n \t    {\n@@ -12571,70 +12611,110 @@ Composite_literal_expression::lower_array(Type* type)\n \t      return Expression::make_error(location);\n \t    }\n \n-\t  // FIXME: Our representation isn't very good; this avoids\n-\t  // thrashing.\n-\t  if (index > 0x1000000)\n-\t    {\n-\t      error_at(index_expr->location(), \"index too large for compiler\");\n-\t      return Expression::make_error(location);\n-\t    }\n-\t}\n-\n-      if (index == vals.size())\n-\tvals.push_back(val);\n-      else\n-\t{\n-\t  if (index > vals.size())\n+\t  if (std::find(indexes->begin(), indexes->end(), index)\n+\t      != indexes->end())\n \t    {\n-\t      vals.reserve(index + 32);\n-\t      vals.resize(index + 1, static_cast<Expression*>(NULL));\n-\t    }\n-\t  if (vals[index] != NULL)\n-\t    {\n-\t      error_at((index_expr != NULL\n-\t\t\t? index_expr->location()\n-\t\t\t: val->location()),\n-\t\t       \"duplicate value for index %lu\",\n+\t      error_at(index_expr->location(), \"duplicate value for index %lu\",\n \t\t       index);\n \t      return Expression::make_error(location);\n \t    }\n-\t  vals[index] = val;\n+\n+\t  indexes->push_back(index);\n \t}\n \n+      vals->push_back(val);\n+\n       ++index;\n     }\n \n-  size_t size = vals.size();\n-  Expression_list* list = new Expression_list;\n-  list->reserve(size);\n-  for (size_t i = 0; i < size; ++i)\n-    list->push_back(vals[i]);\n+  if (indexes->empty())\n+    {\n+      delete indexes;\n+      indexes = NULL;\n+    }\n \n-  return this->make_array(type, list);\n+  return this->make_array(type, indexes, vals);\n }\n \n // Actually build the array composite literal. This handles\n // [...]{...}.\n \n Expression*\n-Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n+Composite_literal_expression::make_array(\n+    Type* type,\n+    const std::vector<unsigned long>* indexes,\n+    Expression_list* vals)\n {\n   Location location = this->location();\n   Array_type* at = type->array_type();\n+\n   if (at->length() != NULL && at->length()->is_nil_expression())\n     {\n-      size_t size = vals == NULL ? 0 : vals->size();\n+      size_t size;\n+      if (vals == NULL)\n+\tsize = 0;\n+      else if (indexes == NULL)\n+\t{\n+\t  size = vals->size();\n+\t  Integer_type* it = Type::lookup_integer_type(\"int\")->integer_type();\n+\t  if (sizeof(size) <= static_cast<size_t>(it->bits() * 8)\n+\t      && size >> (it->bits() - 1) != 0)\n+\t    {\n+\t      error_at(location, \"too many elements in composite literal\");\n+\t      return Expression::make_error(location);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  size = *std::max_element(indexes->begin(), indexes->end());\n+\t  ++size;\n+\t}\n+\n       mpz_t vlen;\n       mpz_init_set_ui(vlen, size);\n       Expression* elen = Expression::make_integer(&vlen, NULL, location);\n       mpz_clear(vlen);\n       at = Type::make_array_type(at->element_type(), elen);\n       type = at;\n     }\n+  else if (at->length() != NULL\n+\t   && !at->length()->is_error_expression()\n+\t   && this->vals_ != NULL)\n+    {\n+      Numeric_constant nc;\n+      unsigned long val;\n+      if (at->length()->numeric_constant_value(&nc)\n+\t  && nc.to_unsigned_long(&val) == Numeric_constant::NC_UL_VALID)\n+\t{\n+\t  if (indexes == NULL)\n+\t    {\n+\t      if (this->vals_->size() > val)\n+\t\t{\n+\t\t  error_at(location, \"too many elements in composite literal\");\n+\t\t  return Expression::make_error(location);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned long max = *std::max_element(indexes->begin(),\n+\t\t\t\t\t\t    indexes->end());\n+\t      if (max >= val)\n+\t\t{\n+\t\t  error_at(location,\n+\t\t\t   (\"some element keys in composite literal \"\n+\t\t\t    \"are out of range\"));\n+\t\t  return Expression::make_error(location);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n   if (at->length() != NULL)\n-    return new Fixed_array_construction_expression(type, vals, location);\n+    return new Fixed_array_construction_expression(type, indexes, vals,\n+\t\t\t\t\t\t   location);\n   else\n-    return new Open_array_construction_expression(type, vals, location);\n+    return new Open_array_construction_expression(type, indexes, vals,\n+\t\t\t\t\t\t  location);\n }\n \n // Lower a map composite literal."}]}