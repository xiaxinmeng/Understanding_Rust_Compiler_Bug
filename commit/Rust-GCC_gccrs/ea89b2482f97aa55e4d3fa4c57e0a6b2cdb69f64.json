{"sha": "ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE4OWIyNDgyZjk3YWE1NWU0ZDNmYTRjNTdlMGE2YjJjZGI2OWY2NA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-09-27T21:17:36Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-09-27T21:17:36Z"}, "message": "predefined_ops.h: New.\n\n2013-09-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/predefined_ops.h: New.\n\t* include/bits/stl_heap.h: Include <bits/predefined_ops.h>.\n\t(__is_heap_until, __push_heap, __adjust_heap, __pop_heap): Remove\n\talgo duplication.\n\t(__is_heap): Adapt.\n\t(__make_heap): New.\n\t(make_heap): Adapt to use latter.\n\t(__sort_heap): New.\n\t(sort_heap): Adapt to use latter.\n\t* include/bits/algobase.h: Include <bits/predefined_ops.h>.\n\t(__lexicographical_compare_impl): New.\n\t(__lexicographical_compare<false>::__lc): Adapt to use latter.\n\t(lexicographical_compare): Likewise.\n\t(__lower_bound): New.\n\t(lower_bound): Adapt to use latter.\n\t(equal): Use _GLIBCXX_STD_A::equal in N3671 overloads.\n\t(__mismatch): New.\n\t(mismatch): Use latter.\n\t* include/bits/algo.h: Include <bits/predefined_ops.h>. Remove\n\t<functional> include.\n\t(__move_median_first, __find, __find_if, __find_if_not): Remove\n\talgo duplication.\n\t(__find_end): Likewise.\n\t(__search_n): Rename into ...\n\t(__search_n_aux): ... this.\n\t(__search_n): Renew, use latter.\n\t(search_n): Use latter.\n\t(__search): New.\n\t(search): Use latter.\n\t(__find_end): Likewise.\n\t(__remove_copy_if): New.\n\t(remove_copy): Use latter.\n\t(__adjacent_find): New.\n\t(adjacent_find): Use latter.\n\t(__unique): New.\n\t(unique): Use latter.\n\t(__unique_copy): Remove algo duplication.\n\t(__stable_partition): New.\n\t(stable_partition): Use latter.\n\t(__heap_select): Remove algo duplication, use __make_heap.\n\t(__partial_sort): New, use latter.\n\t(partial_sort): Use latter.\n\t(__partial_sort_copy): New.\n\t(partial_sort_copy): Use latter.\n\t(__unguarded_linear_insert, __insertion_sort): Remove algo\n\tduplication.\n\t(__unguarded_insertion_sort, __final_insertion_sort): Likewise.\n\t(__unguarded_partition, __unguarded_partition_pivot): Likewise.\n\t(__partial_sort): New.\n\t(partial_sort): Use latter.\n\t(__sort): New.\n\t(sort): Use latter.\n\t(lower_bound): Use __lower_bound.\n\t(__upper_bound): New.\n\t(upper_bound): Use latter.\n\t(__equal_range): New.\n\t(equal_range): Use latter.\n\t(__move_merge_adaptive, __move_merge_adaptive_backward): Remove\n\talgo duplication.\n\t(__merge_adaptive, __merge_without_buffer): Likewise.\n\t(__inplace_merge): New.\n\t(inplace_merge): Use latter.\n\t(__move_merge, __merge_sort_loop, __chunk_insertion_sort): Remove\n\talgo duplication.\n\t(__merge_sort_with_buffer, __stable_sort_adaptive): Likewise.\n\t(__inplace_stable_sort): Likewise.\n\t(__include): New.\n\t(includes): Use latter.\n\t(__next_permutation): New.\n\t(next_permutation): Use latter.\n\t(__prev_permutation): New.\n\t(prev_permutation): Use latter.\n\t(__replace_copy_if): New.\n\t(replace_copy): Use latter.\n\t(__is_sorted_until): New.\n\t(is_sorted_unitl): Use latter.\n\t(__minmax_element): New.\n\t(minmax_element): Use latter.\n\t(__is_permutation): New.\n\t(is_permutation): Use latter.\n\t(__adjacent_find): New.\n\t(adjacent_find): Use latter.\n\t(__count_if): New.\n\t(count): Use latter.\n\t(count_if): Likewise.\n\t(__merge): New.\n\t(merge): Use latter.\n\t(__stable_sort): New.\n\t(stable_sort): Use latter.\n\t(__set_union): New.\n\t(set_union): Use latter.\n\t(__set_intersection): New.\n\t(set_intersection): Use latter.\n\t(__set_difference): New.\n\t(set_difference): Use latter.\n\t(__set_symmetric_difference): New.\n\t(set_symmetric_difference): Use latter.\n\t(__min_element): New.\n\t(min_element): Use latter.\n\t(__max_element): New.\n\t(max_element): Use latter.\n\t* include/Makefile.am: Add predefined_ops.h.\n\t* include/Makefile.in: Regenerate.\n\t* include/parallel/algobase.h (equal, mismatch): Add overloads\n\tfrom N3671.\n\t* testsuite/25_algorithms/is_permutation/vectorbool.cc: New.\n\t* testsuite/25_algorithms/adjacent_find/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/find/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/find_if/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/find_first_of/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/heap/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/find_end/vectorbool.cc: Likewise.\n\t* testsuite/25_algorithms/find_if_not/vectorbool.cc: Likewise.\n\nFrom-SVN: r202992", "tree": {"sha": "982dee36a36ef4c06c3ecd1d32e305fef700f0c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/982dee36a36ef4c06c3ecd1d32e305fef700f0c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/comments", "author": null, "committer": null, "parents": [{"sha": "522d4efcd3bda29e0557756bbe7346cbf8a375f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/522d4efcd3bda29e0557756bbe7346cbf8a375f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/522d4efcd3bda29e0557756bbe7346cbf8a375f0"}], "stats": {"total": 4396, "additions": 2168, "deletions": 2228}, "files": [{"sha": "ead095e786a916c541c51279fc3bf8268516ac04", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -1,4 +1,120 @@\n-2013-08-07  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+2013-09-27  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/predefined_ops.h: New.\n+\t* include/bits/stl_heap.h: Include <bits/predefined_ops.h>.\n+\t(__is_heap_until, __push_heap, __adjust_heap, __pop_heap): Remove\n+\talgo duplication.\n+\t(__is_heap): Adapt.\n+\t(__make_heap): New.\n+\t(make_heap): Adapt to use latter.\n+\t(__sort_heap): New.\n+\t(sort_heap): Adapt to use latter.\n+\t* include/bits/algobase.h: Include <bits/predefined_ops.h>.\n+\t(__lexicographical_compare_impl): New.\n+\t(__lexicographical_compare<false>::__lc): Adapt to use latter.\n+\t(lexicographical_compare): Likewise.\n+\t(__lower_bound): New.\n+\t(lower_bound): Adapt to use latter.\n+\t(equal): Use _GLIBCXX_STD_A::equal in N3671 overloads.\n+\t(__mismatch): New.\n+\t(mismatch): Use latter.\n+\t* include/bits/algo.h: Include <bits/predefined_ops.h>. Remove\n+\t<functional> include.\n+\t(__move_median_first, __find, __find_if, __find_if_not): Remove\n+\talgo duplication.\n+\t(__find_end): Likewise.\n+\t(__search_n): Rename into ...\n+\t(__search_n_aux): ... this.\n+\t(__search_n): Renew, use latter.\n+\t(search_n): Use latter.\n+\t(__search): New.\n+\t(search): Use latter.\n+\t(__find_end): Likewise.\n+\t(__remove_copy_if): New.\n+\t(remove_copy): Use latter.\n+\t(__adjacent_find): New.\n+\t(adjacent_find): Use latter.\n+\t(__unique): New.\n+\t(unique): Use latter.\n+\t(__unique_copy): Remove algo duplication.\n+\t(__stable_partition): New.\n+\t(stable_partition): Use latter.\n+\t(__heap_select): Remove algo duplication, use __make_heap.\n+\t(__partial_sort): New, use latter.\n+\t(partial_sort): Use latter.\n+\t(__partial_sort_copy): New.\n+\t(partial_sort_copy): Use latter.\n+\t(__unguarded_linear_insert, __insertion_sort): Remove algo\n+\tduplication.\n+\t(__unguarded_insertion_sort, __final_insertion_sort): Likewise.\n+\t(__unguarded_partition, __unguarded_partition_pivot): Likewise.\n+\t(__partial_sort): New.\n+\t(partial_sort): Use latter.\n+\t(__sort): New.\n+\t(sort): Use latter.\n+\t(lower_bound): Use __lower_bound.\n+\t(__upper_bound): New.\n+\t(upper_bound): Use latter.\n+\t(__equal_range): New.\n+\t(equal_range): Use latter.\n+\t(__move_merge_adaptive, __move_merge_adaptive_backward): Remove\n+\talgo duplication.\n+\t(__merge_adaptive, __merge_without_buffer): Likewise.\n+\t(__inplace_merge): New.\n+\t(inplace_merge): Use latter.\n+\t(__move_merge, __merge_sort_loop, __chunk_insertion_sort): Remove\n+\talgo duplication.\n+\t(__merge_sort_with_buffer, __stable_sort_adaptive): Likewise.\n+\t(__inplace_stable_sort): Likewise.\n+\t(__include): New.\n+\t(includes): Use latter.\n+\t(__next_permutation): New.\n+\t(next_permutation): Use latter.\n+\t(__prev_permutation): New.\n+\t(prev_permutation): Use latter.\n+\t(__replace_copy_if): New.\n+\t(replace_copy): Use latter.\n+\t(__is_sorted_until): New.\n+\t(is_sorted_unitl): Use latter.\n+\t(__minmax_element): New.\n+\t(minmax_element): Use latter.\n+\t(__is_permutation): New.\n+\t(is_permutation): Use latter.\n+\t(__adjacent_find): New.\n+\t(adjacent_find): Use latter.\n+\t(__count_if): New.\n+\t(count): Use latter.\n+\t(count_if): Likewise.\n+\t(__merge): New.\n+\t(merge): Use latter.\n+\t(__stable_sort): New.\n+\t(stable_sort): Use latter.\n+\t(__set_union): New.\n+\t(set_union): Use latter.\n+\t(__set_intersection): New.\n+\t(set_intersection): Use latter.\n+\t(__set_difference): New.\n+\t(set_difference): Use latter.\n+\t(__set_symmetric_difference): New.\n+\t(set_symmetric_difference): Use latter.\n+\t(__min_element): New.\n+\t(min_element): Use latter.\n+\t(__max_element): New.\n+\t(max_element): Use latter.\n+\t* include/Makefile.am: Add predefined_ops.h.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/parallel/algobase.h (equal, mismatch): Add overloads\n+\tfrom N3671.\n+\t* testsuite/25_algorithms/is_permutation/vectorbool.cc: New.\n+\t* testsuite/25_algorithms/adjacent_find/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/find/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/find_if/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/find_first_of/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/heap/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/find_end/vectorbool.cc: Likewise.\n+\t* testsuite/25_algorithms/find_if_not/vectorbool.cc: Likewise.\n+\n+2013-09-27  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \tPR libstdc++/57465\n \t* include/std/functional"}, {"sha": "1a4fd6f9bc2f7ca8abe0e8c0550984772ec5beae", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -121,6 +121,7 @@ bits_headers = \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/parse_numbers.h \\\n \t${bits_srcdir}/postypes.h \\\n+\t${bits_srcdir}/predefined_ops.h \\\n \t${bits_srcdir}/ptr_traits.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\"}, {"sha": "87a9f1b80cfb36c6597d2cd8f79f6ff279e41db4", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -388,6 +388,7 @@ bits_headers = \\\n \t${bits_srcdir}/ostream_insert.h \\\n \t${bits_srcdir}/parse_numbers.h \\\n \t${bits_srcdir}/postypes.h \\\n+\t${bits_srcdir}/predefined_ops.h \\\n \t${bits_srcdir}/ptr_traits.h \\\n \t${bits_srcdir}/random.h \\\n \t${bits_srcdir}/random.tcc \\"}, {"sha": "30870b7638374947cda300e564de85f3d15171b9", "filename": "libstdc++-v3/include/bits/predefined_ops.h", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpredefined_ops.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpredefined_ops.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fpredefined_ops.h?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,304 @@\n+// Default predicates for internal use -*- C++ -*-\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file predefined_ops.h\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_PREDEFINED_OPS_H\n+#define _GLIBCXX_PREDEFINED_OPS_H\t1\n+\n+namespace __gnu_cxx\n+{\n+namespace __ops\n+{\n+  struct _Iter_less_iter\n+  {\n+    template<typename _Iterator1, typename _Iterator2>\n+      bool\n+      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n+      { return *__it1 < *__it2; }\n+  };\n+\n+  inline _Iter_less_iter\n+  __iter_less_iter()\n+  { return _Iter_less_iter(); }\n+\n+  struct _Iter_less_val\n+  {\n+    template<typename _Iterator, typename _Value>\n+      bool\n+      operator()(_Iterator __it, _Value& __val) const\n+      { return *__it < __val; }\n+    };\n+\n+  inline _Iter_less_val\n+  __iter_less_val()\n+  { return _Iter_less_val(); }\n+\n+  inline _Iter_less_val\n+  __iter_comp_val(_Iter_less_iter)\n+  { return _Iter_less_val(); }\n+\n+  struct _Val_less_iter\n+  {\n+    template<typename _Value, typename _Iterator>\n+      bool\n+      operator()(_Value& __val, _Iterator __it) const\n+      { return __val < *__it; }\n+    };\n+\n+  inline _Val_less_iter\n+  __val_less_iter()\n+  { return _Val_less_iter(); }\n+\n+  inline _Val_less_iter\n+  __val_comp_iter(_Iter_less_iter)\n+  { return _Val_less_iter(); }\n+\n+  struct _Iter_equal_to_iter\n+  {\n+    template<typename _Iterator1, typename _Iterator2>\n+      bool\n+      operator()(_Iterator1 __it1, _Iterator2 __it2) const\n+      { return *__it1 == *__it2; }\n+    };\n+\n+  inline _Iter_equal_to_iter\n+  __iter_equal_to_iter()\n+  { return _Iter_equal_to_iter(); }\n+\n+  struct _Iter_equal_to_val\n+  {\n+    template<typename _Iterator, typename _Value>\n+      bool\n+      operator()(_Iterator __it, _Value& __val) const\n+      { return *__it == __val; }\n+    };\n+\n+  inline _Iter_equal_to_val\n+  __iter_equal_to_val()\n+  { return _Iter_equal_to_val(); }\n+\n+  inline _Iter_equal_to_val\n+  __iter_comp_val(_Iter_equal_to_iter)\n+  { return _Iter_equal_to_val(); }\n+\n+  template<typename _Compare>\n+    struct _Iter_comp_iter\n+    {\n+      _Compare _M_comp;\n+\n+      _Iter_comp_iter(_Compare __comp)\n+\t: _M_comp(__comp)\n+      { }\n+\n+      template<typename _Iterator1, typename _Iterator2>\n+        bool\n+        operator()(_Iterator1 __it1, _Iterator2 __it2)\n+        { return bool(_M_comp(*__it1, *__it2)); }\n+    };\n+\n+  template<typename _Compare>\n+    inline _Iter_comp_iter<_Compare>\n+    __iter_comp_iter(_Compare __comp)\n+    { return _Iter_comp_iter<_Compare>(__comp); }\n+\n+  template<typename _Compare>\n+    struct _Iter_comp_val\n+    {\n+      _Compare _M_comp;\n+\n+      _Iter_comp_val(_Compare __comp)\n+\t: _M_comp(__comp)\n+      { }\n+\n+      template<typename _Iterator, typename _Value>\n+\tbool\n+\toperator()(_Iterator __it, _Value& __val)\n+\t{ return bool(_M_comp(*__it, __val)); }\n+    };\n+\n+  template<typename _Compare>\n+   inline _Iter_comp_val<_Compare>\n+    __iter_comp_val(_Compare __comp)\n+    { return _Iter_comp_val<_Compare>(__comp); }\n+\n+  template<typename _Compare>\n+    inline _Iter_comp_val<_Compare>\n+    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)\n+    { return _Iter_comp_val<_Compare>(__comp._M_comp); }\n+\n+  template<typename _Compare>\n+    struct _Val_comp_iter\n+    {\n+      _Compare _M_comp;\n+\n+      _Val_comp_iter(_Compare __comp)\n+\t: _M_comp(__comp)\n+      { }\n+\n+      template<typename _Value, typename _Iterator>\n+\tbool\n+\toperator()(_Value& __val, _Iterator __it)\n+\t{ return bool(_M_comp(__val, *__it)); }\n+    };\n+\n+  template<typename _Compare>\n+    inline _Val_comp_iter<_Compare>\n+    __val_comp_iter(_Compare __comp)\n+    { return _Val_comp_iter<_Compare>(__comp); }\n+\n+  template<typename _Compare>\n+    inline _Val_comp_iter<_Compare>\n+    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)\n+    { return _Val_comp_iter<_Compare>(__comp._M_comp); }\n+\n+  template<typename _Value>\n+    struct _Iter_equals_val\n+    {\n+      _Value& _M_value;\n+\n+      _Iter_equals_val(_Value& __value)\n+\t: _M_value(__value)\n+      { }\n+\n+      template<typename _Iterator>\n+\tbool\n+\toperator()(_Iterator __it)\n+\t{ return *__it == _M_value; }\n+    };\n+\n+  template<typename _Value>\n+    inline _Iter_equals_val<_Value>\n+    __iter_equals_val(_Value& __val)\n+    { return _Iter_equals_val<_Value>(__val); }\n+\n+  template<typename _Iterator1>\n+    struct _Iter_equals_iter\n+    {\n+      typename std::iterator_traits<_Iterator1>::reference _M_ref;\n+\n+      _Iter_equals_iter(_Iterator1 __it1)\n+\t: _M_ref(*__it1)\n+      { }\n+\n+      template<typename _Iterator2>\n+\tbool\n+\toperator()(_Iterator2 __it2)\n+\t{ return *__it2 == _M_ref; }\n+    };\n+\n+  template<typename _Iterator>\n+    inline _Iter_equals_iter<_Iterator>\n+    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)\n+    { return _Iter_equals_iter<_Iterator>(__it); }\n+\n+  template<typename _Predicate>\n+    struct _Iter_pred\n+    {\n+      _Predicate _M_pred;\n+\n+      _Iter_pred(_Predicate __pred)\n+\t: _M_pred(__pred)\n+      { }\n+\n+      template<typename _Iterator>\n+\tbool\n+\toperator()(_Iterator __it)\n+\t{ return bool(_M_pred(*__it)); }\n+    };\n+\n+  template<typename _Predicate>\n+    inline _Iter_pred<_Predicate>\n+    __pred_iter(_Predicate __pred)\n+    { return _Iter_pred<_Predicate>(__pred); }\n+\n+  template<typename _Compare, typename _Value>\n+    struct _Iter_comp_to_val\n+    {\n+      _Compare _M_comp;\n+      _Value& _M_value;\n+\n+      _Iter_comp_to_val(_Compare __comp, _Value& __value)\n+\t: _M_comp(__comp), _M_value(__value)\n+      { }\n+\n+      template<typename _Iterator>\n+\tbool\n+\toperator()(_Iterator __it)\n+\t{ return bool(_M_comp(*__it, _M_value)); }\n+    };\n+\n+  template<typename _Compare, typename _Value>\n+    _Iter_comp_to_val<_Compare, _Value>\n+    __iter_comp_val(_Compare __comp, _Value &__val)\n+    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }\n+\n+  template<typename _Compare, typename _Iterator1>\n+    struct _Iter_comp_to_iter\n+    {\n+      _Compare _M_comp;\n+      typename std::iterator_traits<_Iterator1>::reference _M_ref;\n+\n+      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)\n+\t: _M_comp(__comp), _M_ref(*__it1)\n+      { }\n+\n+      template<typename _Iterator2>\n+\tbool\n+\toperator()(_Iterator2 __it2)\n+\t{ return bool(_M_comp(*__it2, _M_ref)); }\n+    };\n+\n+  template<typename _Compare, typename _Iterator>\n+    inline _Iter_comp_to_iter<_Compare, _Iterator>\n+    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)\n+    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }\n+\n+  template<typename _Predicate>\n+    struct _Iter_negate\n+    {\n+      _Predicate _M_pred;\n+\n+      _Iter_negate(_Predicate __pred)\n+\t: _M_pred(__pred)\n+      { }\n+\n+      template<typename _Iterator>\n+\tbool\n+\toperator()(_Iterator __it)\n+\t{ return !bool(_M_pred(*__it)); }\n+    };\n+\n+  template<typename _Predicate>\n+    inline _Iter_negate<_Predicate>\n+    __negate(_Iter_pred<_Predicate> __pred)\n+    { return _Iter_negate<_Predicate>(__pred._M_pred); }\n+\n+} // namespace __ops\n+} // namespace __gnu_cxx\n+\n+#endif"}, {"sha": "36f03a40539843b6540e8518c8acae70e1e832ff", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 1069, "deletions": 2004, "changes": 3073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64"}, {"sha": "fae8beb217197b47feb16d339a23341b19f5789a", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 97, "deletions": 77, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -68,6 +68,7 @@\n #include <bits/concept_check.h>\n #include <debug/debug.h>\n #include <bits/move.h> // For std::swap and _GLIBCXX_MOVE\n+#include <bits/predefined_ops.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -862,6 +863,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         { return true; }\n     };\n \n+  template<typename _II1, typename _II2, typename _Compare>\n+    bool\n+    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,\n+\t\t\t\t   _II2 __first2, _II2 __last2,\n+\t\t\t\t   _Compare __comp)\n+    {\n+      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n+      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n+      typedef std::__lc_rai<_Category1, _Category2> __rai_type;\n+\n+      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);\n+      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n+\t   ++__first1, ++__first2)\n+\t{\n+\t  if (__comp(__first1, __first2))\n+\t    return true;\n+\t  if (__comp(__first2, __first1))\n+\t    return false;\n+\t}\n+      return __first1 == __last1 && __first2 != __last2;\n+    }\n+\n   template<bool _BoolType>\n     struct __lexicographical_compare\n     {\n@@ -875,21 +898,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __lexicographical_compare<_BoolType>::\n       __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n       {\n-\ttypedef typename iterator_traits<_II1>::iterator_category _Category1;\n-\ttypedef typename iterator_traits<_II2>::iterator_category _Category2;\n-\ttypedef std::__lc_rai<_Category1, _Category2> \t__rai_type;\n-\t\n-\t__last1 = __rai_type::__newlast1(__first1, __last1,\n-\t\t\t\t\t __first2, __last2);\n-\tfor (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n-\t     ++__first1, ++__first2)\n-\t  {\n-\t    if (*__first1 < *__first2)\n-\t      return true;\n-\t    if (*__first2 < *__first1)\n-\t      return false;\n-\t  }\n-\treturn __first1 == __last1 && __first2 != __last2;\n+\treturn std::__lexicographical_compare_impl(\n+\t\t__first1, __last1, __first2, __last2,\n+\t\t__gnu_cxx::__ops::__iter_less_iter());\n       }\n \n   template<>\n@@ -926,42 +937,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t\t    __first2, __last2);\n     }\n \n-  /**\n-   *  @brief Finds the first position in which @a val could be inserted\n-   *         without changing the ordering.\n-   *  @param  __first   An iterator.\n-   *  @param  __last    Another iterator.\n-   *  @param  __val     The search term.\n-   *  @return         An iterator pointing to the first element <em>not less\n-   *                  than</em> @a val, or end() if every element is less than \n-   *                  @a val.\n-   *  @ingroup binary_search_algorithms\n-  */\n-  template<typename _ForwardIterator, typename _Tp>\n+  template<typename _ForwardIterator, typename _Tp, typename _Compare>\n     _ForwardIterator\n-    lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n-\t\tconst _Tp& __val)\n+    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t  const _Tp& __val, _Compare __comp)\n     {\n-#ifdef _GLIBCXX_CONCEPT_CHECKS\n-      typedef typename iterator_traits<_ForwardIterator>::value_type\n-\t_ValueType;\n-#endif\n       typedef typename iterator_traits<_ForwardIterator>::difference_type\n \t_DistanceType;\n \n-      // concept requirements\n-      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n-      __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)\n-      __glibcxx_requires_partitioned_lower(__first, __last, __val);\n-\n       _DistanceType __len = std::distance(__first, __last);\n \n       while (__len > 0)\n \t{\n \t  _DistanceType __half = __len >> 1;\n \t  _ForwardIterator __middle = __first;\n \t  std::advance(__middle, __half);\n-\t  if (*__middle < __val)\n+\t  if (__comp(__middle, __val))\n \t    {\n \t      __first = __middle;\n \t      ++__first;\n@@ -973,6 +964,32 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __first;\n     }\n \n+  /**\n+   *  @brief Finds the first position in which @a val could be inserted\n+   *         without changing the ordering.\n+   *  @param  __first   An iterator.\n+   *  @param  __last    Another iterator.\n+   *  @param  __val     The search term.\n+   *  @return         An iterator pointing to the first element <em>not less\n+   *                  than</em> @a val, or end() if every element is less than \n+   *                  @a val.\n+   *  @ingroup binary_search_algorithms\n+  */\n+  template<typename _ForwardIterator, typename _Tp>\n+    _ForwardIterator\n+    lower_bound(_ForwardIterator __first, _ForwardIterator __last,\n+\t\tconst _Tp& __val)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n+      __glibcxx_function_requires(_LessThanOpConcept<\n+\t    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n+      __glibcxx_requires_partitioned_lower(__first, __last, __val);\n+\n+      return std::__lower_bound(__first, __last, __val,\n+\t\t\t\t__gnu_cxx::__ops::__iter_less_val());\n+    }\n+\n   /// This is a helper function for the sort routines and for random.tcc.\n   //  Precondition: __n > 0.\n   inline _GLIBCXX_CONSTEXPR int\n@@ -1100,7 +1117,7 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t  auto __d2 = std::distance(__first2, __last2);\n \t  if (__d1 != __d2)\n \t    return false;\n-\t  return std::equal(__first1, __last1, __first2);\n+\t  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2);\n \t}\n \n       for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n@@ -1146,7 +1163,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t  auto __d2 = std::distance(__first2, __last2);\n \t  if (__d1 != __d2)\n \t    return false;\n-\t  return std::equal(__first1, __last1, __first2, __binary_pred);\n+\t  return _GLIBCXX_STD_A::equal(__first1, __last1, __first2,\n+\t\t\t\t       __binary_pred);\n \t}\n \n       for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n@@ -1212,26 +1230,29 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n     lexicographical_compare(_II1 __first1, _II1 __last1,\n \t\t\t    _II2 __first2, _II2 __last2, _Compare __comp)\n     {\n-      typedef typename iterator_traits<_II1>::iterator_category _Category1;\n-      typedef typename iterator_traits<_II2>::iterator_category _Category2;\n-      typedef std::__lc_rai<_Category1, _Category2> \t__rai_type;\n-\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_II1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_II2>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);\n-      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);\n-\t   ++__first1, ++__first2)\n-\t{\n-\t  if (__comp(*__first1, *__first2))\n-\t    return true;\n-\t  if (__comp(*__first2, *__first1))\n-\t    return false;\n-\t}\n-      return __first1 == __last1 && __first2 != __last2;\n+      return std::__lexicographical_compare_impl\n+\t(__first1, __last1, __first2, __last2,\n+\t __gnu_cxx::__ops::__iter_comp_iter(__comp));\n+    }\n+\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n+    pair<_InputIterator1, _InputIterator2>\n+    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t       _InputIterator2 __first2, _BinaryPredicate __binary_pred)\n+    {\n+      while (__first1 != __last1 && __binary_pred(__first1, __first2))\n+        {\n+\t  ++__first1;\n+\t  ++__first2;\n+        }\n+      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n     }\n \n   /**\n@@ -1260,12 +1281,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n \n-      while (__first1 != __last1 && *__first1 == *__first2)\n-        {\n-\t  ++__first1;\n-\t  ++__first2;\n-        }\n-      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,\n+\t\t\t     __gnu_cxx::__ops::__iter_equal_to_iter());\n     }\n \n   /**\n@@ -1295,15 +1312,28 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n       __glibcxx_requires_valid_range(__first1, __last1);\n \n-      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))\n+      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2,\n+\t__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));\n+    }\n+\n+#if __cplusplus > 201103L\n+\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n+    pair<_InputIterator1, _InputIterator2>\n+    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t       _InputIterator2 __first2, _InputIterator2 __last2,\n+\t       _BinaryPredicate __binary_pred)\n+    {\n+      while (__first1 != __last1 && __first2 != __last2\n+\t     && __binary_pred(__first1, __first2))\n         {\n \t  ++__first1;\n \t  ++__first2;\n         }\n       return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n     }\n \n-#if __cplusplus > 201103L\n   /**\n    *  @brief Finds the places in ranges which don't match.\n    *  @ingroup non_mutating_algorithms\n@@ -1332,13 +1362,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      while (__first1 != __last1 && __first2 != __last2\n-\t  && *__first1 == *__first2)\n-        {\n-\t  ++__first1;\n-\t  ++__first2;\n-        }\n-      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,\n+\t\t\t     __gnu_cxx::__ops::__iter_equal_to_iter());\n     }\n \n   /**\n@@ -1371,13 +1396,8 @@ _GLIBCXX_BEGIN_NAMESPACE_ALGO\n       __glibcxx_requires_valid_range(__first1, __last1);\n       __glibcxx_requires_valid_range(__first2, __last2);\n \n-      while (__first1 != __last1 && __first2 != __last2\n-\t  && bool(__binary_pred(*__first1, *__first2)))\n-        {\n-\t  ++__first1;\n-\t  ++__first2;\n-        }\n-      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n+      return _GLIBCXX_STD_A::__mismatch(__first1, __last1, __first2, __last2,\n+\t\t\t     __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));\n     }\n #endif\n "}, {"sha": "a0c51ff7a1f157bee6687f801efd3c0bcbf5dae9", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 86, "deletions": 146, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -57,6 +57,7 @@\n \n #include <debug/debug.h>\n #include <bits/move.h>\n+#include <bits/predefined_ops.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -67,21 +68,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @ingroup sorting_algorithms\n    */\n \n-  template<typename _RandomAccessIterator, typename _Distance>\n-    _Distance\n-    __is_heap_until(_RandomAccessIterator __first, _Distance __n)\n-    {\n-      _Distance __parent = 0;\n-      for (_Distance __child = 1; __child < __n; ++__child)\n-\t{\n-\t  if (__first[__parent] < __first[__child])\n-\t    return __child;\n-\t  if ((__child & 1) == 0)\n-\t    ++__parent;\n-\t}\n-      return __n;\n-    }\n-\n   template<typename _RandomAccessIterator, typename _Distance,\n \t   typename _Compare>\n     _Distance\n@@ -91,7 +77,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Distance __parent = 0;\n       for (_Distance __child = 1; __child < __n; ++__child)\n \t{\n-\t  if (__comp(__first[__parent], __first[__child]))\n+\t  if (__comp(__first + __parent, __first + __child))\n \t    return __child;\n \t  if ((__child & 1) == 0)\n \t    ++__parent;\n@@ -104,13 +90,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _RandomAccessIterator, typename _Distance>\n     inline bool\n     __is_heap(_RandomAccessIterator __first, _Distance __n)\n-    { return std::__is_heap_until(__first, __n) == __n; }\n+    {\n+      return std::__is_heap_until(__first, __n,\n+\t\t\t__gnu_cxx::__ops::__iter_less_iter()) == __n;\n+    }\n \n   template<typename _RandomAccessIterator, typename _Compare,\n \t   typename _Distance>\n     inline bool\n     __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)\n-    { return std::__is_heap_until(__first, __n, __comp) == __n; }\n+    {\n+      return std::__is_heap_until(__first, __n,\n+\t__gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;\n+    }\n \n   template<typename _RandomAccessIterator>\n     inline bool\n@@ -126,13 +118,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap,\n   // + is_heap and is_heap_until in C++0x.\n \n-  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n+  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,\n+\t   typename _Compare>\n     void\n     __push_heap(_RandomAccessIterator __first,\n-\t\t_Distance __holeIndex, _Distance __topIndex, _Tp __value)\n+\t\t_Distance __holeIndex, _Distance __topIndex, _Tp __value,\n+\t\t_Compare __comp)\n     {\n       _Distance __parent = (__holeIndex - 1) / 2;\n-      while (__holeIndex > __topIndex && *(__first + __parent) < __value)\n+      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))\n \t{\n \t  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));\n \t  __holeIndex = __parent;\n@@ -169,24 +163,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));\n       std::__push_heap(__first, _DistanceType((__last - __first) - 1),\n-\t\t       _DistanceType(0), _GLIBCXX_MOVE(__value));\n-    }\n-\n-  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,\n-\t   typename _Compare>\n-    void\n-    __push_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-\t\t_Distance __topIndex, _Tp __value, _Compare __comp)\n-    {\n-      _Distance __parent = (__holeIndex - 1) / 2;\n-      while (__holeIndex > __topIndex\n-\t     && __comp(*(__first + __parent), __value))\n-\t{\n-\t  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));\n-\t  __holeIndex = __parent;\n-\t  __parent = (__holeIndex - 1) / 2;\n-\t}\n-      *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);\n+\t\t       _DistanceType(0), _GLIBCXX_MOVE(__value),\n+\t\t       __gnu_cxx::__ops::__iter_less_val());\n     }\n \n   /**\n@@ -219,20 +197,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       _ValueType __value = _GLIBCXX_MOVE(*(__last - 1));\n       std::__push_heap(__first, _DistanceType((__last - __first) - 1),\n-\t\t       _DistanceType(0), _GLIBCXX_MOVE(__value), __comp);\n+\t\t       _DistanceType(0), _GLIBCXX_MOVE(__value),\n+\t\t       __gnu_cxx::__ops::__iter_comp_val(__comp));\n     }\n \n-  template<typename _RandomAccessIterator, typename _Distance, typename _Tp>\n+  template<typename _RandomAccessIterator, typename _Distance,\n+\t   typename _Tp, typename _Compare>\n     void\n     __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-\t\t  _Distance __len, _Tp __value)\n+\t\t  _Distance __len, _Tp __value, _Compare __comp)\n     {\n       const _Distance __topIndex = __holeIndex;\n       _Distance __secondChild = __holeIndex;\n       while (__secondChild < (__len - 1) / 2)\n \t{\n \t  __secondChild = 2 * (__secondChild + 1);\n-\t  if (*(__first + __secondChild) < *(__first + (__secondChild - 1)))\n+\t  if (__comp(__first + __secondChild,\n+\t\t     __first + (__secondChild - 1)))\n \t    __secondChild--;\n \t  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));\n \t  __holeIndex = __secondChild;\n@@ -244,14 +225,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t\t     + (__secondChild - 1)));\n \t  __holeIndex = __secondChild - 1;\n \t}\n-      std::__push_heap(__first, __holeIndex, __topIndex,\n-\t\t       _GLIBCXX_MOVE(__value));\n+      std::__push_heap(__first, __holeIndex, __topIndex, \n+\t\t       _GLIBCXX_MOVE(__value),\n+\t\t       __gnu_cxx::__ops::__iter_comp_val(__comp));\n     }\n \n-  template<typename _RandomAccessIterator>\n+  template<typename _RandomAccessIterator, typename _Compare>\n     inline void\n     __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-\t       _RandomAccessIterator __result)\n+\t       _RandomAccessIterator __result, _Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIterator>::value_type\n \t_ValueType;\n@@ -262,7 +244,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       *__result = _GLIBCXX_MOVE(*__first);\n       std::__adjust_heap(__first, _DistanceType(0),\n \t\t\t _DistanceType(__last - __first),\n-\t\t\t _GLIBCXX_MOVE(__value));\n+\t\t\t _GLIBCXX_MOVE(__value), __comp);\n     }\n \n   /**\n@@ -294,55 +276,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__last - __first > 1)\n \t{\n \t  --__last;\n-\t  std::__pop_heap(__first, __last, __last);\n+\t  std::__pop_heap(__first, __last, __last,\n+\t\t\t  __gnu_cxx::__ops::__iter_less_iter());\n \t}\n     }\n \n-  template<typename _RandomAccessIterator, typename _Distance,\n-\t   typename _Tp, typename _Compare>\n-    void\n-    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,\n-\t\t  _Distance __len, _Tp __value, _Compare __comp)\n-    {\n-      const _Distance __topIndex = __holeIndex;\n-      _Distance __secondChild = __holeIndex;\n-      while (__secondChild < (__len - 1) / 2)\n-\t{\n-\t  __secondChild = 2 * (__secondChild + 1);\n-\t  if (__comp(*(__first + __secondChild),\n-\t\t     *(__first + (__secondChild - 1))))\n-\t    __secondChild--;\n-\t  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));\n-\t  __holeIndex = __secondChild;\n-\t}\n-      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)\n-\t{\n-\t  __secondChild = 2 * (__secondChild + 1);\n-\t  *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first\n-\t\t\t\t\t\t     + (__secondChild - 1)));\n-\t  __holeIndex = __secondChild - 1;\n-\t}\n-      std::__push_heap(__first, __holeIndex, __topIndex, \n-\t\t       _GLIBCXX_MOVE(__value), __comp);      \n-    }\n-\n-  template<typename _RandomAccessIterator, typename _Compare>\n-    inline void\n-    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-\t       _RandomAccessIterator __result, _Compare __comp)\n-    {\n-      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n-\t_ValueType;\n-      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n-\t_DistanceType;\n-\n-      _ValueType __value = _GLIBCXX_MOVE(*__result);\n-      *__result = _GLIBCXX_MOVE(*__first);\n-      std::__adjust_heap(__first, _DistanceType(0),\n-\t\t\t _DistanceType(__last - __first),\n-\t\t\t _GLIBCXX_MOVE(__value), __comp);\n-    }\n-\n   /**\n    *  @brief  Pop an element off a heap using comparison functor.\n    *  @param  __first  Start of heap.\n@@ -369,33 +307,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__last - __first > 1)\n \t{\n \t  --__last;\n-\t  std::__pop_heap(__first, __last, __last, __comp);\n+\t  std::__pop_heap(__first, __last, __last,\n+\t\t\t  __gnu_cxx::__ops::__iter_comp_iter(__comp));\n \t}\n     }\n \n-  /**\n-   *  @brief  Construct a heap over a range.\n-   *  @param  __first  Start of heap.\n-   *  @param  __last   End of heap.\n-   *  @ingroup heap_algorithms\n-   *\n-   *  This operation makes the elements in [__first,__last) into a heap.\n-  */\n-  template<typename _RandomAccessIterator>\n+  template<typename _RandomAccessIterator, typename _Compare>\n     void\n-    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t\t_Compare __comp)\n     {\n       typedef typename iterator_traits<_RandomAccessIterator>::value_type\n \t  _ValueType;\n       typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n \t  _DistanceType;\n \n-      // concept requirements\n-      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n-\t    _RandomAccessIterator>)\n-      __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n-      __glibcxx_requires_valid_range(__first, __last);\n-\n       if (__last - __first < 2)\n \treturn;\n \n@@ -404,12 +330,36 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       while (true)\n \t{\n \t  _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));\n-\t  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value));\n+\t  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),\n+\t\t\t     __comp);\n \t  if (__parent == 0)\n \t    return;\n \t  __parent--;\n \t}\n     }\n+  \n+  /**\n+   *  @brief  Construct a heap over a range.\n+   *  @param  __first  Start of heap.\n+   *  @param  __last   End of heap.\n+   *  @ingroup heap_algorithms\n+   *\n+   *  This operation makes the elements in [__first,__last) into a heap.\n+  */\n+  template<typename _RandomAccessIterator>\n+    inline void\n+    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    {\n+      // concept requirements\n+      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n+\t    _RandomAccessIterator>)\n+      __glibcxx_function_requires(_LessThanComparableConcept<\n+\t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+\n+      std::__make_heap(__first, __last,\n+\t\t       __gnu_cxx::__ops::__iter_less_iter());\n+    }\n \n   /**\n    *  @brief  Construct a heap over a range using comparison functor.\n@@ -422,33 +372,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  Comparisons are made using __comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    void\n+    inline void\n     make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t      _Compare __comp)\n     {\n-      typedef typename iterator_traits<_RandomAccessIterator>::value_type\n-\t  _ValueType;\n-      typedef typename iterator_traits<_RandomAccessIterator>::difference_type\n-\t  _DistanceType;\n-\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      if (__last - __first < 2)\n-\treturn;\n+      std::__make_heap(__first, __last,\n+\t\t       __gnu_cxx::__ops::__iter_comp_iter(__comp));\n+    }\n \n-      const _DistanceType __len = __last - __first;\n-      _DistanceType __parent = (__len - 2) / 2;\n-      while (true)\n+  template<typename _RandomAccessIterator, typename _Compare>\n+    void\n+    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t\t_Compare __comp)\n+    {\n+      while (__last - __first > 1)\n \t{\n-\t  _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));\n-\t  std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value),\n-\t\t\t     __comp);\n-\t  if (__parent == 0)\n-\t    return;\n-\t  __parent--;\n+\t  --__last;\n+\t  std::__pop_heap(__first, __last, __last, __comp);\n \t}\n     }\n \n@@ -461,7 +406,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  This operation sorts the valid heap in the range [__first,__last).\n   */\n   template<typename _RandomAccessIterator>\n-    void\n+    inline void\n     sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n     {\n       // concept requirements\n@@ -472,11 +417,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __glibcxx_requires_valid_range(__first, __last);\n       __glibcxx_requires_heap(__first, __last);\n \n-      while (__last - __first > 1)\n-\t{\n-\t  --__last;\n-\t  std::__pop_heap(__first, __last, __last);\n-\t}\n+      std::__sort_heap(__first, __last,\n+\t\t       __gnu_cxx::__ops::__iter_less_iter());\n     }\n \n   /**\n@@ -490,7 +432,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  Comparisons are made using __comp.\n   */\n   template<typename _RandomAccessIterator, typename _Compare>\n-    void\n+    inline void\n     sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n \t      _Compare __comp)\n     {\n@@ -500,11 +442,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __glibcxx_requires_valid_range(__first, __last);\n       __glibcxx_requires_heap_pred(__first, __last, __comp);\n \n-      while (__last - __first > 1)\n-\t{\n-\t  --__last;\n-\t  std::__pop_heap(__first, __last, __last, __comp);\n-\t}\n+      std::__sort_heap(__first, __last,\n+\t\t       __gnu_cxx::__ops::__iter_comp_iter(__comp));\n     }\n \n #if __cplusplus >= 201103L\n@@ -529,8 +468,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      return __first + std::__is_heap_until(__first, std::distance(__first,\n-\t\t\t\t\t\t\t\t   __last));\n+      return __first + \n+\tstd::__is_heap_until(__first, std::distance(__first, __last),\n+\t\t\t     __gnu_cxx::__ops::__iter_less_iter());\n     }\n \n   /**\n@@ -554,9 +494,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _RandomAccessIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      return __first + std::__is_heap_until(__first, std::distance(__first,\n-\t\t\t\t\t\t\t\t   __last),\n-\t\t\t\t\t    __comp);\n+      return __first\n+\t+ std::__is_heap_until(__first, std::distance(__first, __last),\n+\t\t\t       __gnu_cxx::__ops::__iter_comp_iter(__comp));\n     }\n \n   /**"}, {"sha": "d615065a5553a5b7b7d7908985aabfca43ee7b21", "filename": "libstdc++-v3/include/parallel/algobase.h", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Falgobase.h?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -122,6 +122,25 @@ namespace __parallel\n                                _IteratorCategory1(), _IteratorCategory2());\n     }\n \n+#if __cplusplus > 201103L\n+  template<typename _InputIterator1, typename _InputIterator2>\n+    inline pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2, _InputIterator2 __last2)\n+    { return _GLIBCXX_STD_A::mismatch(__first1, __last1, __first2, __last2); }\n+\n+  template<typename _InputIterator1, typename _InputIterator2,\n+\t   typename _BinaryPredicate>\n+    inline pair<_InputIterator1, _InputIterator2>\n+    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n+\t     _InputIterator2 __first2, _InputIterator2 __last2,\n+\t     _BinaryPredicate __binary_pred)\n+    {\n+      return _GLIBCXX_STD_A::mismatch(__first1, __last1, __first2, __last2,\n+\t\t\t\t      __binary_pred);\n+    }\n+#endif\n+\n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2>\n     inline bool\n@@ -155,6 +174,22 @@ namespace __parallel\n               == __end1;\n     }\n \n+#if __cplusplus > 201103L\n+  template<typename _II1, typename _II2>\n+    inline bool\n+    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\n+    { return _GLIBCXX_STD_A::equal(__first1, __last1, __first2, __last2); }\n+\n+  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>\n+    inline bool\n+    equal(_IIter1 __first1, _IIter1 __last1,\n+\t  _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)\n+    {\n+      return _GLIBCXX_STD_A::equal(__first1, __last1, __first2, __last2,\n+\t\t\t\t   __binary_pred);\n+    }\n+#endif\n+\n   // Sequential fallback\n   template<typename _IIter1, typename _IIter2>\n     inline bool"}, {"sha": "c5278bbe974094a87ecb20a9c85b14c091e9a0f4", "filename": "libstdc++-v3/testsuite/25_algorithms/adjacent_find/vectorbool.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fadjacent_find%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,44 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.1.5 [lib.alg.adjacent_find]\n+\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+void \n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::vector<bool> v;\n+  v.push_back(true);\n+  v.push_back(false);\n+  v.push_back(true);\n+  v.push_back(false);\n+  v.push_back(false);\n+\n+  VERIFY( std::adjacent_find(v.begin(), v.end()) == v.begin() + 3 );\n+  VERIFY( std::adjacent_find(v.begin(), v.end() - 1) == v.end() - 1 );\n+}  \n+\n+int \n+main()\n+{\n+  test01();\n+}"}, {"sha": "13de9300c1029773746c5089f49de8e99cc3a154", "filename": "libstdc++-v3/testsuite/25_algorithms/find/vectorbool.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.1.2 find\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test1()\n+{\n+  std::vector<bool> v;\n+  v.push_back(false);\n+  v.push_back(false);\n+  v.push_back(true);\n+  v.push_back(false);\n+  VERIFY( std::find(v.begin(), v.end(), true) == v.begin() + 2 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+}"}, {"sha": "eabaa4c572cf9c9266caa395e283d239c85d6349", "filename": "libstdc++-v3/testsuite/25_algorithms/find_end/vectorbool.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_end%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.1.3 [lib.alg.find.end]\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test1()\n+{\n+  std::vector<bool> v1;\n+  v1.push_back(false);\n+  v1.push_back(false);\n+  v1.push_back(false);\n+  v1.push_back(true);\n+  v1.push_back(true);\n+  v1.push_back(false);\n+  v1.push_back(true);\n+  v1.push_back(true);\n+  v1.push_back(false);\n+\n+  std::vector<bool> v2;\n+  v2.push_back(true);\n+  v2.push_back(true);\n+\n+  VERIFY( std::find_end(v1.begin(), v1.end(), v2.begin(), v2.end())\n+\t  == v1.begin() + 6 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+}"}, {"sha": "d43a391c8434dacc03f00a96967e385540a470aa", "filename": "libstdc++-v3/testsuite/25_algorithms/find_first_of/vectorbool.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_first_of%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.1.4 [lib.alg.find.first.of]\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test1()\n+{\n+  std::vector<bool> v1;\n+  v1.push_back(false);\n+  v1.push_back(false);\n+  v1.push_back(true);\n+  v1.push_back(false);\n+  v1.push_back(true);\n+  v1.push_back(true);\n+  v1.push_back(false);\n+  v1.push_back(true);\n+  v1.push_back(true);\n+\n+  std::vector<bool> v2;\n+  v2.push_back(true);\n+  v2.push_back(false);\n+\n+  VERIFY( std::find_first_of(v1.begin(), v1.end(), v2.begin(), v2.end())\n+\t  == v1.begin() );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+}"}, {"sha": "13de9300c1029773746c5089f49de8e99cc3a154", "filename": "libstdc++-v3/testsuite/25_algorithms/find_if/vectorbool.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,39 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.1.2 find\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test1()\n+{\n+  std::vector<bool> v;\n+  v.push_back(false);\n+  v.push_back(false);\n+  v.push_back(true);\n+  v.push_back(false);\n+  VERIFY( std::find(v.begin(), v.end(), true) == v.begin() + 2 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+}"}, {"sha": "f97a7e242563acc2300234f80e57491491af8142", "filename": "libstdc++-v3/testsuite/25_algorithms/find_if_not/vectorbool.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Ffind_if_not%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test1()\n+{\n+  std::vector<bool> v;\n+  v.push_back(false);\n+  v.push_back(false);\n+  v.push_back(true);\n+  v.push_back(false);\n+  VERIFY( std::find_if_not(v.begin(), v.end(), [](bool val){ return !val; })\n+\t  == v.begin() + 2 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+}"}, {"sha": "7f2bc61e1a036abfbd99e36d7533a0a54a79eb26", "filename": "libstdc++-v3/testsuite/25_algorithms/heap/vectorbool.cc", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,146 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.3.6 Heap operations [lib.alg.heap.operations]\n+\n+#include <iterator>\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+const bool A[] = { true, true, false, true, false, false, true, false };\n+const int B[] = { false, false, false, false, true, true, true, true };\n+const int C[] = { true, true, true, true, false, false, false, false };\n+const int N = sizeof(A) / sizeof(bool);\n+\n+// This functor has the equivalent functionality of std::greater<>,\n+// but there is no dependency on <functional> and it also tracks the\n+// number of invocations since creation.\n+class Gt\n+{\n+public:\n+  static int count() { return _S_count; }\n+  static void reset() { _S_count = 0; }\n+  \n+  bool\n+  operator()(bool x, bool y) const\n+  {\n+    ++_S_count;\n+    return x > y; \n+  }\n+\n+private:\n+  static int _S_count;\n+};\n+\n+int Gt::_S_count = 0;\n+\n+// Exercise all of the heap functions for operator<.  The intermediate\n+// results between push_heap and pop_heap and make_heap and sort_heap\n+// are not checked (they could be).\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  // sort array s1 using push_heap/pop_heap\n+  std::vector<bool> s1;\n+  std::copy(A, A + N, std::back_inserter(s1));\n+  VERIFY( std::equal(s1.begin(), s1.begin() + N, A) );\n+  \n+  for (int i = 2; i <= N; ++i)\n+    std::push_heap(s1.begin(), s1.begin() + i);\n+  \n+  for (int i = N; i >= 2; --i)\n+    std::pop_heap(s1.begin(), s1.begin() + i);\n+  \n+  VERIFY( std::equal(s1.begin(), s1.begin() + N, B) );\n+\n+  // sort array s2 using make_heap/sort_heap\n+  std::vector<bool> s2;\n+  std::copy(A, A + N, std::back_inserter(s2));\n+  VERIFY( std::equal(s2.begin(), s2.begin() + N, A) );\n+  \n+  std::make_heap(s2.begin(), s2.begin() + N);\n+  std::sort_heap(s2.begin(), s2.begin() + N);\n+  VERIFY( std::equal(s2.begin(), s2.begin() + N, B) );\n+}\n+\n+// Perform same tests as above but with the comparison predicate\n+// versions, and add complexity constraint checks.\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  Gt gt;\n+\n+#ifndef _GLIBCXX_DEBUG\n+  //const int logN = static_cast<int>(std::log(static_cast<double>(N)) + 0.5);\n+  const int logN = 3;\n+#endif\n+  \n+  std::vector<bool> s1;\n+  std::copy(A, A + N, std::back_inserter(s1));\n+  VERIFY(std::equal(s1.begin(), s1.begin() + N, A));\n+  \n+  for (int i = 2; i <= N; ++i)\n+    {\n+      std::push_heap(s1.begin(), s1.begin() + i, gt);\n+#ifndef _GLIBCXX_DEBUG\n+      VERIFY(gt.count() <= logN);\n+#endif\n+      gt.reset();\n+    }\n+\n+  for (int i = N; i >= 2; --i)\n+    {\n+      std::pop_heap(s1.begin(), s1.begin() + i, gt);\n+#ifndef _GLIBCXX_DEBUG\n+      VERIFY(gt.count() <= 2 * logN);\n+#endif\n+      gt.reset();\n+    }\n+\n+  VERIFY(std::equal(s1.begin(), s1.begin() + N, C));\n+  \n+  // sort array s2 using make_heap/sort_heap\n+  std::vector<bool> s2;\n+  std::copy(A, A + N, std::back_inserter(s2));\n+  VERIFY(std::equal(s2.begin(), s2.begin() + N, A));\n+  \n+  std::make_heap(s2.begin(), s2.begin() + N, gt);\n+#ifndef _GLIBCXX_DEBUG\n+  VERIFY(gt.count() <= 3 * N);\n+#endif\n+  gt.reset();\n+\n+  std::sort_heap(s2.begin(), s2.begin() + N, gt);\n+#ifndef _GLIBCXX_DEBUG\n+  VERIFY(gt.count() <= N * logN);\n+#endif\n+  \n+  VERIFY(std::equal(s2.begin(), s2.begin() + N, C));\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "be5b4ff531f632984aabd383f0213041f6e10f33", "filename": "libstdc++-v3/testsuite/25_algorithms/is_permutation/vectorbool.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fvectorbool.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fvectorbool.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fis_permutation%2Fvectorbool.cc?ref=ea89b2482f97aa55e4d3fa4c57e0a6b2cdb69f64", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=gnu++1y\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [alg.is_permutation] Is permutation\n+\n+#include <vector>\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::vector<bool> v1 = { true, false, true, false, true };\n+  std::vector<bool> v2 = { false, true, false, true, true };\n+  VERIFY( std::is_permutation(v1.begin(), v1.end(), v2.begin()) );\n+  VERIFY( !std::is_permutation(v1.begin() + 1, v1.end(), v2.begin() + 1) );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::vector<bool> v1 = { true, false, true, false, true };\n+  std::vector<bool> v2 = { false, true, false, true, true };\n+  VERIFY( std::is_permutation(v1.begin(), v1.end(), v2.begin(), v2.end()) );\n+  VERIFY( !std::is_permutation(v1.begin(), v1.end() - 1, v2.begin(), v2.end()) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}]}