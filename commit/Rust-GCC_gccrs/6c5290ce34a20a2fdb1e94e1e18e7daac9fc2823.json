{"sha": "6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1MjkwY2UzNGEyMGEyZmRiMWU5NGUxZTE4ZTdkYWFjOWZjMjgyMw==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2007-06-06T10:18:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:18:34Z"}, "message": "a-except.ads, [...]: (Rmsg_28): Fix description for E.4(18) check.\n\n2007-04-20  Thomas Quinot  <quinot@adacore.com>\n\t    Olivier Hainque  <hainque@adacore.com>\n\t    Robert Dewar  <dewar@adacore.com>\n\n\t* a-except.ads, a-except.adb: (Rmsg_28): Fix description for E.4(18)\n\tcheck.\n\t(Raise_Current_Excep): Call Debug_Raise_Exception just before\n\tpropagation starts, to let debuggers know about the event in a reliable\n\tfashion.\n\t(Local_Raise): Moved to System.Exceptions\n\tMore convenient to have this as a separate unit\n\n\t* s-except.adb, s-except.ads: New files.\n\n\t* a-exextr.adb (Unhandled_Exception): Delete - replaced by\n\tDebug_Unhandled_Exception in System.Exceptions where it belongs\n\ttogether with a couple of other debug helpers.\n\t(Notify_Unhandled_Exception): Use Debug_Unhandled_Exception instead of\n\tthe former Unhandled_Exception.\n\n\t* exp_ch11.ads, exp_ch11.adb: (Possible_Local_Raise): New procedure\n\t(Warn_No_Exception_Propagation): New procedure\n\t(Warn_If_No_Propagation): Rewritten for new warning generation\n\t(Expand_Exception_Handlers): New warning generation\n\t(Expand_N_Raise_xxx_Error): Rewritten for new warnings\n\t(Add_Exception_Label): Use Special_Exception_Package_Used for test\n\tinstead of Most_Recent_Exception_Used (accomodates Exception_Traces)\n\t(Expand_Local_Exception_Handlers): Unconditionally add extra block wrap\n\teven if restriction is set (makes life easier in Check_Returns)\n\t(Expand_Local_Exception_Handlers): Follow renamed entity chain when\n\tchecking exception identities.\n\t(Expand_Local_Exception_Handlers): Do not optimize when all others case\n\t(Expand_Local_Exception_Handlers): Set Exception_Junk flag on generated\n\tblock for handler (used by Check_Returns)\n\t(Expand_Local_Exception_Handlers): Local_Raise now takes an address\n\t(Expand_N_Handled_Sequence_Of_Statements): Properly handle -gnatd.x to\n\tremove all exception handlers when optimizing local raise statements.\n\t(Find_Local_Handler): Use Get_Renamed_Entity\n\t(Expand_N_Handled_Sequence_Of_Statements): If the handled sequence is\n\tmarked analyzed after expanding exception handlers, do not generate\n\tredundant cleanup actions, because they have been constructed already.\n\nFrom-SVN: r125375", "tree": {"sha": "34593359b8bd031d198beba60724284ea01a5300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34593359b8bd031d198beba60724284ea01a5300"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/comments", "author": null, "committer": null, "parents": [{"sha": "107cd232e104d0f53bc7924bff71251388668707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/107cd232e104d0f53bc7924bff71251388668707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/107cd232e104d0f53bc7924bff71251388668707"}], "stats": {"total": 791, "additions": 581, "deletions": 210}, "files": [{"sha": "0048622473d0f047a8780f841da03ad91fc64aec", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -50,6 +50,7 @@ pragma Polling (Off);\n --  elaboration circularities with System.Exception_Tables.\n \n with System;                  use System;\n+with System.Exceptions;       use System.Exceptions;\n with System.Standard_Library; use System.Standard_Library;\n with System.Soft_Links;       use System.Soft_Links;\n \n@@ -521,8 +522,8 @@ package body Ada.Exceptions is\n    Rmsg_25 : constant String := \"potentially blocking operation\"   & NUL;\n    Rmsg_26 : constant String := \"stubbed subprogram called\"        & NUL;\n    Rmsg_27 : constant String := \"unchecked union restriction\"      & NUL;\n-   Rmsg_28 : constant String := \"illegal use of remote access-to-\" &\n-                                \"class-wide type, see RM E.4(18)\"  & NUL;\n+   Rmsg_28 : constant String := \"actual/returned class-wide value \"\n+                                & \"not transportable\"              & NUL;\n    Rmsg_29 : constant String := \"empty storage pool\"               & NUL;\n    Rmsg_30 : constant String := \"explicit raise\"                   & NUL;\n    Rmsg_31 : constant String := \"infinite recursion\"               & NUL;\n@@ -690,16 +691,6 @@ package body Ada.Exceptions is\n    --  in case we do not want any exception tracing support. This is\n    --  why this package is separated.\n \n-   -----------------\n-   -- Local_Raise --\n-   -----------------\n-\n-   procedure Local_Raise (Excep : Exception_Id) is\n-      pragma Warnings (Off, Excep);\n-   begin\n-      return;\n-   end Local_Raise;\n-\n    -----------------------\n    -- Stream Attributes --\n    -----------------------\n@@ -800,6 +791,7 @@ package body Ada.Exceptions is\n       --  pragma Volatile is peculiar!\n \n    begin\n+      Debug_Raise_Exception (E => SSL.Exception_Data_Ptr (E));\n       Process_Raise_Exception (E);\n    end Raise_Current_Excep;\n \n@@ -837,6 +829,46 @@ package body Ada.Exceptions is\n       Raise_Current_Excep (E);\n    end Raise_Exception_Always;\n \n+   -------------------------------------\n+   -- Raise_From_Controlled_Operation --\n+   -------------------------------------\n+\n+   procedure Raise_From_Controlled_Operation\n+     (X : Ada.Exceptions.Exception_Occurrence)\n+   is\n+      Prefix   : constant String := \"adjust/finalize raised \";\n+      Orig_Msg : constant String := Exception_Message (X);\n+      New_Msg  : constant String := Prefix & Exception_Name (X);\n+\n+   begin\n+      if Orig_Msg'Length >= Prefix'Length\n+        and then\n+          Orig_Msg (Orig_Msg'First .. Orig_Msg'First + Prefix'Length - 1) =\n+                                                                     Prefix\n+      then\n+         --  Message already has proper prefix, just re-reraise PROGRAM_ERROR\n+\n+         Raise_Exception_No_Defer\n+           (E       => Program_Error'Identity,\n+            Message => Orig_Msg);\n+\n+      elsif Orig_Msg = \"\" then\n+\n+         --  No message present: just provide our own\n+\n+         Raise_Exception_No_Defer\n+           (E       => Program_Error'Identity,\n+            Message => New_Msg);\n+\n+      else\n+         --  Message present, add informational prefix\n+\n+         Raise_Exception_No_Defer\n+           (E       => Program_Error'Identity,\n+            Message => New_Msg & \": \" & Orig_Msg);\n+      end if;\n+   end Raise_From_Controlled_Operation;\n+\n    -------------------------------\n    -- Raise_From_Signal_Handler --\n    -------------------------------"}, {"sha": "a5c77af03c8ac8e455bc82ac11a20e527b8e63ac", "filename": "gcc/ada/a-except.ads", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.ads?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -175,15 +175,6 @@ private\n    --  private barrier, so we can place this function in the private part\n    --  where the compiler can find it, but the spec is unchanged.)\n \n-   procedure Local_Raise (Excep : Exception_Id);\n-   pragma Export (Ada, Local_Raise);\n-   --  This is a dummy routine, used only by the debugger for the purpose of\n-   --  logging local raise statements that were transformed into a direct goto\n-   --  to the handler code. The compiler in this case generates:\n-   --\n-   --    Local_Raise (exception_id);\n-   --    goto Handler\n-\n    procedure Raise_Exception_Always (E : Exception_Id; Message : String := \"\");\n    pragma No_Return (Raise_Exception_Always);\n    pragma Export (Ada, Raise_Exception_Always, \"__gnat_raise_exception\");\n@@ -211,6 +202,12 @@ private\n    --  PC value in the machine state or in some other way ask the operating\n    --  system to return here rather than to the original location.\n \n+   procedure Raise_From_Controlled_Operation\n+     (X : Ada.Exceptions.Exception_Occurrence);\n+   pragma No_Return (Raise_From_Controlled_Operation);\n+   --  Raise Program_Error, proviving information about X (an exception\n+   --  raised during a controlled operation) in the exception message.\n+\n    procedure Reraise_Occurrence_Always (X : Exception_Occurrence);\n    pragma No_Return (Reraise_Occurrence_Always);\n    --  This differs from Raise_Occurrence only in that the caller guarantees"}, {"sha": "af6bec474ddc4f4f72a582d40079ca60c7ab3e85", "filename": "gcc/ada/a-exextr.adb", "status": "modified", "additions": 5, "deletions": 30, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-exextr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fa-exextr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exextr.adb?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Unchecked_Conversion;\n+with Ada.Unchecked_Conversion;\n \n pragma Warnings (Off);\n with Ada.Exceptions.Last_Chance_Handler;\n@@ -62,7 +62,7 @@ package body Exception_Traces is\n    --  Users can replace the default version of this routine,\n    --  Ada.Exceptions.Last_Chance_Handler.\n \n-   function To_Action is new Unchecked_Conversion\n+   function To_Action is new Ada.Unchecked_Conversion\n      (Raise_Action, Exception_Action);\n \n    -----------------------\n@@ -75,22 +75,6 @@ package body Exception_Traces is\n    --  latter case because Notify_Handled_Exception may be called for an\n    --  actually unhandled occurrence in the Front-End-SJLJ case.\n \n-   ---------------------------------\n-   -- Debugger Interface Routines --\n-   ---------------------------------\n-\n-   --  The routines here are null routines that normally have no effect.\n-   --  They are provided for the debugger to place breakpoints on their\n-   --  entry points to get control on an exception.\n-\n-   procedure Unhandled_Exception;\n-   pragma Export (C, Unhandled_Exception, \"__gnat_unhandled_exception\");\n-   --  Hook for GDB to support \"break exception unhandled\"\n-\n-   --  For \"break exception\", GDB uses __gnat_raise_nodefer_with_msg, which\n-   --  is not in this section because it functions as more than simply a\n-   --  debugger interface.\n-\n    --------------------------------\n    -- Import Run-Time C Routines --\n    --------------------------------\n@@ -120,7 +104,7 @@ package body Exception_Traces is\n       if not Excep.Id.Not_Handled_By_Others\n         and then\n         (Exception_Trace = Every_Raise\n-         or else (Exception_Trace = Unhandled_Raise and then Is_Unhandled))\n+          or else (Exception_Trace = Unhandled_Raise and then Is_Unhandled))\n       then\n          To_Stderr (Nline);\n \n@@ -173,18 +157,9 @@ package body Exception_Traces is\n       Task_Termination_Handler.all (Excep.all);\n \n       Notify_Exception (Excep, Is_Unhandled => True);\n-      Unhandled_Exception;\n+      Debug_Unhandled_Exception (SSL.Exception_Data_Ptr (Excep.Id));\n    end Notify_Unhandled_Exception;\n \n-   -------------------------\n-   -- Unhandled_Exception --\n-   -------------------------\n-\n-   procedure Unhandled_Exception is\n-   begin\n-      null;\n-   end Unhandled_Exception;\n-\n    -----------------------------------\n    -- Unhandled_Exception_Terminate --\n    -----------------------------------"}, {"sha": "0bf8711dd622ba8e3b212c34b3201cfd392520d4", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 350, "deletions": 156, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,7 +32,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Util; use Exp_Util;\n-with Hostparm; use Hostparm;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -59,16 +58,10 @@ package body Exp_Ch11 is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Find_Local_Handler\n-     (Ename : Entity_Id;\n-      Nod   : Node_Id) return Node_Id;\n-   pragma Warnings (Off, Find_Local_Handler);\n-   --  This function searches for a local exception handler that will handle\n-   --  the exception named by Ename. If such a local hander exists, then the\n-   --  corresponding N_Exception_Handler is returned. If no such handler is\n-   --  found then Empty is returned. In order to match and return True, the\n-   --  handler may not have a choice parameter specification. N is the raise\n-   --  node that references the handler.\n+   procedure Warn_No_Exception_Propagation_Active (N : Node_Id);\n+   --  Generates warning that pragma Restrictions (No_Exception_Propagation)\n+   --  is in effect. Caller then generates appropriate continuation message.\n+   --  N is the node on which the warning is placed.\n \n    procedure Warn_If_No_Propagation (N : Node_Id);\n    --  Called for an exception raise that is not a local raise (and thus can\n@@ -131,12 +124,16 @@ package body Exp_Ch11 is\n          return;\n       end if;\n \n-      if Restriction_Active (No_Exception_Handlers) then\n+      --  Don't expand an At End handler if we are not allowing exceptions\n+      --  or if exceptions are transformed into local gotos, and never\n+      --  propagated (No_Exception_Propagation).\n+\n+      if No_Exception_Handlers_Set then\n          return;\n       end if;\n \n       if Present (Block) then\n-         New_Scope (Block);\n+         Push_Scope (Block);\n       end if;\n \n       Ohandle :=\n@@ -196,7 +193,7 @@ package body Exp_Ch11 is\n \n       --  There are two cases for this transformation. First the case of\n       --  explicit raise statements. For this case, the transformation we do\n-      --  looks like this. Right now we have for example (where L1,L2 are\n+      --  looks like this. Right now we have for example (where L1, L2 are\n       --  exception labels)\n \n       --  begin\n@@ -215,16 +212,16 @@ package body Exp_Ch11 is\n       --  This gets transformed into:\n \n       --  begin\n-      --     L1 : label;\n-      --     L2 : label;\n-      --     L3 : label;\n+      --     L1 : label;                        -- marked Exception_Junk\n+      --     L2 : label;                        -- marked Exception_Junk\n+      --     L3 : label;                        -- marked Exception_Junk\n \n-      --     begin\n+      --     begin                              -- marked Exception_Junk\n       --        ...\n-      --        local_raise (excep1'Identity);   -- was raise excep1\n+      --        local_raise (excep1'address);   -- was raise excep1\n       --        goto L1;\n       --        ...\n-      --        local_raise (excep2'Identity);   -- was raise excep2\n+      --        local_raise (excep2'address);   -- was raise excep2\n       --        goto L2;\n       --        ...\n       --     exception\n@@ -234,16 +231,20 @@ package body Exp_Ch11 is\n       --           goto L2;\n       --     end;\n \n-      --     goto L3;   -- skip handler when exception not raised\n+      --     goto L3;        -- skip handler if no raise, marked Exception_Junk\n \n-      --     <<L1>>     -- target label for local exception\n-      --        estmts1\n-      --        goto L3;\n+      --     <<L1>>          -- local excep target label, marked Exception_Junk\n+      --        begin        -- marked Exception_Junk\n+      --           estmts1\n+      --        end;\n+      --        goto L3;     -- marked Exception_Junk\n \n-      --     <<L2>>\n-      --        estmts2\n-      --        goto L3;\n-      --     <<L3>>\n+      --     <<L2>>          -- marked Exception_Junk\n+      --        begin        -- marked Exception_Junk\n+      --           estmts2\n+      --        end;\n+      --        goto L3;     -- marked Exception_Junk\n+      --     <<L3>>          -- marked Exception_Junk\n       --  end;\n \n       --  Note: the reason we wrap the original statement sequence in an\n@@ -253,31 +254,37 @@ package body Exp_Ch11 is\n       --  must not reenter the same exception handlers.\n \n       --  If the restriction No_Exception_Propagation is in effect, then we\n-      --  can omit the exception handlers, and we do not need the inner block.\n+      --  can omit the exception handlers.\n \n       --  begin\n-      --     L1 : label;\n-      --     L2 : label;\n-      --     L3 : label;\n+      --     L1 : label;                        -- marked Exception_Junk\n+      --     L2 : label;                        -- marked Exception_Junk\n+      --     L3 : label;                        -- marked Exception_Junk\n \n-      --     ...\n-      --     local_raise (excep1'Identity);   -- was raise excep1\n-      --     goto L1;\n-      --     ...\n-      --     local_raise (excep2'Identity);   -- was raise excep2\n-      --     goto L2;\n-      --     ...\n+      --     begin                              -- marked Exception_Junk\n+      --        ...\n+      --        local_raise (excep1'address);   -- was raise excep1\n+      --        goto L1;\n+      --        ...\n+      --        local_raise (excep2'address);   -- was raise excep2\n+      --        goto L2;\n+      --        ...\n+      --     end;\n \n-      --     goto L3;   -- skip handler when exception not raised\n+      --     goto L3;        -- skip handler if no raise, marked Exception_Junk\n \n-      --     <<L1>>     -- target label for local exception\n-      --        estmts1\n-      --        goto L3;\n+      --     <<L1>>          -- local excep target label, marked Exception_Junk\n+      --        begin        -- marked Exception_Junk\n+      --           estmts1\n+      --        end;\n+      --        goto L3;     -- marked Exception_Junk\n \n-      --     <<L2>>\n-      --        estmts2\n-      --        goto L3;\n-      --     <<L3>>\n+      --     <<L2>>          -- marked Exception_Junk\n+      --        begin        -- marked Exception_Junk\n+      --           estmts2\n+      --        end;\n+\n+      --     <<L3>>          -- marked Exception_Junk\n       --  end;\n \n       --  The second case is for exceptions generated by the back end in one\n@@ -309,8 +316,8 @@ package body Exp_Ch11 is\n       --  raise, then the front end does the expansion described previously,\n       --  creating a label to be used as a goto target to raise the exception.\n       --  However, no attempt is made in the front end to convert any related\n-      --  raise statements into gotos, e.g. all Raise_xxx_Error nodes are left\n-      --  unchanged and passed to the back end.\n+      --  raise statements into gotos, e.g. all N_Raise_xxx_Error nodes are\n+      --  left unchanged and passed to the back end.\n \n       --  Instead, the front end generates two nodes\n \n@@ -335,11 +342,11 @@ package body Exp_Ch11 is\n       --  of code, no optimization is possible.\n \n       --  The back end must maintain three stacks, one for each exception case,\n-      --  the Push node pushes an entry onto the corresponding stack, and pop\n+      --  the Push node pushes an entry onto the corresponding stack, and Pop\n       --  node pops off the entry. Then instead of calling Rcheck_nn, if the\n       --  corresponding top stack entry has an non-empty label, a goto is\n-      --  generated instead of the call. This goto should be preceded by a\n-      --  call to Local_Raise as described above.\n+      --  generated. This goto should be preceded by a call to Local_Raise as\n+      --  described above.\n \n       --  An example of this transformation is as follows, given:\n \n@@ -362,12 +369,12 @@ package body Exp_Ch11 is\n       --     L2 : label;\n \n       --     begin\n-      --       %push_constraint_error_label (L1)\n-      --       R1b : constant long_long_integer := long_long_integer?(b) +\n-      --         long_long_integer?(c);\n-      --       [constraint_error when\n-      --         not (R1b in -16#8000_0000# .. 16#7FFF_FFFF#)\n-      --         \"overflow check failed\"]\n+      --        %push_constraint_error_label (L1)\n+      --        R1b : constant long_long_integer := long_long_integer?(b) +\n+      --          long_long_integer?(c);\n+      --        [constraint_error when\n+      --          not (R1b in -16#8000_0000# .. 16#7FFF_FFFF#)\n+      --          \"overflow check failed\"]\n       --        a := integer?(R1b);\n       --        %pop_constraint_error_Label\n \n@@ -383,6 +390,15 @@ package body Exp_Ch11 is\n       --     <<L2>>\n       --  end;\n \n+      --  Note: the generated labels and goto statements all have the flag\n+      --  Exception_Junk set True, so that Sem_Ch6.Check_Returns will ignore\n+      --  this generated exception stuff when checking for missing return\n+      --  statements (see circuitry in Check_Statement_Sequence).\n+\n+      --  Note: All of the processing described above occurs only if\n+      --  restriction No_Exception_Propagation applies or debug flag .g is\n+      --  enabled.\n+\n       CE_Locally_Handled : Boolean := False;\n       SE_Locally_Handled : Boolean := False;\n       PE_Locally_Handled : Boolean := False;\n@@ -400,9 +416,9 @@ package body Exp_Ch11 is\n \n          procedure Add_Exception_Label (H : Node_Id);\n          --  H is an exception handler. First check for an Exception_Label\n-         --  already allocated for H. If not, allocate one, set the field in\n+         --  already allocated for H. If none, allocate one, set the field in\n          --  the handler node, add the label declaration, and set the flag\n-         --  Local_Expansion_Required. Note: if Local_Handlers_Not_OK is set\n+         --  Local_Expansion_Required. Note: if Local_Raise_Not_OK is set\n          --  the call has no effect and Exception_Label is left empty.\n \n          procedure Add_Label_Declaration (L : Entity_Id);\n@@ -433,6 +449,7 @@ package body Exp_Ch11 is\n          begin\n             if No (Exception_Label (H))\n               and then not Local_Raise_Not_OK (H)\n+              and then not Special_Exception_Package_Used\n             then\n                Local_Expansion_Required := True;\n \n@@ -489,8 +506,15 @@ package body Exp_Ch11 is\n                Pop  : constant Node_Id := Make_Pop_Label  (Sloc (L));\n \n             begin\n-               Set_Exception_Label (Push, Exception_Label (H));\n+               --  We make sure that a call to Get_Local_Raise_Call_Entity is\n+               --  made during front end processing, so that when we need it\n+               --  in the back end, it will already be available and loaded.\n \n+               Discard_Node (Get_Local_Raise_Call_Entity);\n+\n+               --  Prepare and insert Push and Pop nodes\n+\n+               Set_Exception_Label (Push, Exception_Label (H));\n                Insert_Before (F, Push);\n                Set_Analyzed (Push);\n \n@@ -502,8 +526,9 @@ package body Exp_Ch11 is\n          --  Local declarations\n \n          Loc    : constant Source_Ptr := Sloc (HSS);\n-         Stmts  : List_Id;\n+         Stmts  : List_Id := No_List;\n          Choice : Node_Id;\n+         Excep  : Entity_Id;\n \n          procedure Generate_Push_Pop_For_Constraint_Error is\n            new Generate_Push_Pop\n@@ -535,8 +560,16 @@ package body Exp_Ch11 is\n          --  not already done), and generate Push/Pop nodes for the exception\n          --  label at the start and end of the statements of HSS.\n \n+      --  Start of processing for Expand_Local_Exception_Handlers\n+\n       begin\n-         --  See if we have any potential local raises to expand\n+         --  No processing if all exception handlers will get removed\n+\n+         if Debug_Flag_Dot_X then\n+            return;\n+         end if;\n+\n+         --  See for each handler if we have any local raises to expand\n \n          Handler := First_Non_Pragma (Handlrs);\n          while Present (Handler) loop\n@@ -552,26 +585,31 @@ package body Exp_Ch11 is\n \n             --  If we are doing local raise to goto optimization (restriction\n             --  No_Exception_Propagation set or debug flag .g set), then check\n-            --  to see if handler handles CE,PE,SE and if so generate the\n-            --  appropriate push/pop sequences for the back end\n+            --  to see if handler handles CE, PE, SE and if so generate the\n+            --  appropriate push/pop sequence for the back end.\n \n-            if Debug_Flag_Dot_G\n-              or else Restriction_Active (No_Exception_Propagation)\n+            if (Debug_Flag_Dot_G\n+                 or else Restriction_Active (No_Exception_Propagation))\n+              and then Has_Local_Raise (Handler)\n             then\n                Choice := First (Exception_Choices (Handler));\n                while Present (Choice) loop\n-                  if Nkind (Choice) = N_Others_Choice then\n+                  if Nkind (Choice) = N_Others_Choice\n+                    and then not All_Others (Choice)\n+                  then\n                      Generate_Push_Pop_For_Constraint_Error (Handler);\n                      Generate_Push_Pop_For_Program_Error    (Handler);\n                      Generate_Push_Pop_For_Storage_Error    (Handler);\n \n                   elsif Is_Entity_Name (Choice) then\n-                     if Entity (Choice) = Standard_Constraint_Error then\n+                     Excep := Get_Renamed_Entity (Entity (Choice));\n+\n+                     if Excep = Standard_Constraint_Error then\n                         Generate_Push_Pop_For_Constraint_Error (Handler);\n-                     elsif Entity (Choice) = Standard_Program_Error then\n-                        Generate_Push_Pop_For_Program_Error (Handler);\n-                     elsif Entity (Choice) = Standard_Storage_Error then\n-                        Generate_Push_Pop_For_Storage_Error (Handler);\n+                     elsif Excep = Standard_Program_Error then\n+                        Generate_Push_Pop_For_Program_Error    (Handler);\n+                     elsif Excep = Standard_Storage_Error then\n+                        Generate_Push_Pop_For_Storage_Error    (Handler);\n                      end if;\n                   end if;\n \n@@ -591,6 +629,8 @@ package body Exp_Ch11 is\n          --  Prepare to do the transformation\n \n          declare\n+            --  L3 is the label to exit the HSS\n+\n             L3_Dent : constant Entity_Id :=\n                         Make_Defining_Identifier (Loc,\n                           Chars => New_Internal_Name ('L'));\n@@ -599,39 +639,29 @@ package body Exp_Ch11 is\n                         Make_Label (Loc,\n                           Identifier => New_Occurrence_Of (L3_Dent, Loc));\n \n-            Old_HSS : Node_Id;\n             Blk_Stm : Node_Id;\n             Relmt   : Elmt_Id;\n \n          begin\n+            Set_Exception_Junk (Labl_L3);\n             Add_Label_Declaration (L3_Dent);\n \n-            --  If the No_Exception_Propagation restriction is not active,\n-            --  then we must wrap the existing statements and exception\n-            --  handlers in an inner block.\n-\n-            if not Restriction_Active (No_Exception_Propagation) then\n-               Old_HSS := Relocate_Node (HSS);\n+            --  Wrap existing statements and handlers in an inner block\n \n-               --  Construct and analyze the block with a dummy HSS inside it\n-               --  for now (if we do the analyze call with the real HSS in\n-               --  place we have nasty recursion problems).\n-\n-               Blk_Stm :=\n-                 Make_Block_Statement (Loc,\n-                   Handled_Statement_Sequence =>\n-                     Make_Handled_Sequence_Of_Statements (Loc,\n-                       Statements => Empty_List));\n+            Blk_Stm :=\n+              Make_Block_Statement (Loc,\n+                Handled_Statement_Sequence => Relocate_Node (HSS));\n+            Set_Exception_Junk (Blk_Stm);\n \n-               Rewrite (HSS,\n-                 Make_Handled_Sequence_Of_Statements (Loc,\n-                   Statements => New_List (Blk_Stm)));\n-               Analyze (HSS);\n+            Rewrite (HSS,\n+              Make_Handled_Sequence_Of_Statements (Loc,\n+                Statements => New_List (Blk_Stm)));\n \n-               --  Now we can set the real statement sequence in place\n+            --  Set block statement as analyzed, we don't want to actually call\n+            --  Analyze on this block, it would cause a recursion in exception\n+            --  handler processing which would mess things up.\n \n-               Set_Handled_Statement_Sequence (Blk_Stm, Old_HSS);\n-            end if;\n+            Set_Analyzed (Blk_Stm);\n \n             --  Now loop through the exception handlers to deal with those that\n             --  are targets of local raise statements.\n@@ -645,20 +675,28 @@ package body Exp_Ch11 is\n                   declare\n                      Loc : constant Source_Ptr := Sloc (Handler);\n \n+                     --  L1 is the start label for this handler\n+\n                      L1_Dent : constant Entity_Id := Exception_Label (Handler);\n \n                      Labl_L1 : constant Node_Id :=\n                                  Make_Label (Loc,\n                                    Identifier =>\n                                      New_Occurrence_Of (L1_Dent, Loc));\n \n+                     --  Jump to L1 to be used as replacement for the original\n+                     --  handler (used in the case where exception propagation\n+                     --  may still occur).\n+\n                      Name_L1 : constant Node_Id :=\n                                  New_Occurrence_Of (L1_Dent, Loc);\n \n                      Goto_L1 : constant Node_Id :=\n                                  Make_Goto_Statement (Loc,\n                                    Name => Name_L1);\n \n+                     --  Jump to L3 to be used at the end of handler\n+\n                      Name_L3 : constant Node_Id :=\n                                  New_Occurrence_Of (L3_Dent, Loc);\n \n@@ -669,9 +707,18 @@ package body Exp_Ch11 is\n                      H_Stmts : constant List_Id := Statements (Handler);\n \n                   begin\n+                     Set_Exception_Junk (Labl_L1);\n+                     Set_Exception_Junk (Goto_L3);\n+\n+                     --  Note: we do NOT set Exception_Junk in Goto_L1, since\n+                     --  this is a real transfer of control that we want the\n+                     --  Sem_Ch6.Check_Returns procedure to recognize properly.\n+\n                      --  Replace handler by a goto L1. We can mark this as\n                      --  analyzed since it is fully formed, and we don't\n-                     --  want it going through any further checks.\n+                     --  want it going through any further checks. We save\n+                     --  the last statement location in the goto L1 node for\n+                     --  the benefit of Sem_Ch6.Check_Returns.\n \n                      Set_Statements (Handler, New_List (Goto_L1));\n                      Set_Analyzed (Goto_L1);\n@@ -704,11 +751,11 @@ package body Exp_Ch11 is\n                         end loop;\n                      end if;\n \n-                     --  Add goto L3 at end of statement list in block. The\n+                     --  Add a goto L3 at end of statement list in block. The\n                      --  first time, this is what skips over the exception\n                      --  handlers in the normal case. Subsequent times, it\n-                     --  terminates the execution of the handler code, and\n-                     --  skips subsequent handlers.\n+                     --  terminates the execution of the previous handler code,\n+                     --  and skips subsequent handlers.\n \n                      Stmts := Statements (HSS);\n \n@@ -722,19 +769,30 @@ package body Exp_Ch11 is\n                      Set_Etype (Identifier (Labl_L1), Standard_Void_Type);\n \n                      Insert_After_And_Analyze (Last (Stmts), Labl_L1);\n-                     Insert_List_After        (Last (Stmts), H_Stmts);\n+\n+                     declare\n+                        Loc : constant Source_Ptr := Sloc (First (H_Stmts));\n+                        Blk : constant Node_Id :=\n+                                Make_Block_Statement (Loc,\n+                                  Handled_Statement_Sequence =>\n+                                    Make_Handled_Sequence_Of_Statements (Loc,\n+                                      Statements => H_Stmts));\n+                     begin\n+                        Set_Exception_Junk (Blk);\n+                        Insert_After_And_Analyze (Last (Stmts), Blk);\n+                     end;\n                   end;\n \n                   --  Here if we have local raise statements but the handler is\n                   --  not suitable for processing with a local raise. In this\n-                  --  case we have to delete the Local_Raise call and also\n-                  --  generate possible diagnostics.\n+                  --  case we have to generate possible diagnostics.\n \n-               else\n+               elsif Has_Local_Raise (Handler)\n+                 and then Local_Raise_Statements (Handler) /= No_Elist\n+               then\n                   Relmt := First_Elmt (Local_Raise_Statements (Handler));\n                   while Present (Relmt) loop\n                      Warn_If_No_Propagation (Node (Relmt));\n-                     Remove (Prev (Node (Relmt)));\n                      Next_Elmt (Relmt);\n                   end loop;\n                end if;\n@@ -745,7 +803,21 @@ package body Exp_Ch11 is\n             --  Only remaining step is to drop the L3 label and we are done\n \n             Set_Etype (Identifier (Labl_L3), Standard_Void_Type);\n-            Insert_After_And_Analyze (Last (Stmts), Labl_L3);\n+\n+            --  If we had at least one handler, then we drop the label after\n+            --  the last statement of that handler.\n+\n+            if Stmts /= No_List then\n+               Insert_After_And_Analyze (Last (Stmts), Labl_L3);\n+\n+            --  Otherwise we have removed all the handlers (this results from\n+            --  use of pragma Restrictions (No_Exception_Propagation), and we\n+            --  drop the label at the end of the statements of the HSS.\n+\n+            else\n+               Insert_After_And_Analyze (Last (Statements (HSS)), Labl_L3);\n+            end if;\n+\n             return;\n          end;\n       end Expand_Local_Exception_Handlers;\n@@ -810,8 +882,8 @@ package body Exp_Ch11 is\n             Excep := Standard_Program_Error;\n             Cond := Condition (Raise_S);\n \n-            --  The only other possibility is a node that is or used to be\n-            --  a simple raise statement.\n+            --  The only other possibility is a node that is or used to be a\n+            --  simple raise statement.\n \n          else\n             Orig := Original_Node (Raise_S);\n@@ -823,16 +895,17 @@ package body Exp_Ch11 is\n          end if;\n \n          --  Here Excep is the exception to raise, and Cond is the condition\n-         --  First prepare the call to Local_Raise (excep'Identity).\n+         --  First prepare the call to Local_Raise (excep'address).\n \n          if RTE_Available (RE_Local_Raise) then\n             LR :=\n               Make_Procedure_Call_Statement (Loc,\n                 Name => New_Occurrence_Of (RTE (RE_Local_Raise), Loc),\n                 Parameter_Associations => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix         => New_Occurrence_Of (Excep, Loc),\n-                    Attribute_Name => Name_Identity)));\n+                  Unchecked_Convert_To (RTE (RE_Address),\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (Excep, Loc),\n+                      Attribute_Name => Name_Identity))));\n \n             --  Use null statement if Local_Raise not available\n \n@@ -854,6 +927,7 @@ package body Exp_Ch11 is\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => New_List (LR, Goto_L1))));\n+            Set_Exception_Junk (Raise_S);\n \n          --  If there is a condition, we rewrite as\n \n@@ -892,13 +966,11 @@ package body Exp_Ch11 is\n          --  if a source generated handler was not the target of a local raise.\n \n          elsif Restriction_Active (No_Exception_Propagation) then\n-            if No (Local_Raise_Statements (Handler))\n+            if not Has_Local_Raise (Handler)\n               and then Comes_From_Source (Handler)\n               and then Warn_On_Non_Local_Exception\n             then\n-               Error_Msg_N\n-                 (\"?pragma Restrictions (No_Exception_Propagation) in effect\",\n-                  Handler);\n+               Warn_No_Exception_Propagation_Active (Handler);\n                Error_Msg_N\n                  (\"\\?this handler can never be entered, and has been removed\",\n                   Handler);\n@@ -972,7 +1044,7 @@ package body Exp_Ch11 is\n             --  passing a call to the intrinsic Current_Target_Exception (see\n             --  JVM version of Ada.Exceptions in 4jexcept.adb for details).\n \n-            if Hostparm.Java_VM then\n+            if VM_Target /= No_VM then\n                declare\n                   Arg : constant Node_Id :=\n                           Make_Function_Call (Loc,\n@@ -999,7 +1071,7 @@ package body Exp_Ch11 is\n \n                --  We also suppress the call if this is the special handler\n                --  for Abort_Signal, since if we are aborting, we want to keep\n-               --  aborts deferred (one abort is enough thank you very much :-)\n+               --  aborts deferred (one abort is enough).\n \n                --  If abort really needs to be deferred the expander must add\n                --  this call explicitly, see Expand_N_Asynchronous_Select.\n@@ -1023,10 +1095,12 @@ package body Exp_Ch11 is\n          Handler := Next_Handler;\n       end loop Handler_Loop;\n \n-      --  If all handlers got removed, then remove the list\n+      --  If all handlers got removed, then remove the list. Note we cannot\n+      --  reference HSS here, since expanding local handlers may have buried\n+      --  the handlers in an inner block.\n \n-      if Is_Empty_List (Exception_Handlers (HSS)) then\n-         Set_Exception_Handlers (HSS, No_List);\n+      if Is_Empty_List (Handlrs) then\n+         Set_Exception_Handlers (Parent (Handlrs), No_List);\n       end if;\n    end Expand_Exception_Handlers;\n \n@@ -1068,7 +1142,7 @@ package body Exp_Ch11 is\n       --  There is no expansion needed when compiling for the JVM since the\n       --  JVM has a built-in exception mechanism. See 4jexcept.ads for details.\n \n-      if Hostparm.Java_VM then\n+      if VM_Target /= No_VM then\n          return;\n       end if;\n \n@@ -1126,7 +1200,7 @@ package body Exp_Ch11 is\n \n       --  Register_Exception (except'Unchecked_Access);\n \n-      if not Restriction_Active (No_Exception_Handlers)\n+      if not No_Exception_Handlers_Set\n         and then not Restriction_Active (No_Exception_Registration)\n       then\n          L := New_List (\n@@ -1177,13 +1251,23 @@ package body Exp_Ch11 is\n \n    procedure Expand_N_Handled_Sequence_Of_Statements (N : Node_Id) is\n    begin\n+      --  Expand exception handlers\n+\n       if Present (Exception_Handlers (N))\n         and then not Restriction_Active (No_Exception_Handlers)\n       then\n          Expand_Exception_Handlers (N);\n       end if;\n \n-      --  The following code needs comments ???\n+      --  If local exceptions are being expanded, the previous call will\n+      --  have rewritten the construct as a block and reanalyzed it. No\n+      --  further expansion is needed.\n+\n+      if Analyzed (N) then\n+         return;\n+      end if;\n+\n+      --  Add clean up actions if required\n \n       if Nkind (Parent (N)) /= N_Package_Body\n         and then Nkind (Parent (N)) /= N_Accept_Statement\n@@ -1208,6 +1292,10 @@ package body Exp_Ch11 is\n       --  what strange optimization in future may require this adjustment!\n \n       Adjust_Condition (Condition (N));\n+\n+      --  Now deal with possible local raise handling\n+\n+      Possible_Local_Raise (N, Standard_Constraint_Error);\n    end Expand_N_Raise_Constraint_Error;\n \n    ----------------------------------\n@@ -1222,6 +1310,10 @@ package body Exp_Ch11 is\n       --  what strange optimization in future may require this adjustment!\n \n       Adjust_Condition (Condition (N));\n+\n+      --  Now deal with possible local raise handling\n+\n+      Possible_Local_Raise (N, Standard_Program_Error);\n    end Expand_N_Raise_Program_Error;\n \n    ------------------------------\n@@ -1259,10 +1351,14 @@ package body Exp_Ch11 is\n                --  is analyzed twice and would otherwise be added twice.\n \n                Append_Unique_Elmt (N, Local_Raise_Statements (H));\n+               Set_Has_Local_Raise (H);\n+\n+            --  If no local handler, then generate no propagation warning\n+\n+            else\n+               Warn_If_No_Propagation (N);\n             end if;\n \n-         else\n-            Warn_If_No_Propagation (N);\n          end if;\n       end if;\n \n@@ -1294,7 +1390,7 @@ package body Exp_Ch11 is\n       --  mechanism. However we need to keep the expansion for \"raise;\"\n       --  statements. See 4jexcept.ads for details.\n \n-      if Present (Name (N)) and then Hostparm.Java_VM then\n+      if Present (Name (N)) and then VM_Target /= No_VM then\n          return;\n       end if;\n \n@@ -1360,7 +1456,7 @@ package body Exp_Ch11 is\n             --  Build a C-compatible string in case of no exception handlers,\n             --  since this is what the last chance handler is expecting.\n \n-            if Restriction_Active (No_Exception_Handlers) then\n+            if No_Exception_Handlers_Set then\n \n                --  Generate an empty message if configuration pragma\n                --  Suppress_Exception_Locations is set for this unit.\n@@ -1507,8 +1603,63 @@ package body Exp_Ch11 is\n       --  what strange optimization in future may require this adjustment!\n \n       Adjust_Condition (Condition (N));\n+\n+      --  Now deal with possible local raise handling\n+\n+      Possible_Local_Raise (N, Standard_Storage_Error);\n    end Expand_N_Raise_Storage_Error;\n \n+   --------------------------\n+   -- Possible_Local_Raise --\n+   --------------------------\n+\n+   procedure Possible_Local_Raise (N : Node_Id; E : Entity_Id) is\n+   begin\n+      --  Nothing to do if local raise optimization not active\n+\n+      if not Debug_Flag_Dot_G\n+        and then not Restriction_Active (No_Exception_Propagation)\n+      then\n+         return;\n+      end if;\n+\n+      --  Nothing to do if original node was an explicit raise, because in\n+      --  that case, we already generated the required warning for the raise.\n+\n+      if Nkind (Original_Node (N)) = N_Raise_Statement then\n+         return;\n+      end if;\n+\n+      --  Otherwise see if we have a local handler for the exception\n+\n+      declare\n+         H : constant Node_Id := Find_Local_Handler (E, N);\n+\n+      begin\n+         --  If so, mark that it has a local raise\n+\n+         if Present (H) then\n+            Set_Has_Local_Raise (H, True);\n+\n+         --  Otherwise, if the No_Exception_Propagation restriction is active\n+         --  and the warning is enabled, generate the appropriate warnings.\n+\n+         elsif Warn_On_Non_Local_Exception\n+           and then Restriction_Active (No_Exception_Propagation)\n+         then\n+            Warn_No_Exception_Propagation_Active (N);\n+\n+            if Configurable_Run_Time_Mode then\n+               Error_Msg_NE\n+                 (\"\\?& may call Last_Chance_Handler\", N, E);\n+            else\n+               Error_Msg_NE\n+                 (\"\\?& may result in unhandled exception\", N, E);\n+            end if;\n+         end if;\n+      end;\n+   end Possible_Local_Raise;\n+\n    ------------------------------\n    -- Expand_N_Subprogram_Info --\n    ------------------------------\n@@ -1543,18 +1694,27 @@ package body Exp_Ch11 is\n       H : Node_Id;\n       C : Node_Id;\n \n+      SSE : Scope_Stack_Entry renames Scope_Stack.Table (Scope_Stack.Last);\n+      --  This is used to test for wrapped actions below\n+\n       ERaise  : Entity_Id;\n       EHandle : Entity_Id;\n       --  The entity Id's for the exception we are raising and handling, using\n       --  the renamed exception if a Renamed_Entity is present.\n \n    begin\n+      --  Never any local handler if all handlers removed\n+\n+      if Debug_Flag_Dot_X then\n+         return Empty;\n+      end if;\n+\n       --  Get the exception we are raising, allowing for renaming\n \n-      ERaise := Ename;\n-      while Present (Renamed_Entity (ERaise)) loop\n-         ERaise := Renamed_Entity (ERaise);\n-      end loop;\n+      ERaise := Get_Renamed_Entity (Ename);\n+\n+      --  We need to check if the node we are looking at is contained in\n+      --\n \n       --  Loop to search up the tree\n \n@@ -1563,29 +1723,42 @@ package body Exp_Ch11 is\n          P := Parent (N);\n \n          --  If we get to the top of the tree, or to a subprogram, task, entry,\n-         --  or protected body without having found a matching handler, then\n-         --  there is no local handler.\n+         --  protected body, or accept statement without having found a\n+         --  matching handler, then there is no local handler.\n \n          if No (P)\n            or else Nkind (P) = N_Subprogram_Body\n            or else Nkind (P) = N_Task_Body\n            or else Nkind (P) = N_Protected_Body\n            or else Nkind (P) = N_Entry_Body\n+           or else Nkind (P) = N_Accept_Statement\n          then\n             return Empty;\n \n-            --  Test for handled sequence of statements, where we are in the\n-            --  statement section (the exception handlers of a handled sequence\n-            --  of statements do not cover themselves!)\n+            --  Test for handled sequence of statements with at least one\n+            --  exception handler which might be the one we are looking for.\n \n          elsif Nkind (P) = N_Handled_Sequence_Of_Statements\n-           and then Is_List_Member (N)\n-           and then List_Containing (N) = Statements (P)\n+           and then Present (Exception_Handlers (P))\n          then\n-            --  If we have exception handlers, look at them\n-\n-            if Present (Exception_Handlers (P)) then\n-\n+            --  Before we proceed we need to check if the node N is covered\n+            --  by the statement part of P rather than one of its exception\n+            --  handlers (an exception handler obviously does not cover its\n+            --  own statements).\n+\n+            --  This test is more delicate than might be thought. It is not\n+            --  just a matter of checking the Statements (P), because the node\n+            --  might be waiting to be wrapped in a transient scope, in which\n+            --  case it will end up in the block statements, even though it\n+            --  is not there now.\n+\n+            if Is_List_Member (N)\n+              and then (List_Containing (N) = Statements (P)\n+                          or else\n+                        List_Containing (N) = SSE.Actions_To_Be_Wrapped_Before\n+                          or else\n+                        List_Containing (N) = SSE.Actions_To_Be_Wrapped_After)\n+            then\n                --  Loop through exception handlers\n \n                H := First (Exception_Handlers (P));\n@@ -1619,10 +1792,7 @@ package body Exp_Ch11 is\n \n                         --  Get exception being handled, dealing with renaming\n \n-                        EHandle := Entity (C);\n-                        while Present (Renamed_Entity (EHandle)) loop\n-                           EHandle := Renamed_Entity (EHandle);\n-                        end loop;\n+                        EHandle := Get_Renamed_Entity (Entity (C));\n \n                         --  If match, then check choice parameter\n \n@@ -1651,13 +1821,28 @@ package body Exp_Ch11 is\n    -- Get_Local_Raise_Call_Entity --\n    ---------------------------------\n \n+   --  Note: this is primary provided for use by the back end in generating\n+   --  calls to Local_Raise. But it would be too late in the back end to call\n+   --  RTE if this actually caused a load/analyze of the unit. So what we do\n+   --  is to ensure there is a dummy call to this function during front end\n+   --  processing so that the unit gets loaded then, and not later.\n+\n+   Local_Raise_Call_Entity     : Entity_Id;\n+   Local_Raise_Call_Entity_Set : Boolean := False;\n+\n    function Get_Local_Raise_Call_Entity return Entity_Id is\n    begin\n-      if RTE_Available (RE_Local_Raise) then\n-         return RTE (RE_Local_Raise);\n-      else\n-         return Empty;\n+      if not Local_Raise_Call_Entity_Set then\n+         Local_Raise_Call_Entity_Set := True;\n+\n+         if RTE_Available (RE_Local_Raise) then\n+            Local_Raise_Call_Entity := RTE (RE_Local_Raise);\n+         else\n+            Local_Raise_Call_Entity := Empty;\n+         end if;\n       end if;\n+\n+      return Local_Raise_Call_Entity;\n    end Get_Local_Raise_Call_Entity;\n \n    -----------------------------\n@@ -1705,17 +1890,26 @@ package body Exp_Ch11 is\n       if Restriction_Active (No_Exception_Propagation)\n         and then Warn_On_Non_Local_Exception\n       then\n-         Error_Msg_N\n-           (\"?No_Exception_Propagation restriction is active\", N);\n+         Warn_No_Exception_Propagation_Active (N);\n \n          if Configurable_Run_Time_Mode then\n             Error_Msg_N\n-              (\"?Last_Chance_Handler will be called on exception\", N);\n+              (\"\\?Last_Chance_Handler will be called on exception\", N);\n          else\n             Error_Msg_N\n-              (\"?program may terminate with unhandled exception\", N);\n+              (\"\\?execution may raise unhandled exception\", N);\n          end if;\n       end if;\n    end Warn_If_No_Propagation;\n \n+   ------------------------------------------\n+   -- Warn_No_Exception_Propagation_Active --\n+   ------------------------------------------\n+\n+   procedure Warn_No_Exception_Propagation_Active (N : Node_Id) is\n+   begin\n+      Error_Msg_N\n+        (\"?pragma Restrictions (No_Exception_Propagation) in effect\", N);\n+   end Warn_No_Exception_Propagation_Active;\n+\n end Exp_Ch11;"}, {"sha": "f1fae83b4ee9bc6fe5ac6b74bfce21012545a00d", "filename": "gcc/ada/exp_ch11.ads", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fexp_ch11.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fexp_ch11.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.ads?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -56,6 +56,16 @@ package Exp_Ch11 is\n    --  is also called to expand the special exception handler built for\n    --  accept bodies (see Exp_Ch9.Build_Accept_Body).\n \n+   function Find_Local_Handler\n+     (Ename : Entity_Id;\n+      Nod   : Node_Id) return Node_Id;\n+   --  This function searches for a local exception handler that will handle\n+   --  the exception named by Ename. If such a local hander exists, then the\n+   --  corresponding N_Exception_Handler is returned. If no such handler is\n+   --  found then Empty is returned. In order to match and return True, the\n+   --  handler may not have a choice parameter specification. Nod is the raise\n+   --  node that references the handler.\n+\n    function Get_Local_Raise_Call_Entity return Entity_Id;\n    --  This function is provided for use by the back end in conjunction with\n    --  generation of Local_Raise calls when an exception raise is converted to\n@@ -74,4 +84,12 @@ package Exp_Ch11 is\n    --  VMS, and the argument E is the entity for System.Aux_Dec.Non_Ada_Error.\n    --  This is used to generate the special matching code for this exception.\n \n+   procedure Possible_Local_Raise (N : Node_Id; E : Entity_Id);\n+   --  This procedure is called whenever node N might cause the back end\n+   --  to generate a local raise for a local Constraint/Program/Storage_Error\n+   --  exception. It deals with generating a warning if there is no local\n+   --  handler (and restriction No_Exception_Propagation is set), or if there\n+   --  is a local handler marking that it has a local raise. E is the entity\n+   --  of the corresponding exception.\n+\n end Exp_Ch11;"}, {"sha": "7c1923951ff7cc7db40d84b0d948f486d800cfae", "filename": "gcc/ada/s-except.adb", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fs-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fs-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-except.adb?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -0,0 +1,75 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . E X C E P T I O N S                     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--         Copyright (C) 2006-2007, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Exceptions is\n+\n+   ---------------------------\n+   -- Debug_Raise_Exception --\n+   ---------------------------\n+\n+   procedure Debug_Raise_Exception (E : SSL.Exception_Data_Ptr) is\n+      pragma Inspection_Point (E);\n+   begin\n+      null;\n+   end Debug_Raise_Exception;\n+\n+   -------------------------------\n+   -- Debug_unhandled_Exception --\n+   -------------------------------\n+\n+   procedure Debug_Unhandled_Exception (E : SSL.Exception_Data_Ptr) is\n+      pragma Inspection_Point (E);\n+   begin\n+      null;\n+   end Debug_Unhandled_Exception;\n+\n+   --------------------------------\n+   -- Debug_Raise_Assert_Failure --\n+   --------------------------------\n+\n+   procedure Debug_Raise_Assert_Failure is\n+   begin\n+      null;\n+   end Debug_Raise_Assert_Failure;\n+\n+   -----------------\n+   -- Local_Raise --\n+   -----------------\n+\n+   procedure Local_Raise (Excep : System.Address) is\n+      pragma Warnings (Off, Excep);\n+   begin\n+      return;\n+   end Local_Raise;\n+\n+end System.Exceptions;"}, {"sha": "34ff065c7bfb149003a58705786e205b062d94d0", "filename": "gcc/ada/s-except.ads", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fs-except.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823/gcc%2Fada%2Fs-except.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-except.ads?ref=6c5290ce34a20a2fdb1e94e1e18e7daac9fc2823", "patch": "@@ -0,0 +1,80 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                    S Y S T E M . E X C E P T I O N S                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 2006-2007, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --\n+-- Boston, MA 02110-1301, USA.                                              --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains internal routines used as debugger helpers.\n+--  It should be compiled without optimization to let debuggers inspect\n+--  parameter values reliably from breakpoints on the routines.\n+\n+with System.Standard_Library;\n+\n+package System.Exceptions is\n+\n+   pragma Warnings (Off);\n+   pragma Preelaborate_05;\n+   pragma Warnings (On);\n+   --  To let Ada.Exceptions \"with\" us and let us \"with\" Standard_Library.\n+\n+   package SSL renames System.Standard_Library;\n+   --  To let some of the hooks below have formal parameters typed in\n+   --  accordance with what GDB expects.\n+\n+   procedure Debug_Raise_Exception (E : SSL.Exception_Data_Ptr);\n+   pragma Export\n+     (Ada, Debug_Raise_Exception, \"__gnat_debug_raise_exception\");\n+   --  Hook called at a \"raise\" point for an exception E, when it is\n+   --  just about to be propagated.\n+\n+   procedure Debug_Unhandled_Exception (E : SSL.Exception_Data_Ptr);\n+   pragma Export\n+     (Ada, Debug_Unhandled_Exception, \"__gnat_unhandled_exception\");\n+   --  Hook called during the propagation process of an exception E, as soon\n+   --  as it is known to be unhandled.\n+\n+   procedure Debug_Raise_Assert_Failure;\n+   pragma Export\n+     (Ada, Debug_Raise_Assert_Failure, \"__gnat_debug_raise_assert_failure\");\n+   --  Hook called when an assertion failed. This is used by the debugger to\n+   --  intercept assertion failures, and treat them specially.\n+\n+   procedure Local_Raise (Excep : System.Address);\n+   pragma Export (Ada, Local_Raise);\n+   --  This is a dummy routine, used only by the debugger for the purpose of\n+   --  logging local raise statements that were transformed into a direct goto\n+   --  to the handler code. The compiler in this case generates:\n+   --\n+   --    Local_Raise (exception_data'address);\n+   --    goto Handler\n+   --\n+   --  The argument is the address of the exception data\n+\n+end System.Exceptions;"}]}