{"sha": "8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA3NmMzZTNlNGUyOWNlMTgyOTliYzFlNWUzZTE1MzU5OTNlYWYxNQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-10-21T11:54:25Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-10-21T11:54:25Z"}, "message": "c6x.md (attr \"op_pattern\"): New.\n\n\t* config/c6x/c6x.md (attr \"op_pattern\"): New.\n\t(load_sdata_pic, mov<mode>_insn for QIHIM and SISFVM): Set it.\n\t* config/c6x/c6x-mult.md.in (mulhi3_VARIANT_, mulhisi3_insn_VARIANT_):\n\tLikewise.\n\t* config/c6x/c6x-mult.md: Regenerate.\n\t* config/c6x/c6x.c: Include \"regrename.h\".\n\t(unit_req_table): New typedef.\n\t(unit_reqs): Use it for the declaration.\n\t(unit_req_factor, get_unit_reqs, merge_unit_reqs, unit_req_imbalance,\n\tget_unit_operand_masks, try_rename_operands, reshuffle_units): New\n\tstatic functions.\n\t(count_unit_reqs): New arg reqs.  All callers changed.  Use\n\tget_unit_reqs, and don't merge here.\n\t(res_mii): New arg reqs.  All callers changed.  Rewrite to use a loop\n\tusing unit_req_factor.\n\t(hwloop_optimize): Call reshuffle_units.  Call merge_unit_reqs after\n\tcount_unit_reqs.\n\t(c6x_reorg): Add reg notes problem, and call df_analyze.\n\t* Makefile.in ($(out_object_file)): Depend on regrename.h.\n\nFrom-SVN: r180296", "tree": {"sha": "eee257e4cbc3182a7bd60dc290de7fe4f3cbea3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eee257e4cbc3182a7bd60dc290de7fe4f3cbea3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/comments", "author": null, "committer": null, "parents": [{"sha": "bb35fdd04a97dc08eb7cc391dfcf0bbe2a90501a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb35fdd04a97dc08eb7cc391dfcf0bbe2a90501a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb35fdd04a97dc08eb7cc391dfcf0bbe2a90501a"}], "stats": {"total": 307, "additions": 305, "deletions": 2}, "files": [{"sha": "6b8be05dae24943a441d52883688264ba0496b8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -1,3 +1,25 @@\n+2011-10-21  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* config/c6x/c6x.md (attr \"op_pattern\"): New.\n+\t(load_sdata_pic, mov<mode>_insn for QIHIM and SISFVM): Set it.\n+\t* config/c6x/c6x-mult.md.in (mulhi3_VARIANT_, mulhisi3_insn_VARIANT_):\n+\tLikewise.\n+\t* config/c6x/c6x-mult.md: Regenerate.\n+\t* config/c6x/c6x.c: Include \"regrename.h\".\n+\t(unit_req_table): New typedef.\n+\t(unit_reqs): Use it for the declaration.\n+\t(unit_req_factor, get_unit_reqs, merge_unit_reqs, unit_req_imbalance,\n+\tget_unit_operand_masks, try_rename_operands, reshuffle_units): New\n+\tstatic functions.\n+\t(count_unit_reqs): New arg reqs.  All callers changed.  Use\n+\tget_unit_reqs, and don't merge here.\n+\t(res_mii): New arg reqs.  All callers changed.  Rewrite to use a loop\n+\tusing unit_req_factor.\n+\t(hwloop_optimize): Call reshuffle_units.  Call merge_unit_reqs after\n+\tcount_unit_reqs.\n+\t(c6x_reorg): Add reg notes problem, and call df_analyze.\n+\t* Makefile.in ($(out_object_file)): Depend on regrename.h.\n+\n 2011-10-21  Kai Tietz  <ktietz@redhat.com>\n \n \t* fold-const.c (simple_operand_p_2): Handle integral"}, {"sha": "36089041763e9d49202b2814d64bf8fdd851ec37", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -3537,7 +3537,8 @@ $(out_object_file): $(out_file) $(CONFIG_H) coretypes.h $(TM_H) $(TREE_H) \\\n    output.h $(INSN_ATTR_H) $(SYSTEM_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n    $(TARGET_H) $(LIBFUNCS_H) $(TARGET_DEF_H) $(FUNCTION_H) $(SCHED_INT_H) \\\n    $(TM_P_H) $(EXPR_H) langhooks.h $(GGC_H) $(OPTABS_H) $(REAL_H) \\\n-   tm-constrs.h $(GIMPLE_H) $(DF_H) cselib.h $(COMMON_TARGET_H) hw-doloop.h\n+   tm-constrs.h $(GIMPLE_H) $(DF_H) cselib.h $(COMMON_TARGET_H) hw-doloop.h \\\n+   regrename.h\n \t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n \t\t$(out_file) $(OUTPUT_OPTION)\n "}, {"sha": "7cf66f1ff4df465e13aeb3ab763d2874fcd5644c", "filename": "gcc/config/c6x/c6x-mult.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -81,6 +81,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%2, %1, %0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"sxs\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_const\"\n@@ -104,6 +105,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%1, %2, %0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"ssx\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_lh\"\n@@ -500,6 +502,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%2, %1, %k0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"sxs\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_const_real\"\n@@ -523,6 +526,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%1, %2, %k0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"ssx\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_lh_real\""}, {"sha": "e9a1dc4a40ef5921352fde05af5408f2ace585b2", "filename": "gcc/config/c6x/c6x-mult.md.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x-mult.md.in?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -79,6 +79,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%2, %1, %_MODk_0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"sxs\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_const_VARIANT_\"\n@@ -102,6 +103,7 @@\n   \"%|%.\\\\tmpy\\\\t%$\\\\t%1, %2, %_MODk_0\"\n   [(set_attr \"type\" \"mpy2\")\n    (set_attr \"units\" \"m\")\n+   (set_attr \"op_pattern\" \"ssx\")\n    (set_attr \"cross\" \"n,n,y,y\")])\n \n (define_insn \"mulhisi3_lh_VARIANT_\""}, {"sha": "77564a5b73ae3bb29826a21dbd30317e6858c431", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -51,6 +51,7 @@\n #include \"debug.h\"\n #include \"opts.h\"\n #include \"hw-doloop.h\"\n+#include \"regrename.h\"\n \n /* Table of supported architecture variants.  */\n typedef struct\n@@ -3312,6 +3313,25 @@ merge_unit_reqs (unit_req_table reqs)\n     }\n }\n \n+/* Examine the table REQS and return a measure of unit imbalance by comparing\n+   the two sides of the machine.  If, for example, D1 is used twice and D2\n+   used not at all, the return value should be 1 in the absence of other\n+   imbalances.  */\n+static int\n+unit_req_imbalance (unit_req_table reqs)\n+{\n+  int val = 0;\n+  int i;\n+\n+  for (i = 0; i < UNIT_REQ_MAX; i++)\n+    {\n+      int factor = unit_req_factor (i);\n+      int diff = abs (reqs[0][i] - reqs[1][i]);\n+      val += (diff + factor - 1) / factor / 2;\n+    }\n+  return val;\n+}\n+\n /* Return the resource-constrained minimum iteration interval given the\n    data in the REQS table.  This must have been processed with\n    merge_unit_reqs already.  */\n@@ -3329,6 +3349,241 @@ res_mii (unit_req_table reqs)\n \n   return worst;\n }\n+\n+/* Examine INSN, and store in PMASK1 and PMASK2 bitmasks that represent\n+   the operands that are involved in the (up to) two reservations, as\n+   found by get_unit_reqs.  Return true if we did this successfully, false\n+   if we couldn't identify what to do with INSN.  */\n+static bool\n+get_unit_operand_masks (rtx insn, unsigned int *pmask1, unsigned int *pmask2)\n+{\n+  enum attr_units units;\n+  enum attr_type type;\n+  enum attr_op_pattern op_pat;\n+\n+  if (recog_memoized (insn) < 0)\n+    return 0;\n+  if (GET_CODE (PATTERN (insn)) == COND_EXEC)\n+    return false;\n+  extract_insn (insn);\n+  op_pat = get_attr_op_pattern (insn);\n+  if (op_pat == OP_PATTERN_DT)\n+    {\n+      gcc_assert (recog_data.n_operands == 2);\n+      *pmask1 = 1 << 0;\n+      *pmask2 = 1 << 1;\n+      return true;\n+    }\n+  else if (op_pat == OP_PATTERN_TD)\n+    {\n+      gcc_assert (recog_data.n_operands == 2);\n+      *pmask1 = 1 << 1;\n+      *pmask2 = 1 << 0;\n+      return true;\n+    }\n+  else if (op_pat == OP_PATTERN_SXS)\n+    {\n+      gcc_assert (recog_data.n_operands == 3);\n+      *pmask1 = (1 << 0) | (1 << 2);\n+      *pmask2 = 1 << 1;\n+      return true;\n+    }\n+  else if (op_pat == OP_PATTERN_SX)\n+    {\n+      gcc_assert (recog_data.n_operands == 2);\n+      *pmask1 = 1 << 0;\n+      *pmask2 = 1 << 1;\n+      return true;\n+    }\n+  else if (op_pat == OP_PATTERN_SSX)\n+    {\n+      gcc_assert (recog_data.n_operands == 3);\n+      *pmask1 = (1 << 0) | (1 << 1);\n+      *pmask2 = 1 << 2;\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Try to replace a register in INSN, which has corresponding rename info\n+   from regrename_analyze in INFO.  OP_MASK and ORIG_SIDE provide information\n+   about the operands that must be renamed and the side they are on.\n+   REQS is the table of unit reservations in the loop between HEAD and TAIL.\n+   We recompute this information locally after our transformation, and keep\n+   it only if we managed to improve the balance.  */\n+static void\n+try_rename_operands (rtx head, rtx tail, unit_req_table reqs, rtx insn,\n+\t\t     insn_rr_info *info, unsigned int op_mask, int orig_side)\n+{\n+  enum reg_class super_class = orig_side == 0 ? B_REGS : A_REGS;\n+  HARD_REG_SET unavailable;\n+  unit_req_table new_unit_reqs;\n+  du_head_p this_head;\n+  struct du_chain *chain;\n+  int i;\n+  unsigned tmp_mask;\n+  int best_reg, old_reg;\n+  VEC (du_head_p, heap) *involved_chains = NULL;\n+  unit_req_table new_reqs;\n+\n+  for (i = 0, tmp_mask = op_mask; tmp_mask; i++)\n+    {\n+      du_head_p op_chain;\n+      if ((tmp_mask & (1 << i)) == 0)\n+\tcontinue;\n+      if (info->op_info[i].n_chains != 1)\n+\tgoto out_fail;\n+      op_chain = regrename_chain_from_id (info->op_info[i].heads[0]->id);\n+      VEC_safe_push (du_head_p, heap, involved_chains, op_chain);\n+      tmp_mask &= ~(1 << i);\n+    }\n+\n+  if (VEC_length (du_head_p, involved_chains) > 1)\n+    goto out_fail;\n+\n+  this_head = VEC_index (du_head_p, involved_chains, 0);\n+  if (this_head->cannot_rename)\n+    goto out_fail;\n+\n+  for (chain = this_head->first; chain; chain = chain->next_use)\n+    {\n+      unsigned int mask1, mask2, mask_changed;\n+      int count, side1, side2, req1, req2;\n+      insn_rr_info *this_rr = VEC_index (insn_rr_info, insn_rr,\n+\t\t\t\t\t INSN_UID (chain->insn));\n+\n+      count = get_unit_reqs (chain->insn, &req1, &side1, &req2, &side2);\n+\n+      if (count == 0)\n+\tgoto out_fail;\n+\n+      if (!get_unit_operand_masks (chain->insn, &mask1, &mask2))\n+\tgoto out_fail;\n+\n+      extract_insn (chain->insn);\n+\n+      mask_changed = 0;\n+      for (i = 0; i < recog_data.n_operands; i++)\n+\t{\n+\t  int j;\n+\t  int n_this_op = this_rr->op_info[i].n_chains;\n+\t  for (j = 0; j < n_this_op; j++)\n+\t    {\n+\t      du_head_p other = this_rr->op_info[i].heads[j];\n+\t      if (regrename_chain_from_id (other->id) == this_head)\n+\t\tbreak;\n+\t    }\n+\t  if (j == n_this_op)\n+\t    continue;\n+\n+\t  if (n_this_op != 1)\n+\t    goto out_fail;\n+\t  mask_changed |= 1 << i;\n+\t}\n+      gcc_assert (mask_changed != 0);\n+      if (mask_changed != mask1 && mask_changed != mask2)\n+\tgoto out_fail;\n+    }\n+\n+  /* If we get here, we can do the renaming.  */\n+  COMPL_HARD_REG_SET (unavailable, reg_class_contents[(int) super_class]);\n+\n+  old_reg = this_head->regno;\n+  best_reg = find_best_rename_reg (this_head, super_class, &unavailable, old_reg);\n+\n+  regrename_do_replace (this_head, best_reg);\n+\n+  count_unit_reqs (new_reqs, head, PREV_INSN (tail));\n+  merge_unit_reqs (new_reqs);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"reshuffle for insn %d, op_mask %x, \"\n+\t       \"original side %d, new reg %d\\n\",\n+\t       INSN_UID (insn), op_mask, orig_side, best_reg);\n+      fprintf (dump_file, \"  imbalance %d -> %d\\n\",\n+\t       unit_req_imbalance (reqs), unit_req_imbalance (new_reqs));\n+    }\n+  if (unit_req_imbalance (new_reqs) > unit_req_imbalance (reqs))\n+    regrename_do_replace (this_head, old_reg);\n+  else\n+    memcpy (reqs, new_reqs, sizeof (unit_req_table));\n+\n+ out_fail:\n+  VEC_free (du_head_p, heap, involved_chains);\n+}\n+\n+/* Find insns in LOOP which would, if shifted to the other side\n+   of the machine, reduce an imbalance in the unit reservations.  */\n+static void\n+reshuffle_units (basic_block loop)\n+{\n+  rtx head = BB_HEAD (loop);\n+  rtx tail = BB_END (loop);\n+  rtx insn;\n+  int side;\n+  unit_req_table reqs;\n+  edge e;\n+  edge_iterator ei;\n+  basic_block first = NULL;\n+  bitmap_head bbs;\n+\n+  count_unit_reqs (reqs, head, PREV_INSN (tail));\n+  merge_unit_reqs (reqs);\n+\n+  regrename_init (true);\n+\n+  bitmap_initialize (&bbs, &bitmap_default_obstack);\n+\n+  FOR_EACH_EDGE (e, ei, loop->preds)\n+    {\n+      bitmap_set_bit (&bbs, e->src->index);\n+      first = e->src;\n+    }\n+  bitmap_set_bit (&bbs, loop->index);\n+  regrename_analyze (&bbs);\n+\n+  for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n+    {\n+      enum attr_units units;\n+      enum attr_cross cross;\n+      int count, side1, side2, req1, req2;\n+      unsigned int mask1, mask2;\n+      insn_rr_info *info;\n+\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      count = get_unit_reqs (insn, &req1, &side1, &req2, &side2);\n+\n+      if (count == 0)\n+\tcontinue;\n+\n+      if (!get_unit_operand_masks (insn, &mask1, &mask2))\n+\tcontinue;\n+\n+      info = VEC_index (insn_rr_info, insn_rr, INSN_UID (insn));\n+      if (info->op_info == NULL)\n+\tcontinue;\n+\n+      if (reqs[side1][req1] > 1\n+\t  && reqs[side1][req1] > 2 * reqs[side1 ^ 1][req1])\n+\t{\n+\t  try_rename_operands (head, tail, reqs, insn, info, mask1, side1);\n+\t}\n+\n+      units = get_attr_units (insn);\n+      if (units == UNITS_D_ADDR)\n+\t{\n+\t  gcc_assert (count == 2);\n+\t  if (reqs[side2][req2] > 1\n+\t      && reqs[side2][req2] > 2 * reqs[side2 ^ 1][req2])\n+\t    {\n+\t      try_rename_operands (head, tail, reqs, insn, info, mask2, side2);\n+\t    }\n+\t}\n+    }\n+  regrename_finish ();\n+}\n \f\n /* Backend scheduling state.  */\n typedef struct c6x_sched_context\n@@ -5263,6 +5518,8 @@ hwloop_optimize (hwloop_info loop)\n   if (entry_edge == NULL)\n     return false;\n \n+  reshuffle_units (loop->head);\n+\n   schedule_ebbs_init ();\n   schedule_ebb (BB_HEAD (loop->tail), loop->loop_end, true);\n   schedule_ebbs_finish ();\n@@ -5632,11 +5889,14 @@ c6x_reorg (void)\n   compute_bb_for_insn ();\n \n   df_clear_flags (DF_LR_RUN_DCE);\n+  df_note_add_problem ();\n \n   /* If optimizing, we'll have split before scheduling.  */\n   if (optimize == 0)\n     split_all_insns ();\n \n+  df_analyze ();\n+\n   if (c6x_flag_schedule_insns2)\n     {\n       int sz = get_max_uid () * 3 / 2 + 1;"}, {"sha": "ec3d04e90ac6c6b3f6453e137c042996b5042228", "filename": "gcc/config/c6x/c6x.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8076c3e3e4e29ce18299bc1e5e3e1535993eaf15/gcc%2Fconfig%2Fc6x%2Fc6x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.md?ref=8076c3e3e4e29ce18299bc1e5e3e1535993eaf15", "patch": "@@ -166,6 +166,17 @@\n   \"n,y\"\n   (const_string \"n\"))\n \n+;; This describes the relationship between operands and register files.\n+;; For example, \"sxs\" means that operands 0 and 2 determine the side of\n+;; the machine, and operand 1 can optionally use the cross path.  \"dt\" and\n+;; \"td\" are used to describe loads and stores.\n+;; Used for register renaming in loops for improving modulo scheduling.\n+(define_attr \"op_pattern\"\n+  \"unknown,dt,td,sx,sxs,ssx\"\n+  (cond [(eq_attr \"type\" \"load\") (const_string \"td\")\n+\t (eq_attr \"type\" \"store\") (const_string \"dt\")]\n+\t(const_string \"unknown\")))\n+\n (define_attr \"has_shadow\"\n   \"n,y\"\n   (const_string \"n\"))\n@@ -567,6 +578,7 @@\n    %|%.\\\\tadda%D2\\\\t%$\\\\t%1, %2, %0\"\n   [(set_attr \"units\" \"d\")\n    (set_attr \"cross\" \"y,n\")\n+   (set_attr \"op_pattern\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n ;; Move instruction patterns\n@@ -599,6 +611,7 @@\n   [(set_attr \"type\" \"*,*,*,*,*,*,load,load,load,load,store,store,store,store\")\n    (set_attr \"units62\" \"dls,dls,ls,ls,s,s,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr\")\n    (set_attr \"units64\" \"dls,dls,ls,ls,dl,s,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr\")\n+   (set_attr \"op_pattern\" \"sx,sx,sx,sx,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"addr_regfile\" \"*,*,*,*,*,*,a,b,b,a,a,b,b,a\")\n    (set_attr \"dest_regfile\" \"*,*,*,*,*,*,a,a,b,b,a,a,b,b\")\n    (set_attr \"cross\" \"n,n,y,y,n,n,n,y,n,y,n,y,n,y\")])\n@@ -631,6 +644,7 @@\n   [(set_attr \"type\" \"*,*,*,*,*,*,*,*,*,load,load,load,load,store,store,store,store\")\n    (set_attr \"units62\" \"dls,dls,ls,ls,s,s,d,d,*,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr\")\n    (set_attr \"units64\" \"dls,dls,ls,ls,dl,s,d,d,*,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr,d_addr\")\n+   (set_attr \"op_pattern\" \"sx,sx,sx,sx,*,*,*,*,*,*,*,*,*,*,*,*,*\")\n    (set_attr \"addr_regfile\" \"*,*,*,*,*,*,*,*,*,a,b,b,a,a,b,b,a\")\n    (set_attr \"dest_regfile\" \"*,*,*,*,*,*,*,*,*,a,a,b,b,a,a,b,b\")\n    (set_attr \"cross\" \"n,n,y,y,n,n,y,n,*,n,y,n,y,n,y,n,y\")\n@@ -855,7 +869,7 @@\n \n (define_insn \"<ext_name><mode>si2\"\n  [(set (match_operand:SI 0 \"register_operand\" \"=a,b,a,?a, b,?b\")\n-       (any_ext: SI (match_operand:QIHIM 1 \"nonimmediate_operand\" \"a,b,Q, R, R, Q\")))]\n+       (any_ext:SI (match_operand:QIHIM 1 \"nonimmediate_operand\" \"a,b,Q, R, R, Q\")))]\n   \"\"\n  \"@\n   %|%.\\\\text<u>\\\\t%$\\\\t%1, <ext_shift>, <ext_shift>, %0"}]}