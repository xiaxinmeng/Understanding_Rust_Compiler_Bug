{"sha": "2711355fbc306e7e0f59b3247943614eba4a382b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcxMTM1NWZiYzMwNmU3ZTBmNTliMzI0Nzk0MzYxNGViYTRhMzgyYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2007-03-01T22:14:23Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-03-01T22:14:23Z"}, "message": "tree-ssa-loop-prefetch.c (determine_unroll_factor): Bound the unroll factor by the estimated number of iterations.\n\n\t* tree-ssa-loop-prefetch.c (determine_unroll_factor):  Bound the unroll\n\tfactor by the estimated number of iterations.\n\t(loop_prefetch_arrays): Do not prefetch in loops that iterate less than\n\tprefetch latency.\n\n\t* gcc.dg/tree-ssa/prefetch-4.c: New test.\n\nFrom-SVN: r122435", "tree": {"sha": "f3de9780dd3d10e6cc5dc11481279c3c93f62677", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3de9780dd3d10e6cc5dc11481279c3c93f62677"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2711355fbc306e7e0f59b3247943614eba4a382b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2711355fbc306e7e0f59b3247943614eba4a382b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2711355fbc306e7e0f59b3247943614eba4a382b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2711355fbc306e7e0f59b3247943614eba4a382b/comments", "author": null, "committer": null, "parents": [{"sha": "41dc91a89030fbf30192a18e542dceb3bb9dc28b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41dc91a89030fbf30192a18e542dceb3bb9dc28b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41dc91a89030fbf30192a18e542dceb3bb9dc28b"}], "stats": {"total": 210, "additions": 192, "deletions": 18}, "files": [{"sha": "9c75bc251ed324026b2593a392b845336089b1e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2711355fbc306e7e0f59b3247943614eba4a382b", "patch": "@@ -1,3 +1,10 @@\n+2007-03-01  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-prefetch.c (determine_unroll_factor):  Bound the unroll\n+\tfactor by the estimated number of iterations.\n+\t(loop_prefetch_arrays): Do not prefetch in loops that iterate less than\n+\tprefetch latency.\n+\n 2007-03-01  Richard Henderson  <rth@redhat.com>\n \n \t* expr.c (emit_move_complex_push): Export."}, {"sha": "3a5d29de30df113518c2d513596bb1667bdee060", "filename": "gcc/config/i386/driver-i386.c", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Fconfig%2Fi386%2Fdriver-i386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fdriver-i386.c?ref=2711355fbc306e7e0f59b3247943614eba4a382b", "patch": "@@ -47,6 +47,131 @@ const char *host_detect_local_cpu (int argc, const char **argv);\n #define bit_3DNOWP (1 << 30)\n #define bit_LM (1 << 29)\n \n+/* Returns parameters that describe L1_ASSOC associative cache of size\n+   L1_SIZEKB with lines of size L1_LINE.  */\n+\n+static char *\n+describe_cache (unsigned l1_sizekb, unsigned l1_line,\n+\t\tunsigned l1_assoc ATTRIBUTE_UNUSED)\n+{\n+  char size[1000], line[1000];\n+  unsigned size_in_lines;\n+\n+  /* At the moment, gcc middle-end does not use the information about the\n+     associativity of the cache.  */\n+\n+  size_in_lines = (l1_sizekb * 1024) / l1_line;\n+\n+  sprintf (size, \"--param l1-cache-size=%u\", size_in_lines);\n+  sprintf (line, \"--param l1-cache-line-size=%u\", l1_line);\n+\n+  return concat (size, \" \", line, \" \", NULL);\n+}\n+\n+/* Returns the description of caches for an AMD processor.  */\n+\n+static char *\n+detect_caches_amd (unsigned max_ext_level)\n+{\n+  unsigned eax, ebx, ecx, edx;\n+  unsigned l1_sizekb, l1_line, l1_assoc;\n+\n+  if (max_ext_level < 0x80000005)\n+    return NULL;\n+\n+  cpuid (0x80000005, eax, ebx, ecx, edx);\n+\n+  l1_line = ecx & 0xff;\n+  l1_sizekb = (ecx >> 24) & 0xff;\n+  l1_assoc = (ecx >> 16) & 0xff;\n+\n+  return describe_cache (l1_sizekb, l1_line, l1_assoc);\n+}\n+\n+/* Stores the size of the L1 cache and cache line, and the associativity\n+   of the cache according to REG to L1_SIZEKB, L1_LINE and L1_ASSOC.  */\n+\n+static void\n+decode_caches_intel (unsigned reg, unsigned *l1_sizekb, unsigned *l1_line,\n+\t\t     unsigned *l1_assoc)\n+{\n+  unsigned i, val;\n+\n+  if (((reg >> 31) & 1) != 0)\n+    return;\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      val = reg & 0xff;\n+      reg >>= 8;\n+\n+      switch (val)\n+\t{\n+\tcase 0xa:\n+\t  *l1_sizekb = 8;\n+\t  *l1_line = 32;\n+\t  *l1_assoc = 2;\n+\t  break;\n+\tcase 0xc:\n+\t  *l1_sizekb = 16;\n+\t  *l1_line = 32;\n+\t  *l1_assoc = 4;\n+\t  break;\n+\tcase 0x2c:\n+\t  *l1_sizekb = 32;\n+\t  *l1_line = 64;\n+\t  *l1_assoc = 8;\n+\t  break;\n+\tcase 0x60:\n+\t  *l1_sizekb = 16;\n+\t  *l1_line = 64;\n+\t  *l1_assoc = 8;\n+\t  break;\n+\tcase 0x66:\n+\t  *l1_sizekb = 8;\n+\t  *l1_line = 64;\n+\t  *l1_assoc = 4;\n+\t  break;\n+\tcase 0x67:\n+\t  *l1_sizekb = 16;\n+\t  *l1_line = 64;\n+\t  *l1_assoc = 4;\n+\t  break;\n+\tcase 0x68:\n+\t  *l1_sizekb = 32;\n+\t  *l1_line = 64;\n+\t  *l1_assoc = 4;\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Returns the description of caches for an intel processor.  */\n+\n+static char *\n+detect_caches_intel (unsigned max_level)\n+{\n+  unsigned eax, ebx, ecx, edx;\n+  unsigned l1_sizekb = 0, l1_line = 0, assoc = 0;\n+\n+  if (max_level < 2)\n+    return NULL;\n+\n+  cpuid (2, eax, ebx, ecx, edx);\n+\n+  decode_caches_intel (eax, &l1_sizekb, &l1_line, &assoc);\n+  decode_caches_intel (ebx, &l1_sizekb, &l1_line, &assoc);\n+  decode_caches_intel (ecx, &l1_sizekb, &l1_line, &assoc);\n+  decode_caches_intel (edx, &l1_sizekb, &l1_line, &assoc);\n+  if (!l1_sizekb)\n+    return (char *) \"\";\n+\n+  return describe_cache (l1_sizekb, l1_line, assoc);\n+}\n+\n /* This will be called by the spec parser in gcc.c when it sees\n    a %:local_cpu_detect(args) construct.  Currently it will be called\n    with either \"arch\" or \"tune\" as argument depending on if -march=native\n@@ -62,6 +187,7 @@ const char *host_detect_local_cpu (int argc, const char **argv);\n const char *host_detect_local_cpu (int argc, const char **argv)\n {\n   const char *cpu = NULL;\n+  const char *cache = \"\";\n   enum processor_type processor = PROCESSOR_I386;\n   unsigned int eax, ebx, ecx, edx;\n   unsigned int max_level;\n@@ -126,6 +252,14 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n \n   is_amd = vendor == *(unsigned int*)\"Auth\";\n \n+  if (!arch)\n+    {\n+      if (is_amd)\n+\tcache = detect_caches_amd (ext_level);\n+      else if (vendor == *(unsigned int*)\"Genu\")\n+\tcache = detect_caches_intel (max_level);\n+    }\n+\n   if (is_amd)\n     {\n       if (has_mmx)\n@@ -283,7 +417,7 @@ const char *host_detect_local_cpu (int argc, const char **argv)\n     }\n \n done:\n-  return concat (\"-m\", argv[0], \"=\", cpu, NULL);\n+  return concat (cache, \"-m\", argv[0], \"=\", cpu, NULL);\n }\n #else\n /* If we aren't compiling with GCC we just provide a minimal"}, {"sha": "e2cf6d9f96bddef2a5c665d77b8e301d1762af93", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2711355fbc306e7e0f59b3247943614eba4a382b", "patch": "@@ -1,3 +1,7 @@\n+2007-03-01  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/prefetch-4.c: New test.\n+\n 2007-03-01  Simon Baldwin <simonb@google.com>\n \n \tPR c++/23689"}, {"sha": "8a5230eedd3471d3752ecc0d91ec4956004d86fd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/prefetch-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fprefetch-4.c?ref=2711355fbc306e7e0f59b3247943614eba4a382b", "patch": "@@ -0,0 +1,18 @@\n+/* The loop rolls too little, hence the prefetching would not be useful.  */\n+\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-options \"-O2 -fprefetch-loop-arrays -march=athlon -fdump-tree-final_cleanup\" } */\n+\n+int xxx[20];\n+\n+void foo (int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    xxx[i] = i;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"prefetch\" 0 \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "53977d8bddd55b0b1f51191e2fa304eb46631068", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2711355fbc306e7e0f59b3247943614eba4a382b/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=2711355fbc306e7e0f59b3247943614eba4a382b", "patch": "@@ -885,13 +885,14 @@ should_unroll_loop_p (struct loop *loop, struct tree_niter_desc *desc,\n \n /* Determine the coefficient by that unroll LOOP, from the information\n    contained in the list of memory references REFS.  Description of\n-   umber of iterations of LOOP is stored to DESC.  AHEAD is the number\n-   of iterations ahead that we need to prefetch.  NINSNS is number of\n-   insns of the LOOP.  */\n+   umber of iterations of LOOP is stored to DESC.  NINSNS is the number of\n+   insns of the LOOP.  EST_NITER is the estimated number of iterations of\n+   the loop, or -1 if no estimate is available.  */\n \n static unsigned\n determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n-\t\t\t unsigned ninsns, struct tree_niter_desc *desc)\n+\t\t\t unsigned ninsns, struct tree_niter_desc *desc,\n+\t\t\t HOST_WIDE_INT est_niter)\n {\n   unsigned upper_bound;\n   unsigned nfactor, factor, mod_constraint;\n@@ -906,6 +907,12 @@ determine_unroll_factor (struct loop *loop, struct mem_ref_group *refs,\n      gains from better scheduling and decreasing loop overhead, which is not\n      the case here.  */\n   upper_bound = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / ninsns;\n+\n+  /* If we unrolled the loop more times than it iterates, the unrolled version\n+     of the loop would be never entered.  */\n+  if (est_niter >= 0 && est_niter < (HOST_WIDE_INT) upper_bound)\n+    upper_bound = est_niter;\n+\n   if (upper_bound <= 1)\n     return 1;\n \n@@ -935,7 +942,8 @@ static bool\n loop_prefetch_arrays (struct loop *loop)\n {\n   struct mem_ref_group *refs;\n-  unsigned ahead, ninsns, unroll_factor;\n+  unsigned ahead, ninsns, time, unroll_factor;\n+  HOST_WIDE_INT est_niter;\n   struct tree_niter_desc desc;\n   bool unrolled = false;\n \n@@ -950,21 +958,24 @@ loop_prefetch_arrays (struct loop *loop)\n \n   /* Step 3: determine the ahead and unroll factor.  */\n \n-  /* FIXME: We should use not size of the loop, but the average number of\n-     instructions executed per iteration of the loop.  */\n-  ninsns = tree_num_loop_insns (loop, &eni_time_weights);\n-  ahead = (PREFETCH_LATENCY + ninsns - 1) / ninsns;\n-  unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc);\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Ahead %d, unroll factor %d\\n\", ahead, unroll_factor);\n+  /* FIXME: the time should be weighted by the probabilities of the blocks in\n+     the loop body.  */\n+  time = tree_num_loop_insns (loop, &eni_time_weights);\n+  ahead = (PREFETCH_LATENCY + time - 1) / time;\n+  est_niter = estimated_loop_iterations_int (loop, false);\n \n-  /* If the loop rolls less than the required unroll factor, prefetching\n-     is useless.  */\n-  if (unroll_factor > 1\n-      && cst_and_fits_in_hwi (desc.niter)\n-      && (unsigned HOST_WIDE_INT) int_cst_value (desc.niter) < unroll_factor)\n+  /* The prefetches will run for AHEAD iterations of the original loop.  Unless\n+     the loop rolls at least AHEAD times, prefetching the references does not\n+     make sense.  */\n+  if (est_niter >= 0 && est_niter <= (HOST_WIDE_INT) ahead)\n     goto fail;\n \n+  ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n+  unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc,\n+\t\t\t\t\t   est_niter);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Ahead %d, unroll factor %d\\n\", ahead, unroll_factor);\n+\n   /* Step 4: what to prefetch?  */\n   if (!schedule_prefetches (refs, unroll_factor, ahead))\n     goto fail;"}]}