{"sha": "4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJmYzUyMWM5ZWVhZGFhYzAyODcwYzQxOWZhZDliYTY3ZGEwZmYzYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-23T21:13:57Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-23T21:13:57Z"}, "message": "Send on a closed channel panics.\n\nCalling close on a closed channel panics.\nDon't limit number of receives on a closed channel.\n\nFrom-SVN: r171364", "tree": {"sha": "4d857e22ad7943fcdeeebd79414e85dc2eb195ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d857e22ad7943fcdeeebd79414e85dc2eb195ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/comments", "author": null, "committer": null, "parents": [{"sha": "4573f2cb64ad73945718526e29ead98eaf93de03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4573f2cb64ad73945718526e29ead98eaf93de03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4573f2cb64ad73945718526e29ead98eaf93de03"}], "stats": {"total": 130, "additions": 49, "deletions": 81}, "files": [{"sha": "9877b12a98ce04e1f481453d0809f356fa8afae4", "filename": "gcc/testsuite/go.test/test/chan/select3.go", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fchan%2Fselect3.go?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -97,13 +97,9 @@ func main() {\n \t\t}\n \t})\n \n-\t// sending (a small number of times) to a closed channel is not specified\n-\t// but the current implementation doesn't block: test that different\n-\t// implementations behave the same\n-\ttestBlock(never, func() {\n-\t\tfor i := 0; i < 10; i++ {\n-\t\t\tclosedch <- 7\n-\t\t}\n+\t// sending to a closed channel panics.\n+\ttestPanic(always, func() {\n+\t\tclosedch <- 7\n \t})\n \n \t// receiving from a non-ready channel always blocks\n@@ -189,13 +185,13 @@ func main() {\n \t\t}\n \t})\n \n-\t// selects with closed channels don't block\n+\t// selects with closed channels behave like ordinary operations\n \ttestBlock(never, func() {\n \t\tselect {\n \t\tcase <-closedch:\n \t\t}\n \t})\n-\ttestBlock(never, func() {\n+\ttestPanic(always, func() {\n \t\tselect {\n \t\tcase closedch <- 7:\n \t\t}"}, {"sha": "8126d5a4e4c71ade746f8e836d7f25451cf19d73", "filename": "gcc/testsuite/go.test/test/closedchan.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.test%2Ftest%2Fclosedchan.go?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -100,6 +100,15 @@ func (c SChan) Impl() string {\n \treturn \"(select)\"\n }\n \n+func shouldPanic(f func()) {\n+\tdefer func() {\n+\t\tif recover() == nil {\n+\t\t\tpanic(\"did not panic\")\n+\t\t}\n+\t}()\n+\tf()\n+}\n+\n func test1(c Chan) {\n \t// not closed until the close signal (a zero value) has been received.\n \tif c.Closed() {\n@@ -128,18 +137,15 @@ func test1(c Chan) {\n \t}\n \n \t// send should work with ,ok too: sent a value without blocking, so ok == true.\n-\tok := c.Nbsend(1)\n-\tif !ok {\n-\t\tprintln(\"test1: send on closed got not ok\", c.Impl())\n-\t}\n+\tshouldPanic(func(){c.Nbsend(1)})\n \n-\t// but the value should have been discarded.\n+\t// the value should have been discarded.\n \tif x := c.Recv(); x != 0 {\n \t\tprintln(\"test1: recv on closed got non-zero after send on closed:\", x, c.Impl())\n \t}\n \n \t// similarly Send.\n-\tc.Send(2)\n+\tshouldPanic(func(){c.Send(2)})\n \tif x := c.Recv(); x != 0 {\n \t\tprintln(\"test1: recv on closed got non-zero after send on closed:\", x, c.Impl())\n \t}"}, {"sha": "5d2f49f1ee830594cb654687a504d3394f070a9e", "filename": "libgo/runtime/channel.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fchannel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fchannel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchannel.h?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -36,8 +36,6 @@ struct __go_channel\n   pthread_cond_t cond;\n   /* The size of elements on this channel.  */\n   size_t element_size;\n-  /* Number of operations on closed channel.  */\n-  unsigned short closed_op_count;\n   /* True if a goroutine is waiting to send on a synchronous\n      channel.  */\n   _Bool waiting_to_send;\n@@ -84,22 +82,15 @@ struct __go_channel\n    acquired while this mutex is held.  */\n extern pthread_mutex_t __go_select_data_mutex;\n \n-/* Maximum permitted number of operations on a closed channel.  */\n-#define MAX_CLOSED_OPERATIONS (0x100)\n-\n extern struct __go_channel *__go_new_channel (size_t, size_t);\n \n extern _Bool __go_synch_with_select (struct __go_channel *, _Bool);\n \n extern void __go_broadcast_to_select (struct __go_channel *);\n \n-extern _Bool __go_send_acquire (struct __go_channel *, _Bool);\n-\n-#define SEND_NONBLOCKING_ACQUIRE_SPACE 0\n-#define SEND_NONBLOCKING_ACQUIRE_NOSPACE 1\n-#define SEND_NONBLOCKING_ACQUIRE_CLOSED 2\n+extern void __go_send_acquire (struct __go_channel *, _Bool);\n \n-extern int __go_send_nonblocking_acquire (struct __go_channel *);\n+extern _Bool __go_send_nonblocking_acquire (struct __go_channel *);\n \n extern void __go_send_release (struct __go_channel *);\n "}, {"sha": "44533ebe4c7ff96439d80b97d5a0fcb3b6e6acaf", "filename": "libgo/runtime/go-close.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-close.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-close.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-close.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -5,6 +5,7 @@\n    license that can be found in the LICENSE file.  */\n \n #include \"go-assert.h\"\n+#include \"go-panic.h\"\n #include \"channel.h\"\n \n /* Close a channel.  After a channel is closed, sends are no longer\n@@ -24,6 +25,13 @@ __go_builtin_close (struct __go_channel *channel)\n       __go_assert (i == 0);\n     }\n \n+  if (channel->is_closed)\n+    {\n+      i = pthread_mutex_unlock (&channel->lock);\n+      __go_assert (i == 0);\n+      __go_panic_msg (\"close of closed channel\");\n+    }\n+\n   channel->is_closed = 1;\n \n   i = pthread_cond_broadcast (&channel->cond);"}, {"sha": "d16bde62d75a4df534230be79f07dc541e5c4103", "filename": "libgo/runtime/go-new-channel.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-new-channel.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-new-channel.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-channel.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -39,7 +39,6 @@ __go_new_channel (size_t element_size, size_t entries)\n   i = pthread_cond_init (&ret->cond, NULL);\n   __go_assert (i == 0);\n   ret->element_size = element_size;\n-  ret->closed_op_count = 0;\n   ret->waiting_to_send = 0;\n   ret->waiting_to_receive = 0;\n   ret->selected_for_send = 0;"}, {"sha": "d77a2ace432676e8b95d9fb93d8aef74c7dc056f", "filename": "libgo/runtime/go-rec-nb-small.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-rec-nb-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-rec-nb-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-nb-small.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -32,16 +32,6 @@ __go_receive_nonblocking_acquire (struct __go_channel *channel)\n \t  ? channel->next_store == 0\n \t  : channel->next_fetch == channel->next_store))\n     {\n-      if (channel->saw_close)\n-\t{\n-\t  ++channel->closed_op_count;\n-\t  if (channel->closed_op_count >= MAX_CLOSED_OPERATIONS)\n-\t    {\n-\t      i = pthread_mutex_unlock (&channel->lock);\n-\t      __go_assert (i == 0);\n-\t      __go_panic_msg (\"too many operations on closed channel\");\n-\t    }\n-\t}\n       channel->saw_close = 1;\n       __go_unlock_and_notify_selects (channel);\n       return RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;"}, {"sha": "c4dc8b6e892e40518f63389143a533f14feb0353", "filename": "libgo/runtime/go-rec-small.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-rec-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-rec-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-small.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -123,12 +123,6 @@ __go_receive_acquire (struct __go_channel *channel, _Bool for_select)\n \t      ? channel->next_store == 0\n \t      : channel->next_fetch == channel->next_store))\n \t{\n-\t  if (channel->saw_close)\n-\t    {\n-\t      ++channel->closed_op_count;\n-\t      if (channel->closed_op_count >= MAX_CLOSED_OPERATIONS)\n-\t\t__go_panic_msg (\"too many operations on closed channel\");\n-\t    }\n \t  channel->saw_close = 1;\n \t  channel->selected_for_receive = 0;\n \t  __go_unlock_and_notify_selects (channel);"}, {"sha": "c2732639536f1ca0bb47cb8695cc6ff1611a6353", "filename": "libgo/runtime/go-send-big.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-big.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -21,8 +21,7 @@ __go_send_big (struct __go_channel* channel, const void *val, _Bool for_select)\n   alloc_size = ((channel->element_size + sizeof (uint64_t) - 1)\n \t\t/ sizeof (uint64_t));\n \n-  if (!__go_send_acquire (channel, for_select))\n-    return;\n+  __go_send_acquire (channel, for_select);\n \n   offset = channel->next_store * alloc_size;\n   __builtin_memcpy (&channel->data[offset], val, channel->element_size);"}, {"sha": "1d33dd6207baa75055979850f7a07c3382b56346", "filename": "libgo/runtime/go-send-nb-big.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-nb-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-nb-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-nb-big.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -17,9 +17,8 @@ __go_send_nonblocking_big (struct __go_channel* channel, const void *val)\n   alloc_size = ((channel->element_size + sizeof (uint64_t) - 1)\n \t\t/ sizeof (uint64_t));\n \n-  int data = __go_send_nonblocking_acquire (channel);\n-  if (data != SEND_NONBLOCKING_ACQUIRE_SPACE)\n-    return data == SEND_NONBLOCKING_ACQUIRE_CLOSED;\n+  if (!__go_send_nonblocking_acquire (channel))\n+    return 0;\n \n   offset = channel->next_store * alloc_size;\n   __builtin_memcpy (&channel->data[offset], val, channel->element_size);"}, {"sha": "5c49a67ffb4093518223b5109f67407beae2e113", "filename": "libgo/runtime/go-send-nb-small.c", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-nb-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-nb-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-nb-small.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -10,9 +10,11 @@\n #include \"go-panic.h\"\n #include \"channel.h\"\n \n-/* Prepare to send something on a nonblocking channel.  */\n+/* Prepare to send something on a nonblocking channel.  Return true if\n+   we acquired the channel, false if we did not acquire it because\n+   there is no space to send a value.  */\n \n-int\n+_Bool\n __go_send_nonblocking_acquire (struct __go_channel *channel)\n {\n   int i;\n@@ -29,16 +31,9 @@ __go_send_nonblocking_acquire (struct __go_channel *channel)\n \n   if (channel->is_closed)\n     {\n-      ++channel->closed_op_count;\n-      if (channel->closed_op_count >= MAX_CLOSED_OPERATIONS)\n-\t{\n-\t  i = pthread_mutex_unlock (&channel->lock);\n-\t  __go_assert (i == 0);\n-\t  __go_panic_msg (\"too many operations on closed channel\");\n-\t}\n       i = pthread_mutex_unlock (&channel->lock);\n       __go_assert (i == 0);\n-      return SEND_NONBLOCKING_ACQUIRE_CLOSED;\n+      __go_panic_msg (\"send on closed channel\");\n     }\n \n   if (channel->num_entries > 0)\n@@ -87,10 +82,10 @@ __go_send_nonblocking_acquire (struct __go_channel *channel)\n       i = pthread_mutex_unlock (&channel->lock);\n       __go_assert (i == 0);\n \n-      return SEND_NONBLOCKING_ACQUIRE_NOSPACE;\n+      return 0;\n     }\n \n-  return SEND_NONBLOCKING_ACQUIRE_SPACE;\n+  return 1;\n }\n \n /* Send something 64 bits or smaller on a channel.  */\n@@ -100,9 +95,8 @@ __go_send_nonblocking_small (struct __go_channel *channel, uint64_t val)\n {\n   __go_assert (channel->element_size <= sizeof (uint64_t));\n \n-  int data = __go_send_nonblocking_acquire (channel);\n-  if (data != SEND_NONBLOCKING_ACQUIRE_SPACE)\n-    return data == SEND_NONBLOCKING_ACQUIRE_CLOSED;\n+  if (!__go_send_nonblocking_acquire (channel))\n+    return 0;\n \n   channel->data[channel->next_store] = val;\n "}, {"sha": "56f9470911f37fd2223da1785d7f594803364c3b", "filename": "libgo/runtime/go-send-small.c", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4bfc521c9eeadaac02870c419fad9ba67da0ff3c/libgo%2Fruntime%2Fgo-send-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-send-small.c?ref=4bfc521c9eeadaac02870c419fad9ba67da0ff3c", "patch": "@@ -10,12 +10,11 @@\n #include \"go-panic.h\"\n #include \"channel.h\"\n \n-/* Prepare to send something on a channel.  Return true if the channel\n-   is acquired, false, if it is closed.  FOR_SELECT is true if this\n+/* Prepare to send something on a channel.  FOR_SELECT is true if this\n    call is being made after a select statement returned with this\n    channel selected.  */\n \n-_Bool\n+void\n __go_send_acquire (struct __go_channel *channel, _Bool for_select)\n {\n   int i;\n@@ -25,19 +24,13 @@ __go_send_acquire (struct __go_channel *channel, _Bool for_select)\n \n   while (1)\n     {\n-      /* Check whether the channel is closed.  */\n       if (channel->is_closed)\n \t{\n-\t  ++channel->closed_op_count;\n-\t  if (channel->closed_op_count >= MAX_CLOSED_OPERATIONS)\n-\t    {\n-\t      i = pthread_mutex_unlock (&channel->lock);\n-\t      __go_assert (i == 0);\n-\t      __go_panic_msg (\"too many operations on closed channel\");\n-\t    }\n-\t  channel->selected_for_send = 0;\n-\t  __go_unlock_and_notify_selects (channel);\n-\t  return 0;\n+\t  if (for_select)\n+\t    channel->selected_for_send = 0;\n+\t  i = pthread_mutex_unlock (&channel->lock);\n+\t  __go_assert (i == 0);\n+\t  __go_panic_msg (\"send on closed channel\");\n \t}\n \n       /* If somebody else has the channel locked for sending, we have\n@@ -54,15 +47,15 @@ __go_send_acquire (struct __go_channel *channel, _Bool for_select)\n \t      if (!channel->waiting_to_send)\n \t\t{\n \t\t  __go_assert (channel->next_store == 0);\n-\t\t  return 1;\n+\t\t  return;\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      /* If there is room on the channel, we are OK.  */\n \t      if ((channel->next_store + 1) % channel->num_entries\n \t\t  != channel->next_fetch)\n-\t\treturn 1;\n+\t\treturn;\n \t    }\n \t}\n \n@@ -156,8 +149,7 @@ __go_send_small (struct __go_channel *channel, uint64_t val, _Bool for_select)\n \n   __go_assert (channel->element_size <= sizeof (uint64_t));\n \n-  if (!__go_send_acquire (channel, for_select))\n-    return;\n+  __go_send_acquire (channel, for_select);\n \n   channel->data[channel->next_store] = val;\n "}]}