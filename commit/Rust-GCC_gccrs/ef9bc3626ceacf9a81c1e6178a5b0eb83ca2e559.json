{"sha": "ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559", "node_id": "C_kwDOANBUbNoAKGVmOWJjMzYyNmNlYWNmOWE4MWMxZTYxNzhhNWIwZWI4M2NhMmU1NTk", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-27T23:12:06Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-09-29T22:34:18Z"}, "message": "Audit op1_range and op2_range for undefined LHS.\n\nIf the LHS is undefined, GORI should cease looking. There are numerous\nplaces where this happens, and a few potential traps.\n\n\t* range-op.cc (operator_minus::op2_range): Check for undefined.\n\t(operator_mult::op1_range): Ditto.\n\t(operator_exact_divide::op1_range): Ditto.\n\t(operator_lshift::op1_range): Ditto.\n\t(operator_rshift::op1_range): Ditto.\n\t(operator_cast::op1_range): Ditto.\n\t(operator_bitwise_and::op1_range): Ditto.\n\t(operator_bitwise_or::op1_range): Ditto.\n\t(operator_trunc_mod::op1_range): Ditto.\n\t(operator_trunc_mod::op2_range): Ditto.\n\t(operator_bitwise_not::op1_range): Ditto.\n\t(pointer_or_operator::op1_range): Ditto.\n\t(range_op_handler::op1_range): Ditto.\n\t(range_op_handler::op2_range): Ditto.", "tree": {"sha": "d1484b3cd3ed5313375bdc743137151b0773ad37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1484b3cd3ed5313375bdc743137151b0773ad37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559/comments", "author": null, "committer": null, "parents": [{"sha": "845ee38e9b40230fbb1b9825fb62146fd858cd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/845ee38e9b40230fbb1b9825fb62146fd858cd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/845ee38e9b40230fbb1b9825fb62146fd858cd96"}], "stats": {"total": 29, "additions": 29, "deletions": 0}, "files": [{"sha": "6b75c3651471652b890b5c8ef3efcc314f307466", "filename": "gcc/range-op.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=ef9bc3626ceacf9a81c1e6178a5b0eb83ca2e559", "patch": "@@ -1481,6 +1481,8 @@ operator_minus::op2_range (irange &r, tree type,\n \t\t\t   const irange &op1,\n \t\t\t   relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   return fold_range (r, type, op1, lhs);\n }\n \n@@ -1650,6 +1652,8 @@ operator_mult::op1_range (irange &r, tree type,\n \t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree offset;\n+  if (lhs.undefined_p ())\n+    return false;\n \n   // We can't solve 0 = OP1 * N by dividing by N with a wrapping type.\n   // For example: For 0 = OP1 * 2, OP1 could be 0, or MAXINT, whereas\n@@ -1902,6 +1906,8 @@ operator_exact_divide::op1_range (irange &r, tree type,\n \t\t\t\t  const irange &op2,\n \t\t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   tree offset;\n   // [2, 4] = op1 / [3,3]   since its exact divide, no need to worry about\n   // remainders in the endpoints, so op1 = [2,4] * [3,3] = [6,12].\n@@ -2111,6 +2117,8 @@ operator_lshift::op1_range (irange &r,\n \t\t\t    const irange &op2,\n \t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   tree shift_amount;\n \n   if (!lhs.contains_p (build_zero_cst (type)))\n@@ -2183,6 +2191,8 @@ operator_rshift::op1_range (irange &r,\n \t\t\t    relation_kind rel ATTRIBUTE_UNUSED) const\n {\n   tree shift;\n+  if (lhs.undefined_p ())\n+    return false;\n   if (op2.singleton_p (&shift))\n     {\n       // Ignore nonsensical shifts.\n@@ -2401,6 +2411,8 @@ operator_cast::op1_range (irange &r, tree type,\n \t\t\t  const irange &op2,\n \t\t\t  relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   tree lhs_type = lhs.type ();\n   gcc_checking_assert (types_compatible_p (op2.type(), type));\n \n@@ -2936,6 +2948,8 @@ operator_bitwise_and::op1_range (irange &r, tree type,\n \t\t\t\t const irange &op2,\n \t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   if (types_compatible_p (type, boolean_type_node))\n     return op_logical_and.op1_range (r, type, lhs, op2);\n \n@@ -3121,6 +3135,8 @@ operator_bitwise_or::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &op2,\n \t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   // If this is really a logical wi_fold, call that.\n   if (types_compatible_p (type, boolean_type_node))\n     return op_logical_or.op1_range (r, type, lhs, op2);\n@@ -3370,6 +3386,8 @@ operator_trunc_mod::op1_range (irange &r, tree type,\n \t\t\t       const irange &,\n \t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   // PR 91029.\n   signop sign = TYPE_SIGN (type);\n   unsigned prec = TYPE_PRECISION (type);\n@@ -3394,6 +3412,8 @@ operator_trunc_mod::op2_range (irange &r, tree type,\n \t\t\t       const irange &,\n \t\t\t       relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   // PR 91029.\n   signop sign = TYPE_SIGN (type);\n   unsigned prec = TYPE_PRECISION (type);\n@@ -3522,6 +3542,8 @@ operator_bitwise_not::op1_range (irange &r, tree type,\n \t\t\t\t const irange &op2,\n \t\t\t\t relation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   if (types_compatible_p (type, boolean_type_node))\n     return op_logical_not.op1_range (r, type, lhs, op2);\n \n@@ -4008,6 +4030,8 @@ pointer_or_operator::op1_range (irange &r, tree type,\n \t\t\t\tconst irange &op2 ATTRIBUTE_UNUSED,\n \t\t\t\trelation_kind rel ATTRIBUTE_UNUSED) const\n {\n+  if (lhs.undefined_p ())\n+    return false;\n   if (lhs.zero_p ())\n     {\n       tree zero = build_zero_cst (type);\n@@ -4239,6 +4263,9 @@ range_op_handler::op1_range (vrange &r, tree type,\n \t\t\t     relation_kind rel) const\n {\n   gcc_checking_assert (m_valid);\n+\n+  if (lhs.undefined_p ())\n+    return false;\n   if (m_int)\n     return m_int->op1_range (as_a <irange> (r), type,\n \t\t\t     as_a <irange> (lhs),\n@@ -4260,6 +4287,8 @@ range_op_handler::op2_range (vrange &r, tree type,\n \t\t\t     relation_kind rel) const\n {\n   gcc_checking_assert (m_valid);\n+  if (lhs.undefined_p ())\n+    return false;\n   if (m_int)\n     return m_int->op2_range (as_a <irange> (r), type,\n \t\t\t     as_a <irange> (lhs),"}]}