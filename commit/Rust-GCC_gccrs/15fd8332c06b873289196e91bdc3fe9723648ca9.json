{"sha": "15fd8332c06b873289196e91bdc3fe9723648ca9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVmZDgzMzJjMDZiODczMjg5MTk2ZTkxYmRjM2ZlOTcyMzY0OGNhOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-02-28T19:57:56Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-02-28T19:57:56Z"}, "message": "files.c (_cpp_find_file): If returning early...\n\n\t* files.c (_cpp_find_file): If returning early, before storing\n\tsomething to *hash_slot and *hash_slot is NULL, call htab_clear_slot\n\ton it.  Access *hash_slot using void * type rather than\n\tstruct file_hash_entry * to avoid aliasing issues.\n\nFrom-SVN: r196356", "tree": {"sha": "c42d67f1e6f67c4af0d7e746ecbc6e2602a3254d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c42d67f1e6f67c4af0d7e746ecbc6e2602a3254d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15fd8332c06b873289196e91bdc3fe9723648ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fd8332c06b873289196e91bdc3fe9723648ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15fd8332c06b873289196e91bdc3fe9723648ca9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15fd8332c06b873289196e91bdc3fe9723648ca9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4c37612689003f4df7b6a8561a16f7649f27462f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c37612689003f4df7b6a8561a16f7649f27462f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c37612689003f4df7b6a8561a16f7649f27462f"}], "stats": {"total": 48, "additions": 35, "deletions": 13}, "files": [{"sha": "934db6a08cd332793afe97a82ccddfd7ed941630", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fd8332c06b873289196e91bdc3fe9723648ca9/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fd8332c06b873289196e91bdc3fe9723648ca9/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=15fd8332c06b873289196e91bdc3fe9723648ca9", "patch": "@@ -1,5 +1,10 @@\n 2013-02-28  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* files.c (_cpp_find_file): If returning early, before storing\n+\tsomething to *hash_slot and *hash_slot is NULL, call htab_clear_slot\n+\ton it.  Access *hash_slot using void * type rather than\n+\tstruct file_hash_entry * to avoid aliasing issues.\n+\n \t* configure.ac: Don't define ENABLE_CHECKING whenever\n \t--enable-checking is seen, instead use similar --enable-checking=yes\n \tvs. --enable-checking=release default as gcc/ subdir has and"}, {"sha": "a614b7cebeddbec6ed750ae851c43331f88b5f6f", "filename": "libcpp/files.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15fd8332c06b873289196e91bdc3fe9723648ca9/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15fd8332c06b873289196e91bdc3fe9723648ca9/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=15fd8332c06b873289196e91bdc3fe9723648ca9", "patch": "@@ -492,7 +492,8 @@ _cpp_file *\n _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\tbool fake, int angle_brackets, bool implicit_preinclude)\n {\n-  struct file_hash_entry *entry, **hash_slot;\n+  struct file_hash_entry *entry;\n+  void **hash_slot;\n   _cpp_file *file;\n   bool invalid_pch = false;\n   bool saw_bracket_include = false;\n@@ -503,13 +504,12 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n   if (start_dir == NULL)\n     cpp_error (pfile, CPP_DL_ICE, \"NULL directory in find_file\");\n \n-  hash_slot = (struct file_hash_entry **)\n-    htab_find_slot_with_hash (pfile->file_hash, fname,\n-\t\t\t      htab_hash_string (fname),\n-\t\t\t      INSERT);\n+  hash_slot\n+    = htab_find_slot_with_hash (pfile->file_hash, fname,\n+\t\t\t\thtab_hash_string (fname), INSERT);\n \n   /* First check the cache before we resort to memory allocation.  */\n-  entry = search_cache (*hash_slot, start_dir);\n+  entry = search_cache ((struct file_hash_entry *) *hash_slot, start_dir);\n   if (entry)\n     return entry->u.file;\n \n@@ -533,6 +533,17 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t\t the list of all files so that #import works.  */\n \t      file->next_file = pfile->all_files;\n \t      pfile->all_files = file;\n+\t      if (*hash_slot == NULL)\n+\t\t{\n+\t\t  /* If *hash_slot is NULL, the above htab_find_slot_with_hash\n+\t\t     call just created the slot, but we aren't going to store\n+\t\t     there anything, so need to remove the newly created entry.\n+\t\t     htab_clear_slot requires that it is non-NULL, so store\n+\t\t     there some non-NULL pointer, htab_clear_slot will\n+\t\t     overwrite it immediately.  */\n+\t\t  *hash_slot = file;\n+\t\t  htab_clear_slot (pfile->file_hash, hash_slot);\n+\t\t}\n \t      return file;\n \t    }\n \n@@ -548,6 +559,12 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \t    {\n \t      free ((char *) file->name);\n \t      free (file);\n+\t      if (*hash_slot == NULL)\n+\t\t{\n+\t\t  /* See comment on the above htab_clear_slot call.  */\n+\t\t  *hash_slot = file;\n+\t\t  htab_clear_slot (pfile->file_hash, hash_slot);\n+\t\t}\n \t      return NULL;\n \t    }\n \t  else\n@@ -565,7 +582,7 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n       else\n \tcontinue;\n \n-      entry = search_cache (*hash_slot, file->dir);\n+      entry = search_cache ((struct file_hash_entry *) *hash_slot, file->dir);\n       if (entry)\n \t{\n \t  found_in_cache = file->dir;\n@@ -589,11 +606,11 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n \n   /* Store this new result in the hash table.  */\n   entry = new_file_hash_entry (pfile);\n-  entry->next = *hash_slot;\n+  entry->next = (struct file_hash_entry *) *hash_slot;\n   entry->start_dir = start_dir;\n   entry->location = pfile->line_table->highest_location;\n   entry->u.file = file;\n-  *hash_slot = entry;\n+  *hash_slot = (void *) entry;\n \n   /* If we passed the quote or bracket chain heads, cache them also.\n      This speeds up processing if there are lots of -I options.  */\n@@ -602,22 +619,22 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,\n       && found_in_cache != pfile->bracket_include)\n     {\n       entry = new_file_hash_entry (pfile);\n-      entry->next = *hash_slot;\n+      entry->next = (struct file_hash_entry *) *hash_slot;\n       entry->start_dir = pfile->bracket_include;\n       entry->location = pfile->line_table->highest_location;\n       entry->u.file = file;\n-      *hash_slot = entry;\n+      *hash_slot = (void *) entry;\n     }\n   if (saw_quote_include\n       && pfile->quote_include != start_dir\n       && found_in_cache != pfile->quote_include)\n     {\n       entry = new_file_hash_entry (pfile);\n-      entry->next = *hash_slot;\n+      entry->next = (struct file_hash_entry *) *hash_slot;\n       entry->start_dir = pfile->quote_include;\n       entry->location = pfile->line_table->highest_location;\n       entry->u.file = file;\n-      *hash_slot = entry;\n+      *hash_slot = (void *) entry;\n     }\n \n   return file;"}]}