{"sha": "b485e15bf861b6eb5680c3a268036b2cdeacd656", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ4NWUxNWJmODYxYjZlYjU2ODBjM2EyNjgwMzZiMmNkZWFjZDY1Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-08-21T04:39:29Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-21T04:39:29Z"}, "message": "class.c (build_vtbl_initializer): Clear the entire vtbl_init_data.\n\n\t* class.c (build_vtbl_initializer): Clear the entire\n\tvtbl_init_data.  Start keeping track of the functions for which we\n\thave created vcall offsets here.\n\t(dfs_build_vcall_offset_vtbl_entries): Remove.\n\t(build_vcall_offset_vtbl_entries): Reimplement.\n\t(add_vcall_offset_vtbl_entries_r): New function.\n\t(add_vcall_offset_vtbl_entries_1): Likewise.  Tweak logic for\n\tcomputing when vcall offsets are necessary.\n\nFrom-SVN: r35828", "tree": {"sha": "57fabcf0e8d372f3efe65712e2a6e9d363273a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57fabcf0e8d372f3efe65712e2a6e9d363273a2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b485e15bf861b6eb5680c3a268036b2cdeacd656", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b485e15bf861b6eb5680c3a268036b2cdeacd656", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b485e15bf861b6eb5680c3a268036b2cdeacd656", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b485e15bf861b6eb5680c3a268036b2cdeacd656/comments", "author": null, "committer": null, "parents": [{"sha": "7171b4910c1b59ba953263a0625917ba4b7e57ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7171b4910c1b59ba953263a0625917ba4b7e57ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7171b4910c1b59ba953263a0625917ba4b7e57ee"}], "stats": {"total": 207, "additions": 126, "deletions": 81}, "files": [{"sha": "18449d117d55bcac587009a198d1af54ec7b2348", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b485e15bf861b6eb5680c3a268036b2cdeacd656/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b485e15bf861b6eb5680c3a268036b2cdeacd656/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b485e15bf861b6eb5680c3a268036b2cdeacd656", "patch": "@@ -1,3 +1,14 @@\n+2000-08-20  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* class.c (build_vtbl_initializer): Clear the entire\n+\tvtbl_init_data.  Start keeping track of the functions for which we\n+\thave created vcall offsets here.\n+\t(dfs_build_vcall_offset_vtbl_entries): Remove.\n+\t(build_vcall_offset_vtbl_entries): Reimplement.\n+\t(add_vcall_offset_vtbl_entries_r): New function.\n+\t(add_vcall_offset_vtbl_entries_1): Likewise.  Tweak logic for\n+\tcomputing when vcall offsets are necessary.\n+\n 2000-08-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* decl.c (member_function_or_else): Use cp_error ... %T."}, {"sha": "2834154f3d829b419044e2b575d3154ce51b0a3b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 115, "deletions": 81, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b485e15bf861b6eb5680c3a268036b2cdeacd656/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b485e15bf861b6eb5680c3a268036b2cdeacd656/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b485e15bf861b6eb5680c3a268036b2cdeacd656", "patch": "@@ -160,7 +160,8 @@ static void propagate_binfo_offsets PARAMS ((tree, tree));\n static void layout_virtual_bases PARAMS ((tree, varray_type *));\n static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n-static tree dfs_build_vcall_offset_vtbl_entries PARAMS ((tree, void *));\n+static void add_vcall_offset_vtbl_entries_r PARAMS ((tree, vtbl_init_data *));\n+static void add_vcall_offset_vtbl_entries_1 PARAMS ((tree, vtbl_init_data *));\n static void build_vcall_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n static void layout_vtable_decl PARAMS ((tree, int));\n static tree dfs_find_final_overrider PARAMS ((tree, void *));\n@@ -7097,9 +7098,9 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   vtbl_init_data vid;\n \n   /* Initialize VID.  */\n+  bzero (&vid, sizeof (vid));\n   vid.binfo = binfo;\n   vid.derived = t;\n-  vid.inits = NULL_TREE;\n   vid.last_init = &vid.inits;\n   vid.primary_vtbl_p = (binfo == TYPE_BINFO (t));\n   vid.ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n@@ -7109,9 +7110,15 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n   /* Add entries to the vtable for RTTI.  */\n   build_rtti_vtbl_entries (binfo, rtti_binfo, &vid);\n \n+  /* Create an array for keeping track of the functions we've\n+     processed.  When we see multiple functions with the same\n+     signature, we share the vcall offsets.  */\n+  VARRAY_TREE_INIT (vid.fns, 32, \"fns\");\n   /* Add the vcall and vbase offset entries.  */\n   build_vcall_and_vbase_vtbl_entries (binfo, &vid);\n-   /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n+  /* Clean up.  */\n+  VARRAY_FREE (vid.fns);\n+  /* Clear BINFO_VTABLE_PAATH_MARKED; it's set by\n      build_vbase_offset_vtbl_entries.  */\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n        vbase; \n@@ -7283,25 +7290,98 @@ build_vbase_offset_vtbl_entries (binfo, vid)\n     }\n }\n \n+/* Adds the initializers for the vcall offset entries in the vtable\n+   for BINFO (which is part of the class hierarchy dominated by T) to\n+   VID->INITS.  */\n+\n+static void\n+build_vcall_offset_vtbl_entries (binfo, vid)\n+     tree binfo;\n+     vtbl_init_data *vid;\n+{\n+  /* Under the old ABI, the adjustments to the `this' pointer were made\n+     elsewhere.  */\n+  if (!vcall_offsets_in_vtable_p ())\n+    return;\n+\n+  /* We only need these entries if this base is a virtual base.  */\n+  if (!TREE_VIA_VIRTUAL (binfo))\n+    return;\n+\n+  /* We need a vcall offset for each of the virtual functions in this\n+     vtable.  For example:\n+\n+       class A { virtual void f (); };\n+       class B : virtual public A { };\n+       class C: virtual public A, public B {};\n+      \n+     Now imagine:\n+\n+       B* b = new C;\n+       b->f();\n+\n+     The location of `A' is not at a fixed offset relative to `B'; the\n+     offset depends on the complete object derived from `B'.  So, \n+     `B' vtable contains an entry for `f' that indicates by what\n+     amount the `this' pointer for `B' needs to be adjusted to arrive\n+     at `A'.  \n+\n+     We need entries for all the functions in our primary vtable and\n+     in our non-virtual bases vtables.  */\n+  vid->vbase = binfo;\n+  /* Now, walk through the non-virtual bases, adding vcall offsets.  */\n+  add_vcall_offset_vtbl_entries_r (binfo, vid);\n+}\n+\n+/* Build vcall offsets, starting with those for BINFO.  */\n+\n+static void\n+add_vcall_offset_vtbl_entries_r (binfo, vid)\n+     tree binfo;\n+     vtbl_init_data *vid;\n+{\n+  int i;\n+  tree primary_binfo;\n+\n+  /* Don't walk into virtual bases -- except, of course, for the\n+     virtual base for which we are building vcall offsets.  */\n+  if (TREE_VIA_VIRTUAL (binfo) && vid->vbase != binfo)\n+    return;\n+  \n+  /* If BINFO has a primary base, process it first.  */\n+  primary_binfo = get_primary_binfo (binfo);\n+  if (primary_binfo)\n+    add_vcall_offset_vtbl_entries_r (primary_binfo, vid);\n+\n+  /* Add BINFO itself to the list.  */\n+  add_vcall_offset_vtbl_entries_1 (binfo, vid);\n+\n+  /* Scan the non-primary bases of BINFO.  */\n+  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i) \n+    {\n+      tree base_binfo;\n+      \n+      base_binfo = BINFO_BASETYPE (binfo, i);\n+      if (base_binfo != primary_binfo)\n+\tadd_vcall_offset_vtbl_entries_r (base_binfo, vid);\n+    }\n+}\n+\n /* Called from build_vcall_offset_vtbl_entries via dfs_walk.  */\n \n-static tree\n-dfs_build_vcall_offset_vtbl_entries (binfo, data)\n+static void\n+add_vcall_offset_vtbl_entries_1 (binfo, vid)\n      tree binfo;\n-     void *data;\n+     vtbl_init_data* vid;\n {\n-  vtbl_init_data* vid;\n   tree derived_virtuals;\n   tree base_virtuals;\n+  tree orig_virtuals;\n   tree binfo_inits;\n   /* If BINFO is a primary base, this is the least derived class of\n      BINFO that is not a primary base.  */\n   tree non_primary_binfo;\n-  /* The primary base of BINFO.  */\n-  tree primary_binfo;\n-  int i;\n \n-  vid = (vtbl_init_data *) data;\n   binfo_inits = NULL_TREE;\n \n   /* We might be a primary base class.  Go up the inheritance\n@@ -7329,29 +7409,35 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n       non_primary_binfo = b;\n     }\n \n-  /* Skip virtuals that we have already handled in a primary base\n-     class.  */\n-  base_virtuals = BINFO_VIRTUALS (binfo);\n-  derived_virtuals = BINFO_VIRTUALS (non_primary_binfo);\n-  primary_binfo = get_primary_binfo (binfo);\n-  if (primary_binfo)\n-    for (i = 0; i < CLASSTYPE_VSIZE (BINFO_TYPE (primary_binfo)); ++i)\n-      {\n-\tbase_virtuals = TREE_CHAIN (base_virtuals);\n-\tderived_virtuals = TREE_CHAIN (derived_virtuals);\n-      }\n-\n   /* Make entries for the rest of the virtuals.  */\n-  for (; base_virtuals;\n-       derived_virtuals = TREE_CHAIN (derived_virtuals),\n-\t base_virtuals = TREE_CHAIN (base_virtuals))\n-    {\n-      /* Figure out what function we're looking at.  */\n-      tree fn = BV_FN (derived_virtuals);\n+  for (base_virtuals = BINFO_VIRTUALS (binfo),\n+\t derived_virtuals = BINFO_VIRTUALS (non_primary_binfo),\n+\t orig_virtuals = BINFO_VIRTUALS (TYPE_BINFO (BINFO_TYPE (binfo)));\n+       base_virtuals;\n+       base_virtuals = TREE_CHAIN (base_virtuals),\n+\t derived_virtuals = TREE_CHAIN (derived_virtuals),\n+\t orig_virtuals = TREE_CHAIN (orig_virtuals))\n+    {\n+      tree orig_fn;\n+      tree fn;\n       tree base;\n       tree base_binfo;\n       size_t i;\n \n+      /* Find the declaration that originally caused this function to\n+\t be present.  */\n+      orig_fn = BV_FN (orig_virtuals);\n+\n+      /* We do not need an entry if this function is declared in a\n+\t virtual base (or one of its virtual bases), and not\n+\t overridden in the section of the hierarchy dominated by the\n+\t virtual base for which we are building vcall offsets.  */\n+      if (!same_type_p (DECL_CONTEXT (orig_fn), BINFO_TYPE (binfo)))\n+\tcontinue;\n+\n+      /* Find the overriding function.  */\n+      fn = BV_FN (derived_virtuals);\n+\n       /* If there is already an entry for a function with the same\n \t signature as FN, then we do not need a second vcall offset.\n \t Check the list of functions already present in the derived\n@@ -7398,58 +7484,6 @@ dfs_build_vcall_offset_vtbl_entries (binfo, data)\n       /* Keep track of this function.  */\n       VARRAY_PUSH_TREE (vid->fns, derived_virtuals);\n     }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Adds the initializers for the vcall offset entries in the vtable\n-   for BINFO (which is part of the class hierarchy dominated by T) to\n-   VID->INITS.  */\n-\n-static void\n-build_vcall_offset_vtbl_entries (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n-{\n-  /* Under the old ABI, the adjustments to the `this' pointer were made\n-     elsewhere.  */\n-  if (!vcall_offsets_in_vtable_p ())\n-    return;\n-\n-  /* We only need these entries if this base is a virtual base.  */\n-  if (!TREE_VIA_VIRTUAL (binfo))\n-    return;\n-\n-  /* We need a vcall offset for each of the virtual functions in this\n-     vtable.  For example:\n-\n-       class A { virtual void f (); };\n-       class B : virtual public A { };\n-       class C: virtual public A, public B {};\n-      \n-     Now imagine:\n-\n-       B* b = new C;\n-       b->f();\n-\n-     The location of `A' is not at a fixed offset relative to `B'; the\n-     offset depends on the complete object derived from `B'.  So, \n-     `B' vtable contains an entry for `f' that indicates by what\n-     amount the `this' pointer for `B' needs to be adjusted to arrive\n-     at `A'.  \n-\n-     We need entries for all the functions in our primary vtable and\n-     in our non-virtual bases vtables.  For each base, the entries\n-     appear in the same order as in the base; but the bases themselves\n-     appear in reverse depth-first, left-to-right order.  */\n-  vid->vbase = binfo;\n-  VARRAY_TREE_INIT (vid->fns, 32, \"fns\");\n-  dfs_walk_real (binfo,\n-\t\t dfs_build_vcall_offset_vtbl_entries,\n-\t\t NULL,\n-\t\t dfs_skip_vbases,\n-\t\t vid);\n-  VARRAY_FREE (vid->fns);\n }\n \n /* Return vtbl initializers for the RTTI entries coresponding to the"}]}