{"sha": "2dbc83d953662e61db936cac2ac25f907895205e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRiYzgzZDk1MzY2MmU2MWRiOTM2Y2FjMmFjMjVmOTA3ODk1MjA1ZQ==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-06-08T08:01:10Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-06-08T08:01:10Z"}, "message": "* trans-intrinsic.c: Revert Lee's 2007-06-04 patch.\n\nFrom-SVN: r125565", "tree": {"sha": "595882dd157585370490f7856e50304ff1d4ab6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/595882dd157585370490f7856e50304ff1d4ab6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dbc83d953662e61db936cac2ac25f907895205e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbc83d953662e61db936cac2ac25f907895205e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dbc83d953662e61db936cac2ac25f907895205e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbc83d953662e61db936cac2ac25f907895205e/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4aa97413d3845089735af2d5a5fe7b01eeae6008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4aa97413d3845089735af2d5a5fe7b01eeae6008", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4aa97413d3845089735af2d5a5fe7b01eeae6008"}], "stats": {"total": 603, "additions": 298, "deletions": 305}, "files": [{"sha": "f79524461d4c6347f521889786fee1c98802c3fc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbc83d953662e61db936cac2ac25f907895205e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbc83d953662e61db936cac2ac25f907895205e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2dbc83d953662e61db936cac2ac25f907895205e", "patch": "@@ -1,3 +1,7 @@\n+2007-06-08 Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n+\n+\t* trans-intrinsic.c: Revert Lee's 2007-06-04 patch.\n+\n 2007-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>\n \t    Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n "}, {"sha": "35a0b57f5cc9085341d4c45835e8599e6775320b", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 294, "deletions": 305, "changes": 599, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dbc83d953662e61db936cac2ac25f907895205e/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dbc83d953662e61db936cac2ac25f907895205e/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=2dbc83d953662e61db936cac2ac25f907895205e", "patch": "@@ -163,29 +163,25 @@ real_compnt_info;\n \n enum rounding_mode { RND_ROUND, RND_TRUNC, RND_CEIL, RND_FLOOR };\n \n-/* Evaluate the arguments to an intrinsic function.  The value\n-   of NARGS may be less than the actual number of arguments in EXPR\n-   to allow optional \"KIND\" arguments that are not included in the\n-   generated code to be ignored.  */\n+/* Evaluate the arguments to an intrinsic function.  */\n+/* FIXME: This function and its callers should be rewritten so that it's\n+   not necessary to cons up a list to hold the arguments.  */\n \n-static void\n-gfc_conv_intrinsic_function_args (gfc_se *se, gfc_expr *expr,\n-\t\t\t\t  tree *argarray, int nargs)\n+static tree\n+gfc_conv_intrinsic_function_args (gfc_se * se, gfc_expr * expr)\n {\n   gfc_actual_arglist *actual;\n   gfc_expr *e;\n   gfc_intrinsic_arg  *formal;\n   gfc_se argse;\n-  int curr_arg;\n+  tree args;\n \n+  args = NULL_TREE;\n   formal = expr->value.function.isym->formal;\n-  actual = expr->value.function.actual;\n \n-   for (curr_arg = 0; curr_arg < nargs; curr_arg++,\n-\tactual = actual->next,\n-\tformal = formal ? formal->next : NULL)\n+  for (actual = expr->value.function.actual; actual; actual = actual->next,\n+       formal = formal ? formal->next : NULL)\n     {\n-      gcc_assert (actual);\n       e = actual->expr;\n       /* Skip omitted optional arguments.  */\n       if (!e)\n@@ -199,8 +195,7 @@ gfc_conv_intrinsic_function_args (gfc_se *se, gfc_expr *expr,\n \t{\n \t  gfc_conv_expr (&argse, e);\n \t  gfc_conv_string_parameter (&argse);\n-          argarray[curr_arg++] = argse.string_length;\n-\t  gcc_assert (curr_arg < nargs);\n+\t  args = gfc_chainon_list (args, argse.string_length);\n \t}\n       else\n         gfc_conv_expr_val (&argse, e);\n@@ -215,31 +210,9 @@ gfc_conv_intrinsic_function_args (gfc_se *se, gfc_expr *expr,\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);\n-      argarray[curr_arg] = argse.expr;\n-    }\n-}\n-\n-/* Count the number of actual arguments to the intrinsic function EXPR\n-   including any \"hidden\" string length arguments.  */\n-\n-static unsigned int\n-gfc_intrinsic_argument_list_length (gfc_expr *expr)\n-{\n-  int n = 0;\n-  gfc_actual_arglist *actual;\n-\n-  for (actual = expr->value.function.actual; actual; actual = actual->next)\n-    {\n-      if (!actual->expr)\n-\tcontinue;\n-\n-      if (actual->expr->ts.type == BT_CHARACTER)\n-\tn += 2;\n-      else\n-\tn++;\n+      args = gfc_chainon_list (args, argse.expr);\n     }\n-\n-  return n;\n+  return args;\n }\n \n \n@@ -255,7 +228,8 @@ gfc_conv_intrinsic_conversion (gfc_se * se, gfc_expr * expr)\n   /* Evaluate the argument.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n \n   /* Conversion from complex to non-complex involves taking the real\n      component of the value.  */\n@@ -428,19 +402,20 @@ gfc_conv_intrinsic_aint (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n \n   /* Evaluate the argument.  */\n   gcc_assert (expr->value.function.actual->expr);\n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n \n   /* Use a builtin function if one exists.  */\n   if (n != END_BUILTINS)\n     {\n       tmp = built_in_decls[n];\n-      se->expr = build_call_expr (tmp, 1, arg);\n+      se->expr = build_function_call_expr (tmp, arg);\n       return;\n     }\n \n   /* This code is probably redundant, but we'll keep it lying around just\n      in case.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n+  arg = TREE_VALUE (arg);\n   arg = gfc_evaluate_now (arg, &se->pre);\n \n   /* Test if the value is too large to handle sensibly.  */\n@@ -475,7 +450,8 @@ gfc_conv_intrinsic_int (gfc_se * se, gfc_expr * expr, enum rounding_mode op)\n   /* Evaluate the argument.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n   gcc_assert (expr->value.function.actual->expr);\n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n \n   if (TREE_CODE (TREE_TYPE (arg)) == INTEGER_TYPE)\n     {\n@@ -507,7 +483,8 @@ gfc_conv_intrinsic_imagpart (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n   se->expr = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n }\n \n@@ -519,7 +496,8 @@ gfc_conv_intrinsic_conjg (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n   se->expr = build1 (CONJ_EXPR, TREE_TYPE (arg), arg);\n }\n \n@@ -669,10 +647,8 @@ static void\n gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n {\n   gfc_intrinsic_map_t *m;\n+  tree args;\n   tree fndecl;\n-  tree rettype;\n-  tree *args;\n-  unsigned int num_args;\n   gfc_isym_id id;\n \n   id = expr->value.function.isym->id;\n@@ -690,26 +666,20 @@ gfc_conv_intrinsic_lib_function (gfc_se * se, gfc_expr * expr)\n     }\n \n   /* Get the decl and generate the call.  */\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * num_args);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n   fndecl = gfc_get_intrinsic_lib_fndecl (m, expr);\n-  rettype = TREE_TYPE (TREE_TYPE (fndecl));\n-\n-  fndecl = build_addr (fndecl, current_function_decl);\n-  se->expr = build_call_array (rettype, fndecl, num_args, args);\n+  se->expr = build_function_call_expr (fndecl, args);\n }\n \n /* Generate code for EXPONENT(X) intrinsic function.  */\n \n static void\n gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg, fndecl;\n+  tree args, fndecl;\n   gfc_expr *a1;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n \n   a1 = expr->value.function.actual->expr;\n   switch (a1->ts.kind)\n@@ -730,7 +700,7 @@ gfc_conv_intrinsic_exponent (gfc_se * se, gfc_expr * expr)\n       gcc_unreachable ();\n     }\n \n-  se->expr = build_call_expr (fndecl, 1, arg);\n+  se->expr = build_function_call_expr (fndecl, args);\n }\n \n /* Evaluate a single upper or lower bound.  */\n@@ -934,16 +904,19 @@ gfc_conv_intrinsic_bound (gfc_se * se, gfc_expr * expr, int upper)\n static void\n gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n+  tree args;\n+  tree val;\n   int n;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n+  gcc_assert (args && TREE_CHAIN (args) == NULL_TREE);\n+  val = TREE_VALUE (args);\n \n   switch (expr->value.function.actual->expr->ts.type)\n     {\n     case BT_INTEGER:\n     case BT_REAL:\n-      se->expr = build1 (ABS_EXPR, TREE_TYPE (arg), arg);\n+      se->expr = build1 (ABS_EXPR, TREE_TYPE (val), val);\n       break;\n \n     case BT_COMPLEX:\n@@ -962,7 +935,7 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_call_expr (built_in_decls[n], 1, arg);\n+      se->expr = build_function_call_expr (built_in_decls[n], args);\n       break;\n \n     default:\n@@ -976,23 +949,20 @@ gfc_conv_intrinsic_abs (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n {\n+  tree arg;\n   tree real;\n   tree imag;\n   tree type;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * num_args);\n \n   type = gfc_typenode_for_spec (&expr->ts);\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n-  real = convert (TREE_TYPE (type), args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  real = convert (TREE_TYPE (type), TREE_VALUE (arg));\n   if (both)\n-    imag = convert (TREE_TYPE (type), args[1]);\n-  else if (TREE_CODE (TREE_TYPE (args[0])) == COMPLEX_TYPE)\n+    imag = convert (TREE_TYPE (type), TREE_VALUE (TREE_CHAIN (arg)));\n+  else if (TREE_CODE (TREE_TYPE (TREE_VALUE (arg))) == COMPLEX_TYPE)\n     {\n-      imag = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (args[0])), args[0]);\n+      arg = TREE_VALUE (arg);\n+      imag = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n       imag = convert (TREE_TYPE (type), imag);\n     }\n   else\n@@ -1008,27 +978,30 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n static void\n gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n {\n+  tree arg;\n+  tree arg2;\n   tree type;\n   tree itype;\n   tree tmp;\n   tree test;\n   tree test2;\n   mpfr_t huge;\n   int n, ikind;\n-  tree args[2];\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n \n   switch (expr->ts.type)\n     {\n     case BT_INTEGER:\n       /* Integer case is easy, we've got a builtin op.  */\n-      type = TREE_TYPE (args[0]);\n+      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+      arg = TREE_VALUE (arg);\n+      type = TREE_TYPE (arg);\n \n       if (modulo)\n-       se->expr = build2 (FLOOR_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = build2 (FLOOR_MOD_EXPR, type, arg, arg2);\n       else\n-       se->expr = build2 (TRUNC_MOD_EXPR, type, args[0], args[1]);\n+       se->expr = build2 (TRUNC_MOD_EXPR, type, arg, arg2);\n       break;\n \n     case BT_REAL:\n@@ -1056,17 +1029,18 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       /* Use it if it exists.  */\n       if (n != END_BUILTINS)\n \t{\n-  \t  tmp = build_addr (built_in_decls[n], current_function_decl);\n-\t  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (built_in_decls[n])),\n-                                       tmp, 2, args);\n+\t  tmp = built_in_decls[n];\n+\t  se->expr = build_function_call_expr (tmp, arg);\n \t  if (modulo == 0)\n \t    return;\n \t}\n \n-      type = TREE_TYPE (args[0]);\n+      arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+      arg = TREE_VALUE (arg);\n+      type = TREE_TYPE (arg);\n \n-      args[0] = gfc_evaluate_now (args[0], &se->pre);\n-      args[1] = gfc_evaluate_now (args[1], &se->pre);\n+      arg = gfc_evaluate_now (arg, &se->pre);\n+      arg2 = gfc_evaluate_now (arg2, &se->pre);\n \n       /* Definition:\n \t modulo = arg - floor (arg/arg2) * arg2, so\n@@ -1079,20 +1053,20 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t{\n \t  tree zero = gfc_build_const (type, integer_zero_node);\n \t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n-\t  test = build2 (LT_EXPR, boolean_type_node, args[0], zero);\n-\t  test2 = build2 (LT_EXPR, boolean_type_node, args[1], zero);\n+\t  test = build2 (LT_EXPR, boolean_type_node, arg, zero);\n+\t  test2 = build2 (LT_EXPR, boolean_type_node, arg2, zero);\n \t  test2 = build2 (TRUTH_XOR_EXPR, boolean_type_node, test, test2);\n \t  test = build2 (NE_EXPR, boolean_type_node, tmp, zero);\n \t  test = build2 (TRUTH_AND_EXPR, boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n \t  se->expr = build3 (COND_EXPR, type, test,\n-\t\t\t     build2 (PLUS_EXPR, type, tmp, args[1]), tmp);\n+\t\t\t     build2 (PLUS_EXPR, type, tmp, arg2), tmp);\n \t  return;\n \t}\n \n       /* If we do not have a built_in fmod, the calculation is going to\n \t have to be done longhand.  */\n-      tmp = build2 (RDIV_EXPR, type, args[0], args[1]);\n+      tmp = build2 (RDIV_EXPR, type, arg, arg2);\n \n       /* Test if the value is too large to handle sensibly.  */\n       gfc_set_model_kind (expr->ts.kind);\n@@ -1119,9 +1093,9 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       else\n        tmp = build_fix_expr (&se->pre, tmp, itype, RND_TRUNC);\n       tmp = convert (type, tmp);\n-      tmp = build3 (COND_EXPR, type, test2, tmp, args[0]);\n-      tmp = build2 (MULT_EXPR, type, tmp, args[1]);\n-      se->expr = build2 (MINUS_EXPR, type, args[0], tmp);\n+      tmp = build3 (COND_EXPR, type, test2, tmp, arg);\n+      tmp = build2 (MULT_EXPR, type, tmp, arg2);\n+      se->expr = build2 (MINUS_EXPR, type, arg, tmp);\n       mpfr_clear (huge);\n       break;\n \n@@ -1135,16 +1109,19 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n static void\n gfc_conv_intrinsic_dim (gfc_se * se, gfc_expr * expr)\n {\n+  tree arg;\n+  tree arg2;\n   tree val;\n   tree tmp;\n   tree type;\n   tree zero;\n-  tree args[2];\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  type = TREE_TYPE (args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n \n-  val = build2 (MINUS_EXPR, type, args[0], args[1]);\n+  val = build2 (MINUS_EXPR, type, arg, arg2);\n   val = gfc_evaluate_now (val, &se->pre);\n \n   zero = gfc_build_const (type, integer_zero_node);\n@@ -1163,10 +1140,11 @@ static void\n gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n {\n   tree tmp;\n+  tree arg;\n+  tree arg2;\n   tree type;\n-  tree args[2];\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n   if (expr->ts.type == BT_REAL)\n     {\n       switch (expr->ts.kind)\n@@ -1184,28 +1162,30 @@ gfc_conv_intrinsic_sign (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_call_expr (tmp, 2, args[0], args[1]);\n+      se->expr = build_function_call_expr (tmp, arg);\n       return;\n     }\n \n   /* Having excluded floating point types, we know we are now dealing\n      with signed integer types.  */\n-  type = TREE_TYPE (args[0]);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n \n-  /* Args[0] is used multiple times below.  */\n-  args[0] = gfc_evaluate_now (args[0], &se->pre);\n+  /* Arg is used multiple times below.  */\n+  arg = gfc_evaluate_now (arg, &se->pre);\n \n   /* Construct (A ^ B) >> 31, which generates a bit mask of all zeros if\n      the signs of A and B are the same, and of all ones if they differ.  */\n-  tmp = fold_build2 (BIT_XOR_EXPR, type, args[0], args[1]);\n+  tmp = fold_build2 (BIT_XOR_EXPR, type, arg, arg2);\n   tmp = fold_build2 (RSHIFT_EXPR, type, tmp,\n \t\t     build_int_cst (type, TYPE_PRECISION (type) - 1));\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n \n   /* Construct (A + tmp) ^ tmp, which is A if tmp is zero, and -A if tmp]\n      is all ones (i.e. -1).  */\n   se->expr = fold_build2 (BIT_XOR_EXPR, type,\n-\t\t\t  fold_build2 (PLUS_EXPR, type, args[0], tmp),\n+\t\t\t  fold_build2 (PLUS_EXPR, type, arg, tmp),\n \t\t\t  tmp);\n }\n \n@@ -1229,16 +1209,19 @@ gfc_conv_intrinsic_present (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_dprod (gfc_se * se, gfc_expr * expr)\n {\n+  tree arg;\n+  tree arg2;\n   tree type;\n-  tree args[2];\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n \n   /* Convert the args to double precision before multiplying.  */\n   type = gfc_typenode_for_spec (&expr->ts);\n-  args[0] = convert (type, args[0]);\n-  args[1] = convert (type, args[1]);\n-  se->expr = build2 (MULT_EXPR, type, args[0], args[1]);\n+  arg = convert (type, arg);\n+  arg2 = convert (type, arg2);\n+  se->expr = build2 (MULT_EXPR, type, arg, arg2);\n }\n \n \n@@ -1251,7 +1234,8 @@ gfc_conv_intrinsic_char (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree type;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n \n   /* We currently don't support character types != 1.  */\n   gcc_assert (expr->ts.kind == 1);\n@@ -1271,27 +1255,21 @@ gfc_conv_intrinsic_ctime (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n+  tree arglist;\n   tree type;\n   tree cond;\n   tree gfc_int8_type_node = gfc_get_int_type (8);\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n-  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int8_type_node, \"len\");\n \n-  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  tmp = gfc_conv_intrinsic_function_args (se, expr);\n+  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n+  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n+  arglist = chainon (arglist, tmp);\n \n-  fndecl = build_addr (gfor_fndecl_ctime, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ctime)),\n-\t\t\t  fndecl, num_args, args);\n+  tmp = build_function_call_expr (gfor_fndecl_ctime, arglist);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1312,27 +1290,21 @@ gfc_conv_intrinsic_fdate (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n+  tree arglist;\n   tree type;\n   tree cond;\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n-  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  tmp = gfc_conv_intrinsic_function_args (se, expr);\n+  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n+  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n+  arglist = chainon (arglist, tmp);\n \n-  fndecl = build_addr (gfor_fndecl_fdate, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_fdate)),\n-\t\t\t  fndecl, num_args, args);\n+  tmp = build_function_call_expr (gfor_fndecl_fdate, arglist);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1355,27 +1327,21 @@ gfc_conv_intrinsic_ttynam (gfc_se * se, gfc_expr * expr)\n   tree var;\n   tree len;\n   tree tmp;\n+  tree arglist;\n   tree type;\n   tree cond;\n-  tree fndecl;\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n-  args = alloca (sizeof (tree) * num_args);\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (var);\n-  args[1] = build_fold_addr_expr (len);\n+  tmp = gfc_conv_intrinsic_function_args (se, expr);\n+  arglist = gfc_chainon_list (NULL_TREE, build_fold_addr_expr (var));\n+  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n+  arglist = chainon (arglist, tmp);\n \n-  fndecl = build_addr (gfor_fndecl_ttynam, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_ttynam)),\n-\t\t\t  fndecl, num_args, args);\n+  tmp = build_function_call_expr (gfor_fndecl_ttynam, arglist);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -1415,18 +1381,13 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n   tree val;\n   tree thencase;\n   tree elsecase;\n+  tree arg;\n   tree type;\n-  tree *args;\n-  unsigned int num_args;\n-  unsigned int i;\n \n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * num_args);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n-  limit = args[0];\n+  limit = TREE_VALUE (arg);\n   if (TREE_TYPE (limit) != type)\n     limit = convert (type, limit);\n   /* Only evaluate the argument once.  */\n@@ -1435,9 +1396,9 @@ gfc_conv_intrinsic_minmax (gfc_se * se, gfc_expr * expr, int op)\n \n   mvar = gfc_create_var (type, \"M\");\n   elsecase = build2_v (MODIFY_EXPR, mvar, limit);\n-  for (i = 1; i < num_args; i++)\n+  for (arg = TREE_CHAIN (arg); arg != NULL_TREE; arg = TREE_CHAIN (arg))\n     {\n-      val = args[i];\n+      val = TREE_VALUE (arg);\n       if (TREE_TYPE (val) != type)\n \tval = convert (type, val);\n \n@@ -2301,15 +2262,18 @@ gfc_conv_intrinsic_minmaxval (gfc_se * se, gfc_expr * expr, int op)\n static void\n gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2];\n+  tree arg;\n+  tree arg2;\n   tree type;\n   tree tmp;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  type = TREE_TYPE (args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n \n-  tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n-  tmp = build2 (BIT_AND_EXPR, type, args[0], tmp);\n+  tmp = build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n+  tmp = build2 (BIT_AND_EXPR, type, arg, tmp);\n   tmp = fold_build2 (NE_EXPR, boolean_type_node, tmp,\n \t\t     build_int_cst (type, 0));\n   type = gfc_typenode_for_spec (&expr->ts);\n@@ -2320,10 +2284,16 @@ gfc_conv_intrinsic_btest (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_bitop (gfc_se * se, gfc_expr * expr, int op)\n {\n-  tree args[2];\n+  tree arg;\n+  tree arg2;\n+  tree type;\n+\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  se->expr = fold_build2 (op, TREE_TYPE (args[0]), args[0], args[1]);\n+  se->expr = fold_build2 (op, type, arg, arg2);\n }\n \n /* Bitwise not.  */\n@@ -2332,51 +2302,62 @@ gfc_conv_intrinsic_not (gfc_se * se, gfc_expr * expr)\n {\n   tree arg;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (arg);\n+\n   se->expr = build1 (BIT_NOT_EXPR, TREE_TYPE (arg), arg);\n }\n \n /* Set or clear a single bit.  */\n static void\n gfc_conv_intrinsic_singlebitop (gfc_se * se, gfc_expr * expr, int set)\n {\n-  tree args[2];\n+  tree arg;\n+  tree arg2;\n   tree type;\n   tree tmp;\n   int op;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  type = TREE_TYPE (args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n \n-  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), args[1]);\n+  tmp = fold_build2 (LSHIFT_EXPR, type, build_int_cst (type, 1), arg2);\n   if (set)\n     op = BIT_IOR_EXPR;\n   else\n     {\n       op = BIT_AND_EXPR;\n       tmp = fold_build1 (BIT_NOT_EXPR, type, tmp);\n     }\n-  se->expr = fold_build2 (op, type, args[0], tmp);\n+  se->expr = fold_build2 (op, type, arg, tmp);\n }\n \n /* Extract a sequence of bits.\n     IBITS(I, POS, LEN) = (I >> POS) & ~((~0) << LEN).  */\n static void\n gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[3];\n+  tree arg;\n+  tree arg2;\n+  tree arg3;\n   tree type;\n   tree tmp;\n   tree mask;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n-  type = TREE_TYPE (args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_CHAIN (arg);\n+  arg3 = TREE_VALUE (TREE_CHAIN (arg2));\n+  arg = TREE_VALUE (arg);\n+  arg2 = TREE_VALUE (arg2);\n+  type = TREE_TYPE (arg);\n \n   mask = build_int_cst (type, -1);\n-  mask = build2 (LSHIFT_EXPR, type, mask, args[2]);\n+  mask = build2 (LSHIFT_EXPR, type, mask, arg3);\n   mask = build1 (BIT_NOT_EXPR, type, mask);\n \n-  tmp = build2 (RSHIFT_EXPR, type, args[0], args[1]);\n+  tmp = build2 (RSHIFT_EXPR, type, arg, arg2);\n \n   se->expr = fold_build2 (BIT_AND_EXPR, type, tmp, mask);\n }\n@@ -2386,12 +2367,15 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n {\n-  tree args[2];\n+  tree arg;\n+  tree arg2;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n \n   se->expr = fold_build2 (right_shift ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t  TREE_TYPE (args[0]), args[0], args[1]);\n+\t\t\t  TREE_TYPE (arg), arg, arg2);\n }\n \n /* ISHFT (I, SHIFT) = (abs (shift) >= BIT_SIZE (i))\n@@ -2401,7 +2385,8 @@ gfc_conv_intrinsic_rlshift (gfc_se * se, gfc_expr * expr, int right_shift)\n static void\n gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2];\n+  tree arg;\n+  tree arg2;\n   tree type;\n   tree utype;\n   tree tmp;\n@@ -2411,31 +2396,33 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n   tree lshift;\n   tree rshift;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  type = TREE_TYPE (args[0]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arg));\n+  arg = TREE_VALUE (arg);\n+  type = TREE_TYPE (arg);\n   utype = unsigned_type_for (type);\n \n-  width = fold_build1 (ABS_EXPR, TREE_TYPE (args[1]), args[1]);\n+  width = fold_build1 (ABS_EXPR, TREE_TYPE (arg2), arg2);\n \n   /* Left shift if positive.  */\n-  lshift = fold_build2 (LSHIFT_EXPR, type, args[0], width);\n+  lshift = fold_build2 (LSHIFT_EXPR, type, arg, width);\n \n   /* Right shift if negative.\n      We convert to an unsigned type because we want a logical shift.\n      The standard doesn't define the case of shifting negative\n      numbers, and we try to be compatible with other compilers, most\n      notably g77, here.  */\n   rshift = fold_convert (type, build2 (RSHIFT_EXPR, utype, \n-\t\t\t\t       convert (utype, args[0]), width));\n+\t\t\t\t       convert (utype, arg), width));\n \n-  tmp = fold_build2 (GE_EXPR, boolean_type_node, args[1],\n-\t\t     build_int_cst (TREE_TYPE (args[1]), 0));\n+  tmp = fold_build2 (GE_EXPR, boolean_type_node, arg2,\n+\t\t     build_int_cst (TREE_TYPE (arg2), 0));\n   tmp = fold_build3 (COND_EXPR, type, tmp, lshift, rshift);\n \n   /* The Fortran standard allows shift widths <= BIT_SIZE(I), whereas\n      gcc requires a shift width < BIT_SIZE(I), so we have to catch this\n      special case.  */\n-  num_bits = build_int_cst (TREE_TYPE (args[0]), TYPE_PRECISION (type));\n+  num_bits = build_int_cst (TREE_TYPE (arg2), TYPE_PRECISION (type));\n   cond = fold_build2 (GE_EXPR, boolean_type_node, width, num_bits);\n \n   se->expr = fold_build3 (COND_EXPR, type, cond,\n@@ -2446,37 +2433,38 @@ gfc_conv_intrinsic_ishft (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n {\n-  tree *args;\n+  tree arg;\n+  tree arg2;\n+  tree arg3;\n   tree type;\n   tree tmp;\n   tree lrot;\n   tree rrot;\n   tree zero;\n-  unsigned int num_args;\n \n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * num_args);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n-\n-  if (num_args == 3)\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_CHAIN (arg);\n+  arg3 = TREE_CHAIN (arg2);\n+  if (arg3)\n     {\n       /* Use a library function for the 3 parameter version.  */\n       tree int4type = gfc_get_int_type (4);\n \n-      type = TREE_TYPE (args[0]);\n+      type = TREE_TYPE (TREE_VALUE (arg));\n       /* We convert the first argument to at least 4 bytes, and\n \t convert back afterwards.  This removes the need for library\n \t functions for all argument sizes, and function will be\n \t aligned to at least 32 bits, so there's no loss.  */\n       if (expr->ts.kind < 4)\n-\targs[0] = convert (int4type, args[0]);\n-\n+\t{\n+\t  tmp = convert (int4type, TREE_VALUE (arg));\n+\t  TREE_VALUE (arg) = tmp;\n+\t}\n       /* Convert the SHIFT and SIZE args to INTEGER*4 otherwise we would\n          need loads of library  functions.  They cannot have values >\n \t BIT_SIZE (I) so the conversion is safe.  */\n-      args[1] = convert (int4type, args[1]);\n-      args[2] = convert (int4type, args[2]);\n+      TREE_VALUE (arg2) = convert (int4type, TREE_VALUE (arg2));\n+      TREE_VALUE (arg3) = convert (int4type, TREE_VALUE (arg3));\n \n       switch (expr->ts.kind)\n \t{\n@@ -2494,30 +2482,32 @@ gfc_conv_intrinsic_ishftc (gfc_se * se, gfc_expr * expr)\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n-      se->expr = build_call_expr (tmp, 3, args[0], args[1], args[2]);\n+      se->expr = build_function_call_expr (tmp, arg);\n       /* Convert the result back to the original type, if we extended\n \t the first argument's width above.  */\n       if (expr->ts.kind < 4)\n \tse->expr = convert (type, se->expr);\n \n       return;\n     }\n-  type = TREE_TYPE (args[0]);\n+  arg = TREE_VALUE (arg);\n+  arg2 = TREE_VALUE (arg2);\n+  type = TREE_TYPE (arg);\n \n   /* Rotate left if positive.  */\n-  lrot = fold_build2 (LROTATE_EXPR, type, args[0], args[1]);\n+  lrot = fold_build2 (LROTATE_EXPR, type, arg, arg2);\n \n   /* Rotate right if negative.  */\n-  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (args[1]), args[1]);\n-  rrot = fold_build2 (RROTATE_EXPR, type, args[0], tmp);\n+  tmp = fold_build1 (NEGATE_EXPR, TREE_TYPE (arg2), arg2);\n+  rrot = fold_build2 (RROTATE_EXPR, type, arg, tmp);\n \n-  zero = build_int_cst (TREE_TYPE (args[1]), 0);\n-  tmp = fold_build2 (GT_EXPR, boolean_type_node, args[1], zero);\n+  zero = build_int_cst (TREE_TYPE (arg2), 0);\n+  tmp = fold_build2 (GT_EXPR, boolean_type_node, arg2, zero);\n   rrot = fold_build3 (COND_EXPR, type, tmp, lrot, rrot);\n \n   /* Do nothing if shift == 0.  */\n-  tmp = fold_build2 (EQ_EXPR, boolean_type_node, args[1], zero);\n-  se->expr = fold_build3 (COND_EXPR, type, tmp, args[0], rrot);\n+  tmp = fold_build2 (EQ_EXPR, boolean_type_node, arg2, zero);\n+  se->expr = fold_build3 (COND_EXPR, type, tmp, arg, rrot);\n }\n \n /* The length of a character string.  */\n@@ -2590,12 +2580,12 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_len_trim (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2];\n+  tree args;\n   tree type;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n   type = gfc_typenode_for_spec (&expr->ts);\n-  se->expr = build_call_expr (gfor_fndecl_string_len_trim, 2, args[0], args[1]);\n+  se->expr = build_function_call_expr (gfor_fndecl_string_len_trim, args);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -2606,45 +2596,44 @@ static void\n gfc_conv_intrinsic_index (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n+  tree args;\n+  tree back;\n   tree type;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * 5);\n+  tree tmp;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n   type = gfc_typenode_for_spec (&expr->ts);\n-\n-  if (num_args == 4)\n-    args[4] = build_int_cst (logical4_type_node, 0);\n+  tmp = gfc_advance_chain (args, 3);\n+  if (TREE_CHAIN (tmp) == NULL_TREE)\n+    {\n+      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n+\t\t\tNULL_TREE);\n+      TREE_CHAIN (tmp) = back;\n+    }\n   else\n     {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n+      back = TREE_CHAIN (tmp);\n+      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n     }\n \n-  fndecl = build_addr (gfor_fndecl_string_index, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_index)),\n-\t\t\t       fndecl, 5, args);\n+  se->expr = build_function_call_expr (gfor_fndecl_string_index, args);\n   se->expr = convert (type, se->expr);\n-\n }\n \n /* The ascii value for a single character.  */\n static void\n gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[2];\n+  tree arg;\n   tree type;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 2);\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (args[1])));\n-  args[1] = build1 (NOP_EXPR, pchar_type_node, args[1]);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n+  arg = TREE_VALUE (TREE_CHAIN (arg));\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (arg)));\n+  arg = build1 (NOP_EXPR, pchar_type_node, arg);\n   type = gfc_typenode_for_spec (&expr->ts);\n \n-  se->expr = build_fold_indirect_ref (args[1]);\n+  se->expr = build_fold_indirect_ref (arg);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -2654,33 +2643,32 @@ gfc_conv_intrinsic_ichar (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_merge (gfc_se * se, gfc_expr * expr)\n {\n+  tree arg;\n   tree tsource;\n   tree fsource;\n   tree mask;\n   tree type;\n   tree len;\n-  tree *args;\n-  unsigned int num_args;\n \n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * num_args);\n-\n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  arg = gfc_conv_intrinsic_function_args (se, expr);\n   if (expr->ts.type != BT_CHARACTER)\n     {\n-      tsource = args[0];\n-      fsource = args[1];\n-      mask = args[2];\n+      tsource = TREE_VALUE (arg);\n+      arg = TREE_CHAIN (arg);\n+      fsource = TREE_VALUE (arg);\n+      mask = TREE_VALUE (TREE_CHAIN (arg));\n     }\n   else\n     {\n       /* We do the same as in the non-character case, but the argument\n \t list is different because of the string length arguments. We\n \t also have to set the string length for the result.  */\n-      len = args[0];\n-      tsource = args[1];\n-      fsource = args[3];\n-      mask = args[4];\n+      len = TREE_VALUE (arg);\n+      arg = TREE_CHAIN (arg);\n+      tsource = TREE_VALUE (arg);\n+      arg = TREE_CHAIN (TREE_CHAIN (arg));\n+      fsource = TREE_VALUE (arg);\n+      mask = TREE_VALUE (TREE_CHAIN (arg));\n \n       se->string_length = len;\n     }\n@@ -2837,11 +2825,16 @@ static void\n gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n {\n   tree type;\n-  tree args[4];\n+  tree args;\n+  tree arg2;\n+\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n+  arg2 = TREE_CHAIN (TREE_CHAIN (args));\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, 4);\n+  se->expr = gfc_build_compare_string (TREE_VALUE (args),\n+\t\tTREE_VALUE (TREE_CHAIN (args)), TREE_VALUE (arg2),\n+\t\tTREE_VALUE (TREE_CHAIN (arg2)));\n \n-  se->expr = gfc_build_compare_string (args[0], args[1], args[2], args[3]);\n   type = gfc_typenode_for_spec (&expr->ts);\n   se->expr = fold_build2 (op, type, se->expr,\n \t\t     build_int_cst (TREE_TYPE (se->expr), 0));\n@@ -2851,20 +2844,20 @@ gfc_conv_intrinsic_strcmp (gfc_se * se, gfc_expr * expr, int op)\n static void\n gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n {\n-  tree args[3];\n+  tree args;\n   tree len;\n   tree type;\n   tree var;\n   tree tmp;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &args[1], 2);\n-  len = args[1];\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n+  len = TREE_VALUE (args);\n \n-  type = TREE_TYPE (args[2]);\n+  type = TREE_TYPE (TREE_VALUE (TREE_CHAIN (args)));\n   var = gfc_conv_string_tmp (se, type, len);\n-  args[0] = var;\n+  args = tree_cons (NULL_TREE, var, args);\n \n-  tmp = build_call_expr (fndecl, 3, args[0], args[1], args[2]);\n+  tmp = build_function_call_expr (fndecl, args);\n   gfc_add_expr_to_block (&se->pre, tmp);\n   se->expr = var;\n   se->string_length = len;\n@@ -3313,28 +3306,27 @@ static void\n gfc_conv_intrinsic_scan (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n+  tree args;\n+  tree back;\n   tree type;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * 5);\n+  tree tmp;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n   type = gfc_typenode_for_spec (&expr->ts);\n-\n-  if (num_args == 4)\n-    args[4] = build_int_cst (logical4_type_node, 0);\n+  tmp = gfc_advance_chain (args, 3);\n+  if (TREE_CHAIN (tmp) == NULL_TREE)\n+    {\n+      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n+\t\t\tNULL_TREE);\n+      TREE_CHAIN (tmp) = back;\n+    }\n   else\n     {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n+      back = TREE_CHAIN (tmp);\n+      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n     }\n \n-  fndecl = build_addr (gfor_fndecl_string_scan, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_scan)),\n-\t\t\t       fndecl, 5, args);\n+  se->expr = build_function_call_expr (gfor_fndecl_string_scan, args);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3347,29 +3339,27 @@ static void\n gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n {\n   tree logical4_type_node = gfc_get_logical_type (4);\n+  tree args;\n+  tree back;\n   tree type;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n-\n-  num_args = gfc_intrinsic_argument_list_length (expr);\n-  args = alloca (sizeof (tree) * 5);\n+  tree tmp;\n \n-  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n   type = gfc_typenode_for_spec (&expr->ts);\n-\n-  if (num_args == 4)\n-    args[4] = build_int_cst (logical4_type_node, 0);\n+  tmp = gfc_advance_chain (args, 3);\n+  if (TREE_CHAIN (tmp) == NULL_TREE)\n+    {\n+      back = tree_cons (NULL_TREE, build_int_cst (logical4_type_node, 0),\n+\t\t\tNULL_TREE);\n+      TREE_CHAIN (tmp) = back;\n+    }\n   else\n     {\n-      gcc_assert (num_args == 5);\n-      args[4] = convert (logical4_type_node, args[4]);\n+      back = TREE_CHAIN (tmp);\n+      TREE_VALUE (back) = convert (logical4_type_node, TREE_VALUE (back));\n     }\n \n-  fndecl = build_addr (gfor_fndecl_string_verify, current_function_decl);\n-  se->expr = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_verify)),\n-\t\t\t       fndecl, 5, args);\n-\n+  se->expr = build_function_call_expr (gfor_fndecl_string_verify, args);\n   se->expr = convert (type, se->expr);\n }\n \n@@ -3379,11 +3369,12 @@ gfc_conv_intrinsic_verify (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_si_kind (gfc_se * se, gfc_expr * expr)\n {\n-  tree arg;\n+  tree args;\n \n-  gfc_conv_intrinsic_function_args (se, expr, &arg, 1);\n-  arg = build_fold_addr_expr (arg);\n-  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, arg);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n+  args = TREE_VALUE (args);\n+  args = build_fold_addr_expr (args);\n+  se->expr = build_call_expr (gfor_fndecl_si_kind, 1, args);\n }\n \n /* Generate code for SELECTED_REAL_KIND (P, R) intrinsic function.  */\n@@ -3424,27 +3415,23 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n   tree len;\n   tree addr;\n   tree tmp;\n+  tree arglist;\n   tree type;\n   tree cond;\n-  tree fndecl;\n-  tree *args;\n-  unsigned int num_args;\n \n-  num_args = gfc_intrinsic_argument_list_length (expr) + 2;\n-  args = alloca (sizeof (tree) * num_args);\n+  arglist = NULL_TREE;\n \n   type = build_pointer_type (gfc_character1_type_node);\n   var = gfc_create_var (type, \"pstr\");\n   addr = gfc_build_addr_expr (ppvoid_type_node, var);\n   len = gfc_create_var (gfc_int4_type_node, \"len\");\n \n-  gfc_conv_intrinsic_function_args (se, expr, &args[2], num_args - 2);\n-  args[0] = build_fold_addr_expr (len);\n-  args[1] = addr;\n+  tmp = gfc_conv_intrinsic_function_args (se, expr);\n+  arglist = gfc_chainon_list (arglist, build_fold_addr_expr (len));\n+  arglist = gfc_chainon_list (arglist, addr);\n+  arglist = chainon (arglist, tmp);\n \n-  fndecl = build_addr (gfor_fndecl_string_trim, current_function_decl);\n-  tmp = build_call_array (TREE_TYPE (TREE_TYPE (gfor_fndecl_string_trim)),\n-\t\t\t  fndecl, num_args, args);\n+  tmp = build_function_call_expr (gfor_fndecl_string_trim, arglist);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n   /* Free the temporary afterwards, if necessary.  */\n@@ -3464,16 +3451,18 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n {\n-  tree args[3], ncopies, dest, dlen, src, slen, ncopies_type;\n+  tree args, ncopies, dest, dlen, src, slen, ncopies_type;\n   tree type, cond, tmp, count, exit_label, n, max, largest;\n   stmtblock_t block, body;\n   int i;\n \n   /* Get the arguments.  */\n-  gfc_conv_intrinsic_function_args (se, expr, args, 3);\n-  slen = fold_convert (size_type_node, gfc_evaluate_now (args[0], &se->pre));\n-  src = args[1];\n-  ncopies = gfc_evaluate_now (args[2], &se->pre);\n+  args = gfc_conv_intrinsic_function_args (se, expr);\n+  slen = fold_convert (size_type_node, gfc_evaluate_now (TREE_VALUE (args),\n+\t\t\t\t\t\t\t &se->pre));\n+  src = TREE_VALUE (TREE_CHAIN (args));\n+  ncopies = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+  ncopies = gfc_evaluate_now (ncopies, &se->pre);\n   ncopies_type = TREE_TYPE (ncopies);\n \n   /* Check that NCOPIES is not negative.  */"}]}