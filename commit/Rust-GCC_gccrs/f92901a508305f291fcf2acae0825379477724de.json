{"sha": "f92901a508305f291fcf2acae0825379477724de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkyOTAxYTUwODMwNWYyOTFmY2YyYWNhZTA4MjUzNzk0Nzc3MjRkZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-08T12:42:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-09-20T06:51:07Z"}, "message": "tree-optimization/65206 - dependence analysis on mixed pointer/array\n\nThis adds the capability to analyze the dependence of mixed\npointer/array accesses.  The example is from where using a masked\nload/store creates the pointer-based access when an otherwise\nunconditional access is array based.  Other examples would include\naccesses to an array mixed with accesses from inlined helpers\nthat work on pointers.\n\nThe idea is quite simple and old - analyze the data-ref indices\nas if the reference was pointer-based.  The following change does\nthis by changing dr_analyze_indices to work on the indices\nsub-structure and storing an alternate indices substructure in\neach data reference.  That alternate set of indices is analyzed\nlazily by initialize_data_dependence_relation when it fails to\nmatch-up the main set of indices of two data references.\ninitialize_data_dependence_relation is refactored into a head\nand a tail worker and changed to work on one of the indices\nstructures and thus away from using DR_* access macros which\ncontinue to reference the main indices substructure.\n\nThere are quite some vectorization and loop distribution opportunities\nunleashed in SPEC CPU 2017, notably 520.omnetpp_r, 548.exchange2_r,\n510.parest_r, 511.povray_r, 521.wrf_r, 526.blender_r, 527.cam4_r and\n544.nab_r see amendments in what they report with -fopt-info-loop while\nthe rest of the specrate set sees no changes there.  Measuring runtime\nfor the set where changes were reported reveals nothing off-noise\nbesides 511.povray_r which seems to regress slightly for me\n(on a Zen2 machine with -Ofast -march=native).\n\n2021-09-08  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/65206\n\t* tree-data-ref.h (struct data_reference): Add alt_indices,\n\torder it last.\n\t* tree-data-ref.c (free_data_ref): Release alt_indices.\n\t(dr_analyze_indices): Work on struct indices and get DR_REF as tree.\n\t(create_data_ref): Adjust.\n\t(initialize_data_dependence_relation): Split into head\n\tand tail.  When the base objects fail to match up try\n\tagain with pointer-based analysis of indices.\n\t* tree-vectorizer.c (vec_info_shared::check_datarefs): Do\n\tnot compare the lazily computed alternate set of indices.\n\n\t* gcc.dg/torture/20210916.c: New testcase.\n\t* gcc.dg/vect/pr65206.c: Likewise.", "tree": {"sha": "79351b7f3d6247d38f201375c87c3d1307c6d6af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79351b7f3d6247d38f201375c87c3d1307c6d6af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f92901a508305f291fcf2acae0825379477724de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f92901a508305f291fcf2acae0825379477724de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f92901a508305f291fcf2acae0825379477724de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f92901a508305f291fcf2acae0825379477724de/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abdf63d782cba82b5ecf264248518cbb065650ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abdf63d782cba82b5ecf264248518cbb065650ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abdf63d782cba82b5ecf264248518cbb065650ed"}], "stats": {"total": 228, "additions": 168, "deletions": 60}, "files": [{"sha": "0ea6d45e463dc180c621270de6c1562ccbe5996e", "filename": "gcc/testsuite/gcc.dg/torture/20210916.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20210916.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20210916.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20210916.c?ref=f92901a508305f291fcf2acae0825379477724de", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+\n+typedef union tree_node *tree;\n+struct tree_base {\n+  unsigned : 1;\n+  unsigned lang_flag_2 : 1;\n+};\n+struct tree_type {\n+  tree main_variant;\n+};\n+union tree_node {\n+  struct tree_base base;\n+  struct tree_type type;\n+};\n+tree finish_struct_t, finish_struct_x;\n+void finish_struct()\n+{\n+  for (; finish_struct_t->type.main_variant;)\n+    finish_struct_x->base.lang_flag_2 = 0;\n+}"}, {"sha": "3b6262622c00e38655c55fda683a8daf1b6d27aa", "filename": "gcc/testsuite/gcc.dg/vect/pr65206.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65206.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65206.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65206.c?ref=f92901a508305f291fcf2acae0825379477724de", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-additional-options \"-fno-trapping-math -fno-allow-store-data-races\" } */\n+/* { dg-additional-options \"-mavx\" { target avx } } */\n+\n+#define N 1024\n+\n+double a[N], b[N];\n+\n+void foo ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    if (b[i] < 3.)\n+      a[i] += b[i];\n+}\n+\n+/* We get a .MASK_STORE because while the load of a[i] does not trap\n+   the store would introduce store data races.  Make sure we still\n+   can handle the data dependence with zero distance.  */\n+\n+/* { dg-final { scan-tree-dump-not \"versioning for alias required\" \"vect\" { target { vect_masked_store || avx } } } } */\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops in function\" \"vect\" { target { vect_masked_store || avx } } } } */"}, {"sha": "18307a554fc03f471cfa2f5e99f6b201ef667002", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 117, "deletions": 57, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f92901a508305f291fcf2acae0825379477724de", "patch": "@@ -99,6 +99,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"internal-fn.h\"\n #include \"vr-values.h\"\n #include \"range-op.h\"\n+#include \"tree-ssa-loop-ivopts.h\"\n \n static struct datadep_stats\n {\n@@ -1300,22 +1301,18 @@ base_supports_access_fn_components_p (tree base)\n    DR, analyzed in LOOP and instantiated before NEST.  */\n \n static void\n-dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n+dr_analyze_indices (struct indices *dri, tree ref, edge nest, loop_p loop)\n {\n-  vec<tree> access_fns = vNULL;\n-  tree ref, op;\n-  tree base, off, access_fn;\n-\n   /* If analyzing a basic-block there are no indices to analyze\n      and thus no access functions.  */\n   if (!nest)\n     {\n-      DR_BASE_OBJECT (dr) = DR_REF (dr);\n-      DR_ACCESS_FNS (dr).create (0);\n+      dri->base_object = ref;\n+      dri->access_fns.create (0);\n       return;\n     }\n \n-  ref = DR_REF (dr);\n+  vec<tree> access_fns = vNULL;\n \n   /* REALPART_EXPR and IMAGPART_EXPR can be handled like accesses\n      into a two element array with a constant index.  The base is\n@@ -1338,8 +1335,8 @@ dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n     {\n       if (TREE_CODE (ref) == ARRAY_REF)\n \t{\n-\t  op = TREE_OPERAND (ref, 1);\n-\t  access_fn = analyze_scalar_evolution (loop, op);\n+\t  tree op = TREE_OPERAND (ref, 1);\n+\t  tree access_fn = analyze_scalar_evolution (loop, op);\n \t  access_fn = instantiate_scev (nest, loop, access_fn);\n \t  access_fns.safe_push (access_fn);\n \t}\n@@ -1370,16 +1367,16 @@ dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n      analyzed nest, add it as an additional independent access-function.  */\n   if (TREE_CODE (ref) == MEM_REF)\n     {\n-      op = TREE_OPERAND (ref, 0);\n-      access_fn = analyze_scalar_evolution (loop, op);\n+      tree op = TREE_OPERAND (ref, 0);\n+      tree access_fn = analyze_scalar_evolution (loop, op);\n       access_fn = instantiate_scev (nest, loop, access_fn);\n       if (TREE_CODE (access_fn) == POLYNOMIAL_CHREC)\n \t{\n-\t  tree orig_type;\n \t  tree memoff = TREE_OPERAND (ref, 1);\n-\t  base = initial_condition (access_fn);\n-\t  orig_type = TREE_TYPE (base);\n+\t  tree base = initial_condition (access_fn);\n+\t  tree orig_type = TREE_TYPE (base);\n \t  STRIP_USELESS_TYPE_CONVERSION (base);\n+\t  tree off;\n \t  split_constant_offset (base, &base, &off);\n \t  STRIP_USELESS_TYPE_CONVERSION (base);\n \t  /* Fold the MEM_REF offset into the evolutions initial\n@@ -1424,7 +1421,7 @@ dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n \t\t\t\t base, memoff);\n \t  MR_DEPENDENCE_CLIQUE (ref) = MR_DEPENDENCE_CLIQUE (old);\n \t  MR_DEPENDENCE_BASE (ref) = MR_DEPENDENCE_BASE (old);\n-\t  DR_UNCONSTRAINED_BASE (dr) = true;\n+\t  dri->unconstrained_base = true;\n \t  access_fns.safe_push (access_fn);\n \t}\n     }\n@@ -1436,8 +1433,8 @@ dr_analyze_indices (struct data_reference *dr, edge nest, loop_p loop)\n \t\t    build_int_cst (reference_alias_ptr_type (ref), 0));\n     }\n \n-  DR_BASE_OBJECT (dr) = ref;\n-  DR_ACCESS_FNS (dr) = access_fns;\n+  dri->base_object = ref;\n+  dri->access_fns = access_fns;\n }\n \n /* Extracts the alias analysis information from the memory reference DR.  */\n@@ -1463,6 +1460,8 @@ void\n free_data_ref (data_reference_p dr)\n {\n   DR_ACCESS_FNS (dr).release ();\n+  if (dr->alt_indices.base_object)\n+    dr->alt_indices.access_fns.release ();\n   free (dr);\n }\n \n@@ -1497,7 +1496,7 @@ create_data_ref (edge nest, loop_p loop, tree memref, gimple *stmt,\n \n   dr_analyze_innermost (&DR_INNERMOST (dr), memref,\n \t\t\tnest != NULL ? loop : NULL, stmt);\n-  dr_analyze_indices (dr, nest, loop);\n+  dr_analyze_indices (&dr->indices, DR_REF (dr), nest, loop);\n   dr_analyze_alias (dr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3066,41 +3065,30 @@ access_fn_components_comparable_p (tree ref_a, tree ref_b)\n \t\t\t     TREE_TYPE (TREE_OPERAND (ref_b, 0)));\n }\n \n-/* Initialize a data dependence relation between data accesses A and\n-   B.  NB_LOOPS is the number of loops surrounding the references: the\n-   size of the classic distance/direction vectors.  */\n+/* Initialize a data dependence relation RES in LOOP_NEST.  USE_ALT_INDICES\n+   is true when the main indices of A and B were not comparable so we try again\n+   with alternate indices computed on an indirect reference.  */\n \n struct data_dependence_relation *\n-initialize_data_dependence_relation (struct data_reference *a,\n-\t\t\t\t     struct data_reference *b,\n- \t\t\t\t     vec<loop_p> loop_nest)\n+initialize_data_dependence_relation (struct data_dependence_relation *res,\n+\t\t\t\t     vec<loop_p> loop_nest,\n+\t\t\t\t     bool use_alt_indices)\n {\n-  struct data_dependence_relation *res;\n+  struct data_reference *a = DDR_A (res);\n+  struct data_reference *b = DDR_B (res);\n   unsigned int i;\n \n-  res = XCNEW (struct data_dependence_relation);\n-  DDR_A (res) = a;\n-  DDR_B (res) = b;\n-  DDR_LOOP_NEST (res).create (0);\n-  DDR_SUBSCRIPTS (res).create (0);\n-  DDR_DIR_VECTS (res).create (0);\n-  DDR_DIST_VECTS (res).create (0);\n-\n-  if (a == NULL || b == NULL)\n+  struct indices *indices_a = &a->indices;\n+  struct indices *indices_b = &b->indices;\n+  if (use_alt_indices)\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n-      return res;\n+      if (TREE_CODE (DR_REF (a)) != MEM_REF)\n+\tindices_a = &a->alt_indices;\n+      if (TREE_CODE (DR_REF (b)) != MEM_REF)\n+\tindices_b = &b->alt_indices;\n     }\n-\n-  /* If the data references do not alias, then they are independent.  */\n-  if (!dr_may_alias_p (a, b, loop_nest.exists () ? loop_nest[0] : NULL))\n-    {\n-      DDR_ARE_DEPENDENT (res) = chrec_known;\n-      return res;\n-    }\n-\n-  unsigned int num_dimensions_a = DR_NUM_DIMENSIONS (a);\n-  unsigned int num_dimensions_b = DR_NUM_DIMENSIONS (b);\n+  unsigned int num_dimensions_a = indices_a->access_fns.length ();\n+  unsigned int num_dimensions_b = indices_b->access_fns.length ();\n   if (num_dimensions_a == 0 || num_dimensions_b == 0)\n     {\n       DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n@@ -3125,9 +3113,9 @@ initialize_data_dependence_relation (struct data_reference *a,\n \n      the a and b accesses have a single ARRAY_REF component reference [0]\n      but have two subscripts.  */\n-  if (DR_UNCONSTRAINED_BASE (a))\n+  if (indices_a->unconstrained_base)\n     num_dimensions_a -= 1;\n-  if (DR_UNCONSTRAINED_BASE (b))\n+  if (indices_b->unconstrained_base)\n     num_dimensions_b -= 1;\n \n   /* These structures describe sequences of component references in\n@@ -3210,6 +3198,10 @@ initialize_data_dependence_relation (struct data_reference *a,\n         B: [3, 4]  (i.e. s.e)  */\n   while (index_a < num_dimensions_a && index_b < num_dimensions_b)\n     {\n+      /* The alternate indices form always has a single dimension\n+\t with unconstrained base.  */\n+      gcc_assert (!use_alt_indices);\n+\n       /* REF_A and REF_B must be one of the component access types\n \t allowed by dr_analyze_indices.  */\n       gcc_checking_assert (access_fn_component_p (ref_a));\n@@ -3280,11 +3272,12 @@ initialize_data_dependence_relation (struct data_reference *a,\n   /* See whether FULL_SEQ ends at the base and whether the two bases\n      are equal.  We do not care about TBAA or alignment info so we can\n      use OEP_ADDRESS_OF to avoid false negatives.  */\n-  tree base_a = DR_BASE_OBJECT (a);\n-  tree base_b = DR_BASE_OBJECT (b);\n+  tree base_a = indices_a->base_object;\n+  tree base_b = indices_b->base_object;\n   bool same_base_p = (full_seq.start_a + full_seq.length == num_dimensions_a\n \t\t      && full_seq.start_b + full_seq.length == num_dimensions_b\n-\t\t      && DR_UNCONSTRAINED_BASE (a) == DR_UNCONSTRAINED_BASE (b)\n+\t\t      && (indices_a->unconstrained_base\n+\t\t\t  == indices_b->unconstrained_base)\n \t\t      && operand_equal_p (base_a, base_b, OEP_ADDRESS_OF)\n \t\t      && (types_compatible_p (TREE_TYPE (base_a),\n \t\t\t\t\t      TREE_TYPE (base_b))\n@@ -3323,7 +3316,7 @@ initialize_data_dependence_relation (struct data_reference *a,\n      both lvalues are distinct from the object's declared type.  */\n   if (same_base_p)\n     {\n-      if (DR_UNCONSTRAINED_BASE (a))\n+      if (indices_a->unconstrained_base)\n \tfull_seq.length += 1;\n     }\n   else\n@@ -3332,8 +3325,41 @@ initialize_data_dependence_relation (struct data_reference *a,\n   /* Punt if we didn't find a suitable sequence.  */\n   if (full_seq.length == 0)\n     {\n-      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n-      return res;\n+      if (use_alt_indices\n+\t  || (TREE_CODE (DR_REF (a)) == MEM_REF\n+\t      && TREE_CODE (DR_REF (b)) == MEM_REF)\n+\t  || may_be_nonaddressable_p (DR_REF (a))\n+\t  || may_be_nonaddressable_p (DR_REF (b)))\n+\t{\n+\t  /* Fully exhausted possibilities.  */\n+\t  DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n+\t  return res;\n+\t}\n+\n+      /* Try evaluating both DRs as dereferences of pointers.  */\n+      if (!a->alt_indices.base_object\n+\t  && TREE_CODE (DR_REF (a)) != MEM_REF)\n+\t{\n+\t  tree alt_ref = build2 (MEM_REF, TREE_TYPE (DR_REF (a)),\n+\t\t\t\t build1 (ADDR_EXPR, ptr_type_node, DR_REF (a)),\n+\t\t\t\t build_int_cst\n+\t\t\t\t   (reference_alias_ptr_type (DR_REF (a)), 0));\n+\t  dr_analyze_indices (&a->alt_indices, alt_ref,\n+\t\t\t      loop_preheader_edge (loop_nest[0]),\n+\t\t\t      loop_containing_stmt (DR_STMT (a)));\n+\t}\n+      if (!b->alt_indices.base_object\n+\t  && TREE_CODE (DR_REF (b)) != MEM_REF)\n+\t{\n+\t  tree alt_ref = build2 (MEM_REF, TREE_TYPE (DR_REF (b)),\n+\t\t\t\t build1 (ADDR_EXPR, ptr_type_node, DR_REF (b)),\n+\t\t\t\t build_int_cst\n+\t\t\t\t   (reference_alias_ptr_type (DR_REF (b)), 0));\n+\t  dr_analyze_indices (&b->alt_indices, alt_ref,\n+\t\t\t      loop_preheader_edge (loop_nest[0]),\n+\t\t\t      loop_containing_stmt (DR_STMT (b)));\n+\t}\n+      return initialize_data_dependence_relation (res, loop_nest, true);\n     }\n \n   if (!same_base_p)\n@@ -3381,8 +3407,8 @@ initialize_data_dependence_relation (struct data_reference *a,\n       struct subscript *subscript;\n \n       subscript = XNEW (struct subscript);\n-      SUB_ACCESS_FN (subscript, 0) = DR_ACCESS_FN (a, full_seq.start_a + i);\n-      SUB_ACCESS_FN (subscript, 1) = DR_ACCESS_FN (b, full_seq.start_b + i);\n+      SUB_ACCESS_FN (subscript, 0) = indices_a->access_fns[full_seq.start_a + i];\n+      SUB_ACCESS_FN (subscript, 1) = indices_b->access_fns[full_seq.start_b + i];\n       SUB_CONFLICTS_IN_A (subscript) = conflict_fn_not_known ();\n       SUB_CONFLICTS_IN_B (subscript) = conflict_fn_not_known ();\n       SUB_LAST_CONFLICT (subscript) = chrec_dont_know;\n@@ -3393,6 +3419,40 @@ initialize_data_dependence_relation (struct data_reference *a,\n   return res;\n }\n \n+/* Initialize a data dependence relation between data accesses A and\n+   B.  NB_LOOPS is the number of loops surrounding the references: the\n+   size of the classic distance/direction vectors.  */\n+\n+struct data_dependence_relation *\n+initialize_data_dependence_relation (struct data_reference *a,\n+\t\t\t\t     struct data_reference *b,\n+\t\t\t\t     vec<loop_p> loop_nest)\n+{\n+  data_dependence_relation *res = XCNEW (struct data_dependence_relation);\n+  DDR_A (res) = a;\n+  DDR_B (res) = b;\n+  DDR_LOOP_NEST (res).create (0);\n+  DDR_SUBSCRIPTS (res).create (0);\n+  DDR_DIR_VECTS (res).create (0);\n+  DDR_DIST_VECTS (res).create (0);\n+\n+  if (a == NULL || b == NULL)\n+    {\n+      DDR_ARE_DEPENDENT (res) = chrec_dont_know;\n+      return res;\n+    }\n+\n+  /* If the data references do not alias, then they are independent.  */\n+  if (!dr_may_alias_p (a, b, loop_nest.exists () ? loop_nest[0] : NULL))\n+    {\n+      DDR_ARE_DEPENDENT (res) = chrec_known;\n+      return res;\n+    }\n+\n+  return initialize_data_dependence_relation (res, loop_nest, false);\n+}\n+\n+\n /* Frees memory used by the conflict function F.  */\n \n static void"}, {"sha": "74f579c9f3f23bac25d21546068c2ab43209aa2b", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=f92901a508305f291fcf2acae0825379477724de", "patch": "@@ -166,14 +166,19 @@ struct data_reference\n      and runs to completion.  */\n   bool is_conditional_in_stmt;\n \n+  /* Alias information for the data reference.  */\n+  struct dr_alias alias;\n+\n   /* Behavior of the memory reference in the innermost loop.  */\n   struct innermost_loop_behavior innermost;\n \n   /* Subscripts of this data reference.  */\n   struct indices indices;\n \n-  /* Alias information for the data reference.  */\n-  struct dr_alias alias;\n+  /* Alternate subscripts initialized lazily and used by data-dependence\n+     analysis only when the main indices of two DRs are not comparable.\n+     Keep last to keep vec_info_shared::check_datarefs happy.  */\n+  struct indices alt_indices;\n };\n \n #define DR_STMT(DR)                (DR)->stmt"}, {"sha": "20daa31187d31cb5e029ca9703c1e7e52f4ee96e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f92901a508305f291fcf2acae0825379477724de/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f92901a508305f291fcf2acae0825379477724de", "patch": "@@ -507,7 +507,8 @@ vec_info_shared::check_datarefs ()\n     return;\n   gcc_assert (datarefs.length () == datarefs_copy.length ());\n   for (unsigned i = 0; i < datarefs.length (); ++i)\n-    if (memcmp (&datarefs_copy[i], datarefs[i], sizeof (data_reference)) != 0)\n+    if (memcmp (&datarefs_copy[i], datarefs[i],\n+\t\toffsetof (data_reference, alt_indices)) != 0)\n       gcc_unreachable ();\n }\n "}]}