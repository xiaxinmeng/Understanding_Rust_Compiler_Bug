{"sha": "7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IzZWU5Yzk3ZDdlYjhlZWRmNDZlYzA0ZTg1ZGMwMmZiNTE2MWY3NQ==", "commit": {"author": {"name": "Nicolas Koenig", "email": "koenigni@student.ethz.ch", "date": "2017-06-05T12:35:11Z"}, "committer": {"name": "Nicolas Koenig", "email": "koenigni@gcc.gnu.org", "date": "2017-06-05T12:35:11Z"}, "message": "re PR fortran/35339 (Improve translation of implied do loop in transfer)\n\n\n2017-06-05  Nicolas Koenig  <koenigni@student.ethz.ch>\n\n\tPR fortran/35339\n\t* frontend-passes.c (traverse_io_block): New function.\n\t(simplify_io_impl_do): New function.\n\t(optimize_namespace): Invoke gfc_code_walker with\n\tsimplify_io_impl_do.\n\n2017-06-05  Nicolas Koenig  <koenigni@student.ethz.ch>\n\n\tPR fortran/35339\n\t* gfortran.dg/implied_do_io_1.f90: New Test.\n\t* gfortran.dg/implied_do_io_2.f90: New Test.\n\nFrom-SVN: r248877", "tree": {"sha": "dc82ba68444550009887b24ace68bec2996c24af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc82ba68444550009887b24ace68bec2996c24af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/comments", "author": null, "committer": null, "parents": [{"sha": "e4d1c5c43887c9485dd42c9a82b9340c12e19a57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d1c5c43887c9485dd42c9a82b9340c12e19a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d1c5c43887c9485dd42c9a82b9340c12e19a57"}], "stats": {"total": 355, "additions": 355, "deletions": 0}, "files": [{"sha": "7b61cc4fce52b1ba2b3c0af7be4e3ddfc7630a44", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "patch": "@@ -1,3 +1,11 @@\n+2017-06-05  Nicolas Koenig  <koenigni@student.ethz.ch>\n+\n+\tPR fortran/35339\n+\t* frontend-passes.c (traverse_io_block): New function.\n+\t(simplify_io_impl_do): New function.\n+\t(optimize_namespace): Invoke gfc_code_walker with\n+\tsimplify_io_impl_do.\n+\n 2017-06-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/80918"}, {"sha": "8fa1de12acc5b5076a5e3aebaa64fbeb51e649b5", "filename": "gcc/fortran/frontend-passes.c", "status": "modified", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ffortran%2Ffrontend-passes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ffortran%2Ffrontend-passes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ffrontend-passes.c?ref=7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "patch": "@@ -1064,6 +1064,264 @@ convert_elseif (gfc_code **c, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return 0;\n }\n \n+struct do_stack\n+{\n+  struct do_stack *prev;\n+  gfc_iterator *iter;\n+  gfc_code *code;\n+} *stack_top;\n+\n+/* Recursively traverse the block of a WRITE or READ statement, and maybe\n+   optimize by replacing do loops with their analog array slices.  For\n+   example:\n+\n+     write (*,*) (a(i), i=1,4)\n+\n+   is replaced with\n+\n+     write (*,*) a(1:4:1) .  */\n+\n+static bool\n+traverse_io_block (gfc_code *code, bool *has_reached, gfc_code *prev)\n+{\n+  gfc_code *curr;\n+  gfc_expr *new_e, *expr, *start;\n+  gfc_ref *ref;\n+  struct do_stack ds_push;\n+  int i, future_rank = 0;\n+  gfc_iterator *iters[GFC_MAX_DIMENSIONS];\n+  gfc_expr *e;\n+\n+  /* Find the first transfer/do statement.  */\n+  for (curr = code; curr; curr = curr->next)\n+    {\n+      if (curr->op == EXEC_DO || curr->op == EXEC_TRANSFER)\n+\tbreak;\n+    }\n+\n+  /* Ensure it is the only transfer/do statement because cases like\n+\n+     write (*,*) (a(i), b(i), i=1,4)\n+\n+     cannot be optimized.  */\n+\n+  if (!curr || curr->next)\n+    return false;\n+\n+  if (curr->op == EXEC_DO)\n+    {\n+      if (curr->ext.iterator->var->ref)\n+\treturn false;\n+      ds_push.prev = stack_top;\n+      ds_push.iter = curr->ext.iterator;\n+      ds_push.code = curr;\n+      stack_top = &ds_push;\n+      if (traverse_io_block (curr->block->next, has_reached, prev))\n+\t{\n+\t  if (curr != stack_top->code && !*has_reached)\n+\t    {\n+\t      curr->block->next = NULL;\n+\t      gfc_free_statements (curr);\n+\t    }\n+\t  else\n+\t    *has_reached = true;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  gcc_assert (curr->op == EXEC_TRANSFER);\n+\n+  /* FIXME: Workaround for PR 80945 - array slices with deferred character\n+     lenghts do not work.  Remove this section when the PR is fixed.  */\n+  e = curr->expr1;\n+  if (e->expr_type == EXPR_VARIABLE && e->ts.type == BT_CHARACTER\n+      && e->ts.deferred)\n+    return false;\n+  /* End of section to be removed.  */\n+\n+  ref = e->ref;\n+  if (!ref || ref->type != REF_ARRAY || ref->u.ar.codimen != 0 || ref->next)\n+    return false;\n+\n+  /* Find the iterators belonging to each variable and check conditions.  */\n+  for (i = 0; i < ref->u.ar.dimen; i++)\n+    {\n+      if (!ref->u.ar.start[i] || ref->u.ar.start[i]->ref\n+\t  || ref->u.ar.dimen_type[i] != DIMEN_ELEMENT)\n+\treturn false;\n+\n+      start = ref->u.ar.start[i];\n+      gfc_simplify_expr (start, 0);\n+      switch (start->expr_type)\n+\t{\n+\tcase EXPR_VARIABLE:\n+\n+\t  /* write (*,*) (a(i), i=a%b,1) not handled yet.  */\n+\t  if (start->ref)\n+\t    return false;\n+\n+\t  /*  Check for (a(k), i=1,4) or ((a(j, i), i=1,4), j=1,4).  */\n+\t  if (!stack_top || !stack_top->iter\n+\t      || stack_top->iter->var->symtree != start->symtree)\n+\t    iters[i] = NULL;\n+\t  else\n+\t    {\n+\t      iters[i] = stack_top->iter;\n+\t      stack_top = stack_top->prev;\n+\t      future_rank++;\n+\t    }\n+\t  break;\n+\tcase EXPR_CONSTANT:\n+\t  iters[i] = NULL;\n+\t  break;\n+\tcase EXPR_OP:\n+\t  switch (start->value.op.op)\n+\t    {\n+\t    case INTRINSIC_PLUS:\n+\t    case INTRINSIC_TIMES:\n+\t      if (start->value.op.op1->expr_type != EXPR_VARIABLE)\n+\t\tstd::swap (start->value.op.op1, start->value.op.op2);\n+\t      gcc_fallthrough ();\n+\t    case INTRINSIC_MINUS:\n+\t      if ((start->value.op.op1->expr_type!= EXPR_VARIABLE\n+\t\t   && start->value.op.op2->expr_type != EXPR_CONSTANT)\n+\t\t  || start->value.op.op1->ref)\n+\t\treturn false;\n+\t      if (!stack_top || !stack_top->iter\n+\t\t  || stack_top->iter->var->symtree\n+\t\t  != start->value.op.op1->symtree)\n+\t\treturn false;\n+\t      iters[i] = stack_top->iter;\n+\t      stack_top = stack_top->prev;\n+\t      break;\n+\t    default:\n+\t      return false;\n+\t    }\n+\t  future_rank++;\n+\t  break;\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Create new expr.  */\n+  new_e = gfc_copy_expr (curr->expr1);\n+  new_e->expr_type = EXPR_VARIABLE;\n+  new_e->rank = future_rank;\n+  if (curr->expr1->shape)\n+    new_e->shape = gfc_get_shape (new_e->rank);\n+\n+  /* Assign new starts, ends and strides if necessary.  */\n+  for (i = 0; i < ref->u.ar.dimen; i++)\n+    {\n+      if (!iters[i])\n+\tcontinue;\n+      start = ref->u.ar.start[i];\n+      switch (start->expr_type)\n+\t{\n+\tcase EXPR_CONSTANT:\n+\t  gfc_internal_error (\"bad expression\");\n+\t  break;\n+\tcase EXPR_VARIABLE:\n+\t  new_e->ref->u.ar.dimen_type[i] = DIMEN_RANGE;\n+\t  new_e->ref->u.ar.type = AR_SECTION;\n+\t  gfc_free_expr (new_e->ref->u.ar.start[i]);\n+\t  new_e->ref->u.ar.start[i] = gfc_copy_expr (iters[i]->start);\n+\t  new_e->ref->u.ar.end[i] = gfc_copy_expr (iters[i]->end);\n+\t  new_e->ref->u.ar.stride[i] = gfc_copy_expr (iters[i]->step);\n+\t  break;\n+\tcase EXPR_OP:\n+\t  new_e->ref->u.ar.dimen_type[i] = DIMEN_RANGE;\n+\t  new_e->ref->u.ar.type = AR_SECTION;\n+\t  gfc_free_expr (new_e->ref->u.ar.start[i]);\n+\t  expr = gfc_copy_expr (start);\n+\t  expr->value.op.op1 = gfc_copy_expr (iters[i]->start);\n+\t  new_e->ref->u.ar.start[i] = expr;\n+\t  gfc_simplify_expr (new_e->ref->u.ar.start[i], 0);\n+\t  expr = gfc_copy_expr (start);\n+\t  expr->value.op.op1 = gfc_copy_expr (iters[i]->end);\n+\t  new_e->ref->u.ar.end[i] = expr;\n+\t  gfc_simplify_expr (new_e->ref->u.ar.end[i], 0);\n+\t  switch (start->value.op.op)\n+\t    {\n+\t    case INTRINSIC_MINUS:\n+\t    case INTRINSIC_PLUS:\n+\t      new_e->ref->u.ar.stride[i] = gfc_copy_expr (iters[i]->step);\n+\t      break;\n+\t    case INTRINSIC_TIMES:\n+\t      expr = gfc_copy_expr (start);\n+\t      expr->value.op.op1 = gfc_copy_expr (iters[i]->step);\n+\t      new_e->ref->u.ar.stride[i] = expr;\n+\t      gfc_simplify_expr (new_e->ref->u.ar.stride[i], 0);\n+\t      break;\n+\t    default:\n+\t      gfc_internal_error (\"bad op\");\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  gfc_internal_error (\"bad expression\");\n+\t}\n+    }\n+  curr->expr1 = new_e;\n+\n+  /* Insert modified statement. Check whether the statement needs to be\n+     inserted at the lowest level.  */\n+  if (!stack_top->iter)\n+    {\n+      if (prev)\n+\t{\n+\t  curr->next = prev->next->next;\n+\t  prev->next = curr;\n+\t}\n+      else\n+\t{\n+\t  curr->next = stack_top->code->block->next->next->next;\n+\t  stack_top->code->block->next = curr;\n+\t}\n+    }\n+  else\n+    stack_top->code->block->next = curr;\n+  return true;\n+}\n+\n+/* Function for the gfc_code_walker.  If code is a READ or WRITE statement, it\n+   tries to optimize its block.  */\n+\n+static int\n+simplify_io_impl_do (gfc_code **code, int *walk_subtrees,\n+\t\t     void *data ATTRIBUTE_UNUSED)\n+{\n+  gfc_code **curr, *prev = NULL;\n+  struct do_stack write, first;\n+  bool b = false;\n+  *walk_subtrees = 1;\n+  if (!(*code)->block\n+      || ((*code)->block->op != EXEC_WRITE\n+\t  && (*code)->block->op != EXEC_READ))\n+    return 0;\n+\n+  *walk_subtrees = 0;\n+  write.prev = NULL;\n+  write.iter = NULL;\n+  write.code = *code;\n+\n+  for (curr = &(*code)->block; *curr; curr = &(*curr)->next)\n+    {\n+      if ((*curr)->op == EXEC_DO)\n+\t{\n+\t  first.prev = &write;\n+\t  first.iter = (*curr)->ext.iterator;\n+\t  first.code = *curr;\n+\t  stack_top = &first;\n+\t  traverse_io_block ((*curr)->block->next, &b, prev);\n+\t  stack_top = NULL;\n+\t}\n+      prev = *curr;\n+    }\n+  return 0;\n+}\n+\n /* Optimize a namespace, including all contained namespaces.  */\n \n static void\n@@ -1077,6 +1335,7 @@ optimize_namespace (gfc_namespace *ns)\n   in_assoc_list = false;\n   in_omp_workshare = false;\n \n+  gfc_code_walker (&ns->code, simplify_io_impl_do, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, convert_do_while, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, convert_elseif, dummy_expr_callback, NULL);\n   gfc_code_walker (&ns->code, cfe_code, cfe_expr_0, NULL);"}, {"sha": "bed2af7c5c10504fef6f947dd6f5520b8402a631", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "patch": "@@ -1,3 +1,9 @@\n+2017-06-05  Nicolas Koenig  <koenigni@student.ethz.ch>\n+\n+\tPR fortran/35339\n+\t* gfortran.dg/implied_do_io_1.f90: New Test.\n+\t* gfortran.dg/implied_do_io_2.f90: New Test.\n+\n 2017-06-05 Renlin Li <renlin.li@arm.com>\n \n \t* c-c++-common/Wfloat-conversion.c: Add large_long_double target"}, {"sha": "e4a6d6b37b3752d51c245499a17dfc78ade71025", "filename": "gcc/testsuite/gfortran.dg/implied_do_io_1.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_1.f90?ref=7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+! { dg-options \"-O -fdump-tree-original\" }\n+! PR/35339\n+! This test ensures optimization of implied do loops in io statements\n+\n+program main\n+  implicit none\n+  integer:: i, j, square\n+  integer, parameter:: k = 2, linenum = 14\n+  integer, dimension(2):: a = [(i, i=1,2)]\n+  integer, dimension(2,2):: b = reshape([1, 2, 3, 4], shape(b))\n+  character (len=30), dimension(linenum) :: res\n+  character (len=30) :: line\n+  type tp\n+    integer, dimension(2):: i\n+  end type\n+  type(tp), dimension(2):: t = [tp([1, 2]), tp([1, 2])]\n+  data res / &\n+       ' a   2   2', &\n+       ' b   1   2', &\n+       ' c   1   2', &\n+       ' d   1   2', &\n+       ' e   1   2   1   2', &\n+       ' f   1   2   1   1   2   2', &\n+       ' g   1   2   3   4', &\n+       ' h   1   3   2   4', &\n+       ' i   2', &\n+       ' j   2', &\n+       ' k   1   2   1   2', &\n+       ' l   1', &\n+       ' m   1   1', &\n+       ' n   1   2'/\n+\n+  open(10,file=\"test.dat\")\n+\n+  write (10,1000) 'a', (a(k), i=1,2) \n+  write (10,1000) 'b', (b(i, 1), i=1,2)\n+  write (10,1000) 'c', b(1:2:1, 1)\n+  write (10,1000) 'd', (a(i), i=1,2)\n+  write (10,1000) 'e', ((a(i), i=1,2), j=1,2)\n+  write (10,1000) 'f', (a, b(i, 1), i = 1,2)\n+  write (10,1000) 'g', ((b(i, j), i=1,2),j=1,2)\n+  write (10,1000) 'h', ((b(j, i), i=1,2),j=1,2)\n+  write (10,1000) 'i', (a(i+1), i=1,1)\n+  write (10,1000) 'j', (a(i*2), i=1,1)\n+  write (10,1000) 'k', (a(i), i=1,2), (a(i), i=1,2)\n+  write (10,1000) 'l', (a(i), i=1,1)\n+  write (10,1000) 'm', (1, i=1,2)\n+  write (10,1000) 'n', (t(i)%i(i), i=1,2)\n+  rewind (10)\n+  do i=1,linenum\n+     read (10,'(A)') line\n+     if (line .ne. res(i)) call abort\n+  end do\n+  close(10,status=\"delete\")\n+1000 format (A2,100I4)\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"while\" 7 \"original\" } }"}, {"sha": "52edde543295aaa5a98689aea9c2da30172cd9dd", "filename": "gcc/testsuite/gfortran.dg/implied_do_io_2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimplied_do_io_2.f90?ref=7b3ee9c97d7eb8eedf46ec04e85dc02fb5161f75", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! Test that allocatable characters with deferred length\n+! are written correctly\n+program main\n+    implicit none\n+    integer:: i\n+    integer, parameter:: N = 10\n+    character(len=:), dimension(:),allocatable:: ca\n+    character(len=50):: buffer, line\n+    allocate(character(len=N):: ca(3))\n+    buffer = \"foo  bar  xyzzy\"\n+    ca(1) = \"foo\"\n+    ca(2) = \"bar\"\n+    ca(3) = \"xyzzy\"\n+    write (unit=line, fmt='(3A5)') (ca(i),i=1,3)\n+    if (line /= buffer) call abort\n+    ca(1) = \"\"\n+    ca(2) = \"\"\n+    ca(3) = \"\"\n+    read (unit=line, fmt='(3A5)') (ca(i),i=1,3)\n+    if (line /= buffer) call abort\n+end program\n+"}]}