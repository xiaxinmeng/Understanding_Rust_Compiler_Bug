{"sha": "3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FmOGQ4Y2I4NmFlYjc1ODJmNWM1ZTZmZmM1YzI0Zjc4MmQwNzJmNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-08-01T13:45:12Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-08-01T13:45:12Z"}, "message": "re PR fortran/40011 (Problems with -fwhole-file)\n\n2009-08-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40011\n\t* error.c : Add static flag 'warnings_not_errors'.\n\t(gfc_error): If 'warnings_not_errors' is set, branch to code\n\tfrom gfc_warning.\n\t(gfc_clear_error): Reset 'warnings_not_errors'.\n\t(gfc_errors_to_warnings): New function.\n\t* options.c (gfc_post_options): If pedantic and flag_whole_file\n\tchange the latter to a value of 2.\n\t* parse.c (parse_module): Add module namespace to gsymbol.\n\t(resolve_all_program_units): New function.\n\t(clean_up_modules): New function.\n\t(translate_all_program_units): New function.\n\t(gfc_parse_file): If whole_file, do not clean up module right\n\taway and add derived types to namespace derived types. In\n\taddition, call the three new functions above.\n\t* resolve.c (not_in_recursive): New function.\n\t(not_entry_self_reference): New function.\n\t(resolve_global_procedure): Symbol must not be IFSRC_UNKNOWN,\n\tprocedure must not be in the course of being resolved and\n\tmust return false for the two new functions. Pack away the\n\tcurrent derived type list before calling gfc_resolve for the\n\tgsymbol namespace.  It is unconditionally an error if the ranks\n\tof the reference and ther procedure do not match. Convert\n\terrors to warnings during call to gfc_procedure_use if not\n\tpedantic or legacy.\n\t(gfc_resolve): Set namespace resolved flag to -1 during\n\tresolution and store current cs_base.\n\t* trans-decl.c (gfc_get_symbol_decl): If whole_file compilation\n\tsubstitute a use associated variable, if it is available in a\n\tgsymbolnamespace.\n\t(gfc_get_extern_function_decl): If the procedure is use assoc,\n\tdo not attempt to find it in a gsymbol because it could be an\n\tinterface. If the symbol exists in a module namespace, return\n\tits backend_decl.\n\t* trans-expr.c (gfc_trans_scalar_assign): If a derived type\n\tassignment, set the rhs TYPE_MAIN_VARIANT to that of the rhs.\n\t* trans-types.c (copy_dt_decls_ifequal): Add 'from_gsym' as a\n\tboolean argument. Copy component backend_decls directly if the\n\tcomponents are derived types and from_gsym is true.\n\t(gfc_get_derived_type): If whole_file copy the derived type from\n\tthe module if it is use associated, otherwise, if can be found\n\tin another gsymbol namespace, use the existing derived type as\n\tthe TYPE_CANONICAL and build normally.\n\t* gfortran.h : Add derived_types and resolved fields to\n\tgfc_namespace. Include prototype for gfc_errors_to_warnings.\n\n2009-08-01  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40011\n\t* gfortran.dg/whole_file_7.f90: New test.\n\t* gfortran.dg/whole_file_8.f90: New test.\n\t* gfortran.dg/whole_file_9.f90: New test.\n\t* gfortran.dg/whole_file_10.f90: New test.\n\t* gfortran.dg/whole_file_11.f90: New test.\n\t* gfortran.dg/whole_file_12.f90: New test.\n\t* gfortran.dg/whole_file_13.f90: New test.\n\t* gfortran.dg/whole_file_14.f90: New test.\n\nFrom-SVN: r150333", "tree": {"sha": "0d387c47cf00a2962560d0777fe3a4edba3543d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d387c47cf00a2962560d0777fe3a4edba3543d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/comments", "author": null, "committer": null, "parents": [{"sha": "4fcf08308d076999d6d95f70c0e71de4a34be002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fcf08308d076999d6d95f70c0e71de4a34be002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fcf08308d076999d6d95f70c0e71de4a34be002"}], "stats": {"total": 715, "additions": 685, "deletions": 30}, "files": [{"sha": "d812f9db3c2d97b30529954878cce10198e8328a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1,3 +1,51 @@\n+2009-08-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40011\n+\t* error.c : Add static flag 'warnings_not_errors'.\n+\t(gfc_error): If 'warnings_not_errors' is set, branch to code\n+\tfrom gfc_warning.\n+\t(gfc_clear_error): Reset 'warnings_not_errors'.\n+\t(gfc_errors_to_warnings): New function.\n+\t* options.c (gfc_post_options): If pedantic and flag_whole_file\n+\tchange the latter to a value of 2.\n+\t* parse.c (parse_module): Add module namespace to gsymbol.\n+\t(resolve_all_program_units): New function.\n+\t(clean_up_modules): New function.\n+\t(translate_all_program_units): New function.\n+\t(gfc_parse_file): If whole_file, do not clean up module right\n+\taway and add derived types to namespace derived types. In\n+\taddition, call the three new functions above.\n+\t* resolve.c (not_in_recursive): New function.\n+\t(not_entry_self_reference): New function.\n+\t(resolve_global_procedure): Symbol must not be IFSRC_UNKNOWN,\n+\tprocedure must not be in the course of being resolved and\n+\tmust return false for the two new functions. Pack away the\n+\tcurrent derived type list before calling gfc_resolve for the\n+\tgsymbol namespace.  It is unconditionally an error if the ranks\n+\tof the reference and ther procedure do not match. Convert\n+\terrors to warnings during call to gfc_procedure_use if not\n+\tpedantic or legacy.\n+\t(gfc_resolve): Set namespace resolved flag to -1 during\n+\tresolution and store current cs_base.\n+\t* trans-decl.c (gfc_get_symbol_decl): If whole_file compilation\n+\tsubstitute a use associated variable, if it is available in a\n+\tgsymbolnamespace.\n+\t(gfc_get_extern_function_decl): If the procedure is use assoc,\n+\tdo not attempt to find it in a gsymbol because it could be an\n+\tinterface. If the symbol exists in a module namespace, return\n+\tits backend_decl.\n+\t* trans-expr.c (gfc_trans_scalar_assign): If a derived type\n+\tassignment, set the rhs TYPE_MAIN_VARIANT to that of the rhs.\n+\t* trans-types.c (copy_dt_decls_ifequal): Add 'from_gsym' as a\n+\tboolean argument. Copy component backend_decls directly if the\n+\tcomponents are derived types and from_gsym is true.\n+\t(gfc_get_derived_type): If whole_file copy the derived type from\n+\tthe module if it is use associated, otherwise, if can be found\n+\tin another gsymbol namespace, use the existing derived type as\n+\tthe TYPE_CANONICAL and build normally.\n+\t* gfortran.h : Add derived_types and resolved fields to\n+\tgfc_namespace. Include prototype for gfc_errors_to_warnings.\n+\n 2009-07-29  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40898"}, {"sha": "9d5453e4ceba1209b6f291192ad54b74f1bc4656", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -32,6 +32,8 @@ along with GCC; see the file COPYING3.  If not see\n \n static int suppress_errors = 0;\n \n+static int warnings_not_errors = 0; \n+\n static int terminal_width, buffer_flag, errors, warnings;\n \n static gfc_error_buf error_buffer, warning_buffer, *cur_error_buffer;\n@@ -863,6 +865,9 @@ gfc_error (const char *nocmsgid, ...)\n {\n   va_list argp;\n \n+  if (warnings_not_errors)\n+    goto warning;\n+\n   if (suppress_errors)\n     return;\n \n@@ -878,6 +883,30 @@ gfc_error (const char *nocmsgid, ...)\n \n   if (buffer_flag == 0)\n     gfc_increment_error_count();\n+\n+  return;\n+\n+warning:\n+\n+  if (inhibit_warnings)\n+    return;\n+\n+  warning_buffer.flag = 1;\n+  warning_buffer.index = 0;\n+  cur_error_buffer = &warning_buffer;\n+\n+  va_start (argp, nocmsgid);\n+  error_print (_(\"Warning:\"), _(nocmsgid), argp);\n+  va_end (argp);\n+\n+  error_char ('\\0');\n+\n+  if (buffer_flag == 0)\n+  {\n+    warnings++;\n+    if (warnings_are_errors)\n+      gfc_increment_error_count();\n+  }\n }\n \n \n@@ -955,6 +984,7 @@ void\n gfc_clear_error (void)\n {\n   error_buffer.flag = 0;\n+  warnings_not_errors = 0;\n }\n \n \n@@ -1042,3 +1072,12 @@ gfc_get_errors (int *w, int *e)\n   if (e != NULL)\n     *e = errors;\n }\n+\n+\n+/* Switch errors into warnings.  */\n+\n+void\n+gfc_errors_to_warnings (int f)\n+{\n+  warnings_not_errors = (f == 1) ? 1 : 0;\n+}"}, {"sha": "da3d5f052b888b6998865f3ace49d373bd8e03af", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1329,6 +1329,8 @@ typedef struct gfc_namespace\n \n   gfc_charlen *cl_list, *old_cl_list;\n \n+  gfc_dt_list *derived_types;\n+\n   int save_all, seen_save, seen_implicit_none;\n \n   /* Normally we don't need to refcount namespaces.  However when we read\n@@ -1350,6 +1352,9 @@ typedef struct gfc_namespace\n \n   /* Set to 1 if resolved has been called for this namespace.  */\n   int resolved;\n+\n+  /* Set to 1 if code has been generated for this namespace.  */\n+  int translated;\n }\n gfc_namespace;\n \n@@ -2288,6 +2293,7 @@ void gfc_pop_error (gfc_error_buf *);\n void gfc_free_error (gfc_error_buf *);\n \n void gfc_get_errors (int *, int *);\n+void gfc_errors_to_warnings (int);\n \n /* arith.c */\n void gfc_arith_init_1 (void);"}, {"sha": "3e20f8e45d4b84516dd8bb1503da09ffad885ba4", "filename": "gcc/fortran/options.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -371,6 +371,9 @@ gfc_post_options (const char **pfilename)\n       gfc_option.warn_tabs = 0;\n     }\n \n+  if (pedantic && gfc_option.flag_whole_file)\n+    gfc_option.flag_whole_file = 2;\n+\n   gfc_cpp_post_options ();\n \n /* FIXME: return gfc_cpp_preprocess_only ();"}, {"sha": "e4463bd7edf1ac01cd3d7c8727070ce2d268870a", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 91, "deletions": 22, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -3760,6 +3760,8 @@ parse_module (void)\n       st = next_statement ();\n       goto loop;\n     }\n+\n+  s->ns = gfc_current_ns;\n }\n \n \n@@ -3809,6 +3811,76 @@ add_global_program (void)\n }\n \n \n+/* Resolve all the program units when whole file scope option\n+   is active. */\n+static void\n+resolve_all_program_units (gfc_namespace *gfc_global_ns_list)\n+{\n+  gfc_free_dt_list ();\n+  gfc_current_ns = gfc_global_ns_list;\n+  for (; gfc_current_ns; gfc_current_ns = gfc_current_ns->sibling)\n+    {\n+      gfc_current_locus = gfc_current_ns->proc_name->declared_at;\n+      gfc_resolve (gfc_current_ns);\n+      gfc_current_ns->derived_types = gfc_derived_types;\n+      gfc_derived_types = NULL;\n+    }\n+}\n+\n+\n+static void\n+clean_up_modules (gfc_gsymbol *gsym)\n+{\n+  if (gsym == NULL)\n+    return;\n+\n+  clean_up_modules (gsym->left);\n+  clean_up_modules (gsym->right);\n+\n+  if (gsym->type != GSYM_MODULE || !gsym->ns)\n+    return;\n+\n+  gfc_current_ns = gsym->ns;\n+  gfc_derived_types = gfc_current_ns->derived_types;\n+  gfc_done_2 ();\n+  gsym->ns = NULL;\n+  return;\n+}\n+\n+\n+/* Translate all the program units when whole file scope option\n+   is active. This could be in a different order to resolution if\n+   there are forward references in the file.  */\n+static void\n+translate_all_program_units (gfc_namespace *gfc_global_ns_list)\n+{\n+  int errors;\n+\n+  gfc_current_ns = gfc_global_ns_list;\n+  gfc_get_errors (NULL, &errors);\n+\n+  for (; !errors && gfc_current_ns; gfc_current_ns = gfc_current_ns->sibling)\n+    {\n+      gfc_current_locus = gfc_current_ns->proc_name->declared_at;\n+      gfc_derived_types = gfc_current_ns->derived_types;\n+      gfc_generate_code (gfc_current_ns);\n+      gfc_current_ns->translated = 1;\n+    }\n+\n+  /* Clean up all the namespaces after translation.  */\n+  gfc_current_ns = gfc_global_ns_list;\n+  for (;gfc_current_ns;)\n+    {\n+      gfc_namespace *ns = gfc_current_ns->sibling;\n+      gfc_derived_types = gfc_current_ns->derived_types;\n+      gfc_done_2 ();\n+      gfc_current_ns = ns;\n+    }\n+\n+  clean_up_modules (gfc_gsym_root);\n+}\n+\n+\n /* Top level parser.  */\n \n gfc_try\n@@ -3933,15 +4005,24 @@ gfc_parse_file (void)\n       gfc_dump_module (s.sym->name, errors_before == errors);\n       if (errors == 0)\n \tgfc_generate_module_code (gfc_current_ns);\n+      pop_state ();\n+      if (!gfc_option.flag_whole_file)\n+\tgfc_done_2 ();\n+      else\n+\t{\n+\t  gfc_current_ns->derived_types = gfc_derived_types;\n+\t  gfc_derived_types = NULL;\n+\t  gfc_current_ns = NULL;\n+\t}\n     }\n   else\n     {\n       if (errors == 0)\n \tgfc_generate_code (gfc_current_ns);\n+      pop_state ();\n+      gfc_done_2 ();\n     }\n \n-  pop_state ();\n-  gfc_done_2 ();\n   goto loop;\n \n prog_units:\n@@ -3964,35 +4045,23 @@ gfc_parse_file (void)\n   if (!gfc_option.flag_whole_file)\n     goto termination;\n \n-  /* Do the resolution.  */ \n-  gfc_current_ns = gfc_global_ns_list;\n-  for (; gfc_current_ns; gfc_current_ns = gfc_current_ns->sibling)\n-    {\n-      gfc_current_locus = gfc_current_ns->proc_name->declared_at;\n-      gfc_resolve (gfc_current_ns);\n-    }\n+  /* Do the resolution.  */\n+  resolve_all_program_units (gfc_global_ns_list);\n \n   /* Do the parse tree dump.  */ \n-  gfc_current_ns = gfc_option.dump_parse_tree ? gfc_global_ns_list : NULL;\n+  gfc_current_ns\n+\t= gfc_option.dump_parse_tree ? gfc_global_ns_list : NULL;\n+\n   for (; gfc_current_ns; gfc_current_ns = gfc_current_ns->sibling)\n     {\n       gfc_dump_parse_tree (gfc_current_ns, stdout);\n-      fputs (\"-----------------------------------------\\n\\n\", stdout);\n+      fputs (\"------------------------------------------\\n\\n\", stdout);\n     }\n \n-  gfc_current_ns = gfc_global_ns_list;\n-  gfc_get_errors (NULL, &errors);\n-\n-  /* Do the translation.  This could be in a different order to\n-     resolution if there are forward references in the file.  */\n-  for (; !errors && gfc_current_ns; gfc_current_ns = gfc_current_ns->sibling)\n-    {\n-      gfc_current_locus = gfc_current_ns->proc_name->declared_at;\n-      gfc_generate_code (gfc_current_ns);\n-    }\n+  /* Do the translation.  */\n+  translate_all_program_units (gfc_global_ns_list);\n \n termination:\n-  gfc_free_dt_list ();\n \n   gfc_end_source_files ();\n   return SUCCESS;"}, {"sha": "6202a2d197e0fb16d85e694d7913cd089e200b74", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1652,6 +1652,47 @@ find_noncopying_intrinsics (gfc_symbol *fnsym, gfc_actual_arglist *actual)\n    The namespace of the gsymbol is resolved and then, once this is\n    done the interface is checked.  */\n \n+\n+static bool\n+not_in_recursive (gfc_symbol *sym, gfc_namespace *gsym_ns)\n+{\n+  if (!gsym_ns->proc_name->attr.recursive)\n+    return true;\n+\n+  if (sym->ns == gsym_ns)\n+    return false;\n+\n+  if (sym->ns->parent && sym->ns->parent == gsym_ns)\n+    return false;\n+\n+  return true;\n+}\n+\n+static bool\n+not_entry_self_reference  (gfc_symbol *sym, gfc_namespace *gsym_ns)\n+{\n+  if (gsym_ns->entries)\n+    {\n+      gfc_entry_list *entry = gsym_ns->entries;\n+\n+      for (; entry; entry = entry->next)\n+\t{\n+\t  if (strcmp (sym->name, entry->sym->name) == 0)\n+\t    {\n+\t      if (strcmp (gsym_ns->proc_name->name,\n+\t\t\t  sym->ns->proc_name->name) == 0)\n+\t\treturn false;\n+\n+\t      if (sym->ns->parent\n+\t\t  && strcmp (gsym_ns->proc_name->name,\n+\t\t\t     sym->ns->parent->proc_name->name) == 0)\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n+  return true;\n+}\n+\n static void\n resolve_global_procedure (gfc_symbol *sym, locus *where,\n \t\t\t  gfc_actual_arglist **actual, int sub)\n@@ -1668,9 +1709,13 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n     gfc_global_used (gsym, where);\n \n   if (gfc_option.flag_whole_file\n+\t&& sym->attr.if_source == IFSRC_UNKNOWN\n \t&& gsym->type != GSYM_UNKNOWN\n \t&& gsym->ns\n-\t&& gsym->ns->proc_name)\n+\t&& gsym->ns->resolved != -1\n+\t&& gsym->ns->proc_name\n+\t&& not_in_recursive (sym, gsym->ns)\n+\t&& not_entry_self_reference (sym, gsym->ns))\n     {\n       /* Make sure that translation for the gsymbol occurs before\n \t the procedure currently being resolved.  */\n@@ -1687,9 +1732,41 @@ resolve_global_procedure (gfc_symbol *sym, locus *where,\n \t}\n \n       if (!gsym->ns->resolved)\n-\tgfc_resolve (gsym->ns);\n+\t{\n+\t  gfc_dt_list *old_dt_list;\n+\n+\t  /* Stash away derived types so that the backend_decls do not\n+\t     get mixed up.  */\n+\t  old_dt_list = gfc_derived_types;\n+\t  gfc_derived_types = NULL;\n+\n+\t  gfc_resolve (gsym->ns);\n+\n+\t  /* Store the new derived types with the global namespace.  */\n+\t  if (gfc_derived_types)\n+\t    gsym->ns->derived_types = gfc_derived_types;\n+\n+\t  /* Restore the derived types of this namespace.  */\n+\t  gfc_derived_types = old_dt_list;\n+\t}\n+\n+      if (gsym->ns->proc_name->attr.function\n+\t    && gsym->ns->proc_name->as\n+\t    && gsym->ns->proc_name->as->rank\n+\t    && (!sym->as || sym->as->rank != gsym->ns->proc_name->as->rank))\n+\tgfc_error (\"The reference to function '%s' at %L either needs an \"\n+\t\t   \"explicit INTERFACE or the rank is incorrect\", sym->name,\n+\t\t   where);\n+\n+      if (gfc_option.flag_whole_file == 1\n+\t    || ((gfc_option.warn_std & GFC_STD_LEGACY)\n+\t\t  &&\n+\t       !(gfc_option.warn_std & GFC_STD_GNU)))\n+\tgfc_errors_to_warnings (1);\n \n       gfc_procedure_use (gsym->ns->proc_name, actual, where);\n+\n+      gfc_errors_to_warnings (0);\n     }\n \n   if (gsym->type == GSYM_UNKNOWN)\n@@ -11134,15 +11211,19 @@ void\n gfc_resolve (gfc_namespace *ns)\n {\n   gfc_namespace *old_ns;\n+  code_stack *old_cs_base;\n \n   if (ns->resolved)\n     return;\n \n+  ns->resolved = -1;\n   old_ns = gfc_current_ns;\n+  old_cs_base = cs_base;\n \n   resolve_types (ns);\n   resolve_codes (ns);\n \n   gfc_current_ns = old_ns;\n+  cs_base = old_cs_base;\n   ns->resolved = 1;\n }"}, {"sha": "70b78ed9705e1632c1ad56b609c841652af89833", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1098,6 +1098,32 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n   if (sym->backend_decl)\n     return sym->backend_decl;\n \n+  /* If use associated and whole file compilation, use the module\n+     declaration.  This is only needed for intrinsic types because\n+     they are substituted for one another during optimization.  */\n+  if (gfc_option.flag_whole_file\n+\t&& sym->attr.flavor == FL_VARIABLE\n+\t&& sym->ts.type != BT_DERIVED\n+\t&& sym->attr.use_assoc\n+\t&& sym->module)\n+    {\n+      gfc_gsymbol *gsym;\n+\n+      gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->module);\n+      if (gsym && gsym->ns && gsym->type == GSYM_MODULE)\n+\t{\n+\t  gfc_symbol *s;\n+\t  s = NULL;\n+\t  gfc_find_symbol (sym->name, gsym->ns, 0, &s);\n+\t  if (s && s->backend_decl)\n+\t    {\n+\t      if (sym->ts.type == BT_CHARACTER)\n+\t\tsym->ts.cl->backend_decl = s->ts.cl->backend_decl;\n+\t      return s->backend_decl;\n+\t    }\n+\t}\n+    }\n+\n   /* Catch function declarations.  Only used for actual parameters and\n      procedure pointers.  */\n   if (sym->attr.flavor == FL_PROCEDURE)\n@@ -1341,6 +1367,7 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n   gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->name);\n \n   if (gfc_option.flag_whole_file\n+\t&& !sym->attr.use_assoc\n \t&& !sym->backend_decl\n \t&& gsym && gsym->ns\n \t&& ((gsym->type == GSYM_SUBROUTINE) || (gsym->type == GSYM_FUNCTION))\n@@ -1371,6 +1398,26 @@ gfc_get_extern_function_decl (gfc_symbol * sym)\n \treturn sym->backend_decl;\n     }\n \n+  /* See if this is a module procedure from the same file.  If so,\n+     return the backend_decl.  */\n+  if (sym->module)\n+    gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->module);\n+\n+  if (gfc_option.flag_whole_file\n+\t&& gsym && gsym->ns\n+\t&& gsym->type == GSYM_MODULE)\n+    {\n+      gfc_symbol *s;\n+\n+      s = NULL;\n+      gfc_find_symbol (sym->name, gsym->ns, 0, &s);\n+      if (s && s->backend_decl)\n+\t{\n+\t  sym->backend_decl = s->backend_decl;\n+\t  return sym->backend_decl;\n+\t}\n+    }\n+\n   if (sym->attr.intrinsic)\n     {\n       /* Call the resolution function to get the actual name.  This is"}, {"sha": "7352db849e06fd57db62c8f65aa4b593bbea2787", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -4436,8 +4436,24 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n       gfc_add_block_to_block (&block, &lse->pre);\n       gfc_add_block_to_block (&block, &rse->pre);\n \n+      /* TODO This is rather obviously the wrong place to do this.\n+\t However, a number of testcases, such as function_kinds_1\n+\t and function_types_2 fail without it, by ICEing at\n+\t fold_const: 2710 (fold_convert_loc).  */\n+      if (ts.type == BT_DERIVED\n+\t    && gfc_option.flag_whole_file\n+\t    && (TYPE_MAIN_VARIANT (TREE_TYPE (rse->expr))\n+\t\t!= TYPE_MAIN_VARIANT (TREE_TYPE (lse->expr))))\n+\t{\n+\t  tmp = gfc_evaluate_now (rse->expr, &block);\n+\t  TYPE_MAIN_VARIANT (TREE_TYPE (tmp))\n+\t\t= TYPE_MAIN_VARIANT (TREE_TYPE (lse->expr));\n+\t}\n+      else\n+\ttmp = rse->expr;\n+      \n       gfc_add_modify (&block, lse->expr,\n-\t\t\t   fold_convert (TREE_TYPE (lse->expr), rse->expr));\n+\t\t\t   fold_convert (TREE_TYPE (lse->expr), tmp));\n     }\n \n   gfc_add_block_to_block (&block, &lse->post);"}, {"sha": "92373e1b1a2d65eb4602711a676270bd537a865e", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 65, "deletions": 5, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1853,7 +1853,8 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n    in 4.4.2 and resolved by gfc_compare_derived_types.  */\n \n static int\n-copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n+copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to,\n+\t\t       bool from_gsym)\n {\n   gfc_component *to_cm;\n   gfc_component *from_cm;\n@@ -1876,7 +1877,8 @@ copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n     {\n       to_cm->backend_decl = from_cm->backend_decl;\n-      if (!from_cm->attr.pointer && from_cm->ts.type == BT_DERIVED)\n+      if ((!from_cm->attr.pointer || from_gsym)\n+\t      && from_cm->ts.type == BT_DERIVED)\n \tgfc_get_derived_type (to_cm->ts.derived);\n \n       else if (from_cm->ts.type == BT_CHARACTER)\n@@ -1916,8 +1918,12 @@ static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode = NULL, field = NULL, field_type = NULL, fieldlist = NULL;\n+  tree canonical = NULL_TREE;\n+  bool got_canonical = false;\n   gfc_component *c;\n   gfc_dt_list *dt;\n+  gfc_namespace *ns;\n+  gfc_gsymbol *gsym;\n \n   gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n@@ -1949,7 +1955,59 @@ gfc_get_derived_type (gfc_symbol * derived)\n       \n       return derived->backend_decl;\n     }\n-  \n+\n+/* If use associated, use the module type for this one.  */\n+  if (gfc_option.flag_whole_file\n+\t&& derived->backend_decl == NULL\n+\t&& derived->attr.use_assoc\n+\t&& derived->module)\n+    {\n+      gsym =  gfc_find_gsymbol (gfc_gsym_root, derived->module);\n+      if (gsym && gsym->ns && gsym->type == GSYM_MODULE)\n+\t{\n+\t  gfc_symbol *s;\n+\t  s = NULL;\n+\t  gfc_find_symbol (derived->name, gsym->ns, 0, &s);\n+\t  if (s && s->backend_decl)\n+\t    {\n+\t      copy_dt_decls_ifequal (s, derived, true);\n+\t      goto copy_derived_types;\n+\t    }\n+\t}\n+    }\n+\n+  /* If a whole file compilation, the derived types from an earlier\n+     namespace can be used as the the canonical type.  */\n+  if (gfc_option.flag_whole_file\n+\t&& derived->backend_decl == NULL\n+\t&& !derived->attr.use_assoc\n+\t&& gfc_global_ns_list)\n+    {\n+      for (ns = gfc_global_ns_list;\n+\t   ns->translated && !got_canonical;\n+\t   ns = ns->sibling)\n+\t{\n+\t  dt = ns->derived_types;\n+\t  for (; dt && !canonical; dt = dt->next)\n+\t    {\n+\t      copy_dt_decls_ifequal (dt->derived, derived, true);\n+\t      if (derived->backend_decl)\n+\t\tgot_canonical = true;\n+\t    }\n+\t}\n+    }\n+\n+  /* Store up the canonical type to be added to this one.  */\n+  if (got_canonical)\n+    {\n+      if (TYPE_CANONICAL (derived->backend_decl))\n+\tcanonical = TYPE_CANONICAL (derived->backend_decl);\n+      else\n+\tcanonical = derived->backend_decl;\n+\n+      derived->backend_decl = NULL_TREE;\n+    }\n+\n   /* derived->backend_decl != 0 means we saw it before, but its\n      components' backend_decl may have not been built.  */\n   if (derived->backend_decl)\n@@ -2065,6 +2123,7 @@ gfc_get_derived_type (gfc_symbol * derived)\n   /* Now we have the final fieldlist.  Record it, then lay out the\n      derived type, including the fields.  */\n   TYPE_FIELDS (typenode) = fieldlist;\n+  TYPE_CANONICAL (typenode) = canonical;\n \n   gfc_finish_type (typenode);\n   gfc_set_decl_location (TYPE_STUB_DECL (typenode), &derived->declared_at);\n@@ -2083,9 +2142,10 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n   derived->backend_decl = typenode;\n \n-  /* Add this backend_decl to all the other, equal derived types.  */\n+copy_derived_types:\n+\n   for (dt = gfc_derived_types; dt; dt = dt->next)\n-    copy_dt_decls_ifequal (derived, dt->derived);\n+    copy_dt_decls_ifequal (derived, dt->derived, false);\n \n   return derived->backend_decl;\n }"}, {"sha": "cb3b647e0e5c48c8eb251dd73d91acc742df36db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -1,3 +1,15 @@\n+2009-08-01  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40011\n+\t* gfortran.dg/whole_file_7.f90: New test.\n+\t* gfortran.dg/whole_file_8.f90: New test.\n+\t* gfortran.dg/whole_file_9.f90: New test.\n+\t* gfortran.dg/whole_file_10.f90: New test.\n+\t* gfortran.dg/whole_file_11.f90: New test.\n+\t* gfortran.dg/whole_file_12.f90: New test.\n+\t* gfortran.dg/whole_file_13.f90: New test.\n+\t* gfortran.dg/whole_file_14.f90: New test.\n+\n 2009-07-31  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/cpp0x/initlist22.C: Adjust for new rvalue reference"}, {"sha": "fb100bb0ed5ef269635b99503b3b7daa1373d2f2", "filename": "gcc/testsuite/gfortran.dg/whole_file_10.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_10.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+! Test the fix for the fifth problem in PR40011, where the\n+! entries were not resolved, resulting in a segfault.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+recursive function fac(i) result (res)\n+  integer :: i, j, k, res\n+  k = 1\n+  goto 100\n+entry bifac(i,j) result (res)\n+  k = j\n+100 continue\n+  if (i < k) then\n+    res = 1\n+  else\n+    res = i * bifac(i-k,k)\n+  end if\n+end function\n+\n+program test\n+  external fac\n+  external bifac\n+  integer :: fac, bifac\n+  print *, fac(5)\n+  print *, bifac(5,2)\n+  print*, fac(6)\n+  print *, bifac(6,2)\n+  print*, fac(0)\n+  print *, bifac(1,2)\n+end program test"}, {"sha": "d01b2100c4bed08eec44c0a2ba29d37ae55849ce", "filename": "gcc/testsuite/gfortran.dg/whole_file_11.f90", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_11.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,37 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+!\n+! Tests the fix PR40011 comment 16 in which the derived type lists in\n+! different program units were getting mixed up.\n+!\n+! Contributed by Daniel Franck  <dfranke@gcc.gnu.org>\n+!\n+MODULE module_foo\n+  TYPE :: foo_node\n+    TYPE(foo_node_private), POINTER :: p\n+  END TYPE\n+\n+  TYPE :: foo_node_private\n+    TYPE(foo_node), DIMENSION(-1:1) :: link\n+  END TYPE\n+\n+  TYPE :: foo\n+    TYPE(foo_node) :: root\n+  END TYPE\n+END MODULE\n+\n+FUNCTION foo_insert()\n+  USE module_foo, ONLY: foo, foo_node\n+\n+  INTEGER :: foo_insert\n+  TYPE(foo_node) :: parent, current\n+  INTEGER :: cmp\n+\n+  parent  = current\n+  current = current%p%link(cmp)\n+END FUNCTION\n+\n+FUNCTION foo_count()\n+  USE module_foo, ONLY: foo\n+  INTEGER :: foo_count\n+END FUNCTION"}, {"sha": "150ac5f9d5db648bda2ac03d01996c82e391efd2", "filename": "gcc/testsuite/gfortran.dg/whole_file_12.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_12.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+!\n+! Tests the fix PR40011 comment 17 in which the explicit interface was\n+! being ignored and the missing argument was not correctly handled, which\n+! led to an ICE.\n+!\n+! Contributed by Dominique d'Humieres  <dominiq@lps.ens.fr\n+!\n+          Implicit None \n+          call sub(1,2) \n+          call sub(1,2,3)\n+ \n+          contains\n+\n+          subroutine sub(i,j,k) \n+          Implicit None \n+          Integer, Intent( In )           :: i \n+          Integer, Intent( In )           :: j \n+          Integer, Intent( In ), Optional :: k \n+          intrinsic present \n+          write(*,*)' 3 presence flag ',present(k) \n+          write(*,*)' 1st arg ',i \n+          write(*,*)' 2nd arg ',j \n+          if (present(k)) then \n+            write(*,*)' 3rd arg ',k \n+          else \n+            write(*,*)' 3rd arg is absent' \n+          endif \n+          return \n+          end subroutine\n+\n+          end"}, {"sha": "99e3ceecb7d3df430034ab67a475f00590c4f210", "filename": "gcc/testsuite/gfortran.dg/whole_file_13.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_13.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-options \"-fwhole-file -O3\" }\n+! Check that the TYPE_CANONICAL is being correctly set\n+! for the derived types, when whole file compiling.\n+! (based on import.f90)\n+!\n+subroutine test(x)\n+  type myType3\n+    sequence\n+    integer :: i\n+  end type myType3\n+  type(myType3) :: x\n+  if(x%i /= 7) call abort()\n+  x%i = 1\n+end subroutine test\n+\n+\n+program foo\n+  type myType3\n+    sequence\n+    integer :: i\n+  end type myType3\n+\n+  type(myType3) :: z\n+  z%i = 7\n+  call test(z)\n+  if(z%i /= 1) call abort\n+end program foo"}, {"sha": "65058960b957f705fef7a74b48be5abbf1b3d8cf", "filename": "gcc/testsuite/gfortran.dg/whole_file_14.f90", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_14.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_14.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_14.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,28 @@\n+! { dg-do run }\n+! { dg-options \"-fwhole-file -O3\" }\n+! Check that the derived types are correctly substituted when\n+! whole file compiling.\n+!\n+! Contributed by Dominique d'Humieres  <dominiq@lps.ens.fr\n+!\n+module global\n+ type                                ::  mytype\n+   type(mytype),pointer   ::  this\n+ end type mytype\n+ type(mytype),target        :: base\n+end module global\n+\n+program test_equi\n+  use global\n+  call check()\n+  print *, \"base%this%this=>base?\"  ,  associated(base%this%this,base)\n+  print *, \"base%this%this=>?\" ,          associated(base%this%this)\n+  print *, \"base%this=>?\" ,                   associated(base%this)\n+contains\n+  subroutine check()\n+    type(mytype),target        :: j\n+    base%this => j                      !have the variables point\n+    j%this => base                      !to one another\n+  end subroutine check                  !take j out of scope\n+end program test_equi\n+! { dg-final { cleanup-modules \"global\" } }"}, {"sha": "53fed228ae29a988502dd74c876d729fb847c35a", "filename": "gcc/testsuite/gfortran.dg/whole_file_7.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_7.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+! Test the fixes for the first two problems in PR40011\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+! This function would not compile because -fwhole-file would\n+! try repeatedly to resolve the function because of the self\n+! reference.\n+RECURSIVE FUNCTION eval_args(q)  result (r)\n+  INTEGER NNODE \n+  PARAMETER (NNODE  = 10) \n+  TYPE NODE \n+    SEQUENCE \n+    INTEGER car \n+    INTEGER cdr \n+  END TYPE NODE \n+  TYPE(NODE) heap(NNODE) \n+  INTEGER r, q \n+  r = eval_args(heap(q)%cdr) \n+END FUNCTION eval_args \n+\n+function test(n)\n+  real, dimension(2) :: test\n+  integer            :: n\n+  test = n\n+  return\n+end function test\n+\n+program arr     ! The error was not picked up causing an ICE\n+  real, dimension(2) :: res\n+  res = test(2) ! { dg-error \"needs an explicit INTERFACE\" }\n+  print *, res\n+end program"}, {"sha": "6ea319a9d12f3d9efd4c1025a1a994191e8982fe", "filename": "gcc/testsuite/gfortran.dg/whole_file_8.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_8.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+! Test the fix for the third problem in PR40011, where false\n+! type/rank mismatches were found in the main program calls.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+subroutine test_d(fn, val, res)\n+  double precision fn\n+  double precision val, res\n+\n+  print *, fn(val), res\n+end subroutine\n+\n+subroutine test_c(fn, val, res)\n+  complex fn\n+  complex val, res\n+\n+  print *, fn(val), res\n+end subroutine\n+\n+program specifics\n+\n+  intrinsic dcos\n+  intrinsic dcosh\n+  intrinsic dexp\n+\n+  intrinsic conjg\n+\n+  call test_d (dcos, 1d0, dcos(1d0))\n+  call test_d (dcosh, 1d0, dcosh(1d0))\n+  call test_d (dexp, 1d0, dexp(1d0))\n+\n+  call test_c (conjg, (1.0,1.0) , conjg((1.0,1.0)))\n+\n+end program"}, {"sha": "64dce42ee2134dd3d0b4ce9a74e57e96d8ca4d78", "filename": "gcc/testsuite/gfortran.dg/whole_file_9.f90", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fwhole_file_9.f90?ref=3af8d8cb86aeb7582f5c5e6ffc5c24f782d072f7", "patch": "@@ -0,0 +1,46 @@\n+! { dg-do compile }\n+! { dg-options \"-fwhole-file\" }\n+! Test the fix for the fourth problem in PR40011, where the\n+! entries were not resolved, resulting in a segfault.\n+!\n+! Contributed by Dominique d'Humieres <dominiq@lps.ens.fr>\n+!\n+program test\n+interface\n+  function bad_stuff(n)\n+    integer :: bad_stuff (2)\n+    integer :: n(2)\n+  end function bad_stuff\n+   recursive function rec_stuff(n) result (tmp)\n+    integer :: n(2), tmp(2)\n+  end function rec_stuff\n+end interface\n+   integer :: res(2)\n+  res = bad_stuff((/-19,-30/))\n+\n+end program test\n+\n+  recursive function bad_stuff(n)\n+    integer :: bad_stuff (2)\n+    integer :: n(2), tmp(2), ent = 0, sent = 0\n+    save ent, sent\n+    ent = -1\n+   entry rec_stuff(n) result (tmp)\n+    if (ent == -1) then\n+      sent = ent\n+      ent = 0\n+    end if\n+    ent = ent + 1\n+    tmp = 1\n+    if(maxval (n) < 5) then\n+      tmp = tmp + rec_stuff (n+1)\n+      ent = ent - 1\n+    endif\n+    if (ent == 1) then\n+      if (sent == -1) then\n+        bad_stuff = tmp + bad_stuff (1)\n+      end if\n+      ent = 0\n+      sent = 0\n+    end if\n+  end function bad_stuff"}]}