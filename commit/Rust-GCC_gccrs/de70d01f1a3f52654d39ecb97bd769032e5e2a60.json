{"sha": "de70d01f1a3f52654d39ecb97bd769032e5e2a60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU3MGQwMWYxYTNmNTI2NTRkMzllY2I5N2JkNzY5MDMyZTVlMmE2MA==", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2019-07-05T07:02:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-05T07:02:28Z"}, "message": "[Ada] Removing support for SCIL \"contract-only\" subprogram bodies\n\nRemove support added for CodePeer (which was never enabled by default;\nit was controlled by the -gnatd.K option) for generation of SCIL\n\"contract-only\" subprogram bodies. These were intended for use when a\nsubprogram's \"real\" body is unavailable but the subprogram spec has\npre/post-conditions specified.\n\n2019-07-05  Javier Miranda  <miranda@adacore.com>\n\ngcc/ada/\n\n\t* debug.adb (-gnatd.K): Leave available this switch.\n\t* contracts.adb (Build_And_Analyze_Contract_Only_Subprograms):\n\tRemove.\n\t* scil_ll.ads, scil_ll.adb (Contract_Only_Body_Flag,\n\tContract_Only_Body_Nodes, Get_Contract_Only_Body,\n\tIs_Contract_Only_Body, Set_Contract_Only_Body): Remove.\n\nFrom-SVN: r273111", "tree": {"sha": "f824752c3278aa4f5c46ad97fbad6e537c7ffac9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f824752c3278aa4f5c46ad97fbad6e537c7ffac9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de70d01f1a3f52654d39ecb97bd769032e5e2a60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de70d01f1a3f52654d39ecb97bd769032e5e2a60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de70d01f1a3f52654d39ecb97bd769032e5e2a60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de70d01f1a3f52654d39ecb97bd769032e5e2a60/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "034a6629f4b3d64bf53dda42bf79b328c6d83190", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/034a6629f4b3d64bf53dda42bf79b328c6d83190", "html_url": "https://github.com/Rust-GCC/gccrs/commit/034a6629f4b3d64bf53dda42bf79b328c6d83190"}], "stats": {"total": 594, "additions": 11, "deletions": 583}, "files": [{"sha": "ac29b9229ba752ee1ebd138b0221f34f044f912a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=de70d01f1a3f52654d39ecb97bd769032e5e2a60", "patch": "@@ -1,3 +1,12 @@\n+2019-07-05  Javier Miranda  <miranda@adacore.com>\n+\n+\t* debug.adb (-gnatd.K): Leave available this switch.\n+\t* contracts.adb (Build_And_Analyze_Contract_Only_Subprograms):\n+\tRemove.\n+\t* scil_ll.ads, scil_ll.adb (Contract_Only_Body_Flag,\n+\tContract_Only_Body_Nodes, Get_Contract_Only_Body,\n+\tIs_Contract_Only_Body, Set_Contract_Only_Body): Remove.\n+\n 2019-07-05  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* libgnat/a-strunb.ads: Import documentation from the RM"}, {"sha": "4610b53767e6355b65585d3b0f4e29303df2c1f5", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=de70d01f1a3f52654d39ecb97bd769032e5e2a60", "patch": "@@ -25,7 +25,6 @@\n \n with Aspects;  use Aspects;\n with Atree;    use Atree;\n-with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n@@ -51,7 +50,6 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n-with SCIL_LL;  use SCIL_LL;\n with Tbuild;   use Tbuild;\n \n package body Contracts is\n@@ -63,11 +61,6 @@ package body Contracts is\n    --\n    --    Part_Of\n \n-   procedure Build_And_Analyze_Contract_Only_Subprograms (L : List_Id);\n-   --  (CodePeer): Subsidiary procedure to Analyze_Contracts which builds the\n-   --  contract-only subprogram body of eligible subprograms found in L, adds\n-   --  them to their corresponding list of declarations, and analyzes them.\n-\n    procedure Expand_Subprogram_Contract (Body_Id : Entity_Id);\n    --  Expand the contracts of a subprogram body and its correspoding spec (if\n    --  any). This routine processes all [refined] pre- and postconditions as\n@@ -354,10 +347,6 @@ package body Contracts is\n       Decl : Node_Id;\n \n    begin\n-      if CodePeer_Mode and then Debug_Flag_Dot_KK then\n-         Build_And_Analyze_Contract_Only_Subprograms (L);\n-      end if;\n-\n       Decl := First (L);\n       while Present (Decl) loop\n \n@@ -1305,490 +1294,6 @@ package body Contracts is\n       Restore_SPARK_Mode (Saved_SM, Saved_SMP);\n    end Analyze_Task_Contract;\n \n-   -------------------------------------------------\n-   -- Build_And_Analyze_Contract_Only_Subprograms --\n-   -------------------------------------------------\n-\n-   procedure Build_And_Analyze_Contract_Only_Subprograms (L : List_Id) is\n-      procedure Analyze_Contract_Only_Subprograms;\n-      --  Analyze the contract-only subprograms of L\n-\n-      procedure Append_Contract_Only_Subprograms (Subp_List : List_Id);\n-      --  Append the contract-only bodies of Subp_List to its declarations list\n-\n-      function Build_Contract_Only_Subprogram (E : Entity_Id) return Node_Id;\n-      --  If E is an entity for a non-imported subprogram specification with\n-      --  pre/postconditions and we are compiling with CodePeer mode, then\n-      --  this procedure will create a wrapper to help Gnat2scil process its\n-      --  contracts. Return Empty if the wrapper cannot be built.\n-\n-      function Build_Contract_Only_Subprograms (L : List_Id) return List_Id;\n-      --  Build the contract-only subprograms of all eligible subprograms found\n-      --  in list L.\n-\n-      function Has_Private_Declarations (N : Node_Id) return Boolean;\n-      --  Return True for package specs, task definitions, and protected type\n-      --  definitions whose list of private declarations is not empty.\n-\n-      ---------------------------------------\n-      -- Analyze_Contract_Only_Subprograms --\n-      ---------------------------------------\n-\n-      procedure Analyze_Contract_Only_Subprograms is\n-         procedure Analyze_Contract_Only_Bodies;\n-         --  Analyze all the contract-only bodies of L\n-\n-         ----------------------------------\n-         -- Analyze_Contract_Only_Bodies --\n-         ----------------------------------\n-\n-         procedure Analyze_Contract_Only_Bodies is\n-            Decl : Node_Id;\n-\n-         begin\n-            Decl := First (L);\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Subprogram_Body\n-                 and then Is_Contract_Only_Body\n-                            (Defining_Unit_Name (Specification (Decl)))\n-               then\n-                  Analyze (Decl);\n-               end if;\n-\n-               Next (Decl);\n-            end loop;\n-         end Analyze_Contract_Only_Bodies;\n-\n-      --  Start of processing for Analyze_Contract_Only_Subprograms\n-\n-      begin\n-         if Ekind (Current_Scope) /= E_Package then\n-            Analyze_Contract_Only_Bodies;\n-\n-         else\n-            declare\n-               Pkg_Spec : constant Node_Id :=\n-                            Package_Specification (Current_Scope);\n-\n-            begin\n-               if not Has_Private_Declarations (Pkg_Spec) then\n-                  Analyze_Contract_Only_Bodies;\n-\n-               --  For packages with private declarations, the contract-only\n-               --  bodies of subprograms defined in the visible part of the\n-               --  package are added to its private declarations (to ensure\n-               --  that they do not cause premature freezing of types and also\n-               --  that they are analyzed with proper visibility). Hence they\n-               --  will be analyzed later.\n-\n-               elsif Visible_Declarations (Pkg_Spec) = L then\n-                  null;\n-\n-               elsif Private_Declarations (Pkg_Spec) = L then\n-                  Analyze_Contract_Only_Bodies;\n-               end if;\n-            end;\n-         end if;\n-      end Analyze_Contract_Only_Subprograms;\n-\n-      --------------------------------------\n-      -- Append_Contract_Only_Subprograms --\n-      --------------------------------------\n-\n-      procedure Append_Contract_Only_Subprograms (Subp_List : List_Id) is\n-      begin\n-         if No (Subp_List) then\n-            return;\n-         end if;\n-\n-         if Ekind (Current_Scope) /= E_Package then\n-            Append_List (Subp_List, To => L);\n-\n-         else\n-            declare\n-               Pkg_Spec : constant Node_Id :=\n-                            Package_Specification (Current_Scope);\n-\n-            begin\n-               if not Has_Private_Declarations (Pkg_Spec) then\n-                  Append_List (Subp_List, To => L);\n-\n-               --  If the package has private declarations then append them to\n-               --  its private declarations; they will be analyzed when the\n-               --  contracts of its private declarations are analyzed.\n-\n-               else\n-                  Append_List\n-                    (List => Subp_List,\n-                     To   => Private_Declarations (Pkg_Spec));\n-               end if;\n-            end;\n-         end if;\n-      end Append_Contract_Only_Subprograms;\n-\n-      ------------------------------------\n-      -- Build_Contract_Only_Subprogram --\n-      ------------------------------------\n-\n-      --  This procedure takes care of building a wrapper to generate better\n-      --  analysis results in the case of a call to a subprogram whose body\n-      --  is unavailable to CodePeer but whose specification includes Pre/Post\n-      --  conditions. The body might be unavailable for any of a number or\n-      --  reasons (it is imported, the .adb file is simply missing, or the\n-      --  subprogram might be subject to an Annotate (CodePeer, Skip_Analysis)\n-      --  pragma). The built subprogram has the following contents:\n-      --    * check preconditions\n-      --    * call the subprogram\n-      --    * check postconditions\n-\n-      function Build_Contract_Only_Subprogram (E : Entity_Id) return Node_Id is\n-         Loc : constant Source_Ptr := Sloc (E);\n-\n-         Missing_Body_Name : constant Name_Id :=\n-                               New_External_Name (Chars (E), \"__missing_body\");\n-\n-         function Build_Missing_Body_Decls return List_Id;\n-         --  Build the declaration of the missing body subprogram and its\n-         --  corresponding pragma Import.\n-\n-         function Build_Missing_Body_Subprogram_Call return Node_Id;\n-         --  Build the call to the missing body subprogram\n-\n-         function Skip_Contract_Only_Subprogram (E : Entity_Id) return Boolean;\n-         --  Return True for cases where the wrapper is not needed or we cannot\n-         --  build it.\n-\n-         ------------------------------\n-         -- Build_Missing_Body_Decls --\n-         ------------------------------\n-\n-         function Build_Missing_Body_Decls return List_Id is\n-            Spec : constant Node_Id := Declaration_Node (E);\n-            Decl : Node_Id;\n-            Prag : Node_Id;\n-\n-         begin\n-            Decl :=\n-              Make_Subprogram_Declaration (Loc, Copy_Subprogram_Spec (Spec));\n-            Set_Chars (Defining_Entity (Decl), Missing_Body_Name);\n-\n-            Prag :=\n-              Make_Pragma (Loc,\n-                Chars                        => Name_Import,\n-                Pragma_Argument_Associations => New_List (\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Make_Identifier (Loc, Name_Ada)),\n-\n-                  Make_Pragma_Argument_Association (Loc,\n-                    Expression => Make_Identifier (Loc, Missing_Body_Name))));\n-\n-            return New_List (Decl, Prag);\n-         end Build_Missing_Body_Decls;\n-\n-         ----------------------------------------\n-         -- Build_Missing_Body_Subprogram_Call --\n-         ----------------------------------------\n-\n-         function Build_Missing_Body_Subprogram_Call return Node_Id is\n-            Forml : Entity_Id;\n-            Parms : List_Id;\n-\n-         begin\n-            Parms := New_List;\n-\n-            --  Build parameter list that we need\n-\n-            Forml := First_Formal (E);\n-            while Present (Forml) loop\n-               Append_To (Parms, Make_Identifier (Loc, Chars (Forml)));\n-               Next_Formal (Forml);\n-            end loop;\n-\n-            --  Build the call to the missing body subprogram\n-\n-            if Ekind_In (E, E_Function, E_Generic_Function) then\n-               return\n-                 Make_Simple_Return_Statement (Loc,\n-                   Expression =>\n-                     Make_Function_Call (Loc,\n-                       Name                   =>\n-                         Make_Identifier (Loc, Missing_Body_Name),\n-                       Parameter_Associations => Parms));\n-\n-            else\n-               return\n-                 Make_Procedure_Call_Statement (Loc,\n-                   Name                   =>\n-                     Make_Identifier (Loc, Missing_Body_Name),\n-                   Parameter_Associations => Parms);\n-            end if;\n-         end Build_Missing_Body_Subprogram_Call;\n-\n-         -----------------------------------\n-         -- Skip_Contract_Only_Subprogram --\n-         -----------------------------------\n-\n-         function Skip_Contract_Only_Subprogram\n-           (E : Entity_Id) return Boolean\n-         is\n-            function Depends_On_Enclosing_Private_Type return Boolean;\n-            --  Return True if some formal of E (or its return type) are\n-            --  private types defined in an enclosing package.\n-\n-            function Some_Enclosing_Package_Has_Private_Decls return Boolean;\n-            --  Return True if some enclosing package of the current scope has\n-            --  private declarations.\n-\n-            ---------------------------------------\n-            -- Depends_On_Enclosing_Private_Type --\n-            ---------------------------------------\n-\n-            function Depends_On_Enclosing_Private_Type return Boolean is\n-               function Defined_In_Enclosing_Package\n-                 (Typ : Entity_Id) return Boolean;\n-               --  Return True if Typ is an entity defined in an enclosing\n-               --  package of the current scope.\n-\n-               ----------------------------------\n-               -- Defined_In_Enclosing_Package --\n-               ----------------------------------\n-\n-               function Defined_In_Enclosing_Package\n-                 (Typ : Entity_Id) return Boolean\n-               is\n-                  Scop : Entity_Id := Scope (Current_Scope);\n-\n-               begin\n-                  while Scop /= Scope (Typ)\n-                    and then not Is_Compilation_Unit (Scop)\n-                  loop\n-                     Scop := Scope (Scop);\n-                  end loop;\n-\n-                  return Scop = Scope (Typ);\n-               end Defined_In_Enclosing_Package;\n-\n-               --  Local variables\n-\n-               Param_E : Entity_Id;\n-               Typ     : Entity_Id;\n-\n-            --  Start of processing for Depends_On_Enclosing_Private_Type\n-\n-            begin\n-               Param_E := First_Entity (E);\n-               while Present (Param_E) loop\n-                  Typ := Etype (Param_E);\n-\n-                  if Is_Private_Type (Typ)\n-                    and then Defined_In_Enclosing_Package (Typ)\n-                  then\n-                     return True;\n-                  end if;\n-\n-                  Next_Entity (Param_E);\n-               end loop;\n-\n-               return\n-                 Ekind (E) = E_Function\n-                   and then Is_Private_Type (Etype (E))\n-                   and then Defined_In_Enclosing_Package (Etype (E));\n-            end Depends_On_Enclosing_Private_Type;\n-\n-            ----------------------------------------------\n-            -- Some_Enclosing_Package_Has_Private_Decls --\n-            ----------------------------------------------\n-\n-            function Some_Enclosing_Package_Has_Private_Decls return Boolean is\n-               Scop     : Entity_Id := Current_Scope;\n-               Pkg_Spec : Node_Id   := Package_Specification (Scop);\n-\n-            begin\n-               loop\n-                  if Ekind (Scop) = E_Package\n-                    and then Has_Private_Declarations\n-                               (Package_Specification (Scop))\n-                  then\n-                     Pkg_Spec := Package_Specification (Scop);\n-                  end if;\n-\n-                  exit when Is_Compilation_Unit (Scop);\n-                  Scop := Scope (Scop);\n-               end loop;\n-\n-               return Pkg_Spec /= Package_Specification (Current_Scope);\n-            end Some_Enclosing_Package_Has_Private_Decls;\n-\n-         --  Start of processing for Skip_Contract_Only_Subprogram\n-\n-         begin\n-            if not CodePeer_Mode\n-              or else Inside_A_Generic\n-              or else not Is_Subprogram (E)\n-              or else Is_Abstract_Subprogram (E)\n-              or else Is_Imported (E)\n-              or else No (Contract (E))\n-              or else No (Pre_Post_Conditions (Contract (E)))\n-              or else Is_Contract_Only_Body (E)\n-              or else Convention (E) = Convention_Protected\n-            then\n-               return True;\n-\n-            --  We do not support building the contract-only subprogram if E\n-            --  is a subprogram declared in a nested package that has some\n-            --  formal or return type depending on a private type defined in\n-            --  an enclosing package.\n-\n-            elsif Ekind (Current_Scope) = E_Package\n-              and then Some_Enclosing_Package_Has_Private_Decls\n-              and then Depends_On_Enclosing_Private_Type\n-            then\n-               if Debug_Flag_Dot_KK then\n-                  declare\n-                     Saved_Mode : constant Warning_Mode_Type := Warning_Mode;\n-\n-                  begin\n-                     --  Warnings are disabled by default under CodePeer_Mode\n-                     --  (see switch-c). Enable them temporarily.\n-\n-                     Warning_Mode := Normal;\n-                     Error_Msg_N\n-                       (\"cannot generate contract-only subprogram?\", E);\n-                     Warning_Mode := Saved_Mode;\n-                  end;\n-               end if;\n-\n-               return True;\n-            end if;\n-\n-            return False;\n-         end Skip_Contract_Only_Subprogram;\n-\n-      --  Start of processing for Build_Contract_Only_Subprogram\n-\n-      begin\n-         --  Test cases where the wrapper is not needed and cases where we\n-         --  cannot build it.\n-\n-         if Skip_Contract_Only_Subprogram (E) then\n-            return Empty;\n-         end if;\n-\n-         --  Note on calls to Copy_Separate_Tree. The trees we are copying\n-         --  here are fully analyzed, but we definitely want fully syntactic\n-         --  unanalyzed trees in the body we construct, so that the analysis\n-         --  generates the right visibility, and that is exactly what the\n-         --  calls to Copy_Separate_Tree give us.\n-\n-         declare\n-            Name : constant Name_Id :=\n-                     New_External_Name (Chars (E), \"__contract_only\");\n-            Id   : Entity_Id;\n-            Bod  : Node_Id;\n-\n-         begin\n-            Bod :=\n-              Make_Subprogram_Body (Loc,\n-                Specification              =>\n-                  Copy_Subprogram_Spec (Declaration_Node (E)),\n-                Declarations               =>\n-                  Build_Missing_Body_Decls,\n-                Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (\n-                      Build_Missing_Body_Subprogram_Call),\n-                    End_Label  => Make_Identifier (Loc, Name)));\n-\n-            Id := Defining_Unit_Name (Specification (Bod));\n-\n-            --  Copy only the pre/postconditions of the original contract\n-            --  since it is what we need, but also because pragmas stored in\n-            --  the other fields have N_Pragmas with N_Aspect_Specifications\n-            --  that reference their associated pragma (thus causing an endless\n-            --  loop when trying to copy the subtree).\n-\n-            declare\n-               New_Contract : constant Node_Id := Make_Contract (Sloc (E));\n-\n-            begin\n-               Set_Pre_Post_Conditions (New_Contract,\n-                 Copy_Separate_Tree (Pre_Post_Conditions (Contract (E))));\n-               Set_Contract (Id, New_Contract);\n-            end;\n-\n-            --  Fix the name of this new subprogram and link the original\n-            --  subprogram with its Contract_Only_Body subprogram.\n-\n-            Set_Chars (Id, Name);\n-            Set_Is_Contract_Only_Body (Id);\n-            Set_Contract_Only_Body (E, Id);\n-\n-            return Bod;\n-         end;\n-      end Build_Contract_Only_Subprogram;\n-\n-      -------------------------------------\n-      -- Build_Contract_Only_Subprograms --\n-      -------------------------------------\n-\n-      function Build_Contract_Only_Subprograms (L : List_Id) return List_Id is\n-         Decl     : Node_Id;\n-         New_Subp : Node_Id;\n-         Result   : List_Id := No_List;\n-         Subp_Id  : Entity_Id;\n-\n-      begin\n-         Decl := First (L);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Subprogram_Declaration then\n-               Subp_Id  := Defining_Unit_Name (Specification (Decl));\n-               New_Subp := Build_Contract_Only_Subprogram (Subp_Id);\n-\n-               if Present (New_Subp) then\n-                  if No (Result) then\n-                     Result := New_List;\n-                  end if;\n-\n-                  Append_To (Result, New_Subp);\n-               end if;\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n-\n-         return Result;\n-      end Build_Contract_Only_Subprograms;\n-\n-      ------------------------------\n-      -- Has_Private_Declarations --\n-      ------------------------------\n-\n-      function Has_Private_Declarations (N : Node_Id) return Boolean is\n-      begin\n-         if not Nkind_In (N, N_Package_Specification,\n-                             N_Protected_Definition,\n-                             N_Task_Definition)\n-         then\n-            return False;\n-         else\n-            return\n-              Present (Private_Declarations (N))\n-                and then Is_Non_Empty_List (Private_Declarations (N));\n-         end if;\n-      end Has_Private_Declarations;\n-\n-      --  Local variables\n-\n-      Subp_List : List_Id;\n-\n-   --  Start of processing for Build_And_Analyze_Contract_Only_Subprograms\n-\n-   begin\n-      Subp_List := Build_Contract_Only_Subprograms (L);\n-      Append_Contract_Only_Subprograms (Subp_List);\n-      Analyze_Contract_Only_Subprograms;\n-   end Build_And_Analyze_Contract_Only_Subprograms;\n-\n    -----------------------------\n    -- Create_Generic_Contract --\n    -----------------------------"}, {"sha": "2635654a89a688685f4b258175afdf145497ef0e", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=de70d01f1a3f52654d39ecb97bd769032e5e2a60", "patch": "@@ -128,7 +128,7 @@ package body Debug is\n    --  d.H  GNSA mode for ASIS\n    --  d.I  Do not ignore enum representation clauses in CodePeer mode\n    --  d.J  Relaxed rules for pragma No_Return\n-   --  d.K  Enable generation of contract-only procedures in CodePeer mode\n+   --  d.K\n    --  d.L  Depend on back end for limited types in if and case expressions\n    --  d.M  Relaxed RM semantics\n    --  d.N  Add node to all entities\n@@ -904,13 +904,6 @@ package body Debug is\n    --       for that. If the procedure does in fact return normally, execution\n    --       is erroneous, and therefore unpredictable.\n \n-   --  d.K  Enable generation of contract-only procedures in CodePeer mode and\n-   --       report a warning on subprograms for which the contract-only body\n-   --       cannot be built. Currently reported on subprograms defined in\n-   --       nested package specs that have some formal (or return type) whose\n-   --       type is a private type defined in some enclosing package and that\n-   --       have pre/postconditions.\n-\n    --  d.L  Normally the front end generates special expansion for conditional\n    --       expressions of a limited type. This debug flag removes this special\n    --       case expansion, leaving it up to the back end to handle conditional"}, {"sha": "841206d0db0abbba151509fdff1ad87cdd4132b9", "filename": "gcc/ada/scil_ll.adb", "status": "modified", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fscil_ll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fscil_ll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.adb?ref=de70d01f1a3f52654d39ecb97bd769032e5e2a60", "patch": "@@ -49,25 +49,6 @@ package body SCIL_LL is\n    -- Internal Hash Tables --\n    --------------------------\n \n-   package Contract_Only_Body_Flag is new Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Boolean,\n-      No_Element => False,\n-      Key        => Node_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  This table records the value of flag Is_Contract_Only_Flag of tree nodes\n-\n-   package Contract_Only_Body_Nodes is new Simple_HTable\n-     (Header_Num => Header_Num,\n-      Element    => Node_Id,\n-      No_Element => Empty,\n-      Key        => Node_Id,\n-      Hash       => Hash,\n-      Equal      => \"=\");\n-   --  This table records the value of attribute Contract_Only_Body of tree\n-   --  nodes.\n-\n    package SCIL_Nodes is new Simple_HTable\n      (Header_Num => Header_Num,\n       Element    => Node_Id,\n@@ -86,21 +67,6 @@ package body SCIL_LL is\n       Set_SCIL_Node (Target, Get_SCIL_Node (Source));\n    end Copy_SCIL_Node;\n \n-   ----------------------------\n-   -- Get_Contract_Only_Body --\n-   ----------------------------\n-\n-   function Get_Contract_Only_Body (N : Node_Id) return Node_Id is\n-   begin\n-      if CodePeer_Mode\n-        and then Present (N)\n-      then\n-         return Contract_Only_Body_Nodes.Get (N);\n-      else\n-         return Empty;\n-      end if;\n-   end Get_Contract_Only_Body;\n-\n    -------------------\n    -- Get_SCIL_Node --\n    -------------------\n@@ -132,42 +98,9 @@ package body SCIL_LL is\n    procedure Initialize is\n    begin\n       SCIL_Nodes.Reset;\n-      Contract_Only_Body_Nodes.Reset;\n-      Contract_Only_Body_Flag.Reset;\n       Set_Reporting_Proc (Copy_SCIL_Node'Access);\n    end Initialize;\n \n-   ---------------------------\n-   -- Is_Contract_Only_Body --\n-   ---------------------------\n-\n-   function Is_Contract_Only_Body (E : Entity_Id) return Boolean is\n-   begin\n-      return Contract_Only_Body_Flag.Get (E);\n-   end Is_Contract_Only_Body;\n-\n-   ----------------------------\n-   -- Set_Contract_Only_Body --\n-   ----------------------------\n-\n-   procedure Set_Contract_Only_Body (N : Node_Id; Value : Node_Id) is\n-   begin\n-      pragma Assert (CodePeer_Mode\n-        and then Present (N)\n-        and then Is_Contract_Only_Body (Value));\n-\n-      Contract_Only_Body_Nodes.Set (N, Value);\n-   end Set_Contract_Only_Body;\n-\n-   -------------------------------\n-   -- Set_Is_Contract_Only_Body --\n-   -------------------------------\n-\n-   procedure Set_Is_Contract_Only_Body (E : Entity_Id) is\n-   begin\n-      Contract_Only_Body_Flag.Set (E, True);\n-   end Set_Is_Contract_Only_Body;\n-\n    -------------------\n    -- Set_SCIL_Node --\n    -------------------"}, {"sha": "6246af76265e5c13a6050c722717cb22ab0d860f", "filename": "gcc/ada/scil_ll.ads", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fscil_ll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de70d01f1a3f52654d39ecb97bd769032e5e2a60/gcc%2Fada%2Fscil_ll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.ads?ref=de70d01f1a3f52654d39ecb97bd769032e5e2a60", "patch": "@@ -30,31 +30,19 @@\n ------------------------------------------------------------------------------\n \n --  This package extends the tree nodes with fields that are used to reference\n---  the SCIL node and the Contract_Only_Body of a subprogram with aspects.\n+--  the SCIL node.\n \n with Types; use Types;\n \n package SCIL_LL is\n \n-   function Get_Contract_Only_Body (N : Node_Id) return Node_Id;\n-   --  Read the value of attribute Contract_Only_Body\n-\n    function Get_SCIL_Node (N : Node_Id) return Node_Id;\n    --  Read the value of attribute SCIL node\n \n-   procedure Set_Contract_Only_Body (N : Node_Id; Value : Node_Id);\n-   --  Set the value of attribute Contract_Only_Body\n-\n    procedure Set_SCIL_Node (N : Node_Id; Value : Node_Id);\n    --  Set the value of attribute SCIL node\n \n    procedure Initialize;\n    --  Initialize the table of SCIL nodes\n \n-   function Is_Contract_Only_Body (E : Entity_Id) return Boolean;\n-   --  Return True if E is a Contract_Only_Body subprogram\n-\n-   procedure Set_Is_Contract_Only_Body (E : Entity_Id);\n-   --  Set E as Contract_Only_Body subprogram\n-\n end SCIL_LL;"}]}