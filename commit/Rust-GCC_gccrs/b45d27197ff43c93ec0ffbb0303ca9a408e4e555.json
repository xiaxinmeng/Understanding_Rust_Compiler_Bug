{"sha": "b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ1ZDI3MTk3ZmY0M2M5M2VjMGZmYmIwMzAzY2E5YTQwOGU0ZTU1NQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-05-28T13:24:16Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-05-28T13:24:16Z"}, "message": "tree-ssa-alias.c (ao_ref_init): New function.\n\n2009-05-28  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-alias.c (ao_ref_init): New function.\n\t(ao_ref_base): Likewise.\n\t(ao_ref_base_alias_set): Likewise.\n\t(ao_ref_alias_set): Likewise.\n\t(refs_may_alias_p_1): Change signature.\n\t(refs_may_alias_p): Adjust.\n\t(refs_anti_dependent_p): Likewise.\n\t(refs_output_dependent_p): Likewise.\n\t(call_may_clobber_ref_p_1): Change signature.\n\t(call_may_clobber_ref_p): Adjust.\n\t(stmt_may_clobber_ref_p_1): New function split out from ...\n\t(stmt_may_clobber_ref_p): ... here.\n\t(maybe_skip_until): Adjust signature.\n\t(get_continuation_for_phi): Likewise.\n\t(walk_non_aliased_vuses): Likewise.\n\t* tree-ssa-alias.h (struct ao_ref_s): New structure type.\n\t(ao_ref_init): Declare.\n\t(ao_ref_base): Likewise.\n\t(ao_ref_alias_set): Likewise.\n\t(stmt_may_clobber_ref_p_1): Likewise.\n\t(walk_non_aliased_vuses): Adjust.\n\t* tree-ssa-sccvn.c (ao_ref_init_from_vn_reference): New function.\n\t(get_ref_from_reference_ops): remove.\n\t(vn_reference_lookup_2): Adjust signature.\n\t(vn_reference_lookup_3): Do not re-build trees.  Handle unions.\n\t(vn_reference_lookup_pieces): Adjust signature, do not re-build\n\ttrees.\n\t(vn_reference_lookup): Adjust.\n\t(vn_reference_insert): Likewise.\n\t(vn_reference_insert_pieces): Adjust signature.\n\t(visit_reference_op_call): Adjust.\n\t* tree-ssa-pre.c (get_expr_type): Simplify.\n\t(phi_translate_1): Adjust.\n\t(compute_avail): Likewise.\n\t(translate_vuse_through_block): Do not re-build trees.\n\t(value_dies_in_block_x): Likewise.\n\t* tree-ssa-sccvn.h (struct vn_reference_s): Add type and alias-set\n\tfields.\n\t(vn_reference_lookup_pieces): Adjust declaration.\n\t(vn_reference_insert_pieces): Likewise.\n\n\t* gcc.dg/tree-ssa/ssa-fre-26.c: New testcase.\n\t* gcc.c-torture/execute/20090527-1.c: Likewise.\n\nFrom-SVN: r147953", "tree": {"sha": "b52d3f9e34439d91ac7faf7bf6abb10bcb34c45c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b52d3f9e34439d91ac7faf7bf6abb10bcb34c45c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "554223b6bde54d4a0365748ff9bccd78378969fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/554223b6bde54d4a0365748ff9bccd78378969fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/554223b6bde54d4a0365748ff9bccd78378969fd"}], "stats": {"total": 644, "additions": 487, "deletions": 157}, "files": [{"sha": "be7e92fd85752e027d421e1f486b79540b83f7e1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -1,3 +1,46 @@\n+2009-05-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.c (ao_ref_init): New function.\n+\t(ao_ref_base): Likewise.\n+\t(ao_ref_base_alias_set): Likewise.\n+\t(ao_ref_alias_set): Likewise.\n+\t(refs_may_alias_p_1): Change signature.\n+\t(refs_may_alias_p): Adjust.\n+\t(refs_anti_dependent_p): Likewise.\n+\t(refs_output_dependent_p): Likewise.\n+\t(call_may_clobber_ref_p_1): Change signature.\n+\t(call_may_clobber_ref_p): Adjust.\n+\t(stmt_may_clobber_ref_p_1): New function split out from ...\n+\t(stmt_may_clobber_ref_p): ... here.\n+\t(maybe_skip_until): Adjust signature.\n+\t(get_continuation_for_phi): Likewise.\n+\t(walk_non_aliased_vuses): Likewise.\n+\t* tree-ssa-alias.h (struct ao_ref_s): New structure type.\n+\t(ao_ref_init): Declare.\n+\t(ao_ref_base): Likewise.\n+\t(ao_ref_alias_set): Likewise.\n+\t(stmt_may_clobber_ref_p_1): Likewise.\n+\t(walk_non_aliased_vuses): Adjust.\n+\t* tree-ssa-sccvn.c (ao_ref_init_from_vn_reference): New function.\n+\t(get_ref_from_reference_ops): remove.\n+\t(vn_reference_lookup_2): Adjust signature.\n+\t(vn_reference_lookup_3): Do not re-build trees.  Handle unions.\n+\t(vn_reference_lookup_pieces): Adjust signature, do not re-build\n+\ttrees.\n+\t(vn_reference_lookup): Adjust.\n+\t(vn_reference_insert): Likewise.\n+\t(vn_reference_insert_pieces): Adjust signature.\n+\t(visit_reference_op_call): Adjust.\n+\t* tree-ssa-pre.c (get_expr_type): Simplify.\n+\t(phi_translate_1): Adjust.\n+\t(compute_avail): Likewise.\n+\t(translate_vuse_through_block): Do not re-build trees.\n+\t(value_dies_in_block_x): Likewise.\n+\t* tree-ssa-sccvn.h (struct vn_reference_s): Add type and alias-set\n+\tfields.\n+\t(vn_reference_lookup_pieces): Adjust declaration.\n+\t(vn_reference_insert_pieces): Likewise.\n+\n 2009-05-28  Benjamin Kosnik  <bkoz@redhat.com>\n \n \t* tree-ssa-copy.c (replace_exp_1): Move op for warning-free use"}, {"sha": "b0706c50a87bfa935d9cefde8517ec8e79d88133", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -1,3 +1,8 @@\n+2009-05-28  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-fre-26.c: New testcase.\n+\t* gcc.c-torture/execute/20090527-1.c: Likewise.\n+\n 2009-05-28  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/39754"}, {"sha": "d8e3711cdf6375d7c1cec4e9a948af3d5bbce6db", "filename": "gcc/testsuite/gcc.c-torture/execute/20090527-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090527-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090527-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090527-1.c?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -0,0 +1,38 @@\n+typedef enum { POSITION_ASIS, POSITION_UNSPECIFIED } unit_position;\n+\n+typedef enum { STATUS_UNKNOWN, STATUS_UNSPECIFIED } unit_status;\n+\n+typedef struct\n+{\n+  unit_position position;\n+  unit_status status;\n+} unit_flags;\n+\n+extern void abort (void);\n+\n+void\n+new_unit (unit_flags * flags)\n+{\n+  if (flags->status == STATUS_UNSPECIFIED)\n+    flags->status = STATUS_UNKNOWN;\n+\n+  if (flags->position == POSITION_UNSPECIFIED)\n+    flags->position = POSITION_ASIS;\n+\n+  switch (flags->status)\n+    {\n+    case STATUS_UNKNOWN:\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+}\n+\n+int main()\n+{\n+  unit_flags f;\n+  f.status = STATUS_UNSPECIFIED;\n+  new_unit (&f);\n+  return 0;\n+}"}, {"sha": "144d146b9355cd5ff682615a4677924dae41985c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-26.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-26.c?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-sra -fdump-tree-fre-details\" } */\n+\n+union U {\n+  float f;\n+  int i;\n+};\n+\n+int foo (union U *p)\n+{\n+  union U u;\n+  p->f = 0.0;\n+  u = *p;\n+  return u.i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"Replaced u.i with 0 in\" \"fre\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre\" } } */"}, {"sha": "e68fb51f0126cfad4b1f89213a5d59eb0e681304", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 131, "deletions": 42, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -439,6 +439,55 @@ debug_points_to_info_for (tree var)\n   dump_points_to_info_for (stderr, var);\n }\n \n+\n+/* Initializes the alias-oracle reference representation *R from REF.  */\n+\n+void\n+ao_ref_init (ao_ref *r, tree ref)\n+{\n+  r->ref = ref;\n+  r->base = NULL_TREE;\n+  r->offset = 0;\n+  r->size = -1;\n+  r->max_size = -1;\n+  r->ref_alias_set = -1;\n+  r->base_alias_set = -1;\n+}\n+\n+/* Returns the base object of the memory reference *REF.  */\n+\n+tree\n+ao_ref_base (ao_ref *ref)\n+{\n+  if (ref->base)\n+    return ref->base;\n+  ref->base = get_ref_base_and_extent (ref->ref, &ref->offset, &ref->size,\n+\t\t\t\t       &ref->max_size);\n+  return ref->base;\n+}\n+\n+/* Returns the base object alias set of the memory reference *REF.  */\n+\n+static alias_set_type ATTRIBUTE_UNUSED\n+ao_ref_base_alias_set (ao_ref *ref)\n+{\n+  if (ref->base_alias_set != -1)\n+    return ref->base_alias_set;\n+  ref->base_alias_set = get_alias_set (ao_ref_base (ref));\n+  return ref->base_alias_set;\n+}\n+\n+/* Returns the reference alias set of the memory reference *REF.  */\n+\n+alias_set_type\n+ao_ref_alias_set (ao_ref *ref)\n+{\n+  if (ref->ref_alias_set != -1)\n+    return ref->ref_alias_set;\n+  ref->ref_alias_set = get_alias_set (ref->ref);\n+  return ref->ref_alias_set;\n+}\n+\n /* Return 1 if TYPE1 and TYPE2 are to be considered equivalent for the\n    purpose of TBAA.  Return 0 if they are distinct and -1 if we cannot\n    decide.  */\n@@ -675,7 +724,7 @@ indirect_refs_may_alias_p (tree ref1, tree ptr1,\n /* Return true, if the two memory references REF1 and REF2 may alias.  */\n \n static bool\n-refs_may_alias_p_1 (tree ref1, tree ref2, bool tbaa_p)\n+refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n {\n   tree base1, base2;\n   HOST_WIDE_INT offset1 = 0, offset2 = 0;\n@@ -684,18 +733,26 @@ refs_may_alias_p_1 (tree ref1, tree ref2, bool tbaa_p)\n   bool var1_p, var2_p, ind1_p, ind2_p;\n   alias_set_type set;\n \n-  gcc_assert ((SSA_VAR_P (ref1)\n-\t       || handled_component_p (ref1)\n-\t       || INDIRECT_REF_P (ref1)\n-\t       || TREE_CODE (ref1) == TARGET_MEM_REF)\n-\t      && (SSA_VAR_P (ref2)\n-\t\t  || handled_component_p (ref2)\n-\t\t  || INDIRECT_REF_P (ref2)\n-\t\t  || TREE_CODE (ref2) == TARGET_MEM_REF));\n+  gcc_assert ((!ref1->ref\n+\t       || SSA_VAR_P (ref1->ref)\n+\t       || handled_component_p (ref1->ref)\n+\t       || INDIRECT_REF_P (ref1->ref)\n+\t       || TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n+\t      && (!ref2->ref\n+\t\t  || SSA_VAR_P (ref2->ref)\n+\t\t  || handled_component_p (ref2->ref)\n+\t\t  || INDIRECT_REF_P (ref2->ref)\n+\t\t  || TREE_CODE (ref2->ref) == TARGET_MEM_REF));\n \n   /* Decompose the references into their base objects and the access.  */\n-  base1 = get_ref_base_and_extent (ref1, &offset1, &size1, &max_size1);\n-  base2 = get_ref_base_and_extent (ref2, &offset2, &size2, &max_size2);\n+  base1 = ao_ref_base (ref1);\n+  offset1 = ref1->offset;\n+  size1 = ref1->size;\n+  max_size1 = ref1->max_size;\n+  base2 = ao_ref_base (ref2);\n+  offset2 = ref2->offset;\n+  size2 = ref2->size;\n+  max_size2 = ref2->max_size;\n \n   /* We can end up with registers or constants as bases for example from\n      *D.1663_44 = VIEW_CONVERT_EXPR<struct DB_LSN>(__tmp$B0F64_59);\n@@ -719,34 +776,35 @@ refs_may_alias_p_1 (tree ref1, tree ref2, bool tbaa_p)\n   /* First defer to TBAA if possible.  */\n   if (tbaa_p\n       && flag_strict_aliasing\n-      && !alias_sets_conflict_p (get_alias_set (ref1), get_alias_set (ref2)))\n+      && !alias_sets_conflict_p (ao_ref_alias_set (ref1),\n+\t\t\t\t ao_ref_alias_set (ref2)))\n     return false;\n \n   /* If one reference is a TARGET_MEM_REF weird things are allowed.  Still\n      TBAA disambiguation based on the access type is possible, so bail\n      out only after that check.  */\n-  if (TREE_CODE (ref1) == TARGET_MEM_REF\n-      || TREE_CODE (ref2) == TARGET_MEM_REF)\n+  if ((ref1->ref && TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n+      || (ref2->ref && TREE_CODE (ref2->ref) == TARGET_MEM_REF))\n     return true;\n \n   /* Dispatch to the pointer-vs-decl or pointer-vs-pointer disambiguators.  */\n   ind1_p = INDIRECT_REF_P (base1);\n   ind2_p = INDIRECT_REF_P (base2);\n   set = tbaa_p ? -1 : 0;\n   if (var1_p && ind2_p)\n-    return indirect_ref_may_alias_decl_p (ref2, TREE_OPERAND (base2, 0),\n+    return indirect_ref_may_alias_decl_p (ref2->ref, TREE_OPERAND (base2, 0),\n \t\t\t\t\t  offset2, max_size2, set,\n-\t\t\t\t\t  ref1, base1,\n+\t\t\t\t\t  ref1->ref, base1,\n \t\t\t\t\t  offset1, max_size1, set);\n   else if (ind1_p && var2_p)\n-    return indirect_ref_may_alias_decl_p (ref1, TREE_OPERAND (base1, 0),\n+    return indirect_ref_may_alias_decl_p (ref1->ref, TREE_OPERAND (base1, 0),\n \t\t\t\t\t  offset1, max_size1, set,\n-\t\t\t\t\t  ref2, base2,\n+\t\t\t\t\t  ref2->ref, base2,\n \t\t\t\t\t  offset2, max_size2, set);\n   else if (ind1_p && ind2_p)\n-    return indirect_refs_may_alias_p (ref1, TREE_OPERAND (base1, 0),\n+    return indirect_refs_may_alias_p (ref1->ref, TREE_OPERAND (base1, 0),\n \t\t\t\t      offset1, max_size1, set,\n-\t\t\t\t      ref2, TREE_OPERAND (base2, 0),\n+\t\t\t\t      ref2->ref, TREE_OPERAND (base2, 0),\n \t\t\t\t      offset2, max_size2, set);\n \n   gcc_unreachable ();\n@@ -755,7 +813,11 @@ refs_may_alias_p_1 (tree ref1, tree ref2, bool tbaa_p)\n bool\n refs_may_alias_p (tree ref1, tree ref2)\n {\n-  bool res = refs_may_alias_p_1 (ref1, ref2, true);\n+  ao_ref r1, r2;\n+  bool res;\n+  ao_ref_init (&r1, ref1);\n+  ao_ref_init (&r2, ref2);\n+  res = refs_may_alias_p_1 (&r1, &r2, true);\n   if (res)\n     ++alias_stats.refs_may_alias_p_may_alias;\n   else\n@@ -769,7 +831,10 @@ refs_may_alias_p (tree ref1, tree ref2)\n bool\n refs_anti_dependent_p (tree load, tree store)\n {\n-  return refs_may_alias_p_1 (load, store, false);\n+  ao_ref r1, r2;\n+  ao_ref_init (&r1, load);\n+  ao_ref_init (&r2, store);\n+  return refs_may_alias_p_1 (&r1, &r2, false);\n }\n \n /* Returns true if there is a output dependence for the stores\n@@ -778,7 +843,10 @@ refs_anti_dependent_p (tree load, tree store)\n bool\n refs_output_dependent_p (tree store1, tree store2)\n {\n-  return refs_may_alias_p_1 (store1, store2, false);\n+  ao_ref r1, r2;\n+  ao_ref_init (&r1, store1);\n+  ao_ref_init (&r2, store2);\n+  return refs_may_alias_p_1 (&r1, &r2, false);\n }\n \n /* If the call CALL may use the memory reference REF return true,\n@@ -907,7 +975,7 @@ ref_maybe_used_by_stmt_p (gimple stmt, tree ref)\n    return true, otherwise return false.  */\n \n static bool\n-call_may_clobber_ref_p_1 (gimple call, tree ref)\n+call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n {\n   tree base;\n \n@@ -916,7 +984,7 @@ call_may_clobber_ref_p_1 (gimple call, tree ref)\n       & (ECF_PURE|ECF_CONST|ECF_LOOPING_CONST_OR_PURE|ECF_NOVOPS))\n     return false;\n \n-  base = get_base_address (ref);\n+  base = ao_ref_base (ref);\n   if (!base)\n     return true;\n \n@@ -957,10 +1025,13 @@ call_may_clobber_ref_p_1 (gimple call, tree ref)\n   return true;\n }\n \n-static bool\n+static bool ATTRIBUTE_UNUSED\n call_may_clobber_ref_p (gimple call, tree ref)\n {\n-  bool res = call_may_clobber_ref_p_1 (call, ref);\n+  bool res;\n+  ao_ref r;\n+  ao_ref_init (&r, ref);\n+  res = call_may_clobber_ref_p_1 (call, &r);\n   if (res)\n     ++alias_stats.call_may_clobber_ref_p_may_alias;\n   else\n@@ -973,34 +1044,52 @@ call_may_clobber_ref_p (gimple call, tree ref)\n    otherwise return false.  */\n \n bool\n-stmt_may_clobber_ref_p (gimple stmt, tree ref)\n+stmt_may_clobber_ref_p_1 (gimple stmt, ao_ref *ref)\n {\n   if (is_gimple_call (stmt))\n     {\n       tree lhs = gimple_call_lhs (stmt);\n       if (lhs\n-\t  && !is_gimple_reg (lhs)\n-\t  && refs_may_alias_p (ref, lhs))\n-\treturn true;\n+\t  && !is_gimple_reg (lhs))\n+\t{\n+\t  ao_ref r;\n+\t  ao_ref_init (&r, lhs);\n+\t  if (refs_may_alias_p_1 (ref, &r, true))\n+\t    return true;\n+\t}\n \n-      return call_may_clobber_ref_p (stmt, ref);\n+      return call_may_clobber_ref_p_1 (stmt, ref);\n     }\n   else if (is_gimple_assign (stmt))\n-    return refs_may_alias_p (ref, gimple_assign_lhs (stmt));\n+    {\n+      ao_ref r;\n+      ao_ref_init (&r, gimple_assign_lhs (stmt));\n+      return refs_may_alias_p_1 (ref, &r, true);\n+    }\n   else if (gimple_code (stmt) == GIMPLE_ASM)\n     return true;\n \n   return false;\n }\n \n-static tree get_continuation_for_phi (gimple, tree, bitmap *);\n+bool\n+stmt_may_clobber_ref_p (gimple stmt, tree ref)\n+{\n+  ao_ref r;\n+  ao_ref_init (&r, ref);\n+  return stmt_may_clobber_ref_p_1 (stmt, &r);\n+}\n+\n+\n+static tree get_continuation_for_phi (gimple, ao_ref *, bitmap *);\n \n /* Walk the virtual use-def chain of VUSE until hitting the virtual operand\n    TARGET or a statement clobbering the memory reference REF in which\n    case false is returned.  The walk starts with VUSE, one argument of PHI.  */\n \n static bool\n-maybe_skip_until (gimple phi, tree target, tree ref, tree vuse, bitmap *visited)\n+maybe_skip_until (gimple phi, tree target, ao_ref *ref,\n+\t\t  tree vuse, bitmap *visited)\n {\n   if (!*visited)\n     *visited = BITMAP_ALLOC (NULL);\n@@ -1024,7 +1113,7 @@ maybe_skip_until (gimple phi, tree target, tree ref, tree vuse, bitmap *visited)\n \t}\n       /* A clobbering statement or the end of the IL ends it failing.  */\n       else if (gimple_nop_p (def_stmt)\n-\t       || stmt_may_clobber_ref_p (def_stmt, ref))\n+\t       || stmt_may_clobber_ref_p_1 (def_stmt, ref))\n \treturn false;\n       vuse = gimple_vuse (def_stmt);\n     }\n@@ -1038,7 +1127,7 @@ maybe_skip_until (gimple phi, tree target, tree ref, tree vuse, bitmap *visited)\n    be found.  */\n \n static tree\n-get_continuation_for_phi (gimple phi, tree ref, bitmap *visited)\n+get_continuation_for_phi (gimple phi, ao_ref *ref, bitmap *visited)\n {\n   unsigned nargs = gimple_phi_num_args (phi);\n \n@@ -1096,9 +1185,9 @@ get_continuation_for_phi (gimple phi, tree ref, bitmap *visited)\n    TODO: Cache the vector of equivalent vuses per ref, vuse pair.  */\n \n void *\n-walk_non_aliased_vuses (tree ref, tree vuse,\n-\t\t\tvoid *(*walker)(tree, tree, void *),\n-\t\t\tvoid *(*translate)(tree *, tree, void *),void *data)\n+walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n+\t\t\tvoid *(*walker)(ao_ref *, tree, void *),\n+\t\t\tvoid *(*translate)(ao_ref *, tree, void *), void *data)\n {\n   bitmap visited = NULL;\n   void *res;\n@@ -1121,11 +1210,11 @@ walk_non_aliased_vuses (tree ref, tree vuse,\n \tvuse = get_continuation_for_phi (def_stmt, ref, &visited);\n       else\n \t{\n-\t  if (stmt_may_clobber_ref_p (def_stmt, ref))\n+\t  if (stmt_may_clobber_ref_p_1 (def_stmt, ref))\n \t    {\n \t      if (!translate)\n \t\tbreak;\n-\t      res = (*translate) (&ref, vuse, data);\n+\t      res = (*translate) (ref, vuse, data);\n \t      /* Failed lookup and translation.  */\n \t      if (res == (void *)-1)\n \t\t{"}, {"sha": "115d393551212f33ce7d4a4639337ead63c6d669", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -74,17 +74,50 @@ struct GTY(()) pt_solution\n };\n \n \n+/* Simplified and cached information about a memory reference tree.\n+   Used by the alias-oracle internally and externally in alternate\n+   interfaces.  */\n+typedef struct ao_ref_s\n+{\n+  /* The original full memory reference tree or NULL_TREE if that is\n+     not available.  */\n+  tree ref;\n+\n+  /* The following fields are the decomposed reference as returned\n+     by get_ref_base_and_extent.  */\n+  /* The base object of the memory reference or NULL_TREE if all of\n+     the following fields are not yet computed.  */\n+  tree base;\n+  /* The offset relative to the base.  */\n+  HOST_WIDE_INT offset;\n+  /* The size of the access.  */\n+  HOST_WIDE_INT size;\n+  /* The maximum possible extent of the access or -1 if unconstrained.  */\n+  HOST_WIDE_INT max_size;\n+\n+  /* The alias set of the access or -1 if not yet computed.  */\n+  alias_set_type ref_alias_set;\n+\n+  /* The alias set of the base object or -1 if not yet computed.  */\n+  alias_set_type base_alias_set;\n+} ao_ref;\n+\n+\n /* In tree-ssa-alias.c  */\n+extern void ao_ref_init (ao_ref *, tree);\n+extern tree ao_ref_base (ao_ref *);\n+extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern enum escape_type is_escape_site (gimple);\n extern bool ptr_deref_may_alias_global_p (tree);\n extern bool refs_may_alias_p (tree, tree);\n extern bool refs_anti_dependent_p (tree, tree);\n extern bool refs_output_dependent_p (tree, tree);\n extern bool ref_maybe_used_by_stmt_p (gimple, tree);\n extern bool stmt_may_clobber_ref_p (gimple, tree);\n-extern void *walk_non_aliased_vuses (tree, tree,\n-\t\t\t\t     void *(*)(tree, tree, void *),\n-\t\t\t\t     void *(*)(tree *, tree, void *), void *);\n+extern bool stmt_may_clobber_ref_p_1 (gimple, ao_ref *);\n+extern void *walk_non_aliased_vuses (ao_ref *, tree,\n+\t\t\t\t     void *(*)(ao_ref *, tree, void *),\n+\t\t\t\t     void *(*)(ao_ref *, tree, void *), void *);\n extern unsigned int walk_aliased_vdefs (tree, tree,\n \t\t\t\t\tbool (*)(tree, tree, void *), void *,\n \t\t\t\t\tbitmap *);"}, {"sha": "fc311bcdbf93a9a31454b2039a8de20a89a80e75", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -1252,12 +1252,12 @@ fully_constant_expression (pre_expr e)\n \n static tree\n translate_vuse_through_block (VEC (vn_reference_op_s, heap) *operands,\n-\t\t\t      tree vuse,\n+\t\t\t      alias_set_type set, tree type, tree vuse,\n \t\t\t      basic_block phiblock,\n \t\t\t      basic_block block)\n {\n   gimple phi = SSA_NAME_DEF_STMT (vuse);\n-  tree ref;\n+  ao_ref ref;\n \n   if (gimple_bb (phi) != phiblock)\n     return vuse;\n@@ -1268,13 +1268,13 @@ translate_vuse_through_block (VEC (vn_reference_op_s, heap) *operands,\n       return PHI_ARG_DEF (phi, e->dest_idx);\n     }\n \n-  if (!(ref = get_ref_from_reference_ops (operands)))\n+  if (!ao_ref_init_from_vn_reference (&ref, set, type, operands))\n     return NULL_TREE;\n \n   /* Use the alias-oracle to find either the PHI node in this block,\n      the first VUSE used in this block that is equivalent to vuse or\n      the first VUSE which definition in this block kills the value.  */\n-  while (!stmt_may_clobber_ref_p (phi, ref))\n+  while (!stmt_may_clobber_ref_p_1 (phi, &ref))\n     {\n       vuse = gimple_vuse (phi);\n       phi = SSA_NAME_DEF_STMT (vuse);\n@@ -1317,23 +1317,7 @@ get_expr_type (const pre_expr e)\n     case CONSTANT:\n       return TREE_TYPE (PRE_EXPR_CONSTANT (e));\n     case REFERENCE:\n-      {\n-\tvn_reference_op_t vro;\n-\n-\tgcc_assert (PRE_EXPR_REFERENCE (e)->operands);\n-\tvro = VEC_index (vn_reference_op_s,\n-\t\t\t PRE_EXPR_REFERENCE (e)->operands,\n-\t\t\t 0);\n-\t/* We don't store type along with COMPONENT_REF because it is\n-\t   always the same as FIELD_DECL's type.  */\n-\tif (!vro->type)\n-\t  {\n-\t    gcc_assert (vro->opcode == COMPONENT_REF);\n-\t    return TREE_TYPE (vro->op0);\n-\t  }\n-\treturn vro->type;\n-      }\n-\n+      return PRE_EXPR_REFERENCE (e)->type;\n     case NARY:\n       return PRE_EXPR_NARY (e)->type;\n     }\n@@ -1661,6 +1645,7 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \tif (vuse)\n \t  {\n \t    newvuse = translate_vuse_through_block (newoperands,\n+\t\t\t\t\t\t    ref->set, ref->type,\n \t\t\t\t\t\t    vuse, phiblock, pred);\n \t    if (newvuse == NULL_TREE)\n \t      {\n@@ -1675,7 +1660,8 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t    unsigned int new_val_id;\n \t    pre_expr constant;\n \n-\t    tree result = vn_reference_lookup_pieces (newvuse,\n+\t    tree result = vn_reference_lookup_pieces (newvuse, ref->set,\n+\t\t\t\t\t\t      ref->type,\n \t\t\t\t\t\t      newoperands,\n \t\t\t\t\t\t      &newref, true);\n \t    if (newref)\n@@ -1706,7 +1692,8 @@ phi_translate_1 (pre_expr expr, bitmap_set_t set1, bitmap_set_t set2,\n \t\tnew_val_id = get_next_value_id ();\n \t\tVEC_safe_grow_cleared (bitmap_set_t, heap, value_expressions,\n \t\t\t\t       get_max_value_id() + 1);\n-\t\tnewref = vn_reference_insert_pieces (newvuse,\n+\t\tnewref = vn_reference_insert_pieces (newvuse, ref->set,\n+\t\t\t\t\t\t     ref->type,\n \t\t\t\t\t\t     newoperands,\n \t\t\t\t\t\t     result, new_val_id);\n \t\tnewoperands = NULL;\n@@ -1884,10 +1871,10 @@ value_dies_in_block_x (pre_expr expr, basic_block block)\n   tree vuse = PRE_EXPR_REFERENCE (expr)->vuse;\n   vn_reference_t refx = PRE_EXPR_REFERENCE (expr);\n   gimple def;\n-  tree ref = NULL_TREE;\n   gimple_stmt_iterator gsi;\n   unsigned id = get_expression_id (expr);\n   bool res = false;\n+  ao_ref ref;\n \n   if (!vuse)\n     return false;\n@@ -1902,6 +1889,7 @@ value_dies_in_block_x (pre_expr expr, basic_block block)\n      top of the basic block, a statement uses VUSE there can be no kill\n      inbetween that use and the original statement that loaded {e, VUSE},\n      so we can stop walking.  */\n+  ref.base = NULL_TREE;\n   for (gsi = gsi_start_bb (block); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree def_vuse, def_vdef;\n@@ -1924,16 +1912,15 @@ value_dies_in_block_x (pre_expr expr, basic_block block)\n \t}\n \n       /* Init ref only if we really need it.  */\n-      if (ref == NULL_TREE)\n+      if (ref.base == NULL_TREE\n+\t  && !ao_ref_init_from_vn_reference (&ref, refx->set, refx->type,\n+\t\t\t\t\t     refx->operands))\n \t{\n-\t  if (!(ref = get_ref_from_reference_ops (refx->operands)))\n-\t    {\n-\t      res = true;\n-\t      break;\n-\t    }\n+\t  res = true;\n+\t  break;\n \t}\n       /* If the statement may clobber expr, it dies.  */\n-      if (stmt_may_clobber_ref_p (def, ref))\n+      if (stmt_may_clobber_ref_p_1 (def, &ref))\n \t{\n \t  res = true;\n \t  break;\n@@ -3793,7 +3780,8 @@ compute_avail (void)\n \t\t  continue;\n \n \t\tcopy_reference_ops_from_call (stmt, &ops);\n-\t\tvn_reference_lookup_pieces (gimple_vuse (stmt),\n+\t\tvn_reference_lookup_pieces (gimple_vuse (stmt), 0,\n+\t\t\t\t\t    gimple_expr_type (stmt),\n \t\t\t\t\t    ops, &ref, false);\n \t\tVEC_free (vn_reference_op_s, heap, ops);\n \t\tif (!ref)"}, {"sha": "4ee4e39afcd243bf454aab55db3e45e225e401b0", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 190, "deletions": 77, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -543,28 +543,35 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n \t     a matching type is not necessary and a mismatching type\n \t     is always a spurious difference.  */\n \t  temp.type = NULL_TREE;\n+\t  temp.op0 = TREE_OPERAND (ref, 1);\n+\t  temp.op1 = TREE_OPERAND (ref, 2);\n \t  /* If this is a reference to a union member, record the union\n \t     member size as operand.  Do so only if we are doing\n \t     expression insertion (during FRE), as PRE currently gets\n \t     confused with this.  */\n \t  if (may_insert\n-\t      && TREE_OPERAND (ref, 2) == NULL_TREE\n-\t      && TREE_CODE (DECL_CONTEXT (TREE_OPERAND (ref, 1))) == UNION_TYPE\n-\t      && integer_zerop (DECL_FIELD_OFFSET (TREE_OPERAND (ref, 1)))\n-\t      && integer_zerop (DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1))))\n-\t    temp.op0 = TYPE_SIZE (TREE_TYPE (TREE_OPERAND (ref, 1)));\n-\t  else\n-\t    {\n-\t      /* Record field as operand.  */\n-\t      temp.op0 = TREE_OPERAND (ref, 1);\n-\t      temp.op1 = TREE_OPERAND (ref, 2);\n-\t    }\n+\t      && temp.op1 == NULL_TREE\n+\t      && TREE_CODE (DECL_CONTEXT (temp.op0)) == UNION_TYPE\n+\t      && integer_zerop (DECL_FIELD_OFFSET (temp.op0))\n+\t      && integer_zerop (DECL_FIELD_BIT_OFFSET (temp.op0))\n+\t      && host_integerp (TYPE_SIZE (TREE_TYPE (temp.op0)), 0))\n+\t    temp.op0 = TYPE_SIZE (TREE_TYPE (temp.op0));\n \t  break;\n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n \t  /* Record index as operand.  */\n \t  temp.op0 = TREE_OPERAND (ref, 1);\n-\t  temp.op1 = TREE_OPERAND (ref, 2);\n+\t  /* Record even constant lower bounds.  */\n+\t  if (TREE_OPERAND (ref, 2))\n+\t    temp.op1 = TREE_OPERAND (ref, 2);\n+\t  else\n+\t    {\n+\t      tree domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n+\t      if (domain\n+\t\t  && TYPE_MIN_VALUE (domain)\n+\t\t  && !integer_zerop (TYPE_MIN_VALUE (domain)))\n+\t\ttemp.op1 = TYPE_MIN_VALUE (domain);\n+\t    }\n \t  temp.op2 = TREE_OPERAND (ref, 3);\n \t  break;\n \tcase STRING_CST:\n@@ -612,24 +619,68 @@ copy_reference_ops_from_ref (tree ref, VEC(vn_reference_op_s, heap) **result)\n     }\n }\n \n-/* Re-create a reference tree from the reference ops OPS.\n-   Returns NULL_TREE if the ops were not handled.\n-   This routine needs to be kept in sync with copy_reference_ops_from_ref.  */\n+/* Build a alias-oracle reference abstraction in *REF from the vn_reference\n+   operands in *OPS, the reference alias set SET and the reference type TYPE.\n+   Return true if something useful was produced.  */\n \n-tree\n-get_ref_from_reference_ops (VEC(vn_reference_op_s, heap) *ops)\n+bool\n+ao_ref_init_from_vn_reference (ao_ref *ref,\n+\t\t\t       alias_set_type set, tree type,\n+\t\t\t       VEC (vn_reference_op_s, heap) *ops)\n {\n   vn_reference_op_t op;\n   unsigned i;\n-  tree ref, *op0_p = &ref;\n+  tree base = NULL_TREE;\n+  tree *op0_p = &base;\n+  HOST_WIDE_INT offset = 0;\n+  HOST_WIDE_INT max_size;\n+  HOST_WIDE_INT size = -1;\n+  tree size_tree = NULL_TREE;\n+\n+  /* First get the final access size from just the outermost expression.  */\n+  op = VEC_index (vn_reference_op_s, ops, 0);\n+  if (op->opcode == COMPONENT_REF)\n+    {\n+      if (TREE_CODE (op->op0) == INTEGER_CST)\n+\tsize_tree = op->op0;\n+      else\n+\tsize_tree = DECL_SIZE (op->op0);\n+    }\n+  else if (op->opcode == BIT_FIELD_REF)\n+    size_tree = op->op0;\n+  else\n+    {\n+      enum machine_mode mode = TYPE_MODE (type);\n+      if (mode == BLKmode)\n+\tsize_tree = TYPE_SIZE (type);\n+      else\n+        size = GET_MODE_BITSIZE (mode);\n+    }\n+  if (size_tree != NULL_TREE)\n+    {\n+      if (!host_integerp (size_tree, 1))\n+\tsize = -1;\n+      else\n+\tsize = TREE_INT_CST_LOW (size_tree);\n+    }\n \n+  /* Initially, maxsize is the same as the accessed element size.\n+     In the following it will only grow (or become -1).  */\n+  max_size = size;\n+\n+  /* Compute cumulative bit-offset for nested component-refs and array-refs,\n+     and find the ultimate containing object.  */\n   for (i = 0; VEC_iterate (vn_reference_op_s, ops, i, op); ++i)\n     {\n       switch (op->opcode)\n \t{\n+\t/* These may be in the reference ops, but we cannot do anything\n+\t   sensible with them here.  */\n \tcase CALL_EXPR:\n-\t  return NULL_TREE;\n+\tcase ADDR_EXPR:\n+\t  return false;\n \n+\t/* Record the base objects.  */\n \tcase ALIGN_INDIRECT_REF:\n \tcase INDIRECT_REF:\n \t  *op0_p = build1 (op->opcode, op->type, NULL_TREE);\n@@ -642,26 +693,69 @@ get_ref_from_reference_ops (VEC(vn_reference_op_s, heap) *ops)\n \t  op0_p = &TREE_OPERAND (*op0_p, 0);\n \t  break;\n \n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase RESULT_DECL:\n+\tcase SSA_NAME:\n+\tcase FILTER_EXPR:\n+\tcase EXC_PTR_EXPR:\n+\t  *op0_p = op->op0;\n+\t  break;\n+\n+\t/* And now the usual component-reference style ops.  */\n \tcase BIT_FIELD_REF:\n-\t  *op0_p = build3 (BIT_FIELD_REF, op->type, NULL_TREE,\n-\t\t\t   op->op0, op->op1);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n+\t  offset += tree_low_cst (op->op1, 0);\n \t  break;\n \n \tcase COMPONENT_REF:\n-\t  /* We cannot re-construct our fancy union reference handling.  */\n-\t  if (TREE_CODE (op->op0) == INTEGER_CST)\n-\t    return NULL_TREE;\n-\t  *op0_p = build3 (COMPONENT_REF, TREE_TYPE (op->op0), NULL_TREE,\n-\t\t\t   op->op0, op->op1);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n-\t  break;\n+\t  {\n+\t    tree field = op->op0;\n+\t    /* We do not have a complete COMPONENT_REF tree here so we\n+\t       cannot use component_ref_field_offset.  Do the interesting\n+\t       parts manually.  */\n+\n+\t    /* Our union trick, done for offset zero only.  */\n+\t    if (TREE_CODE (field) == INTEGER_CST)\n+\t      ;\n+\t    else if (op->op1\n+\t\t     || !host_integerp (DECL_FIELD_OFFSET (field), 1))\n+\t      max_size = -1;\n+\t    else\n+\t      {\n+\t\toffset += (TREE_INT_CST_LOW (DECL_FIELD_OFFSET (field))\n+\t\t\t   * BITS_PER_UNIT);\n+\t\toffset += TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (field));\n+\t      }\n+\t    break;\n+\t  }\n \n \tcase ARRAY_RANGE_REF:\n \tcase ARRAY_REF:\n-\t  *op0_p = build4 (op->opcode, op->type, NULL_TREE,\n-\t\t\t   op->op0, op->op1, op->op2);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n+\t  /* Same for ARRAY_REFs.  We do not have access to the array\n+\t     type here, but we recorded the lower bound in op1.  */\n+\t  if (op->op2\n+\t      || !host_integerp (op->op0, 0)\n+\t      || (op->op1 && !host_integerp (op->op1, 0))\n+\t      || !host_integerp (TYPE_SIZE (op->type), 1))\n+\t    max_size = -1;\n+\t  else\n+\t    {\n+\t      HOST_WIDE_INT hindex = TREE_INT_CST_LOW (op->op0);\n+\t      if (op->op1)\n+\t\thindex -= TREE_INT_CST_LOW (op->op1);\n+\t      hindex *= TREE_INT_CST_LOW (TYPE_SIZE (op->type));\n+\t      offset += hindex;\n+\t    }\n+\t  break;\n+\n+\tcase REALPART_EXPR:\n+\t  break;\n+\n+\tcase IMAGPART_EXPR:\n+\t  offset += size;\n+\t  break;\n+\n+\tcase VIEW_CONVERT_EXPR:\n \t  break;\n \n \tcase STRING_CST:\n@@ -670,37 +764,26 @@ get_ref_from_reference_ops (VEC(vn_reference_op_s, heap) *ops)\n \tcase VECTOR_CST:\n \tcase REAL_CST:\n \tcase CONSTRUCTOR:\n-\tcase VAR_DECL:\n-\tcase PARM_DECL:\n \tcase CONST_DECL:\n-\tcase RESULT_DECL:\n-\tcase SSA_NAME:\n-\tcase FILTER_EXPR:\n-\tcase EXC_PTR_EXPR:\n-\t  *op0_p = op->op0;\n-\t  break;\n-\n-\tcase ADDR_EXPR:\n-\t  if (op->op0 != NULL_TREE)\n-\t    {\n-\t      gcc_assert (is_gimple_min_invariant (op->op0));\n-\t      *op0_p = op->op0;\n-\t      break;\n-\t    }\n-\t  /* Fallthrough.  */\n-\tcase IMAGPART_EXPR:\n-\tcase REALPART_EXPR:\n-\tcase VIEW_CONVERT_EXPR:\n-\t  *op0_p = build1 (op->opcode, op->type, NULL_TREE);\n-\t  op0_p = &TREE_OPERAND (*op0_p, 0);\n-\t  break;\n+\t  return false;\n \n \tdefault:\n-\t  return NULL_TREE;\n+\t  return false;\n \t}\n     }\n \n-  return ref;\n+  if (base == NULL_TREE)\n+    return false;\n+\n+  ref->ref = NULL_TREE;\n+  ref->base = base;\n+  ref->offset = offset;\n+  ref->size = size;\n+  ref->max_size = max_size;\n+  ref->ref_alias_set = set;\n+  ref->base_alias_set = -1;\n+\n+  return true;\n }\n \n /* Copy the operations present in load/store/call REF into RESULT, a vector of\n@@ -920,7 +1003,7 @@ vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)\n    with the current VUSE and performs the expression lookup.  */\n \n static void *\n-vn_reference_lookup_2 (tree op ATTRIBUTE_UNUSED, tree vuse, void *vr_)\n+vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse, void *vr_)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n   void **slot;\n@@ -949,16 +1032,18 @@ vn_reference_lookup_2 (tree op ATTRIBUTE_UNUSED, tree vuse, void *vr_)\n    of VUSE.  */\n \n static void *\n-vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n+vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_)\n {\n   vn_reference_t vr = (vn_reference_t)vr_;\n   gimple def_stmt = SSA_NAME_DEF_STMT (vuse);\n   tree fndecl;\n-  tree ref = *refp;\n   tree base;\n   HOST_WIDE_INT offset, size, maxsize;\n \n-  base = get_ref_base_and_extent (ref, &offset, &size, &maxsize);\n+  base = ao_ref_base (ref);\n+  offset = ref->offset;\n+  size = ref->size;\n+  maxsize = ref->max_size;\n \n   /* If we cannot constrain the size of the reference we cannot\n      test if anything kills it.  */\n@@ -968,7 +1053,7 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n   /* def_stmt may-defs *ref.  See if we can derive a value for *ref\n      from that defintion.\n      1) Memset.  */\n-  if (is_gimple_reg_type (TREE_TYPE (ref))\n+  if (is_gimple_reg_type (vr->type)\n       && is_gimple_call (def_stmt)\n       && (fndecl = gimple_call_fndecl (def_stmt))\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n@@ -987,13 +1072,18 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n \t  && operand_equal_p (base, base2, 0)\n \t  && offset2 <= offset\n \t  && offset2 + size2 >= offset + maxsize)\n-\treturn vn_reference_insert (ref,\n-\t\t\t\t    fold_convert (TREE_TYPE (ref),\n-\t\t\t\t\t\t  integer_zero_node), vuse);\n+\t{\n+\t  tree val = fold_convert (vr->type, integer_zero_node);\n+\t  unsigned int value_id = get_or_alloc_constant_value_id (val);\n+\t  return vn_reference_insert_pieces (vuse, vr->set, vr->type,\n+\t\t\t\t\t     VEC_copy (vn_reference_op_s,\n+\t\t\t\t\t\t       heap, vr->operands),\n+\t\t\t\t\t     val, value_id);\n+\t}\n     }\n \n   /* 2) Assignment from an empty CONSTRUCTOR.  */\n-  else if (is_gimple_reg_type (TREE_TYPE (ref))\n+  else if (is_gimple_reg_type (vr->type)\n \t   && gimple_assign_single_p (def_stmt)\n \t   && gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR\n \t   && CONSTRUCTOR_NELTS (gimple_assign_rhs1 (def_stmt)) == 0)\n@@ -1005,9 +1095,14 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n       if (operand_equal_p (base, base2, 0)\n \t  && offset2 <= offset\n \t  && offset2 + size2 >= offset + maxsize)\n-\treturn vn_reference_insert (ref,\n-\t\t\t\t    fold_convert (TREE_TYPE (ref),\n-\t\t\t\t\t\t  integer_zero_node), vuse);\n+\t{\n+\t  tree val = fold_convert (vr->type, integer_zero_node);\n+\t  unsigned int value_id = get_or_alloc_constant_value_id (val);\n+\t  return vn_reference_insert_pieces (vuse, vr->set, vr->type,\n+\t\t\t\t\t     VEC_copy (vn_reference_op_s,\n+\t\t\t\t\t\t       heap, vr->operands),\n+\t\t\t\t\t     val, value_id);\n+\t}\n     }\n \n   /* For aggregate copies translate the reference through them if\n@@ -1022,6 +1117,7 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n       int i, j;\n       VEC (vn_reference_op_s, heap) *lhs = NULL, *rhs = NULL;\n       vn_reference_op_t vro;\n+      ao_ref r;\n \n       /* See if the assignment kills REF.  */\n       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),\n@@ -1071,9 +1167,12 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n \tVEC_replace (vn_reference_op_s, vr->operands, i + 1 + j, vro);\n       VEC_free (vn_reference_op_s, heap, rhs);\n       vr->hashcode = vn_reference_compute_hash (vr);\n-      *refp = get_ref_from_reference_ops (vr->operands);\n-      if (!*refp)\n+\n+      /* Adjust *ref from the new operands.  */\n+      if (!ao_ref_init_from_vn_reference (&r, vr->set, vr->type, vr->operands))\n \treturn (void *)-1;\n+      gcc_assert (ref->size == r.size);\n+      *ref = r;\n \n       /* Keep looking for the adjusted *REF / VR pair.  */\n       return NULL;\n@@ -1089,7 +1188,7 @@ vn_reference_lookup_3 (tree *refp, tree vuse, void *vr_)\n    vn_reference_t stored in the hashtable if something is found.  */\n \n tree\n-vn_reference_lookup_pieces (tree vuse,\n+vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n \t\t\t    VEC (vn_reference_op_s, heap) *operands,\n \t\t\t    vn_reference_t *vnresult, bool maywalk)\n {\n@@ -1110,17 +1209,19 @@ vn_reference_lookup_pieces (tree vuse,\n \t  * VEC_length (vn_reference_op_s, operands));\n   vr1.operands = operands = shared_lookup_references\n     = valueize_refs (shared_lookup_references);\n+  vr1.type = type;\n+  vr1.set = set;\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   vn_reference_lookup_1 (&vr1, vnresult);\n \n   if (!*vnresult\n       && maywalk\n       && vr1.vuse)\n     {\n-      tree ref = get_ref_from_reference_ops (operands);\n-      if (ref)\n+      ao_ref r;\n+      if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))\n \t*vnresult =\n-\t  (vn_reference_t)walk_non_aliased_vuses (ref, vr1.vuse,\n+\t  (vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\t  vn_reference_lookup_2,\n \t\t\t\t\t\t  vn_reference_lookup_3, &vr1);\n       if (vr1.operands != operands)\n@@ -1151,14 +1252,18 @@ vn_reference_lookup (tree op, tree vuse, bool maywalk,\n \n   vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n   vr1.operands = operands = valueize_shared_reference_ops_from_ref (op);\n+  vr1.type = TREE_TYPE (op);\n+  vr1.set = get_alias_set (op);\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n \n   if (maywalk\n       && vr1.vuse)\n     {\n       vn_reference_t wvnresult;\n+      ao_ref r;\n+      ao_ref_init (&r, op);\n       wvnresult =\n-\t(vn_reference_t)walk_non_aliased_vuses (op, vr1.vuse,\n+\t(vn_reference_t)walk_non_aliased_vuses (&r, vr1.vuse,\n \t\t\t\t\t\tvn_reference_lookup_2,\n \t\t\t\t\t\tvn_reference_lookup_3, &vr1);\n       if (vr1.operands != operands)\n@@ -1193,6 +1298,8 @@ vn_reference_insert (tree op, tree result, tree vuse)\n     vr1->value_id = get_or_alloc_constant_value_id (result);\n   vr1->vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n   vr1->operands = valueize_refs (create_reference_ops_from_ref (op));\n+  vr1->type = TREE_TYPE (op);\n+  vr1->set = get_alias_set (op);\n   vr1->hashcode = vn_reference_compute_hash (vr1);\n   vr1->result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;\n \n@@ -1220,7 +1327,7 @@ vn_reference_insert (tree op, tree result, tree vuse)\n    structure we created.  */\n \n vn_reference_t\n-vn_reference_insert_pieces (tree vuse,\n+vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,\n \t\t\t    VEC (vn_reference_op_s, heap) *operands,\n \t\t\t    tree result, unsigned int value_id)\n \n@@ -1232,6 +1339,8 @@ vn_reference_insert_pieces (tree vuse,\n   vr1->value_id = value_id;\n   vr1->vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n   vr1->operands = valueize_refs (operands);\n+  vr1->type = type;\n+  vr1->set = set;\n   vr1->hashcode = vn_reference_compute_hash (vr1);\n   if (result && TREE_CODE (result) == SSA_NAME)\n     result = SSA_VAL (result);\n@@ -1825,6 +1934,8 @@ visit_reference_op_call (tree lhs, gimple stmt)\n \n   vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;\n   vr1.operands = valueize_shared_reference_ops_from_call (stmt);\n+  vr1.type = gimple_expr_type (stmt);\n+  vr1.set = 0;\n   vr1.hashcode = vn_reference_compute_hash (&vr1);\n   result = vn_reference_lookup_1 (&vr1, NULL);\n   if (result)\n@@ -1842,6 +1953,8 @@ visit_reference_op_call (tree lhs, gimple stmt)\n       vr2 = (vn_reference_t) pool_alloc (current_info->references_pool);\n       vr2->vuse = vr1.vuse;\n       vr2->operands = valueize_refs (create_reference_ops_from_call (stmt));\n+      vr2->type = vr1.type;\n+      vr2->set = vr1.set;\n       vr2->hashcode = vr1.hashcode;\n       vr2->result = lhs;\n       slot = htab_find_slot_with_hash (current_info->references,"}, {"sha": "706ea4e44b85c07d89c16fddbf87577122ec33a2", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b45d27197ff43c93ec0ffbb0303ca9a408e4e555/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=b45d27197ff43c93ec0ffbb0303ca9a408e4e555", "patch": "@@ -92,6 +92,8 @@ typedef struct vn_reference_s\n   unsigned int value_id;\n   hashval_t hashcode;\n   tree vuse;\n+  alias_set_type set;\n+  tree type;\n   VEC (vn_reference_op_s, heap) *operands;\n   tree result;\n } *vn_reference_t;\n@@ -177,13 +179,14 @@ void vn_reference_fold_indirect (VEC (vn_reference_op_s, heap) **,\n \t\t\t\t unsigned int *);\n void copy_reference_ops_from_ref (tree, VEC(vn_reference_op_s, heap) **);\n void copy_reference_ops_from_call (gimple, VEC(vn_reference_op_s, heap) **);\n-tree get_ref_from_reference_ops (VEC(vn_reference_op_s, heap) *ops);\n-tree vn_reference_lookup_pieces (tree,\n+bool ao_ref_init_from_vn_reference (ao_ref *, alias_set_type, tree,\n+\t\t\t\t    VEC (vn_reference_op_s, heap) *);\n+tree vn_reference_lookup_pieces (tree, alias_set_type, tree,\n \t\t\t\t VEC (vn_reference_op_s, heap) *,\n \t\t\t\t vn_reference_t *, bool);\n tree vn_reference_lookup (tree, tree, bool, vn_reference_t *);\n vn_reference_t vn_reference_insert (tree, tree, tree);\n-vn_reference_t vn_reference_insert_pieces (tree,\n+vn_reference_t vn_reference_insert_pieces (tree, alias_set_type, tree,\n \t\t\t\t\t   VEC (vn_reference_op_s, heap) *,\n \t\t\t\t\t   tree, unsigned int);\n "}]}