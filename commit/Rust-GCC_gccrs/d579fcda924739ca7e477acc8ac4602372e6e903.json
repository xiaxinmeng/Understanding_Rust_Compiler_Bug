{"sha": "d579fcda924739ca7e477acc8ac4602372e6e903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU3OWZjZGE5MjQ3MzljYTdlNDc3YWNjOGFjNDYwMjM3MmU2ZTkwMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-06-18T14:39:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-06-18T14:39:57Z"}, "message": "Makefile.in (LTO_STREAMER_H): Add pointer-set.h dependency.\n\n2013-06-18  Richard Biener  <rguenther@suse.de>\n\n\t* Makefile.in (LTO_STREAMER_H): Add pointer-set.h dependency.\n\t* lto-streamer.h: Include pointer-set.h.\n\t(struct lto_decl_slot): Remove.\n\t(struct lto_tree_ref_encoder): Make tree_hash_table a pointer-map.\n\tRemove next_index entry.\n\t(lto_hash_decl_slot_node, lto_eq_decl_slot_node,\n\tlto_hash_type_slot_node, lto_eq_type_slot_node): Remove.\n\t(lto_init_tree_ref_encoder): Adjust.\n\t(lto_destroy_tree_ref_encoder): Likewise.\n\t* lto-section-out.c (lto_hash_decl_slot_node, lto_eq_decl_slot_node,\n\tlto_hash_type_slot_node, lto_eq_type_slot_node): Remove.\n\t(lto_output_decl_index): Adjust.\n\t(lto_new_out_decl_state): Likewise.\n\t(lto_record_function_out_decl_state): Likewise.\n\t* lto-streamer-out.c (copy_function): Likewise.\n\nFrom-SVN: r200171", "tree": {"sha": "3ed062f66c02bd2142734bd6798e53cd89f9ba6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ed062f66c02bd2142734bd6798e53cd89f9ba6c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d579fcda924739ca7e477acc8ac4602372e6e903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d579fcda924739ca7e477acc8ac4602372e6e903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d579fcda924739ca7e477acc8ac4602372e6e903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d579fcda924739ca7e477acc8ac4602372e6e903/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "31ee20ba67b2020f64f5068444f2b0409d128881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31ee20ba67b2020f64f5068444f2b0409d128881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31ee20ba67b2020f64f5068444f2b0409d128881"}], "stats": {"total": 136, "additions": 32, "deletions": 104}, "files": [{"sha": "7e771b5ebe5e875e907323a876d6e84a8def6786", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d579fcda924739ca7e477acc8ac4602372e6e903", "patch": "@@ -1,3 +1,21 @@\n+2013-06-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* Makefile.in (LTO_STREAMER_H): Add pointer-set.h dependency.\n+\t* lto-streamer.h: Include pointer-set.h.\n+\t(struct lto_decl_slot): Remove.\n+\t(struct lto_tree_ref_encoder): Make tree_hash_table a pointer-map.\n+\tRemove next_index entry.\n+\t(lto_hash_decl_slot_node, lto_eq_decl_slot_node,\n+\tlto_hash_type_slot_node, lto_eq_type_slot_node): Remove.\n+\t(lto_init_tree_ref_encoder): Adjust.\n+\t(lto_destroy_tree_ref_encoder): Likewise.\n+\t* lto-section-out.c (lto_hash_decl_slot_node, lto_eq_decl_slot_node,\n+\tlto_hash_type_slot_node, lto_eq_type_slot_node): Remove.\n+\t(lto_output_decl_index): Adjust.\n+\t(lto_new_out_decl_state): Likewise.\n+\t(lto_record_function_out_decl_state): Likewise.\n+\t* lto-streamer-out.c (copy_function): Likewise.\n+\n 2013-06-18  Richard Biener  <rguenther@suse.de>\n \n \t* Makefile.in (cgraphunit.o): Add $(CFGLOOP_H) dependency."}, {"sha": "d5121f3b43c4f6b0a6747f1a70013e6a6a0fc56d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d579fcda924739ca7e477acc8ac4602372e6e903", "patch": "@@ -967,7 +967,7 @@ LRA_INT_H = lra.h $(BITMAP_H) $(RECOG_H) $(INSN_ATTR_H) insn-codes.h \\\n DBGCNT_H = dbgcnt.h dbgcnt.def\n LTO_STREAMER_H = lto-streamer.h $(LINKER_PLUGIN_API_H) $(TARGET_H) \\\n \t\t$(CGRAPH_H) $(VEC_H) $(HASH_TABLE_H) $(TREE_H) $(GIMPLE_H) \\\n-\t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h\n+\t\t$(GCOV_IO_H) $(DIAGNOSTIC_H) alloc-pool.h pointer-set.h\n DATA_STREAMER_H = data-streamer.h $(VEC_H) $(LTO_STREAMER_H)\n GIMPLE_STREAMER_H = gimple-streamer.h $(LTO_STREAMER_H) $(BASIC_BLOCK_H) \\\n \t\t    $(FUNCTION_H)"}, {"sha": "4b4440838c518df2072155d1e782235e673ff2da", "filename": "gcc/lto-section-out.c", "status": "modified", "additions": 6, "deletions": 82, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-section-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-section-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-out.c?ref=d579fcda924739ca7e477acc8ac4602372e6e903", "patch": "@@ -48,59 +48,7 @@ static vec<lto_out_decl_state_ptr> decl_state_stack;\n    generate the decl directory later. */\n \n vec<lto_out_decl_state_ptr> lto_function_decl_states;\n-/* Returns a hash code for P.  */\n \n-hashval_t\n-lto_hash_decl_slot_node (const void *p)\n-{\n-  const struct lto_decl_slot *ds = (const struct lto_decl_slot *) p;\n-\n-  /*\n-    return (hashval_t) DECL_UID (ds->t);\n-  */\n-  return (hashval_t) TREE_HASH (ds->t);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-int\n-lto_eq_decl_slot_node (const void *p1, const void *p2)\n-{\n-  const struct lto_decl_slot *ds1 =\n-    (const struct lto_decl_slot *) p1;\n-  const struct lto_decl_slot *ds2 =\n-    (const struct lto_decl_slot *) p2;\n-\n-  /*\n-  return DECL_UID (ds1->t) == DECL_UID (ds2->t);\n-  */\n-  return ds1->t == ds2->t;\n-}\n-\n-\n-/* Returns a hash code for P.  */\n-\n-hashval_t\n-lto_hash_type_slot_node (const void *p)\n-{\n-  const struct lto_decl_slot *ds = (const struct lto_decl_slot *) p;\n-  return (hashval_t) TYPE_UID (ds->t);\n-}\n-\n-\n-/* Returns nonzero if P1 and P2 are equal.  */\n-\n-int\n-lto_eq_type_slot_node (const void *p1, const void *p2)\n-{\n-  const struct lto_decl_slot *ds1 =\n-    (const struct lto_decl_slot *) p1;\n-  const struct lto_decl_slot *ds2 =\n-    (const struct lto_decl_slot *) p2;\n-\n-  return TYPE_UID (ds1->t) == TYPE_UID (ds2->t);\n-}\n \n /*****************************************************************************\n    Output routines shared by all of the serialization passes.\n@@ -278,29 +226,19 @@ lto_output_decl_index (struct lto_output_stream *obs,\n \t\t       tree name, unsigned int *this_index)\n {\n   void **slot;\n-  struct lto_decl_slot d_slot;\n   int index;\n   bool new_entry_p = FALSE;\n \n-  d_slot.t = name;\n-  slot = htab_find_slot (encoder->tree_hash_table, &d_slot, INSERT);\n+  slot = pointer_map_insert (encoder->tree_hash_table, name);\n   if (*slot == NULL)\n     {\n-      struct lto_decl_slot *new_slot\n-\t= (struct lto_decl_slot *) xmalloc (sizeof (struct lto_decl_slot));\n-      index = encoder->next_index++;\n-\n-      new_slot->t = name;\n-      new_slot->slot_num = index;\n-      *slot = new_slot;\n+      index = encoder->trees.length ();\n+      *slot = (void *)(uintptr_t) index;\n       encoder->trees.safe_push (name);\n       new_entry_p = TRUE;\n     }\n   else\n-    {\n-      struct lto_decl_slot *old_slot = (struct lto_decl_slot *)*slot;\n-      index = old_slot->slot_num;\n-    }\n+    index = (uintptr_t) *slot;\n \n   if (obs)\n     streamer_write_uhwi_stream (obs, index);\n@@ -440,23 +378,9 @@ lto_new_out_decl_state (void)\n {\n   struct lto_out_decl_state *state = XCNEW (struct lto_out_decl_state);\n   int i;\n-  htab_hash hash_fn;\n-  htab_eq eq_fn;\n \n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n-    {\n-      if (i == LTO_DECL_STREAM_TYPE)\n-\t{\n-\t  hash_fn = lto_hash_type_slot_node;\n-\t  eq_fn = lto_eq_type_slot_node;\n-\t}\n-      else\n-\t{\n-\t  hash_fn = lto_hash_decl_slot_node;\n-\t  eq_fn = lto_eq_decl_slot_node;\n-\t}\n-      lto_init_tree_ref_encoder (&state->streams[i], hash_fn, eq_fn);\n-    }\n+    lto_init_tree_ref_encoder (&state->streams[i]);\n \n   return state;\n }\n@@ -514,7 +438,7 @@ lto_record_function_out_decl_state (tree fn_decl,\n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n     if (state->streams[i].tree_hash_table)\n       {\n-\thtab_delete (state->streams[i].tree_hash_table);\n+\tpointer_map_destroy (state->streams[i].tree_hash_table);\n \tstate->streams[i].tree_hash_table = NULL;\n       }\n   state->fn_decl = fn_decl;"}, {"sha": "8fe7bd8082a1e74ca2bdfa29c8b098ca7e465052", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=d579fcda924739ca7e477acc8ac4602372e6e903", "patch": "@@ -1922,9 +1922,9 @@ copy_function (struct cgraph_node *node)\n \t So just copy the vector.  All the encoders in the in state\n \t must be empty where we reach here. */\n       gcc_assert (lto_tree_ref_encoder_size (encoder) == 0);\n+      encoder->trees.reserve_exact (n);\n       for (j = 0; j < n; j++)\n \tencoder->trees.safe_push (trees[j]);\n-      encoder->next_index = n;\n     }\n \n   lto_free_section_data (file_data, LTO_section_function_body, name,"}, {"sha": "a3e2918f6f3de19860a6eaebfe68c1eefe917630", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d579fcda924739ca7e477acc8ac4602372e6e903/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=d579fcda924739ca7e477acc8ac4602372e6e903", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"gcov-io.h\"\n #include \"diagnostic.h\"\n+#include \"pointer-set.h\"\n \n /* Define when debugging the LTO streamer.  This causes the writer\n    to output the numeric value for the memory address of the tree node\n@@ -474,21 +475,12 @@ struct GTY(()) lto_tree_ref_table\n };\n \n \n-/* Mapping between trees and slots in an array.  */\n-struct lto_decl_slot\n-{\n-  tree t;\n-  int slot_num;\n-};\n-\n-\n /* The lto_tree_ref_encoder struct is used to encode trees into indices. */\n \n struct lto_tree_ref_encoder\n {\n-  htab_t tree_hash_table;\t/* Maps pointers to indices. */\n-  unsigned int next_index;\t/* Next available index. */\n-  vec<tree> trees;\t/* Maps indices to pointers. */\n+  pointer_map_t *tree_hash_table;\t/* Maps pointers to indices. */\n+  vec<tree> trees;\t\t\t/* Maps indices to pointers. */\n };\n \n \n@@ -788,10 +780,6 @@ extern void lto_value_range_error (const char *,\n \t\t\t\t   HOST_WIDE_INT) ATTRIBUTE_NORETURN;\n \n /* In lto-section-out.c  */\n-extern hashval_t lto_hash_decl_slot_node (const void *);\n-extern int lto_eq_decl_slot_node (const void *, const void *);\n-extern hashval_t lto_hash_type_slot_node (const void *);\n-extern int lto_eq_type_slot_node (const void *, const void *);\n extern void lto_begin_section (const char *, bool);\n extern void lto_end_section (void);\n extern void lto_write_stream (struct lto_output_stream *);\n@@ -1007,11 +995,9 @@ lto_tag_check_range (enum LTO_tags actual, enum LTO_tags tag1,\n \n /* Initialize an lto_out_decl_buffer ENCODER.  */\n static inline void\n-lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder,\n-\t\t\t   htab_hash hash_fn, htab_eq eq_fn)\n+lto_init_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n-  encoder->tree_hash_table = htab_create (37, hash_fn, eq_fn, free);\n-  encoder->next_index = 0;\n+  encoder->tree_hash_table = pointer_map_create ();\n   encoder->trees.create (0);\n }\n \n@@ -1023,7 +1009,7 @@ lto_destroy_tree_ref_encoder (struct lto_tree_ref_encoder *encoder)\n {\n   /* Hash table may be delete already.  */\n   if (encoder->tree_hash_table)\n-    htab_delete (encoder->tree_hash_table);\n+    pointer_map_destroy (encoder->tree_hash_table);\n   encoder->trees.release ();\n }\n "}]}