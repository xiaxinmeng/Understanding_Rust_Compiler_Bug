{"sha": "d2be99bd64f3c83ee16d9cdf48076da9323a0f65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDJiZTk5YmQ2NGYzYzgzZWUxNmQ5Y2RmNDgwNzZkYTkzMjNhMGY2NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:33:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-06-23T02:33:59Z"}, "message": "(can_convert): Also check for distance > 0.\n\n(can_convert_arg): Ditto.\n(user_harshness): Ditto.\n(build_method_call): Make instance_ptr the signature pointer itself instead of\ndereferencing the optr.\n\nFrom-SVN: r10043", "tree": {"sha": "3b2318947904d301f95bbc953c9e3dc036b94697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b2318947904d301f95bbc953c9e3dc036b94697"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2be99bd64f3c83ee16d9cdf48076da9323a0f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2be99bd64f3c83ee16d9cdf48076da9323a0f65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2be99bd64f3c83ee16d9cdf48076da9323a0f65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2be99bd64f3c83ee16d9cdf48076da9323a0f65/comments", "author": null, "committer": null, "parents": [{"sha": "c407792d6df76ceb007217935e003dd391e12b8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c407792d6df76ceb007217935e003dd391e12b8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c407792d6df76ceb007217935e003dd391e12b8a"}], "stats": {"total": 25, "additions": 18, "deletions": 7}, "files": [{"sha": "6b0f63b0ebf99d569fbe82b572b3b2de3d53fce8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2be99bd64f3c83ee16d9cdf48076da9323a0f65/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2be99bd64f3c83ee16d9cdf48076da9323a0f65/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d2be99bd64f3c83ee16d9cdf48076da9323a0f65", "patch": "@@ -1,5 +1,5 @@\n /* Functions related to invoking methods and overloaded functions.\n-   Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com) and\n    hacked by Brendan Kehoe (brendan@cygnus.com).\n \n@@ -638,7 +638,7 @@ user_harshness (type, parmtype, parm)\n \tcontinue;\n \n       if (tmp = convert_harshness (type, TREE_VALUE (conv), NULL_TREE),\n-\t  tmp.code < USER_CODE)\n+\t  tmp.code < USER_CODE && tmp.distance >= 0)\n \t{\n \t  if (winner)\n \t    return EVIL_CODE;\n@@ -662,7 +662,7 @@ can_convert (to, from)\n {\n   struct harshness_code h;\n   h = convert_harshness (to, from, NULL_TREE);\n-  return h.code < USER_CODE;\n+  return h.code < USER_CODE && h.distance >= 0;\n }\n \n int\n@@ -671,7 +671,7 @@ can_convert_arg (to, from, arg)\n {\n   struct harshness_code h;\n   h = convert_harshness (to, from, arg);\n-  return h.code < USER_CODE;\n+  return h.code < USER_CODE && h.distance >= 0;\n }\n \n #ifdef DEBUG_MATCHING\n@@ -1824,7 +1824,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t    basetype = SIGNATURE_TYPE (basetype);\n \n \t  if ((IS_SIGNATURE (basetype)\n-\t       && (instance_ptr = build_optr_ref (instance)))\n+\t       && (instance_ptr = instance))\n \t      || (lvalue_p (instance)\n \t\t  && (instance_ptr = build_unary_op (ADDR_EXPR, instance, 0)))\n \t      || (instance_ptr = unary_complex_lvalue (ADDR_EXPR, instance)))\n@@ -1865,7 +1865,10 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t      instance_ptr = build_unary_op (ADDR_EXPR, instance, 0);\n \t    }\n \t  /* @@ Should we call comp_target_types here?  */\n-\t  inst_ptr_basetype = TREE_TYPE (TREE_TYPE (instance_ptr));\n+\t  if (IS_SIGNATURE (basetype))\n+\t    inst_ptr_basetype = basetype;\n+\t  else\n+\t    inst_ptr_basetype = TREE_TYPE (TREE_TYPE (instance_ptr));\n \t  if (TYPE_MAIN_VARIANT (basetype) == TYPE_MAIN_VARIANT (inst_ptr_basetype))\n \t    basetype = inst_ptr_basetype;\n \t  else\n@@ -1960,7 +1963,15 @@ build_method_call (instance, name, parms, basetype_path, flags)\n       parmtypes = chainon (parmtypes, last);\n     }\n \n-  if (instance)\n+  if (instance && IS_SIGNATURE (basetype))\n+    {\n+      /* @@ Should this be the constp/volatilep flags for the optr field\n+\t of the signature pointer?  */\n+      constp = TYPE_READONLY (basetype);\n+      volatilep = TYPE_VOLATILE (basetype);\n+      parms = tree_cons (NULL_TREE, instance_ptr, parms);\n+    }\n+  else if (instance)\n     {\n       /* TREE_READONLY (instance) fails for references.  */\n       constp = TYPE_READONLY (TREE_TYPE (TREE_TYPE (instance_ptr)));"}]}