{"sha": "e8d6096cebf3cb47d430503ac2e445a74d7edad6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThkNjA5NmNlYmYzY2I0N2Q0MzA1MDNhYzJlNDQ1YTc0ZDdlZGFkNg==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-07-22T20:04:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1992-07-22T20:04:55Z"}, "message": "(movdf+1): Use new 'T' and 'U' constraints to determine when an ldd or std will have a length of 1...\n\n(movdf+1): Use new 'T' and 'U' constraints to\ndetermine when an ldd or std will have a length of 1, and\ntherefore is eligible for use in some delay slots.\n(uncond_branch): New attribute used for unconditional branches.\nAll unconditional branch patterns changed to use this attribute.\n(define_delays and delay slot attributes): Do not allow\nuncond_branch instructions in delay slots.  Do not allow fpload or\nfpstore operations in a conditional branch delay slot.  Allow\nfpload and fpstore in call, unconditional branch, and annuled\nconditional branch delay slots.\n\nFrom-SVN: r1663", "tree": {"sha": "c8eab4ef195180e1eda69d2e49d4e0c80df4e587", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8eab4ef195180e1eda69d2e49d4e0c80df4e587"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8d6096cebf3cb47d430503ac2e445a74d7edad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d6096cebf3cb47d430503ac2e445a74d7edad6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8d6096cebf3cb47d430503ac2e445a74d7edad6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8d6096cebf3cb47d430503ac2e445a74d7edad6/comments", "author": null, "committer": null, "parents": [{"sha": "7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c56249dfc5c2b07aa44deab2baadbc3a1ce3894"}], "stats": {"total": 75, "additions": 46, "deletions": 29}, "files": [{"sha": "9a34c358bea08b8fb88f53453cacf87f2dd620ba", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8d6096cebf3cb47d430503ac2e445a74d7edad6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8d6096cebf3cb47d430503ac2e445a74d7edad6/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e8d6096cebf3cb47d430503ac2e445a74d7edad6", "patch": "@@ -29,7 +29,7 @@\n ;; type \"call_no_delay_slot\" is a call followed by an unimp instruction.\n \n (define_attr \"type\"\n-  \"move,unary,binary,compare,load,store,branch,call,call_no_delay_slot,address,fpload,fpstore,fp,fpcmp,fpmul,fpdiv,fpsqrt,multi,misc\"\n+  \"move,unary,binary,compare,load,store,uncond_branch,branch,call,call_no_delay_slot,address,fpload,fpstore,fp,fpcmp,fpmul,fpdiv,fpsqrt,multi,misc\"\n   (const_string \"binary\"))\n \n ;; Set true if insn uses call-clobbered intermediate register.\n@@ -72,7 +72,7 @@\n ;; Attributes for instruction and branch scheduling\n \n (define_attr \"in_call_delay\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"branch,call,call_no_delay_slot,multi\")\n+  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,multi\")\n \t \t(const_string \"false\")\n \t (eq_attr \"type\" \"load,fpload,store,fpstore\")\n \t \t(if_then_else (eq_attr \"length\" \"1\")\n@@ -93,16 +93,33 @@\n ;; branches.  This would allow us to remove the nop always inserted before\n ;; a floating point branch.\n \n+\n (define_attr \"in_branch_delay\" \"false,true\"\n-  (if_then_else (and (eq_attr \"type\" \"!branch,call,call_no_delay_slot,multi\")\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi,fpload,fpstore\")\n+\t\t     (eq_attr \"length\" \"1\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+(define_attr \"in_uncond_branch_delay\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi\")\n+\t\t     (eq_attr \"length\" \"1\"))\n+\t\t(const_string \"true\")\n+\t\t(const_string \"false\")))\n+\n+(define_attr \"in_annul_branch_delay\" \"false,true\"\n+  (if_then_else (and (eq_attr \"type\" \"!uncond_branch,branch,call,call_no_delay_slot,multi\")\n \t\t     (eq_attr \"length\" \"1\"))\n \t\t(const_string \"true\")\n \t\t(const_string \"false\")))\n \n (define_delay (eq_attr \"type\" \"branch\")\n   [(eq_attr \"in_branch_delay\" \"true\")\n-   (nil) (eq_attr \"in_branch_delay\" \"true\")])\n+   (nil) (eq_attr \"in_annul_branch_delay\" \"true\")])\n \n+(define_delay (eq_attr \"type\" \"uncond_branch\")\n+  [(eq_attr \"in_uncond_branch_delay\" \"true\")\n+   (nil) (nil)])\n+   \n ;; Function units of the SPARC\n \n ;; (define_function_unit {name} {num-units} {n-users} {test}\n@@ -1146,8 +1163,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=f,r,Q,Q,f,&r,?f,?r\")\n-\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\" \"f,r,f,r,Q,Q,r,f\"))]\n+  [(set (match_operand:DF 0 \"reg_or_nonsymb_mem_operand\" \"=T,U,f,r,Q,Q,f,&r,?f,?r\")\n+\t(match_operand:DF 1 \"reg_or_nonsymb_mem_operand\" \"U,T,f,r,f,r,Q,Q,r,f\"))]\n   \"register_operand (operands[0], DFmode)\n    || register_operand (operands[1], DFmode)\"\n   \"*\n@@ -1156,8 +1173,8 @@\n     return output_fp_move_double (operands);\n   return output_move_double (operands);\n }\"\n-  [(set_attr \"type\" \"fp,move,fpstore,store,fpload,load,multi,multi\")\n-   (set_attr \"length\" \"2,2,3,3,3,3,3,3\")])\n+  [(set_attr \"type\" \"fpstore,fpload,fp,move,fpstore,store,fpload,load,multi,multi\")\n+   (set_attr \"length\" \"1,1,2,2,3,3,3,3,3,3\")])\n \n (define_insn \"\"\n   [(set (mem:DF (match_operand:SI 0 \"symbolic_operand\" \"i,i\"))\n@@ -2516,7 +2533,7 @@\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n   \"\"\n   \"b%* %l0%(\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"uncond_branch\")])\n \n (define_expand \"tablejump\"\n   [(parallel [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n@@ -2539,21 +2556,21 @@\n    (use (reg:SI 15))]\n   \"\"\n   \"jmp %%o7+%0%#\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"uncond_branch\")])\n \n (define_insn \"\"\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"jmp %a0%#\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"uncond_branch\")])\n \n (define_insn \"\"\n   [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n    (set (reg:SI 15) (label_ref (match_dup 0)))]\n   \"\"\n   \"call %l0%#\"\n-  [(set_attr \"type\" \"branch\")])\n+  [(set_attr \"type\" \"uncond_branch\")])\n \n ;; This pattern recognizes the \"instruction\" that appears in \n ;; a function call that wants a structure value, \n@@ -2728,7 +2745,7 @@\n   [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n   \"\"\n  \"jmp %a0%#\"\n- [(set_attr \"type\" \"branch\")])\n+ [(set_attr \"type\" \"uncond_branch\")])\n  \n (define_expand \"nonlocal_goto\"\n   [(match_operand:SI 0 \"general_operand\" \"\")\n@@ -2971,79 +2988,79 @@\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"r\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n-  \"registers_ok_for_ldd (operands[0], operands[2]) \n+  \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n-   && memory_ok_for_ldd (XEXP (operands[1], 0), XEXP (operands[3], 0))\" \n+   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\" \n   \"ldd %1,%0\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n         (match_operand:SI 1 \"register_operand\" \"r\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n         (match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"registers_ok_for_ldd (operands[1], operands[3]) \n+  \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n-   && memory_ok_for_ldd (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n   \"std %1,%0\")\n  \n (define_peephole\n   [(set (match_operand:SF 0 \"register_operand\" \"fr\")\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n    (set (match_operand:SF 2 \"register_operand\" \"fr\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n-  \"registers_ok_for_ldd (operands[0], operands[2]) \n+  \"registers_ok_for_ldd_peep (operands[0], operands[2]) \n    && ! MEM_VOLATILE_P (operands[1]) && ! MEM_VOLATILE_P (operands[3])\n-   && memory_ok_for_ldd (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[1], 0), XEXP (operands[3], 0))\"\n   \"ldd %1,%0\")\n \n (define_peephole\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n         (match_operand:SF 1 \"register_operand\" \"fr\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n         (match_operand:SF 3 \"register_operand\" \"fr\"))]\n-  \"registers_ok_for_ldd (operands[1], operands[3]) \n+  \"registers_ok_for_ldd_peep (operands[1], operands[3]) \n    && ! MEM_VOLATILE_P (operands[0]) && ! MEM_VOLATILE_P (operands[2])\n-   && memory_ok_for_ldd (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[0], 0), XEXP (operands[2], 0))\"\n   \"std %1,%0\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"register_operand\" \"r\")\n         (match_operand:SI 1 \"memory_operand\" \"\"))\n    (set (match_operand:SI 2 \"register_operand\" \"r\")\n         (match_operand:SI 3 \"memory_operand\" \"\"))]\n-  \"registers_ok_for_ldd (operands[2], operands[0]) \n+  \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n    && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n-   && memory_ok_for_ldd (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n   \"ldd %3,%2\")\n \n (define_peephole\n   [(set (match_operand:SI 0 \"memory_operand\" \"\")\n         (match_operand:SI 1 \"register_operand\" \"r\"))\n    (set (match_operand:SI 2 \"memory_operand\" \"\")\n         (match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"registers_ok_for_ldd (operands[3], operands[1]) \n+  \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n    && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n-   && memory_ok_for_ldd (XEXP (operands[2], 0), XEXP (operands[0], 0))\" \n+   && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\" \n   \"std %3,%2\")\n  \n (define_peephole\n   [(set (match_operand:SF 0 \"register_operand\" \"fr\")\n         (match_operand:SF 1 \"memory_operand\" \"\"))\n    (set (match_operand:SF 2 \"register_operand\" \"fr\")\n         (match_operand:SF 3 \"memory_operand\" \"\"))]\n-  \"registers_ok_for_ldd (operands[2], operands[0]) \n+  \"registers_ok_for_ldd_peep (operands[2], operands[0]) \n    && ! MEM_VOLATILE_P (operands[3]) && ! MEM_VOLATILE_P (operands[1])\n-   && memory_ok_for_ldd (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[3], 0), XEXP (operands[1], 0))\"\n   \"ldd %3,%2\")\n \n (define_peephole\n   [(set (match_operand:SF 0 \"memory_operand\" \"\")\n         (match_operand:SF 1 \"register_operand\" \"fr\"))\n    (set (match_operand:SF 2 \"memory_operand\" \"\")\n         (match_operand:SF 3 \"register_operand\" \"fr\"))]\n-  \"registers_ok_for_ldd (operands[3], operands[1]) \n+  \"registers_ok_for_ldd_peep (operands[3], operands[1]) \n    && ! MEM_VOLATILE_P (operands[2]) && ! MEM_VOLATILE_P (operands[0])\n-   && memory_ok_for_ldd (XEXP (operands[2], 0), XEXP (operands[0], 0))\"\n+   && addrs_ok_for_ldd_peep (XEXP (operands[2], 0), XEXP (operands[0], 0))\"\n   \"std %3,%2\")\n  \n ;; Optimize the case of following a reg-reg move with a test"}]}