{"sha": "c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "node_id": "C_kwDOANBUbNoAKGMwNTg5ZWE3ZGJlNmMzNmNmYjMzNDIyMGQ0ZWEzOTA1YzA2NzNkOWY", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-28T08:59:53Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-04-29T07:29:30Z"}, "message": "ast: Resolver: Flatten use declarations to paths\n\nIn order to resolve `SimplePath`s, we have to expand all paths present\nin a `UseDeclaration` and resolve them. For example, we want to resolve\ntwo paths with the following statement `use foo::bar::{baz, bul}`:\n`foo::bar::baz` and `foo::bar::bul`.\nThis also removes the prelude inclusion (`use std::prelude::v1::*`)\nsince we cannot resolve it (yet!)", "tree": {"sha": "129e835a56f76324b6c465e9b7a30936d36c2958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/129e835a56f76324b6c465e9b7a30936d36c2958"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83e13db1fa12d3ff8751a293595cbf01fd1ac236", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e13db1fa12d3ff8751a293595cbf01fd1ac236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e13db1fa12d3ff8751a293595cbf01fd1ac236"}], "stats": {"total": 423, "additions": 403, "deletions": 20}, "files": [{"sha": "69ad6eb13fd9b1c5a7274f2ef4bce94a20b979a4", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -410,6 +410,8 @@ class SimplePath\n   {\n     return segments;\n   }\n+\n+  std::vector<SimplePathSegment> &get_segments () { return segments; }\n };\n \n // path-to-string inverse comparison operator"}, {"sha": "4bed5af51eeb237b193829599153b52531c436fd", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -1179,15 +1179,37 @@ class UseTree\n   Location locus;\n \n public:\n+  enum Kind\n+  {\n+    Glob,\n+    Rebind,\n+    List,\n+  };\n+\n   virtual ~UseTree () {}\n \n+  // Overload assignment operator to clone\n+  UseTree &operator= (UseTree const &other)\n+  {\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  UseTree (const UseTree &other) = default;\n+\n+  // move constructors\n+  UseTree (UseTree &&other) = default;\n+  UseTree &operator= (UseTree &&other) = default;\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<UseTree> clone_use_tree () const\n   {\n     return std::unique_ptr<UseTree> (clone_use_tree_impl ());\n   }\n \n   virtual std::string as_string () const = 0;\n+  virtual Kind get_kind () const = 0;\n \n   Location get_locus () const { return locus; }\n \n@@ -1237,6 +1259,14 @@ class UseTreeGlob : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return Glob; }\n+\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n   /* TODO: find way to ensure only PATH_PREFIXED glob_type has path - factory\n    * methods? */\n protected:\n@@ -1318,6 +1348,18 @@ class UseTreeList : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return List; }\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n+  const std::vector<std::unique_ptr<UseTree>> &get_trees () const\n+  {\n+    return trees;\n+  }\n+\n   // TODO: find way to ensure only PATH_PREFIXED path_type has path - factory\n   // methods?\n protected:\n@@ -1363,6 +1405,20 @@ class UseTreeRebind : public UseTree\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  Kind get_kind () const override { return Rebind; }\n+\n+  SimplePath get_path () const\n+  {\n+    rust_assert (has_path ());\n+    return path;\n+  }\n+\n+  const Identifier &get_identifier () const\n+  {\n+    rust_assert (has_identifier ());\n+    return identifier;\n+  }\n+\n   // TODO: find way to ensure only PATH_PREFIXED path_type has path - factory\n   // methods?\n protected:\n@@ -1420,6 +1476,7 @@ class UseDeclaration : public VisItem\n   UseDeclaration &operator= (UseDeclaration &&other) = default;\n \n   Location get_locus () const override final { return locus; }\n+  const std::unique_ptr<UseTree> &get_tree () const { return use_tree; }\n \n   void accept_vis (ASTVisitor &vis) override;\n "}, {"sha": "93eca1b9df2a2b9fbf0dcb77678a64b5fa8ad339", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 295, "deletions": 2, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -17,6 +17,8 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-ast-resolve-item.h\"\n+#include \"rust-ast-resolve-path.h\"\n+#include \"selftest.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -133,7 +135,7 @@ ResolveTraitItems::visit (AST::TraitItemMethod &func)\n \t\t\t\t       self_param.get_is_mut (),\n \t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n \n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n     new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n \n@@ -694,7 +696,7 @@ ResolveItem::visit (AST::Method &method)\n \t\t\t\t       self_param.get_is_mut (),\n \t\t\t\t       std::unique_ptr<AST::Pattern> (nullptr));\n \n-  std::vector<std::unique_ptr<AST::TypePathSegment> > segments;\n+  std::vector<std::unique_ptr<AST::TypePathSegment>> segments;\n   segments.push_back (std::unique_ptr<AST::TypePathSegment> (\n     new AST::TypePathSegment (\"Self\", false, self_param.get_locus ())));\n \n@@ -902,6 +904,133 @@ ResolveItem::visit (AST::ExternBlock &extern_block)\n     }\n }\n \n+static void\n+flatten_glob (const AST::UseTreeGlob &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+static void\n+flatten_rebind (const AST::UseTreeRebind &glob,\n+\t\tstd::vector<AST::SimplePath> &paths);\n+static void\n+flatten_list (const AST::UseTreeList &glob,\n+\t      std::vector<AST::SimplePath> &paths);\n+\n+static void\n+flatten (const AST::UseTree *tree, std::vector<AST::SimplePath> &paths)\n+{\n+  switch (tree->get_kind ())\n+    {\n+      case AST::UseTree::Glob: {\n+\tauto glob = static_cast<const AST::UseTreeGlob *> (tree);\n+\tflatten_glob (*glob, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::Rebind: {\n+\tauto rebind = static_cast<const AST::UseTreeRebind *> (tree);\n+\tflatten_rebind (*rebind, paths);\n+\tbreak;\n+      }\n+      case AST::UseTree::List: {\n+\tauto list = static_cast<const AST::UseTreeList *> (tree);\n+\tflatten_list (*list, paths);\n+\tbreak;\n+      }\n+      break;\n+    }\n+}\n+\n+static void\n+flatten_glob (const AST::UseTreeGlob &glob, std::vector<AST::SimplePath> &paths)\n+{\n+  if (glob.has_path ())\n+    paths.emplace_back (glob.get_path ());\n+}\n+\n+static void\n+flatten_rebind (const AST::UseTreeRebind &rebind,\n+\t\tstd::vector<AST::SimplePath> &paths)\n+{\n+  auto path = rebind.get_path ();\n+  if (rebind.has_path ())\n+    paths.emplace_back (path);\n+\n+  // FIXME: Do we want to emplace the rebind here as well?\n+  if (rebind.has_identifier ())\n+    {\n+      auto rebind_path = path;\n+      auto new_seg = rebind.get_identifier ();\n+\n+      // Add the identifier as a new path\n+      rebind_path.get_segments ().back ()\n+\t= AST::SimplePathSegment (new_seg, Location ());\n+\n+      paths.emplace_back (rebind_path);\n+    }\n+}\n+\n+static void\n+flatten_list (const AST::UseTreeList &list, std::vector<AST::SimplePath> &paths)\n+{\n+  auto prefix = AST::SimplePath::create_empty ();\n+  if (list.has_path ())\n+    prefix = list.get_path ();\n+\n+  for (const auto &tree : list.get_trees ())\n+    {\n+      auto sub_paths = std::vector<AST::SimplePath> ();\n+      flatten (tree.get (), sub_paths);\n+\n+      for (auto &sub_path : sub_paths)\n+\t{\n+\t  auto new_path = prefix;\n+\t  std::copy (sub_path.get_segments ().begin (),\n+\t\t     sub_path.get_segments ().end (),\n+\t\t     std::back_inserter (new_path.get_segments ()));\n+\n+\t  paths.emplace_back (new_path);\n+\t}\n+    }\n+}\n+\n+/**\n+ * Flatten a UseDeclaration's UseTree into multiple simple paths to resolve.\n+ *\n+ * Given the following use declarations:\n+ * ```\n+ * use some::path::to_resolve; #1\n+ * use some::path::to_glob::*; #2\n+ * use some::path::{one, two}; #2\n+ * ```\n+ *\n+ * In the first case, we simply want to return a vector with a single\n+ * SimplePath:\n+ * [some::path::to_resolve]\n+ *\n+ * In the second case, we want to resolve the glob's \"origin path\":\n+ * [some::path::to_glob]\n+ *\n+ * Finally in the third case, we want to create two SimplePaths to resolve:\n+ * [some::path::one, some::path::two]\n+ */\n+static std::vector<AST::SimplePath>\n+flatten_use_dec_to_paths (const AST::UseDeclaration &use_item)\n+{\n+  auto paths = std::vector<AST::SimplePath> ();\n+\n+  const auto &tree = use_item.get_tree ();\n+  flatten (tree.get (), paths);\n+\n+  return paths;\n+}\n+\n+void\n+ResolveItem::visit (AST::UseDeclaration &use_item)\n+{\n+  auto to_resolve = flatten_use_dec_to_paths (use_item);\n+\n+  for (auto &path : to_resolve)\n+    ResolvePath::go (&path, parent);\n+}\n+\n void\n ResolveImplItems::go (AST::InherentImplItem *item, const CanonicalPath &prefix,\n \t\t      const CanonicalPath &canonical_prefix)\n@@ -991,3 +1120,167 @@ ResolveExternItem::visit (AST::ExternalStaticItem &item)\n \n } // namespace Resolver\n } // namespace Rust\n+\n+#if CHECKING_P\n+\n+namespace selftest {\n+\n+static void\n+rust_flatten_nested_glob (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_glob (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto glob\n+    = Rust::AST::UseTreeGlob (Rust::AST::UseTreeGlob::PathType::PATH_PREFIXED,\n+\t\t\t      frob, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_glob (glob, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+}\n+\n+static void\n+rust_flatten_rebind_none (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foobar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE,\n+\t\t\t\t\t  foobar, Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 1);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+}\n+\n+static void\n+rust_flatten_rebind (void)\n+{\n+  auto frob = Rust::AST::SimplePath::from_str (\"frobulator\", Location ());\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  frob, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0], \"frobulator\");\n+  ASSERT_EQ (paths[1], \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_rebind_nested (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto baz = Rust::AST::SimplePathSegment (\"baz\", Location ());\n+\n+  auto foo_bar_baz = Rust::AST::SimplePath ({foo, bar, baz});\n+\n+  auto rebind = Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::IDENTIFIER,\n+\t\t\t\t\t  foo_bar_baz, Location (), \"saindoux\");\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_rebind (rebind, paths);\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"saindoux\");\n+}\n+\n+static void\n+rust_flatten_list (void)\n+{\n+  auto foo = Rust::AST::SimplePathSegment (\"foo\", Location ());\n+  auto bar = Rust::AST::SimplePathSegment (\"bar\", Location ());\n+  auto foo_bar = Rust::AST::SimplePath ({foo, bar});\n+\n+  auto baz = Rust::AST::SimplePath::from_str (\"baz\", Location ());\n+  auto bul = Rust::AST::SimplePath::from_str (\"bul\", Location ());\n+\n+  // use foo::bar::{baz, bul};\n+\n+  auto use0 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, baz,\n+\t\t\t\t  Location ()));\n+  auto use1 = std::unique_ptr<Rust::AST::UseTree> (\n+    new Rust::AST::UseTreeRebind (Rust::AST::UseTreeRebind::NONE, bul,\n+\t\t\t\t  Location ()));\n+\n+  auto uses = std::vector<std::unique_ptr<Rust::AST::UseTree>> ();\n+  uses.emplace_back (std::move (use0));\n+  uses.emplace_back (std::move (use1));\n+\n+  auto list = Rust::AST::UseTreeList (Rust::AST::UseTreeList::PATH_PREFIXED,\n+\t\t\t\t      foo_bar, std::move (uses), Location ());\n+\n+  auto paths = std::vector<Rust::AST::SimplePath> ();\n+  Rust::Resolver::flatten_list (list, paths);\n+\n+  for (auto &path : paths)\n+    fprintf (stderr, \"%s\\n\", path.as_string ().c_str ());\n+\n+  ASSERT_TRUE (!paths.empty ());\n+  ASSERT_EQ (paths.size (), 2);\n+  ASSERT_EQ (paths[0].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[0].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[0].get_segments ()[2].as_string (), \"baz\");\n+  ASSERT_EQ (paths[1].get_segments ()[0].as_string (), \"foo\");\n+  ASSERT_EQ (paths[1].get_segments ()[1].as_string (), \"bar\");\n+  ASSERT_EQ (paths[1].get_segments ()[2].as_string (), \"bul\");\n+}\n+\n+static void\n+rust_use_dec_flattening (void)\n+{\n+  rust_flatten_glob ();\n+  rust_flatten_nested_glob ();\n+  rust_flatten_rebind_none ();\n+  rust_flatten_rebind ();\n+  rust_flatten_rebind_nested ();\n+  rust_flatten_list ();\n+}\n+\n+void\n+rust_simple_path_resolve_test (void)\n+{\n+  rust_use_dec_flattening ();\n+}\n+} // namespace selftest\n+\n+#endif // CHECKING_P"}, {"sha": "e6b11f514cba12582b06617138638ed7ec10fffa", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -26,6 +26,7 @@\n #include \"rust-ast-resolve-type.h\"\n #include \"rust-ast-resolve-pattern.h\"\n #include \"rust-ast-resolve-stmt.h\"\n+#include \"config.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -81,6 +82,7 @@ class ResolveItem : public ResolverBase\n   void visit (AST::TraitImpl &impl_block) override;\n   void visit (AST::Trait &trait) override;\n   void visit (AST::ExternBlock &extern_block) override;\n+  void visit (AST::UseDeclaration &) override;\n \n protected:\n   void resolve_impl_item (AST::TraitImplItem *item, const CanonicalPath &prefix,\n@@ -136,4 +138,13 @@ class ResolveExternItem : public ResolverBase\n } // namespace Resolver\n } // namespace Rust\n \n+#if CHECKING_P\n+\n+namespace selftest {\n+extern void\n+rust_simple_path_resolve_test (void);\n+} // namespace selftest\n+\n+#endif // CHECKING_P\n+\n #endif // RUST_AST_RESOLVE_ITEM_H"}, {"sha": "73f9839ee3e6743784dd46da4d1866021a34c377", "filename": "gcc/rust/rust-lang.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -36,6 +36,7 @@\n #include \"selftest.h\"\n #include \"rust-cfg-parser.h\"\n #include \"rust-privacy-ctx.h\"\n+#include \"rust-ast-resolve-item.h\"\n \n #include <mpfr.h>\n // note: header files must be in this order or else forward declarations don't\n@@ -459,6 +460,7 @@ run_rust_tests ()\n   rust_cfg_parser_test ();\n   rust_privacy_ctx_test ();\n   rust_crate_name_validation_test ();\n+  rust_simple_path_resolve_test ();\n }\n } // namespace selftest\n "}, {"sha": "0b0e5af915f48c955aafc22f9117c669466f1559", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -932,23 +932,25 @@ Session::injection (AST::Crate &crate)\n \n   // create use tree path\n   // prelude is injected_crate_name\n-  std::vector<AST::SimplePathSegment> segments\n-    = {AST::SimplePathSegment (injected_crate_name, Location ()),\n-       AST::SimplePathSegment (\"prelude\", Location ()),\n-       AST::SimplePathSegment (\"v1\", Location ())};\n-  // create use tree and decl\n-  std::unique_ptr<AST::UseTreeGlob> use_tree (\n-    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n-\t\t\t  AST::SimplePath (std::move (segments)), Location ()));\n-  AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\",\n-\t\t\t\t\t\t\t  Location ()),\n-\t\t\t       nullptr);\n-  std::unique_ptr<AST::UseDeclaration> use_decl (\n-    new AST::UseDeclaration (std::move (use_tree),\n-\t\t\t     AST::Visibility::create_error (),\n-\t\t\t     {std::move (prelude_attr)}, Location ()));\n-\n-  crate.items.insert (crate.items.begin (), std::move (use_decl));\n+  // FIXME: Once we do want to include the standard library, add the prelude\n+  // use item\n+  // std::vector<AST::SimplePathSegment> segments\n+  //   = {AST::SimplePathSegment (injected_crate_name, Location ()),\n+  //      AST::SimplePathSegment (\"prelude\", Location ()),\n+  //      AST::SimplePathSegment (\"v1\", Location ())};\n+  // // create use tree and decl\n+  // std::unique_ptr<AST::UseTreeGlob> use_tree (\n+  //   new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n+  //     \t\t  AST::SimplePath (std::move (segments)), Location ()));\n+  // AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\",\n+  //     \t\t\t\t\t\t  Location ()),\n+  //     \t\t       nullptr);\n+  // std::unique_ptr<AST::UseDeclaration> use_decl (\n+  //   new AST::UseDeclaration (std::move (use_tree),\n+  //     \t\t     AST::Visibility::create_error (),\n+  //     \t\t     {std::move (prelude_attr)}, Location ()));\n+\n+  // crate.items.insert (crate.items.begin (), std::move (use_decl));\n \n   /* TODO: potentially add checking attribute crate type? I can't figure out\n    * what this does currently comment says \"Unconditionally collect crate"}, {"sha": "d65faf2972a044cc1d2ba0309e3ed235dabe7bd8", "filename": "gcc/testsuite/rust/compile/torture/cfg_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcfg_attr.rs?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -1,4 +1,4 @@\n-use std::env; // Add one line so gccrs doesn't believe we're parsing a shebang\n+mod fake {} // Add one line so gccrs doesn't believe we're parsing a shebang\n \n #[cfg_attr(feature = \"somefeature\", attribute = \"someattr\")]\n struct Feature;"}, {"sha": "94b96321a6353476aac869768e4ca45e875430bb", "filename": "gcc/testsuite/rust/compile/use_1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0589ea7dbe6c36cfb334220d4ea3905c0673d9f/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fuse_1.rs?ref=c0589ea7dbe6c36cfb334220d4ea3905c0673d9f", "patch": "@@ -0,0 +1,16 @@\n+mod frob {}\n+\n+use foo::bar::baz; // { dg-error \"cannot find simple path segment .foo.\" }\n+use frob::ulator; // { dg-error \"cannot find simple path segment .ulator.\" }\n+\n+mod sain {\n+    mod doux {}\n+\n+    mod dron {}\n+}\n+\n+use not_sain::*; // { dg-error \"cannot find simple path segment .not_sain.\" }\n+\n+use sain::*;\n+use sain::{doux, dron};\n+use sain::{doux, dron, graal}; // { dg-error \"cannot find simple path segment .graal.\" }"}]}