{"sha": "a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVkZTAyZTllM2VmZGNkYWNjNWRjMTAwYjYxZDFmZDQ1ZTcxOTk1NQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-22T20:31:14Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-22T20:31:14Z"}, "message": "* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::evrp_range_analyzer)\n\tInitialize vr_values.\n\t(evrp_range_analyzer::try_find_new_range): Call methods attached to\n\tvr_values via vr_values class instance rather than delegators.\n\t(evrp_range_analyzer::record_ranges_from_phis): Likewise.\n\t(evrp_range_analyzer::record_ranges_from_stmt): Likewise.\n\t(evrp_range_analyzer::push_value_range): Likewise.\n\t(evrp_range_analyzer::pop_value_range): Likewise.\n\t* gimple-ssa-evrp-analyze.h (class evrp_range_analyzer): Remove\n\tmost delegators.  Those remaining are exposed as public interfaces.\n\tMake vr_values a pointer and private.\n\t(evrp_range_analyzer::~evrp_range_analyzer): Delete the attached\n\tvr_values.\n\t(evrp_range_analyzer::get_vr_value): New method.\n\t* gimple-ssa-evrp.c (class evrp_folder): Use DISABLE_COPY_AND_ASSIGN.\n\t(evrp_folder::evrp_folder): New ctor to initialize vr_values.\n\t(class evrp_dom_walker): Attach evrp_folder class, initialize\n\tit in the ctor.  Remove temporary delegators.\n\t(evrp_dom_walker::before_dom_children): Call methods in attached\n\tevrp_range_analyzer class via class instance pointer.  Use\n\tfree value_range_constant_singleton to remove need for\n\top_with_constant_singleton_value delegator method.  Do not\n\tcreate a vrp_prop class instance for every call!  Narrow\n\tscope of a couple variables.\n\t(evrp_dom_walker::cleanup): Call methods in attached\n\tevrp_range_analyzer class via class instance pointer.\n\t* vr-values.h (class vr_values): Privatize many methods and\n\tdata members.\n\nFrom-SVN: r255074", "tree": {"sha": "97da5bea9a9415baae6f7880c5b5f649e95dff73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97da5bea9a9415baae6f7880c5b5f649e95dff73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/comments", "author": null, "committer": null, "parents": [{"sha": "16d24520af1ad5ff832d243f177d88f08a1ba012", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d24520af1ad5ff832d243f177d88f08a1ba012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d24520af1ad5ff832d243f177d88f08a1ba012"}], "stats": {"total": 219, "additions": 127, "deletions": 92}, "files": [{"sha": "4ecf5bcc038f3331df620f765eb961b1eb2a1435", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "patch": "@@ -1,3 +1,34 @@\n+2017-11-22  Jeff Law  <law@redhat.com>\n+\n+\t* gimple-ssa-evrp-analyze.c (evrp_range_analyzer::evrp_range_analyzer)\n+\tInitialize vr_values.\n+\t(evrp_range_analyzer::try_find_new_range): Call methods attached to\n+\tvr_values via vr_values class instance rather than delegators.\n+\t(evrp_range_analyzer::record_ranges_from_phis): Likewise.\n+\t(evrp_range_analyzer::record_ranges_from_stmt): Likewise.\n+\t(evrp_range_analyzer::push_value_range): Likewise.\n+\t(evrp_range_analyzer::pop_value_range): Likewise.\n+\t* gimple-ssa-evrp-analyze.h (class evrp_range_analyzer): Remove\n+\tmost delegators.  Those remaining are exposed as public interfaces.\n+\tMake vr_values a pointer and private.\n+\t(evrp_range_analyzer::~evrp_range_analyzer): Delete the attached\n+\tvr_values.\n+\t(evrp_range_analyzer::get_vr_value): New method.\n+\t* gimple-ssa-evrp.c (class evrp_folder): Use DISABLE_COPY_AND_ASSIGN.\n+\t(evrp_folder::evrp_folder): New ctor to initialize vr_values.\n+\t(class evrp_dom_walker): Attach evrp_folder class, initialize\n+\tit in the ctor.  Remove temporary delegators.\n+\t(evrp_dom_walker::before_dom_children): Call methods in attached\n+\tevrp_range_analyzer class via class instance pointer.  Use\n+\tfree value_range_constant_singleton to remove need for\n+\top_with_constant_singleton_value delegator method.  Do not\n+\tcreate a vrp_prop class instance for every call!  Narrow\n+\tscope of a couple variables.\n+\t(evrp_dom_walker::cleanup): Call methods in attached\n+\tevrp_range_analyzer class via class instance pointer.\n+\t* vr-values.h (class vr_values): Privatize many methods and\n+\tdata members.\n+\n 2017-11-22  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree.def (REDUC_MAX_EXPR, REDUC_MIN_EXPR, REDUC_PLUS_EXPR): Delete."}, {"sha": "c3877791a5e40fcf79ee44992d859b084dd7762b", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "patch": "@@ -53,6 +53,7 @@ evrp_range_analyzer::evrp_range_analyzer () : stack (10)\n       FOR_EACH_EDGE (e, ei, bb->preds)\n         e->flags |= EDGE_EXECUTABLE;\n     }\n+  vr_values = new class vr_values;\n }\n \n void\n@@ -73,8 +74,8 @@ evrp_range_analyzer::try_find_new_range (tree name,\n   value_range *old_vr = get_value_range (name);\n \n   /* Discover VR when condition is true.  */\n-  extract_range_for_var_from_comparison_expr (name, code, op,\n-\t\t\t\t\t      limit, &vr);\n+  vr_values->extract_range_for_var_from_comparison_expr (name, code, op,\n+\t\t\t\t\t\t\t limit, &vr);\n   /* If we found any usable VR, set the VR to ssa_name and create a\n      PUSH old value in the stack with the old VR.  */\n   if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n@@ -83,7 +84,7 @@ evrp_range_analyzer::try_find_new_range (tree name,\n \t  && vrp_operand_equal_p (old_vr->min, vr.min)\n \t  && vrp_operand_equal_p (old_vr->max, vr.max))\n \treturn NULL;\n-      value_range *new_vr = vr_values.vrp_value_range_pool.allocate ();\n+      value_range *new_vr = vr_values->vrp_value_range_pool.allocate ();\n       *new_vr = vr;\n       return new_vr;\n     }\n@@ -167,7 +168,7 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n       value_range vr_result = VR_INITIALIZER;\n       bool interesting = stmt_interesting_for_vrp (phi);\n       if (!has_unvisited_preds && interesting)\n-\textract_range_from_phi_node (phi, &vr_result);\n+\tvr_values->extract_range_from_phi_node (phi, &vr_result);\n       else\n \t{\n \t  set_value_range_to_varying (&vr_result);\n@@ -179,9 +180,9 @@ evrp_range_analyzer::record_ranges_from_phis (basic_block bb)\n \t  if (interesting\n \t      && (l = loop_containing_stmt (phi))\n \t      && l->header == gimple_bb (phi))\n-\t  adjust_range_with_scev (&vr_result, l, phi, lhs);\n+\t  vr_values->adjust_range_with_scev (&vr_result, l, phi, lhs);\n \t}\n-      update_value_range (lhs, &vr_result);\n+      vr_values->update_value_range (lhs, &vr_result);\n \n       /* Set the SSA with the value range.  */\n       if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n@@ -216,11 +217,11 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n     {\n       edge taken_edge;\n       value_range vr = VR_INITIALIZER;\n-      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+      vr_values->extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n       if (output\n \t  && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n \t{\n-\t  update_value_range (output, &vr);\n+\t  vr_values->update_value_range (output, &vr);\n \n \t  /* Set the SSA with the value range.  */\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n@@ -240,10 +241,10 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt)\n \t    set_ptr_nonnull (output);\n \t}\n       else\n-\tset_defs_to_varying (stmt);\n+\tvr_values->set_defs_to_varying (stmt);\n     }\n   else\n-    set_defs_to_varying (stmt);\n+    vr_values->set_defs_to_varying (stmt);\n \n   /* See if we can derive a range for any of STMT's operands.  */\n   tree op;\n@@ -319,7 +320,7 @@ evrp_range_analyzer::push_value_range (tree var, value_range *vr)\n       fprintf (dump_file, \"\\n\");\n     }\n   stack.safe_push (std::make_pair (var, get_value_range (var)));\n-  set_vr_value (var, vr);\n+  vr_values->set_vr_value (var, vr);\n }\n \n /* Pop the Value Range from the vrp_stack and update VAR with it.  */\n@@ -337,7 +338,7 @@ evrp_range_analyzer::pop_value_range (tree var)\n       dump_value_range (dump_file, vr);\n       fprintf (dump_file, \"\\n\");\n     }\n-  set_vr_value (var, vr);\n+  vr_values->set_vr_value (var, vr);\n   stack.pop ();\n   return vr;\n }"}, {"sha": "637678034a8e2c701af670193f404058ebc5831d", "filename": "gcc/gimple-ssa-evrp-analyze.h", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp-analyze.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp-analyze.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.h?ref=a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "patch": "@@ -24,16 +24,45 @@ class evrp_range_analyzer\n {\n  public:\n   evrp_range_analyzer (void);\n-  ~evrp_range_analyzer (void) { stack.release (); }\n+  ~evrp_range_analyzer (void)\n+  {\n+    delete vr_values;\n+    stack.release ();\n+  }\n \n   void enter (basic_block);\n   void leave (basic_block);\n   void record_ranges_from_stmt (gimple *);\n \n-  class vr_values vr_values;\n+  /* Main interface to retrieve range information.  */\n+  value_range *get_value_range (const_tree op)\n+    { return vr_values->get_value_range (op); }\n+\n+  /* Dump all the current value ranges.  This is primarily\n+     a debugging interface.  */\n+  void dump_all_value_ranges (FILE *fp)\n+    { vr_values->dump_all_value_ranges (fp); }\n+\n+  /* A bit of a wart.  This should ideally go away.  */\n+  void vrp_visit_cond_stmt (gcond *cond, edge *e)\n+    { return vr_values->vrp_visit_cond_stmt (cond, e); }\n+\n+  /* Get the underlying vr_values class instance.  If TRANSFER is\n+     true, then we are transferring ownership.  Else we keep ownership.\n+\n+     This should be converted to a unique_ptr.  */\n+  class vr_values *get_vr_values (bool transfer)\n+    {\n+      class vr_values *x = vr_values;\n+      if (transfer)\n+\tvr_values = NULL;\n+      return x;\n+    }\n \n  private:\n   DISABLE_COPY_AND_ASSIGN (evrp_range_analyzer);\n+  class vr_values *vr_values;\n+\n   void push_value_range (tree var, value_range *vr);\n   value_range *pop_value_range (tree var);\n   value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n@@ -42,30 +71,6 @@ class evrp_range_analyzer\n \n   /* STACK holds the old VR.  */\n   auto_vec<std::pair <tree, value_range*> > stack;\n-\n-  /* Temporary delegators.  */\n-  value_range *get_value_range (const_tree op)\n-    { return vr_values.get_value_range (op); }\n-  bool update_value_range (const_tree op, value_range *vr)\n-    { return vr_values.update_value_range (op, vr); }\n-  void extract_range_from_phi_node (gphi *phi, value_range *vr)\n-    { vr_values.extract_range_from_phi_node (phi, vr); }\n-  void adjust_range_with_scev (value_range *vr, struct loop *loop,\n-                               gimple *stmt, tree var)\n-    { vr_values.adjust_range_with_scev (vr, loop, stmt, var); }\n-  void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,\n-                                tree *output_p, value_range *vr)\n-    { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }\n-  void set_defs_to_varying (gimple *stmt)\n-    { return vr_values.set_defs_to_varying (stmt); }\n-  void set_vr_value (tree name, value_range *vr)\n-    { vr_values.set_vr_value (name, vr); }\n-  void extract_range_for_var_from_comparison_expr (tree var,\n-\t\t\t\t\t\t   enum tree_code cond_code,\n-\t\t\t\t\t\t   tree op, tree limit,\n-\t\t\t\t\t\t   value_range *vr_p)\n-    { vr_values.extract_range_for_var_from_comparison_expr (var, cond_code,\n-\t\t\t\t\t\t\t    op, limit, vr_p); }\n };\n \n #endif /* GCC_GIMPLE_SSA_EVRP_ANALYZE_H */"}, {"sha": "a554cf9e834ab5e283f427df09b0ddb6518c8da1", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "patch": "@@ -46,8 +46,11 @@ class evrp_folder : public substitute_and_fold_engine\n {\n  public:\n   tree get_value (tree) FINAL OVERRIDE;\n-\n+  evrp_folder (class vr_values *vr_values_) : vr_values (vr_values_) { }\n   class vr_values *vr_values;\n+\n+ private:\n+  DISABLE_COPY_AND_ASSIGN (evrp_folder);\n };\n \n tree\n@@ -63,7 +66,9 @@ evrp_folder::get_value (tree op)\n class evrp_dom_walker : public dom_walker\n {\n public:\n-  evrp_dom_walker () : dom_walker (CDI_DOMINATORS)\n+  evrp_dom_walker ()\n+    : dom_walker (CDI_DOMINATORS),\n+      evrp_folder (evrp_range_analyzer.get_vr_values (false))\n     {\n       need_eh_cleanup = BITMAP_ALLOC (NULL);\n     }\n@@ -82,14 +87,7 @@ class evrp_dom_walker : public dom_walker\n   auto_vec<gimple *> stmts_to_remove;\n \n   class evrp_range_analyzer evrp_range_analyzer;\n-\n-  /* Temporary delegators.  */\n-  value_range *get_value_range (const_tree op)\n-    { return evrp_range_analyzer.vr_values.get_value_range (op); }\n-  tree op_with_constant_singleton_value_range (tree op)\n-    { return evrp_range_analyzer.vr_values.op_with_constant_singleton_value_range (op); }\n-  void vrp_visit_cond_stmt (gcond *cond, edge *e)\n-    { evrp_range_analyzer.vr_values.vrp_visit_cond_stmt (cond, e); }\n+  class evrp_folder evrp_folder;\n };\n \n edge\n@@ -108,8 +106,9 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n       if (virtual_operand_p (lhs))\n \tcontinue;\n \n+      value_range *vr = evrp_range_analyzer.get_value_range (lhs);\n       /* Mark PHIs whose lhs we fully propagate for removal.  */\n-      tree val = op_with_constant_singleton_value_range (lhs);\n+      tree val = value_range_constant_singleton (vr);\n       if (val && may_propagate_copy (lhs, val))\n \t{\n \t  stmts_to_remove.safe_push (phi);\n@@ -139,7 +138,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \n       if (gcond *cond = dyn_cast <gcond *> (stmt))\n \t{\n-\t  vrp_visit_cond_stmt (cond, &taken_edge);\n+\t  evrp_range_analyzer.vrp_visit_cond_stmt (cond, &taken_edge);\n \t  if (taken_edge)\n \t    {\n \t      if (taken_edge->flags & EDGE_TRUE_VALUE)\n@@ -153,16 +152,15 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t}\n       else if (stmt_interesting_for_vrp (stmt))\n \t{\n-\t  value_range vr = VR_INITIALIZER;\n \t  output = get_output_for_vrp (stmt);\n \t  if (output)\n \t    {\n \t      tree val;\n-\t      vr = *get_value_range (output);\n+\t      value_range *vr = evrp_range_analyzer.get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n-\t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n-\t\t  && (val = op_with_constant_singleton_value_range (output))\n+\t      if ((vr->type == VR_RANGE || vr->type == VR_ANTI_RANGE)\n+\t\t  && (val = value_range_constant_singleton (vr))\n \t\t  && may_propagate_copy (output, val)\n \t\t  && !stmt_could_throw_p (stmt)\n \t\t  && !gimple_has_side_effects (stmt))\n@@ -174,8 +172,6 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t}\n \n       /* Try folding stmts with the VR discovered.  */\n-      class evrp_folder evrp_folder;\n-      evrp_folder.vr_values = &evrp_range_analyzer.vr_values;\n       bool did_replace = evrp_folder.replace_uses_in (stmt);\n       if (fold_stmt (&gsi, follow_single_use_edges)\n \t  || did_replace)\n@@ -222,7 +218,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  if (TREE_CODE (arg) != SSA_NAME\n \t      || virtual_operand_p (arg))\n \t    continue;\n-\t  tree val = op_with_constant_singleton_value_range (arg);\n+\t  value_range *vr = evrp_range_analyzer.get_value_range (arg);\n+\t  tree val = value_range_constant_singleton (vr);\n \t  if (val && may_propagate_copy (arg, val))\n \t    propagate_value (use_p, val);\n \t}\n@@ -245,7 +242,7 @@ evrp_dom_walker::cleanup (void)\n   if (dump_file)\n     {\n       fprintf (dump_file, \"\\nValue ranges after Early VRP:\\n\\n\");\n-      evrp_range_analyzer.vr_values.dump_all_value_ranges (dump_file);\n+      evrp_range_analyzer.dump_all_value_ranges (dump_file);\n       fprintf (dump_file, \"\\n\");\n     }\n "}, {"sha": "9eeebedfaed359be02fa3c3f66a7238a69393016", "filename": "gcc/vr-values.h", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5de02e9e3efdcdacc5dc100b61d1fd45e719955/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=a5de02e9e3efdcdacc5dc100b61d1fd45e719955", "patch": "@@ -40,80 +40,81 @@ class vr_values\n   vr_values (void);\n   ~vr_values (void);\n \n-  /* Value range array.  After propagation, VR_VALUE[I] holds the range\n-     of values that SSA name N_I may take.  */\n-  unsigned int num_vr_values;\n-  value_range **vr_value;\n-  bool values_propagated;\n+  value_range *get_value_range (const_tree);\n \n-  /* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n-     number of executable edges we saw the last time we visited the\n-     node.  */\n-  int *vr_phi_edge_counts;\n+  void set_vr_value (tree, value_range *);\n+  void set_defs_to_varying (gimple *);\n+  bool update_value_range (const_tree, value_range *);\n+  tree op_with_constant_singleton_value_range (tree);\n+  void adjust_range_with_scev (value_range *, struct loop *, gimple *, tree);\n+  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n+  void dump_all_value_ranges (FILE *);\n+\n+  void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n+\t\t\t\t\t\t   tree, tree, value_range *);\n+  void extract_range_from_phi_node (gphi *, value_range *);\n+  void extract_range_basic (value_range *, gimple *);\n+  void extract_range_from_assignment (value_range *, gassign *);\n+  void extract_range_from_stmt (gimple *, edge *, tree *, value_range *);\n+\n+  void vrp_visit_cond_stmt (gcond *, edge *);\n+\n+  void simplify_cond_using_ranges_2 (gcond *);\n+  bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n+\n+  /* This probably belongs in the lattice rather than in here.  */\n+  bool values_propagated;\n \n   /* Allocation pools for tree-vrp allocations.  */\n   object_allocator<value_range> vrp_value_range_pool;\n-  bitmap_obstack vrp_equiv_obstack;\n \n-  value_range *get_value_range (const_tree);\n-  void set_vr_value (tree, value_range *);\n-\n-  void set_defs_to_varying (gimple *);\n-  bool update_value_range (const_tree, value_range *);\n+ private:\n+  bitmap_obstack vrp_equiv_obstack;\n   void add_equivalence (bitmap *, const_tree);\n   bool vrp_stmt_computes_nonzero (gimple *);\n-  tree op_with_constant_singleton_value_range (tree);\n   bool op_with_boolean_value_range_p (tree);\n   bool check_for_binary_op_overflow (enum tree_code, tree, tree, tree, bool *);\n-  void adjust_range_with_scev (value_range *, struct loop *, gimple *, tree);\n   value_range get_vr_for_comparison (int);\n   tree compare_name_with_value (enum tree_code, tree, tree, bool *, bool);\n   tree compare_names (enum tree_code, tree, tree, bool *);\n   bool two_valued_val_range_p (tree, tree *, tree *);\n-\n   tree vrp_evaluate_conditional_warnv_with_ops_using_ranges (enum tree_code,\n \t\t\t\t\t\t\t     tree, tree,\n \t\t\t\t\t\t\t     bool *);\n   tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n \t\t\t\t\t\ttree, tree, bool,\n \t\t\t\t\t\tbool *, bool *);\n-  tree vrp_evaluate_conditional (tree_code, tree, tree, gimple *);\n-\n-\n-  void dump_all_value_ranges (FILE *);\n-\n-  void extract_range_for_var_from_comparison_expr (tree, enum tree_code,\n-\t\t\t\t\t\t   tree, tree, value_range *);\n   void extract_range_from_assert (value_range *, tree);\n   void extract_range_from_ssa_name (value_range *, tree);\n   void extract_range_from_binary_expr (value_range *, enum tree_code,\n \t\t\t\t       tree, tree, tree);\n   void extract_range_from_unary_expr (value_range *, enum tree_code,\n \t\t\t\t      tree, tree);\n-  void extract_range_from_phi_node (gphi *, value_range *);\n   void extract_range_from_cond_expr (value_range *, gassign *);\n-  void extract_range_basic (value_range *, gimple *);\n-  void extract_range_from_assignment (value_range *, gassign *);\n-  void extract_range_from_stmt (gimple *, edge *, tree *, value_range *);\n   void extract_range_from_comparison (value_range *, enum tree_code,\n \t\t\t\t      tree, tree, tree);\n-\n   void vrp_visit_assignment_or_call (gimple*, tree *, value_range *);\n   void vrp_visit_switch_stmt (gswitch *, edge *);\n-  void vrp_visit_cond_stmt (gcond *, edge *);\n-\n   bool simplify_truth_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_div_or_mod_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_abs_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_bit_ops_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_min_or_max_using_ranges (gimple_stmt_iterator *, gimple *);\n   bool simplify_cond_using_ranges_1 (gcond *);\n-  void simplify_cond_using_ranges_2 (gcond *);\n   bool simplify_switch_using_ranges (gswitch *);\n   bool simplify_float_conversion_using_ranges (gimple_stmt_iterator *,\n \t\t\t\t\t       gimple *);\n   bool simplify_internal_call_using_ranges (gimple_stmt_iterator *, gimple *);\n-  bool simplify_stmt_using_ranges (gimple_stmt_iterator *);\n+\n+  /* Value range array.  After propagation, VR_VALUE[I] holds the range\n+     of values that SSA name N_I may take.  */\n+  unsigned int num_vr_values;\n+  value_range **vr_value;\n+\n+  /* For a PHI node which sets SSA name N_I, VR_COUNTS[I] holds the\n+     number of executable edges we saw the last time we visited the\n+     node.  */\n+  int *vr_phi_edge_counts;\n };\n \n #define VR_INITIALIZER { VR_UNDEFINED, NULL_TREE, NULL_TREE, NULL }"}]}