{"sha": "ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY3OGJjM2MwYjlkMjNiM2RlY2Q4YjY0MzljOTlhMDI1ZWJjOGYyOA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-03-05T11:35:47Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-03-05T11:35:47Z"}, "message": "check.c (positive_check): Add new function checking constant for being greater then zero.\n\ngcc/fortran/ChangeLog:\n\n2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n            Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n\n\t* check.c (positive_check): Add new function checking constant for\n\tbeing greater then zero.\n\t(gfc_check_image_status): Add checking of image_status arguments.\n\t(gfc_check_failed_or_stopped_images): Same but for failed_- and\n\tstopped_images function.\n\t* dump-parse-tree.c (show_code_node): Added output of FAIL IMAGE.\n\t* gfortran.h (enum gfc_statement): Added FAIL_IMAGE_ST.\n\t(enum gfc_isym_id): Added new intrinsic symbols.\n\t(enum gfc_exec_op): Added EXEC_FAIL_IMAGE.\n\t* gfortran.texi: Added description for the new API functions. Updated\n\tcoverage of gfortran of TS18508.\n\t* intrinsic.c (add_functions): Added symbols to resolve new intrinsic\n\tfunctions. \n\t* intrinsic.h: Added prototypes.\n\t* iresolve.c (gfc_resolve_failed_images): Resolve the failed_images\n\tintrinsic.\n\t(gfc_resolve_image_status): Same for image_status.\n\t(gfc_resolve_stopped_images): Same for stopped_images.\n\t* libgfortran.h: Added prototypes.\n\t* match.c (gfc_match_if): Added matching of FAIL IMAGE statement.\n\t(gfc_match_fail_image): Match a FAIL IMAGE statement.\n\t* match.h: Added prototype.\n\t* parse.c (decode_statement): Added matching for FAIL IMAGE.\n\t(next_statement): Same.\n\t(gfc_ascii_statement): Same.\n\t* resolve.c: Same.\n\t* simplify.c (gfc_simplify_failed_or_stopped_images): For COARRAY=\n\tsingle a constant result can be returne.d\n\t(gfc_simplify_image_status): For COARRAY=single the result is constant.\n\t* st.c (gfc_free_statement): Added FAIL_IMAGE handling.\n\t* trans-decl.c (gfc_build_builtin_function_decls): Added decls of the\n\tnew intrinsics.\n\t* trans-expr.c (gfc_conv_procedure_call): This is first time all\n\targuments of a function are optional, which is now handled here\n\tcorrectly.\n\t* trans-intrinsic.c (conv_intrinsic_image_status): Translate\n\timage_status.\n\t(gfc_conv_intrinsic_function): Add support for image_status.\n\t(gfc_is_intrinsic_libcall): Add support for the remaining new\n\tintrinsics.\n\t* trans-stmt.c (gfc_trans_fail_image): Trans a fail image.\n\t* trans-stmt.h: Add the prototype for the above.\n\t* trans.c (trans_code): Dispatch for fail_image.\n\t* trans.h: Add the trees for the new intrinsics.\n\nlibgfortran/ChangeLog:\n\n2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n            Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n\n\t* caf/libcaf.h: Added prototypes and stat codes for failed and stopped\n\timages.\n\t* caf/single.c (void _gfortran_caf_fail_image): Add the routine.\n\t(int _gfortran_caf_image_status): Same.\n\t(_gfortran_caf_failed_images): Same.\n\t(_gfortran_caf_stopped_images): Same.\n\n\ngcc/testsuite/ChangeLog:\n\n2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n            Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n\n\t* gfortran.dg/coarray/fail_image_1.f08: New test.\n\t* gfortran.dg/coarray/fail_image_2.f08: New test.\n\t* gfortran.dg/coarray/failed_images_1.f08: New test.\n\t* gfortran.dg/coarray/failed_images_2.f08: New test.\n\t* gfortran.dg/coarray/image_status_1.f08: New test.\n\t* gfortran.dg/coarray/image_status_2.f08: New test.\n\t* gfortran.dg/coarray/stopped_images_1.f08: New test.\n\t* gfortran.dg/coarray/stopped_images_2.f08: New test.\n\t* gfortran.dg/coarray_fail_st.f90: New test.\n\t* gfortran.dg/coarray_failed_images_1.f08: New test.\n\t* gfortran.dg/coarray_image_status_1.f08: New test.\n\t* gfortran.dg/coarray_stopped_images_1.f08: New test.\n\nFrom-SVN: r245900", "tree": {"sha": "992e5a7217ac50b58fd957616898363d731e3380", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/992e5a7217ac50b58fd957616898363d731e3380"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/comments", "author": null, "committer": null, "parents": [{"sha": "55a8bcbb1fc83958e12037974b20f2164840ca42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55a8bcbb1fc83958e12037974b20f2164840ca42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55a8bcbb1fc83958e12037974b20f2164840ca42"}], "stats": {"total": 890, "additions": 871, "deletions": 19}, "files": [{"sha": "8640646127c1fbccd28f197f90d254792ed91444", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1,3 +1,51 @@\n+2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>,\n+\t    Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\n+\t* check.c (positive_check): Add new function checking constant for\n+\tbeing greater then zero.\n+\t(gfc_check_image_status): Add checking of image_status arguments.\n+\t(gfc_check_failed_or_stopped_images): Same but for failed_- and\n+\tstopped_images function.\n+\t* dump-parse-tree.c (show_code_node): Added output of FAIL IMAGE.\n+\t* gfortran.h (enum gfc_statement): Added FAIL_IMAGE_ST.\n+\t(enum gfc_isym_id): Added new intrinsic symbols.\n+\t(enum gfc_exec_op): Added EXEC_FAIL_IMAGE.\n+\t* gfortran.texi: Added description for the new API functions. Updated\n+\tcoverage of gfortran of TS18508.\n+\t* intrinsic.c (add_functions): Added symbols to resolve new intrinsic\n+\tfunctions. \n+\t* intrinsic.h: Added prototypes.\n+\t* iresolve.c (gfc_resolve_failed_images): Resolve the failed_images\n+\tintrinsic.\n+\t(gfc_resolve_image_status): Same for image_status.\n+\t(gfc_resolve_stopped_images): Same for stopped_images.\n+\t* libgfortran.h: Added prototypes.\n+\t* match.c (gfc_match_if): Added matching of FAIL IMAGE statement.\n+\t(gfc_match_fail_image): Match a FAIL IMAGE statement.\n+\t* match.h: Added prototype.\n+\t* parse.c (decode_statement): Added matching for FAIL IMAGE.\n+\t(next_statement): Same.\n+\t(gfc_ascii_statement): Same.\n+\t* resolve.c: Same.\n+\t* simplify.c (gfc_simplify_failed_or_stopped_images): For COARRAY=\n+\tsingle a constant result can be returne.d\n+\t(gfc_simplify_image_status): For COARRAY=single the result is constant.\n+\t* st.c (gfc_free_statement): Added FAIL_IMAGE handling.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Added decls of the\n+\tnew intrinsics.\n+\t* trans-expr.c (gfc_conv_procedure_call): This is first time all\n+\targuments of a function are optional, which is now handled here\n+\tcorrectly.\n+\t* trans-intrinsic.c (conv_intrinsic_image_status): Translate\n+\timage_status.\n+\t(gfc_conv_intrinsic_function): Add support for image_status.\n+\t(gfc_is_intrinsic_libcall): Add support for the remaining new\n+\tintrinsics.\n+\t* trans-stmt.c (gfc_trans_fail_image): Trans a fail image.\n+\t* trans-stmt.h: Add the prototype for the above.\n+\t* trans.c (trans_code): Dispatch for fail_image.\n+\t* trans.h: Add the trees for the new intrinsics.\n+\n 2017-03-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/79841"}, {"sha": "45bc68ef7ad46575716dd2374c2afdb805175f1b", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -295,6 +295,29 @@ nonnegative_check (const char *arg, gfc_expr *expr)\n }\n \n \n+/* If expr is a constant, then check to ensure that it is greater than zero.  */\n+\n+static bool\n+positive_check (int n, gfc_expr *expr)\n+{\n+  int i;\n+\n+  if (expr->expr_type == EXPR_CONSTANT)\n+    {\n+      gfc_extract_int (expr, &i);\n+      if (i <= 0)\n+\t{\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L must be positive\",\n+\t\t     gfc_current_intrinsic_arg[n]->name, gfc_current_intrinsic,\n+\t\t     &expr->where);\n+\t  return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+\n /* If expr2 is constant, then check that the value is less than\n    (less than or equal to, if 'or_equal' is true) bit_size(expr1).  */\n \n@@ -1137,6 +1160,60 @@ gfc_check_atomic_ref (gfc_expr *value, gfc_expr *atom, gfc_expr *stat)\n }\n \n \n+bool\n+gfc_check_image_status (gfc_expr *image, gfc_expr *team)\n+{\n+  /* IMAGE has to be a positive, scalar integer.  */\n+  if (!type_check (image, 0, BT_INTEGER) || !scalar_check (image, 0)\n+      || !positive_check (0, image))\n+    return false;\n+\n+  if (team)\n+    {\n+      gfc_error (\"%qs argument of %qs intrinsic at %L not yet supported\",\n+\t\t gfc_current_intrinsic_arg[1]->name, gfc_current_intrinsic,\n+\t\t &team->where);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+\n+bool\n+gfc_check_failed_or_stopped_images (gfc_expr *team, gfc_expr *kind)\n+{\n+  if (team)\n+    {\n+      gfc_error (\"%qs argument of %qs intrinsic at %L not yet supported\",\n+\t\t gfc_current_intrinsic_arg[0]->name, gfc_current_intrinsic,\n+\t\t &team->where);\n+      return false;\n+    }\n+\n+  if (kind)\n+    {\n+      int k;\n+\n+      if (!type_check (kind, 1, BT_INTEGER) || !scalar_check (kind, 1)\n+\t  || !positive_check (1, kind))\n+\treturn false;\n+\n+      /* Get the kind, reporting error on non-constant or overflow.  */\n+      gfc_current_locus = kind->where;\n+      if (gfc_extract_int (kind, &k, 1))\n+\treturn false;\n+      if (gfc_validate_kind (BT_INTEGER, k, true) == -1)\n+\t{\n+\t  gfc_error (\"%qs argument of %qs intrinsic at %L shall specify a \"\n+\t\t     \"valid integer kind\", gfc_current_intrinsic_arg[1]->name,\n+\t\t     gfc_current_intrinsic, &kind->where);\n+\t  return false;\n+\t}\n+    }\n+  return true;\n+}\n+\n+\n bool\n gfc_check_atomic_cas (gfc_expr *atom, gfc_expr *old, gfc_expr *compare,\n \t\t      gfc_expr *new_val,  gfc_expr *stat)"}, {"sha": "87a530458f9927eeb7860dcd9c7aab587575db77", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1818,6 +1818,10 @@ show_code_node (int level, gfc_code *c)\n \n       break;\n \n+    case EXEC_FAIL_IMAGE:\n+      fputs (\"FAIL IMAGE \", dumpfile);\n+      break;\n+\n     case EXEC_SYNC_ALL:\n       fputs (\"SYNC ALL \", dumpfile);\n       if (c->expr2 != NULL)"}, {"sha": "293655078a4869c34f660089c1763917671e29c0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -263,7 +263,7 @@ enum gfc_statement\n   ST_OMP_TASKLOOP_SIMD, ST_OMP_END_TASKLOOP_SIMD, ST_OMP_ORDERED_DEPEND,\n   ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,\n-  ST_EVENT_WAIT,ST_NONE\n+  ST_EVENT_WAIT,ST_FAIL_IMAGE,ST_NONE\n };\n \n /* Types of interfaces that we can have.  Assignment interfaces are\n@@ -429,6 +429,7 @@ enum gfc_isym_id\n   GFC_ISYM_EXP,\n   GFC_ISYM_EXPONENT,\n   GFC_ISYM_EXTENDS_TYPE_OF,\n+  GFC_ISYM_FAILED_IMAGES,\n   GFC_ISYM_FDATE,\n   GFC_ISYM_FE_RUNTIME_ERROR,\n   GFC_ISYM_FGET,\n@@ -472,6 +473,7 @@ enum gfc_isym_id\n   GFC_ISYM_IEOR,\n   GFC_ISYM_IERRNO,\n   GFC_ISYM_IMAGE_INDEX,\n+  GFC_ISYM_IMAGE_STATUS,\n   GFC_ISYM_INDEX,\n   GFC_ISYM_INT,\n   GFC_ISYM_INT2,\n@@ -585,6 +587,7 @@ enum gfc_isym_id\n   GFC_ISYM_SRAND,\n   GFC_ISYM_SR_KIND,\n   GFC_ISYM_STAT,\n+  GFC_ISYM_STOPPED_IMAGES,\n   GFC_ISYM_STORAGE_SIZE,\n   GFC_ISYM_STRIDE,\n   GFC_ISYM_SUM,\n@@ -2457,7 +2460,7 @@ enum gfc_exec_op\n   EXEC_OPEN, EXEC_CLOSE, EXEC_WAIT,\n   EXEC_READ, EXEC_WRITE, EXEC_IOLENGTH, EXEC_TRANSFER, EXEC_DT_END,\n   EXEC_BACKSPACE, EXEC_ENDFILE, EXEC_INQUIRE, EXEC_REWIND, EXEC_FLUSH,\n-  EXEC_LOCK, EXEC_UNLOCK, EXEC_EVENT_POST, EXEC_EVENT_WAIT,\n+  EXEC_LOCK, EXEC_UNLOCK, EXEC_EVENT_POST, EXEC_EVENT_WAIT, EXEC_FAIL_IMAGE,\n   EXEC_OACC_KERNELS_LOOP, EXEC_OACC_PARALLEL_LOOP, EXEC_OACC_ROUTINE,\n   EXEC_OACC_PARALLEL, EXEC_OACC_KERNELS, EXEC_OACC_DATA, EXEC_OACC_HOST_DATA,\n   EXEC_OACC_LOOP, EXEC_OACC_UPDATE, EXEC_OACC_WAIT, EXEC_OACC_CACHE,"}, {"sha": "85afdda46ef05bb86bfa412f1b0986116f6f8c2c", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 117, "deletions": 1, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1125,7 +1125,7 @@ of @code{BIND(C) procedures.}\n @item GNU Fortran's implementation for variables with @code{ASYNCHRONOUS}\n attribute is compatible with TS 29113.\n \n-@item Assumed types (@code{TYPE(*)}.\n+@item Assumed types (@code{TYPE(*)}).\n \n @item Assumed-rank (@code{DIMENSION(..)}). However, the array descriptor\n of the TS is not yet supported.\n@@ -1147,6 +1147,10 @@ do not support polymorphic types or types with allocatable, pointer or\n polymorphic components.\n \n @item Events (@code{EVENT POST}, @code{EVENT WAIT}, @code{EVENT_QUERY})\n+\n+@item Failed images (@code{FAIL IMAGE}, @code{IMAGE_STATUS},\n+@code{FAILED_IMAGES}, @code{STOPPED_IMAGES})\n+\n @end itemize\n \n \n@@ -3873,6 +3877,7 @@ of such a type\n * caf_register_t::\n * caf_deregister_t::\n * caf_reference_t::\n+* caf_team_t::\n @end menu\n \n @node caf_token_t\n@@ -4035,6 +4040,11 @@ type conversion still needs to take place the type is transported here.\n At the moment @code{CAF_ARR_REF_VECTOR} is not implemented in the front end for\n descriptor-less arrays.  The library caf_single has untested support for it.\n \n+@node caf_team_t\n+@subsection @code{caf_team_t}\n+\n+Opaque pointer to represent a team-handle.  This type is a stand-in for the\n+future implementation of teams.  It is about to change without further notice.\n \n @node Function ABI Documentation\n @section Function ABI Documentation\n@@ -4044,6 +4054,9 @@ descriptor-less arrays.  The library caf_single has untested support for it.\n * _gfortran_caf_finish:: Finalization function\n * _gfortran_caf_this_image:: Querying the image number\n * _gfortran_caf_num_images:: Querying the maximal number of images\n+* _gfortran_caf_image_status :: Query the status of an image\n+* _gfortran_caf_failed_images :: Get an array of the indexes of the failed images\n+* _gfortran_caf_stopped_images :: Get an array of the indexes of the stopped images\n * _gfortran_caf_register:: Registering coarrays\n * _gfortran_caf_deregister:: Deregistering coarrays\n * _gfortran_caf_is_present:: Query whether an allocatable or pointer component in a derived type coarray is allocated\n@@ -4063,6 +4076,7 @@ descriptor-less arrays.  The library caf_single has untested support for it.\n * _gfortran_caf_sync_memory:: Wait for completion of segment-memory operations\n * _gfortran_caf_error_stop:: Error termination with exit code\n * _gfortran_caf_error_stop_str:: Error termination with string\n+* _gfortran_caf_fail_image :: Mark the image failed and end its execution\n * _gfortran_caf_atomic_define:: Atomic variable assignment\n * _gfortran_caf_atomic_ref:: Atomic variable reference\n * _gfortran_caf_atomic_cas:: Atomic compare and swap\n@@ -4182,6 +4196,90 @@ then the compiler passes @code{distance=0} and @code{failed=-1} to the function.\n @end table\n \n \n+@node _gfortran_caf_image_status\n+@subsection @code{_gfortran_caf_image_status} --- Query the status of an image\n+@cindex Coarray, _gfortran_caf_image_status\n+\n+@table @asis\n+@item @emph{Description}:\n+Get the status of the image given by the id @var{image} of the team given by\n+@var{team}.  Valid results are zero, for image is ok, @code{STAT_STOPPED_IMAGE}\n+from the ISO_FORTRAN_ENV module to indicate that the image has been stopped and\n+@code{STAT_FAILED_IMAGE} also from ISO_FORTRAN_ENV to indicate that the image\n+has executed a @code{FAIL IMAGE} statement.\n+\n+@item @emph{Syntax}:\n+@code{int _gfortran_caf_image_status (int image, caf_team_t * team)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{image} @tab the positive scalar id of the image in the current TEAM.\n+@item @var{team} @tab optional; team on the which the inquiry is to be\n+performed.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function follows TS18508.  Because team-functionality is not yet\n+implemented a null-pointer is passed for the @var{team} argument at the moment.\n+@end table\n+\n+\n+@node _gfortran_caf_failed_images\n+@subsection @code{_gfortran_caf_failed_images} --- Get an array of the indexes of the failed images\n+@cindex Coarray, _gfortran_caf_failed_images\n+\n+@table @asis\n+@item @emph{Description}:\n+Get an array of image indexes in the current @var{team} that have failed.  The\n+array is sorted ascendingly.  When @var{team} is not provided the current team\n+is to be used.  When @var{kind} is provided then the resulting array is of that\n+integer kind else it is of default integer kind.  The returns an unallocated\n+size zero array when no images have failed.\n+\n+@item @emph{Syntax}:\n+@code{int _gfortran_caf_failed_images (caf_team_t * team, int * kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{team} @tab optional; team on the which the inquiry is to be\n+performed.\n+@item @var{image} @tab optional; the kind of the resulting integer array.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function follows TS18508.  Because team-functionality is not yet\n+implemented a null-pointer is passed for the @var{team} argument at the moment.\n+@end table\n+\n+\n+@node _gfortran_caf_stopped_images\n+@subsection @code{_gfortran_caf_stopped_images} --- Get an array of the indexes of the stopped images\n+@cindex Coarray, _gfortran_caf_stopped_images\n+\n+@table @asis\n+@item @emph{Description}:\n+Get an array of image indexes in the current @var{team} that have stopped.  The\n+array is sorted ascendingly.  When @var{team} is not provided the current team\n+is to be used.  When @var{kind} is provided then the resulting array is of that\n+integer kind else it is of default integer kind.  The returns an unallocated\n+size zero array when no images have failed.\n+\n+@item @emph{Syntax}:\n+@code{int _gfortran_caf_stopped_images (caf_team_t * team, int * kind)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{team} @tab optional; team on the which the inquiry is to be\n+performed.\n+@item @var{image} @tab optional; the kind of the resulting integer array.\n+@end multitable\n+\n+@item @emph{NOTES}\n+This function follows TS18508.  Because team-functionality is not yet\n+implemented a null-pointer is passed for the @var{team} argument at the moment.\n+@end table\n+\n+\n @node _gfortran_caf_register\n @subsection @code{_gfortran_caf_register} --- Registering coarrays\n @cindex Coarray, _gfortran_caf_register\n@@ -4993,6 +5091,24 @@ function should terminate the program with a nonzero-exit code.\n \n \n \n+@node _gfortran_caf_fail_image\n+@subsection @code{_gfortran_caf_fail_image} --- Mark the image failed and end its execution\n+@cindex Coarray, _gfortran_caf_fail_image\n+\n+@table @asis\n+@item @emph{Description}:\n+Invoked for an @code{FAIL IMAGE} statement.  The function should terminate the\n+current image.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_fail_image ()}\n+\n+@item @emph{NOTES}\n+This function follows TS18508.\n+@end table\n+\n+\n+\n @node _gfortran_caf_atomic_define\n @subsection @code{_gfortran_caf_atomic_define} --- Atomic variable assignment\n @cindex Coarray, _gfortran_caf_atomic_define"}, {"sha": "2f60fe8c87721344ab2d4e3e03fdd8f0318bd5ad", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1840,6 +1840,13 @@ add_functions (void)\n \t     a, BT_UNKNOWN, 0, REQUIRED,\n \t     mo, BT_UNKNOWN, 0, REQUIRED);\n \n+  add_sym_2 (\"failed_images\", GFC_ISYM_FAILED_IMAGES, CLASS_TRANSFORMATIONAL,\n+\t     ACTUAL_NO, BT_INTEGER, dd, GFC_STD_F2008_TS,\n+\t     gfc_check_failed_or_stopped_images,\n+\t     gfc_simplify_failed_or_stopped_images,\n+\t     gfc_resolve_failed_images, \"team\", BT_VOID, di, OPTIONAL,\n+\t     \"kind\", BT_INTEGER, di, OPTIONAL);\n+\n   add_sym_0 (\"fdate\",  GFC_ISYM_FDATE, CLASS_IMPURE, ACTUAL_NO, BT_CHARACTER,\n \t     dc, GFC_STD_GNU, NULL, NULL, gfc_resolve_fdate);\n \n@@ -2081,6 +2088,11 @@ add_functions (void)\n \t     gfc_check_image_index, gfc_simplify_image_index, gfc_resolve_image_index,\n \t     ca, BT_REAL, dr, REQUIRED, sub, BT_INTEGER, ii, REQUIRED);\n \n+  add_sym_2 (\"image_status\", GFC_ISYM_IMAGE_STATUS, CLASS_ELEMENTAL, ACTUAL_NO,\n+\t     BT_INTEGER, di, GFC_STD_F2008_TS, gfc_check_image_status,\n+\t     gfc_simplify_image_status, gfc_resolve_image_status, \"image\",\n+\t     BT_INTEGER, di, REQUIRED, \"team\", BT_VOID, di, OPTIONAL);\n+\n   /* The resolution function for INDEX is called gfc_resolve_index_func\n      because the name gfc_resolve_index is already used in resolve.c.  */\n   add_sym_4 (\"index\", GFC_ISYM_INDEX, CLASS_ELEMENTAL, ACTUAL_YES,\n@@ -2989,6 +3001,13 @@ add_functions (void)\n \n   make_generic (\"stat\", GFC_ISYM_STAT, GFC_STD_GNU);\n \n+  add_sym_2 (\"stopped_images\", GFC_ISYM_STOPPED_IMAGES, CLASS_TRANSFORMATIONAL,\n+\t     ACTUAL_NO, BT_INTEGER, dd, GFC_STD_F2008_TS,\n+\t     gfc_check_failed_or_stopped_images,\n+\t     gfc_simplify_failed_or_stopped_images,\n+\t     gfc_resolve_stopped_images, \"team\", BT_VOID, di, OPTIONAL,\n+\t     \"kind\", BT_INTEGER, di, OPTIONAL);\n+\n   add_sym_2 (\"storage_size\", GFC_ISYM_STORAGE_SIZE, CLASS_INQUIRY, ACTUAL_NO,\n \t     BT_INTEGER, di, GFC_STD_F2008,\n \t     gfc_check_storage_size, gfc_simplify_storage_size,"}, {"sha": "e8280f6f2ac3826548217ef7aaf25a429db05a4e", "filename": "gcc/fortran/intrinsic.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -71,6 +71,7 @@ bool gfc_check_dshift (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_eoshift (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_dtime_etime (gfc_expr *);\n bool gfc_check_event_query (gfc_expr *, gfc_expr *, gfc_expr *);\n+bool gfc_check_failed_or_stopped_images (gfc_expr *, gfc_expr *);\n bool gfc_check_fgetputc (gfc_expr *, gfc_expr *);\n bool gfc_check_fgetput (gfc_expr *);\n bool gfc_check_float (gfc_expr *);\n@@ -92,6 +93,7 @@ bool gfc_check_ibits (gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_ichar_iachar (gfc_expr *, gfc_expr *);\n bool gfc_check_idnint (gfc_expr *);\n bool gfc_check_ieor (gfc_expr *, gfc_expr *);\n+bool gfc_check_image_status (gfc_expr *, gfc_expr *);\n bool gfc_check_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n bool gfc_check_int (gfc_expr *, gfc_expr *);\n bool gfc_check_intconv (gfc_expr *);\n@@ -292,6 +294,7 @@ gfc_expr *gfc_simplify_erfc_scaled (gfc_expr *);\n gfc_expr *gfc_simplify_exp (gfc_expr *);\n gfc_expr *gfc_simplify_exponent (gfc_expr *);\n gfc_expr *gfc_simplify_extends_type_of (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_failed_or_stopped_images (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_float (gfc_expr *);\n gfc_expr *gfc_simplify_floor (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_fraction (gfc_expr *);\n@@ -308,6 +311,7 @@ gfc_expr *gfc_simplify_ibset (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ichar (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_ieor (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_image_index (gfc_expr *, gfc_expr *);\n+gfc_expr *gfc_simplify_image_status (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_index (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int (gfc_expr *, gfc_expr *);\n gfc_expr *gfc_simplify_int2 (gfc_expr *);\n@@ -473,6 +477,7 @@ void gfc_resolve_event_query (gfc_code *);\n void gfc_resolve_exp (gfc_expr *, gfc_expr *);\n void gfc_resolve_exponent (gfc_expr *, gfc_expr *);\n void gfc_resolve_extends_type_of (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_failed_images (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fdate (gfc_expr *);\n void gfc_resolve_floor (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_fnum (gfc_expr *, gfc_expr *);\n@@ -496,6 +501,7 @@ void gfc_resolve_ibclr (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibits (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_ibset (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_image_index (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_image_status (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_index_func (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *,\n \t\t\t     gfc_expr *);\n void gfc_resolve_ierrno (gfc_expr *);\n@@ -571,12 +577,13 @@ void gfc_resolve_signal (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sin (gfc_expr *, gfc_expr *);\n void gfc_resolve_sinh (gfc_expr *, gfc_expr *);\n void gfc_resolve_size (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n-void gfc_resolve_stride (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_spacing (gfc_expr *, gfc_expr *);\n void gfc_resolve_spread (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_sqrt (gfc_expr *, gfc_expr *);\n void gfc_resolve_stat (gfc_expr *, gfc_expr *, gfc_expr *);\n+void gfc_resolve_stopped_images (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_storage_size (gfc_expr *f, gfc_expr *a, gfc_expr *kind);\n+void gfc_resolve_stride (gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_srand (gfc_code *);\n void gfc_resolve_sum (gfc_expr *, gfc_expr *, gfc_expr *, gfc_expr *);\n void gfc_resolve_symlnk (gfc_expr *, gfc_expr *, gfc_expr *);"}, {"sha": "b784ac339e9642207b5d281e9c97d3c8437815d0", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -2830,6 +2830,38 @@ gfc_resolve_atan2d (gfc_expr *f, gfc_expr *x, gfc_expr *y ATTRIBUTE_UNUSED)\n }\n \n \n+/* Resolve failed_images (team, kind).  */\n+\n+void\n+gfc_resolve_failed_images (gfc_expr *f, gfc_expr *team ATTRIBUTE_UNUSED,\n+\t\t\t   gfc_expr *kind)\n+{\n+  static char failed_images[] = \"_gfortran_caf_failed_images\";\n+  f->rank = 1;\n+  f->ts.type = BT_INTEGER;\n+  if (kind == NULL)\n+    f->ts.kind = gfc_default_integer_kind;\n+  else\n+    gfc_extract_int (kind, &f->ts.kind);\n+  f->value.function.name = failed_images;\n+}\n+\n+\n+/* Resolve image_status (image, team).  */\n+\n+void\n+gfc_resolve_image_status (gfc_expr *f, gfc_expr *image ATTRIBUTE_UNUSED,\n+\t\t\t  gfc_expr *team ATTRIBUTE_UNUSED)\n+{\n+  static char image_status[] = \"_gfortran_caf_image_status\";\n+  f->ts.type = BT_INTEGER;\n+  f->ts.kind = gfc_default_integer_kind;\n+  f->value.function.name = image_status;\n+}\n+\n+\n+/* Resolve image_index (...).  */\n+\n void\n gfc_resolve_image_index (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,\n \t\t\t gfc_expr *sub ATTRIBUTE_UNUSED)\n@@ -2841,6 +2873,23 @@ gfc_resolve_image_index (gfc_expr *f, gfc_expr *array ATTRIBUTE_UNUSED,\n }\n \n \n+/* Resolve stopped_images (team, kind).  */\n+\n+void\n+gfc_resolve_stopped_images (gfc_expr *f, gfc_expr *team ATTRIBUTE_UNUSED,\n+\t\t\t    gfc_expr *kind)\n+{\n+  static char stopped_images[] = \"_gfortran_caf_stopped_images\";\n+  f->rank = 1;\n+  f->ts.type = BT_INTEGER;\n+  if (kind == NULL)\n+    f->ts.kind = gfc_default_integer_kind;\n+  else\n+    gfc_extract_int (kind, &f->ts.kind);\n+  f->value.function.name = stopped_images;\n+}\n+\n+\n void\n gfc_resolve_this_image (gfc_expr *f, gfc_expr *array, gfc_expr *dim,\n \t\t\tgfc_expr *distance ATTRIBUTE_UNUSED)"}, {"sha": "c5ff99247618e72d351d4636f4ec5ed1a043daf1", "filename": "gcc/fortran/libgfortran.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flibgfortran.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -117,14 +117,14 @@ typedef enum\n }\n libgfortran_error_codes;\n \n-/* Must kept in sync with libgfortrancaf.h.  */\n+/* Must kept in sync with libgfortran/caf/libcaf.h.  */\n typedef enum\n {\n   GFC_STAT_UNLOCKED = 0,\n   GFC_STAT_LOCKED,\n   GFC_STAT_LOCKED_OTHER_IMAGE,\n   GFC_STAT_STOPPED_IMAGE = 6000, /* See LIBERROR_INQUIRE_INTERNAL_UNIT above. */\n-  GFC_STAT_FAILED_IMAGE\n+  GFC_STAT_FAILED_IMAGE  = 6001\n }\n libgfortran_stat_codes;\n "}, {"sha": "a47585c5516f030251e6a8d25f59ac3eb8dec009", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1601,6 +1601,7 @@ gfc_match_if (gfc_statement *if_type)\n   match (\"event post\", gfc_match_event_post, ST_EVENT_POST)\n   match (\"event wait\", gfc_match_event_wait, ST_EVENT_WAIT)\n   match (\"exit\", gfc_match_exit, ST_EXIT)\n+  match (\"fail image\", gfc_match_fail_image, ST_FAIL_IMAGE)\n   match (\"flush\", gfc_match_flush, ST_FLUSH)\n   match (\"forall\", match_simple_forall, ST_FORALL)\n   match (\"go to\", gfc_match_goto, ST_GOTO)\n@@ -3265,6 +3266,28 @@ gfc_match_event_wait (void)\n }\n \n \n+/* Match a FAIL IMAGE statement.  */\n+\n+match\n+gfc_match_fail_image (void)\n+{\n+  if (!gfc_notify_std (GFC_STD_F2008_TS, \"FAIL IMAGE statement at %C\"))\n+    return MATCH_ERROR;\n+\n+  if (gfc_match_char ('(') == MATCH_YES)\n+    goto syntax;\n+\n+  new_st.op = EXEC_FAIL_IMAGE;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_FAIL_IMAGE);\n+\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match LOCK/UNLOCK statement. Syntax:\n      LOCK ( lock-variable [ , lock-stat-list ] )\n      UNLOCK ( lock-variable [ , sync-stat-list ] )"}, {"sha": "64f2038f032fa5b2b5498f725da0a76070fb4dde", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -73,6 +73,7 @@ match gfc_match_elseif (void);\n match gfc_match_event_post (void);\n match gfc_match_event_wait (void);\n match gfc_match_critical (void);\n+match gfc_match_fail_image (void);\n match gfc_match_block (void);\n match gfc_match_associate (void);\n match gfc_match_do (void);"}, {"sha": "28fa218b2fc17739010ea06286a38654024bba3f", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -488,6 +488,7 @@ decode_statement (void)\n       break;\n \n     case 'f':\n+      match (\"fail image\", gfc_match_fail_image, ST_FAIL_IMAGE);\n       match (\"final\", gfc_match_final_decl, ST_FINAL);\n       match (\"flush\", gfc_match_flush, ST_FLUSH);\n       match (\"format\", gfc_match_format, ST_FORMAT);\n@@ -1499,7 +1500,7 @@ next_statement (void)\n   case ST_OMP_TARGET_EXIT_DATA: case ST_OMP_ORDERED_DEPEND: \\\n   case ST_ERROR_STOP: case ST_SYNC_ALL: \\\n   case ST_SYNC_IMAGES: case ST_SYNC_MEMORY: case ST_LOCK: case ST_UNLOCK: \\\n-  case ST_EVENT_POST: case ST_EVENT_WAIT: \\\n+  case ST_EVENT_POST: case ST_EVENT_WAIT: case ST_FAIL_IMAGE: \\\n   case ST_OACC_UPDATE: case ST_OACC_WAIT: case ST_OACC_CACHE: \\\n   case ST_OACC_ENTER_DATA: case ST_OACC_EXIT_DATA\n \n@@ -1827,6 +1828,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_EVENT_WAIT:\n       p = \"EVENT WAIT\";\n       break;\n+    case ST_FAIL_IMAGE:\n+      p = \"FAIL IMAGE\";\n+      break;\n     case ST_END_ASSOCIATE:\n       p = \"END ASSOCIATE\";\n       break;"}, {"sha": "1fbc9f6ef93127532b7471158ab5be855c44a0d8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -10883,6 +10883,9 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  resolve_lock_unlock_event (code);\n \t  break;\n \n+\tcase EXEC_FAIL_IMAGE:\n+\t  break;\n+\n \tcase EXEC_ENTRY:\n \t  /* Keep track of which entry we are up to.  */\n \t  current_entry_id = code->ext.entry->id;"}, {"sha": "169aef1d8923867441ff1f493887ddbd9241fb99", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -2465,6 +2465,37 @@ gfc_simplify_exponent (gfc_expr *x)\n }\n \n \n+gfc_expr *\n+gfc_simplify_failed_or_stopped_images (gfc_expr *team ATTRIBUTE_UNUSED,\n+\t\t\t\t       gfc_expr *kind)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_current_locus = *gfc_current_intrinsic_where;\n+      gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n+      return &gfc_bad_expr;\n+    }\n+\n+  if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+    {\n+      gfc_expr *result;\n+      int actual_kind;\n+      if (kind)\n+\tgfc_extract_int (kind, &actual_kind);\n+      else\n+\tactual_kind = gfc_default_integer_kind;\n+\n+      result = gfc_get_array_expr (BT_INTEGER, actual_kind, &gfc_current_locus);\n+      result->rank = 1;\n+      return result;\n+    }\n+\n+  /* For fcoarray = lib no simplification is possible, because it is not known\n+     what images failed or are stopped at compile time.  */\n+  return NULL;\n+}\n+\n+\n gfc_expr *\n gfc_simplify_float (gfc_expr *a)\n {\n@@ -6763,6 +6794,36 @@ gfc_simplify_image_index (gfc_expr *coarray, gfc_expr *sub)\n   return result;\n }\n \n+gfc_expr *\n+gfc_simplify_image_status (gfc_expr *image, gfc_expr *team ATTRIBUTE_UNUSED)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_current_locus = *gfc_current_intrinsic_where;\n+      gfc_fatal_error (\"Coarrays disabled at %C, use %<-fcoarray=%> to enable\");\n+      return &gfc_bad_expr;\n+    }\n+\n+  /* Simplification is possible for fcoarray = single only.  For all other modes\n+     the result depends on runtime conditions.  */\n+  if (flag_coarray != GFC_FCOARRAY_SINGLE)\n+    return NULL;\n+\n+  if (gfc_is_constant_expr (image))\n+    {\n+      gfc_expr *result;\n+      result = gfc_get_constant_expr (BT_INTEGER, gfc_default_integer_kind,\n+\t\t\t\t      &image->where);\n+      if (mpz_get_si (image->value.integer) == 1)\n+\tmpz_set_si (result->value.integer, 0);\n+      else\n+\tmpz_set_si (result->value.integer, GFC_STAT_STOPPED_IMAGE);\n+      return result;\n+    }\n+  else\n+    return NULL;\n+}\n+\n \n gfc_expr *\n gfc_simplify_this_image (gfc_expr *coarray, gfc_expr *dim,"}, {"sha": "bffe50df7b819641a8216bc57816393d190f5089", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -120,6 +120,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_UNLOCK:\n     case EXEC_EVENT_POST:\n     case EXEC_EVENT_WAIT:\n+    case EXEC_FAIL_IMAGE:\n       break;\n \n     case EXEC_BLOCK:"}, {"sha": "449ca9a84dadf55892b00cf44502773fb105ae4a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -153,6 +153,10 @@ tree gfor_fndecl_caf_unlock;\n tree gfor_fndecl_caf_event_post;\n tree gfor_fndecl_caf_event_wait;\n tree gfor_fndecl_caf_event_query;\n+tree gfor_fndecl_caf_fail_image;\n+tree gfor_fndecl_caf_failed_images;\n+tree gfor_fndecl_caf_image_status;\n+tree gfor_fndecl_caf_stopped_images;\n tree gfor_fndecl_co_broadcast;\n tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n@@ -3732,6 +3736,28 @@ gfc_build_builtin_function_decls (void)\n \tvoid_type_node, 5, pvoid_type_node, size_type_node, integer_type_node,\n \tpint_type, pint_type);\n \n+      gfor_fndecl_caf_fail_image = gfc_build_library_function_decl (\n+\tget_identifier (PREFIX(\"caf_fail_image\")), void_type_node, 0);\n+      /* CAF's FAIL doesn't return.  */\n+      TREE_THIS_VOLATILE (gfor_fndecl_caf_fail_image) = 1;\n+\n+      gfor_fndecl_caf_failed_images\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_failed_images\")), \"WRR\",\n+\t    void_type_node, 3, pvoid_type_node, ppvoid_type_node,\n+\t    integer_type_node);\n+\n+      gfor_fndecl_caf_image_status\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_image_status\")), \"RR\",\n+\t    integer_type_node, 2, integer_type_node, ppvoid_type_node);\n+\n+      gfor_fndecl_caf_stopped_images\n+\t= gfc_build_library_function_decl_with_spec (\n+\t    get_identifier (PREFIX(\"caf_stopped_images\")), \"WRR\",\n+\t    void_type_node, 3, pvoid_type_node, ppvoid_type_node,\n+\t    integer_type_node);\n+\n       gfor_fndecl_co_broadcast = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_co_broadcast\")), \"W.WW\",\n \tvoid_type_node, 5, pvoid_type_node, integer_type_node,"}, {"sha": "7bced25df4918a2a562ce7b418043e3ced9e8a67", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -6228,13 +6228,15 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       gfc_add_block_to_block (&se->pre, &post);\n \n       /* Transformational functions of derived types with allocatable\n-         components must have the result allocatable components copied.  */\n+\t components must have the result allocatable components copied when the\n+\t argument is actually given.  */\n       arg = expr->value.function.actual;\n       if (result && arg && expr->rank\n-\t    && expr->value.function.isym\n-\t    && expr->value.function.isym->transformational\n-\t    && arg->expr->ts.type == BT_DERIVED\n-\t    && arg->expr->ts.u.derived->attr.alloc_comp)\n+\t  && expr->value.function.isym\n+\t  && expr->value.function.isym->transformational\n+\t  && arg->expr\n+\t  && arg->expr->ts.type == BT_DERIVED\n+\t  && arg->expr->ts.u.derived->attr.alloc_comp)\n \t{\n \t  tree tmp2;\n \t  /* Copy the allocatable components.  We have to use a"}, {"sha": "b7524bceb6b0049742f0daf12d1472c107530a5c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -2388,6 +2388,42 @@ trans_this_image (gfc_se * se, gfc_expr *expr)\n }\n \n \n+/* Convert a call to image_status.  */\n+\n+static void\n+conv_intrinsic_image_status (gfc_se *se, gfc_expr *expr)\n+{\n+  unsigned int num_args;\n+  tree *args, tmp;\n+\n+  num_args = gfc_intrinsic_argument_list_length (expr);\n+  args = XALLOCAVEC (tree, num_args);\n+  gfc_conv_intrinsic_function_args (se, expr, args, num_args);\n+  /* In args[0] the number of the image the status is desired for has to be\n+     given.  */\n+\n+  if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+    {\n+      tree arg;\n+      arg = gfc_evaluate_now (args[0], &se->pre);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node,\n+\t\t\t     fold_convert (integer_type_node, arg),\n+\t\t\t     integer_one_node);\n+      tmp = fold_build3_loc (input_location, COND_EXPR, integer_type_node,\n+\t\t\t     tmp, integer_zero_node,\n+\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t    GFC_STAT_STOPPED_IMAGE));\n+    }\n+  else if (flag_coarray == GFC_FCOARRAY_LIB)\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_image_status, 2,\n+\t\t\t       args[0], build_int_cst (integer_type_node, -1));\n+  else\n+    gcc_unreachable ();\n+\n+  se->expr = tmp;\n+}\n+\n+\n static void\n trans_image_index (gfc_se * se, gfc_expr *expr)\n {\n@@ -9108,6 +9144,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       trans_image_index (se, expr);\n       break;\n \n+    case GFC_ISYM_IMAGE_STATUS:\n+      conv_intrinsic_image_status (se, expr);\n+      break;\n+\n     case GFC_ISYM_NUM_IMAGES:\n       trans_num_images (se, expr);\n       break;\n@@ -9458,10 +9498,12 @@ gfc_is_intrinsic_libcall (gfc_expr * expr)\n       /* Ignore absent optional parameters.  */\n       return 1;\n \n-    case GFC_ISYM_RESHAPE:\n     case GFC_ISYM_CSHIFT:\n     case GFC_ISYM_EOSHIFT:\n+    case GFC_ISYM_FAILED_IMAGES:\n+    case GFC_ISYM_STOPPED_IMAGES:\n     case GFC_ISYM_PACK:\n+    case GFC_ISYM_RESHAPE:\n     case GFC_ISYM_UNPACK:\n       /* Pass absent optional parameters.  */\n       return 2;"}, {"sha": "98687c80637dee21a0735af20e6529709dff3826", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -674,6 +674,24 @@ gfc_trans_stop (gfc_code *code, bool error_stop)\n   return gfc_finish_block (&se.pre);\n }\n \n+/* Translate the FAIL IMAGE statement.  */\n+\n+tree\n+gfc_trans_fail_image (gfc_code *code ATTRIBUTE_UNUSED)\n+{\n+  if (flag_coarray == GFC_FCOARRAY_LIB)\n+    return build_call_expr_loc (input_location,\n+\t\t\t\tgfor_fndecl_caf_fail_image, 1,\n+\t\t\t\tbuild_int_cst (pchar_type_node, 0));\n+  else\n+    {\n+      const char *name = gfc_get_string (PREFIX (\"exit_i%d\"), 4);\n+      gfc_symbol *exsym = gfc_get_intrinsic_sub_symbol (name);\n+      tree tmp = gfc_get_symbol_decl (exsym);\n+      return build_call_expr_loc (input_location, tmp, 1, integer_zero_node);\n+    }\n+}\n+\n \n tree\n gfc_trans_lock_unlock (gfc_code *code, gfc_exec_op op)"}, {"sha": "0a39e26c21889f555ee01015152c781b02781bfb", "filename": "gcc/fortran/trans-stmt.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -56,6 +56,7 @@ tree gfc_trans_select_type (gfc_code *);\n tree gfc_trans_sync (gfc_code *, gfc_exec_op);\n tree gfc_trans_lock_unlock (gfc_code *, gfc_exec_op);\n tree gfc_trans_event_post_wait (gfc_code *, gfc_exec_op);\n+tree gfc_trans_fail_image (gfc_code *);\n tree gfc_trans_forall (gfc_code *);\n tree gfc_trans_where (gfc_code *);\n tree gfc_trans_allocate (gfc_code *);"}, {"sha": "e25ccaa258a6caf58ba1bfa93d87afa2e259cf48", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1953,6 +1953,10 @@ trans_code (gfc_code * code, tree cond)\n \t  res = gfc_trans_event_post_wait (code, code->op);\n \t  break;\n \n+\tcase EXEC_FAIL_IMAGE:\n+\t  res = gfc_trans_fail_image (code);\n+\t  break;\n+\n \tcase EXEC_FORALL:\n \t  res = gfc_trans_forall (code);\n \t  break;"}, {"sha": "d02f3470eebc00e95e1e51e1094f43a2e9ad2e72", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -833,6 +833,10 @@ extern GTY(()) tree gfor_fndecl_caf_unlock;\n extern GTY(()) tree gfor_fndecl_caf_event_post;\n extern GTY(()) tree gfor_fndecl_caf_event_wait;\n extern GTY(()) tree gfor_fndecl_caf_event_query;\n+extern GTY(()) tree gfor_fndecl_caf_fail_image;\n+extern GTY(()) tree gfor_fndecl_caf_failed_images;\n+extern GTY(()) tree gfor_fndecl_caf_image_status;\n+extern GTY(()) tree gfor_fndecl_caf_stopped_images;\n extern GTY(()) tree gfor_fndecl_co_broadcast;\n extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;"}, {"sha": "fcaacff3cc9ebcd51822f972bca1134a6e75e2e3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1,3 +1,19 @@\n+2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n+            Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\n+\t* gfortran.dg/coarray/fail_image_1.f08: New test.\n+\t* gfortran.dg/coarray/fail_image_2.f08: New test.\n+\t* gfortran.dg/coarray/failed_images_1.f08: New test.\n+\t* gfortran.dg/coarray/failed_images_2.f08: New test.\n+\t* gfortran.dg/coarray/image_status_1.f08: New test.\n+\t* gfortran.dg/coarray/image_status_2.f08: New test.\n+\t* gfortran.dg/coarray/stopped_images_1.f08: New test.\n+\t* gfortran.dg/coarray/stopped_images_2.f08: New test.\n+\t* gfortran.dg/coarray_fail_st.f90: New test.\n+\t* gfortran.dg/coarray_failed_images_1.f08: New test.\n+\t* gfortran.dg/coarray_image_status_1.f08: New test.\n+\t* gfortran.dg/coarray_stopped_images_1.f08: New test.\n+\n 2017-03-03  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/79758"}, {"sha": "b1e1bbb221dd91fddffa5d0ba42c31685531e315", "filename": "gcc/testsuite/gfortran.dg/coarray/fail_image_1.f08", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+\n+program fail_image_statement_1\n+  implicit none\n+\n+  fail image ! OK\n+  fail image (1)  ! { dg-error \"Syntax error in FAIL IMAGE statement at \\\\(1\\\\)\" }\n+\n+end program fail_image_statement_1\n+"}, {"sha": "e482a60b8f296c9bea21c5705482c2af9bafe149", "filename": "gcc/testsuite/gfortran.dg/coarray/fail_image_2.f08", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffail_image_2.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do run }\n+\n+program fail_image_statement_2\n+  implicit none\n+\n+  fail image ! OK\n+  error stop \"This statement should not be reached.\"\n+\n+end program fail_image_statement_2\n+"}, {"sha": "4898dd8a7a2f9e5d482e9d53b57ff1ed437a4c65", "filename": "gcc/testsuite/gfortran.dg/coarray/failed_images_1.f08", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+program test_failed_images_1\n+  implicit none\n+\n+  integer, allocatable :: fi(:)\n+  real :: r\n+  integer :: i\n+\n+  fi = failed_images()         ! OK\n+  fi = failed_images(TEAM=1)   ! { dg-error \"'team' argument of 'failed_images' intrinsic at \\\\(1\\\\) not yet supported\" }\n+  fi = failed_images(KIND=1)   ! OK\n+  fi = failed_images(KIND=4)   ! OK\n+  fi = failed_images(KIND=0)   ! { dg-error \"'kind' argument of 'failed_images' intrinsic at \\\\\\(1\\\\\\) must be positive\" }\n+  fi = failed_images(KIND=r)   ! { dg-error \"'kind' argument of 'failed_images' intrinsic at \\\\\\(1\\\\\\) must be INTEGER\" }\n+  fi = failed_images(KIND=i)   ! { dg-error \"Constant expression required at \\\\\\(1\\\\\\)\" }\n+  fi = failed_images(KIND=42)  ! { dg-error \"'kind' argument of 'failed_images' intrinsic at \\\\\\(1\\\\\\) shall specify a valid integer kind\" }\n+\n+end program test_failed_images_1\n+"}, {"sha": "ca5fe4020d5e1febb76f7e7150bd30c297bb9c91", "filename": "gcc/testsuite/gfortran.dg/coarray/failed_images_2.f08", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Ffailed_images_2.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+\n+program test_failed_images_2\n+  implicit none\n+\n+  integer, allocatable :: fi(:)\n+  integer(kind=1), allocatable :: sfi(:)\n+\n+  fi = failed_images()\n+  if (size(fi) > 0) error stop \"failed_images result shall be empty array\"\n+  sfi = failed_images(KIND=1)\n+  if (size(sfi) > 0) error stop \"failed_images result shall be empty array\"\n+  sfi = failed_images(KIND=8)\n+  if (size(sfi) > 0) error stop \"failed_images result shall be empty array\"\n+  \n+end program test_failed_images_2\n+"}, {"sha": "098a2bb958e17a9691c14e5b2dabd3476ea9b5d5", "filename": "gcc/testsuite/gfortran.dg/coarray/image_status_1.f08", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do compile }\n+\n+program test_image_status_1\n+  implicit none\n+\n+  integer :: isv\n+  integer(kind=1) :: k1\n+  integer(kind=2) :: k2\n+  integer(kind=4) :: k4\n+  integer(kind=8) :: k8\n+\n+  isv = image_status(1) ! Ok\n+  isv = image_status(-1)      ! { dg-error \"'image' argument of 'image_status' intrinsic at \\\\(1\\\\) must be positive\" }\n+  isv = image_status(0)       ! { dg-error \"'image' argument of 'image_status' intrinsic at \\\\(1\\\\) must be positive\" }\n+  isv = image_status(.true.)  ! { dg-error \"'image' argument of 'image_status' intrinsic at \\\\(1\\\\) must be INTEGER\" }\n+  isv = image_status([1,2,3]) ! { dg-error \"'image' argument of 'image_status' intrinsic at \\\\(1\\\\) must be a scalar\" }\n+  isv = image_status(k1) ! Ok\n+  isv = image_status(k2) ! Ok\n+  isv = image_status(k4) ! Ok\n+  isv = image_status(k8) ! Ok\n+  isv = image_status(1, team=1) ! { dg-error \"'team' argument of 'image_status' intrinsic at \\\\(1\\\\) not yet supported\" }\n+  isv = image_status()          ! { dg-error \"Missing actual argument 'image' in call to 'image_status' at \\\\(1\\\\)\" }\n+  isv = image_status(team=1)    ! { dg-error \"Missing actual argument 'image' in call to 'image_status' at \\\\(1\\\\)\" }\n+\n+end program test_image_status_1\n+"}, {"sha": "fb49289cb782f0dd7317e2ddf1621f6bd16e1e29", "filename": "gcc/testsuite/gfortran.dg/coarray/image_status_2.f08", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fimage_status_2.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do run }\n+\n+program test_image_status_2\n+  use iso_fortran_env , only : STAT_STOPPED_IMAGE\n+  implicit none\n+\n+  if (image_status(1) /= 0) error stop \"Image 1 should report OK.\"\n+  if (image_status(2) /= STAT_STOPPED_IMAGE) error stop \"Image 2 should be stopped.\"\n+  if (image_status(3) /= STAT_STOPPED_IMAGE) error stop \"Image 3 should be stopped.\"\n+\n+end program test_image_status_2\n+"}, {"sha": "403de585b9af897460cabca7f9b3751715753b20", "filename": "gcc/testsuite/gfortran.dg/coarray/stopped_images_1.f08", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do compile }\n+\n+program test_stopped_images_1\n+  implicit none\n+\n+  integer, allocatable :: gi(:)\n+  real :: r\n+  integer :: i\n+\n+  gi = stopped_images()         ! OK\n+  gi = stopped_images(TEAM=1)   ! { dg-error \"'team' argument of 'stopped_images' intrinsic at \\\\(1\\\\) not yet supported\" }\n+  gi = stopped_images(KIND=1)   ! OK\n+  gi = stopped_images(KIND=4)   ! OK\n+  gi = stopped_images(KIND=0)   ! { dg-error \"'kind' argument of 'stopped_images' intrinsic at \\\\\\(1\\\\\\) must be positive\" }\n+  gi = stopped_images(KIND=r)   ! { dg-error \"'kind' argument of 'stopped_images' intrinsic at \\\\\\(1\\\\\\) must be INTEGER\" }\n+  gi = stopped_images(KIND=i)   ! { dg-error \"Constant expression required at \\\\\\(1\\\\\\)\" }\n+  gi = stopped_images(KIND=42)  ! { dg-error \"'kind' argument of 'stopped_images' intrinsic at \\\\\\(1\\\\\\) shall specify a valid integer kind\" }\n+\n+end program test_stopped_images_1\n+"}, {"sha": "0bf4a81a7e2008d4415b07c5807c4aff67720df0", "filename": "gcc/testsuite/gfortran.dg/coarray/stopped_images_2.f08", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fstopped_images_2.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do run }\n+\n+program test_stopped_images_2\n+  implicit none\n+\n+  integer, allocatable :: si(:)\n+  integer(kind=1), allocatable :: ssi(:)\n+\n+  si = stopped_images()\n+  if (size(si) > 0) error stop \"stopped_images result shall be empty array\"\n+  ssi = stopped_images(KIND=1)\n+  if (size(ssi) > 0) error stop \"stopped_images result shall be empty array\"\n+  ssi = stopped_images(KIND=8)\n+  if (size(ssi) > 0) error stop \"stopped_images result shall be empty array\"\n+  \n+end program test_stopped_images_2\n+"}, {"sha": "d4eb8e2c240be1aac5a52ac3727f22c792dadd96", "filename": "gcc/testsuite/gfortran.dg/coarray_fail_st.f90", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_fail_st.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_fail_st.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_fail_st.f90?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,21 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib\" }\n+!\n+program fail_statement\n+  implicit none\n+\n+  integer :: me,np,stat\n+\n+  me = this_image()\n+  np = num_images()\n+  stat = 0\n+\n+  if(me == 1) fail image\n+\n+  sync all(stat=stat)\n+\n+  if(stat /= 0) write(*,*) 'Image failed during sync'\n+\n+end program fail_statement\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_fail_image \\\\\\(0B\\\\\\);\" 1 \"original\" } }"}, {"sha": "82387ec6a0ee0ffb82703209e5b28bdbcb2eb736", "filename": "gcc/testsuite/gfortran.dg/coarray_failed_images_1.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_failed_images_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_failed_images_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_failed_images_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib -lcaf_single\" }\n+\n+program test_failed_images_1\n+  implicit none\n+\n+  integer :: me,np,stat\n+  character(len=1) :: c\n+  integer, allocatable :: fi(:)\n+  integer(kind=1), allocatable :: sfi(:)\n+\n+  fi = failed_images()\n+  if (size(fi) > 0) error stop \"failed_images result shall be empty array\"\n+  if (allocated(fi)) error stop \"failed_images result shall not be allocated\"\n+\n+  sfi = failed_images(KIND=1)\n+  if (size(sfi) > 0) error stop \"failed_images result shall be empty array\"\n+  if (allocated(sfi)) error stop \"failed_images result shall not be allocated\"\n+\n+  sfi = failed_images(KIND=8)\n+  if (size(sfi) > 0) error stop \"failed_images result shall be empty array\"\n+! The implicit type conversion in the assignment above allocates an array. \n+!  if (allocated(sfi)) error stop \"failed_images result shall not be allocated\"\n+\n+end program test_failed_images_1\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_failed_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_failed_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, D\\\\\\.\\[0-9\\]+\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_failed_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, D\\\\\\.\\[0-9\\]+\\\\\\);\" 1 \"original\" } }"}, {"sha": "1062c60f7591eb93eb2eed991561f0f797741aff", "filename": "gcc/testsuite/gfortran.dg/coarray_image_status_1.f08", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_image_status_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_image_status_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_image_status_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! { dg-options \"-fcoarray=lib -lcaf_single -fdump-tree-original\" }\n+\n+program test_image_status_1\n+  use iso_fortran_env , only : STAT_STOPPED_IMAGE\n+  implicit none\n+\n+  if (image_status(1) /= 0) error stop \"image_status(1) should not fail\"\n+  if (image_status(42) /= STAT_STOPPED_IMAGE) error stop \"image_status(42) should report stopped image\"\n+\n+end program test_image_status_1\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_image_status \\\\\\(1, .+\\\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_image_status \\\\\\(42, .+\\\\\\)\" 1 \"original\" } }\n+\n+"}, {"sha": "36f86ed1a512233154fc5b847479b54b603ad955", "filename": "gcc/testsuite/gfortran.dg/coarray_stopped_images_1.f08", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_stopped_images_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_stopped_images_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_stopped_images_1.f08?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-options \"-fdump-tree-original -fcoarray=lib -lcaf_single\" }\n+\n+program test_stopped_images_1\n+  implicit none\n+\n+  integer :: me,np,stat\n+  character(len=1) :: c\n+  integer, allocatable :: si(:)\n+  integer(kind=1), allocatable :: ssi(:)\n+\n+  si = stopped_images()\n+  if (size(si) > 0) error stop \"stopped_images result shall be empty array at 1\"\n+  if (allocated(si)) error stop \"stopped_images result shall not be allocated at 1\"\n+\n+  ssi = stopped_images(KIND=1)\n+  if (size(ssi) > 0) error stop \"stopped_images result shall be empty array at 2\"\n+  if (allocated(ssi)) error stop \"stopped_images result shall not be allocated at 2\"\n+\n+  ssi = stopped_images(KIND=8)\n+  if (size(ssi) > 0) error stop \"stopped_images result shall be empty array at 3\"\n+! The implicit type conversion in the assignment above allocates an array. \n+!  if (allocated(ssi)) error stop \"stopped_images result shall not be allocated at 3\"\n+  \n+end program test_stopped_images_1\n+\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_stopped_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_stopped_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, D\\\\\\.\\[0-9\\]+\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_stopped_images \\\\\\(&D\\\\\\.\\[0-9\\]+, 0B, D\\\\\\.\\[0-9\\]+\\\\\\);\" 1 \"original\" } }"}, {"sha": "edb416bde94b14e63c02c936ef44782dc2729157", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -1,3 +1,13 @@\n+2017-03-05  Andre Vehreschild  <vehre@gcc.gnu.org>\n+            Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\n+\t* caf/libcaf.h: Added prototypes and stat codes for failed and stopped\n+\timages.\n+\t* caf/single.c (void _gfortran_caf_fail_image): Add the routine.\n+\t(int _gfortran_caf_image_status): Same.\n+\t(_gfortran_caf_failed_images): Same.\n+\t(_gfortran_caf_stopped_images): Same.\n+\n 2017-03-02  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "24726462e893d451c97c6d20a8358d079ce6e542", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -41,14 +41,20 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define likely(x)       __builtin_expect(!!(x), 1)\n #define unlikely(x)     __builtin_expect(!!(x), 0)\n #endif\n+#endif\n \n /* Definitions of the Fortran 2008 standard; need to kept in sync with\n-   ISO_FORTRAN_ENV, cf. libgfortran.h.  */\n-#define STAT_UNLOCKED\t\t0\n-#define STAT_LOCKED\t\t1\n-#define STAT_LOCKED_OTHER_IMAGE\t2\n-#define STAT_STOPPED_IMAGE \t6000\n-#endif\n+   ISO_FORTRAN_ENV, cf. gcc/fortran/libgfortran.h.  */\n+typedef enum\n+{\n+  CAF_STAT_UNLOCKED = 0,\n+  CAF_STAT_LOCKED,\n+  CAF_STAT_LOCKED_OTHER_IMAGE,\n+  CAF_STAT_STOPPED_IMAGE = 6000,\n+  CAF_STAT_FAILED_IMAGE  = 6001\n+}\n+caf_stat_codes_t;\n+\n \n /* Describes what type of array we are registerring.  Keep in sync with\n    gcc/fortran/trans.h.  */\n@@ -74,6 +80,7 @@ typedef enum caf_deregister_t {\n caf_deregister_t;\n \n typedef void* caf_token_t;\n+typedef void * caf_team_t;\n typedef gfc_array_void gfc_descriptor_t;\n \n /* Linked list of static coarrays registered.  */\n@@ -198,6 +205,7 @@ void _gfortran_caf_stop_str (const char *, int32_t)\n void _gfortran_caf_error_stop_str (const char *, int32_t)\n      __attribute__ ((noreturn));\n void _gfortran_caf_error_stop (int32_t) __attribute__ ((noreturn));\n+void _gfortran_caf_fail_image (void) __attribute__ ((noreturn));\n \n void _gfortran_caf_co_broadcast (gfc_descriptor_t *, int, int *, char *, int);\n void _gfortran_caf_co_sum (gfc_descriptor_t *, int, int *, char *, int);\n@@ -243,6 +251,13 @@ void _gfortran_caf_event_post (caf_token_t, size_t, int, int *, char *, int);\n void _gfortran_caf_event_wait (caf_token_t, size_t, int, int *, char *, int);\n void _gfortran_caf_event_query (caf_token_t, size_t, int, int *, int *);\n \n+void _gfortran_caf_failed_images (gfc_descriptor_t *,\n+\t\t\t\t  caf_team_t * __attribute__ ((unused)), int *);\n+int _gfortran_caf_image_status (int, caf_team_t * __attribute__ ((unused)));\n+void _gfortran_caf_stopped_images (gfc_descriptor_t *,\n+\t\t\t\t   caf_team_t * __attribute__ ((unused)),\n+\t\t\t\t   int *);\n+\n int _gfortran_caf_is_present (caf_token_t, int, caf_reference_t *);\n \n #endif  /* LIBCAF_H  */"}, {"sha": "bf1a229975403c0e68acbe62aa138c2fce5e76b8", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=ef78bc3c0b9d23b3decd8b6439c99a025ebc8f28", "patch": "@@ -264,13 +264,15 @@ _gfortran_caf_sync_images (int count __attribute__ ((unused)),\n     *stat = 0;\n }\n \n+\n void\n _gfortran_caf_stop_numeric(int32_t stop_code)\n {\n   fprintf (stderr, \"STOP %d\\n\", stop_code);\n   exit (0);\n }\n \n+\n void\n _gfortran_caf_stop_str(const char *string, int32_t len)\n {\n@@ -282,6 +284,7 @@ _gfortran_caf_stop_str(const char *string, int32_t len)\n   exit (0);\n }\n \n+\n void\n _gfortran_caf_error_stop_str (const char *string, int32_t len)\n {\n@@ -294,6 +297,74 @@ _gfortran_caf_error_stop_str (const char *string, int32_t len)\n }\n \n \n+/* Reported that the program terminated because of a fail image issued.\n+   Because this is a single image library, nothing else than aborting the whole\n+   program can be done.  */\n+\n+void _gfortran_caf_fail_image (void)\n+{\n+  fputs (\"IMAGE FAILED!\\n\", stderr);\n+  exit (0);\n+}\n+\n+\n+/* Get the status of image IMAGE.  Because being the single image library all\n+   other images are reported to be stopped.  */\n+\n+int _gfortran_caf_image_status (int image,\n+\t\t\t\tcaf_team_t * team __attribute__ ((unused)))\n+{\n+  if (image == 1)\n+    return 0;\n+  else\n+    return CAF_STAT_STOPPED_IMAGE;\n+}\n+\n+\n+/* Single image library.  There can not be any failed images with only one\n+   image.  */\n+\n+void\n+_gfortran_caf_failed_images (gfc_descriptor_t *array,\n+\t\t\t     caf_team_t * team __attribute__ ((unused)),\n+\t\t\t     int * kind)\n+{\n+  int local_kind = kind != NULL ? *kind : 4;\n+\n+  array->base_addr = NULL;\n+  array->dtype = ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT)\n+\t\t  | (local_kind << GFC_DTYPE_SIZE_SHIFT));\n+   /* Setting lower_bound higher then upper_bound is what the compiler does to\n+      indicate an empty array.  */\n+  array->dim[0].lower_bound = 0;\n+  array->dim[0]._ubound = -1;\n+  array->dim[0]._stride = 1;\n+  array->offset = 0;\n+}\n+\n+\n+/* With only one image available no other images can be stopped.  Therefore\n+   return an empty array.  */\n+\n+void\n+_gfortran_caf_stopped_images (gfc_descriptor_t *array,\n+\t\t\t      caf_team_t * team __attribute__ ((unused)),\n+\t\t\t      int * kind)\n+{\n+  int local_kind = kind != NULL ? *kind : 4;\n+\n+  array->base_addr = NULL;\n+  array->dtype =  ((BT_INTEGER << GFC_DTYPE_TYPE_SHIFT)\n+\t\t   | (local_kind << GFC_DTYPE_SIZE_SHIFT));\n+  /* Setting lower_bound higher then upper_bound is what the compiler does to\n+     indicate an empty array.  */\n+  array->dim[0].lower_bound = 0;\n+  array->dim[0]._ubound = -1;\n+  array->dim[0]._stride = 1;\n+  array->offset = 0;\n+}\n+\n+\n void\n _gfortran_caf_error_stop (int32_t error)\n {"}]}