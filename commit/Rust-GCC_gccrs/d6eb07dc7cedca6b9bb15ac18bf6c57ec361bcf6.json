{"sha": "d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZlYjA3ZGM3Y2VkY2E2YjliYjE1YWMxOGJmNmM1N2VjMzYxYmNmNg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2006-11-21T10:07:38Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2006-11-21T10:07:38Z"}, "message": "bfin.opt (mstack-check-l1): New.\n\n\t* config/bfin/bfin.opt (mstack-check-l1): New.\n\t* doc/invoke.texi (Blackfin Options): Document it.\n\t* config/bfin/bfin.c (bfin_expand_prologue): Generate code to use\n\tstack bounds in L1 memory if the new option is enabled.\n\t(override_options): Don't allow combinations of -fstack-limit and\n\t-mstack-check-l1.\n\t(add_to_reg): Renamed from add_to_sp.  All callers changed.  Lose some\n\tdead code.\n\nFrom-SVN: r119049", "tree": {"sha": "5d3920bc13b47b335c046459a056228986472d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d3920bc13b47b335c046459a056228986472d40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/comments", "author": null, "committer": null, "parents": [{"sha": "ec414fedf1981fe24112e7e500f262d005daaed3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec414fedf1981fe24112e7e500f262d005daaed3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec414fedf1981fe24112e7e500f262d005daaed3"}], "stats": {"total": 99, "additions": 79, "deletions": 20}, "files": [{"sha": "a7f0b779db4d95764e59e482e6db95ccda0e47a1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "patch": "@@ -1,3 +1,14 @@\n+2006-11-21  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* config/bfin/bfin.opt (mstack-check-l1): New.\n+\t* doc/invoke.texi (Blackfin Options): Document it.\n+\t* config/bfin/bfin.c (bfin_expand_prologue): Generate code to use\n+\tstack bounds in L1 memory if the new option is enabled.\n+\t(override_options): Don't allow combinations of -fstack-limit and\n+\t-mstack-check-l1.\n+\t(add_to_reg): Renamed from add_to_sp.  All callers changed.  Lose some\n+\tdead code.\n+\n 2006-11-21  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/spu/spu.c (spu_expand_vector_init): Initialise x."}, {"sha": "46c028b53f8fe1b6923faaedb23025b886e1a906", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "patch": "@@ -547,12 +547,12 @@ frame_related_constant_load (rtx reg, HOST_WIDE_INT constant, bool related)\n     RTX_FRAME_RELATED_P (insn) = 1;\n }\n \n-/* Generate efficient code to add a value to the frame pointer.  We\n-   can use P1 as a scratch register.  Set RTX_FRAME_RELATED_P on the\n-   generated insns if FRAME is nonzero.  */\n+/* Generate efficient code to add a value to a P register.  We can use\n+   P1 as a scratch register.  Set RTX_FRAME_RELATED_P on the generated\n+   insns if FRAME is nonzero.  */\n \n static void\n-add_to_sp (rtx spreg, HOST_WIDE_INT value, int frame)\n+add_to_reg (rtx reg, HOST_WIDE_INT value, int frame)\n {\n   if (value == 0)\n     return;\n@@ -568,13 +568,9 @@ add_to_sp (rtx spreg, HOST_WIDE_INT value, int frame)\n       if (frame)\n \tframe_related_constant_load (tmpreg, value, TRUE);\n       else\n-\t{\n-\t  insn = emit_move_insn (tmpreg, GEN_INT (value));\n-\t  if (frame)\n-\t    RTX_FRAME_RELATED_P (insn) = 1;\n-\t}\n+\tinsn = emit_move_insn (tmpreg, GEN_INT (value));\n \n-      insn = emit_insn (gen_addsi3 (spreg, spreg, tmpreg));\n+      insn = emit_insn (gen_addsi3 (reg, reg, tmpreg));\n       if (frame)\n \tRTX_FRAME_RELATED_P (insn) = 1;\n     }\n@@ -591,7 +587,7 @@ add_to_sp (rtx spreg, HOST_WIDE_INT value, int frame)\n \t     it's no good.  */\n \t  size = -60;\n \n-\tinsn = emit_insn (gen_addsi3 (spreg, spreg, GEN_INT (size)));\n+\tinsn = emit_insn (gen_addsi3 (reg, reg, GEN_INT (size)));\n \tif (frame)\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \tvalue -= size;\n@@ -684,7 +680,7 @@ do_link (rtx spreg, HOST_WIDE_INT frame_size, bool all)\n \t  rtx insn = emit_insn (pat);\n \t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n-      add_to_sp (spreg, -frame_size, 1);\n+      add_to_reg (spreg, -frame_size, 1);\n     }\n }\n \n@@ -701,7 +697,7 @@ do_unlink (rtx spreg, HOST_WIDE_INT frame_size, bool all)\n     {\n       rtx postinc = gen_rtx_MEM (Pmode, gen_rtx_POST_INC (Pmode, spreg));\n \n-      add_to_sp (spreg, frame_size, 0);\n+      add_to_reg (spreg, frame_size, 0);\n       if (must_save_fp_p ())\n \t{\n \t  rtx fpreg = gen_rtx_REG (Pmode, REG_FP);\n@@ -911,16 +907,24 @@ bfin_expand_prologue (void)\n       return;\n     }\n \n-  if (current_function_limit_stack)\n+  if (current_function_limit_stack\n+      || TARGET_STACK_CHECK_L1)\n     {\n       HOST_WIDE_INT offset\n \t= bfin_initial_elimination_offset (ARG_POINTER_REGNUM,\n \t\t\t\t\t   STACK_POINTER_REGNUM);\n-      rtx lim = stack_limit_rtx;\n+      rtx lim = current_function_limit_stack ? stack_limit_rtx : NULL_RTX;\n+      rtx p2reg = gen_rtx_REG (Pmode, REG_P2);\n \n+      if (!lim)\n+\t{\n+\t  rtx p1reg = gen_rtx_REG (Pmode, REG_P1);\n+\t  emit_move_insn (p2reg, gen_int_mode (0xFFB00000, SImode));\n+\t  emit_move_insn (p2reg, gen_rtx_MEM (Pmode, p2reg));\n+\t  lim = p2reg;\n+\t}\n       if (GET_CODE (lim) == SYMBOL_REF)\n \t{\n-\t  rtx p2reg = gen_rtx_REG (Pmode, REG_P2);\n \t  if (TARGET_ID_SHARED_LIBRARY)\n \t    {\n \t      rtx p1reg = gen_rtx_REG (Pmode, REG_P1);\n@@ -935,11 +939,18 @@ bfin_expand_prologue (void)\n \t    }\n \t  else\n \t    {\n-\t      rtx limit = plus_constant (stack_limit_rtx, offset);\n+\t      rtx limit = plus_constant (lim, offset);\n \t      emit_move_insn (p2reg, limit);\n \t      lim = p2reg;\n \t    }\n \t}\n+      else\n+\t{\n+\t  if (lim != p2reg)\n+\t    emit_move_insn (p2reg, lim);\n+\t  add_to_reg (p2reg, offset, 0);\n+\t  lim = p2reg;\n+\t}\n       emit_insn (gen_compare_lt (bfin_cc_rtx, spreg, lim));\n       emit_insn (gen_trapifcc ());\n     }\n@@ -2026,8 +2037,11 @@ override_options (void)\n   if (TARGET_ID_SHARED_LIBRARY && flag_pic == 0)\n     flag_pic = 1;\n \n+  if (stack_limit_rtx && TARGET_STACK_CHECK_L1)\n+    error (\"Can't use multiple stack checking methods together.\");\n+\n   if (TARGET_ID_SHARED_LIBRARY && TARGET_FDPIC)\n-      error (\"ID shared libraries and FD-PIC mode can't be used together.\");\n+    error (\"ID shared libraries and FD-PIC mode can't be used together.\");\n \n   /* Don't allow the user to specify -mid-shared-library and -msep-data\n      together, as it makes little sense from a user's point of view...  */"}, {"sha": "6c044f4388a3cb2e4120ba1f9d21be0125c40d95", "filename": "gcc/config/bfin/bfin.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fconfig%2Fbfin%2Fbfin.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fconfig%2Fbfin%2Fbfin.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.opt?ref=d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "patch": "@@ -60,3 +60,7 @@ Avoid generating pc-relative calls; use indirection\n mfdpic\n Target Report Mask(FDPIC)\n Enable Function Descriptor PIC mode\n+\n+mstack-check-l1\n+Target Report Mask(STACK_CHECK_L1)\n+Do stack checking using bounds in L1 scratch memory"}, {"sha": "045c5fd2557187552445202e04809d59dfd4b069", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d6eb07dc7cedca6b9bb15ac18bf6c57ec361bcf6", "patch": "@@ -429,9 +429,10 @@ Objective-C and Objective-C++ Dialects}.\n @emph{Blackfin Options}\n @gccoptlist{-momit-leaf-frame-pointer -mno-omit-leaf-frame-pointer @gol\n -mspecld-anomaly -mno-specld-anomaly -mcsync-anomaly -mno-csync-anomaly @gol\n--mlow-64k -mno-low64k -mid-shared-library @gol\n+-mlow-64k  -mno-low64k  -mstack-check-l1  -mid-shared-library @gol\n -mno-id-shared-library -mshared-library-id=@var{n} @gol\n--mlong-calls  -mno-long-calls}\n+-mleaf-id-shared-library  -mno-leaf-id-shared-library @gol\n+-msep-data  -mno-sep-data  -mlong-calls  -mno-long-calls}\n \n @emph{CRIS Options}\n @gccoptlist{-mcpu=@var{cpu}  -march=@var{cpu}  -mtune=@var{cpu} @gol\n@@ -7845,6 +7846,11 @@ the entire program fits into the low 64k of memory.\n @opindex mno-low-64k\n Assume that the program is arbitrarily large.  This is the default.\n \n+@item -mstack-check-l1\n+@opindex mstack-check-l1\n+Do stack checking using information placed into L1 scratchpad memory by the\n+uClinux kernel.\n+\n @item -mid-shared-library\n @opindex mid-shared-library\n Generate code that supports shared libraries via the library ID method.\n@@ -7856,13 +7862,37 @@ without virtual memory management.  This option implies @option{-fPIC}.\n Generate code that doesn't assume ID based shared libraries are being used.\n This is the default.\n \n+@item -mleaf-id-shared-library\n+@opindex mleaf-id-shared-library\n+Generate code that supports shared libraries via the library ID method,\n+but assumes that this library or executable won't link against any other\n+ID shared libraries.  That allows the compiler to use faster code for jumps\n+and calls.\n+\n+@item -mno-leaf-id-shared-library\n+@opindex mno-leaf-id-shared-library\n+Do not assume that the code being compiled won't link against any ID shared\n+libraries.  Slower code will be generated for jump and call insns.\n+\n @item -mshared-library-id=n\n @opindex mshared-library-id\n Specified the identification number of the ID based shared library being\n compiled.  Specifying a value of 0 will generate more compact code, specifying\n other values will force the allocation of that number to the current\n library but is no more space or time efficient than omitting this option.\n \n+@item -msep-data\n+@opindex msep-data\n+Generate code that allows the data segment to be located in a different\n+area of memory from the text segment.  This allows for execute in place in\n+an environment without virtual memory management by eliminating relocations\n+against the text section.\n+\n+@item -mno-sep-data\n+@opindex mno-sep-data\n+Generate code that assumes that the data segment follows the text segment.\n+This is the default.\n+\n @item -mlong-calls\n @itemx -mno-long-calls\n @opindex mlong-calls"}]}