{"sha": "c9543403c19fdc3c3b5a8db8546340de085bd14e", "node_id": "C_kwDOANBUbNoAKGM5NTQzNDAzYzE5ZmRjM2MzYjVhOGRiODU0NjM0MGRlMDg1YmQxNGU", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-12-06T19:04:35Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-12-06T23:36:33Z"}, "message": "analyzer: fix equivalence class state purging [PR103533]\n\nWhilst debugging state explosions seen when enabling taint detection\nwith -fanalyzer (PR analyzer/103533), I noticed that constraint\nmanager instances could contain stray, redundant constants, such\nas this instance:\n\nconstraint_manager:\n  equiv classes:\n    ec0: {(int)0 == [m_constant]\u20180\u2019}\n    ec1: {(size_t)4 == [m_constant]\u20184\u2019}\n  constraints:\n\nwhere there are two equivalence classes, each just containing a\nconstant, with no constraints using them.\n\nThis patch makes constraint_manager::canonicalize more aggressive\nabout purging state, handling the case of purging a redundant\nEC containing just a constant.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/103533\n\t* constraint-manager.cc (equiv_class::contains_non_constant_p):\n\tNew.\n\t(constraint_manager::canonicalize): Call it when determining\n\tredundant ECs.\n\t(selftest::test_purging): New selftest.\n\t(selftest::run_constraint_manager_tests): Likewise.\n\t* constraint-manager.h (equiv_class::contains_non_constant_p):\n\tNew decl.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "b6ab4e9e0cec37beb184a27c2df3b38a485e865c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ab4e9e0cec37beb184a27c2df3b38a485e865c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9543403c19fdc3c3b5a8db8546340de085bd14e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9543403c19fdc3c3b5a8db8546340de085bd14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9543403c19fdc3c3b5a8db8546340de085bd14e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9543403c19fdc3c3b5a8db8546340de085bd14e/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "325c6163a33af91264d1b7817a45b8425d5e6a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325c6163a33af91264d1b7817a45b8425d5e6a4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/325c6163a33af91264d1b7817a45b8425d5e6a4f"}], "stats": {"total": 151, "additions": 149, "deletions": 2}, "files": [{"sha": "76e44e77d0a6539a22e8d071c8ecbdaea2675170", "filename": "gcc/analyzer/constraint-manager.cc", "status": "modified", "additions": 147, "deletions": 2, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9543403c19fdc3c3b5a8db8546340de085bd14e/gcc%2Fanalyzer%2Fconstraint-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9543403c19fdc3c3b5a8db8546340de085bd14e/gcc%2Fanalyzer%2Fconstraint-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.cc?ref=c9543403c19fdc3c3b5a8db8546340de085bd14e", "patch": "@@ -1145,6 +1145,30 @@ equiv_class::canonicalize ()\n   m_vars.qsort (svalue::cmp_ptr_ptr);\n }\n \n+/* Return true if this EC contains a variable, false if it merely\n+   contains constants.\n+   Subroutine of constraint_manager::canonicalize, for removing\n+   redundant ECs.  */\n+\n+bool\n+equiv_class::contains_non_constant_p () const\n+{\n+  if (m_constant)\n+    {\n+      for (auto iter : m_vars)\n+\tif (iter->maybe_get_constant ())\n+\t  continue;\n+\telse\n+\t  /* We have {non-constant == constant}.  */\n+\t  return true;\n+      /* We only have constants.  */\n+      return false;\n+    }\n+  else\n+    /* Return true if we have {non-constant == non-constant}.  */\n+    return m_vars.length () > 1;\n+}\n+\n /* Get a debug string for C_OP.  */\n \n const char *\n@@ -2718,8 +2742,7 @@ constraint_manager::canonicalize ()\n       {\n \tequiv_class *ec = m_equiv_classes[i];\n \tif (!used_ecs.contains (ec)\n-\t    && ((ec->m_vars.length () < 2 && ec->m_constant == NULL_TREE)\n-\t\t|| (ec->m_vars.length () == 0)))\n+\t    && !ec->contains_non_constant_p ())\n \t  {\n \t    m_equiv_classes.unordered_remove (i);\n \t    delete ec;\n@@ -3704,6 +3727,127 @@ test_many_constants ()\n     }\n }\n \n+/* Verify that purging state relating to a variable doesn't leave stray\n+   equivalence classes (after canonicalization).  */\n+\n+static void\n+test_purging (void)\n+{\n+  tree int_0 = build_int_cst (integer_type_node, 0);\n+  tree a = build_global_decl (\"a\", integer_type_node);\n+  tree b = build_global_decl (\"b\", integer_type_node);\n+\n+  /*  \"a != 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, NE_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 1);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should have an empty constraint_manager.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 0);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+  }\n+\n+  /*  \"a != 0\" && \"b != 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, NE_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, b, NE_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 3);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 2);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should just have the constraint/ECs involving b != 0.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 1);\n+    ASSERT_CONDITION_TRUE (model, b, NE_EXPR, int_0);\n+  }\n+\n+  /*  \"a != 0\" && \"b == 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, NE_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, b, EQ_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 1);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should just have the EC involving b == 0.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 1);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+    ASSERT_CONDITION_TRUE (model, b, EQ_EXPR, int_0);\n+  }\n+\n+  /*  \"a == 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 1);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should have an empty constraint_manager.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 0);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+  }\n+\n+  /*  \"a == 0\" && \"b != 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, b, NE_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 1);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should just have the constraint/ECs involving b != 0.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 2);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 1);\n+    ASSERT_CONDITION_TRUE (model, b, NE_EXPR, int_0);\n+  }\n+\n+  /*  \"a == 0\" && \"b == 0\".  */\n+  {\n+    region_model_manager mgr;\n+    region_model model (&mgr);\n+    ADD_SAT_CONSTRAINT (model, a, EQ_EXPR, int_0);\n+    ADD_SAT_CONSTRAINT (model, b, EQ_EXPR, int_0);\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 1);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+\n+    /* Purge state for \"a\".  */\n+    const svalue *sval_a = model.get_rvalue (a, NULL);\n+    model.purge_state_involving (sval_a, NULL);\n+    model.canonicalize ();\n+    /* We should just have the EC involving b == 0.  */\n+    ASSERT_EQ (model.get_constraints ()->m_equiv_classes.length (), 1);\n+    ASSERT_EQ (model.get_constraints ()->m_constraints.length (), 0);\n+    ASSERT_CONDITION_TRUE (model, b, EQ_EXPR, int_0);\n+  }\n+}\n+\n /* Implementation detail of ASSERT_DUMP_BOUNDED_RANGES_EQ.  */\n \n static void\n@@ -4035,6 +4179,7 @@ run_constraint_manager_tests (bool transitivity)\n   test_constraint_impl ();\n   test_equality ();\n   test_many_constants ();\n+  test_purging ();\n   test_bounded_range ();\n   test_bounded_ranges ();\n "}, {"sha": "c7b9d9c697b40f476735c57e5280646ec3d2a62a", "filename": "gcc/analyzer/constraint-manager.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9543403c19fdc3c3b5a8db8546340de085bd14e/gcc%2Fanalyzer%2Fconstraint-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9543403c19fdc3c3b5a8db8546340de085bd14e/gcc%2Fanalyzer%2Fconstraint-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fconstraint-manager.h?ref=c9543403c19fdc3c3b5a8db8546340de085bd14e", "patch": "@@ -248,6 +248,8 @@ class equiv_class\n \n   json::object *to_json () const;\n \n+  bool contains_non_constant_p () const;\n+\n   /* An equivalence class can contain multiple constants (e.g. multiple\n      different zeroes, for different types); these are just for the last\n      constant added.  */"}]}