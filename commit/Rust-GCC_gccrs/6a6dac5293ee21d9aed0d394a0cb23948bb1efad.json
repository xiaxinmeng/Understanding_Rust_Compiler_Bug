{"sha": "6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE2ZGFjNTI5M2VlMjFkOWFlZDBkMzk0YTBjYjIzOTQ4YmIxZWZhZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-06-19T18:06:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-06-19T18:06:12Z"}, "message": "cgraph.h (const_value_known_p): Replace by ...\n\n\n\t* cgraph.h (const_value_known_p): Replace by ...\n\t(ctor_for_folding): .. this one.\n\t* cgraphunit.c (process_function_and_variable_attributes): Use it.\n\t* lto-cgraph.c (compute_ltrans_boundary): Use ctor_for_folding.\n\t* expr.c (expand_expr_real_1): Likewise.\n\t(string_constant): Likewise.\n\t* tree-ssa-loop-ivcanon.c (constant_after_peeling): Likewise.\n\t* ipa.c (process_references): Likewise.\n\t(symtab_remove_unreachable_nodes): Likewise.\n\t* ipa-inline-analysis.c (param_change_prob): Likewise.\n\t* gimple-fold.c (canonicalize_constructor_val): Likewise.\n\t(get_base_constructor): Likwise.\n\t* varpool.c (varpool_remove_node): Likewise.\n\t(varpool_remove_initializer): LIkewise.\n\t(dump_varpool_node): LIkwise.\n\t(const_value_known_p): Rewrite to ...\n\t(ctor_for_folding): ... this one.\n\n\t* lto-partition.c (add_references_to_partition): Use\n\tctor_for_folding.\n\n\t* gcc.dg/tree-ssa/attr-alias-2.c: New testcase.\n\nFrom-SVN: r200211", "tree": {"sha": "1d4237222ae0ad0d8207eb6ee9f94b244ffae6e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d4237222ae0ad0d8207eb6ee9f94b244ffae6e5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/comments", "author": null, "committer": null, "parents": [{"sha": "216c12abf6eccbcf5c5ff1898e8b063a494af40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/216c12abf6eccbcf5c5ff1898e8b063a494af40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/216c12abf6eccbcf5c5ff1898e8b063a494af40c"}], "stats": {"total": 336, "additions": 224, "deletions": 112}, "files": [{"sha": "b2c2ee70afcf1329fd1240507b8220c3f10462b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -1,3 +1,23 @@\n+2013-06-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (const_value_known_p): Replace by ...\n+\t(ctor_for_folding): .. this one.\n+\t* cgraphunit.c (process_function_and_variable_attributes): Use it.\n+\t* lto-cgraph.c (compute_ltrans_boundary): Use ctor_for_folding.\n+\t* expr.c (expand_expr_real_1): Likewise.\n+\t(string_constant): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (constant_after_peeling): Likewise.\n+\t* ipa.c (process_references): Likewise.\n+\t(symtab_remove_unreachable_nodes): Likewise.\n+\t* ipa-inline-analysis.c (param_change_prob): Likewise.\n+\t* gimple-fold.c (canonicalize_constructor_val): Likewise.\n+\t(get_base_constructor): Likwise.\n+\t* varpool.c (varpool_remove_node): Likewise.\n+\t(varpool_remove_initializer): LIkewise.\n+\t(dump_varpool_node): LIkwise.\n+\t(const_value_known_p): Rewrite to ...\n+\t(ctor_for_folding): ... this one.\n+\n 2013-06-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR driver/57651"}, {"sha": "ef2a2a0a348cf2b0a6cce2b5da7b385133fa47e7", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -797,7 +797,7 @@ void varpool_analyze_node (struct varpool_node *);\n struct varpool_node * varpool_extra_name_alias (tree, tree);\n struct varpool_node * varpool_create_variable_alias (tree, tree);\n void varpool_reset_queue (void);\n-bool const_value_known_p (tree);\n+tree ctor_for_folding (tree);\n bool varpool_for_node_and_aliases (struct varpool_node *,\n \t\t                   bool (*) (struct varpool_node *, void *),\n \t\t\t           void *, bool);"}, {"sha": "731a0e91294c9d5fd0eadb57049d26b34039ca5c", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -762,8 +762,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     {\n       tree decl = vnode->symbol.decl;\n       if (DECL_EXTERNAL (decl)\n-\t  && DECL_INITIAL (decl)\n-\t  && const_value_known_p (decl))\n+\t  && DECL_INITIAL (decl))\n \tvarpool_finalize_decl (decl);\n       if (DECL_PRESERVE_P (decl))\n \tvnode->symbol.force_output = true;"}, {"sha": "bce96c9c2272d7ab10eefb2be3585ef28f3648d2", "filename": "gcc/expr.c", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -9698,6 +9698,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \ttree array = treeop0;\n \ttree index = treeop1;\n+        tree init;\n \n \t/* Fold an expression like: \"foo\"[2].\n \t   This is not done in fold so it won't happen inside &.\n@@ -9744,76 +9745,72 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t && modifier != EXPAND_INITIALIZER\n \t\t && modifier != EXPAND_MEMORY\n \t\t && TREE_READONLY (array) && ! TREE_SIDE_EFFECTS (array)\n-\t\t && TREE_CODE (array) == VAR_DECL && DECL_INITIAL (array)\n-\t\t && TREE_CODE (DECL_INITIAL (array)) != ERROR_MARK\n-\t\t && const_value_known_p (array))\n+\t\t && TREE_CODE (index) == INTEGER_CST\n+\t\t && (TREE_CODE (array) == VAR_DECL\n+\t\t     || TREE_CODE (array) == CONST_DECL)\n+\t\t && (init = ctor_for_folding (array)) != error_mark_node)\n \t  {\n-\t    if (TREE_CODE (index) == INTEGER_CST)\n+\t    if (TREE_CODE (init) == CONSTRUCTOR)\n \t      {\n-\t\ttree init = DECL_INITIAL (array);\n+\t\tunsigned HOST_WIDE_INT ix;\n+\t\ttree field, value;\n \n-\t\tif (TREE_CODE (init) == CONSTRUCTOR)\n-\t\t  {\n-\t\t    unsigned HOST_WIDE_INT ix;\n-\t\t    tree field, value;\n+\t\tFOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), ix,\n+\t\t\t\t\t  field, value)\n+\t\t  if (tree_int_cst_equal (field, index))\n+\t\t    {\n+\t\t      if (TREE_SIDE_EFFECTS (value))\n+\t\t\tbreak;\n \n-\t\t    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (init), ix,\n-\t\t\t\t\t      field, value)\n-\t\t      if (tree_int_cst_equal (field, index))\n+\t\t      if (TREE_CODE (value) == CONSTRUCTOR)\n \t\t\t{\n-\t\t\t  if (TREE_SIDE_EFFECTS (value))\n+\t\t\t  /* If VALUE is a CONSTRUCTOR, this\n+\t\t\t     optimization is only useful if\n+\t\t\t     this doesn't store the CONSTRUCTOR\n+\t\t\t     into memory.  If it does, it is more\n+\t\t\t     efficient to just load the data from\n+\t\t\t     the array directly.  */\n+\t\t\t  rtx ret = expand_constructor (value, target,\n+\t\t\t\t\t\t\tmodifier, true);\n+\t\t\t  if (ret == NULL_RTX)\n \t\t\t    break;\n-\n-\t\t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n-\t\t\t    {\n-\t\t\t      /* If VALUE is a CONSTRUCTOR, this\n-\t\t\t\t optimization is only useful if\n-\t\t\t\t this doesn't store the CONSTRUCTOR\n-\t\t\t\t into memory.  If it does, it is more\n-\t\t\t\t efficient to just load the data from\n-\t\t\t\t the array directly.  */\n-\t\t\t      rtx ret = expand_constructor (value, target,\n-\t\t\t\t\t\t\t    modifier, true);\n-\t\t\t      if (ret == NULL_RTX)\n-\t\t\t\tbreak;\n-\t\t\t    }\n-\n-\t\t\t  return expand_expr (fold (value), target, tmode,\n-\t\t\t\t\t      modifier);\n \t\t\t}\n-\t\t  }\n-\t\telse if(TREE_CODE (init) == STRING_CST)\n+\n+\t\t      return expand_expr (fold (value), target, tmode,\n+\t\t\t\t\t  modifier);\n+\t\t    }\n+\t      }\n+\t    else if(TREE_CODE (init) == STRING_CST)\n+\t      {\n+\t\ttree index1 = index;\n+\t\ttree low_bound = array_ref_low_bound (exp);\n+\t\tindex1 = fold_convert_loc (loc, sizetype,\n+\t\t\t\t\t   treeop1);\n+\n+\t\t/* Optimize the special-case of a zero lower bound.\n+\n+\t\t   We convert the low_bound to sizetype to avoid some problems\n+\t\t   with constant folding.  (E.g. suppose the lower bound is 1,\n+\t\t   and its mode is QI.  Without the conversion,l (ARRAY\n+\t\t   +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n+\t\t   +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */\n+\n+\t\tif (! integer_zerop (low_bound))\n+\t\t  index1 = size_diffop_loc (loc, index1,\n+\t\t\t\t\tfold_convert_loc (loc, sizetype,\n+\t\t\t\t\t\t\t  low_bound));\n+\n+\t\tif (0 > compare_tree_int (index1,\n+\t\t\t\t\t  TREE_STRING_LENGTH (init)))\n \t\t  {\n-\t\t    tree index1 = index;\n-\t\t    tree low_bound = array_ref_low_bound (exp);\n-\t\t    index1 = fold_convert_loc (loc, sizetype,\n-\t\t\t\t\t       treeop1);\n-\n-\t\t    /* Optimize the special-case of a zero lower bound.\n-\n-\t\t       We convert the low_bound to sizetype to avoid some problems\n-\t\t       with constant folding.  (E.g. suppose the lower bound is 1,\n-\t\t       and its mode is QI.  Without the conversion,l (ARRAY\n-\t\t       +(INDEX-(unsigned char)1)) becomes ((ARRAY+(-(unsigned char)1))\n-\t\t       +INDEX), which becomes (ARRAY+255+INDEX).  Opps!)  */\n-\n-\t\t    if (! integer_zerop (low_bound))\n-\t\t      index1 = size_diffop_loc (loc, index1,\n-\t\t\t\t\t    fold_convert_loc (loc, sizetype,\n-\t\t\t\t\t\t\t      low_bound));\n-\n-\t\t    if (0 > compare_tree_int (index1,\n-\t\t\t\t\t      TREE_STRING_LENGTH (init)))\n-\t\t      {\n-\t\t\ttree type = TREE_TYPE (TREE_TYPE (init));\n-\t\t\tenum machine_mode mode = TYPE_MODE (type);\n-\n-\t\t\tif (GET_MODE_CLASS (mode) == MODE_INT\n-\t\t\t    && GET_MODE_SIZE (mode) == 1)\n-\t\t\t  return gen_int_mode (TREE_STRING_POINTER (init)\n-\t\t\t\t\t       [TREE_INT_CST_LOW (index1)],\n-\t\t\t\t\t       mode);\n-\t\t      }\n+\t\t    tree type = TREE_TYPE (TREE_TYPE (init));\n+\t\t    enum machine_mode mode = TYPE_MODE (type);\n+\n+\t\t    if (GET_MODE_CLASS (mode) == MODE_INT\n+\t\t\t&& GET_MODE_SIZE (mode) == 1)\n+\t\t      return gen_int_mode (TREE_STRING_POINTER (init)\n+\t\t\t\t\t   [TREE_INT_CST_LOW (index1)],\n+\t\t\t\t\t   mode);\n \t\t  }\n \t      }\n \t  }\n@@ -10676,17 +10673,18 @@ string_constant (tree arg, tree *ptr_offset)\n \t   || TREE_CODE (array) == CONST_DECL)\n     {\n       int length;\n+      tree init = ctor_for_folding (array);\n \n       /* Variables initialized to string literals can be handled too.  */\n-      if (!const_value_known_p (array)\n-\t  || !DECL_INITIAL (array)\n-\t  || TREE_CODE (DECL_INITIAL (array)) != STRING_CST)\n+      if (init == error_mark_node\n+\t  || !init\n+\t  || TREE_CODE (init) != STRING_CST)\n \treturn 0;\n \n       /* Avoid const char foo[4] = \"abcde\";  */\n       if (DECL_SIZE_UNIT (array) == NULL_TREE\n \t  || TREE_CODE (DECL_SIZE_UNIT (array)) != INTEGER_CST\n-\t  || (length = TREE_STRING_LENGTH (DECL_INITIAL (array))) <= 0\n+\t  || (length = TREE_STRING_LENGTH (init)) <= 0\n \t  || compare_tree_int (DECL_SIZE_UNIT (array), length) < 0)\n \treturn 0;\n \n@@ -10699,7 +10697,7 @@ string_constant (tree arg, tree *ptr_offset)\n \treturn 0;\n \n       *ptr_offset = offset;\n-      return DECL_INITIAL (array);\n+      return init;\n     }\n \n   return 0;"}, {"sha": "b6d22b3a7c835012edcbf84af4554863525efbaa", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -192,9 +192,9 @@ canonicalize_constructor_val (tree cval, tree from_decl)\n tree\n get_symbol_constant_value (tree sym)\n {\n-  if (const_value_known_p (sym))\n+  tree val = ctor_for_folding (sym);\n+  if (val != error_mark_node)\n     {\n-      tree val = DECL_INITIAL (sym);\n       if (val)\n \t{\n \t  val = canonicalize_constructor_val (unshare_expr (val), sym);\n@@ -2695,19 +2695,18 @@ get_base_constructor (tree base, HOST_WIDE_INT *bit_offset,\n   switch (TREE_CODE (base))\n     {\n     case VAR_DECL:\n-      if (!const_value_known_p (base))\n-\treturn NULL_TREE;\n-\n-      /* Fallthru.  */\n     case CONST_DECL:\n-      if (!DECL_INITIAL (base)\n-\t  && (TREE_STATIC (base) || DECL_EXTERNAL (base)))\n-        return error_mark_node;\n-      /* Do not return an error_mark_node DECL_INITIAL.  LTO uses this\n-         as special marker (_not_ zero ...) for its own purposes.  */\n-      if (DECL_INITIAL (base) == error_mark_node)\n-\treturn NULL_TREE;\n-      return DECL_INITIAL (base);\n+      {\n+\ttree init = ctor_for_folding (base);\n+\n+\t/* Our semantic is exact oposite of ctor_for_folding;\n+\t   NULL means unknown, while error_mark_node is 0.  */\n+\tif (init == error_mark_node)\n+\t  return NULL_TREE;\n+\tif (!init)\n+\t  return error_mark_node;\n+\treturn init;\n+      }\n \n     case ARRAY_REF:\n     case COMPONENT_REF:"}, {"sha": "9a3629285fb9f2e12065b9d49231c48c02c70ea2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -2106,8 +2106,9 @@ param_change_prob (gimple stmt, int i)\n       struct record_modified_bb_info info;\n       bitmap_iterator bi;\n       unsigned index;\n+      tree init = ctor_for_folding (base);\n \n-      if (const_value_known_p (base))\n+      if (init != error_mark_node)\n \treturn 0;\n       if (!bb->frequency)\n \treturn REG_BR_PROB_BASE;"}, {"sha": "7c0d495695ba6cbc27b60aa270ef3107fef91d8b", "filename": "gcc/ipa.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -145,7 +145,9 @@ process_references (struct ipa_ref_list *list,\n \t\t     constant folding.  Keep references alive so partitioning\n \t\t     knows about potential references.  */\n \t\t  || (TREE_CODE (node->symbol.decl) == VAR_DECL\n-\t\t      && flag_wpa && const_value_known_p (node->symbol.decl)))))\n+\t\t      && flag_wpa\n+\t\t      && ctor_for_folding (node->symbol.decl)\n+\t\t         != error_mark_node))))\n \tpointer_set_insert (reachable, node);\n       enqueue_node ((symtab_node) node, first, reachable);\n     }\n@@ -400,6 +402,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       else if (!pointer_set_contains (reachable, vnode))\n         {\n+\t  tree init;\n \t  if (vnode->symbol.definition)\n \t    {\n \t      if (file)\n@@ -411,8 +414,10 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  vnode->symbol.aux = NULL;\n \n \t  /* Keep body if it may be useful for constant folding.  */\n-\t  if (!const_value_known_p (vnode->symbol.decl))\n+\t  if ((init = ctor_for_folding (vnode->symbol.decl)) == error_mark_node)\n \t    varpool_remove_initializer (vnode);\n+\t  else\n+\t    DECL_INITIAL (vnode->symbol.decl) = init;\n \t  ipa_remove_all_references (&vnode->symbol.ref_list);\n \t}\n       else"}, {"sha": "2122f705845b4f4f11a77fb48aa511bfe26d8fad", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -766,10 +766,9 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       symtab_node node = lto_symtab_encoder_deref (encoder, i);\n       if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n \t{\n-\t  if (DECL_INITIAL (vnode->symbol.decl)\n-\t      && !lto_symtab_encoder_encode_initializer_p (encoder,\n-\t\t\t\t\t\t\t   vnode)\n-\t      && const_value_known_p (vnode->symbol.decl))\n+\t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n+\t\t\t\t\t\t\tvnode)\n+\t      && ctor_for_folding (vnode->symbol.decl) != error_mark_node)\n \t    {\n \t      lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n \t      add_references (encoder, &vnode->symbol.ref_list);"}, {"sha": "2723678f27585ad649de9ae673f3fb00b188a3fb", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -1,3 +1,8 @@\n+2013-06-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c (add_references_to_partition): Use\n+\tctor_for_folding.\n+\n 2013-06-18  Richard Biener  <rguenther@suse.de>\n \n \t* lto.c (lto_register_var_decl_in_symtab): Pass in cache index"}, {"sha": "ffc8da3e94e35ef9a5d755b71be8a1d5e7dc3cd9", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -146,7 +146,7 @@ add_references_to_partition (ltrans_partition part, symtab_node node)\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n     else if (is_a <varpool_node> (ref->referred)\n-\t     && const_value_known_p (ref->referred->symbol.decl)\n+\t     && ctor_for_folding (ref->referred->symbol.decl) != error_mark_node\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n \tif (!part->initializers_visited)"}, {"sha": "baae9b9447e1f787e8589e43f7cc7aac8c5d22b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -1,3 +1,7 @@\n+2013-06-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/attr-alias-2.c: New testcase.\n+\n 2013-06-19  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n        * c-c++-common/cilk-plus/AN/builtin_fn_custom.c: Replaced all the"}, {"sha": "50623a47459b17bcb9ecf7c3cfd2830e1c0c51e5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/attr-alias-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fattr-alias-2.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do compile } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+static int a=4;\n+static int b __attribute__ ((alias(\"a\")));\n+main()\n+{\n+   return b+a;\n+}\n+/* { dg-final { scan-tree-dump \"return 8\" \"optimized\" } } */\n+/* { dg-do compile } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+static int a=4;\n+static int b __attribute__ ((alias(\"a\")));\n+main()\n+{\n+   return b+a;\n+}\n+/* { dg-final { scan-tree-dump \"return 8\" \"optimized\" } } */\n+/* { dg-do compile } */\n+/* { dg-require-alias \"\" } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+static int a=4;\n+static int b __attribute__ ((alias(\"a\")));\n+main()\n+{\n+   return b+a;\n+}\n+/* { dg-final { scan-tree-dump \"return 8\" \"optimized\" } } */"}, {"sha": "91cf8c16a3234caee78fd8d4a0e2b18d0facce14", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -174,7 +174,7 @@ constant_after_peeling (tree op, gimple stmt, struct loop *loop)\n       while (handled_component_p (base))\n \tbase = TREE_OPERAND (base, 0);\n       if ((DECL_P (base)\n-\t   && const_value_known_p (base))\n+\t   && ctor_for_folding (base) != error_mark_node)\n \t  || CONSTANT_CLASS_P (base))\n \t{\n \t  /* If so, see if we understand all the indices.  */"}, {"sha": "b426757ec8463feef14a304fd45313931790067d", "filename": "gcc/varpool.c", "status": "modified", "additions": 71, "deletions": 19, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a6dac5293ee21d9aed0d394a0cb23948bb1efad/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=6a6dac5293ee21d9aed0d394a0cb23948bb1efad", "patch": "@@ -66,12 +66,15 @@ void\n varpool_remove_node (struct varpool_node *node)\n {\n   symtab_unregister_node ((symtab_node)node);\n+  tree init;\n \n   /* Because we remove references from external functions before final compilation,\n      we may end up removing useful constructors.\n      FIXME: We probably want to trace boundaries better.  */\n-  if (!const_value_known_p (node->symbol.decl))\n+  if ((init = ctor_for_folding (node->symbol.decl)) == error_mark_node)\n     varpool_remove_initializer (node);\n+  else\n+    DECL_INITIAL (node->symbol.decl) = init;\n   ggc_free (node);\n }\n \n@@ -109,7 +112,7 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n     fprintf (f, \" output\");\n   if (TREE_READONLY (node->symbol.decl))\n     fprintf (f, \" read-only\");\n-  if (const_value_known_p (node->symbol.decl))\n+  if (ctor_for_folding (node->symbol.decl) != error_mark_node)\n     fprintf (f, \" const-value-known\");\n   fprintf (f, \"\\n\");\n }\n@@ -144,44 +147,93 @@ varpool_node_for_asm (tree asmname)\n }\n \n /* Return if DECL is constant and its initial value is known (so we can do\n-   constant folding using DECL_INITIAL (decl)).  */\n+   constant folding using DECL_INITIAL (decl)).\n+   Return ERROR_MARK_NODE when value is unknown.  */\n \n-bool\n-const_value_known_p (tree decl)\n+tree\n+ctor_for_folding (tree decl)\n {\n+  struct varpool_node *node, *real_node;\n+  tree real_decl;\n+\n   if (TREE_CODE (decl) != VAR_DECL\n-      &&TREE_CODE (decl) != CONST_DECL)\n-    return false;\n+      && TREE_CODE (decl) != CONST_DECL)\n+    return error_mark_node;\n \n   if (TREE_CODE (decl) == CONST_DECL\n       || DECL_IN_CONSTANT_POOL (decl))\n-    return true;\n+    return DECL_INITIAL (decl);\n+\n+  if (TREE_THIS_VOLATILE (decl))\n+    return error_mark_node;\n+\n+  /* Do not care about automatic variables.  Those are never initialized\n+     anyway, because gimplifier exapnds the code*/\n+  if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n+    {\n+      gcc_assert (!TREE_PUBLIC (decl));\n+      return error_mark_node;\n+    }\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n \n-  if (!TREE_READONLY (decl) || TREE_THIS_VOLATILE (decl))\n-    return false;\n+  node = varpool_get_node (decl);\n+  if (node)\n+    {\n+      real_node = varpool_variable_node (node);\n+      real_decl = real_node->symbol.decl;\n+    }\n+  else\n+    real_decl = decl;\n+\n+  /* See if we are dealing with alias.\n+     In most cases alias is just alternative symbol pointing to a given\n+     constructor.  This allows us to use interposition rules of DECL\n+     constructor of REAL_NODE.  However weakrefs are special by being just\n+     alternative name of their target (if defined).  */\n+  if (decl != real_decl)\n+    {\n+      gcc_assert (!DECL_INITIAL (decl)\n+\t\t  || DECL_INITIAL (decl) == error_mark_node);\n+      if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl)))\n+\t{\n+\t  node = varpool_alias_target (node);\n+\t  decl = node->symbol.decl;\n+\t}\n+    }\n \n-  /* Gimplifier takes away constructors of local vars  */\n-  if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n-    return DECL_INITIAL (decl) != NULL;\n+  /* Vtables are defined by their types and must match no matter of interposition\n+     rules.  */\n+  if (DECL_VIRTUAL_P (real_decl))\n+    {\n+      gcc_checking_assert (TREE_READONLY (real_decl));\n+      return DECL_INITIAL (real_decl);\n+    }\n+\n+  /* If thre is no constructor, we have nothing to do.  */\n+  if (DECL_INITIAL (real_decl) == error_mark_node)\n+    return error_mark_node;\n \n-  gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n+  /* Non-readonly alias of readonly variable is also de-facto readonly,\n+     because the variable itself is in readonly section.  \n+     We also honnor READONLY flag on alias assuming that user knows\n+     what he is doing.  */\n+  if (!TREE_READONLY (decl) && !TREE_READONLY (real_decl))\n+    return error_mark_node;\n \n   /* Variables declared 'const' without an initializer\n      have zero as the initializer if they may not be\n      overridden at link or run time.  */\n-  if (!DECL_INITIAL (decl)\n-      && (DECL_EXTERNAL (decl)\n-\t  || decl_replaceable_p (decl)))\n-    return false;\n+  if (!DECL_INITIAL (real_decl)\n+      && (DECL_EXTERNAL (decl) || decl_replaceable_p (decl)))\n+    return error_mark_node;\n \n   /* Variables declared `const' with an initializer are considered\n      to not be overwritable with different initializer by default. \n \n      ??? Previously we behaved so for scalar variables but not for array\n      accesses.  */\n-  return true;\n+  return DECL_INITIAL (real_decl);\n }\n \n /* Add the variable DECL to the varpool."}]}