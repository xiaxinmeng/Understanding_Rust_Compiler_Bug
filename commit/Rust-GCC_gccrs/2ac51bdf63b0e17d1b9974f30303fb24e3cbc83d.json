{"sha": "2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFjNTFiZGY2M2IwZTE3ZDFiOTk3NGYzMDMwM2ZiMjRlM2NiYzgzZA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-07-22T07:50:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-08-04T15:02:56Z"}, "message": "d: Fix struct literals that have non-deterministic hash values (PR96153)\n\nAdds code generation for generating a temporary for, and pre-filling\nstruct and array literals with zeroes before assigning, so that\nalignment holes don't cause objects to produce a non-deterministic hash\nvalue.  A new field has been added to the expression visitor to track\nwhether the result is being generated for another literal, so that\nmemset() is only called once on the top-level literal expression, and\nnot for nesting struct or arrays.\n\ngcc/d/ChangeLog:\n\n\tPR d/96153\n\t* d-tree.h (build_expr): Add literalp argument.\n\t* expr.cc (ExprVisitor): Add literalp_ field.\n\t(ExprVisitor::ExprVisitor): Initialize literalp_.\n\t(ExprVisitor::visit (AssignExp *)): Call memset() on blits where RHS\n\tis a struct literal.  Elide assignment if initializer is all zeroes.\n\t(ExprVisitor::visit (CastExp *)): Forward literalp_ to generation of\n\tsubexpression.\n\t(ExprVisitor::visit (AddrExp *)): Likewise.\n\t(ExprVisitor::visit (ArrayLiteralExp *)): Use memset() to pre-fill\n\tobject with zeroes.  Set literalp in subexpressions.\n\t(ExprVisitor::visit (StructLiteralExp *)): Likewise.\n\t(ExprVisitor::visit (TupleExp *)): Set literalp in subexpressions.\n\t(ExprVisitor::visit (VectorExp *)): Likewise.\n\t(ExprVisitor::visit (VectorArrayExp *)): Likewise.\n\t(build_expr): Forward literal_p to ExprVisitor.\n\ngcc/testsuite/ChangeLog:\n\n\tPR d/96153\n\t* gdc.dg/pr96153.d: New test.", "tree": {"sha": "78a0b25b1cb01fd3bf17716064ac421dd5f04adf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78a0b25b1cb01fd3bf17716064ac421dd5f04adf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19fad46721af338b24aff48127ae654673bffa7b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19fad46721af338b24aff48127ae654673bffa7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19fad46721af338b24aff48127ae654673bffa7b"}], "stats": {"total": 137, "additions": 101, "deletions": 36}, "files": [{"sha": "072de7e65439c20458eccc40071c4528998300a1", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "patch": "@@ -633,7 +633,7 @@ extern void d_comdat_linkage (tree);\n extern void d_linkonce_linkage (tree);\n \n /* In expr.cc.  */\n-extern tree build_expr (Expression *, bool = false);\n+extern tree build_expr (Expression *, bool = false, bool = false);\n extern tree build_expr_dtor (Expression *);\n extern tree build_return_dtor (Expression *, Type *, TypeFunction *);\n "}, {"sha": "85407ac7eb05523722e746e1930142a78a5f7934", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 69, "deletions": 35, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "patch": "@@ -223,12 +223,14 @@ class ExprVisitor : public Visitor\n \n   tree result_;\n   bool constp_;\n+  bool literalp_;\n \n public:\n-  ExprVisitor (bool constp)\n+  ExprVisitor (bool constp, bool literalp)\n   {\n     this->result_ = NULL_TREE;\n     this->constp_ = constp;\n+    this->literalp_ = literalp;\n   }\n \n   tree result (void)\n@@ -1072,7 +1074,7 @@ class ExprVisitor : public Visitor\n     if (tb1->ty == Tstruct)\n       {\n \ttree t1 = build_expr (e->e1);\n-\ttree t2 = convert_for_assignment (build_expr (e->e2),\n+\ttree t2 = convert_for_assignment (build_expr (e->e2, false, true),\n \t\t\t\t\t  e->e2->type, e->e1->type);\n \tStructDeclaration *sd = tb1->isTypeStruct ()->sym;\n \n@@ -1101,11 +1103,22 @@ class ExprVisitor : public Visitor\n \t    tree init = NULL_TREE;\n \n \t    /* Fill any alignment holes in the struct using memset.  */\n-\t    if (e->op == TOKconstruct && !identity_compare_p (sd))\n-\t      init = build_memset_call (t1);\n+\t    if ((e->op == TOKconstruct\n+\t\t || (e->e2->op == TOKstructliteral && e->op == TOKblit))\n+\t\t&& (sd->isUnionDeclaration () || !identity_compare_p (sd)))\n+\t      {\n+\t\tt1 = stabilize_reference (t1);\n+\t\tinit = build_memset_call (t1);\n+\t      }\n \n-\t    tree result = build_assign (modifycode, t1, t2);\n-\t    this->result_ = compound_expr (init, result);\n+\t    /* Elide generating assignment if init is all zeroes.  */\n+\t    if (init != NULL_TREE && initializer_zerop (t2))\n+\t      this->result_ = compound_expr (init, t1);\n+\t    else\n+\t      {\n+\t\ttree result = build_assign (modifycode, t1, t2);\n+\t\tthis->result_ = compound_expr (init, result);\n+\t      }\n \t  }\n \n \treturn;\n@@ -1135,6 +1148,7 @@ class ExprVisitor : public Visitor\n \t   to call postblits, this assignment should call dtors on old\n \t   assigned elements.  */\n \tif ((!postblit && !destructor)\n+\t    || (e->op == TOKconstruct && e->e2->op == TOKarrayliteral)\n \t    || (e->op == TOKconstruct && !lvalue && postblit)\n \t    || (e->op == TOKblit || e->e1->type->size () == 0))\n \t  {\n@@ -1452,7 +1466,7 @@ class ExprVisitor : public Visitor\n   {\n     Type *ebtype = e->e1->type->toBasetype ();\n     Type *tbtype = e->to->toBasetype ();\n-    tree result = build_expr (e->e1, this->constp_);\n+    tree result = build_expr (e->e1, this->constp_, this->literalp_);\n \n     /* Just evaluate e1 if it has any side effects.  */\n     if (tbtype->ty == Tvoid)\n@@ -1702,7 +1716,7 @@ class ExprVisitor : public Visitor\n \texp = sle->sym;\n       }\n     else\n-      exp = build_expr (e->e1, this->constp_);\n+      exp = build_expr (e->e1, this->constp_, this->literalp_);\n \n     TREE_CONSTANT (exp) = 0;\n     this->result_ = d_convert (type, build_address (exp));\n@@ -2663,12 +2677,12 @@ class ExprVisitor : public Visitor\n     tree result = NULL_TREE;\n \n     if (e->e0)\n-      result = build_expr (e->e0);\n+      result = build_expr (e->e0, this->constp_, true);\n \n     for (size_t i = 0; i < e->exps->length; ++i)\n       {\n \tExpression *exp = (*e->exps)[i];\n-\tresult = compound_expr (result, build_expr (exp));\n+\tresult = compound_expr (result, build_expr (exp, this->constp_, true));\n       }\n \n     if (result == NULL_TREE)\n@@ -2717,7 +2731,7 @@ class ExprVisitor : public Visitor\n     for (size_t i = 0; i < e->elements->length; i++)\n       {\n \tExpression *expr = e->getElement (i);\n-\ttree value = build_expr (expr, this->constp_);\n+\ttree value = build_expr (expr, this->constp_, true);\n \n \t/* Only append nonzero values, the backend will zero out the rest\n \t   of the constructor as we don't set CONSTRUCTOR_NO_CLEARING.  */\n@@ -2765,6 +2779,22 @@ class ExprVisitor : public Visitor\n \tif (constant_p && initializer_constant_valid_p (ctor, TREE_TYPE (ctor)))\n \t  TREE_STATIC (ctor) = 1;\n \n+\t/* Use memset to fill any alignment holes in the array.  */\n+\tif (!this->constp_ && !this->literalp_)\n+\t  {\n+\t    TypeStruct *ts = etype->baseElemOf ()->isTypeStruct ();\n+\n+\t    if (ts != NULL && (!identity_compare_p (ts->sym)\n+\t\t\t       || ts->sym->isUnionDeclaration ()))\n+\t      {\n+\t\ttree var = build_local_temp (TREE_TYPE (ctor));\n+\t\ttree init = build_memset_call (var);\n+\t\t/* Evaluate memset() first, then any saved elements.  */\n+\t\tsaved_elems = compound_expr (init, saved_elems);\n+\t\tctor = compound_expr (modify_expr (var, ctor), var);\n+\t      }\n+\t  }\n+\n \tthis->result_ = compound_expr (saved_elems, d_convert (type, ctor));\n       }\n     else\n@@ -2885,7 +2915,8 @@ class ExprVisitor : public Visitor\n \tif (ftype->ty == Tsarray && !same_type_p (type, ftype))\n \t  {\n \t    /* Initialize a static array with a single element.  */\n-\t    tree elem = build_expr (exp, this->constp_);\n+\t    tree elem = build_expr (exp, this->constp_, true);\n+\t    saved_elems = compound_expr (saved_elems, stabilize_expr (&elem));\n \t    elem = d_save_expr (elem);\n \n \t    if (initializer_zerop (elem))\n@@ -2895,14 +2926,12 @@ class ExprVisitor : public Visitor\n \t  }\n \telse\n \t  {\n-\t    value = convert_expr (build_expr (exp, this->constp_),\n+\t    value = convert_expr (build_expr (exp, this->constp_, true),\n \t\t\t\t  exp->type, field->type);\n \t  }\n \n \t/* Split construction of values out of the constructor.  */\n-\ttree init = stabilize_expr (&value);\n-\tif (init != NULL_TREE)\n-\t  saved_elems = compound_expr (saved_elems, init);\n+\tsaved_elems = compound_expr (saved_elems, stabilize_expr (&value));\n \n \tCONSTRUCTOR_APPEND_ELT (ve, get_symbol_decl (field), value);\n       }\n@@ -2932,24 +2961,27 @@ class ExprVisitor : public Visitor\n \treturn;\n       }\n \n+    /* Construct the struct literal for run-time.  */\n     if (e->sym != NULL)\n       {\n+\t/* Store the result in a symbol to initialize the literal.  */\n \ttree var = build_deref (e->sym);\n \tctor = compound_expr (modify_expr (var, ctor), var);\n-\tthis->result_ = compound_expr (saved_elems, ctor);\n       }\n-    else if (e->sd->isUnionDeclaration ())\n+    else if (!this->literalp_)\n       {\n-\t/* For unions, use memset to fill holes in the object.  */\n-\ttree var = build_local_temp (TREE_TYPE (ctor));\n-\ttree init = build_memset_call (var);\n-\n-\tinit = compound_expr (init, saved_elems);\n-\tinit = compound_expr (init, modify_expr (var, ctor));\n-\tthis->result_  = compound_expr (init, var);\n+\t/* Use memset to fill any alignment holes in the object.  */\n+\tif (!identity_compare_p (e->sd) || e->sd->isUnionDeclaration ())\n+\t  {\n+\t    tree var = build_local_temp (TREE_TYPE (ctor));\n+\t    tree init = build_memset_call (var);\n+\t    /* Evaluate memset() first, then any saved element constructors.  */\n+\t    saved_elems = compound_expr (init, saved_elems);\n+\t    ctor = compound_expr (modify_expr (var, ctor), var);\n+\t  }\n       }\n-    else\n-      this->result_ = compound_expr (saved_elems, ctor);\n+\n+    this->result_ = compound_expr (saved_elems, ctor);\n   }\n \n   /* Build a null literal.  */\n@@ -2964,7 +2996,6 @@ class ExprVisitor : public Visitor\n   void visit (VectorExp *e)\n   {\n     tree type = build_ctype (e->type);\n-    tree etype = TREE_TYPE (type);\n \n     /* First handle array literal expressions.  */\n     if (e->e1->op == TOKarrayliteral)\n@@ -2977,7 +3008,8 @@ class ExprVisitor : public Visitor\n \tfor (size_t i = 0; i < ale->elements->length; i++)\n \t  {\n \t    Expression *expr = ale->getElement (i);\n-\t    tree value = d_convert (etype, build_expr (expr, this->constp_));\n+\t    tree value = d_convert (TREE_TYPE (type),\n+\t\t\t\t    build_expr (expr, this->constp_, true));\n \t    if (!CONSTANT_CLASS_P (value))\n \t      constant_p = false;\n \n@@ -2993,16 +3025,17 @@ class ExprVisitor : public Visitor\n     else\n       {\n \t/* Build constructor from single value.  */\n-\ttree val = d_convert (etype, build_expr (e->e1, this->constp_));\n-\tthis->result_ = build_vector_from_val (type, val);\n+\ttree value = d_convert (TREE_TYPE (type),\n+\t\t\t\tbuild_expr (e->e1, this->constp_, true));\n+\tthis->result_ = build_vector_from_val (type, value);\n       }\n   }\n \n   /* Build a static array representation of a vector expression.  */\n \n   void visit (VectorArrayExp *e)\n   {\n-    this->result_ = convert_expr (build_expr (e->e1, this->constp_),\n+    this->result_ = convert_expr (build_expr (e->e1, this->constp_, true),\n \t\t\t\t  e->e1->type, e->type);\n   }\n \n@@ -3057,12 +3090,13 @@ class ExprVisitor : public Visitor\n \n /* Main entry point for ExprVisitor interface to generate code for\n    the Expression AST class E.  If CONST_P is true, then E is a\n-   constant expression.  */\n+   constant expression.  If LITERAL_P is true, then E is a value used\n+   in the initialization of another literal.  */\n \n tree\n-build_expr (Expression *e, bool const_p)\n+build_expr (Expression *e, bool const_p, bool literal_p)\n {\n-  ExprVisitor v = ExprVisitor (const_p);\n+  ExprVisitor v = ExprVisitor (const_p, literal_p);\n   location_t saved_location = input_location;\n \n   input_location = make_location_t (e->loc);"}, {"sha": "c0e3ae024f5981ec6f1e73eebeb94e5efc614df5", "filename": "gcc/testsuite/gdc.dg/pr96153.d", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Fpr96153.d?ref=2ac51bdf63b0e17d1b9974f30303fb24e3cbc83d", "patch": "@@ -0,0 +1,31 @@\n+// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=96153\n+// { dg-additional-options \"-fmain -funittest\" }\n+// { dg-do run { target hw } }\n+// { dg-skip-if \"needs gcc/config.d\" { ! d_runtime } }\n+struct Checked(T, Hook)\n+{\n+    private T payload;\n+    Hook hook;\n+\n+    size_t toHash() const nothrow @safe\n+    {\n+        return hashOf(payload) ^ hashOf(hook);\n+    }\n+}\n+\n+Checked!(T, Hook) checked(Hook, T)(const T value)\n+{\n+    return Checked!(T, Hook)(value);\n+}\n+\n+@system unittest\n+{\n+    static struct Hook3\n+    {\n+        ulong var1 = ulong.max;\n+        uint var2 = uint.max;\n+    }\n+\n+    assert(checked!Hook3(12).toHash() != checked!Hook3(13).toHash());\n+    assert(checked!Hook3(13).toHash() == checked!Hook3(13).toHash());\n+}"}]}