{"sha": "5e03c1561679683d0c4c237f254600fe7ed10a31", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUwM2MxNTYxNjc5NjgzZDBjNGMyMzdmMjU0NjAwZmU3ZWQxMGEzMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-17T15:31:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-10-17T15:31:23Z"}, "message": "(gen_reload): Renamed from gen_input_reload.\n\n(emit_reload_insns): Delete SECONDARY_MEM_NEEDED case for input reloads that\ncan't happen and doesn't work.\nFix errors in use of reload_outxx insns.\nSimplify output reload code by using gen_reload.\n\nFrom-SVN: r8285", "tree": {"sha": "8e1416edbddac0e02e140abc438360fc95bc854e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e1416edbddac0e02e140abc438360fc95bc854e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e03c1561679683d0c4c237f254600fe7ed10a31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e03c1561679683d0c4c237f254600fe7ed10a31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e03c1561679683d0c4c237f254600fe7ed10a31", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e03c1561679683d0c4c237f254600fe7ed10a31/comments", "author": null, "committer": null, "parents": [{"sha": "94bba16f3d663636f869d88779c37c249a16a43a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94bba16f3d663636f869d88779c37c249a16a43a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94bba16f3d663636f869d88779c37c249a16a43a"}], "stats": {"total": 188, "additions": 51, "deletions": 137}, "files": [{"sha": "0a2ee20155c872789f4282519e3845a8eb796166", "filename": "gcc/reload1.c", "status": "modified", "additions": 51, "deletions": 137, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e03c1561679683d0c4c237f254600fe7ed10a31/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e03c1561679683d0c4c237f254600fe7ed10a31/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5e03c1561679683d0c4c237f254600fe7ed10a31", "patch": "@@ -6004,50 +6004,8 @@ emit_reload_insns (insn)\n \t\t    {\n \t\t      if (icode != CODE_FOR_nothing)\n \t\t\t{\n-\t\t\t  rtx pat;\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t\t\t  /* If we need a memory location to do the move, do\n-\t\t\t     it that way.  */\n-\t\t\t  if (GET_CODE (real_oldequiv) == REG\n-\t\t\t      && REGNO (real_oldequiv) < FIRST_PSEUDO_REGISTER\n-\t\t\t      && SECONDARY_MEMORY_NEEDED\n-\t\t\t      (REGNO_REG_CLASS (REGNO (real_oldequiv)),\n-\t\t\t       REGNO_REG_CLASS (REGNO (second_reload_reg)),\n-\t\t\t       GET_MODE (second_reload_reg)))\n-\t\t\t    {\n-\t\t\t      /* Get the memory to use and rewrite both\n-\t\t\t\t registers to its mode.  */\n-\t\t\t      rtx loc\n-\t\t\t\t= get_secondary_mem (real_oldequiv,\n-\t\t\t\t\t\t     GET_MODE (second_reload_reg),\n-\t\t\t\t\t\t     reload_opnum[j],\n-\t\t\t\t\t\t     reload_when_needed[j]);\n-\t\t\t      rtx tmp_reloadreg;\n-\n-\t\t\t      if (GET_MODE (loc)\n-\t\t\t\t  != GET_MODE (second_reload_reg))\n-\t\t\t\tsecond_reload_reg\n-\t\t\t\t  = gen_rtx (REG,\n-\t\t\t\t\t     GET_MODE (loc),\n-\t\t\t\t\t     REGNO (second_reload_reg));\n-\t\t\t  \n-\t\t\t      if (GET_MODE (loc) != GET_MODE (real_oldequiv))\n-\t\t\t\ttmp_reloadreg = gen_rtx (REG, GET_MODE (loc),\n-\t\t\t\t\t\t\t REGNO (real_oldequiv));\n-\t\t\t      else\n-\t\t\t\ttmp_reloadreg = real_oldequiv;\n-\t\t\t      \n-\t\t\t      emit_move_insn (loc, tmp_reloadreg);\n-\t\t\t      emit_move_insn (second_reload_reg, loc);\n-\t\t\t      pat = gen_move_insn (reloadreg, second_reload_reg);\n-\t\t\t      \n-\t\t\t    }\n-\t\t\t  else\n-#endif\n-\t\t\t    pat = GEN_FCN (icode) (reloadreg,\n-\t\t\t\t\t\t   real_oldequiv,\n-\t\t\t\t\t\t   second_reload_reg);\n-\t\t\t  emit_insn (pat);\n+\t\t\t  emit_insn (GEN_FCN (icode) (reloadreg, real_oldequiv,\n+\t\t\t\t\t\t      second_reload_reg));\n \t\t\t  special = 1;\n \t\t\t}\n \t\t      else\n@@ -6067,9 +6025,9 @@ emit_reload_insns (insn)\n \t\t\t\t\t   third_reload_reg)));\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    gen_input_reload (second_reload_reg, oldequiv,\n-\t\t\t\t\t      reload_opnum[j],\n-\t\t\t\t\t      reload_when_needed[j]);\n+\t\t\t    gen_reload (second_reload_reg, oldequiv,\n+\t\t\t\t\treload_opnum[j],\n+\t\t\t\t\treload_when_needed[j]);\n \n \t\t\t  oldequiv = second_reload_reg;\n \t\t\t}\n@@ -6078,8 +6036,8 @@ emit_reload_insns (insn)\n #endif\n \n \t      if (! special && ! rtx_equal_p (reloadreg, oldequiv))\n-\t\tgen_input_reload (reloadreg, oldequiv, reload_opnum[j],\n-\t\t\t\t  reload_when_needed[j]);\n+\t\tgen_reload (reloadreg, oldequiv, reload_opnum[j],\n+\t\t\t    reload_when_needed[j]);\n \n #if defined(SECONDARY_INPUT_RELOAD_CLASS) && defined(PRESERVE_DEATH_INFO_REGNO_P)\n \t      /* We may have to make a REG_DEAD note for the secondary reload\n@@ -6316,7 +6274,7 @@ emit_reload_insns (insn)\n #ifdef SECONDARY_OUTPUT_RELOAD_CLASS\n \n \t  /* If we need two reload regs, set RELOADREG to the intermediate\n-\t     one, since it will be stored into OUT.  We might need a secondary\n+\t     one, since it will be stored into OLD.  We might need a secondary\n \t     register only for an input reload, so check again here.  */\n \n \t  if (reload_secondary_out_reload[j] >= 0)\n@@ -6346,10 +6304,10 @@ emit_reload_insns (insn)\n \t\t    {\n \t\t      /* See if we need both a scratch and intermediate reload\n \t\t\t register.  */\n+\n \t\t      int secondary_reload = reload_secondary_out_reload[j];\n \t\t      enum insn_code tertiary_icode\n \t\t\t= reload_secondary_out_icode[secondary_reload];\n-\t\t      rtx pat;\n \n \t\t      if (GET_MODE (reloadreg) != mode)\n \t\t\treloadreg = gen_rtx (REG, mode, REGNO (reloadreg));\n@@ -6358,79 +6316,33 @@ emit_reload_insns (insn)\n \t\t\t{\n \t\t\t  rtx third_reloadreg\n \t\t\t    = reload_reg_rtx[reload_secondary_out_reload[secondary_reload]];\n-\t\t\t  pat = (GEN_FCN (tertiary_icode)\n-\t\t\t\t (reloadreg, second_reloadreg, third_reloadreg));\n-\t\t\t}\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t\t      /* If we need a memory location to do the move, do it that way.  */\n-\t\t      else if (GET_CODE (reloadreg) == REG\n-\t\t\t       && REGNO (reloadreg) < FIRST_PSEUDO_REGISTER\n-\t\t\t       && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (reloadreg)),\n-\t\t\t\t\t   REGNO_REG_CLASS (REGNO (second_reloadreg)),\n-\t\t\t\t\t   GET_MODE (second_reloadreg)))\n-\t\t\t{\n-\t\t\t  /* Get the memory to use and rewrite both registers\n-\t\t\t     to its mode.  */\n-\t\t\t  rtx loc\n-\t\t\t    = get_secondary_mem (reloadreg,\n-\t\t\t\t\t\t GET_MODE (second_reloadreg),\n-\t\t\t\t\t\t reload_opnum[j],\n-\t\t\t\t\t\t reload_when_needed[j]);\n-\t\t\t  rtx tmp_reloadreg;\n-\t\t\t    \n-\t\t\t  if (GET_MODE (loc) != GET_MODE (second_reloadreg))\n-\t\t\t    second_reloadreg = gen_rtx (REG, GET_MODE (loc),\n-\t\t\t\t\t\t\tREGNO (second_reloadreg));\n-\t\t\t  \n-\t\t\t  if (GET_MODE (loc) != GET_MODE (reloadreg))\n-\t\t\t    tmp_reloadreg = gen_rtx (REG, GET_MODE (loc),\n-\t\t\t\t\t\t     REGNO (reloadreg));\n-\t\t\t  else\n-\t\t\t    tmp_reloadreg = reloadreg;\n-\t\t\t  \n-\t\t\t  emit_move_insn (loc, second_reloadreg);\n-\t\t\t  pat = gen_move_insn (tmp_reloadreg, loc);\n+\n+\t\t\t  /* Copy primary reload reg to secondary reload reg.\n+\t\t\t     (Note that these have been swapped above, then\n+\t\t\t     secondary reload reg to OLD using our insn.  */\n+\n+\t\t\t  gen_reload (reloadreg, second_reloadreg,\n+\t\t\t\t      reload_opnum[j], reload_when_needed[j]);\n+\t\t\t  emit_insn ((GEN_FCN (tertiary_icode)\n+\t\t\t\t      (real_old, reloadreg, third_reloadreg)));\n+\t\t\t  special = 1;\n \t\t\t}\n-#endif\n+\n \t\t      else\n-\t\t\tpat = gen_move_insn (reloadreg, second_reloadreg);\n+\t\t\t/* Copy between the reload regs here and then to\n+\t\t\t   OUT later.  */\n \n-\t\t      emit_insn (pat);\n+\t\t\tgen_reload (reloadreg, second_reloadreg,\n+\t\t\t\t    reload_opnum[j], reload_when_needed[j]);\n \t\t    }\n \t\t}\n \t    }\n #endif\n \n \t  /* Output the last reload insn.  */\n \t  if (! special)\n-\t    {\n-#ifdef SECONDARY_MEMORY_NEEDED\n-\t      /* If we need a memory location to do the move, do it that way.  */\n-\t      if (GET_CODE (old) == REG && REGNO (old) < FIRST_PSEUDO_REGISTER\n-\t\t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (old)),\n-\t\t\t\t\t      REGNO_REG_CLASS (REGNO (reloadreg)),\n-\t\t\t\t\t      GET_MODE (reloadreg)))\n-\t\t{\n-\t\t  /* Get the memory to use and rewrite both registers to\n-\t\t     its mode.  */\n-\t\t  rtx loc = get_secondary_mem (old, GET_MODE (reloadreg),\n-\t\t\t\t\t       reload_opnum[j],\n-\t\t\t\t\t       reload_when_needed[j]);\n-\n-\t\t  if (GET_MODE (loc) != GET_MODE (reloadreg))\n-\t\t    reloadreg = gen_rtx (REG, GET_MODE (loc),\n-\t\t\t\t\t REGNO (reloadreg));\n-\n-\t\t  if (GET_MODE (loc) != GET_MODE (old))\n-\t\t    old = gen_rtx (REG, GET_MODE (loc), REGNO (old));\n-\n-\t\t  emit_insn (gen_move_insn (loc, reloadreg));\n-\t\t  emit_insn (gen_move_insn (old, loc));\n-\t\t}\n-\t      else\n-#endif\n-\t\temit_insn (gen_move_insn (old, reloadreg));\n-\t    }\n+\t    gen_reload (old, reloadreg, reload_opnum[j],\n+\t\t\treload_when_needed[j]);\n \n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n \t  /* If final will look at death notes for this reg,\n@@ -6694,14 +6606,15 @@ emit_reload_insns (insn)\n     }\n }\n \f\n-/* Emit code to perform an input reload of IN to RELOADREG.  IN is from\n-   operand OPNUM with reload type TYPE. \n+/* Emit code to perform a reload from IN (which may be a reload register) to\n+   OUT (which may also be a reload register).  IN or OUT is from operand\n+   OPNUM with reload type TYPE. \n \n    Returns first insn emitted.  */\n \n rtx\n-gen_input_reload (reloadreg, in, opnum, type)\n-     rtx reloadreg;\n+gen_reload (out, in, opnum, type)\n+     rtx out;\n      rtx in;\n      int opnum;\n      enum reload_type type;\n@@ -6768,13 +6681,13 @@ gen_input_reload (reloadreg, in, opnum, type)\n \t it will be A = A + B as constrain_operands expects. */\n \n       if (GET_CODE (XEXP (in, 1)) == REG\n-\t  && REGNO (reloadreg) == REGNO (XEXP (in, 1)))\n+\t  && REGNO (out) == REGNO (XEXP (in, 1)))\n \ttem = op0, op0 = op1, op1 = tem;\n \n       if (op0 != XEXP (in, 0) || op1 != XEXP (in, 1))\n \tin = gen_rtx (PLUS, GET_MODE (in), op0, op1);\n \n-      insn = emit_insn (gen_rtx (SET, VOIDmode, reloadreg, in));\n+      insn = emit_insn (gen_rtx (SET, VOIDmode, out, in));\n       code = recog_memoized (insn);\n \n       if (code >= 0)\n@@ -6803,16 +6716,16 @@ gen_input_reload (reloadreg, in, opnum, type)\n \t      && REGNO (op1) >= FIRST_PSEUDO_REGISTER))\n \ttem = op0, op0 = op1, op1 = tem;\n \n-      emit_insn (gen_move_insn (reloadreg, op0));\n+      emit_insn (gen_move_insn (out, op0));\n \n-      /* If OP0 and OP1 are the same, we can use RELOADREG for OP1.\n+      /* If OP0 and OP1 are the same, we can use OUT for OP1.\n \t This fixes a problem on the 32K where the stack pointer cannot\n \t be used as an operand of an add insn.  */\n \n       if (rtx_equal_p (op0, op1))\n-\top1 = reloadreg;\n+\top1 = out;\n \n-      insn = emit_insn (gen_add2_insn (reloadreg, op1));\n+      insn = emit_insn (gen_add2_insn (out, op1));\n \n       /* If that failed, copy the address register to the reload register.\n \t Then add the constant to the reload register. */\n@@ -6831,43 +6744,44 @@ gen_input_reload (reloadreg, in, opnum, type)\n \n       delete_insns_since (last);\n \n-      emit_insn (gen_move_insn (reloadreg, op1));\n-      emit_insn (gen_add2_insn (reloadreg, op0));\n+      emit_insn (gen_move_insn (out, op1));\n+      emit_insn (gen_add2_insn (out, op0));\n     }\n \n #ifdef SECONDARY_MEMORY_NEEDED\n   /* If we need a memory location to do the move, do it that way.  */\n   else if (GET_CODE (in) == REG && REGNO (in) < FIRST_PSEUDO_REGISTER\n+\t   && GET_CODE (out) == REG && REGNO (out) < FIRST_PSEUDO_REGISTER\n \t   && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (in)),\n-\t\t\t\t       REGNO_REG_CLASS (REGNO (reloadreg)),\n-\t\t\t\t       GET_MODE (reloadreg)))\n+\t\t\t\t       REGNO_REG_CLASS (REGNO (out)),\n+\t\t\t\t       GET_MODE (out)))\n     {\n       /* Get the memory to use and rewrite both registers to its mode.  */\n-      rtx loc = get_secondary_mem (in, GET_MODE (reloadreg), opnum, type);\n+      rtx loc = get_secondary_mem (in, GET_MODE (out), opnum, type);\n \n-      if (GET_MODE (loc) != GET_MODE (reloadreg))\n-\treloadreg = gen_rtx (REG, GET_MODE (loc), REGNO (reloadreg));\n+      if (GET_MODE (loc) != GET_MODE (out))\n+\tout = gen_rtx (REG, GET_MODE (loc), REGNO (out));\n \n       if (GET_MODE (loc) != GET_MODE (in))\n \tin = gen_rtx (REG, GET_MODE (loc), REGNO (in));\n \n       emit_insn (gen_move_insn (loc, in));\n-      emit_insn (gen_move_insn (reloadreg, loc));\n+      emit_insn (gen_move_insn (out, loc));\n     }\n #endif\n \n   /* If IN is a simple operand, use gen_move_insn.  */\n   else if (GET_RTX_CLASS (GET_CODE (in)) == 'o' || GET_CODE (in) == SUBREG)\n-    emit_insn (gen_move_insn (reloadreg, in));\n+    emit_insn (gen_move_insn (out, in));\n \n #ifdef HAVE_reload_load_address\n   else if (HAVE_reload_load_address)\n-    emit_insn (gen_reload_load_address (reloadreg, in));\n+    emit_insn (gen_reload_load_address (out, in));\n #endif\n \n-  /* Otherwise, just write (set REGLOADREG IN) and hope for the best.  */\n+  /* Otherwise, just write (set OUT IN) and hope for the best.  */\n   else\n-    emit_insn (gen_rtx (SET, VOIDmode, reloadreg, in));\n+    emit_insn (gen_rtx (SET, VOIDmode, out, in));\n \n   /* Return the first insn emitted.\n      We can not just return get_last_insn, because there may have\n@@ -7014,7 +6928,7 @@ inc_for_reload (reloadreg, value, inc_amount)\n     emit_insn (gen_move_insn (reloadreg, incloc));\n \n   /* See if we can directly increment INCLOC.  Use a method similar to that\n-     in gen_input_reload.  */\n+     in gen_reload.  */\n \n   last = get_last_insn ();\n   add_insn = emit_insn (gen_rtx (SET, VOIDmode, incloc,"}]}