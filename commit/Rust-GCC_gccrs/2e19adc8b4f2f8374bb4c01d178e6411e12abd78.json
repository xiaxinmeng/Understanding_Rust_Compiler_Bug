{"sha": "2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUxOWFkYzhiNGYyZjgzNzRiYjRjMDFkMTc4ZTY0MTFlMTJhYmQ3OA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-04-27T14:09:55Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-04-27T14:09:55Z"}, "message": "[AArch64] Fix for gcc-7 regression PR 80530\n\n\nThis patch fixes the regression caused by the changes to add square root\nestimation when compiling for xgene-1 or exynos-m1 targets.\n\nThe issue is that the expand path for the reciprocal estimate square\nroot pattern assumes that pattern cannot fail once it has been decided\nthat this expansion path is available, but because the logic deep inside\naarch64_emit_approx_sqrt() differs from use_rsqrt_p() the two disagree\nas to what is safe.\n\nThis patch refactors the logic to ensure that we cannot unknowingly make\ndifferent choices here.\n\n\tPR target/80530\n\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Ensure\n\tthat the logic for permitting reciprocal estimates matches that\n\tin use_rsqrt_p.\n\nFrom-SVN: r247340", "tree": {"sha": "13bc8b456051f0d15d9f67335955c31dfa565082", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13bc8b456051f0d15d9f67335955c31dfa565082"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e19adc8b4f2f8374bb4c01d178e6411e12abd78/comments", "author": null, "committer": null, "parents": [{"sha": "a96eb6f2d7efc24f1be6a3cca2b7437fc6059779", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96eb6f2d7efc24f1be6a3cca2b7437fc6059779", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96eb6f2d7efc24f1be6a3cca2b7437fc6059779"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "526a91dc9f6817b948418b87f87709d311e8dea1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e19adc8b4f2f8374bb4c01d178e6411e12abd78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e19adc8b4f2f8374bb4c01d178e6411e12abd78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "patch": "@@ -1,3 +1,10 @@\n+2017-04-27  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/80530\n+\t* config/aarch64/aarch64.c (aarch64_emit_approx_sqrt): Ensure\n+\tthat the logic for permitting reciprocal estimates matches that\n+\tin use_rsqrt_p.\n+\n 2017-04-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/80534"}, {"sha": "b760905ce3bb374d49153a68dff7948213d853e0", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e19adc8b4f2f8374bb4c01d178e6411e12abd78/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e19adc8b4f2f8374bb4c01d178e6411e12abd78/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=2e19adc8b4f2f8374bb4c01d178e6411e12abd78", "patch": "@@ -7925,33 +7925,40 @@ aarch64_emit_approx_sqrt (rtx dst, rtx src, bool recp)\n   machine_mode mode = GET_MODE (dst);\n \n   if (GET_MODE_INNER (mode) == HFmode)\n-    return false;\n+    {\n+      gcc_assert (!recp);\n+      return false;\n+    }\n \n-  machine_mode mmsk = mode_for_vector\n-\t\t        (int_mode_for_mode (GET_MODE_INNER (mode)),\n-\t\t\t GET_MODE_NUNITS (mode));\n-  bool use_approx_sqrt_p = (!recp\n-\t\t\t    && (flag_mlow_precision_sqrt\n-\t\t\t        || (aarch64_tune_params.approx_modes->sqrt\n-\t\t\t\t    & AARCH64_APPROX_MODE (mode))));\n-  bool use_approx_rsqrt_p = (recp\n-\t\t\t     && (flag_mrecip_low_precision_sqrt\n-\t\t\t\t || (aarch64_tune_params.approx_modes->recip_sqrt\n-\t\t\t\t     & AARCH64_APPROX_MODE (mode))));\n+  machine_mode mmsk\n+    = mode_for_vector (int_mode_for_mode (GET_MODE_INNER (mode)),\n+\t\t       GET_MODE_NUNITS (mode));\n+  if (!recp)\n+    {\n+      if (!(flag_mlow_precision_sqrt\n+\t    || (aarch64_tune_params.approx_modes->sqrt\n+\t\t& AARCH64_APPROX_MODE (mode))))\n+\treturn false;\n+\n+      if (flag_finite_math_only\n+\t  || flag_trapping_math\n+\t  || !flag_unsafe_math_optimizations\n+\t  || optimize_function_for_size_p (cfun))\n+\treturn false;\n+    }\n+  else\n+    /* Caller assumes we cannot fail.  */\n+    gcc_assert (use_rsqrt_p (mode));\n \n-  if (!flag_finite_math_only\n-      || flag_trapping_math\n-      || !flag_unsafe_math_optimizations\n-      || !(use_approx_sqrt_p || use_approx_rsqrt_p)\n-      || optimize_function_for_size_p (cfun))\n-    return false;\n \n   rtx xmsk = gen_reg_rtx (mmsk);\n   if (!recp)\n-    /* When calculating the approximate square root, compare the argument with\n-       0.0 and create a mask.  */\n-    emit_insn (gen_rtx_SET (xmsk, gen_rtx_NEG (mmsk, gen_rtx_EQ (mmsk, src,\n-\t\t\t\t\t\t\t  CONST0_RTX (mode)))));\n+    /* When calculating the approximate square root, compare the\n+       argument with 0.0 and create a mask.  */\n+    emit_insn (gen_rtx_SET (xmsk,\n+\t\t\t    gen_rtx_NEG (mmsk,\n+\t\t\t\t\t gen_rtx_EQ (mmsk, src,\n+\t\t\t\t\t\t     CONST0_RTX (mode)))));\n \n   /* Estimate the approximate reciprocal square root.  */\n   rtx xdst = gen_reg_rtx (mode);"}]}