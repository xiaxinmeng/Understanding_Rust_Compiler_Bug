{"sha": "ece0ca60b808b326b3163eed25d784801a38e086", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWNlMGNhNjBiODA4YjMyNmIzMTYzZWVkMjVkNzg0ODAxYTM4ZTA4Ng==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-17T04:12:51Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-17T04:12:51Z"}, "message": "Add #if 0 around use of DECL_ABSTRACT_VIRTUAL_P.\n\n(pure_or_virtual_attribute):\nAdd #if 0 around use of DECL_ABSTRACT_VIRTUAL_P.\n\n(BLOCK_INLINE_FUNCTION):  Obsolete definition deleted.\n(block_ultimate_origin):  New function.\n(output_block): Local `have_significant_locals' renamed to `must_output_die'.\n(output_block): Handle abstract & concrete blocks in inline functions.\n(output_decls_for_scope): Don't bump `next_block_number' for abstract blocks.\n\nFrom-SVN: r1601", "tree": {"sha": "ff233a799c703a3fa5ff5f8514eafb90606e7fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff233a799c703a3fa5ff5f8514eafb90606e7fbf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ece0ca60b808b326b3163eed25d784801a38e086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece0ca60b808b326b3163eed25d784801a38e086", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece0ca60b808b326b3163eed25d784801a38e086", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece0ca60b808b326b3163eed25d784801a38e086/comments", "author": null, "committer": null, "parents": [{"sha": "815781420c8616442065777bb0dfea57b2b94f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815781420c8616442065777bb0dfea57b2b94f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815781420c8616442065777bb0dfea57b2b94f06"}], "stats": {"total": 121, "additions": 92, "deletions": 29}, "files": [{"sha": "a6d80f058db5baeccc0b7200cc92bcdd8498dec5", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 92, "deletions": 29, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ece0ca60b808b326b3163eed25d784801a38e086/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ece0ca60b808b326b3163eed25d784801a38e086/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=ece0ca60b808b326b3163eed25d784801a38e086", "patch": "@@ -80,13 +80,6 @@ extern char *rindex ();\n #define ASM_COMMENT_START \";#\"\n #endif\n \n-/* Define a macro which, when given a pointer to some BLOCK node, returns\n-   a pointer to the FUNCTION_DECL node from which the given BLOCK node\n-   was instantiated (as an inline expansion).  This macro needs to be\n-   defined properly in tree.h, however for the moment, we just fake it.  */\n-\n-#define BLOCK_INLINE_FUNCTION(block) 0\n-\n /* Define a macro which returns non-zero for any tagged type which is\n    used (directly or indirectly) in the specification of either some\n    function's return type or some formal parameter of some function.\n@@ -1010,6 +1003,37 @@ decl_ultimate_origin (decl)\n     }\n }\n \n+/* Determine the \"ultimate origin\" of a block.  The block may be an\n+   inlined instance of an inlined instance of a block which is local\n+   to an inline function, so we have to trace all of the way back\n+   through the origin chain to find out what sort of node actually\n+   served as the original seed for the given block.  */\n+\n+static tree\n+block_ultimate_origin (block)\n+     register tree block;\n+{\n+  register tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n+\n+  if (immediate_origin == NULL)\n+    return NULL;\n+  else\n+    {\n+      register tree ret_val;\n+      register tree lookahead = immediate_origin;\n+\n+      do\n+\t{\n+\t  ret_val = lookahead;\n+\t  lookahead = (TREE_CODE (ret_val) == BLOCK)\n+\t\t       ? BLOCK_ABSTRACT_ORIGIN (ret_val)\n+\t\t       : NULL;\n+\t}\n+      while (lookahead != NULL && lookahead != ret_val);\n+      return ret_val;\n+    }\n+}\n+\n static void\n output_unsigned_leb128 (value)\n      register unsigned long value;\n@@ -2611,9 +2635,11 @@ pure_or_virtual_attribute (func_decl)\n {\n   if (DECL_VIRTUAL_P (func_decl))\n     {\n+#if 0 /* DECL_ABSTRACT_VIRTUAL_P is C++-specific.  */\n       if (DECL_ABSTRACT_VIRTUAL_P (func_decl))\n         ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);\n       else\n+#endif\n         ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_virtual);\n       ASM_OUTPUT_DWARF_STRING (asm_out_file, \"\");\n     }\n@@ -3985,33 +4011,69 @@ static void\n output_block (stmt)\n     register tree stmt;\n {\n-  register int have_significant_locals = 0;\n+  register int must_output_die = 0;\n+  register tree origin;\n+  register enum tree_code origin_code;\n \n   /* Ignore blocks never really used to make RTL.  */\n \n   if (! stmt || ! TREE_USED (stmt))\n     return;\n \n-  /* Determine if this block contains any \"significant\" local declarations\n-     which we need to output DIEs for.  */\n+  /* Determine the \"ultimate origin\" of this block.  This block may be an\n+     inlined instance of an inlined instance of inline function, so we\n+     have to trace all of the way back through the origin chain to find\n+     out what sort of node actually served as the original seed for the\n+     creation of the current block.  */\n \n-  if (BLOCK_INLINE_FUNCTION (stmt))\n-    /* The outer scopes for inlinings *must* always be represented.  */\n-    have_significant_locals = 1;\n-  else\n-    if (debug_info_level > DINFO_LEVEL_TERSE)\n-      have_significant_locals = (BLOCK_VARS (stmt) != NULL);\n-    else\n-      {\n-        register tree decl;\n+  origin = block_ultimate_origin (stmt);\n+  origin_code = (origin != NULL) ? TREE_CODE (origin) : ERROR_MARK;\n \n-\tfor (decl = BLOCK_VARS (stmt); decl; decl = TREE_CHAIN (decl))\n-\t  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n+  /* Determine if we need to output any Dwarf DIEs at all to represent this\n+     block.  */\n+\n+  if (origin_code == FUNCTION_DECL)\n+    /* The outer scopes for inlinings *must* always be represented.  We\n+       generate TAG_inlined_subroutine DIEs for them.  (See below.)  */\n+    must_output_die = 1;\n+  else\n+    {\n+      /* In the case where the current block represents an inlining of the\n+\t \"body block\" of an inline function, we must *NOT* output any DIE\n+\t for this block because we have already output a DIE to represent\n+\t the whole inlined function scope and the \"body block\" of any\n+\t function doesn't really represent a different scope according to\n+\t ANSI C rules.  So we check here to make sure that this block does\n+\t not represent a \"body block inlining\" before trying to set the\n+\t `must_output_die' flag.  */\n+\n+      if (origin != NULL\n+\t  && origin_code == BLOCK\n+\t  && ! is_body_block (origin))\n+\t{\n+\t  /* Determine if this block directly contains any \"significant\"\n+\t     local declarations which we will need to output DIEs for.  */\n+\n+\t  if (debug_info_level > DINFO_LEVEL_TERSE)\n+\t    /* We are not in terse mode so *any* local declaration counts\n+\t       as being a \"significant\" one.  */\n+\t    must_output_die = (BLOCK_VARS (stmt) != NULL);\n+\t  else\n \t    {\n-\t      have_significant_locals = 1;\n-\t      break;\n+\t      register tree decl;\n+\n+\t      /* We are in terse mode, so only local (nested) function\n+\t         definitions count as \"significant\" local declarations.  */\n+\n+\t      for (decl = BLOCK_VARS (stmt); decl; decl = TREE_CHAIN (decl))\n+\t\tif (TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n+\t\t  {\n+\t\t    must_output_die = 1;\n+\t\t    break;\n+\t\t  }\n \t    }\n-      }\n+\t}\n+    }\n \n   /* It would be a waste of space to generate a Dwarf TAG_lexical_block\n      DIE for any block which contains no significant local declarations\n@@ -4021,11 +4083,11 @@ output_block (stmt)\n      a \"significant\" local declaration gets restricted to include only\n      inlined function instances and local (nested) function definitions.  */\n \n-  if (have_significant_locals)\n+  if (must_output_die)\n     {\n-      output_die (BLOCK_INLINE_FUNCTION (stmt)\n-\t\t\t? output_inlined_subroutine_die\n-\t\t\t: output_lexical_block_die,\n+      output_die ((origin_code == FUNCTION_DECL)\n+\t\t    ? output_inlined_subroutine_die\n+\t\t    : output_lexical_block_die,\n \t\t  stmt);\n       output_decls_for_scope (stmt);\n       end_sibling_chain ();\n@@ -4046,7 +4108,8 @@ output_decls_for_scope (stmt)\n   if (! stmt || ! TREE_USED (stmt))\n     return;\n \n-  next_block_number++;\n+  if (! BLOCK_ABSTRACT (stmt))\n+    next_block_number++;\n \n   /* Output the DIEs to represent all of the data objects, functions,\n      typedefs, and tagged types declared directly within this block"}]}