{"sha": "89e037d0e36654e84823c47980ef19dc0f77b8ce", "node_id": "C_kwDOANBUbNoAKDg5ZTAzN2QwZTM2NjU0ZTg0ODIzYzQ3OTgwZWYxOWRjMGY3N2I4Y2U", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-05-18T10:17:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-02T09:06:44Z"}, "message": "[Ada] Get rid of secondary stack for most calls returning tagged types\n\nThis eliminates the use of the secondary stack to return specific tagged\ntypes from functions in calls that are not dispatching on result, which\ncomprises returning controlled types, by introducing thunks whose only\npurpose is to move the result from the primary to the secondary stack\nfor primitive functions that are controlling on result, and referencing\nthem in the dispatch table in lieu of the primitive functions.\n\nThe implementation reuses the existing machinery of interface thunks and\nthus creates another kind of thunks, secondary stack thunks, which only\nperform a call to the primitive function and return the result.\n\ngcc/ada/\n\n\t* einfo.ads (Has_Controlling_Result): Document new usage.\n\t(Is_Thunk): Document secondary stack thunks.\n\t(Returns_By_Ref): Adjust.\n\t* exp_ch6.adb (Caller_Known_Size): Return true for tagged types.\n\t(Expand_N_Extended_Return_Statement): Do not call Set_By_Ref.\n\t(Expand_Simple_Function_Return): For a BIP return with an Alloc_Form\n\tparameter, mark the node as returning on the secondary stack.\n\tReplace call to Is_Limited_Interface with Is_Limited_View.  Deal wit\n\tsecondary stack thunks.  Do not call Set_By_Ref.  Optimize the case\n\tof a call to a function whose type also needs finalization.\n\t(Needs_BIP_Task_Actuals): Replace Thunk_Entity with Thunk_Target.\n\t(Needs_BIP_Finalization_Master): Cosmetic fixes.\n\t(Needs_BIP_Alloc_Form): Check No_Secondary_Stack restriction and\n\treturn true for tagged types.\n\t* exp_ch7.adb (Transient Scope Management): Update description.\n\t* exp_disp.adb (Expand_Dispatching_Call): Always set Returns_By_Ref\n\ton designated type if the call is dispatching on result.  Tidy up.\n\t(Expand_Interface_Thunk): Change type of Thunk_Code from Node_Id to\n\tList_Id.  Change type of local variables from Node_Id to Entity_Id.\n\tPropagate Aliased_Present flag to create the formals and explicitly\n\tset Has_Controlling_Result to False.  Build a secondary stack thunk\n\tif necessary in the function case.\n\t(Expand_Secondary_Stack_Thunk): New function.\n\t(Make_Secondary_DT): Build secondary stack thunks if necessary.\n\t(Make_DT): Likewise.\n\t(Register_Predefined_Primitive): Likewise.\n\t(Register_Primitive): Likewise.\n\t* exp_util.ads (Is_Secondary_Stack_Thunk): Declare.\n\t(Thunk_Target): Likewise.\n\t* exp_util.adb (Is_Secondary_Stack_Thunk): New function.\n\t(Thunk_Target): Likewise.\n\t* fe.h (Is_Secondary_Stack_Thunk): Declare.\n\t(Thunk_Target): Likewise.\n\t* gen_il-fields.ads (Opt_Field_Enum): Remove By_Ref.\n\t* gen_il-gen-gen_nodes.adb (N_Simple_Return_Statement): Likewise.\n\t(N_Extended_Return_Statement): Likewise.\n\t* sem_ch6.adb (Analyze_Subprogram_Specification): Skip check for\n\tabstract return type in the thunk case.\n\t(Create_Extra_Formals): Replace Thunk_Entity with Thunk_Target.\n\t* sem_disp.adb (Check_Controlling_Formals): Skip in the thunk case.\n\t* sem_util.adb: Add use and with clauses for Exp_Ch6.\n\t(Compute_Returns_By_Ref): Do not process procedures and only set\n\tthe flag for direct return by reference.\n\t(Needs_Secondary_Stack): Do not return true for specific tagged\n\ttypes and adjust comments accordingly.\n\t* sinfo.ads (By_Ref): Delete.\n\t(N_Simple_Return_Statement): Remove By_Ref.\n\t(N_Extended_Return_Statement): Likewise.\n\t* gcc-interface/ada-tree.h (TYPE_RETURN_UNCONSTRAINED_P): Delete.\n\t* gcc-interface/decl.cc (gnat_to_gnu_subprog_type): Do not use it.\n\tReturn by direct reference if the return type needs the secondary\n\tstack as well as for secondary stack thunks.\n\t* gcc-interface/gigi.h (fntype_same_flags_p): Remove parameter.\n\t* gcc-interface/misc.cc (gnat_type_hash_eq): Adjust to above change.\n\t* gcc-interface/trans.cc (finalize_nrv): Replace test on\n\tTYPE_RETURN_UNCONSTRAINED_P with TYPE_RETURN_BY_DIRECT_REF_P.\n\t(Subprogram_Body_to_gnu): Do not call maybe_make_gnu_thunk for\n\tsecondary stack thunks.\n\t(Call_to_gnu): Do not test TYPE_RETURN_UNCONSTRAINED_P.\n\t(gnat_to_gnu) <N_Simple_Return_Statement>: In the return by direct\n\treference case, test for the presence of Storage_Pool on the node\n\tto build an allocator.\n\t(maybe_make_gnu_thunk): Deal with Thunk_Entity and Thunk_Target.\n\t* gcc-interface/utils.cc (fntype_same_flags_p): Remove parameter.", "tree": {"sha": "a46d60ed190c91c3cdb0691d81578acd523e34d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a46d60ed190c91c3cdb0691d81578acd523e34d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e037d0e36654e84823c47980ef19dc0f77b8ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e037d0e36654e84823c47980ef19dc0f77b8ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e037d0e36654e84823c47980ef19dc0f77b8ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e037d0e36654e84823c47980ef19dc0f77b8ce/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7c1d59b367431c350d91c1cdb460fb1bb6d6bc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c1d59b367431c350d91c1cdb460fb1bb6d6bc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c1d59b367431c350d91c1cdb460fb1bb6d6bc6"}], "stats": {"total": 857, "additions": 558, "deletions": 299}, "files": [{"sha": "c5843f2903f9286442f8f61d08b338c3559d873f", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -1576,7 +1576,8 @@ package Einfo is\n \n --    Has_Controlling_Result\n --       Defined in E_Function entities. Set if the function is a primitive\n---       function of a tagged type which can dispatch on result.\n+--       function of a tagged type which can dispatch on result. Also set on\n+--       secondary stack thunks built for such a primitive function.\n \n --    Has_Convention_Pragma\n --       Defined in all entities. Set for an entity for which a valid pragma\n@@ -3322,17 +3323,29 @@ package Einfo is\n --       Applies to all entities. True for task types and subtypes\n \n --    Is_Thunk\n---       Defined in all entities. True for subprograms that are thunks: that is\n---       small subprograms built by the expander for tagged types that cover\n---       interface types. As part of the runtime call to an interface, thunks\n+--       Defined in all entities. True for subprograms that are thunks, that is\n+--       small subprograms built by the expander for particular tagged types.\n+--       There are two different kinds of thunk: interface thunk and secondary\n+--       stack thunk. Interface thunks are built for tagged types that cover\n+--       interface types. As part of the runtime call to an interface, they\n --       displace the pointer to the object (pointer named \"this\" in the C++\n --       terminology) from a secondary dispatch table to the primary dispatch\n --       table associated with a given tagged type; if the thunk is a function\n --       that returns an object which covers an interface type then the thunk\n --       displaces the pointer to the object from the primary dispatch table to\n---       the secondary dispatch table associated with the interface type. Set\n---       by Expand_Interface_Thunk and used by Expand_Call to handle extra\n---       actuals associated with accessibility level.\n+--       the secondary dispatch table associated with the interface type.\n+\n+--       Secondary stack thunks are built for tagged types that do not need to\n+--       be returned on the secondary stack but have primitive functions which\n+--       can dispatch on result. In this case, dispatching calls made to these\n+--       primitive functions nevertheless need to return on the secondary stack\n+--       and a thunk is built to move the result from the primary stack onto\n+--       the secondary stack on return from the primitive function. The flag\n+--       Has_Controlling_Result is set on secondary stack thunks but not on\n+--       interface thunks.\n+\n+--       Thunks may be chained in a single way: an interface thunk may point to\n+--       a secondary stack thunk, which points to the final thunk target.\n \n --    Is_Trivial_Subprogram\n --       Defined in all entities. Set in subprograms where either the body\n@@ -4241,8 +4254,7 @@ package Einfo is\n --    Returns_By_Ref\n --       Defined in subprogram type entities and functions. Set if a function\n --       (or an access-to-function type) returns a result by reference, either\n---       because its return type is a by-reference-type or because the function\n---       explicitly uses the secondary stack.\n+--       because the result is built in place, or its type is by-reference.\n \n --    Reverse_Bit_Order [base type only]\n --       Defined in all record type entities. Set if entity has a Bit_Order"}, {"sha": "15a20392457dc7b3689228d6bf03a4b507b1415a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 61, "deletions": 48, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -164,7 +164,7 @@ package body Exp_Ch6 is\n    function Caller_Known_Size\n      (Func_Call   : Node_Id;\n       Result_Subt : Entity_Id) return Boolean;\n-   --  True if result subtype is definite, or has a size that does not require\n+   --  True if result subtype is definite or has a size that does not require\n    --  secondary stack usage (i.e. no variant part or components whose type\n    --  depends on discriminants). In particular, untagged types with only\n    --  access discriminants do not require secondary stack use. Note we must\n@@ -1055,12 +1055,12 @@ package body Exp_Ch6 is\n      (Func_Call   : Node_Id;\n       Result_Subt : Entity_Id) return Boolean\n    is\n-      Ctrl : constant Node_Id   := Controlling_Argument (Func_Call);\n       Utyp : constant Entity_Id := Underlying_Type (Result_Subt);\n \n    begin\n-      return (No (Ctrl) and then Is_Definite_Subtype (Utyp))\n-        or else not Needs_Secondary_Stack (Utyp);\n+      return not Needs_Secondary_Stack (Utyp)\n+        and then not (Is_Tagged_Type (Utyp)\n+                       and then Present (Controlling_Argument (Func_Call)));\n    end Caller_Known_Size;\n \n    -----------------------\n@@ -5549,10 +5549,6 @@ package body Exp_Ch6 is\n                     Present (Unqual_BIP_Iface_Function_Call\n                               (Expression (Original_Node (Ret_Obj_Decl))))));\n \n-            --  Return the build-in-place result by reference\n-\n-            Set_By_Ref (Return_Stmt);\n-\n          elsif Is_BIP_Func then\n \n             --  Locate the implicit access parameter associated with the\n@@ -5586,10 +5582,6 @@ package body Exp_Ch6 is\n                Obj_Alloc_Formal : Entity_Id;\n \n             begin\n-               --  Build-in-place results must be returned by reference\n-\n-               Set_By_Ref (Return_Stmt);\n-\n                --  Retrieve the implicit access parameter passed by the caller\n \n                Obj_Acc_Formal :=\n@@ -7316,13 +7308,18 @@ package body Exp_Ch6 is\n \n       --  Deal with returning variable length objects and controlled types\n \n-      --  Nothing to do if we are returning by reference, or this is not a\n-      --  type that requires special processing (indicated by the fact that\n-      --  it requires a cleanup scope for the secondary stack case).\n+      --  Nothing to do if we are returning by reference\n \n-      if Is_Build_In_Place_Function (Scope_Id)\n-        or else Is_Limited_Interface (Exp_Typ)\n-      then\n+      if Is_Build_In_Place_Function (Scope_Id) then\n+         --  Prevent the reclamation of the secondary stack by all enclosing\n+         --  blocks and loops as well as the related function; otherwise the\n+         --  result would be reclaimed too early.\n+\n+         if Needs_BIP_Alloc_Form (Scope_Id) then\n+            Set_Enclosing_Sec_Stack_Return (N);\n+         end if;\n+\n+      elsif Is_Limited_View (R_Type) then\n          null;\n \n       --  No copy needed for thunks returning interface type objects since\n@@ -7333,15 +7330,16 @@ package body Exp_Ch6 is\n          null;\n \n       --  If the call is within a thunk and the type is a limited view, the\n-      --  backend will eventually see the non-limited view of the type.\n+      --  back end will eventually see the non-limited view of the type.\n \n       elsif Is_Thunk (Scope_Id) and then Is_Incomplete_Type (Exp_Typ) then\n          return;\n \n       --  A return statement from an ignored Ghost function does not use the\n       --  secondary stack (or any other one).\n \n-      elsif not Needs_Secondary_Stack (R_Type)\n+      elsif (not Needs_Secondary_Stack (R_Type)\n+              and then not Is_Secondary_Stack_Thunk (Scope_Id))\n         or else Is_Ignored_Ghost_Entity (Scope_Id)\n       then\n          --  Mutable records with variable-length components are not returned\n@@ -7380,8 +7378,9 @@ package body Exp_Ch6 is\n          --    return Rnn.all;\n \n          --  but optimize the case where the result is a function call that\n-         --  also needs finalization. In this case the result is already on\n-         --  the return stack and no further processing is required.\n+         --  also needs finalization. In this case the result can directly be\n+         --  allocated on the the return stack of the caller and no further\n+         --  processing is required.\n \n          if Present (Utyp)\n            and then Needs_Finalization (Utyp)\n@@ -7448,17 +7447,11 @@ package body Exp_Ch6 is\n \n          --  Optimize the case where the result is a function call that also\n          --  returns on the secondary stack. In this case the result is already\n-         --  on the secondary stack and no further processing is required\n-         --  except to set the By_Ref flag to ensure that gigi does not attempt\n-         --  an extra unnecessary copy. (Actually not just unnecessary but\n-         --  wrong in the case of a controlled type, where gigi does not know\n-         --  how to do a copy.)\n+         --  on the secondary stack and no further processing is required.\n \n          if Exp_Is_Function_Call\n            and then Needs_Secondary_Stack (Exp_Typ)\n          then\n-            Set_By_Ref (N);\n-\n             --  Remove side effects from the expression now so that other parts\n             --  of the expander do not have to reanalyze this node without this\n             --  optimization\n@@ -7488,7 +7481,15 @@ package body Exp_Ch6 is\n          --  controlled (by the virtue of restriction No_Finalization) because\n          --  gigi is not able to properly allocate class-wide types.\n \n-         elsif CW_Or_Needs_Finalization (Utyp) then\n+         --  But optimize the case where the result is a function call that\n+         --  also needs finalization. In this case the result can directly be\n+         --  allocated on the secondary stack and no further processing is\n+         --  required.\n+\n+         elsif CW_Or_Needs_Finalization (Utyp)\n+           and then not (Exp_Is_Function_Call\n+                          and then Needs_Finalization (Exp_Typ))\n+         then\n             declare\n                Loc        : constant Source_Ptr := Sloc (N);\n                Acc_Typ    : constant Entity_Id := Make_Temporary (Loc, 'A');\n@@ -10047,7 +10048,7 @@ package body Exp_Ch6 is\n       --  formals.\n \n       if Is_Thunk (Func_Id) then\n-         Subp_Id := Thunk_Entity (Func_Id);\n+         Subp_Id := Thunk_Target (Func_Id);\n \n       --  Common case\n \n@@ -10091,37 +10092,49 @@ package body Exp_Ch6 is\n    -- Needs_BIP_Finalization_Master --\n    -----------------------------------\n \n-   function Needs_BIP_Finalization_Master\n-     (Func_Id : Entity_Id) return Boolean\n+   function Needs_BIP_Finalization_Master (Func_Id : Entity_Id) return Boolean\n    is\n-      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n-      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+      Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n    begin\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n       --  A formal giving the finalization master is needed for build-in-place\n       --  functions whose result type needs finalization or is a tagged type.\n       --  Tagged primitive build-in-place functions need such a formal because\n       --  they can be called by a dispatching call, and extensions may require\n-      --  finalization even if the root type doesn't. This means they're also\n-      --  needed for tagged nonprimitive build-in-place functions with tagged\n-      --  results, since such functions can be called via access-to-function\n-      --  types, and those can be used to call primitives, so masters have to\n-      --  be passed to all such build-in-place functions, primitive or not.\n-\n-      return\n-        not Restriction_Active (No_Finalization)\n-          and then (Needs_Finalization (Func_Typ)\n-                     or else Is_Tagged_Type (Func_Typ));\n+      --  finalization even if the root type doesn't. This means nonprimitive\n+      --  build-in-place functions with tagged results also need it, since such\n+      --  functions can be called via access-to-function types, and those can\n+      --  be used to call primitives, so the formal needs to be passed to all\n+      --  such build-in-place functions, primitive or not.\n+\n+      return not Restriction_Active (No_Finalization)\n+        and then (Needs_Finalization (Typ) or else Is_Tagged_Type (Typ));\n    end Needs_BIP_Finalization_Master;\n \n    --------------------------\n    -- Needs_BIP_Alloc_Form --\n    --------------------------\n \n    function Needs_BIP_Alloc_Form (Func_Id : Entity_Id) return Boolean is\n-      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n-      Func_Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+      Typ : constant Entity_Id := Underlying_Type (Etype (Func_Id));\n+\n    begin\n-      return Needs_Secondary_Stack (Func_Typ);\n+      pragma Assert (Is_Build_In_Place_Function (Func_Id));\n+\n+      --  A formal giving the allocation method is needed for build-in-place\n+      --  functions whose result type is returned on the secondary stack or\n+      --  is a tagged type. Tagged primitive build-in-place functions need\n+      --  such a formal because they can be called by a dispatching call, and\n+      --  the secondary stack is always used for dispatching-on-result calls.\n+      --  This means nonprimitive build-in-place functions with tagged results\n+      --  also need it, as such functions can be called via access-to-function\n+      --  types, and those can be used to call primitives, so the formal needs\n+      --  to be passed to all such build-in-place functions, primitive or not.\n+\n+      return not Restriction_Active (No_Secondary_Stack)\n+        and then (Needs_Secondary_Stack (Typ) or else Is_Tagged_Type (Typ));\n    end Needs_BIP_Alloc_Form;\n \n    -------------------------------------"}, {"sha": "b6fc62d2b80a133d20c67caaaaf5a8dbc52692ad", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 9, "deletions": 32, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -76,15 +76,15 @@ package body Exp_Ch7 is\n    -- Transient Scope Management --\n    --------------------------------\n \n-   --  A transient scope is created when temporary objects are created by the\n-   --  compiler. These temporary objects are allocated on the secondary stack\n-   --  and the transient scope is responsible for finalizing the object when\n-   --  appropriate and reclaiming the memory at the right time. The temporary\n-   --  objects are generally the objects allocated to store the result of a\n-   --  function returning an unconstrained or a tagged value. Expressions\n-   --  needing to be wrapped in a transient scope (functions calls returning\n-   --  unconstrained or tagged values) may appear in 3 different contexts which\n-   --  lead to 3 different kinds of transient scope expansion:\n+   --  A transient scope is needed when certain temporary objects are created\n+   --  by the compiler. These temporary objects are allocated on the secondary\n+   --  stack and/or need finalization, and the transient scope is responsible\n+   --  for finalizing the objects and reclaiming the memory of the secondary\n+   --  stack at the appropriate time. They are generally objects allocated to\n+   --  store the result of a function returning an unconstrained or controlled\n+   --  value. Expressions needing to be wrapped in a transient scope may appear\n+   --  in three different contexts which lead to different kinds of transient\n+   --  scope expansion:\n \n    --   1. In a simple statement (procedure call, assignment, ...). In this\n    --      case the instruction is wrapped into a transient block. See\n@@ -99,29 +99,6 @@ package body Exp_Ch7 is\n    --      declaration and the secondary stack deallocation is done in the\n    --      proper enclosing scope. See Wrap_Transient_Declaration for details.\n \n-   --  Note about functions returning tagged types: it has been decided to\n-   --  always allocate their result in the secondary stack, even though is not\n-   --  absolutely mandatory when the tagged type is constrained because the\n-   --  caller knows the size of the returned object and thus could allocate the\n-   --  result in the primary stack. An exception to this is when the function\n-   --  builds its result in place, as is done for functions with inherently\n-   --  limited result types for Ada 2005. In that case, certain callers may\n-   --  pass the address of a constrained object as the target object for the\n-   --  function result.\n-\n-   --  By always allocating tagged results in the secondary stack, a couple of\n-   --  implementation difficulties are avoided:\n-\n-   --    - If this is a dispatching function call, the computation of the size\n-   --      of the result is possible but complex from the outside.\n-\n-   --    - If the result type is class-wide, it is unconstrained anyway.\n-\n-   --  Furthermore, the small loss in efficiency which is the result of this\n-   --  decision is not such a big deal because functions returning tagged types\n-   --  are not as common in practice compared to functions returning access to\n-   --  a tagged type.\n-\n    --------------------------------------------------\n    -- Transient Blocks and Finalization Management --\n    --------------------------------------------------"}, {"sha": "ddb0cedc0487afc02fa77387c6c4ee4c3a7b279a", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 314, "deletions": 81, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -83,7 +83,7 @@ package body Exp_Disp is\n    procedure Expand_Interface_Thunk\n      (Prim       : Entity_Id;\n       Thunk_Id   : out Entity_Id;\n-      Thunk_Code : out Node_Id;\n+      Thunk_Code : out List_Id;\n       Iface      : Entity_Id);\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n    --  generate additional subprograms (thunks) associated with each primitive\n@@ -94,6 +94,21 @@ package body Exp_Disp is\n    --  is set to the defining identifier of the thunk and Thunk_Code to the\n    --  code generated for the thunk respectively.\n \n+   procedure Expand_Secondary_Stack_Thunk\n+     (Prim       : Entity_Id;\n+      Thunk_Id   : out Entity_Id;\n+      Thunk_Code : out Node_Id);\n+   --  When a primitive function of a tagged type can dispatch on result and\n+   --  the tagged type is not returned on the secondary stack, we generate an\n+   --  additional function (thunk) that calls the primitive function with the\n+   --  same actuals and move its result onto the secondary stack. This thunk\n+   --  is intended to be put into the slot of the primitive function in the\n+   --  dispatch table, so as to be invoked in lieu of the primitive function\n+   --  in dispatching calls. If there is no need to generate the thunk, then\n+   --  Thunk_Id is set to Empty. Otherwise Thunk_Id is set to the defining\n+   --  identifier of the thunk and Thunk_Code to the code generated for the\n+   --  thunk respectively.\n+\n    function Has_DT (Typ : Entity_Id) return Boolean;\n    pragma Inline (Has_DT);\n    --  Returns true if we generate a dispatch table for tagged type Typ\n@@ -727,7 +742,6 @@ package body Exp_Disp is\n       New_Call_Name   : Node_Id;\n       New_Params      : List_Id := No_List;\n       Param           : Node_Id;\n-      Res_Typ         : Entity_Id;\n       Subp_Ptr_Typ    : Entity_Id;\n       Subp_Typ        : Entity_Id;\n       Typ             : Entity_Id;\n@@ -875,21 +889,20 @@ package body Exp_Disp is\n          end loop;\n       end if;\n \n-      --  Generate the appropriate subprogram pointer type\n+      --  Generate the appropriate subprogram designated type\n+\n+      Subp_Typ := Create_Itype (E_Subprogram_Type, Call_Node);\n+      Copy_Strub_Mode (Subp_Typ, Subp);\n+      Set_Convention  (Subp_Typ, Convention (Subp));\n \n       if Etype (Subp) = Typ then\n-         Res_Typ := CW_Typ;\n+         Set_Etype          (Subp_Typ, CW_Typ);\n+         Set_Returns_By_Ref (Subp_Typ, True);\n       else\n-         Res_Typ := Etype (Subp);\n+         Set_Etype          (Subp_Typ, Etype (Subp));\n+         Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n       end if;\n \n-      Subp_Typ     := Create_Itype (E_Subprogram_Type, Call_Node);\n-      Copy_Strub_Mode (Subp_Typ, Subp);\n-      Subp_Ptr_Typ := Create_Itype (E_Access_Subprogram_Type, Call_Node);\n-      Set_Etype          (Subp_Typ, Res_Typ);\n-      Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n-      Set_Convention     (Subp_Typ, Convention (Subp));\n-\n       --  Notify gigi that the designated type is a dispatching primitive\n \n       Set_Is_Dispatch_Table_Entity (Subp_Typ);\n@@ -986,14 +999,13 @@ package body Exp_Disp is\n          end if;\n       end;\n \n-      --  Complete description of pointer type, including size information, as\n-      --  must be done with itypes to prevent order-of-elaboration anomalies\n-      --  in gigi.\n+      --  Generate the appropriate subprogram pointer type and decorate it\n \n-      Set_Etype (Subp_Ptr_Typ, Subp_Ptr_Typ);\n+      Subp_Ptr_Typ := Create_Itype (E_Access_Subprogram_Type, Call_Node);\n+      Set_Etype                    (Subp_Ptr_Typ, Subp_Ptr_Typ);\n       Set_Directly_Designated_Type (Subp_Ptr_Typ, Subp_Typ);\n-      Set_Convention (Subp_Ptr_Typ, Convention (Subp_Typ));\n-      Layout_Type    (Subp_Ptr_Typ);\n+      Set_Convention               (Subp_Ptr_Typ, Convention (Subp_Typ));\n+      Layout_Type                  (Subp_Ptr_Typ);\n \n       --  If the controlling argument is a value of type Ada.Tag or an abstract\n       --  interface class-wide type then use it directly. Otherwise, the tag\n@@ -1770,7 +1782,7 @@ package body Exp_Disp is\n    procedure Expand_Interface_Thunk\n      (Prim       : Entity_Id;\n       Thunk_Id   : out Entity_Id;\n-      Thunk_Code : out Node_Id;\n+      Thunk_Code : out List_Id;\n       Iface      : Entity_Id)\n    is\n       Actuals      : constant List_Id    := New_List;\n@@ -1785,16 +1797,16 @@ package body Exp_Disp is\n       Decl_1        : Node_Id;\n       Decl_2        : Node_Id;\n       Expr          : Node_Id;\n-      Formal        : Node_Id;\n+      Formal        : Entity_Id;\n       Ftyp          : Entity_Id;\n-      Iface_Formal  : Node_Id;\n+      Iface_Formal  : Entity_Id;\n       New_Arg       : Node_Id;\n       Offset_To_Top : Node_Id;\n       Target_Formal : Entity_Id;\n \n    begin\n       Thunk_Id   := Empty;\n-      Thunk_Code := Empty;\n+      Thunk_Code := Empty_List;\n \n       --  No thunk needed if the primitive has been eliminated\n \n@@ -1873,6 +1885,7 @@ package body Exp_Disp is\n              Defining_Identifier =>\n                Make_Defining_Identifier (Sloc (Formal),\n                  Chars => Chars (Formal)),\n+             Aliased_Present => Aliased_Present (Parent (Formal)),\n              In_Present => In_Present (Parent (Formal)),\n              Out_Present => Out_Present (Parent (Formal)),\n              Parameter_Type => New_Occurrence_Of (Ftyp, Loc),\n@@ -2062,14 +2075,17 @@ package body Exp_Disp is\n \n       Mutate_Ekind (Thunk_Id, Ekind (Prim));\n       Set_Is_Thunk (Thunk_Id);\n+      Set_Has_Controlling_Result (Thunk_Id, False);\n       Set_Convention (Thunk_Id, Convention (Prim));\n       Set_Needs_Debug_Info (Thunk_Id, Needs_Debug_Info (Target));\n       Set_Thunk_Entity (Thunk_Id, Target);\n \n+      Thunk_Code := New_List;\n+\n       --  Procedure case\n \n       if Ekind (Target) = E_Procedure then\n-         Thunk_Code :=\n+         Append_To (Thunk_Code,\n            Make_Subprogram_Body (Loc,\n               Specification =>\n                 Make_Procedure_Specification (Loc,\n@@ -2081,14 +2097,16 @@ package body Exp_Disp is\n                   Statements => New_List (\n                     Make_Procedure_Call_Statement (Loc,\n                       Name => New_Occurrence_Of (Target, Loc),\n-                      Parameter_Associations => Actuals))));\n+                      Parameter_Associations => Actuals)))));\n \n       --  Function case\n \n       else pragma Assert (Ekind (Target) = E_Function);\n          declare\n-            Result_Def : Node_Id;\n-            Call_Node  : Node_Id;\n+            Call_Node     : Node_Id;\n+            Result_Def    : Node_Id;\n+            SS_Thunk_Id   : Entity_Id;\n+            SS_Thunk_Code : Node_Id;\n \n          begin\n             Call_Node :=\n@@ -2122,6 +2140,19 @@ package body Exp_Disp is\n             --    function F (O : T) return T;\n \n             else\n+               Expand_Secondary_Stack_Thunk\n+                 (Target, SS_Thunk_Id, SS_Thunk_Code);\n+\n+               if Present (SS_Thunk_Id) then\n+                  Set_Thunk_Entity (Thunk_Id, SS_Thunk_Id);\n+                  Call_Node :=\n+                    Make_Function_Call (Loc,\n+                      Name                   =>\n+                        New_Occurrence_Of (SS_Thunk_Id, Loc),\n+                      Parameter_Associations => Actuals);\n+                  Append_To (Thunk_Code, SS_Thunk_Code);\n+               end if;\n+\n                Result_Def :=\n                  New_Occurrence_Of (Class_Wide_Type (Etype (Prim)), Loc);\n \n@@ -2136,7 +2167,7 @@ package body Exp_Disp is\n                    Expression   => Relocate_Node (Call_Node));\n             end if;\n \n-            Thunk_Code :=\n+            Append_To (Thunk_Code,\n               Make_Subprogram_Body (Loc,\n                 Specification              =>\n                   Make_Function_Specification (Loc,\n@@ -2147,11 +2178,135 @@ package body Exp_Disp is\n                 Handled_Statement_Sequence =>\n                   Make_Handled_Sequence_Of_Statements (Loc,\n                     Statements => New_List (\n-                      Make_Simple_Return_Statement (Loc, Call_Node))));\n+                      Make_Simple_Return_Statement (Loc, Call_Node)))));\n          end;\n       end if;\n    end Expand_Interface_Thunk;\n \n+   ------------------------------------\n+   --  Expand_Secondary_Stack_Thunk  --\n+   ------------------------------------\n+\n+   procedure Expand_Secondary_Stack_Thunk\n+     (Prim       : Entity_Id;\n+      Thunk_Id   : out Entity_Id;\n+      Thunk_Code : out Node_Id)\n+   is\n+      Actuals      : constant List_Id    := New_List;\n+      Formals      : constant List_Id    := New_List;\n+      Loc          : constant Source_Ptr := Sloc (Prim);\n+      Typ          : constant Entity_Id  := Etype (Prim);\n+\n+      Call_Node   : Node_Id;\n+      Expr        : Node_Id;\n+      Formal      : Entity_Id;\n+      Prim_Formal : Entity_Id;\n+      Result_Def  : Node_Id;\n+\n+   begin\n+      Thunk_Id   := Empty;\n+      Thunk_Code := Empty;\n+\n+      --  No thunk needed if the primitive has been eliminated\n+\n+      if Is_Eliminated (Prim) then\n+         return;\n+\n+      --  No thunk needed for procedures or functions not dispatching on result\n+\n+      elsif Ekind (Prim) = E_Procedure\n+        or else not Has_Controlling_Result (Prim)\n+      then\n+         return;\n+\n+      --  No thunk needed if the result type is an access type\n+\n+      elsif Is_Access_Type (Typ) then\n+         return;\n+\n+      --  No thunk needed if the tagged type is returned in place\n+\n+      elsif Is_Build_In_Place_Result_Type (Typ) then\n+         return;\n+\n+      --  No thunk needed if the tagged type is returned on the secondary stack\n+\n+      elsif Needs_Secondary_Stack (Typ) then\n+         return;\n+      end if;\n+\n+      pragma Assert (Is_Tagged_Type (Typ));\n+\n+      --  Duplicate the formals of the target primitive and build the actuals\n+\n+      Prim_Formal := First_Formal (Prim);\n+      while Present (Prim_Formal) loop\n+         Expr := New_Copy_Tree (Expression (Parent (Prim_Formal)));\n+\n+         Formal :=\n+           Make_Defining_Identifier (Sloc (Prim_Formal),\n+             Chars => Chars (Prim_Formal));\n+\n+         Append_To (Formals,\n+           Make_Parameter_Specification (Loc,\n+             Defining_Identifier => Formal,\n+             Aliased_Present => Aliased_Present (Parent (Prim_Formal)),\n+             In_Present => In_Present (Parent (Prim_Formal)),\n+             Out_Present => Out_Present (Parent (Prim_Formal)),\n+             Parameter_Type => New_Occurrence_Of (Etype (Prim_Formal), Loc),\n+             Expression => Expr));\n+\n+         --  Ensure proper matching of access types. Required to avoid\n+         --  reporting spurious errors.\n+\n+         if Is_Access_Type (Etype (Prim_Formal)) then\n+            Append_To (Actuals,\n+              Unchecked_Convert_To (Base_Type (Etype (Prim_Formal)),\n+                New_Occurrence_Of (Formal, Loc)));\n+\n+         --  No special management required for this actual\n+\n+         else\n+            Append_To (Actuals, New_Occurrence_Of (Formal, Loc));\n+         end if;\n+\n+         Next_Formal (Prim_Formal);\n+      end loop;\n+\n+      Thunk_Id := Make_Temporary (Loc, 'T');\n+\n+      --  Note: any change to this symbol name needs to be coordinated\n+      --  with GNATcoverage, as that tool relies on it to identify\n+      --  thunks and exclude them from source coverage analysis.\n+\n+      Mutate_Ekind (Thunk_Id, E_Function);\n+      Set_Is_Thunk (Thunk_Id);\n+      Set_Has_Controlling_Result (Thunk_Id, True);\n+      Set_Convention (Thunk_Id, Convention (Prim));\n+      Set_Needs_Debug_Info (Thunk_Id, Needs_Debug_Info (Prim));\n+      Set_Thunk_Entity (Thunk_Id, Prim);\n+\n+      Result_Def := New_Copy (Result_Definition (Parent (Prim)));\n+\n+      Call_Node :=\n+        Make_Function_Call (Loc,\n+          Name                   => New_Occurrence_Of (Prim, Loc),\n+          Parameter_Associations => Actuals);\n+\n+      Thunk_Code :=\n+        Make_Subprogram_Body (Loc,\n+          Specification              =>\n+            Make_Function_Specification (Loc,\n+              Defining_Unit_Name       => Thunk_Id,\n+              Parameter_Specifications => Formals,\n+              Result_Definition        => Result_Def),\n+          Declarations               => Empty_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc,\n+              Statements => New_List (\n+                Make_Simple_Return_Statement (Loc, Call_Node))));\n+   end Expand_Secondary_Stack_Thunk;\n+\n    --------------------------\n    -- Has_CPP_Constructors --\n    --------------------------\n@@ -3868,11 +4023,14 @@ package body Exp_Disp is\n          --  save their entity to fill the aggregate.\n \n          declare\n-            Nb_P_Prims : constant Nat := Number_Of_Predefined_Prims (Typ);\n-            Prim_Table : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n-            Decl       : Node_Id;\n-            Thunk_Id   : Entity_Id;\n-            Thunk_Code : Node_Id;\n+            Nb_P_Prims    : constant Nat := Number_Of_Predefined_Prims (Typ);\n+            Prim_Table    : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n+            Decl          : Node_Id;\n+            E             : Entity_Id;\n+            SS_Thunk_Id   : Entity_Id;\n+            SS_Thunk_Code : Node_Id;\n+            Thunk_Id      : Entity_Id;\n+            Thunk_Code    : List_Id;\n \n          begin\n             Prim_Ops_Aggr_List := New_List;\n@@ -3887,19 +4045,27 @@ package body Exp_Disp is\n                     and then not Is_Abstract_Subprogram (Prim)\n                     and then not Is_Eliminated (Prim)\n                     and then not Generate_SCIL\n-                    and then not Present (Prim_Table\n-                                           (UI_To_Int (DT_Position (Prim))))\n+                    and then not\n+                      Present (Prim_Table (UI_To_Int (DT_Position (Prim))))\n                   then\n                      if not Build_Thunks then\n-                        Prim_Table (UI_To_Int (DT_Position (Prim))) :=\n-                          Alias (Prim);\n+                        E := Ultimate_Alias (Prim);\n+                        Expand_Secondary_Stack_Thunk\n+                          (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+                        if Present (SS_Thunk_Id) then\n+                           E := SS_Thunk_Id;\n+                           Append_To (Result, SS_Thunk_Code);\n+                        end if;\n+\n+                        Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n \n                      else\n                         Expand_Interface_Thunk\n                           (Prim, Thunk_Id, Thunk_Code, Iface);\n \n                         if Present (Thunk_Id) then\n-                           Append_To (Result, Thunk_Code);\n+                           Append_List_To (Result, Thunk_Code);\n                            Prim_Table (UI_To_Int (DT_Position (Prim))) :=\n                              Thunk_Id;\n                         end if;\n@@ -4042,17 +4208,20 @@ package body Exp_Disp is\n             OSD_Aggr_List := New_List;\n \n             declare\n-               Prim_Table : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n-               Prim       : Entity_Id;\n-               Prim_Alias : Entity_Id;\n-               Prim_Elmt  : Elmt_Id;\n-               E          : Entity_Id;\n-               Count      : Nat := 0;\n-               Pos        : Nat;\n+               Prim_Table    : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n+               Prim          : Entity_Id;\n+               Prim_Alias    : Entity_Id;\n+               Prim_Elmt     : Elmt_Id;\n+               E             : Entity_Id;\n+               Count         : Nat;\n+               Pos           : Nat;\n+               SS_Thunk_Id   : Entity_Id;\n+               SS_Thunk_Code : Node_Id;\n \n             begin\n                Prim_Table := (others => Empty);\n                Prim_Alias := Empty;\n+               Count      := 0;\n \n                Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n                while Present (Prim_Elmt) loop\n@@ -4066,11 +4235,15 @@ package body Exp_Disp is\n                      E   := Ultimate_Alias (Prim);\n                      Pos := UI_To_Int (DT_Position (Prim_Alias));\n \n-                     if Present (Prim_Table (Pos)) then\n-                        pragma Assert (Prim_Table (Pos) = E);\n-                        null;\n+                     if No (Prim_Table (Pos)) then\n+                        Expand_Secondary_Stack_Thunk\n+                          (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+                        if Present (SS_Thunk_Id) then\n+                           E := SS_Thunk_Id;\n+                           Append_To (Result, SS_Thunk_Code);\n+                        end if;\n \n-                     else\n                         Prim_Table (Pos) := E;\n \n                         Append_To (OSD_Aggr_List,\n@@ -4158,12 +4331,14 @@ package body Exp_Disp is\n \n          else\n             declare\n-               CPP_Nb_Prims : constant Nat := CPP_Num_Prims (Typ);\n-               E            : Entity_Id;\n-               Prim_Pos     : Nat;\n-               Prim_Table   : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n-               Thunk_Code   : Node_Id;\n-               Thunk_Id     : Entity_Id;\n+               CPP_Nb_Prims  : constant Nat := CPP_Num_Prims (Typ);\n+               E             : Entity_Id;\n+               Prim_Pos      : Nat;\n+               Prim_Table    : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n+               SS_Thunk_Id   : Entity_Id;\n+               SS_Thunk_Code : Node_Id;\n+               Thunk_Id      : Entity_Id;\n+               Thunk_Code    : List_Id;\n \n             begin\n                Prim_Table := (others => Empty);\n@@ -4198,9 +4373,18 @@ package body Exp_Disp is\n                                               Use_Full_View => True)\n                   then\n                      if not Build_Thunks then\n+                        E := Alias (Prim);\n+                        Expand_Secondary_Stack_Thunk\n+                          (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+                        if Present (SS_Thunk_Id) then\n+                           E := SS_Thunk_Id;\n+                           Append_To (Result, SS_Thunk_Code);\n+                        end if;\n+\n                         Prim_Pos :=\n                           UI_To_Int (DT_Position (Interface_Alias (Prim)));\n-                        Prim_Table (Prim_Pos) := Alias (Prim);\n+                        Prim_Table (Prim_Pos) := E;\n \n                      else\n                         Expand_Interface_Thunk\n@@ -4211,7 +4395,7 @@ package body Exp_Disp is\n                              UI_To_Int (DT_Position (Interface_Alias (Prim)));\n \n                            Prim_Table (Prim_Pos) := Thunk_Id;\n-                           Append_To (Result, Thunk_Code);\n+                           Append_List_To (Result, Thunk_Code);\n                         end if;\n                      end if;\n                   end if;\n@@ -5661,10 +5845,12 @@ package body Exp_Disp is\n \n       else\n          declare\n-            Nb_P_Prims : constant Nat := Number_Of_Predefined_Prims (Typ);\n-            Prim_Table : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n-            Decl       : Node_Id;\n-            E          : Entity_Id;\n+            Nb_P_Prims    : constant Nat := Number_Of_Predefined_Prims (Typ);\n+            Prim_Table    : array (Nat range 1 .. Nb_P_Prims) of Entity_Id;\n+            Decl          : Node_Id;\n+            E             : Entity_Id;\n+            SS_Thunk_Id   : Entity_Id;\n+            SS_Thunk_Code : Node_Id;\n \n          begin\n             Prim_Ops_Aggr_List := New_List;\n@@ -5684,6 +5870,15 @@ package body Exp_Disp is\n                   then\n                      E := Ultimate_Alias (Prim);\n                      pragma Assert (not Is_Abstract_Subprogram (E));\n+\n+                     Expand_Secondary_Stack_Thunk\n+                       (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+                     if Present (SS_Thunk_Id) then\n+                        E := SS_Thunk_Id;\n+                        Append_To (Result, SS_Thunk_Code);\n+                     end if;\n+\n                      Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n                   end if;\n \n@@ -5794,12 +5989,14 @@ package body Exp_Disp is\n \n          else\n             declare\n-               CPP_Nb_Prims : constant Nat := CPP_Num_Prims (Typ);\n-               E            : Entity_Id;\n-               Prim         : Entity_Id;\n-               Prim_Elmt    : Elmt_Id;\n-               Prim_Pos     : Nat;\n-               Prim_Table   : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n+               CPP_Nb_Prims  : constant Nat := CPP_Num_Prims (Typ);\n+               E             : Entity_Id;\n+               Prim          : Entity_Id;\n+               Prim_Elmt     : Elmt_Id;\n+               Prim_Pos      : Nat;\n+               Prim_Table    : array (Nat range 1 .. Nb_Prim) of Entity_Id;\n+               SS_Thunk_Id   : Entity_Id;\n+               SS_Thunk_Code : Node_Id;\n \n             begin\n                Prim_Table := (others => Empty);\n@@ -5856,6 +6053,14 @@ package body Exp_Disp is\n                      pragma Assert\n                        (UI_To_Int (DT_Position (Prim)) <= Nb_Prim);\n \n+                     Expand_Secondary_Stack_Thunk\n+                       (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+                     if Present (SS_Thunk_Id) then\n+                        E := SS_Thunk_Id;\n+                        Append_To (Result, SS_Thunk_Code);\n+                     end if;\n+\n                      Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n                   end if;\n \n@@ -7153,12 +7358,15 @@ package body Exp_Disp is\n      (Loc     : Source_Ptr;\n       Prim    : Entity_Id) return List_Id\n    is\n-      L          : constant List_Id   := New_List;\n+      L          : constant List_Id := New_List;\n       Tagged_Typ : constant Entity_Id := Find_Dispatching_Type (Prim);\n \n+      E             : Entity_Id;\n       Iface_DT_Ptr  : Elmt_Id;\n+      SS_Thunk_Id   : Entity_Id;\n+      SS_Thunk_Code : Node_Id;\n       Thunk_Id      : Entity_Id;\n-      Thunk_Code    : Node_Id;\n+      Thunk_Code    : List_Id;\n \n    begin\n       if No (Access_Disp_Table (Tagged_Typ))\n@@ -7187,7 +7395,15 @@ package body Exp_Disp is\n            (Prim, Thunk_Id, Thunk_Code, Related_Type (Node (Iface_DT_Ptr)));\n \n          if Present (Thunk_Id) then\n-            Append_To (L, Thunk_Code);\n+            Append_List_To (L, Thunk_Code);\n+\n+            E := Prim;\n+            Expand_Secondary_Stack_Thunk (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+            if Present (SS_Thunk_Id) then\n+               E := SS_Thunk_Id;\n+               Append_To (L, SS_Thunk_Code);\n+            end if;\n \n             Append_To (L,\n               Build_Set_Predefined_Prim_Op_Address (Loc,\n@@ -7210,7 +7426,7 @@ package body Exp_Disp is\n                 Address_Node =>\n                   Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                     Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Occurrence_Of (Prim, Loc),\n+                      Prefix         => New_Occurrence_Of (E, Loc),\n                       Attribute_Name => Name_Unrestricted_Access))));\n          end if;\n \n@@ -7246,15 +7462,18 @@ package body Exp_Disp is\n       L : constant List_Id := New_List;\n \n       DT_Ptr        : Entity_Id;\n+      E             : Entity_Id;\n       Iface_Prim    : Entity_Id;\n       Iface_Typ     : Entity_Id;\n       Iface_DT_Ptr  : Entity_Id;\n       Iface_DT_Elmt : Elmt_Id;\n       Pos           : Uint;\n+      SS_Thunk_Id   : Entity_Id;\n+      SS_Thunk_Code : Node_Id;\n       Tag           : Entity_Id;\n       Tag_Typ       : Entity_Id;\n       Thunk_Id      : Entity_Id;\n-      Thunk_Code    : Node_Id;\n+      Thunk_Code    : List_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -7275,6 +7494,14 @@ package body Exp_Disp is\n          Pos     := DT_Position (Prim);\n          Tag     := First_Tag_Component (Tag_Typ);\n \n+         E := Prim;\n+         Expand_Secondary_Stack_Thunk (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+         if Present (SS_Thunk_Id) then\n+            E := SS_Thunk_Id;\n+            Append_To (L, SS_Thunk_Code);\n+         end if;\n+\n          if Is_Predefined_Dispatching_Operation (Prim)\n            or else Is_Predefined_Dispatching_Alias (Prim)\n          then\n@@ -7288,7 +7515,7 @@ package body Exp_Disp is\n                 Address_Node =>\n                   Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                     Make_Attribute_Reference (Loc,\n-                      Prefix         => New_Occurrence_Of (Prim, Loc),\n+                      Prefix         => New_Occurrence_Of (E, Loc),\n                       Attribute_Name => Name_Unrestricted_Access))));\n \n             --  Register copy of the pointer to the 'size primitive in the TSD\n@@ -7321,7 +7548,7 @@ package body Exp_Disp is\n                    Address_Node =>\n                      Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n-                         Prefix         => New_Occurrence_Of (Prim, Loc),\n+                         Prefix         => New_Occurrence_Of (E, Loc),\n                          Attribute_Name => Name_Unrestricted_Access))));\n             end if;\n          end if;\n@@ -7358,8 +7585,8 @@ package body Exp_Disp is\n \n          Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code, Iface_Typ);\n \n-         if not Is_Ancestor (Iface_Typ, Tag_Typ, Use_Full_View => True)\n-           and then Present (Thunk_Code)\n+         if Present (Thunk_Id)\n+           and then not Is_Ancestor (Iface_Typ, Tag_Typ, Use_Full_View => True)\n          then\n             --  Generate the code necessary to fill the appropriate entry of\n             --  the secondary dispatch table of Prim's controlling type with\n@@ -7373,7 +7600,15 @@ package body Exp_Disp is\n             Pos        := DT_Position (Iface_Prim);\n             Tag        := First_Tag_Component (Iface_Typ);\n \n-            Prepend_To (L, Thunk_Code);\n+            Append_List_To (L, Thunk_Code);\n+\n+            E := Ultimate_Alias (Prim);\n+            Expand_Secondary_Stack_Thunk (E, SS_Thunk_Id, SS_Thunk_Code);\n+\n+            if Present (SS_Thunk_Id) then\n+               E := SS_Thunk_Id;\n+               Append_To (L, SS_Thunk_Code);\n+            end if;\n \n             if Is_Predefined_Dispatching_Operation (Prim)\n               or else Is_Predefined_Dispatching_Alias (Prim)\n@@ -7402,8 +7637,7 @@ package body Exp_Disp is\n                    Address_Node =>\n                      Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n-                         Prefix          =>\n-                           New_Occurrence_Of (Alias (Prim), Loc),\n+                         Prefix          => New_Occurrence_Of (E, Loc),\n                          Attribute_Name  => Name_Unrestricted_Access))));\n \n             else\n@@ -7434,8 +7668,7 @@ package body Exp_Disp is\n                    Address_Node =>\n                      Unchecked_Convert_To (RTE (RE_Prim_Ptr),\n                        Make_Attribute_Reference (Loc,\n-                         Prefix         =>\n-                           New_Occurrence_Of (Ultimate_Alias (Prim), Loc),\n+                         Prefix         => New_Occurrence_Of (E, Loc),\n                          Attribute_Name => Name_Unrestricted_Access))));\n \n             end if;"}, {"sha": "0f193182729c952e937432d13ca9004dd1fc43d8", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -9294,6 +9294,17 @@ package body Exp_Util is\n       return False;\n    end Is_Secondary_Stack_BIP_Func_Call;\n \n+   ------------------------------\n+   -- Is_Secondary_Stack_Thunk --\n+   ------------------------------\n+\n+   function Is_Secondary_Stack_Thunk (Id : Entity_Id) return Boolean is\n+   begin\n+      return Ekind (Id) = E_Function\n+        and then Is_Thunk (Id)\n+        and then Has_Controlling_Result (Id);\n+   end Is_Secondary_Stack_Thunk;\n+\n    -------------------------------------\n    -- Is_Tag_To_Class_Wide_Conversion --\n    -------------------------------------\n@@ -14059,6 +14070,23 @@ package body Exp_Util is\n       end if;\n    end Small_Integer_Type_For;\n \n+   ------------------\n+   -- Thunk_Target --\n+   ------------------\n+\n+   function Thunk_Target (Thunk : Entity_Id) return Entity_Id is\n+      Target : Entity_Id := Thunk;\n+\n+   begin\n+      pragma Assert (Is_Thunk (Thunk));\n+\n+      while Is_Thunk (Target) loop\n+         Target := Thunk_Entity (Target);\n+      end loop;\n+\n+      return Target;\n+   end Thunk_Target;\n+\n    -------------------\n    -- Type_Map_Hash --\n    -------------------"}, {"sha": "e812ca06a7f6d8bcc82ec740ee3da69272d26a76", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -837,6 +837,11 @@ package Exp_Util is\n    --  Determine whether Expr denotes a build-in-place function which returns\n    --  its result on the secondary stack.\n \n+   function Is_Secondary_Stack_Thunk (Id : Entity_Id) return Boolean;\n+   --  Determine whether Id denotes a secondary stack thunk\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n    function Is_Tag_To_Class_Wide_Conversion\n      (Obj_Id : Entity_Id) return Boolean;\n    --  Determine whether object Obj_Id is the result of a tag-to-class-wide\n@@ -1190,6 +1195,12 @@ package Exp_Util is\n    --  Return the smallest standard integer type containing at least S bits and\n    --  of the signedness given by Uns.\n \n+   function Thunk_Target (Thunk : Entity_Id) return Entity_Id;\n+   --  Return the entity ultimately called by the thunk, that is to say return\n+   --  the Thunk_Entity of the last member on the thunk chain.\n+\n+   --  WARNING: There is a matching C declaration of this subprogram in fe.h\n+\n    function Type_May_Have_Bit_Aligned_Components\n      (Typ : Entity_Id) return Boolean;\n    --  Determines if Typ is a composite type that has within it (looking down\n@@ -1216,4 +1227,6 @@ private\n    pragma Inline (Force_Evaluation);\n    pragma Inline (Get_Mapped_Entity);\n    pragma Inline (Is_Library_Level_Tagged_Type);\n+   pragma Inline (Is_Secondary_Stack_Thunk);\n+   pragma Inline (Thunk_Target);\n end Exp_Util;"}, {"sha": "983f6c3a441b4597b72cf03cb0fa00238d35d1e8", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -182,13 +182,17 @@ extern Boolean Is_Init_Proc\t\t(Entity_Id);\n \n /* exp_util: */\n \n+#define Find_Interface_Tag\t\texp_util__find_interface_tag\n #define Is_Fully_Repped_Tagged_Type\texp_util__is_fully_repped_tagged_type\n #define Is_Related_To_Func_Return\texp_util__is_related_to_func_return\n-#define Find_Interface_Tag\t\texp_util__find_interface_tag\n+#define Is_Secondary_Stack_Thunk\texp_util__is_secondary_stack_thunk\n+#define Thunk_Target\t\t\texp_util__thunk_target\n \n+extern Entity_Id Find_Interface_Tag\t\t(Entity_Id, Entity_Id);\n extern Boolean Is_Fully_Repped_Tagged_Type\t(Entity_Id);\n extern Boolean Is_Related_To_Func_Return\t(Entity_Id);\n-extern Entity_Id Find_Interface_Tag\t\t(Entity_Id, Entity_Id);\n+extern Boolean Is_Secondary_Stack_Thunk\t\t(Entity_Id);\n+extern Entity_Id Thunk_Target \t\t\t(Entity_Id);\n \n /* lib: */\n "}, {"sha": "6d9639d1907d94327fb910a8d6d199184eaf60eb", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -97,11 +97,6 @@ do {\t\t\t\t\t\t\t \\\n    an Ada array other than the first.  */\n #define TYPE_MULTI_ARRAY_P(NODE) TYPE_LANG_FLAG_1 (ARRAY_TYPE_CHECK (NODE))\n \n-/* For FUNCTION_TYPE and METHOD_TYPE, nonzero if function returns an\n-   unconstrained array or record type.  */\n-#define TYPE_RETURN_UNCONSTRAINED_P(NODE) \\\n-  TYPE_LANG_FLAG_1 (FUNC_OR_METHOD_CHECK (NODE))\n-\n /* For RECORD_TYPE, UNION_TYPE, and QUAL_UNION_TYPE, nonzero if this denotes\n    a justified modular type (will only be true for RECORD_TYPE).  */\n #define TYPE_JUSTIFIED_MODULAR_P(NODE) \\"}, {"sha": "bbbb343180df9e0d4b07d929a1a3716097f18aa0", "filename": "gcc/ada/gcc-interface/decl.cc", "status": "modified", "additions": 7, "deletions": 36, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.cc?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -5807,7 +5807,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n   bool pure_flag = Is_Pure (gnat_subprog);\n   bool return_by_direct_ref_p = false;\n   bool return_by_invisi_ref_p = false;\n-  bool return_unconstrained_p = false;\n   bool incomplete_profile_p = false;\n   int num;\n \n@@ -5822,7 +5821,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t   && !TYPE_IS_DUMMY_P (TREE_TYPE (gnu_type)))\n     {\n       gnu_return_type = TREE_TYPE (gnu_type);\n-      return_unconstrained_p = TYPE_RETURN_UNCONSTRAINED_P (gnu_type);\n       return_by_direct_ref_p = TYPE_RETURN_BY_DIRECT_REF_P (gnu_type);\n       return_by_invisi_ref_p = TREE_ADDRESSABLE (gnu_type);\n     }\n@@ -5838,38 +5836,16 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n       else\n \tgnu_return_type = gnat_to_gnu_profile_type (gnat_return_type);\n \n-      /* If this function returns by reference, make the actual return type\n-\t the reference type and make a note of that.  */\n-      if (Returns_By_Ref (gnat_subprog))\n+      /* If this function returns by reference or on the secondary stack, make\n+\t the actual return type the reference type and make a note of that.  */\n+      if (Returns_By_Ref (gnat_subprog)\n+\t  || Needs_Secondary_Stack (gnat_return_type)\n+\t  || Is_Secondary_Stack_Thunk (gnat_subprog))\n \t{\n \t  gnu_return_type = build_reference_type (gnu_return_type);\n \t  return_by_direct_ref_p = true;\n \t}\n \n-      /* If the return type is an unconstrained array type, the return value\n-\t will be allocated on the secondary stack so the actual return type\n-\t is the fat pointer type.  */\n-      else if (TREE_CODE (gnu_return_type) == UNCONSTRAINED_ARRAY_TYPE)\n-\t{\n-\t  gnu_return_type = TYPE_REFERENCE_TO (gnu_return_type);\n-\t  return_unconstrained_p = true;\n-\t}\n-\n-      /* This is the same unconstrained array case, but for a dummy type.  */\n-      else if (TYPE_REFERENCE_TO (gnu_return_type)\n-\t       && TYPE_IS_FAT_POINTER_P (TYPE_REFERENCE_TO (gnu_return_type)))\n-\t{\n-\t  gnu_return_type = TYPE_REFERENCE_TO (gnu_return_type);\n-\t  return_unconstrained_p = true;\n-\t}\n-\n-      /* This is for the other types returned on the secondary stack.  */\n-      else if (Needs_Secondary_Stack (gnat_return_type))\n-\t{\n-\t  gnu_return_type = build_reference_type (gnu_return_type);\n-\t  return_unconstrained_p = true;\n-\t}\n-\n       /* If the Mechanism is By_Reference, ensure this function uses the\n \t target's by-invisible-reference mechanism, which may not be the\n \t same as above (e.g. it might be passing an extra parameter).  */\n@@ -5949,8 +5925,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t}\n \n       if (kind == E_Function)\n-\tSet_Mechanism (gnat_subprog, return_unconstrained_p\n-\t\t\t\t     || return_by_direct_ref_p\n+\tSet_Mechanism (gnat_subprog, return_by_direct_ref_p\n \t\t\t\t     || return_by_invisi_ref_p\n \t\t\t\t     ? By_Reference : By_Copy);\n     }\n@@ -5962,7 +5937,7 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n      Similarly, if the function returns an unconstrained type, then the\n      function will allocate the return value on the secondary stack and\n      thus calls to it cannot be CSE'ed, lest the stack be reclaimed.  */\n-  if (VOID_TYPE_P (gnu_return_type) || return_unconstrained_p)\n+  if (VOID_TYPE_P (gnu_return_type) || return_by_direct_ref_p)\n     pure_flag = false;\n \n   /* Loop over the parameters and get their associated GCC tree.  While doing\n@@ -6250,7 +6225,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \tgnu_type = make_node (method_p ? METHOD_TYPE : FUNCTION_TYPE);\n       TREE_TYPE (gnu_type) = gnu_return_type;\n       TYPE_ARG_TYPES (gnu_type) = gnu_param_type_list;\n-      TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n       TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n       TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n     }\n@@ -6267,7 +6241,6 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t\t= TYPE_MAIN_VARIANT (gnu_basetype);\n \t    }\n \t  TYPE_CI_CO_LIST (gnu_type) = gnu_cico_list;\n-\t  TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n \t  TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n \t  TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n \t  TYPE_CANONICAL (gnu_type) = gnu_type;\n@@ -6289,13 +6262,11 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \t  /* GNU_TYPE may be shared since GCC hashes types.  Unshare it if it\n \t     has a different TYPE_CI_CO_LIST or flags.  */\n \t  if (!fntype_same_flags_p (gnu_type, gnu_cico_list,\n-\t\t\t\t    return_unconstrained_p,\n \t\t\t\t    return_by_direct_ref_p,\n \t\t\t\t    return_by_invisi_ref_p))\n \t    {\n \t      gnu_type = copy_type (gnu_type);\n \t      TYPE_CI_CO_LIST (gnu_type) = gnu_cico_list;\n-\t      TYPE_RETURN_UNCONSTRAINED_P (gnu_type) = return_unconstrained_p;\n \t      TYPE_RETURN_BY_DIRECT_REF_P (gnu_type) = return_by_direct_ref_p;\n \t      TREE_ADDRESSABLE (gnu_type) = return_by_invisi_ref_p;\n \t    }"}, {"sha": "6d70c30305a2cd15db5f0aee7ef40b904a5c5f57", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -547,7 +547,7 @@ extern int gnat_types_compatible_p (tree t1, tree t2);\n extern bool gnat_useless_type_conversion (tree expr);\n \n /* Return true if T, a {FUNCTION,METHOD}_TYPE, has the specified flags.  */\n-extern bool fntype_same_flags_p (const_tree, tree, bool, bool, bool);\n+extern bool fntype_same_flags_p (const_tree, tree, bool, bool);\n \n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value"}, {"sha": "7824ebf21f98c0d7683bda42bf6539835bea91c4", "filename": "gcc/ada/gcc-interface/misc.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Fmisc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.cc?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -684,7 +684,6 @@ gnat_type_hash_eq (const_tree t1, const_tree t2)\n {\n   gcc_assert (FUNC_OR_METHOD_TYPE_P (t1) && TREE_CODE (t1) == TREE_CODE (t2));\n   return fntype_same_flags_p (t1, TYPE_CI_CO_LIST (t2),\n-\t\t\t      TYPE_RETURN_UNCONSTRAINED_P (t2),\n \t\t\t      TYPE_RETURN_BY_DIRECT_REF_P (t2),\n \t\t\t      TREE_ADDRESSABLE (t2));\n }"}, {"sha": "8097a89b5ed3089b772729dff56c9a4bc76e3bfe", "filename": "gcc/ada/gcc-interface/trans.cc", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Ftrans.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.cc?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -3725,7 +3725,7 @@ finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret\n   data.result = DECL_RESULT (fndecl);\n   data.gnat_ret = gnat_ret;\n   data.visited = new hash_set<tree>;\n-  if (TYPE_RETURN_UNCONSTRAINED_P (TREE_TYPE (fndecl)))\n+  if (TYPE_RETURN_BY_DIRECT_REF_P (TREE_TYPE (fndecl)))\n     func = finalize_nrv_unc_r;\n   else\n     func = finalize_nrv_r;\n@@ -3902,6 +3902,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \n   /* Try to create a bona-fide thunk and hand it over to the middle-end.  */\n   if (Is_Thunk (gnat_subprog)\n+      && !Is_Secondary_Stack_Thunk (gnat_subprog)\n       && maybe_make_gnu_thunk (gnat_subprog, gnu_subprog))\n     return;\n \n@@ -5252,10 +5253,9 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  gnu_result_type = TREE_TYPE (gnu_call);\n \t}\n \n-      /* If the function returns an unconstrained array or by direct reference,\n-\t we have to dereference the pointer.  */\n-      if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type)\n-\t  || TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n+      /* If the function returns by direct reference, we have to dereference\n+\t the pointer.  */\n+      if (TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n \tgnu_call = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_call);\n \n       if (gnu_target)\n@@ -7439,52 +7439,58 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      gnu_ret_val = TREE_OPERAND (gnu_ret_val, 0);\n \n \t    /* If the function returns by direct reference, return a pointer\n-\t       to the return value.  */\n-\t    if (TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type)\n-\t\t|| By_Ref (gnat_node))\n-\t      gnu_ret_val = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n-\n-\t    /* Otherwise, if it returns an unconstrained array, we have to\n-\t       allocate a new version of the result and return it.  */\n-\t    else if (TYPE_RETURN_UNCONSTRAINED_P (gnu_subprog_type))\n+\t       to the return value, possibly after allocating it.  */\n+\t    if (TYPE_RETURN_BY_DIRECT_REF_P (gnu_subprog_type))\n \t      {\n-\t\tgnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n-\n-\t\t/* And find out whether this is a candidate for Named Return\n-\t\t   Value.  If so, record it.  */\n-\t\tif (optimize\n-\t\t    && !optimize_debug\n-\t\t    && !TYPE_CI_CO_LIST (gnu_subprog_type))\n+\t\tif (Present (Storage_Pool (gnat_node)))\n \t\t  {\n-\t\t    tree ret_val = gnu_ret_val;\n-\n-\t\t    /* Strip useless conversions around the return value.  */\n-\t\t    if (gnat_useless_type_conversion (ret_val))\n-\t\t      ret_val = TREE_OPERAND (ret_val, 0);\n-\n-\t\t    /* Strip unpadding around the return value.  */\n-\t\t    if (TREE_CODE (ret_val) == COMPONENT_REF\n-\t\t\t&& TYPE_IS_PADDING_P\n-\t\t\t   (TREE_TYPE (TREE_OPERAND (ret_val, 0))))\n-\t\t      ret_val = TREE_OPERAND (ret_val, 0);\n-\n-\t\t    /* Now apply the test to the return value.  */\n-\t\t    if (return_value_ok_for_nrv_p (NULL_TREE, ret_val))\n+\t\t    gnu_ret_val = maybe_unconstrained_array (gnu_ret_val);\n+\n+\t\t    /* And find out whether it is a candidate for Named Return\n+\t\t       Value.  If so, record it.  Note that we disable this NRV\n+\t\t       optimization when we're preserving the control flow as\n+\t\t       it entails hoisting the allocation done below.  */\n+\t\t    if (optimize\n+\t\t\t&& !optimize_debug\n+\t\t\t&& !TYPE_CI_CO_LIST (gnu_subprog_type))\n \t\t      {\n-\t\t\tif (!f_named_ret_val)\n-\t\t\t  f_named_ret_val = BITMAP_GGC_ALLOC ();\n-\t\t\tbitmap_set_bit (f_named_ret_val, DECL_UID (ret_val));\n-\t\t\tif (!f_gnat_ret)\n-\t\t\t  f_gnat_ret = gnat_node;\n+\t\t\ttree ret_val = gnu_ret_val;\n+\n+\t\t\t/* Strip conversions around the return value.  */\n+\t\t\tif (gnat_useless_type_conversion (ret_val))\n+\t\t\t  ret_val = TREE_OPERAND (ret_val, 0);\n+\n+\t\t\t/* Strip unpadding around the return value.  */\n+\t\t\tif (TREE_CODE (ret_val) == COMPONENT_REF\n+\t\t\t    && TYPE_IS_PADDING_P\n+\t\t\t      (TREE_TYPE (TREE_OPERAND (ret_val, 0))))\n+\t\t\t  ret_val = TREE_OPERAND (ret_val, 0);\n+\n+\t\t\t/* Now apply the test to the return value.  */\n+\t\t\tif (return_value_ok_for_nrv_p (NULL_TREE, ret_val))\n+\t\t\t  {\n+\t\t\t    if (!f_named_ret_val)\n+\t\t\t      f_named_ret_val = BITMAP_GGC_ALLOC ();\n+\t\t\t    bitmap_set_bit (f_named_ret_val,\n+\t\t\t\t\t    DECL_UID (ret_val));\n+\t\t\t    if (!f_gnat_ret)\n+\t\t\t      f_gnat_ret = gnat_node;\n+\t\t\t  }\n \t\t      }\n+\n+\t\t    gnu_ret_val\n+\t\t      = build_allocator (TREE_TYPE (gnu_ret_val),\n+\t\t\t\t\t gnu_ret_val,\n+\t\t\t\t\t TREE_TYPE (gnu_ret_obj),\n+\t\t\t\t\t Procedure_To_Call (gnat_node),\n+\t\t\t\t\t Storage_Pool (gnat_node),\n+\t\t\t\t\t gnat_node,\n+\t\t\t\t\t false);\n \t\t  }\n \n-\t\tgnu_ret_val = build_allocator (TREE_TYPE (gnu_ret_val),\n-\t\t\t\t\t       gnu_ret_val,\n-\t\t\t\t\t       TREE_TYPE (gnu_ret_obj),\n-\t\t\t\t\t       Procedure_To_Call (gnat_node),\n-\t\t\t\t\t       Storage_Pool (gnat_node),\n-\t\t\t\t\t       gnat_node, false);\n+\t\telse\n+\t\t  gnu_ret_val\n+\t\t    = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_ret_val);\n \t      }\n \n \t    /* Otherwise, if it returns by invisible reference, dereference\n@@ -10670,7 +10676,8 @@ make_covariant_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n static bool\n maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n {\n-  const Entity_Id gnat_target = Thunk_Entity (gnat_thunk);\n+  /* We use the Thunk_Target to compute the properties of the thunk.  */\n+  const Entity_Id gnat_target = Thunk_Target (gnat_thunk);\n \n   /* Check that the first formal of the target is the only controlling one.  */\n   Entity_Id gnat_formal = First_Formal (gnat_target);\n@@ -10738,7 +10745,9 @@ maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk)\n       indirect_offset = (HOST_WIDE_INT) (POINTER_SIZE / BITS_PER_UNIT);\n     }\n \n-  tree gnu_target = gnat_to_gnu_entity (gnat_target, NULL_TREE, false);\n+  /* But we generate a call to the Thunk_Entity in the thunk.  */\n+  tree gnu_target\n+    = gnat_to_gnu_entity (Thunk_Entity (gnat_thunk), NULL_TREE, false);\n \n   /* If the target is local, then thunk and target must have the same context\n      because cgraph_node::expand_thunk can only forward the static chain.  */"}, {"sha": "3aa810ba21a9dde35791de621f37c27001849ec9", "filename": "gcc/ada/gcc-interface/utils.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Futils.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgcc-interface%2Futils.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.cc?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -3841,11 +3841,10 @@ gnat_useless_type_conversion (tree expr)\n /* Return true if T, a {FUNCTION,METHOD}_TYPE, has the specified flags.  */\n \n bool\n-fntype_same_flags_p (const_tree t, tree cico_list, bool return_unconstrained_p,\n-\t\t     bool return_by_direct_ref_p, bool return_by_invisi_ref_p)\n+fntype_same_flags_p (const_tree t, tree cico_list, bool return_by_direct_ref_p,\n+\t\t     bool return_by_invisi_ref_p)\n {\n   return TYPE_CI_CO_LIST (t) == cico_list\n-\t && TYPE_RETURN_UNCONSTRAINED_P (t) == return_unconstrained_p\n \t && TYPE_RETURN_BY_DIRECT_REF_P (t) == return_by_direct_ref_p\n \t && TREE_ADDRESSABLE (t) == return_by_invisi_ref_p;\n }"}, {"sha": "c6bcb71d40a0d4a2d72e2d17ca1b6d40c8efb6fa", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -88,7 +88,6 @@ package Gen_IL.Fields is\n       Body_Required,\n       Body_To_Inline,\n       Box_Present,\n-      By_Ref,\n       Char_Literal_Value,\n       Chars,\n       Check_Address_Alignment,"}, {"sha": "97c16bce0431519ec3fcf71534fedbf75333cea8", "filename": "gcc/ada/gen_il-gen-gen_nodes.adb", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_nodes.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -1059,7 +1059,6 @@ begin -- Gen_IL.Gen.Gen_Nodes\n \n    Cc (N_Simple_Return_Statement, N_Statement_Other_Than_Procedure_Call,\n        (Sy (Expression, Node_Id, Default_Empty),\n-        Sm (By_Ref, Flag),\n         Sm (Comes_From_Extended_Return_Statement, Flag),\n         Sm (Procedure_To_Call, Node_Id),\n         Sm (Return_Statement_Entity, Node_Id),\n@@ -1068,7 +1067,6 @@ begin -- Gen_IL.Gen.Gen_Nodes\n    Cc (N_Extended_Return_Statement, N_Statement_Other_Than_Procedure_Call,\n        (Sy (Return_Object_Declarations, List_Id),\n         Sy (Handled_Statement_Sequence, Node_Id, Default_Empty),\n-        Sm (By_Ref, Flag),\n         Sm (Procedure_To_Call, Node_Id),\n         Sm (Return_Statement_Entity, Node_Id),\n         Sm (Storage_Pool, Node_Id)));"}, {"sha": "9950d9ecffe310e50fbf706a6e36ce97af323478", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -5989,7 +5989,7 @@ package body Sem_Ch6 is\n          --  the subprogram is abstract also. This does not apply to renaming\n          --  declarations, where abstractness is inherited, and to subprogram\n          --  bodies generated for stream operations, which become renamings as\n-         --  bodies.\n+         --  bodies. We also skip the check for thunks.\n \n          --  In case of primitives associated with abstract interface types\n          --  the check is applied later (see Analyze_Subprogram_Declaration).\n@@ -5998,6 +5998,7 @@ package body Sem_Ch6 is\n               N_Abstract_Subprogram_Declaration        |\n               N_Formal_Abstract_Subprogram_Declaration |\n               N_Subprogram_Renaming_Declaration\n+           and then not Is_Thunk (Designator)\n          then\n             if Is_Abstract_Type (Etype (Designator)) then\n                Error_Msg_N\n@@ -9011,7 +9012,7 @@ package body Sem_Ch6 is\n       --  Local variables\n \n       Formal_Type : Entity_Id;\n-      P_Formal    : Entity_Id := Empty;\n+      P_Formal    : Entity_Id;\n \n    --  Start of processing for Create_Extra_Formals\n \n@@ -9023,10 +9024,10 @@ package body Sem_Ch6 is\n          return;\n       end if;\n \n-      --  No need to generate extra formals in interface thunks whose target\n-      --  primitive has no extra formals.\n+      --  No need to generate extra formals in thunks whose target has no extra\n+      --  formals, but we can have two of them chained (interface and stack).\n \n-      if Is_Thunk (E) and then No (Extra_Formals (Thunk_Entity (E))) then\n+      if Is_Thunk (E) and then No (Extra_Formals (Thunk_Target (E))) then\n          return;\n       end if;\n \n@@ -9036,6 +9037,8 @@ package body Sem_Ch6 is\n \n       if Is_Overloadable (E) and then Present (Alias (E)) then\n          P_Formal := First_Formal (Alias (E));\n+      else\n+         P_Formal := Empty;\n       end if;\n \n       Formal := First_Formal (E);"}, {"sha": "7bead6b3522faef94312038658f9d5270f481fdb", "filename": "gcc/ada/sem_disp.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_disp.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -296,6 +296,12 @@ package body Sem_Disp is\n       Ctrl_Type : Entity_Id;\n \n    begin\n+      --  We skip the check for thunks\n+\n+      if Is_Thunk (Subp) then\n+         return;\n+      end if;\n+\n       Formal := First_Formal (Subp);\n       while Present (Formal) loop\n          Ctrl_Type := Check_Controlling_Type (Etype (Formal), Subp);"}, {"sha": "e1cfa0470aed485feb50f379297e56a18285bd09", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -31,6 +31,7 @@ with Elists;         use Elists;\n with Errout;         use Errout;\n with Erroutc;        use Erroutc;\n with Exp_Ch3;        use Exp_Ch3;\n+with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch11;       use Exp_Ch11;\n with Exp_Util;       use Exp_Util;\n with Fname;          use Fname;\n@@ -6881,19 +6882,25 @@ package body Sem_Util is\n    ----------------------------\n \n    procedure Compute_Returns_By_Ref (Func : Entity_Id) is\n-      Typ  : constant Entity_Id := Etype (Func);\n+      Kind : constant Entity_Kind := Ekind (Func);\n+      Typ  : constant Entity_Id   := Etype (Func);\n \n    begin\n-      if Is_Limited_View (Typ) then\n+      --  Nothing to do for procedures\n+\n+      if Kind in E_Procedure | E_Generic_Procedure\n+        or else (Kind = E_Subprogram_Type and then Typ = Standard_Void_Type)\n+      then\n+         null;\n+\n+      --  The build-in-place protocols return a reference to the result\n+\n+      elsif Is_Build_In_Place_Function (Func) then\n          Set_Returns_By_Ref (Func);\n \n-      --  For class-wide types and types which both need finalization and are\n-      --  returned on the secondary stack, the secondary stack allocation is\n-      --  done by the front end, see Expand_Simple_Function_Return.\n+      --  In Ada 95, limited types are returned by reference\n \n-      elsif Needs_Secondary_Stack (Typ)\n-        and then CW_Or_Needs_Finalization (Underlying_Type (Typ))\n-      then\n+      elsif Is_Limited_View (Typ) then\n          Set_Returns_By_Ref (Func);\n       end if;\n    end Compute_Returns_By_Ref;\n@@ -23481,13 +23488,14 @@ package body Sem_Util is\n       then\n          return Needs_Secondary_Stack (Cloned_Subtype (Typ));\n \n-      --  Functions returning specific tagged types may dispatch on result, so\n-      --  their returned value is allocated on the secondary stack, even in the\n-      --  definite case. We must treat nondispatching functions the same way,\n-      --  because access-to-function types can point at both, so the calling\n-      --  conventions must be compatible.\n+      --  Class-wide types obviously have an unknown size. For specific tagged\n+      --  types, if a call returning one of them is dispatching on result, and\n+      --  this type is not returned on the secondary stack, then the call goes\n+      --  through a thunk that only moves the result from the primary onto the\n+      --  secondary stack, because the computation of the size of the result is\n+      --  possible but complex from the outside.\n \n-      elsif Is_Tagged_Type (Typ) then\n+      elsif Is_Class_Wide_Type (Typ) then\n          return True;\n \n       --  If the return slot of the back end cannot be accessed, then there\n@@ -23498,9 +23506,9 @@ package body Sem_Util is\n       elsif not Back_End_Return_Slot and then Needs_Finalization (Typ) then\n          return True;\n \n-      --  Untagged definite subtypes are known size. This includes all\n-      --  elementary [sub]types. Tasks are known size even if they have\n-      --  discriminants. So we return False here, with one exception:\n+      --  Definite subtypes have a known size. This includes all elementary\n+      --  types. Tasks have a known size even if they have discriminants, so\n+      --  we return False here, with one exception:\n       --  For a type like:\n       --    type T (Last : Natural := 0) is\n       --       X : String (1 .. Last);\n@@ -23513,7 +23521,7 @@ package body Sem_Util is\n       elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n          return Large_Max_Size_Mutable (Typ);\n \n-      --  Indefinite (discriminated) untagged record or protected type\n+      --  Indefinite (discriminated) record or protected type\n \n       elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n          return not Caller_Known_Size_Record (Typ);"}, {"sha": "e18a427f9a2957878e7a43f7350ba14c7c45bb56", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e037d0e36654e84823c47980ef19dc0f77b8ce/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=89e037d0e36654e84823c47980ef19dc0f77b8ce", "patch": "@@ -927,12 +927,6 @@ package Sinfo is\n    --    a pragma Import or Interface applies, in which case no body is\n    --    permitted (in Ada 83 or Ada 95).\n \n-   --  By_Ref\n-   --    Present in N_Simple_Return_Statement and N_Extended_Return_Statement,\n-   --    this flag is set when the returned expression is already allocated on\n-   --    the secondary stack and thus the result is passed by reference rather\n-   --    than copied another time.\n-\n    --  Cleanup_Actions\n    --    Present in block statements created for transient blocks, contains\n    --    additional cleanup actions carried over from the transient scope.\n@@ -5576,7 +5570,6 @@ package Sinfo is\n       --  Expression (set to Empty if no expression present)\n       --  Storage_Pool\n       --  Procedure_To_Call\n-      --  By_Ref\n       --  Comes_From_Extended_Return_Statement\n \n       --  Note: Return_Statement_Entity points to an E_Return_Statement\n@@ -5591,7 +5584,6 @@ package Sinfo is\n       --  Handled_Statement_Sequence (set to Empty if not present)\n       --  Storage_Pool\n       --  Procedure_To_Call\n-      --  By_Ref\n \n       --  Note: Return_Statement_Entity points to an E_Return_Statement.\n "}]}