{"sha": "ceca734e8f8b368ab4087ce3970118775735f593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VjYTczNGU4ZjhiMzY4YWI0MDg3Y2UzOTcwMTE4Nzc1NzM1ZjU5Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-01T16:30:38Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-01T16:30:38Z"}, "message": "expr.c (emit_move_complex_push): Export.\n\n        * expr.c (emit_move_complex_push): Export.\n        (emit_move_complex_parts): Split out from ...\n        (emit_move_complex): ... here.\n        * expr.h (emit_move_complex_push, emit_move_complex_parts): Declare.\n        * config/i386/i386.md (movcdi): New.\n\nFrom-SVN: r122432", "tree": {"sha": "b6d11fc471a5238e81dafa6b6bd684ff01ef7366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6d11fc471a5238e81dafa6b6bd684ff01ef7366"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceca734e8f8b368ab4087ce3970118775735f593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceca734e8f8b368ab4087ce3970118775735f593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceca734e8f8b368ab4087ce3970118775735f593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceca734e8f8b368ab4087ce3970118775735f593/comments", "author": null, "committer": null, "parents": [{"sha": "5f81370d9f02d82b58964b104eb60197b7e773ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f81370d9f02d82b58964b104eb60197b7e773ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f81370d9f02d82b58964b104eb60197b7e773ef"}], "stats": {"total": 59, "additions": 48, "deletions": 11}, "files": [{"sha": "b0e26a9bb138db5f8ac145e781a5c2eb2b2eb5d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceca734e8f8b368ab4087ce3970118775735f593", "patch": "@@ -1,3 +1,11 @@\n+2007-03-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (emit_move_complex_push): Export.\n+\t(emit_move_complex_parts): Split out from ...\n+\t(emit_move_complex): ... here.\n+\t* expr.h (emit_move_complex_push, emit_move_complex_parts): Declare.\n+\t* config/i386/i386.md (movcdi): New.\n+\n 2007-03-01  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (ix86_modes_tieable_p): Fix typo, use also"}, {"sha": "409ce0c5f78ffd13f8373afd1e74de7da67f1363", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ceca734e8f8b368ab4087ce3970118775735f593", "patch": "@@ -2266,6 +2266,22 @@\n   [(const_int 0)]\n   \"ix86_split_long_move (operands); DONE;\")\n \n+;; This expands to what emit_move_complex would generate if we didn't\n+;; have a movti pattern.  Having this avoids problems with reload on\n+;; 32-bit targets when SSE is present, but doesn't seem to be harmful\n+;; to have around all the time.\n+(define_expand \"movcdi\"\n+  [(set (match_operand:CDI 0 \"nonimmediate_operand\" \"\")\n+\t(match_operand:CDI 1 \"general_operand\" \"\"))]\n+  \"\"\n+{\n+  if (push_operand (operands[0], CDImode))\n+    emit_move_complex_push (CDImode, operands[0], operands[1]);\n+  else\n+    emit_move_complex_parts (operands[0], operands[1]);\n+  DONE;\n+})\n+\n (define_expand \"movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"general_operand\" \"\"))]"}, {"sha": "1dc437cb8368ee32af52fc29e655775d3bd41fbd", "filename": "gcc/expr.c", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ceca734e8f8b368ab4087ce3970118775735f593", "patch": "@@ -2987,7 +2987,7 @@ emit_move_resolve_push (enum machine_mode mode, rtx x)\n    X is known to satisfy push_operand, and MODE is known to be complex.\n    Returns the last instruction emitted.  */\n \n-static rtx\n+rtx\n emit_move_complex_push (enum machine_mode mode, rtx x, rtx y)\n {\n   enum machine_mode submode = GET_MODE_INNER (mode);\n@@ -3027,6 +3027,25 @@ emit_move_complex_push (enum machine_mode mode, rtx x, rtx y)\n \t\t\t read_complex_part (y, !imag_first));\n }\n \n+/* A subroutine of emit_move_complex.  Perform the move from Y to X\n+   via two moves of the parts.  Returns the last instruction emitted.  */\n+\n+rtx\n+emit_move_complex_parts (rtx x, rtx y)\n+{\n+  /* Show the output dies here.  This is necessary for SUBREGs\n+     of pseudos since we cannot track their lifetimes correctly;\n+     hard regs shouldn't appear here except as return values.  */\n+  if (!reload_completed && !reload_in_progress\n+      && REG_P (x) && !reg_overlap_mentioned_p (x, y))\n+    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n+\n+  write_complex_part (x, read_complex_part (y, false), false);\n+  write_complex_part (x, read_complex_part (y, true), true);\n+\n+  return get_last_insn ();\n+}\n+\n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n    MODE is known to be complex.  Returns the last instruction emitted.  */\n \n@@ -3081,16 +3100,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \treturn ret;\n     }\n \n-  /* Show the output dies here.  This is necessary for SUBREGs\n-     of pseudos since we cannot track their lifetimes correctly;\n-     hard regs shouldn't appear here except as return values.  */\n-  if (!reload_completed && !reload_in_progress\n-      && REG_P (x) && !reg_overlap_mentioned_p (x, y))\n-    emit_insn (gen_rtx_CLOBBER (VOIDmode, x));\n-\n-  write_complex_part (x, read_complex_part (y, false), false);\n-  write_complex_part (x, read_complex_part (y, true), true);\n-  return get_last_insn ();\n+  return emit_move_complex_parts (x, y);\n }\n \n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X."}, {"sha": "bc3feeeab80346a189fb0e2765c3c2b3ba9eb7cb", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceca734e8f8b368ab4087ce3970118775735f593/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=ceca734e8f8b368ab4087ce3970118775735f593", "patch": "@@ -465,6 +465,9 @@ extern rtx emit_move_insn (rtx, rtx);\n /* Emit insns to set X from Y, with no frills.  */\n extern rtx emit_move_insn_1 (rtx, rtx);\n \n+extern rtx emit_move_complex_push (enum machine_mode, rtx, rtx);\n+extern rtx emit_move_complex_parts (rtx, rtx);\n+\n /* Push a block of length SIZE (perhaps variable)\n    and return an rtx to address the beginning of the block.  */\n extern rtx push_block (rtx, int, int);"}]}