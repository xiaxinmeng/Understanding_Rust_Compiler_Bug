{"sha": "84973b27e8283fa75075f124ad4e6e14dc7726a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ5NzNiMjdlODI4M2ZhNzUwNzVmMTI0YWQ0ZTZlMTRkYzc3MjZhNA==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2005-01-14T07:36:27Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2005-01-14T07:36:27Z"}, "message": "jni.h (_Jv_JNIEnv::bottom_locals): New field.\n\n2005-01-13  Graydon Hoare  <graydon@redhat.com>\n\n\t* include/jni.h (_Jv_JNIEnv::bottom_locals): New field.\n\t* include/jvm.h (_Jv_FreeJNIEnv): Declare.\n\t* java/lang/natThread.cc (finalize_native): Call _Jv_FreeJNIEnv.\n\t* jni.cc: Reuse bottom frame between calls, avoid clearing\n\tframe when no local references are made.\n\nFrom-SVN: r93632", "tree": {"sha": "57a4dece632a26e9b5430fff053a24e1b01280d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57a4dece632a26e9b5430fff053a24e1b01280d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84973b27e8283fa75075f124ad4e6e14dc7726a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84973b27e8283fa75075f124ad4e6e14dc7726a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84973b27e8283fa75075f124ad4e6e14dc7726a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84973b27e8283fa75075f124ad4e6e14dc7726a4/comments", "author": null, "committer": null, "parents": [{"sha": "a0ee8b5f99e1d646105e0f916ae443f1c512b454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0ee8b5f99e1d646105e0f916ae443f1c512b454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0ee8b5f99e1d646105e0f916ae443f1c512b454"}], "stats": {"total": 119, "additions": 98, "deletions": 21}, "files": [{"sha": "40b9998232edeff4e58cd384291beae135ee5cac", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=84973b27e8283fa75075f124ad4e6e14dc7726a4", "patch": "@@ -1,3 +1,11 @@\n+2005-01-13  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* include/jni.h (_Jv_JNIEnv::bottom_locals): New field.\n+\t* include/jvm.h (_Jv_FreeJNIEnv): Declare.\n+\t* java/lang/natThread.cc (finalize_native): Call _Jv_FreeJNIEnv.\n+\t* jni.cc: Reuse bottom frame between calls, avoid clearing\n+\tframe when no local references are made.\n+\n 2005-01-13  Michael Koch  <konqueror@gmx.de>\n \n \tPR libgcj/17784"}, {"sha": "c1b6e20b5abec54973fec8772c1701f70dcaab03", "filename": "libjava/include/jni.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=84973b27e8283fa75075f124ad4e6e14dc7726a4", "patch": "@@ -693,6 +693,10 @@ class _Jv_JNIEnv\n   /* The chain of local frames.  */\n   struct _Jv_JNI_LocalFrame *locals;\n \n+  /* The bottom-most element of the chain, initialized with the env and\n+     reused between non-nesting JNI calls.  */\n+  struct _Jv_JNI_LocalFrame *bottom_locals;\n+\n public:\n   jint GetVersion ()\n   { return p->GetVersion (this); }"}, {"sha": "67a4b18176e81c9f80b676718a9b733437572d54", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=84973b27e8283fa75075f124ad4e6e14dc7726a4", "patch": "@@ -522,6 +522,9 @@ extern void _Jv_JNI_Init (void);\n _Jv_JNIEnv *_Jv_GetCurrentJNIEnv ();\n void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *);\n \n+/* Free a JNIEnv. */\n+void _Jv_FreeJNIEnv (_Jv_JNIEnv *);\n+\n struct _Jv_JavaVM;\n _Jv_JavaVM *_Jv_GetJavaVM (); \n "}, {"sha": "e79ab11b9c600a07ec5b9c53a7cdfcdf483dabd1", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=84973b27e8283fa75075f124ad4e6e14dc7726a4", "patch": "@@ -84,6 +84,7 @@ finalize_native (jobject ptr)\n #ifdef _Jv_HaveMutexDestroy\n   _Jv_MutexDestroy (&nt->join_mutex);\n #endif\n+  _Jv_FreeJNIEnv(nt->jni_env);\n }\n \n jint"}, {"sha": "6e0ab899c3ed86ac69d62263dc6af0bfcb602c3f", "filename": "libjava/jni.cc", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84973b27e8283fa75075f124ad4e6e14dc7726a4/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=84973b27e8283fa75075f124ad4e6e14dc7726a4", "patch": "@@ -71,7 +71,7 @@ extern struct JNIInvokeInterface _Jv_JNI_InvokeFunctions;\n \n // Number of slots in the default frame.  The VM must allow at least\n // 16.\n-#define FRAME_SIZE 32\n+#define FRAME_SIZE 16\n \n // Mark value indicating this is an overflow frame.\n #define MARK_NONE    0\n@@ -85,10 +85,13 @@ struct _Jv_JNI_LocalFrame\n {\n   // This is true if this frame object represents a pushed frame (eg\n   // from PushLocalFrame).\n-  int marker :  2;\n+  int marker;\n+\n+  // Flag to indicate some locals were allocated.\n+  int allocated_p;\n \n   // Number of elements in frame.\n-  int size   : 30;\n+  int size;\n \n   // Next frame in chain.\n   _Jv_JNI_LocalFrame *next;\n@@ -289,6 +292,7 @@ _Jv_JNI_EnsureLocalCapacity (JNIEnv *env, jint size)\n \n   frame->marker = MARK_NONE;\n   frame->size = size;\n+  frame->allocated_p = 0;\n   memset (&frame->vec[0], 0, size * sizeof (jobject));\n   frame->next = env->locals;\n   env->locals = frame;\n@@ -327,6 +331,7 @@ _Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n \t      set = true;\n \t      done = true;\n \t      frame->vec[i] = obj;\n+\t      frame->allocated_p = 1;\n \t      break;\n \t    }\n \t}\n@@ -344,6 +349,7 @@ _Jv_JNI_NewLocalRef (JNIEnv *env, jobject obj)\n       _Jv_JNI_EnsureLocalCapacity (env, 16);\n       // We know the first element of the new frame will be ok.\n       env->locals->vec[0] = obj;\n+      env->locals->allocated_p = 1;\n     }\n \n   mark_for_gc (obj, local_ref_table);\n@@ -366,12 +372,14 @@ _Jv_JNI_PopLocalFrame (JNIEnv *env, jobject result, int stop)\n       done = (rf->marker == stop);\n \n       _Jv_JNI_LocalFrame *n = rf->next;\n-      // When N==NULL, we've reached the stack-allocated frame, and we\n-      // must not free it.  However, we must be sure to clear all its\n-      // elements, since we might conceivably reuse it.\n+      // When N==NULL, we've reached the reusable bottom_locals, and we must\n+      // not free it.  However, we must be sure to clear all its elements.\n       if (n == NULL)\n \t{\n-\t  memset (&rf->vec[0], 0, rf->size * sizeof (jobject));\n+\t  if (rf->allocated_p)\n+\t    memset (&rf->vec[0], 0, rf->size * sizeof (jobject));\n+\t  rf->allocated_p = 0;\n+\t  rf = NULL;\n \t  break;\n \t}\n \n@@ -412,9 +420,17 @@ _Jv_JNI_check_types (JNIEnv *env, JArray<T> *array, jclass K)\n extern \"C\" void\n _Jv_JNI_PopSystemFrame (JNIEnv *env)\n {\n-  _Jv_JNI_PopLocalFrame (env, NULL, MARK_SYSTEM);\n+  // Only enter slow path when we're not at the bottom, or there have been\n+  // allocations. Usually this is false and we can just null out the locals\n+  // field.\n \n-  if (env->ex)\n+  if (__builtin_expect ((env->locals->next \n+\t\t\t || env->locals->allocated_p), false))\n+    _Jv_JNI_PopLocalFrame (env, NULL, MARK_SYSTEM);\n+  else\n+    env->locals = NULL;\n+  \n+  if (__builtin_expect (env->ex != NULL, false))\n     {\n       jthrowable t = env->ex;\n       env->ex = NULL;\n@@ -2030,35 +2046,78 @@ extern \"C\" JNIEnv *\n _Jv_GetJNIEnvNewFrame (jclass klass)\n {\n   JNIEnv *env = _Jv_GetCurrentJNIEnv ();\n-  if (env == NULL)\n+  if (__builtin_expect (env == NULL, false))\n     {\n       env = (JNIEnv *) _Jv_MallocUnchecked (sizeof (JNIEnv));\n       env->p = &_Jv_JNIFunctions;\n       env->klass = klass;\n       env->locals = NULL;\n       // We set env->ex below.\n \n+      // Set up the bottom, reusable frame.\n+      env->bottom_locals = (_Jv_JNI_LocalFrame *) \n+\t_Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t     + (FRAME_SIZE\n+\t\t\t\t* sizeof (jobject)));\n+      \n+      env->bottom_locals->marker = MARK_SYSTEM;\n+      env->bottom_locals->size = FRAME_SIZE;\n+      env->bottom_locals->next = NULL;\n+      env->bottom_locals->allocated_p = 0;\n+      memset (&env->bottom_locals->vec[0], 0, \n+\t      env->bottom_locals->size * sizeof (jobject));\n+\n       _Jv_SetCurrentJNIEnv (env);\n     }\n \n-  _Jv_JNI_LocalFrame *frame\n-    = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n-\t\t\t\t\t\t  + (FRAME_SIZE\n-\t\t\t\t\t\t     * sizeof (jobject)));\n+  // If we're in a simple JNI call (non-nested), we can just reuse the\n+  // locals frame we allocated many calls ago, back when the env was first\n+  // built, above.\n \n-  frame->marker = MARK_SYSTEM;\n-  frame->size = FRAME_SIZE;\n-  frame->next = env->locals;\n+  if (__builtin_expect (env->locals == NULL, true))\n+    env->locals = env->bottom_locals;\n \n-  for (int i = 0; i < frame->size; ++i)\n-    frame->vec[i] = NULL;\n+  else\n+    {\n+      // Alternatively, we might be re-entering JNI, in which case we can't\n+      // reuse the bottom_locals frame, because it is already underneath\n+      // us. So we need to make a new one.\n+\n+      _Jv_JNI_LocalFrame *frame\n+\t= (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t\t\t      + (FRAME_SIZE\n+\t\t\t\t\t\t\t * sizeof (jobject)));\n+      \n+      frame->marker = MARK_SYSTEM;\n+      frame->size = FRAME_SIZE;\n+      frame->allocated_p = 0;\n+      frame->next = env->locals;\n+\n+      memset (&frame->vec[0], 0, \n+\t      frame->size * sizeof (jobject));\n+\n+      env->locals = frame;\n+    }\n \n-  env->locals = frame;\n   env->ex = NULL;\n \n   return env;\n }\n \n+// Destroy the env's reusable resources. This is called from the thread\n+// destructor \"finalize_native\" in natThread.cc\n+void \n+_Jv_FreeJNIEnv (_Jv_JNIEnv *env)\n+{\n+  if (env == NULL)\n+    return;\n+\n+  if (env->bottom_locals != NULL)\n+    _Jv_Free (env->bottom_locals);\n+\n+  _Jv_Free (env);\n+}\n+\n // Return the function which implements a particular JNI method.  If\n // we can't find the function, we throw the appropriate exception.\n // This is `extern \"C\"' because the compiler uses it.\n@@ -2274,16 +2333,18 @@ _Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv,\n   env->p = &_Jv_JNIFunctions;\n   env->ex = NULL;\n   env->klass = NULL;\n-  env->locals\n+  env->bottom_locals\n     = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n \t\t\t\t\t\t  + (FRAME_SIZE\n \t\t\t\t\t\t     * sizeof (jobject)));\n+  env->locals = env->bottom_locals;\n   if (env->locals == NULL)\n     {\n       _Jv_Free (env);\n       return JNI_ERR;\n     }\n \n+  env->locals->allocated_p = 0;\n   env->locals->marker = MARK_SYSTEM;\n   env->locals->size = FRAME_SIZE;\n   env->locals->next = NULL;"}]}