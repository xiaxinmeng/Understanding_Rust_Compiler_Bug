{"sha": "1214196da79aabbe5c14ed36e5a28012e141f04c", "node_id": "C_kwDOANBUbNoAKDEyMTQxOTZkYTc5YWFiYmU1YzE0ZWQzNmU1YTI4MDEyZTE0MWYwNGM", "commit": {"author": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-09-30T23:26:31Z"}, "committer": {"name": "Jeff Law", "email": "jeffreyalaw@gmail.com", "date": "2022-09-30T23:31:33Z"}, "message": "More gimple const/copy propagation opportunities\n\nWhile investigating a benchmark for optimization opportunities I came across single block loop which either iterates precisely once or forever.    This is an interesting scenario as we can ignore the infinite looping path and treat any PHI nodes as degenerates.  So more concretely let's consider this trivial testcase:\n\nvolatile void abort (void);\n\nvoid\nfoo(int a)\n{\n int b = 0;\n\n while (1)\n   {\n     if (!a)\n       break;\n     b = 1;\n   }\n\n if (b != 0)\n   abort ();\n}\n\nQuick analysis shows that b's initial value is 0 and its value only changes if we enter an infinite loop.  So if we get to the test b != 0, the only possible value b could have would be 0 and the test and its true arm can be eliminated.\n\nThe DOM3 dump looks something like this:\n\n;;   basic block 2, loop depth 0, count 118111600 (estimated locally), maybe hot\n;;    prev block 0, next block 3, flags: (NEW, VISITED)\n;;    pred:       ENTRY [always]  count:118111600 (estimated locally) (FALLTHRU,EXECUTABLE)\n;;    succ:       3 [always]  count:118111600 (estimated locally) (FALLTHRU,EXECUTABLE)\n\n;;   basic block 3, loop depth 1, count 1073741824 (estimated locally), maybe hot\n;;    prev block 2, next block 4, flags: (NEW, VISITED)\n;;    pred:       2 [always]  count:118111600 (estimated locally) (FALLTHRU,EXECUTABLE)\n;;                3 [89.0% (guessed)]  count:955630224 (estimated locally) (FALSE_VALUE,EXECUTABLE)\n  # b_1 = PHI <0(2), 1(3)>\n  if (a_3(D) == 0)\n    goto <bb 4>; [11.00%]\n  else\n    goto <bb 3>; [89.00%]\n;;    succ:       4 [11.0% (guessed)]  count:118111600 (estimated locally) (TRUE_VALUE,EXECUTABLE)\n;;                3 [89.0% (guessed)]  count:955630224 (estimated locally) (FALSE_VALUE,EXECUTABLE)\n\n;;   basic block 4, loop depth 0, count 118111600 (estimated locally), maybe hot\n;;    prev block 3, next block 5, flags: (NEW, VISITED)\n;;    pred:       3 [11.0% (guessed)]  count:118111600 (estimated locally) (TRUE_VALUE,EXECUTABLE)\n  if (b_1 != 0)\n    goto <bb 5>; [0.00%]\n  else\n    goto <bb 6>; [100.00%]\n;;    succ:       5 [never]  count:0 (precise) (TRUE_VALUE,EXECUTABLE)\n;;                6 [always]  count:118111600 (estimated locally) (FALSE_VALUE,EXECUTABLE)\n\nThis is a good representative of what the benchmark code looks like.\n\nThe primary effect we want to capture is to realize that the test if (b_1 != 0) is always false and optimize it accordingly.\n\nIn the benchmark, this opportunity is well hidden until after the loop optimizers have completed, so the first chance to capture this case is in DOM3.  Furthermore, DOM wants loops normalized with latch blocks/edges.  So instead of bb3 looping back to itself, there's an intermediate empty block during DOM.\n\nI originally thought this was likely to only affect the benchmark.  But when I instrumented the optimization and bootstrapped GCC, much to my surprise there were several hundred similar cases identified in GCC itself.  So it's not as benchmark specific as I'd initially feared.\n\nAnyway, detecting this in DOM is pretty simple.   We detect the infinite loop, including the latch block.  Once we've done that, we walk the PHI nodes and attach equivalences to the appropriate outgoing edge.   That's all we need to do as the rest of DOM is already prepared to handle equivalences on edges.\n\ngcc/\n\t* tree-ssa-dom.cc (single_block_loop_p): New function.\n\t(record_edge_info): Also record equivalences for the outgoing\n\tedge of a single block loop where the condition is an invariant.\n\ngcc/testsuite/\n\t* gcc.dg/infinite-loop.c: New test.", "tree": {"sha": "101a2d79eff477ec8c28074b733b2c4f2ed69035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/101a2d79eff477ec8c28074b733b2c4f2ed69035"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1214196da79aabbe5c14ed36e5a28012e141f04c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1214196da79aabbe5c14ed36e5a28012e141f04c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1214196da79aabbe5c14ed36e5a28012e141f04c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1214196da79aabbe5c14ed36e5a28012e141f04c/comments", "author": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JeffreyALaw", "id": 14062506, "node_id": "MDQ6VXNlcjE0MDYyNTA2", "avatar_url": "https://avatars.githubusercontent.com/u/14062506?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JeffreyALaw", "html_url": "https://github.com/JeffreyALaw", "followers_url": "https://api.github.com/users/JeffreyALaw/followers", "following_url": "https://api.github.com/users/JeffreyALaw/following{/other_user}", "gists_url": "https://api.github.com/users/JeffreyALaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/JeffreyALaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JeffreyALaw/subscriptions", "organizations_url": "https://api.github.com/users/JeffreyALaw/orgs", "repos_url": "https://api.github.com/users/JeffreyALaw/repos", "events_url": "https://api.github.com/users/JeffreyALaw/events{/privacy}", "received_events_url": "https://api.github.com/users/JeffreyALaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89b5a316cffa4a9fa2504e776a4cdc2ef492f00b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b5a316cffa4a9fa2504e776a4cdc2ef492f00b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b5a316cffa4a9fa2504e776a4cdc2ef492f00b"}], "stats": {"total": 159, "additions": 157, "deletions": 2}, "files": [{"sha": "25037a2027ec53a5f4822da1724840a61bba62df", "filename": "gcc/testsuite/gcc.dg/infinite-loop.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1214196da79aabbe5c14ed36e5a28012e141f04c/gcc%2Ftestsuite%2Fgcc.dg%2Finfinite-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1214196da79aabbe5c14ed36e5a28012e141f04c/gcc%2Ftestsuite%2Fgcc.dg%2Finfinite-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finfinite-loop.c?ref=1214196da79aabbe5c14ed36e5a28012e141f04c", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O2\" } */\n+void link_error (void);\n+\n+void __attribute__ ((noinline,noipa))\n+foo(int a)\n+{\n+ int b = 0;\n+\n+ while (1)\n+   {\n+     if (!a)\n+       break;\n+     b = 1;\n+   }\n+\n+ if (b != 0)\n+   link_error ();\n+}\n+\n+int\n+main()\n+{\n+  foo (0);\n+}\n+"}, {"sha": "8d8312ca3500ddbd1b50f3b31e979f1a243347da", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 131, "deletions": 2, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1214196da79aabbe5c14ed36e5a28012e141f04c/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1214196da79aabbe5c14ed36e5a28012e141f04c/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=1214196da79aabbe5c14ed36e5a28012e141f04c", "patch": "@@ -426,6 +426,74 @@ free_all_edge_infos (void)\n     }\n }\n \n+/* Return TRUE if BB has precisely two preds, one of which\n+   is a backedge from a forwarder block where the forwarder\n+   block is a direct successor of BB.  Being a forwarder\n+   block, it has no side effects other than transfer of\n+   control.  Otherwise return FALSE.  */\n+\n+static bool\n+single_block_loop_p (basic_block bb)\n+{\n+  /* Two preds.  */\n+  if (EDGE_COUNT (bb->preds) != 2)\n+    return false;\n+\n+  /* One and only one of the edges must be marked with\n+     EDGE_DFS_BACK.  */\n+  basic_block pred = NULL;\n+  unsigned int count = 0;\n+  if (EDGE_PRED (bb, 0)->flags & EDGE_DFS_BACK)\n+    {\n+      pred = EDGE_PRED (bb, 0)->src;\n+      count++;\n+    }\n+  if (EDGE_PRED (bb, 1)->flags & EDGE_DFS_BACK)\n+    {\n+      pred = EDGE_PRED (bb, 1)->src;\n+      count++;\n+    }\n+\n+  if (count != 1)\n+    return false;\n+\n+  /* Now examine PRED.  It should have a single predecessor which\n+     is BB and a single successor that is also BB.  */\n+  if (EDGE_COUNT (pred->preds) != 1\n+      || EDGE_COUNT (pred->succs) != 1\n+      || EDGE_PRED (pred, 0)->src != bb\n+      || EDGE_SUCC (pred, 0)->dest != bb)\n+    return false;\n+\n+  /* This looks good from a CFG standpoint.  Now look at the guts\n+     of PRED.  Basically we want to verify there are no PHI nodes\n+     and no real statements.  */\n+  if (! gimple_seq_empty_p (phi_nodes (pred)))\n+    return false;\n+\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_last_bb (pred); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+\n+      switch (gimple_code (stmt))\n+\t{\n+\t  case GIMPLE_LABEL:\n+\t    if (DECL_NONLOCAL (gimple_label_label (as_a <glabel *> (stmt))))\n+\t      return false;\n+\t    break;\n+\n+\t  case GIMPLE_DEBUG:\n+\t    break;\n+\n+\t  default:\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* We have finished optimizing BB, record any information implied by\n    taking a specific outgoing edge from BB.  */\n \n@@ -435,6 +503,13 @@ record_edge_info (basic_block bb)\n   gimple_stmt_iterator gsi = gsi_last_bb (bb);\n   class edge_info *edge_info;\n \n+  /* Free all the outgoing edge info data associated with\n+     BB's outgoing edges.  */\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    free_dom_edge_info (e);\n+\n   if (! gsi_end_p (gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n@@ -450,8 +525,6 @@ record_edge_info (basic_block bb)\n \t      int i;\n               int n_labels = gimple_switch_num_labels (switch_stmt);\n \t      tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));\n-\t      edge e;\n-\t      edge_iterator ei;\n \n \t      for (i = 0; i < n_labels; i++)\n \t\t{\n@@ -583,6 +656,62 @@ record_edge_info (basic_block bb)\n               if (can_infer_simple_equiv && TREE_CODE (inverted) == EQ_EXPR)\n \t\tedge_info->record_simple_equiv (op0, op1);\n             }\n+\n+\t  /* If this block is a single block loop, then we may be able to\n+\t     record some equivalences on the loop's exit edge.  */\n+\t  if (single_block_loop_p (bb))\n+\t    {\n+\t      /* We know it's a single block loop.  Now look at the loop\n+\t\t exit condition.  What we're looking for is whether or not\n+\t\t the exit condition is loop invariant which we can detect\n+\t\t by checking if all the SSA_NAMEs referenced are defined\n+\t\t outside the loop.  */\n+\t      if ((TREE_CODE (op0) != SSA_NAME\n+\t\t   || gimple_bb (SSA_NAME_DEF_STMT (op0)) != bb)\n+\t\t  && (TREE_CODE (op1) != SSA_NAME\n+\t\t      || gimple_bb (SSA_NAME_DEF_STMT (op1)) != bb))\n+\t\t{\n+\t\t  /* At this point we know the exit condition is loop\n+\t\t     invariant.  The only way to get out of the loop is\n+\t\t     if never traverses the backedge to begin with.  This\n+\t\t     implies that any PHI nodes create equivalances we can\n+\t\t     attach to the loop exit edge.  */\n+\t\t  int alternative\n+\t\t    = (EDGE_PRED (bb, 0)->flags & EDGE_DFS_BACK) ? 1 : 0;\n+\n+\t\t  gphi_iterator gsi;\n+\t\t  for (gsi = gsi_start_phis (bb);\n+\t\t       !gsi_end_p (gsi);\n+\t\t       gsi_next (&gsi))\n+\t\t    {\n+\t\t      /* If the other alternative is the same as the result,\n+\t\t\t then this is a degenerate and can be ignored.  */\n+\t\t      if (dst == PHI_ARG_DEF (phi, !alternative))\n+\t\t\tcontinue;\n+\n+\t\t      /* Now get the EDGE_INFO class so we can append\n+\t\t\t it to our list.  We want the successor edge\n+\t\t\t where the destination is not the source of\n+\t\t\t an incoming edge.  */\n+\t\t      gphi *phi = gsi.phi ();\n+\t\t      tree src = PHI_ARG_DEF (phi, alternative);\n+\t\t      tree dst = PHI_RESULT (phi);\n+\n+\t\t      if (EDGE_SUCC (bb, 0)->dest\n+\t\t\t  != EDGE_PRED (bb, !alternative)->src)\n+\t\t\tedge_info = (class edge_info *)EDGE_SUCC (bb, 0)->aux;\n+\t\t      else\n+\t\t\tedge_info = (class edge_info *)EDGE_SUCC (bb, 1)->aux;\n+\n+\t\t      /* Note that since this processing is done independently\n+\t\t\t of other edge equivalency processing, we may not\n+\t\t\t have an EDGE_INFO structure set up yet.  */\n+\t\t      if (edge_info == NULL)\n+\t\t\tedge_info = new class edge_info (false_edge);\n+\t\t      edge_info->record_simple_equiv (dst, src);\n+\t\t    }\n+\t\t}\n+\t    }\n         }\n     }\n }"}]}