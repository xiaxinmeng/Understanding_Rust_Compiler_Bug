{"sha": "4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU1YjAwMmJhYTVjZTkwOTdlM2ExYTQ3OThiMzFjODNmMGUyZWY1Ng==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2004-09-08T19:17:53Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2004-09-08T19:17:53Z"}, "message": "sparc.c (sparc_indent_opcode): New variable.\n\n\t* config/sparc/sparc.c (sparc_indent_opcode): New variable.\n\t(output_return): Do not test for the presence of the 'unimp' insn.\n\tUse 'current_function_uses_only_leaf_regs' and 'final_sequence'\n\tas predicates instead of custom ones.  Return raw strings when\n\tpossible.\n\t(output_sibcall): Likewise.  Concatenate strings.\n\t(output_ubranch): Remove kludge for TurboSPARC.\n\t(output_cbranch): Remove 'noop' parameter.  Do not output 'nop'.\n\t(output_v9branch): Likewise.\n\t(print_operand): Use 'final_sequence' instead of 'dbr_sequence_length'.\n\t<#>: Set sparc_indent_opcode if the delay slot is filled.\n\t<(>: Likewise.\n\t<)>: New operand to emit the displacement from the saved PC on return.\n\t<@>: Remove.\n\t* config/sparc/sparc.h (sparc_indent_opcode): Declare it.\n\t(ASM_OUTPUT_OPCODE): New macro.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Remove '^' and add ')'.\n\t* config/sparc/sparc.md (normal_branch, inverted_branch,\n\tnormal_fp_branch, inverted_fp_branch, normal_fpe_branch,\n\tinverted_fpe_branch): Adjust call to output_cbranch.\n\t(normal_int_branch_sp64, inverted_int_branch_sp64): Adjust\n\tcall to output_v9branch.\n\t* config/sparc/sparc-protos.h (output_cbranch): Adjust.\n\t(output_v9branch): Likewise.\n\nFrom-SVN: r87198", "tree": {"sha": "a9321393d72a1201f896606a77956af853d6274c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9321393d72a1201f896606a77956af853d6274c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5826770c628d6e527ac774243d3632ad44ed49ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5826770c628d6e527ac774243d3632ad44ed49ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5826770c628d6e527ac774243d3632ad44ed49ce"}], "stats": {"total": 284, "additions": 132, "deletions": 152}, "files": [{"sha": "063bcfffaaf76ae5ee0e52598496be4ef3d220da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "patch": "@@ -1,3 +1,30 @@\n+2004-09-08  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/sparc.c (sparc_indent_opcode): New variable.\n+\t(output_return): Do not test for the presence of the 'unimp' insn.\n+\tUse 'current_function_uses_only_leaf_regs' and 'final_sequence'\n+\tas predicates instead of custom ones.  Return raw strings when\n+\tpossible.\n+\t(output_sibcall): Likewise.  Concatenate strings.\n+\t(output_ubranch): Remove kludge for TurboSPARC.\n+\t(output_cbranch): Remove 'noop' parameter.  Do not output 'nop'.\n+\t(output_v9branch): Likewise.\n+\t(print_operand): Use 'final_sequence' instead of 'dbr_sequence_length'.\n+\t<#>: Set sparc_indent_opcode if the delay slot is filled.\n+\t<(>: Likewise.\n+\t<)>: New operand to emit the displacement from the saved PC on return.\n+\t<@>: Remove.\n+\t* config/sparc/sparc.h (sparc_indent_opcode): Declare it.\n+\t(ASM_OUTPUT_OPCODE): New macro.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Remove '^' and add ')'.\n+\t* config/sparc/sparc.md (normal_branch, inverted_branch,\n+\tnormal_fp_branch, inverted_fp_branch, normal_fpe_branch,\n+\tinverted_fpe_branch): Adjust call to output_cbranch.\n+\t(normal_int_branch_sp64, inverted_int_branch_sp64): Adjust\n+\tcall to output_v9branch.\n+\t* config/sparc/sparc-protos.h (output_cbranch): Adjust.\n+\t(output_v9branch): Likewise.\n+\n 2004-09-08  Devang Patel  <dpatel@apple.com>\n \n \t* config/darwin.h  (TARGET_OPTION_TRANSLATE_TABLE): Add -segaddr,"}, {"sha": "71599c962233241048f0e099b8fd54e6005c109d", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "patch": "@@ -81,11 +81,11 @@ extern void sparc_emit_set_symbolic_const64 (rtx, rtx, rtx);\n extern int sparc_splitdi_legitimate (rtx, rtx);\n extern int sparc_absnegfloat_split_legitimate (rtx, rtx);\n extern const char *output_ubranch (rtx, int, rtx);\n-extern const char *output_cbranch (rtx, rtx, int, int, int, int, rtx);\n+extern const char *output_cbranch (rtx, rtx, int, int, int, rtx);\n extern const char *output_return (rtx);\n extern const char *output_sibcall (rtx, rtx);\n extern const char *output_v8plus_shift (rtx *, rtx, const char *);\n-extern const char *output_v9branch (rtx, rtx, int, int, int, int, int, rtx);\n+extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n extern void emit_v9_brxx_insn (enum rtx_code, rtx, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);"}, {"sha": "336d832e61a49ff6b09cbc908517f423489cefbc", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 80, "deletions": 140, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "patch": "@@ -276,10 +276,12 @@ struct machine_function GTY(())\n    Normally, this is %fp, but if we are in a leaf procedure, this\n    is %sp+\"something\".  We record \"something\" separately as it may\n    be too big for reg+constant addressing.  */\n-\n static rtx frame_base_reg;\n static HOST_WIDE_INT frame_base_offset;\n \n+/* 1 if the next opcode is to be specially indented.  */\n+int sparc_indent_opcode = 0;\n+\n static void sparc_init_modes (void);\n static void scan_record_type (tree, int *, int *, int *);\n static int function_arg_slotno (const CUMULATIVE_ARGS *, enum machine_mode,\n@@ -4675,44 +4677,17 @@ output_restore (rtx pat)\n const char *\n output_return (rtx insn)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n-  bool delay_slot_filled_p = dbr_sequence_length () > 0;\n-  /* True if the caller has placed an \"unimp\" insn immediately after the call.\n-     This insn is used in the 32-bit ABI when calling a function that returns\n-     a non zero-sized structure. The 64-bit ABI doesn't have it.  Be careful\n-     to have this test be the same as that used on the call.  */\n-  bool sparc_skip_caller_unimp\n-    = ! TARGET_ARCH64\n-      && current_function_returns_struct\n-      && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n-\t  == INTEGER_CST)\n-      && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl)));\n-\n-  if (leaf_function_p)\n+  if (current_function_uses_only_leaf_regs)\n     {\n       /* This is a leaf function so we don't have to bother restoring the\n \t register window, which frees us from dealing with the convoluted\n \t semantics of restore/return.  We simply output the jump to the\n-\t return address and the insn in the delay slot, which usually is\n-\t the substraction restoring the stack pointer %sp.  */\n+\t return address and the insn in the delay slot (if any).  */\n \n       if (current_function_calls_eh_return)\n \tabort ();\n \n-      fprintf (asm_out_file, \"\\tjmp\\t%%o7+%d\\n\", sparc_skip_caller_unimp ? 12 : 8);\n-\n-      if (delay_slot_filled_p)\n-\t{\n-\t  rtx delay = NEXT_INSN (insn);\n-\t  if (! delay)\n-\t    abort ();\n-\n-\t  final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n-\t  PATTERN (delay) = gen_blockage ();\n-\t  INSN_CODE (delay) = -1;\n-\t}\n-      else\n-\tfputs (\"\\t nop\\n\", asm_out_file);\n+      return \"jmp\\t%%o7+%)%#\";\n     }\n   else\n     {\n@@ -4725,7 +4700,7 @@ output_return (rtx insn)\n \t{\n \t  /* If the function uses __builtin_eh_return, the eh_return\n \t     machinery occupies the delay slot.  */\n-\t  if (delay_slot_filled_p || sparc_skip_caller_unimp)\n+\t  if (final_sequence)\n \t    abort ();\n \n \t  if (! flag_delayed_branch)\n@@ -4741,7 +4716,7 @@ output_return (rtx insn)\n \t  else\n \t    fputs (\"\\t nop\\n\", asm_out_file);\n \t}\n-      else if (delay_slot_filled_p)\n+      else if (final_sequence)\n \t{\n \t  rtx delay, pat;\n \n@@ -4754,32 +4729,25 @@ output_return (rtx insn)\n \t  if (TARGET_V9 && ! epilogue_renumber (&pat, 1))\n \t    {\n \t      epilogue_renumber (&pat, 0);\n-\t      fprintf (asm_out_file, \"\\treturn\\t%%i7+%d\\n\",\n-\t\t       sparc_skip_caller_unimp ? 12 : 8);\n-\t      final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n+\t      return \"return\\t%%i7+%)%#\";\n \t    }\n \t  else\n \t    {\n-\t      fprintf (asm_out_file, \"\\tjmp\\t%%i7+%d\\n\",\n-\t\t       sparc_skip_caller_unimp ? 12 : 8);\n+\t      output_asm_insn (\"jmp\\t%%i7+%)\", NULL);\n \t      output_restore (pat);\n+\t      PATTERN (delay) = gen_blockage ();\n+\t      INSN_CODE (delay) = -1;\n \t    }\n-\n-\t  PATTERN (delay) = gen_blockage ();\n-\t  INSN_CODE (delay) = -1;\n \t}\n       else\n         {\n \t  /* The delay slot is empty.  */\n \t  if (TARGET_V9)\n-\t    fprintf (asm_out_file, \"\\treturn\\t%%i7+%d\\n\\t nop\\n\",\n-\t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t    return \"return\\t%%i7+%)\\n\\t nop\";\n \t  else if (flag_delayed_branch)\n-\t    fprintf (asm_out_file, \"\\tjmp\\t%%i7+%d\\n\\t restore\\n\",\n-\t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t    return \"jmp\\t%%i7+%)\\n\\t restore\";\n \t  else\n-\t    fprintf (asm_out_file, \"\\trestore\\n\\tjmp\\t%%o7+%d\\n\\t nop\\n\",\n-\t\t     sparc_skip_caller_unimp ? 12 : 8);\n+\t    return \"restore\\n\\tjmp\\t%%o7+%)\\n\\t nop\";\n \t}\n     }\n \n@@ -4791,45 +4759,30 @@ output_return (rtx insn)\n const char *\n output_sibcall (rtx insn, rtx call_operand)\n {\n-  int leaf_function_p = current_function_uses_only_leaf_regs;\n-  bool delay_slot_filled_p = dbr_sequence_length () > 0;\n   rtx operands[1];\n \n   if (! flag_delayed_branch)\n     abort();\n \n   operands[0] = call_operand;\n \n-  if (leaf_function_p)\n+  if (current_function_uses_only_leaf_regs)\n     {\n       /* This is a leaf function so we don't have to bother restoring the\n \t register window.  We simply output the jump to the function and\n \t the insn in the delay slot (if any).  */\n \n-      if (LEAF_SIBCALL_SLOT_RESERVED_P && delay_slot_filled_p)\n+      if (LEAF_SIBCALL_SLOT_RESERVED_P && final_sequence)\n \tabort();\n \n-      if (delay_slot_filled_p)\n-\t{\n-\t  rtx delay = NEXT_INSN (insn);\n-\t  if (! delay)\n-\t    abort ();\n-\n-\t  output_asm_insn (\"sethi\\t%%hi(%a0), %%g1\", operands);\n-\t  output_asm_insn (\"jmp\\t%%g1 + %%lo(%a0)\", operands);\n-\t  final_scan_insn (delay, asm_out_file, 1, 0, 1, NULL);\n-\n-\t  PATTERN (delay) = gen_blockage ();\n-\t  INSN_CODE (delay) = -1;\n-\t}\n+      if (final_sequence)\n+\toutput_asm_insn (\"sethi\\t%%hi(%a0), %%g1\\n\\tjmp\\t%%g1 + %%lo(%a0)%#\",\n+\t\t\t operands);\n       else\n-\t{\n-\t  /* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize\n-\t     it into branch if possible.  */\n-\t  output_asm_insn (\"or\\t%%o7, %%g0, %%g1\", operands);\n-\t  output_asm_insn (\"call\\t%a0, 0\", operands);\n-\t  output_asm_insn (\" or\\t%%g1, %%g0, %%o7\", operands);\n-\t}\n+\t/* Use or with rs2 %%g0 instead of mov, so that as/ld can optimize\n+\t   it into branch if possible.  */\n+\toutput_asm_insn (\"or\\t%%o7, %%g0, %%g1\\n\\tcall\\t%a0, 0\\n\\t or\\t%%g1, %%g0, %%o7\",\n+\t\t\t operands);\n     }\n   else\n     {\n@@ -4839,7 +4792,7 @@ output_sibcall (rtx insn, rtx call_operand)\n \n       output_asm_insn (\"call\\t%a0, 0\", operands);\n \n-      if (delay_slot_filled_p)\n+      if (final_sequence)\n \t{\n \t  rtx delay = NEXT_INSN (insn);\n \t  if (! delay)\n@@ -6118,51 +6071,29 @@ const char *\n output_ubranch (rtx dest, int label, rtx insn)\n {\n   static char string[64];\n-  bool noop = false;\n+  bool v9_form = false;\n   char *p;\n \n-  /* TurboSPARC is reported to have problems with\n-     with\n-\tfoo: b,a foo\n-     i.e. an empty loop with the annul bit set.  The workaround is to use \n-        foo: b foo; nop\n-     instead.  */\n-\n-  if (! TARGET_V9 && flag_delayed_branch\n-      && (INSN_ADDRESSES (INSN_UID (dest))\n-\t  == INSN_ADDRESSES (INSN_UID (insn))))\n+  if (TARGET_V9 && INSN_ADDRESSES_SET_P ())\n     {\n-      strcpy (string, \"b\\t\");\n-      noop = true;\n+      int delta = (INSN_ADDRESSES (INSN_UID (dest))\n+\t\t   - INSN_ADDRESSES (INSN_UID (insn)));\n+      /* Leave some instructions for \"slop\".  */\n+      if (delta >= -260000 && delta < 260000)\n+\tv9_form = true;\n     }\n-  else\n-    {\n-      bool v9_form = false;\n-\n-      if (TARGET_V9 && INSN_ADDRESSES_SET_P ())\n-\t{\n-\t  int delta = (INSN_ADDRESSES (INSN_UID (dest))\n-\t\t       - INSN_ADDRESSES (INSN_UID (insn)));\n-\t  /* Leave some instructions for \"slop\".  */\n-\t  if (delta >= -260000 && delta < 260000)\n-\t    v9_form = true;\n-\t}\n \n-      if (v9_form)\n-\tstrcpy (string, \"ba%*,pt\\t%%xcc, \");\n-      else\n-\tstrcpy (string, \"b%*\\t\");\n-    }\n+  if (v9_form)\n+    strcpy (string, \"ba%*,pt\\t%%xcc, \");\n+  else\n+    strcpy (string, \"b%*\\t\");\n \n   p = strchr (string, '\\0');\n   *p++ = '%';\n   *p++ = 'l';\n   *p++ = '0' + label;\n   *p++ = '%';\n-  if (noop)\n-    *p++ = '#';\n-  else\n-    *p++ = '(';\n+  *p++ = '(';\n   *p = '\\0';\n \n   return string;\n@@ -6177,13 +6108,11 @@ output_ubranch (rtx dest, int label, rtx insn)\n \n    REVERSED is nonzero if we should reverse the sense of the comparison.\n \n-   ANNUL is nonzero if we should generate an annulling branch.\n-\n-   NOOP is nonzero if we have to follow this branch by a noop.  */\n+   ANNUL is nonzero if we should generate an annulling branch.  */\n \n const char *\n output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n-\t\tint noop, rtx insn)\n+\t\trtx insn)\n {\n   static char string[64];\n   enum rtx_code code = GET_CODE (op);\n@@ -6406,18 +6335,18 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n   if (far)\n     {\n       strcpy (p, \".+12\\n\\t nop\\n\\tb\\t\");\n-      if (annul || noop)\n+      /* Skip the next insn if requested or\n+\t if we know that it will be a nop.  */\n+      if (annul || ! final_sequence)\n         p[3] = '6';\n       p += 14;\n     }\n   *p++ = '%';\n   *p++ = 'l';\n-  /* Set the char indicating the number of the operand containing the\n-     label_ref.  */\n   *p++ = label + '0';\n+  *p++ = '%';\n+  *p++ = '#';\n   *p = '\\0';\n-  if (noop)\n-    strcpy (p, \"\\n\\t nop\");\n \n   return string;\n }\n@@ -6644,13 +6573,11 @@ sparc_emit_fixunsdi (rtx *operands, enum machine_mode mode)\n \n    REVERSED is nonzero if we should reverse the sense of the comparison.\n \n-   ANNUL is nonzero if we should generate an annulling branch.\n-\n-   NOOP is nonzero if we have to follow this branch by a noop.  */\n+   ANNUL is nonzero if we should generate an annulling branch.  */\n \n const char *\n output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n-\t\t int annul, int noop, rtx insn)\n+\t\t int annul, rtx insn)\n {\n   static char string[64];\n   enum rtx_code code = GET_CODE (op);\n@@ -6759,7 +6686,9 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n \t}\n \n       strcpy (p, \".+12\\n\\t nop\\n\\t\");\n-      if (annul || noop)\n+      /* Skip the next insn if requested or\n+\t if we know that it will be a nop.  */\n+      if (annul || ! final_sequence)\n         p[3] = '6';\n       p += 12;\n       if (veryfar)\n@@ -6776,11 +6705,10 @@ output_v9branch (rtx op, rtx dest, int reg, int label, int reversed,\n   *p++ = '%';\n   *p++ = 'l';\n   *p++ = '0' + label;\n+  *p++ = '%';\n+  *p++ = '#';\n   *p = '\\0';\n \n-  if (noop)\n-    strcpy (p, \"\\n\\t nop\");\n-\n   return string;\n }\n \n@@ -7077,43 +7005,55 @@ print_operand (FILE *file, rtx x, int code)\n   switch (code)\n     {\n     case '#':\n-      /* Output a 'nop' if there's nothing for the delay slot.  */\n-      if (dbr_sequence_length () == 0)\n+      /* Output an insn in a delay slot.  */\n+      if (final_sequence)\n+        sparc_indent_opcode = 1;\n+      else\n \tfputs (\"\\n\\t nop\", file);\n       return;\n     case '*':\n       /* Output an annul flag if there's nothing for the delay slot and we\n-\t are optimizing.  This is always used with '(' below.  */\n-      /* Sun OS 4.1.1 dbx can't handle an annulled unconditional branch;\n-\t this is a dbx bug.  So, we only do this when optimizing.  */\n-      /* On UltraSPARC, a branch in a delay slot causes a pipeline flush.\n+\t are optimizing.  This is always used with '(' below.\n+         Sun OS 4.1.1 dbx can't handle an annulled unconditional branch;\n+\t this is a dbx bug.  So, we only do this when optimizing.\n+         On UltraSPARC, a branch in a delay slot causes a pipeline flush.\n \t Always emit a nop in case the next instruction is a branch.  */\n-      if (dbr_sequence_length () == 0\n-\t  && (optimize && (int)sparc_cpu < PROCESSOR_V9))\n+      if (! final_sequence && (optimize && (int)sparc_cpu < PROCESSOR_V9))\n \tfputs (\",a\", file);\n       return;\n     case '(':\n       /* Output a 'nop' if there's nothing for the delay slot and we are\n \t not optimizing.  This is always used with '*' above.  */\n-      if (dbr_sequence_length () == 0\n-\t  && ! (optimize && (int)sparc_cpu < PROCESSOR_V9))\n+      if (! final_sequence && ! (optimize && (int)sparc_cpu < PROCESSOR_V9))\n \tfputs (\"\\n\\t nop\", file);\n+      else if (final_sequence)\n+        sparc_indent_opcode = 1;\n+      return;\n+    case ')':\n+      /* Output the right displacement from the saved PC on function return.\n+\t The caller may have placed an \"unimp\" insn immediately after the call\n+\t so we have to account for it.  This insn is used in the 32-bit ABI\n+\t when calling a function that returns a non zero-sized structure. The\n+\t 64-bit ABI doesn't have it.  Be careful to have this test be the same\n+\t as that used on the call.  */\n+     if (! TARGET_ARCH64\n+\t && current_function_returns_struct\n+\t && (TREE_CODE (DECL_SIZE (DECL_RESULT (current_function_decl)))\n+\t     == INTEGER_CST)\n+\t && ! integer_zerop (DECL_SIZE (DECL_RESULT (current_function_decl))))\n+\tfputs (\"12\", file);\n+      else\n+        fputc ('8', file);\n       return;\n     case '_':\n       /* Output the Embedded Medium/Anywhere code model base register.  */\n       fputs (EMBMEDANY_BASE_REG, file);\n       return;\n-    case '@':\n-      /* Print out what we are using as the frame pointer.  This might\n-\t be %fp, or might be %sp+offset.  */\n-      /* ??? What if offset is too big? Perhaps the caller knows it isn't? */\n-      fprintf (file, \"%s+\"HOST_WIDE_INT_PRINT_DEC,\n-\t       reg_names[REGNO (frame_base_reg)], frame_base_offset);\n-      return;\n     case '&':\n       /* Print some local dynamic TLS name.  */\n       assemble_name (file, get_some_local_dynamic_name ());\n       return;\n+\n     case 'Y':\n       /* Adjust the operand to take into account a RESTORE operation.  */\n       if (GET_CODE (x) == CONST_INT)"}, {"sha": "562a10d28c6b646b292784e63a4defb980b4d1e3", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "patch": "@@ -2517,6 +2517,19 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_IDENT(FILE, NAME) \\\n   fprintf (FILE, \"%s\\\"%s\\\"\\n\", IDENT_ASM_OP, NAME);\n \n+/* Prettify the assembly.  */\n+\n+extern int sparc_indent_opcode;\n+\n+#define ASM_OUTPUT_OPCODE(FILE, PTR)\t\\\n+  do {\t\t\t\t\t\\\n+    if (sparc_indent_opcode)\t\t\\\n+      {\t\t\t\t\t\\\n+\tputc (' ', FILE);\t\t\\\n+\tsparc_indent_opcode = 0;\t\\\n+      }\t\t\t\t\t\\\n+  } while (0)\n+\n /* Emit a dtp-relative reference to a TLS variable.  */\n \n #ifdef HAVE_AS_TLS\n@@ -2525,8 +2538,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n #endif\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '^'\t\t\\\n-   || (CHAR) == '(' || (CHAR) == '_' || (CHAR) == '&')\n+  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '('\t\t\\\n+   || (CHAR) == ')' || (CHAR) == '_' || (CHAR) == '&')\n \n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified."}, {"sha": "886d190d16ade6bf8305864d2fe1b8c65f3cba05", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=4e5b002baa5ce9097e3a1a4798b31c83f0e2ef56", "patch": "@@ -1549,7 +1549,7 @@\n {\n   return output_cbranch (operands[0], operands[1], 1, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"icc\")])\n@@ -1565,7 +1565,7 @@\n {\n   return output_cbranch (operands[0], operands[1], 1, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"icc\")])\n@@ -1582,7 +1582,7 @@\n {\n   return output_cbranch (operands[1], operands[2], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"fcc\")])\n@@ -1599,7 +1599,7 @@\n {\n   return output_cbranch (operands[1], operands[2], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"fcc\")])\n@@ -1616,7 +1616,7 @@\n {\n   return output_cbranch (operands[1], operands[2], 2, 0,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"fcc\")])\n@@ -1633,7 +1633,7 @@\n {\n   return output_cbranch (operands[1], operands[2], 2, 1,\n \t\t\t final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t ! final_sequence, insn);\n+\t\t\t insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"fcc\")])\n@@ -1655,7 +1655,7 @@\n {\n   return output_v9branch (operands[0], operands[2], 1, 2, 0,\n \t\t\t  final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t  ! final_sequence, insn);\n+\t\t\t  insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"reg\")])\n@@ -1672,7 +1672,7 @@\n {\n   return output_v9branch (operands[0], operands[2], 1, 2, 1,\n \t\t\t  final_sequence && INSN_ANNULLED_BRANCH_P (insn),\n-\t\t\t  ! final_sequence, insn);\n+\t\t\t  insn);\n }\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"branch_type\" \"reg\")])"}]}