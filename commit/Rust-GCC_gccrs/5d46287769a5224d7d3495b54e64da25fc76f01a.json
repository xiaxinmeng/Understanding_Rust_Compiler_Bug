{"sha": "5d46287769a5224d7d3495b54e64da25fc76f01a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ0NjI4Nzc2OWE1MjI0ZDdkMzQ5NWI1NGU2NGRhMjVmYzc2ZjAxYQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-11-13T16:03:27Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-11-13T16:03:27Z"}, "message": "Rewrite value_range constructors to the value_range_kind is at the end, and defaults to VR_RANGE.\n\nRewrite value_range constructors to the value_range_kind is at the\nend, and defaults to VR_RANGE.  Similarly for set() methods.\n\nFrom-SVN: r278148", "tree": {"sha": "2f3e30c5b6cc304056ebd319776479c3f80510ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f3e30c5b6cc304056ebd319776479c3f80510ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d46287769a5224d7d3495b54e64da25fc76f01a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d46287769a5224d7d3495b54e64da25fc76f01a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d46287769a5224d7d3495b54e64da25fc76f01a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d46287769a5224d7d3495b54e64da25fc76f01a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7b521fbd43b3cbaf4313c7719bed72d4de3b49a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b521fbd43b3cbaf4313c7719bed72d4de3b49a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b521fbd43b3cbaf4313c7719bed72d4de3b49a9"}], "stats": {"total": 282, "additions": 155, "deletions": 127}, "files": [{"sha": "004711204a8aa7defcafc990a41ebc848b0e8fde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -1,3 +1,48 @@\n+2019-11-13  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* gimple-fold.c (size_must_be_zero_p): Rewrite use of value_range\n+\tconstructors and set methods so value_range_kind is the last\n+\targument and defaults to VR_RANGE.\n+\t* gimple-ssa-evrp-analyze.c (record_ranges_from_stmt): Same.\n+\t* ipa-cp.c (propagate_vr_across_jump_function): Same.\n+\t* ipa-prop.c (ipa_get_value_range): Same.\n+\t(ipa_compute_jump_functions_for_edge): Same.\n+\t* range-op.cc (value_range_from_overflowed_bounds): Same.\n+\t(operator_cast::op1_range): Same.\n+\t(range_tests): Same.\n+\t* range.cc (range_nonzero): Same.\n+\t* tree-ssanames.c (get_range_info): Same.\n+\t* tree-vrp.c (value_range_equiv::set): Same.\n+\t(value_range::value_range): Same.\n+\t(value_range_equiv::value_range_equiv): Same.\n+\t(value_range_equiv::update): Same.\n+\t(value_range_equiv::deep_copy): Same.\n+\t(value_range_equiv::move): Same.\n+\t(value_range_equiv::set_undefined): Same.\n+\t(value_range::set): Same.\n+\t(value_range::set_nonzero): Same.\n+\t(ranges_from_anti_range): Same.\n+\t(extract_range_from_plus_minus_expr): Same.\n+\t(value_range::intersect_helper): Same.\n+\t(value_range_equiv::intersect): Same.\n+\t(value_range::union_helper): Same.\n+\t(value_range_equiv::union_): Same.\n+\t(value_range::normalize_symbolics): Same.\n+\t(value_range::invert): Same.\n+\t(determine_value_range_1): Same.\n+\t* tree-vrp.h (class value_range): Same.\n+\t(class value_range_equiv): Same.\n+\t* vr-values.c (set_value_range_to_nonnegative): Same.\n+\t(set_value_range_to_truthvalue): Same.\n+\t(vr_values::update_value_range): Same.\n+\t(vr_values::extract_range_for_var_from_comparison_expr): Same.\n+\t(vr_values::extract_range_from_binary_expr): Same.\n+\t(vr_values::extract_range_from_comparison): Same.\n+\t(vr_values::extract_range_basic): Same.\n+\t(vr_values::adjust_range_with_scev): Same.\n+\t(vr_values::vrp_evaluate_conditional_warnv_with_ops): Same.\n+\t(vr_values::extract_range_from_phi_node): Same.\n+\n 2019-11-13  Ulrich Drepper  <drepper@redhat.com>\n \n \t* tree-dump.c (dequeue_and_dump): Print first tree operand"}, {"sha": "e176be80efbf305312c09a0f9e00f2e2e382a7e5", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -677,8 +677,7 @@ size_must_be_zero_p (tree size)\n   /* Compute the value of SSIZE_MAX, the largest positive value that\n      can be stored in ssize_t, the signed counterpart of size_t.  */\n   wide_int ssize_max = wi::lshift (wi::one (prec), prec - 1) - 1;\n-  value_range valid_range (VR_RANGE,\n-\t\t\t   build_int_cst (type, 0),\n+  value_range valid_range (build_int_cst (type, 0),\n \t\t\t   wide_int_to_tree (type, ssize_max));\n   value_range vr;\n   get_range_info (size, vr);"}, {"sha": "5840767a799cd23686e269ddaae76399133e4f4d", "filename": "gcc/gimple-ssa-evrp-analyze.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fgimple-ssa-evrp-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fgimple-ssa-evrp-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp-analyze.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -334,7 +334,7 @@ evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)\n \t\t bitmaps.  Ugh.  */\n \t      value_range_equiv *new_vr\n \t\t= vr_values->allocate_value_range_equiv ();\n-\t      new_vr->set (vr.kind (), vr.min (), vr.max ());\n+\t      new_vr->set (vr.min (), vr.max (), NULL, vr.kind ());\n \t      vr.equiv_clear ();\n \t      push_value_range (output, new_vr);\n \t    }"}, {"sha": "901962b789f0197e525e2ce6bf84de0086801d5a", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -2005,7 +2005,7 @@ propagate_vr_across_jump_function (cgraph_edge *cs, ipa_jump_func *jfunc,\n \t  if (TREE_OVERFLOW_P (val))\n \t    val = drop_tree_overflow (val);\n \n-\t  value_range tmpvr (VR_RANGE, val, val);\n+\t  value_range tmpvr (val, val);\n \t  return dest_lat->meet_with (&tmpvr);\n \t}\n     }"}, {"sha": "312b2108f84976b8cf937ed373e17e3361907d0f", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -1822,9 +1822,9 @@ ipa_get_value_range (value_range *tmp)\n    value_ranges.  */\n \n static value_range *\n-ipa_get_value_range (enum value_range_kind type, tree min, tree max)\n+ipa_get_value_range (enum value_range_kind kind, tree min, tree max)\n {\n-  value_range tmp (type, min, max);\n+  value_range tmp (min, max, kind);\n   return ipa_get_value_range (&tmp);\n }\n \n@@ -1914,16 +1914,16 @@ ipa_compute_jump_functions_for_edge (struct ipa_func_body_info *fbi,\n       else\n \t{\n \t  wide_int min, max;\n-\t  value_range_kind type;\n+\t  value_range_kind kind;\n \t  if (TREE_CODE (arg) == SSA_NAME\n \t      && param_type\n-\t      && (type = get_range_info (arg, &min, &max))\n-\t      && (type == VR_RANGE || type == VR_ANTI_RANGE))\n+\t      && (kind = get_range_info (arg, &min, &max))\n+\t      && (kind == VR_RANGE || kind == VR_ANTI_RANGE))\n \t    {\n \t      value_range resvr;\n-\t      value_range tmpvr (type,\n-\t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), min),\n-\t\t\t\t      wide_int_to_tree (TREE_TYPE (arg), max));\n+\t      value_range tmpvr (wide_int_to_tree (TREE_TYPE (arg), min),\n+\t\t\t\t wide_int_to_tree (TREE_TYPE (arg), max),\n+\t\t\t\t kind);\n \t      range_fold_unary_expr (&resvr, NOP_EXPR, param_type,\n \t\t\t\t     &tmpvr, TREE_TYPE (arg));\n \t      if (!resvr.undefined_p () && !resvr.varying_p ())"}, {"sha": "5c7ff60b78848667e7c72e45c25105411fc5dc61", "filename": "gcc/range-op.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -212,7 +212,7 @@ value_range_from_overflowed_bounds (value_range &r, tree type,\n   if (covers || wi::cmp (tmin, tmax, sgn) > 0)\n     r = value_range (type);\n   else\n-    r = value_range (VR_ANTI_RANGE, type, tmin, tmax);\n+    r = value_range (type, tmin, tmax, VR_ANTI_RANGE);\n }\n \n // Create and return a range from a pair of wide-ints.  MIN_OVF and\n@@ -1636,11 +1636,11 @@ operator_cast::op1_range (value_range &r, tree type,\n \t  // *not* in the RHS is 0 or -1.\n \t  unsigned prec = TYPE_PRECISION (type);\n \t  if (lhs.zero_p ())\n-\t    r = value_range (VR_ANTI_RANGE, type,\n-\t\t\t     wi::minus_one (prec), wi::minus_one (prec));\n+\t    r = value_range (type, wi::minus_one (prec), wi::minus_one (prec),\n+\t\t\t     VR_ANTI_RANGE);\n \t  else\n-\t    r = value_range (VR_ANTI_RANGE, type,\n-\t\t\t     wi::zero (prec), wi::zero (prec));\n+\t    r = value_range (type, wi::zero (prec), wi::zero (prec),\n+\t\t\t     VR_ANTI_RANGE);\n \t  // And intersect it with what we know about op2.\n \t  r.intersect (op2);\n \t}\n@@ -2835,7 +2835,7 @@ range_tests ()\n   value_range r0, r1, rold;\n \n   // Test that NOT(255) is [0..254] in 8-bit land.\n-  value_range not_255 (VR_ANTI_RANGE, UCHAR (255), UCHAR (255));\n+  value_range not_255 (UCHAR (255), UCHAR (255), VR_ANTI_RANGE);\n   ASSERT_TRUE (not_255 == value_range (UCHAR (0), UCHAR (254)));\n \n   // Test that NOT(0) is [1..255] in 8-bit land.\n@@ -2876,17 +2876,17 @@ range_tests ()\n   ASSERT_TRUE (r0 == value_range (UINT(6), maxuint));\n \n   // Check that ~[10,MAX] => [0,9] for unsigned int.\n-  r0 = value_range (VR_RANGE, UINT(10), maxuint);\n+  r0 = value_range (UINT(10), maxuint);\n   r0.invert ();\n   ASSERT_TRUE (r0 == value_range (UINT (0), UINT (9)));\n \n   // Check that ~[0,5] => [6,MAX] for unsigned 128-bit numbers.\n-  r0 = value_range (VR_ANTI_RANGE, UINT128 (0), UINT128 (5));\n+  r0 = value_range (UINT128 (0), UINT128 (5), VR_ANTI_RANGE);\n   r1 = value_range (UINT128(6), build_minus_one_cst (u128_type));\n   ASSERT_TRUE (r0 == r1);\n \n   // Check that [~5] is really [-MIN,4][6,MAX].\n-  r0 = value_range (VR_ANTI_RANGE, INT (5), INT (5));\n+  r0 = value_range (INT (5), INT (5), VR_ANTI_RANGE);\n   r1 = value_range (minint, INT (4));\n   r1.union_ (value_range (INT (6), maxint));\n   ASSERT_FALSE (r1.undefined_p ());"}, {"sha": "e592d05738e49a38e84d61ca56ce3c7a8db8e423", "filename": "gcc/range.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Frange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Frange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange.cc?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -62,8 +62,8 @@ range_zero (tree type)\n value_range\n range_nonzero (tree type)\n {\n-  return value_range (VR_ANTI_RANGE,\n-\t\t\t   build_zero_cst (type), build_zero_cst (type));\n+  return value_range (build_zero_cst (type), build_zero_cst (type),\n+\t\t      VR_ANTI_RANGE);\n }\n \n value_range"}, {"sha": "8d044901b19e6e78ac48ba721bc4c54d9e4acf7e", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -455,7 +455,7 @@ get_range_info (const_tree name, value_range &vr)\n     {\n       min = wide_int_to_tree (TREE_TYPE (name), wmin);\n       max = wide_int_to_tree (TREE_TYPE (name), wmax);\n-      vr.set (kind, min, max);\n+      vr.set (min, max, kind);\n     }\n   return kind;\n }"}, {"sha": "610b65dedec0364bc363852dc600edad38b9b7dc", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 47, "deletions": 60, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -102,67 +102,55 @@ value_range_equiv::set_equiv (bitmap equiv)\n /* Initialize value_range.  */\n \n void\n-value_range_equiv::set (enum value_range_kind kind, tree min, tree max,\n-\t\t\tbitmap equiv)\n+value_range_equiv::set (tree min, tree max, bitmap equiv,\n+\t\t\tvalue_range_kind kind)\n {\n-  value_range::set (kind, min, max);\n+  value_range::set (min, max, kind);\n   set_equiv (equiv);\n   if (flag_checking)\n     check ();\n }\n \n-value_range::value_range (value_range_kind kind, tree min, tree max)\n+value_range::value_range (tree min, tree max, value_range_kind kind)\n {\n-  set (kind, min, max);\n+  set (min, max, kind);\n }\n \n-value_range_equiv::value_range_equiv (value_range_kind kind,\n-\t\t\t\t      tree min, tree max, bitmap equiv)\n+value_range_equiv::value_range_equiv (tree min, tree max, bitmap equiv,\n+\t\t\t\t      value_range_kind kind)\n {\n   m_equiv = NULL;\n-  set (kind, min, max, equiv);\n+  set (min, max, equiv, kind);\n }\n \n value_range_equiv::value_range_equiv (const value_range &other)\n {\n   m_equiv = NULL;\n-  set (other.kind (), other.min(), other.max (), NULL);\n+  set (other.min(), other.max (), NULL, other.kind ());\n }\n \n value_range::value_range (tree type)\n {\n   set_varying (type);\n }\n \n-value_range::value_range (enum value_range_kind kind, tree type,\n-\t\t\t  const wide_int &wmin, const wide_int &wmax)\n-{\n-  tree min = wide_int_to_tree (type, wmin);\n-  tree max = wide_int_to_tree (type, wmax);\n-  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n-  set (kind, min, max);\n-}\n-\n value_range::value_range (tree type,\n-\t\t\t  const wide_int &wmin, const wide_int &wmax)\n+\t\t\t  const wide_int &wmin, const wide_int &wmax,\n+\t\t\t  enum value_range_kind kind)\n {\n   tree min = wide_int_to_tree (type, wmin);\n   tree max = wide_int_to_tree (type, wmax);\n-  set (VR_RANGE, min, max);\n-}\n-\n-value_range::value_range (tree min, tree max)\n-{\n-  set (VR_RANGE, min, max);\n+  gcc_checking_assert (kind == VR_RANGE || kind == VR_ANTI_RANGE);\n+  set (min, max, kind);\n }\n \n /* Like set, but keep the equivalences in place.  */\n \n void\n-value_range_equiv::update (value_range_kind kind, tree min, tree max)\n+value_range_equiv::update (tree min, tree max, value_range_kind kind)\n {\n-  set (kind, min, max,\n-       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL);\n+  set (min, max,\n+       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL, kind);\n }\n \n /* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n@@ -174,13 +162,13 @@ value_range_equiv::update (value_range_kind kind, tree min, tree max)\n void\n value_range_equiv::deep_copy (const value_range_equiv *from)\n {\n-  set (from->m_kind, from->min (), from->max (), from->m_equiv);\n+  set (from->min (), from->max (), from->m_equiv, from->m_kind);\n }\n \n void\n value_range_equiv::move (value_range_equiv *from)\n {\n-  set (from->m_kind, from->min (), from->max ());\n+  set (from->min (), from->max (), NULL, from->m_kind);\n   m_equiv = from->m_equiv;\n   from->m_equiv = NULL;\n }\n@@ -309,7 +297,7 @@ value_range::set_undefined ()\n void\n value_range_equiv::set_undefined ()\n {\n-  set (VR_UNDEFINED, NULL, NULL, NULL);\n+  set (NULL, NULL, NULL, VR_UNDEFINED);\n }\n \n void\n@@ -714,7 +702,7 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n    extract ranges from var + CST op limit.  */\n \n void\n-value_range::set (enum value_range_kind kind, tree min, tree max)\n+value_range::set (tree min, tree max, value_range_kind kind)\n {\n   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n   if (kind == VR_UNDEFINED)\n@@ -878,7 +866,7 @@ value_range::set (tree val)\n   gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n   if (TREE_OVERFLOW_P (val))\n     val = drop_tree_overflow (val);\n-  set (VR_RANGE, val, val);\n+  set (val, val);\n }\n \n void\n@@ -887,7 +875,7 @@ value_range_equiv::set (tree val)\n   gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n   if (TREE_OVERFLOW_P (val))\n     val = drop_tree_overflow (val);\n-  set (VR_RANGE, val, val, NULL);\n+  set (val, val);\n }\n \n /* Set value range VR to a nonzero range of type TYPE.  */\n@@ -896,7 +884,7 @@ void\n value_range::set_nonzero (tree type)\n {\n   tree zero = build_int_cst (type, 0);\n-  set (VR_ANTI_RANGE, zero, zero);\n+  set (zero, zero, VR_ANTI_RANGE);\n }\n \n /* Set value range VR to a ZERO range of type TYPE.  */\n@@ -1282,12 +1270,10 @@ ranges_from_anti_range (const value_range *ar,\n     return false;\n \n   if (tree_int_cst_lt (vrp_val_min (type), ar->min ()))\n-    vr0->set (VR_RANGE,\n-\t      vrp_val_min (type),\n+    vr0->set (vrp_val_min (type),\n \t      wide_int_to_tree (type, wi::to_wide (ar->min ()) - 1));\n   if (tree_int_cst_lt (ar->max (), vrp_val_max (type)))\n-    vr1->set (VR_RANGE,\n-\t      wide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n+    vr1->set (wide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n \t      vrp_val_max (type));\n   if (vr0->undefined_p ())\n     {\n@@ -1700,7 +1686,7 @@ extract_range_from_plus_minus_expr (value_range *vr,\n       vr->set_varying (expr_type);\n     }\n   else\n-    vr->set (kind, min, max);\n+    vr->set (min, max, kind);\n }\n \n /* Return the range-ops handler for CODE and EXPR_TYPE.  If no\n@@ -5857,21 +5843,21 @@ value_range::intersect_helper (const value_range *vr0, const value_range *vr1)\n   if (vr1->undefined_p ())\n     return *vr1;\n \n-  value_range_kind vr0type = vr0->kind ();\n+  value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  intersect_ranges (&vr0type, &vr0min, &vr0max,\n+  intersect_ranges (&vr0kind, &vr0min, &vr0max,\n \t\t    vr1->kind (), vr1->min (), vr1->max ());\n   /* Make sure to canonicalize the result though as the inversion of a\n      VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n      fall back to vr0 when this turns things to varying.  */\n   value_range tem;\n-  if (vr0type == VR_UNDEFINED)\n+  if (vr0kind == VR_UNDEFINED)\n     tem.set_undefined ();\n-  else if (vr0type == VR_VARYING)\n+  else if (vr0kind == VR_VARYING)\n     tem.set_varying (vr0->type ());\n   else\n-    tem.set (vr0type, vr0min, vr0max);\n+    tem.set (vr0min, vr0max, vr0kind);\n   /* If that failed, use the saved original VR0.  */\n   if (tem.varying_p ())\n     return *vr0;\n@@ -5921,7 +5907,7 @@ value_range_equiv::intersect (const value_range_equiv *other)\n   else\n     {\n       value_range tem = intersect_helper (this, other);\n-      this->update (tem.kind (), tem.min (), tem.max ());\n+      this->update (tem.min (), tem.max (), tem.kind ());\n \n       /* If the result is VR_UNDEFINED there is no need to mess with\n \t equivalencies.  */\n@@ -5967,20 +5953,20 @@ value_range::union_helper (const value_range *vr0, const value_range *vr1)\n       || vr1->varying_p ())\n     return *vr1;\n \n-  value_range_kind vr0type = vr0->kind ();\n+  value_range_kind vr0kind = vr0->kind ();\n   tree vr0min = vr0->min ();\n   tree vr0max = vr0->max ();\n-  union_ranges (&vr0type, &vr0min, &vr0max,\n+  union_ranges (&vr0kind, &vr0min, &vr0max,\n \t\tvr1->kind (), vr1->min (), vr1->max ());\n \n   /* Work on a temporary so we can still use vr0 when union returns varying.  */\n   value_range tem;\n-  if (vr0type == VR_UNDEFINED)\n+  if (vr0kind == VR_UNDEFINED)\n     tem.set_undefined ();\n-  else if (vr0type == VR_VARYING)\n+  else if (vr0kind == VR_VARYING)\n     tem.set_varying (vr0->type ());\n   else\n-    tem.set (vr0type, vr0min, vr0max);\n+    tem.set (vr0min, vr0max, vr0kind);\n \n   /* Failed to find an efficient meet.  Before giving up and setting\n      the result to VARYING, see if we can at least derive a useful\n@@ -6042,7 +6028,7 @@ value_range_equiv::union_ (const value_range_equiv *other)\n   else\n     {\n       value_range tem = union_helper (this, other);\n-      this->update (tem.kind (), tem.min (), tem.max ());\n+      this->update (tem.min (), tem.max (), tem.kind ());\n \n       /* The resulting set of equivalences is always the intersection of\n \t the two sets.  */\n@@ -6104,9 +6090,9 @@ value_range::normalize_symbolics () const\n     {\n       // [SYM, NUM] -> [-MIN, NUM]\n       if (min_symbolic)\n-\treturn value_range (VR_RANGE, vrp_val_min (ttype), max ());\n+\treturn value_range (vrp_val_min (ttype), max ());\n       // [NUM, SYM] -> [NUM, +MAX]\n-      return value_range (VR_RANGE, min (), vrp_val_max (ttype));\n+      return value_range (min (), vrp_val_max (ttype));\n     }\n   gcc_checking_assert (kind () == VR_ANTI_RANGE);\n   // ~[SYM, NUM] -> [NUM + 1, +MAX]\n@@ -6115,7 +6101,7 @@ value_range::normalize_symbolics () const\n       if (!vrp_val_is_max (max ()))\n \t{\n \t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n-\t  return value_range (VR_RANGE, n, vrp_val_max (ttype));\n+\t  return value_range (n, vrp_val_max (ttype));\n \t}\n       value_range var;\n       var.set_varying (ttype);\n@@ -6125,7 +6111,7 @@ value_range::normalize_symbolics () const\n   if (!vrp_val_is_min (min ()))\n     {\n       tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n-      return value_range (VR_RANGE, vrp_val_min (ttype), n);\n+      return value_range (vrp_val_min (ttype), n);\n     }\n   value_range var;\n   var.set_varying (ttype);\n@@ -6233,9 +6219,9 @@ value_range::invert ()\n   /* We can't just invert VR_RANGE and VR_ANTI_RANGE because we may\n      create non-canonical ranges.  Use the constructors instead.  */\n   if (m_kind == VR_RANGE)\n-    *this = value_range (VR_ANTI_RANGE, m_min, m_max);\n+    *this = value_range (m_min, m_max, VR_ANTI_RANGE);\n   else if (m_kind == VR_ANTI_RANGE)\n-    *this = value_range (VR_RANGE, m_min, m_max);\n+    *this = value_range (m_min, m_max);\n   else\n     gcc_unreachable ();\n }\n@@ -6947,8 +6933,9 @@ determine_value_range_1 (value_range *vr, tree expr)\n       if (TREE_CODE (expr) == SSA_NAME\n \t  && INTEGRAL_TYPE_P (TREE_TYPE (expr))\n \t  && (kind = get_range_info (expr, &min, &max)) != VR_VARYING)\n-\tvr->set (kind, wide_int_to_tree (TREE_TYPE (expr), min),\n-\t\t wide_int_to_tree (TREE_TYPE (expr), max));\n+\tvr->set (wide_int_to_tree (TREE_TYPE (expr), min),\n+\t\t wide_int_to_tree (TREE_TYPE (expr), max),\n+\t\t kind);\n       else\n \tvr->set_varying (TREE_TYPE (expr));\n     }"}, {"sha": "4b0e9c7a22627880a654dca7753e25e0cc6aa73c", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -42,14 +42,12 @@ class GTY((for_user)) value_range\n   friend void range_tests ();\n public:\n   value_range ();\n-  value_range (value_range_kind, tree, tree);\n-  value_range (tree, tree);\n-  value_range (value_range_kind,\n-\t       tree type, const wide_int &, const wide_int &);\n-  value_range (tree type, const wide_int &, const wide_int &);\n+  value_range (tree, tree, value_range_kind = VR_RANGE);\n+  value_range (tree type, const wide_int &, const wide_int &,\n+\t       value_range_kind = VR_RANGE);\n   value_range (tree type);\n \n-  void set (value_range_kind, tree, tree);\n+  void set (tree, tree, value_range_kind = VR_RANGE);\n   void set (tree);\n   void set_nonzero (tree);\n   void set_zero (tree);\n@@ -128,7 +126,7 @@ class GTY((user)) value_range_equiv : public value_range\n   value_range_equiv ();\n   value_range_equiv (const value_range &);\n   /* Deep-copies equiv bitmap argument.  */\n-  value_range_equiv (value_range_kind, tree, tree, bitmap = NULL);\n+  value_range_equiv (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n \n   /* Shallow-copies equiv bitmap.  */\n   value_range_equiv (const value_range_equiv &) /* = delete */;\n@@ -139,9 +137,9 @@ class GTY((user)) value_range_equiv : public value_range\n   void move (value_range_equiv *);\n \n   /* Leaves equiv bitmap alone.  */\n-  void update (value_range_kind, tree, tree);\n+  void update (tree, tree, value_range_kind = VR_RANGE);\n   /* Deep-copies equiv bitmap argument.  */\n-  void set (value_range_kind, tree, tree, bitmap = NULL);\n+  void set (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n   void set (tree);\n \n   bool operator== (const value_range_equiv &) const /* = delete */;"}, {"sha": "9143fa0c30bed69fa4a33e2a692ff513a421d3ff", "filename": "gcc/vr-values.c", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d46287769a5224d7d3495b54e64da25fc76f01a/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=5d46287769a5224d7d3495b54e64da25fc76f01a", "patch": "@@ -57,7 +57,7 @@ static inline void\n set_value_range_to_nonnegative (value_range_equiv *vr, tree type)\n {\n   tree zero = build_int_cst (type, 0);\n-  vr->update (VR_RANGE, zero, vrp_val_max (type));\n+  vr->update (zero, vrp_val_max (type));\n }\n \n /* Set value range VR to a range of a truthvalue of type TYPE.  */\n@@ -68,7 +68,7 @@ set_value_range_to_truthvalue (value_range_equiv *vr, tree type)\n   if (TYPE_PRECISION (type) == 1)\n     vr->set_varying (type);\n   else\n-    vr->update (VR_RANGE, build_int_cst (type, 0), build_int_cst (type, 1));\n+    vr->update (build_int_cst (type, 0), build_int_cst (type, 1));\n }\n \n /* Return the lattice entry for VAR or NULL if it doesn't exist or cannot\n@@ -246,8 +246,8 @@ vr_values::update_value_range (const_tree var, value_range_equiv *new_vr)\n \t  return true;\n \t}\n       else\n-\told_vr->set (new_vr->kind (),\n-\t\t     new_vr->min (), new_vr->max (), new_vr->equiv ());\n+\told_vr->set (new_vr->min (), new_vr->max (), new_vr->equiv (),\n+\t\t     new_vr->kind ());\n     }\n \n   new_vr->equiv_clear ();\n@@ -539,30 +539,30 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n          vice-versa.  Use set_and_canonicalize which does this for\n          us.  */\n       if (cond_code == LE_EXPR)\n-\tvr_p->set (VR_RANGE, min, max, vr_p->equiv ());\n+\tvr_p->set (min, max, vr_p->equiv ());\n       else if (cond_code == GT_EXPR)\n-        vr_p->set (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n+\tvr_p->set (min, max, vr_p->equiv (), VR_ANTI_RANGE);\n       else\n \tgcc_unreachable ();\n     }\n   else if (cond_code == EQ_EXPR)\n     {\n-      enum value_range_kind range_type;\n+      enum value_range_kind range_kind;\n \n       if (limit_vr)\n \t{\n-\t  range_type = limit_vr->kind ();\n+\t  range_kind = limit_vr->kind ();\n \t  min = limit_vr->min ();\n \t  max = limit_vr->max ();\n \t}\n       else\n \t{\n-\t  range_type = VR_RANGE;\n+\t  range_kind = VR_RANGE;\n \t  min = limit;\n \t  max = limit;\n \t}\n \n-      vr_p->update (range_type, min, max);\n+      vr_p->update (min, max, range_kind);\n \n       /* When asserting the equality VAR == LIMIT and LIMIT is another\n \t SSA name, the new range will also inherit the equivalence set\n@@ -613,7 +613,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t  && vrp_val_is_max (max))\n \tmin = max = limit;\n \n-      vr_p->set (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n+      vr_p->set (min, max, vr_p->equiv (), VR_ANTI_RANGE);\n     }\n   else if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n     {\n@@ -652,7 +652,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\tTREE_NO_WARNING (max) = 1;\n \t    }\n \n-\t  vr_p->update (VR_RANGE, min, max);\n+\t  vr_p->update (min, max);\n \t}\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n@@ -692,7 +692,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t\tTREE_NO_WARNING (min) = 1;\n \t    }\n \n-\t  vr_p->update (VR_RANGE, min, max);\n+\t  vr_p->update (min, max);\n \t}\n     }\n   else\n@@ -832,7 +832,7 @@ vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n \t      wide_int wmax = wi::to_wide (max, TYPE_PRECISION (TREE_TYPE (max)));\n \t      tree range_min = build_zero_cst (expr_type);\n \t      tree range_max = wide_int_to_tree (expr_type, wmax - 1);\n-\t      vr->set (VR_RANGE, range_min, range_max);\n+\t      vr->set (range_min, range_max);\n \t      return;\n \t    }\n      }\n@@ -853,15 +853,15 @@ vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n \n       /* Try with VR0 and [-INF, OP1].  */\n       if (is_gimple_min_invariant (minus_p ? vr0.max () : vr0.min ()))\n-\tn_vr1.set (VR_RANGE, vrp_val_min (expr_type), op1);\n+\tn_vr1.set (vrp_val_min (expr_type), op1);\n \n       /* Try with VR0 and [OP1, +INF].  */\n       else if (is_gimple_min_invariant (minus_p ? vr0.min () : vr0.max ()))\n-\tn_vr1.set (VR_RANGE, op1, vrp_val_max (expr_type));\n+\tn_vr1.set (op1, vrp_val_max (expr_type));\n \n       /* Try with VR0 and [OP1, OP1].  */\n       else\n-\tn_vr1.set (VR_RANGE, op1, op1);\n+\tn_vr1.set (op1, op1);\n \n       range_fold_binary_expr (vr, code, expr_type, &vr0, &n_vr1);\n     }\n@@ -877,11 +877,11 @@ vr_values::extract_range_from_binary_expr (value_range_equiv *vr,\n \n       /* Try with [-INF, OP0] and VR1.  */\n       if (is_gimple_min_invariant (minus_p ? vr1.max () : vr1.min ()))\n-\tn_vr0.set (VR_RANGE, vrp_val_min (expr_type), op0);\n+\tn_vr0.set (vrp_val_min (expr_type), op0);\n \n       /* Try with [OP0, +INF] and VR1.  */\n       else if (is_gimple_min_invariant (minus_p ? vr1.min (): vr1.max ()))\n-\tn_vr0.set (VR_RANGE, op0, vrp_val_max (expr_type));\n+\tn_vr0.set (op0, vrp_val_max (expr_type));\n \n       /* Try with [OP0, OP0] and VR1.  */\n       else\n@@ -989,7 +989,7 @@ vr_values::extract_range_from_comparison (value_range_equiv *vr,\n       if (is_gimple_min_invariant (val))\n \tvr->set (val);\n       else\n-\tvr->update (VR_RANGE, val, val);\n+\tvr->update (val, val);\n     }\n   else\n     /* The result of a comparison is always true or false.  */\n@@ -1270,8 +1270,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t  maxi = prec - 1;\n \t  goto bitop_builtin;\n \tbitop_builtin:\n-\t  vr->set (VR_RANGE, build_int_cst (type, mini),\n-\t\t   build_int_cst (type, maxi));\n+\t  vr->set (build_int_cst (type, mini), build_int_cst (type, maxi));\n \t  return;\n \tcase CFN_UBSAN_CHECK_ADD:\n \t  subcode = PLUS_EXPR;\n@@ -1298,7 +1297,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t      size = targetm.goacc.dim_limit (axis);\n \n \t    tree type = TREE_TYPE (gimple_call_lhs (stmt));\n-\t    vr->set(VR_RANGE, build_int_cst (type, is_pos ? 0 : 1),\n+\t    vr->set(build_int_cst (type, is_pos ? 0 : 1),\n \t\t    size\n \t\t    ? build_int_cst (type, size - is_pos) : vrp_val_max (type));\n \t  }\n@@ -1319,7 +1318,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t   smaller than the former type).\n \t\t   FIXME: Use max_object_size() - 1 here.  */\n \t\ttree range_max = wide_int_to_tree (type, wmax - 2);\n-\t\tvr->set (VR_RANGE, range_min, range_max);\n+\t\tvr->set (range_min, range_max);\n \t\treturn;\n \t      }\n \t  break;\n@@ -1381,7 +1380,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t    {\n \t\t      /* This is the boolean return value whether compare and\n \t\t\t exchange changed anything or not.  */\n-\t\t      vr->set (VR_RANGE, build_int_cst (type, 0),\n+\t\t      vr->set (build_int_cst (type, 0),\n \t\t\t       build_int_cst (type, 1));\n \t\t      return;\n \t\t    }\n@@ -1403,7 +1402,7 @@ vr_values::extract_range_basic (value_range_equiv *vr, gimple *stmt)\n \t\t\t       && !TYPE_UNSIGNED (type))\n \t\t\tvr->set_varying (type);\n \t\t      else\n-\t\t\tvr->set (VR_RANGE, build_int_cst (type, 0),\n+\t\t\tvr->set (build_int_cst (type, 0),\n \t\t\t\t build_int_cst (type, 1));\n \t\t    }\n \t\t  else if (types_compatible_p (type, TREE_TYPE (op0))\n@@ -1921,7 +1920,7 @@ vr_values::adjust_range_with_scev (value_range_equiv *vr, class loop *loop,\n   if (TREE_OVERFLOW_P (max))\n     max = drop_tree_overflow (max);\n \n-  vr->update (VR_RANGE, min, max);\n+  vr->update (min, max);\n }\n \n /* Dump value ranges of all SSA_NAMEs to FILE.  */\n@@ -2383,13 +2382,13 @@ vr_values::vrp_evaluate_conditional_warnv_with_ops (enum tree_code code,\n \t  value_range vro, vri;\n \t  if (code == GT_EXPR || code == GE_EXPR)\n \t    {\n-\t      vro.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n-\t      vri.set (VR_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t      vro.set (TYPE_MIN_VALUE (TREE_TYPE (op0)), x, VR_ANTI_RANGE);\n+\t      vri.set (TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n \t    }\n \t  else if (code == LT_EXPR || code == LE_EXPR)\n \t    {\n-\t      vro.set (VR_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n-\t      vri.set (VR_ANTI_RANGE, TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t      vro.set (TYPE_MIN_VALUE (TREE_TYPE (op0)), x);\n+\t      vri.set (TYPE_MIN_VALUE (TREE_TYPE (op0)), x, VR_ANTI_RANGE);\n \t    }\n \t  else\n \t    gcc_unreachable ();\n@@ -2873,8 +2872,8 @@ vr_values::extract_range_from_phi_node (gphi *phi,\n \t\t{\n \t\t  if (!vr_arg_->varying_p () && !vr_arg_->undefined_p ())\n \t\t    {\n-\t\t      vr_arg_tem.set (vr_arg_->kind (), vr_arg_->min (),\n-\t\t\t\t      vr_arg_->max (), NULL);\n+\t\t      vr_arg_tem.set (vr_arg_->min (), vr_arg_->max (), NULL,\n+\t\t\t\t      vr_arg_->kind ());\n \t\t      if (vr_arg_tem.symbolic_p ())\n \t\t\tvr_arg_tem.set_varying (TREE_TYPE (arg));\n \t\t    }\n@@ -2984,7 +2983,7 @@ vr_values::extract_range_from_phi_node (gphi *phi,\n \t\t\t\t   vrp_val_max (vr_result->type ()),\n \t\t\t\t   build_int_cst (vr_result->type (), 1));\n \n-      vr_result->update (vr_result->kind (), new_min, new_max);\n+      vr_result->update (new_min, new_max, vr_result->kind ());\n \n       /* If we dropped either bound to +-INF then if this is a loop\n \t PHI node SCEV may known more about its value-range.  */"}]}