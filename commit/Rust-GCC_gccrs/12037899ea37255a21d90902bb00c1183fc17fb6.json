{"sha": "12037899ea37255a21d90902bb00c1183fc17fb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIwMzc4OTllYTM3MjU1YTIxZDkwOTAyYmIwMGMxMTgzZmMxN2ZiNg==", "commit": {"author": {"name": "Razya Ladelsky", "email": "razya@il.ibm.com", "date": "2011-07-05T13:08:01Z"}, "committer": {"name": "Razya Ladelsky", "email": "razya@gcc.gnu.org", "date": "2011-07-05T13:08:01Z"}, "message": "07-05-2011  Razya Ladelsky  <razya@il.ibm.com>\n\n        * tree-cfg.c (gimple_duplicate_sese_tail): Remove handling of \n        the loop's number of iterations.\n        * tree-parloops.c (transform_to_exit_first_loop): Add the \n        handling of the loop's number of iterations before the call \n        to gimple_duplicate_sese_tail.\n        Insert the stmt caclculating the new rhs of the loop's\n        condition stmt to the preheader instead of iters_bb.\n        * testsuite/gcc.dg/autopar/pr49580.c: New test.\n\nFrom-SVN: r175851", "tree": {"sha": "67135b0c880f731ab81c64aa984089f4ac3e36f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67135b0c880f731ab81c64aa984089f4ac3e36f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12037899ea37255a21d90902bb00c1183fc17fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12037899ea37255a21d90902bb00c1183fc17fb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12037899ea37255a21d90902bb00c1183fc17fb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12037899ea37255a21d90902bb00c1183fc17fb6/comments", "author": null, "committer": null, "parents": [{"sha": "509a31f8e558782f0cdc3c337dc957bb443a4d23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/509a31f8e558782f0cdc3c337dc957bb443a4d23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/509a31f8e558782f0cdc3c337dc957bb443a4d23"}], "stats": {"total": 121, "additions": 89, "deletions": 32}, "files": [{"sha": "9a5141e93741d3be5503d0d3b9ac86cb6764100f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=12037899ea37255a21d90902bb00c1183fc17fb6", "patch": "@@ -1,3 +1,14 @@\n+2011-07-05  Razya Ladelsky  <razya@il.ibm.com>\n+\n+\tPR tree-optimization/49580\n+\t* tree-cfg.c (gimple_duplicate_sese_tail): Remove handling of \n+\tthe loop's number of iterations.\n+        * tree-parloops.c (transform_to_exit_first_loop): Add the \n+\thandling of the loop's number of iterations before the call \n+\tto gimple_duplicate_sese_tail.\n+        Insert the stmt caclculating the new rhs of the loop's\n+\tcondition stmt to the preheader instead of iters_bb.\n+\n 2011-07-05  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR rtl-optimization/47449"}, {"sha": "87833d3fdfa60d45a016d0a79c10f897552fe962", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=12037899ea37255a21d90902bb00c1183fc17fb6", "patch": "@@ -1,3 +1,8 @@\n+2011-07-05  Razya Ladelsky  <razya@il.ibm.com>\n+\n+\tPR tree-optimization/49580\n+\t* gcc.dg/autopar/pr49580.c: New test.\n+\n 2011-07-05  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49518"}, {"sha": "e08fd0e0c6cfb0275a96fbe35dcae0da4c870328", "filename": "gcc/testsuite/gcc.dg/autopar/pr49580.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49580.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49580.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fautopar%2Fpr49580.c?ref=12037899ea37255a21d90902bb00c1183fc17fb6", "patch": "@@ -0,0 +1,38 @@\n+/* PR debug/49580 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-parallelize-loops=4 -fdump-tree-parloops-details\" } */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+\n+#define N 1600\n+\n+unsigned int ub[N];\n+unsigned char reg_has_output_reload[N];\n+unsigned int uc[N];\n+\n+ __attribute__ ((noinline)) \n+ void main2 (unsigned int regno, unsigned int n_reloads)\n+ {\n+  unsigned int nr=0; \n+\n+  if (regno> ub[regno])\n+    nr=regno;\n+  else\n+    nr=ub[nr];\n+\n+  while (nr-- > 0)\n+    if (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n+      ub[regno + nr] = 0;\n+}\n+\n+int main (void)\n+{ \n+  main2 (799, 0);\n+  return 0;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"SUCCESS: may be parallelized\" 1 \"parloops\" } } */\n+/* { dg-final { cleanup-tree-dump \"parloops\" } } */\n+"}, {"sha": "12d8fb4e5f062262d21258c993994802d070b3b7", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=12037899ea37255a21d90902bb00c1183fc17fb6", "patch": "@@ -5411,12 +5411,10 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   int total_freq = 0, exit_freq = 0;\n   gcov_type total_count = 0, exit_count = 0;\n   edge exits[2], nexits[2], e;\n-  gimple_stmt_iterator gsi,gsi1;\n+  gimple_stmt_iterator gsi;\n   gimple cond_stmt;\n   edge sorig, snew;\n   basic_block exit_bb;\n-  basic_block iters_bb;\n-  tree new_rhs;\n   gimple_stmt_iterator psi;\n   gimple phi;\n   tree def;\n@@ -5497,35 +5495,6 @@ gimple_duplicate_sese_tail (edge entry ATTRIBUTE_UNUSED, edge exit ATTRIBUTE_UNU\n   gcc_assert (gimple_code (cond_stmt) == GIMPLE_COND);\n   cond_stmt = gimple_copy (cond_stmt);\n \n- /* If the block consisting of the exit condition has the latch as\n-    successor, then the body of the loop is executed before\n-    the exit condition is tested.  In such case, moving the\n-    condition to the entry, causes that the loop will iterate\n-    one less iteration (which is the wanted outcome, since we\n-    peel out the last iteration).  If the body is executed after\n-    the condition, moving the condition to the entry requires\n-    decrementing one iteration.  */\n-  if (exits[1]->dest == orig_loop->latch)\n-    new_rhs = gimple_cond_rhs (cond_stmt);\n-  else\n-  {\n-    new_rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (gimple_cond_rhs (cond_stmt)),\n-\t\t\t   gimple_cond_rhs (cond_stmt),\n-\t\t\t   build_int_cst (TREE_TYPE (gimple_cond_rhs (cond_stmt)), 1));\n-\n-    if (TREE_CODE (gimple_cond_rhs (cond_stmt)) == SSA_NAME)\n-      {\n-\titers_bb = gimple_bb (SSA_NAME_DEF_STMT (gimple_cond_rhs (cond_stmt)));\n-\tfor (gsi1 = gsi_start_bb (iters_bb); !gsi_end_p (gsi1); gsi_next (&gsi1))\n-\t  if (gsi_stmt (gsi1) == SSA_NAME_DEF_STMT (gimple_cond_rhs (cond_stmt)))\n-\t    break;\n-\n-\tnew_rhs = force_gimple_operand_gsi (&gsi1, new_rhs, true,\n-\t\t\t\t\t    NULL_TREE,false,GSI_CONTINUE_LINKING);\n-      }\n-  }\n-  gimple_cond_set_rhs (cond_stmt, unshare_expr (new_rhs));\n-  gimple_cond_set_lhs (cond_stmt, unshare_expr (gimple_cond_lhs (cond_stmt)));\n   gsi_insert_after (&gsi, cond_stmt, GSI_NEW_STMT);\n \n   sorig = single_succ_edge (switch_bb);"}, {"sha": "339ddcc18a51c49871aa5b52baf2abee1c9111cc", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12037899ea37255a21d90902bb00c1183fc17fb6/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=12037899ea37255a21d90902bb00c1183fc17fb6", "patch": "@@ -1474,6 +1474,8 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n   gimple phi, nphi, cond_stmt, stmt, cond_nit;\n   gimple_stmt_iterator gsi;\n   tree nit_1;\n+  edge exit_1;\n+  tree new_rhs;\n \n   split_block_after_labels (loop->header);\n   orig_header = single_succ (loop->header);\n@@ -1502,6 +1504,38 @@ transform_to_exit_first_loop (struct loop *loop, htab_t reduction_list, tree nit\n \t  control = t;\n \t}\n     }\n+\n+ /* Setting the condition towards peeling the last iteration:\n+    If the block consisting of the exit condition has the latch as\n+    successor, then the body of the loop is executed before\n+    the exit condition is tested.  In such case, moving the\n+    condition to the entry, causes that the loop will iterate\n+    one less iteration (which is the wanted outcome, since we\n+    peel out the last iteration).  If the body is executed after\n+    the condition, moving the condition to the entry requires\n+    decrementing one iteration.  */\n+  exit_1 = EDGE_SUCC (exit->src, EDGE_SUCC (exit->src, 0) == exit); \n+  if (exit_1->dest == loop->latch)\n+    new_rhs = gimple_cond_rhs (cond_stmt);\n+  else\n+  {\n+    new_rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (gimple_cond_rhs (cond_stmt)),\n+\t\t\t   gimple_cond_rhs (cond_stmt),\n+\t\t\t   build_int_cst (TREE_TYPE (gimple_cond_rhs (cond_stmt)), 1));\n+    if (TREE_CODE (gimple_cond_rhs (cond_stmt)) == SSA_NAME)\n+      {\n+ \tbasic_block preheader;\n+  \tgimple_stmt_iterator gsi1;\n+\n+  \tpreheader = loop_preheader_edge(loop)->src;\n+    \tgsi1 = gsi_after_labels (preheader);\n+\tnew_rhs = force_gimple_operand_gsi (&gsi1, new_rhs, true,\n+\t\t\t\t\t    NULL_TREE,false,GSI_CONTINUE_LINKING);\n+      }\n+  }\n+  gimple_cond_set_rhs (cond_stmt, unshare_expr (new_rhs));\n+  gimple_cond_set_lhs (cond_stmt, unshare_expr (gimple_cond_lhs (cond_stmt)));\n+  \n   bbs = get_loop_body_in_dom_order (loop);\n \n   for (n = 0; bbs[n] != loop->latch; n++)"}]}