{"sha": "db430d2664d9f13b8ef7cd41fad8e8270c618491", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGI0MzBkMjY2NGQ5ZjEzYjhlZjdjZDQxZmFkOGU4MjcwYzYxODQ5MQ==", "commit": {"author": {"name": "David S. Miller", "email": "davem@redhat.com", "date": "2002-04-20T04:47:49Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "2002-04-20T04:47:49Z"}, "message": "linux.h (MD_FALLBACK_FRAME_STATE_FOR): Define.\n\n2002-04-19  David S. Miller  <davem@redhat.com>\n\n\t* config/sparc/linux.h (MD_FALLBACK_FRAME_STATE_FOR): Define.\n\t* config/sparc/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Likewise.\n\nFrom-SVN: r52546", "tree": {"sha": "00655c84e120607419106de1a2041e82840f4ec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00655c84e120607419106de1a2041e82840f4ec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db430d2664d9f13b8ef7cd41fad8e8270c618491", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db430d2664d9f13b8ef7cd41fad8e8270c618491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db430d2664d9f13b8ef7cd41fad8e8270c618491", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db430d2664d9f13b8ef7cd41fad8e8270c618491/comments", "author": null, "committer": null, "parents": [{"sha": "19367215056227b261f2670e01be338c65c1cefe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19367215056227b261f2670e01be338c65c1cefe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19367215056227b261f2670e01be338c65c1cefe"}], "stats": {"total": 199, "additions": 199, "deletions": 0}, "files": [{"sha": "004339e757ae83568d21f737a1c8e7cd518159a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db430d2664d9f13b8ef7cd41fad8e8270c618491", "patch": "@@ -1,3 +1,8 @@\n+2002-04-19  David S. Miller  <davem@redhat.com>\n+\n+\t* config/sparc/linux.h (MD_FALLBACK_FRAME_STATE_FOR): Define.\n+\t* config/sparc/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Likewise.\n+\n 2002-04-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/3756"}, {"sha": "3e7e0611a938c95ca55dfb7004d0d9db0fe093f5", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=db430d2664d9f13b8ef7cd41fad8e8270c618491", "patch": "@@ -257,3 +257,72 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* We use GNU ld so undefine this so that attribute((init_priority)) works.  */\n #undef CTORS_SECTION_ASM_OP\n #undef DTORS_SECTION_ASM_OP\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#endif\n+\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    int new_cfa_, i_, oldstyle_;\t\t\t\t\t\\\n+    int regs_off_, fpu_save_off_;\t\t\t\t\t\\\n+    int fpu_save_, this_cfa_;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (pc_[1] != 0x91d02010)\t\t/* ta 0x10 */\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    if (pc_[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\t\\\n+      oldstyle_ = 1;\t\t\t\t\t\t\t\\\n+    else if (pc_[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\t\\\n+      oldstyle_ = 0;\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    if (oldstyle_)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        regs_off_ = 96;\t\t\t\t\t\t\t\\\n+        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        regs_off_ = 96 + 128;\t\t\t\t\t\t\\\n+        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4) + (2 * 4);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    this_cfa_ = (int) (CONTEXT)->cfa;\t\t\t\t\t\\\n+    new_cfa_ = *(int *)(((CONTEXT)->cfa) + (regs_off_+(4*4)+(14 * 4)));\t\\\n+    fpu_save_ = *(int *)((this_cfa_) + (fpu_save_off_));\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (int) (CONTEXT)->cfa;\t\t\t\\\n+    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        if (i_ == 14)\t\t\t\t\t\t\t\\\n+          continue;\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n+\t   this_cfa_ + (regs_off_+(4 * 4)+(i_ * 4)) - new_cfa_;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n+\t  this_cfa_ + (i_ * 4) - new_cfa_;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (fpu_save_)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (i_ = 0; i_ < 32; ++i_)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n+\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[0].loc.offset = this_cfa_+(regs_off_+4)-new_cfa_;\t\\\n+    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)"}, {"sha": "0ab61c2a7dc75d190f96922a776b59d8ad36f249", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db430d2664d9f13b8ef7cd41fad8e8270c618491/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=db430d2664d9f13b8ef7cd41fad8e8270c618491", "patch": "@@ -377,3 +377,128 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* We use GNU ld so undefine this so that attribute((init_priority)) works.  */\n #undef CTORS_SECTION_ASM_OP\n #undef DTORS_SECTION_ASM_OP\n+\n+/* Do code reading to identify a signal frame, and set the frame\n+   state data appropriately.  See unwind-dw2.c for the structs.  */\n+\n+#ifdef IN_LIBGCC2\n+#include <signal.h>\n+#include <sys/ucontext.h>\n+#endif\n+\n+/* Handle multilib correctly.  */\n+#if defined(__arch64__)\n+/* 64-bit Sparc version */\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    long new_cfa_, i_;\t\t\t\t\t\t\t\\\n+    long regs_off_, fpu_save_off_;\t\t\t\t\t\\\n+    long this_cfa_, fpu_save_;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (pc_[0] != 0x82102065\t\t/* mov NR_rt_sigreturn, %g1 */\t\\\n+        || pc_[1] != 0x91d0206d)\t\t/* ta 0x6d */\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    regs_off_ = 192 + 128;\t\t\t\t\t\t\\\n+    fpu_save_off_ = regs_off_ + (16 * 8) + (3 * 8) + (2 * 4);\t\t\\\n+    this_cfa_ = (long) (CONTEXT)->cfa;\t\t\t\t\t\\\n+    new_cfa_ = *(long *)(((CONTEXT)->cfa) + (regs_off_ + (14 * 8)));\t\\\n+    fpu_save_ = *(long *)((this_cfa_) + (fpu_save_off_));\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n+    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        if (i_ == 14)\t\t\t\t\t\t\t\\\n+          continue;\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n+\t  this_cfa_ + (regs_off_ + (i_ * 8)) - new_cfa_;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n+\t  this_cfa_ + (i_ * 8) - new_cfa_;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (fpu_save_)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (i_ = 0; i_ < 64; ++i_)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            if (i_ > 32 && (i_ & 0x1))\t\t\t\t\t\\\n+              continue;\t\t\t\t\t\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n+\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[0].loc.offset =\t\t\t\t\t\\\n+      this_cfa_ + (regs_off_ + (16 * 8) + 8) - new_cfa_;\t\t\\\n+    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)\n+#else\n+/* 32-bit Sparc version */\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned int *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    int new_cfa_, i_, oldstyle_;\t\t\t\t\t\\\n+    int regs_off_, fpu_save_off_;\t\t\t\t\t\\\n+    int fpu_save_, this_cfa_;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    if (pc_[1] != 0x91d02010)\t\t/* ta 0x10 */\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    if (pc_[0] == 0x821020d8)\t\t/* mov NR_sigreturn, %g1 */\t\\\n+      oldstyle_ = 1;\t\t\t\t\t\t\t\\\n+    else if (pc_[0] == 0x82102065)\t/* mov NR_rt_sigreturn, %g1 */\t\\\n+      oldstyle_ = 0;\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    if (oldstyle_)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        regs_off_ = 96;\t\t\t\t\t\t\t\\\n+        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        regs_off_ = 96 + 128;\t\t\t\t\t\t\\\n+        fpu_save_off_ = regs_off_ + (4 * 4) + (16 * 4) + (2 * 4);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    this_cfa_ = (int) (CONTEXT)->cfa;\t\t\t\t\t\\\n+    new_cfa_ = *(int *)(((CONTEXT)->cfa) + (regs_off_+(4*4)+(14 * 4)));\t\\\n+    fpu_save_ = *(int *)((this_cfa_) + (fpu_save_off_));\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 14;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (int) (CONTEXT)->cfa;\t\t\t\\\n+    for (i_ = 1; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        if (i_ == 14)\t\t\t\t\t\t\t\\\n+          continue;\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_].loc.offset =\t\t\t\t\t\\\n+\t   this_cfa_ + (regs_off_+(4 * 4)+(i_ * 4)) - new_cfa_;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    for (i_ = 0; i_ < 16; ++i_)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].how = REG_SAVED_OFFSET;\t\t\t\\\n+\t(FS)->regs.reg[i_ + 16].loc.offset =\t\t\t\t\\\n+\t  this_cfa_ + (i_ * 4) - new_cfa_;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    if (fpu_save_)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfor (i_ = 0; i_ < 32; ++i_)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].how = REG_SAVED_OFFSET;\t\t\\\n+\t    (FS)->regs.reg[i_ + 32].loc.offset =\t\t\t\\\n+\t      (fpu_save_ + (i_ * 4)) - new_cfa_;\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    /* Stick return address into %g0, same trick Alpha uses.  */\t\\\n+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[0].loc.offset = this_cfa_+(regs_off_+4)-new_cfa_;\t\\\n+    (FS)->retaddr_column = 0;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif"}]}