{"sha": "e0d801845122f3952530d8047f17cfe62bf2aafc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBkODAxODQ1MTIyZjM5NTI1MzBkODA0N2YxN2NmZTYyYmYyYWFmYw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-08-10T05:34:44Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-08-10T05:34:44Z"}, "message": "Sparc backend rewrite by rth and myself, please\nperuse the lengthy ChangeLog for a blow by blow account.\n\nCo-Authored-By: Richard Henderson <rth@cygnus.com>\n\nFrom-SVN: r21652", "tree": {"sha": "aa7b5df64d652b017925c5ebca8ec5b668713b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa7b5df64d652b017925c5ebca8ec5b668713b88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0d801845122f3952530d8047f17cfe62bf2aafc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d801845122f3952530d8047f17cfe62bf2aafc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0d801845122f3952530d8047f17cfe62bf2aafc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0d801845122f3952530d8047f17cfe62bf2aafc/comments", "author": null, "committer": null, "parents": [{"sha": "b08b85c4a0b590394116fdb5acc8d4e2068544b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b08b85c4a0b590394116fdb5acc8d4e2068544b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b08b85c4a0b590394116fdb5acc8d4e2068544b1"}], "stats": {"total": 8308, "additions": 4625, "deletions": 3683}, "files": [{"sha": "edb3dc6392f149e832efb10f38981c3e6f88d1f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -1,3 +1,286 @@\n+Mon Aug 10 04:28:13 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\t\t\t  Richard Henderson  <rth@cygnus.com>\n+\t\n+\tRewrite Sparc backend for better code generation and\n+\timproved sparc64 support.\n+\t* config/sparc/sp64-elf.h: Set JUMP_TABLES_IN_TEXT_SECTION to\n+\tzero.\n+\t* config/sparc/sysv4.h: Likewise.\n+\t* config/sparc/sparc.c (v8plus_regcmp_p, sparc_operand,\n+\tmove_operand, v8plus_regcmp_op, emit_move_sequence,\n+\tsinglemove_string, doublemove_string, mem_aligned_8,\n+\toutput_move_double, output_move_quad, output_fp_move_double,\n+\tmove_quad_direction, output_fp_move_quad, output_scc_insn):\n+\tRemove.\n+\t(small_int_or_double): New predicate.\n+\t(gen_compare_reg): Remove TARGET_V8PLUS cmpdi_v8plus emission.\n+\t(legitimize_pic_address): Emit movsi_{high,lo_sum}_pic instead of\n+\told pic_{sethi,lo_sum}_si patterns.\n+\t(mem_min_alignment): New generic function to replace\n+\tmem_aligned_8, which uses REGNO_POINTER_ALIGN information when\n+\tavailable and can test for arbitrary alignments.  All callers\n+\tchanged.\n+\t(save_regs, restore_regs, build_big_number,\n+\toutput_function_prologue, output_cbranch, output_return,\n+\tsparc_flat_save_restore, sparc_flat_output_function_prologue,\n+\tsparc_flat_output_function_epilogue): Prettify\n+\tinsn output.\n+\t(output_function_epilogue): Likewise and add code to output\n+\tdeferred case vectors.\n+\t(output_v9branch): Likewise, add new arg INSN and use it to tack\n+\ton branch prediction settings.  All callers changed.\n+\t(print_operand): Likewise and output %l44 for LO_SUMs when\n+\tTARGET_CM_MEDMID.\n+\t(sparc_splitdi_legitimate): New function to make sure DImode\n+\tsplits can be run properly when !arch64.\n+\t(sparc_initialize_trampoline, sparc64_initialize_trampoline):\n+\tReformat example code in comments.\n+\t(set_extends): Remove UNSPEC/v8plus_clear_high case.\n+\t(sparc_addr_diff_list, sparc_addr_list): New statics to keep track\n+\tof deferred case vectors we need to output.\n+\t(sparc_defer_case_vector): Record a case vector.\n+\t(sparc_output_addr_vec, sparc_output_addr_diff_vec,\n+\tsparc_output_deferred_case_vectors): New functions to output them.\n+\t(sparc_emit_set_const32): New function to form 32-bit constants in\n+\tregisters when that requires more than one instruction.\n+\t(safe_constDI, sparc_emit_set_const64_quick1,\n+\tsparc_emit_set_const64_quick2, sparc_emit_set_const64_longway,\n+\tanalyze_64bit_constant, const64_is_2insns,\n+\tcreate_simple_focus_bits, sparc_emit_set_const64): New functions\n+\twhich do the same for 64-bit constants when arch64.\n+\t(sparc_emit_set_symbolic_const64): New function to emit address\n+\tloading for all code models on v9.\n+\t* config/sparc/sparc.h (CONDITIONAL_REGISTER_USAGE): Do not make\n+\t%g1 fixed when arch64, unfix %g0 when TARGET_LIVE_G0.\n+\t(ALTER_HARD_SUBREG): Fix thinko, return REGNO + 1 not 1.\n+\t(SECONDARY_INPUT_RELOAD_CLASS, SECONDARY_OUTPUT_RELOAD_CLASS): Fix\n+\tinaccuracies in comments, add symbolic and text_segment operands\n+\twhen TARGET_CM_MEDANY and TARGET_CM_EMBMEDANY respectively.  Use\n+\tGENERAL_REGS in these cases as a temp REG is needed to load these\n+\taddresses into a register properly.\n+\t(EXTRA_CONSTRAINT): Document more accurately, remove Q case as it\n+\tis no longer used.\n+\t(GO_IF_LEGITIMATE_ADDRESS): Allow TFmode for LO_SUM on v9 since fp\n+\tquads are guarenteed to have 16-byte alignment.\n+\t(LEGITIMIZE_ADDRESS): For SYMBOL_REF, CONST, and LABEL_REF use\n+\tcopy_to_suggested_reg instead of explicit LO_SUM and HIGH.\n+\t(ASM_OUTPUT_ADDR_VEC, ASM_OUTPUT_ADDR_DIFF_VEC): New macros for\n+\tdeferred case vector implementation.\n+\t(ASM_OUTPUT_ADDR_VEC_ELT): Use fputc to output newline.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Parenthesize LABEL in macro calls.\n+\tGenerate \"internal label - label\" instead of \"label - 1b\".\n+\t(PRINT_OPERAND_ADDRESS): For LO_SUM use %l44 on TARGET_CM_MEDMID.\n+\t(PREDICATE_CODES): Remove sparc_operand, move_operand,\n+\tv8plus_regcmp_op.  Add small_int_or_double, input_operand, and\n+\tzero_operand.\n+\t(doublemove_string, output_block_move, output_fp_move_double,\n+\toutput_fp_move_quad, output_move_double, output_move_quad,\n+\toutput_scc_insn, singlemove_string, mem_aligned_8, move_operand,\n+\tsparc_operand, v8plus_regcmp_op, v8plus_regcmp_p): Remove externs.\n+\t(sparc_emit_set_const32, sparc_emit_set_const64,\n+\tsparc_emit_set_symbolic_const64, input_operand, zero_operand,\n+\tmem_min_alignment, small_int_or_double): Add externs.\n+\t* config/sparc/sparc.md: Document the many uses of UNSPEC and\n+\tUNSPEC_VOLATILE in this backend.\n+\t(define_function_unit ieu): Rename to ieu_unnamed.  Add move and\n+\tunary to types which execute in it.\n+\t(define_function_unit ieu_shift): Rename to ieu0.\n+\t(define_function_unit ieu1): New, executes compare, call, and\n+\tuncond_branch type insns.\n+\t(define_function_units for type fdivs, fdivd, fsqrt): These\n+\texecute in the fpu multiply unit not the adder on UltraSparc.\n+\t(define_expand cmpdi): Disallow TARGET_V8PLUS.\n+\t(define_insn cmpsi_insn): Rename to cmpsi_insn_sp32.\n+\t(define_insn cmpsi_insn_sp64): New, same as sp32 variant except it\n+\tallows the arith_double_operand predicate and rHI constraint when\n+\tTARGET_ARCH64.\n+\t(define_insn cmpdi_sp64, cmpsf_fpe, cmpdf_fpe, cmptf_fpe,\n+\tcmpsf_fp, cmpdf_fp, cmptf_fp, sltu_insn, neg_sltu_insn,\n+\tneg_sltu_minux_x, neg_sltu_plus_x, sgeu_insn, neg_sgeu_insn,\n+\tsltu_plus_x, sltu_plus_x, sltu_plus_x_plus_y, x_minus_sltu,\n+\tsgeu_plus_x, x_minus_sgeu, movqi_cc_sp64, movhi_cc_sp64,\n+\tmovsi_cc_sp64, movdi_cc_sp64, movsf_cc_sp64, movdf_cc_sp64,\n+\tmovtf_cc_sp64, movqi_cc_reg_sp64, movhi_cc_reg_sp64,\n+\tmovsi_cc_reg_sp64, movdi_cc_reg_sp64, movsf_cc_reg_sp64,\n+\tmovdf_cc_reg_sp64, movtf_cc_reg_sp64, zero_extendhisi2_insn,\n+\tcmp_siqi_trunc, cmp_siqi_trunc_set, sign_extendhisi2_insn,\n+\tsign_extendqihi2_insn, sign_extendqisi2_insn,\n+\tsign_extendqidi2_insn, sign_extendhidi2_insn,\n+\textendsfdf2, extendsftf2, extenddftf2, truncdfsf2, trunctfsf2,\n+\ttrunctfdf2, floatsisf2, floatsidf2, floatsitf2, floatdisf2,\n+\tfloatdidf2, floatditf2, fix_truncsfsi2, fix_truncdfsi2,\n+\tfix_trunctfsi2, fix_truncsfdi2, fix_truncdfdi2, fix_trunctfdi2,\n+\tadddi3_sp64, addsi3, cmp_ccx_plus, cmp_cc_plus_set, subdi_sp64,\n+\tsubsi3, cmp_minus_ccx, cmp_minus_ccx_set, mulsi3, muldi3,\n+\tmuldi3_v8plus, cmp_mul_set, mulsidi3, mulsidi3_v8plus,\n+\tconst_mulsidi3_v8plus, mulsidi3_sp32, const_mulsidi3,\n+\tsmulsi3_highpart_v8plus, unnamed subreg mult,\n+\tconst_smulsi3_highpart_v8plus, smulsi3_highpart_sp32,\n+\tconst_smulsi3_highpart, umulsidi3_v8plus, umulsidi3_sp32,\n+\tconst_umulsidi3, const_umulsidi3_v8plus, umulsi3_highpart_v8plus,\n+\tconst_umulsi3_highpart_v8plus, umulsi3_highpart_sp32,\n+\tconst_umulsi3_highpart, divsi3, divdi3, cmp_sdiv_cc_set, udivsi3,\n+\tudivdi3, cmp_udiv_cc_set, smacsi, smacdi, umacdi, anddi3_sp64,\n+\tandsi3, and_not_di_sp64, and_not_si, iordi3_sp64, iorsi3,\n+\tor_not_di_sp64, or_not_si, xordi3_sp64, xorsi3, xor_not_di_sp64,\n+\txor_not_si, cmp_cc_arith_op, cmp_ccx_arith_op,\n+\tcmp_cc_arith_op_set, cmp_ccx_arith_op_set, cmp_ccx_xor_not,\n+\tcmp_cc_xor_not_set, cmp_ccx_xor_not_set, cmp_cc_arith_op_not,\n+\tcmp_ccx_arith_op_not, cmp_cc_arith_op_not_set,\n+\tcmp_ccx_arith_op_not_set, negdi2_sp64, cmp_cc_neg, cmp_ccx_neg,\n+\tcmp_cc_set_neg, cmp_ccx_set_neg, one_cmpldi2_sp64, cmp_cc_not,\n+\tcmp_ccx_not, cmp_cc_set_not, cmp_ccx_set_not, addtf3, adddf3,\n+\taddsf3, subtf3, subdf3, subsf3, multf3, muldf3, mulsf3,\n+\tmuldf3_extend, multf3_extend, divtf3, divdf3, divsf3, negtf2,\n+\tnegdf2, negsf2, abstf2, absdf2, abssf2, sqrttf2, sqrtdf2, sqrtsf2,\n+\tashlsi3, ashldi3, unnamed DI ashift, cmp_cc_ashift_1,\n+\tcmp_cc_set_ashift_1, ashrsi3, ashrdi3, unnamed DI ashiftrt,\n+\tashrdi3_v8plus, lshrsi3, lshrdi3, unnamed DI lshiftrt,\n+\tlshrdi3_v8plus, tablejump_sp32, tablejump_sp64, call_address_sp32,\n+\tcall_symbolic_sp32, call_address_sp64, call_symbolic_sp64,\n+\tcall_address_struct_value_sp32, call_symbolic_struct_value_sp32,\n+\tcall_address_untyped_struct_value_sp32,\n+\tcall_symbolic_untyped_struct_value_sp32, call_value_address_sp32,\n+\tcall_value_symbolic_sp32, call_value_address_sp64,\n+\tcall_value_symbolic_sp64, branch_sp32, branch_sp64,\n+\tflush_register_windows, goto_handler_and_restore,\n+\tgoto_handler_and_restore_v9, goto_handler_and_restore_v9_sp64,\n+\tflush, all ldd/std peepholes, return_qi, return_hi, return_si,\n+\treturn_addsi, return_di, return_adddi, return_sf, all call+jump\n+\tpeepholes, trap, unnamed trap insns): Prettify output strings.\n+\t(define_insn anddi3_sp32, and_not_di_sp32, iordi3_sp32,\n+\tor_not_di_sp32, xordi3_sp32, xor_not_di_sp32, one_cmpldi2):\n+\tLikewise and force + implement splits for integer cases.\n+\t(define_insn return_sf_no_fpu): Likewise and allow to match when\n+\tno-fpu because of our subreg SFmode splits.\n+\t(define_insn zero_extendqihi2, zero_extendqisi2_insn,\n+\tzero_extendqidi2_insn, zero_extendhidi2_insn,\n+\tzero_extendsidi2_insn, sign_extendsidi2_insn): Likewise and use\n+\tinput_operand for second operand.\n+\t(cmp_minus_cc, cmp_minus_cc_set): Likewise and use\n+\treg_or_0_operand for operand 2 so new splits can use it.\n+\t(cmp_zero_extendqisi2, cmp_zero_extendqisi2_set, cmp_cc_plus,\n+\tcmp_cc_xor_not): Likewise and don't forget to check TARGET_LIVE_G0\n+\ttoo.\n+\t(cmp_zero_extract, cmp_zero_extract_sp64): Likewise and allow\n+\tCONST_DOUBLEs for operand 2.\n+\t(define_insn move_label_di): Likewise and label distance\n+\toptimization because it no longer works with new deferred case\n+\tvector scheme.  To be revisited.\n+\t(define_insn x_minus_y_minus_sltu, x_minus_sltu_plus_y): Likewise\n+\tand allow reg_or_0_operand and J constraint for second operand.\n+\t(define_insn jump): Set branch predict taken on V9.\n+\t(define_insn tablejump): Emit LABEL_REF + PLUS memory address for\n+\tnew deferred case vector scheme.\n+\t(define_insn pic_tablejump_32, pic_tablejump_64): Remove.\n+\t(define_insn negdi2_sp32): Force + implement splits.\n+\t(define_insn negsi2, one_cmplsi2): Rename to negsi2_not_liveg0 and\n+\tone_cmplsi2_not_liveg0 respectively, and create\texpander of original\n+\tnames which emit special rtl for TARGET_LIVE_G0.\n+\t(define_insn cmpdi_v8plus, scc_si, scc_di): Remove.\n+\t(define_insn seq, sne, slt, sge, sle, sltu, sgeu): Don't do\n+\tgen_compare_reg, FAIL instead.\n+\t(define_insn sgtu, sleu): Likewise and check gen_s*() return\n+\tvalues when trying to reverse condition codes, if they FAIL then\n+\tdo likewise.\n+\t(define_insn snesi_zero, neg_snesi_zero, snesi_zero_extend,\n+\tsnedi_zero, neg_snedi_zero, snedi_zero_trunc, seqsi_zero,\n+\tneg_seqsi_zero, seqsi_zero_extend, seqdi_zero, neg_seqdi_zero,\n+\tseqdi_zero_trunc, x_plus_i_ne_0, x_minus_i_ne_0, x_plus_i_eq_0,\n+\tx_minus_i_eq_0): Add new splits to perform these multi-insn cases,\n+\tset output string to # to indicate they are mandatory splits.\n+\t(define_insn pic_lo_sum_si, pic_sethi_si, pic_lo_sum_di,\n+\tpic_sethi_di, move_pic_label_si): Remove.\n+\t(define_insn movsi_low_sum, movsi_high, movsi_lo_sum_pic,\n+\tmovsi_high_pic, movsi_pic_label_reg): New patterns to take their\n+\tplace.\n+\t(define_expand movsi_pic_label_ref, define_insn\n+\tmovsi_high_pic_label_ref, movsi_lo_sum_pic_label_ref): New\n+\texpander and insns to handle PIC label references and deferred\n+\tcase vectors.\n+\t(define_insn get_pc_via_rdpc): Comment out as it is no longer\n+\tused.\n+\t(define_expand movqi, movhi, movsi, movdi, movsf, movdf, movtf):\n+\tRewrite to not use emit_move_sequence, make use of new constant\n+\tformation code, and new splits for all multi-insn cases.\n+\t(define_insn movqi_insn): Remove sethi case, it can never happen.\n+\tUse reg_or_zero_operand instead of const0_rtx explicit test,\n+\tuse input_operand instead of move_operand for source, and use\n+\tgeneral_operand now for dest.\n+\t(define_insn movhi_insn): Similar but leave sethi case.\n+\t(define_insn lo_sum_qi, store_qi, store_hi): Remove.\n+\t(define_insn sethi_hi lo_sum_hi): Rename to movhi_high and\n+\tmovhi_lo_sum respectively, prettify output string.\n+\t(define_insn movsi_zero_liveg0): New pattern to put zero into a\n+\tregister when needed on TARGET_LIVE_G0.\n+\t(define_insn movsi_insn): Use general_operand and input_operand\n+\tfor dest and src respectively.  Simplify applicability test.\n+\tPrettify output strings, and add clr alternative for J\n+\tconstraint.\n+\t(define_insn movdi_sp32_v9, movdi_sp32, define_splits for\n+\tdeprecated std and reg-reg DI moves): Remove and...\n+\t(define_insn movdi_insn_sp32, movdi_insn_sp64): Replace with new\n+\timplementation which uses forced splits for all non-single insn\n+\tcases.\n+\t(define_split DI move cases on !arch64): New splits to handle all\n+\tsituations of 64-bit double register DImode on 32bit, and\n+\tunaligned registers and memory addresses for all subtargets.\n+\t(define_insn movsf_const_insn, movdf_const_insn, store_sf):\n+\tRemove.\n+\t(define_insn movsf_insn, movsf_no_f_insn): Use general_operand and\n+\tinput_operand for dest and src respectively, prettify output\n+\tstrings.\n+\t(define_insn movdf_insn, movdf_no_e_insn, store_df,\n+\tmovtf_const_insn, movtf_insn, movtf_no_e_insn, store_tf): Remove\n+\tand...\n+\t(define_insn movdf_insn_sp32, movdf_no_e_insn_sp32,\n+\tmovdf_insn_sp64, movdf_no_e_insn_sp64, movtf_insn,\n+\tmovtf_no_e_insn_sp32, movtf_insn_hq_sp64, movtf_insn_sp64,\n+\tmovtf_no_e_insn_sp64) Replace with new\n+\timplementation which uses forced splits for all non-single insn\n+\tcases.\n+\t(define_split DF move cases): New splits in similar vein to DI\n+\tmove counterparts.\n+\t(define_insn sethi_di_medlow, sethi_di_medium_pic,\n+\tsethi_di_embmedany_data, sethi_di_embmedany_text, sethi_di_sp64,\n+\tmovdi_sp64_insn): Remove old v9 code model and constant loading\n+\tsupport insns and..\n+\t(define_insn pic_lo_sum_di, pic_sethi_di,\n+\tsethi_di_medlow_embmedany_pic, sethi_di_medlow, losum_di_medlow,\n+\tseth44, setm44, setl44, sethh, setlm, sethm, setlo,\n+\tembmedany_sethi, embmedany_losum, embmedany_brsum,\n+\tembmedany_textuhi, embmedany_texthi, embmedany_textulo,\n+\tembmedany_textlo, movdi_lo_sum_sp64_cint, movdi_lo_sum_sp64_dbl,\n+\tmovdi_high_sp64_cint, movdi_high_sp64_dbl): Replace with new\n+\tscheme, using unspecs, secondary reloads, and one to one sparc\n+\tinsn to rtl insn mapping for better scheduling and code gen.\n+\t(define_expand reload_indi, reload_outdi): Reload helpers for\n+\tMEDANY and EMBMEDANY symbol address loading cases which require a\n+\ttemporary register.\n+\t(define_expand movsicc): Remove v8plus_regcmp cases.\n+\t(define_insn movdi_cc_sp64_trunc, movdi_cc_reg_sp64_trunc,\n+\tcmp_zero_extendqidi2, cmp_zero_extendqidi2_set, cmp_qidi_trunc,\n+\tcmp_diqi_trunc_set): New patterns used by some of the new scc\n+\tsplits on arch64.\n+\t(define_insn xordi3_sp64_dbl): New pattern used for constant\n+\tformation when crossing from 32-bit targets.\n+\t(define_insn movsi_cc_reg_v8plus, v8plus_clear_high, and helper\n+\tsplit): Remove.\n+\t(define_insn addx, subx): Make visible and prettify.\n+\t(define_insn adddi3_insn_sp32): Likewise and force split.\n+\t(define_insn addx_extend, subx_extend, unnamed): New patterns for\n+\t64bit scc split usage.\n+\t(define_insn unnamed plusDI zero_extend, unnamed minusDI\n+\tzero_extend, subdi3): Force and implement splits.\n+\t\n+\t* final.c (final_scan_insn): Don't output labels if target\n+\tspecifies ASM_OUTPUT_ADDR_{DIFF}_VEC.  Do these macro operations\n+\tinstead.\n+\t\n+\t* reorg.c (dbr_schedule): When taking on BR_PRED notes at the end,\n+\tdon't forget to walk inside SEQUENCESs too as these are what the\n+\tdelay slot scheduler will create.\n+\t\n Mon Aug 10 01:21:01 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.md (extxl+1,+2): New patterns to work around"}, {"sha": "a1e4ef0c252ab500db1b01865a4d8e0cfdcc1f69", "filename": "gcc/config/sparc/sp64-elf.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsp64-elf.h?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -102,9 +102,10 @@ crtbegin.o%s \\\n /* The medium/anywhere code model practically requires us to put jump tables\n    in the text section as gcc is unable to distinguish LABEL_REF's of jump\n    tables from other label refs (when we need to).  */\n-/* ??? Revisit this.  */\n+/* But we now defer the tables to the end of the function, so we make\n+   this 0 to not confuse the branch shortening code.  */\n #undef JUMP_TABLES_IN_TEXT_SECTION\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n \n /* System V Release 4 uses DWARF debugging info.\n    GDB doesn't support 64 bit stabs yet and the desired debug format is DWARF"}, {"sha": "c4411fae5fd3cdb58eb5777f19f44b5560859d73", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1552, "deletions": 1678, "changes": 3230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=e0d801845122f3952530d8047f17cfe62bf2aafc"}, {"sha": "9749bd1a3b607d4d2764bef77eee7ed8aa78de58", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 89, "deletions": 76, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -916,10 +916,8 @@ do\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tfixed_regs[5] = 1;\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-\tfixed_regs[1] = 1;\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n+    if (TARGET_LIVE_G0)\t\t\t\t\t\t\\\n+      fixed_regs[0] = 0;\t\t\t\t\t\\\n     if (! TARGET_V9)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n \tint regno;\t\t\t\t\t\t\\\n@@ -982,9 +980,15 @@ while (0)\n \n /* A subreg in 64 bit mode will have the wrong offset for a floating point\n    register.  The least significant part is at offset 1, compared to 0 for\n-   integer registers.  */\n+   integer registers.  This only applies when FMODE is a larger mode.  */\n #define ALTER_HARD_SUBREG(TMODE, WORD, FMODE, REGNO)\t\t\t\\\n-     (TARGET_ARCH64 && (REGNO) >= 32 && (REGNO) < 96 && (TMODE) == SImode ? 1 : ((REGNO) + (WORD)))\n+     (TARGET_ARCH64\t\t\t\t\t\t\t\\\n+      && (REGNO) >= SPARC_FIRST_FP_REG\t\t\t\t\t\\\n+      && (REGNO) <= SPARC_LAST_V9_FP_REG\t\t\t\t\\\n+      && (TMODE) == SImode\t\t\t\t\t\t\\\n+      && !((FMODE) == QImode || (FMODE) == HImode)\t\t\t\\\n+      ? ((REGNO) + 1)\t\t\t\t\t\t\t\\\n+      : ((REGNO) + (WORD)))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    See sparc.c for how we initialize this.  */\n@@ -1356,24 +1360,39 @@ extern char leaf_reg_remap[];\n /* Return the register class of a scratch register needed to load IN into\n    a register of class CLASS in MODE.\n \n-   On the SPARC, when PIC, we need a temporary when loading some addresses\n-   into a register.\n-\n-   Also, we need a temporary when loading/storing a HImode/QImode value\n+   We need a temporary when loading/storing a HImode/QImode value\n    between memory and the FPU registers.  This can happen when combine puts\n    a paradoxical subreg in a float/fix conversion insn.  */\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((FP_REG_CLASS_P (CLASS) && ((MODE) == HImode || (MODE) == QImode) \\\n+  ((FP_REG_CLASS_P (CLASS)\t\t\t\t\t\\\n+    && ((MODE) == HImode || (MODE) == QImode)\t\t\t\\\n     && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-\t|| ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-\t    && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n+        || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+            && true_regnum (IN) == -1)))\t\t\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\\\n+   : (((TARGET_CM_MEDANY\t\t\t\t\t\\\n+        && symbolic_operand ((IN), (MODE)))\t\t\t\\\n+       || (TARGET_CM_EMBMEDANY\t\t\t\t\t\\\n+           && text_segment_operand ((IN), (MODE))))\t\t\\\n+      && !flag_pic)\t\t\t\t\t\t\\\n+     ? GENERAL_REGS\t\t\t\t\t\t\\\n+     : NO_REGS)\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS, MODE, IN)\t\t\\\n-  ((FP_REG_CLASS_P (CLASS) && ((MODE) == HImode || (MODE) == QImode) \\\n-    && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n-\t|| ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n-\t    && true_regnum (IN) == -1))) ? GENERAL_REGS : NO_REGS)\n+   ((FP_REG_CLASS_P (CLASS)\t\t\t\t\t\\\n+     && ((MODE) == HImode || (MODE) == QImode)\t\t\t\\\n+     && (GET_CODE (IN) == MEM\t\t\t\t\t\\\n+         || ((GET_CODE (IN) == REG || GET_CODE (IN) == SUBREG)\t\\\n+             && true_regnum (IN) == -1)))\t\t\t\\\n+    ? GENERAL_REGS\t\t\t\t\t\t\\\n+   : (((TARGET_CM_MEDANY\t\t\t\t\t\\\n+        && symbolic_operand ((IN), (MODE)))\t\t\t\\\n+       || (TARGET_CM_EMBMEDANY\t\t\t\t\t\\\n+           && text_segment_operand ((IN), (MODE))))\t\t\\\n+      && !flag_pic)\t\t\t\t\t\t\\\n+     ? GENERAL_REGS\t\t\t\t\t\t\\\n+     : NO_REGS)\n \n /* On SPARC it is not possible to directly move data between \n    GENERAL_REGS and FP_REGS.  */\n@@ -2263,15 +2282,13 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n    After reload, it makes no difference, since pseudo regs have\n    been eliminated by then.  */\n \n-/* Optional extra constraints for this machine.  Borrowed from romp.h.\n+/* Optional extra constraints for this machine.\n \n-   For the SPARC, `Q' means that this is a memory operand but not a\n-   symbolic memory operand.  Note that an unassigned pseudo register\n-   is such a memory operand.  Needed because reload will generate\n-   these things in insns and then not re-recognize the insns, causing\n-   constrain_operands to fail.\n+   'T' handles memory addresses where the alignment is known to\n+       be at least 8 bytes.\n \n-   `S' handles constraints for calls.  ??? So where is it?  */\n+   `U' handles all pseudo registers or a hard even numbered\n+       integer register, needed for ldd/std instructions.  */\n \n #ifndef REG_OK_STRICT\n \n@@ -2287,17 +2304,11 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n /* 'T', 'U' are for aligned memory loads which aren't needed for v9.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q'\t\t\t\t\t\t\\\n-   ? ((GET_CODE (OP) == MEM\t\t\t\t\\\n-       && memory_address_p (GET_MODE (OP), XEXP (OP, 0)) \\\n-       && ! symbolic_memory_operand (OP, VOIDmode))\t\\\n-      || (reload_in_progress && GET_CODE (OP) == REG\t\\\n-\t  && REGNO (OP) >= FIRST_PSEUDO_REGISTER))\t\\\n-   : (! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-   ? (mem_aligned_8 (OP))\t\t\t\t\\\n-   : (! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n-   ? (register_ok_for_ldd (OP))\t\t\t\t\\\n-   : 0)\n+   ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n+    ? (mem_min_alignment (OP, 8))\t\t\t\\\n+    : ((! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n+       ? (register_ok_for_ldd (OP))\t\t\t\\\n+       : 0))\n  \n #else\n \n@@ -2307,19 +2318,14 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n-  ((C) == 'Q'\t\t\t\t\t\t\\\n-   ? (GET_CODE (OP) == REG\t\t\t\t\\\n-      ? (REGNO (OP) >= FIRST_PSEUDO_REGISTER\t\t\\\n-\t && reg_renumber[REGNO (OP)] < 0)\t\t\\\n-      : GET_CODE (OP) == MEM)\t\t\t\t\\\n-   : (! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n-   ? mem_aligned_8 (OP) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n-   : (! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n-   ? (GET_CODE (OP) == REG\t\t\t\t\\\n-      && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\t\\\n-\t  || reg_renumber[REGNO (OP)] >= 0)\t\t\\\n-      && register_ok_for_ldd (OP))\t\t\t\\\n-   : 0)\n+   ((! TARGET_ARCH64 && (C) == 'T')\t\t\t\\\n+    ? mem_min_alignment (OP, 8) && strict_memory_address_p (Pmode, XEXP (OP, 0)) \\\n+    : ((! TARGET_ARCH64 && (C) == 'U')\t\t\t\\\n+       ? (GET_CODE (OP) == REG\t\t\t\t\\\n+          && (REGNO (OP) < FIRST_PSEUDO_REGISTER\t\\\n+\t      || reg_renumber[REGNO (OP)] >= 0)\t\t\\\n+          && register_ok_for_ldd (OP))\t\t\t\\\n+       : 0))\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -2387,8 +2393,8 @@ extern struct rtx_def *sparc_builtin_saveregs ();\n \t  && CONSTANT_P (op1)\t\t\t\t\\\n \t  /* We can't allow TFmode, because an offset\t\\\n \t     greater than or equal to the alignment (8)\t\\\n-\t     may cause the LO_SUM to overflow.  */\t\\\n-\t  && MODE != TFmode)\t\t\t\t\\\n+\t     may cause the LO_SUM to overflow if !v9. */\\\n+\t  && (MODE != TFmode || TARGET_V9))\t\t\\\n \tgoto ADDR;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == CONST_INT && SMALL_INT (X))\t\\\n@@ -2435,8 +2441,7 @@ extern struct rtx_def *legitimize_pic_address ();\n \t\t   copy_to_mode_reg (Pmode, XEXP (X, 0)));\t\\\n   else if (GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == CONST\t\\\n \t   || GET_CODE (X) == LABEL_REF)\t\t\t\\\n-    (X) = gen_rtx_LO_SUM (Pmode,\t\t\t\t\\\n-\t\t\t  copy_to_mode_reg (Pmode, gen_rtx_HIGH (Pmode, X)), X); \\\n+    (X) = copy_to_suggested_reg (X, NULL_RTX, Pmode); \t\t\\\n   if (memory_address_p (MODE, X))\t\t\t\t\\\n     goto WIN; }\n \n@@ -2676,9 +2681,6 @@ extern struct rtx_def *legitimize_pic_address ();\n \treturn 0;\t\t\t\t\t\t\\\n     return 8;\n \n-/* Compute the cost of an address.  For the sparc, all valid addresses are\n-   the same cost.  */\n-\n #define ADDRESS_COST(RTX)  1\n \n /* Compute extra cost of moving data between one register class\n@@ -2920,6 +2922,15 @@ extern struct rtx_def *legitimize_pic_address ();\n #define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n   fprintf (FILE, \"\\t%s\\t0x%x\\n\", ASM_BYTE_OP, (VALUE))\n \n+/* This is how we hook in and defer the case-vector until the end of\n+   the function.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC(LAB,VEC) \\\n+  sparc_defer_case_vector ((LAB),(VEC), 0)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,VEC) \\\n+  sparc_defer_case_vector ((LAB),(VEC), 1)\n+\n /* This is how to output an element of a case-vector that is absolute.  */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n@@ -2933,7 +2944,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\\n   assemble_name (FILE, label);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\n\");\t\t\t\t\t\t\t\\\n+  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n } while (0)\n \n /* This is how to output an element of a case-vector that is relative.\n@@ -2942,15 +2953,18 @@ do {\t\t\t\t\t\t\t\t\t\\\n #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   char label[30];\t\t\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (VALUE));\t\t\t\\\n   if (Pmode == SImode)\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t\");\t\t\t\t\t\\\n   else if (TARGET_CM_MEDLOW)\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.word\\t0\\n\\t.word\\t\");\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     fprintf (FILE, \"\\t.xword\\t\");\t\t\t\t\t\\\n   assemble_name (FILE, label);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"-1b\\n\");\t\t\t\t\t\t\\\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", (REL));\t\t\t\\\n+  fputc ('-', FILE);\t\t\t\t\t\t\t\\\n+  assemble_name (FILE, label);\t\t\t\t\t\t\\\n+  fputc ('\\n', FILE);\t\t\t\t\t\t\t\\\n } while (0)\n \n /* This is how to output an assembler line\n@@ -3116,7 +3130,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (addr) == LO_SUM)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       output_operand (XEXP (addr, 0), 0);\t\t\t\\\n-      fputs (\"+%lo(\", FILE);\t\t\t\t\t\\\n+      if (TARGET_CM_MEDMID)\t\t\t\t\t\\\n+        fputs (\"+%l44(\", FILE);\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+        fputs (\"+%lo(\", FILE);\t\t\t\t\t\\\n       output_address (XEXP (addr, 1));\t\t\t\t\\\n       fputc (')', FILE);\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n@@ -3160,15 +3177,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"data_segment_operand\", {SYMBOL_REF, PLUS, CONST}},\t\t\t\t    \\\n {\"text_segment_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST}},\t\t\t    \\\n {\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\t    \\\n-{\"sparc_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\t    \\\n-{\"move_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE, MEM}},\t    \\\n {\"splittable_symbolic_memory_operand\", {MEM}},\t\t\t\t\t    \\\n {\"splittable_immediate_memory_operand\", {MEM}},\t\t\t\t\t    \\\n {\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\t    \\\n {\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\t    \\\n {\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\t    \\\n {\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\t    \\\n-{\"v8plus_regcmp_op\", {EQ, NE}},\t\t\t\t\t\t\t    \\\n {\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\t    \\\n {\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\t    \\\n {\"cc_arithopn\", {AND, IOR}},\t\t\t\t\t\t\t    \\\n@@ -3179,9 +3193,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n {\"arith11_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n {\"arith10_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n {\"small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n+{\"small_int_or_double\", {CONST_INT, CONST_DOUBLE, CONSTANT_P_RTX}},\t\t    \\\n {\"uns_small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n {\"uns_arith_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\t    \\\n-{\"clobbered_register\", {REG}},\n+{\"clobbered_register\", {REG}},\t\t\t\t\t\t\t    \\\n+{\"input_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\t    \\\n+{\"zero_operand\", {CONST_INT, CONSTANT_P_RTX}},\n \n \n /* The number of Pmode words for the setjmp buffer.  */\n@@ -3191,17 +3208,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Declare functions defined in sparc.c and used in templates.  */\n \n-extern char *doublemove_string ();\n-extern char *output_block_move ();\n+extern void sparc_emit_set_const32 ();\n+extern void sparc_emit_set_const64 ();\n+extern void sparc_emit_set_symbolic_const64 ();\n+extern int sparc_splitdi_legitimate ();\n+\n extern char *output_cbranch ();\n-extern char *output_fp_move_double ();\n-extern char *output_fp_move_quad ();\n-extern char *output_move_double ();\n-extern char *output_move_quad ();\n extern char *output_return ();\n-extern char *output_scc_insn ();\n extern char *output_v9branch ();\n-extern char *singlemove_string ();\n \n extern void emit_v9_brxx_insn ();\n extern void finalize_pic ();\n@@ -3221,6 +3235,8 @@ extern int arith11_operand ();\n extern int arith_double_operand ();\n extern int arith_operand ();\n extern int call_operand_address ();\n+extern int input_operand ();\n+extern int zero_operand ();\n extern int cc_arithop ();\n extern int cc_arithopn ();\n extern int check_pic ();\n@@ -3234,8 +3250,7 @@ extern int fcc_reg_operand ();\n extern int fp_zero_operand ();\n extern int icc_or_fcc_reg_operand ();\n extern int label_ref_operand ();\n-extern int mem_aligned_8 ();\n-extern int move_operand ();\n+extern int mem_min_alignment ();\n extern int noov_compare_op ();\n extern int pic_address_needs_scratch ();\n extern int reg_or_0_operand ();\n@@ -3246,11 +3261,11 @@ extern int registers_ok_for_ldd_peep ();\n extern int restore_operand ();\n extern int short_branch ();\n extern int small_int ();\n+extern int small_int_or_double ();\n extern int sp64_medium_pic_operand ();\n extern int sparc_flat_eligible_for_epilogue_delay ();\n extern int sparc_flat_epilogue_delay_slots ();\n extern int sparc_issue_rate ();\n-extern int sparc_operand ();\n extern int splittable_immediate_memory_operand ();\n extern int splittable_symbolic_memory_operand ();\n extern int supersparc_adjust_cost ();\n@@ -3259,8 +3274,6 @@ extern int symbolic_operand ();\n extern int text_segment_operand ();\n extern int ultrasparc_adjust_cost ();\n extern int uns_small_int ();\n-extern int v8plus_regcmp_op ();\n-extern int v8plus_regcmp_p ();\n extern int v9_regcmp_op ();\n extern int v9_regcmp_p ();\n "}, {"sha": "5cf7e807db4f4854920fb2ab34fab44e307adb77", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2663, "deletions": 1926, "changes": 4589, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=e0d801845122f3952530d8047f17cfe62bf2aafc"}, {"sha": "5a614e5ffa9d31f8d68f7fb47a07317c61364bc2", "filename": "gcc/config/sparc/sysv4.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Fconfig%2Fsparc%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsysv4.h?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -66,7 +66,9 @@ Boston, MA 02111-1307, USA.  */\n /* The native assembler can't compute differences between symbols in different\n    sections when generating pic code, so we must put jump tables in the\n    text section.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION 1\n+/* But we now defer the tables to the end of the function, so we make\n+   this 0 to not confuse the branch shortening code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION 0\n \n /* Pass -K to the assembler when PIC.  */\n #undef ASM_SPEC"}, {"sha": "e6a1d5347a67d97c083f91690c8cf5932daed5fa", "filename": "gcc/final.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -2326,6 +2326,11 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t  if (GET_CODE (nextbody) == ADDR_VEC\n \t      || GET_CODE (nextbody) == ADDR_DIFF_VEC)\n \t    {\n+#if defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC)\n+\t      /* In this case, the case vector is being moved by the\n+\t\t target, so don't output the label at all.  Leave that\n+\t\t to the back end macros.  */\n+#else\n \t      if (! JUMP_TABLES_IN_TEXT_SECTION)\n \t\t{\n \t\t  readonly_data_section ();\n@@ -2343,6 +2348,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\t\t\t     NEXT_INSN (insn));\n #else\n \t      ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (insn));\n+#endif\n #endif\n \t      break;\n \t    }\n@@ -2397,6 +2403,24 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t\tapp_on = 0;\n \t      }\n \n+#if defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC)\n+\t    if (GET_CODE (body) == ADDR_VEC)\n+\t      {\n+#ifdef ASM_OUTPUT_ADDR_VEC\n+\t\tASM_OUTPUT_ADDR_VEC (PREV_INSN (insn), body);\n+#else\n+\t\tabort();\n+#endif\n+\t      }\n+\t    else\n+\t      {\n+#ifdef ASM_OUTPUT_ADDR_DIFF_VEC\n+\t\tASM_OUTPUT_ADDR_DIFF_VEC (PREV_INSN (insn), body);\n+#else\n+\t\tabort();\n+#endif\n+\t      }\n+#else\n \t    vlen = XVECLEN (body, GET_CODE (body) == ADDR_DIFF_VEC);\n \t    for (idx = 0; idx < vlen; idx++)\n \t      {\n@@ -2426,6 +2450,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t    ASM_OUTPUT_CASE_END (file,\n \t\t\t\t CODE_LABEL_NUMBER (PREV_INSN (insn)),\n \t\t\t\t insn);\n+#endif\n #endif\n \n \t    function_section (current_function_decl);"}, {"sha": "fb855a9f221596a14b9a6c00d160d4d28c9f9222", "filename": "gcc/reorg.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0d801845122f3952530d8047f17cfe62bf2aafc/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=e0d801845122f3952530d8047f17cfe62bf2aafc", "patch": "@@ -4660,6 +4660,13 @@ dbr_schedule (first, file)\n     {\n       int pred_flags;\n \n+      if (GET_CODE (insn) == INSN)\n+        {\n+\t  rtx pat = PATTERN (insn);\n+\n+\t  if (GET_CODE (pat) == SEQUENCE)\n+\t    insn = XVECEXP (pat, 0, 0);\n+\t}\n       if (GET_CODE (insn) != JUMP_INSN)\n \tcontinue;\n "}]}