{"sha": "4d1d804584e7b0795a7c355d3a9cafaa947f1071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQxZDgwNDU4NGU3YjA3OTVhN2MzNTVkM2E5Y2FmYWE5NDdmMTA3MQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-03-28T00:12:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-03-28T00:12:41Z"}, "message": "basic-block.h (basic_block_computed_jump_target): Declare.\n\n\t* basic-block.h (basic_block_computed_jump_target): Declare.\n\t* flags.h: (current_function_has_computed_jump): Declare.\n\t* flow.c: (basic_block_computed_jump_target): Define.\n\t(flow_analysis): Allocate it. Set current_function_has_computed_jump\n\tto 0.\n\t(find_basic_blocks): Set current_function_has_computed_jump and\n\telements of basic_block_computed_jump_target to 1 as appropriate.\n\t* function.c: (current_function_has_computed_jump): Define.\n\t* global.c (global_conflicts): Don't allocate pseudos into stack regs\n\tat the start of a block that is reachable by a computed jump.\n\t* reg-stack.c (stack_reg_life_analysis): If must restart, do so\n\timmediately.\n\t(subst_stack_regs): Undo change from Sep 4 1997.\n\t(uses_reg_or_mem): Now unused, deleted.\n\t* stupid.c (stupid_life_analysis): Compute\n\tcurrent_function_has_computed_jump.\n\t(stupid_find_reg): Don't allocate stack regs if the function has a\n\tcomputed goto.\n        * haifa-sched.c (is_cfg_nonregular): Delete code to determine if\n        the current function has a computed jump.  Use the global value\n        instead.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r18860", "tree": {"sha": "2736d7d7941b48fd63e1b71a3c5182d1b4de78d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2736d7d7941b48fd63e1b71a3c5182d1b4de78d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d1d804584e7b0795a7c355d3a9cafaa947f1071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1d804584e7b0795a7c355d3a9cafaa947f1071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d1d804584e7b0795a7c355d3a9cafaa947f1071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d1d804584e7b0795a7c355d3a9cafaa947f1071/comments", "author": null, "committer": null, "parents": [{"sha": "56f28b73e7dbb93306da989b3984dd78f918b3e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56f28b73e7dbb93306da989b3984dd78f918b3e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56f28b73e7dbb93306da989b3984dd78f918b3e6"}], "stats": {"total": 181, "additions": 93, "deletions": 88}, "files": [{"sha": "c887af59d78940effa073e1f50423276fd78f50b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -1,3 +1,28 @@\n+Sat Mar 28 01:06:12 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de>\n+\t\t\t  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* basic-block.h (basic_block_computed_jump_target): Declare.\n+\t* flags.h: (current_function_has_computed_jump): Declare.\n+\t* flow.c: (basic_block_computed_jump_target): Define.\n+\t(flow_analysis): Allocate it. Set current_function_has_computed_jump\n+\tto 0.\n+\t(find_basic_blocks): Set current_function_has_computed_jump and\n+\telements of basic_block_computed_jump_target to 1 as appropriate.\n+\t* function.c: (current_function_has_computed_jump): Define.\n+\t* global.c (global_conflicts): Don't allocate pseudos into stack regs\n+\tat the start of a block that is reachable by a computed jump.\n+\t* reg-stack.c (stack_reg_life_analysis): If must restart, do so\n+\timmediately.\n+\t(subst_stack_regs): Undo change from Sep 4 1997.\n+\t(uses_reg_or_mem): Now unused, deleted.\n+\t* stupid.c (stupid_life_analysis): Compute\n+\tcurrent_function_has_computed_jump.\n+\t(stupid_find_reg): Don't allocate stack regs if the function has a\n+\tcomputed goto.\n+\t* haifa-sched.c (is_cfg_nonregular): Delete code to determine if\n+\tthe current function has a computed jump.  Use the global value\n+\tinstead.\n+\n Sat Mar 28 00:21:37 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386/freebsd.h (CPP_PREDEFINES): Remove __386BSD__."}, {"sha": "68f10ff10904bb241ff1a7d46208d21334832180", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -108,6 +108,11 @@ extern rtx *basic_block_head;\n \n extern rtx *basic_block_end;\n \n+/* Index by basic block number, determine whether the block can be reached\n+   through a computed jump.  */\n+\n+extern char *basic_block_computed_jump_target;\n+\n /* Index by basic block number, get address of regset\n    describing the registers live at the start of that block.  */\n "}, {"sha": "dccfc54b8bff9e6b6ec2a96d81dcaa61cdb1f61d", "filename": "gcc/flags.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -457,6 +457,13 @@ extern int current_function_has_nonlocal_label;\n \n extern int current_function_has_nonlocal_goto;\n \n+/* Nonzero if this function has a computed goto.\n+\n+   It is computed during find_basic_blocks or during stupid life\n+   analysis.  */\n+\n+extern int current_function_has_computed_jump;\n+\n /* Nonzero if GCC must add code to check memory access (used by Checker).  */\n \n extern int flag_check_memory_usage;"}, {"sha": "7c6a17f0e75a2d46ee9c7addc9ccc385844eb372", "filename": "gcc/flow.c", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -197,6 +197,11 @@ rtx *basic_block_head;\n \n rtx *basic_block_end;\n \n+/* Element N indicates whether basic block N can be reached through a\n+   computed jump.  */\n+\n+char *basic_block_computed_jump_target;\n+\n /* Element N is a regset describing the registers live\n    at the start of basic block N.\n    This info lasts until we finish compiling the function.  */\n@@ -354,6 +359,7 @@ find_basic_blocks (f, nregs, file, live_reachable_p)\n   basic_block_head = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n   basic_block_end = (rtx *) xmalloc (n_basic_blocks * sizeof (rtx));\n   basic_block_drops_in = (char *) xmalloc (n_basic_blocks);\n+  basic_block_computed_jump_target = (char *) oballoc (n_basic_blocks);\n   basic_block_loop_depth = (short *) xmalloc (n_basic_blocks * sizeof (short));\n   uid_block_number\n     = (int *) xmalloc ((max_uid_for_flow + 1) * sizeof (int));\n@@ -403,7 +409,9 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n   block_live_static = block_live;\n   bzero (block_live, n_basic_blocks);\n   bzero (block_marked, n_basic_blocks);\n+  bzero (basic_block_computed_jump_target, n_basic_blocks);\n   bzero (active_eh_handler, (max_uid_for_flow + 1) * sizeof (rtx));\n+  current_function_has_computed_jump = 0;\n \n   /* Initialize with just block 0 reachable and no blocks marked.  */\n   if (n_basic_blocks > 0)\n@@ -611,16 +619,25 @@ find_basic_blocks_1 (f, nonlocal_label_list, live_reachable_p)\n \t\t\t   and forced_labels list.  */\n \t\t\tif (computed_jump_p (insn))\n \t\t\t  {\n+\t\t\t    current_function_has_computed_jump = 1;\n \t\t\t    for (x = label_value_list; x; x = XEXP (x, 1))\n-\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t XEXP (x, 0)),\n-\t\t\t\t\t      insn, 0);\n+\t\t\t      {\n+\t\t\t\tint b = BLOCK_NUM (XEXP (x, 0));\n+\t\t\t\tbasic_block_computed_jump_target[b] = 1;\n+\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t   XEXP (x, 0)),\n+\t\t\t\t\t\tinsn, 0);\n+\t\t\t      }\n \n \t\t\t    for (x = forced_labels; x; x = XEXP (x, 1))\n-\t\t\t      mark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n-\t\t\t\t\t\t\t\t XEXP (x, 0)),\n-\t\t\t\t\t      insn, 0);\n-\t\t\t    }\n+\t\t\t      {\n+\t\t\t\tint b = BLOCK_NUM (XEXP (x, 0));\n+\t\t\t\tbasic_block_computed_jump_target[b] = 1;\n+\t\t\t\tmark_label_ref (gen_rtx_LABEL_REF (VOIDmode,\n+\t\t\t\t\t\t\t\t   XEXP (x, 0)),\n+\t\t\t\t\t\tinsn, 0);\n+\t\t\t      }\n+\t\t\t  }\n \n \t\t\t/* If this is a CALL_INSN, then mark it as reaching\n \t\t\t   the active EH handler for this CALL_INSN.  If"}, {"sha": "f69076f2b716c93008bda701433bfb36a8bc2120", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -126,6 +126,13 @@ int current_function_has_nonlocal_label;\n \n int current_function_has_nonlocal_goto;\n \n+/* Nonzero if this function has a computed goto.\n+\n+   It is computed during find_basic_blocks or during stupid life\n+   analysis.  */\n+\n+int current_function_has_computed_jump;\n+\n /* Nonzero if function being compiled contains nested functions.  */\n \n int current_function_contains_functions;"}, {"sha": "a92fdb1b332ed6dfda71f9a605c58035755275b5", "filename": "gcc/global.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -671,6 +671,15 @@ global_conflicts ()\n \t   allocno now live, and with each hard reg now live.  */\n \n \trecord_conflicts (block_start_allocnos, ax);\n+\n+#ifdef STACK_REGS\n+\t/* Pseudos can't go in stack regs at the start of a basic block\n+\t   that can be reached through a computed goto, since reg-stack\n+\t   can't handle computed gotos.  */\n+\tif (basic_block_computed_jump_target[b])\n+\t  for (ax = FIRST_STACK_REG; ax <= LAST_STACK_REG; ax++)\n+\t    record_one_conflict (ax);\n+#endif\n       }\n \n       insn = basic_block_head[b];"}, {"sha": "046c3531546f5c53b4fa3e59c6cdf101412f6fb7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -1098,6 +1098,11 @@ is_cfg_nonregular ()\n   if (forced_labels)\n     return 1;\n \n+  /* If this function has a computed jump, then we consider the cfg\n+     not well structured.  */\n+  if (current_function_has_computed_jump)\n+    return 1;\n+\n   /* If we have exception handlers, then we consider the cfg not well\n      structured.  ?!?  We should be able to handle this now that flow.c\n      computes an accurate cfg for EH.  */\n@@ -1124,20 +1129,6 @@ is_cfg_nonregular ()\n \t  break;\n       }\n \n-  /* If this function has a computed jump, then we consider the cfg\n-     not well structured.  */\n-  for (b = 0; b < n_basic_blocks; b++)\n-    {\n-      for (insn = basic_block_head[b];; insn = NEXT_INSN (insn))\n-\t{\n-\t  if (computed_jump_p (insn))\n-\t    return 1;\n-\n-\t  if (insn == basic_block_end[b])\n-\t    break;\n-\t}\n-    }\n-\n   /* All the tests passed.  Consider the cfg well structured.  */\n   return 0;\n }"}, {"sha": "0d17f3f87c4e8f3f40f30d2a20b4af007677b53d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -249,7 +249,6 @@ static void record_reg_life_pat\t\tPROTO((rtx, HARD_REG_SET *,\n static void get_asm_operand_lengths\tPROTO((rtx, int, int *, int *));\n static void record_reg_life\t\tPROTO((rtx, int, stack));\n static void find_blocks\t\t\tPROTO((rtx));\n-static int uses_reg_or_mem\t\tPROTO((rtx));\n static rtx stack_result\t\t\tPROTO((tree));\n static void stack_reg_life_analysis\tPROTO((rtx, HARD_REG_SET *));\n static void replace_reg\t\t\tPROTO((rtx *, int));\n@@ -1403,38 +1402,6 @@ find_blocks (first)\n     }\n }\n \n-/* Return 1 if X contain a REG or MEM that is not in the constant pool.  */\n-\n-static int\n-uses_reg_or_mem (x)\n-     rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  int i, j;\n-  char *fmt;\n-\n-  if (code == REG\n-      || (code == MEM\n-\t  && ! (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n-\t\t&& CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))))\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e'\n-\t  && uses_reg_or_mem (XEXP (x, i)))\n-\treturn 1;\n-\n-      if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  if (uses_reg_or_mem (XVECEXP (x, i, j)))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n /* If current function returns its result in an fp stack register,\n    return the REG.  Otherwise, return 0.  */\n \n@@ -1583,6 +1550,7 @@ stack_reg_life_analysis (first, stackentry)\n \n \t\t  block = jump_block;\n \t\t  must_restart = 1;\n+\t\t  break;\n \n \t\twin:\n \t\t  ;\n@@ -2730,7 +2698,6 @@ subst_stack_regs (insn, regstack)\n {\n   register rtx *note_link, note;\n   register int i;\n-  rtx head, jump, pat, cipat;\n   int n_operands;\n \n   if (GET_CODE (insn) == CALL_INSN)\n@@ -2802,39 +2769,6 @@ subst_stack_regs (insn, regstack)\n   if (GET_CODE (insn) == NOTE)\n     return;\n \n-  /* If we are reached by a computed goto which sets this same stack register,\n-     then pop this stack register, but maintain regstack. */\n-\n-  pat = single_set (insn);\n-  if (pat != 0\n-      && INSN_UID (insn) <= max_uid\n-      && GET_CODE (block_begin[BLOCK_NUM(insn)]) == CODE_LABEL\n-      && GET_CODE (pat) == SET && STACK_REG_P (SET_DEST (pat)))\n-    for (head = block_begin[BLOCK_NUM(insn)], jump = LABEL_REFS (head);\n-\t jump != head;\n-\t jump = LABEL_NEXTREF (jump))\n-      {\n-\tcipat = single_set (CONTAINING_INSN (jump));\n-\tif (cipat != 0\n-\t    && GET_CODE (cipat) == SET\n-\t    && SET_DEST (cipat) == pc_rtx\n-\t    && uses_reg_or_mem (SET_SRC (cipat))\n-\t    && INSN_UID (CONTAINING_INSN (jump)) <= max_uid)\n-\t  {\n-\t    int from_block = BLOCK_NUM (CONTAINING_INSN (jump));\n-\t    if (TEST_HARD_REG_BIT (block_out_reg_set[from_block],\n-\t\t\t\t   REGNO (SET_DEST (pat))))\n-\t      {\n-\t\tstruct stack_def old;\n-\t\tbcopy (regstack->reg, old.reg, sizeof (old.reg));\n-\t\temit_pop_insn (insn, regstack, SET_DEST (pat), emit_insn_before);\n-\t\tregstack->top += 1;\n-\t\tbcopy (old.reg, regstack->reg, sizeof (old.reg));\n-\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (SET_DEST (pat)));\n-\t      }\n-\t  }\n-      }\n-\n   /* If there is a REG_UNUSED note on a stack register on this insn,\n      the indicated reg must be popped.  The REG_UNUSED note is removed,\n      since the form of the newly emitted pop insn references the reg,"}, {"sha": "8b1153682fa9d21018917a4289dffcf611e2de5f", "filename": "gcc/stupid.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d1d804584e7b0795a7c355d3a9cafaa947f1071/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=4d1d804584e7b0795a7c355d3a9cafaa947f1071", "patch": "@@ -130,6 +130,8 @@ stupid_life_analysis (f, nregs, file)\n   register rtx last, insn;\n   int max_uid, max_suid;\n \n+  current_function_has_computed_jump = 0;\n+\n   bzero (regs_ever_live, sizeof regs_ever_live);\n \n   regs_live = (char *) alloca (nregs);\n@@ -265,6 +267,8 @@ stupid_life_analysis (f, nregs, file)\n \t     be live if it's also used to pass arguments.  */\n \t  stupid_mark_refs (CALL_INSN_FUNCTION_USAGE (insn), insn);\n \t}\n+      if (GET_CODE (insn) == JUMP_INSN && computed_jump_p (insn))\n+\tcurrent_function_has_computed_jump = 1;\n     }\n \n   /* Now decide the order in which to allocate the pseudo registers.  */\n@@ -394,6 +398,12 @@ stupid_find_reg (call_preserved, class, mode,\n   for (ins = born_insn; ins < dead_insn; ins++)\n     IOR_HARD_REG_SET (used, after_insn_hard_regs[ins]);\n \n+#ifdef STACK_REGS\n+  if (current_function_has_computed_jump)\n+    for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n+      SET_HARD_REG_BIT (used, i);\n+#endif\n+  \n   IOR_COMPL_HARD_REG_SET (used, reg_class_contents[(int) class]);\n \n #ifdef CLASS_CANNOT_CHANGE_SIZE"}]}