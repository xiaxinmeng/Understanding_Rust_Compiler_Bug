{"sha": "62ab1cafcf809ee77f6183758b27f7b579bd9900", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhYjFjYWZjZjgwOWVlNzdmNjE4Mzc1OGIyN2Y3YjU3OWJkOTkwMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-12-13T12:56:49Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-12-13T12:56:49Z"}, "message": "loop.c (remove_constant_addition): Fix prototype and whitespace.\n\n\t* loop.c (remove_constant_addition): Fix prototype and whitespace.\n\t(emit_prefetch_instructions): Remove warnings and whitespace\n\tchanges.\n\nFrom-SVN: r47972", "tree": {"sha": "e099d443991f8566d8cffedb2059b01e6c256afd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e099d443991f8566d8cffedb2059b01e6c256afd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62ab1cafcf809ee77f6183758b27f7b579bd9900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab1cafcf809ee77f6183758b27f7b579bd9900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62ab1cafcf809ee77f6183758b27f7b579bd9900", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62ab1cafcf809ee77f6183758b27f7b579bd9900/comments", "author": null, "committer": null, "parents": [{"sha": "c03bc36d9d581a77f9024f43acf37830e4fac9ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c03bc36d9d581a77f9024f43acf37830e4fac9ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c03bc36d9d581a77f9024f43acf37830e4fac9ef"}], "stats": {"total": 132, "additions": 83, "deletions": 49}, "files": [{"sha": "67931eb4bf6ddce7f0b829f946b7f22e520f04c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab1cafcf809ee77f6183758b27f7b579bd9900/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab1cafcf809ee77f6183758b27f7b579bd9900/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62ab1cafcf809ee77f6183758b27f7b579bd9900", "patch": "@@ -1,3 +1,9 @@\n+Thu Dec 13 07:47:24 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* loop.c (remove_constant_addition): Fix prototype and whitespace.\n+\t(emit_prefetch_instructions): Remove warnings and whitespace\n+\tchanges.\n+\n Thu Dec 13 06:48:38 2001  Douglas B. Rupp  <rupp@gnat.com>\n \n \t* config/alpha/vms-cc.c (preprocess_args): Fix forward"}, {"sha": "83ede76b2037cffb0a7974ff9684b01fc1a5d7c5", "filename": "gcc/loop.c", "status": "modified", "additions": 77, "deletions": 49, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62ab1cafcf809ee77f6183758b27f7b579bd9900/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62ab1cafcf809ee77f6183758b27f7b579bd9900/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=62ab1cafcf809ee77f6183758b27f7b579bd9900", "patch": "@@ -346,7 +346,7 @@ static rtx loop_insn_sink_or_swim PARAMS((const struct loop *, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n static void loop_delete_insns PARAMS ((rtx, rtx));\n-static int remove_constant_addition PARAMS ((rtx *));\n+static HOST_WIDE_INT remove_constant_addition PARAMS ((rtx *));\n void debug_ivs PARAMS ((const struct loop *));\n void debug_iv_class PARAMS ((const struct iv_class *));\n void debug_biv PARAMS ((const struct induction *));\n@@ -3634,12 +3634,13 @@ rtx_equal_for_prefetch_p (x, y)\n \f\n /* Remove constant addition value from the expression X (when present)\n    and return it.  */\n+\n static HOST_WIDE_INT\n remove_constant_addition (x)\n    rtx *x;\n {\n   HOST_WIDE_INT addval = 0;\n-  rtx exp=*x;\n+  rtx exp = *x;\n \n   if (GET_CODE (exp) == CONST)\n     exp = XEXP (exp, 0);\n@@ -3648,18 +3649,21 @@ remove_constant_addition (x)\n       addval = INTVAL (exp);\n       *x = const0_rtx;\n     }\n+\n   /* For plus expression recurse on ourself.  */\n   else if (GET_CODE (exp) == PLUS)\n     {\n       addval += remove_constant_addition (&XEXP (exp, 0));\n       addval += remove_constant_addition (&XEXP (exp, 1));\n-      /* In case our parameter was constant,  remove extra zero\n-         from the expression.  */\n+\n+      /* In case our parameter was constant, remove extra zero from the\n+\t expression.  */\n       if (XEXP (exp, 0) == const0_rtx)\n         *x = XEXP (exp, 1);\n       else if (XEXP (exp, 1) == const0_rtx)\n         *x = XEXP (exp, 0);\n     }\n+\n   return addval;\n }\n \n@@ -3681,10 +3685,11 @@ remove_constant_addition (x)\n    that support write prefetches.\n \n    Several heuristics are used to determine when to prefetch.  They are\n-   controlled by defined symbols that can be overridden for each target.\n-*/\n+   controlled by defined symbols that can be overridden for each target. */\n+\n static void\n-emit_prefetch_instructions (struct loop *loop)\n+emit_prefetch_instructions (loop)\n+     struct loop *loop;\n {\n   int num_prefetches = 0;\n   int num_real_prefetches = 0;\n@@ -3705,6 +3710,7 @@ emit_prefetch_instructions (struct loop *loop)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"Prefetch: ignoring loop - has call.\\n\");\n+\n       return;\n     }\n \n@@ -3726,6 +3732,7 @@ emit_prefetch_instructions (struct loop *loop)\n       int basestride = 0;\n \n       biv1 = biv;\n+\n       /* Expect all BIVs to be executed in each iteration.  This makes our\n \t analysis more conservative.  */\n       while (biv1)\n@@ -3736,34 +3743,39 @@ emit_prefetch_instructions (struct loop *loop)\n \t     since these only result in larger strides and make our\n \t     heuristics more conservative.\n \t     ??? What does the last sentence mean?  */\n-\n \t  if (GET_CODE (biv->add_val) != CONST_INT)\n \t    {\n \t      if (loop_dump_stream)\n \t\t{\n-\t\t  fprintf (loop_dump_stream, \"Prefetch: biv %i ignored: non-constant addition at insn %i:\",\n+\t\t  fprintf (loop_dump_stream,\n+\t\t\t   \"Prefetch: biv %i ignored: non-constant addition at insn %i:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n \t\t  print_rtl (loop_dump_stream, biv->add_val);\n \t\t  fprintf (loop_dump_stream, \"\\n\");\n \t\t}\n \t      break;\n \t    }\n+\n \t  if (biv->maybe_multiple)\n \t    {\n \t      if (loop_dump_stream)\n \t\t{\n-\t\t  fprintf (loop_dump_stream, \"Prefetch: biv %i ignored: maybe_multiple at insn %i:\",\n+\t\t  fprintf (loop_dump_stream,\n+\t\t\t   \"Prefetch: biv %i ignored: maybe_multiple at insn %i:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n \t\t  print_rtl (loop_dump_stream, biv->add_val);\n \t\t  fprintf (loop_dump_stream, \"\\n\");\n \t\t}\n \t      break;\n \t    }\n+\n \t  basestride += INTVAL (biv1->add_val);\n \t  biv1 = biv1->next_iv;\n \t}\n+\n       if (biv1 || !basestride)\n \tcontinue;\n+\n       for (iv = bl->giv; iv; iv = iv->next_iv)\n \t{\n \t  rtx address;\n@@ -3777,29 +3789,27 @@ emit_prefetch_instructions (struct loop *loop)\n \t  /* There are several reasons why an induction variable is not\n \t     interesting to us.  */\n \t  if (iv->giv_type != DEST_ADDR\n-\t  /* We are interested only in constant stride memory references\n-\t     in order to be able to compute density easily.  */\n+\t      /* We are interested only in constant stride memory references\n+\t\t in order to be able to compute density easily.  */\n \t      || GET_CODE (iv->mult_val) != CONST_INT\n-\t  /* Don't handle reversed order prefetches, since they are usually\n-\t     ineffective.  Later we may be able to reverse such BIVs.  */\n+\t      /* Don't handle reversed order prefetches, since they are usually\n+\t\t ineffective.  Later we may be able to reverse such BIVs.  */\n \t      || (PREFETCH_NO_REVERSE_ORDER \n \t\t  && (stride = INTVAL (iv->mult_val) * basestride) < 0)\n-\t  /* Prefetching of accesses with such a extreme stride is probably\n-\t     not worthwhile, either.  */\n+\t      /* Prefetching of accesses with such a extreme stride is probably\n+\t\t not worthwhile, either.  */\n \t      || (PREFETCH_NO_EXTREME_STRIDE\n \t\t  && stride > PREFETCH_EXTREME_STRIDE)\n-\t  /* Ignore GIVs with varying add values; we can't predict the value\n-\t     for the next iteration.  */\n+\t      /* Ignore GIVs with varying add values; we can't predict the\n+\t\t value for the next iteration.  */\n \t      || !loop_invariant_p (loop, iv->add_val)\n-\t  /* Ignore GIVs in the nested loops; they ought to have been handled\n-\t     already.  */\n+\t      /* Ignore GIVs in the nested loops; they ought to have been\n+\t\t handled already.  */\n \t      || iv->maybe_multiple)\n \t    {\n \t      if (loop_dump_stream)\n-\t\t{\n-\t\t  fprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %i\\n\",\n-\t\t\t   INSN_UID (iv->insn));\n-\t\t}\n+\t\tfprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %i\\n\",\n+\t\t\t INSN_UID (iv->insn));\n \t      continue;\n \t    }\n \n@@ -3816,6 +3826,7 @@ emit_prefetch_instructions (struct loop *loop)\n \t  index += size;\n \t  d.mem_write = 0;\n \t  d.mem_address = *iv->location;\n+\n \t  /* When the GIV is not always executed, we might be better off by\n \t     not dirtying the cache pages.  */\n \t  if (PREFETCH_NOT_ALWAYS || iv->always_executed)\n@@ -3834,7 +3845,6 @@ emit_prefetch_instructions (struct loop *loop)\n \t\t   4096 is artificial threshold.  It should not be too small,\n \t\t   but also not bigger than small portion of memory usually\n \t\t   traversed by single loop.  */\n-\n \t\tif (index >= info[i].index && index - info[i].index < 4096)\n \t\t  {\n \t\t    info[i].write |= d.mem_write;\n@@ -3846,6 +3856,7 @@ emit_prefetch_instructions (struct loop *loop)\n \t\t    add = 0;\n \t\t    break;\n \t\t  }\n+\n \t\tif (index < info[i].index && info[i].index - index < 4096)\n \t\t  {\n \t\t    info[i].write |= d.mem_write;\n@@ -3854,6 +3865,7 @@ emit_prefetch_instructions (struct loop *loop)\n \t\t    break;\n \t\t  }\n \t      }\n+\n \t  /* Merging failed.  */\n \t  if (add)\n \t    {\n@@ -3868,35 +3880,35 @@ emit_prefetch_instructions (struct loop *loop)\n \t      if (num_prefetches >= MAX_PREFETCHES)\n \t\t{\n \t\t  if (loop_dump_stream)\n-\t\t    fprintf(loop_dump_stream,\"Maximal number of prefetches exceeded.\\n\");\n+\t\t    fprintf (loop_dump_stream,\n+\t\t\t     \"Maximal number of prefetches exceeded.\\n\");\n \t\t  return;\n \t\t}\n \t    }\n \t}\n     }\n+\n   for (i = 0; i < num_prefetches; i++)\n     {\n       /* Attempt to calculate the number of bytes fetched by the loop.\n \t Avoid overflow.  */\n       if (LOOP_INFO (loop)->n_iterations\n-          && (0xffffffff / info[i].stride) >= LOOP_INFO (loop)->n_iterations)\n+          && ((unsigned HOST_WIDE_INT) (0xffffffff / info[i].stride)\n+\t      >= LOOP_INFO (loop)->n_iterations))\n \tinfo[i].total_bytes = info[i].stride * LOOP_INFO (loop)->n_iterations;\n       else\n \tinfo[i].total_bytes = 0xffffffff;\n \n-\n       /* Prefetch is worthwhile only when the loads/stores are dense.  */\n       if (PREFETCH_ONLY_DENSE_MEM\n-\t  && (info[i].bytes_accesed * 256 / info[i].stride > PREFETCH_DENSE_MEM)\n-\t  && (info[i].total_bytes / PREFETCH_BLOCK >=\n-\t      PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n+\t  && info[i].bytes_accesed * 256 / info[i].stride > PREFETCH_DENSE_MEM\n+\t  && (info[i].total_bytes / PREFETCH_BLOCK\n+\t      >= PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n \t{\n \t  info[i].prefetch_before_loop = 1;\n-\t  if (info[i].total_bytes / PREFETCH_BLOCK <=\n-\t      PREFETCH_BLOCKS_BEFORE_LOOP_MAX)\n-\t    info[i].prefetch_in_loop = 0;\n-\t  else\n-\t    info[i].prefetch_in_loop = 1;\n+\t  info[i].prefetch_in_loop\n+\t    = (info[i].total_bytes / PREFETCH_BLOCK\n+\t       > PREFETCH_BLOCKS_BEFORE_LOOP_MAX);\n \t}\n       else\n         info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n@@ -3906,41 +3918,49 @@ emit_prefetch_instructions (struct loop *loop)\n \t  num_real_prefetches += ((info[i].stride + PREFETCH_BLOCK - 1)\n \t\t\t\t  / PREFETCH_BLOCK);\n \t  if (info[i].write)\n-\t    num_real_write_prefetches +=\n-\t\t((info[i].stride + PREFETCH_BLOCK - 1) / PREFETCH_BLOCK);\n+\t    num_real_write_prefetches\n+\t      += (info[i].stride + PREFETCH_BLOCK - 1) / PREFETCH_BLOCK;\n \t}\n     }\n+\n   if (loop_dump_stream)\n     {\n       for (i = 0; i < num_prefetches; i++)\n \t{\n \t  fprintf (loop_dump_stream, \"Prefetch insn %i address: \",\n \t\t   INSN_UID (info[i].giv->insn));\n \t  print_rtl (loop_dump_stream, info[i].base_address);\n-\t  fprintf (loop_dump_stream, \" Index:%i stride:%i density:%i%% total_bytes: %u %s in loop:%s before:%s\\n\",\n-\t\t   info[i].index, info[i].stride,\n-\t\t   info[i].bytes_accesed * 100 / info[i].stride,\n+\t  fprintf (loop_dump_stream, \" Index: \");\n+\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].index);\n+\t  fprintf (loop_dump_stream, \" stride: \");\n+\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].stride);\n+\t  fprintf (loop_dump_stream,\n+\t\t   \" density: %i%% total_bytes: %u%sin loop: %s before: %s\\n\",\n+\t\t   (int) (info[i].bytes_accesed * 100 / info[i].stride),\n \t\t   info[i].total_bytes,\n-\t\t   info[i].write ? \"read/write\" : \"read only\",\n+\t\t   info[i].write ? \" read/write \" : \" read only \",\n \t\t   info[i].prefetch_in_loop ? \"yes\" : \"no\",\n \t\t   info[i].prefetch_before_loop ? \"yes\" : \"no\");\n \t}\n-      fprintf (loop_dump_stream, \"Real prefetches needed:%i (write:%i)\\n\",\n+\n+      fprintf (loop_dump_stream, \"Real prefetches needed: %i (write: %i)\\n\",\n \t       num_real_prefetches, num_real_write_prefetches);\n     }\n \n   if (!num_real_prefetches)\n     return;\n \n-  ahead = (SIMULTANEOUS_PREFETCHES / (num_real_prefetches));\n+  ahead = SIMULTANEOUS_PREFETCHES / num_real_prefetches;\n \n   if (!ahead)\n     return;\n+\n   for (i = 0; i < num_prefetches; i++)\n     {\n       if (info[i].prefetch_in_loop)\n \t{\n \t  int y;\n+\n \t  for (y = 0; y < ((info[i].stride + PREFETCH_BLOCK - 1)\n \t\t\t   / PREFETCH_BLOCK); y++)\n \t    {\n@@ -3964,9 +3984,11 @@ emit_prefetch_instructions (struct loop *loop)\n \t\t}\n \n \t      emit_insn_before (gen_prefetch (loc, GEN_INT (info[i].write),\n-\t\t                              GEN_INT (3)), before_insn);\n+\t\t                              GEN_INT (3)),\n+\t\t\t\tbefore_insn);\n \n-\t      /* Check all insns emitted and record the new GIV information.  */\n+\t      /* Check all insns emitted and record the new GIV\n+\t\t information.  */\n \t      insn = NEXT_INSN (prev_insn);\n \t      while (insn != before_insn)\n \t\t{\n@@ -3977,26 +3999,32 @@ emit_prefetch_instructions (struct loop *loop)\n \t\t}\n \t    }\n \t}\n+\n       if (info[i].prefetch_before_loop)\n \t{\n \t  int y;\n+\n \t  /* Emit INSNs before the loop to fetch the first cache lines.  */\n-\t  for (y = 0; ((!info[i].prefetch_in_loop || y < ahead)\n-\t\t       && y * PREFETCH_BLOCK < (int)info[i].total_bytes); y ++)\n+\t  for (y = 0;\n+\t       (!info[i].prefetch_in_loop || y < ahead)\n+\t       && y * PREFETCH_BLOCK < (int) info[i].total_bytes; y ++)\n \t    {\n \t      rtx reg = gen_reg_rtx (Pmode);\n \t      rtx loop_start = loop->start;\n \t      rtx add_val = simplify_gen_binary (PLUS, Pmode,\n \t\t\t\t\t\t info[i].giv->add_val,\n \t\t\t\t\t\t GEN_INT (y * PREFETCH_BLOCK));\n+\n \t      loop_iv_add_mult_emit_before (loop, info[i].class->initial_value,\n \t\t\t\t\t    info[i].giv->mult_val,\n \t\t\t\t            add_val, reg, 0, loop_start);\n \t      emit_insn_before (gen_prefetch (reg, GEN_INT (info[i].write),\n-\t\t\t\t\t      GEN_INT (3)), loop_start);\n+\t\t\t\t\t      GEN_INT (3)),\n+\t\t\t\tloop_start);\n \t    }\n \t}\n     }\n+\n   return;\n }\n \f"}]}