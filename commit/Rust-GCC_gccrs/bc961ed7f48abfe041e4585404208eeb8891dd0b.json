{"sha": "bc961ed7f48abfe041e4585404208eeb8891dd0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM5NjFlZDdmNDhhYmZlMDQxZTQ1ODU0MDQyMDhlZWI4ODkxZGQwYg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T05:58:28Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-15T05:58:28Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r986", "tree": {"sha": "23ecb78f6f9221995078ad885dab3c69bda5593a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/23ecb78f6f9221995078ad885dab3c69bda5593a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc961ed7f48abfe041e4585404208eeb8891dd0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc961ed7f48abfe041e4585404208eeb8891dd0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc961ed7f48abfe041e4585404208eeb8891dd0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc961ed7f48abfe041e4585404208eeb8891dd0b/comments", "author": null, "committer": null, "parents": [{"sha": "e16c591a119cfadadb854ee51dffc724d9ee97f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16c591a119cfadadb854ee51dffc724d9ee97f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16c591a119cfadadb854ee51dffc724d9ee97f8"}], "stats": {"total": 42, "additions": 42, "deletions": 0}, "files": [{"sha": "f9eeef8c00cb2820d67b7ca159b095eb5247bf5d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc961ed7f48abfe041e4585404208eeb8891dd0b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc961ed7f48abfe041e4585404208eeb8891dd0b/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=bc961ed7f48abfe041e4585404208eeb8891dd0b", "patch": "@@ -1048,6 +1048,47 @@ output_move_double (operands)\n       || (optype0 != REGOP && optype0 != CNSTOP && optype1 == REGOP\n \t  && (REGNO (operands[1]) & 1) == 0))\n     {\n+      /* Now that all misaligned double parms are copied\n+\t on function entry, we can assume any 64-bit object\n+\t is 64-bit aligned.  */\n+#if 1\n+      rtx addr;\n+      rtx base, offset;\n+\n+      if (optype0 == REGOP)\n+\taddr = operands[1];\n+      else\n+\taddr = operands[0];\n+\n+      /* See what register we use in the address.  */\n+      base = 0;\n+      if (GET_CODE (XEXP (addr, 0)) == PLUS)\n+\t{\n+\t  rtx temp = XEXP (addr, 0);\n+\t  if (GET_CODE (XEXP (temp, 0)) == REG\n+\t      && GET_CODE (XEXP (temp, 1)) == CONST_INT)\n+\t    base = XEXP (temp, 0), offset = XEXP (temp, 1);\n+\t}\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\n+\tbase = XEXP (addr, 0), offset = const0_rtx;\n+\n+      /* If it's the  stack or frame pointer, check offset alignment.\n+\t We can have improper aligment in the function entry code.  */\n+      if (base\n+\t  && (REGNO (base) == FRAME_POINTER_REGNUM\n+\t      || REGNO (base) == STACK_POINTER_REGNUM))\n+\t{\n+\t  if ((INTVAL (offset) & 0x7) == 0)\n+\t    return (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n+\t}\n+      else\n+\t/* Anything else, we know is properly aligned.  */\n+\treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n+#else\n+      /* This old code is preserved in case we ever need\n+\t it for Fortran.  It won't be complete right;\n+\t In Fortran, doubles can be just 32-bit aligned\n+\t even in global variables and arrays.  */\n       rtx addr;\n       rtx base, offset;\n \n@@ -1098,6 +1139,7 @@ output_move_double (operands)\n \t\t   || MEM_IN_STRUCT_P (addr)\n \t\t   || TARGET_HOPE_ALIGN))\n \treturn (addr == operands[1] ? \"ldd %1,%0\" : \"std %1,%0\");\n+#endif /* 0 */\n     }\n \n   if (optype0 == REGOP && optype1 == REGOP"}]}