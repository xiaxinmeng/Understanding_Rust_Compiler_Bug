{"sha": "658f32fda265f363b18b912ad3560eebeeb28b64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjU4ZjMyZmRhMjY1ZjM2M2IxOGI5MTJhZDM1NjBlZWJlZWIyOGI2NA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-02-04T22:08:04Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2006-02-04T22:08:04Z"}, "message": "re PR debug/24444 (invalid register in debug info)\n\nPR debug/24444\n* config/ia64/ia64.c: Include debug.h.\n(MAX_ARTIFICIAL_LABEL_BYTES): New.\n(ia64_label_after_insn, ia64_dwarf2out_def_steady_cfa): New.\n(IA64_CHANGE_CFA_IN_EPILOGUE): Define to 0.\n(process_epilogue, process_set, process_for_unwind_directive):\nOutput unwind info only if requested.  Add CFA info if requested.\nAdd new arguments as needed.  Adjust callers.\n* config/ia64/ia64.h (ARG_POINTER_CFA_OFFSET): Override\nincorrect default.\n(DWARF2_FRAME_INFO): Define to zero.\n* config/ia64/unwind-ia64.c: Remove code that compensated for\nthe CFA offset error fixed above.\n* config/ia64/t-ia64 (ia64.o): Depend on debug.h.\n* dwarf2out.c (DWARF2_FRAME_INFO): Define default.\n(dwarf2out_do_frame): Require nonzero DWARF2_UNWIND_INFO for\n-funwind-tables and -fexceptions to enable frame info.\n(dwarf2out_frame_init): Define initial CFA even if\nDWARF2_UNWIND_INFO is disabled.  Call initial_return_save if\nDWARF2_UNWIND_INFO is nonzero, not just defined.\n(dwarf2out_frame_finish): Output non-EH call frame info only\nif DWARF2_FRAME_INFO is nonzero.\n(convert_cfa_to_loc_list,\ncompute_frame_pointer_to_cfa_displacement): Define even if\nunwind info is not supported.\n(gen_subprogram_die): Use the above unconditionally.  Remove\nlegacy alternate code.\n* toplev.c (compile_file): Compile in call to\ndwarf2out_frame_finish if DWARF2_DEBUGGING_INFO is defined.\n(lang_dependent_init): Ditto for dwarf2out_frame_init.\n\nFrom-SVN: r110594", "tree": {"sha": "fb40a2b7673d57f55dfc5ac1a79cb20828a95882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fb40a2b7673d57f55dfc5ac1a79cb20828a95882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/658f32fda265f363b18b912ad3560eebeeb28b64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/658f32fda265f363b18b912ad3560eebeeb28b64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/658f32fda265f363b18b912ad3560eebeeb28b64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/658f32fda265f363b18b912ad3560eebeeb28b64/comments", "author": null, "committer": null, "parents": [{"sha": "5460aa9c92db4858927d7a7c2118e71d7c90aa6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5460aa9c92db4858927d7a7c2118e71d7c90aa6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5460aa9c92db4858927d7a7c2118e71d7c90aa6d"}], "stats": {"total": 281, "additions": 206, "deletions": 75}, "files": [{"sha": "e1fac08dbb54eaad05126ec08726fedcd52dcaa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -1,3 +1,36 @@\n+2006-02-04  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/24444\n+\t* config/ia64/ia64.c: Include debug.h.\n+\t(MAX_ARTIFICIAL_LABEL_BYTES): New.\n+\t(ia64_label_after_insn, ia64_dwarf2out_def_steady_cfa): New.\n+\t(IA64_CHANGE_CFA_IN_EPILOGUE): Define to 0.\n+\t(process_epilogue, process_set, process_for_unwind_directive):\n+\tOutput unwind info only if requested.  Add CFA info if requested.\n+\tAdd new arguments as needed.  Adjust callers.\n+\t* config/ia64/ia64.h (ARG_POINTER_CFA_OFFSET): Override\n+\tincorrect default.\n+\t(DWARF2_FRAME_INFO): Define to zero.\n+\t* config/ia64/unwind-ia64.c: Remove code that compensated for\n+\tthe CFA offset error fixed above.\n+\t* config/ia64/t-ia64 (ia64.o): Depend on debug.h.\n+\t* dwarf2out.c (DWARF2_FRAME_INFO): Define default.\n+\t(dwarf2out_do_frame): Require nonzero DWARF2_UNWIND_INFO for\n+\t-funwind-tables and -fexceptions to enable frame info.\n+\t(dwarf2out_frame_init): Define initial CFA even if\n+\tDWARF2_UNWIND_INFO is disabled.  Call initial_return_save if\n+\tDWARF2_UNWIND_INFO is nonzero, not just defined.\n+\t(dwarf2out_frame_finish): Output non-EH call frame info only\n+\tif DWARF2_FRAME_INFO is nonzero.\n+\t(convert_cfa_to_loc_list,\n+\tcompute_frame_pointer_to_cfa_displacement): Define even if\n+\tunwind info is not supported.\n+\t(gen_subprogram_die): Use the above unconditionally.  Remove\n+\tlegacy alternate code.\n+\t* toplev.c (compile_file): Compile in call to\n+\tdwarf2out_frame_finish if DWARF2_DEBUGGING_INFO is defined.\n+\t(lang_dependent_init): Ditto for dwarf2out_frame_init.\n+\n 2006-02-04  David Edelsohn  <edelsohn@gnu.org>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "cee13b010aff23f0f939ed597c50452fbb7590c3", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 135, "deletions": 45, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -53,6 +53,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"cfglayout.h\"\n #include \"tree-gimple.h\"\n #include \"intl.h\"\n+#include \"debug.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -190,8 +191,8 @@ static void final_emit_insn_group_barriers (FILE *);\n static void emit_predicate_relation_info (void);\n static void ia64_reorg (void);\n static bool ia64_in_small_data_p (tree);\n-static void process_epilogue (void);\n-static int process_set (FILE *, rtx);\n+static void process_epilogue (FILE *, rtx, bool, bool);\n+static int process_set (FILE *, rtx, rtx, bool, bool);\n \n static bool ia64_assemble_integer (rtx, unsigned int, int);\n static void ia64_output_function_prologue (FILE *, HOST_WIDE_INT);\n@@ -7971,29 +7972,84 @@ static bool last_block;\n \n static bool need_copy_state;\n \n+#ifndef MAX_ARTIFICIAL_LABEL_BYTES\n+# define MAX_ARTIFICIAL_LABEL_BYTES 30\n+#endif\n+\n+/* Emit a debugging label after a call-frame-related insn.  We'd\n+   rather output the label right away, but we'd have to output it\n+   after, not before, the instruction, and the instruction has not\n+   been output yet.  So we emit the label after the insn, delete it to\n+   avoid introducing basic blocks, and mark it as preserved, such that\n+   it is still output, given that it is referenced in debug info.  */\n+\n+static const char *\n+ia64_emit_deleted_label_after_insn (rtx insn)\n+{\n+  char label[MAX_ARTIFICIAL_LABEL_BYTES];\n+  rtx lb = gen_label_rtx ();\n+  rtx label_insn = emit_label_after (lb, insn);\n+\n+  LABEL_PRESERVE_P (lb) = 1;\n+\n+  delete_insn (label_insn);\n+\n+  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", CODE_LABEL_NUMBER (label_insn));\n+\n+  return xstrdup (label);\n+}\n+\n+/* Define the CFA after INSN with the steady-state definition.  */\n+\n+static void\n+ia64_dwarf2out_def_steady_cfa (rtx insn)\n+{\n+  rtx fp = frame_pointer_needed\n+    ? hard_frame_pointer_rtx\n+    : stack_pointer_rtx;\n+\n+  dwarf2out_def_cfa\n+    (ia64_emit_deleted_label_after_insn (insn),\n+     REGNO (fp),\n+     ia64_initial_elimination_offset\n+     (REGNO (arg_pointer_rtx), REGNO (fp))\n+     + ARG_POINTER_CFA_OFFSET (current_function_decl));\n+}\n+\n+/* The generic dwarf2 frame debug info generator does not define a\n+   separate region for the very end of the epilogue, so refrain from\n+   doing so in the IA64-specific code as well.  */\n+\n+#define IA64_CHANGE_CFA_IN_EPILOGUE 0\n+\n /* The function emits unwind directives for the start of an epilogue.  */\n \n static void\n-process_epilogue (void)\n+process_epilogue (FILE *asm_out_file, rtx insn, bool unwind, bool frame)\n {\n   /* If this isn't the last block of the function, then we need to label the\n      current state, and copy it back in at the start of the next block.  */\n \n   if (!last_block)\n     {\n-      fprintf (asm_out_file, \"\\t.label_state %d\\n\",\n-\t       ++cfun->machine->state_num);\n+      if (unwind)\n+\tfprintf (asm_out_file, \"\\t.label_state %d\\n\",\n+\t\t ++cfun->machine->state_num);\n       need_copy_state = true;\n     }\n \n-  fprintf (asm_out_file, \"\\t.restore sp\\n\");\n+  if (unwind)\n+    fprintf (asm_out_file, \"\\t.restore sp\\n\");\n+  if (IA64_CHANGE_CFA_IN_EPILOGUE && frame)\n+    dwarf2out_def_cfa (ia64_emit_deleted_label_after_insn (insn),\n+\t\t       STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n }\n \n /* This function processes a SET pattern looking for specific patterns\n    which result in emitting an assembly directive required for unwinding.  */\n \n static int\n-process_set (FILE *asm_out_file, rtx pat)\n+process_set (FILE *asm_out_file, rtx pat, rtx insn, bool unwind, bool frame)\n {\n   rtx src = SET_SRC (pat);\n   rtx dest = SET_DEST (pat);\n@@ -8009,8 +8065,11 @@ process_set (FILE *asm_out_file, rtx pat)\n       /* If this is the final destination for ar.pfs, then this must\n \t be the alloc in the prologue.  */\n       if (dest_regno == current_frame_info.reg_save_ar_pfs)\n-\tfprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n-\t\t ia64_dbx_register_number (dest_regno));\n+\t{\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save ar.pfs, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n+\t}\n       else\n \t{\n \t  /* This must be an alloc before a sibcall.  We must drop the\n@@ -8021,8 +8080,9 @@ process_set (FILE *asm_out_file, rtx pat)\n \t     sp\" now.  */\n \t  if (current_frame_info.total_size == 0 && !frame_pointer_needed)\n \t    /* if haven't done process_epilogue() yet, do it now */\n-\t    process_epilogue ();\n-\t  fprintf (asm_out_file, \"\\t.prologue\\n\");\n+\t    process_epilogue (asm_out_file, insn, unwind, frame);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.prologue\\n\");\n \t}\n       return 1;\n     }\n@@ -8038,16 +8098,22 @@ process_set (FILE *asm_out_file, rtx pat)\n \t  gcc_assert (op0 == dest && GET_CODE (op1) == CONST_INT);\n \t  \n \t  if (INTVAL (op1) < 0)\n-\t    fprintf (asm_out_file, \"\\t.fframe \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n-\t\t     -INTVAL (op1));\n+\t    {\n+\t      gcc_assert (!frame_pointer_needed);\n+\t      if (unwind)\n+\t\tfprintf (asm_out_file, \"\\t.fframe \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n+\t\t\t -INTVAL (op1));\n+\t      if (frame)\n+\t\tia64_dwarf2out_def_steady_cfa (insn);\n+\t    }\n \t  else\n-\t    process_epilogue ();\n+\t    process_epilogue (asm_out_file, insn, unwind, frame);\n \t}\n       else\n \t{\n \t  gcc_assert (GET_CODE (src) == REG\n \t\t      && REGNO (src) == HARD_FRAME_POINTER_REGNUM);\n-\t  process_epilogue ();\n+\t  process_epilogue (asm_out_file, insn, unwind, frame);\n \t}\n \n       return 1;\n@@ -8064,33 +8130,40 @@ process_set (FILE *asm_out_file, rtx pat)\n \tcase BR_REG (0):\n \t  /* Saving return address pointer.  */\n \t  gcc_assert (dest_regno == current_frame_info.reg_save_b0);\n-\t  fprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n-\t\t   ia64_dbx_register_number (dest_regno));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save rp, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase PR_REG (0):\n \t  gcc_assert (dest_regno == current_frame_info.reg_save_pr);\n-\t  fprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n-\t\t   ia64_dbx_register_number (dest_regno));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save pr, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase AR_UNAT_REGNUM:\n \t  gcc_assert (dest_regno == current_frame_info.reg_save_ar_unat);\n-\t  fprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n-\t\t   ia64_dbx_register_number (dest_regno));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save ar.unat, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase AR_LC_REGNUM:\n \t  gcc_assert (dest_regno == current_frame_info.reg_save_ar_lc);\n-\t  fprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n-\t\t   ia64_dbx_register_number (dest_regno));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save ar.lc, r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n \t  return 1;\n \n \tcase STACK_POINTER_REGNUM:\n \t  gcc_assert (dest_regno == HARD_FRAME_POINTER_REGNUM\n \t\t      && frame_pointer_needed);\n-\t  fprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n-\t\t   ia64_dbx_register_number (dest_regno));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.vframe r%d\\n\",\n+\t\t     ia64_dbx_register_number (dest_regno));\n+\t  if (frame)\n+\t    ia64_dwarf2out_def_steady_cfa (insn);\n \t  return 1;\n \n \tdefault:\n@@ -8135,60 +8208,69 @@ process_set (FILE *asm_out_file, rtx pat)\n \t{\n \tcase BR_REG (0):\n \t  gcc_assert (!current_frame_info.reg_save_b0);\n-\t  fprintf (asm_out_file, \"\\t%s rp, %ld\\n\", saveop, off);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t%s rp, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase PR_REG (0):\n \t  gcc_assert (!current_frame_info.reg_save_pr);\n-\t  fprintf (asm_out_file, \"\\t%s pr, %ld\\n\", saveop, off);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t%s pr, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_LC_REGNUM:\n \t  gcc_assert (!current_frame_info.reg_save_ar_lc);\n-\t  fprintf (asm_out_file, \"\\t%s ar.lc, %ld\\n\", saveop, off);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t%s ar.lc, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_PFS_REGNUM:\n \t  gcc_assert (!current_frame_info.reg_save_ar_pfs);\n-\t  fprintf (asm_out_file, \"\\t%s ar.pfs, %ld\\n\", saveop, off);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t%s ar.pfs, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase AR_UNAT_REGNUM:\n \t  gcc_assert (!current_frame_info.reg_save_ar_unat);\n-\t  fprintf (asm_out_file, \"\\t%s ar.unat, %ld\\n\", saveop, off);\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t%s ar.unat, %ld\\n\", saveop, off);\n \t  return 1;\n \n \tcase GR_REG (4):\n \tcase GR_REG (5):\n \tcase GR_REG (6):\n \tcase GR_REG (7):\n-\t  fprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n-\t\t   1 << (src_regno - GR_REG (4)));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save.g 0x%x\\n\",\n+\t\t     1 << (src_regno - GR_REG (4)));\n \t  return 1;\n \n \tcase BR_REG (1):\n \tcase BR_REG (2):\n \tcase BR_REG (3):\n \tcase BR_REG (4):\n \tcase BR_REG (5):\n-\t  fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n-\t\t   1 << (src_regno - BR_REG (1)));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save.b 0x%x\\n\",\n+\t\t     1 << (src_regno - BR_REG (1)));\n \t  return 1;\n \n \tcase FR_REG (2):\n \tcase FR_REG (3):\n \tcase FR_REG (4):\n \tcase FR_REG (5):\n-\t  fprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n-\t\t   1 << (src_regno - FR_REG (2)));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save.f 0x%x\\n\",\n+\t\t     1 << (src_regno - FR_REG (2)));\n \t  return 1;\n \n \tcase FR_REG (16): case FR_REG (17): case FR_REG (18): case FR_REG (19):\n \tcase FR_REG (20): case FR_REG (21): case FR_REG (22): case FR_REG (23):\n \tcase FR_REG (24): case FR_REG (25): case FR_REG (26): case FR_REG (27):\n \tcase FR_REG (28): case FR_REG (29): case FR_REG (30): case FR_REG (31):\n-\t  fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n-\t\t   1 << (src_regno - FR_REG (12)));\n+\t  if (unwind)\n+\t    fprintf (asm_out_file, \"\\t.save.gf 0x0, 0x%x\\n\",\n+\t\t     1 << (src_regno - FR_REG (12)));\n \t  return 1;\n \n \tdefault:\n@@ -8205,8 +8287,11 @@ process_set (FILE *asm_out_file, rtx pat)\n void\n process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n {\n-  if (flag_unwind_tables\n-      || (flag_exceptions && !USING_SJLJ_EXCEPTIONS))\n+  bool unwind = (flag_unwind_tables\n+\t\t || (flag_exceptions && !USING_SJLJ_EXCEPTIONS));\n+  bool frame = dwarf2out_do_frame ();\n+\n+  if (unwind || frame)\n     {\n       rtx pat;\n \n@@ -8218,9 +8303,14 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n \t  /* Restore unwind state from immediately before the epilogue.  */\n \t  if (need_copy_state)\n \t    {\n-\t      fprintf (asm_out_file, \"\\t.body\\n\");\n-\t      fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n-\t\t       cfun->machine->state_num);\n+\t      if (unwind)\n+\t\t{\n+\t\t  fprintf (asm_out_file, \"\\t.body\\n\");\n+\t\t  fprintf (asm_out_file, \"\\t.copy_state %d\\n\",\n+\t\t\t   cfun->machine->state_num);\n+\t\t}\n+\t      if (IA64_CHANGE_CFA_IN_EPILOGUE && frame)\n+\t\tia64_dwarf2out_def_steady_cfa (insn);\n \t      need_copy_state = false;\n \t    }\n \t}\n@@ -8237,7 +8327,7 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n       switch (GET_CODE (pat))\n         {\n \tcase SET:\n-\t  process_set (asm_out_file, pat);\n+\t  process_set (asm_out_file, pat, insn, unwind, frame);\n \t  break;\n \n \tcase PARALLEL:\n@@ -8248,7 +8338,7 @@ process_for_unwind_directive (FILE *asm_out_file, rtx insn)\n \t      {\n \t\trtx x = XVECEXP (pat, 0, par_index);\n \t\tif (GET_CODE (x) == SET)\n-\t\t  process_set (asm_out_file, x);\n+\t\t  process_set (asm_out_file, x, insn, unwind, frame);\n \t      }\n \t    break;\n \t  }"}, {"sha": "302323653a13905ea22c559dde27547e7fa81493", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -981,6 +981,12 @@ enum reg_class\n    On some machines it may depend on the data type of the function.  */\n #define FIRST_PARM_OFFSET(FUNDECL) 0\n \n+/* The CFA is defined as the SP at the call site, so we have to take\n+   into account that the first argument pointer is\n+   STACK_POINTER_OFFSET bytes off the stack pointer.  */\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) \\\n+  (FIRST_PARM_OFFSET (FNDECL) - STACK_POINTER_OFFSET)\n+\n /* A C expression whose value is RTL representing the value of the return\n    address for the frame COUNT steps up from the current frame, after the\n    prologue.  */\n@@ -1867,6 +1873,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define DWARF2_DEBUGGING_INFO 1\n \n+/* We do not want call-frame info to be output, since debuggers are\n+   supposed to use the target unwind info.  Leave this undefined it\n+   TARGET_UNWIND_INFO might ever be false.  */\n+\n+#define DWARF2_FRAME_INFO 0\n+\n #define DWARF2_ASM_LINE_DEBUG_INFO (TARGET_DWARF2_ASM)\n \n /* Use tags for debug info labels, so that they don't break instruction"}, {"sha": "e3713f91f23b7bd90e98ad427782f43b739475a2", "filename": "gcc/config/ia64/t-ia64", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Ft-ia64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Ft-ia64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Ft-ia64?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -50,3 +50,5 @@ ia64-c.o: $(srcdir)/config/ia64/ia64-c.c $(CONFIG_H) $(SYSTEM_H) \\\n \n # genattrtab generates very long string literals.\n insn-attrtab.o-warn = -Wno-error\n+\n+ia64.o: debug.h"}, {"sha": "bed14f0ad61fd4fad0f183d46e731093b2f28317", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -2067,7 +2067,7 @@ uw_advance_context (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n }\n \n /* Fill in CONTEXT for top-of-stack.  The only valid registers at this\n-   level will be the return address and the CFA.  Note that CFA = SP+16.  */\n+   level will be the return address and the CFA.  */\n    \n #define uw_init_context(CONTEXT)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -2083,7 +2083,7 @@ uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n {\n   void *rp = __builtin_extract_return_addr (__builtin_return_address (0));\n   /* Set psp to the caller's stack pointer.  */\n-  void *psp = __builtin_dwarf_cfa () - 16;\n+  void *psp = __builtin_dwarf_cfa ();\n   _Unwind_FrameState fs;\n   unsigned long rnat, tmp1, tmp2;\n "}, {"sha": "78afb5afae16a7ead2351cd535a0d64ea0bbddd7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -90,20 +90,31 @@ static void dwarf2out_source_line (unsigned int, const char *);\n    DW_CFA_... = DWARF2 CFA call frame instruction\n    DW_TAG_... = DWARF2 DIE tag */\n \n+#ifndef DWARF2_FRAME_INFO\n+# ifdef DWARF2_DEBUGGING_INFO\n+#  define DWARF2_FRAME_INFO \\\n+  (write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)\n+# else\n+#  define DWARF2_FRAME_INFO 0\n+# endif\n+#endif\n+\n /* Decide whether we want to emit frame unwind information for the current\n    translation unit.  */\n \n int\n dwarf2out_do_frame (void)\n {\n+  /* We want to emit correct CFA location expressions or lists, so we\n+     have to return true if we're going to output debug info, even if\n+     we're not going to output frame or unwind info.  */\n   return (write_symbols == DWARF2_DEBUG\n \t  || write_symbols == VMS_AND_DWARF2_DEBUG\n-#ifdef DWARF2_FRAME_INFO\n \t  || DWARF2_FRAME_INFO\n-#endif\n #ifdef DWARF2_UNWIND_INFO\n-\t  || flag_unwind_tables\n-\t  || (flag_exceptions && ! USING_SJLJ_EXCEPTIONS)\n+\t  || (DWARF2_UNWIND_INFO\n+\t      && (flag_unwind_tables\n+\t\t  || (flag_exceptions && ! USING_SJLJ_EXCEPTIONS)))\n #endif\n \t  );\n }\n@@ -2586,23 +2597,20 @@ dwarf2out_frame_init (void)\n   /* Generate the CFA instructions common to all FDE's.  Do it now for the\n      sake of lookup_cfa.  */\n \n-#ifdef DWARF2_UNWIND_INFO\n   /* On entry, the Canonical Frame Address is at SP.  */\n   dwarf2out_def_cfa (NULL, STACK_POINTER_REGNUM, INCOMING_FRAME_SP_OFFSET);\n-  initial_return_save (INCOMING_RETURN_ADDR_RTX);\n+\n+#ifdef DWARF2_UNWIND_INFO\n+  if (DWARF2_UNWIND_INFO)\n+    initial_return_save (INCOMING_RETURN_ADDR_RTX);\n #endif\n }\n \n void\n dwarf2out_frame_finish (void)\n {\n   /* Output call frame information.  */\n-  if (write_symbols == DWARF2_DEBUG\n-      || write_symbols == VMS_AND_DWARF2_DEBUG\n-#ifdef DWARF2_FRAME_INFO\n-      || DWARF2_FRAME_INFO\n-#endif\n-      )\n+  if (DWARF2_FRAME_INFO)\n     output_call_frame_info (0);\n \n #ifndef TARGET_UNWIND_INFO\n@@ -10326,7 +10334,6 @@ tree_add_const_value_attribute (dw_die_ref var_die, tree decl)\n     add_const_value_attribute (var_die, rtl);\n }\n \n-#ifdef DWARF2_UNWIND_INFO\n /* Convert the CFI instructions for the current function into a location\n    list.  This is used for DW_AT_frame_base when we targeting a dwarf2\n    consumer that does not support the dwarf3 DW_OP_call_frame_cfa.  */\n@@ -10433,7 +10440,6 @@ compute_frame_pointer_to_cfa_displacement (void)\n \n   frame_pointer_cfa_offset = -offset;\n }\n-#endif\n \n /* Generate a DW_AT_name attribute given some string value to be included as\n    the value of the attribute.  */\n@@ -11668,7 +11674,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n       add_AT_fde_ref (subr_die, DW_AT_MIPS_fde, current_funcdef_fde);\n #endif\n \n-#ifdef DWARF2_UNWIND_INFO\n       /* We define the \"frame base\" as the function's CFA.  This is more\n \t convenient for several reasons: (1) It's stable across the prologue\n \t and epilogue, which makes it better than just a frame pointer,\n@@ -11695,17 +11700,6 @@ gen_subprogram_die (tree decl, dw_die_ref context_die)\n \t debugger about.  We'll need to adjust all frame_base references\n \t by this displacement.  */\n       compute_frame_pointer_to_cfa_displacement ();\n-#else\n-      /* For targets which support DWARF2, but not DWARF2 call-frame info,\n-\t we just use the stack pointer or frame pointer.  */\n-      /* ??? Should investigate getting better info via callbacks, or else\n-\t by interpreting the IA-64 unwind info.  */\n-      {\n-\trtx fp_reg\n-\t  = frame_pointer_needed ? hard_frame_pointer_rtx : stack_pointer_rtx;\n-\tadd_AT_loc (subr_die, DW_AT_frame_base, reg_loc_descriptor (fp_reg));\n-      }\n-#endif\n \n       if (cfun->static_chain_decl)\n \tadd_AT_location_description (subr_die, DW_AT_static_link,"}, {"sha": "6b49f17206b67ab51906b955e1bd668b3f062b2b", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/658f32fda265f363b18b912ad3560eebeeb28b64/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=658f32fda265f363b18b912ad3560eebeeb28b64", "patch": "@@ -1028,7 +1028,7 @@ compile_file (void)\n   /* Do dbx symbols.  */\n   timevar_push (TV_SYMOUT);\n \n-#ifdef DWARF2_UNWIND_INFO\n+#if defined DWARF2_DEBUGGING_INFO || defined DWARF2_UNWIND_INFO\n   if (dwarf2out_do_frame ())\n     dwarf2out_frame_finish ();\n #endif\n@@ -1868,7 +1868,7 @@ lang_dependent_init (const char *name)\n      predefined types.  */\n   timevar_push (TV_SYMOUT);\n \n-#ifdef DWARF2_UNWIND_INFO\n+#if defined DWARF2_DEBUGGING_INFO || defined DWARF2_UNWIND_INFO\n   if (dwarf2out_do_frame ())\n     dwarf2out_frame_init ();\n #endif"}]}