{"sha": "16e4b777c8391192e3cd53ba549ccc023b07409a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlNGI3NzdjODM5MTE5MmUzY2Q1M2JhNTQ5Y2NjMDIzYjA3NDA5YQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-19T09:33:40Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-19T09:33:40Z"}, "message": "IndexColorModel.java: New version from classpath.\n\n2003-06-19  Michael Koch  <konqueror@gmx.de>\n\n\t* java/awt/image/IndexColorModel.java:\n\tNew version from classpath.\n\nFrom-SVN: r68185", "tree": {"sha": "163729db2d8c841d5f6b5921e761de3dccea8302", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/163729db2d8c841d5f6b5921e761de3dccea8302"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16e4b777c8391192e3cd53ba549ccc023b07409a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e4b777c8391192e3cd53ba549ccc023b07409a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16e4b777c8391192e3cd53ba549ccc023b07409a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16e4b777c8391192e3cd53ba549ccc023b07409a/comments", "author": null, "committer": null, "parents": [{"sha": "85009435975dee67ed981ecb0955e7d6499dbe6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85009435975dee67ed981ecb0955e7d6499dbe6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85009435975dee67ed981ecb0955e7d6499dbe6a"}], "stats": {"total": 93, "additions": 58, "deletions": 35}, "files": [{"sha": "eccedbcc3d7dd1c4371fecf8e373e0c9095e918d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4b777c8391192e3cd53ba549ccc023b07409a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4b777c8391192e3cd53ba549ccc023b07409a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=16e4b777c8391192e3cd53ba549ccc023b07409a", "patch": "@@ -1,3 +1,8 @@\n+2003-06-19  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/awt/image/IndexColorModel.java:\n+\tNew version from classpath.\n+\n 2003-06-18  Tom Tromey  <tromey@redhat.com>\n \n \t* java/net/Inet6Address.java (isAnyLocalAddress): Don't use \"==\""}, {"sha": "066c8682accabad28956b000e6a22d890682cbab", "filename": "libjava/java/awt/image/IndexColorModel.java", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16e4b777c8391192e3cd53ba549ccc023b07409a/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16e4b777c8391192e3cd53ba549ccc023b07409a/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fimage%2FIndexColorModel.java?ref=16e4b777c8391192e3cd53ba549ccc023b07409a", "patch": "@@ -39,15 +39,13 @@\n package java.awt.image;\n \n /**\n- *\n  * @author C. Brian Jones (cbj@gnu.org) \n  */\n public class IndexColorModel extends ColorModel\n {\n     private int map_size;\n     private boolean opaque;\n     private int trans = -1;\n-\n     private int[] rgb;\n \n     /**\n@@ -63,7 +61,8 @@ public class IndexColorModel extends ColorModel\n      * @param blues the blue component of all colors\n      */\n     public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n-\t\t\t   byte[] blues) {\n+                         byte[] blues)\n+  {\n \tthis(bits, size, reds, greens, blues, (byte[])null);\n     }\n \n@@ -81,7 +80,8 @@ public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n      * @param trans the index of the transparent color\n      */\n     public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n-\t\t\t   byte[] blues, int trans) {\n+                         byte[] blues, int trans)\n+  {\n \tthis(bits, size, reds, greens, blues, (byte[])null);\n \tthis.trans = trans;\n     }\n@@ -100,26 +100,31 @@ public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n      * @param alphas the alpha component of all colors\n      */\n     public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n-\t\t\t   byte[] blues, byte[] alphas) {\n+                         byte[] blues, byte[] alphas)\n+  {\n \tsuper(bits);\n \tmap_size = size;\n \topaque = (alphas == null);\n \n \trgb = new int[size];\n-\tif (alphas == null) {\n-\t    for (int i = 0; i < size; i++) {\n-\t\trgb[i] = 0xff000000 | \n-\t\t         ((reds[i] & 0xff) << 16) |\n-\t\t         ((greens[i] & 0xff) << 8) |\n-\t\t          (blues[i] & 0xff);\n+    if (alphas == null)\n+      {\n+        for (int i = 0; i < size; i++)\n+          {\n+            rgb[i] = (0xff000000\n+                      | ((reds[i] & 0xff) << 16)\n+                      | ((greens[i] & 0xff) << 8)\n+                      | (blues[i] & 0xff));\n \t    }\n \t}\n-\telse {\n-\t    for (int i = 0; i < size; i++) {\n-\t\trgb[i] = ((alphas[i] & 0xff) << 24 | \n-\t\t         ((reds[i] & 0xff) << 16) |\n-\t\t         ((greens[i] & 0xff) << 8) |\n-\t\t          (blues[i] & 0xff));\n+    else\n+      {\n+        for (int i = 0; i < size; i++)\n+          {\n+            rgb[i] = ((alphas[i] & 0xff) << 24\n+                      | ((reds[i] & 0xff) << 16)\n+                      | ((greens[i] & 0xff) << 8)\n+                      | (blues[i] & 0xff));\n \t    }\n \t}\n     }\n@@ -137,7 +142,8 @@ public IndexColorModel(int bits, int size, byte[] reds, byte[] greens,\n      * @param hasAlpha <code>cmap</code> has alpha values\n      */\n     public IndexColorModel(int bits, int size, byte[] cmap, int start, \n-\t\t\t   boolean hasAlpha) {\n+                          boolean hasAlpha)\n+  {\n \tthis(bits, size, cmap, start, hasAlpha, -1);\n     }\n \n@@ -155,49 +161,56 @@ public IndexColorModel(int bits, int size, byte[] cmap, int start,\n      * @param trans the index of the transparent color\n      */\n     public IndexColorModel(int bits, int size, byte[] cmap, int start, \n-\t\t\t   boolean hasAlpha, int trans) {\n+                          boolean hasAlpha, int trans)\n+  {\n \tsuper(bits);\n \tmap_size = size;\n         opaque = !hasAlpha;\n \tthis.trans = trans;\n     }\n \n-    public final int getMapSize() {\n+  public final int getMapSize ()\n+  {\n \treturn map_size;\n     }\n \n     /**\n      * Get the index of the transparent color in this color model\n      */\n-    public final int getTransparentPixel() {\n+  public final int getTransparentPixel ()\n+  {\n \treturn trans;\n     }\n \n     /**\n      * <br>\n      */\n-    public final void getReds(byte[] r) {\n+  public final void getReds (byte[] r)\n+  {\n \tgetComponents( r, 2 );\n     }\n \n     /**\n      * <br>\n      */\n-    public final void getGreens(byte[] g) {\n+  public final void getGreens (byte[] g)\n+  {\n \tgetComponents( g, 1 );\n     }\n \n     /**\n      * <br>\n      */\n-    public final void getBlues(byte[] b) {\n+  public final void getBlues (byte[] b)\n+  {\n \tgetComponents( b, 0 );\n     }\n \n     /**\n      * <br>\n      */\n-    public final void getAlphas(byte[] a) {\n+  public final void getAlphas (byte[] a)\n+  {\n \tgetComponents( a, 3 );\n     }\n \n@@ -210,54 +223,59 @@ private void getComponents( byte[] c, int ci )\n \n     /**\n      * Get the red component of the given pixel.\n-     * <br>\n      */\n-    public final int getRed(int pixel) {\n+  public final int getRed (int pixel)\n+  {\n \tif( pixel < map_size ) \n \t    return  (int)(( generateMask( 2 )  & rgb[pixel]) >> (2 * pixel_bits ) );\n+    \n \treturn 0;\n     }\n \n     /**\n      * Get the green component of the given pixel.\n-     * <br>\n      */\n-    public final int getGreen(int pixel) {\n+  public final int getGreen (int pixel)\n+  {\n \tif( pixel < map_size ) \n \t    return (int)(( generateMask( 1 )  & rgb[pixel]) >> (1 * pixel_bits ) );\n+    \n \treturn 0;\n     }\n \n     /**\n      * Get the blue component of the given pixel.\n-     * <br>\n      */\n-    public final int getBlue(int pixel) {\n+  public final int getBlue (int pixel)\n+  {\n \tif( pixel < map_size ) \n \t    return  (int)( generateMask( 0 )  & rgb[pixel]);\n+    \n \treturn 0;\n     }\n \n     /**\n      * Get the alpha component of the given pixel.\n-     * <br>\n      */\n-    public final int getAlpha(int pixel) {\n+  public final int getAlpha (int pixel)\n+  {\n \tif( pixel < map_size ) \n \t    return  (int)(( generateMask( 3 )  & rgb[pixel]) >> (3 * pixel_bits ) );\n+    \n \treturn 0;\n     }\n \n     /**\n      * Get the RGB color value of the given pixel using the default\n      * RGB color model. \n-     * <br>\n      *\n      * @param pixel a pixel value\n      */\n-    public final int getRGB(int pixel) {\n+  public final int getRGB (int pixel)\n+  {\n \tif( pixel < map_size ) \n \t    return rgb[pixel];\n+    \n \treturn 0;\n     }\n     "}]}