{"sha": "2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4YWI3MGMyZWVlN2E5MTJhYzc0YjU3YzQ3ZTdiYzMyZjlmMTE5OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-04-23T08:43:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-04-23T08:43:10Z"}, "message": "tree-vect-slp.c (vect_find_first_load_in_slp_instance): Remove.\n\n2015-04-23  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (vect_find_first_load_in_slp_instance): Remove.\n\t(vect_find_last_store_in_slp_instance): Rename to ...\n\t(vect_find_last_scalar_stmt_in_slp): ... this and generalize.\n\t(vect_analyze_slp_cost_1): Use vector_load for constant defs\n\tand vec_construct for external defs when estimating prologue cost.\n\t(vect_analyze_slp_instance): Do not init SLP_INSTANCE_FIRST_LOAD_STMT.\n\tCompute costs here only when vectorizing loops.\n\t(vect_slp_analyze_bb_1): Compute SLP cost here, after vector types\n\thave been determined.\n\t(vect_schedule_slp_instance): Simplify vectorized code placement\n\tand prepare for in-BB external defs.\n\t* tree-vectorizer.h (struct _slp_instance): Remove first_load member.\n\t(SLP_INSTANCE_FIRST_LOAD_STMT): Remove.\n\t* tree-vect-stmts.c (vect_model_store_cost): Remove PURE_SLP_STMT\n\tguard.\n\t(vect_model_load_cost): Likewise.\n\t(vectorizable_store): Instead add it here.\n\t(vectorizable_load): Likewise.\n\t(vect_is_simple_use): Dump def type textually.\n\nFrom-SVN: r222354", "tree": {"sha": "187d843f1d350584c321a0b83e66ab240069b775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/187d843f1d350584c321a0b83e66ab240069b775"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b0dd8c90ff1a4a50e21b4b2918c7484f36106947", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0dd8c90ff1a4a50e21b4b2918c7484f36106947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0dd8c90ff1a4a50e21b4b2918c7484f36106947"}], "stats": {"total": 189, "additions": 108, "deletions": 81}, "files": [{"sha": "077a49eae9a05e3a9c74bc33df0e92942411403b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "patch": "@@ -1,3 +1,25 @@\n+2015-04-23  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (vect_find_first_load_in_slp_instance): Remove.\n+\t(vect_find_last_store_in_slp_instance): Rename to ...\n+\t(vect_find_last_scalar_stmt_in_slp): ... this and generalize.\n+\t(vect_analyze_slp_cost_1): Use vector_load for constant defs\n+\tand vec_construct for external defs when estimating prologue cost.\n+\t(vect_analyze_slp_instance): Do not init SLP_INSTANCE_FIRST_LOAD_STMT.\n+\tCompute costs here only when vectorizing loops.\n+\t(vect_slp_analyze_bb_1): Compute SLP cost here, after vector types\n+\thave been determined.\n+\t(vect_schedule_slp_instance): Simplify vectorized code placement\n+\tand prepare for in-BB external defs.\n+\t* tree-vectorizer.h (struct _slp_instance): Remove first_load member.\n+\t(SLP_INSTANCE_FIRST_LOAD_STMT): Remove.\n+\t* tree-vect-stmts.c (vect_model_store_cost): Remove PURE_SLP_STMT\n+\tguard.\n+\t(vect_model_load_cost): Likewise.\n+\t(vectorizable_store): Instead add it here.\n+\t(vectorizable_load): Likewise.\n+\t(vect_is_simple_use): Dump def type textually.\n+\n 2015-04-23  Richard Biener  <rguenther@suse.de>\n \n \t* cfgexpand.c (expand_gimple_stmt_1): Use ops.code."}, {"sha": "d82df3e5daa44c04135fa49a58661ada66c06ae0", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 43, "deletions": 62, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "patch": "@@ -1379,42 +1379,23 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n }\n \n \n-/* Find the first load in the loop that belongs to INSTANCE.\n-   When loads are in several SLP nodes, there can be a case in which the first\n-   load does not appear in the first SLP node to be transformed, causing\n-   incorrect order of statements.  Since we generate all the loads together,\n-   they must be inserted before the first load of the SLP instance and not\n-   before the first load of the first node of the instance.  */\n-\n-static gimple\n-vect_find_first_load_in_slp_instance (slp_instance instance)\n-{\n-  int i, j;\n-  slp_tree load_node;\n-  gimple first_load = NULL, load;\n-\n-  FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), i, load_node)\n-    FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load)\n-      first_load = get_earlier_stmt (load, first_load);\n-\n-  return first_load;\n-}\n-\n-\n /* Find the last store in SLP INSTANCE.  */\n \n static gimple\n-vect_find_last_store_in_slp_instance (slp_instance instance)\n+vect_find_last_scalar_stmt_in_slp (slp_tree node)\n {\n-  int i;\n-  slp_tree node;\n-  gimple last_store = NULL, store;\n+  gimple last = NULL, stmt;\n \n-  node = SLP_INSTANCE_TREE (instance);\n-  for (i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &store); i++)\n-    last_store = get_later_stmt (store, last_store);\n+  for (int i = 0; SLP_TREE_SCALAR_STMTS (node).iterate (i, &stmt); i++)\n+    {\n+      stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+      if (is_pattern_stmt_p (stmt_vinfo))\n+\tlast = get_later_stmt (STMT_VINFO_RELATED_STMT (stmt_vinfo), last);\n+      else\n+\tlast = get_later_stmt (stmt, last);\n+    }\n \n-  return last_store;\n+  return last;\n }\n \n /* Compute the cost for the SLP node NODE in the SLP instance INSTANCE.  */\n@@ -1487,10 +1468,19 @@ vect_analyze_slp_cost_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (!op || op == lhs)\n \tcontinue;\n       if (vect_is_simple_use (op, NULL, loop_vinfo, bb_vinfo,\n-\t\t\t      &def_stmt, &def, &dt)\n-\t  && (dt == vect_constant_def || dt == vect_external_def))\n-\trecord_stmt_cost (prologue_cost_vec, 1, vector_stmt,\n-\t\t\t  stmt_info, 0, vect_prologue);\n+\t\t\t      &def_stmt, &def, &dt))\n+\t{\n+\t  /* Without looking at the actual initializer a vector of\n+\t     constants can be implemented as load from the constant pool.\n+\t     ???  We need to pass down stmt_info for a vector type\n+\t     even if it points to the wrong stmt.  */\n+\t  if (dt == vect_constant_def)\n+\t    record_stmt_cost (prologue_cost_vec, 1, vector_load,\n+\t\t\t      stmt_info, 0, vect_prologue);\n+\t  else if (dt == vect_external_def)\n+\t    record_stmt_cost (prologue_cost_vec, 1, vec_construct,\n+\t\t\t      stmt_info, 0, vect_prologue);\n+\t}\n     }\n }\n \n@@ -1668,7 +1658,6 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       SLP_INSTANCE_UNROLLING_FACTOR (new_instance) = unrolling_factor;\n       SLP_INSTANCE_BODY_COST_VEC (new_instance) = vNULL;\n       SLP_INSTANCE_LOADS (new_instance) = loads;\n-      SLP_INSTANCE_FIRST_LOAD_STMT (new_instance) = NULL;\n \n       /* Compute the load permutation.  */\n       slp_tree load_node;\n@@ -1715,17 +1704,17 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               vect_free_slp_instance (new_instance);\n               return false;\n             }\n-\n-          SLP_INSTANCE_FIRST_LOAD_STMT (new_instance)\n-\t    = vect_find_first_load_in_slp_instance (new_instance);\n         }\n \n-      /* Compute the costs of this SLP instance.  */\n-      vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n-\t\t\t     new_instance, TYPE_VECTOR_SUBPARTS (vectype));\n \n       if (loop_vinfo)\n-        LOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n+\t{\n+\t  /* Compute the costs of this SLP instance.  Delay this for BB\n+\t     vectorization as we don't have vector types computed yet.  */\n+\t  vect_analyze_slp_cost (loop_vinfo, bb_vinfo,\n+\t\t\t\t new_instance, TYPE_VECTOR_SUBPARTS (vectype));\n+\t  LOOP_VINFO_SLP_INSTANCES (loop_vinfo).safe_push (new_instance);\n+\t}\n       else\n         BB_VINFO_SLP_INSTANCES (bb_vinfo).safe_push (new_instance);\n \n@@ -2368,6 +2357,15 @@ vect_slp_analyze_bb_1 (basic_block bb)\n       return NULL;\n     }\n \n+  /* Compute the costs of the SLP instances.  */\n+  FOR_EACH_VEC_ELT (slp_instances, i, instance)\n+    {\n+      gimple stmt = SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0];\n+      tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n+      vect_analyze_slp_cost (NULL, bb_vinfo,\n+\t\t\t     instance, TYPE_VECTOR_SUBPARTS (vectype));\n+    }\n+\n   /* Cost model: check if the vectorization is worthwhile.  */\n   if (!unlimited_cost_model (NULL)\n       && !vect_bb_vectorization_profitable_p (bb_vinfo))\n@@ -3236,26 +3234,9 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  /* Loads should be inserted before the first load.  */\n-  if (SLP_INSTANCE_FIRST_LOAD_STMT (instance)\n-      && STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && !REFERENCE_CLASS_P (gimple_get_lhs (stmt))\n-      && SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-    si = gsi_for_stmt (SLP_INSTANCE_FIRST_LOAD_STMT (instance));\n-  else if (is_pattern_stmt_p (stmt_info))\n-    si = gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info));\n-  else\n-    si = gsi_for_stmt (stmt);\n-\n-  /* Stores should be inserted just before the last store.  */\n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && REFERENCE_CLASS_P (gimple_get_lhs (stmt)))\n-    { \n-      gimple last_store = vect_find_last_store_in_slp_instance (instance);\n-      if (is_pattern_stmt_p (vinfo_for_stmt (last_store)))\n-       last_store = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (last_store));\n-      si = gsi_for_stmt (last_store);\n-    }\n+  /* Vectorized stmts go before the last scalar stmt which is where\n+     all uses are ready.  */\n+  si = gsi_for_stmt (vect_find_last_scalar_stmt_in_slp (node));\n \n   /* Mark the first element of the reduction chain as reduction to properly\n      transform the node.  In the analysis phase only the last element of the"}, {"sha": "4496293fb4616a27f02953e97ec5ad08e0460f5a", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "patch": "@@ -968,10 +968,6 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   struct data_reference *first_dr;\n   gimple first_stmt;\n \n-  /* The SLP costs were already calculated during SLP tree build.  */\n-  if (PURE_SLP_STMT (stmt_info))\n-    return;\n-\n   if (dt == vect_constant_def || dt == vect_external_def)\n     prologue_cost += record_stmt_cost (prologue_cost_vec, 1, scalar_to_vec,\n \t\t\t\t       stmt_info, 0, vect_prologue);\n@@ -1098,10 +1094,6 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n   unsigned int inside_cost = 0, prologue_cost = 0;\n \n-  /* The SLP costs were already calculated during SLP tree build.  */\n-  if (PURE_SLP_STMT (stmt_info))\n-    return;\n-\n   /* Grouped accesses?  */\n   first_stmt = GROUP_FIRST_ELEMENT (stmt_info);\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info) && first_stmt && !slp_node)\n@@ -5181,8 +5173,10 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n-      vect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt,\n-\t\t\t     NULL, NULL, NULL);\n+      /* The SLP costs are calculated during SLP analysis.  */\n+      if (!PURE_SLP_STMT (stmt_info))\n+\tvect_model_store_cost (stmt_info, ncopies, store_lanes_p, dt,\n+\t\t\t       NULL, NULL, NULL);\n       return true;\n     }\n \n@@ -5901,7 +5895,10 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n-      vect_model_load_cost (stmt_info, ncopies, load_lanes_p, NULL, NULL, NULL);\n+      /* The SLP costs are calculated during SLP analysis.  */\n+      if (!PURE_SLP_STMT (stmt_info))\n+\tvect_model_load_cost (stmt_info, ncopies, load_lanes_p,\n+\t\t\t      NULL, NULL, NULL);\n       return true;\n     }\n \n@@ -7758,6 +7755,41 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n       *dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n     }\n \n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"type of def: \");\n+      switch (*dt)\n+\t{\n+\tcase vect_uninitialized_def:\n+\t  dump_printf (MSG_NOTE, \"uninitialized\\n\");\n+\t  break;\n+\tcase vect_constant_def:\n+\t  dump_printf (MSG_NOTE, \"constant\\n\");\n+\t  break;\n+\tcase vect_external_def:\n+\t  dump_printf (MSG_NOTE, \"external\\n\");\n+\t  break;\n+\tcase vect_internal_def:\n+\t  dump_printf (MSG_NOTE, \"internal\\n\");\n+\t  break;\n+\tcase vect_induction_def:\n+\t  dump_printf (MSG_NOTE, \"induction\\n\");\n+\t  break;\n+\tcase vect_reduction_def:\n+\t  dump_printf (MSG_NOTE, \"reduction\\n\");\n+\t  break;\n+\tcase vect_double_reduction_def:\n+\t  dump_printf (MSG_NOTE, \"double reduction\\n\");\n+\t  break;\n+\tcase vect_nested_cycle:\n+\t  dump_printf (MSG_NOTE, \"nested cycle\\n\");\n+\t  break;\n+\tcase vect_unknown_def_type:\n+\t  dump_printf (MSG_NOTE, \"unknown\\n\");\n+\t  break;\n+\t}\n+    }\n+\n   if (*dt == vect_unknown_def_type\n       || (stmt\n \t  && *dt == vect_double_reduction_def\n@@ -7769,9 +7801,6 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n       return false;\n     }\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"type of def: %d.\\n\", *dt);\n-\n   switch (gimple_code (*def_stmt))\n     {\n     case GIMPLE_PHI:"}, {"sha": "0796cc19fcd8190957679ce2204e1cd35519c6b3", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=2e8ab70c2eee7a912ac74b57c47e7bc32f9f1198", "patch": "@@ -131,10 +131,6 @@ typedef struct _slp_instance {\n \n   /* The group of nodes that contain loads of this SLP instance.  */\n   vec<slp_tree> loads;\n-\n-  /* The first scalar load of the instance. The created vector loads will be\n-     inserted before this statement.  */\n-  gimple first_load;\n } *slp_instance;\n \n \n@@ -144,7 +140,6 @@ typedef struct _slp_instance {\n #define SLP_INSTANCE_UNROLLING_FACTOR(S)         (S)->unrolling_factor\n #define SLP_INSTANCE_BODY_COST_VEC(S)            (S)->body_cost_vec\n #define SLP_INSTANCE_LOADS(S)                    (S)->loads\n-#define SLP_INSTANCE_FIRST_LOAD_STMT(S)          (S)->first_load\n \n #define SLP_TREE_CHILDREN(S)                     (S)->children\n #define SLP_TREE_SCALAR_STMTS(S)                 (S)->stmts"}]}