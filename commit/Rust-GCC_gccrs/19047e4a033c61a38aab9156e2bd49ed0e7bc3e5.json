{"sha": "19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkwNDdlNGEwMzNjNjFhMzhhYWI5MTU2ZTJiZDQ5ZWQwZTdiYzNlNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2008-09-21T19:25:48Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2008-09-21T19:25:48Z"}, "message": "sparc-protos.h (gen_compare_operator): Declare.\n\n\t* config/sparc/sparc-protos.h (gen_compare_operator): Declare.\n\t(sparc_emit_float_lib_cmp): Change return type.\n\t* config/sparc/sparc.c (gen_compare_reg): Add comment about TFmode.\n\t(gen_compare_operator): New function.\n\t(sparc_emit_float_lib_cmp): Return the new operator to be used in\n\tthe comparison sequence.  Minor tweaks.\n\t* config/sparc/sparc.md (seq, sne, sgt, slt, sge, sle): Assert\n\tthat the final operator and the result of sparc_emit_float_lib_cmp\n\tmatch for software TFmode; use emit_insn in lieu of emit_jump_insn.\n\t(beq, bne, bgt, blt, bge, ble, bunordered, bordered, bungt, bunlt,\n\tbuneq, bunge, bunle, bltgt): Assert that the final operator and the\n\tresult of sparc_emit_float_lib_cmp match for software TFmode.\n\t(movqicc, movhicc, movsicc, movdicc): Merge into...\n\t(mov<I:mode>cc): ...this.\n\t(movsfcc, movdfcc, movtfcc): Merge into...\n\t(mov<F:mode>cc): ...this.\n\t(movqi_cc_sp64, movhi_cc_sp64, movsi_cc_sp64, movdi_cc_sp64): Merge\n\tinto...\n\t(mov<I:mode>_cc_v9): ...this.\n\t(movdi_cc_sp64_trunc): Delete.\n\t(movqi_cc_reg_sp64, movhi_cc_reg_sp64, movsi_cc_reg_sp64,\n\tmovdi_cc_reg_sp64): Merge into...\n\t(mov<I:mode>_cc_reg_sp64): ...this.\n\t(movsf_cc_sp64): Rename into...\n\t(movsf_cc_v9): ...this.\n\t(movdf_cc_sp64): Rename into...\n\t(movdf_cc_v9): ...this.\n\t(movtf_cc_hq_sp64): Rename into...\n\t(movtf_cc_hq_v9): ...this.\n\t(movtf_cc_sp64): Rename into...\n\t(movtf_cc_v9): ...this.  Adjust for renaming of movdf_cc_sp64.\n\nFrom-SVN: r140530", "tree": {"sha": "496c5871e01bbfff3796265f869be6e4db344cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/496c5871e01bbfff3796265f869be6e4db344cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/comments", "author": null, "committer": null, "parents": [{"sha": "4b7f8314ba66ab03974e94bf80718b157cc1350f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b7f8314ba66ab03974e94bf80718b157cc1350f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b7f8314ba66ab03974e94bf80718b157cc1350f"}], "stats": {"total": 633, "additions": 249, "deletions": 384}, "files": [{"sha": "8a1603e2f13cbc8bef3b5058b6123f15e8474151", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "patch": "@@ -1,3 +1,37 @@\n+2008-09-21  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/sparc/sparc-protos.h (gen_compare_operator): Declare.\n+\t(sparc_emit_float_lib_cmp): Change return type.\n+\t* config/sparc/sparc.c (gen_compare_reg): Add comment about TFmode.\n+\t(gen_compare_operator): New function.\n+\t(sparc_emit_float_lib_cmp): Return the new operator to be used in\n+\tthe comparison sequence.  Minor tweaks.\n+\t* config/sparc/sparc.md (seq, sne, sgt, slt, sge, sle): Assert\n+\tthat the final operator and the result of sparc_emit_float_lib_cmp\n+\tmatch for software TFmode; use emit_insn in lieu of emit_jump_insn.\n+\t(beq, bne, bgt, blt, bge, ble, bunordered, bordered, bungt, bunlt,\n+\tbuneq, bunge, bunle, bltgt): Assert that the final operator and the\n+\tresult of sparc_emit_float_lib_cmp match for software TFmode.\n+\t(movqicc, movhicc, movsicc, movdicc): Merge into...\n+\t(mov<I:mode>cc): ...this.\n+\t(movsfcc, movdfcc, movtfcc): Merge into...\n+\t(mov<F:mode>cc): ...this.\n+\t(movqi_cc_sp64, movhi_cc_sp64, movsi_cc_sp64, movdi_cc_sp64): Merge\n+\tinto...\n+\t(mov<I:mode>_cc_v9): ...this.\n+\t(movdi_cc_sp64_trunc): Delete.\n+\t(movqi_cc_reg_sp64, movhi_cc_reg_sp64, movsi_cc_reg_sp64,\n+\tmovdi_cc_reg_sp64): Merge into...\n+\t(mov<I:mode>_cc_reg_sp64): ...this.\n+\t(movsf_cc_sp64): Rename into...\n+\t(movsf_cc_v9): ...this.\n+\t(movdf_cc_sp64): Rename into...\n+\t(movdf_cc_v9): ...this.\n+\t(movtf_cc_hq_sp64): Rename into...\n+\t(movtf_cc_hq_v9): ...this.\n+\t(movtf_cc_sp64): Rename into...\n+\t(movtf_cc_v9): ...this.  Adjust for renaming of movdf_cc_sp64.\n+\n 2008-09-21  Diego Novillo  <dnovillo@google.com>\n \n \t* doc/gccint.texi: Include generic.texi and gimple.texi."}, {"sha": "a15837fccc0d23a727284abfa9b8c4ae5b19179b", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "patch": "@@ -54,7 +54,8 @@ extern void sparc_output_scratch_registers (FILE *);\n extern enum machine_mode select_cc_mode (enum rtx_code, rtx, rtx);\n /* Define the function that build the compare insn for scc and bcc.  */\n extern rtx gen_compare_reg (enum rtx_code code);\n-extern void sparc_emit_float_lib_cmp (rtx, rtx, enum rtx_code);\n+extern rtx gen_compare_operator (enum rtx_code code);\n+extern enum rtx_code sparc_emit_float_lib_cmp (rtx, rtx, enum rtx_code);\n extern void sparc_emit_floatunsdi (rtx [2], enum machine_mode);\n extern void sparc_emit_fixunsdi (rtx [2], enum machine_mode);\n extern void emit_tfmode_binop (enum rtx_code, rtx *);"}, {"sha": "fd56653206721f40e8141ad06c21d7a8a39b2b6d", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "patch": "@@ -2001,8 +2001,7 @@ select_cc_mode (enum rtx_code op, rtx x, rtx y ATTRIBUTE_UNUSED)\n     }\n }\n \n-/* X and Y are two things to compare using CODE.  Emit the compare insn and\n-   return the rtx for the cc reg in the proper mode.  */\n+/* Emit the compare insn and return the CC reg for a CODE comparison.  */\n \n rtx\n gen_compare_reg (enum rtx_code code)\n@@ -2065,12 +2064,28 @@ gen_compare_reg (enum rtx_code code)\n   else\n     cc_reg = gen_rtx_REG (mode, SPARC_ICC_REG);\n \n-  emit_insn (gen_rtx_SET (VOIDmode, cc_reg,\n-\t\t\t  gen_rtx_COMPARE (mode, x, y)));\n+  /* We shouldn't get there for TFmode if !TARGET_HARD_QUAD.  If we do, this\n+     will only result in an unrecognizable insn so no point in asserting.  */\n+  emit_insn (gen_rtx_SET (VOIDmode, cc_reg, gen_rtx_COMPARE (mode, x, y)));\n \n   return cc_reg;\n }\n \n+/* Same as above but return the whole compare operator.  */\n+\n+rtx\n+gen_compare_operator (enum rtx_code code)\n+{\n+  rtx cc_reg;\n+\n+  if (GET_MODE (sparc_compare_op0) == TFmode && !TARGET_HARD_QUAD)\n+    code\n+      = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, code);\n+\n+  cc_reg = gen_compare_reg (code);\n+  return gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n+}\n+\n /* This function is used for v9 only.\n    CODE is the code for an Scc's comparison.\n    OPERANDS[0] is the target of the Scc insn.\n@@ -6099,41 +6114,45 @@ output_cbranch (rtx op, rtx dest, int label, int reversed, int annul,\n }\n \n /* Emit a library call comparison between floating point X and Y.\n-   COMPARISON is the rtl operator to compare with (EQ, NE, GT, etc.).\n+   COMPARISON is the operator to compare with (EQ, NE, GT, etc).\n+   Return the new operator to be used in the comparison sequence.\n+\n    TARGET_ARCH64 uses _Qp_* functions, which use pointers to TFmode\n    values as arguments instead of the TFmode registers themselves,\n    that's why we cannot call emit_float_lib_cmp.  */\n-void\n+\n+enum rtx_code\n sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n {\n   const char *qpfunc;\n   rtx slot0, slot1, result, tem, tem2;\n   enum machine_mode mode;\n+  enum rtx_code new_comparison;\n \n   switch (comparison)\n     {\n     case EQ:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_feq\" : \"_Q_feq\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_feq\" : \"_Q_feq\");\n       break;\n \n     case NE:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_fne\" : \"_Q_fne\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_fne\" : \"_Q_fne\");\n       break;\n \n     case GT:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_fgt\" : \"_Q_fgt\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_fgt\" : \"_Q_fgt\");\n       break;\n \n     case GE:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_fge\" : \"_Q_fge\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_fge\" : \"_Q_fge\");\n       break;\n \n     case LT:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_flt\" : \"_Q_flt\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_flt\" : \"_Q_flt\");\n       break;\n \n     case LE:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_fle\" : \"_Q_fle\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_fle\" : \"_Q_fle\");\n       break;\n \n     case ORDERED:\n@@ -6144,7 +6163,7 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n     case UNGE:\n     case UNLE:\n     case LTGT:\n-      qpfunc = (TARGET_ARCH64) ? \"_Qp_cmp\" : \"_Q_cmp\";\n+      qpfunc = (TARGET_ARCH64 ? \"_Qp_cmp\" : \"_Q_cmp\");\n       break;\n \n     default:\n@@ -6153,35 +6172,33 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \n   if (TARGET_ARCH64)\n     {\n-      if (GET_CODE (x) != MEM)\n+      if (MEM_P (x))\n+\tslot0 = x;\n+      else\n \t{\n \t  slot0 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n \t  emit_move_insn (slot0, x);\n \t}\n-      else\n-\tslot0 = x;\n \n-      if (GET_CODE (y) != MEM)\n+      if (MEM_P (y))\n+\tslot1 = y;\n+      else\n \t{\n \t  slot1 = assign_stack_temp (TFmode, GET_MODE_SIZE(TFmode), 0);\n \t  emit_move_insn (slot1, y);\n \t}\n-      else\n-\tslot1 = y;\n \n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,\n \t\t\t DImode, 2,\n \t\t\t XEXP (slot0, 0), Pmode,\n \t\t\t XEXP (slot1, 0), Pmode);\n-\n       mode = DImode;\n     }\n   else\n     {\n       emit_library_call (gen_rtx_SYMBOL_REF (Pmode, qpfunc), LCT_NORMAL,\n \t\t\t SImode, 2,\n \t\t\t x, TFmode, y, TFmode);\n-\n       mode = SImode;\n     }\n \n@@ -6195,28 +6212,31 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n   switch (comparison)\n     {\n     default:\n-      emit_cmp_insn (result, const0_rtx, NE, NULL_RTX, mode, 0);\n+      new_comparison = NE;\n+      emit_cmp_insn (result, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n       break;\n     case ORDERED:\n     case UNORDERED:\n-      emit_cmp_insn (result, GEN_INT(3), comparison == UNORDERED ? EQ : NE,\n-\t\t     NULL_RTX, mode, 0);\n+      new_comparison = (comparison == UNORDERED ? EQ : NE);\n+      emit_cmp_insn (result, GEN_INT(3), new_comparison, NULL_RTX, mode, 0);\n       break;\n     case UNGT:\n     case UNGE:\n-      emit_cmp_insn (result, const1_rtx,\n-\t\t     comparison == UNGT ? GT : NE, NULL_RTX, mode, 0);\n+      new_comparison = (comparison == UNGT ? GT : NE);\n+      emit_cmp_insn (result, const1_rtx, new_comparison, NULL_RTX, mode, 0);\n       break;\n     case UNLE:\n-      emit_cmp_insn (result, const2_rtx, NE, NULL_RTX, mode, 0);\n+      new_comparison = NE;\n+      emit_cmp_insn (result, const2_rtx, new_comparison, NULL_RTX, mode, 0);\n       break;\n     case UNLT:\n       tem = gen_reg_rtx (mode);\n       if (TARGET_ARCH32)\n \temit_insn (gen_andsi3 (tem, result, const1_rtx));\n       else\n \temit_insn (gen_anddi3 (tem, result, const1_rtx));\n-      emit_cmp_insn (tem, const0_rtx, NE, NULL_RTX, mode, 0);\n+      new_comparison = NE;\n+      emit_cmp_insn (tem, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n       break;\n     case UNEQ:\n     case LTGT:\n@@ -6230,10 +6250,12 @@ sparc_emit_float_lib_cmp (rtx x, rtx y, enum rtx_code comparison)\n \temit_insn (gen_andsi3 (tem2, tem, const2_rtx));\n       else\n \temit_insn (gen_anddi3 (tem2, tem, const2_rtx));\n-      emit_cmp_insn (tem2, const0_rtx, comparison == UNEQ ? EQ : NE,\n-\t\t     NULL_RTX, mode, 0);\n+      new_comparison = (comparison == UNEQ ? EQ : NE);\n+      emit_cmp_insn (tem2, const0_rtx, new_comparison, NULL_RTX, mode, 0);\n       break;\n     }\n+\n+  return new_comparison;\n }\n \n /* Generate an unsigned DImode to FP conversion.  This is the same code"}, {"sha": "d0b73893945fbfb7a14f3a0aa859dc24bd617ce0", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 161, "deletions": 353, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19047e4a033c61a38aab9156e2bd49ed0e7bc3e5/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=19047e4a033c61a38aab9156e2bd49ed0e7bc3e5", "patch": "@@ -621,8 +621,10 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -673,8 +675,10 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -693,8 +697,10 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -713,8 +719,10 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -733,8 +741,10 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -753,8 +763,10 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n-      emit_jump_insn (gen_sne (operands[0]));\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n+      gcc_assert (code == NE);\n+      emit_insn (gen_sne (operands[0]));\n       DONE;\n     }\n   else if (TARGET_V9)\n@@ -1270,7 +1282,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, EQ);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1293,7 +1307,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, NE);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1316,7 +1332,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GT);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1349,7 +1367,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LT);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1382,7 +1402,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, GE);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1415,7 +1437,9 @@\n     }\n   else if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LE);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1441,8 +1465,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1,\n-\t\t\t\tUNORDERED);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNORDERED);\n+      gcc_assert (code == EQ);\n       emit_jump_insn (gen_beq (operands[0]));\n       DONE;\n     }\n@@ -1458,7 +1483,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, ORDERED);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, ORDERED);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1474,7 +1501,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGT);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGT);\n+      gcc_assert (code == GT);\n       emit_jump_insn (gen_bgt (operands[0]));\n       DONE;\n     }\n@@ -1490,7 +1519,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLT);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLT);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1506,7 +1537,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNEQ);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNEQ);\n+      gcc_assert (code == EQ);\n       emit_jump_insn (gen_beq (operands[0]));\n       DONE;\n     }\n@@ -1522,7 +1555,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGE);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNGE);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1538,7 +1573,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLE);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, UNLE);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -1554,7 +1591,9 @@\n {\n   if (GET_MODE (sparc_compare_op0) == TFmode && ! TARGET_HARD_QUAD)\n     {\n-      sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LTGT);\n+      enum rtx_code code\n+        = sparc_emit_float_lib_cmp (sparc_compare_op0, sparc_compare_op1, LTGT);\n+      gcc_assert (code == NE);\n       emit_jump_insn (gen_bne (operands[0]));\n       DONE;\n     }\n@@ -3015,48 +3054,22 @@\n })\n \n \n-;; SPARC-V9 conditional move instructions.\n+;; SPARC-V9 conditional move instructions\n \n ;; We can handle larger constants here for some flavors, but for now we keep\n ;; it simple and only allow those constants supported by all flavors.\n ;; Note that emit_conditional_move canonicalizes operands 2,3 so that operand\n ;; 3 contains the constant if one is present, but we handle either for\n ;; generality (sparc.c puts a constant in operand 2).\n \n-(define_expand \"movqicc\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n-\t(if_then_else:QI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:QI 2 \"arith10_operand\" \"\")\n-\t\t\t (match_operand:QI 3 \"arith10_operand\" \"\")))]\n-  \"TARGET_V9\"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (GET_MODE (sparc_compare_op0) == DImode\n-      && ! TARGET_ARCH64)\n-    FAIL;\n-\n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n-      && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n-  else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n-    }\n-})\n+(define_mode_iterator I [QI HI SI DI])\n \n-(define_expand \"movhicc\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(if_then_else:HI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:HI 2 \"arith10_operand\" \"\")\n-\t\t\t (match_operand:HI 3 \"arith10_operand\" \"\")))]\n-  \"TARGET_V9\"\n+(define_expand \"mov<I:mode>cc\"\n+  [(set (match_operand:I 0 \"register_operand\" \"\")\n+\t(if_then_else:I (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t(match_operand:I 2 \"arith10_operand\" \"\")\n+\t\t\t(match_operand:I 3 \"arith10_operand\" \"\")))]\n+  \"TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n \n@@ -3068,72 +3081,18 @@\n       && GET_CODE (sparc_compare_op0) == REG\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n-  else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n-    }\n-})\n-\n-(define_expand \"movsicc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"arith10_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"arith10_operand\" \"\")))]\n-  \"TARGET_V9\"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  enum machine_mode op0_mode = GET_MODE (sparc_compare_op0);\n-\n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && (TARGET_ARCH64 && op0_mode == DImode && v9_regcmp_p (code)))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, op0_mode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n+    operands[1] = gen_rtx_fmt_ee (code, DImode, sparc_compare_op0, const0_rtx);\n   else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg),\n-\t\t\t\t    cc_reg, const0_rtx);\n-    }\n+    operands[1] = gen_compare_operator (code);\n })\n \n-(define_expand \"movdicc\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"\")\n-\t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:DI 2 \"arith10_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"arith10_operand\" \"\")))]\n-  \"TARGET_ARCH64\"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n-      && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n-  else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg),\n-\t\t\t\t    cc_reg, const0_rtx);\n-    }\n-})\n+(define_mode_iterator F [SF DF TF])\n \n-(define_expand \"movsfcc\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SF 2 \"register_operand\" \"\")\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n+(define_expand \"mov<F:mode>cc\"\n+  [(set (match_operand:F 0 \"register_operand\" \"\")\n+\t(if_then_else:F (match_operand 1 \"comparison_operator\" \"\")\n+\t\t\t(match_operand:F 2 \"register_operand\" \"\")\n+\t\t\t(match_operand:F 3 \"register_operand\" \"\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n {\n   enum rtx_code code = GET_CODE (operands[1]);\n@@ -3146,187 +3105,128 @@\n       && GET_CODE (sparc_compare_op0) == REG\n       && GET_MODE (sparc_compare_op0) == DImode\n       && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n+    operands[1] = gen_rtx_fmt_ee (code, DImode, sparc_compare_op0, const0_rtx);\n   else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n-    }\n+    operands[1] = gen_compare_operator (code);\n })\n \n-(define_expand \"movdfcc\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(if_then_else:DF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:DF 2 \"register_operand\" \"\")\n-\t\t\t (match_operand:DF 3 \"register_operand\" \"\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (GET_MODE (sparc_compare_op0) == DImode\n-      && ! TARGET_ARCH64)\n-    FAIL;\n-\n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n-      && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n-  else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n-    }\n-})\n-\n-(define_expand \"movtfcc\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"\")\n-\t(if_then_else:TF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:TF 2 \"register_operand\" \"\")\n-\t\t\t (match_operand:TF 3 \"register_operand\" \"\")))]\n-  \"TARGET_V9 && TARGET_FPU\"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-\n-  if (GET_MODE (sparc_compare_op0) == DImode\n-      && ! TARGET_ARCH64)\n-    FAIL;\n-\n-  if (sparc_compare_op1 == const0_rtx\n-      && GET_CODE (sparc_compare_op0) == REG\n-      && GET_MODE (sparc_compare_op0) == DImode\n-      && v9_regcmp_p (code))\n-    {\n-      operands[1] = gen_rtx_fmt_ee (code, DImode,\n-\t\t\t     sparc_compare_op0, sparc_compare_op1);\n-    }\n-  else\n-    {\n-      rtx cc_reg = gen_compare_reg (code);\n-      operands[1] = gen_rtx_fmt_ee (code, GET_MODE (cc_reg), cc_reg, const0_rtx);\n-    }\n-})\n-\n-;; Conditional move define_insns.\n-\n-(define_insn \"*movqi_cc_sp64\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:QI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:QI 3 \"arith11_operand\" \"rL,0\")\n-                         (match_operand:QI 4 \"arith11_operand\" \"0,rL\")))]\n-  \"TARGET_V9\"\n-  \"@\n-   mov%C1\\t%x2, %3, %0\n-   mov%c1\\t%x2, %4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movhi_cc_sp64\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:HI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:HI 3 \"arith11_operand\" \"rL,0\")\n-                         (match_operand:HI 4 \"arith11_operand\" \"0,rL\")))]\n-  \"TARGET_V9\"\n-  \"@\n-   mov%C1\\t%x2, %3, %0\n-   mov%c1\\t%x2, %4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movsi_cc_sp64\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:SI 3 \"arith11_operand\" \"rL,0\")\n-                         (match_operand:SI 4 \"arith11_operand\" \"0,rL\")))]\n-  \"TARGET_V9\"\n-  \"@\n-   mov%C1\\t%x2, %3, %0\n-   mov%c1\\t%x2, %4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n+;; Conditional move define_insns\n \n-(define_insn \"*movdi_cc_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:DI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:DI 3 \"arith11_operand\" \"rL,0\")\n-                         (match_operand:DI 4 \"arith11_operand\" \"0,rL\")))]\n-  \"TARGET_ARCH64\"\n+(define_insn \"*mov<I:mode>_cc_v9\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:I (match_operator 1 \"comparison_operator\"\n+\t\t\t       [(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+\t\t\t\t(const_int 0)])\n+\t\t\t(match_operand:I 3 \"arith11_operand\" \"rL,0\")\n+\t\t\t(match_operand:I 4 \"arith11_operand\" \"0,rL\")))]\n+  \"TARGET_V9 && !(<I:MODE>mode == DImode && TARGET_ARCH32)\"\n   \"@\n    mov%C1\\t%x2, %3, %0\n    mov%c1\\t%x2, %4, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n-(define_insn \"*movdi_cc_sp64_trunc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"comparison_operator\"\n-\t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n+(define_insn \"*mov<I:mode>_cc_reg_sp64\"\n+  [(set (match_operand:I 0 \"register_operand\" \"=r,r\")\n+\t(if_then_else:I (match_operator 1 \"v9_register_compare_operator\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:SI 3 \"arith11_operand\" \"rL,0\")\n-                         (match_operand:SI 4 \"arith11_operand\" \"0,rL\")))]\n+\t\t\t(match_operand:I 3 \"arith10_operand\" \"rM,0\")\n+\t\t\t(match_operand:I 4 \"arith10_operand\" \"0,rM\")))]\n   \"TARGET_ARCH64\"\n   \"@\n-   mov%C1\\t%x2, %3, %0\n-   mov%c1\\t%x2, %4, %0\"\n+   movr%D1\\t%2, %r3, %0\n+   movr%d1\\t%2, %r4, %0\"\n   [(set_attr \"type\" \"cmove\")])\n \n-(define_insn \"*movsf_cc_sp64\"\n+(define_insn \"*movsf_cc_v9\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n \t(if_then_else:SF (match_operator 1 \"comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:SF 3 \"register_operand\" \"f,0\")\n-                         (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0\")\n+\t\t\t (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n   \"@\n    fmovs%C1\\t%x2, %3, %0\n    fmovs%c1\\t%x2, %4, %0\"\n   [(set_attr \"type\" \"fpcmove\")])\n \n-(define_insn \"movdf_cc_sp64\"\n+(define_insn \"*movsf_cc_reg_sp64\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(if_then_else:SF (match_operator 1 \"v9_register_compare_operator\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"f,0\")\n+\t\t\t (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n+  \"TARGET_ARCH64 && TARGET_FPU\"\n+  \"@\n+   fmovrs%D1\\t%2, %3, %0\n+   fmovrs%d1\\t%2, %4, %0\"\n+  [(set_attr \"type\" \"fpcrmove\")])\n+\n+;; Named because invoked by movtf_cc_v9\n+(define_insn \"movdf_cc_v9\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:DF (match_operator 1 \"comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:DF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n   \"TARGET_V9 && TARGET_FPU\"\n   \"@\n    fmovd%C1\\t%x2, %3, %0\n    fmovd%c1\\t%x2, %4, %0\"\n   [(set_attr \"type\" \"fpcmove\")\n    (set_attr \"fptype\" \"double\")])\n \n-(define_insn \"*movtf_cc_hq_sp64\"\n+;; Named because invoked by movtf_cc_reg_sp64\n+(define_insn \"movdf_cc_reg_sp64\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:DF (match_operator 1 \"v9_register_compare_operator\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n+  \"TARGET_ARCH64 && TARGET_FPU\"\n+  \"@\n+   fmovrd%D1\\t%2, %3, %0\n+   fmovrd%d1\\t%2, %4, %0\"\n+  [(set_attr \"type\" \"fpcrmove\")\n+   (set_attr \"fptype\" \"double\")])\n+\n+(define_insn \"*movtf_cc_hq_v9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n \t\t\t\t[(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n   \"TARGET_V9 && TARGET_FPU && TARGET_HARD_QUAD\"\n   \"@\n    fmovq%C1\\t%x2, %3, %0\n    fmovq%c1\\t%x2, %4, %0\"\n   [(set_attr \"type\" \"fpcmove\")])\n \n-(define_insn_and_split \"*movtf_cc_sp64\"\n+(define_insn \"*movtf_cc_reg_hq_sp64\"\n+  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n+\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n+\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n+\t\t\t\t (const_int 0)])\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n+  \"@\n+   fmovrq%D1\\t%2, %3, %0\n+   fmovrq%d1\\t%2, %4, %0\"\n+  [(set_attr \"type\" \"fpcrmove\")])\n+\n+(define_insn_and_split \"*movtf_cc_v9\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"comparison_operator\"\n \t\t\t    [(match_operand 2 \"icc_or_fcc_register_operand\" \"X,X\")\n \t\t\t     (const_int 0)])\n-                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n   \"TARGET_V9 && TARGET_FPU && !TARGET_HARD_QUAD\"\n   \"#\"\n   \"&& reload_completed\"\n@@ -3351,117 +3251,25 @@\n   if ((third && reg_overlap_mentioned_p (dest1, srcb2))\n       || (!third && reg_overlap_mentioned_p (dest1, srca2)))\n     {\n-      emit_insn (gen_movdf_cc_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n-      emit_insn (gen_movdf_cc_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, srcb1));\n     }\n   else\n     {\n-      emit_insn (gen_movdf_cc_sp64 (dest1, operands[1], operands[2], srca1, srcb1));\n-      emit_insn (gen_movdf_cc_sp64 (dest2, operands[1], operands[2], srca2, srcb2));\n+      emit_insn (gen_movdf_cc_v9 (dest1, operands[1], operands[2], srca1, srcb1));\n+      emit_insn (gen_movdf_cc_v9 (dest2, operands[1], operands[2], srca2, srcb2));\n     }\n   DONE;\n }\n   [(set_attr \"length\" \"2\")])\n \n-(define_insn \"*movqi_cc_reg_sp64\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:QI (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:QI 3 \"arith10_operand\" \"rM,0\")\n-                         (match_operand:QI 4 \"arith10_operand\" \"0,rM\")))]\n-  \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movhi_cc_reg_sp64\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:HI (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:HI 3 \"arith10_operand\" \"rM,0\")\n-                         (match_operand:HI 4 \"arith10_operand\" \"0,rM\")))]\n-  \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movsi_cc_reg_sp64\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SI (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:SI 3 \"arith10_operand\" \"rM,0\")\n-                         (match_operand:SI 4 \"arith10_operand\" \"0,rM\")))]\n-  \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movdi_cc_reg_sp64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:DI (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:DI 3 \"arith10_operand\" \"rM,0\")\n-                         (match_operand:DI 4 \"arith10_operand\" \"0,rM\")))]\n-  \"TARGET_ARCH64\"\n-  \"@\n-   movr%D1\\t%2, %r3, %0\n-   movr%d1\\t%2, %r4, %0\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movsf_cc_reg_sp64\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n-\t(if_then_else:SF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:SF 3 \"register_operand\" \"f,0\")\n-                         (match_operand:SF 4 \"register_operand\" \"0,f\")))]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"@\n-   fmovrs%D1\\t%2, %3, %0\n-   fmovrs%d1\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcrmove\")])\n-\n-(define_insn \"movdf_cc_reg_sp64\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=e,e\")\n-\t(if_then_else:DF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:DF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:DF 4 \"register_operand\" \"0,e\")))]\n-  \"TARGET_ARCH64 && TARGET_FPU\"\n-  \"@\n-   fmovrd%D1\\t%2, %3, %0\n-   fmovrd%d1\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcrmove\")\n-   (set_attr \"fptype\" \"double\")])\n-\n-(define_insn \"*movtf_cc_reg_hq_sp64\"\n-  [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n-\t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n-\t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n-\t\t\t\t (const_int 0)])\n-                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n-  \"TARGET_ARCH64 && TARGET_FPU && TARGET_HARD_QUAD\"\n-  \"@\n-   fmovrq%D1\\t%2, %3, %0\n-   fmovrq%d1\\t%2, %4, %0\"\n-  [(set_attr \"type\" \"fpcrmove\")])\n-\n (define_insn_and_split \"*movtf_cc_reg_sp64\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=e,e\")\n \t(if_then_else:TF (match_operator 1 \"v9_register_compare_operator\"\n \t\t\t\t[(match_operand:DI 2 \"register_operand\" \"r,r\")\n \t\t\t\t (const_int 0)])\n-                         (match_operand:TF 3 \"register_operand\" \"e,0\")\n-                         (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n+\t\t\t (match_operand:TF 3 \"register_operand\" \"e,0\")\n+\t\t\t (match_operand:TF 4 \"register_operand\" \"0,e\")))]\n   \"TARGET_ARCH64 && TARGET_FPU && ! TARGET_HARD_QUAD\"\n   \"#\"\n   \"&& reload_completed\""}]}