{"sha": "ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE2MWZjNTMwOGU4MzhlZGNlOGJiYjJmYjZmMTg5OWJjZDk3ODlkNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-07-21T07:17:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-07-21T07:17:57Z"}, "message": "cfgcleanup.c (flow_find_cross_jump): Do not crossjump across hot/cold regions.\n\n\n\t* cfgcleanup.c (flow_find_cross_jump): Do not crossjump across\n\thot/cold regions.\n\t(try_crossjump_to_edge): Do not punt on partitioned functions.\n\nFrom-SVN: r250418", "tree": {"sha": "879bfe0f96414c04bff13dc12e193a5465b13e48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/879bfe0f96414c04bff13dc12e193a5465b13e48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5/comments", "author": null, "committer": null, "parents": [{"sha": "d9af4feaf09350974d2cefcc284ebc3716f6829f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9af4feaf09350974d2cefcc284ebc3716f6829f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9af4feaf09350974d2cefcc284ebc3716f6829f"}], "stats": {"total": 40, "additions": 22, "deletions": 18}, "files": [{"sha": "121af7734589dc9103ea1745e79eee62d1e8e5ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "patch": "@@ -1,3 +1,9 @@\n+2016-07-21  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgcleanup.c (flow_find_cross_jump): Do not crossjump across\n+\thot/cold regions.\n+\t(try_crossjump_to_edge): Do not punt on partitioned functions.\n+\n 2016-07-21  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* bb-reorder.c (find_rarely_executed_basic_blocks_and_crossing_edges):"}, {"sha": "365c971effb3da1e05525a85e8b12954531933cc", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba61fc5308e838edce8bbb2fb6f1899bcd9789d5/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=ba61fc5308e838edce8bbb2fb6f1899bcd9789d5", "patch": "@@ -1435,6 +1435,13 @@ flow_find_cross_jump (basic_block bb1, basic_block bb2, rtx_insn **f1,\n       if (i1 == BB_HEAD (bb1) || i2 == BB_HEAD (bb2))\n \tbreak;\n \n+      /* Do not turn corssing edge to non-crossing or vice versa after\n+\t reload. */\n+      if (BB_PARTITION (BLOCK_FOR_INSN (i1))\n+\t  != BB_PARTITION (BLOCK_FOR_INSN (i2))\n+\t  && reload_completed)\n+\tbreak;\n+\n       dir = merge_dir (dir, old_insns_match_p (0, i1, i2));\n       if (dir == dir_none || (!dir_p && dir != dir_both))\n \tbreak;\n@@ -1958,18 +1965,6 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \n   newpos1 = newpos2 = NULL;\n \n-  /* If we have partitioned hot/cold basic blocks, it is a bad idea\n-     to try this optimization.\n-\n-     Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really\n-     must be left untouched (they are required to make it safely across\n-     partition boundaries).  See the comments at the top of\n-     bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n-\n-  if (crtl->has_bb_partition && reload_completed)\n-    return false;\n-\n   /* Search backward through forwarder blocks.  We don't need to worry\n      about multiple entry or chained forwarders, as they will be optimized\n      away.  We do this to look past the unconditional jump following a\n@@ -2003,6 +1998,11 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n   if (EDGE_COUNT (src1->preds) == 0 || EDGE_COUNT (src2->preds) == 0)\n     return false;\n \n+  /* Do not turn corssing edge to non-crossing or vice versa after reload.  */\n+  if (BB_PARTITION (src1) != BB_PARTITION (src2)\n+      && reload_completed)\n+    return false;\n+\n   /* Look for the common insn sequence, part the first ...  */\n   if (!outgoing_edges_match (mode, src1, src2))\n     return false;\n@@ -2024,12 +2024,10 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n \n   if (dir == dir_backward)\n     {\n-#define SWAP(T, X, Y) do { T tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n-      SWAP (basic_block, osrc1, osrc2);\n-      SWAP (basic_block, src1, src2);\n-      SWAP (edge, e1, e2);\n-      SWAP (rtx_insn *, newpos1, newpos2);\n-#undef SWAP\n+      std::swap (osrc1, osrc2);\n+      std::swap (src1, src2);\n+      std::swap (e1, e2);\n+      std::swap (newpos1, newpos2);\n     }\n \n   /* Don't proceed with the crossjump unless we found a sufficient number"}]}