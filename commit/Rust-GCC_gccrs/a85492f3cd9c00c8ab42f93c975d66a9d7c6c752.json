{"sha": "a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg1NDkyZjNjZDljMDBjOGFiNDJmOTNjOTc1ZDY2YTlkN2M2Yzc1Mg==", "commit": {"author": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-07-19T15:24:42Z"}, "committer": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-07-19T15:24:42Z"}, "message": "Now adding the mmintrin.h intrinsic headers. The DG tests will follow.\n\n2017-07-19  Steven Munroe  <munroesj@gcc.gnu.org>\n\n\t* config.gcc (powerpc*-*-*): Add mmintrin.h.\n\t* config/rs6000/mmintrin.h: New file.\n\t* config/rs6000/x86intrin.h [__ALTIVEC__]: Include mmintrin.h.\n\nFrom-SVN: r250350", "tree": {"sha": "fa515cfa168bc42083fd5b3c6dbf9c3ee0807a2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa515cfa168bc42083fd5b3c6dbf9c3ee0807a2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/comments", "author": null, "committer": null, "parents": [{"sha": "4e66b02bc151b83ac2c6b1f7bec0084d8b461d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e66b02bc151b83ac2c6b1f7bec0084d8b461d43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e66b02bc151b83ac2c6b1f7bec0084d8b461d43"}], "stats": {"total": 1470, "additions": 1468, "deletions": 2}, "files": [{"sha": "b27b9aa74b7b8b20130b7391f5c3145ca2f2098a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "patch": "@@ -1,3 +1,9 @@\n+2017-07-19  Steven Munroe  <munroesj@gcc.gnu.org>\n+\n+\t* config.gcc (powerpc*-*-*): Add mmintrin.h.\n+\t* config/rs6000/mmintrin.h: New file.\n+\t* config/rs6000/x86intrin.h [__ALTIVEC__]: Include mmintrin.h.\n+\n 2017-07-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/81346"}, {"sha": "b8b99692a5f488044a5b2cc7471433f37ca25a8e", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "patch": "@@ -456,7 +456,8 @@ powerpc*-*-*)\n \tcpu_type=rs6000\n \textra_objs=\"rs6000-string.o rs6000-p8swap.o\"\n \textra_headers=\"ppc-asm.h altivec.h htmintrin.h htmxlintrin.h\"\n-\textra_headers=\"${extra_headers} bmi2intrin.h bmiintrin.h x86intrin.h\"\n+\textra_headers=\"${extra_headers} bmi2intrin.h bmiintrin.h\"\n+\textra_headers=\"${extra_headers} mmintrin.h x86intrin.h\"\n \textra_headers=\"${extra_headers} ppu_intrinsics.h spu2vmx.h vec_types.h si2vmx.h\"\n \textra_headers=\"${extra_headers} paired.h\"\n \tcase x$with_cpu in"}, {"sha": "00b9a1507b89a20167900950734fe6e4b676a999", "filename": "gcc/config/rs6000/mmintrin.h", "status": "added", "additions": 1456, "deletions": 0, "changes": 1456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig%2Frs6000%2Fmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig%2Frs6000%2Fmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fmmintrin.h?ref=a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "patch": "@@ -0,0 +1,1456 @@\n+/* Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 9.0.  */\n+\n+#ifndef NO_WARN_X86_INTRINSICS\n+/* This header is distributed to simplify porting x86_64 code that\n+   makes explicit use of Intel intrinsics to powerpc64le.\n+   It is the user's responsibility to determine if the results are\n+   acceptable and make additional changes as necessary.\n+   Note that much code that uses Intel intrinsics can be rewritten in\n+   standard C or GNU C extensions, which are more portable and better\n+   optimized across multiple targets.\n+\n+   In the specific case of X86 MMX (__m64) intrinsics, the PowerPC\n+   target does not support a native __vector_size__ (8) type.  Instead\n+   we typedef __m64 to a 64-bit unsigned long long, which is natively\n+   supported in 64-bit mode.  This works well for the _si64 and some\n+   _pi32 operations, but starts to generate long sequences for _pi16\n+   and _pi8 operations.  For those cases it better (faster and\n+   smaller code) to transfer __m64 data to the PowerPC vector 128-bit\n+   unit, perform the operation, and then transfer the result back to\n+   the __m64 type. This implies that the direct register move\n+   instructions, introduced with power8, are available for efficient\n+   implementation of these transfers.\n+\n+   Most MMX intrinsic operations can be performed efficiently as\n+   C language 64-bit scalar operation or optimized to use the newer\n+   128-bit SSE/Altivec operations.  We recomend this for new\n+   applications.  */\n+#warning \"Please read comment above.  Use -DNO_WARN_X86_INTRINSICS to disable this warning.\"\n+#endif\n+\n+#ifndef _MMINTRIN_H_INCLUDED\n+#define _MMINTRIN_H_INCLUDED\n+\n+#include <altivec.h>\n+/* The Intel API is flexible enough that we must allow aliasing with other\n+   vector types, and their scalar components.  */\n+typedef __attribute__ ((__aligned__ (8))) unsigned long long __m64;\n+\n+typedef __attribute__ ((__aligned__ (8)))\n+union\n+  {\n+    __m64 as_m64;\n+    char as_char[8];\n+    signed char as_signed_char [8];\n+    short as_short[4];\n+    int as_int[2];\n+    long long as_long_long;\n+    float as_float[2];\n+    double as_double;\n+  } __m64_union;\n+\n+/* Empty the multimedia state.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_empty (void)\n+{\n+  /* nothing to do on PowerPC.  */\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_empty (void)\n+{\n+  /* nothing to do on PowerPC.  */\n+}\n+\n+/* Convert I to a __m64 object.  The integer is zero-extended to 64-bits.  */\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi32_si64 (int __i)\n+{\n+  return (__m64) (unsigned int) __i;\n+}\n+\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_from_int (int __i)\n+{\n+  return _mm_cvtsi32_si64 (__i);\n+}\n+\n+/* Convert the lower 32 bits of the __m64 object into an integer.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_si32 (__m64 __i)\n+{\n+  return ((int) __i);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_to_int (__m64 __i)\n+{\n+  return _mm_cvtsi64_si32 (__i);\n+}\n+\n+#ifdef __powerpc64__\n+/* Convert I to a __m64 object.  */\n+\n+/* Intel intrinsic.  */\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_from_int64 (long long __i)\n+{\n+  return (__m64) __i;\n+}\n+\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_m64 (long long __i)\n+{\n+  return (__m64) __i;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64x_si64 (long long __i)\n+{\n+  return (__m64) __i;\n+}\n+\n+extern __inline __m64  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pi64x (long long __i)\n+{\n+  return (__m64) __i;\n+}\n+\n+/* Convert the __m64 object to a 64bit integer.  */\n+\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_to_int64 (__m64 __i)\n+{\n+  return (long long)__i;\n+}\n+\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtm64_si64 (__m64 __i)\n+{\n+  return (long long) __i;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_si64x (__m64 __i)\n+{\n+  return (long long) __i;\n+}\n+\n+#ifdef _ARCH_PWR8\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with signed saturation.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short vm1;\n+  __vector signed char vresult;\n+\n+  vm1 = (__vector signed short)__builtin_pack_vector_int128 (__m2, __m1);\n+  vresult = vec_vpkshss (vm1, vm1);\n+  return (__m64) __builtin_unpack_vector_int128 ((__vector __int128)vresult, 0);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_packsswb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_packs_pi16 (__m1, __m2);\n+}\n+\n+/* Pack the two 32-bit values from M1 in to the lower two 16-bit values of\n+   the result, and the two 32-bit values from M2 into the upper two 16-bit\n+   values of the result, all with signed saturation.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packs_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed int vm1;\n+  __vector signed short vresult;\n+\n+  vm1 = (__vector signed int)__builtin_pack_vector_int128 (__m2, __m1);\n+  vresult = vec_vpkswss (vm1, vm1);\n+  return ((__m64) __builtin_unpack_vector_int128 ((__vector __int128)vresult, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_packssdw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_packs_pi32 (__m1, __m2);\n+}\n+\n+/* Pack the four 16-bit values from M1 into the lower four 8-bit values of\n+   the result, and the four 16-bit values from M2 into the upper four 8-bit\n+   values of the result, all with unsigned saturation.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_packs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short vm1;\n+  __vector unsigned char vresult;\n+\n+  vm1 = (__vector signed short)__builtin_pack_vector_int128 (__m2, __m1);\n+  vresult = vec_vpkshus (vm1, vm1);\n+  return ((__m64) __builtin_unpack_vector_int128 ((__vector __int128)vresult, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_packuswb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_packs_pu16 (__m1, __m2);\n+}\n+#endif /* end ARCH_PWR8 */\n+\n+/* Interleave the four 8-bit values from the high half of M1 with the four\n+   8-bit values from the high half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector unsigned char a, b, c;\n+\n+  a = (__vector unsigned char)vec_splats (__m1);\n+  b = (__vector unsigned char)vec_splats (__m2);\n+  c = vec_mergel (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = m1.as_char[4];\n+  res.as_char[1] = m2.as_char[4];\n+  res.as_char[2] = m1.as_char[5];\n+  res.as_char[3] = m2.as_char[5];\n+  res.as_char[4] = m1.as_char[6];\n+  res.as_char[5] = m2.as_char[6];\n+  res.as_char[6] = m1.as_char[7];\n+  res.as_char[7] = m2.as_char[7];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpckhbw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpackhi_pi8 (__m1, __m2);\n+}\n+\n+/* Interleave the two 16-bit values from the high half of M1 with the two\n+   16-bit values from the high half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = m1.as_short[2];\n+  res.as_short[1] = m2.as_short[2];\n+  res.as_short[2] = m1.as_short[3];\n+  res.as_short[3] = m2.as_short[3];\n+\n+  return (__m64) res.as_m64;\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpckhwd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpackhi_pi16 (__m1, __m2);\n+}\n+/* Interleave the 32-bit value from the high half of M1 with the 32-bit\n+   value from the high half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = m1.as_int[1];\n+  res.as_int[1] = m2.as_int[1];\n+\n+  return (__m64) res.as_m64;\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpckhdq (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpackhi_pi32 (__m1, __m2);\n+}\n+/* Interleave the four 8-bit values from the low half of M1 with the four\n+   8-bit values from the low half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector unsigned char a, b, c;\n+\n+  a = (__vector unsigned char)vec_splats (__m1);\n+  b = (__vector unsigned char)vec_splats (__m2);\n+  c = vec_mergel (a, b);\n+  return (__builtin_unpack_vector_int128 ((vector __int128_t)c, 1));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = m1.as_char[0];\n+  res.as_char[1] = m2.as_char[0];\n+  res.as_char[2] = m1.as_char[1];\n+  res.as_char[3] = m2.as_char[1];\n+  res.as_char[4] = m1.as_char[2];\n+  res.as_char[5] = m2.as_char[2];\n+  res.as_char[6] = m1.as_char[3];\n+  res.as_char[7] = m2.as_char[3];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpcklbw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpacklo_pi8 (__m1, __m2);\n+}\n+/* Interleave the two 16-bit values from the low half of M1 with the two\n+   16-bit values from the low half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = m1.as_short[0];\n+  res.as_short[1] = m2.as_short[0];\n+  res.as_short[2] = m1.as_short[1];\n+  res.as_short[3] = m2.as_short[1];\n+\n+  return (__m64) res.as_m64;\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpcklwd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpacklo_pi16 (__m1, __m2);\n+}\n+\n+/* Interleave the 32-bit value from the low half of M1 with the 32-bit\n+   value from the low half of M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_pi32 (__m64 __m1, __m64 __m2)\n+{\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = m1.as_int[0];\n+  res.as_int[1] = m2.as_int[0];\n+\n+  return (__m64) res.as_m64;\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_punpckldq (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_unpacklo_pi32 (__m1, __m2);\n+}\n+\n+/* Add the 8-bit values in M1 to the 8-bit values in M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed char a, b, c;\n+\n+  a = (__vector signed char)vec_splats (__m1);\n+  b = (__vector signed char)vec_splats (__m2);\n+  c = vec_add (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = m1.as_char[0] + m2.as_char[0];\n+  res.as_char[1] = m1.as_char[1] + m2.as_char[1];\n+  res.as_char[2] = m1.as_char[2] + m2.as_char[2];\n+  res.as_char[3] = m1.as_char[3] + m2.as_char[3];\n+  res.as_char[4] = m1.as_char[4] + m2.as_char[4];\n+  res.as_char[5] = m1.as_char[5] + m2.as_char[5];\n+  res.as_char[6] = m1.as_char[6] + m2.as_char[6];\n+  res.as_char[7] = m1.as_char[7] + m2.as_char[7];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_add_pi8 (__m1, __m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_pi16 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = vec_add (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = m1.as_short[0] + m2.as_short[0];\n+  res.as_short[1] = m1.as_short[1] + m2.as_short[1];\n+  res.as_short[2] = m1.as_short[2] + m2.as_short[2];\n+  res.as_short[3] = m1.as_short[3] + m2.as_short[3];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_add_pi16 (__m1, __m2);\n+}\n+\n+/* Add the 32-bit values in M1 to the 32-bit values in M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_pi32 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR9\n+  __vector signed int a, b, c;\n+\n+  a = (__vector signed int)vec_splats (__m1, __m1);\n+  b = (__vector signed int)vec_splats (__m2, __m2);\n+  c = vec_add (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = m1.as_int[0] + m2.as_int[0];\n+  res.as_int[1] = m1.as_int[1] + m2.as_int[1];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_add_pi32 (__m1, __m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed char a, b, c;\n+\n+  a = (__vector signed char)vec_splats (__m1);\n+  b = (__vector signed char)vec_splats (__m2);\n+  c = vec_sub (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = m1.as_char[0] - m2.as_char[0];\n+  res.as_char[1] = m1.as_char[1] - m2.as_char[1];\n+  res.as_char[2] = m1.as_char[2] - m2.as_char[2];\n+  res.as_char[3] = m1.as_char[3] - m2.as_char[3];\n+  res.as_char[4] = m1.as_char[4] - m2.as_char[4];\n+  res.as_char[5] = m1.as_char[5] - m2.as_char[5];\n+  res.as_char[6] = m1.as_char[6] - m2.as_char[6];\n+  res.as_char[7] = m1.as_char[7] - m2.as_char[7];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_sub_pi8 (__m1, __m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_pi16 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = vec_sub (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = m1.as_short[0] - m2.as_short[0];\n+  res.as_short[1] = m1.as_short[1] - m2.as_short[1];\n+  res.as_short[2] = m1.as_short[2] - m2.as_short[2];\n+  res.as_short[3] = m1.as_short[3] - m2.as_short[3];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_sub_pi16 (__m1, __m2);\n+}\n+\n+/* Subtract the 32-bit values in M2 from the 32-bit values in M1.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_pi32 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR9\n+  __vector signed int a, b, c;\n+\n+  a = (__vector signed int)vec_splats (__m1);\n+  b = (__vector signed int)vec_splats (__m2);\n+  c = vec_sub (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = m1.as_int[0] - m2.as_int[0];\n+  res.as_int[1] = m1.as_int[1] - m2.as_int[1];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_add_pi32 (__m1, __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m1 + __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m1 - __m2);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m << __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psllq (__m64 __m, __m64 __count)\n+{\n+  return _mm_sll_si64 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_si64 (__m64 __m, const int __count)\n+{\n+  return (__m << __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psllqi (__m64 __m, const int __count)\n+{\n+  return _mm_slli_si64 (__m, __count);\n+}\n+\n+/* Shift the 64-bit value in M left by COUNT; shift in zeros.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_si64 (__m64 __m, __m64 __count)\n+{\n+  return (__m >> __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrlq (__m64 __m, __m64 __count)\n+{\n+  return _mm_srl_si64 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_si64 (__m64 __m, const int __count)\n+{\n+  return (__m >> __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrlqi (__m64 __m, const int __count)\n+{\n+  return _mm_srli_si64 (__m, __count);\n+}\n+\n+/* Bit-wise AND the 64-bit values in M1 and M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_and_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m1 & __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pand (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_and_si64 (__m1, __m2);\n+}\n+\n+/* Bit-wise complement the 64-bit value in M1 and bit-wise AND it with the\n+   64-bit value in M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_andnot_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return (~__m1 & __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pandn (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_andnot_si64 (__m1, __m2);\n+}\n+\n+/* Bit-wise inclusive OR the 64-bit values in M1 and M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_or_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return (__m1 | __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_por (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_or_si64 (__m1, __m2);\n+}\n+\n+/* Bit-wise exclusive OR the 64-bit values in M1 and M2.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_xor_si64 (__m64 __m1, __m64 __m2)\n+{\n+  return  (__m1 ^ __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pxor (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_xor_si64 (__m1, __m2);\n+}\n+\n+/* Creates a 64-bit zero.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setzero_si64 (void)\n+{\n+  return (__m64) 0;\n+}\n+\n+/* Compare eight 8-bit values.  The result of the comparison is 0xFF if the\n+   test is true and zero if false.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#ifdef _ARCH_PWR6\n+  __m64 res;\n+  __asm__(\n+      \"cmpb %0,%1,%2;\\n\"\n+      : \"=r\" (res)\n+      : \"r\" (__m1),\n+\t\"r\" (__m2)\n+      : );\n+  return (res);\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = (m1.as_char[0] == m2.as_char[0])? -1: 0;\n+  res.as_char[1] = (m1.as_char[1] == m2.as_char[1])? -1: 0;\n+  res.as_char[2] = (m1.as_char[2] == m2.as_char[2])? -1: 0;\n+  res.as_char[3] = (m1.as_char[3] == m2.as_char[3])? -1: 0;\n+  res.as_char[4] = (m1.as_char[4] == m2.as_char[4])? -1: 0;\n+  res.as_char[5] = (m1.as_char[5] == m2.as_char[5])? -1: 0;\n+  res.as_char[6] = (m1.as_char[6] == m2.as_char[6])? -1: 0;\n+  res.as_char[7] = (m1.as_char[7] == m2.as_char[7])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpeqb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpeq_pi8 (__m1, __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_pi8 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed char a, b, c;\n+\n+  a = (__vector signed char)vec_splats (__m1);\n+  b = (__vector signed char)vec_splats (__m2);\n+  c = (__vector signed char)vec_cmpgt (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_char[0] = (m1.as_char[0] > m2.as_char[0])? -1: 0;\n+  res.as_char[1] = (m1.as_char[1] > m2.as_char[1])? -1: 0;\n+  res.as_char[2] = (m1.as_char[2] > m2.as_char[2])? -1: 0;\n+  res.as_char[3] = (m1.as_char[3] > m2.as_char[3])? -1: 0;\n+  res.as_char[4] = (m1.as_char[4] > m2.as_char[4])? -1: 0;\n+  res.as_char[5] = (m1.as_char[5] > m2.as_char[5])? -1: 0;\n+  res.as_char[6] = (m1.as_char[6] > m2.as_char[6])? -1: 0;\n+  res.as_char[7] = (m1.as_char[7] > m2.as_char[7])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpgtb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpgt_pi8 (__m1, __m2);\n+}\n+\n+/* Compare four 16-bit values.  The result of the comparison is 0xFFFF if\n+   the test is true and zero if false.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_pi16 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = (__vector signed short)vec_cmpeq (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = (m1.as_short[0] == m2.as_short[0])? -1: 0;\n+  res.as_short[1] = (m1.as_short[1] == m2.as_short[1])? -1: 0;\n+  res.as_short[2] = (m1.as_short[2] == m2.as_short[2])? -1: 0;\n+  res.as_short[3] = (m1.as_short[3] == m2.as_short[3])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpeqw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpeq_pi16 (__m1, __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_pi16 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = (__vector signed short)vec_cmpgt (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_short[0] = (m1.as_short[0] > m2.as_short[0])? -1: 0;\n+  res.as_short[1] = (m1.as_short[1] > m2.as_short[1])? -1: 0;\n+  res.as_short[2] = (m1.as_short[2] > m2.as_short[2])? -1: 0;\n+  res.as_short[3] = (m1.as_short[3] > m2.as_short[3])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpgtw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpgt_pi16 (__m1, __m2);\n+}\n+\n+/* Compare two 32-bit values.  The result of the comparison is 0xFFFFFFFF if\n+   the test is true and zero if false.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_pi32 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR9\n+  __vector signed int a, b, c;\n+\n+  a = (__vector signed int)vec_splats (__m1);\n+  b = (__vector signed int)vec_splats (__m2);\n+  c = (__vector signed short)vec_cmpeq (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = (m1.as_int[0] == m2.as_int[0])? -1: 0;\n+  res.as_int[1] = (m1.as_int[1] == m2.as_int[1])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpeqd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpeq_pi32 (__m1, __m2);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_pi32 (__m64 __m1, __m64 __m2)\n+{\n+#if _ARCH_PWR9\n+  __vector signed int a, b, c;\n+\n+  a = (__vector signed int)vec_splats (__m1);\n+  b = (__vector signed int)vec_splats (__m2);\n+  c = (__vector signed short)vec_cmpgt (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __m1;\n+  m2.as_m64 = __m2;\n+\n+  res.as_int[0] = (m1.as_int[0] > m2.as_int[0])? -1: 0;\n+  res.as_int[1] = (m1.as_int[1] > m2.as_int[1])? -1: 0;\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pcmpgtd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_cmpgt_pi32 (__m1, __m2);\n+}\n+\n+#if _ARCH_PWR8\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using signed\n+   saturated arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed char a, b, c;\n+\n+  a = (__vector signed char)vec_splats (__m1);\n+  b = (__vector signed char)vec_splats (__m2);\n+  c = vec_adds (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddsb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_adds_pi8 (__m1, __m2);\n+}\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using signed\n+   saturated arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = vec_adds (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddsw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_adds_pi16 (__m1, __m2);\n+}\n+/* Add the 8-bit values in M1 to the 8-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  __vector unsigned char a, b, c;\n+\n+  a = (__vector unsigned char)vec_splats (__m1);\n+  b = (__vector unsigned char)vec_splats (__m2);\n+  c = vec_adds (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddusb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_adds_pu8 (__m1, __m2);\n+}\n+\n+/* Add the 16-bit values in M1 to the 16-bit values in M2 using unsigned\n+   saturated arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_adds_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector unsigned short a, b, c;\n+\n+  a = (__vector unsigned short)vec_splats (__m1);\n+  b = (__vector unsigned short)vec_splats (__m2);\n+  c = vec_adds (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_paddusw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_adds_pu16 (__m1, __m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using signed\n+   saturating arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_pi8 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed char a, b, c;\n+\n+  a = (__vector signed char)vec_splats (__m1);\n+  b = (__vector signed char)vec_splats (__m2);\n+  c = vec_subs (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubsb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_subs_pi8 (__m1, __m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   signed saturating arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = vec_subs (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubsw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_subs_pi16 (__m1, __m2);\n+}\n+\n+/* Subtract the 8-bit values in M2 from the 8-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_pu8 (__m64 __m1, __m64 __m2)\n+{\n+  __vector unsigned char a, b, c;\n+\n+  a = (__vector unsigned char)vec_splats (__m1);\n+  b = (__vector unsigned char)vec_splats (__m2);\n+  c = vec_subs (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubusb (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_subs_pu8 (__m1, __m2);\n+}\n+\n+/* Subtract the 16-bit values in M2 from the 16-bit values in M1 using\n+   unsigned saturating arithmetic.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_subs_pu16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector unsigned short a, b, c;\n+\n+  a = (__vector unsigned short)vec_splats (__m1);\n+  b = (__vector unsigned short)vec_splats (__m2);\n+  c = vec_subs (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psubusw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_subs_pu16 (__m1, __m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 producing\n+   four 32-bit intermediate results, which are then summed by pairs to\n+   produce two 32-bit results.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_madd_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short a, b;\n+  __vector signed int c;\n+  __vector signed int zero = {0, 0, 0, 0};\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = vec_vmsumshm (a, b, zero);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmaddwd (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_madd_pi16 (__m1, __m2);\n+}\n+/* Multiply four signed 16-bit values in M1 by four signed 16-bit values in\n+   M2 and produce the high 16 bits of the 32-bit results.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mulhi_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short a, b;\n+  __vector signed short c;\n+  __vector signed int w0, w1;\n+  __vector unsigned char xform1 = {\n+      0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,\n+      0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F\n+    };\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+\n+  w0 = vec_vmulesh (a, b);\n+  w1 = vec_vmulosh (a, b);\n+  c = (__vector signed short)vec_perm (w0, w1, xform1);\n+\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmulhw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_mulhi_pi16 (__m1, __m2);\n+}\n+\n+/* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce\n+   the low 16 bits of the results.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mullo_pi16 (__m64 __m1, __m64 __m2)\n+{\n+  __vector signed short a, b, c;\n+\n+  a = (__vector signed short)vec_splats (__m1);\n+  b = (__vector signed short)vec_splats (__m2);\n+  c = a * b;\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmullw (__m64 __m1, __m64 __m2)\n+{\n+  return _mm_mullo_pi16 (__m1, __m2);\n+}\n+\n+/* Shift four 16-bit values in M left by COUNT.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_pi16 (__m64 __m, __m64 __count)\n+{\n+  __vector signed short m, r;\n+  __vector unsigned short c;\n+\n+  if (__count <= 15)\n+    {\n+      m = (__vector signed short)vec_splats (__m);\n+      c = (__vector unsigned short)vec_splats ((unsigned short)__count);\n+      r = vec_sl (m, (__vector unsigned short)c);\n+      return (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+    }\n+  else\n+  return (0);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psllw (__m64 __m, __m64 __count)\n+{\n+  return _mm_sll_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_pi16 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_sll_pi16.  */\n+  return _mm_sll_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psllwi (__m64 __m, int __count)\n+{\n+  return _mm_slli_pi16 (__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M left by COUNT.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sll_pi32 (__m64 __m, __m64 __count)\n+{\n+  __m64_union m, res;\n+\n+  m.as_m64 = __m;\n+\n+  res.as_int[0] = m.as_int[0] << __count;\n+  res.as_int[1] = m.as_int[1] << __count;\n+  return (res.as_m64);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pslld (__m64 __m, __m64 __count)\n+{\n+  return _mm_sll_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_slli_pi32 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_sll_pi32.  */\n+  return _mm_sll_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pslldi (__m64 __m, int __count)\n+{\n+  return _mm_slli_pi32 (__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in the sign bit.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sra_pi16 (__m64 __m, __m64 __count)\n+{\n+  __vector signed short m, r;\n+  __vector unsigned short c;\n+\n+  if (__count <= 15)\n+    {\n+\tm = (__vector signed short)vec_splats (__m);\n+\tc = (__vector unsigned short)vec_splats ((unsigned short)__count);\n+\tr = vec_sra (m, (__vector unsigned short)c);\n+\treturn (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+    }\n+  else\n+  return (0);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psraw (__m64 __m, __m64 __count)\n+{\n+  return _mm_sra_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srai_pi16 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_sra_pi32.  */\n+  return _mm_sra_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrawi (__m64 __m, int __count)\n+{\n+  return _mm_srai_pi16 (__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in the sign bit.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sra_pi32 (__m64 __m, __m64 __count)\n+{\n+  __m64_union m, res;\n+\n+  m.as_m64 = __m;\n+\n+  res.as_int[0] = m.as_int[0] >> __count;\n+  res.as_int[1] = m.as_int[1] >> __count;\n+  return (res.as_m64);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrad (__m64 __m, __m64 __count)\n+{\n+  return _mm_sra_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srai_pi32 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_sra_pi32.  */\n+  return _mm_sra_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psradi (__m64 __m, int __count)\n+{\n+  return _mm_srai_pi32 (__m, __count);\n+}\n+\n+/* Shift four 16-bit values in M right by COUNT; shift in zeros.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_pi16 (__m64 __m, __m64 __count)\n+{\n+  __vector unsigned short m, r;\n+  __vector unsigned short c;\n+\n+  if (__count <= 15)\n+    {\n+\tm = (__vector unsigned short)vec_splats (__m);\n+\tc = (__vector unsigned short)vec_splats ((unsigned short)__count);\n+\tr = vec_sr (m, (__vector unsigned short)c);\n+\treturn (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+    }\n+  else\n+    return (0);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrlw (__m64 __m, __m64 __count)\n+{\n+  return _mm_srl_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_pi16 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_sra_pi32.  */\n+  return _mm_srl_pi16 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrlwi (__m64 __m, int __count)\n+{\n+  return _mm_srli_pi16 (__m, __count);\n+}\n+\n+/* Shift two 32-bit values in M right by COUNT; shift in zeros.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srl_pi32 (__m64 __m, __m64 __count)\n+{\n+  __m64_union m, res;\n+\n+  m.as_m64 = __m;\n+\n+  res.as_int[0] = (unsigned int)m.as_int[0] >> __count;\n+  res.as_int[1] = (unsigned int)m.as_int[1] >> __count;\n+  return (res.as_m64);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrld (__m64 __m, __m64 __count)\n+{\n+  return _mm_srl_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_srli_pi32 (__m64 __m, int __count)\n+{\n+  /* Promote int to long then invoke mm_srl_pi32.  */\n+  return _mm_srl_pi32 (__m, __count);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psrldi (__m64 __m, int __count)\n+{\n+  return _mm_srli_pi32 (__m, __count);\n+}\n+#endif /* _ARCH_PWR8 */\n+\n+/* Creates a vector of two 32-bit values; I0 is least significant.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pi32 (int __i1, int __i0)\n+{\n+  __m64_union res;\n+\n+  res.as_int[0] = __i0;\n+  res.as_int[1] = __i1;\n+  return (res.as_m64);\n+}\n+\n+/* Creates a vector of four 16-bit values; W0 is least significant.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pi16 (short __w3, short __w2, short __w1, short __w0)\n+{\n+  __m64_union res;\n+\n+  res.as_short[0] = __w0;\n+  res.as_short[1] = __w1;\n+  res.as_short[2] = __w2;\n+  res.as_short[3] = __w3;\n+  return (res.as_m64);\n+}\n+\n+/* Creates a vector of eight 8-bit values; B0 is least significant.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_pi8 (char __b7, char __b6, char __b5, char __b4,\n+\t     char __b3, char __b2, char __b1, char __b0)\n+{\n+  __m64_union res;\n+\n+  res.as_char[0] = __b0;\n+  res.as_char[1] = __b1;\n+  res.as_char[2] = __b2;\n+  res.as_char[3] = __b3;\n+  res.as_char[4] = __b4;\n+  res.as_char[5] = __b5;\n+  res.as_char[6] = __b6;\n+  res.as_char[7] = __b7;\n+  return (res.as_m64);\n+}\n+\n+/* Similar, but with the arguments in reverse order.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_pi32 (int __i0, int __i1)\n+{\n+  __m64_union res;\n+\n+  res.as_int[0] = __i0;\n+  res.as_int[1] = __i1;\n+  return (res.as_m64);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_pi16 (short __w0, short __w1, short __w2, short __w3)\n+{\n+  return _mm_set_pi16 (__w3, __w2, __w1, __w0);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_pi8 (char __b0, char __b1, char __b2, char __b3,\n+\t      char __b4, char __b5, char __b6, char __b7)\n+{\n+  return _mm_set_pi8 (__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);\n+}\n+\n+/* Creates a vector of two 32-bit values, both elements containing I.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_pi32 (int __i)\n+{\n+  __m64_union res;\n+\n+  res.as_int[0] = __i;\n+  res.as_int[1] = __i;\n+  return (res.as_m64);\n+}\n+\n+/* Creates a vector of four 16-bit values, all elements containing W.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_pi16 (short __w)\n+{\n+#if _ARCH_PWR9\n+  __vector signed short w;\n+\n+  w = (__vector signed short)vec_splats (__w);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)w, 0));\n+#else\n+  __m64_union res;\n+\n+  res.as_short[0] = __w;\n+  res.as_short[1] = __w;\n+  res.as_short[2] = __w;\n+  res.as_short[3] = __w;\n+  return (res.as_m64);\n+#endif\n+}\n+\n+/* Creates a vector of eight 8-bit values, all elements containing B.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_pi8 (signed char __b)\n+{\n+#if _ARCH_PWR8\n+  __vector signed char b;\n+\n+  b = (__vector signed char)vec_splats (__b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)b, 0));\n+#else\n+  __m64_union res;\n+\n+  res.as_char[0] = __b;\n+  res.as_char[1] = __b;\n+  res.as_char[2] = __b;\n+  res.as_char[3] = __b;\n+  res.as_char[4] = __b;\n+  res.as_char[5] = __b;\n+  res.as_char[6] = __b;\n+  res.as_char[7] = __b;\n+  return (res.as_m64);\n+#endif\n+}\n+#endif /* __powerpc64__ */\n+#endif /* _MMINTRIN_H_INCLUDED */"}, {"sha": "1526a7de2eface2b1730aeaf919f0866b77c99ed", "filename": "gcc/config/rs6000/x86intrin.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a85492f3cd9c00c8ab42f93c975d66a9d7c6c752/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx86intrin.h?ref=a85492f3cd9c00c8ab42f93c975d66a9d7c6c752", "patch": "@@ -35,9 +35,12 @@\n #ifndef _X86INTRIN_H_INCLUDED\n #define _X86INTRIN_H_INCLUDED\n \n+#ifdef __ALTIVEC__\n+#include <mmintrin.h>\n+#endif /* __ALTIVEC__ */\n+\n #include <bmiintrin.h>\n \n #include <bmi2intrin.h>\n \n-\n #endif /* _X86INTRIN_H_INCLUDED */"}]}