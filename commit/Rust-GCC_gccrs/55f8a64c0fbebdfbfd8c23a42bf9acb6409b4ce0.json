{"sha": "55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVmOGE2NGMwZmJlYmRmYmZkOGMyM2E0MmJmOWFjYjY0MDliNGNlMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-08T00:10:42Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-08T00:10:42Z"}, "message": "(gen_int_relational): Handle overflow when incrementing cmp1.\n\nFrom-SVN: r2714", "tree": {"sha": "92446c4050d695e79d6c273b81099ed46cb8e272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92446c4050d695e79d6c273b81099ed46cb8e272"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0/comments", "author": null, "committer": null, "parents": [{"sha": "8843f6e2a93e098c0a488d68b324f16eb7a23186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8843f6e2a93e098c0a488d68b324f16eb7a23186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8843f6e2a93e098c0a488d68b324f16eb7a23186"}], "stats": {"total": 38, "additions": 27, "deletions": 11}, "files": [{"sha": "09c73fe27ff2437e91ac2f50df8c0dcc5dd06b28", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=55f8a64c0fbebdfbfd8c23a42bf9acb6409b4ce0", "patch": "@@ -1554,20 +1554,21 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n     int reverse_regs;\t\t/* reverse registers in test */\n     int invert_const;\t\t/* != 0 if invert value if cmp1 is constant */\n     int invert_reg;\t\t/* != 0 if invert value if cmp1 is register */\n+    int unsignedp;\t\t/* != 0 for unsigned comparisons.  */\n   };\n \n   static struct cmp_info info[ (int)ITEST_MAX ] = {\n \n-    { XOR,\t 0,  65535,  0,\t 0,  0,\t 0 },\t/* EQ  */\n-    { XOR,\t 0,  65535,  0,\t 0,  1,\t 1 },\t/* NE  */\n-    { LT,   -32769,  32766,  1,\t 1,  1,\t 0 },\t/* GT  */\n-    { LT,   -32768,  32767,  0,\t 0,  1,\t 1 },\t/* GE  */\n-    { LT,   -32768,  32767,  0,\t 0,  0,\t 0 },\t/* LT  */\n-    { LT,   -32769,  32766,  1,\t 1,  0,\t 1 },\t/* LE  */\n-    { LTU,  -32769,  32766,  1,\t 1,  1,\t 0 },\t/* GTU */\n-    { LTU,  -32768,  32767,  0,\t 0,  1,\t 1 },\t/* GEU */\n-    { LTU,  -32768,  32767,  0,\t 0,  0,\t 0 },\t/* LTU */\n-    { LTU,  -32769,  32766,  1,\t 1,  0,\t 1 },\t/* LEU */\n+    { XOR,\t 0,  65535,  0,\t 0,  0,\t 0, 0 },\t/* EQ  */\n+    { XOR,\t 0,  65535,  0,\t 0,  1,\t 1, 0 },\t/* NE  */\n+    { LT,   -32769,  32766,  1,\t 1,  1,\t 0, 0 },\t/* GT  */\n+    { LT,   -32768,  32767,  0,\t 0,  1,\t 1, 0 },\t/* GE  */\n+    { LT,   -32768,  32767,  0,\t 0,  0,\t 0, 0 },\t/* LT  */\n+    { LT,   -32769,  32766,  1,\t 1,  0,\t 1, 0 },\t/* LE  */\n+    { LTU,  -32769,  32766,  1,\t 1,  1,\t 0, 1 },\t/* GTU */\n+    { LTU,  -32768,  32767,  0,\t 0,  1,\t 1, 1 },\t/* GEU */\n+    { LTU,  -32768,  32767,  0,\t 0,  0,\t 0, 1 },\t/* LTU */\n+    { LTU,  -32769,  32766,  1,\t 1,  0,\t 1, 1 },\t/* LEU */\n   };\n \n   enum internal_test test;\n@@ -1631,7 +1632,22 @@ gen_int_relational (test_code, result, cmp0, cmp1, p_invert)\n   if (GET_CODE (cmp1) == CONST_INT)\n     {\n       if (p_info->const_add != 0)\n-\tcmp1 = GEN_INT (INTVAL (cmp1) + p_info->const_add);\n+\t{\n+\t  HOST_WIDE_INT new = INTVAL (cmp1) + p_info->const_add;\n+\t  /* If modification of cmp1 caused overflow,\n+\t     we would get the wrong answer if we follow the usual path;\n+\t     thus, x > 0xffffffffu would turn into x > 0u.  */\n+\t  if ((p_info->unsignedp\n+\t       ? (unsigned HOST_WIDE_INT) new > INTVAL (cmp1)\n+\t       : new > INTVAL (cmp1))\n+\t      != (p_info->const_add > 0))\n+\t    /* 1 is the right value in the LE and LEU case.\n+\t       In the GT and GTU case, *p_invert is already set,\n+\t       so this is effectively 0.  */\n+\t    return force_reg (SImode, const1_rtx);\n+\t  else\n+\t    cmp1 = GEN_INT (new);\n+\t}\n     }\n   else if (p_info->reverse_regs)\n     {"}]}