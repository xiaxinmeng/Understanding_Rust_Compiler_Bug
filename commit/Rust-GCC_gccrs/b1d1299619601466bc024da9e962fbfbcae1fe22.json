{"sha": "b1d1299619601466bc024da9e962fbfbcae1fe22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFkMTI5OTYxOTYwMTQ2NmJjMDI0ZGE5ZTk2MmZiZmJjYWUxZmUyMg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:58:19Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-27T16:58:19Z"}, "message": "[multiple changes]\n\n2014-01-27  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb (Resolve_Comparison_Op): Add type name/location\n\tto unordered msg.\n\t(Resolve_Range): Add type name/location to unordered msg.\n\n2014-01-27  Claire Dross  <dross@adacore.com>\n\n\t* a-cofove.adb/s (Copy): Add precondition so that Copy (Source,\n\tCapacity) is only called with Capacity >= Length (Source) and\n\tCapacity in Capacity_Range.\n\t* a-cfdlli.adb/s, a-cfhase.adb/s, a-cfhama.adb/s, a-cforse.adb/s,\n\ta-cforma.adb/s (Copy): Add precondition so that Copy (Source, Capacity)\n\tis only called with Capacity >= Source.Capacity. Raise Capacity_Error\n\tin the code is this is not the case.\n\n2014-01-27  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Fix handling of\n\tselected component in an instance where the component of the\n\tactual is not visibile at instantiation.\n\nFrom-SVN: r207146", "tree": {"sha": "9bb29935d01cc9a45a7f899c2d0c5e9743ccbe22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bb29935d01cc9a45a7f899c2d0c5e9743ccbe22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1d1299619601466bc024da9e962fbfbcae1fe22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d1299619601466bc024da9e962fbfbcae1fe22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1d1299619601466bc024da9e962fbfbcae1fe22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d1299619601466bc024da9e962fbfbcae1fe22/comments", "author": null, "committer": null, "parents": [{"sha": "fcadacf7bf304b9d1533abee137fee659c2aa039", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcadacf7bf304b9d1533abee137fee659c2aa039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcadacf7bf304b9d1533abee137fee659c2aa039"}], "stats": {"total": 129, "additions": 98, "deletions": 31}, "files": [{"sha": "237c3e0aa0a94e5b598474b7dc2f47e5893ace8f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -1,3 +1,25 @@\n+2014-01-27  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Comparison_Op): Add type name/location\n+\tto unordered msg.\n+\t(Resolve_Range): Add type name/location to unordered msg.\n+\n+2014-01-27  Claire Dross  <dross@adacore.com>\n+\n+\t* a-cofove.adb/s (Copy): Add precondition so that Copy (Source,\n+\tCapacity) is only called with Capacity >= Length (Source) and\n+\tCapacity in Capacity_Range.\n+\t* a-cfdlli.adb/s, a-cfhase.adb/s, a-cfhama.adb/s, a-cforse.adb/s,\n+\ta-cforma.adb/s (Copy): Add precondition so that Copy (Source, Capacity)\n+\tis only called with Capacity >= Source.Capacity. Raise Capacity_Error\n+\tin the code is this is not the case.\n+\n+2014-01-27  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): Fix handling of\n+\tselected component in an instance where the component of the\n+\tactual is not visibile at instantiation.\n+\n 2014-01-27  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch6.adb: sem_ch6.adb (Set_Actual_Subtypes): If the type"}, {"sha": "982c1b7d2f724f87d4795a2223fc252438fb4ff4", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -229,6 +229,10 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n       P : List (C);\n \n    begin\n+      if 0 < Capacity and then Capacity < Source.Capacity then\n+         raise Capacity_Error;\n+      end if;\n+\n       N := 1;\n       while N <= Source.Capacity loop\n          P.Nodes (N).Prev := Source.Nodes (N).Prev;"}, {"sha": "54f1886d297b235e9469c86dc89a724bece756e5", "filename": "gcc/ada/a-cfdlli.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -84,7 +84,8 @@ package Ada.Containers.Formal_Doubly_Linked_Lists is\n    procedure Assign (Target : in out List; Source : List) with\n      Pre => Target.Capacity >= Length (Source);\n \n-   function Copy (Source : List; Capacity : Count_Type := 0) return List;\n+   function Copy (Source : List; Capacity : Count_Type := 0) return List with\n+     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : List;"}, {"sha": "938423894c205e8f819ed96da3a6e067b79fb93d", "filename": "gcc/ada/a-cfhama.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -207,6 +207,10 @@ package body Ada.Containers.Formal_Hashed_Maps is\n       Cu     : Cursor;\n \n    begin\n+      if 0 < Capacity and then Capacity < Source.Capacity then\n+         raise Capacity_Error;\n+      end if;\n+\n       Target.Length := Source.Length;\n       Target.Free := Source.Free;\n "}, {"sha": "71eed2b0e4db81cc23eae08973e4d08188f3cdea", "filename": "gcc/ada/a-cfhama.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhama.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -100,7 +100,7 @@ package Ada.Containers.Formal_Hashed_Maps is\n      (Source   : Map;\n       Capacity : Count_Type := 0) return Map\n    with\n-     Pre => Capacity >= Source.Capacity;\n+     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n    --  Copy returns a container stricty equal to Source. It must have\n    --  the same cursors associated with each element. Therefore:\n    --  - capacity=0 means use container.capacity as capacity of target"}, {"sha": "96f0d05c057210bd972ffee6eca78c6735f5a921", "filename": "gcc/ada/a-cfhase.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -233,6 +233,10 @@ package body Ada.Containers.Formal_Hashed_Sets is\n       Cu     : Cursor;\n \n    begin\n+      if 0 < Capacity and then Capacity < Source.Capacity then\n+         raise Capacity_Error;\n+      end if;\n+\n       Target.Length := Source.Length;\n       Target.Free := Source.Free;\n "}, {"sha": "a3fc63dc03679a52893a50383ac53706f3915c03", "filename": "gcc/ada/a-cfhase.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfhase.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -106,7 +106,7 @@ package Ada.Containers.Formal_Hashed_Sets is\n      (Source   : Set;\n       Capacity : Count_Type := 0) return Set\n    with\n-     Pre => Capacity >= Source.Capacity;\n+     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : Set;"}, {"sha": "33cd101badc2e945271ed7ef739393aa8034c978", "filename": "gcc/ada/a-cforma.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -283,6 +283,10 @@ package body Ada.Containers.Formal_Ordered_Maps is\n       N    : Count_Type;\n \n    begin\n+      if 0 < Capacity and then Capacity < Source.Capacity then\n+         raise Capacity_Error;\n+      end if;\n+\n       return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n          if Length (Source) > 0 then\n             Target.Length := Source.Length;"}, {"sha": "a9426764560ac17bd5433282004eacb276add4bf", "filename": "gcc/ada/a-cforma.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforma.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -92,7 +92,7 @@ package Ada.Containers.Formal_Ordered_Maps is\n      Pre => Target.Capacity >= Length (Source);\n \n    function Copy (Source : Map; Capacity : Count_Type := 0) return Map with\n-     Pre => Capacity >= Source.Capacity;\n+     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Key (Container : Map; Position : Cursor) return Key_Type with\n      Pre => Has_Element (Container, Position);"}, {"sha": "1b202f03b1bf45dd50fc5bff13c673c68b96fb08", "filename": "gcc/ada/a-cforse.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -320,6 +320,10 @@ package body Ada.Containers.Formal_Ordered_Sets is\n       Target : Set (Count_Type'Max (Source.Capacity, Capacity));\n \n    begin\n+      if 0 < Capacity and then Capacity < Source.Capacity then\n+         raise Capacity_Error;\n+      end if;\n+\n       if Length (Source) > 0 then\n          Target.Length := Source.Length;\n          Target.Root   := Source.Root;"}, {"sha": "e935be5e457bf2ee5b19a37f6dd1248ffb92ea68", "filename": "gcc/ada/a-cforse.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cforse.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -94,7 +94,7 @@ package Ada.Containers.Formal_Ordered_Sets is\n      Pre => Target.Capacity >= Length (Source);\n \n    function Copy (Source : Set; Capacity : Count_Type := 0) return Set with\n-     Pre => Capacity >= Source.Capacity;\n+     Pre => Capacity = 0 or else Capacity >= Source.Capacity;\n \n    function Element\n      (Container : Set;"}, {"sha": "93372e1c5cb9cfb9db22fbd7b2cf0decf072ae77", "filename": "gcc/ada/a-cofove.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -301,10 +301,10 @@ package body Ada.Containers.Formal_Vectors is\n    begin\n       if Capacity = 0 then\n          C := LS;\n-      elsif Capacity >= LS then\n+      elsif Capacity >= LS and then Capacity in Capacity_Range then\n          C := Capacity;\n       else\n-         raise Constraint_Error;\n+         raise Capacity_Error;\n       end if;\n \n       return Target : Vector (C) do"}, {"sha": "313165c49c662c24f568e13588406960fdc7c91e", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -125,7 +125,7 @@ package Ada.Containers.Formal_Vectors is\n      (Source   : Vector;\n       Capacity : Count_Type := 0) return Vector\n    with\n-     Pre => Length (Source) <= Capacity;\n+     Pre => Length (Source) <= Capacity and then Capacity in Capacity_Range;\n \n    function To_Cursor\n      (Container : Vector;"}, {"sha": "51e7f090b19d6cb576c716be5711f8a799001e28", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -3943,6 +3943,7 @@ package body Sem_Ch4 is\n       --  searches have failed. When the match is found (it always will be),\n       --  the Etype of both N and Sel are set from this component, and the\n       --  entity of Sel is set to reference this component.\n+      --  ??? no longer true that a match is found ???\n \n       function Has_Mode_Conformant_Spec (Comp : Entity_Id) return Boolean;\n       --  It is known that the parent of N denotes a subprogram call. Comp\n@@ -3971,9 +3972,7 @@ package body Sem_Ch4 is\n             Next_Component (Comp);\n          end loop;\n \n-         --  This must succeed because code was legal in the generic\n-\n-         raise Program_Error;\n+         --  Need comment on what is going on when we fall through ???\n       end Find_Component_In_Instance;\n \n       ------------------------------\n@@ -4607,27 +4606,47 @@ package body Sem_Ch4 is\n             Analyze_Selected_Component (N);\n             return;\n \n-         --  Similarly, if this is the actual for a formal derived type, the\n-         --  component inherited from the generic parent may not be visible\n-         --  in the actual, but the selected component is legal.\n+         --  Similarly, if this is the actual for a formal derived type, or\n+         --  a derived type thereof, the component inherited from the generic\n+         --  parent may not be visible in the actual, but the selected\n+         --  component is legal. Climb up the derivation chain of the generic\n+         --  parent type until we find the proper ancestor type.\n \n-         elsif Ekind (Prefix_Type) = E_Record_Subtype_With_Private\n-           and then Is_Generic_Actual_Type (Prefix_Type)\n-           and then Present (Full_View (Prefix_Type))\n-         then\n-            Find_Component_In_Instance\n-              (Generic_Parent_Type (Parent (Prefix_Type)));\n-            return;\n+         elsif In_Instance and then Is_Tagged_Type (Prefix_Type) then\n+            declare\n+               Par : Entity_Id := Prefix_Type;\n+            begin\n+               --  Climb up derivation chain to generic actual subtype\n+\n+               while not Is_Generic_Actual_Type (Par) loop\n+                  if Ekind (Par) = E_Record_Type then\n+                     Par := Parent_Subtype (Par);\n+                     exit when No (Par);\n+                  else\n+                     exit when Par = Etype (Par);\n+                     Par := Etype (Par);\n+                  end if;\n+               end loop;\n \n-         --  Finally, the formal and the actual may be private extensions,\n-         --  but the generic is declared in a child unit of the parent, and\n-         --  an additional step is needed to retrieve the proper scope.\n+               if Present (Par) and then Is_Generic_Actual_Type (Par) then\n+                  --  Now look for component in ancestor types\n \n-         elsif In_Instance\n-           and then Present (Parent_Subtype (Etype (Base_Type (Prefix_Type))))\n-         then\n-            Find_Component_In_Instance\n-              (Parent_Subtype (Etype (Base_Type (Prefix_Type))));\n+                  Par := Generic_Parent_Type (Declaration_Node (Par));\n+                  loop\n+                     Find_Component_In_Instance (Par);\n+                     exit when Present (Entity (Sel))\n+                       or else Par = Etype (Par);\n+                     Par := Etype (Par);\n+                  end loop;\n+               end if;\n+            end;\n+\n+            --  The search above must have eventually succeeded, since the\n+            --  selected component was legal in the generic.\n+\n+            if No (Entity (Sel)) then\n+               raise Program_Error;\n+            end if;\n             return;\n \n          --  Component not found, specialize error message when appropriate"}, {"sha": "aff4b47926a63fc44c6797234838fa6e05589454", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1d1299619601466bc024da9e962fbfbcae1fe22/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=b1d1299619601466bc024da9e962fbfbcae1fe22", "patch": "@@ -6287,7 +6287,10 @@ package body Sem_Res is\n       --  Check comparison on unordered enumeration\n \n       if Bad_Unordered_Enumeration_Reference (N, Etype (L)) then\n-         Error_Msg_N (\"comparison on unordered enumeration type?U?\", N);\n+         Error_Msg_Sloc := Sloc (Etype (L));\n+         Error_Msg_NE\n+           (\"comparison on unordered enumeration type& declared#?U?\",\n+            N, Etype (L));\n       end if;\n \n       --  Evaluate the relation (note we do this after the above check since\n@@ -8830,7 +8833,9 @@ package body Sem_Res is\n \n         and then not First_Last_Ref\n       then\n-         Error_Msg (\"subrange of unordered enumeration type?U?\", Sloc (N));\n+         Error_Msg_Sloc := Sloc (Typ);\n+         Error_Msg_NE\n+           (\"subrange of unordered enumeration type& declared#?U?\", N, Typ);\n       end if;\n \n       Check_Unset_Reference (L);"}]}