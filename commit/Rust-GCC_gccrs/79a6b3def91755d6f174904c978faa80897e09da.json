{"sha": "79a6b3def91755d6f174904c978faa80897e09da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhNmIzZGVmOTE3NTVkNmYxNzQ5MDRjOTc4ZmFhODA4OTdlMDlkYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-14T09:09:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-14T09:09:20Z"}, "message": "bb-reorder.c: Remove frequencies from comments.\n\n\n\t* bb-reorder.c: Remove frequencies from comments.\n\t(better_edge_p): Use profile counts.\n\t(find_traces): Dump profile counts.\n\t(rotate_loop): Use profile counts.\n\t(find_traces_1_round): Likewise.\n\t(connect_better_edge_p): Use counts instead of probabilities for\n\treverse walk.\n\t(copy_bb_p): Drop early check for non-0 frequency.\n\t(sanitize_hot_paths): Update comments.\n\nFrom-SVN: r254721", "tree": {"sha": "ba793335cae563ae2ceb4ac350ca398ae7433d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba793335cae563ae2ceb4ac350ca398ae7433d6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a6b3def91755d6f174904c978faa80897e09da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a6b3def91755d6f174904c978faa80897e09da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a6b3def91755d6f174904c978faa80897e09da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a6b3def91755d6f174904c978faa80897e09da/comments", "author": null, "committer": null, "parents": [{"sha": "ed10d09bcc8e7af47896f9ca1f5dbc5fd710929d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed10d09bcc8e7af47896f9ca1f5dbc5fd710929d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed10d09bcc8e7af47896f9ca1f5dbc5fd710929d"}], "stats": {"total": 125, "additions": 76, "deletions": 49}, "files": [{"sha": "dbe4c0550894116bccc22d6f16500d11efb7580c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a6b3def91755d6f174904c978faa80897e09da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a6b3def91755d6f174904c978faa80897e09da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79a6b3def91755d6f174904c978faa80897e09da", "patch": "@@ -1,3 +1,15 @@\n+2017-11-13  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* bb-reorder.c: Remove frequencies from comments.\n+\t(better_edge_p): Use profile counts.\n+\t(find_traces): Dump profile counts.\n+\t(rotate_loop): Use profile counts.\n+\t(find_traces_1_round): Likewise.\n+\t(connect_better_edge_p): Use counts instead of probabilities for\n+\treverse walk.\n+\t(copy_bb_p): Drop early check for non-0 frequency.\n+\t(sanitize_hot_paths): Update comments.\n+\n 2017-11-13  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-split.c (struct split_point): Add count."}, {"sha": "55e6dc647d70e5bd2b0af309949bba3db6a657d3", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a6b3def91755d6f174904c978faa80897e09da/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a6b3def91755d6f174904c978faa80897e09da/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=79a6b3def91755d6f174904c978faa80897e09da", "patch": "@@ -38,7 +38,7 @@\n \n    There are two parameters: Branch Threshold and Exec Threshold.\n    If the probability of an edge to a successor of the current basic block is\n-   lower than Branch Threshold or its frequency is lower than Exec Threshold,\n+   lower than Branch Threshold or its count is lower than Exec Threshold,\n    then the successor will be the seed in one of the next rounds.\n    Each round has these parameters lower than the previous one.\n    The last round has to have these parameters set to zero so that the\n@@ -75,7 +75,7 @@\n    multiple predecessors/ successors during trace discovery.  When connecting\n    traces, only connect Trace n with Trace n + 1.  This change reduces most\n    long jumps compared with the above algorithm.\n-   (2) Ignore the edge probability and frequency for fallthru edges.\n+   (2) Ignore the edge probability and count for fallthru edges.\n    (3) Keep the original order of blocks when there is no chance to fall\n    through.  We rely on the results of cfg_cleanup.\n \n@@ -134,10 +134,10 @@ struct target_bb_reorder *this_target_bb_reorder = &default_target_bb_reorder;\n /* Branch thresholds in thousandths (per mille) of the REG_BR_PROB_BASE.  */\n static const int branch_threshold[N_ROUNDS] = {400, 200, 100, 0, 0};\n \n-/* Exec thresholds in thousandths (per mille) of the frequency of bb 0.  */\n+/* Exec thresholds in thousandths (per mille) of the count of bb 0.  */\n static const int exec_threshold[N_ROUNDS] = {500, 200, 50, 0, 0};\n \n-/* If edge frequency is lower than DUPLICATION_THRESHOLD per mille of entry\n+/* If edge count is lower than DUPLICATION_THRESHOLD per mille of entry\n    block the edge destination is not duplicated while connecting traces.  */\n #define DUPLICATION_THRESHOLD 100\n \n@@ -196,7 +196,7 @@ struct trace\n   int length;\n };\n \n-/* Maximum frequency and count of one of the entry blocks.  */\n+/* Maximum count of one of the entry blocks.  */\n static profile_count max_entry_count;\n \n /* Local function prototypes.  */\n@@ -205,7 +205,8 @@ static void find_traces_1_round (int, profile_count, struct trace *, int *,\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static long bb_to_key (basic_block);\n static bool better_edge_p (const_basic_block, const_edge, profile_probability,\n-\t\t\t   int, profile_probability, int, const_edge);\n+\t\t\t   profile_count, profile_probability, profile_count,\n+\t\t\t   const_edge);\n static bool copy_bb_p (const_basic_block, int);\n \f\n /* Return the trace number in which BB was visited.  */\n@@ -313,10 +314,14 @@ find_traces (int *n_traces, struct trace *traces)\n \t  for (bb = traces[i].first;\n \t       bb != traces[i].last;\n \t       bb = (basic_block) bb->aux)\n-\t    fprintf (dump_file, \"%d [%d] \", bb->index,\n-\t\t     bb->count.to_frequency (cfun));\n-\t  fprintf (dump_file, \"%d [%d]\\n\", bb->index,\n-\t\t   bb->count.to_frequency (cfun));\n+\t    {\n+\t      fprintf (dump_file, \"%d [\", bb->index);\n+\t      bb->count.dump (dump_file);\n+\t      fprintf (dump_file, \"] \");\n+\t    }\n+\t  fprintf (dump_file, \"%d [\", bb->index);\n+\t  bb->count.dump (dump_file);\n+\t  fprintf (dump_file, \"]\\n\");\n \t}\n       fflush (dump_file);\n     }\n@@ -434,7 +439,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \n /* One round of finding traces.  Find traces for BRANCH_TH and EXEC_TH i.e. do\n    not include basic blocks whose probability is lower than BRANCH_TH or whose\n-   frequency is lower than EXEC_TH into traces (or whose count is lower than\n+   count is lower than EXEC_TH into traces (or whose count is lower than\n    COUNT_TH).  Store the new traces into TRACES and modify the number of\n    traces *N_TRACES.  Set the round (which the trace belongs to) to ROUND.\n    The function expects starting basic blocks to be in *HEAP and will delete\n@@ -465,7 +470,7 @@ find_traces_1_round (int branch_th, profile_count count_th,\n       if (dump_file)\n \tfprintf (dump_file, \"Getting bb %d\\n\", bb->index);\n \n-      /* If the BB's frequency is too low, send BB to the next round.  When\n+      /* If the BB's count is too low, send BB to the next round.  When\n \t partitioning hot/cold blocks into separate sections, make sure all\n \t the cold blocks (and ONLY the cold blocks) go into the (extra) final\n \t round.  When optimizing for size, do not push to next round.  */\n@@ -494,13 +499,11 @@ find_traces_1_round (int branch_th, profile_count count_th,\n \n       do\n \t{\n-\t  profile_probability prob;\n-\t  int freq;\n \t  bool ends_in_call;\n \n-\t  /* The probability and frequency of the best edge.  */\n+\t  /* The probability and count of the best edge.  */\n \t  profile_probability best_prob = profile_probability::uninitialized ();\n-\t  int best_freq = INT_MIN / 2;\n+\t  profile_count best_count = profile_count::uninitialized ();\n \n \t  best_edge = NULL;\n \t  mark_bb_visited (bb, *n_traces);\n@@ -529,8 +532,8 @@ find_traces_1_round (int branch_th, profile_count count_th,\n \t      if (BB_PARTITION (e->dest) != BB_PARTITION (bb))\n \t\tcontinue;\n \n-\t      prob = e->probability;\n-\t      freq = e->dest->count.to_frequency (cfun);\n+\t      profile_probability prob = e->probability;\n+\t      profile_count count = e->dest->count;\n \n \t      /* The only sensible preference for a call instruction is the\n \t\t fallthru edge.  Don't bother selecting anything else.  */\n@@ -540,26 +543,26 @@ find_traces_1_round (int branch_th, profile_count count_th,\n \t\t    {\n \t\t      best_edge = e;\n \t\t      best_prob = prob;\n-\t\t      best_freq = freq;\n+\t\t      best_count = count;\n \t\t    }\n \t\t  continue;\n \t\t}\n \n \t      /* Edge that cannot be fallthru or improbable or infrequent\n \t\t successor (i.e. it is unsuitable successor).  When optimizing\n-\t\t for size, ignore the probability and frequency.  */\n+\t\t for size, ignore the probability and count.  */\n \t      if (!(e->flags & EDGE_CAN_FALLTHRU) || (e->flags & EDGE_COMPLEX)\n \t\t  || !prob.initialized_p ()\n \t\t  || ((prob.to_reg_br_prob_base () < branch_th\n \t\t      || e->count () < count_th) && (!for_size)))\n \t\tcontinue;\n \n-\t      if (better_edge_p (bb, e, prob, freq, best_prob, best_freq,\n+\t      if (better_edge_p (bb, e, prob, count, best_prob, best_count,\n \t\t\t\t best_edge))\n \t\t{\n \t\t  best_edge = e;\n \t\t  best_prob = prob;\n-\t\t  best_freq = freq;\n+\t\t  best_count = count;\n \t\t}\n \t    }\n \n@@ -641,7 +644,7 @@ find_traces_1_round (int branch_th, profile_count count_th,\n \t\t{\n \t\t  bb_heap_t *which_heap = *heap;\n \n-\t\t  prob = e->probability;\n+\t\t  profile_probability prob = e->probability;\n \n \t\t  if (!(e->flags & EDGE_CAN_FALLTHRU)\n \t\t      || (e->flags & EDGE_COMPLEX)\n@@ -927,22 +930,21 @@ bb_to_key (basic_block bb)\n \n /* Return true when the edge E from basic block BB is better than the temporary\n    best edge (details are in function).  The probability of edge E is PROB. The\n-   frequency of the successor is FREQ.  The current best probability is\n-   BEST_PROB, the best frequency is BEST_FREQ.\n+   count of the successor is COUNT.  The current best probability is\n+   BEST_PROB, the best count is BEST_COUNT.\n    The edge is considered to be equivalent when PROB does not differ much from\n-   BEST_PROB; similarly for frequency.  */\n+   BEST_PROB; similarly for count.  */\n \n static bool\n better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n-\t       int freq, profile_probability best_prob, int best_freq,\n-\t       const_edge cur_best_edge)\n+\t       profile_count count, profile_probability best_prob,\n+\t       profile_count best_count, const_edge cur_best_edge)\n {\n   bool is_better_edge;\n \n   /* The BEST_* values do not have to be best, but can be a bit smaller than\n      maximum values.  */\n   profile_probability diff_prob = best_prob.apply_scale (1, 10);\n-  int diff_freq = best_freq / 10;\n \n   /* The smaller one is better to keep the original order.  */\n   if (optimize_function_for_size_p (cfun))\n@@ -962,21 +964,27 @@ better_edge_p (const_basic_block bb, const_edge e, profile_probability prob,\n   else if (prob < best_prob - diff_prob)\n     /* The edge has lower probability than the temporary best edge.  */\n     is_better_edge = false;\n-  else if (freq < best_freq - diff_freq)\n-    /* The edge and the temporary best edge  have almost equivalent\n-       probabilities.  The higher frequency of a successor now means\n-       that there is another edge going into that successor.\n-       This successor has lower frequency so it is better.  */\n-    is_better_edge = true;\n-  else if (freq > best_freq + diff_freq)\n-    /* This successor has higher frequency so it is worse.  */\n-    is_better_edge = false;\n-  else if (e->dest->prev_bb == bb)\n-    /* The edges have equivalent probabilities and the successors\n-       have equivalent frequencies.  Select the previous successor.  */\n-    is_better_edge = true;\n   else\n-    is_better_edge = false;\n+    {\n+      profile_count diff_count = best_count.apply_scale (1, 10);\n+      if (count < best_count - diff_count\n+\t  || (!best_count.initialized_p ()\n+\t      && count.nonzero_p ()))\n+\t/* The edge and the temporary best edge  have almost equivalent\n+\t   probabilities.  The higher countuency of a successor now means\n+\t   that there is another edge going into that successor.\n+\t   This successor has lower countuency so it is better.  */\n+\tis_better_edge = true;\n+      else if (count > best_count + diff_count)\n+\t/* This successor has higher countuency so it is worse.  */\n+\tis_better_edge = false;\n+      else if (e->dest->prev_bb == bb)\n+\t/* The edges have equivalent probabilities and the successors\n+\t   have equivalent frequencies.  Select the previous successor.  */\n+\tis_better_edge = true;\n+      else\n+\tis_better_edge = false;\n+    }\n \n   return is_better_edge;\n }\n@@ -1014,6 +1022,16 @@ connect_better_edge_p (const_edge e, bool src_index_p, int best_len,\n     {\n       e_index = e->src->index;\n \n+      /* We are looking for predecessor, so probabilities are not that\n+\t informative.  We do not want to connect A to B becuse A has\n+\t only one sucessor (probablity is 100%) while there is edge\n+\t A' to B where probability is 90% but which is much more frequent.  */\n+      if (e->count () > cur_best_edge->count ())\n+\t/* The edge has higher probability than the temporary best edge.  */\n+\tis_better_edge = true;\n+      else if (e->count () < cur_best_edge->count ())\n+\t/* The edge has lower probability than the temporary best edge.  */\n+\tis_better_edge = false;\n       if (e->probability > cur_best_edge->probability)\n \t/* The edge has higher probability than the temporary best edge.  */\n \tis_better_edge = true;\n@@ -1343,8 +1361,6 @@ copy_bb_p (const_basic_block bb, int code_may_grow)\n   int max_size = uncond_jump_length;\n   rtx_insn *insn;\n \n-  if (!bb->count.to_frequency (cfun))\n-    return false;\n   if (EDGE_COUNT (bb->preds) < 2)\n     return false;\n   if (!can_duplicate_block_p (bb))\n@@ -1508,8 +1524,8 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n             break;\n           }\n           /* The following loop will look for the hottest edge via\n-             the edge count, if it is non-zero, then fallback to the edge\n-             frequency and finally the edge probability.  */\n+             the edge count, if it is non-zero, then fallback to\n+             the edge probability.  */\n           if (!(e->count () > highest_count))\n             highest_count = e->count ();\n           if (!highest_probability.initialized_p ()\n@@ -1534,8 +1550,7 @@ sanitize_hot_paths (bool walk_up, unsigned int cold_bb_count,\n \t      || e->count () == profile_count::zero ())\n \t    continue;\n           /* Select the hottest edge using the edge count, if it is non-zero,\n-             then fallback to the edge frequency and finally the edge\n-             probability.  */\n+             then fallback to the edge probability.  */\n           if (highest_count.initialized_p ())\n             {\n               if (!(e->count () >= highest_count))"}]}