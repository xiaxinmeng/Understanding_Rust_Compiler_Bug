{"sha": "a61a36ab30b7711b5d5cf002d52e6e9514499739", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxYTM2YWIzMGI3NzExYjVkNWNmMDAyZDUyZTZlOTUxNDQ5OTczOQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-06-29T20:38:59Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-06-29T20:38:59Z"}, "message": "re PR fortran/40551 (Optimizations possible using gfc_full_array_ref_p)\n\n2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40551\n\t* dependency.h : Add second bool* argument to prototype of\n\tgfc_full_array_ref_p.\n\t* dependency.c (gfc_full_array_ref_p): If second argument is\n\tpresent, return true if last dimension of reference is an\n\telement or has unity stride.\n\t* trans-array.c : Add NULL second argument to references to\n\tgfc_full_array_ref_p.\n\t* trans-expr.c : The same, except for;\n\t(gfc_trans_arrayfunc_assign): Return fail if lhs reference\n\tis not a full array or a contiguous section.\n\n2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40551\n\t* gfortran.dg/func_assign_2.f90 : New test.\n\nFrom-SVN: r149062", "tree": {"sha": "aca49e7453dd7b8e481ea5b320d8145f0bddc97c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aca49e7453dd7b8e481ea5b320d8145f0bddc97c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61a36ab30b7711b5d5cf002d52e6e9514499739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61a36ab30b7711b5d5cf002d52e6e9514499739", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61a36ab30b7711b5d5cf002d52e6e9514499739", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61a36ab30b7711b5d5cf002d52e6e9514499739/comments", "author": null, "committer": null, "parents": [{"sha": "96da806615b899b591da751f4bdd3b7507bfdc89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96da806615b899b591da751f4bdd3b7507bfdc89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96da806615b899b591da751f4bdd3b7507bfdc89"}], "stats": {"total": 94, "additions": 83, "deletions": 11}, "files": [{"sha": "976a448a3b186ad6a8a027a59f2fbadf316d0bdc", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -1,3 +1,17 @@\n+2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40551\n+\t* dependency.h : Add second bool* argument to prototype of\n+\tgfc_full_array_ref_p.\n+\t* dependency.c (gfc_full_array_ref_p): If second argument is\n+\tpresent, return true if last dimension of reference is an\n+\telement or has unity stride.\n+\t* trans-array.c : Add NULL second argument to references to\n+\tgfc_full_array_ref_p.\n+\t* trans-expr.c : The same, except for;\n+\t(gfc_trans_arrayfunc_assign): Return fail if lhs reference\n+\tis not a full array or a contiguous section.\n+\n 2009-06-28  Tobias Burnus  <burnus@net-b.de>\n \t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n "}, {"sha": "eb07e7c5db6325727543082fb52488625e48a13d", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -1186,12 +1186,16 @@ gfc_check_element_vs_element (gfc_ref *lref, gfc_ref *rref, int n)\n \n \n /* Determine if an array ref, usually an array section specifies the\n-   entire array.  */\n+   entire array.  In addition, if the second, pointer argument is\n+   provided, the function will return true if the reference is\n+   contiguous; eg. (:, 1) gives true but (1,:) gives false.  */\n \n bool\n-gfc_full_array_ref_p (gfc_ref *ref)\n+gfc_full_array_ref_p (gfc_ref *ref, bool *contiguous)\n {\n   int i;\n+  bool lbound_OK = true;\n+  bool ubound_OK = true;\n \n   if (ref->type != REF_ARRAY)\n     return false;\n@@ -1209,6 +1213,10 @@ gfc_full_array_ref_p (gfc_ref *ref)\n \t the correct element.  */\n       if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT)\n \t{\n+\t  /* This is a contiguous reference.  */\n+\t  if (contiguous)\n+\t    *contiguous = (i + 1 == ref->u.ar.dimen);\n+\n \t  if (!ref->u.ar.as\n \t      || !ref->u.ar.as->lower[i]\n \t      || !ref->u.ar.as->upper[i]\n@@ -1228,17 +1236,24 @@ gfc_full_array_ref_p (gfc_ref *ref)\n \t      || !ref->u.ar.as->lower[i]\n \t      || gfc_dep_compare_expr (ref->u.ar.start[i],\n \t\t\t\t       ref->u.ar.as->lower[i])))\n-\treturn false;\n+\tlbound_OK = false;\n       /* Check the upper bound.  */\n       if (ref->u.ar.end[i]\n \t  && (!ref->u.ar.as\n \t      || !ref->u.ar.as->upper[i]\n \t      || gfc_dep_compare_expr (ref->u.ar.end[i],\n \t\t\t\t       ref->u.ar.as->upper[i])))\n-\treturn false;\n+\tubound_OK = false;\n       /* Check the stride.  */\n       if (ref->u.ar.stride[i] && !gfc_expr_is_one (ref->u.ar.stride[i], 0))\n \treturn false;\n+\n+      /* This is a contiguous reference.  */\n+      if (contiguous)\n+\t*contiguous = (i + 1 == ref->u.ar.dimen);\n+\n+      if (!lbound_OK || !ubound_OK)\n+\treturn false;\n     }\n   return true;\n }\n@@ -1356,11 +1371,11 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \t  if (lref->u.ar.dimen != rref->u.ar.dimen)\n \t    {\n \t      if (lref->u.ar.type == AR_FULL)\n-\t\tfin_dep = gfc_full_array_ref_p (rref) ? GFC_DEP_EQUAL\n-\t\t\t\t\t\t      : GFC_DEP_OVERLAP;\n+\t\tfin_dep = gfc_full_array_ref_p (rref, NULL) ? GFC_DEP_EQUAL\n+\t\t\t\t\t\t\t    : GFC_DEP_OVERLAP;\n \t      else if (rref->u.ar.type == AR_FULL)\n-\t\tfin_dep = gfc_full_array_ref_p (lref) ? GFC_DEP_EQUAL\n-\t\t\t\t\t\t      : GFC_DEP_OVERLAP;\n+\t\tfin_dep = gfc_full_array_ref_p (lref, NULL) ? GFC_DEP_EQUAL\n+\t\t\t\t\t\t\t    : GFC_DEP_OVERLAP;\n \t      else\n \t\treturn 1;\n \t      break;"}, {"sha": "6fa0416e2a7c11bf81bda1894fe8f331e31a1404", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -33,7 +33,7 @@ gfc_dep_check;\n /*********************** Functions prototypes **************************/\n \n bool gfc_ref_needs_temporary_p (gfc_ref *);\n-bool gfc_full_array_ref_p (gfc_ref *);\n+bool gfc_full_array_ref_p (gfc_ref *, bool *);\n gfc_expr *gfc_get_noncopying_intrinsic_argument (gfc_expr *);\n int gfc_check_fncall_dependency (gfc_expr *, sym_intent, gfc_symbol *,\n \t\t\t\t gfc_actual_arglist *, gfc_dep_check);"}, {"sha": "ce9114f250cad2f97189920fd3dc64bfa26018b9", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -5008,7 +5008,7 @@ gfc_conv_expr_descriptor (gfc_se * se, gfc_expr * expr, gfc_ss * ss)\n       else if (se->direct_byref)\n \tfull = 0;\n       else\n-\tfull = gfc_full_array_ref_p (info->ref);\n+\tfull = gfc_full_array_ref_p (info->ref, NULL);\n \n       if (full)\n \t{"}, {"sha": "6a38f10f6568214c1aa56e43bd3e38f83c6e3a69", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -4300,6 +4300,7 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n   gfc_ss *ss;\n   gfc_ref * ref;\n   bool seen_array_ref;\n+  bool c = false;\n   gfc_component *comp = NULL;\n \n   /* The caller has already checked rank>0 and expr_type == EXPR_FUNCTION.  */\n@@ -4311,6 +4312,10 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n       && expr2->value.function.esym->attr.elemental)\n     return NULL;\n \n+  /* Fail if rhs is not FULL or a contiguous section.  */\n+  if (expr1->ref && !(gfc_full_array_ref_p (expr1->ref, &c) || c))\n+    return NULL;\n+\n   /* Fail if EXPR1 can't be expressed as a descriptor.  */\n   if (gfc_ref_needs_temporary_p (expr1->ref))\n     return NULL;\n@@ -4785,7 +4790,7 @@ copyable_array_p (gfc_expr * expr)\n   if (expr->rank < 1 || !expr->ref || expr->ref->next)\n     return false;\n \n-  if (!gfc_full_array_ref_p (expr->ref))\n+  if (!gfc_full_array_ref_p (expr->ref, NULL))\n     return false;\n \n   /* Next check that it's of a simple enough type.  */"}, {"sha": "d8ed7cb2090c3e4902aaedb583c5032e81897a5b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -1,3 +1,8 @@\n+2009-06-29  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40551\n+\t* gfortran.dg/func_assign_2.f90 : New test.\n+\n 2009-06-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/14187"}, {"sha": "e308375ef9da3c9143cfa70d21983268f13a8a3f", "filename": "gcc/testsuite/gfortran.dg/func_assign_2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_assign_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61a36ab30b7711b5d5cf002d52e6e9514499739/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_assign_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunc_assign_2.f90?ref=a61a36ab30b7711b5d5cf002d52e6e9514499739", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do run }\n+! Test the fix for PR40551 in which the assignment\n+! was not dealing correctly with non-contiguous lhs\n+! references; eg. a(1,:)\n+!\n+! Reported by by Maciej Zwierzycki\n+! at http://gcc.gnu.org/ml/fortran/2009-06/msg00254.html\n+! and by Tobias Burnus <burnus@gcc.gnu.org> on Bugzilla\n+!\n+integer :: a(2,2)\n+a = -42\n+a(1,:) = func()\n+if (any (reshape (a, [4]) /= [1, -42, 2, -42])) call abort \n+a = -42\n+a(2,:) = func()\n+if (any (reshape (a, [4]) /= [-42, 1, -42, 2])) call abort \n+a = -42\n+a(:,1) = func()\n+if (any (reshape (a, [4]) /= [1, 2, -42, -42])) call abort \n+a = -42\n+a(:,2) = func()\n+if (any (reshape (a, [4]) /= [-42, -42, 1, 2])) call abort \n+contains\n+ function func()\n+   integer :: func(2)\n+   call sub(func)\n+ end function func\n+ subroutine sub(a)\n+   integer :: a(2)\n+   a = [1,2]\n+ end subroutine\n+end\n+"}]}