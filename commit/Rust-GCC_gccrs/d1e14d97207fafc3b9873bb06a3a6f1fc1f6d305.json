{"sha": "d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlMTRkOTcyMDdmYWZjM2I5ODczYmIwNmEzYTZmMWZjMWY2ZDMwNQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2018-10-22T13:54:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-22T13:54:23Z"}, "message": "re PR middle-end/63155 (memory hog)\n\n2018-10-22  Steven Bosscher <steven@gcc.gnu.org>\n\tRichard Biener  <rguenther@suse.de>\n\n\t* bitmap.h: Update data structure documentation, including a\n\tdescription of bitmap views as either linked-lists or splay trees.\n\t(struct bitmap_element_def): Update comments for splay tree bitmaps.\n\t(struct bitmap_head_def): Likewise.\n\t(bitmap_list_view, bitmap_tree_view): New prototypes.\n\t(bitmap_initialize_stat): Initialize a bitmap_head's indx and\n\ttree_form fields.\n\t(bmp_iter_set_init): Assert the iterated bitmaps are in list form.\n\t(bmp_iter_and_init, bmp_iter_and_compl_init): Likewise.\n\t* bitmap.c (bitmap_elem_to_freelist): Unregister overhead of a\n\treleased bitmap element here.\n\t(bitmap_element_free): Remove.\n\t(bitmap_elt_clear_from): Work on splay tree bitmaps.\n\t(bitmap_list_link_element): Renamed from bitmap_element_link.  Move\n\tthis function similar ones such that linked-list bitmap implementation\n\tfunctions are grouped.\n\t(bitmap_list_unlink_element): Renamed from bitmap_element_unlink,\n\tand moved for grouping.\n\t(bitmap_list_insert_element_after): Renamed from\n\tbitmap_elt_insert_after, and moved for grouping.\n\t(bitmap_list_find_element): New function spliced from bitmap_find_bit.\n\t(bitmap_tree_link_left, bitmap_tree_link_right,\n\tbitmap_tree_rotate_left, bitmap_tree_rotate_right, bitmap_tree_splay,\n\tbitmap_tree_link_element, bitmap_tree_unlink_element,\n\tbitmap_tree_find_element): New functions for splay-tree bitmap\n\timplementation.\n\t(bitmap_element_link, bitmap_element_unlink, bitmap_elt_insert_after):\n\tRenamed and moved, see above entries.\n\t(bitmap_tree_listify_from): New function to convert part of a splay\n\ttree bitmap to a linked-list bitmap.\n\t(bitmap_list_view): Convert a splay tree bitmap to linked-list form.\n\t(bitmap_tree_view): Convert a linked-list bitmap to splay tree form.\n\t(bitmap_find_bit): Remove.\n\t(bitmap_clear, bitmap_clear_bit, bitmap_set_bit,\n\tbitmap_single_bit_set_p, bitmap_first_set_bit, bitmap_last_set_bit):\n\tHandle splay tree bitmaps.\n\t(bitmap_copy, bitmap_count_bits, bitmap_and, bitmap_and_into,\n\tbitmap_elt_copy, bitmap_and_compl, bitmap_and_compl_into,\n\tbitmap_compl_and_into, bitmap_elt_ior, bitmap_ior, bitmap_ior_into,\n\tbitmap_xor, bitmap_xor_into, bitmap_equal_p, bitmap_intersect_p,\n\tbitmap_intersect_compl_p, bitmap_ior_and_compl,\n\tbitmap_ior_and_compl_into, bitmap_set_range, bitmap_clear_range,\n\tbitmap_hash): Reject trying to act on splay tree bitmaps.  Make\n\tcorresponding changes to use linked-list specific bitmap_element\n\tmanipulation functions as applicable for efficiency.\n\t(bitmap_tree_to_vec): New function.\n\t(debug_bitmap_elt_file): New function split out from ...\n\t(debug_bitmap_file): ... here.  Handle splay tree bitmaps.\n\t(bitmap_print): Likewise.\n\n\tPR tree-optimization/63155\n\t* tree-ssa-propagate.c (ssa_prop_init): Use tree-view for the\n\tSSA edge worklists.\n\t* tree-ssa-coalesce.c (coalesce_ssa_name): Populate used_in_copies\n\tin tree-view.\n\nFrom-SVN: r265390", "tree": {"sha": "65b4e3557263726e01defd72ac797144469cbc27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b4e3557263726e01defd72ac797144469cbc27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/comments", "author": null, "committer": null, "parents": [{"sha": "ddec5aea567a131daf0c5741d676d6f4a68ca45d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddec5aea567a131daf0c5741d676d6f4a68ca45d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddec5aea567a131daf0c5741d676d6f4a68ca45d"}], "stats": {"total": 1323, "additions": 969, "deletions": 354}, "files": [{"sha": "54f36a1278df73739cdd4ffc16d819ae2d8010b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "patch": "@@ -1,6 +1,65 @@\n+2018-10-22  Steven Bosscher <steven@gcc.gnu.org>\n+\tRichard Biener  <rguenther@suse.de>\n+\n+\t* bitmap.h: Update data structure documentation, including a\n+\tdescription of bitmap views as either linked-lists or splay trees.\n+\t(struct bitmap_element_def): Update comments for splay tree bitmaps.\n+\t(struct bitmap_head_def): Likewise.\n+\t(bitmap_list_view, bitmap_tree_view): New prototypes.\n+\t(bitmap_initialize_stat): Initialize a bitmap_head's indx and\n+\ttree_form fields.\n+\t(bmp_iter_set_init): Assert the iterated bitmaps are in list form.\n+\t(bmp_iter_and_init, bmp_iter_and_compl_init): Likewise.\n+\t* bitmap.c (bitmap_elem_to_freelist): Unregister overhead of a\n+\treleased bitmap element here.\n+\t(bitmap_element_free): Remove.\n+\t(bitmap_elt_clear_from): Work on splay tree bitmaps.\n+\t(bitmap_list_link_element): Renamed from bitmap_element_link.  Move\n+\tthis function similar ones such that linked-list bitmap implementation\n+\tfunctions are grouped.\n+\t(bitmap_list_unlink_element): Renamed from bitmap_element_unlink,\n+\tand moved for grouping.\n+\t(bitmap_list_insert_element_after): Renamed from\n+\tbitmap_elt_insert_after, and moved for grouping.\n+\t(bitmap_list_find_element): New function spliced from bitmap_find_bit.\n+\t(bitmap_tree_link_left, bitmap_tree_link_right,\n+\tbitmap_tree_rotate_left, bitmap_tree_rotate_right, bitmap_tree_splay,\n+\tbitmap_tree_link_element, bitmap_tree_unlink_element,\n+\tbitmap_tree_find_element): New functions for splay-tree bitmap\n+\timplementation.\n+\t(bitmap_element_link, bitmap_element_unlink, bitmap_elt_insert_after):\n+\tRenamed and moved, see above entries.\n+\t(bitmap_tree_listify_from): New function to convert part of a splay\n+\ttree bitmap to a linked-list bitmap.\n+\t(bitmap_list_view): Convert a splay tree bitmap to linked-list form.\n+\t(bitmap_tree_view): Convert a linked-list bitmap to splay tree form.\n+\t(bitmap_find_bit): Remove.\n+\t(bitmap_clear, bitmap_clear_bit, bitmap_set_bit,\n+\tbitmap_single_bit_set_p, bitmap_first_set_bit, bitmap_last_set_bit):\n+\tHandle splay tree bitmaps.\n+\t(bitmap_copy, bitmap_count_bits, bitmap_and, bitmap_and_into,\n+\tbitmap_elt_copy, bitmap_and_compl, bitmap_and_compl_into,\n+\tbitmap_compl_and_into, bitmap_elt_ior, bitmap_ior, bitmap_ior_into,\n+\tbitmap_xor, bitmap_xor_into, bitmap_equal_p, bitmap_intersect_p,\n+\tbitmap_intersect_compl_p, bitmap_ior_and_compl,\n+\tbitmap_ior_and_compl_into, bitmap_set_range, bitmap_clear_range,\n+\tbitmap_hash): Reject trying to act on splay tree bitmaps.  Make\n+\tcorresponding changes to use linked-list specific bitmap_element\n+\tmanipulation functions as applicable for efficiency.\n+\t(bitmap_tree_to_vec): New function.\n+\t(debug_bitmap_elt_file): New function split out from ...\n+\t(debug_bitmap_file): ... here.  Handle splay tree bitmaps.\n+\t(bitmap_print): Likewise.\n+\n+\tPR tree-optimization/63155\n+\t* tree-ssa-propagate.c (ssa_prop_init): Use tree-view for the\n+\tSSA edge worklists.\n+\t* tree-ssa-coalesce.c (coalesce_ssa_name): Populate used_in_copies\n+\tin tree-view.\n+\n 2018-10-22  Martin Liska  <mliska@suse.cz>\n \n-  PR tree-optimization/87686\n+\tPR tree-optimization/87686\n \tRevert\n \t2018-08-29  Martin Liska  <mliska@suse.cz>\n "}, {"sha": "c3880ebd81c47037b134556e19e180ea8b5fe7ab", "filename": "gcc/bitmap.c", "status": "modified", "additions": 735, "deletions": 285, "changes": 1020, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "patch": "@@ -26,6 +26,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Memory allocation statistics purpose instance.  */\n mem_alloc_description<bitmap_usage> bitmap_mem_desc;\n \n+static bitmap_element *bitmap_tree_listify_from (bitmap, bitmap_element *);\n+\n /* Register new bitmap.  */\n void\n bitmap_register (bitmap b MEM_STAT_DECL)\n@@ -49,22 +51,18 @@ static int bitmap_default_obstack_depth;\n static GTY((deletable)) bitmap_element *bitmap_ggc_free; /* Freelist of\n \t\t\t\t\t\t\t    GC'd elements.  */\n \n-static void bitmap_elem_to_freelist (bitmap, bitmap_element *);\n-static void bitmap_element_free (bitmap, bitmap_element *);\n-static bitmap_element *bitmap_element_allocate (bitmap);\n-static int bitmap_element_zerop (const bitmap_element *);\n-static void bitmap_element_link (bitmap, bitmap_element *);\n-static bitmap_element *bitmap_elt_insert_after (bitmap, bitmap_element *, unsigned int);\n-static void bitmap_elt_clear_from (bitmap, bitmap_element *);\n-static bitmap_element *bitmap_find_bit (bitmap, unsigned int);\n \f\n+/* Bitmap memory management.  */\n \n-/* Add ELEM to the appropriate freelist.  */\n+/* Add ELT to the appropriate freelist.  */\n static inline void\n bitmap_elem_to_freelist (bitmap head, bitmap_element *elt)\n {\n   bitmap_obstack *bit_obstack = head->obstack;\n \n+  if (GATHER_STATISTICS)\n+    register_overhead (head, -((int)sizeof (bitmap_element)));\n+\n   elt->next = NULL;\n   elt->indx = -1;\n   if (bit_obstack)\n@@ -79,41 +77,6 @@ bitmap_elem_to_freelist (bitmap head, bitmap_element *elt)\n     }\n }\n \n-/* Free a bitmap element.  Since these are allocated off the\n-   bitmap_obstack, \"free\" actually means \"put onto the freelist\".  */\n-\n-static inline void\n-bitmap_element_free (bitmap head, bitmap_element *elt)\n-{\n-  bitmap_element *next = elt->next;\n-  bitmap_element *prev = elt->prev;\n-\n-  if (prev)\n-    prev->next = next;\n-\n-  if (next)\n-    next->prev = prev;\n-\n-  if (head->first == elt)\n-    head->first = next;\n-\n-  /* Since the first thing we try is to insert before current,\n-     make current the next entry in preference to the previous.  */\n-  if (head->current == elt)\n-    {\n-      head->current = next != 0 ? next : prev;\n-      if (head->current)\n-\thead->indx = head->current->indx;\n-      else\n-\thead->indx = 0;\n-    }\n-\n-  if (GATHER_STATISTICS)\n-    register_overhead (head, -((int)sizeof (bitmap_element)));\n-\n-  bitmap_elem_to_freelist (head, elt);\n-}\n-\f\n /* Allocate a bitmap element.  The bits are cleared, but nothing else is.  */\n \n static inline bitmap_element *\n@@ -166,15 +129,20 @@ bitmap_element_allocate (bitmap head)\n   return element;\n }\n \n-/* Remove ELT and all following elements from bitmap HEAD.  */\n+/* Remove ELT and all following elements from bitmap HEAD.\n+   Put the released elements in the freelist for HEAD.  */\n \n void\n bitmap_elt_clear_from (bitmap head, bitmap_element *elt)\n {\n   bitmap_element *prev;\n   bitmap_obstack *bit_obstack = head->obstack;\n \n-  if (!elt) return;\n+  if (!elt)\n+    return;\n+\n+  if (head->tree_form)\n+    elt = bitmap_tree_listify_from (head, elt);\n \n   if (GATHER_STATISTICS)\n     {\n@@ -201,26 +169,533 @@ bitmap_elt_clear_from (bitmap head, bitmap_element *elt)\n       head->indx = 0;\n     }\n \n-  /* Put the entire list onto the free list in one operation. */\n+  /* Put the entire list onto the freelist in one operation. */\n   if (bit_obstack)\n     {\n       elt->prev = bit_obstack->elements;\n       bit_obstack->elements = elt;\n     }\n   else\n     {\n-      elt->prev = bitmap_ggc_free;\n-      bitmap_ggc_free = elt;\n+      elt->prev = bitmap_ggc_free;\n+      bitmap_ggc_free = elt;\n+    }\n+}\n+\f\n+/* Linked-list view of bitmaps.\n+\n+   In this representation, the bitmap elements form a double-linked list\n+   with elements sorted by increasing index.  */\n+\n+/* Link the bitmap element into the current bitmap linked list.  */\n+\n+static inline void\n+bitmap_list_link_element (bitmap head, bitmap_element *element)\n+{\n+  unsigned int indx = element->indx;\n+  bitmap_element *ptr;\n+\n+  gcc_checking_assert (!head->tree_form);\n+\n+  /* If this is the first and only element, set it in.  */\n+  if (head->first == 0)\n+    {\n+      element->next = element->prev = 0;\n+      head->first = element;\n+    }\n+\n+  /* If this index is less than that of the current element, it goes someplace\n+     before the current element.  */\n+  else if (indx < head->indx)\n+    {\n+      for (ptr = head->current;\n+\t   ptr->prev != 0 && ptr->prev->indx > indx;\n+\t   ptr = ptr->prev)\n+\t;\n+\n+      if (ptr->prev)\n+\tptr->prev->next = element;\n+      else\n+\thead->first = element;\n+\n+      element->prev = ptr->prev;\n+      element->next = ptr;\n+      ptr->prev = element;\n+    }\n+\n+  /* Otherwise, it must go someplace after the current element.  */\n+  else\n+    {\n+      for (ptr = head->current;\n+\t   ptr->next != 0 && ptr->next->indx < indx;\n+\t   ptr = ptr->next)\n+\t;\n+\n+      if (ptr->next)\n+\tptr->next->prev = element;\n+\n+      element->next = ptr->next;\n+      element->prev = ptr;\n+      ptr->next = element;\n+    }\n+\n+  /* Set up so this is the first element searched.  */\n+  head->current = element;\n+  head->indx = indx;\n+}\n+\n+/* Unlink the bitmap element from the current bitmap linked list,\n+   and return it to the freelist.  */\n+\n+static inline void\n+bitmap_list_unlink_element (bitmap head, bitmap_element *element)\n+{\n+  bitmap_element *next = element->next;\n+  bitmap_element *prev = element->prev;\n+\n+  gcc_checking_assert (!head->tree_form);\n+\n+  if (prev)\n+    prev->next = next;\n+\n+  if (next)\n+    next->prev = prev;\n+\n+  if (head->first == element)\n+    head->first = next;\n+\n+  /* Since the first thing we try is to insert before current,\n+     make current the next entry in preference to the previous.  */\n+  if (head->current == element)\n+    {\n+      head->current = next != 0 ? next : prev;\n+      if (head->current)\n+\thead->indx = head->current->indx;\n+      else\n+\thead->indx = 0;\n+    }\n+\n+  bitmap_elem_to_freelist (head, element);\n+}\n+\n+/* Insert a new uninitialized element into bitmap HEAD after element\n+   ELT.  If ELT is NULL, insert the element at the start.  Return the\n+   new element.  */\n+\n+static bitmap_element *\n+bitmap_list_insert_element_after (bitmap head,\n+\t\t\t\t  bitmap_element *elt, unsigned int indx)\n+{\n+  bitmap_element *node = bitmap_element_allocate (head);\n+  node->indx = indx;\n+\n+  gcc_checking_assert (!head->tree_form);\n+\n+  if (!elt)\n+    {\n+      if (!head->current)\n+\t{\n+\t  head->current = node;\n+\t  head->indx = indx;\n+\t}\n+      node->next = head->first;\n+      if (node->next)\n+\tnode->next->prev = node;\n+      head->first = node;\n+      node->prev = NULL;\n+    }\n+  else\n+    {\n+      gcc_checking_assert (head->current);\n+      node->next = elt->next;\n+      if (node->next)\n+\tnode->next->prev = node;\n+      elt->next = node;\n+      node->prev = elt;\n+    }\n+  return node;\n+}\n+\n+/* Return the element for INDX, or NULL if the element doesn't exist.\n+   Update the `current' field even if we can't find an element that  \n+   would hold the bitmap's bit to make eventual allocation\n+   faster.  */\n+\n+static inline bitmap_element *\n+bitmap_list_find_element (bitmap head, unsigned int indx)\n+{\n+  bitmap_element *element;\n+\n+  if (head->current == NULL\n+      || head->indx == indx)\n+    return head->current;\n+\n+  if (head->current == head->first\n+      && head->first->next == NULL)\n+    return NULL;\n+\n+  /* Usage can be NULL due to allocated bitmaps for which we do not\n+     call initialize function.  */\n+  bitmap_usage *usage = NULL;\n+  if (GATHER_STATISTICS)\n+    usage = bitmap_mem_desc.get_descriptor_for_instance (head);\n+\n+  /* This bitmap has more than one element, and we're going to look\n+     through the elements list.  Count that as a search.  */\n+  if (GATHER_STATISTICS && usage)\n+    usage->m_nsearches++;\n+\n+  if (head->indx < indx)\n+    /* INDX is beyond head->indx.  Search from head->current\n+       forward.  */\n+    for (element = head->current;\n+\t element->next != 0 && element->indx < indx;\n+\t element = element->next)\n+      {\n+\tif (GATHER_STATISTICS && usage)\n+\t  usage->m_search_iter++;\n+      }\n+\n+  else if (head->indx / 2 < indx)\n+    /* INDX is less than head->indx and closer to head->indx than to\n+       0.  Search from head->current backward.  */\n+    for (element = head->current;\n+\t element->prev != 0 && element->indx > indx;\n+\t element = element->prev)\n+      {\n+\tif (GATHER_STATISTICS && usage)\n+\t  usage->m_search_iter++;\n+      }\n+\n+  else\n+    /* INDX is less than head->indx and closer to 0 than to\n+       head->indx.  Search from head->first forward.  */\n+    for (element = head->first;\n+\t element->next != 0 && element->indx < indx;\n+\t element = element->next)\n+      {\n+\tif (GATHER_STATISTICS && usage)\n+\t  usage->m_search_iter++;\n+      }\n+\n+  /* `element' is the nearest to the one we want.  If it's not the one we\n+     want, the one we want doesn't exist.  */\n+  gcc_checking_assert (element != NULL);\n+  head->current = element;\n+  head->indx = element->indx;\n+  if (element->indx != indx)\n+    element = 0;\n+  return element;\n+}\n+\n+\f\n+/* Splay-tree view of bitmaps.\n+\n+   This is an almost one-to-one the implementatin of the simple top-down\n+   splay tree in Sleator and Tarjan's \"Self-adjusting Binary Search Trees\".\n+   It is probably not the most efficient form of splay trees, but it should\n+   be good enough to experiment with this idea of bitmaps-as-trees.\n+   \n+   For all functions below, the variable or function argument \"t\" is a node\n+   in the tree, and \"e\" is a temporary or new node in the tree.  The rest\n+   is sufficiently straigh-forward (and very well explained in the paper)\n+   that comment would only clutter things.  */\n+\n+static inline void\n+bitmap_tree_link_left (bitmap_element * &t, bitmap_element * &l)\n+{\n+  l->next = t;\n+  l = t;\n+  t = t->next;\n+}\n+\n+static inline void\n+bitmap_tree_link_right (bitmap_element * &t, bitmap_element * &r)\n+{\n+  r->prev = t;\n+  r = t;\n+  t = t->prev;\n+}\n+\n+static inline void\n+bitmap_tree_rotate_left (bitmap_element * &t)\n+{\n+  bitmap_element *e = t->next;\n+  t->next = t->next->prev;\n+  e->prev = t;\n+  t = e;\n+}\n+\n+static inline void\n+bitmap_tree_rotate_right (bitmap_element * &t)\n+{\n+  bitmap_element *e = t->prev;\n+  t->prev = t->prev->next;\n+  e->next = t;\n+  t = e;\n+}\n+\n+static bitmap_element *\n+bitmap_tree_splay (bitmap head, bitmap_element *t, unsigned int indx)\n+{\n+  bitmap_element N, *l, *r;\n+\n+  if (t == NULL)\n+    return NULL;\n+\n+  bitmap_usage *usage = NULL;\n+  if (GATHER_STATISTICS)\n+    usage = bitmap_mem_desc.get_descriptor_for_instance (head);\n+\n+  N.prev = N.next = NULL;\n+  l = r = &N;\n+\n+  while (indx != t->indx)\n+    {\n+      if (GATHER_STATISTICS && usage)\n+\tusage->m_search_iter++;\n+\n+      if (indx < t->indx)\n+\t{\n+\t  if (t->prev != NULL && indx < t->prev->indx)\n+\t    bitmap_tree_rotate_right (t);\n+\t  if (t->prev == NULL)\n+\t    break;\n+\t  bitmap_tree_link_right (t, r);\n+\t}\n+      else if (indx > t->indx)\n+\t{\n+\t  if (t->next != NULL && indx > t->next->indx)\n+\t    bitmap_tree_rotate_left (t);\n+\t  if (t->next == NULL)\n+\t    break;\n+\t  bitmap_tree_link_left (t, l);\n+\t}\n+    }\n+\n+  l->next = t->prev;\n+  r->prev = t->next;\n+  t->prev = N.next;\n+  t->next = N.prev;\n+  return t;\n+}\n+\n+/* Link bitmap element E into the current bitmap splay tree.  */\n+\n+static inline void\n+bitmap_tree_link_element (bitmap head, bitmap_element *e)\n+{\n+  if (head->first == NULL)\n+    e->prev = e->next = NULL;\n+  else\n+    {\n+      bitmap_element *t = bitmap_tree_splay (head, head->first, e->indx);\n+      if (e->indx < t->indx)\n+\t{\n+\t  e->prev = t->prev;\n+\t  e->next = t;\n+\t  t->prev = NULL;\n+\t}\n+      else if (e->indx > t->indx)\n+\t{\n+\t  e->next = t->next;\n+\t  e->prev = t;\n+\t  t->next = NULL;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+  head->first = e;\n+  head->current = e;\n+  head->indx = e->indx;\n+}\n+\n+/* Unlink bitmap element E from the current bitmap splay tree,\n+   and return it to the freelist.  */\n+\n+static void\n+bitmap_tree_unlink_element (bitmap head, bitmap_element *e)\n+{\n+  bitmap_element *t = bitmap_tree_splay (head, head->first, e->indx);\n+\n+  gcc_checking_assert (t == e);\n+\n+  if (e->prev == NULL)\n+    t = e->next;\n+  else\n+    {\n+      t = bitmap_tree_splay (head, e->prev, e->indx);\n+      t->next = e->next;\n+    }\n+  head->first = t;\n+  head->current = t;\n+  head->indx = (t != NULL) ? t->indx : 0;\n+\n+  bitmap_elem_to_freelist (head, e);\n+}\n+\n+/* Return the element for INDX, or NULL if the element doesn't exist.  */\n+\n+static inline bitmap_element *\n+bitmap_tree_find_element (bitmap head, unsigned int indx)\n+{\n+  if (head->current == NULL\n+      || head->indx == indx)\n+    return head->current;\n+\n+  /* Usage can be NULL due to allocated bitmaps for which we do not\n+     call initialize function.  */\n+  bitmap_usage *usage = NULL;\n+  if (GATHER_STATISTICS)\n+    usage = bitmap_mem_desc.get_descriptor_for_instance (head);\n+\n+  /* This bitmap has more than one element, and we're going to look\n+     through the elements list.  Count that as a search.  */\n+  if (GATHER_STATISTICS && usage)\n+    usage->m_nsearches++;\n+\n+  bitmap_element *element = bitmap_tree_splay (head, head->first, indx);\n+  gcc_checking_assert (element != NULL);\n+  head->first = element;\n+  head->current = element;\n+  head->indx = element->indx;\n+  if (element->indx != indx)\n+    element = 0;\n+  return element;\n+}\n+\f\n+/* Converting bitmap views from linked-list to tree and vice versa.  */\n+\n+/* Splice element E and all elements with a larger index from\n+   bitmap HEAD, convert the spliced elements to the linked-list\n+   view, and return the head of the list (which should be E again),  */\n+\n+static bitmap_element *\n+bitmap_tree_listify_from (bitmap head, bitmap_element *e)\n+{\n+  bitmap_element *t, *erb;\n+\n+  /* Detach the right branch from E (all elements with indx > E->indx),\n+     and splay E to the root.  */\n+  erb = e->next;\n+  e->next = NULL;\n+  t = bitmap_tree_splay (head, head->first, e->indx);\n+  gcc_checking_assert (t == e);\n+\n+  /* Because E has no right branch, and we rotated it to the root,\n+     the left branch is the new root.  */\n+  t = e->prev;\n+  head->first = t;\n+  head->current = t;\n+  head->indx = (t != NULL) ? t->indx : 0;\n+\n+  /* Detach the tree from E, and re-attach the right branch of E.  */\n+  e->prev = NULL;\n+  e->next = erb;\n+\n+  /* The tree is now valid again.  Now we need to \"un-tree\" E.\n+     It is imperative that a non-recursive implementation is used\n+     for this, because splay trees have a worst case depth of O(N)\n+     for a tree with N nodes.  A recursive implementation could\n+     result in a stack overflow for a sufficiently large, unbalanced\n+     bitmap tree.  */\n+\n+  auto_vec<bitmap_element *, 32> stack;\n+  auto_vec<bitmap_element *, 32> sorted_elements;\n+  bitmap_element *n = e;\n+\n+  while (true)\n+    {\n+      while (n != NULL)\n+\t{\n+\t  stack.safe_push (n);\n+\t  n = n->prev;\n+\t}\n+\n+      if (stack.is_empty ())\n+\tbreak;\n+\n+      n = stack.pop ();\n+      sorted_elements.safe_push (n);\n+      n = n->next;\n+    }\n+\n+  gcc_assert (sorted_elements[0] == e);\n+\n+  bitmap_element *prev = NULL;\n+  unsigned ix;\n+  FOR_EACH_VEC_ELT (sorted_elements, ix, n)\n+    {\n+      if (prev != NULL)\n+        prev->next = n;\n+      n->prev = prev;\n+      n->next = NULL;\n+      prev = n;\n+    }\n+\n+  return e;\n+}\n+\n+/* Convert bitmap HEAD from splay-tree view to linked-list view.  */\n+\n+void\n+bitmap_list_view (bitmap head)\n+{\n+  bitmap_element *ptr;\n+\n+  gcc_assert (head->tree_form);\n+\n+  ptr = head->first;\n+  if (ptr)\n+    {\n+      while (ptr->prev)\n+\tbitmap_tree_rotate_right (ptr);\n+      head->first = ptr;\n+      head->first = bitmap_tree_listify_from (head, ptr);\n     }\n+\n+  head->tree_form = false;\n }\n \n-/* Clear a bitmap by freeing the linked list.  */\n+/* Convert bitmap HEAD from linked-list view to splay-tree view.\n+   This is simply a matter of dropping the prev or next pointers\n+   and setting the tree_form flag.  The tree will balance itself\n+   if and when it is used.  */\n+\n+void\n+bitmap_tree_view (bitmap head)\n+{\n+  bitmap_element *ptr;\n+\n+  gcc_assert (! head->tree_form);\n+\n+  ptr = head->first;\n+  while (ptr)\n+    {\n+      ptr->prev = NULL;\n+      ptr = ptr->next;\n+    }\n+\n+  head->tree_form = true;\n+}\n+\f\n+/* Clear a bitmap by freeing all its elements.  */\n \n void\n bitmap_clear (bitmap head)\n {\n-  if (head->first)\n-    bitmap_elt_clear_from (head, head->first);\n+  if (head->first == NULL)\n+    return;\n+  if (head->tree_form)\n+    {\n+      bitmap_element *e, *t;\n+      for (e = head->first; e->prev; e = e->prev)\n+\t/* Loop to find the element with the smallest index.  */ ;\n+      t = bitmap_tree_splay (head, head->first, e->indx);\n+      gcc_checking_assert (t == e);\n+      head->first = t;\n+    }\n+  bitmap_elt_clear_from (head, head->first);\n }\n \f\n /* Initialize a bitmap obstack.  If BIT_OBSTACK is NULL, initialize\n@@ -344,96 +819,6 @@ bitmap_element_zerop (const bitmap_element *element)\n #endif\n }\n \f\n-/* Link the bitmap element into the current bitmap linked list.  */\n-\n-static inline void\n-bitmap_element_link (bitmap head, bitmap_element *element)\n-{\n-  unsigned int indx = element->indx;\n-  bitmap_element *ptr;\n-\n-  /* If this is the first and only element, set it in.  */\n-  if (head->first == 0)\n-    {\n-      element->next = element->prev = 0;\n-      head->first = element;\n-    }\n-\n-  /* If this index is less than that of the current element, it goes someplace\n-     before the current element.  */\n-  else if (indx < head->indx)\n-    {\n-      for (ptr = head->current;\n-\t   ptr->prev != 0 && ptr->prev->indx > indx;\n-\t   ptr = ptr->prev)\n-\t;\n-\n-      if (ptr->prev)\n-\tptr->prev->next = element;\n-      else\n-\thead->first = element;\n-\n-      element->prev = ptr->prev;\n-      element->next = ptr;\n-      ptr->prev = element;\n-    }\n-\n-  /* Otherwise, it must go someplace after the current element.  */\n-  else\n-    {\n-      for (ptr = head->current;\n-\t   ptr->next != 0 && ptr->next->indx < indx;\n-\t   ptr = ptr->next)\n-\t;\n-\n-      if (ptr->next)\n-\tptr->next->prev = element;\n-\n-      element->next = ptr->next;\n-      element->prev = ptr;\n-      ptr->next = element;\n-    }\n-\n-  /* Set up so this is the first element searched.  */\n-  head->current = element;\n-  head->indx = indx;\n-}\n-\n-/* Insert a new uninitialized element into bitmap HEAD after element\n-   ELT.  If ELT is NULL, insert the element at the start.  Return the\n-   new element.  */\n-\n-static bitmap_element *\n-bitmap_elt_insert_after (bitmap head, bitmap_element *elt, unsigned int indx)\n-{\n-  bitmap_element *node = bitmap_element_allocate (head);\n-  node->indx = indx;\n-\n-  if (!elt)\n-    {\n-      if (!head->current)\n-\t{\n-\t  head->current = node;\n-\t  head->indx = indx;\n-\t}\n-      node->next = head->first;\n-      if (node->next)\n-\tnode->next->prev = node;\n-      head->first = node;\n-      node->prev = NULL;\n-    }\n-  else\n-    {\n-      gcc_checking_assert (head->current);\n-      node->next = elt->next;\n-      if (node->next)\n-\tnode->next->prev = node;\n-      elt->next = node;\n-      node->prev = elt;\n-    }\n-  return node;\n-}\n-\f\n /* Copy a bitmap to another bitmap.  */\n \n void\n@@ -442,6 +827,8 @@ bitmap_copy (bitmap to, const_bitmap from)\n   const bitmap_element *from_ptr;\n   bitmap_element *to_ptr = 0;\n \n+  gcc_checking_assert (!to->tree_form && !from->tree_form);\n+\n   bitmap_clear (to);\n \n   /* Copy elements in forward direction one at a time.  */\n@@ -452,8 +839,9 @@ bitmap_copy (bitmap to, const_bitmap from)\n       to_elt->indx = from_ptr->indx;\n       memcpy (to_elt->bits, from_ptr->bits, sizeof (to_elt->bits));\n \n-      /* Here we have a special case of bitmap_element_link, for the case\n-\t where we know the links are being entered in sequence.  */\n+      /* Here we have a special case of bitmap_list_link_element,\n+         for the case where we know the links are being entered\n+\t in sequence.  */\n       if (to_ptr == 0)\n \t{\n \t  to->first = to->current = to_elt;\n@@ -492,85 +880,18 @@ bitmap_move (bitmap to, bitmap from)\n     }\n }\n \f\n-/* Find a bitmap element that would hold a bitmap's bit.\n-   Update the `current' field even if we can't find an element that\n-   would hold the bitmap's bit to make eventual allocation\n-   faster.  */\n-\n-static inline bitmap_element *\n-bitmap_find_bit (bitmap head, unsigned int bit)\n-{\n-  bitmap_element *element;\n-  unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n-\n-  if (head->current == NULL\n-      || head->indx == indx)\n-    return head->current;\n-  if (head->current == head->first\n-      && head->first->next == NULL)\n-    return NULL;\n-\n-  /* Usage can be NULL due to allocated bitmaps for which we do not\n-     call initialize function.  */\n-  bitmap_usage *usage = NULL;\n-  if (GATHER_STATISTICS)\n-    usage = bitmap_mem_desc.get_descriptor_for_instance (head);\n-\n-  /* This bitmap has more than one element, and we're going to look\n-     through the elements list.  Count that as a search.  */\n-  if (GATHER_STATISTICS && usage)\n-    usage->m_nsearches++;\n-\n-  if (head->indx < indx)\n-    /* INDX is beyond head->indx.  Search from head->current\n-       forward.  */\n-    for (element = head->current;\n-\t element->next != 0 && element->indx < indx;\n-\t element = element->next)\n-      {\n-\tif (GATHER_STATISTICS && usage)\n-\t  usage->m_search_iter++;\n-      }\n-\n-  else if (head->indx / 2 < indx)\n-    /* INDX is less than head->indx and closer to head->indx than to\n-       0.  Search from head->current backward.  */\n-    for (element = head->current;\n-\t element->prev != 0 && element->indx > indx;\n-\t element = element->prev)\n-      {\n-\tif (GATHER_STATISTICS && usage)\n-\t  usage->m_search_iter++;\n-      }\n-\n-  else\n-    /* INDX is less than head->indx and closer to 0 than to\n-       head->indx.  Search from head->first forward.  */\n-    for (element = head->first;\n-\t element->next != 0 && element->indx < indx;\n-\t element = element->next)\n-      if (GATHER_STATISTICS && usage)\n-\t{\n-\t  usage->m_search_iter++;\n-\t}\n-\n-  /* `element' is the nearest to the one we want.  If it's not the one we\n-     want, the one we want doesn't exist.  */\n-  head->current = element;\n-  head->indx = element->indx;\n-  if (element->indx != indx)\n-    element = 0;\n-\n-  return element;\n-}\n-\f\n /* Clear a single bit in a bitmap.  Return true if the bit changed.  */\n \n bool\n bitmap_clear_bit (bitmap head, int bit)\n {\n-  bitmap_element *const ptr = bitmap_find_bit (head, bit);\n+  unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  bitmap_element *ptr;\n \n+  if (!head->tree_form)\n+    ptr = bitmap_list_find_element (head, indx);\n+  else\n+    ptr = bitmap_tree_find_element (head, indx);\n   if (ptr != 0)\n     {\n       unsigned bit_num  = bit % BITMAP_WORD_BITS;\n@@ -583,7 +904,12 @@ bitmap_clear_bit (bitmap head, int bit)\n \t  /* If we cleared the entire word, free up the element.  */\n \t  if (!ptr->bits[word_num]\n \t      && bitmap_element_zerop (ptr))\n-\t    bitmap_element_free (head, ptr);\n+\t    {\n+\t      if (!head->tree_form)\n+\t\tbitmap_list_unlink_element (head, ptr);\n+\t      else\n+\t\tbitmap_tree_unlink_element (head, ptr);\n+\t    }\n \t}\n \n       return res;\n@@ -597,38 +923,48 @@ bitmap_clear_bit (bitmap head, int bit)\n bool\n bitmap_set_bit (bitmap head, int bit)\n {\n-  bitmap_element *ptr = bitmap_find_bit (head, bit);\n+  unsigned indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  bitmap_element *ptr;\n+  if (!head->tree_form)\n+    ptr = bitmap_list_find_element (head, indx);\n+  else\n+    ptr = bitmap_tree_find_element (head, indx);\n   unsigned word_num = bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n   unsigned bit_num  = bit % BITMAP_WORD_BITS;\n   BITMAP_WORD bit_val = ((BITMAP_WORD) 1) << bit_num;\n \n-  if (ptr == 0)\n-    {\n-      ptr = bitmap_element_allocate (head);\n-      ptr->indx = bit / BITMAP_ELEMENT_ALL_BITS;\n-      ptr->bits[word_num] = bit_val;\n-      bitmap_element_link (head, ptr);\n-      return true;\n-    }\n-  else\n+  if (ptr != 0)\n     {\n       bool res = (ptr->bits[word_num] & bit_val) == 0;\n       if (res)\n \tptr->bits[word_num] |= bit_val;\n       return res;\n     }\n+\n+  ptr = bitmap_element_allocate (head);\n+  ptr->indx = bit / BITMAP_ELEMENT_ALL_BITS;\n+  ptr->bits[word_num] = bit_val;\n+  if (!head->tree_form)\n+    bitmap_list_link_element (head, ptr);\n+  else\n+    bitmap_tree_link_element (head, ptr);\n+  return true;\n }\n \n /* Return whether a bit is set within a bitmap.  */\n \n int\n bitmap_bit_p (bitmap head, int bit)\n {\n+  unsigned int indx = bit / BITMAP_ELEMENT_ALL_BITS;\n   bitmap_element *ptr;\n   unsigned bit_num;\n   unsigned word_num;\n \n-  ptr = bitmap_find_bit (head, bit);\n+  if (!head->tree_form)\n+    ptr = bitmap_list_find_element (head, indx);\n+  else\n+    ptr = bitmap_tree_find_element (head, indx);\n   if (ptr == 0)\n     return 0;\n \n@@ -692,6 +1028,7 @@ bitmap_count_bits (const_bitmap a)\n   unsigned long count = 0;\n   const bitmap_element *elt;\n \n+  gcc_checking_assert (!a->tree_form);\n   for (elt = a->first; elt; elt = elt->next)\n     count += bitmap_count_bits_in_word (elt->bits);\n \n@@ -748,9 +1085,11 @@ bitmap_single_bit_set_p (const_bitmap a)\n     return false;\n \n   elt = a->first;\n+\n   /* As there are no completely empty bitmap elements, a second one\n      means we have more than one bit set.  */\n-  if (elt->next != NULL)\n+  if (elt->next != NULL\n+      && (!a->tree_form || elt->prev != NULL))\n     return false;\n \n   for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n@@ -782,6 +1121,11 @@ bitmap_first_set_bit (const_bitmap a)\n   unsigned ix;\n \n   gcc_checking_assert (elt);\n+\n+  if (a->tree_form)\n+    while (elt->prev)\n+      elt = elt->prev;\n+\n   bit_no = elt->indx * BITMAP_ELEMENT_ALL_BITS;\n   for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n     {\n@@ -827,14 +1171,20 @@ bitmap_first_set_bit (const_bitmap a)\n unsigned\n bitmap_last_set_bit (const_bitmap a)\n {\n-  const bitmap_element *elt = a->current ? a->current : a->first;\n+  const bitmap_element *elt;\n   unsigned bit_no;\n   BITMAP_WORD word;\n   int ix;\n \n+  if (a->tree_form)\n+    elt = a->first;\n+  else\n+    elt = a->current ? a->current : a->first;\n   gcc_checking_assert (elt);\n+\n   while (elt->next)\n     elt = elt->next;\n+\n   bit_no = elt->indx * BITMAP_ELEMENT_ALL_BITS;\n   for (ix = BITMAP_ELEMENT_WORDS - 1; ix >= 0; ix--)\n     {\n@@ -876,6 +1226,7 @@ bitmap_and (bitmap dst, const_bitmap a, const_bitmap b)\n   const bitmap_element *b_elt = b->first;\n   bitmap_element *dst_prev = NULL;\n \n+  gcc_checking_assert (!dst->tree_form && !a->tree_form && !b->tree_form);\n   gcc_assert (dst != a && dst != b);\n \n   if (a == b)\n@@ -897,7 +1248,8 @@ bitmap_and (bitmap dst, const_bitmap a, const_bitmap b)\n \t  BITMAP_WORD ior = 0;\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t    dst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t\ta_elt->indx);\n \t  else\n \t    dst_elt->indx = a_elt->indx;\n \t  for (ix = 0; ix < BITMAP_ELEMENT_WORDS; ix++)\n@@ -934,6 +1286,8 @@ bitmap_and_into (bitmap a, const_bitmap b)\n   bitmap_element *next;\n   bool changed = false;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   if (a == b)\n     return false;\n \n@@ -942,7 +1296,7 @@ bitmap_and_into (bitmap a, const_bitmap b)\n       if (a_elt->indx < b_elt->indx)\n \t{\n \t  next = a_elt->next;\n-\t  bitmap_element_free (a, a_elt);\n+\t  bitmap_list_unlink_element (a, a_elt);\n \t  a_elt = next;\n \t  changed = true;\n \t}\n@@ -964,7 +1318,7 @@ bitmap_and_into (bitmap a, const_bitmap b)\n \t    }\n \t  next = a_elt->next;\n \t  if (!ior)\n-\t    bitmap_element_free (a, a_elt);\n+\t    bitmap_list_unlink_element (a, a_elt);\n \t  a_elt = next;\n \t  b_elt = b_elt->next;\n \t}\n@@ -1006,7 +1360,8 @@ bitmap_elt_copy (bitmap dst, bitmap_element *dst_elt, bitmap_element *dst_prev,\n     {\n       changed = true;\n       if (!dst_elt)\n-\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, src_elt->indx);\n+\tdst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t    src_elt->indx);\n       else\n \tdst_elt->indx = src_elt->indx;\n       memcpy (dst_elt->bits, src_elt->bits, sizeof (dst_elt->bits));\n@@ -1028,6 +1383,7 @@ bitmap_and_compl (bitmap dst, const_bitmap a, const_bitmap b)\n   bitmap_element **dst_prev_pnext = &dst->first;\n   bool changed = false;\n \n+  gcc_checking_assert (!dst->tree_form && !a->tree_form && !b->tree_form);\n   gcc_assert (dst != a && dst != b);\n \n   if (a == b)\n@@ -1076,7 +1432,8 @@ bitmap_and_compl (bitmap dst, const_bitmap a, const_bitmap b)\n \t      bool new_element;\n \t      if (!dst_elt || dst_elt->indx > a_elt->indx)\n \t\t{\n-\t\t  dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t\t  dst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t\t      a_elt->indx);\n \t\t  new_element = true;\n \t\t}\n \t      else\n@@ -1098,7 +1455,7 @@ bitmap_and_compl (bitmap dst, const_bitmap a, const_bitmap b)\n \t      else\n \t        {\n \t          changed |= !new_element;\n-\t\t  bitmap_element_free (dst, dst_elt);\n+\t\t  bitmap_list_unlink_element (dst, dst_elt);\n \t\t  dst_elt = *dst_prev_pnext;\n \t\t}\n \t    }\n@@ -1139,6 +1496,8 @@ bitmap_and_compl_into (bitmap a, const_bitmap b)\n   bitmap_element *next;\n   BITMAP_WORD changed = 0;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   if (a == b)\n     {\n       if (bitmap_empty_p (a))\n@@ -1173,7 +1532,7 @@ bitmap_and_compl_into (bitmap a, const_bitmap b)\n \t    }\n \t  next = a_elt->next;\n \t  if (!ior)\n-\t    bitmap_element_free (a, a_elt);\n+\t    bitmap_list_unlink_element (a, a_elt);\n \t  a_elt = next;\n \t  b_elt = b_elt->next;\n \t}\n@@ -1191,6 +1550,8 @@ bitmap_set_range (bitmap head, unsigned int start, unsigned int count)\n   bitmap_element *elt, *elt_prev;\n   unsigned int i;\n \n+  gcc_checking_assert (!head->tree_form);\n+\n   if (!count)\n     return;\n \n@@ -1203,17 +1564,17 @@ bitmap_set_range (bitmap head, unsigned int start, unsigned int count)\n   first_index = start / BITMAP_ELEMENT_ALL_BITS;\n   end_bit_plus1 = start + count;\n   last_index = (end_bit_plus1 - 1) / BITMAP_ELEMENT_ALL_BITS;\n-  elt = bitmap_find_bit (head, start);\n+  elt = bitmap_list_find_element (head, first_index);\n \n-  /* If bitmap_find_bit returns zero, the current is the closest block\n+  /* If bitmap_list_find_element returns zero, the current is the closest block\n      to the result.  Otherwise, just use bitmap_element_allocate to\n      ensure ELT is set; in the loop below, ELT == NULL means \"insert\n      at the end of the bitmap\".  */\n   if (!elt)\n     {\n       elt = bitmap_element_allocate (head);\n       elt->indx = first_index;\n-      bitmap_element_link (head, elt);\n+      bitmap_list_link_element (head, elt);\n     }\n \n   gcc_checking_assert (elt->indx == first_index);\n@@ -1230,7 +1591,7 @@ bitmap_set_range (bitmap head, unsigned int start, unsigned int count)\n       unsigned int ix;\n \n       if (!elt || elt->indx != i)\n-\telt = bitmap_elt_insert_after (head, elt_prev, i);\n+\telt = bitmap_list_insert_element_after (head, elt_prev, i);\n \n       if (elt_start_bit <= start)\n \t{\n@@ -1296,6 +1657,8 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n   unsigned int first_index, end_bit_plus1, last_index;\n   bitmap_element *elt;\n \n+  gcc_checking_assert (!head->tree_form);\n+\n   if (!count)\n     return;\n \n@@ -1308,9 +1671,9 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n   first_index = start / BITMAP_ELEMENT_ALL_BITS;\n   end_bit_plus1 = start + count;\n   last_index = (end_bit_plus1 - 1) / BITMAP_ELEMENT_ALL_BITS;\n-  elt = bitmap_find_bit (head, start);\n+  elt = bitmap_list_find_element (head, first_index);\n \n-  /* If bitmap_find_bit returns zero, the current is the closest block\n+  /* If bitmap_list_find_element returns zero, the current is the closest block\n      to the result.  If the current is less than first index, find the\n      next one.  Otherwise, just set elt to be current.  */\n   if (!elt)\n@@ -1339,7 +1702,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \n       if (elt_start_bit >= start && elt_end_bit_plus1 <= end_bit_plus1)\n \t/* Get rid of the entire elt and go to the next one.  */\n-\tbitmap_element_free (head, elt);\n+\tbitmap_list_unlink_element (head, elt);\n       else\n \t{\n \t  /* Going to have to knock out some bits in this elt.  */\n@@ -1409,7 +1772,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t      }\n \t  /* Check to see if there are any bits left.  */\n \t  if (clear)\n-\t    bitmap_element_free (head, elt);\n+\t    bitmap_list_unlink_element (head, elt);\n \t}\n       elt = next_elt;\n     }\n@@ -1431,6 +1794,7 @@ bitmap_compl_and_into (bitmap a, const_bitmap b)\n   bitmap_element *a_prev = NULL;\n   bitmap_element *next;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n   gcc_assert (a != b);\n \n   if (bitmap_empty_p (a))\n@@ -1451,13 +1815,13 @@ bitmap_compl_and_into (bitmap a, const_bitmap b)\n \t  /* A is before B.  Remove A */\n \t  next = a_elt->next;\n \t  a_prev = a_elt->prev;\n-\t  bitmap_element_free (a, a_elt);\n+\t  bitmap_list_unlink_element (a, a_elt);\n \t  a_elt = next;\n \t}\n       else if (!a_elt || b_elt->indx < a_elt->indx)\n \t{\n \t  /* B is before A.  Copy B. */\n-\t  next = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n+\t  next = bitmap_list_insert_element_after (a, a_prev, b_elt->indx);\n \t  memcpy (next->bits, b_elt->bits, sizeof (next->bits));\n \t  a_prev = next;\n \t  b_elt = b_elt->next;\n@@ -1478,7 +1842,7 @@ bitmap_compl_and_into (bitmap a, const_bitmap b)\n \t    }\n \t  next = a_elt->next;\n \t  if (!ior)\n-\t    bitmap_element_free (a, a_elt);\n+\t    bitmap_list_unlink_element (a, a_elt);\n \t  else\n \t    a_prev = a_elt;\n \t  a_elt = next;\n@@ -1523,7 +1887,8 @@ bitmap_elt_ior (bitmap dst, bitmap_element *dst_elt, bitmap_element *dst_prev,\n \t{\n \t  changed = true;\n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t    dst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t\ta_elt->indx);\n \t  else\n \t    dst_elt->indx = a_elt->indx;\n \t  for (ix = 0; ix < BITMAP_ELEMENT_WORDS; ix++)\n@@ -1562,6 +1927,7 @@ bitmap_ior (bitmap dst, const_bitmap a, const_bitmap b)\n   bitmap_element **dst_prev_pnext = &dst->first;\n   bool changed = false;\n \n+  gcc_checking_assert (!dst->tree_form && !a->tree_form && !b->tree_form);\n   gcc_assert (dst != a && dst != b);\n \n   while (a_elt || b_elt)\n@@ -1610,6 +1976,7 @@ bitmap_ior_into (bitmap a, const_bitmap b)\n   bitmap_element **a_prev_pnext = &a->first;\n   bool changed = false;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n   if (a == b)\n     return false;\n \n@@ -1648,7 +2015,9 @@ bitmap_xor (bitmap dst, const_bitmap a, const_bitmap b)\n   const bitmap_element *b_elt = b->first;\n   bitmap_element *dst_prev = NULL;\n \n+  gcc_checking_assert (!dst->tree_form && !a->tree_form && !b->tree_form);\n   gcc_assert (dst != a && dst != b);\n+\n   if (a == b)\n     {\n       bitmap_clear (dst);\n@@ -1664,7 +2033,8 @@ bitmap_xor (bitmap dst, const_bitmap a, const_bitmap b)\n \t  BITMAP_WORD ior = 0;\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n+\t    dst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t\ta_elt->indx);\n \t  else\n \t    dst_elt->indx = a_elt->indx;\n \t  for (ix = 0; ix < BITMAP_ELEMENT_WORDS; ix++)\n@@ -1699,7 +2069,8 @@ bitmap_xor (bitmap dst, const_bitmap a, const_bitmap b)\n \t    }\n \n \t  if (!dst_elt)\n-\t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n+\t    dst_elt = bitmap_list_insert_element_after (dst, dst_prev,\n+\t\t\t\t\t\t\tsrc->indx);\n \t  else\n \t    dst_elt->indx = src->indx;\n \t  memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n@@ -1724,6 +2095,8 @@ bitmap_xor_into (bitmap a, const_bitmap b)\n   const bitmap_element *b_elt = b->first;\n   bitmap_element *a_prev = NULL;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   if (a == b)\n     {\n       bitmap_clear (a);\n@@ -1735,7 +2108,8 @@ bitmap_xor_into (bitmap a, const_bitmap b)\n       if (!a_elt || b_elt->indx < a_elt->indx)\n \t{\n \t  /* Copy b_elt.  */\n-\t  bitmap_element *dst = bitmap_elt_insert_after (a, a_prev, b_elt->indx);\n+\t  bitmap_element *dst = bitmap_list_insert_element_after (a, a_prev,\n+\t\t\t\t\t\t\t\t  b_elt->indx);\n \t  memcpy (dst->bits, b_elt->bits, sizeof (dst->bits));\n \t  a_prev = dst;\n \t  b_elt = b_elt->next;\n@@ -1763,7 +2137,7 @@ bitmap_xor_into (bitmap a, const_bitmap b)\n \t  if (ior)\n \t    a_prev = a_elt;\n \t  else\n-\t    bitmap_element_free (a, a_elt);\n+\t    bitmap_list_unlink_element (a, a_elt);\n \t  a_elt = next;\n \t}\n     }\n@@ -1783,6 +2157,8 @@ bitmap_equal_p (const_bitmap a, const_bitmap b)\n   const bitmap_element *b_elt;\n   unsigned ix;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   for (a_elt = a->first, b_elt = b->first;\n        a_elt && b_elt;\n        a_elt = a_elt->next, b_elt = b_elt->next)\n@@ -1805,6 +2181,8 @@ bitmap_intersect_p (const_bitmap a, const_bitmap b)\n   const bitmap_element *b_elt;\n   unsigned ix;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   for (a_elt = a->first, b_elt = b->first;\n        a_elt && b_elt;)\n     {\n@@ -1832,6 +2210,9 @@ bitmap_intersect_compl_p (const_bitmap a, const_bitmap b)\n   const bitmap_element *a_elt;\n   const bitmap_element *b_elt;\n   unsigned ix;\n+\n+  gcc_checking_assert (!a->tree_form && !b->tree_form);\n+\n   for (a_elt = a->first, b_elt = b->first;\n        a_elt && b_elt;)\n     {\n@@ -1866,6 +2247,8 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b, const_bitmap k\n   bitmap_element *dst_prev = NULL;\n   bitmap_element **dst_prev_pnext = &dst->first;\n \n+  gcc_checking_assert (!dst->tree_form && !a->tree_form && !b->tree_form\n+\t\t       && !kill->tree_form);\n   gcc_assert (dst != a && dst != b && dst != kill);\n \n   /* Special cases.  We don't bother checking for bitmap_equal_p (b, kill).  */\n@@ -1958,16 +2341,18 @@ bitmap_ior_and_compl (bitmap dst, const_bitmap a, const_bitmap b, const_bitmap k\n   return changed;\n }\n \n-/* A |= (FROM1 & ~FROM2).  Return true if A changes.  */\n+/* A |= (B & ~C).  Return true if A changes.  */\n \n bool\n-bitmap_ior_and_compl_into (bitmap a, const_bitmap from1, const_bitmap from2)\n+bitmap_ior_and_compl_into (bitmap a, const_bitmap b, const_bitmap c)\n {\n   bitmap_head tmp;\n   bool changed;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form && !c->tree_form);\n+\n   bitmap_initialize (&tmp, &bitmap_default_obstack);\n-  bitmap_and_compl (&tmp, from1, from2);\n+  bitmap_and_compl (&tmp, b, c);\n   changed = bitmap_ior_into (a, &tmp);\n   bitmap_clear (&tmp);\n \n@@ -1988,6 +2373,8 @@ bitmap_ior_and_into (bitmap a, const_bitmap b, const_bitmap c)\n   bool changed = false;\n   unsigned ix;\n \n+  gcc_checking_assert (!a->tree_form && !b->tree_form && !c->tree_form);\n+\n   if (b == c)\n     return bitmap_ior_into (a, b);\n   if (bitmap_empty_p (b) || bitmap_empty_p (c))\n@@ -2054,13 +2441,16 @@ bitmap_ior_and_into (bitmap a, const_bitmap b, const_bitmap c)\n }\n \n /* Compute hash of bitmap (for purposes of hashing).  */\n+\n hashval_t\n bitmap_hash (const_bitmap head)\n {\n   const bitmap_element *ptr;\n   BITMAP_WORD hash = 0;\n   int ix;\n \n+  gcc_checking_assert (!head->tree_form);\n+\n   for (ptr = head->first; ptr; ptr = ptr->next)\n     {\n       hash ^= ptr->indx;\n@@ -2071,6 +2461,61 @@ bitmap_hash (const_bitmap head)\n }\n \n \f\n+/* Function to obtain a vector of bitmap elements in bit order from\n+   HEAD in tree view.  */\n+\n+static void\n+bitmap_tree_to_vec (vec<bitmap_element *> &elts, const_bitmap head)\n+{\n+  gcc_checking_assert (head->tree_form);\n+  auto_vec<bitmap_element *, 32> stack;\n+  bitmap_element *e = head->first;\n+  while (true)\n+    {\n+      while (e != NULL)\n+\t{\n+\t  stack.safe_push (e);\n+\t  e = e->prev;\n+\t}\n+      if (stack.is_empty ())\n+\tbreak;\n+\n+      e = stack.pop ();\n+      elts.safe_push (e);\n+      e = e->next;\n+    }\n+}\n+\n+/* Debugging function to print out the contents of a bitmap element.  */\n+\n+DEBUG_FUNCTION void\n+debug_bitmap_elt_file (FILE *file, const bitmap_element *ptr)\n+{\n+  unsigned int i, j, col = 26;\n+\n+  fprintf (file, \"\\t\" HOST_PTR_PRINTF \" next = \" HOST_PTR_PRINTF\n+\t   \" prev = \" HOST_PTR_PRINTF \" indx = %u\\n\\t\\tbits = {\",\n+\t   (const void*) ptr, (const void*) ptr->next,\n+\t   (const void*) ptr->prev, ptr->indx);\n+\n+  for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n+    for (j = 0; j < BITMAP_WORD_BITS; j++)\n+      if ((ptr->bits[i] >> j) & 1)\n+\t{\n+\t  if (col > 70)\n+\t    {\n+\t      fprintf (file, \"\\n\\t\\t\\t\");\n+\t      col = 24;\n+\t    }\n+\n+\t  fprintf (file, \" %u\", (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n+\t\t\t\t + i * BITMAP_WORD_BITS + j));\n+\t  col += 4;\n+\t}\n+\n+  fprintf (file, \" }\\n\");\n+}\n+\n /* Debugging function to print out the contents of a bitmap.  */\n \n DEBUG_FUNCTION void\n@@ -2082,32 +2527,16 @@ debug_bitmap_file (FILE *file, const_bitmap head)\n \t   \" current = \" HOST_PTR_PRINTF \" indx = %u\\n\",\n \t   (void *) head->first, (void *) head->current, head->indx);\n \n-  for (ptr = head->first; ptr; ptr = ptr->next)\n+  if (head->tree_form)\n     {\n-      unsigned int i, j, col = 26;\n-\n-      fprintf (file, \"\\t\" HOST_PTR_PRINTF \" next = \" HOST_PTR_PRINTF\n-\t       \" prev = \" HOST_PTR_PRINTF \" indx = %u\\n\\t\\tbits = {\",\n-\t       (const void*) ptr, (const void*) ptr->next,\n-\t       (const void*) ptr->prev, ptr->indx);\n-\n-      for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n-\tfor (j = 0; j < BITMAP_WORD_BITS; j++)\n-\t  if ((ptr->bits[i] >> j) & 1)\n-\t    {\n-\t      if (col > 70)\n-\t\t{\n-\t\t  fprintf (file, \"\\n\\t\\t\\t\");\n-\t\t  col = 24;\n-\t\t}\n-\n-\t      fprintf (file, \" %u\", (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t\t\t\t     + i * BITMAP_WORD_BITS + j));\n-\t      col += 4;\n-\t    }\n-\n-      fprintf (file, \" }\\n\");\n+      auto_vec<bitmap_element *, 32> elts;\n+      bitmap_tree_to_vec (elts, head);\n+      for (unsigned i = 0; i < elts.length (); ++i)\n+\tdebug_bitmap_elt_file (file, elts[i]);\n     }\n+  else\n+    for (ptr = head->first; ptr; ptr = ptr->next)\n+      debug_bitmap_elt_file (file, ptr);\n }\n \n /* Function to be called from the debugger to print the contents\n@@ -2128,13 +2557,34 @@ bitmap_print (FILE *file, const_bitmap head, const char *prefix,\n {\n   const char *comma = \"\";\n   unsigned i;\n-  bitmap_iterator bi;\n \n   fputs (prefix, file);\n-  EXECUTE_IF_SET_IN_BITMAP (head, 0, i, bi)\n+  if (head->tree_form)\n+    {\n+      auto_vec<bitmap_element *, 32> elts;\n+      bitmap_tree_to_vec (elts, head);\n+      for (i = 0; i < elts.length (); ++i)\n+\tfor (unsigned ix = 0; ix != BITMAP_ELEMENT_WORDS; ++ix)\n+\t  {\n+\t    BITMAP_WORD word = elts[i]->bits[ix];\n+\t    for (unsigned bit = 0; bit != BITMAP_WORD_BITS; ++bit)\n+\t      if (word & ((BITMAP_WORD)1 << bit))\n+\t\t{\n+\t\t  fprintf (file, \"%s%d\", comma,\n+\t\t\t   (bit + BITMAP_WORD_BITS * ix\n+\t\t\t    + elts[i]->indx * BITMAP_ELEMENT_ALL_BITS));\n+\t\t  comma = \", \";\n+\t\t}\n+\t  }\n+    }\n+  else\n     {\n-      fprintf (file, \"%s%d\", comma, i);\n-      comma = \", \";\n+      bitmap_iterator bi;\n+      EXECUTE_IF_SET_IN_BITMAP (head, 0, i, bi)\n+\t{\n+\t  fprintf (file, \"%s%d\", comma, i);\n+\t  comma = \", \";\n+\t}\n     }\n   fputs (suffix, file);\n }"}, {"sha": "5d3e8a5088e7f513594982e0010e7f9c0a2aaecf", "filename": "gcc/bitmap.h", "status": "modified", "additions": 170, "deletions": 68, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "patch": "@@ -20,16 +20,21 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_BITMAP_H\n #define GCC_BITMAP_H\n \n-/* Implementation of sparse integer sets as a linked list.\n+/* Implementation of sparse integer sets as a linked list or tree.\n \n    This sparse set representation is suitable for sparse sets with an\n-   unknown (a priori) universe.  The set is represented as a double-linked\n-   list of container nodes (struct bitmap_element).  Each node consists\n-   of an index for the first member that could be held in the container,\n-   a small array of integers that represent the members in the container,\n-   and pointers to the next and previous element in the linked list.  The\n-   elements in the list are sorted in ascending order, i.e. the head of\n+   unknown (a priori) universe.\n+\n+   Sets are represented as double-linked lists of container nodes of\n+   type \"struct bitmap_element\" or as a binary trees of the same\n+   container nodes.  Each container node consists of an index for the\n+   first member that could be held in the container, a small array of\n+   integers that represent the members in the container, and pointers\n+   to the next and previous element in the linked list, or left and\n+   right children in the tree.  In linked-list form, the container\n+   nodes in the list are sorted in ascending order, i.e. the head of\n    the list holds the element with the smallest member of the set.\n+   In tree form, nodes to the left have a smaller container index.\n \n    For a given member I in the set:\n      - the element for I will have index is I / (bits per element)\n@@ -42,34 +47,97 @@ along with GCC; see the file COPYING3.  If not see\n    high storage overhead *per element*, but a small overall overhead if\n    the set is very sparse.\n \n-   The downside is that many operations are relatively slow because the\n-   linked list has to be traversed to test membership (i.e. member_p/\n-   add_member/remove_member).  To improve the performance of this set\n-   representation, the last accessed element and its index are cached.\n-   For membership tests on members close to recently accessed members,\n-   the cached last element improves membership test to a constant-time\n-   operation.\n+   The storage requirements for linked-list sparse sets are O(E), with E->N\n+   in the worst case (a sparse set with large distances between the values\n+   of the set members).\n \n-   The following operations can always be performed in O(1) time:\n+   This representation also works well for data flow problems where the size\n+   of the set may grow dynamically, but care must be taken that the member_p,\n+   add_member, and remove_member operations occur with a suitable access\n+   pattern.\n+\n+   The linked-list set representation works well for problems involving very\n+   sparse sets.  The canonical example in GCC is, of course, the \"set of\n+   sets\" for some CFG-based data flow problems (liveness analysis, dominance\n+   frontiers, etc.).\n+   \n+   For random-access sparse sets of unknown universe, the binary tree\n+   representation is likely to be a more suitable choice.  Theoretical\n+   access times for the binary tree representation are better than those\n+   for the linked-list, but in practice this is only true for truely\n+   random access.\n+\n+   Often the most suitable representation during construction of the set\n+   is not the best choice for the usage of the set.  For such cases, the\n+   \"view\" of the set can be changed from one representation to the other.\n+   This is an O(E) operation:\n+\n+     * from list to tree view\t: bitmap_tree_view\n+     * from tree to list view\t: bitmap_list_view\n+\n+   Traversing linked lists or trees can be cache-unfriendly.  Performance\n+   can be improved by keeping container nodes in the set grouped together\n+   in  memory, using a dedicated obstack for a set (or group of related\n+   sets).  Elements allocated on obstacks are released to a free-list and\n+   taken off the free list.  If multiple sets are allocated on the same\n+   obstack, elements freed from one set may be re-used for one of the other\n+   sets.  This usually helps avoid cache misses.\n+\n+   A single free-list is used for all sets allocated in GGC space.  This is\n+   bad for persistent sets, so persistent sets should be allocated on an\n+   obstack whenever possible.\n+\n+   For random-access sets with a known, relatively small universe size, the\n+   SparseSet or simple bitmap representations may be more efficient than a\n+   linked-list set.\n+\n+\n+   LINKED LIST FORM\n+   ================\n+\n+   In linked-list form, in-order iterations of the set can be executed\n+   efficiently.  The downside is that many random-access operations are\n+   relatively slow, because the linked list has to be traversed to test\n+   membership (i.e. member_p/ add_member/remove_member).\n+   \n+   To improve the performance of this set representation, the last\n+   accessed element and its index are cached.  For membership tests on\n+   members close to recently accessed members, the cached last element\n+   improves membership test to a constant-time operation.\n+\n+   The following operations can always be performed in O(1) time in\n+   list view:\n \n      * clear\t\t\t: bitmap_clear\n+     * smallest_member\t\t: bitmap_first_set_bit\n      * choose_one\t\t: (not implemented, but could be\n-\t\t\t\t   implemented in constant time)\n+\t\t\t\t   in constant time)\n \n-   The following operations can be performed in O(E) time worst-case (with\n-   E the number of elements in the linked list), but in O(1) time with a\n-   suitable access patterns:\n+   The following operations can be performed in O(E) time worst-case in\n+   list view (with E the number of elements in the linked list), but in\n+   O(1) time with a suitable access patterns:\n \n      * member_p\t\t\t: bitmap_bit_p\n-     * add_member\t\t: bitmap_set_bit\n-     * remove_member\t\t: bitmap_clear_bit\n+     * add_member\t\t: bitmap_set_bit / bitmap_set_range\n+     * remove_member\t\t: bitmap_clear_bit / bitmap_clear_range\n \n-   The following operations can be performed in O(E) time:\n+   The following operations can be performed in O(E) time in list view:\n \n      * cardinality\t\t: bitmap_count_bits\n-     * set_size\t\t\t: bitmap_last_set_bit (but this could\n+     * largest_member\t\t: bitmap_last_set_bit (but this could\n \t\t\t\t  in constant time with a pointer to\n \t\t\t\t  the last element in the chain)\n+     * set_size\t\t\t: bitmap_last_set_bit\n+\n+   In tree view the following operations can all be performed in O(log E)\n+   amortized time with O(E) worst-case behavior.\n+\n+     * smallest_member\n+     * largest_member\n+     * set_size\n+     * member_p\n+     * add_member\n+     * remove_member\n \n    Additionally, the linked-list sparse set representation supports\n    enumeration of the members in O(E) time:\n@@ -93,39 +161,53 @@ along with GCC; see the file COPYING3.  If not see\n      * A | (B & ~C)\t\t: bitmap_ior_and_compl /\n \t\t\t\t  bitmap_ior_and_compl_into\n \n-   The storage requirements for linked-list sparse sets are O(E), with E->N\n-   in the worst case (a sparse set with large distances between the values\n-   of the set members).\n \n-   The linked-list set representation works well for problems involving very\n-   sparse sets.  The canonical example in GCC is, of course, the \"set of\n-   sets\" for some CFG-based data flow problems (liveness analysis, dominance\n-   frontiers, etc.).\n-   \n-   This representation also works well for data flow problems where the size\n-   of the set may grow dynamically, but care must be taken that the member_p,\n-   add_member, and remove_member operations occur with a suitable access\n-   pattern.\n-   \n-   For random-access sets with a known, relatively small universe size, the\n-   SparseSet or simple bitmap representations may be more efficient than a\n-   linked-list set.  For random-access sets of unknown universe, a hash table\n-   or a balanced binary tree representation is likely to be a more suitable\n-   choice.\n+   BINARY TREE FORM\n+   ================\n+   An alternate \"view\" of a bitmap is its binary tree representation.\n+   For this representation, splay trees are used because they can be\n+   implemented using the same data structures as the linked list, with\n+   no overhead for meta-data (like color, or rank) on the tree nodes.\n \n-   Traversing linked lists is usually cache-unfriendly, even with the last\n-   accessed element cached.\n+   In binary tree form, random-access to the set is much more efficient\n+   than for the linked-list representation.  Downsides are the high cost\n+   of clearing the set, and the relatively large number of operations\n+   necessary to balance the tree.  Also, iterating the set members is\n+   not supported.\n    \n-   Cache performance can be improved by keeping the elements in the set\n-   grouped together in memory, using a dedicated obstack for a set (or group\n-   of related sets).  Elements allocated on obstacks are released to a\n-   free-list and taken off the free list.  If multiple sets are allocated on\n-   the same obstack, elements freed from one set may be re-used for one of\n-   the other sets.  This usually helps avoid cache misses.\n+   As for the linked-list representation, the last accessed element and\n+   its index are cached, so that membership tests on the latest accessed\n+   members is a constant-time operation.  Other lookups take O(logE)\n+   time amortized (but O(E) time worst-case).\n \n-   A single free-list is used for all sets allocated in GGC space.  This is\n-   bad for persistent sets, so persistent sets should be allocated on an\n-   obstack whenever possible.  */\n+   The following operations can always be performed in O(1) time:\n+\n+     * choose_one\t\t: (not implemented, but could be\n+\t\t\t\t   implemented in constant time)\n+\n+   The following operations can be performed in O(logE) time amortized\n+   but O(E) time worst-case, but in O(1) time if the same element is\n+   accessed.\n+\n+     * member_p\t\t\t: bitmap_bit_p\n+     * add_member\t\t: bitmap_set_bit\n+     * remove_member\t\t: bitmap_clear_bit\n+\n+   The following operations can be performed in O(logE) time amortized\n+   but O(E) time worst-case:\n+\n+     * smallest_member\t\t: bitmap_first_set_bit\n+     * largest_member\t\t: bitmap_last_set_bit\n+     * set_size\t\t\t: bitmap_last_set_bit\n+\n+   The following operations can be performed in O(E) time:\n+\n+     * clear\t\t\t: bitmap_clear\n+\n+   The binary tree sparse set representation does *not* support any form\n+   of enumeration, and does also *not* support logical operations on sets.\n+   The binary tree representation is only supposed to be used for sets\n+   on which many random-access membership tests will happen.  */\n \n #include \"obstack.h\"\n \n@@ -225,31 +307,45 @@ struct GTY (()) bitmap_obstack {\n    linear in the number of elements to be freed.  */\n \n struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) bitmap_element {\n-  struct bitmap_element *next;\t/* Next element.  */\n-  struct bitmap_element *prev;\t/* Previous element.  */\n-  unsigned int indx;\t\t\t/* regno/BITMAP_ELEMENT_ALL_BITS.  */\n-  BITMAP_WORD bits[BITMAP_ELEMENT_WORDS]; /* Bits that are set.  */\n+  /* In list form, the next element in the linked list;\n+     in tree form, the left child node in the tree.  */\n+  struct bitmap_element *next;\n+  /* In list form, the previous element in the linked list;\n+     in tree form, the right child node in the tree.  */\n+  struct bitmap_element *prev;\n+  /* regno/BITMAP_ELEMENT_ALL_BITS.  */\n+  unsigned int indx;\n+  /* Bits that are set, counting from INDX, inclusive  */\n+  BITMAP_WORD bits[BITMAP_ELEMENT_WORDS];\n };\n \n /* Head of bitmap linked list.  The 'current' member points to something\n    already pointed to by the chain started by first, so GTY((skip)) it.  */\n \n struct GTY(()) bitmap_head {\n-  unsigned int indx;\t\t\t/* Index of last element looked at.  */\n-  unsigned int descriptor_id;\t\t/* Unique identifier for the allocation\n-\t\t\t\t\t   site of this bitmap, for detailed\n-\t\t\t\t\t   statistics gathering.  */\n-  bitmap_element *first;\t\t/* First element in linked list.  */\n-  bitmap_element * GTY((skip(\"\"))) current; /* Last element looked at.  */\n-  bitmap_obstack *obstack;\t\t/* Obstack to allocate elements from.\n-\t\t\t\t\t   If NULL, then use GGC allocation.  */\n+  /* Index of last element looked at.  */\n+  unsigned int indx;\n+  /* False if the bitmap is in list form; true if the bitmap is in tree form.\n+     Bitmap iterators only work on bitmaps in list form.  */\n+  bool tree_form;\n+  /* In list form, the first element in the linked list;\n+     in tree form, the root of the tree.   */\n+  bitmap_element *first;\n+  /* Last element looked at.  */\n+  bitmap_element * GTY((skip(\"\"))) current;\n+  /* Obstack to allocate elements from.  If NULL, then use GGC allocation.  */\n+  bitmap_obstack *obstack;\n   void dump ();\n };\n \n /* Global data */\n extern bitmap_element bitmap_zero_bits;\t/* Zero bitmap element */\n extern bitmap_obstack bitmap_default_obstack;   /* Default bitmap obstack */\n \n+/* Change the view of the bitmap to list, or tree.  */\n+void bitmap_list_view (bitmap);\n+void bitmap_tree_view (bitmap);\n+\n /* Clear a bitmap by freeing up the linked list.  */\n extern void bitmap_clear (bitmap);\n \n@@ -316,10 +412,10 @@ extern bool bitmap_clear_bit (bitmap, int);\n /* Set a single bit in a bitmap.  Return true if the bit changed.  */\n extern bool bitmap_set_bit (bitmap, int);\n \n-/* Return true if a register is set in a register set.  */\n+/* Return true if a bit is set in a bitmap.  */\n extern int bitmap_bit_p (bitmap, int);\n \n-/* Debug functions to print a bitmap linked list.  */\n+/* Debug functions to print a bitmap.  */\n extern void debug_bitmap (const_bitmap);\n extern void debug_bitmap_file (FILE *, const_bitmap);\n \n@@ -339,6 +435,7 @@ static inline void\n bitmap_initialize (bitmap head, bitmap_obstack *obstack CXX_MEM_STAT_INFO)\n {\n   head->first = head->current = NULL;\n+  head->indx = head->tree_form = 0;\n   head->obstack = obstack;\n   if (GATHER_STATISTICS)\n     bitmap_register (head PASS_MEM_STAT);\n@@ -398,6 +495,8 @@ bmp_iter_set_init (bitmap_iterator *bi, const_bitmap map,\n   bi->elt1 = map->first;\n   bi->elt2 = NULL;\n \n+  gcc_checking_assert (!map->tree_form);\n+\n   /* Advance elt1 until it is not before the block containing start_bit.  */\n   while (1)\n     {\n@@ -440,6 +539,8 @@ bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n   bi->elt1 = map1->first;\n   bi->elt2 = map2->first;\n \n+  gcc_checking_assert (!map1->tree_form && !map2->tree_form);\n+\n   /* Advance elt1 until it is not before the block containing\n      start_bit.  */\n   while (1)\n@@ -498,8 +599,7 @@ bmp_iter_and_init (bitmap_iterator *bi, const_bitmap map1, const_bitmap map2,\n   *bit_no = start_bit;\n }\n \n-/* Initialize an iterator to iterate over the bits in MAP1 & ~MAP2.\n-   */\n+/* Initialize an iterator to iterate over the bits in MAP1 & ~MAP2.  */\n \n static inline void\n bmp_iter_and_compl_init (bitmap_iterator *bi,\n@@ -509,6 +609,8 @@ bmp_iter_and_compl_init (bitmap_iterator *bi,\n   bi->elt1 = map1->first;\n   bi->elt2 = map2->first;\n \n+  gcc_checking_assert (!map1->tree_form && !map2->tree_form);\n+\n   /* Advance elt1 until it is not before the block containing start_bit.  */\n   while (1)\n     {"}, {"sha": "83b0c1fec8a44c67d4c1800f811b859695c1595c", "filename": "gcc/tree-ssa-coalesce.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Ftree-ssa-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Ftree-ssa-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-coalesce.c?ref=d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "patch": "@@ -1703,9 +1703,11 @@ coalesce_ssa_name (var_map map)\n   coalesce_list *cl;\n   auto_bitmap used_in_copies;\n \n+  bitmap_tree_view (used_in_copies);\n   cl = create_coalesce_list_for_region (map, used_in_copies);\n   if (map->outofssa_p)\n     populate_coalesce_list_for_outofssa (cl, used_in_copies);\n+  bitmap_list_view (used_in_copies);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     dump_var_map (dump_file, map);"}, {"sha": "1f3ccafa00e3782e43439f95489fadaa906c9bb1", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=d1e14d97207fafc3b9873bb06a3a6f1fc1f6d305", "patch": "@@ -381,6 +381,8 @@ ssa_prop_init (void)\n   /* Worklists of SSA edges.  */\n   ssa_edge_worklist = BITMAP_ALLOC (NULL);\n   ssa_edge_worklist_back = BITMAP_ALLOC (NULL);\n+  bitmap_tree_view (ssa_edge_worklist);\n+  bitmap_tree_view (ssa_edge_worklist_back);\n \n   /* Worklist of basic-blocks.  */\n   bb_to_cfg_order = XNEWVEC (int, last_basic_block_for_fn (cfun) + 1);"}]}