{"sha": "8c660648cab7bed53c82b8283dcf170db7e97983", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM2NjA2NDhjYWI3YmVkNTNjODJiODI4M2RjZjE3MGRiN2U5Nzk4Mw==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1997-08-12T04:07:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-12T04:07:19Z"}, "message": "* Integrate Haifa instruction scheduler.\n\n        * Integrate regmove pass.\nSee ChangeLog for deatils.\n\nFrom-SVN: r14770", "tree": {"sha": "d4545c8066f57414681646f5d32d3f9b95acbe1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4545c8066f57414681646f5d32d3f9b95acbe1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c660648cab7bed53c82b8283dcf170db7e97983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c660648cab7bed53c82b8283dcf170db7e97983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c660648cab7bed53c82b8283dcf170db7e97983", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c660648cab7bed53c82b8283dcf170db7e97983/comments", "author": null, "committer": null, "parents": [{"sha": "aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa32d8415861b4a41e0b3f38654bc425cb7cb64d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa32d8415861b4a41e0b3f38654bc425cb7cb64d"}], "stats": {"total": 10747, "additions": 10737, "deletions": 10}, "files": [{"sha": "608c3d73ba214dd2ff11416da0012183740e84d8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -1,3 +1,76 @@\n+Mon Aug 11 14:50:55 1997  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* Integrate Haifa instruction scheduler.\n+\t* Makefile.in (ALL_CFLAGS): Add SCHED_CFLAGS.  Prefix all references\n+\tto sched with $(SCHED_CFLAGS.\n+\t* configure.in: Handle --enable-haifa.\n+\t* configure: Rebuilt.\n+\t* flags.h: Add new flags for haifa instruction scheduler.\n+\t* genattrtab.c (expand_units): For haifa, don't subtract one\n+\twhen computing blockage.\n+\t* toplev.h (flag_schedule_interblock): Haifa scheduler flag.\n+\t(flag_schedule_speculative): Ditto.\n+\t(flag_schedule_speculative_load): Ditto.\n+\t(flag_schedule_speculative_load_dangerous): Ditto.\n+\t(flag_schedule_reverse_before_reload): Ditto.\n+\t(flag_schedule_reverse_after_reload): Ditto.\n+\t(flag_branch_on_count_reg): Ditto.\n+\t(f_options): Add Haifa switches.\n+\t(main): Turn off some Haifa options if appropriate macro is\n+\tdefined.  Process Haifa switches.\n+\t* unroll.c (iteration_info): No longer static, since Haifa\n+\tscheduler uses it.\n+\t(unroll_loop): Inform HAIFA scheduler about loop unrolling factor.\n+\t* unroll.c (unroll_loop): Set loop_unroll_iter, loop_start_value.\n+\t* loop.h (loop_unroll_factor, loop_number): Add HAIFA decls.\n+\t* loop.h (loop_initial_value,loop_unroll_iter): New globals.\n+\t* loop.c (loop_optimize): If HAIFA is defined, allocate additional\n+\tstorage for the Haifa scheduler.\n+\t(mark_loop_jump): If HAIFA defined, set LABEL_OUTSIDE_LOOP_P and\n+\tLABEL_NEXTREF.\n+\t(strength_reduce): If HAIFA and HAVE_decrement_and_branch_on_count\n+\tare defined, call analyze_loop_iterations and insert_bct to use\n+\tcountdown loops.\n+\t(record_giv): Refine test for jumps out of loops if HAIFA is\n+\tdefined.\n+\t(analyze_loop_iterations): New function to identify if we can use\n+\ta countdown loop.\n+\t(insert_bct): Insert countdown loop.\n+\t(instrument_loop_bct): Low level code to insert countdown loop.\n+\t(loop_number): Calculate UID of loop.\n+\t(indirect_jump_in_function_p): Return true if an indirect jump is\n+\tin the function.\n+\t(is_power_of_2): Return true if value is a power of 2.\n+\t(is_conditional_branch): Return true if insn is a conditional\n+\tjump.\n+\t(fix_bct_param): Process -fbct-{min,max}-N switches.\n+\t(check_bct_param): Return true if loop should be instrumented.\n+\t* loop.c (loop_initial_value,loop_unroll_iter): New globals.\n+\t(loop_optimize): Initialize.\n+\t(get_condition_for_loop): Ditto.\n+\t* loop.c (strength_reduce): Inside of code that uses #ifdef\n+\tHAVE_decrement_and_branch_on_count code, test it to make sure the\n+\tcondition is true.\n+\t(instrument_loop_bct): Ditto.\n+\t* haifa-sched.c: New file.\n+\t\n+\n+\t* Integrate regmove pass.\n+\t* Makefile.in (OBJS): Add regmove.o\n+\t(regmove.o): Add dependencies.\n+\t* flow.c (find_use_as_address): No longer static.\n+\t* rtl.h (find_use_as_address): Declare.\n+\t* toplev.c (regmove_dump, flag_regmove): Define.\n+\t(f_options): Add -fregmove.\n+\t(regmove_dump_file, regmove_time): Define.\n+\t(fatal_insn): Close the regmove dump file.\n+\t(compile_file): Initialize regmove_time; open/close the regmove dump\n+\tfile as needed.  Print regmove time as needed.\n+\t(rest_of_compilation): Run regmove pass if requested, dump\n+\tRTL after regmove if requested.\n+\t(main): If -O2 or more, turn on regmove.  Handle dump switches.\n+\t* regmove.c: New file.\n+\t\n Mon Aug 11 14:15:02 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* Integrate tlink patch from jason@cygnus.com"}, {"sha": "adf5db49806af9a1684db285e22e9dad8ebc3214", "filename": "gcc/Makefile.in", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -444,7 +444,7 @@ INTERNAL_CFLAGS = $(CROSS) -DIN_GCC @extra_c_flags@\n \n # This is the variable actually used when we compile.\n ALL_CFLAGS = $(INTERNAL_CFLAGS) $(X_CFLAGS) $(T_CFLAGS) $(CFLAGS) $(XCFLAGS) \\\n-\t@DEFS@\n+\t@DEFS@ $(SCHED_CFLAGS)\n \n # Likewise.\n ALL_CPPFLAGS = $(CPPFLAGS) $(X_CPPFLAGS) $(T_CPPFLAGS)\n@@ -548,14 +548,17 @@ BC_OBJS = bc-emit.o bc-optab.o\n # Bytecode header files constructed at build time; vmsconfig.com wants this.\n BC_ALL = bc-arity.h bc-opcode.h bc-opname.h\n \n+SCHED_PREFIX = @sched_prefix@\n+SCHED_CFLAGS = @sched_cflags@\n+\n # Language-independent object files.\n OBJS = toplev.o version.o tree.o print-tree.o stor-layout.o fold-const.o \\\n  function.o stmt.o except.o expr.o calls.o expmed.o explow.o optabs.o \\\n- varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o real.o \\\n- dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o \\\n+ varasm.o rtl.o print-rtl.o rtlanal.o emit-rtl.o real.o regmove.o \\\n+ dbxout.o sdbout.o dwarfout.o dwarf2out.o xcoffout.o bitmap.o alias.o \\\n  integrate.o jump.o cse.o loop.o unroll.o flow.o stupid.o combine.o \\\n  regclass.o local-alloc.o global.o reload.o reload1.o caller-save.o \\\n- insn-peep.o reorg.o alias.o sched.o final.o recog.o reg-stack.o \\\n+ insn-peep.o reorg.o $(SCHED_PREFIX)sched.o final.o recog.o reg-stack.o \\\n  insn-opinit.o insn-recog.o insn-extract.o insn-output.o insn-emit.o \\\n  profile.o insn-attrtab.o $(out_object_file) getpwd.o convert.o $(EXTRA_OBJS)\n \n@@ -1326,7 +1329,9 @@ reorg.o : reorg.c $(CONFIG_H) $(RTL_H) conditions.h hard-reg-set.h \\\n    flags.h output.h\n alias.o : alias.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \\\n    insn-codes.h\n-sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) $(RTL_H) $(BASIC_BLOCK_H) regs.h hard-reg-set.h \\\n+regmove.o : regmove.c $(CONFIG_H) $(RTL_H) insn-config.h recog.h output.h \\\n+  reload.h regs.h hard-reg-set.h flags.h expr.h insn-flags.h\n+$(SCHED_PREFIX)sched.o : $(SCHED_PREFIX)sched.c $(CONFIG_H) $(RTL_H) $(BASIC_BLOCK_H) regs.h hard-reg-set.h \\\n    flags.h insn-config.h insn-attr.h\n final.o : final.c $(CONFIG_H) $(RTL_H) $(TREE_H) flags.h regs.h \\\n    recog.h conditions.h insn-config.h insn-attr.h except.h real.h output.h \\"}, {"sha": "74dd86eeead5a56947b585ba9b065c451fe12476", "filename": "gcc/configure", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -4361,6 +4361,26 @@ if [ ! -f Makefile.in ]; then\n \techo \"source ${srcdir}/.gdbinit\" >> .gdbinit\n fi\n \n+# Override SCHED_OBJ and SCHED_CFLAGS to enable the Haifa scheduler.\n+sched_prefix=\n+sched_cflags=\n+if [[ x$enable_haifa = xyes ]]; then\n+    echo \"Using the Haifa scheduler.\"\n+    sched_prefix=haifa-\n+    sched_cflags=-DHAIFA\n+fi\n+\n+\n+if [[ x$enable_haifa != x ]]; then\n+    # Explicitly remove files that need to be recompiled for the Haifa scheduler.\n+    for x in genattrtab.o toplev.o loop.o unroll.o *sched.o; do\n+\tif [ -f $x ]; then\n+\t    echo \"Removing $x\"\n+\t    rm -f $x\n+\tfi\n+    done\n+fi\n+\n # Process the language and host/target makefile fragments.\n ${CONFIG_SHELL-/bin/sh} $srcdir/configure.frag $srcdir \"$subdirs\" \"$dep_host_xmake_file\" \"$dep_tmake_file\"\n \n@@ -4602,6 +4622,8 @@ s%@CC@%$CC%g\n s%@SET_MAKE@%$SET_MAKE%g\n s%@CPP@%$CPP%g\n s%@manext@%$manext%g\n+s%@sched_prefix@%$sched_prefix%g\n+s%@sched_cflags@%$sched_cflags%g\n s%@objext@%$objext%g\n s%@subdirs@%$subdirs%g\n s%@all_languages@%$all_languages%g"}, {"sha": "17ac2f41701f93946dd00e3d22d103bb6a5dbb50", "filename": "gcc/configure.in", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -3027,6 +3027,26 @@ if [[ ! -f Makefile.in ]]; then\n \techo \"source ${srcdir}/.gdbinit\" >> .gdbinit\n fi\n \n+# Override SCHED_OBJ and SCHED_CFLAGS to enable the Haifa scheduler.\n+sched_prefix=\n+sched_cflags=\n+if [[ x$enable_haifa = xyes ]]; then\n+    echo \"Using the Haifa scheduler.\"\n+    sched_prefix=haifa-\n+    sched_cflags=-DHAIFA\n+fi\n+AC_SUBST(sched_prefix)\n+AC_SUBST(sched_cflags)\n+if [[ x$enable_haifa != x ]]; then\n+    # Explicitly remove files that need to be recompiled for the Haifa scheduler.\n+    for x in genattrtab.o toplev.o loop.o unroll.o *sched.o; do\n+\tif [ -f $x ]; then\n+\t    echo \"Removing $x\"\n+\t    rm -f $x\n+\tfi\n+    done\n+fi\n+\n # Process the language and host/target makefile fragments.\n ${CONFIG_SHELL-/bin/sh} $srcdir/configure.frag $srcdir \"$subdirs\" \"$dep_host_xmake_file\" \"$dep_tmake_file\"\n "}, {"sha": "58f5bc0af1c9a3aff80ee511d71f1a3039c889da", "filename": "gcc/flags.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -304,6 +304,34 @@ extern int flag_shared_data;\n extern int flag_schedule_insns;\n extern int flag_schedule_insns_after_reload;\n \n+#ifdef HAIFA\n+/* The following flags have effect only for scheduling before register\n+   allocation:\n+\n+   flag_schedule_interblock means schedule insns accross basic blocks.\n+   flag_schedule_speculative means allow speculative motion of non-load insns.\n+   flag_schedule_speculative_load means allow speculative motion of some\n+   load insns.\n+   flag_schedule_speculative_load_dangerous allows speculative motion of more\n+   load insns.\n+   flag_schedule_reverse_before_reload means try to reverse original order\n+   of insns (S).\n+   flag_schedule_reverse_after_reload means try to reverse original order\n+   of insns (R).  */\n+\n+extern int flag_schedule_interblock;\n+extern int flag_schedule_speculative;\n+extern int flag_schedule_speculative_load;\n+extern int flag_schedule_speculative_load_dangerous;\n+extern int flag_schedule_reverse_before_reload;\n+extern int flag_schedule_reverse_after_reload;\n+\n+/* flag_on_branch_count_reg means try to replace add-1,compare,branch tupple\n+   by a cheaper branch, on a count register. */\n+extern int flag_branch_on_count_reg;\n+#endif  /* HAIFA */\n+\n+\n /* Nonzero means put things in delayed-branch slots if supported. */\n \n extern int flag_delayed_branch;"}, {"sha": "3ca1dcf256f95ea924f97a9839cf8db659a0befe", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -268,7 +268,6 @@ static void find_auto_inc\t\tPROTO((regset, rtx, rtx));\n static void mark_used_regs\t\tPROTO((regset, regset, rtx, int, rtx));\n static int try_pre_increment_1\t\tPROTO((rtx));\n static int try_pre_increment\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n-static rtx find_use_as_address\t\tPROTO((rtx, rtx, HOST_WIDE_INT));\n void dump_flow_info\t\t\tPROTO((FILE *));\n \f\n /* Find basic blocks of the current function and perform data flow analysis.\n@@ -2795,7 +2794,7 @@ try_pre_increment (insn, reg, amount)\n    If REG appears more than once, or is used other than in such an address,\n    return (rtx)1.  */\n \n-static rtx\n+rtx\n find_use_as_address (x, reg, plusconst)\n      register rtx x;\n      rtx reg;"}, {"sha": "bde3f5199a29f325f29dff081f5b76a0fbc41654", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -2003,6 +2003,9 @@ expand_units ()\n \n \t  for (op = unit->ops; op; op = op->next)\n \t    {\n+#ifdef HAIFA\n+\t      rtx blockage = op->issue_exp;\n+#else\n \t      rtx blockage = operate_exp (POS_MINUS_OP, readycost,\n \t\t\t\t\t  make_numeric_value (1));\n \n@@ -2018,6 +2021,7 @@ expand_units ()\n \t\t\t\t      blockage);\n \n \t      blockage = operate_exp (MAX_OP, blockage, op->issue_exp);\n+#endif\n \t      blockage = simplify_knowing (blockage, unit->condexp);\n \n \t      /* Add this op's contribution to MAX (BLOCKAGE (E,*)) and"}, {"sha": "ced081416a6c6b444a97eca2ef0942c1be5d1bbe", "filename": "gcc/haifa-sched.c", "status": "added", "additions": 8713, "deletions": 0, "changes": 8713, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983"}, {"sha": "2c7ae54b993e82587eedf9d97ae6bccfec217182", "filename": "gcc/invoke.texi", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -147,7 +147,7 @@ in the following sections.\n -ffunction-sections -finline-functions\n -fkeep-inline-functions -fno-default-inline\n -fno-defer-pop  -fno-function-cse\n--fno-inline  -fno-peephole  -fomit-frame-pointer\n+-fno-inline  -fno-peephole  -fomit-frame-pointer -fregmove\n -frerun-cse-after-loop  -fschedule-insns\n -fschedule-insns2  -fstrength-reduce  -fthread-jumps\n -funroll-all-loops  -funroll-loops\n@@ -2195,6 +2195,12 @@ used in one place: in @file{reorg.c}, instead of guessing which path a\n branch is mostly to take, the @samp{REG_BR_PROB} values are used to\n exactly determine which path is taken more often.\n @end ifset\n+\n+@item -fregmove\n+Some machines only support 2 operands per instruction.  On such\n+machines, GNU CC might have to do extra copies.  The @samp{-fregmove}\n+option overrides the default for the machine to do the copy before\n+register allocation.\n @end table\n \n @node Preprocessor Options"}, {"sha": "2c4092d0c8501e05a4e2481568056ea963d7c20d", "filename": "gcc/loop.c", "status": "modified", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -81,6 +81,42 @@ static rtx *loop_number_loop_starts, *loop_number_loop_ends;\n \n int *loop_outer_loop;\n \n+#ifdef HAIFA\n+/* The main output of analyze_loop_iterations is placed here */\n+\n+int *loop_can_insert_bct;\n+\n+/* For each loop, determines whether some of its inner loops has used\n+   count register */\n+\n+int *loop_used_count_register;\n+\n+/* For each loop, remember its unrolling factor (if at all).\n+   contents of the array:\n+   0/1: not unrolled.\n+   -1: completely unrolled - no further instrumentation is needed.\n+   >1: holds the exact amount of unrolling.  */\n+\n+int *loop_unroll_factor;\n+int *loop_unroll_iter;\n+\n+/* loop parameters for arithmetic loops. These loops have a loop variable\n+   which is initialized to loop_start_value, incremented in each iteration\n+   by \"loop_increment\".  At the end of the iteration the loop variable is\n+   compared to the loop_comparison_value (using loop_comparison_code).  */\n+\n+rtx *loop_increment;\n+rtx *loop_comparison_value;\n+rtx *loop_start_value;\n+enum rtx_code *loop_comparison_code;\n+\n+/* for debugging: selects sub-range of loops for which the bct optimization\n+   is invoked.  The numbering is per compilation-unit.  */\n+int dbg_bct_min = -1;\n+int dbg_bct_max = -1;\n+#endif  /* HAIFA */\n+\n+\n /* Indexed by loop number, contains a nonzero value if the \"loop\" isn't\n    really a loop (an insn outside the loop branches into it).  */\n \n@@ -286,6 +322,32 @@ static int maybe_eliminate_biv_1 ();\n static int last_use_this_basic_block ();\n static void record_initial ();\n static void update_reg_last_use ();\n+\n+#ifdef HAIFA\n+/* This is extern from unroll.c */\n+void iteration_info ();\n+\n+/* Two main functions for implementing bct:\n+   first - to be called before loop unrolling, and the second - after */\n+static void analyze_loop_iterations ();\n+static void insert_bct ();\n+\n+/* Auxiliary function that inserts the bct pattern into the loop */\n+static void instrument_loop_bct ();\n+\n+/* Indirect_jump_in_function is computed once per function.  */\n+int indirect_jump_in_function = 0;\n+static int indirect_jump_in_function_p ();\n+\n+int loop_number ();\n+static int is_power_of_2();\n+static int is_conditional_branch ();\n+\n+/* Debugging functions.  */\n+int fix_bct_param ();\n+static int check_bct_param ();\n+#endif  /* HAIFA */\n+\n \f\n /* Relative gain of eliminating various kinds of operations.  */\n int add_cost;\n@@ -379,6 +441,32 @@ loop_optimize (f, dumpfile)\n   loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n   loop_number_exit_count = (int *) alloca (max_loop_num * sizeof (int));\n \n+#ifdef HAIFA\n+  /* Allocate for BCT optimization */\n+  loop_can_insert_bct = (int *) alloca (max_loop_num * sizeof (int));\n+  bzero ((char *) loop_can_insert_bct, max_loop_num * sizeof (int));\n+\n+  loop_used_count_register = (int *) alloca (max_loop_num * sizeof (int));\n+  bzero ((char *) loop_used_count_register, max_loop_num * sizeof (int));\n+\n+  loop_unroll_factor = (int *) alloca (max_loop_num *sizeof (int));\n+  bzero ((char *) loop_unroll_factor, max_loop_num * sizeof (int));\n+\n+  loop_unroll_iter = (int *) alloca (max_loop_num *sizeof (int));\n+  bzero ((char *) loop_unroll_iter, max_loop_num * sizeof (int));\n+\n+  loop_increment = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  loop_comparison_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  loop_start_value = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  bzero ((char *) loop_increment, max_loop_num * sizeof (rtx));\n+  bzero ((char *) loop_comparison_value, max_loop_num * sizeof (rtx));\n+  bzero ((char *) loop_start_value, max_loop_num * sizeof (rtx));\n+\n+  loop_comparison_code \n+    = (enum rtx_code *) alloca (max_loop_num * sizeof (enum rtx_code));\n+  bzero ((char *) loop_comparison_code, max_loop_num * sizeof (enum rtx_code));\n+#endif  /* HAIFA */\n+\n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n   find_and_verify_loops (f);\n@@ -430,6 +518,12 @@ loop_optimize (f, dumpfile)\n   if (flag_unroll_loops && write_symbols != NO_DEBUG)\n     find_loop_tree_blocks ();\n \n+#ifdef HAIFA\n+  /* determine if the function has indirect jump. If it does,\n+     we cannot instrument loops in this function with bct */\n+  indirect_jump_in_function = indirect_jump_in_function_p (f);\n+#endif  /* HAIFA */\n+\n   /* Now scan the loops, last ones first, since this means inner ones are done\n      before outer ones.  */\n   for (i = max_loop_num-1; i >= 0; i--)\n@@ -2639,6 +2733,11 @@ mark_loop_jump (x, loop_num)\n \n       if (loop_num != -1)\n \t{\n+#ifdef HAIFA\n+\t  LABEL_OUTSIDE_LOOP_P (x) = 1;\n+\t  LABEL_NEXTREF (x) = loop_number_exit_labels[loop_num];\n+#endif  /* HAIFA */\n+\n \t  loop_number_exit_labels[loop_num] = x;\n \n \t  for (outer_loop = loop_num; outer_loop != -1;\n@@ -3755,6 +3854,16 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n      so that \"decrement and branch until zero\" insn can be used.  */\n   check_dbra_loop (loop_end, insn_count, loop_start);\n \n+#ifdef HAIFA\n+  /* record loop-variables relevant for BCT optimization before unrolling\n+     the loop.  Unrolling may update part of this information, and the\n+     correct data will be used for generating the BCT.  */\n+#ifdef HAVE_decrement_and_branch_on_count\n+  if (HAVE_decrement_and_branch_on_count)\n+    analyze_loop_iterations (loop_start, loop_end);\n+#endif\n+#endif  /* HAIFA */\n+\n   /* Create reg_map to hold substitutions for replaceable giv regs.  */\n   reg_map = (rtx *) alloca (max_reg_before_loop * sizeof (rtx));\n   bzero ((char *) reg_map, max_reg_before_loop * sizeof (rtx));\n@@ -4247,6 +4356,14 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   if (flag_unroll_loops)\n     unroll_loop (loop_end, insn_count, loop_start, end_insert_before, 1);\n \n+#ifdef HAIFA\n+  /* instrument the loop with bct insn */\n+#ifdef HAVE_decrement_and_branch_on_count\n+  if (HAVE_decrement_and_branch_on_count)\n+    insert_bct (loop_start, loop_end);\n+#endif\n+#endif  /* HAIFA */\n+\n   if (loop_dump_stream)\n     fprintf (loop_dump_stream, \"\\n\");\n }\n@@ -6932,3 +7049,638 @@ get_condition_for_loop (x)\n   return gen_rtx (swap_condition (GET_CODE (comparison)), VOIDmode,\n \t\t  XEXP (comparison, 1), XEXP (comparison, 0));\n }\n+\n+#ifdef HAIFA\n+/* Analyze a loop in order to instrument it with the use of count register.\n+   loop_start and loop_end are the first and last insns of the loop.\n+   This function works in cooperation with insert_bct ().\n+   loop_can_insert_bct[loop_num] is set according to whether the optimization\n+   is applicable to the loop.  When it is applicable, the following variables\n+   are also set:\n+    loop_start_value[loop_num]\n+    loop_comparison_value[loop_num]\n+    loop_increment[loop_num]\n+    loop_comparison_code[loop_num] */\n+\n+static\n+void analyze_loop_iterations (loop_start, loop_end)\n+  rtx loop_start, loop_end;\n+{\n+  rtx comparison, comparison_value;\n+  rtx iteration_var, initial_value, increment;\n+  enum rtx_code comparison_code;\n+\n+  rtx last_loop_insn;\n+  rtx insn;\n+  int i;\n+\n+  /* loop_variable mode */\n+  enum machine_mode original_mode;\n+\n+  /* find the number of the loop */\n+  int loop_num = loop_number (loop_start, loop_end);\n+\n+  /* we change our mind only when we are sure that loop will be instrumented */\n+  loop_can_insert_bct[loop_num] = 0;\n+\n+  /* debugging: do we wish to instrument this loop? */\n+  if ( !check_bct_param () )\n+    return;\n+\n+  /* is the optimization suppressed.  */\n+  if ( !flag_branch_on_count_reg )\n+    return;\n+\n+  /* make sure that count-reg is not in use */\n+  if (loop_used_count_register[loop_num]){\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"analyze_loop_iterations %d: BCT instrumentation failed: count register already in use\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* make sure that the function has no indirect jumps.  */\n+  if (indirect_jump_in_function){\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+              \"analyze_loop_iterations %d: BCT instrumentation failed: indirect jump in function\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* make sure that the last loop insn is a conditional jump */\n+  last_loop_insn = PREV_INSN (loop_end);\n+  if (!is_conditional_branch (last_loop_insn)) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+              \"analyze_loop_iterations %d: BCT instrumentation failed: invalid jump at loop end\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* First find the iteration variable.  If the last insn is a conditional\n+     branch, and the insn preceding it tests a register value, make that\n+     register the iteration variable.  */\n+\n+  /* We used to use prev_nonnote_insn here, but that fails because it might\n+     accidentally get the branch for a contained loop if the branch for this\n+     loop was deleted.  We can only trust branches immediately before the\n+     loop_end.  */\n+\n+  comparison = get_condition_for_loop (last_loop_insn);\n+  /* ??? Get_condition may switch position of induction variable and\n+     invariant register when it canonicalizes the comparison.  */\n+\n+  if (comparison == 0) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"analyze_loop_iterations %d: BCT instrumentation failed: comparison not found\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  comparison_code = GET_CODE (comparison);\n+  iteration_var = XEXP (comparison, 0);\n+  comparison_value = XEXP (comparison, 1);\n+\n+  original_mode = GET_MODE (iteration_var);\n+  if (GET_MODE_CLASS (original_mode) != MODE_INT\n+      || GET_MODE_SIZE (original_mode) != UNITS_PER_WORD) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"analyze_loop_iterations %d: BCT Instrumentation failed: loop variable not integer\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* get info about loop bounds and increment */\n+  iteration_info (iteration_var, &initial_value, &increment,\n+\t\t  loop_start, loop_end);\n+\n+  /* make sure that all required loop data were found */\n+  if (!(initial_value && increment && comparison_value\n+\t&& invariant_p (comparison_value) && invariant_p (increment)\n+\t&& ! indirect_jump_in_function))\n+    {\n+      if (loop_dump_stream) {\n+\tfprintf (loop_dump_stream,\n+                \"analyze_loop_iterations %d: BCT instrumentation failed because of wrong loop: \", loop_num);\n+\tif (!(initial_value && increment && comparison_value)) {\n+\t  fprintf (loop_dump_stream, \"\\tbounds not available: \");\n+\t  if ( ! initial_value )\n+\t    fprintf (loop_dump_stream, \"initial \");\n+\t  if ( ! increment )\n+\t    fprintf (loop_dump_stream, \"increment \");\n+\t  if ( ! comparison_value )\n+\t    fprintf (loop_dump_stream, \"comparison \");\n+\t  fprintf (loop_dump_stream, \"\\n\");\n+\t}\n+\tif (!invariant_p (comparison_value) || !invariant_p (increment))\n+\t  fprintf (loop_dump_stream, \"\\tloop bounds not invariant\\n\");\n+      }\n+      return;\n+    }\n+\n+  /* make sure that the increment is constant */\n+  if (GET_CODE (increment) != CONST_INT) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+              \"analyze_loop_iterations %d: instrumentation failed: not arithmetic loop\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* make sure that the loop contains neither function call, nor jump on table.\n+     (the count register might be altered by the called function, and might\n+     be used for a branch on table).  */\n+  for (insn = loop_start; insn && insn != loop_end; insn = NEXT_INSN (insn)) {\n+    if (GET_CODE (insn) == CALL_INSN){\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+                \"analyze_loop_iterations %d: BCT instrumentation failed: function call in the loop\\n\",\n+\t\tloop_num);\n+      return;\n+    }\n+\n+    if (GET_CODE (insn) == JUMP_INSN\n+       && (GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC\n+\t   || GET_CODE (PATTERN (insn)) == ADDR_VEC)){\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+                \"analyze_loop_iterations %d: BCT instrumentation failed: computed branch in the loop\\n\",\n+\t\tloop_num);\n+      return;\n+    }\n+  }\n+\n+  /* At this point, we are sure that the loop can be instrumented with BCT.\n+     Some of the loops, however, will not be instrumented - the final decision\n+     is taken by insert_bct () */\n+  if (loop_dump_stream)\n+    fprintf (loop_dump_stream,\n+            \"analyze_loop_iterations: loop (luid =%d) can be BCT instrumented.\\n\",\n+\t    loop_num);\n+\n+  /* mark all enclosing loops that they cannot use count register */\n+  /* ???: In fact, since insert_bct may decide not to instrument this loop,\n+     marking here may prevent instrumenting an enclosing loop that could\n+    actually be instrumented.  But since this is rare, it is safer to mark\n+    here in case the order of calling  (analyze/insert)_bct would be changed.  */\n+  for (i=loop_num; i != -1; i = loop_outer_loop[i])\n+    loop_used_count_register[i] = 1;\n+\n+  /* Set data structures which will be used by the instrumentation phase */\n+  loop_start_value[loop_num] = initial_value;\n+  loop_comparison_value[loop_num] = comparison_value;\n+  loop_increment[loop_num] = increment;\n+  loop_comparison_code[loop_num] = comparison_code;\n+  loop_can_insert_bct[loop_num] = 1;\n+}\n+\n+\n+/* instrument loop for insertion of bct instruction.  We distinguish between\n+ loops with compile-time bounds, to those with run-time bounds.  The loop\n+ behaviour is analized according to the following characteristics/variables:\n+ ; Input variables:\n+ ;   comparison-value: the value to which the iteration counter is compared.\n+ ;   initial-value: iteration-counter initial value.\n+ ;   increment: iteration-counter increment.\n+ ; Computed variables:\n+ ;   increment-direction: the sign of the increment.\n+ ;   compare-direction: '1' for GT, GTE, '-1' for LT, LTE, '0' for NE.\n+ ;   range-direction: sign (comparison-value - initial-value)\n+ We give up on the following cases:\n+ ; loop variable overflow.\n+ ; run-time loop bounds with comparison code NE.\n+ */\n+\n+static void\n+insert_bct (loop_start, loop_end)\n+     rtx loop_start, loop_end;\n+{\n+  rtx initial_value, comparison_value, increment;\n+  enum rtx_code comparison_code;\n+\n+  int increment_direction, compare_direction;\n+  int unsigned_p = 0;\n+\n+  /* if the loop condition is <= or >=, the number of iteration\n+      is 1 more than the range of the bounds of the loop */\n+  int add_iteration = 0;\n+\n+  /* the only machine mode we work with - is the integer of the size that the\n+     machine has */\n+  enum machine_mode loop_var_mode = SImode;\n+\n+  int loop_num = loop_number (loop_start, loop_end);\n+\n+  /* get loop-variables. No need to check that these are valid - already\n+     checked in analyze_loop_iterations ().  */\n+  comparison_code = loop_comparison_code[loop_num];\n+  initial_value = loop_start_value[loop_num];\n+  comparison_value = loop_comparison_value[loop_num];\n+  increment = loop_increment[loop_num];\n+\n+  /* check analyze_loop_iterations decision for this loop.  */\n+  if (! loop_can_insert_bct[loop_num]){\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"insert_bct: [%d] - was decided not to instrument by analyze_loop_iterations ()\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* make sure that the loop was not fully unrolled.  */\n+  if (loop_unroll_factor[loop_num] == -1){\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream, \"insert_bct %d: was completely unrolled\\n\", loop_num);\n+    return;\n+  }\n+\n+  /* make sure that the last loop insn is a conditional jump .\n+     This check is repeated from analyze_loop_iterations (),\n+     because unrolling might have changed that.  */\n+  if (!is_conditional_branch (PREV_INSN (loop_end))){\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"insert_bct: not instrumenting BCT because of invalid branch\\n\");\n+    return;\n+  }\n+\n+  /* fix increment in case loop was unrolled.  */\n+  if (loop_unroll_factor[loop_num] > 1)\n+    increment = GEN_INT ( INTVAL (increment) * loop_unroll_factor[loop_num] );\n+\n+  /* determine properties and directions of the loop */\n+  increment_direction = (INTVAL (increment) > 0) ? 1:-1;\n+  switch ( comparison_code ) {\n+  case LEU:\n+    unsigned_p = 1;\n+    /* fallthrough */\n+  case LE:\n+    compare_direction = 1;\n+    add_iteration = 1;\n+    break;\n+  case GEU:\n+    unsigned_p = 1;\n+    /* fallthrough */\n+  case GE:\n+    compare_direction = -1;\n+    add_iteration = 1;\n+    break;\n+  case EQ:\n+    /* in this case we cannot know the number of iterations */\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+              \"insert_bct: %d: loop cannot be instrumented: == in condition\\n\",\n+\t      loop_num);\n+    return;\n+  case LTU:\n+    unsigned_p = 1;\n+    /* fallthrough */\n+  case LT:\n+    compare_direction = 1;\n+    break;\n+  case GTU:\n+    unsigned_p = 1;\n+    /* fallthrough */\n+  case GT:\n+    compare_direction = -1;\n+    break;\n+  case NE:\n+    compare_direction = 0;\n+    break;\n+  default:\n+    abort ();\n+  }\n+\n+\n+  /* make sure that the loop does not end by an overflow */\n+  if (compare_direction != increment_direction) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+              \"insert_bct: %d: loop cannot be instrumented: terminated by overflow\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  /* try to instrument the loop.  */\n+\n+  /* Handle the simpler case, where the bounds are known at compile time.  */\n+  if (GET_CODE (initial_value) == CONST_INT && GET_CODE (comparison_value) == CONST_INT)\n+    {\n+      int n_iterations;\n+      int increment_value_abs = INTVAL (increment) * increment_direction;\n+\n+      /* check the relation between compare-val and initial-val */\n+      int difference = INTVAL (comparison_value) - INTVAL (initial_value);\n+      int range_direction = (difference > 0) ? 1 : -1;\n+\n+      /* make sure the loop executes enough iterations to gain from BCT */\n+      if (difference > -3 && difference < 3) {\n+\tif (loop_dump_stream)\n+\t  fprintf (loop_dump_stream,\n+\t\t  \"insert_bct: loop %d not BCT instrumented: too small iteration count.\\n\",\n+\t\t  loop_num);\n+\treturn;\n+      }\n+\n+      /* make sure that the loop executes at least once */\n+      if ((range_direction ==  1 && compare_direction == -1)\n+\t  || (range_direction == -1 && compare_direction ==  1))\n+\t{\n+\t  if (loop_dump_stream)\n+\t    fprintf (loop_dump_stream,\n+\t\t    \"insert_bct: loop %d: does not iterate even once. Not instrumenting.\\n\",\n+\t\t    loop_num);\n+\t  return;\n+\t}\n+\n+      /* make sure that the loop does not end by an overflow (in compile time\n+         bounds we must have an additional check for overflow, because here\n+         we also support the compare code of 'NE'.  */\n+      if (comparison_code == NE\n+\t  && increment_direction != range_direction) {\n+\tif (loop_dump_stream)\n+\t  fprintf (loop_dump_stream,\n+\t\t  \"insert_bct (compile time bounds): %d: loop not instrumented: terminated by overflow\\n\",\n+\t\t  loop_num);\n+\treturn;\n+      }\n+\n+      /* Determine the number of iterations by:\n+\t ;\n+         ;                  compare-val - initial-val + (increment -1) + additional-iteration\n+         ; num_iterations = -----------------------------------------------------------------\n+         ;                                           increment\n+\t */\n+      difference = (range_direction > 0) ? difference : -difference;\n+#if 0\n+      fprintf (stderr, \"difference is: %d\\n\", difference); /* @*/\n+      fprintf (stderr, \"increment_value_abs is: %d\\n\", increment_value_abs); /* @*/\n+      fprintf (stderr, \"add_iteration is: %d\\n\", add_iteration); /* @*/\n+      fprintf (stderr, \"INTVAL (comparison_value) is: %d\\n\", INTVAL (comparison_value)); /* @*/\n+      fprintf (stderr, \"INTVAL (initial_value) is: %d\\n\", INTVAL (initial_value)); /* @*/\n+#endif\n+\n+      if (increment_value_abs == 0) {\n+\tfprintf (stderr, \"insert_bct: error: increment == 0 !!!\\n\");\n+\tabort ();\n+      }\n+      n_iterations = (difference + increment_value_abs - 1 + add_iteration)\n+\t/ increment_value_abs;\n+\n+#if 0\n+      fprintf (stderr, \"number of iterations is: %d\\n\", n_iterations); /* @*/\n+#endif\n+      instrument_loop_bct (loop_start, loop_end, GEN_INT (n_iterations));\n+\n+      /* Done with this loop.  */\n+      return;\n+    }\n+\n+  /* Handle the more complex case, that the bounds are NOT known at compile time.  */\n+  /* In this case we generate run_time calculation of the number of iterations */\n+\n+  /* With runtime bounds, if the compare is of the form '!=' we give up */\n+  if (comparison_code == NE) {\n+    if (loop_dump_stream)\n+      fprintf (loop_dump_stream,\n+\t      \"insert_bct: fail for loop %d: runtime bounds with != comparison\\n\",\n+\t      loop_num);\n+    return;\n+  }\n+\n+  else {\n+    /* We rely on the existence of run-time guard to ensure that the\n+       loop executes at least once.  */\n+    rtx sequence;\n+    rtx iterations_num_reg;\n+\n+    int increment_value_abs = INTVAL (increment) * increment_direction;\n+\n+    /* make sure that the increment is a power of two, otherwise (an\n+       expensive) divide is needed.  */\n+    if ( !is_power_of_2(increment_value_abs) )\n+      {\n+\tif (loop_dump_stream)\n+\t  fprintf (loop_dump_stream,\n+\t\t  \"insert_bct: not instrumenting BCT because the increment is not power of 2\\n\");\n+\treturn;\n+      }\n+\n+    /* compute the number of iterations */\n+    start_sequence ();\n+    {\n+      /* CYGNUS LOCAL: HAIFA bug fix */\n+      rtx temp_reg;\n+\n+      /* Again, the number of iterations is calculated by:\n+\t ;\n+         ;                  compare-val - initial-val + (increment -1) + additional-iteration\n+         ; num_iterations = -----------------------------------------------------------------\n+         ;                                           increment\n+\t */\n+      /* ??? Do we have to call copy_rtx here before passing rtx to\n+\t expand_binop?  */\n+      if (compare_direction > 0) {\n+\t/* <, <= :the loop variable is increasing */\n+\ttemp_reg = expand_binop (loop_var_mode, sub_optab, comparison_value,\n+\t\t\t\t initial_value, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+      }\n+      else {\n+\ttemp_reg = expand_binop (loop_var_mode, sub_optab, initial_value,\n+\t\t\t\t comparison_value, NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+      }\n+\n+      if (increment_value_abs - 1 + add_iteration != 0)\n+\ttemp_reg = expand_binop (loop_var_mode, add_optab, temp_reg,\n+\t\t\t\t GEN_INT (increment_value_abs - 1 + add_iteration),\n+\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\n+      if (increment_value_abs != 1)\n+\t{\n+\t  /* ??? This will generate an expensive divide instruction for\n+\t     most targets.  The original authors apparently expected this\n+\t     to be a shift, since they test for power-of-2 divisors above,\n+\t     but just naively generating a divide instruction will not give \n+\t     a shift.  It happens to work for the PowerPC target because\n+\t     the rs6000.md file has a divide pattern that emits shifts.\n+\t     It will probably not work for any other target.  */\n+\t  iterations_num_reg = expand_binop (loop_var_mode, sdiv_optab,\n+\t\t\t\t\t     temp_reg,\n+\t\t\t\t\t     GEN_INT (increment_value_abs),\n+\t\t\t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t}\n+      else\n+\titerations_num_reg = temp_reg;\n+      /* END CYGNUS LOCAL: HAIFA bug fix */\n+    }\n+    sequence = gen_sequence ();\n+    end_sequence ();\n+    emit_insn_before (sequence, loop_start);\n+    instrument_loop_bct (loop_start, loop_end, iterations_num_reg);\n+  }\n+}\n+\n+/* instrument loop by inserting a bct in it. This is done in the following way:\n+   1. A new register is created and assigned the hard register number of the count\n+    register.\n+   2. In the head of the loop the new variable is initialized by the value passed in the\n+    loop_num_iterations parameter.\n+   3. At the end of the loop, comparison of the register with 0 is generated.\n+    The created comparison follows the pattern defined for the\n+    decrement_and_branch_on_count insn, so this insn will be generated in assembly\n+    generation phase.\n+   4. The compare&branch on the old variable is deleted. So, if the loop-variable was\n+    not used elsewhere, it will be eliminated by data-flow analisys.  */\n+\n+static void\n+instrument_loop_bct (loop_start, loop_end, loop_num_iterations)\n+     rtx loop_start, loop_end;\n+     rtx loop_num_iterations;\n+{\n+  rtx temp_reg1, temp_reg2;\n+  rtx start_label;\n+\n+  rtx sequence;\n+  enum machine_mode loop_var_mode = SImode;\n+\n+#ifdef HAVE_decrement_and_branch_on_count\n+  if (HAVE_decrement_and_branch_on_count)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream, \"Loop: Inserting BCT\\n\");\n+\n+      /* eliminate the check on the old variable */\n+      delete_insn (PREV_INSN (loop_end));\n+      delete_insn (PREV_INSN (loop_end));\n+\n+      /* insert the label which will delimit the start of the loop */\n+      start_label = gen_label_rtx ();\n+      emit_label_after (start_label, loop_start);\n+\n+      /* insert initialization of the count register into the loop header */\n+      start_sequence ();\n+      temp_reg1 = gen_reg_rtx (loop_var_mode);\n+      emit_insn (gen_move_insn (temp_reg1, loop_num_iterations));\n+\n+      /* this will be count register */\n+      temp_reg2 = gen_rtx (REG, loop_var_mode, COUNT_REGISTER_REGNUM);\n+      /* we have to move the value to the count register from an GPR\n+\t because rtx pointed to by loop_num_iterations could contain\n+\t expression which cannot be moved into count register */\n+      emit_insn (gen_move_insn (temp_reg2, temp_reg1));\n+\n+      sequence = gen_sequence ();\n+      end_sequence ();\n+      emit_insn_after (sequence, loop_start);\n+\n+      /* insert new comparison on the count register instead of the\n+\t old one, generating the needed BCT pattern (that will be\n+\t later recognized by assembly generation phase).  */\n+      emit_jump_insn_before (gen_decrement_and_branch_on_count (temp_reg2, start_label),\n+\t\t\t     loop_end);\n+      LABEL_NUSES (start_label)++;\n+    }\n+\n+#endif /* HAVE_decrement_and_branch_on_count */\n+}\n+\n+/* calculate the uid of the given loop */\n+int\n+loop_number (loop_start, loop_end)\n+     rtx loop_start, loop_end;\n+{\n+  int loop_num = -1;\n+\n+  /* assume that this insn contains the LOOP_START\n+     note, so it will not be changed by the loop unrolling */\n+  loop_num = uid_loop_num[INSN_UID (loop_start)];\n+  /* sanity check - should never happen */\n+  if (loop_num == -1)\n+    abort ();\n+\n+  return loop_num;\n+}\n+\n+/* scan the function and determine whether it has indirect (computed) jump */\n+static int\n+indirect_jump_in_function_p (start)\n+     rtx start;\n+{\n+  rtx insn;\n+  int is_indirect_jump = 0;\n+\n+  for (insn = start; insn; insn = NEXT_INSN (insn)) {\n+    if (GET_CODE (insn) == JUMP_INSN) {\n+      if (GET_CODE (PATTERN (insn)) == SET) {\n+\trtx insn_work_code = XEXP (PATTERN (insn), 1);\n+\n+\tif (GET_CODE (insn_work_code) == LABEL_REF)\n+\t  continue;\n+\tif (GET_CODE (insn_work_code) == IF_THEN_ELSE) {\n+\t  rtx jump_target = XEXP (insn_work_code, 1);\n+\n+\t  if (jump_target == pc_rtx\n+\t     || (GET_CODE (jump_target) == (enum rtx_code)LABEL_REF))\n+\t    continue;\n+\t}\n+      }\n+      is_indirect_jump = 1;\n+    }\n+  }\n+  return is_indirect_jump;\n+}\n+\n+/* return 1 iff n is a power of 2 */\n+static int\n+is_power_of_2(n)\n+     int n;\n+{\n+  return (n & (n-1)) == 0;\n+}\n+\n+/* return 1 iff insn is a conditional jump */\n+is_conditional_branch (insn)\n+     rtx insn;\n+{\n+  rtx work_code;\n+  if (GET_CODE (insn) != JUMP_INSN)\n+    return 0;\n+  work_code = PATTERN (insn);\n+  if (GET_CODE (work_code) != SET)\n+    return 0;\n+  if (GET_CODE (XEXP (work_code, 1)) != IF_THEN_ELSE)\n+    return 0;\n+  return 1;\n+}\n+\n+/* debugging: fix_bct_param () is called from toplev.c upon detection\n+   of the -fbct-***-N options.  */\n+int\n+fix_bct_param (param, val)\n+     char *param, *val;\n+{\n+  if ( !strcmp (param, \"max\") )\n+    dbg_bct_max = atoi (val);\n+  else if ( !strcmp (param, \"min\") )\n+    dbg_bct_min = atoi (val);\n+}\n+\n+/* debugging: return 1 if the loop should be instrumented,\n+   according to bct-min/max.  */\n+static int\n+check_bct_param ()\n+{\n+  static int dbg_bct_num = 0;\n+\n+  dbg_bct_num++;\n+  if (dbg_bct_num > dbg_bct_min || dbg_bct_min == -1)\n+    if (dbg_bct_num <= dbg_bct_max || dbg_bct_max == -1)\n+      return 1;\n+  return 0;\n+}\n+#endif\t/* HAIFA */\n+/* END CYGNUS LOCAL haifa */"}, {"sha": "d8c83cdcab6a5f0a9993c0d96a068af861f75c96", "filename": "gcc/loop.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -181,3 +181,13 @@ rtx final_biv_value PROTO((struct iv_class *, rtx, rtx));\n rtx final_giv_value PROTO((struct induction *, rtx, rtx));\n void emit_unrolled_add PROTO((rtx, rtx, rtx));\n int back_branch_in_range_p PROTO((rtx, rtx, rtx));\n+\n+#ifdef HAIFA\n+/* variables for interaction between unroll.c and loop.c, for\n+   the insertion of branch-on-count instruction. */\n+extern int *loop_unroll_factor;\n+extern rtx *loop_start_value;\n+extern int *loop_unroll_iter;\n+extern int loop_number();\n+#endif  /* HAIFA */\n+"}, {"sha": "639059b3686702ba5698b4fc4bb82c7e9098b2be", "filename": "gcc/regmove.c", "status": "added", "additions": 983, "deletions": 0, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -0,0 +1,983 @@\n+/* Move registers around to reduce number of move instructions needed.\n+   Copyright (C) 1987, 88, 89, 92-5, 1996, 1997 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* This module looks for cases where matching constraints would force\n+   an instruction to need a reload, and this reload would be a register\n+   to register move.  It then attempts to change the registers used by the\n+   instruction to avoid the move instruction.  */\n+\n+#include \"config.h\"\n+#ifdef __STDC__\n+#include <stdarg.h>\n+#else\n+#include <varargs.h>\n+#endif\n+\n+/* Must precede rtl.h for FFS.  */\n+#include <stdio.h>\n+\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+#include \"reload.h\"\n+#include \"regs.h\"\n+\n+static int stable_but_for_p PROTO((rtx, rtx, rtx));\n+\n+#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT) \\\n+    || defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+\n+/* INC_INSN is an instruction that adds INCREMENT to REG.\n+   Try to fold INC_INSN as a post/pre in/decrement into INSN.\n+   Iff INC_INSN_SET is nonzero, inc_insn has a destination different from src.\n+   Return nonzero for success.  */\n+static int\n+try_auto_increment (insn, inc_insn, inc_insn_set, reg, increment, pre)\n+     rtx reg, insn, inc_insn ,inc_insn_set;\n+     HOST_WIDE_INT increment;\n+     int pre;\n+{\n+  enum rtx_code inc_code;\n+\n+  rtx pset = single_set (insn);\n+  if (pset)\n+    {\n+      /* Can't use the size of SET_SRC, we might have something like\n+\t (sign_extend:SI (mem:QI ...  */\n+      rtx use = find_use_as_address (pset, reg, 0);\n+      if (use != 0 && use != (rtx) 1)\n+\t{\n+\t  int size = GET_MODE_SIZE (GET_MODE (use));\n+\t  if (0\n+#ifdef HAVE_POST_INCREMENT\n+\t      || (pre == 0 && (inc_code = POST_INC, increment == size))\n+#endif\n+#ifdef HAVE_PRE_INCREMENT\n+\t      || (pre == 1 && (inc_code = PRE_INC, increment == size))\n+#endif\n+#ifdef HAVE_POST_DECREMENT\n+\t      || (pre == 0 && (inc_code = POST_DEC, increment == -size))\n+#endif\n+#ifdef HAVE_PRE_DECREMENT\n+\t      || (pre == 1 && (inc_code = PRE_DEC, increment == -size))\n+#endif\n+          )\n+            {\n+              if (inc_insn_set)\n+                validate_change\n+                  (inc_insn, \n+                   &SET_SRC (inc_insn_set),\n+\t\t   XEXP (SET_SRC (inc_insn_set), 0), 1);\n+              validate_change (insn, &XEXP (use, 0),\n+                               gen_rtx (inc_code,\n+                                        Pmode,\n+                                        reg), 1);\n+              if (apply_change_group ())\n+                {\n+                  REG_NOTES (insn)\n+                    = gen_rtx (EXPR_LIST, REG_INC,\n+                               reg, REG_NOTES (insn));\n+                  if (! inc_insn_set)\n+                    {\n+                      PUT_CODE (inc_insn, NOTE);\n+                      NOTE_LINE_NUMBER (inc_insn) = NOTE_INSN_DELETED;\n+                      NOTE_SOURCE_FILE (inc_insn) = 0;\n+                    }\n+\t\t  return 1;\n+                }\n+            }\n+        }\n+    }\n+  return 0;\n+}\n+#endif  /* defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT) */\n+\n+void\n+regmove_optimize (f, nregs, regmove_dump_file)\n+     rtx f;\n+     int nregs;\n+     FILE *regmove_dump_file;\n+{\n+#ifdef REGISTER_CONSTRAINTS\n+  rtx insn;\n+  int matches[MAX_RECOG_OPERANDS][MAX_RECOG_OPERANDS];\n+  int modified[MAX_RECOG_OPERANDS];\n+  int early_clobber[MAX_RECOG_OPERANDS];\n+  int commutative;\n+  int pass;\n+\n+  /* A forward/backward pass.  Replace output operands with input operands.  */\n+\n+  for (pass = 0; pass < 2; pass++)\n+    {\n+      if (regmove_dump_file)\n+\tfprintf (regmove_dump_file, \"Starting %s pass...\\n\",\n+\t\t pass ? \"backward\" : \"forward\");\n+\n+      for (insn = pass ? get_last_insn () : f; insn;\n+\t   insn = pass ? PREV_INSN (insn) : NEXT_INSN (insn))\n+\t{\n+\t  if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t    {\n+\t      int insn_code_number = recog_memoized (insn);\n+\t      int operand_number, match_number;\n+\t      \n+\t      if (insn_code_number < 0)\n+\t\tcontinue;\n+    \n+\t      insn_extract (insn);\n+\t      if (! constrain_operands (insn_code_number, 0))\n+\t\tcontinue;\n+\t      \n+\t      commutative = -1;\n+    \n+\t      /* Must initialize this before the loop, because the code for\n+\t\t the commutative case may set matches for operands other than\n+\t\t the current one.  */\n+\t      bzero (matches, sizeof (matches));\n+    \n+\t      for (operand_number = 0;\n+\t\t   operand_number < insn_n_operands[insn_code_number];\n+\t\t   operand_number++)\n+\t\t{\n+\t\t  int output_operand = 0;\n+\t\t  int matching_operand = operand_number;\n+\t\t  char *p, c;\n+\t\t  int i = 0;\n+    \n+\t\t  modified[operand_number] = 0;\n+\t\t  early_clobber[operand_number] = 0;\n+    \n+\t\t  p = insn_operand_constraint[insn_code_number][operand_number];\n+\n+\t\t  if (*p == '=')\n+\t\t    modified[operand_number] = 2;\n+\t\t  else if (*p == '+')\n+\t\t    modified[operand_number] = 1;\n+\n+\t\t  for (;*p && i < which_alternative; p++)\n+\t\t    if (*p == ',')\n+\t\t      i++;\n+    \n+\t\t  while ((c = *p++) != '\\0' && c != ',')\n+\t\t    switch (c)\n+\t\t      {\n+\t\t      case '=':\n+\t\t\tbreak;\n+\t\t      case '+':\n+\t\t\tbreak;\n+\t\t      case '&':\n+\t\t\tearly_clobber[operand_number] = 1;\n+\t\t\tbreak;\n+\t\t      case '%':\n+\t\t\tcommutative = operand_number;\n+\t\t\tbreak;\n+\t\t      case '0': case '1': case '2': case '3': case '4':\n+\t\t      case '5': case '6': case '7': case '8': case '9':\n+\t\t\tc -= '0';\n+\t\t\tmatches[operand_number][c] = 1;\n+\t\t\tif (commutative >= 0)\n+\t\t\t  {\n+\t\t\t    if (c == commutative || c == commutative + 1)\n+\t\t\t      {\n+\t\t\t\tint other = c + (c == commutative ? 1 : -1);\n+\t\t\t\tmatches[operand_number][other] = 1;\n+\t\t\t      }\n+\t\t\t    if (operand_number == commutative\n+\t\t\t\t|| operand_number == commutative + 1)\n+\t\t\t      {\n+\t\t\t\tint other = (operand_number\n+\t\t\t\t\t     + (operand_number == commutative\n+\t\t\t\t\t\t? 1 : -1));\n+\t\t\t\tmatches[other][c] = 1;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+    \n+\t      /* Now scan through the operands looking for a source operand\n+\t\t which is supposed to match the destination operand.\n+\t\t Then scan forward for an instruction which uses the dest\n+\t\t operand.\n+\t\t If it dies there, then replace the dest in both operands with\n+\t\t the source operand.  */\n+    \n+\t      for (operand_number = 0;\n+\t\t   operand_number < insn_n_operands[insn_code_number];\n+\t\t   operand_number++)\n+\t\t{\n+\t\t  for (match_number = 0;\n+\t\t       match_number < insn_n_operands[insn_code_number];\n+\t\t       match_number++)\n+\t\t    {\n+\t\t      rtx set, p, src, dst, src_subreg;\n+\t\t      rtx post_inc = 0, post_inc_set = 0, search_end = 0;\n+\t\t      rtx src_note, dst_note;\n+\t\t      int success = 0;\n+\t\t      int num_calls = 0;\n+\t\t      enum rtx_code code = NOTE;\n+\t\t      HOST_WIDE_INT insn_const, newconst;\n+\t\t      rtx overlap = 0; /* need to move insn ? */\n+    \n+\t\t      /* Nothing to do if the two operands aren't supposed to\n+\t\t\t match.  */\n+\t\t      if (matches[operand_number][match_number] == 0)\n+\t\t\tcontinue;\n+    \n+\t\t      src = recog_operand[operand_number];\n+\t\t      dst = recog_operand[match_number];\n+    \n+\t\t      if (GET_CODE (src) != REG\n+\t\t\t  || REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\t\t\tcontinue;\n+    \n+\t\t      src_subreg = src;\n+\t\t      if (GET_CODE (dst) == SUBREG\n+\t\t\t  && GET_MODE_SIZE (GET_MODE (dst))\n+\t\t\t     >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n+\t\t\t{\n+\t\t\t  src_subreg\n+\t\t\t    = gen_rtx(SUBREG,  GET_MODE (SUBREG_REG (dst)),\n+\t\t\t\t      src, SUBREG_WORD (dst));\n+\t\t\t  dst = SUBREG_REG (dst);\n+\t\t\t}\n+\t\t      if (GET_CODE (dst) != REG\n+\t\t\t  || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n+\t\t\tcontinue;\n+    \n+\t\t      /* If the operands already match, then there is nothing\n+\t\t\t to do.  */\n+\t\t      if (operands_match_p (src, dst))\n+\t\t\tcontinue;\n+    \n+\t\t      set = single_set (insn);\n+\t\t      if (! set)\n+\t\t\tcontinue;\n+    \n+\t\t      /* operand_number/src must be a read-only operand, and\n+\t\t\t match_operand/dst must be a write-only operand.  */\n+\t\t      if (modified[match_number] != 2)\n+\t\t\tcontinue;\n+    \n+\t\t      if (early_clobber[match_number] == 1)\n+\t\t\tcontinue;\n+    \n+\t\t      if (modified[operand_number] != 0)\n+\t\t\tcontinue;\n+    \n+\t\t      /* Make sure match_operand is the destination.  */\n+\t\t      if (recog_operand[match_number] != SET_DEST (set))\n+\t\t\tcontinue;\n+\t\t  \n+\t\t      src_note = find_reg_note (insn, REG_DEAD, src);\n+    \n+\t\t      if (! src_note)\n+\t\t\t{\n+\t\t\t  /* Look for (set (regX) (op regA constX))\n+\t\t\t\t      (set (regY) (op regA constY))\n+\t\t\t     and change that to\n+\t\t\t\t      (set (regA) (op regA constX)).\n+\t\t\t\t      (set (regY) (op regA constY-constX)).\n+\t\t\t     This works for add and shift operations, if\n+\t\t\t     regA is dead after or set by the second insn.  */\n+\n+\t\t\t  code = GET_CODE (SET_SRC (set));\n+\t\t\t  if ((code == PLUS || code == LSHIFTRT\n+\t\t\t       || code == ASHIFT || code == ASHIFTRT)\n+\t\t\t      && XEXP (SET_SRC (set), 0) == src\n+\t\t\t      && (GET_CODE (XEXP (SET_SRC (set), 1))\n+\t\t\t\t  == CONST_INT))\n+\t\t\t    insn_const = INTVAL (XEXP (SET_SRC (set), 1));\n+\t\t\t  else if (! stable_but_for_p (SET_SRC (set), src, dst))\n+\t\t\t    continue;\n+\t\t\t  else\n+\t\t\t    /* We might find a src_note while scanning.  */\n+\t\t\t    code = NOTE;\n+\t\t\t}\n+\n+\t\t      if (regmove_dump_file)\n+\t\t\tfprintf (regmove_dump_file,\n+\t\t\t\t \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t\t operand_number, INSN_UID (insn), match_number);\n+    \n+\t\t      /* ??? If src is set once, and is set equal to a\n+\t\t\t constant, then do not use it for this optimization,\n+\t\t\t as this would make it no longer equivalent to a\n+\t\t\t constant?  */\n+    \n+\t\t      /* Scan forward to find the next instruction that\n+\t\t\t uses the output operand.  If the operand dies here,\n+\t\t\t then replace it in both instructions with\n+\t\t\t operand_number.  */\n+    \n+\t\t      for (p = NEXT_INSN (insn); p; p = NEXT_INSN (p))\n+\t\t\t{\n+\t\t\t  if (GET_CODE (p) == CODE_LABEL\n+\t\t\t      || GET_CODE (p) == JUMP_INSN\n+\t\t\t      || (GET_CODE (p) == NOTE\n+\t\t\t\t  && ((NOTE_LINE_NUMBER (p)\n+\t\t\t\t       == NOTE_INSN_LOOP_BEG)\n+\t\t\t\t      || (NOTE_LINE_NUMBER (p)\n+\t\t\t\t\t  == NOTE_INSN_LOOP_END))))\n+\t\t\t    break;\n+    \n+\t\t\t  if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\t\t\t    continue;\n+    \n+\t\t\t  if (reg_set_p (src, p) || reg_set_p (dst, p)\n+\t\t\t      || (GET_CODE (PATTERN (p)) == USE\n+\t\t\t\t  && reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t      XEXP (PATTERN (p),\n+\t\t\t\t\t\t\t      0))))\n+\t\t\t    break;\n+    \n+\t\t\t  /* See if all of DST dies in P.  This test is\n+\t\t\t     slightly more conservative than it needs to be.  */\n+\t\t\t  if ((dst_note\n+\t\t\t\t= find_regno_note (p, REG_DEAD, REGNO (dst)))\n+\t\t\t      && (GET_MODE (XEXP (dst_note, 0))\n+\t\t\t\t  == GET_MODE (dst)))\n+\t\t\t    {\n+\t\t\t      if (! src_note)\n+\t\t\t\t{\n+\t\t\t\t  rtx q;\n+\t\t\t\t  rtx set2;\n+    \n+\t\t\t\t  /* If an optimization is done, the value\n+\t\t\t\t     of SRC while P is executed will be\n+\t\t\t\t     changed.  Check that this is OK.  */\n+\t\t\t\t  if (reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t       PATTERN (p)))\n+\t\t\t\t    break;\n+\t\t\t\t  for (q = p; q; q = NEXT_INSN (q))\n+\t\t\t\t    {\n+\t\t\t\t      if (GET_CODE (q) == CODE_LABEL\n+\t\t\t\t\t  || GET_CODE (q) == JUMP_INSN\n+\t\t\t\t\t  || (GET_CODE (q) == NOTE\n+\t\t\t\t\t      && ((NOTE_LINE_NUMBER (q)\n+\t\t\t\t\t\t   == NOTE_INSN_LOOP_BEG)\n+\t\t\t\t\t\t  || (NOTE_LINE_NUMBER (q)\n+\t\t\t\t\t\t      == NOTE_INSN_LOOP_END))))\n+\t\t\t\t\t{\n+\t\t\t\t\t  q = 0;\n+\t\t\t\t\t  break;\n+\t\t\t\t\t}\n+\t\t\t\t      if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t\t\t\t\tcontinue;\n+\t\t\t\t      if (reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t\t   PATTERN (q))\n+\t\t\t\t\t  || reg_set_p (src, q))\n+\t\t\t\t\tbreak;\n+\t\t\t\t    }\n+\t\t\t\t  if (q)\n+\t\t\t\t    set2 = single_set (q);\n+\t\t\t\t  if (! q || ! set2\n+\t\t\t\t      || GET_CODE (SET_SRC (set2)) != code\n+\t\t\t\t      || XEXP (SET_SRC (set2), 0) != src\n+\t\t\t\t      || (GET_CODE (XEXP (SET_SRC (set2), 1))\n+\t\t\t\t\t  != CONST_INT)\n+\t\t\t\t      || (SET_DEST (set2) != src\n+\t\t\t\t\t  && !find_reg_note (q, REG_DEAD, src)))\n+\t\t\t\t    {\n+\t\t\t\t      /* If this is a PLUS, we can still save\n+\t\t\t\t\t a register by doing\n+\t\t\t\t\t src += insn_const;\n+\t\t\t\t\t P;\n+\t\t\t\t\t src -= insn_const; .\n+\t\t\t\t\t This also gives opportunities for\n+\t\t\t\t\t subsequent optimizations in the\n+\t\t\t\t\t backward pass, so do it there.  */\n+\t\t\t\t      if (code == PLUS && pass == 1\n+#ifdef HAVE_cc0\n+\t\t\t\t\t  /* We man not emit an insn directly\n+\t\t\t\t\t     after P if the latter sets CC0.  */\n+\t\t\t\t\t  && ! sets_cc0_p (PATTERN (p))\n+#endif\n+\t\t\t\t\t  )\n+\n+\t\t\t\t\t{\n+\t\t\t\t\t  search_end = q;\n+\t\t\t\t\t  q = insn;\n+\t\t\t\t\t  set2 = set;\n+\t\t\t\t\t  newconst = -insn_const;\n+\t\t\t\t\t  code = MINUS;\n+\t\t\t\t\t}\n+\t\t\t\t      else\n+\t\t\t\t\tbreak;\n+\t\t\t\t    }\n+\t\t\t\t  else\n+\t\t\t\t    {\n+\t\t\t\t      newconst\n+\t\t\t\t\t= (INTVAL (XEXP (SET_SRC (set2), 1))\n+\t\t\t\t\t   - insn_const);\n+\t\t\t\t      /* Reject out of range shifts.  */\n+\t\t\t\t      if (code != PLUS\n+\t\t\t\t\t  && (newconst < 0\n+\t\t\t\t\t      || (newconst\n+\t\t\t\t\t\t  >= GET_MODE_BITSIZE (GET_MODE (SET_SRC (set2))))))\n+\t\t\t\t\tbreak;\n+\t\t\t\t      if (code == PLUS)\n+\t\t\t\t\t{\n+\t\t\t\t\t  post_inc = q;\n+\t\t\t\t\t  if (SET_DEST (set2) != src)\n+\t\t\t\t\t    post_inc_set = set2;\n+\t\t\t\t\t}\n+\t\t\t\t    }\n+\t\t\t\t  /* We use 1 as last argument to\n+\t\t\t\t     validate_change so that all changes\n+\t\t\t\t     are accepted or rejected together by\n+\t\t\t\t     apply_change_group when it is called\n+\t\t\t\t     by validate_replace_rtx .  */\n+\t\t\t\t  validate_change (q, &XEXP (SET_SRC (set2), 1),\n+\t\t\t\t\t\t   GEN_INT (newconst), 1);\n+\t\t\t\t}\n+\t\t\t      validate_change (insn,\n+\t\t\t\t\t       recog_operand_loc[match_number],\n+\t\t\t\t\t       src, 1);\n+\t\t\t      if (validate_replace_rtx (dst, src_subreg, p))\n+\t\t\t\tsuccess = 1;\n+\t\t\t      break;\n+\t\t\t    }\n+    \n+\t\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t\t    break;\n+\t\t\t  if (! src_note\n+\t\t\t      && reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\t\t    {\n+\t\t\t      /* INSN was already checked to be movable when\n+\t\t\t\t we found no REG_DEAD note for src on it.  */\n+\t\t\t      overlap = p;\n+\t\t\t      src_note = find_reg_note (p, REG_DEAD, src);\n+\t\t\t    }\n+    \n+\t\t\t  /* If we have passed a call instruction, and the\n+\t\t\t     pseudo-reg SRC is not already live across a call,\n+\t\t\t     then don't perform the optimization.  */\n+\t\t\t  if (GET_CODE (p) == CALL_INSN)\n+\t\t\t    {\n+\t\t\t      num_calls++;\n+    \n+\t\t\t      if (REG_N_CALLS_CROSSED (REGNO (src)) == 0)\n+\t\t\t\tbreak;\n+\t\t\t    }\n+\t\t\t}\n+    \n+\t\t      if (success)\n+\t\t\t{\n+\t\t\t  /* Remove the death note for DST from P.  */\n+\t\t\t  remove_note (p, dst_note);\n+\t\t\t  if (code == MINUS)\n+\t\t\t    {\n+\t\t\t      post_inc\n+\t\t\t\t= emit_insn_after (copy_rtx (PATTERN (insn)),\n+\t\t\t\t\t\t   p);\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+\t\t\t      if (search_end\n+\t\t\t\t  && try_auto_increment (search_end, post_inc,\n+\t\t\t\t\t\t\t 0, src, newconst, 1))\n+\t\t\t\tpost_inc = 0;\n+#endif\n+\t\t\t      validate_change (insn, &XEXP (SET_SRC (set), 1),\n+\t\t\t\t\t       GEN_INT (insn_const), 0);\n+\t\t\t      REG_N_SETS (REGNO (src))++;\n+\t\t\t    }\n+\t\t\t  if (overlap)\n+\t\t\t    {\n+\t\t\t      /* The lifetime of src and dest overlap,\n+\t\t\t\t but we can change this by moving insn.  */\n+\t\t\t      rtx pat = PATTERN (insn);\n+\t\t\t      if (src_note)\n+\t\t\t\tremove_note (overlap, src_note);\n+#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n+\t\t\t      if (code == PLUS\n+\t\t\t\t  && try_auto_increment (overlap, insn, 0,\n+\t\t\t\t\t\t\t src, insn_const, 0))\n+\t\t\t\tinsn = overlap;\n+\t\t\t      else\n+#endif\n+\t\t\t\t{\n+\t\t\t\t  emit_insn_after_with_line_notes\n+\t\t\t\t    (pat, PREV_INSN (p), insn);\n+\t\t\t\t  PUT_CODE (insn, NOTE);\n+\t\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t\t\t  /* emit_insn_after_with_line_notes\n+\t\t\t\t     has no return value, so search\n+\t\t\t\t     for the new insn.  */\n+\t\t\t\t  for (insn = p; PATTERN (insn) != pat; )\n+\t\t\t\t    insn = PREV_INSN (insn);\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  /* Sometimes we'd generate src = const; src += n;\n+\t\t\t     if so, replace the instruction that set src\n+\t\t\t     in the first place.  */\n+\t\t\t\n+\t\t\t  if (! overlap && (code == PLUS || code == MINUS))\n+\t\t\t    {\n+\t\t\t      rtx note\n+\t\t\t\t= find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\t\t\t      rtx q, set2;\n+\t\t\t      int num_calls2 = 0;\n+\n+\t\t\t      if (note && CONSTANT_P (XEXP (note, 0)))\n+\t\t\t\t{\n+\t\t\t\t  for (q = PREV_INSN (insn); q;\n+\t\t\t\t       q = PREV_INSN(q))\n+\t\t\t\t    {\n+\t\t\t\t      if (GET_CODE (q) == JUMP_INSN)\n+\t\t\t\t\t{\n+\t\t\t\t\t  q = 0;\n+\t\t\t\t\t  break;\n+\t\t\t\t\t}\n+\t\t\t\t      if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t\t\t\t\tcontinue;\n+\t\t\t\t      if (reg_set_p (src, q))\n+\t\t\t\t\t{\n+\t\t\t\t\t  set2 = single_set (q);\n+\t\t\t\t\t  break;\n+\t\t\t\t\t}\n+\t\t\t\t      if (reg_overlap_mentioned_p (src,\n+\t\t\t\t\t  PATTERN (q)))\n+\t\t\t\t\t{\n+\t\t\t\t\t  q = 0;\n+\t\t\t\t\t  break;\n+\t\t\t\t\t}\n+\t\t\t\t      if (GET_CODE (p) == CALL_INSN)\n+\t\t\t\t\tnum_calls2++;\n+\t\t\t\t    }\n+\t\t\t\t  if (q && set2 && SET_DEST (set2) == src\n+\t\t\t\t      && CONSTANT_P (SET_SRC (set2))\n+\t\t\t\t      && validate_change (insn, &SET_SRC (set),\n+\t\t\t\t\t\t\t  XEXP (note, 0), 0))\n+\t\t\t\t    {\n+\t\t\t\t      PUT_CODE (q, NOTE);\n+\t\t\t\t      NOTE_LINE_NUMBER (q) = NOTE_INSN_DELETED;\n+\t\t\t\t      NOTE_SOURCE_FILE (q) = 0;\n+\t\t\t\t      REG_N_SETS (REGNO (src))--;\n+\t\t\t\t      REG_N_CALLS_CROSSED (REGNO (src))\n+\t\t\t\t\t-= num_calls2;\n+\t\t\t\t      insn_const = 0;\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  if (0) ;\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+\t\t\t  else if ((code == PLUS || code == MINUS)\n+\t\t\t\t   && insn_const\n+\t\t\t\t   && try_auto_increment (p, insn, 0,\n+\t\t\t\t\t\t\t  src, insn_const, 1))\n+\t\t\t    insn = p;\n+#endif\n+#if defined (HAVE_POST_INCREMENT) || defined (HAVE_POST_DECREMENT)\n+\t\t\t  else if (post_inc\n+\t\t\t\t   && try_auto_increment (p, post_inc,\n+\t\t\t\t\t\t\t  post_inc_set, src,\n+\t\t\t\t\t\t\t  newconst, 0))\n+\t\t\t    post_inc = 0;\n+#endif\n+#if defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT)\n+\t\t\t  /* If post_inc still prevails, try to find an\n+\t\t\t     insn where it can be used as a pre-in/decrement.\n+\t\t\t     If code is MINUS, this was already tried.  */\n+\t\t\t  if (post_inc && code == PLUS\n+\t\t\t  /* Check that newconst is likely to be usable\n+\t\t\t     in a pre-in/decrement before starting the\n+\t\t\t     search.  */\n+\t\t\t      && (0\n+#if defined (HAVE_PRE_INCREMENT)\n+\t\t\t\t  || (newconst > 0 && newconst <= MOVE_MAX)\n+#endif\n+#if defined (HAVE_PRE_DECREMENT)\n+\t\t\t\t  || (newconst < 0 && newconst >= -MOVE_MAX)\n+#endif\n+\t\t\t\t ) && exact_log2 (newconst))\n+\t\t\t    {\n+\t\t\t      rtx q, inc_dest;\n+\n+\t\t\t      inc_dest\n+\t\t\t\t= post_inc_set ? SET_DEST (post_inc_set) : src;\n+\t\t\t      for (q = post_inc; q = NEXT_INSN (q); )\n+\t\t\t\t{\n+\t\t\t\t  if (GET_CODE (q) == CODE_LABEL\n+\t\t\t\t      || GET_CODE (q) == JUMP_INSN\n+\t\t\t\t      || (GET_CODE (q) == NOTE\n+\t\t\t\t\t  && ((NOTE_LINE_NUMBER (q)\n+\t\t\t\t\t       == NOTE_INSN_LOOP_BEG)\n+\t\t\t\t\t      || (NOTE_LINE_NUMBER (q)\n+\t\t\t\t\t\t  == NOTE_INSN_LOOP_END))))\n+\t\t\t\t    break;\n+\t\t\t\t  if (GET_RTX_CLASS (GET_CODE (q)) != 'i')\n+\t\t\t\t    continue;\n+\t\t\t\t  if (src != inc_dest\n+\t\t\t\t      && (reg_overlap_mentioned_p (src,\n+\t\t\t\t\t\t\t\t   PATTERN (q))\n+\t\t\t\t\t  || reg_set_p (src, q)))\n+\t\t\t\t    break;\n+\t\t\t\t  if (reg_set_p (inc_dest, q))\n+\t\t\t\t    break;\n+\t\t\t\t  if (reg_overlap_mentioned_p (inc_dest,\n+\t\t\t\t\t\t\t       PATTERN (q)))\n+\t\t\t\t    {\n+\t\t\t\t      try_auto_increment (q, post_inc,\n+\t\t\t\t\t\t\t  post_inc_set,\n+\t\t\t\t\t\t\t  inc_dest,\n+\t\t\t\t\t\t\t  newconst, 1);\n+\t\t\t\t      break;\n+\t\t\t\t    }\n+\t\t\t\t}\n+\t\t\t    }\n+#endif /* defined (HAVE_PRE_INCREMENT) || defined (HAVE_PRE_DECREMENT) */\n+\t\t\t  /* Move the death note for DST to INSN if it is used\n+\t\t\t     there.  */\n+\t\t\t  if (reg_overlap_mentioned_p (dst, PATTERN (insn)))\n+\t\t\t    {\n+\t\t\t      XEXP (dst_note, 1) = REG_NOTES (insn);\n+\t\t\t      REG_NOTES (insn) = dst_note;\n+\t\t\t    }\n+    \n+\t\t\t  if (src_note)\n+\t\t\t    {\n+\t\t\t      /* Move the death note for SRC from INSN to P.  */\n+\t\t\t      if (! overlap)\n+\t\t\t\tremove_note (insn, src_note);\n+\t\t\t      XEXP (src_note, 1) = REG_NOTES (p);\n+\t\t\t      REG_NOTES (p) = src_note;\n+    \n+\t\t\t      REG_N_CALLS_CROSSED (REGNO (src)) += num_calls;\n+\t\t\t    }\n+    \n+\t\t\t  REG_N_SETS (REGNO (src))++;\n+\t\t\t  REG_N_SETS (REGNO (dst))--;\n+    \n+\t\t\t  REG_N_CALLS_CROSSED (REGNO (dst)) -= num_calls;\n+    \n+\t\t\t  /* ??? Must adjust reg_live_length, and reg_n_refs for\n+\t\t\t     both registers.  Must keep track of loop_depth in\n+\t\t\t     order to get reg_n_refs adjustment correct.  */\n+    \n+\t\t\t  if (regmove_dump_file)\n+\t\t\t    fprintf (regmove_dump_file,\n+\t\t\t\t     \"Fixed operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t\t     operand_number, INSN_UID (insn),\n+\t\t\t\t     match_number);\n+    \n+\t\t\t  goto done_forwards;\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t    done_forwards:\n+\t      ;\n+\t    }\n+\t}\n+    }\n+\n+  /* A backward pass.  Replace input operands with output operands.  */\n+\n+  if (regmove_dump_file)\n+    fprintf (regmove_dump_file, \"Starting backward pass...\\n\");\n+\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  int insn_code_number = recog_memoized (insn);\n+\t  int operand_number, match_number;\n+\t  \n+\t  if (insn_code_number < 0)\n+\t    continue;\n+\n+\t  insn_extract (insn);\n+\t  if (! constrain_operands (insn_code_number, 0))\n+\t    continue;\n+\t  \n+\t  commutative = -1;\n+\n+\t  /* Must initialize this before the loop, because the code for\n+\t     the commutative case may set matches for operands other than\n+\t     the current one.  */\n+\t  bzero (matches, sizeof (matches));\n+\n+\t  for (operand_number = 0;\n+\t       operand_number < insn_n_operands[insn_code_number];\n+\t       operand_number++)\n+\t    {\n+\t      int output_operand = 0;\n+\t      int matching_operand = operand_number;\n+\t      char *p, c;\n+\t      int i = 0;\n+\n+\t      modified[operand_number] = 0;\n+\t      early_clobber[operand_number] = 0;\n+\n+\t      p = insn_operand_constraint[insn_code_number][operand_number];\n+\n+\t      if (*p == '=')\n+\t\tmodified[operand_number] = 2;\n+\t      else if (*p == '+')\n+\t\tmodified[operand_number] = 1;\n+\n+\t      for (; *p && i < which_alternative; p++)\n+\t\tif (*p == ',')\n+\t\t  i++;\n+\n+\t      while ((c = *p++) != '\\0' && c != ',')\n+\t\tswitch (c)\n+\t\t  {\n+\t\t  case '=':\n+\t\t    break;\n+\t\t  case '+':\n+\t\t    break;\n+\t\t  case '&':\n+\t\t    early_clobber[operand_number] = 1;\n+\t\t    break;\n+\t\t  case '%':\n+\t\t    commutative = operand_number;\n+\t\t    break;\n+\t\t  case '0': case '1': case '2': case '3': case '4':\n+\t\t  case '5': case '6': case '7': case '8': case '9':\n+\t\t    c -= '0';\n+\t\t    matches[c][operand_number] = 1;\n+\t\t    if (commutative >= 0)\n+\t\t      {\n+\t\t\tif (c == commutative || c == commutative + 1)\n+\t\t\t  {\n+\t\t\t    int other = c + (c == commutative ? 1 : -1);\n+\t\t\t    matches[other][operand_number] = 1;\n+\t\t\t  }\n+\t\t\tif (operand_number == commutative\n+\t\t\t    || operand_number == commutative + 1)\n+\t\t\t  {\n+\t\t\t    int other = (operand_number\n+\t\t\t\t\t + (operand_number == commutative\n+\t\t\t\t\t    ? 1 : -1));\n+\t\t\t    matches[c][other] = 1;\n+\t\t\t  }\n+\t\t      }\n+\t\t    break;\n+\t\t  }\n+\t    }\n+\n+\t  /* Now scan through the operands looking for a destination operand\n+\t     which is supposed to match a source operand.\n+\t     Then scan backward for an instruction which sets the source\n+\t     operand.  If safe, then replace the source operand with the\n+\t     dest operand in both instructions.  */\n+\n+\t  for (operand_number = 0;\n+\t       operand_number < insn_n_operands[insn_code_number];\n+\t       operand_number++)\n+\t    {\n+\t      for (match_number = 0;\n+\t\t   match_number < insn_n_operands[insn_code_number];\n+\t\t   match_number++)\n+\t\t{\n+\t\t  rtx set, p, src, dst;\n+\t\t  rtx src_note, dst_note;\n+\t\t  int success = 0;\n+\t\t  int num_calls = 0;\n+\n+\t\t  /* Nothing to do if the two operands aren't supposed to\n+\t\t     match.  */\n+\t\t  if (matches[operand_number][match_number] == 0)\n+\t\t    continue;\n+\n+\t\t  dst = recog_operand[operand_number];\n+\t\t  src = recog_operand[match_number];\n+\n+\t\t  if (GET_CODE (src) != REG\n+\t\t      || REGNO (src) < FIRST_PSEUDO_REGISTER)\n+\t\t    continue;\n+\n+\t\t  if (GET_CODE (dst) != REG\n+\t\t      || REGNO (dst) < FIRST_PSEUDO_REGISTER)\n+\t\t    continue;\n+\n+\t\t  /* If the operands already match, then there is nothing\n+\t\t     to do.  */\n+\t\t  if (operands_match_p (src, dst))\n+\t\t    continue;\n+\n+\t\t  set = single_set (insn);\n+\t\t  if (! set)\n+\t\t    continue;\n+\n+\t\t  /* operand_number/dst must be a write-only operand, and\n+\t\t     match_operand/src must be a read-only operand.  */\n+\t\t  if (modified[match_number] != 0)\n+\t\t    continue;\n+\n+\t\t  if (early_clobber[operand_number] == 1)\n+\t\t    continue;\n+\n+\t\t  if (modified[operand_number] != 2)\n+\t\t    continue;\n+\n+\t\t  /* Make sure operand_number is the destination.  */\n+\t\t  if (recog_operand[operand_number] != SET_DEST (set))\n+\t\t    continue;\n+\t      \n+\t\t  if (! (src_note = find_reg_note (insn, REG_DEAD, src)))\n+\t\t    continue;\n+\n+\t\t  /* Can not modify an earlier insn to set dst if this insn\n+\t\t     uses an old value in the source.  */\n+\t\t  if (reg_overlap_mentioned_p (dst, SET_SRC (set)))\n+\t\t    continue;\n+\n+\t\t  if (regmove_dump_file)\n+\t\t    fprintf (regmove_dump_file,\n+\t\t\t     \"Could fix operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t     operand_number, INSN_UID (insn), match_number);\n+\n+\t\t  /* ??? If src is set once, and is set equal to a constant,\n+\t\t     then do not use it for this optimization, as this would\n+\t\t     make it no longer equivalent to a constant?  */\n+\n+\t\t  /* Scan backward to find the first instruction that uses\n+\t\t     the input operand.  If the operand is set here, then\n+\t\t     replace it in both instructions with operand_number.  */\n+\n+\t\t  for (p = PREV_INSN (insn); p; p = PREV_INSN (p))\n+\t\t    {\n+\t\t      rtx pset;\n+\n+\t\t      if (GET_CODE (p) == CODE_LABEL\n+\t\t\t  || GET_CODE (p) == JUMP_INSN\n+\t\t\t  || (GET_CODE (p) == NOTE\n+\t\t\t      && (NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_BEG\n+\t\t\t\t  || NOTE_LINE_NUMBER (p) == NOTE_INSN_LOOP_END)))\n+\t\t\tbreak;\n+\n+\t\t      if (GET_RTX_CLASS (GET_CODE (p)) != 'i')\n+\t\t\tcontinue;\n+\n+\t\t      /* ??? See if all of SRC is set in P.  This test is much\n+\t\t\t more conservative than it needs to be.  */\n+\t\t      pset = single_set (p);\n+\t\t      if (pset && SET_DEST (pset) == src)\n+\t\t\t{\n+\t\t\t  /* We use validate_replace_rtx, in case there\n+\t\t\t     are multiple identical source operands.  All of\n+\t\t\t     them have to be changed at the same time.  */\n+\t\t\t  if (validate_replace_rtx (src, dst, insn))\n+\t\t\t    {\n+\t\t\t      if (validate_change (p, &SET_DEST (pset),\n+\t\t\t\t\t\t   dst, 0))\n+\t\t\t\tsuccess = 1;\n+\t\t\t      else\n+\t\t\t\t{\n+\t\t\t\t  /* Change all source operands back.\n+\t\t\t\t     This modifies the dst as a side-effect.  */\n+\t\t\t\t  validate_replace_rtx (dst, src, insn);\n+\t\t\t\t  /* Now make sure the dst is right.  */\n+\t\t\t\t  validate_change (insn,\n+\t\t\t\t\t\t   recog_operand_loc[operand_number],\n+\t\t\t\t\t\t   dst, 0);\n+\t\t\t\t}\n+\t\t\t    }\n+\t\t\t  break;\n+\t\t\t}\n+\n+\t\t      if (reg_overlap_mentioned_p (src, PATTERN (p))\n+\t\t\t  || reg_overlap_mentioned_p (dst, PATTERN (p)))\n+\t\t\tbreak;\n+\n+\t\t      /* If we have passed a call instruction, and the\n+\t\t\t pseudo-reg DST is not already live across a call,\n+\t\t\t then don't perform the optimization.  */\n+\t\t      if (GET_CODE (p) == CALL_INSN)\n+\t\t\t{\n+\t\t\t  num_calls++;\n+\n+\t\t\t  if (REG_N_CALLS_CROSSED (REGNO (dst)) == 0)\n+\t\t\t    break;\n+\t\t\t}\n+\t\t    }\n+\n+\t\t  if (success)\n+\t\t    {\n+\t\t      /* Remove the death note for SRC from INSN.  */\n+\t\t      remove_note (insn, src_note);\n+\t\t      /* Move the death note for SRC to P if it is used\n+\t\t\t there.  */\n+\t\t      if (reg_overlap_mentioned_p (src, PATTERN (p)))\n+\t\t\t{\n+\t\t\t  XEXP (src_note, 1) = REG_NOTES (p);\n+\t\t\t  REG_NOTES (p) = src_note;\n+\t\t\t}\n+\t\t      /* If there is a REG_DEAD note for DST on P, then remove\n+\t\t\t it, because DST is now set there.  */\n+\t\t      if (dst_note = find_reg_note (p, REG_DEAD, dst))\n+\t\t\tremove_note (p, dst_note);\n+\n+\t\t      REG_N_SETS (REGNO (dst))++;\n+\t\t      REG_N_SETS (REGNO (src))--;\n+\n+\t\t      REG_N_CALLS_CROSSED (REGNO (dst)) += num_calls;\n+\t\t      REG_N_CALLS_CROSSED (REGNO (src)) -= num_calls;\n+\n+\t\t      /* ??? Must adjust reg_live_length, and reg_n_refs for\n+\t\t\t both registers.  Must keep track of loop_depth in\n+\t\t\t order to get reg_n_refs adjustment correct.  */\n+\n+\t\t      if (regmove_dump_file)\n+\t\t\tfprintf (regmove_dump_file,\n+\t\t\t\t \"Fixed operand %d of insn %d matching operand %d.\\n\",\n+\t\t\t\t operand_number, INSN_UID (insn), match_number);\n+\n+\t\t      goto done_backwards;\n+\t\t    }\n+\t\t}\n+\t    }\n+\tdone_backwards:\n+\t  ;\n+\t}\n+    }\n+#endif /* REGISTER_CONSTRAINTS */\n+}\n+\n+/* return nonzero if X is stable but for mentioning SRC or mentioning /\n+   changing DST .  If in doubt, presume it is unstable.  */\n+static int\n+stable_but_for_p (x, src, dst)\n+     rtx x, src, dst;\n+{\n+  RTX_CODE code = GET_CODE (x);\n+  switch (GET_RTX_CLASS (code))\n+    {\n+    case '<': case '1': case 'c': case '2': case 'b': case '3':\n+      {\n+\tint i;\n+\tchar *fmt = GET_RTX_FORMAT (code);\n+\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t  if (fmt[i] == 'e' && ! stable_but_for_p (XEXP (x, i), src, dst))\n+\t      return 0;\n+\treturn 1;\n+      }\n+    case 'o':\n+      if (x == src || x == dst)\n+\treturn 1;\n+      /* fall through */\n+    default:\n+      return ! rtx_unstable_p (x);\n+    }\n+}"}, {"sha": "a5bdfca61d52397143d1d0b31bfde7a7c0de4b4a", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -812,6 +812,7 @@ extern void remove_note\t\tPROTO((rtx, rtx));\n extern void note_stores\t\tPROTO((rtx, void (*)()));\n extern int refers_to_regno_p\tPROTO((int, int, rtx, rtx *));\n extern int reg_overlap_mentioned_p PROTO((rtx, rtx));\n+extern rtx find_use_as_address\tPROTO((rtx, rtx, HOST_WIDE_INT));\n \n \n /* Maximum number of parallel sets and clobbers in any insn in this fn."}, {"sha": "790a51b8fd856d96860e45d85aad70132e33c740", "filename": "gcc/toplev.c", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -245,6 +245,7 @@ int cse2_dump = 0;\n int branch_prob_dump = 0;\n int flow_dump = 0;\n int combine_dump = 0;\n+int regmove_dump = 0;\n int sched_dump = 0;\n int local_reg_dump = 0;\n int global_reg_dump = 0;\n@@ -566,6 +567,35 @@ int flag_pedantic_errors = 0;\n int flag_schedule_insns = 0;\n int flag_schedule_insns_after_reload = 0;\n \n+#ifdef HAIFA\n+/* The following flags have effect only for scheduling before register\n+   allocation:\n+\n+   flag_schedule_interblock means schedule insns accross basic blocks.\n+   flag_schedule_speculative means allow speculative motion of non-load insns.\n+   flag_schedule_speculative_load means allow speculative motion of some\n+   load insns.\n+   flag_schedule_speculative_load_dangerous allows speculative motion of more\n+   load insns.\n+   flag_schedule_reverse_before_reload means try to reverse original order\n+   of insns (S).\n+   flag_schedule_reverse_after_reload means try to reverse original order\n+   of insns (R).  */\n+\n+int flag_schedule_interblock = 1;\n+int flag_schedule_speculative = 1;\n+int flag_schedule_speculative_load = 0;\n+int flag_schedule_speculative_load_dangerous = 0;\n+int flag_schedule_reverse_before_reload = 0;\n+int flag_schedule_reverse_after_reload = 0;\n+\n+\n+/* flag_on_branch_count_reg means try to replace add-1,compare,branch tupple\n+   by a cheaper branch, on a count register. */\n+int flag_branch_on_count_reg;\n+#endif  /* HAIFA */\n+\n+\n /* -finhibit-size-directive inhibits output of .size for ELF.\n    This is used only for compiling crtstuff.c, \n    and it may be extended to other effects\n@@ -616,6 +646,8 @@ int flag_check_memory_usage = 0;\n    -fcheck-memory-usage.  */\n int flag_prefix_function_name = 0;\n \n+int flag_regmove = 0;\n+\n /* 1 if alias checking is on (by default, when -O).  */\n int flag_alias_check = 0;\n \n@@ -666,6 +698,15 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"pretend-float\", &flag_pretend_float, 1},\n   {\"schedule-insns\", &flag_schedule_insns, 1},\n   {\"schedule-insns2\", &flag_schedule_insns_after_reload, 1},\n+#ifdef HAIFA\n+  {\"sched-interblock\",&flag_schedule_interblock, 1},\n+  {\"sched-spec\",&flag_schedule_speculative, 1},\n+  {\"sched-spec-load\",&flag_schedule_speculative_load, 1},\n+  {\"sched-spec-load-dangerous\",&flag_schedule_speculative_load_dangerous, 1},\n+  {\"sched-reverse-S\",&flag_schedule_reverse_before_reload, 1},\n+  {\"sched-reverse-R\",&flag_schedule_reverse_after_reload, 1},\n+  {\"branch-count-reg\",&flag_branch_on_count_reg, 1},\n+#endif  /* HAIFA */\n   {\"pic\", &flag_pic, 1},\n   {\"PIC\", &flag_pic, 2},\n   {\"exceptions\", &flag_exceptions, 1},\n@@ -680,6 +721,7 @@ struct { char *string; int *variable; int on_value;} f_options[] =\n   {\"function-sections\", &flag_function_sections, 1},\n   {\"verbose-asm\", &flag_verbose_asm, 1},\n   {\"gnu-linker\", &flag_gnu_linker, 1},\n+  {\"regmove\", &flag_regmove, 1},\n   {\"pack-struct\", &flag_pack_struct, 1},\n   {\"stack-check\", &flag_stack_check, 1},\n   {\"bytecode\", &output_bytecode, 1},\n@@ -885,6 +927,7 @@ FILE *cse2_dump_file;\n FILE *branch_prob_dump_file;\n FILE *flow_dump_file;\n FILE *combine_dump_file;\n+FILE *regmove_dump_file;\n FILE *sched_dump_file;\n FILE *local_reg_dump_file;\n FILE *global_reg_dump_file;\n@@ -905,6 +948,7 @@ int cse2_time;\n int branch_prob_time;\n int flow_time;\n int combine_time;\n+int regmove_time;\n int sched_time;\n int local_alloc_time;\n int global_alloc_time;\n@@ -1053,6 +1097,8 @@ fatal_insn (message, insn)\n     fflush (flow_dump_file);\n   if (combine_dump_file)\n     fflush (combine_dump_file);\n+  if (regmove_dump_file)\n+    fflush (regmove_dump_file);\n   if (sched_dump_file)\n     fflush (sched_dump_file);\n   if (local_reg_dump_file)\n@@ -2131,6 +2177,7 @@ compile_file (name)\n   branch_prob_time = 0;\n   flow_time = 0;\n   combine_time = 0;\n+  regmove_time = 0;\n   sched_time = 0;\n   local_alloc_time = 0;\n   global_alloc_time = 0;\n@@ -2229,6 +2276,10 @@ compile_file (name)\n   if (combine_dump)\n     combine_dump_file = open_dump_file (dump_base_name, \".combine\");\n \n+  /* If regmove dump desired, open the output file.  */\n+  if (regmove_dump)\n+    regmove_dump_file = open_dump_file (dump_base_name, \".regmove\");\n+\n   /* If scheduling dump desired, open the output file.  */\n   if (sched_dump)\n     sched_dump_file = open_dump_file (dump_base_name, \".sched\");\n@@ -2713,6 +2764,9 @@ compile_file (name)\n       fclose (combine_dump_file);\n     }\n \n+  if (regmove_dump)\n+    fclose (regmove_dump_file);\n+\n   if (sched_dump)\n     fclose (sched_dump_file);\n \n@@ -2765,6 +2819,7 @@ compile_file (name)\n \t  print_time (\"branch-prob\", branch_prob_time);\n \t  print_time (\"flow\", flow_time);\n \t  print_time (\"combine\", combine_time);\n+\t  print_time (\"regmove\", regmove_time);\n \t  print_time (\"sched\", sched_time);\n \t  print_time (\"local-alloc\", local_alloc_time);\n \t  print_time (\"global-alloc\", global_alloc_time);\n@@ -3304,6 +3359,26 @@ rest_of_compilation (decl)\n \t       fflush (combine_dump_file);\n \t     });\n \n+  if (regmove_dump)\n+    TIMEVAR (dump_time,\n+\t     {\n+\t       fprintf (regmove_dump_file, \"\\n;; Function %s\\n\\n\",\n+\t\t\t(*decl_printable_name) (decl, 2));\n+\t     });\n+\n+  /* Register allocation pre-pass, to reduce number of moves\n+     necessary for two-address machines.  */\n+  if (optimize > 0 && flag_regmove)\n+    TIMEVAR (regmove_time, regmove_optimize (insns, max_reg_num (),\n+\t\t\t\t\t     regmove_dump_file));\n+\n+  if (regmove_dump)\n+    TIMEVAR (dump_time,\n+\t     {\n+\t       print_rtl (regmove_dump_file, insns);\n+\t       fflush (regmove_dump_file);\n+\t     });\n+\n   /* Print function header into sched dump now\n      because doing the sched analysis makes some of the dump.  */\n \n@@ -3703,6 +3778,7 @@ main (argc, argv, envp)\n       flag_schedule_insns = 1;\n       flag_schedule_insns_after_reload = 1;\n #endif\n+      flag_regmove = 1;\n     }\n \n   if (optimize >= 3)\n@@ -3764,6 +3840,7 @@ main (argc, argv, envp)\n  \t\t    jump2_opt_dump = 1;\n  \t\t    local_reg_dump = 1;\n  \t\t    loop_dump = 1;\n+\t\t    regmove_dump = 1;\n  \t\t    rtl_dump = 1;\n  \t\t    cse_dump = 1, cse2_dump = 1;\n  \t\t    sched_dump = 1;\n@@ -3815,6 +3892,9 @@ main (argc, argv, envp)\n \t\t  case 't':\n \t\t    cse2_dump = 1;\n \t\t    break;\n+\t\t  case 'N':\n+\t\t    regmove_dump = 1;\n+\t\t    break;\n \t\t  case 'S':\n \t\t    sched_dump = 1;\n \t\t    break;\n@@ -3862,6 +3942,18 @@ main (argc, argv, envp)\n \n \t      if (found)\n \t\t;\n+#ifdef HAIFA\n+#ifdef INSN_SCHEDULING\n+\t      else if (!strncmp (p, \"sched-verbose-\",14))\n+\t\tfix_sched_param(\"verbose\",&p[14]);\n+\t      else if (!strncmp (p, \"sched-max-\",10))\n+\t\tfix_sched_param(\"max\",&p[10]);\n+\t      else if (!strncmp (p, \"sched-inter-max-b-\",18))\n+\t\tfix_sched_param(\"interblock-max-blocks\",&p[18]);\n+\t      else if (!strncmp (p, \"sched-inter-max-i-\",18))\n+\t\tfix_sched_param(\"interblock-max-insns\",&p[18]);\n+#endif\n+#endif  /* HAIFA */\n \t      else if (!strncmp (p, \"fixed-\", 6))\n \t\tfix_register (&p[6], 1, 1);\n \t      else if (!strncmp (p, \"call-used-\", 10))"}, {"sha": "f1864d398b4410dc17fbdf89c6cd7be248e393b3", "filename": "gcc/unroll.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c660648cab7bed53c82b8283dcf170db7e97983/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=8c660648cab7bed53c82b8283dcf170db7e97983", "patch": "@@ -202,7 +202,7 @@ static rtx initial_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void final_reg_note_copy PROTO((rtx, struct inline_remap *));\n static void copy_loop_body PROTO((rtx, rtx, struct inline_remap *, rtx, int,\n \t\t\t\t  enum unroll_types, rtx, rtx, rtx, rtx));\n-static void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n+void iteration_info PROTO((rtx, rtx *, rtx *, rtx, rtx));\n static rtx approx_final_value PROTO((enum rtx_code, rtx, int *, int *));\n static int find_splittable_regs PROTO((enum unroll_types, rtx, rtx, rtx, int));\n static int find_splittable_givs PROTO((struct iv_class *,enum unroll_types,\n@@ -1094,6 +1094,16 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t  /* Set unroll type to MODULO now.  */\n \t  unroll_type = UNROLL_MODULO;\n \t  loop_preconditioned = 1;\n+#ifdef HAIFA\n+\t  if (loop_n_iterations > 0)\n+\t    loop_unroll_iter[ loop_number(loop_start, loop_end) ]\n+\t      = (loop_n_iterations\n+\t\t  - loop_n_iterations % (abs_inc * unroll_number));\n+\t  else\n+\t    /* inform loop.c about the new initial value */\n+\t    loop_start_value[loop_number(loop_start, loop_end)] = initial_value;\n+#endif\n+\n \t}\n     }\n \n@@ -1108,6 +1118,15 @@ unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \n   /* At this point, we are guaranteed to unroll the loop.  */\n \n+#ifdef HAIFA\n+  /* inform loop.c about the factor of unrolling */\n+  if (unroll_type == UNROLL_COMPLETELY)\n+    loop_unroll_factor[ loop_number(loop_start, loop_end) ] = -1;\n+  else\n+    loop_unroll_factor[ loop_number(loop_start, loop_end) ] = unroll_number;\n+#endif  /* HAIFA */\n+\n+\n   /* For each biv and giv, determine whether it can be safely split into\n      a different variable for each unrolled copy of the loop body.\n      We precalculate and save this info here, since computing it is\n@@ -2263,7 +2282,7 @@ biv_total_increment (bl, loop_start, loop_end)\n    Initial_value and/or increment are set to zero if their values could not\n    be calculated.  */\n \n-static void\n+void\n iteration_info (iteration_var, initial_value, increment, loop_start, loop_end)\n      rtx iteration_var, *initial_value, *increment;\n      rtx loop_start, loop_end;"}]}