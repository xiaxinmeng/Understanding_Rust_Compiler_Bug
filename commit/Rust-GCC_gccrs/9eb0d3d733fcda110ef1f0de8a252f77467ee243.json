{"sha": "9eb0d3d733fcda110ef1f0de8a252f77467ee243", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWViMGQzZDczM2ZjZGExMTBlZjFmMGRlOGEyNTJmNzc0NjdlZTI0Mw==", "commit": {"author": {"name": "Christopher D. Rickett", "email": "crickett@lanl.gov", "date": "2007-07-03T21:45:59Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2007-07-03T21:45:59Z"}, "message": "re PR fortran/32579 (problem using iso_c_binding (II))\n\n2007-07-02  Christopher D. Rickett  <crickett@lanl.gov>\n\n\tPR fortran/32579\n\t* symbol.c (gen_cptr_param): Generate C_PTR and C_FUNPTR if\n\tnecessary.\n\t(build_formal_args): Pass intrinsic module symbol id to\n\tgen_cptr_param.\n\n\t* gfortran.dg/iso_c_binding_only.f03: Updated test case.\n\nFrom-SVN: r126280", "tree": {"sha": "48e68821f895d4cda0f4701e502740ebd527a4cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48e68821f895d4cda0f4701e502740ebd527a4cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9eb0d3d733fcda110ef1f0de8a252f77467ee243", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb0d3d733fcda110ef1f0de8a252f77467ee243", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb0d3d733fcda110ef1f0de8a252f77467ee243", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb0d3d733fcda110ef1f0de8a252f77467ee243/comments", "author": null, "committer": null, "parents": [{"sha": "ad22b1ff95b37a2ba2c54fa7dc4c4978784c60d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad22b1ff95b37a2ba2c54fa7dc4c4978784c60d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad22b1ff95b37a2ba2c54fa7dc4c4978784c60d4"}], "stats": {"total": 46, "additions": 37, "deletions": 9}, "files": [{"sha": "51fcdf9c49f887363c9bf7b09475edb7d14f58d0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=9eb0d3d733fcda110ef1f0de8a252f77467ee243", "patch": "@@ -1,3 +1,10 @@\n+2007-07-03  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/32579\n+\t* symbol.c (gen_cptr_param): Generate C_PTR and C_FUNPTR if necessary.\n+\t(build_formal_args): Pass intrinsic module symbol id to\n+\tgen_cptr_param.\n+\n 2007-07-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/25062"}, {"sha": "c7527bfb1c11f5f094611b0f10dd07d27a81027e", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=9eb0d3d733fcda110ef1f0de8a252f77467ee243", "patch": "@@ -3254,14 +3254,21 @@ static void\n gen_cptr_param (gfc_formal_arglist **head,\n                 gfc_formal_arglist **tail,\n                 const char *module_name,\n-                gfc_namespace *ns, const char *c_ptr_name)\n+                gfc_namespace *ns, const char *c_ptr_name,\n+                int iso_c_sym_id)\n {\n   gfc_symbol *param_sym = NULL;\n   gfc_symbol *c_ptr_sym = NULL;\n   gfc_symtree *param_symtree = NULL;\n   gfc_formal_arglist *formal_arg = NULL;\n   const char *c_ptr_in;\n-  const char *c_ptr_type = \"c_ptr\";\n+  const char *c_ptr_type = NULL;\n+\n+  if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n+    c_ptr_type = \"_gfortran_iso_c_binding_c_funptr\";\n+\n+  else\n+    c_ptr_type = \"_gfortran_iso_c_binding_c_ptr\";\n \n   if(c_ptr_name == NULL)\n     c_ptr_in = \"gfc_cptr__\";\n@@ -3285,15 +3292,22 @@ gen_cptr_param (gfc_formal_arglist **head,\n   param_sym->attr.value = 1;\n   param_sym->attr.use_assoc = 1;\n \n-  /* Get the symbol for c_ptr, no matter what it's name is (user renamed).  */\n+  /* Get the symbol for c_ptr or c_funptr, no matter what it's name is \n+     (user renamed).  */\n+  if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n+    c_ptr_sym = get_iso_c_binding_dt (ISOCBINDING_FUNPTR);\n+  else\n   c_ptr_sym = get_iso_c_binding_dt (ISOCBINDING_PTR);\n   if (c_ptr_sym == NULL)\n     {\n       /* This can happen if the user did not define c_ptr but they are\n          trying to use one of the iso_c_binding functions that need it.  */\n-      gfc_error_now (\"Type 'C_PTR' required for ISO_C_BINDING function at %C\");\n+      if (iso_c_sym_id == ISOCBINDING_F_PROCPOINTER)\n+\tgenerate_isocbinding_symbol (module_name, ISOCBINDING_FUNPTR,\n+\t\t\t\t     (char *)c_ptr_type);\n+      else\n       generate_isocbinding_symbol (module_name, ISOCBINDING_PTR,\n-                                   (char *) \"_gfortran_iso_c_binding_c_ptr\");\n+\t\t\t\t     (char *)c_ptr_type);\n \n       gfc_get_ha_symbol (c_ptr_type, &(c_ptr_sym));\n     }\n@@ -3455,7 +3469,7 @@ build_formal_args (gfc_symbol *new_proc_sym,\n       (old_sym->intmod_sym_id == ISOCBINDING_F_PROCPOINTER))\n     {\n       gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"cptr\");\n+\t\t      gfc_current_ns, \"cptr\", old_sym->intmod_sym_id);\n       gen_fptr_param (&head, &tail, (const char *) new_proc_sym->module,\n \t\t      gfc_current_ns, \"fptr\");\n \n@@ -3472,11 +3486,11 @@ build_formal_args (gfc_symbol *new_proc_sym,\n       /* c_associated has one required arg and one optional; both\n \t are c_ptrs.  */\n       gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t      gfc_current_ns, \"c_ptr_1\");\n+\t\t      gfc_current_ns, \"c_ptr_1\", ISOCBINDING_ASSOCIATED);\n       if (add_optional_arg)\n \t{\n \t  gen_cptr_param (&head, &tail, (const char *) new_proc_sym->module,\n-\t\t\t  gfc_current_ns, \"c_ptr_2\");\n+\t\t\t  gfc_current_ns, \"c_ptr_2\", ISOCBINDING_ASSOCIATED);\n \t  /* The last param is optional so mark it as such.  */\n \t  tail->sym->attr.optional = 1;\n \t}"}, {"sha": "fc5dca36f8ccb93435b8db0776da7ee4c5c94ff8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9eb0d3d733fcda110ef1f0de8a252f77467ee243", "patch": "@@ -1,3 +1,8 @@\n+2007-07-03  Christopher D. Rickett  <crickett@lanl.gov>\n+\n+\tPR fortran/32579\n+        * gfortran.dg/iso_c_binding_only.f03: Updated test case.\n+\n 2007-07-03  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/25062"}, {"sha": "dff4318e806ac42914a9f42365115d5ce91be4ac", "filename": "gcc/testsuite/gfortran.dg/iso_c_binding_only.f03", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9eb0d3d733fcda110ef1f0de8a252f77467ee243/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiso_c_binding_only.f03?ref=9eb0d3d733fcda110ef1f0de8a252f77467ee243", "patch": "@@ -1,6 +1,8 @@\n ! { dg-do compile }\n module iso_c_binding_only\n-  use, intrinsic :: iso_c_binding, only: c_null_ptr\n+  ! c_f_procpointer verifies that the c_funptr derived type for the cptr param\n+  ! is auto-generated, and c_f_pointer tests c_ptr.\n+  use, intrinsic :: iso_c_binding, only: c_null_ptr, c_f_procpointer\n   ! This should be allowed since the C_PTR that the C_NULL_PTR needs will use\n   ! a mangled name to prevent collisions.\n   integer :: c_ptr"}]}