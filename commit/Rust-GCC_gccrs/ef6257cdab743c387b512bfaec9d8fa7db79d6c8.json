{"sha": "ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY2MjU3Y2RhYjc0M2MzODdiNTEyYmZhZWM5ZDhmYTdkYjc5ZDZjOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-06-06T12:57:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-06-06T12:57:31Z"}, "message": "i386.md (floatdi?f): Avoid usinf of SSE instructions if TARGET_64BIT is false.\n\n\t* i386.md (floatdi?f): Avoid usinf of SSE instructions\n\tif TARGET_64BIT is false.\n\t(floatdi?f_i386_only): New insn.\n\t(floatdi?f_i386): Disable for !TARGET_64BIT.\n\n\t* (min?f, max?f splitters): Handle case where\n\toperands are cross-matched.\n\n\t* i386.h (HI_REGISTER_NAMES): Remove redundant definition\n\t(MMX_REGISTER_NAMES): Kill.\n\t(PRINT_OPERAND): Fix comment.\n\t(PRINT_REG): Likewise.\n\t* i386.c (print_reg): Kill support for 'm' CODE; simplify.\n\t(print_operand): Update comment; kill 'm'.\n\n\t* i386.c (x86_branch_hints): New global variable\n\t(print_operand): Support outputting of branch prediction hints.\n\t* i386.md (conditional jump patterns): Add branch prediction hints\n\tto the template.\n\t* i386.h (x86_branch_hints): Declare\n\t(TARGET_BRANCH_PREDICTION_HINTS): New macro.\n\t(PRINT_OPERAND_FUNCT_VALID_P): New.\n\t* final.c (final_forward_branch_p): New function.\n\nFrom-SVN: r42945", "tree": {"sha": "670901c9a6689cc4d8ee69e5505e146e4e0b394c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/670901c9a6689cc4d8ee69e5505e146e4e0b394c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/comments", "author": null, "committer": null, "parents": [{"sha": "3b8fd08f822157da91aa63c77f44e7bd0960c7d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b8fd08f822157da91aa63c77f44e7bd0960c7d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b8fd08f822157da91aa63c77f44e7bd0960c7d7"}], "stats": {"total": 270, "additions": 194, "deletions": 76}, "files": [{"sha": "e04cd659c635666fc21f71cd104cf32dc61c9a4e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "patch": "@@ -1,3 +1,29 @@\n+Wed Jun  6 14:51:05 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.md (floatdi?f): Avoid usinf of SSE instructions\n+\tif TARGET_64BIT is false.\n+\t(floatdi?f_i386_only): New insn.\n+\t(floatdi?f_i386): Disable for !TARGET_64BIT.\n+\n+\t* (min?f, max?f splitters): Handle case where\n+\toperands are cross-matched.\n+\n+\t* i386.h (HI_REGISTER_NAMES): Remove redundant definition\n+\t(MMX_REGISTER_NAMES): Kill.\n+\t(PRINT_OPERAND): Fix comment.\n+\t(PRINT_REG): Likewise.\n+\t* i386.c (print_reg): Kill support for 'm' CODE; simplify.\n+\t(print_operand): Update comment; kill 'm'.\n+\n+\t* i386.c (x86_branch_hints): New global variable\n+\t(print_operand): Support outputting of branch prediction hints.\n+\t* i386.md (conditional jump patterns): Add branch prediction hints\n+\tto the template.\n+\t* i386.h (x86_branch_hints): Declare\n+\t(TARGET_BRANCH_PREDICTION_HINTS): New macro.\n+\t(PRINT_OPERAND_FUNCT_VALID_P): New.\n+\t* final.c (final_forward_branch_p): New function.\n+\n 2001-06-06  Richard Henderson  <rth@redhat.com>\n \n \t* flow.c (mark_used_reg): Clean up looping over multiple hard"}, {"sha": "275788e48d494fb2c0883979fe90386519ccbb1f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "patch": "@@ -290,6 +290,7 @@ const int x86_use_bit_test = m_386;\n const int x86_unroll_strlen = m_486 | m_PENT | m_PPRO | m_ATHLON | m_K6;\n const int x86_cmove = m_PPRO | m_ATHLON | m_PENT4;\n const int x86_deep_branch = m_PPRO | m_K6 | m_ATHLON | m_PENT4;\n+const int x86_branch_hints = m_PENT4;\n const int x86_use_sahf = m_PPRO | m_K6 | m_PENT4;\n const int x86_partial_reg_stall = m_PPRO;\n const int x86_use_loop = m_K6;\n@@ -3796,7 +3797,7 @@ print_reg (x, code, file)\n   if (ASSEMBLER_DIALECT == 0 || USER_LABEL_PREFIX[0] == 0)\n     putc ('%', file);\n \n-  if (code == 'w')\n+  if (code == 'w' || MMX_REG_P (x))\n     code = 2;\n   else if (code == 'b')\n     code = 1;\n@@ -3808,8 +3809,6 @@ print_reg (x, code, file)\n     code = 3;\n   else if (code == 'h')\n     code = 0;\n-  else if (code == 'm' || MMX_REG_P (x))\n-    code = 5;\n   else\n     code = GET_MODE_SIZE (GET_MODE (x));\n \n@@ -3821,7 +3820,7 @@ print_reg (x, code, file)\n \tabort ();\n       switch (code)\n \t{\n-\t  case 5:\n+\t  case 0:\n \t    error (\"Extended registers have no high halves\\n\");\n \t    break;\n \t  case 1:\n@@ -3844,9 +3843,6 @@ print_reg (x, code, file)\n     }\n   switch (code)\n     {\n-    case 5:\n-      fputs (hi_reg_name[REGNO (x)], file);\n-      break;\n     case 3:\n       if (STACK_TOP_P (x))\n \t{\n@@ -3879,6 +3875,7 @@ print_reg (x, code, file)\n    L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n    C -- print opcode suffix for set/cmov insn.\n    c -- like C, but print reversed condition\n+   F,f -- likewise, but for floating-point.\n    R -- print the prefix for register names.\n    z -- print the opcode suffix for the size of the current operand.\n    * -- print a star (in certain assembler syntax)\n@@ -3891,10 +3888,11 @@ print_reg (x, code, file)\n    w --  likewise, print the HImode name of the register.\n    k --  likewise, print the SImode name of the register.\n    q --  likewise, print the DImode name of the register.\n-   h --  print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n-   y --  print \"st(0)\" instead of \"st\" as a register.\n-   m --  print \"st(n)\" as an mmx register.\n+   h -- print the QImode name for a \"high\" register, either ah, bh, ch or dh.\n+   y -- print \"st(0)\" instead of \"st\" as a register.\n    D -- print condition for SSE cmp instruction.\n+   P -- if PIC, print an @PLT suffix.\n+   X -- don't print any sort of PIC '@' suffix for a symbol.\n  */\n \n void\n@@ -4017,7 +4015,6 @@ print_operand (file, x, code)\n \tcase 'q':\n \tcase 'h':\n \tcase 'y':\n-\tcase 'm':\n \tcase 'X':\n \tcase 'P':\n \t  break;\n@@ -4085,7 +4082,39 @@ print_operand (file, x, code)\n \tcase 'f':\n \t  put_condition_code (GET_CODE (x), GET_MODE (XEXP (x, 0)), 1, 1, file);\n \t  return;\n+\tcase '+':\n+\t  {\n+\t    rtx x;\n \n+\t    if (!optimize || optimize_size || !TARGET_BRANCH_PREDICTION_HINTS)\n+\t      return;\n+\t    \n+\t    x = find_reg_note (current_output_insn, REG_BR_PROB, 0);\n+\t    if (x)\n+\t      {\n+\t\tint pred_val = INTVAL (XEXP (x, 0));\n+\n+\t\tif (pred_val < REG_BR_PROB_BASE * 45 / 100\n+\t\t    || pred_val > REG_BR_PROB_BASE * 55 / 100)\n+\t\t  {\n+\t\t    int taken = pred_val > REG_BR_PROB_BASE / 2;\n+\t\t    int cputaken = final_forward_branch_p (current_output_insn) == 0;\n+\n+\t\t    /* Emit hints only in the case default branch prediction\n+\t\t       heruistics would fail.  */\n+\t\t    if (taken != cputaken)\n+\t\t      {\n+\t\t\t/* We use 3e (DS) prefix for taken branches and\n+\t\t\t   2e (CS) prefix for not taken branches.  */\n+\t\t\tif (taken)\n+\t\t\t  fputs (\"ds ; \", file);\n+\t\t\telse\n+\t\t\t  fputs (\"cs ; \", file);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    return;\n+\t  }\n \tdefault:\n \t  {\n \t    char str[50];"}, {"sha": "f1f8bef8d22d8d579d449df6af848c143337835b", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "patch": "@@ -202,7 +202,7 @@ extern int target_flags;\n #define CPUMASK (1 << ix86_cpu)\n extern const int x86_use_leave, x86_push_memory, x86_zero_extend_with_and;\n extern const int x86_use_bit_test, x86_cmove, x86_deep_branch;\n-extern const int x86_unroll_strlen;\n+extern const int x86_branch_hints, x86_unroll_strlen;\n extern const int x86_double_with_add, x86_partial_reg_stall, x86_movx;\n extern const int x86_use_loop, x86_use_fiop, x86_use_mov0;\n extern const int x86_use_cltd, x86_read_modify_write;\n@@ -222,6 +222,7 @@ extern const int x86_partial_reg_dependency, x86_memory_mismatch_stall;\n    safe to enable all CMOVE instructions.  */\n #define TARGET_CMOVE ((x86_cmove & (1 << ix86_arch)) || TARGET_SSE)\n #define TARGET_DEEP_BRANCH_PREDICTION (x86_deep_branch & CPUMASK)\n+#define TARGET_BRANCH_PREDICTION_HINTS (x86_branch_hints & CPUMASK)\n #define TARGET_DOUBLE_WITH_ADD (x86_double_with_add & CPUMASK)\n #define TARGET_USE_SAHF ((x86_use_sahf & CPUMASK) && !TARGET_64BIT)\n #define TARGET_MOVX (x86_movx & CPUMASK)\n@@ -2755,11 +2756,6 @@ while (0)\n    For float regs, the stack top is sometimes referred to as \"%st(0)\"\n    instead of just \"%st\".  PRINT_REG handles this with the \"y\" code.  */\n \n-#define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n-{\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n- \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n- \"flags\",\"fpsr\", \"dirflag\", \"frame\" }\n-\n #undef  HI_REGISTER_NAMES\t\t\t\t\t\t\n #define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n {\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n@@ -2798,9 +2794,6 @@ number as al, and ax.\n #define QI_HIGH_REGISTER_NAMES \\\n {\"ah\", \"dh\", \"ch\", \"bh\", }\n \n-#define MMX_REGISTER_NAMES \\\n-{0,0,0,0,0,0,0,0,\"mm0\",\"mm1\",\"mm2\",\"mm3\",\"mm4\",\"mm5\",\"mm6\",\"mm7\"}\n-\n /* How to renumber registers for dbx and gdb.  */\n \n #define DBX_REGISTER_NUMBER(n) \\\n@@ -2970,33 +2963,19 @@ do { long l;\t\t\t\t\t\t\\\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   The CODE z takes the size of operand from the following digit, and\n-   outputs b,w,or l respectively.\n-\n-   On the 80386, we use several such letters:\n-   f -- float insn (print a CONST_DOUBLE as a float rather than in hex).\n-   L,W,B,Q,S,T -- print the opcode suffix for specified size of operand.\n-   R -- print the prefix for register names.\n-   z -- print the opcode suffix for the size of the current operand.\n-   * -- print a star (in certain assembler syntax)\n-   A -- print an absolute memory reference.\n-   P -- if PIC, print an @PLT suffix.\n-   X -- don't print any sort of PIC '@' suffix for a symbol.\n-   s -- ??? something to do with double shifts.  not actually used, afaik.\n-   C -- print a conditional move suffix corresponding to the op code.\n-   c -- likewise, but reverse the condition.\n-   F,f -- likewise, but for floating-point.  */\n+   Effect of various CODE letters is described in i386.c near\n+   print_operand function.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '*')\n+  ((CODE) == '*' || (CODE) == '+')\n \n /* Print the name of a register based on its machine mode and number.\n    If CODE is 'w', pretend the mode is HImode.\n    If CODE is 'b', pretend the mode is QImode.\n    If CODE is 'k', pretend the mode is SImode.\n-   If CODE is 'd', pretend the mode is DImode.\n+   If CODE is 'q', pretend the mode is DImode.\n    If CODE is 'h', pretend the reg is the `high' byte register.\n-   If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op. */\n+   If CODE is 'y', print \"st(0)\" instead of \"st\", if the reg is stack op.  */\n \n #define PRINT_REG(X, CODE, FILE)  \\\n   print_reg (X, CODE, FILE)"}, {"sha": "015bd83be634d6c55f301bdafe80b442c9cd248b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 102, "deletions": 37, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "patch": "@@ -4721,7 +4721,7 @@\n   \"TARGET_80387 || (TARGET_SSE2 && TARGET_64BIT)\"\n   \"\n {\n-  if (TARGET_SSE2)\n+  if (TARGET_SSE2 && TARGET_64BIT)\n    {\n      rtx out = REG_P (operands[0]) ? operands[0] : gen_reg_rtx (DImode);\n      emit_insn (gen_fix_truncdfdi_sse (out, operands[1]));\n@@ -4746,7 +4746,7 @@\n   \"TARGET_80387 || (TARGET_SSE && TARGET_64BIT)\"\n   \"\n {\n-  if (TARGET_SSE2)\n+  if (TARGET_SSE2 && TARGET_64BIT)\n    {\n      rtx out = REG_P (operands[0]) ? operands[0] : gen_reg_rtx (DImode);\n      emit_insn (gen_fix_truncsfdi_sse (out, operands[1]));\n@@ -5070,10 +5070,21 @@\n   \"(TARGET_SSE && TARGET_64BIT) || TARGET_80387\"\n   \"\")\n \n+(define_insn \"*floatdisf2_i387_only\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,?f\")\n+\t(float:SF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_80387 && (!TARGET_SSE || !TARGET_64BIT || TARGET_MIX_SSE_I387)\"\n+  \"@\n+   fild%z1\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"SF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n (define_insn \"*floatdisf2_i387\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f,?f,x\")\n \t(float:SF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r,mr\")))]\n-  \"TARGET_80387 && (!TARGET_SSE || !TARGET_64BIT || TARGET_MIX_SSE_I387)\"\n+  \"TARGET_80387 && TARGET_64BIT && (!TARGET_SSE || TARGET_MIX_SSE_I387)\"\n   \"@\n    fild%z1\\\\t%1\n    #\n@@ -5135,10 +5146,21 @@\n   \"TARGET_80387 || (TARGET_SSE2 && TARGET_64BIT)\"\n   \"\")\n \n+(define_insn \"*floatdidf2_i387_only\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,?f\")\n+\t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r\")))]\n+  \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_64BIT)\"\n+  \"@\n+   fild%z1\\\\t%1\n+   #\"\n+  [(set_attr \"type\" \"fmov,multi\")\n+   (set_attr \"mode\" \"DF\")\n+   (set_attr \"fp_int_src\" \"true\")])\n+\n (define_insn \"*floatdidf2_i387\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f,?f,Y\")\n \t(float:DF (match_operand:DI 1 \"nonimmediate_operand\" \"m,r,mr\")))]\n-  \"TARGET_80387 && (!TARGET_SSE2 || !TARGET_64BIT || TARGET_MIX_SSE_I387)\"\n+  \"TARGET_80387 && TARGET_64BIT && (!TARGET_SSE2 || TARGET_MIX_SSE_I387)\"\n   \"@\n    fild%z1\\\\t%1\n    #\n@@ -5585,6 +5607,8 @@\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((1 << 31) - 1)))\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t\t  && INTVAL (operands[2]) != -128)))\n@@ -5656,6 +5680,8 @@\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((1 << 31) - 1)))\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t\t  && INTVAL (operands[2]) != -128)))\n@@ -5705,6 +5731,8 @@\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((1 << 31) - 1)))\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t\t  && INTVAL (operands[2]) != -128)))\n@@ -5755,7 +5783,9 @@\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if ((INTVAL (operands[2]) == -128\n \t   || (INTVAL (operands[2]) > 0\n-\t       && INTVAL (operands[2]) != 128)))\n+\t       && INTVAL (operands[2]) != 128))\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((1 << 31) - 1))))\n \treturn \\\"sub{q}\\\\t{%2, %0|%0, %2}\\\";\n       operands[2] = GEN_INT (-INTVAL (operands[2]));\n       return \\\"add{q}\\\\t{%2, %0|%0, %2}\\\";\n@@ -5800,6 +5830,8 @@\n       /* Make things pretty and `subl $4,%eax' rather than `addl $-4, %eax'.\n \t Exceptions: -128 encodes smaller than 128, so swap sign and op.  */\n       if (GET_CODE (operands[2]) == CONST_INT\n+\t  /* Avoid overflows.  */\n+\t  && ((INTVAL (operands[2]) & ((1 << 31) - 1)))\n           && (INTVAL (operands[2]) == 128\n \t      || (INTVAL (operands[2]) < 0\n \t\t  && INTVAL (operands[2]) != -128)))\n@@ -12750,7 +12782,7 @@\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n   \"\"\n-  \"j%C1\\\\t%l0\"\n+  \"%+j%C1\\\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set (attr \"prefix_0f\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n@@ -12767,7 +12799,7 @@\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n   \"\"\n-  \"j%c1\\\\t%l0\"\n+  \"%+j%c1\\\\t%l0\"\n   [(set_attr \"type\" \"ibr\")\n    (set (attr \"prefix_0f\")\n \t   (if_then_else (and (ge (minus (match_dup 0) (pc))\n@@ -13110,9 +13142,9 @@\n   if (which_alternative != 0)\n     return \\\"#\\\";\n   if (get_attr_length (insn) == 2)\n-    return \\\"loop\\\\t%l0\\\";\n+    return \\\"%+loop\\\\t%l0\\\";\n   else\n-    return \\\"dec{l}\\\\t%1\\;jne\\\\t%l0\\\";\n+    return \\\"dec{l}\\\\t%1\\;%+jne\\\\t%l0\\\";\n }\"\n   [(set_attr \"ppro_uops\" \"many\")\n    (set (attr \"type\")\n@@ -15806,25 +15838,34 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (match_dup 0)\n \t(if_then_else:SF (lt (match_dup 1)\n \t\t\t     (match_dup 2))\n \t\t\t (match_dup 1)\n \t\t\t (match_dup 2)))])\n \n ;; We can't represent the LT test directly.  Do this by swapping the operands.\n+\n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (lt (match_operand:SF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC 17))]\n-  \"FP_REG_P (operands[0]) && reload_completed\"\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (reg:CCFP 17)\n \t(compare:CCFP (match_dup 2)\n \t\t      (match_dup 1)))\n@@ -15879,10 +15920,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (match_dup 0)\n \t(if_then_else:DF (lt (match_dup 1)\n \t\t\t     (match_dup 2))\n@@ -15894,10 +15939,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (lt (match_operand:DF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC 17))]\n-  \"FP_REG_P (operands[0]) && reload_completed\"\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (reg:CCFP 17)\n \t(compare:CCFP (match_dup 2)\n \t\t      (match_dup 2)))\n@@ -15952,10 +16001,14 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:SF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 4 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (match_dup 0)\n \t(if_then_else:SF (gt (match_dup 1)\n \t\t\t     (match_dup 2))\n@@ -15966,10 +16019,14 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(if_then_else:SF (gt (match_operand:SF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:SF 2 \"register_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC 17))]\n-  \"FP_REG_P (operands[0]) && reload_completed\"\n+\t\t\t (match_operand:SF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:SF 4 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (reg:CCFP 17)\n \t(compare:CCFP (match_dup 1)\n \t\t      (match_dup 2)))\n@@ -16024,10 +16081,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:DF 2 \"nonimmediate_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"nonimmediate_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"SSE_REG_P (operands[0]) && reload_completed\"\n+  \"SSE_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (match_dup 0)\n \t(if_then_else:DF (gt (match_dup 1)\n \t\t\t     (match_dup 2))\n@@ -16038,10 +16099,14 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n \t(if_then_else:DF (gt (match_operand:DF 1 \"register_operand\" \"\")\n \t\t\t     (match_operand:DF 2 \"register_operand\" \"\"))\n-\t\t\t (match_dup 1)\n-\t\t\t (match_dup 2)))\n-   (clobber (reg:CC 17))]\n-  \"FP_REG_P (operands[0]) && reload_completed\"\n+\t\t\t (match_operand:DF 3 \"register_operand\" \"\")\n+\t\t\t (match_operand:DF 4 \"register_operand\" \"\")))\n+   (clobber (reg:CC 17))]\n+  \"FP_REG_P (operands[0]) && reload_completed\n+   && ((operands_match_p (operands[1], operands[3])\n+\t&& operands_match_p (operands[2], operands[4]))\n+       || (operands_match_p (operands[1], operands[4])\n+\t   && operands_match_p (operands[2], operands[3])))\"\n   [(set (reg:CCFP 17)\n \t(compare:CCFP (match_dup 1)\n \t\t      (match_dup 2)))"}, {"sha": "7b36b1b41020b44e577f775fca857c60035c1e70", "filename": "gcc/final.c", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef6257cdab743c387b512bfaec9d8fa7db79d6c8/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef6257cdab743c387b512bfaec9d8fa7db79d6c8", "patch": "@@ -4086,6 +4086,25 @@ leaf_function_p ()\n   return 1;\n }\n \n+/* Return 1 if branch is an forward branch.\n+   Uses insn_shuid array, so it works only in the final pass.  May be used by\n+   output templates to customary add branch prediction hints.\n+ */\n+int\n+final_forward_branch_p (insn)\n+     rtx insn;\n+{\n+  int insn_id, label_id;\n+  if (!uid_shuid)\n+    abort ();\n+  insn_id = INSN_SHUID (insn);\n+  label_id = INSN_SHUID (JUMP_LABEL (insn));\n+  /* We've hit some insns that does not have id information available.  */\n+  if (!insn_id || !label_id)\n+    abort ();\n+  return insn_id < label_id;\n+}\n+\n /* On some machines, a function with no call insns\n    can run faster if it doesn't create its own register window.\n    When output, the leaf function should use only the \"output\""}]}