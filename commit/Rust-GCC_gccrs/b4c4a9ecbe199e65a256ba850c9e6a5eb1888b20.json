{"sha": "b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRjNGE5ZWNiZTE5OWU2NWEyNTZiYTg1MGM5ZTZhNWViMTg4OGIyMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-03-28T17:47:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-03-28T17:47:07Z"}, "message": "pt.c (tsubst): Clear TREE_USED for new FUNCTION_DECLs.\n\n\t* pt.c (tsubst): Clear TREE_USED for new FUNCTION_DECLs.\n\t* pt.c (instantiate_class_template): Make sure template\n\targuments are permanent.\n\t* init.c (resolve_offset_ref): Don't go looking around in\n\ttemplate types.\n\t* semantics.c: Add routines to handle expressions, and some\n\tdeclaration processing.\n\t* parse.y: Use them.\n\t(current_class_depth): Move declaration to cp-tree.h.\n\t* parse.c: Regenerated.\n\t* cp-tree.h: Use them.\n\t(current_class_depth): Declare.\n\t* pt.c (tsubst_copy): Use begin_stmt_expr and finish_stmt_expr.\n\nFrom-SVN: r18882", "tree": {"sha": "5627198955fe3272e4f5854aa834f9a6c0a84417", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5627198955fe3272e4f5854aa834f9a6c0a84417"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/comments", "author": null, "committer": null, "parents": [{"sha": "ba0b8436b0be24ad5a1119335d6b1fe45f733bd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba0b8436b0be24ad5a1119335d6b1fe45f733bd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba0b8436b0be24ad5a1119335d6b1fe45f733bd1"}], "stats": {"total": 2624, "additions": 1242, "deletions": 1382}, "files": [{"sha": "ce9805699d3b7aaa94311eb79c13609421b4ad79", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -1,3 +1,21 @@\n+Sat Mar 28 17:43:52 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* pt.c (tsubst): Clear TREE_USED for new FUNCTION_DECLs.\n+\n+\t* pt.c (instantiate_class_template): Make sure template\n+\targuments are permanent.\n+\t* init.c (resolve_offset_ref): Don't go looking around in\n+\ttemplate types.\n+\n+\t* semantics.c: Add routines to handle expressions, and some\n+\tdeclaration processing.\n+\t* parse.y: Use them.\n+\t(current_class_depth): Move declaration to cp-tree.h.\n+\t* parse.c: Regenerated.\n+\t* cp-tree.h: Use them.\n+\t(current_class_depth): Declare.\n+\t* pt.c (tsubst_copy): Use begin_stmt_expr and finish_stmt_expr.\n+\n Fri Mar 27 20:23:18 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* error.c (dump_decl): Be a bit more explicit with template"}, {"sha": "b8e56f28f280e000c1ca98ff6fbdc9bdcbbff3ff", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -1684,6 +1684,7 @@ extern tree current_class_type;\n extern tree current_class_ptr;\n extern tree previous_class_type;\n extern tree current_class_ref;\n+extern int current_class_depth;\n \n extern tree current_lang_name, lang_name_cplusplus, lang_name_c;\n \n@@ -2580,6 +2581,22 @@ extern void finish_handler                      PROTO((tree));\n extern tree begin_compound_stmt                 PROTO((int));\n extern tree finish_compound_stmt                PROTO((int, tree));\n extern void finish_asm_stmt                     PROTO((tree, tree, tree, tree, tree));\n+extern tree finish_parenthesized_expr           PROTO((tree));\n+extern tree begin_stmt_expr                     PROTO((void));\n+extern tree finish_stmt_expr                    PROTO((tree, tree));\n+extern tree finish_call_expr                    PROTO((tree, tree));\n+extern tree finish_increment_expr               PROTO((tree, enum tree_code));\n+extern tree finish_this_expr                    PROTO((void));\n+extern tree finish_object_call_expr             PROTO((tree, tree, tree));\n+extern tree finish_qualified_object_call_expr   PROTO((tree, tree, tree));\n+extern tree finish_pseudo_destructor_call_expr  PROTO((tree, tree, tree));\n+extern tree finish_globally_qualified_member_call_expr PROTO ((tree, tree));\n+extern tree finish_label_address_expr           PROTO((tree));\n+extern int begin_function_definition            PROTO((tree, tree));\n+extern tree begin_constructor_declarator        PROTO((tree, tree));\n+extern tree finish_template_type_parm           PROTO((tree, tree));\n+extern tree finish_template_template_parm       PROTO((tree, tree));\n+\n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree, int, int));\n extern tree build_signature_reference_type\tPROTO((tree, int, int));"}, {"sha": "d3feefdaca3ff9441b8437827521fb47b7abf261", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -1625,7 +1625,7 @@ build_offset_ref (type, name)\n   if (type == std_node)\n     return do_scoped_id (name, 0);\n \n-  if (processing_template_decl)\n+  if (processing_template_decl || uses_template_parms (type))\n     return build_min_nt (SCOPE_REF, type, name);\n \n   /* Handle namespace names fully here.  */"}, {"sha": "53590ab6a0adaac3418fff001b845b1919dcf3ef", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 822, "deletions": 1073, "changes": 1895, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20"}, {"sha": "007a411772a6dfcb678591ce605ec319842f96ee", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 46, "deletions": 297, "changes": 343, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -55,7 +55,6 @@ extern int errno;\n #endif\n \n extern int end_of_file;\n-extern int current_class_depth;\n \n /* Like YYERROR but do call yyerror.  */\n #define YYERROR1 { yyerror (\"syntax error\"); YYERROR; }\n@@ -237,7 +236,7 @@ empty_parms ()\n %token <ttype> TYPENAME_ELLIPSIS PTYPENAME\n %token <ttype> PRE_PARSED_FUNCTION_DECL EXTERN_LANG_STRING ALL\n %token <ttype> PRE_PARSED_CLASS_DECL DEFARG DEFARG_MARKER\n-%type <ttype> fn.def1 /* Not really! */ component_constructor_declarator\n+%type <ttype> component_constructor_declarator\n %type <ttype> fn.def2 return_id fn.defpen constructor_declarator\n %type <itype> ctor_initializer_opt\n %type <ttype> named_class_head named_class_head_sans_basetype\n@@ -479,36 +478,14 @@ maybe_identifier:\n \n template_type_parm:\n \t  aggr maybe_identifier\n-\t\t{ \n-\t\t  $$ = build_tree_list ($1, $2);\n-\t\t  if (TREE_PURPOSE ($$) == signature_type_node)\n-\t\t    sorry (\"signature as template type parameter\");\n-\t\t  else if (TREE_PURPOSE ($$) != class_type_node)\n-\t\t    {\n-\t\t      pedwarn (\"template type parameters must use the keyword `class'\");\n-\t\t      TREE_PURPOSE ($$) = class_type_node;\n-\t\t    }\n-\t\t}\n+                { $$ = finish_template_type_parm ($1, $2); }\n \t| TYPENAME_KEYWORD maybe_identifier\n-\t\t{ $$ = build_tree_list (class_type_node, $2); }\n+                { $$ = finish_template_type_parm (class_type_node, $2); }\n \t;\n \n template_template_parm:\n \t  template_header aggr maybe_identifier\n-\t\t{\n-\t\t  tree decl = build_decl (TYPE_DECL, $3, NULL_TREE);\n-\t\t  tree tmpl = build_lang_decl (TEMPLATE_DECL, $3, NULL_TREE);\n-\t\t  DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n-\t\t  DECL_TEMPLATE_RESULT (tmpl) = decl;\n-\t\t  SET_DECL_ARTIFICIAL (decl);\n-\t\t  end_template_decl ();\n-\n-\t\t  if ($2 == signature_type_node)\n-\t\t    sorry (\"signature as template template parameter\");\n-\t\t  else if ($2 != class_type_node)\n-\t\t    pedwarn (\"template template parameters must use the keyword `class'\");\n-\t\t  $$ = build_tree_list (class_type_node, tmpl);\n-\t\t}\n+                { $$ = finish_template_template_parm ($2, $3); }\n \t;\n \n template_parm:\n@@ -613,123 +590,55 @@ fndef:\n \n constructor_declarator:\n \t  nested_name_specifier SELFNAME '(' \n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n-\t\t  if ($1 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($1, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n-\t\t}\n+                { $$ = begin_constructor_declarator ($1, $2); }\n \t  parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n \t| nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n-\t\t  if ($1 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($1, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n+                { $$ = begin_constructor_declarator ($1, $2); \n \t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n \t| global_scope nested_name_specifier SELFNAME '(' \n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n-\t\t  if ($2 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($2, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n-\t\t}\n+                { $$ = begin_constructor_declarator ($2, $3); }\n \t parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n \t| global_scope nested_name_specifier SELFNAME LEFT_RIGHT cv_qualifiers exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n-\t\t  if ($2 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($2, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n+\t\t{ $$ = begin_constructor_declarator ($2, $3);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n \t| nested_name_specifier self_template_type '(' \n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n-\t\t  if ($1 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($1, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n-\t\t}\n+                { $$ = begin_constructor_declarator ($1, $2); }\n \t  parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>4, $5, $7, $8); }\n \t| nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n-\t\t  if ($1 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($1, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n+\t\t{ $$ = begin_constructor_declarator ($1, $2);\n \t\t  $$ = make_call_declarator ($$, empty_parms (), $4, $5);\n \t\t}\n \t| global_scope nested_name_specifier self_template_type '(' \n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n-\t\t  if ($2 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($2, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n-\t\t}\n+                { $$ = begin_constructor_declarator ($2, $3); }\n \t parmlist ')' cv_qualifiers exception_specification_opt\n \t\t{ $$ = make_call_declarator ($<ttype>5, $6, $8, $9); }\n \t| global_scope nested_name_specifier self_template_type LEFT_RIGHT cv_qualifiers exception_specification_opt\n-\t\t{\n-\t\t  $$ = build_parse_node (SCOPE_REF, $2, $3);\n-\t\t  if ($2 != current_class_type)\n-\t\t    {\n-\t\t      push_nested_class ($2, 3);\n-\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n-\t\t    }\n+\t\t{ $$ = begin_constructor_declarator ($2, $3); \n \t\t  $$ = make_call_declarator ($$, empty_parms (), $5, $6);\n \t\t}\n \t;\n \n fn.def1:\n \t  typed_declspecs declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1.t, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, attrs, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ if (!begin_function_definition ($1.t, $2))\n+\t\t    YYERROR1; }\n \t| declmods notype_declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, attrs, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ if (!begin_function_definition ($1, $2))\n+\t\t    YYERROR1; }\n \t| notype_declarator\n-\t\t{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n+\t\t    YYERROR1; }\n \t| declmods constructor_declarator\n-\t\t{ tree specs, attrs;\n-\t\t  split_specs_attrs ($1, &specs, &attrs);\n-\t\t  if (! start_function (specs, $2, attrs, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ if (!begin_function_definition ($1, $2))\n+\t\t    YYERROR1; }\n \t| constructor_declarator\n-\t\t{ if (! start_function (NULL_TREE, $$, NULL_TREE, 0))\n-\t\t    YYERROR1;\n-\t\t  reinit_parse_for_function ();\n-\t\t  $$ = NULL_TREE; }\n+\t\t{ if (!begin_function_definition (NULL_TREE, $1))\n+\t\t    YYERROR1; }\n \t;\n \n component_constructor_declarator:\n@@ -1109,18 +1018,9 @@ unary_expr:\n \t\t}\n \t/* Refer to the address of a label as a pointer.  */\n \t| ANDAND identifier\n-\t\t{ tree label = lookup_label ($2);\n-\t\t  if (pedantic)\n+\t\t{ if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids `&&'\");\n-\t\t  if (label == NULL_TREE)\n-\t\t    $$ = null_pointer_node;\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_USED (label) = 1;\n-\t\t      $$ = build1 (ADDR_EXPR, ptr_type_node, label);\n-\t\t      TREE_CONSTANT ($$) = 1;\n-\t\t    }\n-\t\t}\n+  \t\t  $$ = finish_label_address_expr ($2); }\n \t| SIZEOF unary_expr  %prec UNARY\n \t\t{ $$ = expr_sizeof ($2); }\n \t| SIZEOF '(' type_id ')'  %prec HYPERUNARY\n@@ -1389,21 +1289,10 @@ primary:\n \t\t    pop_obstacks ();\n \t\t}\n \t| '(' expr ')'\n-\t\t{ char class;\n-\t\t  $$ = $2;\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-                    /* This inhibits warnings in truthvalue_conversion.  */\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n+\t\t{ $$ = finish_parenthesized_expr ($2); }\n \t| '(' expr_or_declarator ')'\n-\t\t{ char class;\n-\t\t  $$ = reparse_decl_as_expr (NULL_TREE, $2);\n-\t\t  class = TREE_CODE_CLASS (TREE_CODE ($$));\n-\t\t  if (class == 'e' || class == '1'\n-\t\t      || class == '2' || class == '<')\n-                    /* This inhibits warnings in truthvalue_conversion.  */\n-\t\t    C_SET_EXP_ORIGINAL_CODE ($$, ERROR_MARK); }\n+\t\t{ $2 = reparse_decl_as_expr (NULL_TREE, $2);\n+\t\t  $$ = finish_parenthesized_expr ($2); }\n \t| '(' error ')'\n \t\t{ $$ = error_mark_node; }\n \t| '('\n@@ -1412,95 +1301,25 @@ primary:\n \t\t      error (\"braced-group within expression allowed only inside a function\");\n \t\t      YYERROR;\n \t\t    }\n-\t\t  keep_next_level ();\n-\t\t  if (!processing_template_decl)\n-\t\t    $<ttype>$ = expand_start_stmt_expr (); \n-\t\t  else\n-\t\t    $<ttype>$ = NULL_TREE;\n-\t\t}\n-\t  compstmt ')'\n-\t\t{ tree rtl_exp;\n \t\t  if (pedantic)\n-\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n-\t\t  if (!processing_template_decl)\n-\t\t    {\n-\t\t      rtl_exp = expand_end_stmt_expr ($<ttype>2);\n-\t\t      /* The statements have side effects, so the\n-\t\t\t group does.  */ \n-\t\t      TREE_SIDE_EFFECTS (rtl_exp) = 1;\n-\t\t    }\n-\n-\t\t  if (TREE_CODE ($3) == BLOCK)\n-\t\t    {\n-\t\t      /* Make a BIND_EXPR for the BLOCK already made.  */\n-\t\t      if (processing_template_decl)\n-\t\t\t$$ = build (BIND_EXPR, NULL_TREE,\n-\t\t\t\t    NULL_TREE, last_tree, $3);\n-\t\t      else\n-\t\t\t$$ = build (BIND_EXPR, TREE_TYPE (rtl_exp),\n-\t\t\t\t    NULL_TREE, rtl_exp, $3);\n-\n-\t\t      /* Remove the block from the tree at this point.\n-\t\t\t It gets put back at the proper place\n-\t\t\t when the BIND_EXPR is expanded.  */\n-\t\t      delete_block ($3);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = $3;\n+\t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");  \n+\t\t  $<ttype>$ = begin_stmt_expr (); \n \t\t}\n+\t  compstmt ')'\n+               { $$ = finish_stmt_expr ($<ttype>2, $3); }\n \t| primary '(' nonnull_exprlist ')'\n-                {\n-                  $$ = build_x_function_call ($1, $3, current_class_ref); \n-                  if (TREE_CODE ($$) == CALL_EXPR\n-                      && TREE_TYPE ($$) != void_type_node)\n-\t            $$ = require_complete_type ($$);\n-                }\n+               { $$ = finish_call_expr ($1, $3); }\n \t| primary LEFT_RIGHT\n-                {\n-\t\t  $$ = build_x_function_call ($$, NULL_TREE, current_class_ref);\n-\t\t  if (TREE_CODE ($$) == CALL_EXPR\n-\t\t      && TREE_TYPE ($$) != void_type_node)\n-\t\t    $$ = require_complete_type ($$);\n-                }\n+               { $$ = finish_call_expr ($1, NULL_TREE); }\n \t| primary '[' expr ']'\n \t\t{ $$ = grok_array_decl ($$, $3); }\n \t| primary PLUSPLUS\n-\t\t{ /* If we get an OFFSET_REF, turn it into what it really\n-\t\t     means (e.g., a COMPONENT_REF).  This way if we've got,\n-\t\t     say, a reference to a static member that's being operated\n-\t\t     on, we don't end up trying to find a member operator for\n-\t\t     the class it's in.  */\n-\t\t  if (TREE_CODE ($$) == OFFSET_REF)\n-\t\t    $$ = resolve_offset_ref ($$);\n-\t\t  $$ = build_x_unary_op (POSTINCREMENT_EXPR, $$); }\n+\t\t{ $$ = finish_increment_expr ($1, POSTINCREMENT_EXPR); }\n \t| primary MINUSMINUS\n-\t\t{ if (TREE_CODE ($$) == OFFSET_REF)\n-\t\t    $$ = resolve_offset_ref ($$);\n-\t\t  $$ = build_x_unary_op (POSTDECREMENT_EXPR, $$); }\n+\t\t{ $$ = finish_increment_expr ($1, POSTDECREMENT_EXPR); }\n \t/* C++ extensions */\n \t| THIS\n-\t\t{ if (current_class_ptr)\n-\t\t    {\n-#ifdef WARNING_ABOUT_CCD\n-\t\t      TREE_USED (current_class_ptr) = 1;\n-#endif\n-\t\t      $$ = current_class_ptr;\n-\t\t    }\n-\t\t  else if (current_function_decl\n-\t\t\t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n-\t\t    {\n-\t\t      error (\"`this' is unavailable for static member functions\");\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      if (current_function_decl)\n-\t\t\terror (\"invalid use of `this' in non-member function\");\n-\t\t      else\n-\t\t\terror (\"invalid use of `this' at top level\");\n-\t\t      $$ = error_mark_node;\n-\t\t    }\n-\t\t}\n+\t\t{ $$ = finish_this_expr (); }\n \t| CV_QUALIFIER '(' nonnull_exprlist ')'\n \t\t{\n \t\t  tree type = NULL_TREE;\n@@ -1581,30 +1400,17 @@ primary:\n \t| overqualified_id  %prec HYPERUNARY\n \t\t{ $$ = build_offset_ref (OP0 ($$), OP1 ($$)); }\n \t| overqualified_id '(' nonnull_exprlist ')'\n-\t\t{ if (processing_template_decl)\n-\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), $3, NULL_TREE);\n-\t\t  else\n-\t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), $3); }\n+                { $$ = finish_globally_qualified_member_call_expr ($1, $3); }\n \t| overqualified_id LEFT_RIGHT\n-\t\t{ if (processing_template_decl)\n-\t\t    $$ = build_min_nt (CALL_EXPR, copy_to_permanent ($1), \n-\t\t\t\t       NULL_TREE, NULL_TREE);\n-\t\t  else\n-\t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n+\t\t{ $$ = finish_globally_qualified_member_call_expr ($1, NULL_TREE); }\n         | object object_template_id %prec UNARY\n                 { \n \t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); \n \t\t}\n         | object object_template_id '(' nonnull_exprlist ')'\n-                {\n-\t\t  $$ = build_method_call ($1, $2, $4, \n-\t\t\t\t\t  NULL_TREE, LOOKUP_NORMAL); \n-                }\n+                { $$ = finish_object_call_expr ($2, $1, $4); }\n \t| object object_template_id LEFT_RIGHT\n-                {\n-\t\t  $$ = build_method_call ($1, $2, NULL_TREE,\n-\t\t\t\t\t  NULL_TREE, LOOKUP_NORMAL); \n-                }\n+                { $$ = finish_object_call_expr ($2, $1, NULL_TREE); }\n \t| object unqualified_id  %prec UNARY\n \t\t{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object overqualified_id  %prec UNARY\n@@ -1613,75 +1419,18 @@ primary:\n \t\t  else\n \t\t    $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n \t| object unqualified_id '(' nonnull_exprlist ')'\n-\t\t{\n-#if 0\n-\t\t  /* This is a future direction of this code, but because\n-\t\t     build_x_function_call cannot always undo what is done\n-\t\t     in build_component_ref entirely yet, we cannot do this.  */\n-\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, current_class_ref);\n-\t\t  if (TREE_CODE ($$) == CALL_EXPR\n-\t\t      && TREE_TYPE ($$) != void_type_node)\n-\t\t    $$ = require_complete_type ($$);\n-#else\n-\t\t  $$ = build_method_call ($$, $2, $4, NULL_TREE,\n-\t\t\t\t\t  LOOKUP_NORMAL);\n-#endif\n-\t\t}\n+                { $$ = finish_object_call_expr ($2, $1, $4); }\n \t| object unqualified_id LEFT_RIGHT\n-\t\t{\n-#if 0\n-\t\t  /* This is a future direction of this code, but because\n-\t\t     build_x_function_call cannot always undo what is done\n-\t\t     in build_component_ref entirely yet, we cannot do this.  */\n-\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, current_class_ref);\n-\t\t  if (TREE_CODE ($$) == CALL_EXPR\n-\t\t      && TREE_TYPE ($$) != void_type_node)\n-\t\t    $$ = require_complete_type ($$);\n-#else\n-\t\t  $$ = build_method_call ($$, $2, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t  LOOKUP_NORMAL);\n-#endif\n-\t\t}\n+                { $$ = finish_object_call_expr ($2, $1, NULL_TREE); }\n \t| object overqualified_id '(' nonnull_exprlist ')'\n-\t\t{\n-\t\t  if (IS_SIGNATURE (OP0 ($2)))\n-\t\t    {\n-\t\t      warning (\"signature name in scope resolution ignored\");\n-\t\t      $$ = build_method_call ($$, OP1 ($2), $4, NULL_TREE,\n-\t\t\t\t\t      LOOKUP_NORMAL);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), $4);\n-\t\t}\n+                { $$ = finish_qualified_object_call_expr ($2, $1, $4); }\n \t| object overqualified_id LEFT_RIGHT\n-\t\t{\n-\t\t  if (IS_SIGNATURE (OP0 ($2)))\n-\t\t    {\n-\t\t      warning (\"signature name in scope resolution ignored\");\n-\t\t      $$ = build_method_call ($$, OP1 ($2), NULL_TREE, NULL_TREE,\n-\t\t\t\t\t      LOOKUP_NORMAL);\n-\t\t    }\n-\t\t  else\n-\t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), NULL_TREE);\n-\t\t}\n+                { $$ = finish_qualified_object_call_expr ($2, $1, NULL_TREE); }\n \t/* p->int::~int() is valid -- 12.4 */\n \t| object '~' TYPESPEC LEFT_RIGHT\n-\t\t{\n-\t\t  if (IDENTIFIER_GLOBAL_VALUE ($3)\n-\t\t      && (TREE_CODE (TREE_TYPE ($1)) \n-\t\t\t  != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3)))))\n-\t\t    cp_error (\"`%E' is not of type `%T'\", $1, $3);\n-\t\t  $$ = cp_convert (void_type_node, $1);\n-\t\t}\n+\t\t{ $$ = finish_pseudo_destructor_call_expr ($1, NULL_TREE, $3); }\n \t| object TYPESPEC SCOPE '~' TYPESPEC LEFT_RIGHT\n-\t\t{\n-\t\t  if ($2 != $5)\n-\t\t    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", $2, $5);\n-\t\t  if (TREE_CODE (TREE_TYPE ($1))\n-\t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($2))))\n-\t\t    cp_error (\"`%E' is not of type `%T'\", $1, $2);\n-\t\t  $$ = cp_convert (void_type_node, $1);\n-\t\t}\n+\t\t{ $$ = finish_pseudo_destructor_call_expr ($1, $2, $5); }\n \t| object error\n \t\t{\n \t\t  $$ = error_mark_node;"}, {"sha": "893ef2f5b457dda0d23e885347a6f7d42d918d0a", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -3371,6 +3371,11 @@ instantiate_class_template (type)\n        value that results in a specialization being used.  */\n     return type;\n \n+  /* We must copy the arguments to the permanent obstack since\n+     during the tsubst'ing below they may wind up in the\n+     DECL_TI_ARGS of some instantiated member template.  */\n+  args = copy_to_permanent (args);\n+\n   TYPE_BEING_DEFINED (type) = 1;\n \n   if (! push_tinst_level (type))\n@@ -4254,6 +4259,7 @@ tsubst (t, args, in_decl)\n \tTREE_CHAIN (r) = NULL_TREE;\n \tDECL_CHAIN (r) = NULL_TREE;\n \tDECL_PENDING_INLINE_INFO (r) = 0;\n+\tTREE_USED (r) = 0;\n \n \tif (IDENTIFIER_OPNAME_P (DECL_NAME (r)))\n \t  grok_op_properties (r, DECL_VIRTUAL_P (r), DECL_FRIEND_P (r));\n@@ -4868,13 +4874,9 @@ tsubst_copy (t, args, in_decl)\n \t       inside them.  Instead, it simply calls\n \t       build_expr_from_tree.  So, we need to expand the\n \t       BIND_EXPR here.  */ \n-\t    tree rtl_exp = expand_start_stmt_expr();\n+\t    tree rtl_expr = begin_stmt_expr ();\n \t    tree block = tsubst_expr (TREE_OPERAND (r, 1), args, in_decl);\n-\t    rtl_exp = expand_end_stmt_expr (rtl_exp);\n-\t    TREE_SIDE_EFFECTS (rtl_exp) = 1;\n-\t    r = build (BIND_EXPR, TREE_TYPE (rtl_exp), \n-\t\t       NULL_TREE, rtl_exp, block);\n-\t    delete_block (block);\n+\t    r = finish_stmt_expr (rtl_expr, block);\n \t  }\n \n \treturn r;\n@@ -5907,11 +5909,8 @@ unify (tparms, targs, ntparms, parm, arg, strict, explicit_mask)\n \t    return 1;\n \t}\n       else\n-\t{\n-\t  sorry (\"use of `%s' in template type unification\",\n-\t\t tree_code_name [(int) TREE_CODE (parm)]);\n-\t  break;\n-\t}\n+\tsorry (\"use of `%s' in template type unification\",\n+\t       tree_code_name [(int) TREE_CODE (parm)]);\n \n       return 1;\n     }"}, {"sha": "3538aa10341671dd6244318490a87c53933240c2", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -747,3 +747,310 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n       finish_stmt ();\n     }\n }\n+\n+/* Finish a parenthesized expression EXPR.  */\n+\n+tree\n+finish_parenthesized_expr (expr)\n+     tree expr;\n+{\n+  if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expr))))\n+    /* This inhibits warnings in truthvalue_conversion.  */\n+    C_SET_EXP_ORIGINAL_CODE (expr, ERROR_MARK); \n+\n+  return expr;\n+}\n+\n+/* Begin a statement-expression.  Returns a new RTL_EXPR if\n+   appropriate. */\n+\n+tree \n+begin_stmt_expr ()\n+{\n+  keep_next_level ();\n+  return processing_template_decl ? NULL_TREE : expand_start_stmt_expr(); \n+}\n+\n+/* Finish a statement-expression.  RTL_EXPR should be the value\n+   returned by the previous begin_stmt_expr; EXPR is the\n+   statement-expression.  Returns an expression representing the\n+   statement-expression.  */\n+\n+tree \n+finish_stmt_expr (rtl_expr, expr)\n+     tree rtl_expr;\n+     tree expr;\n+{\n+  tree result;\n+\n+  if (!processing_template_decl)\n+    {\n+      rtl_expr = expand_end_stmt_expr (rtl_expr);\n+      /* The statements have side effects, so the group does.  */\n+      TREE_SIDE_EFFECTS (rtl_expr) = 1;\n+    }\n+\n+  if (TREE_CODE (expr) == BLOCK)\n+    {\n+      /* Make a BIND_EXPR for the BLOCK already made.  */\n+      if (processing_template_decl)\n+\tresult = build (BIND_EXPR, NULL_TREE,\n+\t\t\tNULL_TREE, last_tree, expr);\n+      else\n+\tresult = build (BIND_EXPR, TREE_TYPE (rtl_expr),\n+\t\t\tNULL_TREE, rtl_expr, expr);\n+      \n+      /* Remove the block from the tree at this point.\n+\t It gets put back at the proper place\n+\t when the BIND_EXPR is expanded.  */\n+      delete_block (expr);\n+    }\n+  else\n+    result = expr;\n+  \n+  return result;\n+}\n+\n+/* Finish a call to FN with ARGS.  Returns a representation of the\n+   call.  */\n+\n+tree \n+finish_call_expr (fn, args)\n+     tree fn;\n+     tree args;\n+{\n+  tree result = build_x_function_call (fn, args, current_class_ref);\n+\n+  if (TREE_CODE (result) == CALL_EXPR\n+      && TREE_TYPE (result) != void_type_node)\n+    result = require_complete_type (result);\n+\n+  return result;\n+}\n+\n+/* Finish a call to a postfix increment or decrement or EXPR.  (Which\n+   is indicated by CODE, which should be POSTINCREMENT_EXPR or\n+   POSTDECREMENT_EXPR.)  */\n+\n+tree \n+finish_increment_expr (expr, code)\n+     tree expr;\n+     enum tree_code code;\n+{\n+  /* If we get an OFFSET_REF, turn it into what it really means (e.g.,\n+     a COMPONENT_REF).  This way if we've got, say, a reference to a\n+     static member that's being operated on, we don't end up trying to\n+     find a member operator for the class it's in.  */\n+\n+  if (TREE_CODE (expr) == OFFSET_REF)\n+    expr = resolve_offset_ref (expr);\n+  return build_x_unary_op (code, expr);  \n+}\n+\n+/* Finish a use of `this'.  Returns an expression for `this'.  */\n+\n+tree \n+finish_this_expr ()\n+{\n+  tree result;\n+\n+  if (current_class_ptr)\n+    {\n+#ifdef WARNING_ABOUT_CCD\n+      TREE_USED (current_class_ptr) = 1;\n+#endif\n+      result = current_class_ptr;\n+    }\n+  else if (current_function_decl\n+\t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n+    {\n+      error (\"`this' is unavailable for static member functions\");\n+      result = error_mark_node;\n+    }\n+  else\n+    {\n+      if (current_function_decl)\n+\terror (\"invalid use of `this' in non-member function\");\n+      else\n+\terror (\"invalid use of `this' at top level\");\n+      result = error_mark_node;\n+    }\n+\n+  return result;\n+}\n+\n+/* Finish a member function call using OBJECT and ARGS as arguments to\n+   FN.  Returns an expression for the call.  */\n+\n+tree \n+finish_object_call_expr (fn, object, args)\n+     tree fn;\n+     tree object;\n+     tree args;\n+{\n+#if 0\n+  /* This is a future direction of this code, but because\n+     build_x_function_call cannot always undo what is done in\n+     build_component_ref entirely yet, we cannot do this.  */\n+\n+  tree real_fn = build_component_ref (object, fn, NULL_TREE, 1);\n+  return finish_call_expr (real_fn, args);\n+#else\n+  return build_method_call (object, fn, args, NULL_TREE, LOOKUP_NORMAL);\n+#endif\n+}\n+\n+/* Finish a qualified member function call using OBJECT and ARGS as\n+   arguments to FN.  Returns an expressino for the call.  */\n+\n+tree \n+finish_qualified_object_call_expr (fn, object, args)\n+     tree fn;\n+     tree object;\n+     tree args;\n+{\n+  if (IS_SIGNATURE (TREE_OPERAND (fn, 0)))\n+    {\n+      warning (\"signature name in scope resolution ignored\");\n+      return finish_object_call_expr (TREE_OPERAND (fn, 1), object, args);\n+    }\n+  else\n+    return build_scoped_method_call (object, TREE_OPERAND (fn, 0),\n+\t\t\t\t     TREE_OPERAND (fn, 1), args);\n+}\n+\n+/* Finish a pseudo-destructor call expression of OBJECT, with SCOPE\n+   being the scope, if any, of DESTRUCTOR.  Returns an expression for\n+   the call.  */\n+\n+tree \n+finish_pseudo_destructor_call_expr (object, scope, destructor)\n+     tree object;\n+     tree scope;\n+     tree destructor;\n+{\n+  if (scope && scope != destructor)\n+    cp_error (\"destructor specifier `%T::~%T()' must have matching names\", \n+\t      scope, destructor);\n+\n+  if ((scope == NULL_TREE || IDENTIFIER_GLOBAL_VALUE (destructor))\n+      && (TREE_CODE (TREE_TYPE (object)) !=\n+\t  TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (destructor)))))\n+    cp_error (\"`%E' is not of type `%T'\", object, destructor);\n+\n+  return cp_convert (void_type_node, object);\n+}\n+\n+/* Finish a call to a globally qualified member function FN using\n+   ARGS.  Returns an expression for the call.  */\n+\n+tree \n+finish_globally_qualified_member_call_expr (fn, args)\n+     tree fn;\n+     tree args;\n+{\n+  if (processing_template_decl)\n+    return build_min_nt (CALL_EXPR, copy_to_permanent (fn), args,\n+\t\t\t NULL_TREE);\n+  else\n+    return build_member_call (TREE_OPERAND (fn, 0),\n+\t\t\t      TREE_OPERAND (fn, 1),\n+\t\t\t      args);\n+}\n+\n+/* Finish an expression taking the address of LABEL.  Returns an\n+   expression for the address.  */\n+\n+tree \n+finish_label_address_expr (label)\n+     tree label;\n+{\n+  tree result;\n+\n+  label = lookup_label (label);\n+  if (label == NULL_TREE)\n+    result = null_pointer_node;\n+  else\n+    {\n+      TREE_USED (label) = 1;\n+      result = build1 (ADDR_EXPR, ptr_type_node, label);\n+      TREE_CONSTANT (result) = 1;\n+    }\n+\n+  return result;\n+}\n+\n+/* Begin a function defniition declared with DECL_SPECS and\n+   DECLARATOR.  Returns non-zero if the function-declaration is\n+   legal.  */\n+\n+int\n+begin_function_definition (decl_specs, declarator)\n+     tree decl_specs;\n+     tree declarator;\n+{\n+  tree specs;\n+  tree attrs;\n+  split_specs_attrs (decl_specs, &specs, &attrs);\n+  if (!start_function (specs, declarator, attrs, 0))\n+    return 0;\n+  \n+  reinit_parse_for_function ();\n+  return 1;\n+}\n+\n+/* Begin a constructor declarator of the form `SCOPE::NAME'.  Returns\n+   a SCOPE_REF.  */\n+\n+tree \n+begin_constructor_declarator (scope, name)\n+     tree scope;\n+     tree name;\n+{\n+  tree result = build_parse_node (SCOPE_REF, scope, name);\n+\n+  if (scope != current_class_type)\n+    {\n+      push_nested_class (scope, 3);\n+      TREE_COMPLEXITY (result) = current_class_depth;\n+    }\n+\n+  return result;\n+}\n+\n+/* Finish a template type parameter, specified as AGGR IDENTIFIER.\n+   Returns the parameter.  */\n+\n+tree \n+finish_template_type_parm (aggr, identifier)\n+     tree aggr;\n+     tree identifier;\n+{\n+  if (aggr == signature_type_node)\n+    sorry (\"signature as template type parameter\");\n+  else if (aggr != class_type_node)\n+    {\n+      pedwarn (\"template type parameters must use the keyword `class' or `typename'\");\n+      aggr = class_type_node;\n+    }\n+\n+  return build_tree_list (aggr, identifier);\n+}\n+\n+/* Finish a template template parameter, specified as AGGR IDENTIFIER.\n+   Returns the parameter.  */\n+\n+tree \n+finish_template_template_parm (aggr, identifier)\n+     tree aggr;\n+     tree identifier;\n+{\n+  tree decl = build_decl (TYPE_DECL, identifier, NULL_TREE);\n+  tree tmpl = build_lang_decl (TEMPLATE_DECL, identifier, NULL_TREE);\n+  DECL_TEMPLATE_PARMS (tmpl) = current_template_parms;\n+  DECL_TEMPLATE_RESULT (tmpl) = decl;\n+  SET_DECL_ARTIFICIAL (decl);\n+  end_template_decl ();\n+\n+  return finish_template_type_parm (aggr, tmpl);\n+}"}, {"sha": "9f6da97c77131a0e45436c76a3511d95e6c879c8", "filename": "gcc/testsuite/g++.old-deja/g++.pt/spec16.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fspec16.C?ref=b4c4a9ecbe199e65a256ba850c9e6a5eb1888b20", "patch": "@@ -0,0 +1,21 @@\n+// Build don't link:\n+\n+template<class K>\n+struct A {\n+\tint foo(const K&);\n+\tint bar(const K&);\n+};\n+\n+template<class K>\n+int\n+A<K>::bar(const K& k)\n+{\n+\treturn(foo(k));\n+}\n+\n+template<>\n+int\n+A<const char*>::foo(const char*const& k)\n+{\n+        return((int)k);\n+}"}]}