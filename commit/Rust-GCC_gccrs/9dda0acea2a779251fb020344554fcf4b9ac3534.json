{"sha": "9dda0acea2a779251fb020344554fcf4b9ac3534", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWRkYTBhY2VhMmE3NzkyNTFmYjAyMDM0NDU1NGZjZjRiOWFjMzUzNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-05-25T15:12:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-25T15:12:38Z"}, "message": "Reimplement qualified namespace lookup.\n\n\t* name-lookup.c (name_lookup::flags): New member.  Adjust ctor.\n\t(name_lookup::ambiguous, name_lookup::add_value)\n\tname_lookup::add_type, name_lookup::process_binding): New.\n\t(name_lookup::search_namespace_only)\n\tname_lookup::search_namespace, name_lookup::search_usings): New.\n\t(name_lookup::search_qualified): New.\n\t(do_nonmember_using_decl, suggest_alternatives_for)\n\tlookup_qualified_name): Adjust.\n\t(tree_vec_contains): Delete.\n\t(qualified_lookup_using_namespace): Rename to ...\n\t(qualified_namespace_lookup): ... here.  Reimplement.\n(((--This line, and those below, will be ignored--\n\nM    cp/name-lookup.c\nM    cp/ChangeLog\n\nFrom-SVN: r248462", "tree": {"sha": "0bf4ec4456ad95fc6c90b6b1fae098562162521a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0bf4ec4456ad95fc6c90b6b1fae098562162521a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9dda0acea2a779251fb020344554fcf4b9ac3534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dda0acea2a779251fb020344554fcf4b9ac3534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dda0acea2a779251fb020344554fcf4b9ac3534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dda0acea2a779251fb020344554fcf4b9ac3534/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47c05e71d79388ade0514bbf52096146f0b936f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c05e71d79388ade0514bbf52096146f0b936f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c05e71d79388ade0514bbf52096146f0b936f2"}], "stats": {"total": 376, "additions": 264, "deletions": 112}, "files": [{"sha": "9924ddb4a3b569f75ff7cb02e7ef8c2b2e7a4d99", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dda0acea2a779251fb020344554fcf4b9ac3534/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dda0acea2a779251fb020344554fcf4b9ac3534/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9dda0acea2a779251fb020344554fcf4b9ac3534", "patch": "@@ -1,5 +1,19 @@\n 2017-05-25  Nathan Sidwell  <nathan@acm.org>\n \n+\tReimplement qualified namespace lookup.\n+\t* name-lookup.c (name_lookup::flags): New member.  Adjust ctor.\n+\t(name_lookup::ambiguous, name_lookup::add_value,\n+\tname_lookup::add_type, name_lookup::process_binding): New.\n+\t(name_lookup::search_namespace_only,\n+\tname_lookup::search_namespace, name_lookup::search_usings): New.\n+\t(name_lookup::search_qualified): New.\n+\t(do_nonmember_using_decl, suggest_alternatives_for,\n+\tlookup_qualified_name): Adjust.\n+\t(tree_vec_contains): Delete.\n+\t(qualified_lookup_using_namespace): Rename to ...\n+\t(qualified_namespace_lookup): ... here.  Reimplement.\n+\n+\tReimplement ADL.\n \t* cp-tree.h (LOOKUP_SEEN_P, LOOKUP_FOUND_P): New.\n \t* name-lookup.h (lookup_arg_dependent): Return plain tree.\n \t* name-lookup.c (arg_lookup, arg_assoc, arg_assoc_args,"}, {"sha": "a103bdcde660f8e2699fec03e969f4f1abe73013", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 250, "deletions": 112, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9dda0acea2a779251fb020344554fcf4b9ac3534/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9dda0acea2a779251fb020344554fcf4b9ac3534/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=9dda0acea2a779251fb020344554fcf4b9ac3534", "patch": "@@ -48,18 +48,6 @@ struct scope_binding {\n };\n #define EMPTY_SCOPE_BINDING { NULL_TREE, NULL_TREE }\n \n-static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n-\t\t\t\t    tree, int);\n-static bool qualified_lookup_using_namespace (tree, tree,\n-\t\t\t\t\t      struct scope_binding *, int);\n-static void consider_binding_level (tree name,\n-\t\t\t\t    best_match <tree, const char *> &bm,\n-\t\t\t\t    cp_binding_level *lvl,\n-\t\t\t\t    bool look_within_fields,\n-\t\t\t\t    enum lookup_name_fuzzy_kind kind);\n-static tree push_using_directive (tree);\n-static void diagnose_name_conflict (tree, tree);\n-\n /* Create a local binding level for NAME.  */\n \n static cxx_binding *\n@@ -166,6 +154,7 @@ struct name_lookup\n   tree name;\t/* The identifier being looked for.  */\n   tree value;\t/* A (possibly ambiguous) set of things found.  */\n   tree type;\t/* A type that has been found.  */\n+  int flags;\t/* Lookup flags.  */\n   vec<tree, va_heap, vl_embed> *scopes;\n   name_lookup *previous; /* Previously active lookup.  */\n   hash_set<tree> *fn_set;\n@@ -177,8 +166,8 @@ struct name_lookup\n   static name_lookup *active;\n \n public:\n-  name_lookup (tree n)\n-  : name (n), value (NULL_TREE), type (NULL_TREE),\n+  name_lookup (tree n, int f = 0)\n+  : name (n), value (NULL_TREE), type (NULL_TREE), flags (f),\n     scopes (NULL), previous (NULL), fn_set (NULL)\n   {\n     preserve_state ();\n@@ -222,7 +211,22 @@ struct name_lookup\n   void preserve_state ();\n   void restore_state ();\n \n- private:\n+private:\n+  static tree ambiguous (tree thing, tree current);\n+  void add_value (tree new_val);\n+  void add_type (tree new_type);\n+  bool process_binding (tree val_bind, tree type_bind);\n+\n+  /* Look in only namespace.  */\n+  bool search_namespace_only (tree scope);\n+  /* Look in namespace and its (recursive) inlines. Ignore using\n+     directives.  Return true if something found (inc dups). */\n+  bool search_namespace (tree scope);\n+  /* Look in the using directives of namespace + inlines using\n+     qualified lookup rules.  */\n+  bool search_usings (tree scope);\n+\n+private:\n   void add_fns (tree);\n \n   void adl_expr (tree);\n@@ -235,6 +239,10 @@ struct name_lookup\n   void adl_namespace_only (tree);\n \n public:\n+  /* Search namespace + inlines + maybe usings as qualified lookup.  */\n+  bool search_qualified (tree scope, bool usings = true);\n+\n+  /* ADL lookup of ARGS.  */\n   tree search_adl (tree fns, vec<tree, va_gc> *args);\n };\n \n@@ -348,6 +356,207 @@ name_lookup::find_and_mark (tree scope)\n   return result;\n }\n \n+/* THING and CURRENT are ambiguous, concatenate them.  */\n+\n+tree\n+name_lookup::ambiguous (tree thing, tree current)\n+{\n+  if (TREE_CODE (current) != TREE_LIST)\n+    {\n+      current = build_tree_list (NULL_TREE, current);\n+      TREE_TYPE (current) = error_mark_node;\n+    }\n+  current = tree_cons (NULL_TREE, thing, current);\n+  TREE_TYPE (current) = error_mark_node;\n+\n+  return current;\n+}\n+\n+/* Add a NEW_VAL, a found value binding into the current value binding.  */\n+\n+void\n+name_lookup::add_value (tree new_val)\n+{\n+  if (!value)\n+    value = new_val;\n+  else if (value == new_val)\n+    ;\n+  else if ((TREE_CODE (value) == TYPE_DECL\n+\t    && TREE_CODE (new_val) == TYPE_DECL\n+\t    && same_type_p (TREE_TYPE (value), TREE_TYPE (new_val))))\n+    ;\n+  else if (OVL_P (value) && OVL_P (new_val))\n+    {\n+      for (ovl_iterator iter (new_val); iter; ++iter)\n+\tvalue = lookup_add (*iter, value);\n+    }\n+  else\n+    value = ambiguous (new_val, value);\n+}\n+\n+/* Add a NEW_TYPE, a found type binding into the current type binding.  */\n+\n+void\n+name_lookup::add_type (tree new_type)\n+{\n+  if (!type)\n+    type = new_type;\n+  else if (TREE_CODE (type) == TREE_LIST\n+\t   || !same_type_p (TREE_TYPE (type), TREE_TYPE (new_type)))\n+    type = ambiguous (new_type, type);\n+}\n+\n+/* Process a found binding containing NEW_VAL and NEW_TYPE.  Returns\n+   true if we actually found something noteworthy.  */\n+\n+bool\n+name_lookup::process_binding (tree new_val, tree new_type)\n+{\n+  /* Did we really see a type? */\n+  if (new_type\n+      && (LOOKUP_NAMESPACES_ONLY (flags)\n+\t  || (!(flags & LOOKUP_HIDDEN)\n+\t      && DECL_LANG_SPECIFIC (new_type)\n+\t      && DECL_ANTICIPATED (new_type))))\n+    new_type = NULL_TREE;\n+\n+  if (new_val && !(flags & LOOKUP_HIDDEN))\n+    new_val = ovl_skip_hidden (new_val);\n+\n+  /* Do we really see a value? */\n+  if (new_val)\n+    switch (TREE_CODE (new_val))\n+      {\n+      case TEMPLATE_DECL:\n+\t/* If we expect types or namespaces, and not templates,\n+\t   or this is not a template class.  */\n+\tif ((LOOKUP_QUALIFIERS_ONLY (flags)\n+\t     && !DECL_TYPE_TEMPLATE_P (new_val)))\n+\t  new_val = NULL_TREE;\n+\tbreak;\n+      case TYPE_DECL:\n+\tif (LOOKUP_NAMESPACES_ONLY (flags)\n+\t    || (new_type && (flags & LOOKUP_PREFER_TYPES)))\n+\t  new_val = NULL_TREE;\n+\tbreak;\n+      case NAMESPACE_DECL:\n+\tif (LOOKUP_TYPES_ONLY (flags))\n+\t  new_val = NULL_TREE;\n+\tbreak;\n+      default:\n+\tif (LOOKUP_QUALIFIERS_ONLY (flags))\n+\t  new_val = NULL_TREE;\n+      }\n+\n+  if (!new_val)\n+    {\n+      new_val = new_type;\n+      new_type = NULL_TREE;\n+    }\n+\n+  /* Merge into the lookup  */\n+  if (new_val)\n+    add_value (new_val);\n+  if (new_type)\n+    add_type (new_type);\n+\n+  return new_val != NULL_TREE;\n+}\n+\n+/* Look in exactly namespace SCOPE.  */\n+\n+bool\n+name_lookup::search_namespace_only (tree scope)\n+{\n+  bool found = false;\n+\n+  if (cxx_binding *binding = find_namespace_binding (scope, name))\n+    found |= process_binding (binding->value, binding->type);\n+\n+  return found;\n+}\n+\n+/* Conditionally look in namespace SCOPE and inline children.  */\n+\n+bool\n+name_lookup::search_namespace (tree scope)\n+{\n+  if (see_and_mark (scope))\n+    /* We've visited this scope before.  Return what we found then.  */\n+    return found_p (scope);\n+\n+  /* Look in exactly namespace. */\n+  bool found = search_namespace_only (scope);\n+  \n+  /* Look down into inline namespaces.  */\n+  for (tree inner = NAMESPACE_LEVEL (scope)->namespaces;\n+       inner; inner = TREE_CHAIN (inner))\n+    if (DECL_NAMESPACE_INLINE_P (inner))\n+      found |= search_namespace (inner);\n+\n+  if (found)\n+    mark_found (scope);\n+\n+  return found;\n+}\n+\n+/* Recursively follow using directives of SCOPE & its inline children.\n+   Such following is essentially a flood-fill algorithm.  */\n+\n+bool\n+name_lookup::search_usings (tree scope)\n+{\n+  /* We do not check seen_p here, as that was already set during the\n+     namespace_only walk.  */\n+  if (found_p (scope))\n+    return true;\n+\n+  bool found = false;\n+\n+  /* Look in direct usings.  */\n+  for (tree usings = DECL_NAMESPACE_USING (scope);\n+       usings; usings = TREE_CHAIN (usings))\n+    if (!TREE_INDIRECT_USING (usings))\n+      found |= search_qualified (TREE_PURPOSE (usings), true);\n+\n+  /* Look in its inline children.  */\n+  for (tree inner = NAMESPACE_LEVEL (scope)->namespaces;\n+       inner; inner = TREE_CHAIN (inner))\n+    if (DECL_NAMESPACE_INLINE_P (inner))\n+      found |= search_usings (inner);\n+\n+  if (found)\n+    mark_found (scope);\n+\n+  return found;\n+}\n+\n+/* Qualified namespace lookup in SCOPE.\n+   1) Look in SCOPE (+inlines).  If found, we're done.\n+   2) Otherwise, if USINGS is true,\n+      recurse for every using directive of SCOPE (+inlines).\n+\n+   Trickiness is (a) loops and (b) multiple paths to same namespace.\n+   In both cases we want to not repeat any lookups, and know whether\n+   to stop the caller's step #2.  Do this via the FOUND_P marker.  */\n+\n+bool\n+name_lookup::search_qualified (tree scope, bool usings)\n+{\n+  bool found = false;\n+\n+  if (seen_p (scope))\n+    found = found_p (scope);\n+  else \n+    {\n+      found = search_namespace (scope);\n+      if (!found && usings)\n+\tfound = search_usings (scope);\n+    }\n+\n+  return found;\n+}\n+\n /* FNS is a value binding.  If it is a (set of overloaded) functions,\n    add them into the current value.  */\n \n@@ -692,6 +901,17 @@ name_lookup::search_adl (tree fns, vec<tree, va_gc> *args)\n   return fns;\n }\n \n+static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n+\t\t\t\t    tree, int);\n+static bool qualified_namespace_lookup (tree, name_lookup *);\n+static void consider_binding_level (tree name,\n+\t\t\t\t    best_match <tree, const char *> &bm,\n+\t\t\t\t    cp_binding_level *lvl,\n+\t\t\t\t    bool look_within_fields,\n+\t\t\t\t    enum lookup_name_fuzzy_kind kind);\n+static tree push_using_directive (tree);\n+static void diagnose_name_conflict (tree, tree);\n+\n /* ADL lookup of NAME.  FNS is the result of regular lookup, and we\n    don't add duplicates to it.  ARGS is the vector of call\n    arguments (which will not be empty).  */\n@@ -3073,9 +3293,9 @@ validate_nonmember_using_decl (tree decl, tree scope, tree name)\n static void\n do_nonmember_using_decl (tree scope, tree name, tree *value_p, tree *type_p)\n {\n-  struct scope_binding lookup = EMPTY_SCOPE_BINDING;\n+  name_lookup lookup (name, 0);\n \n-  if (!qualified_lookup_using_namespace (name, scope, &lookup, 0))\n+  if (!qualified_namespace_lookup (scope, &lookup))\n     /* Lookup error */\n     return;\n \n@@ -4547,16 +4767,14 @@ suggest_alternatives_for (location_t location, tree name,\n \t && n_searched < max_to_search)\n     {\n       tree scope = namespaces_to_search.pop ();\n-      struct scope_binding binding = EMPTY_SCOPE_BINDING;\n+      name_lookup lookup (name, 0);\n       cp_binding_level *level = NAMESPACE_LEVEL (scope);\n \n-      /* Look in this namespace.  */\n-      qualified_lookup_using_namespace (name, scope, &binding, 0);\n-\n       n_searched++;\n \n-      if (binding.value)\n-\tcandidates.safe_push (binding.value);\n+      /* Look in this namespace.  */\n+      if (qualified_namespace_lookup (scope, &lookup))\n+\tcandidates.safe_push (lookup.value);\n \n       /* Add child namespaces.  */\n       for (t = level->namespaces; t; t = DECL_CHAIN (t))\n@@ -4824,13 +5042,13 @@ lookup_qualified_name (tree scope, tree name, int prefer_type, bool complain,\n \n   if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      struct scope_binding binding = EMPTY_SCOPE_BINDING;\n-\n       int flags = lookup_flags (prefer_type, /*namespaces_only*/false);\n       if (find_hidden)\n \tflags |= LOOKUP_HIDDEN;\n-      if (qualified_lookup_using_namespace (name, scope, &binding, flags))\n-\tt = binding.value;\n+      name_lookup lookup (name, flags);\n+\n+      if (qualified_namespace_lookup (scope, &lookup))\n+\tt = lookup.value;\n     }\n   else if (cxx_dialect != cxx98 && TREE_CODE (scope) == ENUMERAL_TYPE)\n     t = lookup_enumerator (scope, name);\n@@ -4870,99 +5088,19 @@ lookup_using_namespace (tree name, struct scope_binding *val,\n   return val->value != error_mark_node;\n }\n \n-/* Returns true iff VEC contains TARGET.  */\n-\n-static bool\n-tree_vec_contains (vec<tree, va_gc> *vec, tree target)\n-{\n-  unsigned int i;\n-  tree elt;\n-  FOR_EACH_VEC_SAFE_ELT (vec,i,elt)\n-    if (elt == target)\n-      return true;\n-  return false;\n-}\n-\n /* [namespace.qual]\n    Accepts the NAME to lookup and its qualifying SCOPE.\n    Returns the name/type pair found into the cxx_binding *RESULT,\n    or false on error.  */\n \n static bool\n-qualified_lookup_using_namespace (tree name, tree scope,\n-\t\t\t\t  struct scope_binding *result, int flags)\n-{\n-  /* Maintain a list of namespaces visited...  */\n-  vec<tree, va_gc> *seen = NULL;\n-  vec<tree, va_gc> *seen_inline = NULL;\n-  /* ... and a list of namespace yet to see.  */\n-  vec<tree, va_gc> *todo = NULL;\n-  vec<tree, va_gc> *todo_maybe = NULL;\n-  vec<tree, va_gc> *todo_inline = NULL;\n-  tree usings;\n+qualified_namespace_lookup (tree scope, name_lookup *lookup)\n+{\n   timevar_start (TV_NAME_LOOKUP);\n-  /* Look through namespace aliases.  */\n-  scope = ORIGINAL_NAMESPACE (scope);\n-\n-  query_oracle (name);\n-\n-  /* Algorithm: Starting with SCOPE, walk through the set of used\n-     namespaces.  For each used namespace, look through its inline\n-     namespace set for any bindings and usings.  If no bindings are\n-     found, add any usings seen to the set of used namespaces.  */\n-  vec_safe_push (todo, scope);\n-\n-  while (todo->length ())\n-    {\n-      bool found_here;\n-      scope = todo->pop ();\n-      if (tree_vec_contains (seen, scope))\n-\tcontinue;\n-      vec_safe_push (seen, scope);\n-      vec_safe_push (todo_inline, scope);\n-\n-      found_here = false;\n-      while (todo_inline->length ())\n-\t{\n-\t  cxx_binding *binding;\n-\n-\t  scope = todo_inline->pop ();\n-\t  if (tree_vec_contains (seen_inline, scope))\n-\t    continue;\n-\t  vec_safe_push (seen_inline, scope);\n-\n-\t  binding = find_namespace_binding (scope, name);\n-\t  if (binding)\n-\t    {\n-\t      ambiguous_decl (result, binding, flags);\n-\t      if (result->type || result->value)\n-\t\tfound_here = true;\n-\t    }\n-\n-\t  for (usings = DECL_NAMESPACE_USING (scope); usings;\n-\t       usings = TREE_CHAIN (usings))\n-\t    if (!TREE_INDIRECT_USING (usings))\n-\t      {\n-\t\tif (is_associated_namespace (scope, TREE_PURPOSE (usings)))\n-\t\t  vec_safe_push (todo_inline, TREE_PURPOSE (usings));\n-\t\telse\n-\t\t  vec_safe_push (todo_maybe, TREE_PURPOSE (usings));\n-\t      }\n-\t}\n-\n-      if (found_here)\n-\tvec_safe_truncate (todo_maybe, 0);\n-      else\n-\twhile (vec_safe_length (todo_maybe))\n-\t  vec_safe_push (todo, todo_maybe->pop ());\n-    }\n-  vec_free (todo);\n-  vec_free (todo_maybe);\n-  vec_free (todo_inline);\n-  vec_free (seen);\n-  vec_free (seen_inline);\n+  query_oracle (lookup->name);\n+  bool found = lookup->search_qualified (ORIGINAL_NAMESPACE (scope));\n   timevar_stop (TV_NAME_LOOKUP);\n-  return result->value != error_mark_node;\n+  return found;\n }\n \n /* Helper function for lookup_name_fuzzy."}]}