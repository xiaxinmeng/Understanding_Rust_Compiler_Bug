{"sha": "7c424acd9ae0f2a99ee54511c00f78371279a328", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M0MjRhY2Q5YWUwZjJhOTllZTU0NTExYzAwZjc4MzcxMjc5YTMyOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-10-08T14:45:37Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-10-08T14:45:37Z"}, "message": "Allow dynamic initialization of thread_locals.\n\ngcc/cp/\n\t* decl.c: Define tls_aggregates.\n\t(expand_static_init): Remove sorry.  Add to tls_aggregates.\n\t* cp-tree.h: Declare tls_aggregates.\n\t* call.c (set_up_extended_ref_temp): Add to tls_aggregates.\n\t* decl2.c (var_needs_tls_wrapper): New.\n\t(var_defined_without_dynamic_init): New.\n\t(get_tls_init_fn, get_tls_wrapper_fn): New.\n\t(generate_tls_wrapper, handle_tls_init): New.\n\t(cp_write_global_declarations): Call handle_tls_init and\n\tenerate_tls_wrapper.\n\t* mangle.c (write_guarded_var_name): Split out from..\n\t(mangle_guard_variable): ...here.\n\t(mangle_tls_init_fn, mangle_tls_wrapper_fn): Use it.\n\t(decl_tls_wrapper_p): New.\n\t* semantics.c (finish_id_expression): Replace use of thread_local\n\tvariable with a call to its wrapper.\nlibiberty/\n\t* cp-demangle.c (d_special_name, d_dump): Handle TH and TW.\n\t(d_make_comp, d_print_comp): Likewise.\ninclude/\n\t* demangle.h (enum demangle_component_type): Add\n\tDEMANGLE_COMPONENT_TLS_INIT and DEMANGLE_COMPONENT_TLS_WRAPPER.\n\nFrom-SVN: r192211", "tree": {"sha": "bc70ed3cb42f2f1614f8ad5ac0a05170d55fe604", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc70ed3cb42f2f1614f8ad5ac0a05170d55fe604"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c424acd9ae0f2a99ee54511c00f78371279a328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c424acd9ae0f2a99ee54511c00f78371279a328", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c424acd9ae0f2a99ee54511c00f78371279a328", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c424acd9ae0f2a99ee54511c00f78371279a328/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b031b9b56c63fbf2a24638e6ccb8da45ce936c1"}], "stats": {"total": 878, "additions": 859, "deletions": 19}, "files": [{"sha": "7f5d45f90a2bcaafb3a18bb97194c107664164d6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -1,5 +1,23 @@\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n+\tAllow dynamic initialization of thread_locals.\n+\t* decl.c: Define tls_aggregates.\n+\t(expand_static_init): Remove sorry.  Add to tls_aggregates.\n+\t* cp-tree.h: Declare tls_aggregates.\n+\t* call.c (set_up_extended_ref_temp): Add to tls_aggregates.\n+\t* decl2.c (var_needs_tls_wrapper): New.\n+\t(var_defined_without_dynamic_init): New.\n+\t(get_tls_init_fn, get_tls_wrapper_fn): New.\n+\t(generate_tls_wrapper, handle_tls_init): New.\n+\t(cp_write_global_declarations): Call handle_tls_init and\n+\tenerate_tls_wrapper.\n+\t* mangle.c (write_guarded_var_name): Split out from..\n+\t(mangle_guard_variable): ...here.\n+\t(mangle_tls_init_fn, mangle_tls_wrapper_fn): Use it.\n+\t(decl_tls_wrapper_p): New.\n+\t* semantics.c (finish_id_expression): Replace use of thread_local\n+\tvariable with a call to its wrapper.\n+\n \t* decl.c (get_thread_atexit_node): New.\n \t(register_dtor_fn): Use it for TLS.\n "}, {"sha": "3351a585f2b4588d9a0ce6f17f229c3908a2a45b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -8860,8 +8860,14 @@ set_up_extended_ref_temp (tree decl, tree expr, VEC(tree,gc) **cleanups,\n     {\n       rest_of_decl_compilation (var, /*toplev=*/1, at_eof);\n       if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\tstatic_aggregates = tree_cons (NULL_TREE, var,\n-\t\t\t\t       static_aggregates);\n+\t{\n+\t  if (DECL_THREAD_LOCAL_P (var))\n+\t    tls_aggregates = tree_cons (NULL_TREE, var,\n+\t\t\t\t\ttls_aggregates);\n+\t  else\n+\t    static_aggregates = tree_cons (NULL_TREE, var,\n+\t\t\t\t\t   static_aggregates);\n+\t}\n     }\n \n   *initp = init;"}, {"sha": "370f07230f085543c42d03cf2fcb22c113c565d1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -4385,6 +4385,8 @@ extern int at_eof;\n    in the TREE_VALUE slot and the initializer is stored in the\n    TREE_PURPOSE slot.  */\n extern GTY(()) tree static_aggregates;\n+/* Likewise, for thread local storage.  */\n+extern GTY(()) tree tls_aggregates;\n \n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n \n@@ -5197,6 +5199,7 @@ extern tree cp_build_parm_decl\t\t\t(tree, tree);\n extern tree get_guard\t\t\t\t(tree);\n extern tree get_guard_cond\t\t\t(tree);\n extern tree set_guard\t\t\t\t(tree);\n+extern tree get_tls_wrapper_fn\t\t\t(tree);\n extern void mark_needed\t\t\t\t(tree);\n extern bool decl_needed_p\t\t\t(tree);\n extern void note_vague_linkage_fn\t\t(tree);\n@@ -5992,6 +5995,9 @@ extern tree mangle_ctor_vtbl_for_type\t\t(tree, tree);\n extern tree mangle_thunk\t\t\t(tree, int, tree, tree);\n extern tree mangle_conv_op_name_for_type\t(tree);\n extern tree mangle_guard_variable\t\t(tree);\n+extern tree mangle_tls_init_fn\t\t\t(tree);\n+extern tree mangle_tls_wrapper_fn\t\t(tree);\n+extern bool decl_tls_wrapper_p\t\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n \n /* in dump.c */"}, {"sha": "0b936ea1a8be8b93adb51e4deed4727550c9706b", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -169,6 +169,9 @@ tree global_scope_name;\n    in the TREE_PURPOSE slot.  */\n tree static_aggregates;\n \n+/* Like static_aggregates, but for thread_local variables.  */\n+tree tls_aggregates;\n+\n /* -- end of C++ */\n \n /* A node for the integer constant 2.  */\n@@ -6838,16 +6841,6 @@ expand_static_init (tree decl, tree init)\n       return;\n     }\n \n-  if (DECL_THREAD_LOCAL_P (decl) && !DECL_FUNCTION_SCOPE_P (decl))\n-    {\n-      /* We haven't implemented dynamic initialization of non-local\n-\t thread-local storage yet.  FIXME transform to singleton\n-\t function.  */\n-      sorry (\"thread-local variable %qD with dynamic initialization outside \"\n-\t     \"function scope\", decl);\n-      return;\n-    }\n-\n   if (DECL_FUNCTION_SCOPE_P (decl))\n     {\n       /* Emit code to perform this initialization but once.  */\n@@ -6976,6 +6969,8 @@ expand_static_init (tree decl, tree init)\n \t  finish_if_stmt (if_stmt);\n \t}\n     }\n+  else if (DECL_THREAD_LOCAL_P (decl))\n+    tls_aggregates = tree_cons (init, decl, tls_aggregates);\n   else\n     static_aggregates = tree_cons (init, decl, static_aggregates);\n }"}, {"sha": "688a72332cec582910e9f76708f63afd92b2b4db", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -2781,6 +2781,187 @@ set_guard (tree guard)\n \t\t\t       tf_warning_or_error);\n }\n \n+/* Returns true iff we can tell that VAR does not have a dynamic\n+   initializer.  */\n+\n+static bool\n+var_defined_without_dynamic_init (tree var)\n+{\n+  /* If it's defined in another TU, we can't tell.  */\n+  if (DECL_EXTERNAL (var))\n+    return false;\n+  /* If it has a non-trivial destructor, registering the destructor\n+     counts as dynamic initialization.  */\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (var)))\n+    return false;\n+  /* If it's in this TU, its initializer has been processed.  */\n+  gcc_assert (DECL_INITIALIZED_P (var));\n+  /* If it has no initializer or a constant one, it's not dynamic.  */\n+  return (!DECL_NONTRIVIALLY_INITIALIZED_P (var)\n+\t  || DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (var));\n+}\n+\n+/* Returns true iff VAR is a variable that needs uses to be\n+   wrapped for possible dynamic initialization.  */\n+\n+static bool\n+var_needs_tls_wrapper (tree var)\n+{\n+  return (DECL_THREAD_LOCAL_P (var)\n+\t  && !DECL_GNU_TLS_P (var)\n+\t  && !DECL_FUNCTION_SCOPE_P (var)\n+\t  && !var_defined_without_dynamic_init (var));\n+}\n+\n+/* Get a FUNCTION_DECL for the init function for the thread_local\n+   variable VAR.  The init function will be an alias to the function\n+   that initializes all the non-local TLS variables in the translation\n+   unit.  The init function is only used by the wrapper function.  */\n+\n+static tree\n+get_tls_init_fn (tree var)\n+{\n+  /* Only C++11 TLS vars need this init fn.  */\n+  if (!var_needs_tls_wrapper (var))\n+    return NULL_TREE;\n+\n+  tree sname = mangle_tls_init_fn (var);\n+  tree fn = IDENTIFIER_GLOBAL_VALUE (sname);\n+  if (!fn)\n+    {\n+      fn = build_lang_decl (FUNCTION_DECL, sname,\n+\t\t\t    build_function_type (void_type_node,\n+\t\t\t\t\t\t void_list_node));\n+      SET_DECL_LANGUAGE (fn, lang_c);\n+      TREE_PUBLIC (fn) = TREE_PUBLIC (var);\n+      DECL_ARTIFICIAL (fn) = true;\n+      DECL_COMDAT (fn) = DECL_COMDAT (var);\n+      DECL_EXTERNAL (fn) = true;\n+      if (DECL_ONE_ONLY (var))\n+\tmake_decl_one_only (fn, cxx_comdat_group (fn));\n+      if (TREE_PUBLIC (var))\n+\t{\n+\t  tree obtype = strip_array_types (non_reference (TREE_TYPE (var)));\n+\t  /* If the variable might have static initialization, make the\n+\t     init function a weak reference.  */\n+\t  if ((!TYPE_NEEDS_CONSTRUCTING (obtype)\n+\t       || TYPE_HAS_CONSTEXPR_CTOR (obtype))\n+\t      && TARGET_SUPPORTS_WEAK)\n+\t    declare_weak (fn);\n+\t  else\n+\t    DECL_WEAK (fn) = DECL_WEAK (var);\n+\t}\n+      DECL_VISIBILITY (fn) = DECL_VISIBILITY (var);\n+      DECL_VISIBILITY_SPECIFIED (fn) = DECL_VISIBILITY_SPECIFIED (var);\n+      DECL_DLLIMPORT_P (fn) = DECL_DLLIMPORT_P (var);\n+      DECL_IGNORED_P (fn) = 1;\n+      mark_used (fn);\n+\n+      DECL_BEFRIENDING_CLASSES (fn) = var;\n+\n+      SET_IDENTIFIER_GLOBAL_VALUE (sname, fn);\n+    }\n+  return fn;\n+}\n+\n+/* Get a FUNCTION_DECL for the init wrapper function for the thread_local\n+   variable VAR.  The wrapper function calls the init function (if any) for\n+   VAR and then returns a reference to VAR.  The wrapper function is used\n+   in place of VAR everywhere VAR is mentioned.  */\n+\n+tree\n+get_tls_wrapper_fn (tree var)\n+{\n+  /* Only C++11 TLS vars need this wrapper fn.  */\n+  if (!var_needs_tls_wrapper (var))\n+    return NULL_TREE;\n+\n+  tree sname = mangle_tls_wrapper_fn (var);\n+  tree fn = IDENTIFIER_GLOBAL_VALUE (sname);\n+  if (!fn)\n+    {\n+      /* A named rvalue reference is an lvalue, so the wrapper should\n+\t always return an lvalue reference.  */\n+      tree type = non_reference (TREE_TYPE (var));\n+      type = build_reference_type (type);\n+      tree fntype = build_function_type (type, void_list_node);\n+      fn = build_lang_decl (FUNCTION_DECL, sname, fntype);\n+      SET_DECL_LANGUAGE (fn, lang_c);\n+      TREE_PUBLIC (fn) = TREE_PUBLIC (var);\n+      DECL_ARTIFICIAL (fn) = true;\n+      DECL_IGNORED_P (fn) = 1;\n+      /* The wrapper is inline and emitted everywhere var is used.  */\n+      DECL_DECLARED_INLINE_P (fn) = true;\n+      if (TREE_PUBLIC (var))\n+\t{\n+\t  comdat_linkage (fn);\n+#ifdef HAVE_GAS_HIDDEN\n+\t  /* Make the wrapper bind locally; there's no reason to share\n+\t     the wrapper between multiple shared objects.  */\n+\t  DECL_VISIBILITY (fn) = VISIBILITY_INTERNAL;\n+\t  DECL_VISIBILITY_SPECIFIED (fn) = true;\n+#endif\n+\t}\n+      if (!TREE_PUBLIC (fn))\n+\tDECL_INTERFACE_KNOWN (fn) = true;\n+      mark_used (fn);\n+      note_vague_linkage_fn (fn);\n+\n+#if 0\n+      /* We want CSE to commonize calls to the wrapper, but marking it as\n+\t pure is unsafe since it has side-effects.  I guess we need a new\n+\t ECF flag even weaker than ECF_PURE.  FIXME!  */\n+      DECL_PURE_P (fn) = true;\n+#endif\n+\n+      DECL_BEFRIENDING_CLASSES (fn) = var;\n+\n+      SET_IDENTIFIER_GLOBAL_VALUE (sname, fn);\n+    }\n+  return fn;\n+}\n+\n+/* At EOF, generate the definition for the TLS wrapper function FN:\n+\n+   T& var_wrapper() {\n+     if (init_fn) init_fn();\n+     return var;\n+   }  */\n+\n+static void\n+generate_tls_wrapper (tree fn)\n+{\n+  tree var = DECL_BEFRIENDING_CLASSES (fn);\n+\n+  start_preparsed_function (fn, NULL_TREE, SF_DEFAULT | SF_PRE_PARSED);\n+  tree body = begin_function_body ();\n+  /* Only call the init fn if there might be one.  */\n+  if (tree init_fn = get_tls_init_fn (var))\n+    {\n+      tree if_stmt = NULL_TREE;\n+      /* If init_fn is a weakref, make sure it exists before calling.  */\n+      if (lookup_attribute (\"weak\", DECL_ATTRIBUTES (init_fn)))\n+\t{\n+\t  if_stmt = begin_if_stmt ();\n+\t  tree addr = cp_build_addr_expr (init_fn, tf_warning_or_error);\n+\t  tree cond = cp_build_binary_op (DECL_SOURCE_LOCATION (var),\n+\t\t\t\t\t  NE_EXPR, addr, nullptr_node,\n+\t\t\t\t\t  tf_warning_or_error);\n+\t  finish_if_stmt_cond (cond, if_stmt);\n+\t}\n+      finish_expr_stmt (build_cxx_call\n+\t\t\t(init_fn, 0, NULL, tf_warning_or_error));\n+      if (if_stmt)\n+\t{\n+\t  finish_then_clause (if_stmt);\n+\t  finish_if_stmt (if_stmt);\n+\t}\n+    }\n+  finish_return_stmt (convert_from_reference (var));\n+  finish_function_body (body);\n+  expand_or_defer_fn (finish_function (0));\n+}\n+\n /* Start the process of running a particular set of global constructors\n    or destructors.  Subroutine of do_[cd]tors.  */\n \n@@ -3668,6 +3849,75 @@ clear_decl_external (struct cgraph_node *node, void * /*data*/)\n   return false;\n }\n \n+/* Build up the function to run dynamic initializers for thread_local\n+   variables in this translation unit and alias the init functions for the\n+   individual variables to it.  */\n+\n+static void\n+handle_tls_init (void)\n+{\n+  tree vars = prune_vars_needing_no_initialization (&tls_aggregates);\n+  if (vars == NULL_TREE)\n+    return;\n+\n+  location_t loc = DECL_SOURCE_LOCATION (TREE_VALUE (vars));\n+\n+  #ifndef ASM_OUTPUT_DEF\n+  /* This currently requires alias support.  FIXME other targets could use\n+     small thunks instead of aliases.  */\n+  input_location = loc;\n+  sorry (\"dynamic initialization of non-function-local thread_local \"\n+\t \"variables not supported on this target\");\n+  return;\n+  #endif\n+\n+  write_out_vars (vars);\n+\n+  tree guard = build_decl (loc, VAR_DECL, get_identifier (\"__tls_guard\"),\n+\t\t\t   boolean_type_node);\n+  TREE_PUBLIC (guard) = false;\n+  TREE_STATIC (guard) = true;\n+  DECL_ARTIFICIAL (guard) = true;\n+  DECL_IGNORED_P (guard) = true;\n+  TREE_USED (guard) = true;\n+  DECL_TLS_MODEL (guard) = decl_default_tls_model (guard);\n+  pushdecl_top_level_and_finish (guard, NULL_TREE);\n+\n+  tree fn = build_lang_decl (FUNCTION_DECL,\n+\t\t\t     get_identifier (\"__tls_init\"),\n+\t\t\t     build_function_type (void_type_node,\n+\t\t\t\t\t\t  void_list_node));\n+  SET_DECL_LANGUAGE (fn, lang_c);\n+  TREE_PUBLIC (fn) = false;\n+  DECL_ARTIFICIAL (fn) = true;\n+  mark_used (fn);\n+  start_preparsed_function (fn, NULL_TREE, SF_PRE_PARSED);\n+  tree body = begin_function_body ();\n+  tree if_stmt = begin_if_stmt ();\n+  tree cond = cp_build_unary_op (TRUTH_NOT_EXPR, guard, false,\n+\t\t\t\t tf_warning_or_error);\n+  finish_if_stmt_cond (cond, if_stmt);\n+  finish_expr_stmt (cp_build_modify_expr (guard, NOP_EXPR, boolean_true_node,\n+\t\t\t\t\t  tf_warning_or_error));\n+  for (; vars; vars = TREE_CHAIN (vars))\n+    {\n+      tree var = TREE_VALUE (vars);\n+      tree init = TREE_PURPOSE (vars);\n+      one_static_initialization_or_destruction (var, init, true);\n+\n+      tree single_init_fn = get_tls_init_fn (var);\n+      cgraph_node *alias\n+\t= cgraph_same_body_alias (cgraph_get_create_node (fn),\n+\t\t\t\t  single_init_fn, fn);\n+      gcc_assert (alias != NULL);\n+    }\n+\n+  finish_then_clause (if_stmt);\n+  finish_if_stmt (if_stmt);\n+  finish_function_body (body);\n+  expand_or_defer_fn (finish_function (0));\n+}\n+\n /* This routine is called at the end of compilation.\n    Its job is to create all the code needed to initialize and\n    destroy the global aggregates.  We do the destruction\n@@ -3845,6 +4095,9 @@ cp_write_global_declarations (void)\n \t  /* ??? was:  locus.line++; */\n \t}\n \n+      /* Now do the same for thread_local variables.  */\n+      handle_tls_init ();\n+\n       /* Go through the set of inline functions whose bodies have not\n \t been emitted yet.  If out-of-line copies of these functions\n \t are required, emit them.  */\n@@ -3869,6 +4122,9 @@ cp_write_global_declarations (void)\n \t      reconsider = true;\n \t    }\n \n+\t  if (!DECL_INITIAL (decl) && decl_tls_wrapper_p (decl))\n+\t    generate_tls_wrapper (decl);\n+\n \t  if (!DECL_SAVED_TREE (decl))\n \t    continue;\n "}, {"sha": "f448932e6ea14a9d9b69311ff6a0aacfee2a4894", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -3684,23 +3684,70 @@ mangle_conv_op_name_for_type (const tree type)\n   return identifier;\n }\n \n-/* Return an identifier for the name of an initialization guard\n-   variable for indicated VARIABLE.  */\n+/* Write out the appropriate string for this variable when generating\n+   another mangled name based on this one.  */\n \n-tree\n-mangle_guard_variable (const tree variable)\n+static void\n+write_guarded_var_name (const tree variable)\n {\n-  start_mangling (variable);\n-  write_string (\"_ZGV\");\n   if (strncmp (IDENTIFIER_POINTER (DECL_NAME (variable)), \"_ZGR\", 4) == 0)\n     /* The name of a guard variable for a reference temporary should refer\n        to the reference, not the temporary.  */\n     write_string (IDENTIFIER_POINTER (DECL_NAME (variable)) + 4);\n   else\n     write_name (variable, /*ignore_local_scope=*/0);\n+}\n+\n+/* Return an identifier for the name of an initialization guard\n+   variable for indicated VARIABLE.  */\n+\n+tree\n+mangle_guard_variable (const tree variable)\n+{\n+  start_mangling (variable);\n+  write_string (\"_ZGV\");\n+  write_guarded_var_name (variable);\n+  return finish_mangling_get_identifier (/*warn=*/false);\n+}\n+\n+/* Return an identifier for the name of a thread_local initialization\n+   function for VARIABLE.  */\n+\n+tree\n+mangle_tls_init_fn (const tree variable)\n+{\n+  start_mangling (variable);\n+  write_string (\"_ZTH\");\n+  write_guarded_var_name (variable);\n+  return finish_mangling_get_identifier (/*warn=*/false);\n+}\n+\n+/* Return an identifier for the name of a thread_local wrapper\n+   function for VARIABLE.  */\n+\n+#define TLS_WRAPPER_PREFIX \"_ZTW\"\n+\n+tree\n+mangle_tls_wrapper_fn (const tree variable)\n+{\n+  start_mangling (variable);\n+  write_string (TLS_WRAPPER_PREFIX);\n+  write_guarded_var_name (variable);\n   return finish_mangling_get_identifier (/*warn=*/false);\n }\n \n+/* Return true iff FN is a thread_local wrapper function.  */\n+\n+bool\n+decl_tls_wrapper_p (const tree fn)\n+{\n+  if (TREE_CODE (fn) != FUNCTION_DECL)\n+    return false;\n+  tree name = DECL_NAME (fn);\n+  return strncmp (IDENTIFIER_POINTER (name), TLS_WRAPPER_PREFIX,\n+\t\t  strlen (TLS_WRAPPER_PREFIX)) == 0;\n+}\n+\n /* Return an identifier for the name of a temporary variable used to\n    initialize a static reference.  This isn't part of the ABI, but we might\n    as well call them something readable.  */"}, {"sha": "4b06f30ffa8758ae4dad3eab259a20f05371ed48", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -3270,7 +3270,17 @@ finish_id_expression (tree id_expression,\n \t  *non_integral_constant_expression_p = true;\n \t}\n \n-      if (scope)\n+      tree wrap;\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && !cp_unevaluated_operand\n+\t  && DECL_THREAD_LOCAL_P (decl)\n+\t  && (wrap = get_tls_wrapper_fn (decl)))\n+\t{\n+\t  /* Replace an evaluated use of the thread_local variable with\n+\t     a call to its wrapper.  */\n+\t  decl = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);\n+\t}\n+      else if (scope)\n \t{\n \t  decl = (adjust_result_of_qualified_name_lookup\n \t\t  (decl, scope, current_nonlambda_class_type()));"}, {"sha": "00e4696bdbfb50ca2c8bf4eba0d385f4692b3fa9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -1,5 +1,25 @@\n 2012-10-08  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/gomp/tls-5.C: New.\n+\t* g++.dg/gomp/tls-wrap1.C: New.\n+\t* g++.dg/gomp/tls-wrap2.C: New.\n+\t* g++.dg/gomp/tls-wrap3.C: New.\n+\t* g++.dg/gomp/tls-wrap4.C: New.\n+\t* g++.dg/gomp/tls-wrapper-cse.C: New.\n+\t* g++.dg/tls/thread_local-cse.C: New.\n+\t* g++.dg/tls/thread_local-order1.C: New.\n+\t* g++.dg/tls/thread_local-order2.C: New.\n+\t* g++.dg/tls/thread_local-wrap1.C: New.\n+\t* g++.dg/tls/thread_local-wrap2.C: New.\n+\t* g++.dg/tls/thread_local-wrap3.C: New.\n+\t* g++.dg/tls/thread_local-wrap4.C: New.\n+\t* g++.dg/tls/thread_local2g.C: New.\n+\t* g++.dg/tls/thread_local3g.C: New.\n+\t* g++.dg/tls/thread_local4g.C: New.\n+\t* g++.dg/tls/thread_local5g.C: New.\n+\t* g++.dg/tls/thread_local6g.C: New.\n+\t* g++.dg/tls/thread_local7g.C: New.\n+\n \t* g++.dg/tls/thread_local3.C: New.\n \t* g++.dg/tls/thread_local4.C: New.\n \t* g++.dg/tls/thread_local5.C: New."}, {"sha": "74e4faaa88483e6292363f479612c35acfe07e05", "filename": "gcc/testsuite/g++.dg/gomp/tls-5.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-5.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,12 @@\n+// The reference temp should be TLS, not normal data.\n+// { dg-require-effective-target c++11 }\n+// { dg-final { scan-assembler-not \"\\\\.data\" } }\n+\n+extern int&& ir;\n+#pragma omp threadprivate (ir)\n+int&& ir = 42;\n+\n+void f()\n+{\n+  ir = 24;\n+}"}, {"sha": "91c9f8631257946c7167bdee9b2730c8ddbb6374", "filename": "gcc/testsuite/g++.dg/gomp/tls-wrap1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap1.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,13 @@\n+// If we can see the definition at the use site, we don't need to bother\n+// with a wrapper.\n+\n+// { dg-require-effective-target tls }\n+// { dg-final { scan-assembler-not \"_ZTW1i\" } }\n+\n+int i = 42;\n+#pragma omp threadprivate (i)\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "7aa13711c0b6d4dbfce900055b1c944101dbdbb1", "filename": "gcc/testsuite/g++.dg/gomp/tls-wrap2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap2.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,16 @@\n+// If we can't see the definition at the use site, but it's in this translation\n+// unit, we build a wrapper but don't bother with an init function.\n+\n+// { dg-require-effective-target tls }\n+// { dg-final { scan-assembler \"_ZTW1i\" } }\n+// { dg-final { scan-assembler-not \"_ZTH1i\" } }\n+\n+extern int i;\n+#pragma omp threadprivate (i)\n+\n+int main()\n+{\n+  return i - 42;\n+}\n+\n+int i = 42;"}, {"sha": "2504d99d1c3d584a886635d59f9eeebd42314a52", "filename": "gcc/testsuite/g++.dg/gomp/tls-wrap3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap3.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,14 @@\n+// If we can't see the definition at all, we need to assume there might be\n+// an init function.\n+\n+// { dg-require-effective-target tls }\n+// { dg-final { scan-assembler \"_ZTW1i\" } }\n+// { dg-final { scan-assembler \"_ZTH1i\" } }\n+\n+extern int i;\n+#pragma omp threadprivate (i)\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "130114811f8c2500772d94c33ccb93b6abdba126", "filename": "gcc/testsuite/g++.dg/gomp/tls-wrap4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrap4.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,13 @@\n+// We don't need to call the wrapper through the PLT; we can use a separate\n+// copy per shared object.\n+\n+// { dg-require-effective-target tls }\n+// { dg-options \"-std=c++11 -fPIC\" }\n+// { dg-final { scan-assembler-not \"_ZTW1i@PLT\" { target i?86-*-* x86_64-*-* } } }\n+\n+extern thread_local int i;\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "af2de2f1fcc7151248ee964732a617e3cb965d5f", "filename": "gcc/testsuite/g++.dg/gomp/tls-wrapper-cse.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrapper-cse.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrapper-cse.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftls-wrapper-cse.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,18 @@\n+// Test for CSE of the wrapper function: we should only call it once\n+// for the two references to ir.\n+// { dg-options \"-fopenmp -O -fno-inline\" }\n+// { dg-require-effective-target tls }\n+// { dg-final { scan-assembler-times \"call *_ZTW2ir\" 1 { xfail *-*-* } } }\n+\n+// XFAILed until the back end supports a way to mark a function as cseable\n+// though not pure.\n+\n+int f() { return 42; }\n+\n+int ir = f();\n+#pragma omp threadprivate (ir)\n+\n+int main()\n+{\n+  return ir + ir - 84;\n+}"}, {"sha": "47c6aede339e9643b377566b64a9b3b6a96f15f9", "filename": "gcc/testsuite/g++.dg/tls/thread_local-cse.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-cse.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-cse.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-cse.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,20 @@\n+// Test for CSE of the wrapper function: we should only call it once\n+// for the two references to ir.\n+// { dg-options \"-std=c++11 -O -fno-inline -save-temps\" }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-alias }\n+// { dg-final { scan-assembler-times \"call *_ZTW2ir\" 1 { xfail *-*-* } } }\n+// { dg-final cleanup-saved-temps }\n+// { dg-do run }\n+\n+// XFAILed until the back end supports a way to mark a function as cseable\n+// though not pure.\n+\n+int f() { return 42; }\n+\n+thread_local int ir = f();\n+\n+int main()\n+{\n+  return ir + ir - 84;\n+}"}, {"sha": "6557e938c79d3d851ce4300614d94d2fc295e329", "filename": "gcc/testsuite/g++.dg/tls/thread_local-order1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order1.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,25 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-alias }\n+\n+extern \"C\" void abort();\n+extern \"C\" int printf (const char *, ...);\n+#define printf(...)\n+\n+int c;\n+struct A {\n+  int i;\n+  A(int i): i(i) { printf (\"A(%d)\\n\", i); if (i != c++) abort (); }\n+  ~A() { printf(\"~A(%d)\\n\", i); if (i != --c) abort(); }\n+};\n+\n+A a0(0);\n+thread_local A a1(1);\n+thread_local A a2(2);\n+A* ap = &a1;\n+\n+int main()\n+{\n+  if (c != 3) abort();\n+}"}, {"sha": "eb9c7690160b29f0894511b8b3655e21d103a58b", "filename": "gcc/testsuite/g++.dg/tls/thread_local-order2.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-order2.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,28 @@\n+// The standard says that a1 should be destroyed before a0 even though\n+// that isn't reverse order of construction.  We need to move\n+// __cxa_thread_atexit into glibc to get this right.\n+\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-alias }\n+\n+extern \"C\" void abort();\n+extern \"C\" int printf (const char *, ...);\n+#define printf(...)\n+\n+int c;\n+struct A {\n+  int i;\n+  A(int i): i(i) { printf (\"A(%d)\\n\", i); ++c; }\n+  ~A() { printf(\"~A(%d)\\n\", i); if (i != --c) abort(); }\n+};\n+\n+thread_local A a1(1);\n+A* ap = &a1;\n+A a0(0);\n+\n+int main()\n+{\n+  if (c != 2) abort();\n+}"}, {"sha": "56177da1f9f2b9c13257eaac008fafc20c3b96b0", "filename": "gcc/testsuite/g++.dg/tls/thread_local-wrap1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap1.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,13 @@\n+// If we can see the definition at the use site, we don't need to bother\n+// with a wrapper.\n+\n+// { dg-require-effective-target tls }\n+// { dg-options \"-std=c++11\" }\n+// { dg-final { scan-assembler-not \"_ZTW1i\" } }\n+\n+thread_local int i = 42;\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "1e8078fa8d123975d3b0ae92d58d43790f03165d", "filename": "gcc/testsuite/g++.dg/tls/thread_local-wrap2.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap2.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,16 @@\n+// If we can't see the definition at the use site, but it's in this translation\n+// unit, we build a wrapper but don't bother with an init function.\n+\n+// { dg-require-effective-target tls }\n+// { dg-options \"-std=c++11\" }\n+// { dg-final { scan-assembler \"_ZTW1i\" } }\n+// { dg-final { scan-assembler-not \"_ZTH1i\" } }\n+\n+extern thread_local int i;\n+\n+int main()\n+{\n+  return i - 42;\n+}\n+\n+thread_local int i = 42;"}, {"sha": "19e6ab8d0d91937acbbd59a3ff5d5c33e8f738aa", "filename": "gcc/testsuite/g++.dg/tls/thread_local-wrap3.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap3.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,14 @@\n+// If we can't see the definition at all, we need to assume there might be\n+// an init function.\n+\n+// { dg-require-effective-target tls }\n+// { dg-options \"-std=c++11\" }\n+// { dg-final { scan-assembler \"_ZTW1i\" } }\n+// { dg-final { scan-assembler \"_ZTH1i\" } }\n+\n+extern thread_local int i;\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "130114811f8c2500772d94c33ccb93b6abdba126", "filename": "gcc/testsuite/g++.dg/tls/thread_local-wrap4.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local-wrap4.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,13 @@\n+// We don't need to call the wrapper through the PLT; we can use a separate\n+// copy per shared object.\n+\n+// { dg-require-effective-target tls }\n+// { dg-options \"-std=c++11 -fPIC\" }\n+// { dg-final { scan-assembler-not \"_ZTW1i@PLT\" { target i?86-*-* x86_64-*-* } } }\n+\n+extern thread_local int i;\n+\n+int main()\n+{\n+  return i - 42;\n+}"}, {"sha": "36451d2db50523aaa5d2c6eb9d5d718f257d4320", "filename": "gcc/testsuite/g++.dg/tls/thread_local2g.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local2g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,29 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-alias }\n+\n+extern \"C\" void abort();\n+\n+struct A\n+{\n+  A();\n+  int i;\n+};\n+\n+thread_local A a;\n+\n+A &f()\n+{\n+  return a;\n+}\n+\n+int j;\n+A::A(): i(j) { }\n+\n+int main()\n+{\n+  j = 42;\n+  if (f().i != 42)\n+    abort ();\n+}"}, {"sha": "d5e83e86f73084ac68af4ab22b711834544e9b6e", "filename": "gcc/testsuite/g++.dg/tls/thread_local3g.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local3g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-require-alias }\n+// { dg-options -pthread }\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+thread_local A a;\n+\n+void *thread_main(void *)\n+{\n+  A* ap = &a;\n+}\n+\n+#include <pthread.h>\n+\n+int main()\n+{\n+  pthread_t thread;\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+\n+  if (c != 2 || d != 2)\n+    __builtin_abort();\n+}"}, {"sha": "574d26714819add0a2ede5fdc4f14a61b82e7da5", "filename": "gcc/testsuite/g++.dg/tls/thread_local4g.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local4g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,45 @@\n+// Test for cleanups with pthread_cancel.\n+\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-require-alias }\n+// { dg-options -pthread }\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+thread_local A a;\n+\n+void *thread_main(void *)\n+{\n+  A *ap = &a;\n+  while (true)\n+    {\n+      pthread_testcancel();\n+      sleep (1);\n+    }\n+}\n+\n+int main()\n+{\n+  pthread_t thread;\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_cancel(thread);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_cancel(thread);\n+  pthread_join(thread, 0);\n+\n+   if (c != 2 || d != 2)\n+     __builtin_abort();\n+}"}, {"sha": "badab4fa64102162a99a9937b59a21aba8c5de56", "filename": "gcc/testsuite/g++.dg/tls/thread_local5g.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local5g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,45 @@\n+// Test for cleanups in the main thread, too.\n+\n+// { dg-do run }\n+// { dg-require-effective-target c++11 }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-effective-target pthread }\n+// { dg-require-alias }\n+// { dg-options -pthread }\n+\n+#include <pthread.h>\n+#include <unistd.h>\n+\n+int c;\n+int d;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() {\n+    if (++d == 3)\n+      _exit (0);\n+  }\n+};\n+\n+thread_local A a;\n+\n+void *thread_main(void *)\n+{\n+  A* ap = &a;\n+}\n+\n+int main()\n+{\n+  pthread_t thread;\n+  thread_main(0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+  pthread_create (&thread, 0, thread_main, 0);\n+  pthread_join(thread, 0);\n+\n+  // The dtor for a in the main thread is run after main exits, so we\n+  // return 1 now and override the return value with _exit above.\n+  if (c != 3 || d != 2)\n+    __builtin_abort();\n+  return 1;\n+}"}, {"sha": "ff8d608e538b6ce1429486566c5e5da228c91fea", "filename": "gcc/testsuite/g++.dg/tls/thread_local6g.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local6g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,31 @@\n+// Test for cleanups in the main thread without -pthread.\n+\n+// { dg-do run }\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls_runtime }\n+// { dg-require-alias }\n+\n+extern \"C\" void _exit (int);\n+\n+int c;\n+struct A\n+{\n+  A() { ++c; }\n+  ~A() { if (c == 1) _exit(0); }\n+};\n+\n+thread_local A a;\n+\n+void *thread_main(void *)\n+{\n+  A* ap = &a;\n+}\n+\n+int main()\n+{\n+  thread_main(0);\n+\n+  // The dtor for a in the main thread is run after main exits, so we\n+  // return 1 now and override the return value with _exit above.\n+  return 1;\n+}"}, {"sha": "6960598173aa3e34b2bed5202e86c9bb534ab61e", "filename": "gcc/testsuite/g++.dg/tls/thread_local7g.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftls%2Fthread_local7g.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,13 @@\n+// { dg-options \"-std=c++11\" }\n+// { dg-require-effective-target tls }\n+// { dg-require-alias }\n+\n+// The reference temp should be TLS, not normal data.\n+// { dg-final { scan-assembler-not \"\\\\.data\" } }\n+\n+thread_local int&& ir = 42;\n+\n+void f()\n+{\n+  ir = 24;\n+}"}, {"sha": "e5d3e87b920833de9c4a0b8d3b2cb1c9c3e2243b", "filename": "include/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -1,3 +1,8 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* demangle.h (enum demangle_component_type): Add\n+\tDEMANGLE_COMPONENT_TLS_INIT and DEMANGLE_COMPONENT_TLS_WRAPPER.\n+\n 2012-09-18  Florian Weimer  <fweimer@redhat.com>\n \n \tPR other/54411"}, {"sha": "5da79d85221d303b1cec75904859193b94014c9c", "filename": "include/demangle.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -272,6 +272,9 @@ enum demangle_component_type\n   /* A guard variable.  This has one subtree, the name for which this\n      is a guard variable.  */\n   DEMANGLE_COMPONENT_GUARD,\n+  /* The init and wrapper functions for C++11 thread_local variables.  */\n+  DEMANGLE_COMPONENT_TLS_INIT,\n+  DEMANGLE_COMPONENT_TLS_WRAPPER,\n   /* A reference temporary.  This has one subtree, the name for which\n      this is a temporary.  */\n   DEMANGLE_COMPONENT_REFTEMP,"}, {"sha": "8ed6abc207c7600a0324d8fa03f400e844812d45", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -1,3 +1,7 @@\n+2012-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\t* testsuite/libgomp.c++/tls-init1.C: New.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated."}, {"sha": "4cbaccb98511a1a89ea88e41f1aac8697f2a8842", "filename": "libgomp/testsuite/libgomp.c++/tls-init1.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftls-init1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftls-init1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftls-init1.C?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -0,0 +1,26 @@\n+extern \"C\" void abort();\n+\n+struct A\n+{\n+  A();\n+  int i;\n+};\n+\n+extern A a;\n+#pragma omp threadprivate (a)\n+A a;\n+\n+A &f()\n+{\n+  return a;\n+}\n+\n+int j;\n+A::A(): i(j) { }\n+\n+int main()\n+{\n+  j = 42;\n+  if (f().i != 42)\n+    abort ();\n+}"}, {"sha": "303dda23cae01088f4eba47d34e7c5c8ab0fa49b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -1,3 +1,8 @@\n+2012-10-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-demangle.c (d_special_name, d_dump): Handle TH and TW.\n+\t(d_make_comp, d_print_comp): Likewise.\n+\n 2012-09-18  Ian Lance Taylor  <iant@google.com>\n \n \t* strnlen.c: New file."}, {"sha": "32df38c6024b1fa499d06c305b9dd5954772231b", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c424acd9ae0f2a99ee54511c00f78371279a328/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c424acd9ae0f2a99ee54511c00f78371279a328/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=7c424acd9ae0f2a99ee54511c00f78371279a328", "patch": "@@ -696,6 +696,12 @@ d_dump (struct demangle_component *dc, int indent)\n     case DEMANGLE_COMPONENT_PACK_EXPANSION:\n       printf (\"pack expansion\\n\");\n       break;\n+    case DEMANGLE_COMPONENT_TLS_INIT:\n+      printf (\"tls init function\\n\");\n+      break;\n+    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n+      printf (\"tls wrapper function\\n\");\n+      break;\n     }\n \n   d_dump (d_left (dc), indent + 2);\n@@ -832,6 +838,8 @@ d_make_comp (struct d_info *di, enum demangle_component_type type,\n     case DEMANGLE_COMPONENT_COVARIANT_THUNK:\n     case DEMANGLE_COMPONENT_JAVA_CLASS:\n     case DEMANGLE_COMPONENT_GUARD:\n+    case DEMANGLE_COMPONENT_TLS_INIT:\n+    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n     case DEMANGLE_COMPONENT_REFTEMP:\n     case DEMANGLE_COMPONENT_HIDDEN_ALIAS:\n     case DEMANGLE_COMPONENT_TRANSACTION_CLONE:\n@@ -1867,6 +1875,14 @@ d_special_name (struct d_info *di)\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_JAVA_CLASS,\n \t\t\t      cplus_demangle_type (di), NULL);\n \n+\tcase 'H':\n+\t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_INIT,\n+\t\t\t      d_name (di), NULL);\n+\n+\tcase 'W':\n+\t  return d_make_comp (di, DEMANGLE_COMPONENT_TLS_WRAPPER,\n+\t\t\t      d_name (di), NULL);\n+\n \tdefault:\n \t  return NULL;\n \t}\n@@ -4072,6 +4088,16 @@ d_print_comp (struct d_print_info *dpi, int options,\n       d_print_comp (dpi, options, d_left (dc));\n       return;\n \n+    case DEMANGLE_COMPONENT_TLS_INIT:\n+      d_append_string (dpi, \"TLS init function for \");\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n+    case DEMANGLE_COMPONENT_TLS_WRAPPER:\n+      d_append_string (dpi, \"TLS wrapper function for \");\n+      d_print_comp (dpi, options, d_left (dc));\n+      return;\n+\n     case DEMANGLE_COMPONENT_REFTEMP:\n       d_append_string (dpi, \"reference temporary #\");\n       d_print_comp (dpi, options, d_right (dc));"}]}