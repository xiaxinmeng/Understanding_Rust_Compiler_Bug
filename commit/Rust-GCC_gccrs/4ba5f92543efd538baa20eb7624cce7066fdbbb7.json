{"sha": "4ba5f92543efd538baa20eb7624cce7066fdbbb7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGJhNWY5MjU0M2VmZDUzOGJhYTIwZWI3NjI0Y2NlNzA2NmZkYmJiNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-17T15:11:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-17T15:11:56Z"}, "message": "combine.c (combine_simplify_rtx): Attempt to simplify a*(b/c) as (a*b)/c for floats in unsafe_math mode.\n\n\t* combine.c (combine_simplify_rtx): Attempt to simplify\n\ta*(b/c) as (a*b)/c for floats in unsafe_math mode.\n\n\t* simplify-rtx.c (avoid_constatn_pool_reference): New static function.\n\t(simplify_binary_operation, simplify_unary_operation,\n\t simplify_relational_operation): Use it.\n\n\t* combine.c (combine_simplify_rtx): Don't do associative law\n\ton divisions; allow associative law on floats.\n\nFrom-SVN: r44073", "tree": {"sha": "9897d533a511d33bdf87b391d045985a0131d4ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9897d533a511d33bdf87b391d045985a0131d4ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ba5f92543efd538baa20eb7624cce7066fdbbb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba5f92543efd538baa20eb7624cce7066fdbbb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba5f92543efd538baa20eb7624cce7066fdbbb7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba5f92543efd538baa20eb7624cce7066fdbbb7/comments", "author": null, "committer": null, "parents": [{"sha": "3aa8ab7bfa8e38b018aa6eccf474d5d49643c49e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aa8ab7bfa8e38b018aa6eccf474d5d49643c49e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aa8ab7bfa8e38b018aa6eccf474d5d49643c49e"}], "stats": {"total": 304, "additions": 184, "deletions": 120}, "files": [{"sha": "49be9d88e57ca30af5193e6b0c5f2e680e4ca25a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ba5f92543efd538baa20eb7624cce7066fdbbb7", "patch": "@@ -1,3 +1,15 @@\n+Tue Jul 17 16:56:05 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* combine.c (combine_simplify_rtx): Attempt to simplify\n+\ta*(b/c) as (a*b)/c for floats in unsafe_math mode.\n+\n+\t* simplify-rtx.c (avoid_constatn_pool_reference): New static function.\n+\t(simplify_binary_operation, simplify_unary_operation,\n+\t simplify_relational_operation): Use it.\n+\n+\t* combine.c (combine_simplify_rtx): Don't do associative law\n+\ton divisions; allow associative law on floats.\n+\n 2001-07-17  H.J. Lu <hjl@gnu.org>\n \t    Rainer Orth <ro@TechFak.Uni-Bielefeld.DE>\n "}, {"sha": "f8394e6c573b80cdf708da0ac6fdf434de337915", "filename": "gcc/combine.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=4ba5f92543efd538baa20eb7624cce7066fdbbb7", "patch": "@@ -3724,9 +3724,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n      if they are logically related (i.e. (a & b) & a).  */\n   if ((code == PLUS || code == MINUS\n        || code == MULT || code == AND || code == IOR || code == XOR\n-       || code == DIV || code == UDIV\n        || code == SMAX || code == SMIN || code == UMAX || code == UMIN)\n-      && INTEGRAL_MODE_P (mode))\n+      && (INTEGRAL_MODE_P (mode)\n+\t  || (flag_unsafe_math_optimizations && FLOAT_MODE_P (mode))))\n     {\n       if (GET_CODE (XEXP (x, 0)) == code)\n \t{\n@@ -4231,6 +4231,16 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  if (GET_CODE (x) != MULT)\n \t    return x;\n \t}\n+      /* Try simplify a*(b/c) as (a*b)/c.  */\n+      if (FLOAT_MODE_P (mode) && flag_unsafe_math_optimizations\n+\t  && GET_CODE (XEXP (x, 0)) == DIV)\n+\t{\n+\t  rtx tem = simplify_binary_operation (MULT, mode,\n+\t\t\t\t\t       XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t       XEXP (x, 1));\n+\t  if (tem)\n+\t    return gen_binary (DIV, mode, tem, XEXP (XEXP (x, 0), 1));\n+\t}\n       break;\n \n     case UDIV:"}, {"sha": "70b7240301f3099115a1345cfd34db1c811b4a11", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 160, "deletions": 118, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ba5f92543efd538baa20eb7624cce7066fdbbb7/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=4ba5f92543efd538baa20eb7624cce7066fdbbb7", "patch": "@@ -99,6 +99,7 @@ Boston, MA 02111-1307, USA.  */\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx, rtx));\n static void check_fold_consts\t\tPARAMS ((PTR));\n+static rtx avoid_constant_pool_reference PARAMS ((rtx));\n \f\n /* Make a binary operation by properly ordering the operands and \n    seeing if the expression folds.  */\n@@ -135,6 +136,20 @@ simplify_gen_binary (code, mode, op0, op1)\n     return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n+/* In case X is MEM referencing constant pool, return the real value.\n+   Otherwise return X.  */\n+static rtx\n+avoid_constant_pool_reference (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != MEM)\n+    return x;\n+  if (GET_CODE (XEXP (x, 0)) != SYMBOL_REF\n+      || !CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n+    return x;\n+  return get_pool_constant (XEXP (x, 0));\n+}\n+\f\n /* Make a unary operation by first seeing if it folds and otherwise making\n    the specified operation.  */\n \n@@ -287,23 +302,24 @@ simplify_unary_operation (code, mode, op, op_mode)\n      enum machine_mode op_mode;\n {\n   unsigned int width = GET_MODE_BITSIZE (mode);\n+  rtx trueop = avoid_constant_pool_reference (op);\n \n   /* The order of these tests is critical so that, for example, we don't\n      check the wrong mode (input vs. output) for a conversion operation,\n      such as FIX.  At some point, this should be simplified.  */\n \n #if !defined(REAL_IS_NOT_DOUBLE) || defined(REAL_ARITHMETIC)\n \n-  if (code == FLOAT && GET_MODE (op) == VOIDmode\n-      && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+  if (code == FLOAT && GET_MODE (trueop) == VOIDmode\n+      && (GET_CODE (trueop) == CONST_DOUBLE || GET_CODE (trueop) == CONST_INT))\n     {\n       HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n-      if (GET_CODE (op) == CONST_INT)\n-\tlv = INTVAL (op), hv = HWI_SIGN_EXTEND (lv);\n+      if (GET_CODE (trueop) == CONST_INT)\n+\tlv = INTVAL (trueop), hv = HWI_SIGN_EXTEND (lv);\n       else\n-\tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n+\tlv = CONST_DOUBLE_LOW (trueop),  hv = CONST_DOUBLE_HIGH (trueop);\n \n #ifdef REAL_ARITHMETIC\n       REAL_VALUE_FROM_INT (d, lv, hv, mode);\n@@ -327,16 +343,17 @@ simplify_unary_operation (code, mode, op, op_mode)\n       d = real_value_truncate (mode, d);\n       return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n-  else if (code == UNSIGNED_FLOAT && GET_MODE (op) == VOIDmode\n-\t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+  else if (code == UNSIGNED_FLOAT && GET_MODE (trueop) == VOIDmode\n+\t   && (GET_CODE (trueop) == CONST_DOUBLE\n+\t       || GET_CODE (trueop) == CONST_INT))\n     {\n       HOST_WIDE_INT hv, lv;\n       REAL_VALUE_TYPE d;\n \n-      if (GET_CODE (op) == CONST_INT)\n-\tlv = INTVAL (op), hv = HWI_SIGN_EXTEND (lv);\n+      if (GET_CODE (trueop) == CONST_INT)\n+\tlv = INTVAL (trueop), hv = HWI_SIGN_EXTEND (lv);\n       else\n-\tlv = CONST_DOUBLE_LOW (op),  hv = CONST_DOUBLE_HIGH (op);\n+\tlv = CONST_DOUBLE_LOW (trueop),  hv = CONST_DOUBLE_HIGH (trueop);\n \n       if (op_mode == VOIDmode)\n \t{\n@@ -364,10 +381,10 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n #endif\n \n-  if (GET_CODE (op) == CONST_INT\n+  if (GET_CODE (trueop) == CONST_INT\n       && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      register HOST_WIDE_INT arg0 = INTVAL (op);\n+      register HOST_WIDE_INT arg0 = INTVAL (trueop);\n       register HOST_WIDE_INT val;\n \n       switch (code)\n@@ -453,16 +470,17 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n   /* We can do some operations on integer CONST_DOUBLEs.  Also allow\n      for a DImode operation on a CONST_INT.  */\n-  else if (GET_MODE (op) == VOIDmode && width <= HOST_BITS_PER_INT * 2\n-\t   && (GET_CODE (op) == CONST_DOUBLE || GET_CODE (op) == CONST_INT))\n+  else if (GET_MODE (trueop) == VOIDmode && width <= HOST_BITS_PER_INT * 2\n+\t   && (GET_CODE (trueop) == CONST_DOUBLE\n+\t       || GET_CODE (trueop) == CONST_INT))\n     {\n       unsigned HOST_WIDE_INT l1, lv;\n       HOST_WIDE_INT h1, hv;\n \n-      if (GET_CODE (op) == CONST_DOUBLE)\n-\tl1 = CONST_DOUBLE_LOW (op), h1 = CONST_DOUBLE_HIGH (op);\n+      if (GET_CODE (trueop) == CONST_DOUBLE)\n+\tl1 = CONST_DOUBLE_LOW (trueop), h1 = CONST_DOUBLE_HIGH (trueop);\n       else\n-\tl1 = INTVAL (op), h1 = HWI_SIGN_EXTEND (l1);\n+\tl1 = INTVAL (trueop), h1 = HWI_SIGN_EXTEND (l1);\n \n       switch (code)\n \t{\n@@ -531,7 +549,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n \n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-  else if (GET_CODE (op) == CONST_DOUBLE\n+  else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n       REAL_VALUE_TYPE d;\n@@ -546,7 +564,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n       set_float_handler (handler);\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n \n       switch (code)\n \t{\n@@ -587,8 +605,8 @@ simplify_unary_operation (code, mode, op, op_mode)\n       return x;\n     }\n \n-  else if (GET_CODE (op) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (op)) == MODE_FLOAT\n+  else if (GET_CODE (trueop) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (trueop)) == MODE_FLOAT\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n@@ -601,7 +619,7 @@ simplify_unary_operation (code, mode, op, op_mode)\n \n       set_float_handler (handler);\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n \n       switch (code)\n \t{\n@@ -713,6 +731,8 @@ simplify_binary_operation (code, mode, op0, op1)\n   HOST_WIDE_INT val;\n   unsigned int width = GET_MODE_BITSIZE (mode);\n   rtx tem;\n+  rtx trueop0 = avoid_constant_pool_reference (op0);\n+  rtx trueop1 = avoid_constant_pool_reference (op1);\n \n   /* Relational operations don't work here.  We must know the mode\n      of the operands in order to do the comparison correctly.\n@@ -722,9 +742,18 @@ simplify_binary_operation (code, mode, op0, op1)\n   if (GET_RTX_CLASS (code) == '<')\n     abort ();\n \n+  /* Make sure the constant is second.  */\n+  if (GET_RTX_CLASS (code) == 'c'\n+      && swap_commutative_operands_p (trueop0, trueop1))\n+    {\n+      tem = op0, op0 = op1, op1 = tem;\n+      tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n+    }\n+\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n-      && GET_CODE (op0) == CONST_DOUBLE && GET_CODE (op1) == CONST_DOUBLE\n+      && GET_CODE (trueop0) == CONST_DOUBLE\n+      && GET_CODE (trueop1) == CONST_DOUBLE\n       && mode == GET_MODE (op0) && mode == GET_MODE (op1))\n     {\n       REAL_VALUE_TYPE f0, f1, value;\n@@ -735,8 +764,8 @@ simplify_binary_operation (code, mode, op0, op1)\n \n       set_float_handler (handler);\n \n-      REAL_VALUE_FROM_CONST_DOUBLE (f0, op0);\n-      REAL_VALUE_FROM_CONST_DOUBLE (f1, op1);\n+      REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n+      REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n       f0 = real_value_truncate (mode, f0);\n       f1 = real_value_truncate (mode, f1);\n \n@@ -785,21 +814,23 @@ simplify_binary_operation (code, mode, op0, op1)\n   /* We can fold some multi-word operations.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT\n       && width == HOST_BITS_PER_WIDE_INT * 2\n-      && (GET_CODE (op0) == CONST_DOUBLE || GET_CODE (op0) == CONST_INT)\n-      && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n+      && (GET_CODE (trueop0) == CONST_DOUBLE\n+\t  || GET_CODE (trueop0) == CONST_INT)\n+      && (GET_CODE (trueop1) == CONST_DOUBLE\n+\t  || GET_CODE (trueop1) == CONST_INT))\n     {\n       unsigned HOST_WIDE_INT l1, l2, lv;\n       HOST_WIDE_INT h1, h2, hv;\n \n-      if (GET_CODE (op0) == CONST_DOUBLE)\n-\tl1 = CONST_DOUBLE_LOW (op0), h1 = CONST_DOUBLE_HIGH (op0);\n+      if (GET_CODE (trueop0) == CONST_DOUBLE)\n+\tl1 = CONST_DOUBLE_LOW (trueop0), h1 = CONST_DOUBLE_HIGH (trueop0);\n       else\n-\tl1 = INTVAL (op0), h1 = HWI_SIGN_EXTEND (l1);\n+\tl1 = INTVAL (trueop0), h1 = HWI_SIGN_EXTEND (l1);\n \n-      if (GET_CODE (op1) == CONST_DOUBLE)\n-\tl2 = CONST_DOUBLE_LOW (op1), h2 = CONST_DOUBLE_HIGH (op1);\n+      if (GET_CODE (trueop1) == CONST_DOUBLE)\n+\tl2 = CONST_DOUBLE_LOW (trueop1), h2 = CONST_DOUBLE_HIGH (trueop1);\n       else\n-\tl2 = INTVAL (op1), h2 = HWI_SIGN_EXTEND (l2);\n+\tl2 = INTVAL (trueop1), h2 = HWI_SIGN_EXTEND (l2);\n \n       switch (code)\n \t{\n@@ -919,7 +950,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && FLOAT_MODE_P (mode) && ! flag_unsafe_math_optimizations)\n \t    break;\n \n-\t  if (op1 == CONST0_RTX (mode))\n+\t  if (trueop1 == CONST0_RTX (mode))\n \t    return op0;\n \n \t  /* ((-a) + b) -> (b - a) and similarly for (a + (-b)) */\n@@ -931,8 +962,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* (~a) + 1 -> -a */\n \t  if (INTEGRAL_MODE_P (mode)\n \t      && GET_CODE (op0) == NOT\n-\t      && GET_CODE (op1) == CONST_INT\n-\t      && INTVAL (op1) == 1)\n+\t      && trueop1 == const1_rtx)\n \t    return gen_rtx_NEG (mode, XEXP (op0, 0));\n \n \t  /* Handle both-operands-constant cases.  We can only add\n@@ -1025,7 +1055,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n-\t      && op1 == CONST0_RTX (mode))\n+\t      && trueop1 == CONST0_RTX (mode))\n \t    return op0;\n #endif\n \n@@ -1060,21 +1090,21 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* We can't assume x-x is 0 even with non-IEEE floating point,\n \t     but since it is zero except in very strange circumstances, we\n \t     will treat it as zero with -funsafe-math-optimizations.  */\n-\t  if (rtx_equal_p (op0, op1)\n+\t  if (rtx_equal_p (trueop0, trueop1)\n \t      && ! side_effects_p (op0)\n \t      && (! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations))\n \t    return CONST0_RTX (mode);\n \n \t  /* Change subtraction from zero into negation.  */\n-\t  if (op0 == CONST0_RTX (mode))\n+\t  if (trueop0 == CONST0_RTX (mode))\n \t    return gen_rtx_NEG (mode, op1);\n \n \t  /* (-1 - a) is ~a.  */\n-\t  if (op0 == constm1_rtx)\n+\t  if (trueop0 == constm1_rtx)\n \t    return gen_rtx_NOT (mode, op1);\n \n \t  /* Subtracting 0 has no effect.  */\n-\t  if (op1 == CONST0_RTX (mode))\n+\t  if (trueop1 == CONST0_RTX (mode))\n \t    return op0;\n \n \t  /* See if this is something like X * C - X or vice versa or\n@@ -1164,7 +1194,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase MULT:\n-\t  if (op1 == constm1_rtx)\n+\t  if (trueop1 == constm1_rtx)\n \t    {\n \t      tem = simplify_unary_operation (NEG, mode, op0, mode);\n \n@@ -1174,20 +1204,20 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  /* In IEEE floating point, x*0 is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n-\t      && op1 == CONST0_RTX (mode)\n+\t      && trueop1 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n \n \t  /* In IEEE floating point, x*1 is not equivalent to x for nans.\n \t     However, ANSI says we can drop signals,\n \t     so we can do this anyway.  */\n-\t  if (op1 == CONST1_RTX (mode))\n+\t  if (trueop1 == CONST1_RTX (mode))\n \t    return op0;\n \n \t  /* Convert multiply by constant power of two into shift unless\n \t     we are still generating RTL.  This test is a kludge.  */\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (val = exact_log2 (INTVAL (op1))) >= 0\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && (val = exact_log2 (INTVAL (trueop1))) >= 0\n \t      /* If the mode is larger than the host word size, and the\n \t\t uppermost bit is set, then this isn't a power of two due\n \t\t to implicit sign extension.  */\n@@ -1196,8 +1226,8 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && ! rtx_equal_function_value_matters)\n \t    return gen_rtx_ASHIFT (mode, op0, GEN_INT (val));\n \n-\t  if (GET_CODE (op1) == CONST_DOUBLE\n-\t      && GET_MODE_CLASS (GET_MODE (op1)) == MODE_FLOAT)\n+\t  if (GET_CODE (trueop1) == CONST_DOUBLE\n+\t      && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT)\n \t    {\n \t      REAL_VALUE_TYPE d;\n \t      jmp_buf handler;\n@@ -1207,7 +1237,7 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\treturn 0;\n \n \t      set_float_handler (handler);\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n \t      op1is2 = REAL_VALUES_EQUAL (d, dconst2);\n \t      op1ism1 = REAL_VALUES_EQUAL (d, dconstm1);\n \t      set_float_handler (NULL);\n@@ -1222,12 +1252,13 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase IOR:\n-\t  if (op1 == const0_rtx)\n+\t  if (trueop1 == const0_rtx)\n \t    return op0;\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (INTVAL (op1) & GET_MODE_MASK (mode)) == GET_MODE_MASK (mode))\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n+\t          == GET_MODE_MASK (mode)))\n \t    return op1;\n-\t  if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n+\t  if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  /* A | (~A) -> -1 */\n \t  if (((GET_CODE (op0) == NOT && rtx_equal_p (XEXP (op0, 0), op1))\n@@ -1238,23 +1269,25 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase XOR:\n-\t  if (op1 == const0_rtx)\n+\t  if (trueop1 == const0_rtx)\n \t    return op0;\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (INTVAL (op1) & GET_MODE_MASK (mode)) == GET_MODE_MASK (mode))\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n+\t\t  == GET_MODE_MASK (mode)))\n \t    return gen_rtx_NOT (mode, op0);\n-\t  if (op0 == op1 && ! side_effects_p (op0)\n+\t  if (trueop0 == trueop1 && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return const0_rtx;\n \t  break;\n \n \tcase AND:\n-\t  if (op1 == const0_rtx && ! side_effects_p (op0))\n+\t  if (trueop1 == const0_rtx && ! side_effects_p (op0))\n \t    return const0_rtx;\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (INTVAL (op1) & GET_MODE_MASK (mode)) == GET_MODE_MASK (mode))\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && ((INTVAL (trueop1) & GET_MODE_MASK (mode))\n+\t\t  == GET_MODE_MASK (mode)))\n \t    return op0;\n-\t  if (op0 == op1 && ! side_effects_p (op0)\n+\t  if (trueop0 == trueop1 && ! side_effects_p (op0)\n \t      && GET_MODE_CLASS (mode) != MODE_CC)\n \t    return op0;\n \t  /* A & (~A) -> 0 */\n@@ -1268,33 +1301,33 @@ simplify_binary_operation (code, mode, op0, op1)\n \tcase UDIV:\n \t  /* Convert divide by power of two into shift (divide by 1 handled\n \t     below).  */\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (arg1 = exact_log2 (INTVAL (op1))) > 0)\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && (arg1 = exact_log2 (INTVAL (trueop1))) > 0)\n \t    return gen_rtx_LSHIFTRT (mode, op0, GEN_INT (arg1));\n \n \t  /* ... fall through ...  */\n \n \tcase DIV:\n-\t  if (op1 == CONST1_RTX (mode))\n+\t  if (trueop1 == CONST1_RTX (mode))\n \t    return op0;\n \n \t  /* In IEEE floating point, 0/x is not always 0.  */\n \t  if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n \t       || ! FLOAT_MODE_P (mode) || flag_unsafe_math_optimizations)\n-\t      && op0 == CONST0_RTX (mode)\n+\t      && trueop0 == CONST0_RTX (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n \n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n \t  /* Change division by a constant into multiplication.  Only do\n \t     this with -funsafe-math-optimizations.  */\n-\t  else if (GET_CODE (op1) == CONST_DOUBLE\n-\t\t   && GET_MODE_CLASS (GET_MODE (op1)) == MODE_FLOAT\n-\t\t   && op1 != CONST0_RTX (mode)\n+\t  else if (GET_CODE (trueop1) == CONST_DOUBLE\n+\t\t   && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT\n+\t\t   && trueop1 != CONST0_RTX (mode)\n \t\t   && flag_unsafe_math_optimizations)\n \t    {\n \t      REAL_VALUE_TYPE d;\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (d, op1);\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n \n \t      if (! REAL_VALUES_EQUAL (d, dconst0))\n \t\t{\n@@ -1314,23 +1347,23 @@ simplify_binary_operation (code, mode, op0, op1)\n \n \tcase UMOD:\n \t  /* Handle modulus by power of two (mod with 1 handled below).  */\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && exact_log2 (INTVAL (op1)) > 0)\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && exact_log2 (INTVAL (trueop1)) > 0)\n \t    return gen_rtx_AND (mode, op0, GEN_INT (INTVAL (op1) - 1));\n \n \t  /* ... fall through ...  */\n \n \tcase MOD:\n-\t  if ((op0 == const0_rtx || op1 == const1_rtx)\n+\t  if ((trueop0 == const0_rtx || trueop1 == const1_rtx)\n \t      && ! side_effects_p (op0) && ! side_effects_p (op1))\n \t    return const0_rtx;\n \t  break;\n \n \tcase ROTATERT:\n \tcase ROTATE:\n \t  /* Rotating ~0 always results in ~0.  */\n-\t  if (GET_CODE (op0) == CONST_INT && width <= HOST_BITS_PER_WIDE_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (op0) == GET_MODE_MASK (mode)\n+\t  if (GET_CODE (trueop0) == CONST_INT && width <= HOST_BITS_PER_WIDE_INT\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (trueop0) == GET_MODE_MASK (mode)\n \t      && ! side_effects_p (op1))\n \t    return op0;\n \n@@ -1339,42 +1372,42 @@ simplify_binary_operation (code, mode, op0, op1)\n \tcase ASHIFT:\n \tcase ASHIFTRT:\n \tcase LSHIFTRT:\n-\t  if (op1 == const0_rtx)\n+\t  if (trueop1 == const0_rtx)\n \t    return op0;\n-\t  if (op0 == const0_rtx && ! side_effects_p (op1))\n+\t  if (trueop0 == const0_rtx && ! side_effects_p (op1))\n \t    return op0;\n \t  break;\n \n \tcase SMIN:\n-\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (op1) == CONST_INT \n-\t      && INTVAL (op1) == (HOST_WIDE_INT) 1 << (width -1)\n+\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT \n+\t      && INTVAL (trueop1) == (HOST_WIDE_INT) 1 << (width -1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n+\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n \t   \n \tcase SMAX:\n-\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (op1) == CONST_INT\n-\t      && ((unsigned HOST_WIDE_INT) INTVAL (op1)\n+\t  if (width <= HOST_BITS_PER_WIDE_INT && GET_CODE (trueop1) == CONST_INT\n+\t      && ((unsigned HOST_WIDE_INT) INTVAL (trueop1)\n \t\t  == (unsigned HOST_WIDE_INT) GET_MODE_MASK (mode) >> 1)\n \t      && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n+\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n \n \tcase UMIN:\n-\t  if (op1 == const0_rtx && ! side_effects_p (op0))\n+\t  if (trueop1 == const0_rtx && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n+\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n \t    \n \tcase UMAX:\n-\t  if (op1 == constm1_rtx && ! side_effects_p (op0))\n+\t  if (trueop1 == constm1_rtx && ! side_effects_p (op0))\n \t    return op1;\n-\t  else if (rtx_equal_p (op0, op1) && ! side_effects_p (op0))\n+\t  else if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n \t    return op0;\n \t  break;\n \n@@ -1388,8 +1421,8 @@ simplify_binary_operation (code, mode, op0, op1)\n   /* Get the integer argument values in two forms:\n      zero-extended in ARG0, ARG1 and sign-extended in ARG0S, ARG1S.  */\n \n-  arg0 = INTVAL (op0);\n-  arg1 = INTVAL (op1);\n+  arg0 = INTVAL (trueop0);\n+  arg1 = INTVAL (trueop1);\n \n   if (width < HOST_BITS_PER_WIDE_INT)\n     {\n@@ -1785,6 +1818,8 @@ simplify_relational_operation (code, mode, op0, op1)\n {\n   int equal, op0lt, op0ltu, op1lt, op1ltu;\n   rtx tem;\n+  rtx trueop0;\n+  rtx trueop1;\n \n   if (mode == VOIDmode\n       && (GET_MODE (op0) != VOIDmode\n@@ -1795,6 +1830,9 @@ simplify_relational_operation (code, mode, op0, op1)\n   if (GET_CODE (op0) == COMPARE && op1 == const0_rtx)\n     op1 = XEXP (op0, 1), op0 = XEXP (op0, 0);\n \n+  trueop0 = avoid_constant_pool_reference (op0);\n+  trueop1 = avoid_constant_pool_reference (op1);\n+\n   /* We can't simplify MODE_CC values since we don't know what the\n      actual comparison is.  */\n   if (GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC\n@@ -1805,9 +1843,10 @@ simplify_relational_operation (code, mode, op0, op1)\n     return 0;\n \n   /* Make sure the constant is second.  */\n-  if (swap_commutative_operands_p (op0, op1))\n+  if (swap_commutative_operands_p (trueop0, trueop1))\n     {\n       tem = op0, op0 = op1, op1 = tem;\n+      tem = trueop0, trueop0 = trueop1, trueop1 = tem;\n       code = swap_condition (code);\n     }\n \n@@ -1821,9 +1860,9 @@ simplify_relational_operation (code, mode, op0, op1)\n      ANSI C defines unsigned operations such that they never overflow, and\n      thus such cases can not be ignored.  */\n \n-  if (INTEGRAL_MODE_P (mode) && op1 != const0_rtx\n-      && ! ((GET_CODE (op0) == REG || GET_CODE (op0) == CONST_INT)\n-\t    && (GET_CODE (op1) == REG || GET_CODE (op1) == CONST_INT))\n+  if (INTEGRAL_MODE_P (mode) && trueop1 != const0_rtx\n+      && ! ((GET_CODE (op0) == REG || GET_CODE (trueop0) == CONST_INT)\n+\t    && (GET_CODE (op1) == REG || GET_CODE (trueop1) == CONST_INT))\n       && 0 != (tem = simplify_binary_operation (MINUS, mode, op0, op1))\n       && code != GTU && code != GEU && code != LTU && code != LEU)\n     return simplify_relational_operation (signed_condition (code),\n@@ -1837,23 +1876,24 @@ simplify_relational_operation (code, mode, op0, op1)\n \n   /* For non-IEEE floating-point, if the two operands are equal, we know the\n      result.  */\n-  if (rtx_equal_p (op0, op1)\n+  if (rtx_equal_p (trueop0, trueop1)\n       && (TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t  || ! FLOAT_MODE_P (GET_MODE (op0)) \n+\t  || ! FLOAT_MODE_P (GET_MODE (trueop0)) \n \t  || flag_unsafe_math_optimizations))\n     equal = 1, op0lt = 0, op0ltu = 0, op1lt = 0, op1ltu = 0;\n \n   /* If the operands are floating-point constants, see if we can fold\n      the result.  */\n #if ! defined (REAL_IS_NOT_DOUBLE) || defined (REAL_ARITHMETIC)\n-  else if (GET_CODE (op0) == CONST_DOUBLE && GET_CODE (op1) == CONST_DOUBLE\n-\t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_FLOAT)\n+  else if (GET_CODE (trueop0) == CONST_DOUBLE\n+\t   && GET_CODE (trueop1) == CONST_DOUBLE\n+\t   && GET_MODE_CLASS (GET_MODE (trueop0)) == MODE_FLOAT)\n     {\n       struct cfc_args args;\n \n       /* Setup input for check_fold_consts() */\n-      args.op0 = op0;\n-      args.op1 = op1;\n+      args.op0 = trueop0;\n+      args.op1 = trueop1;\n       \n       \n       if (!do_float_handler (check_fold_consts, (PTR) &args))\n@@ -1891,33 +1931,35 @@ simplify_relational_operation (code, mode, op0, op1)\n \n   /* Otherwise, see if the operands are both integers.  */\n   else if ((GET_MODE_CLASS (mode) == MODE_INT || mode == VOIDmode)\n-\t   && (GET_CODE (op0) == CONST_DOUBLE || GET_CODE (op0) == CONST_INT)\n-\t   && (GET_CODE (op1) == CONST_DOUBLE || GET_CODE (op1) == CONST_INT))\n+\t   && (GET_CODE (trueop0) == CONST_DOUBLE\n+\t       || GET_CODE (trueop0) == CONST_INT)\n+\t   && (GET_CODE (trueop1) == CONST_DOUBLE\n+\t       || GET_CODE (trueop1) == CONST_INT))\n     {\n       int width = GET_MODE_BITSIZE (mode);\n       HOST_WIDE_INT l0s, h0s, l1s, h1s;\n       unsigned HOST_WIDE_INT l0u, h0u, l1u, h1u;\n \n       /* Get the two words comprising each integer constant.  */\n-      if (GET_CODE (op0) == CONST_DOUBLE)\n+      if (GET_CODE (trueop0) == CONST_DOUBLE)\n \t{\n-\t  l0u = l0s = CONST_DOUBLE_LOW (op0);\n-\t  h0u = h0s = CONST_DOUBLE_HIGH (op0);\n+\t  l0u = l0s = CONST_DOUBLE_LOW (trueop0);\n+\t  h0u = h0s = CONST_DOUBLE_HIGH (trueop0);\n \t}\n       else\n \t{\n-\t  l0u = l0s = INTVAL (op0);\n+\t  l0u = l0s = INTVAL (trueop0);\n \t  h0u = h0s = HWI_SIGN_EXTEND (l0s);\n \t}\n \t  \n-      if (GET_CODE (op1) == CONST_DOUBLE)\n+      if (GET_CODE (trueop1) == CONST_DOUBLE)\n \t{\n-\t  l1u = l1s = CONST_DOUBLE_LOW (op1);\n-\t  h1u = h1s = CONST_DOUBLE_HIGH (op1);\n+\t  l1u = l1s = CONST_DOUBLE_LOW (trueop1);\n+\t  h1u = h1s = CONST_DOUBLE_HIGH (trueop1);\n \t}\n       else\n \t{\n-\t  l1u = l1s = INTVAL (op1);\n+\t  l1u = l1s = INTVAL (trueop1);\n \t  h1u = h1s = HWI_SIGN_EXTEND (l1s);\n \t}\n \n@@ -1952,8 +1994,8 @@ simplify_relational_operation (code, mode, op0, op1)\n \tcase EQ:\n \t  /* References to the frame plus a constant or labels cannot\n \t     be zero, but a SYMBOL_REF can due to #pragma weak.  */\n-\t  if (((NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n-\t       || GET_CODE (op0) == LABEL_REF)\n+\t  if (((NONZERO_BASE_PLUS_P (op0) && trueop1 == const0_rtx)\n+\t       || GET_CODE (trueop0) == LABEL_REF)\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t      /* On some machines, the ap reg can be 0 sometimes.  */\n \t      && op0 != arg_pointer_rtx\n@@ -1963,8 +2005,8 @@ simplify_relational_operation (code, mode, op0, op1)\n \t  break;\n \n \tcase NE:\n-\t  if (((NONZERO_BASE_PLUS_P (op0) && op1 == const0_rtx)\n-\t       || GET_CODE (op0) == LABEL_REF)\n+\t  if (((NONZERO_BASE_PLUS_P (op0) && trueop1 == const0_rtx)\n+\t       || GET_CODE (trueop0) == LABEL_REF)\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n \t      && op0 != arg_pointer_rtx\n #endif\n@@ -1974,27 +2016,27 @@ simplify_relational_operation (code, mode, op0, op1)\n \n \tcase GEU:\n \t  /* Unsigned values are never negative.  */\n-\t  if (op1 == const0_rtx)\n+\t  if (trueop1 == const0_rtx)\n \t    return const_true_rtx;\n \t  break;\n \n \tcase LTU:\n-\t  if (op1 == const0_rtx)\n+\t  if (trueop1 == const0_rtx)\n \t    return const0_rtx;\n \t  break;\n \n \tcase LEU:\n \t  /* Unsigned values are never greater than the largest\n \t     unsigned value.  */\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (op1) == GET_MODE_MASK (mode)\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (trueop1) == GET_MODE_MASK (mode)\n \t    && INTEGRAL_MODE_P (mode))\n \t  return const_true_rtx;\n \t  break;\n \n \tcase GTU:\n-\t  if (GET_CODE (op1) == CONST_INT\n-\t      && (unsigned HOST_WIDE_INT) INTVAL (op1) == GET_MODE_MASK (mode)\n+\t  if (GET_CODE (trueop1) == CONST_INT\n+\t      && (unsigned HOST_WIDE_INT) INTVAL (trueop1) == GET_MODE_MASK (mode)\n \t      && INTEGRAL_MODE_P (mode))\n \t    return const0_rtx;\n \t  break;"}]}