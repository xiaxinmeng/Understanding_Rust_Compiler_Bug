{"sha": "866e6d1bc163f73aebee6db5eb107fd2c5631543", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY2ZTZkMWJjMTYzZjczYWViZWU2ZGI1ZWIxMDdmZDJjNTYzMTU0Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-16T17:48:26Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2012-01-16T17:48:26Z"}, "message": "trans-array.c (gfc_trans_create_temp_array): In the case of a class array temporary...\n\n2012-01-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* trans-array.c (gfc_trans_create_temp_array): In the case of a\n\tclass array temporary, detect a null 'eltype' on entry and use \n\t'initial' to provde the class reference and so, through the\n\tvtable, the element size for the dynamic type.\n\t* trans-stmt.c (gfc_conv_elemental_dependencies): For class\n\texpressions, set 'eltype' to null and pass the values via the\n\t'initial' expression.\n\n2012-01-16  Paul Thomas  <pault@gcc.gnu.org>\n\n\t* gfortran.dg/class_array_3.f03: Remove the explicit loop in\n\tsubroutine 'qsort' and use index array to assign the result.\n\nFrom-SVN: r183216", "tree": {"sha": "bf7f629b5cbc145d54768a410a2bd8fec3382995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf7f629b5cbc145d54768a410a2bd8fec3382995"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/866e6d1bc163f73aebee6db5eb107fd2c5631543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866e6d1bc163f73aebee6db5eb107fd2c5631543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/866e6d1bc163f73aebee6db5eb107fd2c5631543", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/866e6d1bc163f73aebee6db5eb107fd2c5631543/comments", "author": null, "committer": null, "parents": [{"sha": "c53153e7a099d3212a60912cd407abc04fb2610a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53153e7a099d3212a60912cd407abc04fb2610a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53153e7a099d3212a60912cd407abc04fb2610a"}], "stats": {"total": 105, "additions": 82, "deletions": 23}, "files": [{"sha": "14c226ae137305032d30eeb30c92db0a730a9c53", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=866e6d1bc163f73aebee6db5eb107fd2c5631543", "patch": "@@ -1,3 +1,13 @@\n+2012-01-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_trans_create_temp_array): In the case of a\n+\tclass array temporary, detect a null 'eltype' on entry and use \n+\t'initial' to provde the class reference and so, through the\n+\tvtable, the element size for the dynamic type.\n+\t* trans-stmt.c (gfc_conv_elemental_dependencies): For class\n+\texpressions, set 'eltype' to null and pass the values via the\n+\t'initial' expression.\n+\n 2012-01-14  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/51800"}, {"sha": "6dcd5318a5f8b888d31058feac81c7cb2e4c48dd", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=866e6d1bc163f73aebee6db5eb107fd2c5631543", "patch": "@@ -971,6 +971,11 @@ get_array_ref_dim_for_loop_dim (gfc_ss *ss, int loop_dim)\n    fields of info if known.  Returns the size of the array, or NULL for a\n    callee allocated array.\n \n+   'eltype' == NULL signals that the temporary should be a class object.\n+   The 'initial' expression is used to obtain the size of the dynamic\n+   type; otehrwise the allocation and initialisation proceeds as for any\n+   other expression\n+\n    PRE, POST, INITIAL, DYNAMIC and DEALLOC are as for\n    gfc_trans_allocate_array_storage.  */\n \n@@ -990,9 +995,23 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   tree nelem;\n   tree cond;\n   tree or_expr;\n+  tree class_expr = NULL_TREE;\n   int n, dim, tmp_dim;\n   int total_dim = 0;\n \n+  /* This signals a class array for which we need the size of the\n+     dynamic type.  Generate an eltype and then the class expression.  */\n+  if (eltype == NULL_TREE && initial)\n+    {\n+      if (POINTER_TYPE_P (TREE_TYPE (initial)))\n+\tclass_expr = build_fold_indirect_ref_loc (input_location, initial);\n+      eltype = TREE_TYPE (class_expr);\n+      eltype = gfc_get_element_type (eltype);\n+      /* Obtain the structure (class) expression.  */\n+      class_expr = TREE_OPERAND (class_expr, 0);\n+      gcc_assert (class_expr);\n+    }\n+\n   memset (from, 0, sizeof (from));\n   memset (to, 0, sizeof (to));\n \n@@ -1133,16 +1152,21 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   /* Get the size of the array.  */\n   if (size && !callee_alloc)\n     {\n+      tree elemsize;\n       /* If or_expr is true, then the extent in at least one\n \t dimension is zero and the size is set to zero.  */\n       size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,\n \t\t\t      or_expr, gfc_index_zero_node, size);\n \n       nelem = size;\n+      if (class_expr == NULL_TREE)\n+\telemsize = fold_convert (gfc_array_index_type,\n+\t\t\tTYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      else\n+\telemsize = gfc_vtable_size_get (class_expr);\n+\n       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,\n-\t\tsize,\n-\t\tfold_convert (gfc_array_index_type,\n-\t\t\t      TYPE_SIZE_UNIT (gfc_get_element_type (type))));\n+\t\t\t      size, elemsize);\n     }\n   else\n     {\n@@ -5083,9 +5107,9 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   if (expr->ts.type == BT_CLASS && expr3)\n     {\n       tmp = build_int_cst (unsigned_char_type_node, 0);\n-      /* For class objects we need to nullify the memory in case they have\n-\t allocatable components; the reason is that _copy, which is used for\n-\t initialization, first frees the destination.  */\n+      /* With class objects, it is best to play safe and null the \n+\t memory because we cannot know if dynamic types have allocatable\n+\t components or not.  */\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_MEMSET),\n \t\t\t\t 3, pointer, tmp,  size);"}, {"sha": "16acc33a2698a8608bcb25d5927fc905723876f2", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=866e6d1bc163f73aebee6db5eb107fd2c5631543", "patch": "@@ -282,19 +282,31 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t\t|| (fsym->ts.type ==BT_DERIVED\n \t\t      && fsym->attr.intent == INTENT_OUT))\n \t    initial = parmse.expr;\n+\t  /* For class expressions, we always initialize with the copy of\n+\t     the values.  */\n+\t  else if (e->ts.type == BT_CLASS)\n+\t    initial = parmse.expr;\n \t  else\n \t    initial = NULL_TREE;\n \n-\t  /* Find the type of the temporary to create; we don't use the type\n-\t     of e itself as this breaks for subcomponent-references in e (where\n-\t     the type of e is that of the final reference, but parmse.expr's\n-\t     type corresponds to the full derived-type).  */\n-\t  /* TODO: Fix this somehow so we don't need a temporary of the whole\n-\t     array but instead only the components referenced.  */\n-\t  temptype = TREE_TYPE (parmse.expr); /* Pointer to descriptor.  */\n-\t  gcc_assert (TREE_CODE (temptype) == POINTER_TYPE);\n-\t  temptype = TREE_TYPE (temptype);\n-\t  temptype = gfc_get_element_type (temptype);\n+\t  if (e->ts.type != BT_CLASS)\n+\t    {\n+\t     /* Find the type of the temporary to create; we don't use the type\n+\t\tof e itself as this breaks for subcomponent-references in e\n+\t\t(where the type of e is that of the final reference, but\n+\t\tparmse.expr's type corresponds to the full derived-type).  */\n+\t     /* TODO: Fix this somehow so we don't need a temporary of the whole\n+\t\tarray but instead only the components referenced.  */\n+\t      temptype = TREE_TYPE (parmse.expr); /* Pointer to descriptor.  */\n+\t      gcc_assert (TREE_CODE (temptype) == POINTER_TYPE);\n+\t      temptype = TREE_TYPE (temptype);\n+\t      temptype = gfc_get_element_type (temptype);\n+\t    }\n+\n+\t  else\n+\t    /* For class arrays signal that the size of the dynamic type has to\n+\t       be obtained from the vtable, using the 'initial' expression.  */\n+\t    temptype = NULL_TREE;\n \n \t  /* Generate the temporary.  Cleaning up the temporary should be the\n \t     very last thing done, so we add the code to a new block and add it\n@@ -312,9 +324,20 @@ gfc_conv_elemental_dependencies (gfc_se * se, gfc_se * loopse,\n \t  /* Update other ss' delta.  */\n \t  gfc_set_delta (loopse->loop);\n \n-\t  /* Copy the result back using unpack.  */\n-\t  tmp = build_call_expr_loc (input_location,\n-\t\t\t\t gfor_fndecl_in_unpack, 2, parmse.expr, data);\n+\t  /* Copy the result back using unpack.....  */\n+\t  if (e->ts.type != BT_CLASS)\n+\t    tmp = build_call_expr_loc (input_location,\n+\t\t\tgfor_fndecl_in_unpack, 2, parmse.expr, data);\n+\t  else\n+\t    {\n+\t      /* ... except for class results where the copy is\n+\t\t unconditional.  */\n+\t      tmp = build_fold_indirect_ref_loc (input_location, parmse.expr);\n+\t      tmp = gfc_conv_descriptor_data_get (tmp);\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t\t builtin_decl_explicit (BUILT_IN_MEMCPY),\n+\t\t\t\t\t 3, tmp, data, size);\n+\t    }\n \t  gfc_add_expr_to_block (&se->post, tmp);\n \n \t  /* parmse.pre is already added above.  */"}, {"sha": "4e58ca5c01865431a53a2ee957c8b0c56c978c3b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=866e6d1bc163f73aebee6db5eb107fd2c5631543", "patch": "@@ -1,3 +1,8 @@\n+2012-01-16  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\t* gfortran.dg/class_array_3.f03: Remove the explicit loop in\n+\tsubroutine 'qsort' and use index array to assign the result.\n+\n 2012-01-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/51865"}, {"sha": "8972161fbb3fbec2ea14be1eaeb1bad12e1a65de", "filename": "gcc/testsuite/gfortran.dg/class_array_3.f03", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/866e6d1bc163f73aebee6db5eb107fd2c5631543/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_array_3.f03?ref=866e6d1bc163f73aebee6db5eb107fd2c5631543", "patch": "@@ -45,10 +45,7 @@ subroutine qsort(a)\n    allocate (tmp(size (a, 1)), source = a)\n    index_array = [(i, i = 1, size (a, 1))]\n    call internal_qsort (tmp, index_array)   ! Do not move class elements around until end\n-   do i = 1, size (a, 1)                    ! Since they can be of arbitrary size.\n-     a(i) = tmp(index_array(i))             ! Vector index array would be neater\n-   end do\n-!    a = tmp(index_array)                    ! Like this - TODO: fixme\n+   a = tmp(index_array)\n  end subroutine qsort\n \n  recursive subroutine internal_qsort (x, iarray)"}]}