{"sha": "3696a50beeb73f4ded8a584e76ee16f0bde109b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY5NmE1MGJlZWI3M2Y0ZGVkOGE1ODRlNzZlZTE2ZjBiZGUxMDliOQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T14:32:35Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T20:54:16Z"}, "message": "Change C front end to emit structured loop and switch tree nodes.\n\n2020-08-12  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/c\n\t* c-decl.c (c_break_label, c_cont_label): Delete, and replace\n\twith...\n\t(in_statement): New.\n\t(start_function): Adjust for above change.\n\t(c_push_function_context, c_pop_function_context): Likewise.\n\t* c-lang.h (struct language_function): Likewise.\n\t* c-objc-common.h (LANG_HOOKS_BLOCK_MAY_FALLTHRU): Define.\n\t* c-parser.c (objc_foreach_break_label, objc_foreach_continue_label):\n\tNew.\n\t(c_parser_statement_after_labels): Adjust calls to c_finish_bc_stmt.\n\t(c_parser_switch_statement): Adjust break/switch context handling\n\tand calls to renamed functions.\n\t(c_parser_while_statement): Adjust break/switch context handling and\n\tbuild a WHILE_STMT.\n\t(c_parser_do_statement): Ditto, with DO_STMT respectively.\n\t(c_parser_for_statement): Ditto, with FOR_STMT respectively.\n\t(c_parser_omp_for_loop): Adjust break/switch context handling.\n\t* c-tree.h (c_break_label, c_cont_label): Delete.\n\t(IN_SWITCH_STMT, IN_ITERATION_STMT): Define.\n\t(IN_OMP_BLOCK, IN_OMP_FOR, IN_OBJC_FOREACH): Define.\n\t(in_statement, switch_statement_break_seen_p): Declare.\n\t(c_start_case, c_finish_case): Renamed to...\n\t(c_start_switch, c_finish_switch).\n\t(c_finish_bc_stmt): Adjust arguments.\n\t* c-typeck.c (build_function_call_vec): Don't try to print\n\tstatements with %qE format.\n\t(struct c_switch):  Rename switch_expr field to switch_stmt.\n\tAdd break_stmt_seen_p field.\n\t(c_start_case): Rename to c_start_switch.  Build a SWITCH_STMT\n\tinstead of a SWITCH_EXPR.  Update for changes to struct c_switch.\n\t(do_case): Update for changes to struct c_switch.\n\t(c_finish_case): Rename to c_finish_switch.  Update for changes to\n\tstruct c_switch and change of representation from SWITCH_EXPR to\n\tSWITCH_STMT.\n\t(c_finish_loop): Delete.\n\t(c_finish_bc_stmt): Update to reflect changes to break/continue\n\tstate representation.  Build a BREAK_STMT or CONTINUE_STMT instead\n\tof a GOTO_EXPR except for objc foreach loops.\n\n\tgcc/objc\n\t* objc-act.c (objc_start_method_definition): Update to reflect\n\tchanges to break/continue state bookkeeping in C front end.\n\n\tgcc/testsuite/\n\t* gcc.dg/gomp/block-7.c: Update expected error message wording.", "tree": {"sha": "547aae764865eb453ea15100d01ddd72cae15773", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/547aae764865eb453ea15100d01ddd72cae15773"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3696a50beeb73f4ded8a584e76ee16f0bde109b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3696a50beeb73f4ded8a584e76ee16f0bde109b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3696a50beeb73f4ded8a584e76ee16f0bde109b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3696a50beeb73f4ded8a584e76ee16f0bde109b9/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85e5696a31cac8c14dde14f031e76480205f8a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a85e5696a31cac8c14dde14f031e76480205f8a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a85e5696a31cac8c14dde14f031e76480205f8a0"}], "stats": {"total": 414, "additions": 164, "deletions": 250}, "files": [{"sha": "8204db2a16ea5febe398ce2435c4744d0826ef16", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -112,9 +112,9 @@ struct obstack parser_obstack;\n \n static GTY(()) struct stmt_tree_s c_stmt_tree;\n \n-/* State saving variables.  */\n-tree c_break_label;\n-tree c_cont_label;\n+/* Zero if we are not in an iteration or switch statement, otherwise\n+   a bitmask.  See bitmask definitions in c-tree.h.  */\n+unsigned char in_statement;\n \n /* A list of decls to be made automatically visible in each file scope.  */\n static GTY(()) tree visible_builtins;\n@@ -9163,10 +9163,8 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   warn_about_return_type = 0;\n   c_switch_stack = NULL;\n \n-  /* Indicate no valid break/continue context by setting these variables\n-     to some non-null, non-label value.  We'll notice and emit the proper\n-     error message in c_finish_bc_stmt.  */\n-  c_break_label = c_cont_label = size_zero_node;\n+  /* Indicate no valid break/continue context.  */\n+  in_statement = 0;\n \n   decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, true, NULL,\n \t\t\t  &attributes, NULL, NULL, DEPRECATED_NORMAL);\n@@ -10167,8 +10165,7 @@ c_push_function_context (void)\n \n   p->base.x_stmt_tree = c_stmt_tree;\n   c_stmt_tree.x_cur_stmt_list = vec_safe_copy (c_stmt_tree.x_cur_stmt_list);\n-  p->x_break_label = c_break_label;\n-  p->x_cont_label = c_cont_label;\n+  p->x_in_statement = in_statement;\n   p->x_switch_stack = c_switch_stack;\n   p->arg_info = current_function_arg_info;\n   p->returns_value = current_function_returns_value;\n@@ -10207,8 +10204,7 @@ c_pop_function_context (void)\n \n   c_stmt_tree = p->base.x_stmt_tree;\n   p->base.x_stmt_tree.x_cur_stmt_list = NULL;\n-  c_break_label = p->x_break_label;\n-  c_cont_label = p->x_cont_label;\n+  in_statement = p->x_in_statement;\n   c_switch_stack = p->x_switch_stack;\n   current_function_arg_info = p->arg_info;\n   current_function_returns_value = p->returns_value;"}, {"sha": "7e9a276f86158d3d66ada7c04579679800f78ae7", "filename": "gcc/c/c-lang.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-lang.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-lang.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-lang.h?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -51,8 +51,7 @@ struct GTY(()) lang_decl {\n \n struct GTY(()) language_function {\n   struct c_language_function base;\n-  tree x_break_label;\n-  tree x_cont_label;\n+  unsigned char x_in_statement;\n   struct c_switch * GTY((skip)) x_switch_stack;\n   struct c_arg_info * GTY((skip)) arg_info;\n   int returns_value;"}, {"sha": "76f9db7cc552a8970c0b6963a2d488f257ba6b74", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -56,6 +56,8 @@ along with GCC; see the file COPYING3.  If not see\n #define LANG_HOOKS_TYPES_COMPATIBLE_P c_types_compatible_p\n #undef LANG_HOOKS_MISSING_NORETURN_OK_P\n #define LANG_HOOKS_MISSING_NORETURN_OK_P c_missing_noreturn_ok_p\n+#undef LANG_HOOKS_BLOCK_MAY_FALLTHRU\n+#define LANG_HOOKS_BLOCK_MAY_FALLTHRU c_block_may_fallthru\n #undef  LANG_HOOKS_BUILTIN_FUNCTION\n #define LANG_HOOKS_BUILTIN_FUNCTION c_builtin_function\n #undef  LANG_HOOKS_BUILTIN_FUNCTION_EXT_SCOPE"}, {"sha": "2e6775aefe74d5c356c4c0472856408b2ad353d7", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 60, "deletions": 65, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -1479,6 +1479,9 @@ struct oacc_routine_data {\n   location_t loc;\n };\n \n+/* Used for parsing objc foreach statements.  */\n+static tree objc_foreach_break_label, objc_foreach_continue_label;\n+\n static bool c_parser_nth_token_starts_std_attributes (c_parser *,\n \t\t\t\t\t\t      unsigned int);\n static tree c_parser_std_attribute_specifier_sequence (c_parser *);\n@@ -6221,11 +6224,11 @@ c_parser_statement_after_labels (c_parser *parser, bool *if_p,\n \t  goto expect_semicolon;\n \tcase RID_CONTINUE:\n \t  c_parser_consume_token (parser);\n-\t  stmt = c_finish_bc_stmt (loc, &c_cont_label, false);\n+\t  stmt = c_finish_bc_stmt (loc, objc_foreach_continue_label, false);\n \t  goto expect_semicolon;\n \tcase RID_BREAK:\n \t  c_parser_consume_token (parser);\n-\t  stmt = c_finish_bc_stmt (loc, &c_break_label, true);\n+\t  stmt = c_finish_bc_stmt (loc, objc_foreach_break_label, true);\n \t  goto expect_semicolon;\n \tcase RID_RETURN:\n \t  c_parser_consume_token (parser);\n@@ -6627,7 +6630,8 @@ static void\n c_parser_switch_statement (c_parser *parser, bool *if_p)\n {\n   struct c_expr ce;\n-  tree block, expr, body, save_break;\n+  tree block, expr, body;\n+  unsigned char save_in_statement;\n   location_t switch_loc = c_parser_peek_token (parser)->location;\n   location_t switch_cond_loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_SWITCH));\n@@ -6653,26 +6657,18 @@ c_parser_switch_statement (c_parser *parser, bool *if_p)\n       expr = error_mark_node;\n       ce.original_type = error_mark_node;\n     }\n-  c_start_case (switch_loc, switch_cond_loc, expr, explicit_cast_p);\n-  save_break = c_break_label;\n-  c_break_label = NULL_TREE;\n+  c_start_switch (switch_loc, switch_cond_loc, expr, explicit_cast_p);\n+  save_in_statement = in_statement;\n+  in_statement |= IN_SWITCH_STMT;\n   location_t loc_after_labels;\n   bool open_brace_p = c_parser_peek_token (parser)->type == CPP_OPEN_BRACE;\n   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);\n   location_t next_loc = c_parser_peek_token (parser)->location;\n   if (!open_brace_p && c_parser_peek_token (parser)->type != CPP_SEMICOLON)\n     warn_for_multistatement_macros (loc_after_labels, next_loc, switch_loc,\n \t\t\t\t    RID_SWITCH);\n-  if (c_break_label)\n-    {\n-      location_t here = c_parser_peek_token (parser)->location;\n-      tree t = build1 (LABEL_EXPR, void_type_node, c_break_label);\n-      SET_EXPR_LOCATION (t, here);\n-      SWITCH_BREAK_LABEL_P (c_break_label) = 1;\n-      append_to_statement_list_force (t, &body);\n-    }\n-  c_finish_case (body, ce.original_type);\n-  c_break_label = save_break;\n+  c_finish_switch (body, ce.original_type);\n+  in_statement = save_in_statement;\n   add_stmt (c_end_compound_stmt (switch_loc, block, flag_isoc99));\n   c_parser_maybe_reclassify_token (parser);\n }\n@@ -6690,7 +6686,8 @@ static void\n c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\t\t  bool *if_p)\n {\n-  tree block, cond, body, save_break, save_cont;\n+  tree block, cond, body;\n+  unsigned char save_in_statement;\n   location_t loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_WHILE));\n   token_indent_info while_tinfo\n@@ -6709,19 +6706,16 @@ c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\t   build_int_cst (integer_type_node,\n \t\t\t\t  annot_expr_unroll_kind),\n \t\t   build_int_cst (integer_type_node, unroll));\n-  save_break = c_break_label;\n-  c_break_label = NULL_TREE;\n-  save_cont = c_cont_label;\n-  c_cont_label = NULL_TREE;\n+  save_in_statement = in_statement;\n+  in_statement = IN_ITERATION_STMT;\n \n   token_indent_info body_tinfo\n     = get_token_indent_info (c_parser_peek_token (parser));\n \n   location_t loc_after_labels;\n   bool open_brace = c_parser_next_token_is (parser, CPP_OPEN_BRACE);\n   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);\n-  c_finish_loop (loc, loc, cond, UNKNOWN_LOCATION, NULL, body,\n-\t\t c_break_label, c_cont_label, true);\n+  add_stmt (build_stmt (loc, WHILE_STMT, cond, body));\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n   c_parser_maybe_reclassify_token (parser);\n \n@@ -6733,8 +6727,7 @@ c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n     warn_for_multistatement_macros (loc_after_labels, next_tinfo.location,\n \t\t\t\t    while_tinfo.location, RID_WHILE);\n \n-  c_break_label = save_break;\n-  c_cont_label = save_cont;\n+  in_statement = save_in_statement;\n }\n \n /* Parse a do statement (C90 6.6.5, C99 6.8.5, C11 6.8.5).\n@@ -6746,7 +6739,8 @@ c_parser_while_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n static void\n c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n {\n-  tree block, cond, body, save_break, save_cont, new_break, new_cont;\n+  tree block, cond, body;\n+  unsigned char save_in_statement;\n   location_t loc;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_DO));\n   c_parser_consume_token (parser);\n@@ -6756,17 +6750,11 @@ c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n \t\t\"suggest braces around empty body in %<do%> statement\");\n   block = c_begin_compound_stmt (flag_isoc99);\n   loc = c_parser_peek_token (parser)->location;\n-  save_break = c_break_label;\n-  c_break_label = NULL_TREE;\n-  save_cont = c_cont_label;\n-  c_cont_label = NULL_TREE;\n+  save_in_statement = in_statement;\n+  in_statement = IN_ITERATION_STMT;\n   body = c_parser_c99_block_statement (parser, NULL);\n   c_parser_require_keyword (parser, RID_WHILE, \"expected %<while%>\");\n-  new_break = c_break_label;\n-  c_break_label = save_break;\n-  new_cont = c_cont_label;\n-  c_cont_label = save_cont;\n-  location_t cond_loc = c_parser_peek_token (parser)->location;\n+  in_statement = save_in_statement;\n   cond = c_parser_paren_condition (parser);\n   if (ivdep && cond != error_mark_node)\n     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,\n@@ -6780,8 +6768,8 @@ c_parser_do_statement (c_parser *parser, bool ivdep, unsigned short unroll)\n  \t\t   build_int_cst (integer_type_node, unroll));\n   if (!c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n     c_parser_skip_to_end_of_block_or_statement (parser);\n-  c_finish_loop (loc, cond_loc, cond, UNKNOWN_LOCATION, NULL, body,\n-\t\t new_break, new_cont, false);\n+\n+  add_stmt (build_stmt (loc, DO_STMT, cond, body));\n   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));\n }\n \n@@ -6848,15 +6836,15 @@ static void\n c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t\t\tbool *if_p)\n {\n-  tree block, cond, incr, save_break, save_cont, body;\n+  tree block, cond, incr, body;\n+  unsigned char save_in_statement;\n+  tree save_objc_foreach_break_label, save_objc_foreach_continue_label;\n   /* The following are only used when parsing an ObjC foreach statement.  */\n   tree object_expression;\n   /* Silence the bogus uninitialized warning.  */\n   tree collection_expression = NULL;\n   location_t loc = c_parser_peek_token (parser)->location;\n   location_t for_loc = loc;\n-  location_t cond_loc = UNKNOWN_LOCATION;\n-  location_t incr_loc = UNKNOWN_LOCATION;\n   bool is_foreach_statement = false;\n   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));\n   token_indent_info for_tinfo\n@@ -6966,7 +6954,6 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n       gcc_assert (!parser->objc_could_be_foreach_context);\n       if (!is_foreach_statement)\n \t{\n-\t  cond_loc = c_parser_peek_token (parser)->location;\n \t  if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n \t    {\n \t      if (ivdep)\n@@ -7007,7 +6994,7 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n       /* Parse the increment expression (the third expression in a\n \t for-statement).  In the case of a foreach-statement, this is\n \t the expression that follows the 'in'.  */\n-      loc = incr_loc = c_parser_peek_token (parser)->location;\n+      loc = c_parser_peek_token (parser)->location;\n       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))\n \t{\n \t  if (is_foreach_statement)\n@@ -7033,10 +7020,17 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \t}\n       parens.skip_until_found_close (parser);\n     }\n-  save_break = c_break_label;\n-  c_break_label = NULL_TREE;\n-  save_cont = c_cont_label;\n-  c_cont_label = NULL_TREE;\n+  save_in_statement = in_statement;\n+  if (is_foreach_statement)\n+    {\n+      in_statement = IN_OBJC_FOREACH;\n+      save_objc_foreach_break_label = objc_foreach_break_label;\n+      save_objc_foreach_continue_label = objc_foreach_continue_label;\n+      objc_foreach_break_label = create_artificial_label (loc);\n+      objc_foreach_continue_label = create_artificial_label (loc);\n+    }\n+  else\n+    in_statement = IN_ITERATION_STMT;\n \n   token_indent_info body_tinfo\n     = get_token_indent_info (c_parser_peek_token (parser));\n@@ -7047,11 +7041,12 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n \n   if (is_foreach_statement)\n     objc_finish_foreach_loop (for_loc, object_expression,\n-\t\t\t      collection_expression, body, c_break_label,\n-\t\t\t      c_cont_label);\n+\t\t\t      collection_expression, body,\n+\t\t\t      objc_foreach_break_label,\n+\t\t\t      objc_foreach_continue_label);\n   else\n-    c_finish_loop (for_loc, cond_loc, cond, incr_loc, incr, body,\n-\t\t   c_break_label, c_cont_label, true);\n+    add_stmt (build_stmt (for_loc, FOR_STMT, NULL_TREE, cond, incr,\n+\t\t\t  body, NULL_TREE));\n   add_stmt (c_end_compound_stmt (for_loc, block,\n \t\t\t\t flag_isoc99 || c_dialect_objc ()));\n   c_parser_maybe_reclassify_token (parser);\n@@ -7064,8 +7059,12 @@ c_parser_for_statement (c_parser *parser, bool ivdep, unsigned short unroll,\n     warn_for_multistatement_macros (loc_after_labels, next_tinfo.location,\n \t\t\t\t    for_tinfo.location, RID_FOR);\n \n-  c_break_label = save_break;\n-  c_cont_label = save_cont;\n+  in_statement = save_in_statement;\n+  if (is_foreach_statement)\n+    {\n+      objc_foreach_break_label = save_objc_foreach_break_label;\n+      objc_foreach_continue_label = save_objc_foreach_continue_label;\n+    }\n }\n \n /* Parse an asm statement, a GNU extension.  This is a full-blown asm\n@@ -18038,7 +18037,8 @@ static tree\n c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n \t\t       tree clauses, tree *cclauses, bool *if_p)\n {\n-  tree decl, cond, incr, save_break, save_cont, body, init, stmt, cl;\n+  tree decl, cond, incr, body, init, stmt, cl;\n+  unsigned char save_in_statement;\n   tree declv, condv, incrv, initv, ret = NULL_TREE;\n   tree pre_body = NULL_TREE, this_pre_body;\n   tree ordered_cl = NULL_TREE;\n@@ -18106,6 +18106,11 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   for_loc = c_parser_peek_token (parser)->location;\n   c_parser_consume_token (parser);\n \n+  /* Forbid break/continue in the loop initializer, condition, and\n+     increment expressions.  */\n+  save_in_statement = in_statement;\n+  in_statement = IN_OMP_BLOCK;\n+\n   for (i = 0; i < count; i++)\n     {\n       int bracecount = 0;\n@@ -18279,10 +18284,7 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n   if (nbraces)\n     if_p = NULL;\n \n-  save_break = c_break_label;\n-  c_break_label = size_one_node;\n-  save_cont = c_cont_label;\n-  c_cont_label = NULL_TREE;\n+  in_statement = IN_OMP_FOR;\n   body = push_stmt_list ();\n \n   if (inscan)\n@@ -18296,16 +18298,9 @@ c_parser_omp_for_loop (location_t loc, c_parser *parser, enum tree_code code,\n     }\n   else\n     add_stmt (c_parser_c99_block_statement (parser, if_p));\n-  if (c_cont_label)\n-    {\n-      tree t = build1 (LABEL_EXPR, void_type_node, c_cont_label);\n-      SET_EXPR_LOCATION (t, loc);\n-      add_stmt (t);\n-    }\n \n   body = pop_stmt_list (body);\n-  c_break_label = save_break;\n-  c_cont_label = save_cont;\n+  in_statement = save_in_statement;\n \n   while (nbraces)\n     {"}, {"sha": "7e51859b7e09ec6a2a8a96be713126981a0d1414", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -547,8 +547,19 @@ extern void gen_aux_info_record (tree, int, int, int);\n struct c_spot_bindings;\n class c_struct_parse_info;\n extern struct obstack parser_obstack;\n-extern tree c_break_label;\n-extern tree c_cont_label;\n+/* Set to IN_ITERATION_STMT if parsing an iteration-statement,\n+   to IN_OMP_BLOCK if parsing OpenMP structured block and\n+   IN_OMP_FOR if parsing OpenMP loop.  If parsing a switch statement,\n+   this is bitwise ORed with IN_SWITCH_STMT, unless parsing an\n+   iteration-statement, OpenMP block or loop within that switch.  */\n+#define IN_SWITCH_STMT\t\t1\n+#define IN_ITERATION_STMT\t2\n+#define IN_OMP_BLOCK\t\t4\n+#define IN_OMP_FOR\t\t8\n+#define IN_OBJC_FOREACH\t\t16\n+extern unsigned char in_statement;\n+\n+extern bool switch_statement_break_seen_p;\n \n extern bool global_bindings_p (void);\n extern tree pushdecl (tree);\n@@ -714,8 +725,8 @@ extern void process_init_element (location_t, struct c_expr, bool,\n extern tree build_compound_literal (location_t, tree, tree, bool,\n \t\t\t\t    unsigned int);\n extern void check_compound_literal_type (location_t, struct c_type_name *);\n-extern tree c_start_case (location_t, location_t, tree, bool);\n-extern void c_finish_case (tree, tree);\n+extern tree c_start_switch (location_t, location_t, tree, bool);\n+extern void c_finish_switch (tree, tree);\n extern tree build_asm_expr (location_t, tree, tree, tree, tree, tree, bool,\n \t\t\t    bool);\n extern tree build_asm_stmt (bool, tree);\n@@ -730,7 +741,7 @@ extern tree c_finish_stmt_expr (location_t, tree);\n extern tree c_process_expr_stmt (location_t, tree);\n extern tree c_finish_expr_stmt (location_t, tree);\n extern tree c_finish_return (location_t, tree, tree);\n-extern tree c_finish_bc_stmt (location_t, tree *, bool);\n+extern tree c_finish_bc_stmt (location_t, tree, bool);\n extern tree c_finish_goto_label (location_t, tree);\n extern tree c_finish_goto_ptr (location_t, tree);\n extern tree c_expr_to_decl (tree, bool *, bool *);"}, {"sha": "dd3e30958aca1607151543d4456e3e71f4dc837f", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 70, "deletions": 157, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -3076,7 +3076,7 @@ build_function_call_vec (location_t loc, vec<location_t> arg_loc,\n   if (!(TREE_CODE (fntype) == POINTER_TYPE\n \t&& TREE_CODE (TREE_TYPE (fntype)) == FUNCTION_TYPE))\n     {\n-      if (!flag_diagnostics_show_caret)\n+      if (!flag_diagnostics_show_caret && !STATEMENT_CLASS_P (function))\n \terror_at (loc,\n \t\t  \"called object %qE is not a function or function pointer\",\n \t\t  function);\n@@ -10808,8 +10808,8 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n }\n \f\n struct c_switch {\n-  /* The SWITCH_EXPR being built.  */\n-  tree switch_expr;\n+  /* The SWITCH_STMT being built.  */\n+  tree switch_stmt;\n \n   /* The original type of the testing expression, i.e. before the\n      default conversion is applied.  */\n@@ -10826,6 +10826,9 @@ struct c_switch {\n      warnings crossing decls when branching to a case label.  */\n   struct c_spot_bindings *bindings;\n \n+  /* Whether the switch includes any break statements.  */\n+  bool break_stmt_seen_p;\n+\n   /* The next node on the stack.  */\n   struct c_switch *next;\n \n@@ -10843,14 +10846,14 @@ struct c_switch {\n struct c_switch *c_switch_stack;\n \n /* Start a C switch statement, testing expression EXP.  Return the new\n-   SWITCH_EXPR.  SWITCH_LOC is the location of the `switch'.\n+   SWITCH_STMT.  SWITCH_LOC is the location of the `switch'.\n    SWITCH_COND_LOC is the location of the switch's condition.\n    EXPLICIT_CAST_P is true if the expression EXP has an explicit cast.  */\n \n tree\n-c_start_case (location_t switch_loc,\n-\t      location_t switch_cond_loc,\n-\t      tree exp, bool explicit_cast_p)\n+c_start_switch (location_t switch_loc,\n+\t\tlocation_t switch_cond_loc,\n+\t\ttree exp, bool explicit_cast_p)\n {\n   tree orig_type = error_mark_node;\n   bool bool_cond_p = false;\n@@ -10900,18 +10903,19 @@ c_start_case (location_t switch_loc,\n \t}\n     }\n \n-  /* Add this new SWITCH_EXPR to the stack.  */\n+  /* Add this new SWITCH_STMT to the stack.  */\n   cs = XNEW (struct c_switch);\n-  cs->switch_expr = build2 (SWITCH_EXPR, orig_type, exp, NULL_TREE);\n-  SET_EXPR_LOCATION (cs->switch_expr, switch_loc);\n+  cs->switch_stmt = build_stmt (switch_loc, SWITCH_STMT, exp,\n+\t\t\t\tNULL_TREE, orig_type, NULL_TREE);\n   cs->orig_type = orig_type;\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n   cs->bindings = c_get_switch_bindings ();\n+  cs->break_stmt_seen_p = false;\n   cs->bool_cond_p = bool_cond_p;\n   cs->next = c_switch_stack;\n   c_switch_stack = cs;\n \n-  return add_stmt (cs->switch_expr);\n+  return add_stmt (cs->switch_stmt);\n }\n \n /* Process a case label at location LOC.  */\n@@ -10947,12 +10951,12 @@ do_case (location_t loc, tree low_value, tree high_value)\n     }\n \n   if (c_check_switch_jump_warnings (c_switch_stack->bindings,\n-\t\t\t\t    EXPR_LOCATION (c_switch_stack->switch_expr),\n+\t\t\t\t    EXPR_LOCATION (c_switch_stack->switch_stmt),\n \t\t\t\t    loc))\n     return NULL_TREE;\n \n   label = c_add_case_label (loc, c_switch_stack->cases,\n-\t\t\t    SWITCH_COND (c_switch_stack->switch_expr),\n+\t\t\t    SWITCH_STMT_COND (c_switch_stack->switch_stmt),\n \t\t\t    low_value, high_value);\n   if (label == error_mark_node)\n     label = NULL_TREE;\n@@ -10963,20 +10967,22 @@ do_case (location_t loc, tree low_value, tree high_value)\n    controlling expression of the switch, or NULL_TREE.  */\n \n void\n-c_finish_case (tree body, tree type)\n+c_finish_switch (tree body, tree type)\n {\n   struct c_switch *cs = c_switch_stack;\n   location_t switch_location;\n \n-  SWITCH_BODY (cs->switch_expr) = body;\n+  SWITCH_STMT_BODY (cs->switch_stmt) = body;\n \n   /* Emit warnings as needed.  */\n-  switch_location = EXPR_LOCATION (cs->switch_expr);\n+  switch_location = EXPR_LOCATION (cs->switch_stmt);\n   c_do_switch_warnings (cs->cases, switch_location,\n-\t\t\ttype ? type : TREE_TYPE (cs->switch_expr),\n-\t\t\tSWITCH_COND (cs->switch_expr), cs->bool_cond_p);\n-  if (c_switch_covers_all_cases_p (cs->cases, TREE_TYPE (cs->switch_expr)))\n-    SWITCH_ALL_CASES_P (cs->switch_expr) = 1;\n+\t\t\ttype ? type : SWITCH_STMT_TYPE (cs->switch_stmt),\n+\t\t\tSWITCH_STMT_COND (cs->switch_stmt), cs->bool_cond_p);\n+  if (c_switch_covers_all_cases_p (cs->cases,\n+\t\t\t\t   SWITCH_STMT_TYPE (cs->switch_stmt)))\n+    SWITCH_STMT_ALL_CASES_P (cs->switch_stmt) = 1;\n+  SWITCH_STMT_NO_BREAK_P (cs->switch_stmt) = !cs->break_stmt_seen_p;\n \n   /* Pop the stack.  */\n   c_switch_stack = cs->next;\n@@ -11000,158 +11006,65 @@ c_finish_if_stmt (location_t if_locus, tree cond, tree then_block,\n   add_stmt (stmt);\n }\n \n-/* Emit a general-purpose loop construct.  START_LOCUS is the location of\n-   the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST\n-   is false for DO loops.  INCR is the FOR increment expression.  BODY is\n-   the statement controlled by the loop.  BLAB is the break label.  CLAB is\n-   the continue label.  Everything is allowed to be NULL.\n-   COND_LOCUS is the location of the loop condition, INCR_LOCUS is the\n-   location of the FOR increment expression.  */\n-\n-void\n-c_finish_loop (location_t start_locus, location_t cond_locus, tree cond,\n-\t       location_t incr_locus, tree incr, tree body, tree blab,\n-\t       tree clab, bool cond_is_first)\n-{\n-  tree entry = NULL, exit = NULL, t;\n-\n-  /* If the condition is zero don't generate a loop construct.  */\n-  if (cond && integer_zerop (cond))\n-    {\n-      if (cond_is_first)\n-\t{\n-\t  t = build_and_jump (&blab);\n-\t  SET_EXPR_LOCATION (t, start_locus);\n-\t  add_stmt (t);\n-\t}\n-    }\n-  else\n-    {\n-      tree top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\n-      /* If we have an exit condition, then we build an IF with gotos either\n-\t out of the loop, or to the top of it.  If there's no exit condition,\n-\t then we just build a jump back to the top.  */\n-      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n-\n-      if (cond && !integer_nonzerop (cond))\n-\t{\n-\t  /* Canonicalize the loop condition to the end.  This means\n-\t     generating a branch to the loop condition.  Reuse the\n-\t     continue label, if possible.  */\n-\t  if (cond_is_first)\n-\t    {\n-\t      if (incr || !clab)\n-\t\t{\n-\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n-\t\t}\n-\t      else\n-\t\tt = build1 (GOTO_EXPR, void_type_node, clab);\n-\t      SET_EXPR_LOCATION (t, start_locus);\n-\t      add_stmt (t);\n-\t    }\n-\n-\t  t = build_and_jump (&blab);\n-\t  exit = fold_build3_loc (cond_is_first ? start_locus : input_location,\n-\t\t\t\t  COND_EXPR, void_type_node, cond, exit, t);\n-\t}\n-      else\n-\t{\n-\t  /* For the backward-goto's location of an unconditional loop\n-\t     use the beginning of the body, or, if there is none, the\n-\t     top of the loop.  */\n-\t  location_t loc = EXPR_LOCATION (expr_first (body));\n-\t  if (loc == UNKNOWN_LOCATION)\n-\t    loc = start_locus;\n-\t  SET_EXPR_LOCATION (exit, loc);\n-\t}\n-\n-      add_stmt (top);\n-    }\n-\n-  if (body)\n-    add_stmt (body);\n-  if (clab)\n-    add_stmt (build1 (LABEL_EXPR, void_type_node, clab));\n-  if (incr)\n-    {\n-      if (MAY_HAVE_DEBUG_MARKER_STMTS && incr_locus != UNKNOWN_LOCATION)\n-\t{\n-\t  t = build0 (DEBUG_BEGIN_STMT, void_type_node);\n-\t  SET_EXPR_LOCATION (t, incr_locus);\n-\t  add_stmt (t);\n-\t}\n-      add_stmt (incr);\n-    }\n-  if (entry)\n-    add_stmt (entry);\n-  if (MAY_HAVE_DEBUG_MARKER_STMTS && cond_locus != UNKNOWN_LOCATION)\n-    {\n-      t = build0 (DEBUG_BEGIN_STMT, void_type_node);\n-      SET_EXPR_LOCATION (t, cond_locus);\n-      add_stmt (t);\n-    }\n-  if (exit)\n-    add_stmt (exit);\n-  if (blab)\n-    add_stmt (build1 (LABEL_EXPR, void_type_node, blab));\n-}\n-\n tree\n-c_finish_bc_stmt (location_t loc, tree *label_p, bool is_break)\n+c_finish_bc_stmt (location_t loc, tree label, bool is_break)\n {\n-  bool skip;\n-  tree label = *label_p;\n-\n   /* In switch statements break is sometimes stylistically used after\n      a return statement.  This can lead to spurious warnings about\n      control reaching the end of a non-void function when it is\n      inlined.  Note that we are calling block_may_fallthru with\n      language specific tree nodes; this works because\n      block_may_fallthru returns true when given something it does not\n      understand.  */\n-  skip = !block_may_fallthru (cur_stmt_list);\n+  bool skip = !block_may_fallthru (cur_stmt_list);\n \n-  if (!label)\n-    {\n-      if (!skip)\n-\t*label_p = label = create_artificial_label (loc);\n-    }\n-  else if (TREE_CODE (label) == LABEL_DECL)\n-    ;\n-  else switch (TREE_INT_CST_LOW (label))\n-    {\n-    case 0:\n-      if (is_break)\n+  if (is_break)\n+    switch (in_statement)\n+      {\n+      case 0:\n \terror_at (loc, \"break statement not within loop or switch\");\n-      else\n+\treturn NULL_TREE;\n+      case IN_OMP_BLOCK:\n+\terror_at (loc, \"invalid exit from OpenMP structured block\");\n+\treturn NULL_TREE;\n+      case IN_OMP_FOR:\n+\terror_at (loc, \"break statement used with OpenMP for loop\");\n+\treturn NULL_TREE;\n+      case IN_ITERATION_STMT:\n+      case IN_OBJC_FOREACH:\n+\tbreak;\n+      default:\n+\tgcc_assert (in_statement & IN_SWITCH_STMT);\n+\tc_switch_stack->break_stmt_seen_p = true;\n+\tbreak;\n+      }\n+  else\n+    switch (in_statement & ~IN_SWITCH_STMT)\n+      {\n+      case 0:\n \terror_at (loc, \"continue statement not within a loop\");\n-      return NULL_TREE;\n-\n-    case 1:\n-      gcc_assert (is_break);\n-      error_at (loc, \"break statement used with OpenMP for loop\");\n-      return NULL_TREE;\n-\n-    case 2:\n-      if (is_break) \n-\terror (\"break statement within %<#pragma simd%> loop body\");\n-      else \n-\terror (\"continue statement within %<#pragma simd%> loop body\");\n-      return NULL_TREE;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+\treturn NULL_TREE;\n+      case IN_OMP_BLOCK:\n+\terror_at (loc, \"invalid exit from OpenMP structured block\");\n+\treturn NULL_TREE;\n+      case IN_ITERATION_STMT:\n+      case IN_OMP_FOR:\n+      case IN_OBJC_FOREACH:\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n \n   if (skip)\n     return NULL_TREE;\n-\n-  if (!is_break)\n-    add_stmt (build_predict_expr (PRED_CONTINUE, NOT_TAKEN));\n-\n-  return add_stmt (build1 (GOTO_EXPR, void_type_node, label));\n+  else if (in_statement & IN_OBJC_FOREACH)\n+    {\n+      /* The foreach expander produces low-level code using gotos instead\n+\t of a structured loop construct.  */\n+      gcc_assert (label);\n+      return add_stmt (build_stmt (loc, GOTO_EXPR, label));\n+    }\n+  return add_stmt (build_stmt (loc, (is_break ? BREAK_STMT : CONTINUE_STMT)));\n }\n \n /* A helper routine for c_process_expr_stmt and c_finish_stmt_expr.  */"}, {"sha": "31a2cf3753fb34a72d35cdbf5dd7f753e8f91659", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -2050,10 +2050,8 @@ objc_start_method_definition (bool is_class_method, tree decl, tree attributes,\n     return false;\n \n #ifndef OBJCPLUS\n-  /* Indicate no valid break/continue context by setting these variables\n-     to some non-null, non-label value.  We'll notice and emit the proper\n-     error message in c_finish_bc_stmt.  */\n-  c_break_label = c_cont_label = size_zero_node;\n+  /* Indicate no valid break/continue context.  */\n+  in_statement = 0;\n #endif\n \n   if (attributes)"}, {"sha": "3e8746406be028cb35a9cbe418f9fd9b21915719", "filename": "gcc/testsuite/gcc.dg/gomp/block-7.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3696a50beeb73f4ded8a584e76ee16f0bde109b9/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fblock-7.c?ref=3696a50beeb73f4ded8a584e76ee16f0bde109b9", "patch": "@@ -6,15 +6,15 @@ void foo()\n   for (i = 0; i < 10; ++i)\n     {\n       #pragma omp for\n-      for (j = ({ continue; 0; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n-\t   j < ({ continue; 10; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n-\t   j += ({ continue; 1; })) // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+      for (j = ({ continue; 0; }); // { dg-error \"invalid exit from OpenMP structured block\" }\n+\t   j < ({ continue; 10; }); // { dg-error \"invalid exit from OpenMP structured block\" }\n+\t   j += ({ continue; 1; })) // { dg-error \"invalid exit from OpenMP structured block\" }\n \tcontinue;\n \n       #pragma omp for\n-      for (j = ({ break; 0; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n-\t   j < ({ break; 10; }); // { dg-error \"invalid branch to/from OpenMP structured block\" }\n-\t   j += ({ break; 1; })) // { dg-error \"invalid branch to/from OpenMP structured block\" }\n+      for (j = ({ break; 0; }); // { dg-error \"invalid exit from OpenMP structured block\" }\n+\t   j < ({ break; 10; }); // { dg-error \"invalid exit from OpenMP structured block\" }\n+\t   j += ({ break; 1; })) // { dg-error \"invalid exit from OpenMP structured block\" }\n \tbreak;\t\t\t\t// { dg-error \"break\" }\n     }\n }"}]}