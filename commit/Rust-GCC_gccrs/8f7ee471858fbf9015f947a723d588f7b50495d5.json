{"sha": "8f7ee471858fbf9015f947a723d588f7b50495d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY3ZWU0NzE4NThmYmY5MDE1Zjk0N2E3MjNkNTg4ZjdiNTA0OTVkNQ==", "commit": {"author": {"name": "Dale Johannesen", "email": "dalej@apple.com", "date": "2003-02-28T18:45:38Z"}, "committer": {"name": "Dale Johannesen", "email": "dalej@gcc.gnu.org", "date": "2003-02-28T18:45:38Z"}, "message": "loop.c (struct movable): Add insert_temp, shrink savemode.\n\n2003-02-28  Dale Johannesen <dalej@apple.com>\n\n      * loop.c (struct movable): Add insert_temp, shrink savemode.\n      (scan_loop): Accept invariants that require copying; mark as\n      insert_temp.\n      (combine_movables): Don't combine insert_temp movables.\n      (move_movables): Insert copies for insert_temp movables.\n      Don't record the info based on regno for insert_temp's.\n\nFrom-SVN: r63572", "tree": {"sha": "00ca5755959c029f72b8941802c34459365e3a4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00ca5755959c029f72b8941802c34459365e3a4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f7ee471858fbf9015f947a723d588f7b50495d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7ee471858fbf9015f947a723d588f7b50495d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f7ee471858fbf9015f947a723d588f7b50495d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f7ee471858fbf9015f947a723d588f7b50495d5/comments", "author": null, "committer": null, "parents": [{"sha": "67c2b45f5055fc03f65ce58101ed4894d5cd4b7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67c2b45f5055fc03f65ce58101ed4894d5cd4b7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67c2b45f5055fc03f65ce58101ed4894d5cd4b7f"}], "stats": {"total": 169, "additions": 119, "deletions": 50}, "files": [{"sha": "806351fd44f9c97871d0d93168ed92939bd8229f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f7ee471858fbf9015f947a723d588f7b50495d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f7ee471858fbf9015f947a723d588f7b50495d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f7ee471858fbf9015f947a723d588f7b50495d5", "patch": "@@ -1,3 +1,12 @@\n+2003-02-28  Dale Johannesen <dalej@apple.com>\n+\n+        * loop.c (struct movable): Add insert_temp, shrink savemode.\n+\t(scan_loop): Accept invariants that require copying; mark as\n+        insert_temp.\n+\t(combine_movables): Don't combine insert_temp movables.\n+\t(move_movables): Insert copies for insert_temp movables.\n+\tDon't record the info based on regno for insert_temp's.\n+\n 2003-02-28  Joel Sherrill <joel@OARcorp.com>\n \n \tPR 9638/other"}, {"sha": "222d492b63f9a3fb6c5f53e5001f6666d001c13e", "filename": "gcc/loop.c", "status": "modified", "additions": 110, "deletions": 50, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f7ee471858fbf9015f947a723d588f7b50495d5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f7ee471858fbf9015f947a723d588f7b50495d5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=8f7ee471858fbf9015f947a723d588f7b50495d5", "patch": "@@ -204,6 +204,9 @@ struct movable\n   short savings;\t\t/* Number of insns we can move for this reg,\n \t\t\t\t   including other movables that force this\n \t\t\t\t   or match this one.  */\n+  ENUM_BITFIELD(machine_mode) savemode : 8;   /* Nonzero means it is a mode for \n+\t\t\t\t   a low part that we should avoid changing when\n+\t\t\t\t   clearing the rest of the reg.  */\n   unsigned int cond : 1;\t/* 1 if only conditionally movable */\n   unsigned int force : 1;\t/* 1 means MUST move this insn */\n   unsigned int global : 1;\t/* 1 means reg is live outside this loop */\n@@ -220,9 +223,9 @@ struct movable\n   unsigned int move_insn_first:1;/* Same as above, if this is necessary for the\n \t\t\t\t    first insn of a consecutive sets group.  */\n   unsigned int is_equiv : 1;\t/* 1 means a REG_EQUIV is present on INSN.  */\n-  enum machine_mode savemode;   /* Nonzero means it is a mode for a low part\n-\t\t\t\t   that we should avoid changing when clearing\n-\t\t\t\t   the rest of the reg.  */\n+  unsigned int insert_temp : 1;  /* 1 means we copy to a new pseudo and replace\n+\t\t\t\t    the original insn with a copy from that\n+\t\t\t\t    pseudo, rather than deleting it. */\n   struct movable *match;\t/* First entry for same value */\n   struct movable *forces;\t/* An insn that must be moved if this is */\n   struct movable *next;\n@@ -765,6 +768,7 @@ scan_loop (loop, flags)\n \t      int tem1 = 0;\n \t      int tem2 = 0;\n \t      int move_insn = 0;\n+\t      int insert_temp = 0;\n \t      rtx src = SET_SRC (set);\n \t      rtx dependencies = 0;\n \n@@ -808,34 +812,45 @@ scan_loop (loop, flags)\n \t\t    }\n \t\t}\n \n+\t      if (/* The register is used in basic blocks other\n+\t\t      than the one where it is set (meaning that\n+\t\t      something after this point in the loop might\n+\t\t      depend on its value before the set).  */\n+\t\t   ! reg_in_basic_block_p (p, SET_DEST (set))\n+\t\t   /* And the set is not guaranteed to be executed once\n+\t\t      the loop starts, or the value before the set is\n+\t\t      needed before the set occurs...\n+\n+\t\t      ??? Note we have quadratic behavior here, mitigated\n+\t\t      by the fact that the previous test will often fail for\n+\t\t      large loops.  Rather than re-scanning the entire loop\n+\t\t      each time for register usage, we should build tables\n+\t\t      of the register usage and use them here instead.  */\n+\t\t   && (maybe_never\n+\t\t       || loop_reg_used_before_p (loop, set, p)))\n+\t\t/* It is unsafe to move the set.  However, it may be OK to\n+\t\t   move the source into a new psuedo, and subsitute a \n+\t\t   reg-to-reg copy for the original insn.\n+\n+\t\t   This code used to consider it OK to move a set of a variable\n+\t\t   which was not created by the user and not used in an exit\n+\t\t   test.\n+\t\t   That behavior is incorrect and was removed.  */\n+\t\tinsert_temp = 1;\n+\n \t      /* Don't try to optimize a register that was made\n \t\t by loop-optimization for an inner loop.\n \t\t We don't know its life-span, so we can't compute\n \t\t the benefit.  */\n \t      if (REGNO (SET_DEST (set)) >= max_reg_before_loop)\n \t\t;\n-\t      else if (/* The register is used in basic blocks other\n-\t\t\t  than the one where it is set (meaning that\n-\t\t\t  something after this point in the loop might\n-\t\t\t  depend on its value before the set).  */\n-\t\t       ! reg_in_basic_block_p (p, SET_DEST (set))\n-\t\t       /* And the set is not guaranteed to be executed once\n-\t\t\t  the loop starts, or the value before the set is\n-\t\t\t  needed before the set occurs...\n-\n-\t\t\t  ??? Note we have quadratic behavior here, mitigated\n-\t\t\t  by the fact that the previous test will often fail for\n-\t\t\t  large loops.  Rather than re-scanning the entire loop\n-\t\t\t  each time for register usage, we should build tables\n-\t\t\t  of the register usage and use them here instead.  */\n-\t\t       && (maybe_never\n-\t\t\t   || loop_reg_used_before_p (loop, set, p)))\n-\t\t/* It is unsafe to move the set.\n-\n-\t\t   This code used to consider it OK to move a set of a variable\n-\t\t   which was not created by the user and not used in an exit\n-\t\t   test.\n-\t\t   That behavior is incorrect and was removed.  */\n+\t      /* Don't move the source and add a reg-to-reg copy with -Os\n+\t\t (this certainly increases size) or if the source is\n+\t\t already a reg (the motion will gain nothing). */\n+\t      else if (insert_temp \n+\t\t       && (optimize_size || GET_CODE (SET_SRC (set)) == REG\n+\t\t\t   || (CONSTANT_P (SET_SRC (set))\n+\t\t\t       && LEGITIMATE_CONSTANT_P (SET_SRC (set)))))\n \t\t;\n \t      else if ((tem = loop_invariant_p (loop, src))\n \t\t       && (dependencies == 0\n@@ -926,6 +941,7 @@ scan_loop (loop, flags)\n \t\t  m->partial = 0;\n \t\t  m->move_insn = move_insn;\n \t\t  m->move_insn_first = 0;\n+\t\t  m->insert_temp = insert_temp;\n \t\t  m->is_equiv = (find_reg_note (p, REG_EQUIV, NULL_RTX) != 0);\n \t\t  m->savemode = VOIDmode;\n \t\t  m->regno = regno;\n@@ -1010,6 +1026,7 @@ scan_loop (loop, flags)\n \t\t      m->forces = 0;\n \t\t      m->move_insn = 0;\n \t\t      m->move_insn_first = 0;\n+\t\t      m->insert_temp = insert_temp;\n \t\t      m->partial = 1;\n \t\t      /* If the insn may not be executed on some cycles,\n \t\t\t we can't clear the whole reg; clear just high part.\n@@ -1465,6 +1482,7 @@ combine_movables (movables, regs)\n   for (m = movables->head; m; m = m->next)\n     if (m->match == 0 && regs->array[m->regno].n_times_set == 1\n \t&& m->regno >= FIRST_PSEUDO_REGISTER\n+\t&& !m->insert_temp\n \t&& !m->partial)\n       {\n \tstruct movable *m1;\n@@ -1477,6 +1495,7 @@ combine_movables (movables, regs)\n \t   one match any later ones.  So start this loop at m->next.  */\n \tfor (m1 = m->next; m1; m1 = m1->next)\n \t  if (m != m1 && m1->match == 0\n+\t      && !m1->insert_temp\n \t      && regs->array[m1->regno].n_times_set == 1\n \t      && m1->regno >= FIRST_PSEUDO_REGISTER\n \t      /* A reg used outside the loop mustn't be eliminated.  */\n@@ -1880,6 +1899,10 @@ move_movables (loop, movables, threshold, insn_count)\n \t      int count;\n \t      struct movable *m1;\n \t      rtx first = NULL_RTX;\n+\t      rtx newreg = NULL_RTX;\n+\n+\t      if (m->insert_temp)\n+\t\tnewreg = gen_reg_rtx (GET_MODE (m->set_dest));\n \n \t      /* Now move the insns that set the reg.  */\n \n@@ -1950,10 +1973,22 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t insn stream.  */\n \t\t      while (p && GET_CODE (p) == NOTE)\n \t\t\tp = NEXT_INSN (temp) = NEXT_INSN (p);\n+\n+\t\t      if (m->insert_temp)\n+\t\t\t{\n+\t\t\t  /* Replace the original insn with a move from\n+\t\t\t     our newly created temp. */\n+\t\t\t  start_sequence ();\n+    \t\t\t  emit_move_insn (m->set_dest, newreg);\n+\t\t\t  seq = get_insns ();\n+\t\t\t  end_sequence ();\n+\t\t\t  emit_insn_before (seq, p);\n+\t\t\t}\n \t\t    }\n \n \t\t  start_sequence ();\n-\t\t  emit_move_insn (m->set_dest, m->set_src);\n+\t\t  emit_move_insn (m->insert_temp ? newreg : m->set_dest, \n+\t\t\t          m->set_src);\n \t\t  seq = get_insns ();\n \t\t  end_sequence ();\n \n@@ -2123,6 +2158,16 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t    set_unique_reg_note (i1, m->is_equiv ? REG_EQUIV\n \t\t\t\t\t\t     : REG_EQUAL, m->set_src);\n \t\t\t}\n+\t\t      else if (m->insert_temp)\n+\t\t\t{\n+\t\t\t  rtx *reg_map2 = (rtx *) xcalloc (REGNO (newreg), \n+\t\t\t\tsizeof(rtx));\n+\t\t\t  reg_map2 [m->regno] = newreg;\n+\n+\t\t\t  i1 = loop_insn_hoist (loop, copy_rtx (PATTERN (p)));\n+\t\t\t  replace_regs (i1, reg_map2, REGNO (newreg), 1);\n+\t\t\t  free (reg_map2);\n+\t    \t\t}\n \t\t      else\n \t\t\ti1 = loop_insn_hoist (loop, PATTERN (p));\n \n@@ -2171,40 +2216,55 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t insn stream.  */\n \t\t      while (p && GET_CODE (p) == NOTE)\n \t\t\tp = NEXT_INSN (temp) = NEXT_INSN (p);\n+\n+\t\t      if (m->insert_temp)\n+\t\t\t{\n+\t\t\t  rtx seq;\n+\t\t\t  /* Replace the original insn with a move from\n+\t\t\t     our newly created temp. */\n+\t\t\t  start_sequence ();\n+    \t\t\t  emit_move_insn (m->set_dest, newreg);\n+\t\t\t  seq = get_insns ();\n+\t\t\t  end_sequence ();\n+\t\t\t  emit_insn_before (seq, p);\n+\t\t\t}\n \t\t    }\n \n \t\t  /* The more regs we move, the less we like moving them.  */\n \t\t  threshold -= 3;\n \t\t}\n \n-\t      /* Any other movable that loads the same register\n-\t\t MUST be moved.  */\n-\t      already_moved[regno] = 1;\n-\n-\t      /* This reg has been moved out of one loop.  */\n-\t      regs->array[regno].moved_once = 1;\n+\t      m->done = 1;\n \n-\t      /* The reg set here is now invariant.  */\n-\t      if (! m->partial)\n+\t      if (!m->insert_temp)\n \t\t{\n-\t\t  int i;\n-\t\t  for (i = 0; i < LOOP_REGNO_NREGS (regno, m->set_dest); i++)\n-\t\t    regs->array[regno+i].set_in_loop = 0;\n-\t\t}\n+\t\t  /* Any other movable that loads the same register\n+\t\t     MUST be moved.  */\n+\t\t  already_moved[regno] = 1;\n \n-\t      m->done = 1;\n+\t\t  /* This reg has been moved out of one loop.  */\n+\t\t  regs->array[regno].moved_once = 1;\n \n-\t      /* Change the length-of-life info for the register\n-\t\t to say it lives at least the full length of this loop.\n-\t\t This will help guide optimizations in outer loops.  */\n-\n-\t      if (REGNO_FIRST_LUID (regno) > INSN_LUID (loop_start))\n-\t\t/* This is the old insn before all the moved insns.\n-\t\t   We can't use the moved insn because it is out of range\n-\t\t   in uid_luid.  Only the old insns have luids.  */\n-\t\tREGNO_FIRST_UID (regno) = INSN_UID (loop_start);\n-\t      if (REGNO_LAST_LUID (regno) < INSN_LUID (loop_end))\n-\t\tREGNO_LAST_UID (regno) = INSN_UID (loop_end);\n+\t\t  /* The reg set here is now invariant.  */\n+\t\t  if (! m->partial)\n+\t\t    {\n+\t\t      int i;\n+\t\t      for (i = 0; i < LOOP_REGNO_NREGS (regno, m->set_dest); i++)\n+\t\t\tregs->array[regno+i].set_in_loop = 0;\n+\t\t    }\n+\n+\t\t  /* Change the length-of-life info for the register\n+\t\t     to say it lives at least the full length of this loop.\n+\t\t     This will help guide optimizations in outer loops.  */\n+\n+\t\t  if (REGNO_FIRST_LUID (regno) > INSN_LUID (loop_start))\n+\t\t    /* This is the old insn before all the moved insns.\n+\t\t       We can't use the moved insn because it is out of range\n+\t\t       in uid_luid.  Only the old insns have luids.  */\n+\t\t    REGNO_FIRST_UID (regno) = INSN_UID (loop_start);\n+\t\t  if (REGNO_LAST_LUID (regno) < INSN_LUID (loop_end))\n+\t\t    REGNO_LAST_UID (regno) = INSN_UID (loop_end);\n+\t\t}\n \n \t      /* Combine with this moved insn any other matching movables.  */\n "}]}