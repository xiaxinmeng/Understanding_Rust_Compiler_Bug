{"sha": "820555e6f9621e27b4adf7ba30611b6db7840002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIwNTU1ZTZmOTYyMWUyN2I0YWRmN2JhMzA2MTFiNmRiNzg0MDAwMg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-11-19T04:06:50Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-11-19T04:06:50Z"}, "message": "cp-demangle.c (demangle_operator_name): Remove space before \"sizeof\".\n\n\t* cp-demangle.c (demangle_operator_name): Remove space before\n\t\"sizeof\".\n\t(demangle_type_ptr): Put qualifiers in the right place.  Handle\n\tqualifiers in pointer to member specially.\n\t(demangle_type): Handle qualifiers for pointer or reference\n\tspecially.  Handle function type.\n\t(demangle_local_name): Save and restore caret around demangling of\n\tinitial encoding.\n\nFrom-SVN: r73723", "tree": {"sha": "7d1d650924862251e28e31ebdda256ee5afc1746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7d1d650924862251e28e31ebdda256ee5afc1746"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/820555e6f9621e27b4adf7ba30611b6db7840002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820555e6f9621e27b4adf7ba30611b6db7840002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820555e6f9621e27b4adf7ba30611b6db7840002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820555e6f9621e27b4adf7ba30611b6db7840002/comments", "author": null, "committer": null, "parents": [{"sha": "e2534315a1da96a6e9cebc1e6a3c24940f6a8290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2534315a1da96a6e9cebc1e6a3c24940f6a8290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2534315a1da96a6e9cebc1e6a3c24940f6a8290"}], "stats": {"total": 154, "additions": 134, "deletions": 20}, "files": [{"sha": "fe871fff5dbf833af223bb1b2c19bc961b5b683c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820555e6f9621e27b4adf7ba30611b6db7840002/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820555e6f9621e27b4adf7ba30611b6db7840002/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=820555e6f9621e27b4adf7ba30611b6db7840002", "patch": "@@ -1,5 +1,14 @@\n 2003-11-18  Ian Lance Taylor  <ian@wasabisystems.com>\n \n+\t* cp-demangle.c (demangle_operator_name): Remove space before\n+\t\"sizeof\".\n+\t(demangle_type_ptr): Put qualifiers in the right place.  Handle\n+\tqualifiers in pointer to member specially.\n+\t(demangle_type): Handle qualifiers for pointer or reference\n+\tspecially.  Handle function type.\n+\t(demangle_local_name): Save and restore caret around demangling of\n+\tinitial encoding.\n+\n \t* testsuite/test-demangle.c (main): Don't pass DMGL_VERBOSE to\n \tcplus_demangle.\n "}, {"sha": "a707a833402c56d526d302771bd964c68e411b9f", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 125, "deletions": 20, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/820555e6f9621e27b4adf7ba30611b6db7840002/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/820555e6f9621e27b4adf7ba30611b6db7840002/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=820555e6f9621e27b4adf7ba30611b6db7840002", "patch": "@@ -1147,7 +1147,7 @@ demangle_name (dm, encode_return_type)\n \n /* Demangles and emits a <nested-name>. \n \n-    <nested-name>     ::= N [<CV-qualifiers>] <prefix> <unqulified-name> E  */\n+    <nested-name>     ::= N [<CV-qualifiers>] <prefix> <unqualified-name> E  */\n \n static status_t\n demangle_nested_name (dm, encode_return_type)\n@@ -1662,7 +1662,7 @@ demangle_operator_name (dm, short_name, num_args, type_arg)\n     { \"rS\", \">>=\"      , 2 },\n     { \"rm\", \"%\"        , 2 },\n     { \"rs\", \">>\"       , 2 },\n-    { \"sz\", \" sizeof\"  , 1 }\n+    { \"sz\", \"sizeof\"  , 1 }\n   };\n \n   const int num_operators = \n@@ -2236,6 +2236,9 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n     {\n       /* A pointer-to-member.  */\n       dyn_string_t class_type;\n+      char peek;\n+      int reset_caret = 0;\n+      int old_caret_position;\n       \n       /* Eat the 'M'.  */\n       advance_char (dm);\n@@ -2245,14 +2248,43 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       RETURN_IF_ERROR (demangle_type (dm));\n       class_type = (dyn_string_t) result_pop (dm);\n       \n-      if (peek_char (dm) == 'F')\n+      peek = peek_char (dm);\n+      old_caret_position = result_get_caret (dm);\n+      if (peek == 'r' || peek == 'V' || peek == 'K')\n+\t{\n+\t  dyn_string_t cv_qualifiers = dyn_string_new (24);\n+\t  status_t status;\n+\n+\t  if (cv_qualifiers == NULL)\n+\t    return STATUS_ALLOCATION_FAILED;\n+\n+\t  /* Decode all adjacent CV qualifiers.  */\n+\t  demangle_CV_qualifiers (dm, cv_qualifiers);\n+\n+\t  /* Emit them, and shift the caret left so that the\n+\t     underlying type will be emitted before the\n+\t     qualifiers.  */\n+\t  status = result_add_string (dm, cv_qualifiers);\n+\t  result_shift_caret (dm, -dyn_string_length (cv_qualifiers));\n+\n+\t  dyn_string_delete (cv_qualifiers);\n+\t  RETURN_IF_ERROR (status);\n+\t  /* Prepend a blank.  */\n+\t  RETURN_IF_ERROR (result_add_char (dm, ' '));\n+\t  result_shift_caret (dm, -1);\n+\n+\t  peek = peek_char (dm);\n+\t  reset_caret = 1;\n+\t}\n+\n+      if (peek == 'F')\n \t/* A pointer-to-member function.  We want output along the\n \t   lines of `void (C::*) (int, int)'.  Demangle the function\n \t   type, which would in this case give `void () (int, int)'\n \t   and set *insert_pos to the spot between the first\n \t   parentheses.  */\n \tstatus = demangle_type_ptr (dm, insert_pos, substitution_start);\n-      else if (peek_char (dm) == 'A')\n+      else if (peek == 'A')\n \t/* A pointer-to-member array variable.  We want output that\n \t   looks like `int (Klass::*) [10]'.  Demangle the array type\n \t   as `int () [10]', and set *insert_pos to the spot between\n@@ -2286,6 +2318,9 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       /* Clean up. */\n       dyn_string_delete (class_type);\n \n+      if (reset_caret)\n+\tresult_set_caret (dm, old_caret_position);\n+\n       RETURN_IF_ERROR (status);\n     }\n     break;\n@@ -2317,6 +2352,39 @@ demangle_type_ptr (dm, insert_pos, substitution_start)\n       RETURN_IF_ERROR (demangle_array_type (dm, insert_pos));\n       break;\n \n+    case 'r':\n+    case 'V':\n+    case 'K':\n+      /* Qualified base type.  Pick up the qualifiers.  */\n+      {\n+\tdyn_string_t cv_qualifiers = dyn_string_new (24);\n+\n+\tif (cv_qualifiers == NULL)\n+\t  return STATUS_ALLOCATION_FAILED;\n+\n+\t/* Pick up all adjacent CV qualifiers.  */\n+\tdemangle_CV_qualifiers (dm, cv_qualifiers);\n+\n+\t/* Demangle the underlying type.  */\n+\tstatus = demangle_type_ptr (dm, insert_pos, substitution_start);\n+\n+\t/* Insert the qualifiers where we're told to.  */\n+\tif (STATUS_NO_ERROR (status))\n+\t  {\n+\t    status = result_insert_char (dm, *insert_pos, ' ');\n+\t    ++(*insert_pos);\n+\t    if (STATUS_NO_ERROR (status))\n+\t      status = result_insert_string (dm, *insert_pos, cv_qualifiers);\n+\t  }\n+\n+\t/* The next character should go after the qualifiers.  */\n+\t*insert_pos += dyn_string_length (cv_qualifiers);\n+\n+\tdyn_string_delete (cv_qualifiers);\n+\tRETURN_IF_ERROR (status);\n+      }\n+      break;\n+\n     default:\n       /* No more pointer or reference tokens; this is therefore a\n \t pointer to data.  Finish up by demangling the underlying\n@@ -2404,28 +2472,58 @@ demangle_type (dm)\n \n \t  /* Decode all adjacent CV qualifiers.  */\n \t  demangle_CV_qualifiers (dm, cv_qualifiers);\n-\t  /* Emit them, and shift the caret left so that the\n-\t     underlying type will be emitted before the qualifiers.  */\n-\t  status = result_add_string (dm, cv_qualifiers);\n-\t  result_shift_caret (dm, -dyn_string_length (cv_qualifiers));\n-\t  /* Clean up.  */\n-\t  dyn_string_delete (cv_qualifiers);\n-\t  RETURN_IF_ERROR (status);\n-\t  /* Also prepend a blank, if needed.  */\n-\t  RETURN_IF_ERROR (result_add_char (dm, ' '));\n-\t  result_shift_caret (dm, -1);\n \n-\t  /* Demangle the underlying type.  It will be emitted before\n-\t     the CV qualifiers, since we moved the caret.  */\n-\t  RETURN_IF_ERROR (demangle_type (dm));\n+\t  /* If the underlying type is a pointer or reference type, we\n+\t     need to call demangle_type_ptr to find out where to put\n+\t     the qualifiers.  */\n+\t  peek = peek_char (dm);\n+\t  if (peek == 'P' || peek == 'R' || peek == 'M')\n+\t    {\n+\t      status = demangle_type_ptr (dm, &insert_pos,\n+\t\t\t\t\t  substitution_start (dm));\n+\t      if (STATUS_NO_ERROR (status))\n+\t\t{\n+\t\t  status = result_insert_char (dm, insert_pos, ' ');\n+\t\t  if (STATUS_NO_ERROR (status))\n+\t\t    status = result_insert_string (dm, insert_pos + 1,\n+\t\t\t\t\t\t   cv_qualifiers);\n+\t\t}\n+\t      dyn_string_delete (cv_qualifiers);\n+\t      RETURN_IF_ERROR (status);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Emit the qualifiers, and shift the caret left so that\n+\t\t the underlying type will be emitted first.  */\n+\t      status = result_add_string (dm, cv_qualifiers);\n+\t      result_shift_caret (dm, -dyn_string_length (cv_qualifiers));\n+\t      /* Clean up.  */\n+\t      dyn_string_delete (cv_qualifiers);\n+\t      RETURN_IF_ERROR (status);\n+\t      /* Also prepend a blank, if needed.  */\n+\t      RETURN_IF_ERROR (result_add_char (dm, ' '));\n+\t      result_shift_caret (dm, -1);\n \n-\t  /* Put the caret back where it was previously.  */\n-\t  result_set_caret (dm, old_caret_position);\n+\t      /* Demangle the underlying type.  It will be emitted before\n+\t\t the CV qualifiers, since we moved the caret.  */\n+\t      RETURN_IF_ERROR (demangle_type (dm));\n+\n+\t      /* Put the caret back where it was previously.  */\n+\t      result_set_caret (dm, old_caret_position);\n+\t    }\n \t}\n \tbreak;\n \n       case 'F':\n-\treturn \"Non-pointer or -reference function type.\";\n+\t/* The return type should go at the current position.  */\n+\tinsert_pos = result_caret_pos (dm);\n+\t/* Put in parentheses to indicate that this is a function.  */\n+\tRETURN_IF_ERROR (result_add (dm, \"()\"));\n+\t/* Demangle the function type.  The return type will be\n+\t   inserted before the '()', and the argument list will go\n+\t   after it.  */\n+\tRETURN_IF_ERROR (demangle_function_type (dm, &insert_pos));\n+\tbreak;\n \n       case 'A':\n \tRETURN_IF_ERROR (demangle_array_type (dm, NULL));\n@@ -3472,10 +3570,17 @@ static status_t\n demangle_local_name (dm)\n      demangling_t dm;\n {\n+  int old_caret_position = result_get_caret (dm);\n+\n   DEMANGLE_TRACE (\"local-name\", dm);\n \n   RETURN_IF_ERROR (demangle_char (dm, 'Z'));\n   RETURN_IF_ERROR (demangle_encoding (dm));\n+\n+  /* Restore the caret to avoid being confused by any qualifiers we\n+     may have found during the encoding.  */\n+  result_set_caret (dm, old_caret_position);\n+\n   RETURN_IF_ERROR (demangle_char (dm, 'E'));\n   RETURN_IF_ERROR (result_add (dm, \"::\"));\n "}]}