{"sha": "c0683a829001ee2630451cbdbb138fd89cfe0e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA2ODNhODI5MDAxZWUyNjMwNDUxY2JkYmIxMzhmZDg5Y2ZlMGU1Zg==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2008-10-27T16:24:19Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2008-10-27T16:24:19Z"}, "message": "re PR middle-end/37813 (assert with IRA_COVER_CLASSES with singleton)\n\n2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/37813\n\t* ira-conflicts.c (process_regs_for_copy): Remove class subset\n\tcheck.\n\n\t* ira-int.h (ira_hard_regno_cover_class): New.\n\n\t* ira-lives.c (mark_reg_live, mark_reg_dead,\n\tprocess_bb_node_lives): Use ira_hard_regno_cover_class.\n\n\t* ira.c (reg_class ira_hard_regno_cover_class): New global\n\tvariable.\n\t(setup_hard_regno_cover_class): New function.\n\t(ira_init): Call setup_hard_regno_cover_class.\n\n\t* ira-costs.c (cost_class_nums): Add comment.\n\t(find_allocno_class_costs): Initiate cost_class_nums.\n\t(setup_allocno_cover_class_and_costs): Check cost_class_nums.\n\nFrom-SVN: r141384", "tree": {"sha": "1730ad833e4ff685d5139cd97e10380194193470", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1730ad833e4ff685d5139cd97e10380194193470"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0683a829001ee2630451cbdbb138fd89cfe0e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0683a829001ee2630451cbdbb138fd89cfe0e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0683a829001ee2630451cbdbb138fd89cfe0e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0683a829001ee2630451cbdbb138fd89cfe0e5f/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "801f03e3d21a96f63249aa22c8716490e14b7c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f03e3d21a96f63249aa22c8716490e14b7c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801f03e3d21a96f63249aa22c8716490e14b7c26"}], "stats": {"total": 88, "additions": 76, "deletions": 12}, "files": [{"sha": "666594f8b30616cb98a3242be6db4408b7d66885", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -1,3 +1,23 @@\n+2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/37813\n+\t* ira-conflicts.c (process_regs_for_copy): Remove class subset\n+\tcheck.\n+\n+\t* ira-int.h (ira_hard_regno_cover_class): New.\n+\n+\t* ira-lives.c (mark_reg_live, mark_reg_dead,\n+\tprocess_bb_node_lives): Use ira_hard_regno_cover_class.\n+\n+\t* ira.c (reg_class ira_hard_regno_cover_class): New global\n+\tvariable.\n+\t(setup_hard_regno_cover_class): New function.\n+\t(ira_init): Call setup_hard_regno_cover_class.\n+\n+\t* ira-costs.c (cost_class_nums): Add comment.\n+\t(find_allocno_class_costs): Initiate cost_class_nums.\n+\t(setup_allocno_cover_class_and_costs): Check cost_class_nums.\n+\n 2008-10-27  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR middle-end/37884"}, {"sha": "9bdc3e7252d44bf13333da1ad4de64d89546a742", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -374,8 +374,6 @@ process_regs_for_copy (rtx reg1, rtx reg2, rtx insn, int freq)\n   rclass = REGNO_REG_CLASS (allocno_preferenced_hard_regno);\n   mode = ALLOCNO_MODE (a);\n   cover_class = ALLOCNO_COVER_CLASS (a);\n-  if (! ira_class_subset_p[rclass][cover_class])\n-    return false;\n   if (only_regs_p && insn != NULL_RTX\n       && reg_class_size[rclass] <= (unsigned) CLASS_MAX_NREGS (rclass, mode))\n     /* It is already taken into account in ira-costs.c.  */"}, {"sha": "82adf5dccb82c726d61a918267cf5c533b567595", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -86,7 +86,7 @@ static enum reg_class *cost_classes;\n static int cost_classes_num;\n \n /* Map: cost class -> order number (they start with 0) of the cost\n-   class.  */\n+   class.  The order number is negative for non-cost classes.  */\n static int cost_class_nums[N_REG_CLASSES];\n \n /* It is the current size of struct costs.  */\n@@ -1112,6 +1112,8 @@ find_allocno_class_costs (void)\n       /* We could use only cover classes.  Unfortunately it does not\n \t work well for some targets where some subclass of cover class\n \t is costly and wrong cover class is chosen.  */\n+      for (i = 0; i < N_REG_CLASSES; i++)\n+\tcost_class_nums[i] = -1;\n       for (cost_classes_num = 0;\n \t   cost_classes_num < ira_important_classes_num;\n \t   cost_classes_num++)\n@@ -1392,7 +1394,7 @@ process_bb_node_for_hard_reg_moves (ira_loop_tree_node_t loop_tree_node)\n static void\n setup_allocno_cover_class_and_costs (void)\n {\n-  int i, j, n, regno;\n+  int i, j, n, regno, num;\n   int *reg_costs;\n   enum reg_class cover_class, rclass;\n   enum machine_mode mode;\n@@ -1411,9 +1413,10 @@ setup_allocno_cover_class_and_costs (void)\n       if (cover_class == NO_REGS)\n \tcontinue;\n       ALLOCNO_AVAILABLE_REGS_NUM (a) = ira_available_class_regs[cover_class];\n+      num = cost_class_nums[allocno_pref[i]];\n+      ira_assert (num >= 0);\n       ALLOCNO_COVER_CLASS_COST (a)\n-\t= (COSTS_OF_ALLOCNO (allocno_costs, i)\n-\t   ->cost[cost_class_nums[allocno_pref[i]]]);\n+\t= COSTS_OF_ALLOCNO (allocno_costs, i)->cost[num];\n       if (optimize && ALLOCNO_COVER_CLASS (a) != allocno_pref[i])\n \t{\n \t  n = ira_class_hard_regs_num[cover_class];\n@@ -1423,8 +1426,16 @@ setup_allocno_cover_class_and_costs (void)\n \t    {\n \t      regno = ira_class_hard_regs[cover_class][j];\n \t      rclass = REGNO_REG_CLASS (regno);\n-\t      reg_costs[j] = (COSTS_OF_ALLOCNO (allocno_costs, i)\n-\t\t\t       ->cost[cost_class_nums[rclass]]);\n+\t      num = cost_class_nums[rclass];\n+\t      if (num < 0)\n+\t\t{\n+\t\t  /* The hard register class is not a cover class or a\n+\t\t     class not fully inside in a cover class -- use\n+\t\t     the allocno cover class.  */\n+\t\t  ira_assert (ira_hard_regno_cover_class[regno] == cover_class);\n+\t\t  num = cost_class_nums[cover_class];\n+\t\t}\n+\t      reg_costs[j] = COSTS_OF_ALLOCNO (allocno_costs, i)->cost[num];\n \t    }\n \t}\n     }"}, {"sha": "dafcfb7ec466c51760c454b1089acdda45f20e52", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -547,6 +547,11 @@ extern int ira_reg_cost, ira_mem_cost;\n extern int ira_load_cost, ira_store_cost, ira_shuffle_cost;\n extern int ira_move_loops_num, ira_additional_jumps_num;\n \n+/* Map: hard register number -> cover class it belongs to.  If the\n+   corresponding class is NO_REGS, the hard register is not available\n+   for allocation.  */\n+extern enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n+\n /* Map: register class x machine mode -> number of hard registers of\n    given class needed to store value of given mode.  If the number for\n    some hard-registers of the register class is different, the size"}, {"sha": "c908ab713383a80e6bf57675b2a334cc37cc068e", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -243,7 +243,7 @@ mark_reg_live (rtx reg)\n \t  if (! TEST_HARD_REG_BIT (hard_regs_live, regno)\n \t      && ! TEST_HARD_REG_BIT (eliminable_regset, regno))\n \t    {\n-\t      cover_class = ira_class_translate[REGNO_REG_CLASS (regno)];\n+\t      cover_class = ira_hard_regno_cover_class[regno];\n \t      if (cover_class != NO_REGS)\n \t\t{\n \t\t  curr_reg_pressure[cover_class]++;\n@@ -308,7 +308,7 @@ mark_reg_dead (rtx reg)\n \t{\n \t  if (TEST_HARD_REG_BIT (hard_regs_live, regno))\n \t    {\n-\t      cover_class = ira_class_translate[REGNO_REG_CLASS (regno)];\n+\t      cover_class = ira_hard_regno_cover_class[regno];\n \t      if (cover_class != NO_REGS)\n \t\t{\n \t\t  curr_reg_pressure[cover_class]--;\n@@ -794,10 +794,9 @@ process_bb_node_lives (ira_loop_tree_node_t loop_tree_node)\n \t  {\n \t    enum reg_class cover_class;\n \t    \n-\t    cover_class = REGNO_REG_CLASS (i);\n+\t    cover_class = ira_hard_regno_cover_class[i];\n \t    if (cover_class == NO_REGS)\n \t      continue;\n-\t    cover_class = ira_class_translate[cover_class];\n \t    curr_reg_pressure[cover_class]++;\n \t    if (curr_bb_node->reg_pressure[cover_class]\n \t\t< curr_reg_pressure[cover_class])"}, {"sha": "30ef8c898c757723da98aed925e6f0c670c873f5", "filename": "gcc/ira.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0683a829001ee2630451cbdbb138fd89cfe0e5f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=c0683a829001ee2630451cbdbb138fd89cfe0e5f", "patch": "@@ -976,6 +976,36 @@ find_reg_class_closure (void)\n \n \f\n \n+/* Map: hard register number -> cover class it belongs to.  If the\n+   corresponding class is NO_REGS, the hard register is not available\n+   for allocation.  */\n+enum reg_class ira_hard_regno_cover_class[FIRST_PSEUDO_REGISTER];\n+\n+/* Set up the array above.  */\n+static void\n+setup_hard_regno_cover_class (void)\n+{\n+  int i, j;\n+  enum reg_class cl;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      ira_hard_regno_cover_class[i] = NO_REGS;\n+      for (j = 0; j < ira_reg_class_cover_size; j++)\n+\t{\n+\t  cl = ira_reg_class_cover[j];\n+\t  if (ira_class_hard_reg_index[cl][i] >= 0)\n+\t    {\n+\t      ira_hard_regno_cover_class[i] = cl;\n+\t      break;\n+\t    }\n+\t}\n+\t    \n+    }\n+}\n+\n+\f\n+\n /* Map: register class x machine mode -> number of hard registers of\n    given class needed to store value of given mode.  If the number is\n    different, the size will be negative.  */\n@@ -1118,6 +1148,7 @@ ira_init (void)\n   setup_alloc_regs (flag_omit_frame_pointer != 0);\n   setup_class_subset_and_memory_move_costs ();\n   find_reg_class_closure ();\n+  setup_hard_regno_cover_class ();\n   setup_reg_class_nregs ();\n   setup_prohibited_class_mode_regs ();\n   ira_init_costs ();"}]}