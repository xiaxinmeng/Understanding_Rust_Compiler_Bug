{"sha": "8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU1NGYxMzkyYzRlN2QzMTBlMGU5YjQxODBiYTgwNzJlZDk1ZjA3Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-09-03T06:35:59Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-09-03T06:35:59Z"}, "message": "[multiple changes]\n\n2012-09-03  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n            Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/37336\n        * gfortran.h (symbol_attribute): Add artificial.\n        * module.c (mio_symbol_attribute): Handle attr.artificial\n        * class.c (gfc_build_class_symbol): Defer creation of the vtab\n        if the DT has finalizers, mark generated symbols as\n        attr.artificial.\n        (has_finalizer_component, finalize_component,\n        finalization_scalarizer, generate_finalization_wrapper):\n        New static functions.\n        (gfc_find_derived_vtab): Add _final component and call\n        generate_finalization_wrapper.\n        * dump-parse-tree.c (show_f2k_derived): Use resolved\n        proc_tree->n.sym rather than unresolved proc_sym.\n        (show_attr): Handle attr.artificial.\n        * resolve.c (gfc_resolve_finalizers): Ensure that the vtab\n        * exists.\n        (resolve_fl_derived): Resolve finalizers before\n        generating the vtab.\n        (resolve_symbol): Also allow assumed-rank arrays with CONTIGUOUS;\n        skip artificial symbols.\n        (resolve_fl_derived0): Skip artificial symbols.\n\n2012-09-03  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/51632\n        * gfortran.dg/coarray_class_1.f90: New.\n\nFrom-SVN: r190869", "tree": {"sha": "97423c845762747c432e4c5bc7446781847242d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97423c845762747c432e4c5bc7446781847242d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/comments", "author": null, "committer": null, "parents": [{"sha": "2e4a4bbd9816cace5ee9f7939428ba2410e67efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e4a4bbd9816cace5ee9f7939428ba2410e67efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e4a4bbd9816cace5ee9f7939428ba2410e67efd"}], "stats": {"total": 819, "additions": 806, "deletions": 13}, "files": [{"sha": "6032a1a6a3e3d9d43cf7eba5f35496bbfdc8b841", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -1,3 +1,27 @@\n+2012-09-03  Alessandro Fanfarillo  <fanfarillo.gcc@gmail.com>\n+\t    Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/37336\n+\t* gfortran.h (symbol_attribute): Add artificial.\n+\t* module.c (mio_symbol_attribute): Handle attr.artificial\n+\t* class.c (gfc_build_class_symbol): Defer creation of the vtab\n+\tif the DT has finalizers, mark generated symbols as\n+\tattr.artificial.\n+\t(has_finalizer_component, finalize_component,\n+\tfinalization_scalarizer, generate_finalization_wrapper):\n+\tNew static functions.\n+\t(gfc_find_derived_vtab): Add _final component and call\n+\tgenerate_finalization_wrapper.\n+\t* dump-parse-tree.c (show_f2k_derived): Use resolved\n+\tproc_tree->n.sym rather than unresolved proc_sym.\n+\t(show_attr): Handle attr.artificial.\n+\t* resolve.c (gfc_resolve_finalizers): Ensure that the vtab exists.\n+\t(resolve_fl_derived): Resolve finalizers before\n+\tgenerating the vtab.\n+\t(resolve_symbol): Also allow assumed-rank arrays with CONTIGUOUS;\n+\tskip artificial symbols.\n+\t(resolve_fl_derived0): Skip artificial symbols.\n+\n 2012-09-02  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/54426"}, {"sha": "38a4ddb5302e17376b99e3ad77d16ff81837b10b", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 725, "deletions": 4, "changes": 729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -34,14 +34,17 @@ along with GCC; see the file COPYING3.  If not see\n              declared type of the class variable and its attributes\n              (pointer/allocatable/dimension/...).\n     * _vptr: A pointer to the vtable entry (see below) of the dynamic type.\n-    \n+\n    For each derived type we set up a \"vtable\" entry, i.e. a structure with the\n    following fields:\n     * _hash:     A hash value serving as a unique identifier for this type.\n     * _size:     The size in bytes of the derived type.\n     * _extends:  A pointer to the vtable entry of the parent derived type.\n     * _def_init: A pointer to a default initialized variable of this type.\n     * _copy:     A procedure pointer to a copying procedure.\n+    * _final:    A procedure pointer to a wrapper function, which frees\n+\t\t allocatable components and calls FINAL subroutines.\n+\n    After these follow procedure pointer components for the specific\n    type-bound procedures.  */\n \n@@ -572,7 +575,9 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       if (gfc_add_component (fclass, \"_vptr\", &c) == FAILURE)\n \treturn FAILURE;\n       c->ts.type = BT_DERIVED;\n-      if (delayed_vtab)\n+      if (delayed_vtab\n+\t  || (ts->u.derived->f2k_derived\n+\t      && ts->u.derived->f2k_derived->finalizers))\n \tc->ts.u.derived = NULL;\n       else\n \t{\n@@ -689,6 +694,703 @@ copy_vtab_proc_comps (gfc_symbol *declared, gfc_symbol *vtype)\n }\n \n \n+/* Returns true if any of its nonpointer nonallocatable components or\n+   their nonpointer nonallocatable subcomponents has a finalization\n+   subroutine.  */\n+\n+static bool\n+has_finalizer_component (gfc_symbol *derived)\n+{\n+   gfc_component *c;\n+\n+  for (c = derived->components; c; c = c->next)\n+    {\n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->f2k_derived\n+\t  && c->ts.u.derived->f2k_derived->finalizers)\n+\treturn true;\n+\n+      if (c->ts.type == BT_DERIVED\n+\t  && !c->attr.pointer && !c->attr.allocatable\n+\t  && has_finalizer_component (c->ts.u.derived))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+\n+/* Call DEALLOCATE for the passed component if it is allocatable, if it is\n+   neither allocatable nor a pointer but has a finalizer, call it. If it\n+   is a nonpointer component with allocatable or finalizes components, walk\n+   them. Either of the is required; other nonallocatables and pointers aren't\n+   handled gracefully.\n+   Note: If the component is allocatable, the DEALLOCATE handling takes care\n+   of calling the appropriate finalizers, coarray deregistering, and\n+   deallocation of allocatable subcomponents.  */\n+\n+static void\n+finalize_component (gfc_expr *expr, gfc_symbol *derived, gfc_component *comp,\n+\t\t    gfc_expr *stat, gfc_code **code)\n+{\n+  gfc_expr *e;\n+  gfc_ref *ref;\n+\n+  if (comp->ts.type != BT_DERIVED && comp->ts.type != BT_CLASS\n+      && !comp->attr.allocatable)\n+    return;\n+\n+  if ((comp->ts.type == BT_DERIVED && comp->attr.pointer)\n+      || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t  && CLASS_DATA (comp)->attr.pointer))\n+    return;\n+\n+  if (comp->ts.type == BT_DERIVED && !comp->attr.allocatable\n+      && (comp->ts.u.derived->f2k_derived == NULL\n+\t  || comp->ts.u.derived->f2k_derived->finalizers == NULL)\n+      && !has_finalizer_component (comp->ts.u.derived))\n+    return;\n+\n+  e = gfc_copy_expr (expr);\n+  if (!e->ref)\n+    e->ref = ref = gfc_get_ref ();\n+  else\n+    {\n+      for (ref = e->ref; ref->next; ref = ref->next)\n+\t;\n+      ref->next = gfc_get_ref ();\n+      ref = ref->next;\n+    }\n+  ref->type = REF_COMPONENT;\n+  ref->u.c.sym = derived;\n+  ref->u.c.component = comp;\n+  e->ts = comp->ts;\n+\n+  if (comp->attr.dimension\n+      || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t  && CLASS_DATA (comp)->attr.dimension))\n+    {\n+      ref->next = gfc_get_ref ();\n+      ref->next->type = REF_ARRAY;\n+      ref->next->u.ar.type = AR_FULL;\n+      ref->next->u.ar.dimen = 0;\n+      ref->next->u.ar.as = comp->ts.type == BT_CLASS ? CLASS_DATA (comp)->as\n+\t\t\t\t\t\t\t: comp->as;\n+      e->rank = ref->next->u.ar.as->rank;\n+    }\n+\n+  if (comp->attr.allocatable\n+      || (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t  && CLASS_DATA (comp)->attr.allocatable))\n+    {\n+      /* Call DEALLOCATE (comp, stat=ignore).  */\n+      gfc_code *dealloc;\n+\n+      dealloc = XCNEW (gfc_code);\n+      dealloc->op = EXEC_DEALLOCATE;\n+      dealloc->loc = gfc_current_locus;\n+\n+      dealloc->ext.alloc.list = gfc_get_alloc ();\n+      dealloc->ext.alloc.list->expr = e;\n+\n+      dealloc->expr1 = stat;\n+      if (*code)\n+\t{\n+\t  (*code)->next = dealloc;\n+\t  (*code) = (*code)->next;\n+\t}\n+      else\n+\t(*code) = dealloc;\n+    }\n+  else if (comp->ts.type == BT_DERIVED\n+\t    && comp->ts.u.derived->f2k_derived\n+\t    && comp->ts.u.derived->f2k_derived->finalizers)\n+    {\n+      /* Call FINAL_WRAPPER (comp);  */\n+      gfc_code *final_wrap;\n+      gfc_symbol *vtab;\n+      gfc_component *c;\n+\n+      vtab = gfc_find_derived_vtab (comp->ts.u.derived);\n+      for (c = vtab->ts.u.derived->components; c; c = c->next)\n+\tif (strcmp (c->name, \"_final\") == 0)\n+\t  break;\n+\n+      gcc_assert (c);\n+      final_wrap = XCNEW (gfc_code);\n+      final_wrap->op = EXEC_CALL;\n+      final_wrap->loc = gfc_current_locus;\n+      final_wrap->loc = gfc_current_locus;\n+      final_wrap->symtree = c->initializer->symtree;\n+      final_wrap->resolved_sym = c->initializer->symtree->n.sym;\n+      final_wrap->ext.actual = gfc_get_actual_arglist ();\n+      final_wrap->ext.actual->expr = e;\n+\n+      if (*code)\n+\t{\n+\t  (*code)->next = final_wrap;\n+\t  (*code) = (*code)->next;\n+\t}\n+      else\n+\t(*code) = final_wrap;\n+    }\n+  else\n+    {\n+      gfc_component *c;\n+\n+      for (c = comp->ts.u.derived->components; c; c = c->next)\n+\tfinalize_component (e, c->ts.u.derived, c, stat, code);\n+    }\n+}\n+\n+\n+/* Generate code equivalent to\n+   CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n+\t\t     + idx * STORAGE_SIZE (array)/NUMERIC_STORAGE_SIZE., c_ptr),\n+\t\t     ptr).  */\n+\n+static gfc_code *\n+finalization_scalarizer (gfc_symbol *idx, gfc_symbol *array, gfc_symbol *ptr,\n+\t\t\t gfc_namespace *sub_ns)\n+{\n+  gfc_code *block;\n+  gfc_expr *expr, *expr2, *expr3;\n+\n+  /* C_F_POINTER().  */\n+  block = XCNEW (gfc_code);\n+  block->op = EXEC_CALL;\n+  block->loc = gfc_current_locus;\n+  gfc_get_sym_tree (\"c_f_pointer\", sub_ns, &block->symtree, true);\n+  block->resolved_sym = block->symtree->n.sym;\n+  block->resolved_sym->attr.flavor = FL_PROCEDURE;\n+  block->resolved_sym->attr.intrinsic = 1;\n+  block->resolved_sym->from_intmod = INTMOD_ISO_C_BINDING;\n+  block->resolved_sym->intmod_sym_id = ISOCBINDING_F_POINTER;\n+  gfc_commit_symbol (block->resolved_sym);\n+\n+  /* C_F_POINTER's first argument: TRANSFER ( <addr>, c_intptr_t).  */\n+  block->ext.actual = gfc_get_actual_arglist ();\n+  block->ext.actual->next = gfc_get_actual_arglist ();\n+  block->ext.actual->next->expr = gfc_get_int_expr (gfc_index_integer_kind,\n+\t\t\t\t\t\t    NULL, 0);\n+\n+  /* The <addr> part: TRANSFER (C_LOC (array), c_intptr_t).  */\n+\n+  /* TRANSFER.  */\n+  expr2 = gfc_get_expr ();\n+  expr2->expr_type = EXPR_FUNCTION;\n+  expr2->value.function.name = \"__transfer0\";\n+  expr2->value.function.isym\n+\t    = gfc_intrinsic_function_by_id (GFC_ISYM_TRANSFER);\n+  /* Set symtree for -fdump-parse-tree.  */\n+  gfc_get_sym_tree (\"transfer\", sub_ns, &expr2->symtree, false);\n+  expr2->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  expr2->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (expr2->symtree->n.sym);\n+  expr2->value.function.actual = gfc_get_actual_arglist ();\n+  expr2->value.function.actual->expr\n+\t    = gfc_lval_expr_from_sym (array);\n+  expr2->ts.type = BT_INTEGER;\n+  expr2->ts.kind = gfc_index_integer_kind;\n+\n+  /* TRANSFER's second argument: 0_c_intptr_t.  */\n+  expr2->value.function.actual = gfc_get_actual_arglist ();\n+  expr2->value.function.actual->next = gfc_get_actual_arglist ();\n+  expr2->value.function.actual->next->expr\n+\t\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  expr2->value.function.actual->next->next = gfc_get_actual_arglist ();\n+\n+  /* TRANSFER's first argument: C_LOC (array).  */\n+  expr = gfc_get_expr ();\n+  expr->expr_type = EXPR_FUNCTION;\n+  gfc_get_sym_tree (\"c_loc\", sub_ns, &expr->symtree, false);\n+  expr->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  expr->symtree->n.sym->intmod_sym_id = ISOCBINDING_LOC;\n+  expr->symtree->n.sym->attr.intrinsic = 1;\n+  expr->symtree->n.sym->from_intmod = INTMOD_ISO_C_BINDING;\n+  expr->value.function.esym = expr->symtree->n.sym;\n+  expr->value.function.actual = gfc_get_actual_arglist ();\n+  expr->value.function.actual->expr\n+\t    = gfc_lval_expr_from_sym (array);\n+  expr->symtree->n.sym->result = expr->symtree->n.sym;\n+  gfc_commit_symbol (expr->symtree->n.sym);\n+  expr->ts.type = BT_INTEGER;\n+  expr->ts.kind = gfc_index_integer_kind;\n+  expr2->value.function.actual->expr = expr;\n+\n+  /* STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE.  */\n+  block->ext.actual->expr = gfc_get_expr ();\n+  expr = block->ext.actual->expr;\n+  expr->expr_type = EXPR_OP;\n+  expr->value.op.op = INTRINSIC_DIVIDE;\n+\n+  /* STORAGE_SIZE (array,kind=c_intptr_t).  */\n+  expr->value.op.op1 = gfc_get_expr ();\n+  expr->value.op.op1->expr_type = EXPR_FUNCTION;\n+  expr->value.op.op1->value.function.isym\n+\t\t= gfc_intrinsic_function_by_id (GFC_ISYM_STORAGE_SIZE);\n+  gfc_get_sym_tree (\"storage_size\", sub_ns, &expr->value.op.op1->symtree,\n+\t\t    false);\n+  expr->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  expr->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (expr->value.op.op1->symtree->n.sym);\n+  expr->value.op.op1->value.function.actual = gfc_get_actual_arglist ();\n+  expr->value.op.op1->value.function.actual->expr\n+\t\t= gfc_lval_expr_from_sym (array);\n+  expr->value.op.op1->value.function.actual->next = gfc_get_actual_arglist ();\n+  expr->value.op.op1->value.function.actual->next->expr\n+\t\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  expr->value.op.op2 = gfc_get_int_expr (gfc_index_integer_kind, NULL,\n+\t\t\t\t\t gfc_character_storage_size);\n+  expr->value.op.op1->ts = expr->value.op.op2->ts;\n+  expr->ts = expr->value.op.op1->ts;\n+\n+  /* Offset calculation: idx * (STORAGE_SIZE (...) / NUMERIC_STORAGE_SIZE).  */\n+  block->ext.actual->expr = gfc_get_expr ();\n+  expr3 = block->ext.actual->expr;\n+  expr3->expr_type = EXPR_OP;\n+  expr3->value.op.op = INTRINSIC_TIMES;\n+  expr3->value.op.op1 = gfc_lval_expr_from_sym (idx);\n+  expr3->value.op.op2 = expr;\n+  expr3->ts = expr->ts;\n+\n+  /* <array addr> + <offset>.  */\n+  block->ext.actual->expr = gfc_get_expr ();\n+  block->ext.actual->expr->expr_type = EXPR_OP;\n+  block->ext.actual->expr->value.op.op = INTRINSIC_PLUS;\n+  block->ext.actual->expr->value.op.op1 = expr2;\n+  block->ext.actual->expr->value.op.op2 = expr3;\n+  block->ext.actual->expr->ts = expr->ts;\n+\n+  /* C_F_POINTER's 2nd arg: ptr -- and its absent shape=.  */\n+  block->ext.actual->next = gfc_get_actual_arglist ();\n+  block->ext.actual->next->expr = gfc_lval_expr_from_sym (ptr);\n+  block->ext.actual->next->next = gfc_get_actual_arglist ();\n+\n+  return block;\n+}\n+\n+\n+/* Generate the finalization/polymorphic freeing wrapper subroutine for the\n+   derived type \"derived\". The function first calls the approriate FINAL\n+   subroutine, then it DEALLOCATEs (finalizes/frees) the allocatable\n+   components (but not the inherited ones). Last, it calls the wrapper\n+   subroutine of the parent. The generated wrapper procedure takes as argument\n+   an assumed-rank array.\n+   If neither allocatable components nor FINAL subroutines exists, the vtab\n+   will contain a NULL pointer.  */\n+\n+static void\n+generate_finalization_wrapper (gfc_symbol *derived, gfc_namespace *ns,\n+\t\t\t       const char *tname, gfc_component *vtab_final)\n+{\n+  gfc_symbol *final, *array, *nelem;\n+  gfc_symbol *ptr = NULL, *idx = NULL;\n+  gfc_component *comp;\n+  gfc_namespace *sub_ns;\n+  gfc_code *last_code;\n+  char name[GFC_MAX_SYMBOL_LEN+1];\n+  bool finalizable_comp = false;\n+  gfc_expr *ancestor_wrapper = NULL;\n+\n+  /* Search for the ancestor's finalizers. */\n+  if (derived->attr.extension && derived->components\n+      && (!derived->components->ts.u.derived->attr.abstract\n+\t  || has_finalizer_component (derived)))\n+    {\n+      gfc_symbol *vtab;\n+      gfc_component *comp;\n+\n+      vtab = gfc_find_derived_vtab (derived->components->ts.u.derived);\n+      for (comp = vtab->ts.u.derived->components; comp; comp = comp->next)\n+\tif (comp->name[0] == '_' && comp->name[1] == 'f')\n+\t  {\n+\t    ancestor_wrapper = comp->initializer;\n+\t    break;\n+\t  }\n+    }\n+\n+  /* No wrapper of the ancestor and no own FINAL subroutines and\n+     allocatable components: Return a NULL() expression.  */\n+  if ((!ancestor_wrapper || ancestor_wrapper->expr_type == EXPR_NULL)\n+      && !derived->attr.alloc_comp\n+      && (!derived->f2k_derived || !derived->f2k_derived->finalizers)\n+      && !has_finalizer_component (derived))\n+    {\n+      vtab_final->initializer = gfc_get_null_expr (NULL);\n+      return;\n+    }\n+\n+  /* Check whether there are new allocatable components.  */\n+  for (comp = derived->components; comp; comp = comp->next)\n+    {\n+      if (comp == derived->components && derived->attr.extension\n+\t  && ancestor_wrapper && ancestor_wrapper->expr_type != EXPR_NULL)\n+\tcontinue;\n+\n+      if (comp->ts.type != BT_CLASS && !comp->attr.pointer\n+\t  && (comp->attr.alloc_comp || comp->attr.allocatable\n+\t      || (comp->ts.type == BT_DERIVED\n+\t\t  && has_finalizer_component (comp->ts.u.derived))))\n+\tfinalizable_comp = true;\n+      else if (comp->ts.type == BT_CLASS && CLASS_DATA (comp)\n+\t       && CLASS_DATA (comp)->attr.allocatable)\n+\tfinalizable_comp = true;\n+    }\n+\n+  /* If there is no new finalizer and no new allocatable, return with\n+     an expr to the ancestor's one.  */\n+  if ((!derived->f2k_derived || !derived->f2k_derived->finalizers)\n+      && !finalizable_comp)\n+    {\n+      vtab_final->initializer = gfc_copy_expr (ancestor_wrapper);\n+      return;\n+    }\n+\n+  /* We now create a wrapper, which does the following:\n+     1. Call the suitable finalization subroutine for this type\n+     2. Loop over all noninherited allocatable components and noninherited\n+\tcomponents with allocatable components and DEALLOCATE those; this will\n+\ttake care of finalizers, coarray deregistering and allocatable\n+\tnested components.\n+     3. Call the ancestor's finalizer.  */\n+\n+  /* Declare the wrapper function; it takes an assumed-rank array\n+     as argument. */\n+\n+  /* Set up the namespace.  */\n+  sub_ns = gfc_get_namespace (ns, 0);\n+  sub_ns->sibling = ns->contained;\n+  ns->contained = sub_ns;\n+  sub_ns->resolved = 1;\n+\n+  /* Set up the procedure symbol.  */\n+  sprintf (name, \"__final_%s\", tname);\n+  gfc_get_symbol (name, sub_ns, &final);\n+  sub_ns->proc_name = final;\n+  final->attr.flavor = FL_PROCEDURE;\n+  final->attr.subroutine = 1;\n+  final->attr.pure = 1;\n+  final->attr.artificial = 1;\n+  final->attr.if_source = IFSRC_DECL;\n+  if (ns->proc_name->attr.flavor == FL_MODULE)\n+    final->module = ns->proc_name->name;\n+  gfc_set_sym_referenced (final);\n+\n+  /* Set up formal argument.  */\n+  gfc_get_symbol (\"array\", sub_ns, &array);\n+  array->ts.type = BT_DERIVED;\n+  array->ts.u.derived = derived;\n+  array->attr.flavor = FL_VARIABLE;\n+  array->attr.dummy = 1;\n+  array->attr.contiguous = 1;\n+  array->attr.dimension = 1;\n+  array->attr.artificial = 1;\n+  array->as = gfc_get_array_spec();\n+  array->as->type = AS_ASSUMED_RANK;\n+  array->as->rank = -1;\n+  array->attr.intent = INTENT_INOUT;\n+  gfc_set_sym_referenced (array);\n+  final->formal = gfc_get_formal_arglist ();\n+  final->formal->sym = array;\n+  gfc_commit_symbol (array);\n+\n+  /* Obtain the size (number of elements) of \"array\" MINUS ONE,\n+     which is used in the scalarization.  */\n+  gfc_get_symbol (\"nelem\", sub_ns, &nelem);\n+  nelem->ts.type = BT_INTEGER;\n+  nelem->ts.kind = gfc_index_integer_kind;\n+  nelem->attr.flavor = FL_VARIABLE;\n+  nelem->attr.artificial = 1;\n+  gfc_set_sym_referenced (nelem);\n+  gfc_commit_symbol (nelem);\n+\n+  /* Generate: nelem = SIZE (array) - 1.  */\n+  last_code = XCNEW (gfc_code);\n+  last_code->op = EXEC_ASSIGN;\n+  last_code->loc = gfc_current_locus;\n+\n+  last_code->expr1 = gfc_lval_expr_from_sym (nelem);\n+\n+  last_code->expr2 = gfc_get_expr ();\n+  last_code->expr2->expr_type = EXPR_OP;\n+  last_code->expr2->value.op.op = INTRINSIC_MINUS;\n+  last_code->expr2->value.op.op2\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+  last_code->expr2->ts = last_code->expr2->value.op.op2->ts;\n+\n+  last_code->expr2->value.op.op1 = gfc_get_expr ();\n+  last_code->expr2->value.op.op1->expr_type = EXPR_FUNCTION;\n+  last_code->expr2->value.op.op1->value.function.isym\n+\t= gfc_intrinsic_function_by_id (GFC_ISYM_SIZE);\n+  gfc_get_sym_tree (\"size\", sub_ns, &last_code->expr2->value.op.op1->symtree,\n+\t\t    false);\n+  last_code->expr2->value.op.op1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+  last_code->expr2->value.op.op1->symtree->n.sym->attr.intrinsic = 1;\n+  gfc_commit_symbol (last_code->expr2->value.op.op1->symtree->n.sym);\n+  last_code->expr2->value.op.op1->value.function.actual\n+\t= gfc_get_actual_arglist ();\n+  last_code->expr2->value.op.op1->value.function.actual->expr\n+\t= gfc_lval_expr_from_sym (array);\n+  /* dim=NULL. */\n+  last_code->expr2->value.op.op1->value.function.actual->next\n+\t= gfc_get_actual_arglist ();\n+  /* kind=c_intptr_t. */\n+  last_code->expr2->value.op.op1->value.function.actual->next->next\n+\t= gfc_get_actual_arglist ();\n+  last_code->expr2->value.op.op1->value.function.actual->next->next->expr\n+\t= gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+  last_code->expr2->value.op.op1->ts\n+\t= last_code->expr2->value.op.op1->value.function.isym->ts;\n+\n+  sub_ns->code = last_code;\n+\n+  /* Call final subroutines. We now generate code like:\n+     use iso_c_binding\n+     integer, pointer :: ptr\n+     type(c_ptr) :: cptr\n+     integer(c_intptr_t) :: i, addr\n+\n+     select case (rank (array))\n+       case (3)\n+\t call final_rank3 (array)\n+       case default:\n+\t do i = 0, size (array)-1\n+\t   addr = transfer (c_loc (array), addr) + i * STORAGE_SIZE (array)\n+\t   call c_f_pointer (transfer (addr, cptr), ptr)\n+\t   call elemental_final (ptr)\n+\t end do\n+     end select */\n+\n+  if (derived->f2k_derived && derived->f2k_derived->finalizers)\n+    {\n+      gfc_finalizer *fini, *fini_elem = NULL;\n+      gfc_code *block = NULL;\n+\n+      /* SELECT CASE (RANK (array)).  */\n+      last_code->next = XCNEW (gfc_code);\n+      last_code = last_code->next;\n+      last_code->op = EXEC_SELECT;\n+      last_code->loc = gfc_current_locus;\n+\n+      last_code->expr1 = gfc_get_expr ();\n+      last_code->expr1->expr_type = EXPR_FUNCTION;\n+      last_code->expr1->value.function.isym\n+\t    = gfc_intrinsic_function_by_id (GFC_ISYM_RANK);\n+      gfc_get_sym_tree (\"rank\", sub_ns, &last_code->expr1->symtree,\n+\t\t\tfalse);\n+      last_code->expr1->symtree->n.sym->attr.flavor = FL_PROCEDURE;\n+      last_code->expr1->symtree->n.sym->attr.intrinsic = 1;\n+      gfc_commit_symbol (last_code->expr1->symtree->n.sym);\n+      last_code->expr1->value.function.actual = gfc_get_actual_arglist ();\n+      last_code->expr1->value.function.actual->expr\n+\t    = gfc_lval_expr_from_sym (array);\n+      last_code->expr1->ts = last_code->expr1->value.function.isym->ts;\n+\n+      for (fini = derived->f2k_derived->finalizers; fini; fini = fini->next)\n+\t{\n+\t  if (fini->proc_tree->n.sym->attr.elemental)\n+\t    {\n+\t      fini_elem = fini;\n+\t      continue;\n+\t    }\n+\n+\t  /* CASE (fini_rank).  */\n+\t  if (block)\n+\t    {\n+\t      block->block = XCNEW (gfc_code);\n+\t      block = block->block;\n+\t    }\n+\t  else\n+\t    {\n+\t      block = XCNEW (gfc_code);\n+\t      last_code->block = block;\n+\t    }\n+\t  block->loc = gfc_current_locus;\n+\t  block->op = EXEC_SELECT;\n+\t  block->ext.block.case_list = gfc_get_case ();\n+\t  block->ext.block.case_list->where = gfc_current_locus;\n+\t  if (fini->proc_tree->n.sym->formal->sym->attr.dimension)\n+\t    block->ext.block.case_list->low\n+\t     = gfc_get_int_expr (gfc_default_integer_kind, NULL,\n+\t\t\t\t fini->proc_tree->n.sym->formal->sym->as->rank);\n+\t  else\n+\t    block->ext.block.case_list->low\n+\t\t= gfc_get_int_expr (gfc_default_integer_kind, NULL, 0);\n+\t  block->ext.block.case_list->high\n+\t\t= block->ext.block.case_list->low;\n+\n+\t  /* CALL fini_rank (array).  */\n+\t  block->next = XCNEW (gfc_code);\n+\t  block->next->op = EXEC_CALL;\n+\t  block->next->loc = gfc_current_locus;\n+\t  block->next->symtree = fini->proc_tree;\n+\t  block->next->resolved_sym = fini->proc_tree->n.sym;\n+\t  block->next->ext.actual = gfc_get_actual_arglist ();\n+\t  block->next->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+\t}\n+\n+      /* Elemental call - scalarized.  */\n+      if (fini_elem)\n+\t{\n+\t  gfc_iterator *iter;\n+\n+\t  /* CASE DEFAULT.  */\n+\t  if (block)\n+\t    {\n+\t      block->block = XCNEW (gfc_code);\n+\t      block = block->block;\n+\t    }\n+\t  else\n+\t    {\n+\t      block = XCNEW (gfc_code);\n+\t      last_code->block = block;\n+\t    }\n+\t  block->loc = gfc_current_locus;\n+\t  block->op = EXEC_SELECT;\n+\t  block->ext.block.case_list = gfc_get_case ();\n+\n+\t  gfc_get_symbol (\"idx\", sub_ns, &idx);\n+\t  idx->ts.type = BT_INTEGER;\n+\t  idx->ts.kind = gfc_index_integer_kind;\n+\t  idx->attr.flavor = FL_VARIABLE;\n+\t  idx->attr.artificial = 1;\n+\t  gfc_set_sym_referenced (idx);\n+\t  gfc_commit_symbol (idx);\n+\n+\t  gfc_get_symbol (\"ptr\", sub_ns, &ptr);\n+\t  ptr->ts.type = BT_DERIVED;\n+\t  ptr->ts.u.derived = derived;\n+\t  ptr->attr.flavor = FL_VARIABLE;\n+\t  ptr->attr.pointer = 1;\n+\t  ptr->attr.artificial = 1;\n+\t  gfc_set_sym_referenced (ptr);\n+\t  gfc_commit_symbol (ptr);\n+\n+\t  /* Create loop.  */\n+\t  iter = gfc_get_iterator ();\n+\t  iter->var = gfc_lval_expr_from_sym (idx);\n+\t  iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+\t  iter->end = gfc_lval_expr_from_sym (nelem);\n+\t  iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+\t  block->next = XCNEW (gfc_code);\n+\t  block = block->next;\n+\t  block->op = EXEC_DO;\n+\t  block->loc = gfc_current_locus;\n+\t  block->ext.iterator = iter;\n+\t  block->block = gfc_get_code ();\n+\t  block->block->op = EXEC_DO;\n+\n+\t  /* Create code for\n+\t     CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n+\t\t\t       + idx * STORAGE_SIZE (array), c_ptr), ptr).  */\n+\t  block->block->next = finalization_scalarizer (idx, array, ptr, sub_ns);\n+\t  block = block->block->next;\n+\n+\t  /* CALL final_elemental (array).  */\n+\t  block->next = XCNEW (gfc_code);\n+\t  block = block->next;\n+\t  block->op = EXEC_CALL;\n+\t  block->loc = gfc_current_locus;\n+\t  block->symtree = fini_elem->proc_tree;\n+\t  block->resolved_sym = fini_elem->proc_sym;\n+\t  block->ext.actual = gfc_get_actual_arglist ();\n+\t  block->ext.actual->expr = gfc_lval_expr_from_sym (ptr);\n+\t}\n+    }\n+\n+  /* Finalize and deallocate allocatable components. The same manual\n+     scalarization is used as above.  */\n+\n+  if (finalizable_comp)\n+    {\n+      gfc_symbol *stat;\n+      gfc_code *block = NULL;\n+      gfc_iterator *iter;\n+\n+      if (!idx)\n+\t{\n+\t  gfc_get_symbol (\"idx\", sub_ns, &idx);\n+\t  idx->ts.type = BT_INTEGER;\n+\t  idx->ts.kind = gfc_index_integer_kind;\n+\t  idx->attr.flavor = FL_VARIABLE;\n+\t  idx->attr.artificial = 1;\n+\t  gfc_set_sym_referenced (idx);\n+\t  gfc_commit_symbol (idx);\n+\t}\n+\n+      if (!ptr)\n+\t{\n+\t  gfc_get_symbol (\"ptr\", sub_ns, &ptr);\n+\t  ptr->ts.type = BT_DERIVED;\n+\t  ptr->ts.u.derived = derived;\n+\t  ptr->attr.flavor = FL_VARIABLE;\n+\t  ptr->attr.pointer = 1;\n+\t  ptr->attr.artificial = 1;\n+\t  gfc_set_sym_referenced (ptr);\n+\t  gfc_commit_symbol (ptr);\n+\t}\n+\n+      gfc_get_symbol (\"ignore\", sub_ns, &stat);\n+      stat->attr.flavor = FL_VARIABLE;\n+      stat->attr.artificial = 1;\n+      stat->ts.type = BT_INTEGER;\n+      stat->ts.kind = gfc_default_integer_kind;\n+      gfc_set_sym_referenced (stat);\n+      gfc_commit_symbol (stat);\n+\n+      /* Create loop.  */\n+      iter = gfc_get_iterator ();\n+      iter->var = gfc_lval_expr_from_sym (idx);\n+      iter->start = gfc_get_int_expr (gfc_index_integer_kind, NULL, 0);\n+      iter->end = gfc_lval_expr_from_sym (nelem);\n+      iter->step = gfc_get_int_expr (gfc_index_integer_kind, NULL, 1);\n+      last_code->next = XCNEW (gfc_code);\n+      last_code = last_code->next;\n+      last_code->op = EXEC_DO;\n+      last_code->loc = gfc_current_locus;\n+      last_code->ext.iterator = iter;\n+      last_code->block = gfc_get_code ();\n+      last_code->block->op = EXEC_DO;\n+\n+      /* Create code for\n+\t CALL C_F_POINTER (TRANSFER (TRANSFER (C_LOC (array, cptr), c_intptr)\n+\t\t\t   + idx * STORAGE_SIZE (array), c_ptr), ptr).  */\n+      last_code->block->next = finalization_scalarizer (idx, array, ptr, sub_ns);\n+      block = last_code->block->next;\n+\n+      for (comp = derived->components; comp; comp = comp->next)\n+\t{\n+\t  if (comp == derived->components && derived->attr.extension\n+\t      && ancestor_wrapper && ancestor_wrapper->expr_type != EXPR_NULL)\n+\t    continue;\n+\n+\t  finalize_component (gfc_lval_expr_from_sym (ptr), derived, comp,\n+\t\t\t      gfc_lval_expr_from_sym (stat), &block);\n+\t  if (!last_code->block->next)\n+\t    last_code->block->next = block;\n+\t}\n+\n+    }\n+\n+  /* Call the finalizer of the ancestor.  */\n+  if (ancestor_wrapper && ancestor_wrapper->expr_type != EXPR_NULL)\n+    {\n+      last_code->next = XCNEW (gfc_code);\n+      last_code = last_code->next;\n+      last_code->op = EXEC_CALL;\n+      last_code->loc = gfc_current_locus;\n+      last_code->symtree = ancestor_wrapper->symtree;\n+      last_code->resolved_sym = ancestor_wrapper->symtree->n.sym;\n+\n+      last_code->ext.actual = gfc_get_actual_arglist ();\n+      last_code->ext.actual->expr = gfc_lval_expr_from_sym (array);\n+    }\n+\n+  gfc_commit_symbol (final);\n+  vtab_final->initializer = gfc_lval_expr_from_sym (final);\n+  vtab_final->ts.interface = final;\n+}\n+\n+\n /* Add procedure pointers for all type-bound procedures to a vtab.  */\n \n static void\n@@ -731,7 +1433,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n   /* If the type is a class container, use the underlying derived type.  */\n   if (derived->attr.is_class)\n     derived = gfc_get_derived_super_type (derived);\n-    \n+ \n   if (ns)\n     {\n       char name[GFC_MAX_SYMBOL_LEN+1], tname[GFC_MAX_SYMBOL_LEN+1];\n@@ -831,6 +1533,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t      if (gfc_add_component (vtype, \"_def_init\", &c) == FAILURE)\n \t\tgoto cleanup;\n \t      c->attr.pointer = 1;\n+\t      c->attr.artificial = 1;\n \t      c->attr.access = ACCESS_PRIVATE;\n \t      c->ts.type = BT_DERIVED;\n \t      c->ts.u.derived = derived;\n@@ -842,6 +1545,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  sprintf (name, \"__def_init_%s\", tname);\n \t\t  gfc_get_symbol (name, ns, &def_init);\n \t\t  def_init->attr.target = 1;\n+\t\t  def_init->attr.artificial = 1;\n \t\t  def_init->attr.save = SAVE_IMPLICIT;\n \t\t  def_init->attr.access = ACCESS_PUBLIC;\n \t\t  def_init->attr.flavor = FL_VARIABLE;\n@@ -876,6 +1580,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  copy->attr.flavor = FL_PROCEDURE;\n \t\t  copy->attr.subroutine = 1;\n \t\t  copy->attr.pure = 1;\n+\t\t  copy->attr.artificial = 1;\n \t\t  copy->attr.if_source = IFSRC_DECL;\n \t\t  /* This is elemental so that arrays are automatically\n \t\t     treated correctly by the scalarizer.  */\n@@ -889,7 +1594,8 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  src->ts.u.derived = derived;\n \t\t  src->attr.flavor = FL_VARIABLE;\n \t\t  src->attr.dummy = 1;\n-\t\t  src->attr.intent = INTENT_IN;\n+\t\t  src->attr.artificial = 1;\n+     \t\t  src->attr.intent = INTENT_IN;\n \t\t  gfc_set_sym_referenced (src);\n \t\t  copy->formal = gfc_get_formal_arglist ();\n \t\t  copy->formal->sym = src;\n@@ -898,6 +1604,7 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  dst->ts.u.derived = derived;\n \t\t  dst->attr.flavor = FL_VARIABLE;\n \t\t  dst->attr.dummy = 1;\n+\t\t  dst->attr.artificial = 1;\n \t\t  dst->attr.intent = INTENT_OUT;\n \t\t  gfc_set_sym_referenced (dst);\n \t\t  copy->formal->next = gfc_get_formal_arglist ();\n@@ -912,6 +1619,20 @@ gfc_find_derived_vtab (gfc_symbol *derived)\n \t\t  c->ts.interface = copy;\n \t\t}\n \n+\t      /* Add component _final, which contains a procedure pointer to\n+\t\t a wrapper which handles both the freeing of allocatable\n+\t\t components and the calls to finalization subroutines.\n+\t\t Note: The actual wrapper function can only be generated\n+\t\t at resolution time.  */\n+\n+\t      if (gfc_add_component (vtype, \"_final\", &c) == FAILURE)\n+\t\tgoto cleanup;\n+\t      c->attr.proc_pointer = 1;\n+\t      c->attr.access = ACCESS_PRIVATE;\n+\t      c->tb = XCNEW (gfc_typebound_proc);\n+\t      c->tb->ppc = 1;\n+\t      generate_finalization_wrapper (derived, ns, tname, c);\n+\n \t      /* Add procedure pointers for type-bound procedures.  */\n \t      add_procs_to_declared_vtab (derived, vtype);\n \t    }"}, {"sha": "9d6f93c5f771cf45aa2d527c5aa69ff901a10d14", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -613,6 +613,8 @@ show_attr (symbol_attribute *attr, const char * module)\n   if (attr->save != SAVE_NONE)\n     fprintf (dumpfile, \"%s\", gfc_code2string (save_status, attr->save));\n \n+  if (attr->artificial)\n+    fputs (\" ARTIFICIAL\", dumpfile);\n   if (attr->allocatable)\n     fputs (\" ALLOCATABLE\", dumpfile);\n   if (attr->asynchronous)\n@@ -788,7 +790,7 @@ show_f2k_derived (gfc_namespace* f2k)\n   for (f = f2k->finalizers; f; f = f->next)\n     {\n       show_indent ();\n-      fprintf (dumpfile, \"FINAL %s\", f->proc_sym->name);\n+      fprintf (dumpfile, \"FINAL %s\", f->proc_tree->n.sym->name);\n     }\n \n   /* Type-bound procedures.  */"}, {"sha": "b3224aa526aebd72e3da6ed1e031e748b9f1f3bf", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -761,6 +761,10 @@ typedef struct\n   /* Set if a function must always be referenced by an explicit interface.  */\n   unsigned always_explicit:1;\n \n+  /* Set if the symbol is generated and, hence, standard violations\n+     shouldn't be flaged.  */\n+  unsigned artificial:1;\n+\n   /* Set if the symbol has been referenced in an expression.  No further\n      modification of type or type parameters is permitted.  */\n   unsigned referenced:1;"}, {"sha": "5cfc33506f9f44a6a0bbf0769bdb22f1f7451fb1", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -1844,13 +1844,14 @@ typedef enum\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n   AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS, AB_CLASS_POINTER,\n-  AB_IMPLICIT_PURE\n+  AB_IMPLICIT_PURE, AB_ARTIFICIAL\n }\n ab_attribute;\n \n static const mstring attr_bits[] =\n {\n     minit (\"ALLOCATABLE\", AB_ALLOCATABLE),\n+    minit (\"ARTIFICIAL\", AB_ARTIFICIAL),\n     minit (\"ASYNCHRONOUS\", AB_ASYNCHRONOUS),\n     minit (\"DIMENSION\", AB_DIMENSION),\n     minit (\"CODIMENSION\", AB_CODIMENSION),\n@@ -1975,6 +1976,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n     {\n       if (attr->allocatable)\n \tMIO_NAME (ab_attribute) (AB_ALLOCATABLE, attr_bits);\n+      if (attr->artificial)\n+\tMIO_NAME (ab_attribute) (AB_ARTIFICIAL, attr_bits);\n       if (attr->asynchronous)\n \tMIO_NAME (ab_attribute) (AB_ASYNCHRONOUS, attr_bits);\n       if (attr->dimension)\n@@ -2090,6 +2093,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_ALLOCATABLE:\n \t      attr->allocatable = 1;\n \t      break;\n+\t    case AB_ARTIFICIAL:\n+\t      attr->artificial = 1;\n+\t      break;\n \t    case AB_ASYNCHRONOUS:\n \t      attr->asynchronous = 1;\n \t      break;"}, {"sha": "28eea5d82c8a6fa12fdbb5d8ea8b176dbcc4e2b9", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -11222,6 +11222,7 @@ gfc_resolve_finalizers (gfc_symbol* derived)\n   gfc_error (\"Finalization at %L is not yet implemented\",\n \t     &derived->declared_at);\n \n+  gfc_find_derived_vtab (derived);\n   return result;\n }\n \n@@ -11925,6 +11926,9 @@ resolve_fl_derived0 (gfc_symbol *sym)\n \n   for ( ; c != NULL; c = c->next)\n     {\n+      if (c->attr.artificial)\n+\tcontinue;\n+\n       /* See PRs 51550, 47545, 48654, 49050, 51075 - and 45170.  */\n       if (c->ts.type == BT_CHARACTER && c->ts.deferred && !c->attr.function)\n \t{\n@@ -12321,6 +12325,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \t\t\t &sym->declared_at) == FAILURE)\n     return FAILURE;\n \n+  /* Resolve the finalizer procedures.  */\n+  if (gfc_resolve_finalizers (sym) == FAILURE)\n+    return FAILURE;\n+  \n   if (sym->attr.is_class && sym->ts.u.derived == NULL)\n     {\n       /* Fix up incomplete CLASS symbols.  */\n@@ -12341,10 +12349,6 @@ resolve_fl_derived (gfc_symbol *sym)\n   if (resolve_typebound_procedures (sym) == FAILURE)\n     return FAILURE;\n \n-  /* Resolve the finalizer procedures.  */\n-  if (gfc_resolve_finalizers (sym) == FAILURE)\n-    return FAILURE;\n-  \n   return SUCCESS;\n }\n \n@@ -12541,6 +12545,9 @@ resolve_symbol (gfc_symbol *sym)\n   symbol_attribute class_attr;\n   gfc_array_spec *as;\n \n+  if (sym->attr.artificial)\n+    return;\n+\n   if (sym->attr.flavor == FL_UNKNOWN\n       || (sym->attr.flavor == FL_PROCEDURE && !sym->attr.intrinsic\n \t  && !sym->attr.generic && !sym->attr.external\n@@ -12674,11 +12681,12 @@ resolve_symbol (gfc_symbol *sym)\n   /* F2008, C530. */\n   if (sym->attr.contiguous\n       && (!class_attr.dimension\n-\t  || (as->type != AS_ASSUMED_SHAPE && !class_attr.pointer)))\n+\t  || (as->type != AS_ASSUMED_SHAPE && as->type != AS_ASSUMED_RANK\n+\t      && !class_attr.pointer)))\n     {\n       gfc_error (\"'%s' at %L has the CONTIGUOUS attribute but is not an \"\n-\t\t  \"array pointer or an assumed-shape array\", sym->name,\n-\t\t  &sym->declared_at);\n+\t\t \"array pointer or an assumed-shape or assumed-rank array\",\n+\t\t sym->name, &sym->declared_at);\n       return;\n     }\n "}, {"sha": "dcce082494127d630e8dacd907f5aae7388e3694", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -1,3 +1,8 @@\n+2012-09-03  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/51632\n+\t* gfortran.dg/coarray_class_1.f90: New.\n+\n 2012-09-02  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/49206"}, {"sha": "1644166bcf996fa7a05b1c340254e619a9cb37bc", "filename": "gcc/testsuite/gfortran.dg/coarray_class_1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_class_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e54f1392c4e7d310e0e9b4180ba8072ed95f072/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_class_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_class_1.f90?ref=8e54f1392c4e7d310e0e9b4180ba8072ed95f072", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/51632\n+!\n+! Was rejected before as __def_init and __copy were\n+! resolved and coarray components aren't valid in this\n+! context\n+!\n+module periodic_2nd_order_module\n+  implicit none\n+\n+  type periodic_2nd_order\n+    real, allocatable :: global_f(:)[:]\n+  contains\n+    procedure :: output\n+  end type\n+\n+contains\n+  subroutine output (this)\n+    class(periodic_2nd_order), intent(in) :: this\n+  end subroutine\n+end module"}]}