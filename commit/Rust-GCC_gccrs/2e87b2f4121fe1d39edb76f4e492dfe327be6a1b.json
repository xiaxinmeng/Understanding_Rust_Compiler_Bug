{"sha": "2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmU4N2IyZjQxMjFmZTFkMzllZGI3NmY0ZTQ5MmRmZTMyN2JlNmExYg==", "commit": {"author": {"name": "Stam Markianos-Wright", "email": "stam.markianos-wright@arm.com", "date": "2020-01-16T15:50:08Z"}, "committer": {"name": "Stam Markianos-Wright", "email": "stam.markianos-wright@arm.com", "date": "2020-01-16T15:50:08Z"}, "message": "[GCC][PATCH][ARM] Add Bfloat16_t scalar type, vector types and machine modes to ARM back-end [1/2]\n\ngcc/ChangeLog:\n\n2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n\n\t* config.gcc: Add arm_bf16.h.\n\t* config/arm/arm-builtins.c (arm_mangle_builtin_type): Fix comment.\n\t(arm_simd_builtin_std_type): Add BFmode.\n\t(arm_init_simd_builtin_types): Define element types for vector types.\n\t(arm_init_bf16_types): New function.\n\t(arm_init_builtins): Add arm_init_bf16_types function call.\n\t* config/arm/arm-modes.def: Add BFmode and V4BF, V8BF vector modes.\n\t* config/arm/arm-simd-builtin-types.def: Add V4BF, V8BF.\n\t* config/arm/arm.c (aapcs_vfp_sub_candidate):  Add BFmode.\n\t(arm_hard_regno_mode_ok): Add BFmode and tidy up statements.\n\t(arm_vector_mode_supported_p): Add V4BF, V8BF.\n\t(arm_mangle_type):  Add __bf16.\n\t* config/arm/arm.h: Add V4BF, V8BF to VALID_NEON_DREG_MODE,\n\tVALID_NEON_QREG_MODE respectively. Add export arm_bf16_type_node,\n\tarm_bf16_ptr_type_node.\n\t* config/arm/arm.md: Add BFmode to movhf expand, mov pattern and\n\tdefine_split between ARM registers.\n\t* config/arm/arm_bf16.h: New file.\n\t* config/arm/arm_neon.h: Add arm_bf16.h and Bfloat vector types.\n\t* config/arm/iterators.md: (ANY64_BF, VDXMOV, VHFBF, HFBF, fporbf): New.\n\t(VQXMOV): Add V8BF.\n\t* config/arm/neon.md: Add BF vector types to movhf NEON move patterns.\n\t* config/arm/vfp.md: Add BFmode to movhf patterns.\n\ngcc/testsuite/ChangeLog:\n\n2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n\n\t* g++.dg/abi/mangle-neon.C: Add BF16 SIMD types.\n\t* g++.dg/ext/arm-bf16/bf16-mangle-1.C: New test.\n\t* gcc.target/arm/bfloat16_scalar_1_1.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_1_2.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_2_1.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_2_2.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_3_1.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_3_2.c: New test.\n\t* gcc.target/arm/bfloat16_scalar_4.c: New test.\n\t* gcc.target/arm/bfloat16_simd_1_1.c: New test.\n\t* gcc.target/arm/bfloat16_simd_1_2.c: New test.\n\t* gcc.target/arm/bfloat16_simd_2_1.c: New test.\n\t* gcc.target/arm/bfloat16_simd_2_2.c: New test.\n\t* gcc.target/arm/bfloat16_simd_3_1.c: New test.\n\t* gcc.target/arm/bfloat16_simd_3_2.c: New test.", "tree": {"sha": "e8ba655740eabed273c71c6b0891f09942f7274a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8ba655740eabed273c71c6b0891f09942f7274a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/comments", "author": {"login": "Stammark", "id": 30555766, "node_id": "MDQ6VXNlcjMwNTU1NzY2", "avatar_url": "https://avatars.githubusercontent.com/u/30555766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stammark", "html_url": "https://github.com/Stammark", "followers_url": "https://api.github.com/users/Stammark/followers", "following_url": "https://api.github.com/users/Stammark/following{/other_user}", "gists_url": "https://api.github.com/users/Stammark/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stammark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stammark/subscriptions", "organizations_url": "https://api.github.com/users/Stammark/orgs", "repos_url": "https://api.github.com/users/Stammark/repos", "events_url": "https://api.github.com/users/Stammark/events{/privacy}", "received_events_url": "https://api.github.com/users/Stammark/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Stammark", "id": 30555766, "node_id": "MDQ6VXNlcjMwNTU1NzY2", "avatar_url": "https://avatars.githubusercontent.com/u/30555766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Stammark", "html_url": "https://github.com/Stammark", "followers_url": "https://api.github.com/users/Stammark/followers", "following_url": "https://api.github.com/users/Stammark/following{/other_user}", "gists_url": "https://api.github.com/users/Stammark/gists{/gist_id}", "starred_url": "https://api.github.com/users/Stammark/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Stammark/subscriptions", "organizations_url": "https://api.github.com/users/Stammark/orgs", "repos_url": "https://api.github.com/users/Stammark/repos", "events_url": "https://api.github.com/users/Stammark/events{/privacy}", "received_events_url": "https://api.github.com/users/Stammark/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b4c373beb31795ac1644e60ee34f6c0d744403d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b4c373beb31795ac1644e60ee34f6c0d744403d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b4c373beb31795ac1644e60ee34f6c0d744403d"}], "stats": {"total": 1620, "additions": 1546, "deletions": 74}, "files": [{"sha": "05d50567a0049e08aad3ecb638c23252054cf404", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -1,3 +1,29 @@\n+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n+\n+\t* config.gcc: Add arm_bf16.h.\n+\t* config/arm/arm-builtins.c (arm_mangle_builtin_type): Fix comment.\n+\t(arm_simd_builtin_std_type): Add BFmode.\n+\t(arm_init_simd_builtin_types): Define element types for vector types.\n+\t(arm_init_bf16_types): New function.\n+\t(arm_init_builtins): Add arm_init_bf16_types function call.\n+\t* config/arm/arm-modes.def: Add BFmode and V4BF, V8BF vector modes.\n+\t* config/arm/arm-simd-builtin-types.def: Add V4BF, V8BF.\n+\t* config/arm/arm.c (aapcs_vfp_sub_candidate):  Add BFmode.\n+\t(arm_hard_regno_mode_ok): Add BFmode and tidy up statements.\n+\t(arm_vector_mode_supported_p): Add V4BF, V8BF.\n+\t(arm_mangle_type):  Add __bf16.\n+\t* config/arm/arm.h: Add V4BF, V8BF to VALID_NEON_DREG_MODE, \n+\tVALID_NEON_QREG_MODE respectively. Add export arm_bf16_type_node,\n+\tarm_bf16_ptr_type_node.\n+\t* config/arm/arm.md: Add BFmode to movhf expand, mov pattern and\n+\tdefine_split between ARM registers.\n+\t* config/arm/arm_bf16.h: New file.\n+\t* config/arm/arm_neon.h: Add arm_bf16.h and Bfloat vector types.\n+\t* config/arm/iterators.md: (ANY64_BF, VDXMOV, VHFBF, HFBF, fporbf): New.\n+\t(VQXMOV): Add V8BF.\n+\t* config/arm/neon.md: Add BF vector types to movhf NEON move patterns.\n+\t* config/arm/vfp.md: Add BFmode to movhf patterns.\n+\n 2020-01-16  Mihail Ionescu  <mihail.ionescu@arm.com>\n 2020-01-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n "}, {"sha": "5a2f173047738540c6e5be519f7b70655ae2ae0c", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -344,7 +344,7 @@ arc*-*-*)\n arm*-*-*)\n \tcpu_type=arm\n \textra_objs=\"arm-builtins.o aarch-common.o\"\n-\textra_headers=\"mmintrin.h arm_neon.h arm_acle.h arm_fp16.h arm_cmse.h\"\n+\textra_headers=\"mmintrin.h arm_neon.h arm_acle.h arm_fp16.h arm_cmse.h arm_bf16.h\"\n \ttarget_type_format_char='%'\n \tc_target_objs=\"arm-c.o\"\n \tcxx_target_objs=\"arm-c.o\""}, {"sha": "7f279cca6688c6f11948159666ee647ae533c61d", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -315,22 +315,25 @@ arm_set_sat_qualifiers[SIMD_MAX_BUILTIN_ARGS]\n #define v8qi_UP  E_V8QImode\n #define v4hi_UP  E_V4HImode\n #define v4hf_UP  E_V4HFmode\n+#define v4bf_UP  E_V4BFmode\n #define v2si_UP  E_V2SImode\n #define v2sf_UP  E_V2SFmode\n #define di_UP    E_DImode\n #define v16qi_UP E_V16QImode\n #define v8hi_UP  E_V8HImode\n #define v8hf_UP  E_V8HFmode\n+#define v8bf_UP  E_V8BFmode\n #define v4si_UP  E_V4SImode\n #define v4sf_UP  E_V4SFmode\n #define v2di_UP  E_V2DImode\n #define ti_UP\t E_TImode\n #define ei_UP\t E_EImode\n #define oi_UP\t E_OImode\n #define hf_UP\t E_HFmode\n+#define bf_UP    E_BFmode\n #define si_UP\t E_SImode\n #define void_UP\t E_VOIDmode\n-\n+#define sf_UP\t E_SFmode\n #define UP(X) X##_UP\n \n typedef struct {\n@@ -806,6 +809,11 @@ static struct arm_simd_type_info arm_simd_types [] = {\n \n /* The user-visible __fp16 type.  */\n tree arm_fp16_type_node = NULL_TREE;\n+\n+/* Back-end node type for brain float (bfloat) types.  */\n+tree arm_bf16_type_node = NULL_TREE;\n+tree arm_bf16_ptr_type_node = NULL_TREE;\n+\n static tree arm_simd_intOI_type_node = NULL_TREE;\n static tree arm_simd_intEI_type_node = NULL_TREE;\n static tree arm_simd_intCI_type_node = NULL_TREE;\n@@ -856,7 +864,7 @@ const char *\n arm_mangle_builtin_type (const_tree type)\n {\n   const char *mangle;\n-  /* Walk through all the AArch64 builtins types tables to filter out the\n+  /* Walk through all the Arm builtins types tables to filter out the\n      incoming type.  */\n   if ((mangle = arm_mangle_builtin_vector_type (type))\n       || (mangle = arm_mangle_builtin_scalar_type (type)))\n@@ -897,6 +905,8 @@ arm_simd_builtin_std_type (machine_mode mode,\n       return float_type_node;\n     case E_DFmode:\n       return double_type_node;\n+    case E_BFmode:\n+      return arm_bf16_type_node;\n     default:\n       gcc_unreachable ();\n     }\n@@ -1002,6 +1012,10 @@ arm_init_simd_builtin_types (void)\n   arm_simd_types[Float32x2_t].eltype = float_type_node;\n   arm_simd_types[Float32x4_t].eltype = float_type_node;\n \n+  /* Init Bfloat vector types with underlying __bf16 scalar type.  */\n+  arm_simd_types[Bfloat16x4_t].eltype = arm_bf16_type_node;\n+  arm_simd_types[Bfloat16x8_t].eltype = arm_bf16_type_node;\n+\n   for (i = 0; i < nelts; i++)\n     {\n       tree eltype = arm_simd_types[i].eltype;\n@@ -1187,6 +1201,19 @@ arm_init_builtin (unsigned int fcode, arm_builtin_datum *d,\n   arm_builtin_decls[fcode] = fndecl;\n }\n \n+/* Initialize the backend REAL_TYPE type supporting bfloat types.  */\n+static void\n+arm_init_bf16_types (void)\n+{\n+  arm_bf16_type_node = make_node (REAL_TYPE);\n+  TYPE_PRECISION (arm_bf16_type_node) = 16;\n+  SET_TYPE_MODE (arm_bf16_type_node, BFmode);\n+  layout_type (arm_bf16_type_node);\n+\n+  lang_hooks.types.register_builtin_type (arm_bf16_type_node, \"__bf16\");\n+  arm_bf16_ptr_type_node = build_pointer_type (arm_bf16_type_node);\n+}\n+\n /* Set up ACLE builtins, even builtins for instructions that are not\n    in the current target ISA to allow the user to compile particular modules\n    with different target specific options that differ from the command line\n@@ -1955,6 +1982,8 @@ arm_init_builtins (void)\n      arm_init_neon_builtins which uses it.  */\n   arm_init_fp16_builtins ();\n \n+  arm_init_bf16_types ();\n+\n   if (TARGET_MAYBE_HARD_FLOAT)\n     {\n       arm_init_neon_builtins ();"}, {"sha": "ea92ef35723f979c8bb1f6bfb4fbeb6cd1e4b6e9", "filename": "gcc/config/arm/arm-modes.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-modes.def?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -78,6 +78,11 @@ VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */\n VECTOR_MODE (FLOAT, HF, 2);   /*                 V2HF */\n \n+FLOAT_MODE (BF, 2, 0);\n+ADJUST_FLOAT_FORMAT (BF, &arm_bfloat_half_format);\n+VECTOR_MODE (FLOAT, BF, 4);   /*\t\t V4BF.  */\n+VECTOR_MODE (FLOAT, BF, 8);   /*\t\t V8BF.  */\n+\n /* Fraction and accumulator vector modes.  */\n VECTOR_MODES (FRACT, 4);      /* V4QQ  V2HQ */\n VECTOR_MODES (UFRACT, 4);     /* V4UQQ V2UHQ */"}, {"sha": "ea3c9f97b71f03ac28d83266bcdaddcd0d42678b", "filename": "gcc/config/arm/arm-simd-builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-simd-builtin-types.def?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -48,3 +48,5 @@\n   ENTRY (Float16x8_t, V8HF, none, 128, float16, 19)\n   ENTRY (Float32x4_t, V4SF, none, 128, float32, 19)\n \n+  ENTRY (Bfloat16x4_t, V4BF, none, 64, bfloat16, 20)\n+  ENTRY (Bfloat16x8_t, V8BF, none, 128, bfloat16, 20)"}, {"sha": "12c94d95e5534260f7f9f9d71063b74a9ad931c0", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -6081,7 +6081,7 @@ aapcs_vfp_sub_candidate (const_tree type, machine_mode *modep)\n     {\n     case REAL_TYPE:\n       mode = TYPE_MODE (type);\n-      if (mode != DFmode && mode != SFmode && mode != HFmode)\n+      if (mode != DFmode && mode != SFmode && mode != HFmode && mode != BFmode)\n \treturn -1;\n \n       if (*modep == VOIDmode)\n@@ -24866,17 +24866,11 @@ arm_hard_regno_mode_ok (unsigned int regno, machine_mode mode)\n \n   if (TARGET_HARD_FLOAT && IS_VFP_REGNUM (regno))\n     {\n-      if (mode == SFmode || mode == SImode)\n-\treturn VFP_REGNO_OK_FOR_SINGLE (regno);\n-\n       if (mode == DFmode)\n \treturn VFP_REGNO_OK_FOR_DOUBLE (regno);\n \n-      if (mode == HFmode)\n-\treturn VFP_REGNO_OK_FOR_SINGLE (regno);\n-\n-      /* VFP registers can hold HImode values.  */\n-      if (mode == HImode)\n+      if (mode == HFmode || mode == BFmode || mode == HImode\n+\t  || mode == SFmode || mode == SImode)\n \treturn VFP_REGNO_OK_FOR_SINGLE (regno);\n \n       if (TARGET_NEON)\n@@ -28462,7 +28456,8 @@ arm_vector_mode_supported_p (machine_mode mode)\n   /* Neon also supports V2SImode, etc. listed in the clause below.  */\n   if (TARGET_NEON && (mode == V2SFmode || mode == V4SImode || mode == V8HImode\n       || mode == V4HFmode || mode == V16QImode || mode == V4SFmode\n-      || mode == V2DImode || mode == V8HFmode))\n+      || mode == V2DImode || mode == V8HFmode || mode == V4BFmode\n+      || mode == V8BFmode))\n     return true;\n \n   if ((TARGET_NEON || TARGET_IWMMXT)\n@@ -29366,9 +29361,14 @@ arm_mangle_type (const_tree type)\n       && lang_hooks.types_compatible_p (CONST_CAST_TREE (type), va_list_type))\n     return \"St9__va_list\";\n \n-  /* Half-precision float.  */\n+  /* Half-precision floating point types.  */\n   if (TREE_CODE (type) == REAL_TYPE && TYPE_PRECISION (type) == 16)\n-    return \"Dh\";\n+    {\n+      if (TYPE_MODE (type) == BFmode)\n+\treturn \"u6__bf16\";\n+      else\n+\treturn \"Dh\";\n+    }\n \n   /* Try mangling as a Neon type, TYPE_NAME is non-NULL if this is a\n      builtin type.  */"}, {"sha": "e07cf03538c5bb23e3285859b9e44a627b6e9ced", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -81,6 +81,11 @@ extern void (*arm_lang_output_object_attributes_hook)(void);\n    the backend.  Defined in arm-builtins.c.  */\n extern tree arm_fp16_type_node;\n \n+/* This type is the user-visible __bf16.  We need it in a few places in\n+   the backend.  Defined in arm-builtins.c.  */\n+extern tree arm_bf16_type_node;\n+extern tree arm_bf16_ptr_type_node;\n+\n \f\n #undef  CPP_SPEC\n #define CPP_SPEC \"%(subtarget_cpp_spec)\t\t\t\t\t\\\n@@ -1033,12 +1038,14 @@ extern int arm_arch_bf16;\n /* Modes valid for Neon D registers.  */\n #define VALID_NEON_DREG_MODE(MODE) \\\n   ((MODE) == V2SImode || (MODE) == V4HImode || (MODE) == V8QImode \\\n-   || (MODE) == V4HFmode || (MODE) == V2SFmode || (MODE) == DImode)\n+   || (MODE) == V4HFmode || (MODE) == V2SFmode || (MODE) == DImode \\\n+   || (MODE) == V4BFmode)\n \n /* Modes valid for Neon Q registers.  */\n #define VALID_NEON_QREG_MODE(MODE) \\\n   ((MODE) == V4SImode || (MODE) == V8HImode || (MODE) == V16QImode \\\n-   || (MODE) == V8HFmode || (MODE) == V4SFmode || (MODE) == V2DImode)\n+   || (MODE) == V8HFmode || (MODE) == V4SFmode || (MODE) == V2DImode \\\n+   || (MODE) == V8BFmode)\n \n /* Structure modes valid for Neon registers.  */\n #define VALID_NEON_STRUCT_MODE(MODE) \\"}, {"sha": "528d134a7510c504cd3d7d7ffaefd24a40991ae3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -6181,8 +6181,8 @@\n )\n \n (define_split\n-  [(set (match_operand:ANY64 0 \"arm_general_register_operand\" \"\")\n-\t(match_operand:ANY64 1 \"arm_general_register_operand\" \"\"))]\n+  [(set (match_operand:ANY64_BF 0 \"arm_general_register_operand\" \"\")\n+\t(match_operand:ANY64_BF 1 \"arm_general_register_operand\" \"\"))]\n   \"TARGET_EITHER && reload_completed\"\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 2) (match_dup 3))]\n@@ -7130,52 +7130,52 @@\n    (set_attr \"length\" \"2,4,4,2,4,2,2,4,4\")]\n )\n \n-;; HFmode moves\n-(define_expand \"movhf\"\n-  [(set (match_operand:HF 0 \"general_operand\")\n-\t(match_operand:HF 1 \"general_operand\"))]\n+;; HFmode and BFmode moves.\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:HFBF 0 \"general_operand\")\n+\t(match_operand:HFBF 1 \"general_operand\"))]\n   \"TARGET_EITHER\"\n   \"\n-  gcc_checking_assert (aligned_operand (operands[0], HFmode));\n-  gcc_checking_assert (aligned_operand (operands[1], HFmode));\n+  gcc_checking_assert (aligned_operand (operands[0], <MODE>mode));\n+  gcc_checking_assert (aligned_operand (operands[1], <MODE>mode));\n   if (TARGET_32BIT)\n     {\n       if (MEM_P (operands[0]))\n-        operands[1] = force_reg (HFmode, operands[1]);\n+\toperands[1] = force_reg (<MODE>mode, operands[1]);\n     }\n   else /* TARGET_THUMB1 */\n     {\n       if (can_create_pseudo_p ())\n         {\n            if (!REG_P (operands[0]))\n-\t     operands[1] = force_reg (HFmode, operands[1]);\n+\t     operands[1] = force_reg (<MODE>mode, operands[1]);\n         }\n     }\n   \"\n )\n \n-(define_insn \"*arm32_movhf\"\n-  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n-\t(match_operand:HF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n+(define_insn \"*arm32_mov<mode>\"\n+  [(set (match_operand:HFBF 0 \"nonimmediate_operand\" \"=r,m,r,r\")\n+\t(match_operand:HFBF 1 \"general_operand\"\t   \" m,r,r,F\"))]\n   \"TARGET_32BIT && !TARGET_HARD_FLOAT\n-   && (\t  s_register_operand (operands[0], HFmode)\n-       || s_register_operand (operands[1], HFmode))\"\n+   && (\t  s_register_operand (operands[0], <MODE>mode)\n+       || s_register_operand (operands[1], <MODE>mode))\"\n   \"*\n   switch (which_alternative)\n     {\n     case 0:\t/* ARM register from memory */\n-      return \\\"ldrh%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"ldrh%?\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 1:\t/* memory from ARM register */\n-      return \\\"strh%?\\\\t%1, %0\\\\t%@ __fp16\\\";\n+      return \\\"strh%?\\\\t%1, %0\\\\t%@ __<fporbf>\\\";\n     case 2:\t/* ARM register from ARM register */\n-      return \\\"mov%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"mov%?\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 3:\t/* ARM register from constant */\n       {\n \tlong bits;\n \trtx ops[4];\n \n \tbits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),\n-\t\t\t       HFmode);\n+\t\t\t       <MODE>mode);\n \tops[0] = operands[0];\n \tops[1] = GEN_INT (bits);\n \tops[2] = GEN_INT (bits & 0xff00);"}, {"sha": "decf23f38346c033f9d7502ce82e11ce81b9bc3a", "filename": "gcc/config/arm/arm_bf16.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm_bf16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm_bf16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_bf16.h?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,41 @@\n+/* Arm BF16 intrinsics include file.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifndef _GCC_ARM_BF16_H\n+#define _GCC_ARM_BF16_H 1\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+typedef __bf16 bfloat16_t;\n+typedef float float32_t;\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "3c78f435009ab027f92693d00ab5b40960d5419d", "filename": "gcc/config/arm/arm_neon.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm_neon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Farm_neon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm_neon.h?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -39,6 +39,7 @@ extern \"C\" {\n #endif\n \n #include <arm_fp16.h>\n+#include <arm_bf16.h>\n #include <stdint.h>\n \n typedef __simd64_int8_t int8x8_t;\n@@ -83,6 +84,9 @@ typedef __simd128_uint64_t uint64x2_t;\n \n typedef float float32_t;\n \n+typedef __simd128_bfloat16_t bfloat16x8_t;\n+typedef __simd64_bfloat16_t bfloat16x4_t;\n+\n /* The Poly types are user visible and live in their own world,\n    keep them that way.  */\n typedef __builtin_neon_poly8 poly8_t;"}, {"sha": "33e29509f00a89fa23d0546687c0e4643f0b32d2", "filename": "gcc/config/arm/iterators.md", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fiterators.md?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -28,6 +28,10 @@\n ;; registers.\n (define_mode_iterator ANY64 [DI DF V8QI V4HI V4HF V2SI V2SF])\n \n+;; Additional definition of ANY64 that also includes the special V4BF mode.\n+;; BFmode is allowed only on define_split between ARM registers.\n+(define_mode_iterator ANY64_BF [DI DF V8QI V4HI V4BF V4HF V2SI V2SF])\n+\n (define_mode_iterator ANY128 [V2DI V2DF V16QI V8HI V4SI V4SF])\n \n ;; A list of integer modes that are up to one word long\n@@ -80,6 +84,10 @@\n ;; Double-width vector modes plus 64-bit elements.\n (define_mode_iterator VDX [V8QI V4HI V4HF V2SI V2SF DI])\n \n+;; Double-width vector modes plus 64-bit elements,\n+;; with V4BFmode added, suitable for moves.\n+(define_mode_iterator VDXMOV [V8QI V4HI V4HF V4BF V2SI V2SF DI])\n+\n ;; Double-width vector modes, with V4HF - for vldN_lane and vstN_lane.\n (define_mode_iterator VD_LANE [V8QI V4HI V4HF V2SI V2SF])\n \n@@ -101,8 +109,8 @@\n ;; Quad-width vector modes without floating-point elements.\n (define_mode_iterator VQI [V16QI V8HI V4SI])\n \n-;; Quad-width vector modes, with TImode added, for moves.\n-(define_mode_iterator VQXMOV [V16QI V8HI V8HF V4SI V4SF V2DI TI])\n+;; Quad-width vector modes, with TImode and V8BFmode added, suitable for moves.\n+(define_mode_iterator VQXMOV [V16QI V8HI V8HF V8BF V4SI V4SF V2DI TI])\n \n ;; Opaque structure types wider than TImode.\n (define_mode_iterator VSTRUCT [EI OI CI XI])\n@@ -201,6 +209,12 @@\n ;; Vector modes for 16-bit floating-point support.\n (define_mode_iterator VH [V8HF V4HF])\n \n+;; 16-bit floating-point vector modes suitable for moving (includes BFmode).\n+(define_mode_iterator VHFBF [V8HF V4HF V4BF V8BF])\n+\n+;; 16-bit floating-point scalar modes suitable for moving (includes BFmode).\n+(define_mode_iterator HFBF [HF BF])\n+\n ;; Iterators used for fixed-point support.\n (define_mode_iterator FIXED [QQ HQ SQ UQQ UHQ USQ HA SA UHA USA])\n \n@@ -485,6 +499,9 @@\n ;; vtbl<n> suffix for NEON vector modes.\n (define_mode_attr VTAB_n [(TI \"2\") (EI \"3\") (OI \"4\")])\n \n+;; fp16 or bf16 marker for 16-bit float modes.\n+(define_mode_attr fporbf [(HF \"fp16\") (BF \"bf16\")])\n+\n ;; (Opposite) mode to convert to/from for NEON mode conversions.\n (define_mode_attr V_CVTTO [(V2SI \"V2SF\") (V2SF \"V2SI\")\n                (V4SI \"V4SF\") (V4SF \"V4SI\")])\n@@ -804,6 +821,7 @@\n \t\t     (V4HF \"\") (V8HF \"_q\")\n \t\t     (V2SF \"\") (V4SF \"_q\")\n \t\t     (V4HF \"\") (V8HF \"_q\")\n+\t\t     (V4BF \"\") (V8BF \"_q\")\n \t\t     (DI \"\")   (V2DI \"_q\")\n \t\t     (DF \"\")   (V2DF \"_q\")\n \t\t     (HF \"\")])"}, {"sha": "6087ca6f2badde6a492bb515a2cb5846f3d4ad8e", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -34,9 +34,9 @@\n   [(set_attr \"type\" \"neon_store1_1reg\")])\n \n (define_insn \"*neon_mov<mode>\"\n-  [(set (match_operand:VDX 0 \"nonimmediate_operand\"\n+  [(set (match_operand:VDXMOV 0 \"nonimmediate_operand\"\n \t  \"=w,Un,w, w, w,  ?r,?w,?r, ?Us,*r\")\n-\t(match_operand:VDX 1 \"general_operand\"\n+\t(match_operand:VDXMOV 1 \"general_operand\"\n \t  \" w,w, Dm,Dn,Uni, w, r, Usi,r,*r\"))]\n   \"TARGET_NEON\n    && (register_operand (operands[0], <MODE>mode)\n@@ -161,8 +161,8 @@\n })\n \n (define_expand \"mov<mode>\"\n-  [(set (match_operand:VH 0 \"s_register_operand\")\n-\t(match_operand:VH 1 \"s_register_operand\"))]\n+  [(set (match_operand:VHFBF 0 \"s_register_operand\")\n+\t(match_operand:VHFBF 1 \"s_register_operand\"))]\n   \"TARGET_NEON\"\n {\n   gcc_checking_assert (aligned_operand (operands[0], <MODE>mode));"}, {"sha": "99be8492ded9c2da89258717ed59a04ac82bb5b3", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -363,32 +363,32 @@\n    (set_attr \"arch\"           \"t2,any,any,any,a,t2,any,any,any,any,any,any\")]\n )\n \n-;; HFmode moves\n+;; HFmode and BFmode moves\n \n-(define_insn \"*movhf_vfp_fp16\"\n-  [(set (match_operand:HF 0 \"nonimmediate_operand\"\n-\t\t\t  \"= r,m,t,r,t,r,t,t,Um,r\")\n-\t(match_operand:HF 1 \"general_operand\"\n-\t\t\t  \"  m,r,t,r,r,t,Dv,Um,t,F\"))]\n+(define_insn \"*mov<mode>_vfp_<mode>16\"\n+  [(set (match_operand:HFBF 0 \"nonimmediate_operand\"\n+\t\t\t  \"= ?r,?m,t,r,t,r,t, t, Um,r\")\n+\t(match_operand:HFBF 1 \"general_operand\"\n+\t\t\t  \"  m,r,t,r,r,t,Dv,Um,t, F\"))]\n   \"TARGET_32BIT\n    && TARGET_VFP_FP16INST\n-   && (s_register_operand (operands[0], HFmode)\n-       || s_register_operand (operands[1], HFmode))\"\n+   && (s_register_operand (operands[0], <MODE>mode)\n+       || s_register_operand (operands[1], <MODE>mode))\"\n  {\n   switch (which_alternative)\n     {\n     case 0: /* ARM register from memory.  */\n-      return \\\"ldrh%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"ldrh%?\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 1: /* Memory from ARM register.  */\n-      return \\\"strh%?\\\\t%1, %0\\\\t%@ __fp16\\\";\n+      return \\\"strh%?\\\\t%1, %0\\\\t%@ __<fporbf>\\\";\n     case 2: /* S register from S register.  */\n-      return \\\"vmov\\\\t%0, %1\\t%@ __fp16\\\";\n+      return \\\"vmov\\\\t%0, %1\\t%@ __<fporbf>\\\";\n     case 3: /* ARM register from ARM register.  */\n-      return \\\"mov%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"mov%?\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 4: /* S register from ARM register.  */\n     case 5: /* ARM register from S register.  */\n     case 6: /* S register from immediate.  */\n-      return \\\"vmov.f16\\\\t%0, %1\\t%@ __fp16\\\";\n+      return \\\"vmov.f16\\\\t%0, %1\\t%@ __<fporbf>\\\";\n     case 7: /* S register from memory.  */\n       return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n     case 8: /* Memory from S register.  */\n@@ -399,7 +399,7 @@\n \trtx ops[4];\n \n \tbits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),\n-\t\t\t       HFmode);\n+\t\t\t       <MODE>mode);\n \tops[0] = operands[0];\n \tops[1] = GEN_INT (bits);\n \tops[2] = GEN_INT (bits & 0xff00);\n@@ -442,14 +442,14 @@\n       (const_int 8))])]\n )\n \n-(define_insn \"*movhf_vfp_neon\"\n-  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"= t,Um,r,m,t,r,t,r,r\")\n-\t(match_operand:HF 1 \"general_operand\"\t   \" Um, t,m,r,t,r,r,t,F\"))]\n+(define_insn \"*mov<mode>_vfp_neon\"\n+  [(set (match_operand:HFBF 0 \"nonimmediate_operand\" \"= t,Um,?r,?m,t,r,t,r,r\")\n+\t(match_operand:HFBF 1 \"general_operand\"\t     \" Um, t, m, r,t,r,r,t,F\"))]\n   \"TARGET_32BIT\n    && TARGET_HARD_FLOAT && TARGET_NEON_FP16\n    && !TARGET_VFP_FP16INST\n-   && (   s_register_operand (operands[0], HFmode)\n-       || s_register_operand (operands[1], HFmode))\"\n+   && (   s_register_operand (operands[0], <MODE>mode)\n+       || s_register_operand (operands[1], <MODE>mode))\"\n   \"*\n   switch (which_alternative)\n     {\n@@ -458,13 +458,13 @@\n     case 1:     /* memory from S register */\n       return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n     case 2:     /* ARM register from memory */\n-      return \\\"ldrh\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"ldrh\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 3:     /* memory from ARM register */\n-      return \\\"strh\\\\t%1, %0\\\\t%@ __fp16\\\";\n+      return \\\"strh\\\\t%1, %0\\\\t%@ __<fporbf>\\\";\n     case 4:\t/* S register from S register */\n       return \\\"vmov.f32\\\\t%0, %1\\\";\n     case 5:\t/* ARM register from ARM register */\n-      return \\\"mov\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"mov\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 6:\t/* S register from ARM register */\n       return \\\"vmov\\\\t%0, %1\\\";\n     case 7:\t/* ARM register from S register */\n@@ -475,7 +475,7 @@\n \trtx ops[4];\n \n \tbits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),\n-\t\t\t       HFmode);\n+\t\t\t       <MODE>mode);\n \tops[0] = operands[0];\n \tops[1] = GEN_INT (bits);\n \tops[2] = GEN_INT (bits & 0xff00);\n@@ -498,26 +498,26 @@\n )\n \n ;; FP16 without element load/store instructions.\n-(define_insn \"*movhf_vfp\"\n-  [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,t,r,t,r,r\")\n-\t(match_operand:HF 1 \"general_operand\"\t   \" m,r,t,r,r,t,F\"))]\n+(define_insn \"*mov<mode>_vfp\"\n+  [(set (match_operand:HFBF 0 \"nonimmediate_operand\" \"=r,m,t,r,t,r,r\")\n+\t(match_operand:HFBF 1 \"general_operand\"\t   \" m,r,t,r,r,t,F\"))]\n   \"TARGET_32BIT\n    && TARGET_HARD_FLOAT\n    && !TARGET_NEON_FP16\n    && !TARGET_VFP_FP16INST\n-   && (   s_register_operand (operands[0], HFmode)\n-       || s_register_operand (operands[1], HFmode))\"\n+   && (   s_register_operand (operands[0], <MODE>mode)\n+       || s_register_operand (operands[1], <MODE>mode))\"\n   \"*\n   switch (which_alternative)\n     {\n     case 0:     /* ARM register from memory */\n-      return \\\"ldrh\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"ldrh\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 1:     /* memory from ARM register */\n-      return \\\"strh\\\\t%1, %0\\\\t%@ __fp16\\\";\n+      return \\\"strh\\\\t%1, %0\\\\t%@ __<fporbf>\\\";\n     case 2:\t/* S register from S register */\n       return \\\"vmov.f32\\\\t%0, %1\\\";\n     case 3:\t/* ARM register from ARM register */\n-      return \\\"mov\\\\t%0, %1\\\\t%@ __fp16\\\";\n+      return \\\"mov\\\\t%0, %1\\\\t%@ __<fporbf>\\\";\n     case 4:\t/* S register from ARM register */\n       return \\\"vmov\\\\t%0, %1\\\";\n     case 5:\t/* ARM register from S register */\n@@ -528,7 +528,7 @@\n \trtx ops[4];\n \n \tbits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),\n-\t\t\t       HFmode);\n+\t\t\t       <MODE>mode);\n \tops[0] = operands[0];\n \tops[1] = GEN_INT (bits);\n \tops[2] = GEN_INT (bits & 0xff00);"}, {"sha": "7de3bf65acf5646e1a7a3c62f2c0d2eb6505b1db", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -1,3 +1,21 @@\n+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>\n+\n+\t* g++.dg/abi/mangle-neon.C: Add BF16 SIMD types.\n+\t* g++.dg/ext/arm-bf16/bf16-mangle-1.C: New test.\n+\t* gcc.target/arm/bfloat16_scalar_1_1.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_1_2.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_2_1.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_2_2.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_3_1.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_3_2.c: New test.\n+\t* gcc.target/arm/bfloat16_scalar_4.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_1_1.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_1_2.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_2_1.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_2_2.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_3_1.c: New test.\n+\t* gcc.target/arm/bfloat16_simd_3_2.c: New test.\n+\n 2020-01-16  Mihail Ionescu  <mihail.ionescu@arm.com>\n 2020-01-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n "}, {"sha": "57a9db269222bea6f81e30ec29bcc6837ea7fbd6", "filename": "gcc/testsuite/g++.dg/abi/mangle-neon.C", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle-neon.C?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -31,6 +31,9 @@ void f18 (int8x16_t, int8x16_t) {}\n void f19 (poly8_t a) {}\n void f20 (poly16_t a) {}\n \n+void f21 (bfloat16x4_t a) {}\n+void f22 (bfloat16x8_t a) {}\n+\n // { dg-final { scan-assembler \"_Z2f015__simd64_int8_t:\" } }\n // { dg-final { scan-assembler \"_Z2f116__simd64_int16_t:\" } }\n // { dg-final { scan-assembler \"_Z2f216__simd64_int32_t:\" } }\n@@ -52,3 +55,5 @@ void f20 (poly16_t a) {}\n // { dg-final { scan-assembler \"_Z3f1816__simd128_int8_tS_:\" } }\n // { dg-final { scan-assembler \"_Z3f19a:\" } }\n // { dg-final { scan-assembler \"_Z3f20s:\" } }\n+// { dg-final { scan-assembler \"_Z3f2120__simd64_bfloat16_t:\" } }\n+// { dg-final { scan-assembler \"_Z3f2220__simd128_bfloat16_t:\" } }"}, {"sha": "f634ed1a4404806d5922ae198e9eccd354093f55", "filename": "gcc/testsuite/g++.dg/ext/arm-bf16/bf16-mangle-1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Farm-bf16%2Fbf16-mangle-1.C?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target arm*-*-* } } */\n+\n+/* Test mangling */\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_Z1fPu6__bf16\" } } */\n+void f (__bf16 *x) { }\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_Z1gPu6__bf16S_\" } } */\n+void g (__bf16 *x, __bf16 *y) { }\n+\n+/* { dg-final { scan-assembler \"\\t.global\\t_ZN1SIu6__bf16u6__bf16E1iE\" } } */\n+template <typename T, typename U> struct S { static int i; };\n+template <> int S<__bf16, __bf16>::i = 3;"}, {"sha": "efcc56105dc4532a1b2d3eaa4ee3b264b928a06c", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_1_1.c", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,118 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+"}, {"sha": "8293cafcc147c958d6adebcf058d76e00f8c29c0", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_1_2.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_1_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a+bf16 -mfloat-abi=softfp -mfpu=auto\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+"}, {"sha": "e84f837e1627f031c9798fa8cb08c589029c373b", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_2_1.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=hard -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+#pragma GCC pop_options\n+"}, {"sha": "93ec059819ad169400648903b86ed1ccc6e521e8", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_2_2.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_2_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,124 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=softfp -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+#pragma GCC pop_options\n+"}, {"sha": "a1a7069032211a115e10d3d7adbc559b5af05e51", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_3_1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=hard -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+"}, {"sha": "f49072613f05735237ec803eb431cdf135fd06e6", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_3_2.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_3_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,119 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=softfp -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_bf16.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**bfloat_mov_ww:\n+**\t...\n+**\tvmov.f32\ts1, s15\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_ww (void)\n+{\n+  register bfloat16_t x asm (\"s15\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rw:\n+**\t...\n+**\tvmov\ts1, r4\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rw (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  register bfloat16_t y asm (\"s1\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"t\" (y));\n+}\n+\n+/*\n+**bfloat_mov_wr:\n+**\t...\n+**\tvmov\tr4, s1\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_wr (void)\n+{\n+  register bfloat16_t x asm (\"s1\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=t\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rr:\n+**\t...\n+**\tmov\tr4, r5\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rr (void)\n+{\n+  register bfloat16_t x asm (\"r5\");\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+\n+/*\n+**bfloat_mov_rm:\n+**\t...\n+**\tstrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_rm (void)\n+{\n+  register bfloat16_t x asm (\"r4\");\n+  volatile bfloat16_t y;\n+  asm volatile (\"#foo\" : \"=r\" (x));\n+  y = x;\n+  asm volatile (\"#foo\" : : : \"memory\");\n+}\n+\n+/*\n+**bfloat_mov_mr:\n+**\t...\n+**\tldrh\tr4, \\[.*\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+void bfloat_mov_mr (void)\n+{\n+  volatile bfloat16_t x;\n+  register bfloat16_t y asm (\"r4\");\n+  asm volatile (\"#foo\" : : : \"memory\");\n+  y = x;\n+  asm volatile (\"#foo\" :: \"r\" (y));\n+}\n+"}, {"sha": "9623941d01fc1db32c32f5dd6c4504f20d0b0ddb", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_scalar_4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_scalar_4.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-std=c99 -pedantic-errors -O3 --save-temps\" } */\n+\n+#include <arm_bf16.h>\n+\n+_Complex bfloat16_t stacktest1 (_Complex bfloat16_t __a)\n+{\n+  volatile _Complex bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/* { dg-error {ISO C does not support plain 'complex' meaning 'double complex'} \"\" { target *-*-* } 8 } */\n+/* { dg-error {expected '=', ',', ';', 'asm' or '__attribute__' before 'stacktest1'} \"\" { target *-*-* } 8 } */\n+"}, {"sha": "cad7d54d8e3dab2a12e099ef34d1948f37c416f4", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_1_1.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-add-options arm_v8_2a_bf16_neon }  */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tvstr\td[0-9]+, \\[sp\\]\n+**\tvldr\td[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tvst1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\tvld1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }"}, {"sha": "4ffcc54de5e3a0519338a2d42a13b18c3a8f39b1", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_1_2.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_1_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a+bf16 -mfloat-abi=softfp -mfpu=auto\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tstrd\tr[0-9]+, \\[sp\\]\n+**\tldrd\tr[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tstm\tsp, {r[0-9]+-r[0-9]+}\n+**\tldmia\tsp, {r[0-9]+-r[0-9]+}\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+"}, {"sha": "05ee4d878ec091e16f6ae4ed5bdf8ad117dab772", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_2_1.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=hard -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tvstr\td[0-9]+, \\[sp\\]\n+**\tvldr\td[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tvst1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\tvld1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+#pragma GCC pop_options"}, {"sha": "15fba316d356c6da1f0667bd8115193df4e38ada", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_2_2.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_2_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=softfp -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+#pragma GCC push_options\n+#pragma GCC target (\"+bf16\")\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tstrd\tr[0-9]+, \\[sp\\]\n+**\tldrd\tr[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tstm\tsp, {r[0-9]+-r[0-9]+}\n+**\tldmia\tsp, {r[0-9]+-r[0-9]+}\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+#pragma GCC pop_options"}, {"sha": "b9b7606d0352307b2b741a84bd8d901cf2437007", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_3_1.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_1.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=hard -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tvst1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\tvld1.16\t{d[0-9]+\\[[0-9]+\\]}, \\[r[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tvstr\td[0-9]+, \\[sp\\]\n+**\tvldr\td[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tvst1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\tvld1.64\t{d[0-9]+-d[0-9]+}, \\[sp:[0-9]+\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+"}, {"sha": "ab1fe101af4ab3ad68dba9848b7d5b875ebf426c", "filename": "gcc/testsuite/gcc.target/arm/bfloat16_simd_3_2.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e87b2f4121fe1d39edb76f4e492dfe327be6a1b/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fbfloat16_simd_3_2.c?ref=2e87b2f4121fe1d39edb76f4e492dfe327be6a1b", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do assemble { target { arm*-*-* } } } */\n+/* { dg-require-effective-target arm_v8_neon_ok } */\n+/* { dg-require-effective-target arm_v8_2a_bf16_neon_ok } */\n+/* { dg-additional-options \"-march=armv8.2-a -mfloat-abi=softfp -mfpu=neon-fp-armv8\" } */\n+/* { dg-additional-options \"-O3 --save-temps -std=gnu90\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_neon.h>\n+\n+/*\n+**stacktest1:\n+**\t...\n+**\tstrh\tr[0-9]+, \\[r[0-9]+\\]\t@ __bf16\n+**\tldrh\tr[0-9]+, \\[sp, #[0-9]+\\]\t@ __bf16\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16_t stacktest1 (bfloat16_t __a)\n+{\n+  volatile bfloat16_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest2:\n+**\t...\n+**\tstrd\tr[0-9]+, \\[sp\\]\n+**\tldrd\tr[0-9]+, \\[sp\\]\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x4_t stacktest2 (bfloat16x4_t __a)\n+{\n+  volatile bfloat16x4_t b = __a;\n+  return b;\n+}\n+\n+/*\n+**stacktest3:\n+**\t...\n+**\tstm\tsp, {r[0-9]+-r[0-9]+}\n+**\tldmia\tsp, {r[0-9]+-r[0-9]+}\n+**\t...\n+**\tbx\tlr\n+*/\n+bfloat16x8_t stacktest3 (bfloat16x8_t __a)\n+{\n+  volatile bfloat16x8_t b = __a;\n+  return b;\n+}\n+\n+/*  Test compilation of __attribute__ vectors of 8, 16, 32, etc. BFloats.  */\n+typedef bfloat16_t v8bf __attribute__((vector_size(16)));\n+typedef bfloat16_t v16bf __attribute__((vector_size(32)));\n+typedef bfloat16_t v32bf __attribute__((vector_size(64)));\n+typedef bfloat16_t v64bf __attribute__((vector_size(128)));\n+typedef bfloat16_t v128bf __attribute__((vector_size(256)));\n+\n+v8bf stacktest4 (v8bf __a)\n+{\n+  volatile v8bf b = __a;\n+  return b;\n+}\n+\n+v16bf stacktest5 (v16bf __a)\n+{\n+  volatile v16bf b = __a;\n+  return b;\n+}\n+\n+v32bf stacktest6 (v32bf __a)\n+{\n+  volatile v32bf b = __a;\n+  return b;\n+}\n+\n+v64bf stacktest7 (v64bf __a)\n+{\n+  volatile v64bf b = __a;\n+  return b;\n+}\n+\n+v128bf stacktest8 (v128bf __a)\n+{\n+  volatile v128bf b = __a;\n+  return b;\n+}\n+\n+/* Test use of constant values to assign values to vectors.  */\n+\n+typedef bfloat16_t v2bf __attribute__((vector_size(4)));\n+v2bf c2 (void) { return (v2bf) 0x12345678; }\n+\n+"}]}