{"sha": "d91561cb51f04fceb0c71858503791edba424aac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkxNTYxY2I1MWYwNGZjZWIwYzcxODU4NTAzNzkxZWRiYTQyNGFhYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-05T09:18:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-05T09:18:57Z"}, "message": "cold_partition_label.c: Update template.\n\n\n\n\t* gcc.dg/tree-prof/cold_partition_label.c: Update template.\n\n\t* tree-ssa-loop-im.c (execute_sm_if_changed): Add FLAG_BBS parameter;\n\tupdate profile.\n\t(sm_set_flag_if_changed): Add bbs field.\n\t(execute_sm_if_changed_flag_set): Pass BBS.\n\t(execute_sm): Update.\n\nFrom-SVN: r248872", "tree": {"sha": "80530f04cf2e289ac49373caf2eb1ccac7327824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80530f04cf2e289ac49373caf2eb1ccac7327824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d91561cb51f04fceb0c71858503791edba424aac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91561cb51f04fceb0c71858503791edba424aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d91561cb51f04fceb0c71858503791edba424aac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d91561cb51f04fceb0c71858503791edba424aac/comments", "author": null, "committer": null, "parents": [{"sha": "d83950138bd18b0c79f336513005cacfc0dcfdc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83950138bd18b0c79f336513005cacfc0dcfdc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83950138bd18b0c79f336513005cacfc0dcfdc7"}], "stats": {"total": 105, "additions": 91, "deletions": 14}, "files": [{"sha": "c26c7f237cd5350215387e6dad72cec6e9821369", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91561cb51f04fceb0c71858503791edba424aac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91561cb51f04fceb0c71858503791edba424aac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d91561cb51f04fceb0c71858503791edba424aac", "patch": "@@ -1,3 +1,11 @@\n+2017-06-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-loop-im.c (execute_sm_if_changed): Add FLAG_BBS parameter;\n+\tupdate profile.\n+\t(sm_set_flag_if_changed): Add bbs field.\n+\t(execute_sm_if_changed_flag_set): Pass BBS.\n+\t(execute_sm): Update.\n+\n 2017-06-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (aarch64_store_lane0<mode>):"}, {"sha": "b69c78aaa3f461471038ae5dfc2cf1c82aec3108", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d91561cb51f04fceb0c71858503791edba424aac", "patch": "@@ -1,3 +1,7 @@\n+2017-06-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/tree-prof/cold_partition_label.c: Update template.\n+\n 2017-06-05  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* gcc.target/aarch64/store_lane0_str_1.c: New test."}, {"sha": "52518cf40c38b5c9e4109c0afdaa3d779feba87f", "filename": "gcc/testsuite/gcc.dg/tree-prof/cold_partition_label.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcold_partition_label.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcold_partition_label.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fcold_partition_label.c?ref=d91561cb51f04fceb0c71858503791edba424aac", "patch": "@@ -1,7 +1,7 @@\n /* Test case to check if function foo gets split and the cold function\n    gets a label.  */\n /* { dg-require-effective-target freorder } */\n-/* { dg-options \"-O2 -freorder-blocks-and-partition -save-temps\" } */\n+/* { dg-options \"-O2 -freorder-blocks-and-partition -save-temps -fdump-tree-optimized\" } */\n \n #define SIZE 10000\n \n@@ -39,3 +39,4 @@ main (int argc, char *argv[])\n \n /* { dg-final-use { scan-assembler \"foo\\[._\\]+cold\\[\\._\\]+0\" { target *-*-linux* *-*-gnu* } } } */\n /* { dg-final-use { scan-assembler \"size\\[ \\ta-zA-Z0-0\\]+foo\\[._\\]+cold\\[\\._\\]+0\" { target *-*-linux* *-*-gnu* } } } */\n+/* { dg-final-use { scan-tree-dump-not \"Invalid sum\" \"optimized\"} } */"}, {"sha": "2dcb85d5fad9c695310855e42ade5e0861e9b53c", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 77, "deletions": 13, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d91561cb51f04fceb0c71858503791edba424aac/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=d91561cb51f04fceb0c71858503791edba424aac", "patch": "@@ -1786,7 +1786,8 @@ struct prev_flag_edges {\n */\n \n static void\n-execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n+execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n+\t\t       edge preheader, hash_set <basic_block> *flag_bbs)\n {\n   basic_block new_bb, then_bb, old_dest;\n   bool loop_has_only_one_exit;\n@@ -1796,6 +1797,54 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   struct prev_flag_edges *prev_edges = (struct prev_flag_edges *) ex->aux;\n   bool irr = ex->flags & EDGE_IRREDUCIBLE_LOOP;\n \n+  int freq_sum = 0;\n+  profile_count count_sum = profile_count::zero ();\n+  int nbbs = 0, ncount = 0;\n+  int flag_probability = -1;\n+\n+  /* Flag is set in FLAG_BBS. Determine probability that flag will be true\n+     at loop exit.\n+\n+     This code may look fancy, but it can not update profile very realistically\n+     because we do not know the probability that flag will be true at given\n+     loop exit.\n+\n+     We look for two interesting extremes\n+       - when exit is dominated by block setting the flag, we know it will\n+         always be true.  This is a common case.\n+       - when all blocks setting the flag have very low frequency we know\n+         it will likely be false.\n+     In all other cases we default to 2/3 for flag being true.  */\n+\n+  for (hash_set<basic_block>::iterator it = flag_bbs->begin ();\n+       it != flag_bbs->end (); ++it)\n+    {\n+       freq_sum += (*it)->frequency;\n+       if ((*it)->count.initialized_p ())\n+         count_sum += (*it)->count, ncount ++;\n+       if (dominated_by_p (CDI_DOMINATORS, ex->src, *it))\n+\t flag_probability = REG_BR_PROB_BASE;\n+       nbbs++;\n+    }\n+\n+  if (flag_probability != -1)\n+    ;\n+  else if (ncount == nbbs && count_sum > 0 && preheader->count >= count_sum)\n+    {\n+      flag_probability = count_sum.probability_in (preheader->count);\n+      if (flag_probability > REG_BR_PROB_BASE * 2 / 3)\n+\tflag_probability = REG_BR_PROB_BASE * 2 / 3;\n+    }\n+  else if (freq_sum > 0 && EDGE_FREQUENCY (preheader) >= freq_sum)\n+    {\n+      flag_probability = GCOV_COMPUTE_SCALE (freq_sum,\n+\t\t\t\t\t     EDGE_FREQUENCY (preheader));\n+      if (flag_probability > REG_BR_PROB_BASE * 2 / 3)\n+\tflag_probability = REG_BR_PROB_BASE * 2 / 3;\n+    }\n+  else\n+    flag_probability = REG_BR_PROB_BASE * 2 / 3;\n+\n   /* ?? Insert store after previous store if applicable.  See note\n      below.  */\n   if (prev_edges)\n@@ -1826,6 +1875,8 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   old_dest = ex->dest;\n   new_bb = split_edge (ex);\n   then_bb = create_empty_bb (new_bb);\n+  then_bb->frequency = apply_probability (new_bb->frequency, flag_probability);\n+  then_bb->count = new_bb->count.apply_probability (flag_probability);\n   if (irr)\n     then_bb->flags = BB_IRREDUCIBLE_LOOP;\n   add_bb_to_loop (then_bb, new_bb->loop_father);\n@@ -1840,12 +1891,22 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n   stmt = gimple_build_assign (unshare_expr (mem), tmp_var);\n   gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n-  make_edge (new_bb, then_bb,\n-\t     EDGE_TRUE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n-  make_edge (new_bb, old_dest,\n-\t     EDGE_FALSE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n+  edge e1 = single_succ_edge (new_bb);\n+  edge e2 = make_edge (new_bb, then_bb,\n+\t               EDGE_TRUE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n+  e2->probability = flag_probability;\n+  e2->count = then_bb->count;\n+\n+  e1->flags |= EDGE_FALSE_VALUE | (irr ? EDGE_IRREDUCIBLE_LOOP : 0);\n+  e1->flags &= ~EDGE_FALLTHRU;\n+\n+  e1->probability = REG_BR_PROB_BASE - flag_probability;\n+  e1->count = new_bb->count - then_bb->count;\n+\n   then_old_edge = make_edge (then_bb, old_dest,\n \t\t\t     EDGE_FALLTHRU | (irr ? EDGE_IRREDUCIBLE_LOOP : 0));\n+  then_old_edge->probability = REG_BR_PROB_BASE;\n+  then_old_edge->count = then_bb->count;\n \n   set_immediate_dominator (CDI_DOMINATORS, then_bb, new_bb);\n \n@@ -1889,18 +1950,17 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag)\n \t      update_stmt (phi);\n \t    }\n       }\n-  /* Remove the original fall through edge.  This was the\n-     single_succ_edge (new_bb).  */\n-  EDGE_SUCC (new_bb, 0)->flags &= ~EDGE_FALLTHRU;\n }\n \n /* When REF is set on the location, set flag indicating the store.  */\n \n struct sm_set_flag_if_changed\n {\n-  sm_set_flag_if_changed (tree flag_) : flag (flag_) {}\n+  sm_set_flag_if_changed (tree flag_, hash_set <basic_block> *bbs_)\n+\t : flag (flag_), bbs (bbs_) {}\n   bool operator () (mem_ref_loc *loc);\n   tree flag;\n+  hash_set <basic_block> *bbs;\n };\n \n bool\n@@ -1913,6 +1973,7 @@ sm_set_flag_if_changed::operator () (mem_ref_loc *loc)\n       gimple_stmt_iterator gsi = gsi_for_stmt (loc->stmt);\n       gimple *stmt = gimple_build_assign (flag, boolean_true_node);\n       gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+      bbs->add (gimple_bb (stmt));\n     }\n   return false;\n }\n@@ -1921,12 +1982,13 @@ sm_set_flag_if_changed::operator () (mem_ref_loc *loc)\n    set, set an appropriate flag indicating the store.  */\n \n static tree\n-execute_sm_if_changed_flag_set (struct loop *loop, im_mem_ref *ref)\n+execute_sm_if_changed_flag_set (struct loop *loop, im_mem_ref *ref,\n+\t\t\t\thash_set <basic_block> *bbs)\n {\n   tree flag;\n   char *str = get_lsm_tmp_name (ref->mem.ref, ~0, \"_flag\");\n   flag = create_tmp_reg (boolean_type_node, str);\n-  for_all_locs_in_loop (loop, ref, sm_set_flag_if_changed (flag));\n+  for_all_locs_in_loop (loop, ref, sm_set_flag_if_changed (flag, bbs));\n   return flag;\n }\n \n@@ -1946,6 +2008,7 @@ execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n   struct lim_aux_data *lim_data;\n   bool multi_threaded_model_p = false;\n   gimple_stmt_iterator gsi;\n+  hash_set<basic_block> flag_bbs;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -1966,7 +2029,7 @@ execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n     multi_threaded_model_p = true;\n \n   if (multi_threaded_model_p)\n-    store_flag = execute_sm_if_changed_flag_set (loop, ref);\n+    store_flag = execute_sm_if_changed_flag_set (loop, ref, &flag_bbs);\n \n   rewrite_mem_refs (loop, ref, tmp_var);\n \n@@ -2002,7 +2065,8 @@ execute_sm (struct loop *loop, vec<edge> exits, im_mem_ref *ref)\n \tgsi_insert_on_edge (ex, store);\n       }\n     else\n-      execute_sm_if_changed (ex, ref->mem.ref, tmp_var, store_flag);\n+      execute_sm_if_changed (ex, ref->mem.ref, tmp_var, store_flag,\n+\t\t\t     loop_preheader_edge (loop), &flag_bbs);\n }\n \n /* Hoists memory references MEM_REFS out of LOOP.  EXITS is the list of exit"}]}