{"sha": "335634874738d42760f1966133810dd7c069cab8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1NjM0ODc0NzM4ZDQyNzYwZjE5NjYxMzM4MTBkZDdjMDY5Y2FiOA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:04:15Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-04T18:04:15Z"}, "message": "(mips_isa_string): Add mips4 to comment.\n\n(large_int): Delete code for handling 64 bit constants.\n(mips_const_double_ok): For irix6, reject all floating point constants.\n(mips_move_2words): Use dli not li for 64 bit constants.\nUse dla not la for 64 bit addresses.\n(output_block_move): Likewise.\n(function_arg): Add support for 64bit ABI.\n(override_options): Add support for mips4 and R8000.\n(print_operand): Handle new modifiers 'B', 'b', 'T', 't'.\nMake 'X' case work for 64 bit host.\n(mips_output_filename): Use ASM_OUTPUT_FILENAME.\n(mips_asm_file_start): Go to text section for 64bit ABI.\n(compure_frame_size, save_restore_insns, function_prologue,\nmips_expand_prologue, function_epilogue): Add support for 64 bit ABI.\n(type_dependent_reg, mips_function_value): New functions.\n\nFrom-SVN: r8863", "tree": {"sha": "7993b387421f5724d47a2426679b878445e08212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7993b387421f5724d47a2426679b878445e08212"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/335634874738d42760f1966133810dd7c069cab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335634874738d42760f1966133810dd7c069cab8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/335634874738d42760f1966133810dd7c069cab8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/335634874738d42760f1966133810dd7c069cab8/comments", "author": null, "committer": null, "parents": [{"sha": "516a2dfd6f337bb262112331fa8a9c8fe19463eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/516a2dfd6f337bb262112331fa8a9c8fe19463eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/516a2dfd6f337bb262112331fa8a9c8fe19463eb"}], "stats": {"total": 264, "additions": 206, "deletions": 58}, "files": [{"sha": "e3a74727d46bfa3fb5a9a263ea5889cf6d65551d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 206, "deletions": 58, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/335634874738d42760f1966133810dd7c069cab8/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/335634874738d42760f1966133810dd7c069cab8/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=335634874738d42760f1966133810dd7c069cab8", "patch": "@@ -194,7 +194,7 @@ int mips_isa;\n \n /* Strings to hold which cpu and instruction set architecture to use.  */\n char *mips_cpu_string;\t\t/* for -mcpu=<xxx> */\n-char *mips_isa_string;\t\t/* for -mips{1,2,3} */\n+char *mips_isa_string;\t\t/* for -mips{1,2,3,4} */\n \n /* Generating calls to position independent functions?  */\n enum mips_abicalls_type mips_abicalls;\n@@ -409,7 +409,7 @@ small_int (op, mode)\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n \n-/* Return truth value of whether OP is an integer which is too big to\n+/* Return truth value of whether OP is a 32 bit integer which is too big to\n    be loaded with one instruction.  */\n \n int\n@@ -429,9 +429,7 @@ large_int (op, mode)\n   if (((unsigned long)(value + 32768)) <= 32767)\t/* subu reg,$r0,value */\n     return FALSE;\n \n-  if ((value & 0x0000ffff) == 0\t\t\t\t/* lui reg,value>>16 */\n-      && ((value & ~2147483647) == 0\t\t\t/* signed value */\n-\t  || (value & ~2147483647) == ~2147483647))\n+  if ((value & 0x0000ffff) == 0)\t\t\t/* lui reg,value>>16 */\n     return FALSE;\n \n   return TRUE;\n@@ -487,6 +485,10 @@ mips_const_double_ok (op, mode)\n   if (op == CONST0_RTX (mode))\n     return TRUE;\n \n+  /* ??? li.s does not work right with SGI's Irix 6 assembler.  */\n+  if (ABI_64BIT)\n+    return FALSE;\n+\n   REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n \n   if (REAL_VALUE_ISNAN (d))\n@@ -1349,8 +1351,8 @@ mips_move_2words (operands, insn)\n \t\t    ret = \"li.d\\t%0,%1\";\n \t\t}\n \n-\t      else if (TARGET_FLOAT64)\n-\t\tret = \"li\\t%0,%1\";\n+\t      else if (TARGET_64BIT)\n+\t\tret = \"dli\\t%0,%1\";\n \n \t      else\n \t\t{\n@@ -1401,7 +1403,17 @@ mips_move_2words (operands, insn)\n       else if (code1 == CONST_INT && GET_MODE (op0) == DImode && GP_REG_P (regno0))\n \t{\n \t  if (TARGET_64BIT)\n-\t    ret = \"li\\t%0,%1\";\n+\t    {\n+\t      if (HOST_BITS_PER_WIDE_INT < 64)\n+\t\t/* We can't use 'X' for negative numbers, because then we won't\n+\t\t   get the right value for the upper 32 bits.  */\n+\t\tret = ((INTVAL (op1) < 0) ? \"dli\\t%0,%1\\t\\t\\t# %X1\"\n+\t\t       : \"dli\\t%0,%X1\\t\\t# %1\");\n+\t      else\n+\t\t/* We must use 'X', because otherwise LONG_MIN will print as\n+\t\t   a number that the assembler won't accept.  */\n+\t\tret = \"dli\\t%0,%X1\\t\\t# %1\";\n+\t    }\n \t  else\n \t    {\n \t      operands[2] = GEN_INT (INTVAL (operands[1]) >= 0 ? 0 : -1);\n@@ -1458,9 +1470,10 @@ mips_move_2words (operands, insn)\n \t       || code1 == SYMBOL_REF\n \t       || code1 == CONST)\n \t{\n-\t  if (! TARGET_64BIT)\n-\t    abort ();\n-\t  return mips_move_1word (operands, insn, 0);\n+\t  if (TARGET_STATS)\n+\t    mips_count_memory_refs (op1, 2);\n+\n+\t  ret = \"dla\\t%0,%a1\";\n \t}\n     }\n \n@@ -2445,7 +2458,10 @@ output_block_move (insn, operands, num_regs, move_type)\n \t    {\n \t      xoperands[1] = operands[1];\n \t      xoperands[0] = src_reg;\n-\t      output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t      if (Pmode == DImode)\n+\t\toutput_asm_insn (\"dla\\t%0,%1\", xoperands);\n+\t      else\n+\t\toutput_asm_insn (\"la\\t%0,%1\", xoperands);\n \t    }\n \t}\n \n@@ -2459,7 +2475,10 @@ output_block_move (insn, operands, num_regs, move_type)\n \t    {\n \t      xoperands[1] = operands[0];\n \t      xoperands[0] = dest_reg;\n-\t      output_asm_insn (\"la\\t%0,%1\", xoperands);\n+\t      if (Pmode == DImode)\n+\t\toutput_asm_insn (\"dla\\t%0,%1\", xoperands);\n+\t      else\n+\t\toutput_asm_insn (\"la\\t%0,%1\", xoperands);\n \t    }\n \t}\n     }\n@@ -2802,28 +2821,36 @@ function_arg (cum, mode, type, named)\n   switch (mode)\n     {\n     case SFmode:\n-      if (cum->gp_reg_found || cum->arg_number >= 2 || TARGET_SOFT_FLOAT)\n-\tregbase = GP_ARG_FIRST;\n-      else\n+      if (! ABI_64BIT || mips_isa < 3)\n \t{\n-\t  regbase = FP_ARG_FIRST;\n-\t  /* If the first arg was a float in a floating point register,\n-\t     then set bias to align this float arg properly.  */\n-\t  if (cum->arg_words == 1)\n-\t    bias = 1;\n+\t  if (cum->gp_reg_found || cum->arg_number >= 2 || TARGET_SOFT_FLOAT)\n+\t    regbase = GP_ARG_FIRST;\n+\t  else\n+\t    {\n+\t      regbase = FP_ARG_FIRST;\n+\t      /* If the first arg was a float in a floating point register,\n+\t\t then set bias to align this float arg properly.  */\n+\t      if (cum->arg_words == 1)\n+\t\tbias = 1;\n+\t    }\n \t}\n-\n+      else\n+\tregbase = (TARGET_SOFT_FLOAT || ! named ? GP_ARG_FIRST : FP_ARG_FIRST);\n       break;\n \n     case DFmode:\n       if (! TARGET_64BIT)\n \tcum->arg_words += (cum->arg_words & 1);\n-      regbase = ((cum->gp_reg_found\n-\t\t  || TARGET_SOFT_FLOAT\n-\t\t  || TARGET_SINGLE_FLOAT\n-\t\t  || cum->arg_number >= 2)\n-\t\t ? GP_ARG_FIRST\n-\t\t : FP_ARG_FIRST);\n+      if (! ABI_64BIT || mips_isa < 3)\n+\tregbase = ((cum->gp_reg_found\n+\t\t    || TARGET_SOFT_FLOAT\n+\t\t    || TARGET_SINGLE_FLOAT\n+\t\t    || cum->arg_number >= 2)\n+\t\t   ? GP_ARG_FIRST\n+\t\t   : FP_ARG_FIRST);\n+      else\n+\tregbase = (TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT || ! named\n+\t\t   ? GP_ARG_FIRST : FP_ARG_FIRST);\n       break;\n \n     default:\n@@ -3094,7 +3121,7 @@ override_options ()\n   else if (isdigit (*mips_isa_string))\n     {\n       mips_isa = atoi (mips_isa_string);\n-      if (mips_isa < 1 || mips_isa > 3)\n+      if (mips_isa < 1 || mips_isa > 4)\n \t{\n \t  error (\"-mips%d not supported\", mips_isa);\n \t  mips_isa = 1;\n@@ -3126,6 +3153,10 @@ override_options ()\n \t  mips_cpu_string = \"4000\";\n \t  mips_cpu = PROCESSOR_R4000;\n \t  break;\n+\tcase 4:\n+\t  mips_cpu_string = \"8000\";\n+\t  mips_cpu = PROCESSOR_R8000;\n+\t  break;\n \t}\n \n #ifdef MIPS_CPU_DEFAULT\n@@ -3180,6 +3211,11 @@ override_options ()\n \t    mips_cpu = PROCESSOR_R6000;\n \t  break;\n \n+\tcase '8':\n+\t  if (!strcmp (p, \"8000\"))\n+\t    mips_cpu = PROCESSOR_R8000;\n+\t  break;\n+\n \tcase 'o':\n \t  if (!strcmp (p, \"orion\"))\n \t    mips_cpu = PROCESSOR_R4600;\n@@ -3194,25 +3230,30 @@ override_options ()\n     }\n \n   if ((mips_cpu == PROCESSOR_R3000 && mips_isa > 1)\n-      || (mips_cpu == PROCESSOR_R6000 && mips_isa > 2))\n+      || (mips_cpu == PROCESSOR_R6000 && mips_isa > 2)\n+      || ((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R4600)\n+\t  && mips_isa > 3))\n     error (\"-mcpu=%s does not support -mips%d\", mips_cpu_string, mips_isa);\n \n   /* make sure sizes of ints/longs/etc. are ok */\n   if (mips_isa < 3)\n     {\n       if (TARGET_INT64)\n-\tfatal (\"Only MIPS-III CPUs can support 64 bit ints\");\n+\tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit ints\");\n \n       else if (TARGET_LONG64)\n-\tfatal (\"Only MIPS-III CPUs can support 64 bit longs\");\n+\tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit longs\");\n \n       else if (TARGET_FLOAT64)\n-\tfatal (\"Only MIPS-III CPUs can support 64 bit fp registers\");\n+\tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit fp registers\");\n \n       else if (TARGET_64BIT)\n-\tfatal (\"Only MIPS-III CPUs can support 64 bit gp registers\");\n+\tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit gp registers\");\n     }\n \n+  if (ABI_64BIT && mips_isa >= 3)\n+    flag_pcc_struct_return = 0;\n+\n   /* Tell halfpic.c that we have half-pic code if we do.  */\n   if (TARGET_HALF_PIC)\n     HALF_PIC_INIT ();\n@@ -3445,6 +3486,10 @@ mips_debugger_offset (addr, offset)\n    'C'  print part of opcode for a branch condition.\n    'N'  print part of opcode for a branch condition, inverted.\n    'S'  X is CODE_LABEL, print with prefix of \"LS\" (for embedded switch).\n+   'B'  print 'z' for EQ, 'n' for NE\n+   'b'  print 'n' for EQ, 'z' for NE\n+   'T'  print 'f' for EQ, 't' for NE\n+   't'  print 't' for EQ, 'f' for NE\n    '('\tTurn on .set noreorder\n    ')'\tTurn on .set reorder\n    '['\tTurn on .set noat\n@@ -3664,9 +3709,14 @@ print_operand (file, op, letter)\n   else if ((letter == 'x') && (GET_CODE(op) == CONST_INT))\n     fprintf (file, \"0x%04x\", 0xffff & (INTVAL(op)));\n \n-  else if ((letter == 'X') && (GET_CODE(op) == CONST_INT))\n+  else if ((letter == 'X') && (GET_CODE(op) == CONST_INT)\n+\t   && HOST_BITS_PER_WIDE_INT == 32)\n     fprintf (file, \"0x%08x\", INTVAL(op));\n \n+  else if ((letter == 'X') && (GET_CODE(op) == CONST_INT)\n+\t   && HOST_BITS_PER_WIDE_INT == 64)\n+    fprintf (file, \"0x%016lx\", INTVAL(op));\n+\n   else if ((letter == 'd') && (GET_CODE(op) == CONST_INT))\n     fprintf (file, \"%d\", (INTVAL(op)));\n \n@@ -3678,6 +3728,15 @@ print_operand (file, op, letter)\n   else if (letter == 'd' || letter == 'x' || letter == 'X')\n     fatal (\"PRINT_OPERAND: letter %c was found & insn was not CONST_INT\", letter);\n \n+  else if (letter == 'B')\n+    fputs (code == EQ ? \"z\" : \"n\", file);\n+  else if (letter == 'b')\n+    fputs (code == EQ ? \"n\" : \"z\", file);\n+  else if (letter == 'T')\n+    fputs (code == EQ ? \"f\" : \"t\", file);\n+  else if (letter == 't')\n+    fputs (code == EQ ? \"t\" : \"f\", file);\n+\n   else\n     output_addr_const (file, op);\n }\n@@ -3902,9 +3961,7 @@ mips_output_filename (stream, name)\n       first_time = FALSE;\n       SET_FILE_NUMBER ();\n       current_function_file = name;\n-      fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n-      output_quoted_string (stream, name);\n-      fprintf (stream, \"\\n\");\n+      ASM_OUTPUT_FILENAME (stream, num_source_filenames, name);\n       /* This tells mips-tfile that stabs will follow.  */\n       if (!TARGET_GAS && write_symbols == DBX_DEBUG)\n \tfprintf (stream, \"\\t#@stabs\\n\");\n@@ -3929,18 +3986,13 @@ mips_output_filename (stream, name)\n \t      ignore_line_number = TRUE;\n \t      warning (\"MIPS ECOFF format does not allow changing filenames within functions with #line\");\n \t    }\n-\n-\t  fprintf (stream, \"\\t#.file\\t%d \", num_source_filenames);\n \t}\n-\n       else\n \t{\n \t  SET_FILE_NUMBER ();\n \t  current_function_file = name;\n-\t  fprintf (stream, \"\\t.file\\t%d \", num_source_filenames);\n+\t  ASM_OUTPUT_FILENAME (stream, num_source_filenames, name);\n \t}\n-      output_quoted_string (stream, name);\n-      fprintf (stream, \"\\n\");\n     }\n }\n \n@@ -4061,6 +4113,11 @@ mips_asm_file_start (stream)\n     /* ??? but do not want this (or want pic0) if -non-shared? */\n     fprintf (stream, \"\\t%s\\n\", ABICALLS_ASM_OP);\n \n+  /* Start a section, so that the first .popsection directive is guaranteed\n+     to have a previously defined section to pop back to.  */\n+  if (ABI_64BIT && mips_isa >= 3)\n+    fprintf (stream, \"\\t.section\\t.text\\n\");\n+\n   /* This code exists so that we can put all externs before all symbol\n      references.  This is necessary for the assembler's global pointer\n      optimizations to work.  */\n@@ -4426,7 +4483,11 @@ compute_frame_size (size)\n   gp_reg_rounded = MIPS_STACK_ALIGN (gp_reg_size);\n   total_size += gp_reg_rounded + MIPS_STACK_ALIGN (fp_reg_size);\n \n-  if (total_size == extra_size)\n+  /* The gp reg is caller saved in the 32 bit ABI, so there is no need\n+     for leaf routines (total_size == extra_size) to save the gp reg.\n+     The gp reg is callee saved in the 64 bit ABI, so all routines must\n+     save the gp reg.  */\n+  if (total_size == extra_size && ! (ABI_64BIT && mips_isa >= 3))\n     total_size = extra_size = 0;\n   else if (TARGET_ABICALLS)\n     {\n@@ -4438,6 +4499,11 @@ compute_frame_size (size)\n       total_size += gp_reg_rounded;\n     }\n \n+  /* Add in space reserved on the stack by the callee for storing arguments\n+     passed in registers.  */\n+  if (ABI_64BIT && mips_isa >= 3)\n+    total_size += MIPS_STACK_ALIGN (current_function_pretend_args_size);\n+\n   /* Save other computed information.  */\n   current_frame_info.total_size  = total_size;\n   current_frame_info.var_size    = var_size;\n@@ -4453,8 +4519,8 @@ compute_frame_size (size)\n \n   if (mask)\n     {\n-      unsigned long offset = args_size + extra_size + var_size\n-\t\t\t     + gp_reg_size - UNITS_PER_WORD;\n+      unsigned long offset = (args_size + extra_size + var_size\n+\t\t\t      + gp_reg_size - UNITS_PER_WORD);\n       current_frame_info.gp_sp_offset = offset;\n       current_frame_info.gp_save_offset = offset - total_size;\n     }\n@@ -4598,13 +4664,13 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \n \t\t  if (store_p)\n \t\t    emit_move_insn (mem_rtx, reg_rtx);\n-\t\t  else if (!TARGET_ABICALLS\n+\t\t  else if (!TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3)\n \t\t\t   || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (store_p || !TARGET_ABICALLS\n+\t\t  if (store_p || !TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3)\n \t\t      || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t    fprintf (file, \"\\t%s\\t%s,%ld(%s)\\n\",\n \t\t\t     (TARGET_64BIT\n@@ -4769,7 +4835,7 @@ function_prologue (file, size)\n \t   current_frame_info.fmask,\n \t   current_frame_info.fp_save_offset);\n \n-  if (TARGET_ABICALLS)\n+  if (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3))\n     {\n       char *sp_str = reg_names[STACK_POINTER_REGNUM];\n \n@@ -4896,17 +4962,18 @@ mips_expand_prologue ()\n \n   /* If this function is a varargs function, store any registers that\n      would normally hold arguments ($4 - $7) on the stack.  */\n-  if ((TYPE_ARG_TYPES (fntype) != 0\n-       && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype))) != void_type_node))\n-      || (arg_name != (char *)0\n-\t  && ((arg_name[0] == '_' && strcmp (arg_name, \"__builtin_va_alist\") == 0)\n-\t      || (arg_name[0] == 'v' && strcmp (arg_name, \"va_alist\") == 0))))\n+  if ((! ABI_64BIT || mips_isa < 3)\n+      && ((TYPE_ARG_TYPES (fntype) != 0\n+\t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype))) != void_type_node))\n+\t  || (arg_name != (char *)0\n+\t      && ((arg_name[0] == '_' && strcmp (arg_name, \"__builtin_va_alist\") == 0)\n+\t\t  || (arg_name[0] == 'v' && strcmp (arg_name, \"va_alist\") == 0)))))\n     {\n       int offset = (regno - GP_ARG_FIRST) * UNITS_PER_WORD;\n       rtx ptr = stack_pointer_rtx;\n \n       /* If we are doing svr4-abi, sp has already been decremented by tsize. */\n-      if (TARGET_ABICALLS)\n+      if (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3))\n \toffset += tsize;\n \n       for (; regno <= GP_ARG_LAST; regno++)\n@@ -4924,7 +4991,7 @@ mips_expand_prologue ()\n       rtx tsize_rtx = GEN_INT (tsize);\n \n       /* If we are doing svr4-abi, sp move is done by function_prologue.  */\n-      if (!TARGET_ABICALLS)\n+      if (!TARGET_ABICALLS || (ABI_64BIT && mips_isa >= 3))\n \t{\n \t  if (tsize > 32767)\n \t    {\n@@ -4950,6 +5017,9 @@ mips_expand_prologue ()\n \t  else\n \t    emit_insn (gen_movsi (frame_pointer_rtx, stack_pointer_rtx));\n \t}\n+\n+      if (TARGET_ABICALLS && (ABI_64BIT && mips_isa >= 3))\n+\temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0)));\n     }\n \n   /* If we are profiling, make sure no instructions are scheduled before\n@@ -5070,7 +5140,8 @@ function_epilogue (file, size)\n       save_restore_insns (FALSE, tmp_rtx, tsize, file);\n \n       load_only_r31 = (((current_frame_info.mask\n-\t\t\t & ~ (TARGET_ABICALLS ? PIC_OFFSET_TABLE_MASK : 0))\n+\t\t\t & ~ (TARGET_ABICALLS && ! (ABI_64BIT && mips_isa >= 3)\n+\t\t\t      ? PIC_OFFSET_TABLE_MASK : 0))\n \t\t\t== RA_MASK)\n \t\t       && current_frame_info.fmask == 0);\n \n@@ -5382,6 +5453,83 @@ mips_select_section (decl, reloc)\n \tdata_section ();\n     }\n }\n+\f\n+#if ABI_64BIT\n+/* Support functions for the 64 bit ABI.  */\n+\n+/* Return the register to be used for word INDEX of a variable with type TYPE\n+   being passed starting at general purpose reg REGNO.\n+\n+   If the word being passed is a single field of a structure which has type\n+   double, then pass it in a floating point reg instead of a general purpose\n+   reg.  Otherwise, we return the default value REGNO + INDEX.  */\n+\n+rtx\n+type_dependent_reg (regno, index, type)\n+     int regno;\n+     int index;\n+     tree type;\n+{\n+  tree field;\n+  tree offset;\n+\n+  /* If type isn't a structure type, return the default value now.  */\n+  if (! type || TREE_CODE (type) != RECORD_TYPE || mips_isa < 3)\n+    return gen_rtx (REG, word_mode, regno + index);\n+\n+  /* Iterate through the structure fields to find which one corresponds to\n+     this index.  */\n+  offset = size_int (index * BITS_PER_WORD);\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    {\n+      if (! tree_int_cst_lt (DECL_FIELD_BITPOS (field), offset))\n+\tbreak;\n+    }\n+\n+  if (field && tree_int_cst_equal (DECL_FIELD_BITPOS (field), offset)\n+      && TREE_CODE (TREE_TYPE (field)) == REAL_TYPE\n+      && TYPE_PRECISION (TREE_TYPE (field)) == BITS_PER_WORD)\n+    return gen_rtx (REG, DFmode,\n+\t\t    regno + index + FP_ARG_FIRST - GP_ARG_FIRST);\n+  else\n+    return gen_rtx (REG, word_mode, regno + index);\n+}\n+\n+/* Return register to use for a function return value with VALTYPE for function\n+   FUNC.  */\n+\n+rtx\n+mips_function_value (valtype, func)\n+     tree valtype;\n+     tree func;\n+{\n+  int reg = GP_RETURN;\n+  enum machine_mode mode = TYPE_MODE (valtype);\n+  enum mode_class mclass = GET_MODE_CLASS (mode);\n+\n+  if (mclass == MODE_FLOAT || mclass == MODE_COMPLEX_FLOAT)\n+    reg = FP_RETURN;\n+  else if (TREE_CODE (valtype) == RECORD_TYPE && mips_isa >= 3)\n+    {\n+      /* A struct with only one or two floating point fields is returned in\n+\t the floating point registers.  */\n+      tree field;\n+      int i;\n+\n+      for (i = 0, field = TYPE_FIELDS (valtype); field;\n+\t   field = TREE_CHAIN (field), i++)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (field)) != REAL_TYPE || i >= 2)\n+\t    break;\n+\t}\n+\t  \n+      if (! field)\n+\treg = FP_RETURN;\n+    }\n+\n+  return gen_rtx (REG, mode, reg);\n+}\n+#endif\n \n /* Moving the HI or LO register somewhere requires a general register.  */\n "}]}