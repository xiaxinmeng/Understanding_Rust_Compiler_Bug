{"sha": "938f37772eae24bf9fd62530ed5f0bf0e43598ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM4ZjM3NzcyZWFlMjRiZjlmZDYyNTMwZWQ1ZjBiZjBlNDM1OThlYw==", "commit": {"author": {"name": "Hans Boehm", "email": "Hans_Boehm@hp.com", "date": "2001-12-14T18:43:55Z"}, "committer": {"name": "Hans Boehm", "email": "hboehm@gcc.gnu.org", "date": "2001-12-14T18:43:55Z"}, "message": "prims.cc: Some old cleanups.\n\n\t* libjava/prims.cc: Some old cleanups.  The collector now\n\thandles test for out of memory.\n\t* libjava/prims.cc, libjava/gcj/javaprims.h:\n\t(_Jv_AllocObjectNoInitNoFinalizer, _Jv_AllocObjectNoFinalizer):\n\tNew functions for finalizer-free allocation.\n\t(jvmpi_notify_alloc): Became separate function.\n\t* libjava/java/lang/Object.h, libjava/include/jvm.h: Adjust for\n\trevised vtable layout on IA64.  With TARGET_VTABLE_USES_DESCRIPTORS,\n\tthere is only one extra descriptor.\n\nFrom-SVN: r48002", "tree": {"sha": "5f0133888c909558a79f8bc0aa5a45088a22f853", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f0133888c909558a79f8bc0aa5a45088a22f853"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/938f37772eae24bf9fd62530ed5f0bf0e43598ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938f37772eae24bf9fd62530ed5f0bf0e43598ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/938f37772eae24bf9fd62530ed5f0bf0e43598ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/938f37772eae24bf9fd62530ed5f0bf0e43598ec/comments", "author": null, "committer": null, "parents": [{"sha": "b6bfa8766be24c7e4064a386aa61caca54446f40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6bfa8766be24c7e4064a386aa61caca54446f40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6bfa8766be24c7e4064a386aa61caca54446f40"}], "stats": {"total": 116, "additions": 79, "deletions": 37}, "files": [{"sha": "40781b01768272063744bcb077a628388b4511d2", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=938f37772eae24bf9fd62530ed5f0bf0e43598ec", "patch": "@@ -1,3 +1,16 @@\n+2001-12-14  Hans Boehm  <Hans_Boehm@hp.com>\n+\t* libjava/prims.cc: Some old cleanups.  The collector now\n+\thandles test for out of memory.\n+\n+\t* libjava/prims.cc, libjava/gcj/javaprims.h:\n+\t(_Jv_AllocObjectNoInitNoFinalizer, _Jv_AllocObjectNoFinalizer):\n+\tNew functions for finalizer-free allocation.\n+\t(jvmpi_notify_alloc): Became separate function.\n+\n+\t* libjava/java/lang/Object.h, libjava/include/jvm.h: Adjust for\n+\trevised vtable layout on IA64.  With TARGET_VTABLE_USES_DESCRIPTORS,\n+\tthere is only one extra descriptor.\n+\n 2001-12-12  Tom Tromey  <tromey@redhat.com>\n \n \t* prims.cc (_Jv_RunMain): Use `using' to simplify code.  Set"}, {"sha": "c07d40c8302dd1d691ef445e45546d33c8f4077d", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=938f37772eae24bf9fd62530ed5f0bf0e43598ec", "patch": "@@ -384,6 +384,8 @@ typedef struct _Jv_Field *jfieldID;\n typedef struct _Jv_Method *jmethodID;\n \n extern \"C\" jobject _Jv_AllocObject (jclass, jint) __attribute__((__malloc__));\n+extern \"C\" jobject _Jv_AllocObjectNoFinalizer (jclass, jint) __attribute__((__malloc__));\n+extern \"C\" jobject _Jv_AllocObjectNoInitNoFinalizer (jclass, jint) __attribute__((__malloc__));\n #ifdef JV_HASH_SYNCHRONIZATION\n   extern \"C\" jobject _Jv_AllocPtrFreeObject (jclass, jint)\n   \t\t\t    __attribute__((__malloc__));"}, {"sha": "57ba44fbfadac1924f9641639c833c8ccddb9065", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=938f37772eae24bf9fd62530ed5f0bf0e43598ec", "patch": "@@ -28,18 +28,12 @@ details.  */\n struct _Jv_VTable\n {\n #ifdef __ia64__\n-  jclass clas;\n-  unsigned long : 64;\n-  void *gc_descr;\n-  unsigned long : 64;\n-\n   typedef struct { void *pc, *gp; } vtable_elt;\n #else\n-  jclass clas;\n-  void *gc_descr;\n-\n   typedef void *vtable_elt;\n #endif\n+  jclass clas;\n+  void *gc_descr;\n \n   // This must be last, as derived classes \"extend\" this by\n   // adding new data members.\n@@ -48,12 +42,20 @@ struct _Jv_VTable\n #ifdef __ia64__\n   void *get_method(int i) { return &method[i]; }\n   void set_method(int i, void *fptr) { method[i] = *(vtable_elt *)fptr; }\n+  void *get_finalizer()\n+  {\n+    // We know that get_finalizer is only used for checking whether\n+    // this object needs to have a finalizer registered.  So it is\n+    // safe to simply return just the PC component of the vtable\n+    // slot.\n+    return ((vtable_elt *)(get_method(0)))->pc;\n+  }\n #else\n   void *get_method(int i) { return method[i]; }\n   void set_method(int i, void *fptr) { method[i] = fptr; }\n+  void *get_finalizer() { return get_method(0); }\n #endif\n \n-  void *get_finalizer() { return get_method(0); }\n   static size_t vtable_elt_size() { return sizeof(vtable_elt); }\n   static _Jv_VTable *new_vtable (int count);\n };"}, {"sha": "b0d82707c1164006d66b0af9ebf3f1a7456dbb43", "filename": "libjava/java/lang/Object.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fjava%2Flang%2FObject.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fjava%2Flang%2FObject.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.h?ref=938f37772eae24bf9fd62530ed5f0bf0e43598ec", "patch": "@@ -21,8 +21,11 @@ struct _JvObjectPrefix\n {\n protected:\n   // New ABI Compatibility Dummy, #1 and 2.\n-  virtual void nacd_1 (void) {};  // This slot really contains the Class pointer.\n-  virtual void nacd_2 (void) {};  // Actually the GC bitmap marking descriptor.\n+  virtual void nacd_1 (void) {}; // This slot really contains the Class pointer.\n+  // For IA64, the GC descriptor goes into the second word of the nacd1 descr.\n+# ifndef __ia64__\n+    virtual void nacd_2 (void) {}; // Actually the GC bitmap marking descriptor.\n+# endif\n };\n \n class java::lang::Object : public _JvObjectPrefix"}, {"sha": "40d1bd66f815c920e51f4afdff091f5090d141a5", "filename": "libjava/prims.cc", "status": "modified", "additions": 48, "deletions": 26, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fprims.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/938f37772eae24bf9fd62530ed5f0bf0e43598ec/libjava%2Fprims.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fprims.cc?ref=938f37772eae24bf9fd62530ed5f0bf0e43598ec", "patch": "@@ -256,8 +256,6 @@ _Jv_makeUtf8Const (char* s, int len)\n   if (len < 0)\n     len = strlen (s);\n   Utf8Const* m = (Utf8Const*) _Jv_AllocBytes (sizeof(Utf8Const) + len + 1);\n-  if (! m)\n-    throw no_memory;\n   memcpy (m->data, s, len);\n   m->data[len] = 0;\n   m->length = len;\n@@ -333,33 +331,14 @@ _Jv_ThrowNullPointerException ()\n // The collector calls this when it encounters an out-of-memory condition.\n void _Jv_ThrowNoMemory()\n {\n-  _Jv_Throw (no_memory);\n+  throw no_memory;\n }\n \n-// Allocate a new object of class KLASS.  SIZE is the size of the object\n-// to allocate.  You might think this is redundant, but it isn't; some\n-// classes, such as String, aren't of fixed size.\n-jobject\n-_Jv_AllocObject (jclass klass, jint size)\n-{\n-  _Jv_InitClass (klass);\n-\n-  jobject obj = (jobject) _Jv_AllocObj (size, klass);\n-\n-  // If this class has inherited finalize from Object, then don't\n-  // bother registering a finalizer.  We know that finalize() is the\n-  // very first method after the dummy entry.  If this turns out to be\n-  // unreliable, a more robust implementation can be written.  Such an\n-  // implementation would look for Object.finalize in Object's method\n-  // table at startup, and then use that information to find the\n-  // appropriate index in the method vector.\n-  if (klass->vtable->get_finalizer()\n-      != java::lang::Object::class$.vtable->get_finalizer())\n-    _Jv_RegisterFinalizer (obj, _Jv_FinalizeObject);\n-\n #ifdef ENABLE_JVMPI\n-  // Service JVMPI request.\n-\n+static void\n+jvmpi_notify_alloc(jclass klass, jint size, jobject obj)\n+{\n+  // Service JVMPI allocation request.\n   if (__builtin_expect (_Jv_JVMPI_Notify_OBJECT_ALLOC != 0, false))\n     {\n       JVMPI_Event event;\n@@ -384,8 +363,51 @@ _Jv_AllocObject (jclass klass, jint size)\n       (*_Jv_JVMPI_Notify_OBJECT_ALLOC) (&event);\n       _Jv_EnableGC ();\n     }\n+}\n+#else /* !ENABLE_JVMPI */\n+# define jvmpi_notify_alloc(klass,size,obj) /* do nothing */\n #endif\n \n+// Allocate a new object of class KLASS.  SIZE is the size of the object\n+// to allocate.  You might think this is redundant, but it isn't; some\n+// classes, such as String, aren't of fixed size.\n+// First a version that assumes that we have no finalizer, and that\n+// the class is already initialized.\n+// If we know that JVMPI is disabled, this can be replaced by a direct call\n+// to the allocator for the appropriate GC.\n+jobject\n+_Jv_AllocObjectNoInitNoFinalizer (jclass klass, jint size)\n+{\n+  jobject obj = (jobject) _Jv_AllocObj (size, klass);\n+  jvmpi_notify_alloc (klass, size, obj);\n+  return obj;\n+}\n+\n+// And now a version that initializes if necessary.\n+jobject\n+_Jv_AllocObjectNoFinalizer (jclass klass, jint size)\n+{\n+  _Jv_InitClass (klass);\n+  jobject obj = (jobject) _Jv_AllocObj (size, klass);\n+  jvmpi_notify_alloc (klass, size, obj);\n+  return obj;\n+}\n+\n+// And now the general version that registers a finalizer if necessary.\n+jobject\n+_Jv_AllocObject (jclass klass, jint size)\n+{\n+  jobject obj = _Jv_AllocObjectNoFinalizer (klass, size);\n+\n+  // We assume that the compiler only generates calls to this routine\n+  // if there really is an interesting finalizer.\n+  // Unfortunately, we still have to the dynamic test, since there may\n+  // be cni calls to this routine.\n+  // Nore that on IA64 get_finalizer() returns the starting address of the\n+  // function, not a function pointer.  Thus this still works.\n+  if (klass->vtable->get_finalizer ()\n+      != java::lang::Object::class$.vtable->get_finalizer ())\n+    _Jv_RegisterFinalizer (obj, _Jv_FinalizeObject);\n   return obj;\n }\n "}]}