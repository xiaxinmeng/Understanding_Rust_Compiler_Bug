{"sha": "12be91a78c9f6caadd4024d3af5bc468f9a32130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTJiZTkxYTc4YzlmNmNhYWRkNDAyNGQzYWY1YmM0NjhmOWEzMjEzMA==", "commit": {"author": {"name": "Sascha Brawer", "email": "brawer@dandelis.ch", "date": "2003-10-22T08:54:19Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-10-22T08:54:19Z"}, "message": "QuadCurve2D.java (subdivide): Added documentation.\n\n2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/QuadCurve2D.java (subdivide): Added documentation.\n\tjava/awt/geom/doc-files/QuadCurve2D-3.png: New illustration.\n\n2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/QuadCurve2D.java: Reformatted, wrote Javadoc.\n\t* java/awt/geom/doc-files: New directory.\n\t* java/awt/geom/doc-files/QuadCurve2D-1.png,\n\tjava/awt/geom/doc-files/QuadCurve2D-2.png: New illustrations.\n\n2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/QuadCurve2D.java (subdivide): Implement.\n\n2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n\n\t* java/awt/geom/QuadCurve2D.java (getFlatness, getFlatnessSq): Implement.\n\nFrom-SVN: r72791", "tree": {"sha": "472e7e8f647027bd65c3d8f75ebf3018a9def439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/472e7e8f647027bd65c3d8f75ebf3018a9def439"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/12be91a78c9f6caadd4024d3af5bc468f9a32130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12be91a78c9f6caadd4024d3af5bc468f9a32130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12be91a78c9f6caadd4024d3af5bc468f9a32130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12be91a78c9f6caadd4024d3af5bc468f9a32130/comments", "author": null, "committer": null, "parents": [{"sha": "8c754b9197ad1c39505a47854119f64276a4b22f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c754b9197ad1c39505a47854119f64276a4b22f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c754b9197ad1c39505a47854119f64276a4b22f"}], "stats": {"total": 799, "additions": 706, "deletions": 93}, "files": [{"sha": "1d3e7bbb01489c07551af64f7aa3ccc44da49934", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=12be91a78c9f6caadd4024d3af5bc468f9a32130", "patch": "@@ -1,3 +1,23 @@\n+2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/QuadCurve2D.java (subdivide): Added documentation.\n+\tjava/awt/geom/doc-files/QuadCurve2D-3.png: New illustration.\n+\n+2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/QuadCurve2D.java: Reformatted, wrote Javadoc.\n+\t* java/awt/geom/doc-files: New directory.\n+\t* java/awt/geom/doc-files/QuadCurve2D-1.png,\n+\tjava/awt/geom/doc-files/QuadCurve2D-2.png: New illustrations.\n+\t\n+2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/QuadCurve2D.java (subdivide): Implement.\n+\n+2003-10-22  Sascha Brawer  <brawer@dandelis.ch>\n+\n+\t* java/awt/geom/QuadCurve2D.java (getFlatness, getFlatnessSq): Implement.\n+\n 2003-10-22  Michael Koch  <konqueror@gmx.de>\n \n \t* java/io/File.java"}, {"sha": "e737ec1a4706217b782cf1901756ca0a14bc74a0", "filename": "libjava/java/awt/geom/QuadCurve2D.java", "status": "modified", "additions": 686, "deletions": 93, "changes": 779, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2FQuadCurve2D.java?ref=12be91a78c9f6caadd4024d3af5bc468f9a32130", "patch": "@@ -1,5 +1,5 @@\n /* QuadCurve2D.java -- represents a parameterized quadratic curve in 2-D space\n-   Copyright (C) 2002 Free Software Foundation\n+   Copyright (C) 2002, 2003 Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -42,290 +42,627 @@\n import java.awt.Shape;\n import java.util.NoSuchElementException;\n \n+\n /**\n- * STUBS ONLY\n- * XXX Implement and document.\n+ * A two-dimensional curve that is parameterized with a quadratic\n+ * function.\n+ *\n+ * <p><img src=\"doc-files/QuadCurve2D-1.png\" width=\"350\" height=\"180\"\n+ * alt=\"A drawing of a QuadCurve2D\" />\n+ *\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ *\n+ * @since 1.2\n  */\n-public abstract class QuadCurve2D implements Shape, Cloneable\n+public abstract class QuadCurve2D\n+  implements Shape, Cloneable\n {\n+  /**\n+   * Constructs a new QuadCurve2D. Typical users will want to\n+   * construct instances of a subclass, such as {@link\n+   * QuadCurve2D.Float} or {@link QuadCurve2D.Double}.\n+   */\n   protected QuadCurve2D()\n   {\n   }\n \n+\n+  /**\n+   * Returns the <i>x</i> coordinate of the curve&#x2019;s start\n+   * point.\n+   */\n   public abstract double getX1();\n+\n+\n+  /**\n+   * Returns the <i>y</i> coordinate of the curve&#x2019;s start\n+   * point.\n+   */\n   public abstract double getY1();\n+\n+\n+  /**\n+   * Returns the curve&#x2019;s start point.\n+   */\n   public abstract Point2D getP1();\n+\n+\n+  /**\n+   * Returns the <i>x</i> coordinate of the curve&#x2019;s control\n+   * point.\n+   */\n   public abstract double getCtrlX();\n+\n+\n+  /**\n+   * Returns the <i>y</i> coordinate of the curve&#x2019;s control\n+   * point.\n+   */\n   public abstract double getCtrlY();\n+\n+\n+  /**\n+   * Returns the curve&#x2019;s control point.\n+   */\n   public abstract Point2D getCtrlPt();\n+\n+\n+  /**\n+   * Returns the <i>x</i> coordinate of the curve&#x2019;s end\n+   * point.\n+   */\n   public abstract double getX2();\n+\n+\n+  /**\n+   * Returns the <i>y</i> coordinate of the curve&#x2019;s end\n+   * point.\n+   */\n   public abstract double getY2();\n+\n+\n+  /**\n+   * Returns the curve&#x2019;s end point.\n+   */\n   public abstract Point2D getP2();\n \n+\n+  /**\n+   * Changes the geometry of the curve.\n+   *\n+   * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new start\n+   * point.\n+   *\n+   * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new start\n+   * point.\n+   *\n+   * @param cx the <i>x</i> coordinate of the curve&#x2019;s new\n+   * control point.\n+   *\n+   * @param cy the <i>y</i> coordinate of the curve&#x2019;s new\n+   * control point.\n+   *\n+   * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new end\n+   * point.\n+   *\n+   * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new end\n+   * point.\n+   */\n   public abstract void setCurve(double x1, double y1, double cx, double cy,\n                                 double x2, double y2);\n+\n+\n   public void setCurve(double[] coords, int offset)\n   {\n     setCurve(coords[offset++], coords[offset++],\n              coords[offset++], coords[offset++],\n              coords[offset++], coords[offset++]);\n   }\n+\n+\n   public void setCurve(Point2D p1, Point2D c, Point2D p2)\n   {\n     setCurve(p1.getX(), p1.getY(), c.getX(), c.getY(),\n              p2.getX(), p2.getY());\n   }\n+\n+\n   public void setCurve(Point2D[] pts, int offset)\n   {\n     setCurve(pts[offset].getX(), pts[offset++].getY(),\n              pts[offset].getX(), pts[offset++].getY(),\n              pts[offset].getX(), pts[offset++].getY());\n   }\n+\n+\n+  /**\n+   * Changes the geometry of the curve to that of another curve.\n+   *\n+   * @param c the curve whose coordinates will be copied.\n+   */\n   public void setCurve(QuadCurve2D c)\n   {\n     setCurve(c.getX1(), c.getY1(), c.getCtrlX(), c.getCtrlY(),\n              c.getX2(), c.getY2());\n   }\n+\n+\n   public static double getFlatnessSq(double x1, double y1, double cx,\n                                      double cy, double x2, double y2)\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    return Line2D.ptSegDistSq(x1, y1, x2, y2, cx, cy);\n   }\n+\n+\n   public static double getFlatness(double x1, double y1, double cx, double cy,\n                                    double x2, double y2)\n   {\n-    return Math.sqrt(getFlatnessSq(x1, y1, cx, cy, x2, y2));\n+    return Line2D.ptSegDist(x1, y1, x2, y2, cx, cy);\n   }\n+\n+\n   public static double getFlatnessSq(double[] coords, int offset)\n   {\n-    return getFlatnessSq(coords[offset++], coords[offset++],\n-                         coords[offset++], coords[offset++],\n-                         coords[offset++], coords[offset++]);\n+    return Line2D.ptSegDistSq(coords[offset], coords[offset + 1],\n+                              coords[offset + 4], coords[offset + 5],\n+                              coords[offset + 2], coords[offset + 3]);\n   }\n+\n+\n   public static double getFlatness(double[] coords, int offset)\n   {\n-    return Math.sqrt(getFlatnessSq(coords[offset++], coords[offset++],\n-                                   coords[offset++], coords[offset++],\n-                                   coords[offset++], coords[offset++]));\n+    return Line2D.ptSegDist(coords[offset], coords[offset + 1],\n+                            coords[offset + 4], coords[offset + 5],\n+                            coords[offset + 2], coords[offset + 3]);\n   }\n+\n+\n   public double getFlatnessSq()\n   {\n-    return getFlatnessSq(getX1(), getY1(), getCtrlX(), getCtrlY(),\n-                         getX2(), getY2());\n+    return Line2D.ptSegDistSq(getX1(), getY1(),\n+                              getX2(), getY2(),\n+                              getCtrlX(), getCtrlY());\n   }\n+\n+\n   public double getFlatness()\n   {\n-    return Math.sqrt(getFlatnessSq(getX1(), getY1(), getCtrlX(), getCtrlY(),\n-                                   getX2(), getY2()));\n+    return Line2D.ptSegDist(getX1(), getY1(),\n+                            getX2(), getY2(),\n+                            getCtrlX(), getCtrlY());\n   }\n \n-  public void subdivide(QuadCurve2D l, QuadCurve2D r)\n+\n+  /**\n+   * Subdivides this curve into two halves.\n+   *\n+   * <p><img src=\"doc-files/QuadCurve2D-3.png\" width=\"700\"\n+   * height=\"180\" alt=\"A drawing that illustrates the effects of\n+   * subdividing a QuadCurve2D\" />\n+   *\n+   * @param left a curve whose geometry will be set to the left half\n+   * of this curve, or <code>null</code> if the caller is not\n+   * interested in the left half.\n+   *\n+   * @param right a curve whose geometry will be set to the right half\n+   * of this curve, or <code>null</code> if the caller is not\n+   * interested in the right half.\n+   */\n+  public void subdivide(QuadCurve2D left, QuadCurve2D right)\n   {\n-    if (l == null)\n-      l = new QuadCurve2D.Double();\n-    if (r == null)\n-      r = new QuadCurve2D.Double();\n     // Use empty slots at end to share single array.\n     double[] d = new double[] { getX1(), getY1(), getCtrlX(), getCtrlY(),\n                                 getX2(), getY2(), 0, 0, 0, 0 };\n     subdivide(d, 0, d, 0, d, 4);\n-    l.setCurve(d, 0);\n-    r.setCurve(d, 4);\n+    if (left != null)\n+      left.setCurve(d, 0);\n+    if (right != null)\n+      right.setCurve(d, 4);\n   }\n-  public static void subdivide(QuadCurve2D src, QuadCurve2D l, QuadCurve2D r)\n+\n+\n+  /**\n+   * Subdivides a quadratic curve into two halves.\n+   *\n+   * <p><img src=\"doc-files/QuadCurve2D-3.png\" width=\"700\"\n+   * height=\"180\" alt=\"A drawing that illustrates the effects of\n+   * subdividing a QuadCurve2D\" />\n+   *\n+   * @param src the curve to be subdivided.\n+   *\n+   * @param left a curve whose geometry will be set to the left half\n+   * of <code>src</code>, or <code>null</code> if the caller is not\n+   * interested in the left half.\n+   *\n+   * @param right a curve whose geometry will be set to the right half\n+   * of <code>src</code>, or <code>null</code> if the caller is not\n+   * interested in the right half.\n+   */\n+  public static void subdivide(QuadCurve2D src, QuadCurve2D left,\n+                               QuadCurve2D right)\n   {\n-    src.subdivide(l, r);\n+    src.subdivide(left, right);\n   }\n+\n+\n+  /**\n+   * Subdivides a quadratic curve into two halves, passing all\n+   * coordinates in an array.\n+   *\n+   * <p><img src=\"doc-files/QuadCurve2D-3.png\" width=\"700\"\n+   * height=\"180\" alt=\"A drawing that illustrates the effects of\n+   * subdividing a QuadCurve2D\" />\n+   *\n+   * <p>The left end point and the right start point will always be\n+   * identical. Memory-concious programmers thus may want to pass the\n+   * same array for both <code>left</code> and <code>right</code>, and\n+   * set <code>rightOff</code> to <code>leftOff + 4</code>.\n+   *\n+   * @param src an array containing the coordinates of the curve to be\n+   * subdivided.  The <i>x</i> coordinate of the start point is\n+   * located at <code>src[srcOff]</code>, its <i>y</i> at\n+   * <code>src[srcOff + 1]</code>.  The <i>x</i> coordinate of the\n+   * control point is located at <code>src[srcOff + 2]</code>, its\n+   * <i>y</i> at <code>src[srcOff + 3]</code>.  The <i>x</i>\n+   * coordinate of the end point is located at <code>src[srcOff +\n+   * 4]</code>, its <i>y</i> at <code>src[srcOff + 5]</code>.\n+   *\n+   * @param srcOff an offset into <code>src</code>, specifying\n+   * the index of the start point&#x2019;s <i>x</i> coordinate.\n+   *\n+   * @param left an array that will receive the coordinates of the\n+   * left half of <code>src</code>. It is acceptable to pass\n+   * <code>src</code>. A caller who is not interested in the left half\n+   * can pass <code>null</code>.\n+   *\n+   * @param leftOff an offset into <code>left</code>, specifying the\n+   * index where the start point&#x2019;s <i>x</i> coordinate will be\n+   * stored.\n+   *\n+   * @param right an array that will receive the coordinates of the\n+   * right half of <code>src</code>. It is acceptable to pass\n+   * <code>src</code> or <code>left</code>. A caller who is not\n+   * interested in the right half can pass <code>null</code>.\n+   *\n+   * @param rightOff an offset into <code>right</code>, specifying the\n+   * index where the start point&#x2019;s <i>x</i> coordinate will be\n+   * stored.\n+   */\n   public static void subdivide(double[] src, int srcOff,\n                                double[] left, int leftOff,\n                                double[] right, int rightOff)\n   {\n-    // XXX Implement.\n-    throw new Error(\"not implemented\");\n+    double x1, y1, xc, yc, x2, y2;\n+\n+    x1 = src[srcOff];\n+    y1 = src[srcOff + 1];\n+    xc = src[srcOff + 2];\n+    yc = src[srcOff + 3];\n+    x2 = src[srcOff + 4];\n+    y2 = src[srcOff + 5];\n+\n+    if (left != null)\n+    {\n+      left[leftOff] = x1;\n+      left[leftOff + 1] = y1;\n+    }\n+\n+    if (right != null)\n+    {\n+      right[rightOff + 4] = x2;\n+      right[rightOff + 5] = y2;\n+    }\n+\n+    x1 = (x1 + xc) / 2;\n+    x2 = (xc + x2) / 2;\n+    xc = (x1 + x2) / 2;\n+    y1 = (y1 + yc) / 2;\n+    y2 = (y2 + yc) / 2;\n+    yc = (y1 + y2) / 2;\n+\n+    if (left != null)\n+    {\n+      left[leftOff + 2] = x1;\n+      left[leftOff + 3] = y1;\n+      left[leftOff + 4] = xc;\n+      left[leftOff + 5] = yc;\n+    }\n+\n+    if (right != null)\n+    {\n+      right[rightOff] = xc;\n+      right[rightOff + 1] = yc;\n+      right[rightOff + 2] = x2;\n+      right[rightOff + 3] = y2;\n+    }\n   }\n+\n+\n   public static int solveQuadratic(double[] eqn)\n   {\n     return solveQuadratic(eqn, eqn);\n   }\n+\n+\n   public static int solveQuadratic(double[] eqn, double[] res)\n   {\n     double c = eqn[0];\n     double b = eqn[1];\n     double a = eqn[2];\n     if (a == 0)\n-      {\n-        if (b == 0)\n-          return -1;\n-        res[0] = -c / b;\n-        return 1;\n-      }\n+    {\n+      if (b == 0)\n+        return -1;\n+      res[0] = -c / b;\n+      return 1;\n+    }\n     c /= a;\n     b /= a * 2;\n     double det = Math.sqrt(b * b - c);\n     if (det != det)\n       return 0;\n     // For fewer rounding errors, we calculate the two roots differently.\n     if (b > 0)\n-      {\n-        res[0] = -b - det;\n-        res[1] = -c / (b + det);\n-      }\n+    {\n+      res[0] = -b - det;\n+      res[1] = -c / (b + det);\n+    }\n     else\n-      {\n-        res[0] = -c / (b - det);\n-        res[1] = -b + det;\n-      }\n+    {\n+      res[0] = -c / (b - det);\n+      res[1] = -b + det;\n+    }\n     return 2;\n   }\n \n+\n   public boolean contains(double x, double y)\n   {\n     // XXX Implement.\n     throw new Error(\"not implemented\");\n   }\n+\n+\n   public boolean contains(Point2D p)\n   {\n     return contains(p.getX(), p.getY());\n   }\n+\n+\n   public boolean intersects(double x, double y, double w, double h)\n   {\n     // XXX Implement.\n     throw new Error(\"not implemented\");\n   }\n+\n+\n   public boolean intersects(Rectangle2D r)\n   {\n     return intersects(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n   }\n+\n+\n   public boolean contains(double x, double y, double w, double h)\n   {\n     // XXX Implement.\n     throw new Error(\"not implemented\");\n   }\n+\n+\n   public boolean contains(Rectangle2D r)\n   {\n     return contains(r.getX(), r.getY(), r.getWidth(), r.getHeight());\n   }\n+\n+\n+  /**\n+   * Determines the smallest rectangle that encloses the\n+   * curve&#x2019;s start, end and control point. As the illustration\n+   * below shows, the invisible control point may cause the bounds to\n+   * be much larger than the area that is actually covered by the\n+   * curve.\n+   *\n+   * <p><img src=\"doc-files/QuadCurve2D-2.png\" width=\"350\" height=\"180\"\n+   * alt=\"An illustration of the bounds of a QuadCurve2D\" />\n+   */\n   public Rectangle getBounds()\n   {\n     return getBounds2D().getBounds();\n   }\n+\n+\n   public PathIterator getPathIterator(final AffineTransform at)\n   {\n     return new PathIterator()\n     {\n       /** Current coordinate. */\n       private int current = 0;\n \n+\n       public int getWindingRule()\n       {\n         return WIND_NON_ZERO;\n       }\n \n+\n       public boolean isDone()\n       {\n         return current >= 2;\n       }\n \n+\n       public void next()\n       {\n         current++;\n       }\n \n+\n       public int currentSegment(float[] coords)\n       {\n         int result;\n         switch (current)\n-          {\n-          case 0:\n-            coords[0] = (float) getX1();\n-            coords[1] = (float) getY1();\n-            result = SEG_MOVETO;\n-            break;\n-          case 1:\n-            coords[0] = (float) getCtrlX();\n-            coords[1] = (float) getCtrlY();\n-            coords[2] = (float) getX2();\n-            coords[3] = (float) getY2();\n-            result = SEG_QUADTO;\n-            break;\n-          default:\n-            throw new NoSuchElementException(\"quad iterator out of bounds\");\n-          }\n+        {\n+        case 0:\n+          coords[0] = (float) getX1();\n+          coords[1] = (float) getY1();\n+          result = SEG_MOVETO;\n+          break;\n+\n+        case 1:\n+          coords[0] = (float) getCtrlX();\n+          coords[1] = (float) getCtrlY();\n+          coords[2] = (float) getX2();\n+          coords[3] = (float) getY2();\n+          result = SEG_QUADTO;\n+          break;\n+\n+        default:\n+          throw new NoSuchElementException(\"quad iterator out of bounds\");\n+        }\n         if (at != null)\n           at.transform(coords, 0, coords, 0, 2);\n         return result;\n       }\n \n+\n       public int currentSegment(double[] coords)\n       {\n         int result;\n         switch (current)\n-          {\n-          case 0:\n-            coords[0] = getX1();\n-            coords[1] = getY1();\n-            result = SEG_MOVETO;\n-            break;\n-          case 1:\n-            coords[0] = getCtrlX();\n-            coords[1] = getCtrlY();\n-            coords[2] = getX2();\n-            coords[3] = getY2();\n-            result = SEG_QUADTO;\n-            break;\n-          default:\n-            throw new NoSuchElementException(\"quad iterator out of bounds\");\n-          }\n+        {\n+        case 0:\n+          coords[0] = getX1();\n+          coords[1] = getY1();\n+          result = SEG_MOVETO;\n+          break;\n+\n+        case 1:\n+          coords[0] = getCtrlX();\n+          coords[1] = getCtrlY();\n+          coords[2] = getX2();\n+          coords[3] = getY2();\n+          result = SEG_QUADTO;\n+          break;\n+\n+        default:\n+          throw new NoSuchElementException(\"quad iterator out of bounds\");\n+        }\n         if (at != null)\n           at.transform(coords, 0, coords, 0, 2);\n         return result;\n       }\n     };\n   }\n+\n+\n   public PathIterator getPathIterator(AffineTransform at, double flatness)\n   {\n     return new FlatteningPathIterator(getPathIterator(at), flatness);\n   }\n \n+\n   /**\n-   * Create a new curve of the same run-time type with the same contents as\n+   * Creates a new curve with the same contents as\n    * this one.\n    *\n-   * @return the clone\n-   *\n-   * @exception OutOfMemoryError If there is not enough memory available.\n-   *\n-   * @since 1.2\n+   * @return the clone.\n    */\n   public Object clone()\n   {\n     try\n-      {\n-        return super.clone();\n-      }\n+    {\n+      return super.clone();\n+    }\n     catch (CloneNotSupportedException e)\n-      {\n-        throw (Error) new InternalError().initCause(e); // Impossible\n-      }\n+    {\n+      throw (Error) new InternalError().initCause(e); // Impossible\n+    }\n   }\n \n+\n   /**\n-   * STUBS ONLY\n+   * A two-dimensional curve that is parameterized with a quadratic\n+   * function and stores coordinate values in double-precision\n+   * floating-point format.\n+   *\n+   * @see QuadCurve2D.Float\n+   *\n+   * @author Eric Blake (ebb9@email.byu.edu)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n    */\n-  public static class Double extends QuadCurve2D\n+  public static class Double\n+    extends QuadCurve2D\n   {\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s start point.\n+     */\n     public double x1;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s start point.\n+     */\n     public double y1;\n+\n+\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s control point.\n+     */\n     public double ctrlx;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s control point.\n+     */\n     public double ctrly;\n+\n+\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s end point.\n+     */\n     public double x2;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s end point.\n+     */\n     public double y2;\n \n+\n+    /**\n+     * Constructs a new QuadCurve2D that stores its coordinate values\n+     * in double-precision floating-point format. All points are\n+     * initially at position (0, 0).\n+     */\n     public Double()\n     {\n     }\n \n+\n+    /**\n+     * Constructs a new QuadCurve2D that stores its coordinate values\n+     * in double-precision floating-point format, specifying the\n+     * initial position of each point.\n+     *\n+     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     *\n+     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     *\n+     * @param cx the <i>x</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     *\n+     * @param cy the <i>y</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     *\n+     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     *\n+     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public Double(double x1, double y1, double cx, double cy,\n                   double x2, double y2)\n     {\n@@ -337,45 +674,115 @@ public Double(double x1, double y1, double cx, double cy,\n       this.y2 = y2;\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     */\n     public double getX1()\n     {\n       return x1;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     */\n     public double getY1()\n     {\n       return y1;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s start point.\n+     */\n     public Point2D getP1()\n     {\n       return new Point2D.Double(x1, y1);\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     */\n     public double getCtrlX()\n     {\n       return ctrlx;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     */\n     public double getCtrlY()\n     {\n       return ctrly;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s control point.\n+     */\n     public Point2D getCtrlPt()\n     {\n       return new Point2D.Double(ctrlx, ctrly);\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public double getX2()\n     {\n       return x2;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public double getY2()\n     {\n       return y2;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s end point.\n+     */\n     public Point2D getP2()\n     {\n       return new Point2D.Double(x2, y2);\n     }\n \n+\n+    /**\n+     * Changes the geometry of the curve.\n+     *\n+     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     *\n+     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     */\n     public void setCurve(double x1, double y1, double cx, double cy,\n                          double x2, double y2)\n     {\n@@ -386,6 +793,18 @@ public void setCurve(double x1, double y1, double cx, double cy,\n       this.x2 = x2;\n       this.y2 = y2;\n     }\n+\n+\n+    /**\n+     * Determines the smallest rectangle that encloses the\n+     * curve&#x2019;s start, end and control point. As the\n+     * illustration below shows, the invisible control point may cause\n+     * the bounds to be much larger than the area that is actually\n+     * covered by the curve.\n+     *\n+     * <p><img src=\"doc-files/QuadCurve2D-2.png\" width=\"350\" height=\"180\"\n+     * alt=\"An illustration of the bounds of a QuadCurve2D\" />\n+     */\n     public Rectangle2D getBounds2D()\n     {\n       double nx1 = Math.min(Math.min(x1, ctrlx), x2);\n@@ -394,24 +813,91 @@ public Rectangle2D getBounds2D()\n       double ny2 = Math.max(Math.max(y1, ctrly), y2);\n       return new Rectangle2D.Double(nx1, ny1, nx2 - nx1, ny2 - ny1);\n     }\n-  } // class Double\n+  }\n+\n \n   /**\n-   * STUBS ONLY\n+   * A two-dimensional curve that is parameterized with a quadratic\n+   * function and stores coordinate values in single-precision\n+   * floating-point format.\n+   *\n+   * @see QuadCurve2D.Double\n+   *\n+   * @author Eric Blake (ebb9@email.byu.edu)\n+   * @author Sascha Brawer (brawer@dandelis.ch)\n    */\n-  public static class Float extends QuadCurve2D\n+  public static class Float\n+    extends QuadCurve2D\n   {\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s start point.\n+     */\n     public float x1;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s start point.\n+     */\n     public float y1;\n+\n+\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s control point.\n+     */\n     public float ctrlx;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s control point.\n+     */\n     public float ctrly;\n+\n+\n+    /**\n+     * The <i>x</i> coordinate of the curve&#x2019;s end point.\n+     */\n     public float x2;\n+\n+\n+    /**\n+     * The <i>y</i> coordinate of the curve&#x2019;s end point.\n+     */\n     public float y2;\n \n+\n+    /**\n+     * Constructs a new QuadCurve2D that stores its coordinate values\n+     * in single-precision floating-point format. All points are\n+     * initially at position (0, 0).\n+     */\n     public Float()\n     {\n     }\n \n+\n+    /**\n+     * Constructs a new QuadCurve2D that stores its coordinate values\n+     * in single-precision floating-point format, specifying the\n+     * initial position of each point.\n+     *\n+     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     *\n+     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     *\n+     * @param cx the <i>x</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     *\n+     * @param cy the <i>y</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     *\n+     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     *\n+     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public Float(float x1, float y1, float cx, float cy,\n                  float x2, float y2)\n     {\n@@ -423,45 +909,116 @@ public Float(float x1, float y1, float cx, float cy,\n       this.y2 = y2;\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     */\n     public double getX1()\n     {\n       return x1;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s start\n+     * point.\n+     */\n     public double getY1()\n     {\n       return y1;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s start point.\n+     */\n     public Point2D getP1()\n     {\n       return new Point2D.Float(x1, y1);\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     */\n     public double getCtrlX()\n     {\n       return ctrlx;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s control\n+     * point.\n+     */\n     public double getCtrlY()\n     {\n       return ctrly;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s control point.\n+     */\n     public Point2D getCtrlPt()\n     {\n       return new Point2D.Float(ctrlx, ctrly);\n     }\n \n+\n+    /**\n+     * Returns the <i>x</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public double getX2()\n     {\n       return x2;\n     }\n+\n+\n+    /**\n+     * Returns the <i>y</i> coordinate of the curve&#x2019;s end\n+     * point.\n+     */\n     public double getY2()\n     {\n       return y2;\n     }\n+\n+\n+    /**\n+     * Returns the curve&#x2019;s end point.\n+     */\n     public Point2D getP2()\n     {\n       return new Point2D.Float(x2, y2);\n     }\n \n+\n+    /**\n+     * Changes the geometry of the curve, specifying coordinate values\n+     * as double-precision floating-point numbers.\n+     *\n+     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     *\n+     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     */\n     public void setCurve(double x1, double y1, double cx, double cy,\n                          double x2, double y2)\n     {\n@@ -472,6 +1029,30 @@ public void setCurve(double x1, double y1, double cx, double cy,\n       this.x2 = (float) x2;\n       this.y2 = (float) y2;\n     }\n+\n+\n+    /**\n+     * Changes the geometry of the curve, specifying coordinate values\n+     * as single-precision floating-point numbers.\n+     *\n+     * @param x1 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param y1 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * start point.\n+     *\n+     * @param cx the <i>x</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param cy the <i>y</i> coordinate of the curve&#x2019;s new\n+     * control point.\n+     *\n+     * @param x2 the <i>x</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     *\n+     * @param y2 the <i>y</i> coordinate of the curve&#x2019;s new\n+     * end point.\n+     */\n     public void setCurve(float x1, float y1, float cx, float cy,\n                          float x2, float y2)\n     {\n@@ -482,6 +1063,18 @@ public void setCurve(float x1, float y1, float cx, float cy,\n       this.x2 = x2;\n       this.y2 = y2;\n     }\n+\n+\n+    /**\n+     * Determines the smallest rectangle that encloses the\n+     * curve&#x2019;s start, end and control point. As the\n+     * illustration below shows, the invisible control point may cause\n+     * the bounds to be much larger than the area that is actually\n+     * covered by the curve.\n+     *\n+     * <p><img src=\"doc-files/QuadCurve2D-2.png\" width=\"350\" height=\"180\"\n+     * alt=\"An illustration of the bounds of a QuadCurve2D\" />\n+     */\n     public Rectangle2D getBounds2D()\n     {\n       float nx1 = (float) Math.min(Math.min(x1, ctrlx), x2);\n@@ -490,5 +1083,5 @@ public Rectangle2D getBounds2D()\n       float ny2 = (float) Math.max(Math.max(y1, ctrly), y2);\n       return new Rectangle2D.Float(nx1, ny1, nx2 - nx1, ny2 - ny1);\n     }\n-  } // class Float\n-} // class CubicCurve2D\n+  }\n+}"}, {"sha": "7c2ec0ea9cbc4bb0516c12cd357ba63b0aa27404", "filename": "libjava/java/awt/geom/doc-files/QuadCurve2D-1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-1.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-1.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-1.png?ref=12be91a78c9f6caadd4024d3af5bc468f9a32130"}, {"sha": "496180c44746f3f265dbd03b606064e07998a58f", "filename": "libjava/java/awt/geom/doc-files/QuadCurve2D-2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-2.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-2.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-2.png?ref=12be91a78c9f6caadd4024d3af5bc468f9a32130"}, {"sha": "a7557ba7bafd1b658aedf94074fb6307083c1c1f", "filename": "libjava/java/awt/geom/doc-files/QuadCurve2D-3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-3.png", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/12be91a78c9f6caadd4024d3af5bc468f9a32130/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-3.png", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fawt%2Fgeom%2Fdoc-files%2FQuadCurve2D-3.png?ref=12be91a78c9f6caadd4024d3af5bc468f9a32130"}]}