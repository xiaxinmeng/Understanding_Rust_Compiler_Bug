{"sha": "e987fb1ebecc7494f9869071e487deef70a792f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk4N2ZiMWViZWNjNzQ5NGY5ODY5MDcxZTQ4N2RlZWY3MGE3OTJmNg==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2018-11-23T18:17:04Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2018-11-23T18:17:04Z"}, "message": "Implement P0415 More constexpr for std::complex.\n\n\n2018-11-23  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tImplement P0415 More constexpr for std::complex.\n\t* include/std/complex (conj(complex<Tp>), norm(complex<Tp>)): Constexpr;\n\t(real(Tp), imag(Tp)): Constexpr;\n\t(operator@=(Tp), operator@=(complex<Tp>)): Constexpr;\n\t(operator@(Tp,complex<Tp>), operator@(complex<Tp>,Tp)\n\toperator@(complex<Tp>,complex<Tp>)): Constexpr.\n\t* testsuite/26_numerics/complex/comparison_operators/\n\tmore_constexpr.cc: New test.\n\t* testsuite/26_numerics/complex/operators/more_constexpr.cc: New test.\n\t* testsuite/26_numerics/complex/requirements/\n\tmore_constexpr.cc: New test.\n\t* testsuite/26_numerics/complex/value_operations/\n\tmore_constexpr.cc: New test.\n\t* testsuite/26_numerics/headers/complex/synopsis.cc:\n\tAdd _GLIBCXX20_CONSTEXPR to applicable operators; Add missing proj().\n\t* testsuite/26_numerics/headers/complex/synopsis.cc:\n\tAdd _GLIBCXX20_CONSTEXPR to relevant decls.\n\nFrom-SVN: r266416", "tree": {"sha": "d0291d3e39a50cd2ebfd7625833e1b8c288ad0e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0291d3e39a50cd2ebfd7625833e1b8c288ad0e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e987fb1ebecc7494f9869071e487deef70a792f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e987fb1ebecc7494f9869071e487deef70a792f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e987fb1ebecc7494f9869071e487deef70a792f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e987fb1ebecc7494f9869071e487deef70a792f6/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e02669dbdf1d1099710dbc515f07d0b4785ae2fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e02669dbdf1d1099710dbc515f07d0b4785ae2fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e02669dbdf1d1099710dbc515f07d0b4785ae2fd"}], "stats": {"total": 678, "additions": 524, "deletions": 154}, "files": [{"sha": "24351cb7ad514bc21cc35a676a4d7ee745e5d0e7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -1,3 +1,23 @@\n+2018-11-23  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tImplement P0415 More constexpr for std::complex.\n+\t* include/std/complex (conj(complex<Tp>), norm(complex<Tp>)): Constexpr;\n+\t(real(Tp), imag(Tp)): Constexpr;\n+\t(operator@=(Tp), operator@=(complex<Tp>)): Constexpr;\n+\t(operator@(Tp,complex<Tp>), operator@(complex<Tp>,Tp)\n+\toperator@(complex<Tp>,complex<Tp>)): Constexpr.\n+\t* testsuite/26_numerics/complex/comparison_operators/\n+\tmore_constexpr.cc: New test.\n+\t* testsuite/26_numerics/complex/operators/more_constexpr.cc: New test.\n+\t* testsuite/26_numerics/complex/requirements/\n+\tmore_constexpr.cc: New test.\n+\t* testsuite/26_numerics/complex/value_operations/\n+\tmore_constexpr.cc: New test.\n+\t* testsuite/26_numerics/headers/complex/synopsis.cc:\n+\tAdd _GLIBCXX20_CONSTEXPR to applicable operators; Add missing proj().\n+\t* testsuite/26_numerics/headers/complex/synopsis.cc: \n+\tAdd _GLIBCXX20_CONSTEXPR to relevant decls.\n+\n 2018-11-23  Martin Sebor  <msebor@redhat.com>\n \t    Jonathan Wakely  <jwakely@redhat.com>\n "}, {"sha": "b30346203b163651d49d582b29966320b38e6ca5", "filename": "libstdc++-v3/include/std/complex", "status": "modified", "additions": 105, "deletions": 119, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcomplex?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -70,10 +70,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   ///  Return phase angle of @a z.\n   template<typename _Tp> _Tp arg(const complex<_Tp>&);\n   ///  Return @a z magnitude squared.\n-  template<typename _Tp> _Tp norm(const complex<_Tp>&);\n+  template<typename _Tp> _Tp _GLIBCXX20_CONSTEXPR norm(const complex<_Tp>&);\n \n   ///  Return complex conjugate of @a z.\n-  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);\n+  template<typename _Tp>\n+    _GLIBCXX20_CONSTEXPR complex<_Tp> conj(const complex<_Tp>&);\n   ///  Return complex with magnitude @a rho and angle @a theta.\n   template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);\n \n@@ -169,18 +170,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       real(_Tp __val) { _M_real = __val; }\n \n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       imag(_Tp __val) { _M_imag = __val; }\n \n       /// Assign a scalar to this complex number.\n-      complex<_Tp>& operator=(const _Tp&);\n+      _GLIBCXX20_CONSTEXPR complex<_Tp>& operator=(const _Tp&);\n \n       /// Add a scalar to this complex number.\n       // 26.2.5/1\n-      complex<_Tp>&\n+      _GLIBCXX20_CONSTEXPR complex<_Tp>&\n       operator+=(const _Tp& __t)\n       {\n \t_M_real += __t;\n@@ -189,38 +190,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       /// Subtract a scalar from this complex number.\n       // 26.2.5/3\n-      complex<_Tp>&\n+      _GLIBCXX20_CONSTEXPR complex<_Tp>&\n       operator-=(const _Tp& __t)\n       {\n \t_M_real -= __t;\n \treturn *this;\n       }\n \n       /// Multiply this complex number by a scalar.\n-      complex<_Tp>& operator*=(const _Tp&);\n+      _GLIBCXX20_CONSTEXPR complex<_Tp>& operator*=(const _Tp&);\n       /// Divide this complex number by a scalar.\n-      complex<_Tp>& operator/=(const _Tp&);\n+      _GLIBCXX20_CONSTEXPR complex<_Tp>& operator/=(const _Tp&);\n \n       // Let the compiler synthesize the copy assignment operator\n #if __cplusplus >= 201103L\n-      complex& operator=(const complex&) = default;\n+      _GLIBCXX20_CONSTEXPR complex& operator=(const complex&) = default;\n #endif\n \n       /// Assign another complex number to this one.\n       template<typename _Up>\n-        complex<_Tp>& operator=(const complex<_Up>&);\n+        _GLIBCXX20_CONSTEXPR complex<_Tp>& operator=(const complex<_Up>&);\n       /// Add another complex number to this one.\n       template<typename _Up>\n-        complex<_Tp>& operator+=(const complex<_Up>&);\n+        _GLIBCXX20_CONSTEXPR complex<_Tp>& operator+=(const complex<_Up>&);\n       /// Subtract another complex number from this one.\n       template<typename _Up>\n-        complex<_Tp>& operator-=(const complex<_Up>&);\n+        _GLIBCXX20_CONSTEXPR complex<_Tp>& operator-=(const complex<_Up>&);\n       /// Multiply this complex number by another.\n       template<typename _Up>\n-        complex<_Tp>& operator*=(const complex<_Up>&);\n+        _GLIBCXX20_CONSTEXPR complex<_Tp>& operator*=(const complex<_Up>&);\n       /// Divide this complex number by another.\n       template<typename _Up>\n-        complex<_Tp>& operator/=(const complex<_Up>&);\n+        _GLIBCXX20_CONSTEXPR complex<_Tp>& operator/=(const complex<_Up>&);\n \n       _GLIBCXX_CONSTEXPR complex __rep() const\n       { return *this; }\n@@ -231,7 +232,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Tp>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator=(const _Tp& __t)\n     {\n      _M_real = __t;\n@@ -241,7 +242,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // 26.2.5/5\n   template<typename _Tp>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator*=(const _Tp& __t)\n     {\n       _M_real *= __t;\n@@ -251,7 +252,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // 26.2.5/7\n   template<typename _Tp>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator/=(const _Tp& __t)\n     {\n       _M_real /= __t;\n@@ -261,7 +262,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Tp>\n     template<typename _Up>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator=(const complex<_Up>& __z)\n     {\n       _M_real = __z.real();\n@@ -272,7 +273,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // 26.2.5/9\n   template<typename _Tp>\n     template<typename _Up>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator+=(const complex<_Up>& __z)\n     {\n       _M_real += __z.real();\n@@ -283,7 +284,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // 26.2.5/11\n   template<typename _Tp>\n     template<typename _Up>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator-=(const complex<_Up>& __z)\n     {\n       _M_real -= __z.real();\n@@ -295,7 +296,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // XXX: This is a grammar school implementation.\n   template<typename _Tp>\n     template<typename _Up>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator*=(const complex<_Up>& __z)\n     {\n       const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();\n@@ -308,7 +309,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // XXX: This is a grammar school implementation.\n   template<typename _Tp>\n     template<typename _Up>\n-    complex<_Tp>&\n+    _GLIBCXX20_CONSTEXPR complex<_Tp>&\n     complex<_Tp>::operator/=(const complex<_Up>& __z)\n     {\n       const _Tp __r =  _M_real * __z.real() + _M_imag * __z.imag();\n@@ -322,7 +323,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //@{\n   ///  Return new complex value @a x plus @a y.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -331,7 +332,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator+(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -340,7 +341,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator+(const _Tp& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __y;\n@@ -352,7 +353,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //@{\n   ///  Return new complex value @a x minus @a y.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -361,7 +362,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator-(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -370,19 +371,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator-(const _Tp& __x, const complex<_Tp>& __y)\n     {\n-      complex<_Tp> __r(__x, -__y.imag());\n-      __r -= __y.real();\n+      complex<_Tp> __r = -__y;\n+      __r += __x;\n       return __r;\n     }\n   //@}\n \n   //@{\n   ///  Return new complex value @a x times @a y.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -391,7 +392,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator*(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -400,7 +401,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator*(const _Tp& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __y;\n@@ -412,7 +413,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   //@{\n   ///  Return new complex value @a x divided by @a y.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -421,7 +422,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator/(const complex<_Tp>& __x, const _Tp& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -430,7 +431,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator/(const _Tp& __x, const complex<_Tp>& __y)\n     {\n       complex<_Tp> __r = __x;\n@@ -441,15 +442,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   ///  Return @a x.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator+(const complex<_Tp>& __x)\n     { return __x; }\n \n   ///  Return complex negation of @a x.\n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     operator-(const complex<_Tp>& __x)\n-    {  return complex<_Tp>(-__x.real(), -__x.imag()); }\n+    { return complex<_Tp>(-__x.real(), -__x.imag()); }\n \n   //@{\n   ///  Return true if @a x is equal to @a y.\n@@ -658,7 +659,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Norm_helper\n     {\n       template<typename _Tp>\n-        static inline _Tp _S_do_it(const complex<_Tp>& __z)\n+        static inline _GLIBCXX_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n         {\n           const _Tp __x = __z.real();\n           const _Tp __y = __z.imag();\n@@ -670,15 +671,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct _Norm_helper<true>\n     {\n       template<typename _Tp>\n-        static inline _Tp _S_do_it(const complex<_Tp>& __z)\n+        static inline _GLIBCXX_CONSTEXPR _Tp _S_do_it(const complex<_Tp>& __z)\n         {\n-          _Tp __res = std::abs(__z);\n-          return __res * __res;\n+          //_Tp __res = std::abs(__z);\n+          //return __res * __res;\n+          const _Tp __x = __z.real();\n+          const _Tp __y = __z.imag();\n+          return __x * __x + __y * __y;\n         }\n     };\n \n   template<typename _Tp>\n-    inline _Tp\n+    inline _GLIBCXX20_CONSTEXPR _Tp\n     norm(const complex<_Tp>& __z)\n     {\n       return _Norm_helper<__is_floating<_Tp>::__value\n@@ -694,7 +698,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline complex<_Tp>\n+    inline _GLIBCXX20_CONSTEXPR complex<_Tp>\n     conj(const complex<_Tp>& __z)\n     { return complex<_Tp>(__z.real(), -__z.imag()); }\n \n@@ -1115,41 +1119,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       real(float __val) { __real__ _M_value = __val; }\n \n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       imag(float __val) { __imag__ _M_value = __val; }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator=(float __f)\n       {\n \t_M_value = __f;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator+=(float __f)\n       {\n \t_M_value += __f;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator-=(float __f)\n       {\n \t_M_value -= __f;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator*=(float __f)\n       {\n \t_M_value *= __f;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator/=(float __f)\n       {\n \t_M_value /= __f;\n@@ -1163,7 +1167,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator=(const complex<_Tp>&  __z)\n \t{\n \t  __real__ _M_value = __z.real();\n@@ -1172,41 +1176,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator+=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value += __z.real();\n-\t  __imag__ _M_value += __z.imag();\n+\t  _M_value += __z.__rep();\n \t  return *this;\n \t}\n \n       template<class _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator-=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value -= __z.real();\n-\t  __imag__ _M_value -= __z.imag();\n+\t  _M_value -= __z.__rep();\n \t  return *this;\n \t}\n \n       template<class _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator*=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value *= __t;\n \t  return *this;\n \t}\n \n       template<class _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator/=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value /= __t;\n \t  return *this;\n \t}\n@@ -1268,41 +1266,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       real(double __val) { __real__ _M_value = __val; }\n \n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       imag(double __val) { __imag__ _M_value = __val; }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator=(double __d)\n       {\n \t_M_value = __d;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator+=(double __d)\n       {\n \t_M_value += __d;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator-=(double __d)\n       {\n \t_M_value -= __d;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator*=(double __d)\n       {\n \t_M_value *= __d;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator/=(double __d)\n       {\n \t_M_value /= __d;\n@@ -1315,50 +1313,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value = __z.real();\n-\t  __imag__ _M_value = __z.imag();\n+\t  _M_value = __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator+=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value += __z.real();\n-\t  __imag__ _M_value += __z.imag();\n+\t  _M_value += __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator-=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value -= __z.real();\n-\t  __imag__ _M_value -= __z.imag();\n+\t  _M_value -= __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator*=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value *= __t;\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator/=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value /= __t;\n \t  return *this;\n \t}\n@@ -1422,41 +1413,41 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 387. std::complex over-encapsulated.\n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       real(long double __val) { __real__ _M_value = __val; }\n \n-      void\n+      _GLIBCXX20_CONSTEXPR void\n       imag(long double __val) { __imag__ _M_value = __val; }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator=(long double __r)\n       {\n \t_M_value = __r;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator+=(long double __r)\n       {\n \t_M_value += __r;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator-=(long double __r)\n       {\n \t_M_value -= __r;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator*=(long double __r)\n       {\n \t_M_value *= __r;\n \treturn *this;\n       }\n \n-      complex&\n+      _GLIBCXX20_CONSTEXPR complex&\n       operator/=(long double __r)\n       {\n \t_M_value /= __r;\n@@ -1469,50 +1460,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n         operator=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value = __z.real();\n-\t  __imag__ _M_value = __z.imag();\n+\t  _M_value = __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n \toperator+=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value += __z.real();\n-\t  __imag__ _M_value += __z.imag();\n+\t  _M_value += __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n \toperator-=(const complex<_Tp>& __z)\n \t{\n-\t  __real__ _M_value -= __z.real();\n-\t  __imag__ _M_value -= __z.imag();\n+\t  _M_value -= __z.__rep();\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n \toperator*=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value *= __t;\n \t  return *this;\n \t}\n \n       template<typename _Tp>\n-        complex&\n+        _GLIBCXX20_CONSTEXPR complex&\n \toperator/=(const complex<_Tp>& __z)\n \t{\n-\t  _ComplexT __t;\n-\t  __real__ __t = __z.real();\n-\t  __imag__ __t = __z.imag();\n+\t  const _ComplexT __t = __z.__rep();\n \t  _M_value /= __t;\n \t  return *this;\n \t}\n@@ -1872,7 +1856,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { return _Tp(); }\n \n   template<typename _Tp>\n-    inline typename __gnu_cxx::__promote<_Tp>::__type\n+    _GLIBCXX20_CONSTEXPR inline typename __gnu_cxx::__promote<_Tp>::__type\n     norm(_Tp __x)\n     {\n       typedef typename __gnu_cxx::__promote<_Tp>::__type __type;\n@@ -1911,7 +1895,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Forward declarations.\n   // DR 781.\n-  template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);\n+  template<typename _Tp>\n+    std::complex<_Tp> proj(const std::complex<_Tp>&);\n \n   template<typename _Tp>\n     std::complex<_Tp>\n@@ -1957,7 +1942,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   template<typename _Tp>\n-    inline std::complex<typename __gnu_cxx::__promote<_Tp>::__type>\n+    inline _GLIBCXX20_CONSTEXPR\n+\tstd::complex<typename __gnu_cxx::__promote<_Tp>::__type>\n     conj(_Tp __x)\n     {\n       typedef typename __gnu_cxx::__promote<_Tp>::__type __type;"}, {"sha": "6dc90da78da235e947eb36a70c39f34eb0f3918c", "filename": "libstdc++-v3/testsuite/26_numerics/complex/comparison_operators/more_constexpr.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcomparison_operators%2Fmore_constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcomparison_operators%2Fmore_constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fcomparison_operators%2Fmore_constexpr.cc?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+template<bool ok>\n+  struct thing\n+  { };\n+\n+// \n+template<typename _Tp>\n+  void\n+  test_comparison()\n+  {\n+    constexpr std::complex<_Tp> a{1.1, 2.2};\n+    constexpr std::complex<_Tp> b{3.3, 4.4};\n+    if constexpr (a == b)\n+      auto c [[maybe_unused]] = a + b;\n+    if constexpr (a != b)\n+      auto c [[maybe_unused]] = a - b;\n+\n+    thing<a == b> thing1 [[maybe_unused]];\n+    thing<a != b> thing2 [[maybe_unused]];\n+  }\n+\n+int\n+main()\n+{\n+  test_comparison<float>();\n+  test_comparison<double>();\n+  test_comparison<long double>();\n+\n+  return 0;\n+}"}, {"sha": "a6571559f7011b324c9e8c2e4b583156fb52b561", "filename": "libstdc++-v3/testsuite/26_numerics/complex/operators/more_constexpr.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Foperators%2Fmore_constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Foperators%2Fmore_constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Foperators%2Fmore_constexpr.cc?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -0,0 +1,62 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  // Test constexpr symmetric complex @ real, real @ complex, complex @ complex.\n+  template<typename _Tp>\n+    void\n+    test_operators()\n+    {\n+      constexpr std::complex<_Tp> a{1, 2};\n+      constexpr std::complex<_Tp> b{3, 4};\n+      constexpr _Tp c = 5;\n+\n+      constexpr auto w [[maybe_unused]] = +a;\n+      constexpr auto z [[maybe_unused]] = -a;\n+\n+      constexpr auto apc [[maybe_unused]] = a + c;\n+      constexpr auto amc [[maybe_unused]] = a - c;\n+      constexpr auto atc [[maybe_unused]] = a * c;\n+      constexpr auto adc [[maybe_unused]] = a / c;\n+\n+      constexpr auto cpa [[maybe_unused]] = c + a;\n+      constexpr auto cma [[maybe_unused]] = c - a;\n+      constexpr auto cta [[maybe_unused]] = c * a;\n+      constexpr auto cda [[maybe_unused]] = c / a;\n+\n+      constexpr auto apb [[maybe_unused]] = a + b;\n+      constexpr auto amb [[maybe_unused]] = a - b;\n+      constexpr auto atb [[maybe_unused]] = a * b;\n+      constexpr auto adb [[maybe_unused]] = a / b;\n+    }\n+}\n+\n+int main()\n+{\n+  __gnu_test::test_operators<float>();\n+  __gnu_test::test_operators<double>();\n+  __gnu_test::test_operators<long double>();\n+\n+  return 0;\n+}"}, {"sha": "902e7ce8e87702d9fe52d9db40d826031b49e58e", "filename": "libstdc++-v3/testsuite/26_numerics/complex/requirements/more_constexpr.cc", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fmore_constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fmore_constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Frequirements%2Fmore_constexpr.cc?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -0,0 +1,171 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+\n+  // Test constexpr real(val) imag(val).\n+  template<typename _Tp, const int _Val = 42>\n+    inline void\n+    set_real(std::complex<_Tp>& a)\n+    { a.real(_Val); }\n+\n+  template<typename _Tp, const int _Val = 42>\n+    inline void\n+    set_imag(std::complex<_Tp>& a)\n+    { a.imag(_Val); }\n+\n+  template<typename _Tp>\n+    void\n+    test_members()\n+    {\n+      constexpr std::complex<_Tp> a{1.1, 2.2};\n+\n+      std::complex<_Tp> z = a;\n+\n+      set_real<_Tp, 33>(z);\n+      set_imag<_Tp, 44>(z);\n+    }\n+\n+  // Test operators @=complex and @=real.\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    sum(const std::complex<_Tp>& z, const std::complex<_Up>& w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x += w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    sum(const std::complex<_Tp>& z, _Up w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x += w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    dif(const std::complex<_Tp>& z, const std::complex<_Up>& w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x -= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    dif(const std::complex<_Tp>& z, _Up w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x -= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    prod(const std::complex<_Tp>& z, const std::complex<_Up>& w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x *= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    prod(const std::complex<_Tp>& z, _Up w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x *= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    quot(const std::complex<_Tp>& z, const std::complex<_Up>& w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x /= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    constexpr std::complex<_Tp>\n+    quot(const std::complex<_Tp>& z, _Up w)\n+    {\n+      std::complex<_Tp> x = z;\n+      x /= w;\n+      return x;\n+    }\n+\n+  template<typename _Tp, typename _Up>\n+    void\n+    test_operator_members()\n+    {\n+      constexpr std::complex<_Tp> a{10, 20};\n+      constexpr std::complex<_Up> b{6, 8};\n+      constexpr _Up c{10};\n+\n+      constexpr auto apc = sum(a, c);\n+      static_assert(apc == std::complex<_Tp>{20, 20});\n+      constexpr auto amc = dif(a, c);\n+      static_assert(amc == std::complex<_Tp>{0, 20});\n+      constexpr auto atc = prod(a, c);\n+      static_assert(atc == std::complex<_Tp>{100, 200});\n+      constexpr auto adc = quot(a, c);\n+      static_assert(adc == std::complex<_Tp>{1, 2});\n+\n+      constexpr auto apb = sum(a, b);\n+      static_assert(apb == std::complex<_Tp>{16, 28});\n+      constexpr auto amb = dif(a, b);\n+      static_assert(amb == std::complex<_Tp>{4, 12});\n+      constexpr auto atb = prod(a, b);\n+      static_assert(atb == std::complex<_Tp>{-100, 200});\n+      constexpr auto adb = quot(a, b);\n+      static_assert(adb == std::complex<_Tp>{11/_Tp{5}, 2/_Tp{5}});\n+    }\n+}\n+\n+int main()\n+{\n+  __gnu_test::test_members<float>();\n+  __gnu_test::test_members<double>();\n+  __gnu_test::test_members<long double>();\n+\n+  __gnu_test::test_operator_members<float, float>();\n+  __gnu_test::test_operator_members<float, double>();\n+  __gnu_test::test_operator_members<float, long double>();\n+  __gnu_test::test_operator_members<double, float>();\n+  __gnu_test::test_operator_members<double, double>();\n+  __gnu_test::test_operator_members<double, long double>();\n+  __gnu_test::test_operator_members<long double, float>();\n+  __gnu_test::test_operator_members<long double, double>();\n+  __gnu_test::test_operator_members<long double, long double>();\n+\n+  // Test primary template.\n+  __gnu_test::test_operator_members<__float128, __float128>();\n+\n+  return 0;\n+}"}, {"sha": "e98eacd4332b6cffac7918509ee37e0e0096dfe5", "filename": "libstdc++-v3/testsuite/26_numerics/complex/value_operations/more_constexpr.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fvalue_operations%2Fmore_constexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fvalue_operations%2Fmore_constexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fcomplex%2Fvalue_operations%2Fmore_constexpr.cc?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <complex>\n+#include <testsuite_common_types.h>\n+\n+namespace __gnu_test\n+{\n+  struct constexpr_functions\n+  {\n+    template<typename _Ttesttype>\n+      void\n+      operator()()\n+      {\n+\tstruct _Concept\n+\t{\n+\t  void __constraint()\n+\t  { \n+\t    typedef typename _Ttesttype::_ComplexT _ComplexT;\n+\t    constexpr _ComplexT cc = { 1.1 };\n+\t    constexpr _Ttesttype a(cc);\n+\t    constexpr auto v1 [[maybe_unused]] = norm(a);\n+\t    constexpr auto v2 [[maybe_unused]] = conj(a);\n+\t  }\n+\t};\n+\n+\t_Concept c;\n+\tc.__constraint();\n+      }\n+  };\n+}\n+\n+int main()\n+{\n+  __gnu_test::constexpr_functions test;\n+\n+  test.operator()<std::complex<float>>();\n+  test.operator()<std::complex<double>>();\n+  test.operator()<std::complex<long double>>();\n+\n+  return 0;\n+}"}, {"sha": "81941a49284e550df8e75e72720b7722c1115a2e", "filename": "libstdc++-v3/testsuite/26_numerics/headers/complex/synopsis.cc", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcomplex%2Fsynopsis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e987fb1ebecc7494f9869071e487deef70a792f6/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcomplex%2Fsynopsis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fheaders%2Fcomplex%2Fsynopsis.cc?ref=e987fb1ebecc7494f9869071e487deef70a792f6", "patch": "@@ -28,51 +28,71 @@ namespace std {\n \n   // 26.2.6 operators:\n   template<class T>\n-    complex<T> operator+(const complex<T>&, const complex<T>&);\n-  template<class T> complex<T> operator+(const complex<T>&, const T&);\n-  template<class T> complex<T> operator+(const T&, const complex<T>&);\n-  template<class T> complex<T> operator-\n-    (const complex<T>&, const complex<T>&);\n-  template<class T> complex<T> operator-(const complex<T>&, const T&);\n-  template<class T> complex<T> operator-(const T&, const complex<T>&);\n-  template<class T> complex<T> operator*\n-    (const complex<T>&, const complex<T>&);\n-  template<class T> complex<T> operator*(const complex<T>&, const T&);\n-  template<class T> complex<T> operator*(const T&, const complex<T>&);\n-  template<class T> complex<T> operator/\n-    (const complex<T>&, const complex<T>&);\n-  template<class T> complex<T> operator/(const complex<T>&, const T&);\n-  template<class T> complex<T> operator/(const T&, const complex<T>&);\n-  template<class T> complex<T> operator+(const complex<T>&);\n-  template<class T> complex<T> operator-(const complex<T>&);\n-  template<class T> _GLIBCXX_CONSTEXPR bool operator==\n-    (const complex<T>&, const complex<T>&);\n-  template<class T> _GLIBCXX_CONSTEXPR bool operator==\n-    (const complex<T>&, const T&);\n-  template<class T> _GLIBCXX_CONSTEXPR bool operator==\n-    (const T&, const complex<T>&);\n+    _GLIBCXX20_CONSTEXPR complex<T>\n+    operator+(const complex<T>&, const complex<T>&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator+(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator+(const T&, const complex<T>&);\n \n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T>\n+    operator-(const complex<T>&, const complex<T>&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator-(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator-(const T&, const complex<T>&);\n \n-  template<class T> _GLIBCXX_CONSTEXPR bool operator!=\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator*\n     (const complex<T>&, const complex<T>&);\n-  template<class T> _GLIBCXX_CONSTEXPR bool operator!=\n-    (const complex<T>&, const T&);\n-  template<class T> _GLIBCXX_CONSTEXPR bool operator!=\n-    (const T&, const complex<T>&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator*(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator*(const T&, const complex<T>&);\n+\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T>\n+    operator/(const complex<T>&, const complex<T>&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator/(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator/(const T&, const complex<T>&);\n+\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator+(const complex<T>&);\n+  template<class T>\n+    _GLIBCXX20_CONSTEXPR complex<T> operator-(const complex<T>&);\n+\n+  template<class T>\n+    _GLIBCXX_CONSTEXPR bool operator==(const complex<T>&, const complex<T>&);\n+  template<class T>\n+     _GLIBCXX_CONSTEXPR bool operator==(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX_CONSTEXPR bool operator==(const T&, const complex<T>&);\n+\n+  template<class T>\n+    _GLIBCXX_CONSTEXPR bool operator!=(const complex<T>&, const complex<T>&);\n+  template<class T>\n+    _GLIBCXX_CONSTEXPR bool operator!=(const complex<T>&, const T&);\n+  template<class T>\n+    _GLIBCXX_CONSTEXPR bool operator!=(const T&, const complex<T>&);\n+\n   template<class T, class charT, class traits>\n-  basic_istream<charT, traits>&\n-  operator>>(basic_istream<charT, traits>&, complex<T>&);\n+    basic_istream<charT, traits>&\n+    operator>>(basic_istream<charT, traits>&, complex<T>&);\n   template<class T, class charT, class traits>\n-  basic_ostream<charT, traits>&\n-  operator<<(basic_ostream<charT, traits>&, const complex<T>&);\n+    basic_ostream<charT, traits>&\n+    operator<<(basic_ostream<charT, traits>&, const complex<T>&);\n \n   // 26.2.7 values:\n   template<class T> _GLIBCXX_CONSTEXPR T real(const complex<T>&);\n   template<class T> _GLIBCXX_CONSTEXPR T imag(const complex<T>&);\n   template<class T> T abs(const complex<T>&);\n-  template<class T> T arg(const complex<T>&);\n-  template<class T> T norm(const complex<T>&);\n-  template<class T> complex<T> conj(const complex<T>&);\n+  template<class T> _GLIBCXX20_CONSTEXPR T arg(const complex<T>&);\n+  template<class T> _GLIBCXX20_CONSTEXPR T norm(const complex<T>&);\n+  template<class T> _GLIBCXX20_CONSTEXPR complex<T> conj(const complex<T>&);\n+  template<class T> _GLIBCXX20_CONSTEXPR complex<T> proj(const complex<T>&);\n   template<class T> complex<T> polar(const T& rho, const T& theta);\n \n   // 26.2.8 transcendentals:"}]}