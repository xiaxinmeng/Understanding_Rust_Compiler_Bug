{"sha": "051fb43f810d34a683a5112112757abf6998325a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUxZmI0M2Y4MTBkMzRhNjgzYTUxMTIxMTI3NTdhYmY2OTk4MzI1YQ==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.ibm.com", "date": "2019-10-10T07:56:25Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2019-10-10T07:56:25Z"}, "message": "S/390: PR91035 Fix call to __morestack\n\nFor the call to __morestack we use a special ABI in the S/390 back-end\nwhich requires us to emit a parameter block to the .rodata section.\nIt contains the label whereto __morestack needs to return.  The\nparameter block needs to be explicit in RTL since we also need to take\nthe address of it loaded into r1 in order to pass its address to\n__morestack.  In order to express correctly what __morestack does its\nRTX also contained the return label. Hence we had the return label to\noccur twice in the insn stream.  This is problematic when it comes to\nredirecting edges.  The correlation between these two occurrences of\nthe label cannot be expressed so when doing a redirect only the label\nin the jump RTX gets modified while the parameter block label stays as\nis.\n\nThe patch avoids having two instancs of the label by merging the\nparameter block generation and the __morestack call RTX into one. By\ndoing this I could also get rid of the unspec which was required for\nthe parameter block generation so far.\n\ngcc/ChangeLog:\n\n2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>\n\n\tPR target/91035\n\t* config/s390/s390-protos.h (s390_output_split_stack_data): Add\n\tprototype.\n\t* config/s390/s390.md (UNSPECV_SPLIT_STACK_DATA): Remove.\n\t(\"split_stack_data\", \"split_stack_call\")\n\t(\"split_stack_call_<mode>\", \"split_stack_cond_call\")\n\t(\"split_stack_cond_call_<mode>\"): Remove.\n\t(\"@split_stack_call<mode>\", \"@split_stack_cond_call<mode>\"): New\n\tinsn definition.\n\t* config/s390/s390.c (s390_output_split_stack_data): New function.\n\t(s390_expand_split_stack_prologue): Use the merged expander.\n\nFrom-SVN: r276790", "tree": {"sha": "67401d8660db22285557b39316ba639049103b13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67401d8660db22285557b39316ba639049103b13"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/051fb43f810d34a683a5112112757abf6998325a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051fb43f810d34a683a5112112757abf6998325a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051fb43f810d34a683a5112112757abf6998325a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051fb43f810d34a683a5112112757abf6998325a/comments", "author": {"login": "Andreas-Krebbel", "id": 38103320, "node_id": "MDQ6VXNlcjM4MTAzMzIw", "avatar_url": "https://avatars.githubusercontent.com/u/38103320?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Andreas-Krebbel", "html_url": "https://github.com/Andreas-Krebbel", "followers_url": "https://api.github.com/users/Andreas-Krebbel/followers", "following_url": "https://api.github.com/users/Andreas-Krebbel/following{/other_user}", "gists_url": "https://api.github.com/users/Andreas-Krebbel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Andreas-Krebbel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Andreas-Krebbel/subscriptions", "organizations_url": "https://api.github.com/users/Andreas-Krebbel/orgs", "repos_url": "https://api.github.com/users/Andreas-Krebbel/repos", "events_url": "https://api.github.com/users/Andreas-Krebbel/events{/privacy}", "received_events_url": "https://api.github.com/users/Andreas-Krebbel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e7f906ca5c73fb79d21ec54733e9e75a96c2b4"}], "stats": {"total": 204, "additions": 109, "deletions": 95}, "files": [{"sha": "6f559bc9b14c38ec4761be0fb1773137359cbb32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051fb43f810d34a683a5112112757abf6998325a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051fb43f810d34a683a5112112757abf6998325a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=051fb43f810d34a683a5112112757abf6998325a", "patch": "@@ -1,3 +1,17 @@\n+2019-10-10  Andreas Krebbel  <krebbel@linux.ibm.com>\n+\n+\tPR target/91035\n+\t* config/s390/s390-protos.h (s390_output_split_stack_data): Add\n+\tprototype.\n+\t* config/s390/s390.md (UNSPECV_SPLIT_STACK_DATA): Remove.\n+\t(\"split_stack_data\", \"split_stack_call\")\n+\t(\"split_stack_call_<mode>\", \"split_stack_cond_call\")\n+\t(\"split_stack_cond_call_<mode>\"): Remove.\n+\t(\"@split_stack_call<mode>\", \"@split_stack_cond_call<mode>\"): New\n+\tinsn definition.\n+\t* config/s390/s390.c (s390_output_split_stack_data): New function.\n+\t(s390_expand_split_stack_prologue): Use the merged expander.\n+\n 2019-10-09  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/90879"}, {"sha": "f760f1529322c954be0a179518eb3758630b8fc0", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=051fb43f810d34a683a5112112757abf6998325a", "patch": "@@ -146,6 +146,7 @@ extern int s390_branch_condition_mask (rtx);\n extern int s390_compare_and_branch_condition_mask (rtx);\n extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);\n extern void s390_asm_output_function_label (FILE *, const char *, tree);\n+extern void s390_output_split_stack_data (rtx, rtx, rtx, rtx);\n \n enum s390_indirect_branch_type\n   {"}, {"sha": "8241bd5bbf820775c98785128c0770806d1adb4b", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=051fb43f810d34a683a5112112757abf6998325a", "patch": "@@ -11600,6 +11600,44 @@ static GTY(()) rtx morestack_ref;\n \n #define SPLIT_STACK_AVAILABLE 1024\n \n+/* Emit the parmblock for __morestack into .rodata section.  It\n+   consists of 3 pointer size entries:\n+   - frame size\n+   - size of stack arguments\n+   - offset between parm block and __morestack return label  */\n+\n+void\n+s390_output_split_stack_data (rtx parm_block, rtx call_done,\n+\t\t\t      rtx frame_size, rtx args_size)\n+{\n+  rtx ops[] = { parm_block, call_done };\n+\n+  switch_to_section (targetm.asm_out.function_rodata_section\n+\t\t     (current_function_decl));\n+\n+  if (TARGET_64BIT)\n+    output_asm_insn (\".align\\t8\", NULL);\n+  else\n+    output_asm_insn (\".align\\t4\", NULL);\n+\n+  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (parm_block));\n+  if (TARGET_64BIT)\n+    {\n+      output_asm_insn (\".quad\\t%0\", &frame_size);\n+      output_asm_insn (\".quad\\t%0\", &args_size);\n+      output_asm_insn (\".quad\\t%1-%0\", ops);\n+    }\n+  else\n+    {\n+      output_asm_insn (\".long\\t%0\", &frame_size);\n+      output_asm_insn (\".long\\t%0\", &args_size);\n+      output_asm_insn (\".long\\t%1-%0\", ops);\n+    }\n+\n+  switch_to_section (current_function_section ());\n+}\n+\n /* Emit -fsplit-stack prologue, which goes before the regular function\n    prologue.  */\n \n@@ -11677,16 +11715,8 @@ s390_expand_split_stack_prologue (void)\n \n   call_done = gen_label_rtx ();\n   parm_base = gen_label_rtx ();\n-\n-  /* Emit the parameter block.  */\n-  tmp = gen_split_stack_data (parm_base, call_done,\n-\t\t\t      GEN_INT (frame_size),\n-\t\t\t      GEN_INT (args_size));\n-  insn = emit_insn (tmp);\n-  add_reg_note (insn, REG_LABEL_OPERAND, call_done);\n-  LABEL_NUSES (call_done)++;\n-  add_reg_note (insn, REG_LABEL_OPERAND, parm_base);\n   LABEL_NUSES (parm_base)++;\n+  LABEL_NUSES (call_done)++;\n \n   /* %r1 = litbase.  */\n   insn = emit_move_insn (r1, gen_rtx_LABEL_REF (VOIDmode, parm_base));\n@@ -11696,15 +11726,29 @@ s390_expand_split_stack_prologue (void)\n   /* Now, we need to call __morestack.  It has very special calling\n      conventions: it preserves param/return/static chain registers for\n      calling main function body, and looks for its own parameters at %r1. */\n+  if (cc != NULL)\n+    tmp = gen_split_stack_cond_call (Pmode,\n+\t\t\t\t     morestack_ref,\n+\t\t\t\t     parm_base,\n+\t\t\t\t     call_done,\n+\t\t\t\t     GEN_INT (frame_size),\n+\t\t\t\t     GEN_INT (args_size),\n+\t\t\t\t     cc);\n+  else\n+    tmp = gen_split_stack_call (Pmode,\n+\t\t\t\tmorestack_ref,\n+\t\t\t\tparm_base,\n+\t\t\t\tcall_done,\n+\t\t\t\tGEN_INT (frame_size),\n+\t\t\t\tGEN_INT (args_size));\n+\n+  insn = emit_jump_insn (tmp);\n+  JUMP_LABEL (insn) = call_done;\n+  add_reg_note (insn, REG_LABEL_OPERAND, parm_base);\n+  add_reg_note (insn, REG_LABEL_OPERAND, call_done);\n \n   if (cc != NULL)\n     {\n-      tmp = gen_split_stack_cond_call (morestack_ref, cc, call_done);\n-\n-      insn = emit_jump_insn (tmp);\n-      JUMP_LABEL (insn) = call_done;\n-      LABEL_NUSES (call_done)++;\n-\n       /* Mark the jump as very unlikely to be taken.  */\n       add_reg_br_prob_note (insn,\n \t\t\t    profile_probability::very_unlikely ());\n@@ -11720,10 +11764,6 @@ s390_expand_split_stack_prologue (void)\n     }\n   else\n     {\n-      tmp = gen_split_stack_call (morestack_ref, call_done);\n-      insn = emit_jump_insn (tmp);\n-      JUMP_LABEL (insn) = call_done;\n-      LABEL_NUSES (call_done)++;\n       emit_barrier ();\n     }\n "}, {"sha": "01e5cf920cdfcad715e3caa50ee7a7916ba72a88", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 35, "deletions": 76, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/051fb43f810d34a683a5112112757abf6998325a/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=051fb43f810d34a683a5112112757abf6998325a", "patch": "@@ -298,7 +298,6 @@\n \n    ; Split stack support\n    UNSPECV_SPLIT_STACK_CALL\n-   UNSPECV_SPLIT_STACK_DATA\n \n    UNSPECV_OSC_BREAK\n   ])\n@@ -12000,99 +11999,59 @@\n   DONE;\n })\n \n-;; __morestack parameter block for split stack prologue.  Parameters are:\n-;; parameter block label, label to be called by __morestack, frame size,\n-;; stack parameter size.\n+;; Call to __morestack used by the split stack support\n \n-(define_insn \"split_stack_data\"\n-  [(unspec_volatile [(match_operand 0 \"\" \"X\")\n-\t\t     (match_operand 1 \"\" \"X\")\n-\t\t     (match_operand 2 \"const_int_operand\" \"X\")\n-\t\t     (match_operand 3 \"const_int_operand\" \"X\")]\n-\t\t    UNSPECV_SPLIT_STACK_DATA)]\n-  \"\"\n-{\n-  switch_to_section (targetm.asm_out.function_rodata_section\n-\t\t (current_function_decl));\n+; The insn has 3 parts:\n+; 1. A jump to the call done label. The jump will be done as part of\n+;    __morestack and will not be explicitly emitted to the insn stream.\n+; 2. The call of __morestack including a use for r1 which is supposed to\n+;    point to the parameter block for __morestack.\n+; 3. 3 USES whose values together with the call done label will be\n+;    used to emit the parameter block to the .rodata section. This\n+;    needs to be tied into the same insn as 1. since the call done\n+;    label is emitted also as part of the parm block.  In order to\n+;    allow the edge to the BB with the call done label to be\n+;    redirected both need to make use of the same label_ref.\n \n-  if (TARGET_64BIT)\n-    output_asm_insn (\".align\\t8\", operands);\n-  else\n-    output_asm_insn (\".align\\t4\", operands);\n-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",\n-\t\t\t\t     CODE_LABEL_NUMBER (operands[0]));\n-  if (TARGET_64BIT)\n-    {\n-      output_asm_insn (\".quad\\t%2\", operands);\n-      output_asm_insn (\".quad\\t%3\", operands);\n-      output_asm_insn (\".quad\\t%1-%0\", operands);\n-    }\n-  else\n-    {\n-      output_asm_insn (\".long\\t%2\", operands);\n-      output_asm_insn (\".long\\t%3\", operands);\n-      output_asm_insn (\".long\\t%1-%0\", operands);\n-    }\n-\n-  switch_to_section (current_function_section ());\n-  return \"\";\n-}\n-  [(set_attr \"length\" \"0\")])\n-\n-\n-;; A jg with minimal fuss for use in split stack prologue.\n-\n-(define_expand \"split_stack_call\"\n-  [(match_operand 0 \"bras_sym_operand\" \"X\")\n-   (match_operand 1 \"\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_64BIT)\n-    emit_jump_insn (gen_split_stack_call_di (operands[0], operands[1]));\n-  else\n-    emit_jump_insn (gen_split_stack_call_si (operands[0], operands[1]));\n-  DONE;\n-})\n-\n-(define_insn \"split_stack_call_<mode>\"\n-  [(set (pc) (label_ref (match_operand 1 \"\" \"\")))\n+(define_insn \"@split_stack_call<mode>\"\n+  [(set (pc) (label_ref (match_operand 2 \"\" \"\")))     ; call done label\n    (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n \t\t\t\t    (reg:P 1)]\n-\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n+\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))\n+   (use (label_ref (match_operand 1 \"\" \"X\")))         ; parm block label\n+   (use (match_operand 3 \"const_int_operand\" \"X\"))    ; frame size\n+   (use (match_operand 4 \"const_int_operand\" \"X\"))]   ; arg size\n   \"\"\n-  \"jg\\t%0\"\n+{\n+  s390_output_split_stack_data (operands[1], operands[2], operands[3], operands[4]);\n+  return \"jg\\t%0\";\n+}\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"  \"branch\")])\n \n-;; Also a conditional one.\n-\n-(define_expand \"split_stack_cond_call\"\n-  [(match_operand 0 \"bras_sym_operand\" \"X\")\n-   (match_operand 1 \"\" \"\")\n-   (match_operand 2 \"\" \"\")]\n-  \"\"\n-{\n-  if (TARGET_64BIT)\n-    emit_jump_insn (gen_split_stack_cond_call_di (operands[0], operands[1], operands[2]));\n-  else\n-    emit_jump_insn (gen_split_stack_cond_call_si (operands[0], operands[1], operands[2]));\n-  DONE;\n-})\n+; As above but with a conditional jump\n \n-(define_insn \"split_stack_cond_call_<mode>\"\n+(define_insn \"@split_stack_cond_call<mode>\"\n   [(set (pc)\n \t(if_then_else\n-\t  (match_operand 1 \"\" \"\")\n-\t  (label_ref (match_operand 2 \"\" \"\"))\n+\t  (match_operand 5 \"\" \"\")                     ; condition\n+\t  (label_ref (match_operand 2 \"\" \"\"))         ; call done label\n \t  (pc)))\n    (set (reg:P 1) (unspec_volatile [(match_operand 0 \"bras_sym_operand\" \"X\")\n \t\t\t\t    (reg:P 1)]\n-\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))]\n+\t\t\t\t   UNSPECV_SPLIT_STACK_CALL))\n+   (use (label_ref (match_operand 1 \"\" \"X\")))         ; parm block label\n+   (use (match_operand 3 \"const_int_operand\" \"X\"))    ; frame size\n+   (use (match_operand 4 \"const_int_operand\" \"X\"))]   ; arg size\n   \"\"\n-  \"jg%C1\\t%0\"\n+{\n+  s390_output_split_stack_data (operands[1], operands[2], operands[3], operands[4]);\n+  return \"jg%C5\\t%0\";\n+}\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"  \"branch\")])\n \n+\n (define_insn \"osc_break\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_OSC_BREAK)]\n   \"\""}]}