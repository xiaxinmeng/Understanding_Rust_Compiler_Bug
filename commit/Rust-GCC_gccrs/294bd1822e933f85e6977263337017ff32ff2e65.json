{"sha": "294bd1822e933f85e6977263337017ff32ff2e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0YmQxODIyZTkzM2Y4NWU2OTc3MjYzMzM3MDE3ZmYzMmZmMmU2NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2005-03-20T23:25:14Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2005-03-20T23:25:14Z"}, "message": "rs6000.c (rs6000_parm_start): New function.\n\n\t* config/rs6000/rs6000.c (rs6000_parm_start): New function.\n\t(function_arg_advance): Use rs6000_parm_start.\n\t(function_arg, rs6000_arg_partial_bytes): Likewise.\n\nFrom-SVN: r96771", "tree": {"sha": "fccfecd6e2c20c472cdc6e37224844d982e4f512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fccfecd6e2c20c472cdc6e37224844d982e4f512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/294bd1822e933f85e6977263337017ff32ff2e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294bd1822e933f85e6977263337017ff32ff2e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294bd1822e933f85e6977263337017ff32ff2e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294bd1822e933f85e6977263337017ff32ff2e65/comments", "author": null, "committer": null, "parents": [{"sha": "ed248cf7644668ecbad4a1a333fca6d0f7bba55a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed248cf7644668ecbad4a1a333fca6d0f7bba55a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed248cf7644668ecbad4a1a333fca6d0f7bba55a"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "d9355e4082aea687ee866d7202accff504624025", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294bd1822e933f85e6977263337017ff32ff2e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294bd1822e933f85e6977263337017ff32ff2e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=294bd1822e933f85e6977263337017ff32ff2e65", "patch": "@@ -1,3 +1,9 @@\n+2005-03-21  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (rs6000_parm_start): New function.\n+\t(function_arg_advance): Use rs6000_parm_start.\n+\t(function_arg, rs6000_arg_partial_bytes): Likewise.\n+\n 2005-03-20  Joseph S. Myers  <joseph@codesourcery.com>\n \n \t* c-common.c (check_case_value): Adjust comment about stripping"}, {"sha": "0cf135f01af95c8c5b5c5b08dd8eab4a3d5bffc6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294bd1822e933f85e6977263337017ff32ff2e65/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294bd1822e933f85e6977263337017ff32ff2e65/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=294bd1822e933f85e6977263337017ff32ff2e65", "patch": "@@ -4060,6 +4060,20 @@ function_arg_boundary (enum machine_mode mode, tree type)\n     return PARM_BOUNDARY;\n }\n \n+/* For a function parm of MODE and TYPE, return the starting word in\n+   the parameter area.  NWORDS of the parameter area are already used.  */\n+\n+static unsigned int\n+rs6000_parm_start (enum machine_mode mode, tree type, unsigned int nwords)\n+{\n+  unsigned int align;\n+  unsigned int parm_offset;\n+\n+  align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n+  parm_offset = DEFAULT_ABI == ABI_V4 ? 2 : 6;\n+  return nwords + (-(parm_offset + nwords) & align);\n+}\n+\n /* Compute the size (in words) of a function argument.  */\n \n static unsigned long\n@@ -4314,15 +4328,10 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   else\n     {\n       int n_words = rs6000_arg_size (mode, type);\n-      int align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n+      int start_words = cum->words;\n+      int align_words = rs6000_parm_start (mode, type, start_words);\n \n-      /* The simple alignment calculation here works because\n-\t function_arg_boundary / PARM_BOUNDARY will only be 1 or 2.\n-\t If we ever want to handle alignments larger than 8 bytes for\n-\t 32-bit or 16 bytes for 64-bit, then we'll need to take into\n-\t account the offset to the start of the parm save area.  */\n-      align &= cum->words;\n-      cum->words += align + n_words;\n+      cum->words = align_words + n_words;\n \n       if (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t  && TARGET_HARD_FLOAT && TARGET_FPRS)\n@@ -4335,7 +4344,7 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t  fprintf (stderr, \"nargs = %4d, proto = %d, mode = %4s, \",\n \t\t   cum->nargs_prototype, cum->prototype, GET_MODE_NAME (mode));\n \t  fprintf (stderr, \"named = %d, align = %d, depth = %d\\n\",\n-\t\t   named, align, depth);\n+\t\t   named, align_words - start_words, depth);\n \t}\n     }\n }\n@@ -4826,8 +4835,7 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     }\n   else\n     {\n-      int align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n-      int align_words = cum->words + (cum->words & align);\n+      int align_words = rs6000_parm_start (mode, type, cum->words);\n \n       if (USE_FP_FOR_ARG_P (cum, mode, type))\n \t{\n@@ -4940,8 +4948,6 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t  tree type, bool named)\n {\n   int ret = 0;\n-  int align;\n-  int parm_offset;\n   int align_words;\n \n   if (DEFAULT_ABI == ABI_V4)\n@@ -4957,9 +4963,7 @@ rs6000_arg_partial_bytes (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n       && int_size_in_bytes (type) > 0)\n     return 0;\n \n-  align = function_arg_boundary (mode, type) / PARM_BOUNDARY - 1;\n-  parm_offset = TARGET_32BIT ? 2 : 0;\n-  align_words = cum->words + ((parm_offset - cum->words) & align);\n+  align_words = rs6000_parm_start (mode, type, cum->words);\n \n   if (USE_FP_FOR_ARG_P (cum, mode, type)\n       /* If we are passing this arg in gprs as well, then this function"}]}