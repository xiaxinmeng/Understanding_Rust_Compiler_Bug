{"sha": "bec1da64aec26a490a6de5a9aa4ee667805e8445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVjMWRhNjRhZWMyNmE0OTBhNmRlNWE5YWE0ZWU2Njc4MDVlODQ0NQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-03-19T22:43:10Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-03-19T22:43:10Z"}, "message": "PR tree-optimization/89688 - -Wstringop-overflow confused by const 2D array of char\n\ngcc/c/ChangeLog:\n\n\tPR tree-optimization/89688\n\t* c-decl.c (finish_decl): Call braced_lists_to_string for more\n\tkinds of initializers.\n\ngcc/c-family/ChangeLog:\n\n\tPR tree-optimization/89688\n\t* c-common.c (braced_list_to_string): Make static.\n\t(braced_lists_to_strings): Define new function.\n\t* c-common.h (braced_list_to_string): Remove.\n\t(braced_lists_to_strings): Declare.\n\ngcc/cp/ChangeLog:\n\n\tPR tree-optimization/89688\n\t* typeck2.c (store_init_value): Call braced_lists_to_string for more\n\tkinds of initializers.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/89688\n\t* gcc.dg/strlenopt-61.c: New test.\n\t* g++.dg/warn/Wstringop-overflow-2.C: New test.\n\nFrom-SVN: r269814", "tree": {"sha": "0d5363919c319be1c5f4edf1f375d47e39dbecf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d5363919c319be1c5f4edf1f375d47e39dbecf1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bec1da64aec26a490a6de5a9aa4ee667805e8445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec1da64aec26a490a6de5a9aa4ee667805e8445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bec1da64aec26a490a6de5a9aa4ee667805e8445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bec1da64aec26a490a6de5a9aa4ee667805e8445/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "026216a753ef0a757a9e368a59fa667ea422cf09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/026216a753ef0a757a9e368a59fa667ea422cf09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/026216a753ef0a757a9e368a59fa667ea422cf09"}], "stats": {"total": 342, "additions": 331, "deletions": 11}, "files": [{"sha": "df61b693205ee0e12275ec322b4837b21d4e7bbf", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -1,3 +1,11 @@\n+2019-03-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89688\n+\t* c-common.c (braced_list_to_string): Make static.\n+\t(braced_lists_to_strings): Define new function.\n+\t* c-common.h (braced_list_to_string): Remove.\n+\t(braced_lists_to_strings): Declare.\n+\n 2019-03-12  Martin Liska  <mliska@suse.cz>\n \n \t* c-opts.c (c_common_handle_option): Wrap option with %< and %>."}, {"sha": "0e17fef881853fd56e7aeebe841832e5da110179", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -8814,7 +8814,7 @@ maybe_add_include_fixit (rich_location *richloc, const char *header,\n    TYPE into a STRING_CST for convenience and efficiency.  Return\n    the converted string on success or the original ctor on failure.  */\n \n-tree\n+static tree\n braced_list_to_string (tree type, tree ctor)\n {\n   if (!tree_fits_uhwi_p (TYPE_SIZE_UNIT (type)))\n@@ -8895,4 +8895,52 @@ braced_list_to_string (tree type, tree ctor)\n   return res;\n }\n \n+/* Attempt to convert a CTOR containing braced array initializer lists\n+   for array TYPE into one containing STRING_CSTs, for convenience and\n+   efficiency.  Recurse for arrays of arrays and member initializers.\n+   Return the converted CTOR or STRING_CST on success or the original\n+   CTOR otherwise.  */\n+\n+tree\n+braced_lists_to_strings (tree type, tree ctor)\n+{\n+  if (TREE_CODE (ctor) != CONSTRUCTOR)\n+    return ctor;\n+\n+  tree_code code = TREE_CODE (type);\n+\n+  tree ttp;\n+  if (code == ARRAY_TYPE)\n+    ttp = TREE_TYPE (type);\n+  else if (code == RECORD_TYPE)\n+    {\n+      ttp = TREE_TYPE (ctor);\n+      if (TREE_CODE (ttp) == ARRAY_TYPE)\n+\t{\n+\t  type = ttp;\n+\t  ttp = TREE_TYPE (ttp);\n+\t}\n+    }\n+  else\n+    return ctor;\n+\n+  if (TYPE_STRING_FLAG (ttp))\n+    return braced_list_to_string (type, ctor);\n+\n+  code = TREE_CODE (ttp);\n+  if (code == ARRAY_TYPE || code == RECORD_TYPE)\n+    {\n+      /* Handle array of arrays or struct member initializers.  */\n+      tree val;\n+      unsigned HOST_WIDE_INT idx;\n+      FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (ctor), idx, val)\n+\t{\n+\t  val = braced_lists_to_strings (ttp, val);\n+\t  CONSTRUCTOR_ELT (ctor, idx)->value = val;\n+\t}\n+    }\n+\n+  return ctor;\n+}\n+\n #include \"gt-c-family-c-common.h\""}, {"sha": "104c74226def1b692074a5791d821ed81e9dfd6c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -1372,7 +1372,8 @@ extern void maybe_add_include_fixit (rich_location *, const char *, bool);\n extern void maybe_suggest_missing_token_insertion (rich_location *richloc,\n \t\t\t\t\t\t   enum cpp_ttype token_type,\n \t\t\t\t\t\t   location_t prev_token_loc);\n-extern tree braced_list_to_string (tree, tree);\n+extern tree braced_lists_to_strings (tree, tree);\n+\n extern bool has_attribute (location_t, tree, tree, tree (*)(tree));\n \n #if CHECKING_P"}, {"sha": "fc8049e832e74fc49e0a5f7d9e96de577ed0cac5", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -1,3 +1,9 @@\n+2019-03-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89688\n+\t* c-decl.c (finish_decl): Call braced_lists_to_string for more\n+\tkinds of initializers.\n+\n 2019-03-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/89734"}, {"sha": "8d5c35ab4751154f40ec0fca97117d6d6d328d5a", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -5165,11 +5165,10 @@ finish_decl (tree decl, location_t init_loc, tree init,\n       relayout_decl (decl);\n     }\n \n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_STRING_FLAG (TREE_TYPE (type))\n-      && DECL_INITIAL (decl)\n-      && TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR)\n-    DECL_INITIAL (decl) = braced_list_to_string (type, DECL_INITIAL (decl));\n+  /* Look for braced array initializers for character arrays and\n+     recursively convert them into STRING_CSTs.  */\n+  if (tree init = DECL_INITIAL (decl))\n+    DECL_INITIAL (decl) = braced_lists_to_strings (type, init);\n \n   if (VAR_P (decl))\n     {"}, {"sha": "2157496745e5d33d568bd6b8a7f1c924a974fbb6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -1,3 +1,9 @@\n+2019-03-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89688\n+\t* typeck2.c (store_init_value): Call braced_lists_to_string for more\n+\tkinds of initializers.\n+\n 2019-03-18  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/89630 - ICE with dependent using-decl as template arg."}, {"sha": "e50d6ed83c3795a3f316e97a409dc0735f240106", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -824,10 +824,9 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n       value = digest_init_flags (type, init, flags, tf_warning_or_error);\n     }\n \n-  if (TREE_CODE (type) == ARRAY_TYPE\n-      && TYPE_STRING_FLAG (TREE_TYPE (type))\n-      && TREE_CODE (value) == CONSTRUCTOR)\n-    value = braced_list_to_string (type, value);\n+  /* Look for braced array initializers for character arrays and\n+     recursively convert them into STRING_CSTs.  */\n+  value = braced_lists_to_strings (type, value);\n \n   current_ref_temp_count = 0;\n   value = extend_ref_init_temps (decl, value, cleanups);"}, {"sha": "e60ec93ced399011cf4aeddb311ebfe728a535cb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -1,3 +1,9 @@\n+2019-03-19  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/89688\n+\t* gcc.dg/strlenopt-61.c: New test.\n+\t* g++.dg/warn/Wstringop-overflow-2.C: New test.\n+\n 2019-03-19  Jim Wilson  <jimw@sifive.com>\n \n \tPR target/89411"}, {"sha": "425ba83841b3e0e2fb8ad2c1d5c8f75f36b8303d", "filename": "gcc/testsuite/g++.dg/warn/Wstringop-overflow-2.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWstringop-overflow-2.C?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -0,0 +1,29 @@\n+/* PR tree-optimization/89688 - -Wstringop-overflow confused by const 2D\n+   array of char\n+   { dg-do compile }\n+   { dg-options \"-Wall -fdump-tree-gimple -fdump-tree-optimized\" } */\n+\n+extern \"C\" __SIZE_TYPE__ strlen (const char*);\n+\n+const char a2[2] = { '1' };\n+\n+void a2_len ()\n+{\n+  if (strlen (a2) != 1)\n+    __builtin_abort ();\n+}\n+\n+const char a2_2[2][3] = { { '1' }, { '1', '2' } };\n+\n+void a2_2_len ()\n+{\n+  if  (strlen (a2_2[0]) != 1)   // { dg-bogus \"-Wstringop-overflow\" }\n+    __builtin_abort ();\n+\n+  if  (strlen (a2_2[1]) != 2)   // { dg-bogus \"-Wstringop-overflow\" }\n+    __builtin_abort ();\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"strlen\" \"gimple\" } } */"}, {"sha": "4f8e9c053e450c60399f7872d283789d44a76136", "filename": "gcc/testsuite/gcc.dg/strlenopt-61.c", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bec1da64aec26a490a6de5a9aa4ee667805e8445/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-61.c?ref=bec1da64aec26a490a6de5a9aa4ee667805e8445", "patch": "@@ -0,0 +1,218 @@\n+/* PR tree-optimization/89688 - -Wstringop-overflow confused by const\n+   2D array of char\n+   { dg-do compile }\n+   { dg-options \"-Wall -fdump-tree-gimple -fdump-tree-optimized\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+size_t strlen (const char*);\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {                         \\\n+    extern __attribute__ ((noreturn)) void FAILNAME (name) (void);\t\\\n+    FAILNAME (name)();                          \\\n+  } while (0)\n+\n+#define A(ref, len)\t\t\t\t\t\\\n+  if (strlen (ref) != len) FAIL (failure); else (void)0\n+\n+const char a3_4[3][4] = { { 1 }, { 1, 2 }, { 1, 2, 3 } };\n+\n+void test_a4_4 (void)\n+{\n+  A (a3_4[0], 1);\n+  A (a3_4[1], 2);\n+  A (a3_4[2], 3);\n+\n+  A (&a3_4[0][0], 1);\n+  A (&a3_4[0][1], 0);\n+  A (&a3_4[0][2], 0);\n+  A (&a3_4[0][3], 0);\n+\n+  A (&a3_4[1][0], 2);\n+  A (&a3_4[1][1], 1);\n+  A (&a3_4[1][2], 0);\n+  A (&a3_4[1][3], 0);\n+\n+  A (&a3_4[2][0], 3);\n+  A (&a3_4[2][1], 2);\n+  A (&a3_4[2][2], 1);\n+  A (&a3_4[2][3], 0);\n+}\n+\n+\n+const char a3_4_5[3][4][5] =\n+  {\n+   { { 1 }, { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 } },\n+   { { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 } },\n+   { { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 }, { 1, 2 } },\n+  };\n+\n+void test_a3_4_5 (void)\n+{\n+  A (a3_4_5[0][0], 1);\n+  A (a3_4_5[0][1], 2);\n+  A (a3_4_5[0][2], 3);\n+  A (a3_4_5[0][3], 4);\n+\n+  A (a3_4_5[1][0], 2);\n+  A (a3_4_5[1][1], 3);\n+  A (a3_4_5[1][2], 4);\n+  A (a3_4_5[1][3], 1);\n+\n+  A (a3_4_5[2][0], 3);\n+  A (a3_4_5[2][1], 4);\n+  A (a3_4_5[2][2], 1);\n+  A (a3_4_5[2][3], 2);\n+}\n+\n+\n+struct S\n+{\n+  char a3[3];\n+  char a4_5[4][5];\n+};\n+\n+const struct S sa4[4] =\n+  {\n+   { .a3 = { 0 },\n+     .a4_5 =\n+     {\n+      { 1 }, { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }\n+     }\n+   },\n+   { .a3 = { 1 },\n+     .a4_5 =\n+     {\n+      { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 }\n+     }\n+   },\n+   { .a3 = { 1, 2 },\n+     .a4_5 =\n+     {\n+      { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 }, { 1, 2 }\n+     }\n+   },\n+   { .a3 = { 1 },\n+     .a4_5 =\n+     {\n+      { 1, 2, 3, 4 }, \"1\", { 1, 2 }, \"123\"\n+     }\n+   }\n+  };\n+\n+void test_sa4 (void)\n+{\n+  A (sa4[0].a3, 0);\n+  A (sa4[0].a4_5[0], 1);\n+  A (sa4[0].a4_5[1], 2);\n+  A (sa4[0].a4_5[2], 3);\n+  A (sa4[0].a4_5[3], 4);\n+\n+  A (sa4[1].a3, 1);\n+  A (sa4[1].a4_5[0], 2);\n+  A (sa4[1].a4_5[1], 3);\n+  A (sa4[1].a4_5[2], 4);\n+  A (sa4[1].a4_5[3], 1);\n+\n+  A (sa4[2].a3, 2);\n+  A (sa4[2].a4_5[0], 3);\n+  A (sa4[2].a4_5[1], 4);\n+  A (sa4[2].a4_5[2], 1);\n+  A (sa4[2].a4_5[3], 2);\n+\n+  A (sa4[3].a3, 1);\n+  A (sa4[3].a4_5[0], 4);\n+  A (sa4[3].a4_5[1], 1);\n+  A (sa4[3].a4_5[2], 2);\n+  A (sa4[3].a4_5[3], 3);\n+}\n+\n+\n+struct T\n+{\n+  struct S sa2[2];\n+  char a4[4];\n+};\n+\n+const struct T ta2[2] =\n+  {\n+   [0] =\n+   {\n+    .sa2 =\n+    {\n+     [0] =\n+     { .a3 = { 0 },\n+       .a4_5 =\n+       {\n+\t{ 1 }, { 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }\n+       }\n+     },\n+     [1] =\n+     { .a3 = { 1 },\n+       .a4_5 =\n+       {\n+\t{ 1, 2 }, { 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 }\n+       }\n+     },\n+    },\n+    .a4 = \"12\"\n+   },\n+\n+   [1] =\n+   {\n+    .sa2 =\n+    {\n+     [0] =\n+     { .a3 = { 1, 2 },\n+       .a4_5 =\n+       {\n+\t{ 1, 2, 3 }, { 1, 2, 3, 4 }, { 1 }, { 1, 2 }\n+       }\n+     },\n+     { .a3 = { 1 },\n+       .a4_5 =\n+       {\n+\t{ 1, 2, 3, 4 }, \"1\", { 1, 2 }, \"123\"\n+       }\n+     }\n+    },\n+    .a4 = \"123\"\n+   }\n+  };\n+\n+void test_ta2 (void)\n+{\n+  A (ta2[0].sa2[0].a3, 0);\n+  A (ta2[0].sa2[0].a4_5[0], 1);\n+  A (ta2[0].sa2[0].a4_5[1], 2);\n+  A (ta2[0].sa2[0].a4_5[2], 3);\n+  A (ta2[0].sa2[0].a4_5[3], 4);\n+\n+  A (ta2[0].sa2[1].a3, 1);\n+  A (ta2[0].sa2[1].a4_5[0], 2);\n+  A (ta2[0].sa2[1].a4_5[1], 3);\n+  A (ta2[0].sa2[1].a4_5[2], 4);\n+  A (ta2[0].sa2[1].a4_5[3], 1);\n+\n+  A (ta2[0].a4, 2);\n+\n+  A (ta2[1].sa2[0].a3, 2);\n+  A (ta2[1].sa2[0].a4_5[0], 3);\n+  A (ta2[1].sa2[0].a4_5[1], 4);\n+  A (ta2[1].sa2[0].a4_5[2], 1);\n+  A (ta2[1].sa2[0].a4_5[3], 2);\n+\n+  A (ta2[1].sa2[1].a3, 1);\n+  A (ta2[1].sa2[1].a4_5[0], 4);\n+  A (ta2[1].sa2[1].a4_5[1], 1);\n+  A (ta2[1].sa2[1].a4_5[2], 2);\n+  A (ta2[1].sa2[1].a4_5[3], 3);\n+\n+  A (ta2[1].a4, 3);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"failure\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"strlen\" \"gimple\" } } */"}]}