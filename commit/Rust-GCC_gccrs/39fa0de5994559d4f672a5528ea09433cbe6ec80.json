{"sha": "39fa0de5994559d4f672a5528ea09433cbe6ec80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlmYTBkZTU5OTQ1NTlkNGY2NzJhNTUyOGVhMDk0MzNjYmU2ZWM4MA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-13T15:07:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-13T15:11:15Z"}, "message": "Further increase the limit on the size of accepted Ada files\n\nIt turns out that the limit on the size of accepted Ada files had been\nalready lowered earlier, namely when location ranges had been introduced.\nNow we do not make use of location ranges in Ada so we can recoup the loss.\n\ngcc/ada/\n\t* gcc-interface/misc.c (gnat_init): Set default range bits to 0.\n\t* gcc-interface/trans.c (extract_encoding): Delete.\n\t(decode_name): Likewise.\n\t(File_Name_to_gnu): New function.\n\t(gigi): Call it to translate file names.  Replace assertion on\n\t1-1 mapping between files and line maps with conditional error.", "tree": {"sha": "ccf7e930c39ee5cabf40f4b1c29a63e4798bf22e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ccf7e930c39ee5cabf40f4b1c29a63e4798bf22e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39fa0de5994559d4f672a5528ea09433cbe6ec80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39fa0de5994559d4f672a5528ea09433cbe6ec80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39fa0de5994559d4f672a5528ea09433cbe6ec80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39fa0de5994559d4f672a5528ea09433cbe6ec80/comments", "author": null, "committer": null, "parents": [{"sha": "f9810422f6768b914aabfcbffe64f535bdd18452", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9810422f6768b914aabfcbffe64f535bdd18452", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9810422f6768b914aabfcbffe64f535bdd18452"}], "stats": {"total": 65, "additions": 26, "deletions": 39}, "files": [{"sha": "16bccb917eeb58d41a4749d323263a3cf5c499bc", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fa0de5994559d4f672a5528ea09433cbe6ec80/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fa0de5994559d4f672a5528ea09433cbe6ec80/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=39fa0de5994559d4f672a5528ea09433cbe6ec80", "patch": "@@ -370,6 +370,9 @@ gnat_init (void)\n   sbitsize_one_node = sbitsize_int (1);\n   sbitsize_unit_node = sbitsize_int (BITS_PER_UNIT);\n \n+  /* In Ada, we do not use location ranges.  */\n+  line_table->default_range_bits = 0;\n+\n   /* Register our internal error function.  */\n   global_dc->internal_error = &internal_error_function;\n "}, {"sha": "5a55ca4f29ef3fb0139bd634236e58771bb37b26", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 23, "deletions": 39, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39fa0de5994559d4f672a5528ea09433cbe6ec80/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39fa0de5994559d4f672a5528ea09433cbe6ec80/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=39fa0de5994559d4f672a5528ea09433cbe6ec80", "patch": "@@ -251,17 +251,27 @@ static tree build_raise_check (int, enum exception_info_kind);\n static tree create_init_temporary (const char *, tree, tree *, Node_Id);\n static bool maybe_make_gnu_thunk (Entity_Id gnat_thunk, tree gnu_thunk);\n \n-/* Hooks for debug info back-ends, only supported and used in a restricted set\n-   of configurations.  */\n-static const char *extract_encoding (const char *) ATTRIBUTE_UNUSED;\n-static const char *decode_name (const char *) ATTRIBUTE_UNUSED;\n-\n /* This makes gigi's file_info_ptr visible in this translation unit,\n    so that Sloc_to_locus can look it up when deciding whether to map\n    decls to instances.  */\n \n static struct File_Info_Type *file_map;\n \n+/* Return the string of the identifier allocated for the file name Id.  */\n+\n+static const char*\n+File_Name_to_gnu (Name_Id Id)\n+{\n+  /* __gnat_to_canonical_file_spec translates file names from pragmas\n+     Source_Reference that contain host style syntax not understood by GDB.  */\n+  const char *name = __gnat_to_canonical_file_spec (Get_Name_String (Id));\n+\n+  /* Use the identifier table to make a permanent copy of the file name as\n+     the name table gets reallocated after Gigi returns but before all the\n+     debugging information is output.  */\n+  return IDENTIFIER_POINTER (get_identifier (name));\n+}\n+\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n \n@@ -315,23 +325,18 @@ gigi (Node_Id gnat_root,\n \n   for (i = 0; i < number_file; i++)\n     {\n-      /* Use the identifier table to make a permanent copy of the filename as\n-\t the name table gets reallocated after Gigi returns but before all the\n-\t debugging information is output.  The __gnat_to_canonical_file_spec\n-\t call translates filenames from pragmas Source_Reference that contain\n-\t host style syntax not understood by gdb.  */\n-      const char *filename\n-\t= IDENTIFIER_POINTER\n-\t   (get_identifier\n-\t    (__gnat_to_canonical_file_spec\n-\t     (Get_Name_String (file_info_ptr[i].File_Name))));\n-\n       /* We rely on the order isomorphism between files and line maps.  */\n-      gcc_assert ((int) LINEMAPS_ORDINARY_USED (line_table) == i);\n+      if ((int) LINEMAPS_ORDINARY_USED (line_table) != i)\n+\t{\n+\t  gcc_assert (i > 0);\n+\t  error (\"%s contains too many lines\",\n+\t\t File_Name_to_gnu (file_info_ptr[i - 1].File_Name));\n+\t}\n \n       /* We create the line map for a source file at once, with a fixed number\n \t of columns chosen to avoid jumping over the next power of 2.  */\n-      linemap_add (line_table, LC_ENTER, 0, filename, 1);\n+      linemap_add (line_table, LC_ENTER, 0,\n+\t\t   File_Name_to_gnu (file_info_ptr[i].File_Name), 1);\n       linemap_line_start (line_table, file_info_ptr[i].Num_Source_Lines, 252);\n       linemap_position_for_column (line_table, 252 - 1);\n       linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n@@ -10401,27 +10406,6 @@ set_end_locus_from_node (tree gnu_node, Node_Id gnat_node)\n     }\n }\n \n-/* Return a colon-separated list of encodings contained in encoded Ada\n-   name.  */\n-\n-static const char *\n-extract_encoding (const char *name)\n-{\n-  char *encoding = (char *) ggc_alloc_atomic (strlen (name));\n-  get_encoding (name, encoding);\n-  return encoding;\n-}\n-\n-/* Extract the Ada name from an encoded name.  */\n-\n-static const char *\n-decode_name (const char *name)\n-{\n-  char *decoded = (char *) ggc_alloc_atomic (strlen (name) * 2 + 60);\n-  __gnat_decode (name, decoded, 0);\n-  return decoded;\n-}\n-\n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n    '&' substitution.  */"}]}