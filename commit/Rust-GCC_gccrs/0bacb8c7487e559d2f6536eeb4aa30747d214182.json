{"sha": "0bacb8c7487e559d2f6536eeb4aa30747d214182", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJhY2I4Yzc0ODdlNTU5ZDJmNjUzNmVlYjRhYTMwNzQ3ZDIxNDE4Mg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-07-03T18:09:15Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-07-03T18:09:15Z"}, "message": "c-parser.c (objc_pq_context): Removed.\n\n\t* c-parser.c (objc_pq_context): Removed.\n\t(objc_need_raw_identifier): Likewise.\n\t(c_parser) <objc_pq_context>: New field.\n\t<objc_need_raw_identifier>: Likewise.\n\t(OBJC_NEED_RAW_IDENTIFIER): Removed.\n\t(c_lex_one_token): Update.\n\t(c_parser_objc_protocol_definition): Update.\n\t(c_parser_objc_method_definition): Update.\n\t(c_parser_objc_methodproto): Update.\n\t(c_parser_declspecs): Update.\n\nFrom-SVN: r126269", "tree": {"sha": "f3db6af03a84486624f40cf61fc705951db3d2e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3db6af03a84486624f40cf61fc705951db3d2e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bacb8c7487e559d2f6536eeb4aa30747d214182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bacb8c7487e559d2f6536eeb4aa30747d214182", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bacb8c7487e559d2f6536eeb4aa30747d214182", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bacb8c7487e559d2f6536eeb4aa30747d214182/comments", "author": null, "committer": null, "parents": [{"sha": "c849ec734cf531eaf4b44662f4c3e1f4d440aad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c849ec734cf531eaf4b44662f4c3e1f4d440aad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c849ec734cf531eaf4b44662f4c3e1f4d440aad9"}], "stats": {"total": 67, "additions": 38, "deletions": 29}, "files": [{"sha": "816993d2252f7fff3293d2fdc449b51747746bc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bacb8c7487e559d2f6536eeb4aa30747d214182/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bacb8c7487e559d2f6536eeb4aa30747d214182/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bacb8c7487e559d2f6536eeb4aa30747d214182", "patch": "@@ -1,3 +1,16 @@\n+2007-07-03  Tom Tromey  <tromey@redhat.com>\n+\n+\t* c-parser.c (objc_pq_context): Removed.\n+\t(objc_need_raw_identifier): Likewise.\n+\t(c_parser) <objc_pq_context>: New field.\n+\t<objc_need_raw_identifier>: Likewise.\n+\t(OBJC_NEED_RAW_IDENTIFIER): Removed.\n+\t(c_lex_one_token): Update.\n+\t(c_parser_objc_protocol_definition): Update.\n+\t(c_parser_objc_method_definition): Update.\n+\t(c_parser_objc_methodproto): Update.\n+\t(c_parser_declspecs): Update.\n+\n 2007-07-03  David Ung  <davidu@mips.com>\n \n \t* config/mips/mips.c (mips_issue_rate): Return 4 for 74K processors."}, {"sha": "2ce49e957af52d07491da82e9a75aca7182d5d65", "filename": "gcc/c-parser.c", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bacb8c7487e559d2f6536eeb4aa30747d214182/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bacb8c7487e559d2f6536eeb4aa30747d214182/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=0bacb8c7487e559d2f6536eeb4aa30747d214182", "patch": "@@ -59,21 +59,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"cgraph.h\"\n \n \f\n-/* Objective-C specific parser/lexer information.  */\n-\n-static int objc_pq_context = 0;\n-\n-/* The following flag is needed to contextualize Objective-C lexical\n-   analysis.  In some cases (e.g., 'int NSObject;'), it is undesirable\n-   to bind an identifier to an Objective-C class, even if a class with\n-   that name exists.  */\n-static int objc_need_raw_identifier = 0;\n-#define OBJC_NEED_RAW_IDENTIFIER(VAL)\t\t\\\n-  do {\t\t\t\t\t\t\\\n-    if (c_dialect_objc ())\t\t\t\\\n-      objc_need_raw_identifier = VAL;\t\t\\\n-  } while (0)\n-\n /* The reserved keyword table.  */\n struct resword\n {\n@@ -293,6 +278,13 @@ typedef struct c_parser GTY(())\n   /* True if we're processing a pragma, and shouldn't automatically\n      consume CPP_PRAGMA_EOL.  */\n   BOOL_BITFIELD in_pragma : 1;\n+  /* Objective-C specific parser/lexer information.  */\n+  BOOL_BITFIELD objc_pq_context : 1;\n+  /* The following flag is needed to contextualize Objective-C lexical\n+     analysis.  In some cases (e.g., 'int NSObject;'), it is\n+     undesirable to bind an identifier to an Objective-C class, even\n+     if a class with that name exists.  */\n+  BOOL_BITFIELD objc_need_raw_identifier : 1;\n } c_parser;\n \n \n@@ -305,7 +297,7 @@ static GTY (()) c_parser *the_parser;\n /* Read in and lex a single token, storing it in *TOKEN.  */\n \n static void\n-c_lex_one_token (c_token *token)\n+c_lex_one_token (c_parser *parser, c_token *token)\n {\n   timevar_push (TV_LEX);\n \n@@ -321,8 +313,9 @@ c_lex_one_token (c_token *token)\n       {\n \ttree decl;\n \n-\tint objc_force_identifier = objc_need_raw_identifier;\n-\tOBJC_NEED_RAW_IDENTIFIER (0);\n+\tbool objc_force_identifier = parser->objc_need_raw_identifier;\n+\tif (c_dialect_objc ())\n+\t  parser->objc_need_raw_identifier = false;\n \n \tif (C_IS_RESERVED_WORD (token->value))\n \t  {\n@@ -331,7 +324,8 @@ c_lex_one_token (c_token *token)\n \t    if (c_dialect_objc ())\n \t      {\n \t\tif (!OBJC_IS_AT_KEYWORD (rid_code)\n-\t\t    && (!OBJC_IS_PQ_KEYWORD (rid_code) || objc_pq_context))\n+\t\t    && (!OBJC_IS_PQ_KEYWORD (rid_code)\n+\t\t\t|| parser->objc_pq_context))\n \t\t  {\n \t\t    /* Return the canonical spelling for this keyword.  */\n \t\t    token->value = ridpointers[(int) rid_code];\n@@ -388,7 +382,8 @@ c_lex_one_token (c_token *token)\n     case CPP_SEMICOLON:\n       /* These tokens may affect the interpretation of any identifiers\n \t following, if doing Objective-C.  */\n-      OBJC_NEED_RAW_IDENTIFIER (0);\n+      if (c_dialect_objc ())\n+\tparser->objc_need_raw_identifier = false;\n       break;\n     case CPP_PRAGMA:\n       /* We smuggled the cpp_token->u.pragma value in an INTEGER_CST.  */\n@@ -409,7 +404,7 @@ c_parser_peek_token (c_parser *parser)\n {\n   if (parser->tokens_avail == 0)\n     {\n-      c_lex_one_token (&parser->tokens[0]);\n+      c_lex_one_token (parser, &parser->tokens[0]);\n       parser->tokens_avail = 1;\n     }\n   return &parser->tokens[0];\n@@ -599,7 +594,7 @@ c_parser_peek_2nd_token (c_parser *parser)\n   gcc_assert (parser->tokens_avail == 1);\n   gcc_assert (parser->tokens[0].type != CPP_EOF);\n   gcc_assert (parser->tokens[0].type != CPP_PRAGMA_EOL);\n-  c_lex_one_token (&parser->tokens[1]);\n+  c_lex_one_token (parser, &parser->tokens[1]);\n   parser->tokens_avail = 2;\n   return &parser->tokens[1];\n }\n@@ -1605,7 +1600,8 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t    goto out;\n \t  attrs_ok = true;\n \t  seen_type = true;\n-\t  OBJC_NEED_RAW_IDENTIFIER (1);\n+\t  if (c_dialect_objc ())\n+\t    parser->objc_need_raw_identifier = true;\n \t  t.kind = ctsk_resword;\n \t  t.spec = c_parser_peek_token (parser)->value;\n \t  declspecs_add_type (specs, t);\n@@ -5908,11 +5904,11 @@ c_parser_objc_protocol_definition (c_parser *parser)\n       c_parser_consume_token (parser);\n       if (c_parser_next_token_is (parser, CPP_LESS))\n \tproto = c_parser_objc_protocol_refs (parser);\n-      objc_pq_context = 1;\n+      parser->objc_pq_context = true;\n       objc_start_protocol (id, proto);\n       c_parser_objc_methodprotolist (parser);\n       c_parser_require_keyword (parser, RID_AT_END, \"expected %<@end%>\");\n-      objc_pq_context = 0;\n+      parser->objc_pq_context = false;\n       objc_finish_interface ();\n     }\n }\n@@ -5952,7 +5948,7 @@ c_parser_objc_method_definition (c_parser *parser)\n   enum tree_code type = c_parser_objc_method_type (parser);\n   tree decl;\n   objc_set_method_type (type);\n-  objc_pq_context = 1;\n+  parser->objc_pq_context = true;\n   decl = c_parser_objc_method_decl (parser);\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n@@ -5965,7 +5961,7 @@ c_parser_objc_method_definition (c_parser *parser)\n       c_parser_error (parser, \"expected %<{%>\");\n       return;\n     }\n-  objc_pq_context = 0;\n+  parser->objc_pq_context = false;\n   objc_start_method_definition (decl);\n   add_stmt (c_parser_compound_statement (parser));\n   objc_finish_method_definition (current_function_decl);\n@@ -6029,10 +6025,10 @@ c_parser_objc_methodproto (c_parser *parser)\n   tree decl;\n   objc_set_method_type (type);\n   /* Remember protocol qualifiers in prototypes.  */\n-  objc_pq_context = 1;\n+  parser->objc_pq_context = true;\n   decl = c_parser_objc_method_decl (parser);\n   /* Forget protocol qualifiers here.  */\n-  objc_pq_context = 0;\n+  parser->objc_pq_context = false;\n   objc_add_method_declaration (decl);\n   c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n }"}]}