{"sha": "0f6d54f720796f2ebcb15764ac0d0b174529367d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY2ZDU0ZjcyMDc5NmYyZWJjYjE1NzY0YWMwZDBiMTc0NTI5MzY3ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-05-03T07:46:10Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-05-03T07:46:10Z"}, "message": "hooks.h (hook_bool_mode_uhwi_false): Declare.\n\ngcc/\n\t* hooks.h (hook_bool_mode_uhwi_false): Declare.\n\t* hooks.c (hook_bool_mode_uhwi_false): New function.\n\t* target.def (array_mode_supported_p): New hook.\n\t* doc/tm.texi.in (TARGET_ARRAY_MODE_SUPPORTED_P): Add @hook.\n\t* doc/tm.texi: Regenerate.\n\t* stor-layout.c (mode_for_array): New function.\n\t(layout_type): Use it.\n\t* config/arm/arm.c (arm_array_mode_supported_p): New function.\n\t(TARGET_ARRAY_MODE_SUPPORTED_P): Define.\n\nFrom-SVN: r173290", "tree": {"sha": "0a9929f4d33aeb581d3ef899196493bcc28993e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a9929f4d33aeb581d3ef899196493bcc28993e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f6d54f720796f2ebcb15764ac0d0b174529367d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6d54f720796f2ebcb15764ac0d0b174529367d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f6d54f720796f2ebcb15764ac0d0b174529367d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f6d54f720796f2ebcb15764ac0d0b174529367d/comments", "author": null, "committer": null, "parents": [{"sha": "b15eacc7da352ad393b29bd35b71019f1da2af7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b15eacc7da352ad393b29bd35b71019f1da2af7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b15eacc7da352ad393b29bd35b71019f1da2af7d"}], "stats": {"total": 141, "additions": 133, "deletions": 8}, "files": [{"sha": "f67a0db60d90226f0a58fff86189d7cf2ddc6a74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -1,3 +1,15 @@\n+2011-05-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* hooks.h (hook_bool_mode_uhwi_false): Declare.\n+\t* hooks.c (hook_bool_mode_uhwi_false): New function.\n+\t* target.def (array_mode_supported_p): New hook.\n+\t* doc/tm.texi.in (TARGET_ARRAY_MODE_SUPPORTED_P): Add @hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* stor-layout.c (mode_for_array): New function.\n+\t(layout_type): Use it.\n+\t* config/arm/arm.c (arm_array_mode_supported_p): New function.\n+\t(TARGET_ARRAY_MODE_SUPPORTED_P): Define.\n+\n 2011-05-03  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/48723"}, {"sha": "4f9c2aa706371997372984c130038f1c6d84f3ec", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -243,6 +243,8 @@ static rtx arm_pic_static_addr (rtx orig, rtx reg);\n static bool cortex_a9_sched_adjust_cost (rtx, rtx, rtx, int *);\n static bool xscale_sched_adjust_cost (rtx, rtx, rtx, int *);\n static bool fa726te_sched_adjust_cost (rtx, rtx, rtx, int *);\n+static bool arm_array_mode_supported_p (enum machine_mode,\n+\t\t\t\t\tunsigned HOST_WIDE_INT);\n static enum machine_mode arm_preferred_simd_mode (enum machine_mode);\n static bool arm_class_likely_spilled_p (reg_class_t);\n static bool arm_vector_alignment_reachable (const_tree type, bool is_packed);\n@@ -399,6 +401,8 @@ static const struct default_options arm_option_optimization_table[] =\n #define TARGET_SHIFT_TRUNCATION_MASK arm_shift_truncation_mask\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P arm_vector_mode_supported_p\n+#undef TARGET_ARRAY_MODE_SUPPORTED_P\n+#define TARGET_ARRAY_MODE_SUPPORTED_P arm_array_mode_supported_p\n #undef TARGET_VECTORIZE_PREFERRED_SIMD_MODE\n #define TARGET_VECTORIZE_PREFERRED_SIMD_MODE arm_preferred_simd_mode\n #undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n@@ -22453,6 +22457,20 @@ arm_vector_mode_supported_p (enum machine_mode mode)\n   return false;\n }\n \n+/* Implements target hook array_mode_supported_p.  */\n+\n+static bool\n+arm_array_mode_supported_p (enum machine_mode mode,\n+\t\t\t    unsigned HOST_WIDE_INT nelems)\n+{\n+  if (TARGET_NEON\n+      && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))\n+      && (nelems >= 2 && nelems <= 4))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Use the option -mvectorize-with-neon-quad to override the use of doubleword\n    registers when autovectorizing for Neon, at least until multiple vector\n    widths are supported properly by the middle-end.  */"}, {"sha": "7351e8338b888bf3ef8c9c1757e0f2f6679d6994", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -4277,6 +4277,34 @@ insns involving vector mode @var{mode}.  At the very least, it\n must have move patterns for this mode.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_ARRAY_MODE_SUPPORTED_P (enum machine_mode @var{mode}, unsigned HOST_WIDE_INT @var{nelems})\n+Return true if GCC should try to use a scalar mode to store an array\n+of @var{nelems} elements, given that each element has mode @var{mode}.\n+Returning true here overrides the usual @code{MAX_FIXED_MODE} limit\n+and allows GCC to use any defined integer mode.\n+\n+One use of this hook is to support vector load and store operations\n+that operate on several homogeneous vectors.  For example, ARM NEON\n+has operations like:\n+\n+@smallexample\n+int8x8x3_t vld3_s8 (const int8_t *)\n+@end smallexample\n+\n+where the return type is defined as:\n+\n+@smallexample\n+typedef struct int8x8x3_t\n+@{\n+  int8x8_t val[3];\n+@} int8x8x3_t;\n+@end smallexample\n+\n+If this hook allows @code{val} to have a scalar mode, then\n+@code{int8x8x3_t} can have the same mode.  GCC can then store\n+@code{int8x8x3_t}s in registers rather than forcing them onto the stack.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P (enum machine_mode @var{mode})\n Define this to return nonzero for machine modes for which the port has\n small register classes.  If this target hook returns nonzero for a given"}, {"sha": "45d5982eb7bb3d917c9b65ab993976202fe3c4d5", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -4263,6 +4263,8 @@ insns involving vector mode @var{mode}.  At the very least, it\n must have move patterns for this mode.\n @end deftypefn\n \n+@hook TARGET_ARRAY_MODE_SUPPORTED_P\n+\n @hook TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P\n Define this to return nonzero for machine modes for which the port has\n small register classes.  If this target hook returns nonzero for a given"}, {"sha": "9dfde822a5f513d7f4df7ec445faccbefe62d095", "filename": "gcc/hooks.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -117,6 +117,15 @@ hook_bool_mode_rtx_true (enum machine_mode mode ATTRIBUTE_UNUSED,\n   return true;\n }\n \n+/* Generic hook that takes (enum machine_mode, unsigned HOST_WIDE_INT)\n+   and returns false.  */\n+bool\n+hook_bool_mode_uhwi_false (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t   unsigned HOST_WIDE_INT value ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *a ATTRIBUTE_UNUSED, const char *b ATTRIBUTE_UNUSED)"}, {"sha": "a1b011203d5b6f16dd77a046935474a7747fc945", "filename": "gcc/hooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -36,6 +36,8 @@ extern bool hook_bool_mode_const_rtx_false (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_const_rtx_true (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_rtx_false (enum machine_mode, rtx);\n extern bool hook_bool_mode_rtx_true (enum machine_mode, rtx);\n+extern bool hook_bool_mode_uhwi_false (enum machine_mode,\n+\t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);\n extern bool hook_bool_tree_true (tree);"}, {"sha": "62de10de54a8381790540898c388962439e810be", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -546,6 +546,34 @@ get_mode_alignment (enum machine_mode mode)\n   return MIN (BIGGEST_ALIGNMENT, MAX (1, mode_base_align[mode]*BITS_PER_UNIT));\n }\n \n+/* Return the natural mode of an array, given that it is SIZE bytes in\n+   total and has elements of type ELEM_TYPE.  */\n+\n+static enum machine_mode\n+mode_for_array (tree elem_type, tree size)\n+{\n+  tree elem_size;\n+  unsigned HOST_WIDE_INT int_size, int_elem_size;\n+  bool limit_p;\n+\n+  /* One-element arrays get the component type's mode.  */\n+  elem_size = TYPE_SIZE (elem_type);\n+  if (simple_cst_equal (size, elem_size))\n+    return TYPE_MODE (elem_type);\n+\n+  limit_p = true;\n+  if (host_integerp (size, 1) && host_integerp (elem_size, 1))\n+    {\n+      int_size = tree_low_cst (size, 1);\n+      int_elem_size = tree_low_cst (elem_size, 1);\n+      if (int_elem_size > 0\n+\t  && int_size % int_elem_size == 0\n+\t  && targetm.array_mode_supported_p (TYPE_MODE (elem_type),\n+\t\t\t\t\t     int_size / int_elem_size))\n+\tlimit_p = false;\n+    }\n+  return mode_for_size_tree (size, MODE_INT, limit_p);\n+}\n \f\n /* Subroutine of layout_decl: Force alignment required for the data type.\n    But if the decl itself wants greater alignment, don't override that.  */\n@@ -2040,14 +2068,8 @@ layout_type (tree type)\n \t    && (TYPE_MODE (TREE_TYPE (type)) != BLKmode\n \t\t|| TYPE_NO_FORCE_BLK (TREE_TYPE (type))))\n \t  {\n-\t    /* One-element arrays get the component type's mode.  */\n-\t    if (simple_cst_equal (TYPE_SIZE (type),\n-\t\t\t\t  TYPE_SIZE (TREE_TYPE (type))))\n-\t      SET_TYPE_MODE (type, TYPE_MODE (TREE_TYPE (type)));\n-\t    else\n-\t      SET_TYPE_MODE (type, mode_for_size_tree (TYPE_SIZE (type),\n-\t\t\t\t\t\t       MODE_INT, 1));\n-\n+\t    SET_TYPE_MODE (type, mode_for_array (TREE_TYPE (type),\n+\t\t\t\t\t\t TYPE_SIZE (type)));\n \t    if (TYPE_MODE (type) != BLKmode\n \t\t&& STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n \t\t&& TYPE_ALIGN (type) < GET_MODE_ALIGNMENT (TYPE_MODE (type)))"}, {"sha": "754713fe493c747014414e79278cc9db803b1568", "filename": "gcc/target.def", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f6d54f720796f2ebcb15764ac0d0b174529367d/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=0f6d54f720796f2ebcb15764ac0d0b174529367d", "patch": "@@ -1565,6 +1565,38 @@ DEFHOOK\n  bool, (enum machine_mode mode),\n  hook_bool_mode_false)\n \n+/* True if we should try to use a scalar mode to represent an array,\n+   overriding the usual MAX_FIXED_MODE limit.  */\n+DEFHOOK\n+(array_mode_supported_p,\n+ \"Return true if GCC should try to use a scalar mode to store an array\\n\\\n+of @var{nelems} elements, given that each element has mode @var{mode}.\\n\\\n+Returning true here overrides the usual @code{MAX_FIXED_MODE} limit\\n\\\n+and allows GCC to use any defined integer mode.\\n\\\n+\\n\\\n+One use of this hook is to support vector load and store operations\\n\\\n+that operate on several homogeneous vectors.  For example, ARM NEON\\n\\\n+has operations like:\\n\\\n+\\n\\\n+@smallexample\\n\\\n+int8x8x3_t vld3_s8 (const int8_t *)\\n\\\n+@end smallexample\\n\\\n+\\n\\\n+where the return type is defined as:\\n\\\n+\\n\\\n+@smallexample\\n\\\n+typedef struct int8x8x3_t\\n\\\n+@{\\n\\\n+  int8x8_t val[3];\\n\\\n+@} int8x8x3_t;\\n\\\n+@end smallexample\\n\\\n+\\n\\\n+If this hook allows @code{val} to have a scalar mode, then\\n\\\n+@code{int8x8x3_t} can have the same mode.  GCC can then store\\n\\\n+@code{int8x8x3_t}s in registers rather than forcing them onto the stack.\",\n+ bool, (enum machine_mode mode, unsigned HOST_WIDE_INT nelems),\n+ hook_bool_mode_uhwi_false)\n+\n /* Compute cost of moving data from a register of class FROM to one of\n    TO, using MODE.  */\n DEFHOOK"}]}