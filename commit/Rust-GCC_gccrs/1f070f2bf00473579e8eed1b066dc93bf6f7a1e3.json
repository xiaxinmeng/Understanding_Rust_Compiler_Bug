{"sha": "1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYwNzBmMmJmMDA0NzM1NzllOGVlZDFiMDY2ZGM5M2JmNmY3YTFlMw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2004-10-04T00:40:26Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2004-10-04T00:40:26Z"}, "message": "Convert diagnostics to use quoting flag q 2/n\n\n        Convert diagnostics to use quoting flag q 2/n\n        * class.c (build_base_path, add_method, alter_access,\n        handle_using_decl, check_bases,\n        maybe_warn_about_overly_private_class, find_final_overrider,\n        warn_hidden, finish_struct_anon,\n        add_implicitly_declared_members,\n        check_bitfield_decl, check_field_decls, layout_empty_base,\n        build_base_field, check_methods, layout_virtual_bases,\n        warn_about_ambiguous_bases, layout_class_type,\n        finish_struct_1,\n        resolve_address_of_overloaded_function, instantiate_type,\n        note_name_declared_in_class): Use format flag \"q\" for quoting.\n\nFrom-SVN: r88473", "tree": {"sha": "01aa51ba09be89872ae63db2af49c4e7d18ce872", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01aa51ba09be89872ae63db2af49c4e7d18ce872"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e6fecd0132e22dbd73c08e0317b9d01a4b62cd3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6fecd0132e22dbd73c08e0317b9d01a4b62cd3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6fecd0132e22dbd73c08e0317b9d01a4b62cd3d"}], "stats": {"total": 160, "additions": 88, "deletions": 72}, "files": [{"sha": "a3b396d134c94b3537507f4657edb07965d50420", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "patch": "@@ -1,3 +1,16 @@\n+2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tConvert diagnostics to use quoting flag q 2/n\n+\t* class.c (build_base_path, add_method, alter_access,\n+\thandle_using_decl, check_bases,\n+\tmaybe_warn_about_overly_private_class, find_final_overrider,\n+\twarn_hidden, finish_struct_anon, add_implicitly_declared_members,\n+\tcheck_bitfield_decl, check_field_decls, layout_empty_base,\n+\tbuild_base_field, check_methods, layout_virtual_bases,\n+\twarn_about_ambiguous_bases, layout_class_type, finish_struct_1,\n+\tresolve_address_of_overloaded_function, instantiate_type,\n+\tnote_name_declared_in_class): Use format flag \"q\" for quoting.\n+\n 2004-10-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \tConvert diagnostics to use quoting flag q 1/n"}, {"sha": "c2ac0a699d269019357bbc1b2d0f6764a6c89348", "filename": "gcc/cp/class.c", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f070f2bf00473579e8eed1b066dc93bf6f7a1e3/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=1f070f2bf00473579e8eed1b066dc93bf6f7a1e3", "patch": "@@ -273,7 +273,7 @@ build_base_path (enum tree_code code,\n \n   if (code == MINUS_EXPR && v_binfo)\n     {\n-      error (\"cannot convert from base `%T' to derived type `%T' via virtual base `%T'\",\n+      error (\"cannot convert from base %qT to derived type %qT via virtual base %qT\",\n \t     BINFO_TYPE (binfo), BINFO_TYPE (d_binfo), BINFO_TYPE (v_binfo));\n       return error_mark_node;\n     }\n@@ -885,8 +885,8 @@ add_method (tree type, tree method)\n       \n       if (TYPE_FOR_JAVA (type))\n \terror (DECL_ARTIFICIAL (method)\n-\t       ? \"Java class '%T' cannot have an implicit non-trivial destructor\"\n-\t       : \"Java class '%T' cannot have a destructor\",\n+\t       ? \"Java class %qT cannot have an implicit non-trivial destructor\"\n+\t       : \"Java class %qT cannot have a destructor\",\n \t       DECL_CONTEXT (method));\n     }\n   else\n@@ -1042,9 +1042,10 @@ alter_access (tree t, tree fdecl, tree access)\n       if (TREE_VALUE (elem) != access)\n \t{\n \t  if (TREE_CODE (TREE_TYPE (fdecl)) == FUNCTION_DECL)\n-\t    cp_error_at (\"conflicting access specifications for method `%D', ignored\", TREE_TYPE (fdecl));\n+\t    cp_error_at (\"conflicting access specifications for method\"\n+                         \" %qD, ignored\", TREE_TYPE (fdecl));\n \t  else\n-\t    error (\"conflicting access specifications for field `%E', ignored\",\n+\t    error (\"conflicting access specifications for field %qE, ignored\",\n \t\t   DECL_NAME (fdecl));\n \t}\n       else\n@@ -1094,20 +1095,20 @@ handle_using_decl (tree using_decl, tree t)\n   \n   if (constructor_name_p (name, ctype))\n     {\n-      cp_error_at (\"`%D' names constructor\", using_decl);\n+      cp_error_at (\"%qD names constructor\", using_decl);\n       return;\n     }\n   if (constructor_name_p (name, t))\n     {\n-      cp_error_at (\"`%D' invalid in `%T'\", using_decl, t);\n+      cp_error_at (\"%qD invalid in %qT\", using_decl, t);\n       return;\n     }\n \n   fdecl = lookup_member (binfo, name, 0, false);\n   \n   if (!fdecl)\n     {\n-      cp_error_at (\"no members matching `%D' in `%#T'\", using_decl, ctype);\n+      cp_error_at (\"no members matching %qD in %q#T\", using_decl, ctype);\n       return;\n     }\n \n@@ -1139,16 +1140,16 @@ handle_using_decl (tree using_decl, tree t)\n \t   the same name already present in the current class.  */;\n       else\n \t{\n-\t  cp_error_at (\"`%D' invalid in `%#T'\", using_decl, t);\n-\t  cp_error_at (\"  because of local method `%#D' with same name\",\n+\t  cp_error_at (\"%qD invalid in %q#T\", using_decl, t);\n+\t  cp_error_at (\"  because of local method %q#D with same name\",\n \t\t       OVL_CURRENT (old_value));\n \t  return;\n \t}\n     }\n   else if (!DECL_ARTIFICIAL (old_value))\n     {\n-      cp_error_at (\"`%D' invalid in `%#T'\", using_decl, t);\n-      cp_error_at (\"  because of local member `%#D' with same name\", old_value);\n+      cp_error_at (\"%qD invalid in %q#T\", using_decl, t);\n+      cp_error_at (\"  because of local member %q#D with same name\", old_value);\n       return;\n     }\n   \n@@ -1193,8 +1194,7 @@ check_bases (tree t,\n \t dtor is handled in finish_struct_1.  */\n       if (warn_ecpp && ! TYPE_POLYMORPHIC_P (basetype)\n \t  && TYPE_HAS_DESTRUCTOR (basetype))\n-\twarning (\"base class `%#T' has a non-virtual destructor\",\n-\t\t    basetype);\n+\twarning (\"base class %q#T has a non-virtual destructor\", basetype);\n \n       /* If the base class doesn't have copy constructors or\n \t assignment operators that take const references, then the\n@@ -1213,8 +1213,9 @@ check_bases (tree t,\n \t{\n \t  *cant_have_default_ctor_p = 1;\n \t  if (! TYPE_HAS_CONSTRUCTOR (t))\n-            pedwarn (\"base `%T' with only non-default constructor in class without a constructor\",\n-                        basetype);\n+            pedwarn (\"base %qT with only non-default constructor in class \"\n+                     \"without a constructor\",\n+                     basetype);\n \t}\n \n       if (BINFO_VIRTUAL_P (base_binfo))\n@@ -1519,7 +1520,7 @@ maybe_warn_about_overly_private_class (tree t)\n \t  }\n       if (!has_nonprivate_method) \n \t{\n-\t  warning (\"all member functions in class `%T' are private\", t);\n+\t  warning (\"all member functions in class %qT are private\", t);\n \t  return;\n \t}\n     }\n@@ -1530,7 +1531,7 @@ maybe_warn_about_overly_private_class (tree t)\n   if (TYPE_HAS_DESTRUCTOR (t)\n       && TREE_PRIVATE (CLASSTYPE_DESTRUCTORS (t)))\n     {\n-      warning (\"`%#T' only defines a private destructor and has no friends\",\n+      warning (\"%q#T only defines a private destructor and has no friends\",\n \t       t);\n       return;\n     }\n@@ -1570,8 +1571,8 @@ maybe_warn_about_overly_private_class (tree t)\n \n       if (nonprivate_ctor == 0)\n \t{\n-\t  warning (\"`%#T' only defines private constructors and has no friends\",\n-\t\t      t);\n+\t  warning (\"%q#T only defines private constructors and has no friends\",\n+                   t);\n \t  return;\n \t}\n     }\n@@ -1951,7 +1952,7 @@ find_final_overrider (tree derived, tree binfo, tree fn)\n   /* If there was no winner, issue an error message.  */\n   if (!ffod.candidates || TREE_CHAIN (ffod.candidates))\n     {\n-      error (\"no unique final overrider for `%D' in `%T'\", fn, \n+      error (\"no unique final overrider for %qD in %qT\", fn, \n \t     BINFO_TYPE (derived));\n       return error_mark_node;\n     }\n@@ -2405,8 +2406,8 @@ warn_hidden (tree t)\n       while (base_fndecls) \n \t{\n \t  /* Here we know it is a hider, and no overrider exists.  */\n-\t  cp_warning_at (\"`%D' was hidden\", TREE_VALUE (base_fndecls));\n-\t  cp_warning_at (\"  by `%D'\", fns);\n+\t  cp_warning_at (\"%qD was hidden\", TREE_VALUE (base_fndecls));\n+\t  cp_warning_at (\"  by %qD\", fns);\n \t  base_fndecls = TREE_CHAIN (base_fndecls);\n \t}\n     }\n@@ -2447,16 +2448,17 @@ finish_struct_anon (tree t)\n \n \t      if (TREE_CODE (elt) != FIELD_DECL)\n \t\t{\n-\t\t  cp_pedwarn_at (\"`%#D' invalid; an anonymous union can only have non-static data members\",\n+\t\t  cp_pedwarn_at (\"%q#D invalid; an anonymous union can \"\n+                                 \"only have non-static data members\",\n \t\t\t\t elt);\n \t\t  continue;\n \t\t}\n \n \t      if (TREE_PRIVATE (elt))\n-\t\tcp_pedwarn_at (\"private member `%#D' in anonymous union\",\n+\t\tcp_pedwarn_at (\"private member %q#D in anonymous union\",\n \t\t\t       elt);\n \t      else if (TREE_PROTECTED (elt))\n-\t\tcp_pedwarn_at (\"protected member `%#D' in anonymous union\",\n+\t\tcp_pedwarn_at (\"protected member %q#D in anonymous union\",\n \t\t\t       elt);\n \n \t      TREE_PRIVATE (elt) = TREE_PRIVATE (field);\n@@ -2570,7 +2572,7 @@ add_implicitly_declared_members (tree t,\n   else\n     {\n       if (warn_abi && virtual_dtor)\n-\twarning (\"vtable layout for class `%T' may not be ABI-compliant \"\n+\twarning (\"vtable layout for class %qT may not be ABI-compliant \"\n \t\t \"and may change in a future version of GCC due to implicit \"\n \t\t \"virtual destructor\",\n \t\t t);\n@@ -2628,7 +2630,7 @@ check_bitfield_decl (tree field)\n   if (DECL_INITIAL (field)\n       && ! INTEGRAL_TYPE_P (TREE_TYPE (field)))\n     {\n-      cp_error_at (\"bit-field `%#D' with non-integral type\", field);\n+      cp_error_at (\"bit-field %q#D with non-integral type\", field);\n       w = error_mark_node;\n     }\n \n@@ -2648,24 +2650,24 @@ check_bitfield_decl (tree field)\n \n       if (TREE_CODE (w) != INTEGER_CST)\n \t{\n-\t  cp_error_at (\"bit-field `%D' width not an integer constant\",\n+\t  cp_error_at (\"bit-field %qD width not an integer constant\",\n \t\t       field);\n \t  w = error_mark_node;\n \t}\n       else if (tree_int_cst_sgn (w) < 0)\n \t{\n-\t  cp_error_at (\"negative width in bit-field `%D'\", field);\n+\t  cp_error_at (\"negative width in bit-field %qD\", field);\n \t  w = error_mark_node;\n \t}\n       else if (integer_zerop (w) && DECL_NAME (field) != 0)\n \t{\n-\t  cp_error_at (\"zero width for bit-field `%D'\", field);\n+\t  cp_error_at (\"zero width for bit-field %qD\", field);\n \t  w = error_mark_node;\n \t}\n       else if (compare_tree_int (w, TYPE_PRECISION (type)) > 0\n \t       && TREE_CODE (type) != ENUMERAL_TYPE\n \t       && TREE_CODE (type) != BOOLEAN_TYPE)\n-\tcp_warning_at (\"width of `%D' exceeds its type\", field);\n+\tcp_warning_at (\"width of %qD exceeds its type\", field);\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t       && (0 > compare_tree_int (w,\n \t\t\t\t\t min_precision (TYPE_MIN_VALUE (type),\n@@ -2674,7 +2676,7 @@ check_bitfield_decl (tree field)\n \t\t\t\t\t     min_precision\n \t\t\t\t\t     (TYPE_MAX_VALUE (type),\n \t\t\t\t\t      TYPE_UNSIGNED (type)))))\n-\tcp_warning_at (\"`%D' is too small to hold all values of `%#T'\",\n+\tcp_warning_at (\"%qD is too small to hold all values of %q#T\",\n \t\t       field, type);\n     }\n   \n@@ -2736,13 +2738,13 @@ check_field_decl (tree field,\n       if (TREE_CODE (t) == UNION_TYPE)\n \t{\n \t  if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    cp_error_at (\"member `%#D' with constructor not allowed in union\",\n+\t    cp_error_at (\"member %q#D with constructor not allowed in union\",\n \t\t\t field);\n \t  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n-\t    cp_error_at (\"member `%#D' with destructor not allowed in union\",\n+\t    cp_error_at (\"member %q#D with destructor not allowed in union\",\n \t\t\t field);\n \t  if (TYPE_HAS_COMPLEX_ASSIGN_REF (type))\n-\t    cp_error_at (\"member `%#D' with copy assignment operator not allowed in union\",\n+\t    cp_error_at (\"member %q#D with copy assignment operator not allowed in union\",\n \t\t\t field);\n \t}\n       else\n@@ -2769,7 +2771,7 @@ check_field_decl (tree field,\n       /* `build_class_init_list' does not recognize\n \t non-FIELD_DECLs.  */\n       if (TREE_CODE (t) == UNION_TYPE && any_default_members != 0)\n-\terror (\"multiple fields in union `%T' initialized\", t);\n+\terror (\"multiple fields in union %qT initialized\", t);\n       *any_default_members = 1;\n     }\n }\n@@ -2835,7 +2837,7 @@ check_field_decls (tree t, tree *access_decls,\n \t    {\n \t      if (!pod_type_p (TREE_TYPE (x)) && !TYPE_PACKED (TREE_TYPE (x)))\n \t\tcp_warning_at\n-\t\t  (\"ignoring packed attribute on unpacked non-POD field `%#D'\",\n+\t\t  (\"ignoring packed attribute on unpacked non-POD field %q#D\",\n \t\t   x);\n \t      else\n \t\tDECL_PACKED (x) = 1;\n@@ -2895,33 +2897,32 @@ check_field_decls (tree t, tree *access_decls,\n \t     reference type, the program is ill-formed.  */\n \t  if (TREE_CODE (x) == VAR_DECL)\n \t    {\n-\t      cp_error_at (\"`%D' may not be static because it is a member of a union\", x);\n+\t      cp_error_at (\"%qD may not be static because it is a member of a union\", x);\n \t      continue;\n \t    }\n \t  if (TREE_CODE (type) == REFERENCE_TYPE)\n \t    {\n-\t      cp_error_at (\"`%D' may not have reference type `%T' because it is a member of a union\",\n+\t      cp_error_at (\"%qD may not have reference type `%T' because it is a member of a union\",\n \t\t\t   x, type);\n \t      continue;\n \t    }\n \t}\n \n       /* ``A local class cannot have static data members.'' ARM 9.4 */\n       if (current_function_decl && TREE_STATIC (x))\n-\tcp_error_at (\"field `%D' in local class cannot be static\", x);\n+\tcp_error_at (\"field %qD in local class cannot be static\", x);\n \n       /* Perform error checking that did not get done in\n \t grokdeclarator.  */\n       if (TREE_CODE (type) == FUNCTION_TYPE)\n \t{\n-\t  cp_error_at (\"field `%D' invalidly declared function type\",\n-\t\t       x);\n+\t  cp_error_at (\"field %qD invalidly declared function type\", x);\n \t  type = build_pointer_type (type);\n \t  TREE_TYPE (x) = type;\n \t}\n       else if (TREE_CODE (type) == METHOD_TYPE)\n \t{\n-\t  cp_error_at (\"field `%D' invalidly declared method type\", x);\n+\t  cp_error_at (\"field %qD invalidly declared method type\", x);\n \t  type = build_pointer_type (type);\n \t  TREE_TYPE (x) = type;\n \t}\n@@ -2954,7 +2955,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-            cp_warning_at (\"non-static reference `%#D' in class without a constructor\", x);\n+            cp_warning_at (\"non-static reference %q#D in class without a constructor\", x);\n \t}\n \n       type = strip_array_types (type);\n@@ -3002,7 +3003,7 @@ check_field_decls (tree t, tree *access_decls,\n \n \t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n \t      && extra_warnings)\n-            cp_warning_at (\"non-static const member `%#D' in class without a constructor\", x);\n+            cp_warning_at (\"non-static const member %q#D in class without a constructor\", x);\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -3017,7 +3018,7 @@ check_field_decls (tree t, tree *access_decls,\n \t different name from the class iff the class has a\n \t user-defined constructor.  */\n       if (constructor_name_p (DECL_NAME (x), t) && TYPE_HAS_CONSTRUCTOR (t))\n-\tcp_pedwarn_at (\"field `%#D' with same name as class\", x);\n+\tcp_pedwarn_at (\"field %q#D with same name as class\", x);\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n \t If the type and width are valid, we'll also set DECL_BIT_FIELD.  */\n@@ -3051,16 +3052,16 @@ check_field_decls (tree t, tree *access_decls,\n \t&& TYPE_HAS_DESTRUCTOR (t)\n \t&& !(TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n-      warning (\"`%#T' has pointer data members\", t);\n+      warning (\"%q#T has pointer data members\", t);\n       \n       if (! TYPE_HAS_INIT_REF (t))\n \t{\n-\t  warning (\"  but does not override `%T(const %T&)'\", t, t);\n+\t  warning (\"  but does not override %<%T(const %T&)%>\", t, t);\n \t  if (! TYPE_HAS_ASSIGN_REF (t))\n-\t    warning (\"  or `operator=(const %T&)'\", t);\n+\t    warning (\"  or %<operator=(const %T&)%>\", t);\n \t}\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n-\twarning (\"  but does not override `operator=(const %T&)'\", t);\n+\twarning (\"  but does not override %<operator=(const %T&)%>\", t);\n     }\n \n \n@@ -3493,7 +3494,7 @@ layout_empty_base (tree binfo, tree eoc, splay_tree offsets)\n \tpropagate_binfo_offsets\n \t  (binfo, size_diffop (size_zero_node, BINFO_OFFSET (binfo)));\n       else if (warn_abi)\n-\twarning (\"offset of empty base `%T' may not be ABI-compliant and may\"\n+\twarning (\"offset of empty base %qT may not be ABI-compliant and may\"\n \t\t \"change in a future version of GCC\",\n \t\t BINFO_TYPE (binfo));\n     }\n@@ -3605,7 +3606,7 @@ build_base_field (record_layout_info rli, tree binfo,\n \t      if (abi_version_at_least (2))\n \t\tCLASSTYPE_NEARLY_EMPTY_P (t) = 0;\n \t      else if (warn_abi)\n-\t\twarning (\"class `%T' will be considered nearly empty in a \"\n+\t\twarning (\"class %qT will be considered nearly empty in a \"\n \t\t\t \"future version of GCC\", t);\n \t    }\n \t}\n@@ -3687,7 +3688,7 @@ check_methods (tree t)\n     {\n       check_for_override (x, t);\n       if (DECL_PURE_VIRTUAL_P (x) && ! DECL_VINDEX (x))\n-\tcp_error_at (\"initializer specified for non-virtual method `%D'\", x);\n+\tcp_error_at (\"initializer specified for non-virtual method %qD\", x);\n       /* The name of the field is the original field name\n \t Save this in auxiliary field for later overloading.  */\n       if (DECL_VINDEX (x))\n@@ -4346,7 +4347,8 @@ layout_virtual_bases (record_layout_info rli, splay_tree offsets)\n \t\t\t\t\t CLASSTYPE_ALIGN (basetype)),\n \t\t\t       bitsize_unit_node),\n \t\t   BINFO_OFFSET (vbase))))\n-\t    warning (\"offset of virtual base `%T' is not ABI-compliant and may change in a future version of GCC\",\n+\t    warning (\"offset of virtual base %qT is not ABI-compliant and \"\n+                     \"may change in a future version of GCC\",\n \t\t     basetype);\n \n \t  first_vbase = false;\n@@ -4440,7 +4442,7 @@ warn_about_ambiguous_bases (tree t)\n       basetype = BINFO_TYPE (base_binfo);\n \n       if (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n-\twarning (\"direct base `%T' inaccessible in `%T' due to ambiguity\",\n+\twarning (\"direct base %qT inaccessible in %qT due to ambiguity\",\n \t\t basetype, t);\n     }\n \n@@ -4452,7 +4454,7 @@ warn_about_ambiguous_bases (tree t)\n \tbasetype = BINFO_TYPE (binfo);\n \t\n \tif (!lookup_base (t, basetype, ba_ignore | ba_quiet, NULL))\n-\t  warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n+\t  warning (\"virtual base %qT inaccessible in %qT due to ambiguity\",\n \t\t   basetype, t);\n       }\n }\n@@ -4662,7 +4664,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t\t   && DECL_MODE (field) != TYPE_MODE (type))\n \t    /* Versions of G++ before G++ 3.4 did not reset the\n \t       DECL_MODE.  */\n-\t    warning (\"the offset of `%D' may not be ABI-compliant and may \"\n+\t    warning (\"the offset of %qD may not be ABI-compliant and may \"\n \t\t     \"change in a future version of GCC\", field);\n \t}\n       else\n@@ -4685,7 +4687,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !integer_zerop (size_binop (TRUNC_MOD_EXPR,\n \t\t\t\t\t DECL_FIELD_BIT_OFFSET (field),\n \t\t\t\t\t bitsize_unit_node)))\n-\tcp_warning_at (\"offset of `%D' is not ABI-compliant and may change in a future version of GCC\", \n+\tcp_warning_at (\"offset of %qD is not ABI-compliant and may \"\n+                       \"change in a future version of GCC\", \n \t\t       field);\n \n       /* G++ used to use DECL_FIELD_OFFSET as if it were the byte\n@@ -4694,7 +4697,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  && !tree_int_cst_equal (DECL_FIELD_OFFSET (field),\n \t\t\t\t  byte_position (field))\n \t  && contains_empty_class_p (TREE_TYPE (field)))\n-\tcp_warning_at (\"`%D' contains empty classes which may cause base \"\n+\tcp_warning_at (\"%qD contains empty classes which may cause base \"\n \t\t       \"classes to be placed at different locations in a \"\n \t\t       \"future version of GCC\",\n \t\t       field);\n@@ -4753,7 +4756,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t  TYPE_SIZE (base_t) = bitsize_zero_node;\n \t  TYPE_SIZE_UNIT (base_t) = size_zero_node;\n \t  if (warn_abi && !integer_zerop (rli_size_unit_so_far (rli)))\n-\t    warning (\"layout of classes derived from empty class `%T' \"\n+\t    warning (\"layout of classes derived from empty class %qT \"\n \t\t     \"may change in a future version of GCC\",\n \t\t     t);\n \t}\n@@ -4894,7 +4897,7 @@ finish_struct_1 (tree t)\n   if (COMPLETE_TYPE_P (t))\n     {\n       gcc_assert (IS_AGGR_TYPE (t));\n-      error (\"redefinition of `%#T'\", t);\n+      error (\"redefinition of %q#T\", t);\n       popclass ();\n       return;\n     }\n@@ -5038,7 +5041,7 @@ finish_struct_1 (tree t)\n       if (!TREE_PRIVATE (dtor) ||\n \t  (CLASSTYPE_FRIEND_CLASSES (t) ||\n \t   DECL_FRIENDLIST (TYPE_MAIN_DECL (t))))\n-\twarning (\"%#T' has virtual functions but non-virtual destructor\", t);\n+\twarning (\"%q#T has virtual functions but non-virtual destructor\", t);\n     }\n \n   complete_vars (t);\n@@ -5763,9 +5766,9 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n       /* There were *no* matches.  */\n       if (flags & tf_error)\n \t{\n- \t  error (\"no matches converting function `%D' to type `%#T'\", \n-\t\t    DECL_NAME (OVL_FUNCTION (overload)),\n-\t\t    target_type);\n+ \t  error (\"no matches converting function %qD to type %q#T\", \n+                 DECL_NAME (OVL_FUNCTION (overload)),\n+                 target_type);\n \n \t  /* print_candidates expects a chain with the functions in\n              TREE_VALUE slots, so we cons one up here (we're losing anyway,\n@@ -5786,7 +5789,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n \t{\n \t  tree match;\n \n- \t  error (\"converting overloaded function `%D' to type `%#T' is ambiguous\", \n+ \t  error (\"converting overloaded function %qD to type %q#T is ambiguous\", \n \t\t    DECL_NAME (OVL_FUNCTION (overload)),\n \t\t    target_type);\n \n@@ -5812,10 +5815,10 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n       if (!(flags & tf_error))\n         return error_mark_node;\n \n-      pedwarn (\"assuming pointer to member `%D'\", fn);\n+      pedwarn (\"assuming pointer to member %qD\", fn);\n       if (!explained)\n         {\n-          pedwarn (\"(a pointer to member can only be formed with `&%E')\", fn);\n+          pedwarn (\"(a pointer to member can only be formed with %<&%E%>)\", fn);\n           explained = 1;\n         }\n     }\n@@ -5877,7 +5880,7 @@ instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n       else\n \t{\n \t  if (flags & tf_error)\n-\t    error (\"argument of type `%T' does not match `%T'\",\n+\t    error (\"argument of type %qT does not match %qT\",\n \t\t   TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n \t}\n@@ -6289,8 +6292,8 @@ note_name_declared_in_class (tree name, tree decl)\n \t A name N used in a class S shall refer to the same declaration\n \t in its context and when re-evaluated in the completed scope of\n \t S.  */\n-      error (\"declaration of `%#D'\", decl);\n-      cp_error_at (\"changes meaning of `%D' from `%+#D'\", \n+      error (\"declaration of %q#D\", decl);\n+      cp_error_at (\"changes meaning of %qD from %q+#D\", \n \t\t   DECL_NAME (OVL_CURRENT (decl)),\n \t\t   (tree) n->value);\n     }"}]}