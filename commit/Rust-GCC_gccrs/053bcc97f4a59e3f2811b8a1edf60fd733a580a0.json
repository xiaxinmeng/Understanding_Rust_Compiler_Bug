{"sha": "053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "node_id": "C_kwDOANBUbNoAKDA1M2JjYzk3ZjRhNTllM2YyODExYjhhMWVkZjYwZmQ3MzNhNTgwYTA", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-20T10:45:02Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-01-23T03:18:02Z"}, "message": "c++: constexpr and -fno-elide-constructors [PR101072]\n\nWe've been trying for a while to avoid TARGET_EXPRs in template code, but\nthere were still a few that snuck through, and the one in this case broke\nthe code that tried to handle it.  Fixed by using IMPLICIT_CONV_EXPR, as we\nhave done elsewhere.\n\nI also noticed that finish_compound_literal was assuming that all T{init}\nwere for aggregate T, and we got a few more TARGET_EXPRs from that.  Fixed\nby only messing with TARGET_EXPR if we actually have an aggregate init.\n\n\tPR c++/101072\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (build_implicit_conv_flags): Declare.\n\t* call.cc (build_implicit_conv_flags): Split out from...\n\t(perform_implicit_conversion_flags): ...here.\n\t* decl.cc (check_initializer): Use it.\n\t* pt.cc (tsubst_copy_and_build): Remove TARGET_EXPR handling.\n\t* semantics.cc (finish_compound_literal): Don't treat\n\tscalar values like CONSTRUCTORs.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp0x/constexpr-empty14a.C: New test.", "tree": {"sha": "67c0720cf64acec9f7a48c8e0f16b3e9936dc2b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67c0720cf64acec9f7a48c8e0f16b3e9936dc2b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d43be9dcc1bef95d70fb411d98b4de0d83c6b85d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43be9dcc1bef95d70fb411d98b4de0d83c6b85d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43be9dcc1bef95d70fb411d98b4de0d83c6b85d"}], "stats": {"total": 69, "additions": 45, "deletions": 24}, "files": [{"sha": "f7f861cd16ec9fb6ac0cad5116312af7ea73060f", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -12638,6 +12638,25 @@ can_convert_arg_bad (tree to, tree from, tree arg, int flags,\n   return t != NULL;\n }\n \n+/* Return an IMPLICIT_CONV_EXPR from EXPR to TYPE with bits set from overload\n+   resolution FLAGS.  */\n+\n+tree\n+build_implicit_conv_flags (tree type, tree expr, int flags)\n+{\n+  /* In a template, we are only concerned about determining the\n+     type of non-dependent expressions, so we do not have to\n+     perform the actual conversion.  But for initializers, we\n+     need to be able to perform it at instantiation\n+     (or instantiate_non_dependent_expr) time.  */\n+  expr = build1 (IMPLICIT_CONV_EXPR, type, expr);\n+  if (!(flags & LOOKUP_ONLYCONVERTING))\n+    IMPLICIT_CONV_EXPR_DIRECT_INIT (expr) = true;\n+  if (flags & LOOKUP_NO_NARROWING)\n+    IMPLICIT_CONV_EXPR_BRACED_INIT (expr) = true;\n+  return expr;\n+}\n+\n /* Convert EXPR to TYPE.  Return the converted expression.\n \n    Note that we allow bad conversions here because by the time we get to\n@@ -12674,18 +12693,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n       expr = error_mark_node;\n     }\n   else if (processing_template_decl && conv->kind != ck_identity)\n-    {\n-      /* In a template, we are only concerned about determining the\n-\t type of non-dependent expressions, so we do not have to\n-\t perform the actual conversion.  But for initializers, we\n-\t need to be able to perform it at instantiation\n-\t (or instantiate_non_dependent_expr) time.  */\n-      expr = build1 (IMPLICIT_CONV_EXPR, type, expr);\n-      if (!(flags & LOOKUP_ONLYCONVERTING))\n-\tIMPLICIT_CONV_EXPR_DIRECT_INIT (expr) = true;\n-      if (flags & LOOKUP_NO_NARROWING)\n-\tIMPLICIT_CONV_EXPR_BRACED_INIT (expr) = true;\n-    }\n+    expr = build_implicit_conv_flags (type, expr, flags);\n   else\n     {\n       /* Give a conversion call the same location as expr.  */"}, {"sha": "b9eb71fbc3a8ef216ffa74e40c1d4c45f60d3dfd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -6599,6 +6599,7 @@ extern tree strip_top_quals\t\t\t(tree);\n extern bool reference_related_p\t\t\t(tree, tree);\n extern bool reference_compatible_p\t\t(tree, tree);\n extern int remaining_arguments\t\t\t(tree);\n+extern tree build_implicit_conv_flags\t\t(tree, tree, int);\n extern tree perform_implicit_conversion\t\t(tree, tree, tsubst_flags_t);\n extern tree perform_implicit_conversion_flags\t(tree, tree, tsubst_flags_t, int);\n extern tree build_converted_constant_expr\t(tree, tree, tsubst_flags_t);"}, {"sha": "c5d4f2f536992a3b24c655249189bb4e45370cc6", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -7235,7 +7235,12 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n \t      /* In C++20, the call to build_aggr_init could have created\n \t\t an INIT_EXPR with a CONSTRUCTOR as the RHS to handle\n \t\t A(1, 2).  */\n-\t      init = TREE_OPERAND (init_code, 1);\n+\t      tree rhs = TREE_OPERAND (init_code, 1);\n+\t      if (processing_template_decl && TREE_CODE (rhs) == TARGET_EXPR)\n+\t\t/* Avoid leaking TARGET_EXPR into template trees.  */\n+\t\trhs = build_implicit_conv_flags (type, init, flags);\n+\t      init = rhs;\n+\n \t      init_code = NULL_TREE;\n \t      /* Don't call digest_init; it's unnecessary and will complain\n \t\t about aggregate initialization of non-aggregate classes.  */"}, {"sha": "bba62a5800abb833de8b442feb12cad83e5f27d6", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -21151,15 +21151,6 @@ tsubst_copy_and_build (tree t,\n \tRETURN (build_lambda_object (r));\n       }\n \n-    case TARGET_EXPR:\n-      /* We can get here for a constant initializer of non-dependent type.\n-         FIXME stop folding in cp_parser_initializer_clause.  */\n-      {\n-\ttree r = get_target_expr_sfinae (RECUR (TARGET_EXPR_INITIAL (t)),\n-\t\t\t\t\t complain);\n-\tRETURN (r);\n-      }\n-\n     case TRANSACTION_EXPR:\n       RETURN (tsubst_expr(t, args, complain, in_decl,\n \t     integral_constant_expression_p));"}, {"sha": "07c2b3393be05e4637fde841b8990d115f92bbf2", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -3272,12 +3272,17 @@ finish_compound_literal (tree type, tree compound_literal,\n \n   /* Represent other compound literals with TARGET_EXPR so we produce\n      a prvalue, and can elide copies.  */\n-  if (!VECTOR_TYPE_P (type))\n+  if (TREE_CODE (compound_literal) == CONSTRUCTOR\n+      || TREE_CODE (compound_literal) == VEC_INIT_EXPR)\n     {\n       /* The CONSTRUCTOR is now an initializer, not a compound literal.  */\n-      TREE_HAS_CONSTRUCTOR (compound_literal) = false;\n+      if (TREE_CODE (compound_literal) == CONSTRUCTOR)\n+\tTREE_HAS_CONSTRUCTOR (compound_literal) = false;\n       compound_literal = get_target_expr_sfinae (compound_literal, complain);\n     }\n+  else\n+    /* For e.g. int{42} just make sure it's a prvalue.  */\n+    compound_literal = rvalue (compound_literal);\n \n   return compound_literal;\n }"}, {"sha": "df34cfcb8e7f6486cb927aacceef3dd8a13ec53e", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-empty14a.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty14a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/053bcc97f4a59e3f2811b8a1edf60fd733a580a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty14a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-empty14a.C?ref=053bcc97f4a59e3f2811b8a1edf60fd733a580a0", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/101072\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options -fno-elide-constructors }\n+\n+struct S {};\n+\n+template <class T> void\n+foo (S s)\n+{\n+  constexpr S x = s;\n+}"}]}