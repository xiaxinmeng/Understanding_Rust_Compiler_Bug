{"sha": "62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1NTFjNjZmZDg2N2U2NzdjOWU1ZjE2ZWQ0ZWIxNzBhMzVjZGMzYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-10-11T22:57:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-10-11T22:57:48Z"}, "message": "Makefile.in (web.o): New.\n\n\n\t* Makefile.in (web.o): New.\n\t* web.c: New file.\n\t* rtl.h (web_main): Declare.\n\t* timervar.def (TV_WEB): New.\n\t* toplev.c (dump_file_index, dump_file_info): Add DFI_web.\n\t(rest_of_hanle_web): New.\n\t(flag_web): New static variable.\n\t(lang_independent_options): Add \"web\".\n\t(rest_of_compilation): Call rest_of_handle_web.\n\t* invoke.texi (-fweb): Document.\n\t* common.opt (fweb): New.\n\t* flags.h (flag_web): New.\n\t* opts.c (decode_options): Set flag_web at -O3.\n\n\t* passes.texi (web construction):  Document.\n\t* invoke.texi (-O3): Document that -fweb is enabled.\n\n\t* regrename.c (regrename_optimize): Deal better with situation when\n\treplacement failed.\n\n\t* sched-ebb.c: Include params.h and profile.h\n\t(schedule_ebbs):  Use tracer parameters to discover superblocks\n\t* Makefile.in (sched-ebb.o):  Add dependencies.\n\nFrom-SVN: r72383", "tree": {"sha": "2eff488b5ad6159e99a3ff6f794725c55d868d40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eff488b5ad6159e99a3ff6f794725c55d868d40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/comments", "author": null, "committer": null, "parents": [{"sha": "05d362b88d8226fd136f53aac476527ea8381719", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d362b88d8226fd136f53aac476527ea8381719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05d362b88d8226fd136f53aac476527ea8381719"}], "stats": {"total": 430, "additions": 419, "deletions": 11}, "files": [{"sha": "edacc43e1a581b884cf8441860e9abcd64f7c627", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -1,3 +1,29 @@\n+2003-10-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* Makefile.in (web.o): New.\n+\t* web.c: New file.\n+\t* rtl.h (web_main): Declare.\n+\t* timervar.def (TV_WEB): New.\n+\t* toplev.c (dump_file_index, dump_file_info): Add DFI_web.\n+\t(rest_of_hanle_web): New.\n+\t(flag_web): New static variable.\n+\t(lang_independent_options): Add \"web\".\n+\t(rest_of_compilation): Call rest_of_handle_web.\n+\t* invoke.texi (-fweb): Document.\n+\t* common.opt (fweb): New.\n+\t* flags.h (flag_web): New.\n+\t* opts.c (decode_options): Set flag_web at -O3.\n+\n+\t* passes.texi (web construction):  Document.\n+\t* invoke.texi (-O3): Document that -fweb is enabled.\n+\n+\t* regrename.c (regrename_optimize): Deal better with situation when\n+\treplacement failed.\n+\n+\t* sched-ebb.c: Include params.h and profile.h\n+\t(schedule_ebbs):  Use tracer parameters to discover superblocks\n+\t* Makefile.in (sched-ebb.o):  Add dependencies.\n+\n 2003-10-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (negate_mathfn_p): New function to determine whether"}, {"sha": "3c5cf664f9abe0507918d706adb00dcd089d4426", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -847,7 +847,7 @@ OBJS-common = \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o\t\t   \\\n- alloc-pool.o et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) \n+ alloc-pool.o et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n@@ -1622,6 +1622,8 @@ cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n    except.h $(TARGET_H) $(PARAMS_H)\n+web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n+   hard-reg-set.h flags.h $(BASIC_BLOCK_H) function.h output.h toplev.h df.h\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(GGC_H) $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) except.h gt-gcse.h"}, {"sha": "26af2806a24d318517fe3712e161ffc38762c1ea", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -715,6 +715,10 @@ fverbose-asm\n Common\n Add extra commentary to assembler output\n \n+fweb\n+Common\n+Construct webs and split unrelated uses of single variable\n+\n fwrapv\n Common\n Assume signed arithmetic overflow wraps around"}, {"sha": "67d61c847348b5a450b53ac08af99e8c6dff5081", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -3680,13 +3680,14 @@ also turns on the following optimization flags:\n -fgcse   -fgcse-lm   -fgcse-sm @gol\n -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations @gol\n--fregmove @gol\n+-fregmove -@gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fsched-interblock  -fsched-spec @gol\n -fcaller-saves @gol\n -fpeephole2 @gol\n -freorder-blocks  -freorder-functions @gol\n -fstrict-aliasing @gol\n+-funit-at-a-time @gol\n -falign-functions  -falign-jumps @gol\n -falign-loops  -falign-labels}\n \n@@ -3697,7 +3698,7 @@ invoking @option{-O2} on programs that use computed gotos.\n @opindex O3\n Optimize yet more.  @option{-O3} turns on all optimizations specified by\n @option{-O2} and also turns on the @option{-finline-functions},\n-@option{-funit-at-a-time} and @option{-frename-registers} options.\n+@option{-fweb} and @option{-frename-registers} options.\n \n @item -O0\n @opindex O0"}, {"sha": "ad07f60841e24d4b00e88680bb79f6494effc3d5", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -366,6 +366,18 @@ The option @option{-dG} causes a debugging dump of the RTL code after\n this pass.  This dump file's name is made by appending @samp{.bypass}\n to the input file name.\n \n+@cindex web construction\n+@item\n+Simple optimization pass that splits independent uses of each pseudo\n+increasing effect of other optimizations.  This can improve effect of the\n+other transformation, such as CSE or register allocation.\n+Its source files are @file{web.c}.\n+\n+@opindex dZ\n+The option @option{-dZ} causes a debugging dump of the RTL code after\n+this pass.  This dump file's name is made by appending @samp{.web} to\n+the input file name.\n+\n @item\n @opindex frerun-cse-after-loop\n If @option{-frerun-cse-after-loop} was enabled, a second common"}, {"sha": "93600fbd15fdb875cb01728c5863958575cb9904", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -709,6 +709,8 @@ extern int flag_signaling_nans;\n \n extern int flag_unit_at_a_time;\n \n+extern int flag_web;\n+\n /* A string that's used when a random name is required.  NULL means\n    to make it really random.  */\n "}, {"sha": "9da64d543bb04ec79cd0dacee416340be572b0a9", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -564,6 +564,7 @@ decode_options (unsigned int argc, const char **argv)\n       flag_inline_functions = 1;\n       flag_rename_registers = 1;\n       flag_unswitch_loops = 1;\n+      flag_web = 1;\n     }\n \n   if (optimize < 2 || optimize_size)"}, {"sha": "4e93fab796bc6d21e9d2b4b3cf55f45552831309", "filename": "gcc/regrename.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -230,7 +230,7 @@ regrename_optimize (void)\n       CLEAR_HARD_REG_SET (regs_seen);\n       while (all_chains)\n \t{\n-\t  int new_reg, best_new_reg = -1;\n+\t  int new_reg, best_new_reg;\n \t  int n_uses;\n \t  struct du_chain *this = all_chains;\n \t  struct du_chain *tmp, *last;\n@@ -240,6 +240,8 @@ regrename_optimize (void)\n \n \t  all_chains = this->next_chain;\n \n+\t  best_new_reg = reg;\n+\n #if 0 /* This just disables optimization opportunities.  */\n \t  /* Only rename once we've seen the reg more than once.  */\n \t  if (! TEST_HARD_REG_BIT (regs_seen, reg))\n@@ -320,8 +322,7 @@ regrename_optimize (void)\n \t\t  break;\n \t      if (! tmp)\n \t\t{\n-\t\t  if (best_new_reg == -1\n-\t\t      || tick[best_new_reg] > tick[new_reg])\n+\t\t  if (tick[best_new_reg] > tick[new_reg])\n \t\t    best_new_reg = new_reg;\n \t\t}\n \t    }\n@@ -334,15 +335,16 @@ regrename_optimize (void)\n \t\tfprintf (rtl_dump_file, \" crosses a call\");\n \t    }\n \n-\t  if (best_new_reg == -1)\n+\t  if (best_new_reg == reg)\n \t    {\n+\t      tick[reg] = ++this_tick;\n \t      if (rtl_dump_file)\n-\t\tfprintf (rtl_dump_file, \"; no available registers\\n\");\n+\t\tfprintf (rtl_dump_file, \"; no available better choice\\n\");\n \t      continue;\n \t    }\n \n \t  do_replace (this, best_new_reg);\n-\t  tick[best_new_reg] = this_tick++;\n+\t  tick[best_new_reg] = ++this_tick;\n \n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \", renamed as %s\\n\", reg_names[best_new_reg]);"}, {"sha": "ddbda985e024ac849b7e409926865f9bc809f0f3", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -2055,6 +2055,8 @@ extern rtx remove_death (unsigned int, rtx);\n extern void dump_combine_stats (FILE *);\n extern void dump_combine_total_stats (FILE *);\n #endif\n+/* In web.c */\n+extern void web_main\t\t\tPARAMS ((void));\n \n /* In sched.c.  */\n #ifdef BUFSIZ"}, {"sha": "e005f74160ab954537dcebb6b413b1dcffa5e17f", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -39,6 +39,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"recog.h\"\n #include \"cfglayout.h\"\n+#include \"params.h\"\n #include \"sched-int.h\"\n #include \"target.h\"\n \f\n@@ -561,6 +562,13 @@ void\n schedule_ebbs (FILE *dump_file)\n {\n   basic_block bb;\n+  int probability_cutoff;\n+\n+  if (profile_info && flag_branch_probabilities)\n+    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n+  else\n+    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n+  probability_cutoff = REG_BR_PROB_BASE / 100 * probability_cutoff;\n \n   /* Taking care of this degenerate case makes the rest of\n      this code simpler.  */\n@@ -592,7 +600,7 @@ schedule_ebbs (FILE *dump_file)\n \t      break;\n \t  if (! e)\n \t    break;\n-\t  if (e->probability < REG_BR_PROB_BASE / 2)\n+\t  if (e->probability <= probability_cutoff)\n \t    break;\n \t  bb = bb->next_bb;\n \t}"}, {"sha": "99a0b09d1e7baadf656f0e5c3dbe4c9b24ec4cf7", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -69,6 +69,7 @@ DEFTIMEVAR (TV_GCSE                  , \"global CSE\")\n DEFTIMEVAR (TV_LOOP                  , \"loop analysis\")\n DEFTIMEVAR (TV_BYPASS                , \"bypass jumps\")\n DEFTIMEVAR (TV_TRACER                , \"tracer\")\n+DEFTIMEVAR (TV_WEB                   , \"web\")\n DEFTIMEVAR (TV_CSE2                  , \"CSE 2\")\n DEFTIMEVAR (TV_BRANCH_PROB           , \"branch prediction\")\n DEFTIMEVAR (TV_FLOW                  , \"flow analysis\")"}, {"sha": "797a9908360999ef2c94fcbc3dbbb960b60a1ac7", "filename": "gcc/toplev.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -266,6 +266,7 @@ enum dump_file_index\n   DFI_bp,\n   DFI_ce1,\n   DFI_tracer,\n+  DFI_web,\n   DFI_loop2,\n   DFI_cse2,\n   DFI_life,\n@@ -295,7 +296,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"            m   q         \"\n-\t\"         JK   O Q    V  YZ\"\n+\t\"         JK   O Q    V  Y \"\n */\n \n static struct dump_file_info dump_file[DFI_MAX] =\n@@ -319,6 +320,7 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"bp\",\t'b', 1, 0, 0 },\n   { \"ce1\",\t'C', 1, 0, 0 },\n   { \"tracer\",\t'T', 1, 0, 0 },\n+  { \"web\",      'Z', 0, 0, 0 },\n   { \"loop2\",\t'L', 1, 0, 0 },\n   { \"cse2\",\t't', 1, 0, 0 },\n   { \"life\",\t'f', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n@@ -654,6 +656,10 @@ int flag_complex_divide_method = 0;\n \n int flag_syntax_only = 0;\n \n+/* Nonzero means performs web construction pass.  */\n+\n+int flag_web;\n+\n /* Nonzero means perform loop optimizer.  */\n \n int flag_loop_optimize;\n@@ -1065,6 +1071,7 @@ static const lang_independent_options f_options[] =\n   {\"pcc-struct-return\", &flag_pcc_struct_return, 1 },\n   {\"reg-struct-return\", &flag_pcc_struct_return, 0 },\n   {\"delayed-branch\", &flag_delayed_branch, 1 },\n+  {\"web\", &flag_web, 1},\n   {\"gcse\", &flag_gcse, 1 },\n   {\"gcse-lm\", &flag_gcse_lm, 1 },\n   {\"gcse-sm\", &flag_gcse_sm, 1 },\n@@ -2427,6 +2434,20 @@ rest_of_handle_if_after_combine (tree decl, rtx insns)\n   timevar_pop (TV_IFCVT);\n }\n \n+static void\n+rest_of_handle_web (tree decl, rtx insns)\n+{\n+  open_dump_file (DFI_web, decl);\n+  timevar_push (TV_WEB);\n+  web_main ();\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n+  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\n+  timevar_pop (TV_WEB);\n+  close_dump_file (DFI_web, print_rtl_with_bb, insns);\n+  reg_scan (get_insns (), max_reg_num (), 0);\n+}\n+\n /* Do branch profiling and static profile estimation passes.  */\n static void\n rest_of_handle_branch_prob (tree decl, rtx insns)\n@@ -3313,6 +3334,9 @@ rest_of_compilation (tree decl)\n \n   rest_of_handle_cfg (decl, insns);\n \n+  if (flag_web)\n+    rest_of_handle_web (decl, insns);\n+\n   if (optimize > 0\n       || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     rest_of_handle_branch_prob (decl, insns);"}, {"sha": "e200453971adae024926ad75bfde9106886427d3", "filename": "gcc/web.c", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fweb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62551c66fd867e677c9e5f16ed4eb170a35cdc3a/gcc%2Fweb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fweb.c?ref=62551c66fd867e677c9e5f16ed4eb170a35cdc3a", "patch": "@@ -0,0 +1,323 @@\n+/* Web construction code for GNU compiler.\n+   Contributed by Jan Hubicka\n+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Simple optimization pass that splits indepdendent uses of each pseudo\n+   increasing effectivity of other optimizations.  The optimization can\n+   serve as an example of the use of dataflow module.\n+\n+   We don't split registers with REG_USERVAR set unless -fmessy-debugging is\n+   used, because debug information about such split variables is almost\n+   useless.  \n+\n+   TODO\n+    - Add code to keep debugging up-to-date after splitting of user variable\n+      pseudos.  This can be done by remembering all the pseudos used for the\n+      variable and use life analysis information before reload to determing\n+      wich one of the possible choices is alive and in case more are live,\n+      choose one with latest definition.\n+\n+      Some other optimization passes will benefit from the infrastructure\n+      too.\n+\n+    - We may use profile information and ignore infrequent use for purposes\n+      of web unifying inserting the compensation code later to implement full\n+      induction variable expansion for loops (currently we expand only if\n+      induction is dead afterwards, that is often the case anyway).  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"toplev.h\"\n+\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"df.h\"\n+#include \"function.h\"\n+\n+\n+/* This entry is allocated for each reference in the insn stream.  */\n+struct web_entry\n+{\n+    /* pointer to the parent in the union/find tree.  */\n+  struct web_entry *pred;\n+    /* Newly assigned register to the entry.  Set only for roots.  */\n+  rtx reg;\n+};\n+\n+static struct web_entry *unionfind_root PARAMS ((struct web_entry *));\n+static void unionfind_union\t\tPARAMS ((struct web_entry *,\n+\t\t\t\t\t\t struct web_entry *));\n+static void union_defs\t\t\tPARAMS ((struct df *, struct ref *,\n+\t\t\t\t\t\t struct web_entry *,\n+\t\t\t\t\t\t struct web_entry *));\n+static rtx entry_register\t\tPARAMS ((struct web_entry *,\n+\t\t\t\t\t\t struct ref *, char *, char *));\n+static void replace_ref\t\t\tPARAMS ((struct ref *, rtx));\n+static int mark_addressof\t\tPARAMS ((rtx *, void *));\n+\n+/* Find the root of unionfind tree (the representatnt of set).  */\n+\n+static struct web_entry *\n+unionfind_root (element)\n+     struct web_entry *element;\n+{\n+  struct web_entry *element1 = element, *element2;\n+\n+  while (element->pred)\n+    element = element->pred;\n+  while (element1->pred)\n+    {\n+      element2 = element1->pred;\n+      element1->pred = element;\n+      element1 = element2;\n+    }\n+  return element;\n+}\n+\n+/* Union sets.  */\n+\n+static void\n+unionfind_union (first, second)\n+     struct web_entry *first, *second;\n+{\n+  first = unionfind_root (first);\n+  second = unionfind_root (second);\n+  if (first == second)\n+    return;\n+  second->pred = first;\n+}\n+\n+/* For each use, all possible defs reaching it must come in same register,\n+   union them.  */\n+\n+static void\n+union_defs (df, use, def_entry, use_entry)\n+     struct df *df;\n+     struct ref *use;\n+     struct web_entry *def_entry;\n+     struct web_entry *use_entry;\n+{\n+  rtx insn = DF_REF_INSN (use);\n+  struct df_link *link = DF_REF_CHAIN (use);\n+  struct df_link *use_link = DF_INSN_USES (df, insn);\n+  struct df_link *def_link = DF_INSN_DEFS (df, insn);\n+  rtx set = single_set (insn);\n+\n+  /* Some instructions may use match_dup for it's operands.  In case the\n+     operands are dead, we will assign them different pseudos creating\n+     invalid instruction, so union all uses of the same operands for each\n+     insn.  */\n+\n+  while (use_link)\n+    {\n+      if (use != use_link->ref\n+\t  && DF_REF_REAL_REG (use) == DF_REF_REAL_REG (use_link->ref))\n+\tunionfind_union (use_entry + DF_REF_ID (use),\n+\t\t         use_entry + DF_REF_ID (use_link->ref));\n+      use_link = use_link->next;\n+    }\n+\n+  /* Recognize trivial noop moves and attempt to keep them noop.\n+     While most of noop moves should be removed we still keep some at\n+     libcall boundaries and such.  */\n+\n+  if (set\n+      && SET_SRC (set) == DF_REF_REG (use)\n+      && SET_SRC (set) == SET_DEST (set))\n+    {\n+      while (def_link)\n+\t{\n+\t  if (DF_REF_REAL_REG (use) == DF_REF_REAL_REG (def_link->ref))\n+\t    unionfind_union (use_entry + DF_REF_ID (use),\n+\t\t\t     def_entry + DF_REF_ID (def_link->ref));\n+\t  def_link = def_link->next;\n+\t}\n+    }\n+  while (link)\n+    {\n+      unionfind_union (use_entry + DF_REF_ID (use),\n+\t\t       def_entry + DF_REF_ID (link->ref));\n+      link = link->next;\n+    }\n+\n+  /* An READ_WRITE use require the corresponding def to be in the same\n+     register.  Find it and union.  */\n+  if (use->flags & DF_REF_READ_WRITE)\n+    {\n+      struct df_link *link = DF_INSN_DEFS (df, DF_REF_INSN (use));\n+\n+      while (DF_REF_REAL_REG (link->ref) != DF_REF_REAL_REG (use))\n+\tlink = link->next;\n+\n+      unionfind_union (use_entry + DF_REF_ID (use),\n+\t\t       def_entry + DF_REF_ID (link->ref));\n+    }\n+}\n+\n+/* Find corresponding register for given entry.  */\n+\n+static rtx\n+entry_register (entry, ref, used, use_addressof)\n+     struct web_entry *entry;\n+     struct ref *ref;\n+     char *used;\n+     char *use_addressof;\n+{\n+  struct web_entry *root;\n+  rtx reg, newreg;\n+\n+  /* Find corresponding web and see if it has been visited.  */\n+\n+  root = unionfind_root (entry);\n+  if (root->reg)\n+    return root->reg;\n+\n+  /* We are seeing this web first time, do the assignment.  */\n+\n+  reg = DF_REF_REAL_REG (ref);\n+\n+  /* In case the original register is already assigned, generate new one.  */\n+  if (!used[REGNO (reg)])\n+    newreg = reg, used[REGNO (reg)] = 1;\n+  else if (REG_USERVAR_P (reg) && 0/*&& !flag_messy_debugging*/)\n+    {\n+      newreg = reg;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"New web forced to keep reg=%i (user variable)\\n\",\n+\t\t REGNO (reg));\n+    }\n+  else if (use_addressof [REGNO (reg)])\n+    {\n+      newreg = reg;\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file,\n+\t\t \"New web forced to keep reg=%i (address taken)\\n\",\n+\t\t REGNO (reg));\n+    }\n+  else\n+    {\n+      newreg = gen_reg_rtx (GET_MODE (reg));\n+      REG_USERVAR_P (newreg) = REG_USERVAR_P (reg);\n+      REG_POINTER (newreg) = REG_POINTER (reg);\n+      REG_LOOP_TEST_P (newreg) = REG_LOOP_TEST_P (reg);\n+      RTX_UNCHANGING_P (newreg) = RTX_UNCHANGING_P (reg);\n+      REG_ATTRS (newreg) = REG_ATTRS (reg);\n+      if (rtl_dump_file)\n+\tfprintf (rtl_dump_file, \"Web oldreg=%i newreg=%i\\n\", REGNO (reg),\n+\t\t REGNO (newreg));\n+    }\n+\n+  root->reg = newreg;\n+  return newreg;\n+}\n+\n+/* Replace the reference by REG.  */\n+\n+static void\n+replace_ref (ref, reg)\n+   struct ref *ref;\n+   rtx reg;\n+{\n+  rtx oldreg = DF_REF_REAL_REG (ref);\n+  rtx *loc = DF_REF_REAL_LOC (ref);\n+\n+  if (oldreg == reg)\n+    return;\n+  if (rtl_dump_file)\n+    fprintf (rtl_dump_file, \"Updating insn %i (%i->%i)\\n\",\n+\t     INSN_UID (DF_REF_INSN (ref)), REGNO (oldreg), REGNO (reg)); \n+  *loc = reg;\n+}\n+\n+/* Mark each pseudo, whose address is taken.  */\n+\n+static int\n+mark_addressof (rtl, data)\n+     rtx *rtl;\n+     void *data;\n+{\n+  if (!*rtl)\n+    return 0;\n+  if (GET_CODE (*rtl) == ADDRESSOF\n+      && REG_P (XEXP (*rtl, 0)))\n+    ((char *)data)[REGNO (XEXP (*rtl, 0))] = 1;\n+  return 0;\n+}\n+\n+/* Main entry point.  */\n+\n+void\n+web_main ()\n+{\n+  struct df *df;\n+  struct web_entry *def_entry;\n+  struct web_entry *use_entry;\n+  unsigned int i;\n+  int max = max_reg_num ();\n+  char *used;\n+  char *use_addressof;\n+  rtx insn;\n+\n+  df = df_init ();\n+  df_analyse (df, 0, DF_UD_CHAIN | DF_EQUIV_NOTES);\n+\n+  def_entry =\n+    (struct web_entry *) xcalloc (df->n_defs, sizeof (struct web_entry));\n+  use_entry =\n+    (struct web_entry *) xcalloc (df->n_uses, sizeof (struct web_entry));\n+  used = (char *) xcalloc (max, sizeof (char));\n+  use_addressof = (char *) xcalloc (max, sizeof (char));\n+\n+  if (rtl_dump_file)\n+    df_dump (df, DF_UD_CHAIN | DF_DU_CHAIN, rtl_dump_file);\n+\n+  /* Produce the web.  */\n+  for (i = 0; i < df->n_uses; i++)\n+    union_defs (df, df->uses[i], def_entry, use_entry);\n+\n+  /* We can not safely rename registers whose address is taken.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (INSN_P (insn))\n+      for_each_rtx (&PATTERN (insn), mark_addressof, use_addressof);\n+\n+  /* Update the instruction stream, allocating new registers for split pseudos\n+     in progress.  */\n+  for (i = 0; i < df->n_uses; i++)\n+    replace_ref (df->uses[i], entry_register (use_entry + i, df->uses[i],\n+\t\t\t\t\t      used, use_addressof));\n+  for (i = 0; i < df->n_defs; i++)\n+    replace_ref (df->defs[i], entry_register (def_entry + i, df->defs[i],\n+\t\t\t\t\t      used, use_addressof));\n+\n+  /* Dataflow information is corrupt here, but it can be easy to update it\n+     by creating new entries for new registers and update or calilng\n+     df_insns_modify.  */\n+  free (def_entry);\n+  free (use_entry);\n+  free (used);\n+  free (use_addressof);\n+  df_finish (df);\n+}"}]}