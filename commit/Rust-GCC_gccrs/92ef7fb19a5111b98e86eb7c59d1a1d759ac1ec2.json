{"sha": "92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJlZjdmYjE5YTUxMTFiOThlODZlYjdjNTlkMWExZDc1OWFjMWVjMg==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-04-18T09:24:45Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2009-04-18T09:24:45Z"}, "message": "re PR middle-end/36902 (Array bound warning with dead code after optimization)\n\n2009-04-18  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n\n\tPR middle-end/36902\n\t* tree-vrp.c (check_array_ref): Pass a location_t instead of a\n\tpointer. Use warning_at instead of warning.\n\t(search_for_addr_array): Likewise.\n\t(check_array_bounds): Likewise.\n\t(check_all_array_refs): Check that the incoming edge is not in the\n\tlist of edges to be removed.\n\t(check_all_array_refs): Avoid the temporal pointer.\n\t(vrp_visit_cond_stmt): Fix typo.\n\t(simplify_switch_using_ranges): Handle the case where the switch\n\tindex is an integer constant.\ntestsuite/\n\t* gcc.dg/pr36902.c: New.\n\nFrom-SVN: r146305", "tree": {"sha": "eac4cee15a78ad544b9a96b83862fb6e75037cb9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eac4cee15a78ad544b9a96b83862fb6e75037cb9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/comments", "author": null, "committer": null, "parents": [{"sha": "0e097268ba02d44bba29eb8e3955cde6e9bd5c7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e097268ba02d44bba29eb8e3955cde6e9bd5c7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e097268ba02d44bba29eb8e3955cde6e9bd5c7f"}], "stats": {"total": 156, "additions": 133, "deletions": 23}, "files": [{"sha": "046da0e45db52e463d1223cea35b5faf910534b2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "patch": "@@ -1,3 +1,17 @@\n+2009-04-18  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR middle-end/36902\n+\t* tree-vrp.c (check_array_ref): Pass a location_t instead of a\n+\tpointer. Use warning_at instead of warning.\n+\t(search_for_addr_array): Likewise.\n+\t(check_array_bounds): Likewise.\n+\t(check_all_array_refs): Check that the incoming edge is not in the\n+\tlist of edges to be removed.\n+\t(check_all_array_refs): Avoid the temporal pointer.\n+\t(vrp_visit_cond_stmt): Fix typo.\n+\t(simplify_switch_using_ranges): Handle the case where the switch\n+\tindex is an integer constant.\n+\n 2009-04-18  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* config/mips/mips.c (mips_final_postscan_insn): Make it static."}, {"sha": "a2449e8ebd4b377d821cc6f7b64ffe23c77991bf", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "patch": "@@ -1,3 +1,8 @@\n+2009-04-18  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n+\n+\tPR middle-end/36902\n+\t* gcc.dg/pr36902.c: New.\n+\n 2009-04-17  Diego Novillo  <dnovillo@google.com>\n \n \t* gcc.c-torture/execute/builtins/strlen-3.c: Fix ODR"}, {"sha": "43a2d14f981f18ad252a806a4cda3bf69e28f786", "filename": "gcc/testsuite/gcc.dg/pr36902.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr36902.c?ref=92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "patch": "@@ -0,0 +1,61 @@\n+/* PR middle-end/36902 Array bound warning with dead code after optimization */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Warray-bounds -Wall -Wextra\" } */\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+\n+static inline unsigned char *\n+foo(unsigned char * to, const unsigned char * from, int n)\n+{\n+  switch ( n )\n+    {\n+    case 3:\n+      *to = *from;\n+      break;\n+    case 5:\n+      to[4] = from [4];\n+      break;\n+    }\n+  return to;\n+}\n+\n+struct {\n+  int    size_of_select;\n+  unsigned char pcr_select[4];\n+} sel;\n+\n+int bar(void)\n+{\n+  static unsigned char buf[64];\n+\n+  sel.size_of_select = 3;\n+  foo(buf, sel.pcr_select, sel.size_of_select);\n+\n+  return 1;\n+}\n+\n+\n+static inline unsigned char *\n+foo2(unsigned char * to, const unsigned char * from, int n)\n+{\n+  switch ( n )\n+    {\n+    case 3:\n+      *to = *from;\n+      break;\n+    case 5:\n+      to[4] = from [4]; /* { dg-warning \"array subscript is above array bounds\" } */\n+      break;\n+    }\n+  return to;\n+}\n+\n+int baz(void)\n+{\n+  static unsigned char buf[64];\n+\n+  sel.size_of_select = 5;\n+  foo2(buf, sel.pcr_select, sel.size_of_select);\n+\n+  return 1;\n+}"}, {"sha": "a68eba605040e95f7f835b19f45454783b219753", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=92ef7fb19a5111b98e86eb7c59d1a1d759ac1ec2", "patch": "@@ -4996,7 +4996,7 @@ insert_range_assertions (void)\n    IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */\n \n static void\n-check_array_ref (tree ref, const location_t *location, bool ignore_off_by_one)\n+check_array_ref (tree ref, location_t location, bool ignore_off_by_one)\n {\n   value_range_t* vr = NULL;\n   tree low_sub, up_sub;\n@@ -5035,8 +5035,8 @@ check_array_ref (tree ref, const location_t *location, bool ignore_off_by_one)\n           && TREE_CODE (low_sub) == INTEGER_CST\n           && tree_int_cst_lt (low_sub, low_bound))\n         {\n-          warning (OPT_Warray_bounds,\n-                   \"%Harray subscript is outside array bounds\", location);\n+          warning_at (location, OPT_Warray_bounds,\n+\t\t      \"array subscript is outside array bounds\");\n           TREE_NO_WARNING (ref) = 1;\n         }\n     }\n@@ -5050,15 +5050,15 @@ check_array_ref (tree ref, const location_t *location, bool ignore_off_by_one)\n                                                         0),\n                                        up_sub)))\n     {\n-      warning (OPT_Warray_bounds, \"%Harray subscript is above array bounds\",\n-               location);\n+      warning_at (location, OPT_Warray_bounds,\n+\t\t  \"array subscript is above array bounds\");\n       TREE_NO_WARNING (ref) = 1;\n     }\n   else if (TREE_CODE (low_sub) == INTEGER_CST\n            && tree_int_cst_lt (low_sub, low_bound))\n     {\n-      warning (OPT_Warray_bounds, \"%Harray subscript is below array bounds\",\n-               location);\n+      warning_at (location, OPT_Warray_bounds,\n+\t\t  \"array subscript is below array bounds\");\n       TREE_NO_WARNING (ref) = 1;\n     }\n }\n@@ -5067,7 +5067,7 @@ check_array_ref (tree ref, const location_t *location, bool ignore_off_by_one)\n    address of an ARRAY_REF, and call check_array_ref on it.  */\n \n static void\n-search_for_addr_array (tree t, const location_t *location)\n+search_for_addr_array (tree t, location_t location)\n {\n   while (TREE_CODE (t) == SSA_NAME)\n     {\n@@ -5115,11 +5115,11 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   *walk_subtree = TRUE;\n \n   if (TREE_CODE (t) == ARRAY_REF)\n-    check_array_ref (t, location, false /*ignore_off_by_one*/);\n+    check_array_ref (t, *location, false /*ignore_off_by_one*/);\n \n   if (TREE_CODE (t) == INDIRECT_REF\n       || (TREE_CODE (t) == RETURN_EXPR && TREE_OPERAND (t, 0)))\n-    search_for_addr_array (TREE_OPERAND (t, 0), location);\n+    search_for_addr_array (TREE_OPERAND (t, 0), *location);\n \n   if (TREE_CODE (t) == ADDR_EXPR)\n     *walk_subtree = FALSE;\n@@ -5141,9 +5141,23 @@ check_all_array_refs (void)\n       /* Skip bb's that are clearly unreachable.  */\n       if (single_pred_p (bb))\n       {\n-\tbasic_block pred_bb = EDGE_PRED (bb, 0)->src;\n+\tint i;\n+\tbool reachable = true;\n+\tedge e2;\n+\tedge e = EDGE_PRED (bb, 0);\n+\tbasic_block pred_bb = e->src;\n \tgimple ls = NULL;\n \n+\tfor (i = 0; VEC_iterate (edge, to_remove_edges, i, e2); ++i)\n+\t  if (e == e2)\n+\t    {\n+\t      reachable = false;\n+\t      break;\n+\t    }\n+\n+\tif (!reachable)\n+\t  continue;\n+\n \tif (!gsi_end_p (gsi_last_bb (pred_bb)))\n \t  ls = gsi_stmt (gsi_last_bb (pred_bb));\n \n@@ -5157,7 +5171,6 @@ check_all_array_refs (void)\n       for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n \t{\n \t  gimple stmt = gsi_stmt (si);\n-\t  const location_t *location = gimple_location_ptr (stmt);\n \t  struct walk_stmt_info wi;\n \t  if (!gimple_has_location (stmt))\n \t    continue;\n@@ -5169,13 +5182,14 @@ check_all_array_refs (void)\n \t      for (i = 0; i < n; i++)\n \t\t{\n \t\t  tree arg = gimple_call_arg (stmt, i);\n-\t\t  search_for_addr_array (arg, location);\n+\t\t  search_for_addr_array (arg, gimple_location (stmt));\n \t\t}\n \t    }\n \t  else\n \t    {\n \t      memset (&wi, 0, sizeof (wi));\n-\t      wi.info = CONST_CAST (void *, (const void *) location);\n+\t      wi.info = CONST_CAST (void *, (const void *)\n+\t\t\t\t    gimple_location_ptr (stmt));\n \n \t      walk_gimple_op (gsi_stmt (si),\n \t\t\t      check_array_bounds,\n@@ -5875,7 +5889,7 @@ vrp_visit_cond_stmt (gimple stmt, edge *taken_edge_p)\n    If there is a CASE_LABEL for VAL, its index is placed in IDX and true is\n    returned.\n \n-   If there is no CASE_LABEL for VAL and the is one that is larger than VAL,\n+   If there is no CASE_LABEL for VAL and there is one that is larger than VAL,\n    it is placed in IDX and false is returned.\n \n    If VAL is larger than any CASE_LABEL, n is placed on IDX and false is\n@@ -6860,19 +6874,35 @@ simplify_switch_using_ranges (gimple stmt)\n   tree vec2;\n   switch_update su;\n \n-  if (TREE_CODE (op) != SSA_NAME)\n-    return false;\n+  if (TREE_CODE (op) == SSA_NAME)\n+    {\n+      vr = get_value_range (op);\n \n-  vr = get_value_range (op);\n+      /* We can only handle integer ranges.  */\n+      if (vr->type != VR_RANGE\n+\t  || symbolic_range_p (vr))\n+\treturn false;\n \n-  /* We can only handle integer ranges.  */\n-  if (vr->type != VR_RANGE\n-      || symbolic_range_p (vr))\n+      /* Find case label for min/max of the value range.  */\n+      take_default = !find_case_label_range (stmt, vr->min, vr->max, &i, &j);\n+    }\n+  else if (TREE_CODE (op) == INTEGER_CST)\n+    {\n+      take_default = !find_case_label_index (stmt, 1, op, &i);\n+      if (take_default)\n+\t{\n+\t  i = 1;\n+\t  j = 0;\n+\t}\n+      else \n+\t{\n+\t  j = i;\n+\t}\n+    }\n+  else\n     return false;\n \n-  /* Find case label for min/max of the value range.  */\n   n = gimple_switch_num_labels (stmt);\n-  take_default = !find_case_label_range (stmt, vr->min, vr->max, &i, &j);\n \n   /* Bail out if this is just all edges taken.  */\n   if (i == 1"}]}