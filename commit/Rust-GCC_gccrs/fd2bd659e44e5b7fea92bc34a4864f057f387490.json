{"sha": "fd2bd659e44e5b7fea92bc34a4864f057f387490", "node_id": "C_kwDOANBUbNoAKGZkMmJkNjU5ZTQ0ZTViN2ZlYTkyYmMzNGE0ODY0ZjA1N2YzODc0OTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-07-15T16:09:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-15T16:09:43Z"}, "message": "Merge #1362\n\n1362: extern crate loading  r=philberty a=philberty\n\nWIP still trying to write dejagnu to enable automated tests\r\n\r\nExtern crates statements to tell the front-end to look for another library.\r\nThe mechanism here is heavily inspired from gccgo, so when we compile a\r\nlibrary for example we invoke:\r\n\r\n```\r\n  gccrs -g -O2 -frust-crate=mylib -c src/lib.rs -o src/mylib.o\r\n```\r\n\r\nAll going well this object file will now contain extra data inside\r\n.rust-export section inside the object file which will be preserved inside\r\narchives and shared objects. When we have another application which uses\r\nthis library 'mylib'.\r\n\r\n```rust\r\n  extern crate mylib;\r\n  use mylib::foo;\r\n\r\n  fn main() {\r\n    foo();\r\n  }\r\n```\r\n\r\nWe compile using:\r\n\r\n```\r\ngcc -g -O2 -frust-crate=test -c src/main.rs -o src/main.o\r\n```\r\n\r\nWhen the extern crate line is hit the front-end will look for mylib.o,\r\nlibmylib.a, mylib.rox. If it finds a raw object file it will read the\r\n.rust-export section directly from the object for the public metadata\r\nsuch as public functions, types constants etc. If it fails to find an\r\nobject it might find .rox which is the objdump of the .rust-export to a\r\nraw file, it might even find libmylib.a and read the export directly out\r\nof the archive file reusing code from gccgo to do so.\r\n\r\nThe full compiler pipeline is reused here, so the metatadata is actually\r\njust real rust code. The benifit here is that Rust supports exporting,\r\nmacros and generics so this requires the name-resolution and type info\r\nall to be generated and inserted into the apropriate context classes. Since\r\nthe metadata is real rust code it means we can reuse the full pipeline to\r\ngenerate the code as nessecary. So for the simple case of a public struct\r\nwe simply emit the AST dump of this struct directly into the metadata. If\r\nits a non-generic public function we emit and extern rust abi block for\r\nthat function. If its a trait we can simply emit the trait with the public\r\nmemebers. Generics are more complicated since we need to emit the function\r\nfully for it to be compiled correctly this still needs tests to be added.\r\nThe hardest part is non generic impl blocks which is still a WIP.\r\n\r\nTo finally link the two crates together you run:\r\n\r\n```\r\ngcc -g -O2 -o rust-program.exe src/main.o src/mylib.o\r\n```\r\n\r\nFixes: 1169\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "a080716bf04ed6180acd115fcfbbb856ab6990b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a080716bf04ed6180acd115fcfbbb856ab6990b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd2bd659e44e5b7fea92bc34a4864f057f387490", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi0ZFHCRBK7hj4Ov3rIwAAVLEIACING3JsHAYcw4RvDkwKNl6s\naDsUA6rGM63OAb8A4w4XzBLN3C2jahXoN8NAbtA+zBU21FXyUq1/4H65+eTDaRfA\nYmBpSTp/bwFjZNY1vnMCQPn4RBr82xtQ/zCci/i+cAD2e4bImqrlPWNZSNSqahZL\nJBpHelOUxi/og3sPVWIkvG/L1QCI0F25m6nvoKUWj7VbFMWelPsfx8D+CpjOLCQa\nc6dpRFCcCFm8LTNXNaWSGkH1JdsMXRhNuGX/6GkdlREjXlvtpeiWNFqO6tKsYnWa\nLGJdwY9ZlLM0CPyioYOB5Cd5AAg0E181KZBxPffWjRHEOI7Gnva/rTVON5BS9Cg=\n=vXNz\n-----END PGP SIGNATURE-----\n", "payload": "tree a080716bf04ed6180acd115fcfbbb856ab6990b1\nparent 67f9b173b9061ceef0fd96413578b0e5ddcac061\nparent 2d1378f7310be651e2a538f192d385b136b3d697\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1657901383 +0000\ncommitter GitHub <noreply@github.com> 1657901383 +0000\n\nMerge #1362\n\n1362: extern crate loading  r=philberty a=philberty\n\nWIP still trying to write dejagnu to enable automated tests\r\n\r\nExtern crates statements to tell the front-end to look for another library.\r\nThe mechanism here is heavily inspired from gccgo, so when we compile a\r\nlibrary for example we invoke:\r\n\r\n```\r\n  gccrs -g -O2 -frust-crate=mylib -c src/lib.rs -o src/mylib.o\r\n```\r\n\r\nAll going well this object file will now contain extra data inside\r\n.rust-export section inside the object file which will be preserved inside\r\narchives and shared objects. When we have another application which uses\r\nthis library 'mylib'.\r\n\r\n```rust\r\n  extern crate mylib;\r\n  use mylib::foo;\r\n\r\n  fn main() {\r\n    foo();\r\n  }\r\n```\r\n\r\nWe compile using:\r\n\r\n```\r\ngcc -g -O2 -frust-crate=test -c src/main.rs -o src/main.o\r\n```\r\n\r\nWhen the extern crate line is hit the front-end will look for mylib.o,\r\nlibmylib.a, mylib.rox. If it finds a raw object file it will read the\r\n.rust-export section directly from the object for the public metadata\r\nsuch as public functions, types constants etc. If it fails to find an\r\nobject it might find .rox which is the objdump of the .rust-export to a\r\nraw file, it might even find libmylib.a and read the export directly out\r\nof the archive file reusing code from gccgo to do so.\r\n\r\nThe full compiler pipeline is reused here, so the metatadata is actually\r\njust real rust code. The benifit here is that Rust supports exporting,\r\nmacros and generics so this requires the name-resolution and type info\r\nall to be generated and inserted into the apropriate context classes. Since\r\nthe metadata is real rust code it means we can reuse the full pipeline to\r\ngenerate the code as nessecary. So for the simple case of a public struct\r\nwe simply emit the AST dump of this struct directly into the metadata. If\r\nits a non-generic public function we emit and extern rust abi block for\r\nthat function. If its a trait we can simply emit the trait with the public\r\nmemebers. Generics are more complicated since we need to emit the function\r\nfully for it to be compiled correctly this still needs tests to be added.\r\nThe hardest part is non generic impl blocks which is still a WIP.\r\n\r\nTo finally link the two crates together you run:\r\n\r\n```\r\ngcc -g -O2 -o rust-program.exe src/main.o src/mylib.o\r\n```\r\n\r\nFixes: 1169\r\n\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2bd659e44e5b7fea92bc34a4864f057f387490", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd2bd659e44e5b7fea92bc34a4864f057f387490", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd2bd659e44e5b7fea92bc34a4864f057f387490/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67f9b173b9061ceef0fd96413578b0e5ddcac061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67f9b173b9061ceef0fd96413578b0e5ddcac061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67f9b173b9061ceef0fd96413578b0e5ddcac061"}, {"sha": "2d1378f7310be651e2a538f192d385b136b3d697", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d1378f7310be651e2a538f192d385b136b3d697", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d1378f7310be651e2a538f192d385b136b3d697"}], "stats": {"total": 2791, "additions": 2740, "deletions": 51}, "files": [{"sha": "523680a0a524ba89049e1cfcdf8352f4a2c8dab3", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -136,6 +136,10 @@ GRS_OBJS = \\\n     rust/rust-compile-base.o \\\n     rust/rust-tree.o \\\n     rust/rust-compile-context.o \\\n+    rust/rust-export-metadata.o \\\n+    rust/rust-imports.o \\\n+    rust/rust-import-archive.o \\\n+    rust/rust-extern-crate.o \\\n     $(END)\n # removed object files from here\n \n@@ -301,7 +305,8 @@ RUST_INCLUDES = -I $(srcdir)/rust \\\n \t-I $(srcdir)/rust/typecheck \\\n \t-I $(srcdir)/rust/privacy \\\n \t-I $(srcdir)/rust/lint \\\n-\t-I $(srcdir)/rust/util\n+\t-I $(srcdir)/rust/util \\\n+        -I $(srcdir)/rust/metadata\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -371,3 +376,8 @@ rust/%.o: rust/privacy/%.cc\n rust/%.o: rust/lint/%.cc\n \t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n+\n+# build rust/metadata files in rust folder\n+rust/%.o: rust/metadata/%.cc\n+\t$(COMPILE) $(RUST_CXXFLAGS) $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "ad9ad0b7de72f9ff7be1be4509c5b03962fa6330", "filename": "gcc/rust/ast/rust-ast-dump.cc", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -69,6 +69,45 @@ Dump::format_function_param (FunctionParam &param)\n   param.get_type ()->accept_vis (*this);\n }\n \n+void\n+Dump::emit_attrib (const Attribute &attrib)\n+{\n+  stream << \"#\";\n+  stream << \"[\";\n+\n+  for (size_t i = 0; i < attrib.get_path ().get_segments ().size (); i++)\n+    {\n+      const auto &seg = attrib.get_path ().get_segments ().at (i);\n+      bool has_next = (i + 1) < attrib.get_path ().get_segments ().size ();\n+\n+      stream << seg.get_segment_name ();\n+      if (has_next)\n+\tstream << \"::\";\n+    }\n+\n+  if (attrib.has_attr_input ())\n+    {\n+      stream << \" = \";\n+\n+      bool is_literal = attrib.get_attr_input ().get_attr_input_type ()\n+\t\t\t== AST::AttrInput::AttrInputType::LITERAL;\n+      if (is_literal)\n+\t{\n+\t  auto &literal\n+\t    = static_cast<AST::AttrInputLiteral &> (attrib.get_attr_input ());\n+\t  const auto &value = literal.get_literal ().as_string ();\n+\n+\t  stream << \"\\\"\" << value << \"\\\"\";\n+\t}\n+      else\n+\t{\n+\t  stream << \"FIXME\";\n+\t}\n+    }\n+\n+  stream << \"]\";\n+}\n+\n void\n Dump::visit (Token &tok)\n {}\n@@ -440,7 +479,7 @@ Dump::visit (TypeParam &param)\n   stream << param.get_type_representation ();\n   if (param.has_type ())\n     {\n-      stream << \": \";\n+      stream << \" = \";\n       param.get_type ()->accept_vis (*this);\n     }\n }\n@@ -680,7 +719,33 @@ Dump::visit (TraitItemType &item)\n void\n Dump::visit (Trait &trait)\n {\n-  stream << \"trait \" << trait.get_identifier () << \" {\\n\";\n+  for (const auto &attr : trait.get_outer_attrs ())\n+    {\n+      emit_attrib (attr);\n+      stream << \"\\n\" << indentation;\n+    }\n+\n+  stream << \"trait \" << trait.get_identifier ();\n+\n+  // Traits actually have an implicit Self thrown at the start so we must expect\n+  // the number of generic params to be > 1\n+  if (trait.get_generic_params ().size () > 1)\n+    {\n+      stream << \"<\";\n+      for (size_t i = 1; i < trait.get_generic_params ().size (); i++)\n+\t{\n+\t  auto &param = trait.get_generic_params ().at (i);\n+\t  param->accept_vis (*this);\n+\n+\t  bool has_next = (i + 1) < trait.get_generic_params ().size ();\n+\t  if (has_next)\n+\t    stream << \", \";\n+\t}\n+      stream << \">\";\n+    }\n+\n+  stream << \" {\\n\";\n+\n   indentation.increment ();\n \n   for (auto &item : trait.get_trait_items ())"}, {"sha": "c3854e8287dbfaca0bdc699acea966fd44006fdc", "filename": "gcc/rust/ast/rust-ast-dump.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fast%2Frust-ast-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fast%2Frust-ast-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -64,6 +64,7 @@ class Dump : public ASTVisitor\n    * Format a function's definition parameter\n    */\n   void format_function_param (FunctionParam &param);\n+  void emit_attrib (const Attribute &attrib);\n \n   // rust-ast.h\n   void visit (Token &tok);"}, {"sha": "749f7ebfed27af4b690edf6ea86b324c31b6080e", "filename": "gcc/rust/expand/rust-attribute-visitor.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-attribute-visitor.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -17,8 +17,10 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-attribute-visitor.h\"\n+#include \"rust-session-manager.h\"\n \n namespace Rust {\n+\n // Visitor used to expand attributes.\n void\n AttrVisitor::expand_struct_fields (std::vector<AST::StructField> &fields)\n@@ -2147,15 +2149,22 @@ AttrVisitor::visit (AST::Module &module)\n   expand_pointer_allow_strip (module.get_items ());\n }\n void\n-AttrVisitor::visit (AST::ExternCrate &crate)\n+AttrVisitor::visit (AST::ExternCrate &extern_crate)\n {\n   // strip test based on outer attrs\n-  expander.expand_cfg_attrs (crate.get_outer_attrs ());\n-  if (expander.fails_cfg_with_expand (crate.get_outer_attrs ()))\n+  expander.expand_cfg_attrs (extern_crate.get_outer_attrs ());\n+  if (expander.fails_cfg_with_expand (extern_crate.get_outer_attrs ()))\n     {\n-      crate.mark_for_strip ();\n+      extern_crate.mark_for_strip ();\n       return;\n     }\n+\n+  if (!extern_crate.references_self ())\n+    {\n+      Session &session = Session::get_instance ();\n+      session.load_extern_crate (extern_crate.get_referenced_crate (),\n+\t\t\t\t extern_crate.get_locus ());\n+    }\n }\n void\n AttrVisitor::visit (AST::UseTreeGlob &)"}, {"sha": "1f6855ede1dd3c340d69a4fbde12a94ef9bf4c29", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -103,6 +103,14 @@ Enum(frust_edition) String(2018) Value(1)\n EnumValue\n Enum(frust_edition) String(2021) Value(2)\n \n+frust-embed-metadata\n+Rust Var(flag_rust_embed_metadata)\n+Flag to enable embeding metadata directly into object files\n+\n+frust-metadata-output=\n+Rust Joined RejectNegative\n+-frust-metadata-output=<path.rox>  Path to output crate metadata\n+\n o\n Rust Joined Separate\n ; Documented in common.opt"}, {"sha": "4856bc26149a12584dfdf57203344ff77782a6e9", "filename": "gcc/rust/metadata/rust-export-metadata.cc", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,385 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-export-metadata.h\"\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-ast-dump.h\"\n+#include \"rust-abi.h\"\n+#include \"rust-object-export.h\"\n+\n+#include \"md5.h\"\n+\n+namespace Rust {\n+namespace Metadata {\n+\n+static const std::string extension_path = \".rox\";\n+\n+ExportContext::ExportContext () : mappings (Analysis::Mappings::get ()) {}\n+\n+ExportContext::~ExportContext () {}\n+\n+void\n+ExportContext::push_module_scope (const HIR::Module &module)\n+{\n+  module_stack.push_back (module);\n+}\n+\n+const HIR::Module &\n+ExportContext::pop_module_scope ()\n+{\n+  rust_assert (!module_stack.empty ());\n+  const HIR::Module &poped = module_stack.back ();\n+  module_stack.pop_back ();\n+  return poped;\n+}\n+\n+void\n+ExportContext::emit_trait (const HIR::Trait &trait)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok\n+    = mappings->lookup_ast_item (trait.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n+\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  dumper.go (*item);\n+\n+  public_interface_buffer += oss.str ();\n+}\n+\n+void\n+ExportContext::emit_function (const HIR::Function &fn)\n+{\n+  // lookup the AST node for this\n+  AST::Item *item = nullptr;\n+  bool ok = mappings->lookup_ast_item (fn.get_mappings ().get_nodeid (), &item);\n+  rust_assert (ok);\n+\n+  // is this a CFG macro or not\n+  if (item->is_marked_for_strip ())\n+    return;\n+\n+  // FIXME add assertion that item must be a vis_item;\n+  AST::VisItem &vis_item = static_cast<AST::VisItem &> (*item);\n+\n+  // if its a generic function we need to output the full declaration\n+  // otherwise we can let people link against this\n+\n+  std::stringstream oss;\n+  AST::Dump dumper (oss);\n+  if (!fn.has_generics ())\n+    {\n+      // FIXME assert that this is actually an AST::Function\n+      AST::Function &function = static_cast<AST::Function &> (vis_item);\n+\n+      // we can emit an extern block with abi of \"rust\"\n+      Identifier item_name = function.get_function_name ();\n+\n+      // always empty for extern linkage\n+      AST::WhereClause where_clause = AST::WhereClause::create_empty ();\n+      std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n+\n+      AST::Visibility vis = function.get_visibility ();\n+      std::unique_ptr<AST::Type> return_type\n+\t= std::unique_ptr<AST::Type> (nullptr);\n+      if (function.has_return_type ())\n+\t{\n+\t  return_type = function.get_return_type ()->clone_type ();\n+\t}\n+\n+      std::vector<AST::NamedFunctionParam> function_params;\n+      for (AST::FunctionParam &param : function.get_function_params ())\n+\t{\n+\t  std::string name = param.get_pattern ()->as_string ();\n+\t  std::unique_ptr<AST::Type> param_type\n+\t    = param.get_type ()->clone_type ();\n+\n+\t  AST::NamedFunctionParam p (name, std::move (param_type), {},\n+\t\t\t\t     param.get_locus ());\n+\t  function_params.push_back (std::move (p));\n+\t}\n+\n+      AST::ExternalItem *external_item = new AST::ExternalFunctionItem (\n+\titem_name, {} /* generic_params */, std::move (return_type),\n+\twhere_clause, std::move (function_params), false /* has_variadics */,\n+\t{} /* variadic_outer_attrs */, vis, function.get_outer_attrs (),\n+\tfunction.get_locus ());\n+\n+      std::vector<std::unique_ptr<AST::ExternalItem>> external_items;\n+      external_items.push_back (\n+\tstd::unique_ptr<AST::ExternalItem> (external_item));\n+\n+      AST::ExternBlock extern_block (get_string_from_abi (Rust::ABI::RUST),\n+\t\t\t\t     std::move (external_items),\n+\t\t\t\t     vis_item.get_visibility (), {}, {},\n+\t\t\t\t     fn.get_locus ());\n+\n+      dumper.go (extern_block);\n+    }\n+  else\n+    {\n+      dumper.go (*item);\n+    }\n+\n+  // store the dump\n+  public_interface_buffer += oss.str ();\n+}\n+\n+const std::string &\n+ExportContext::get_interface_buffer () const\n+{\n+  return public_interface_buffer;\n+}\n+\n+// implicitly by using HIR nodes we know that these have passed CFG expansion\n+// and they exist in the compilation unit\n+class ExportVisItems : public HIR::HIRVisItemVisitor\n+{\n+public:\n+  ExportVisItems (ExportContext &context) : ctx (context) {}\n+\n+  void visit (HIR::Module &module) override {}\n+  void visit (HIR::ExternCrate &crate) override {}\n+  void visit (HIR::UseDeclaration &use_decl) override {}\n+  void visit (HIR::TypeAlias &type_alias) override {}\n+  void visit (HIR::StructStruct &struct_item) override {}\n+  void visit (HIR::TupleStruct &tuple_struct) override {}\n+  void visit (HIR::Enum &enum_item) override {}\n+  void visit (HIR::Union &union_item) override {}\n+  void visit (HIR::ConstantItem &const_item) override {}\n+  void visit (HIR::StaticItem &static_item) override {}\n+  void visit (HIR::ImplBlock &impl) override {}\n+  void visit (HIR::ExternBlock &block) override {}\n+\n+  void visit (HIR::Trait &trait) override { ctx.emit_trait (trait); }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    ctx.emit_function (function);\n+  }\n+\n+private:\n+  ExportContext &ctx;\n+};\n+\n+PublicInterface::PublicInterface (HIR::Crate &crate)\n+  : crate (crate), mappings (*Analysis::Mappings::get ()), context ()\n+{}\n+\n+void\n+PublicInterface::Export (HIR::Crate &crate)\n+{\n+  PublicInterface interface (crate);\n+  interface.gather_export_data ();\n+  interface.write_to_object_file ();\n+}\n+\n+void\n+PublicInterface::ExportTo (HIR::Crate &crate, const std::string &output_path)\n+{\n+  PublicInterface interface (crate);\n+  interface.gather_export_data ();\n+  interface.write_to_path (output_path);\n+}\n+\n+void\n+PublicInterface::gather_export_data ()\n+{\n+  ExportVisItems visitor (context);\n+  for (auto &item : crate.items)\n+    {\n+      bool is_vis_item = item->get_hir_kind () == HIR::Node::BaseKind::VIS_ITEM;\n+      if (!is_vis_item)\n+\tcontinue;\n+\n+      HIR::VisItem &vis_item = static_cast<HIR::VisItem &> (*item.get ());\n+      if (is_crate_public (vis_item))\n+\tvis_item.accept_vis (visitor);\n+    }\n+}\n+\n+void\n+PublicInterface::write_to_object_file () const\n+{\n+  // done\n+  const auto &buf = context.get_interface_buffer ();\n+  std::string size_buffer = std::to_string (buf.size ());\n+\n+  // md5 this\n+  struct md5_ctx chksm;\n+  unsigned char checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (buf.c_str (), buf.size (), &chksm);\n+  md5_finish_ctx (&chksm, checksum);\n+\n+  // MAGIC MD5 DLIM  DLIM buffer-size DELIM contents\n+  const std::string current_crate_name = mappings.get_current_crate_name ();\n+\n+  // extern void\n+  rust_write_export_data (kMagicHeader, sizeof (kMagicHeader));\n+  rust_write_export_data ((const char *) checksum, sizeof (checksum));\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (current_crate_name.c_str (),\n+\t\t\t  current_crate_name.size ());\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (size_buffer.c_str (), size_buffer.size ());\n+  rust_write_export_data (kSzDelim, sizeof (kSzDelim));\n+  rust_write_export_data (buf.c_str (), buf.size ());\n+}\n+\n+void\n+PublicInterface::write_to_path (const std::string &path) const\n+{\n+  // validate path contains correct extension\n+  const std::string expected_file_name = expected_metadata_filename ();\n+  const char *path_base_name = basename (path.c_str ());\n+  if (strcmp (path_base_name, expected_file_name.c_str ()) != 0)\n+    {\n+      rust_error_at (Location (),\n+\t\t     \"expected metadata-output path to have base file name of: \"\n+\t\t     \"%<%s%> got %<%s%>\",\n+\t\t     expected_file_name.c_str (), path_base_name);\n+      return;\n+    }\n+\n+  // done\n+  const auto &buf = context.get_interface_buffer ();\n+  std::string size_buffer = std::to_string (buf.size ());\n+\n+  // md5 this\n+  struct md5_ctx chksm;\n+  unsigned char checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (buf.c_str (), buf.size (), &chksm);\n+  md5_finish_ctx (&chksm, checksum);\n+\n+  // MAGIC MD5 DLIM  DLIM buffer-size DELIM contents\n+  const std::string current_crate_name = mappings.get_current_crate_name ();\n+\n+  // write to path\n+  FILE *nfd = fopen (path.c_str (), \"wb\");\n+  if (nfd == NULL)\n+    {\n+      rust_error_at (Location (), \"failed to open file %<%s%> for writing: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      return;\n+    }\n+\n+  // write data\n+  if (fwrite (kMagicHeader, sizeof (kMagicHeader), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (checksum, sizeof (checksum), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (current_crate_name.c_str (), current_crate_name.size (), 1, nfd)\n+      < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (size_buffer.c_str (), size_buffer.size (), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (fwrite (kSzDelim, sizeof (kSzDelim), 1, nfd) < 1)\n+    {\n+      rust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t     path.c_str (), xstrerror (errno));\n+      fclose (nfd);\n+      return;\n+    }\n+\n+  if (!buf.empty ())\n+    if (fwrite (buf.c_str (), buf.size (), 1, nfd) < 1)\n+      {\n+\trust_error_at (Location (), \"failed to write to file %<%s%>: %s\",\n+\t\t       path.c_str (), xstrerror (errno));\n+\tfclose (nfd);\n+\treturn;\n+      }\n+\n+  // done\n+  fclose (nfd);\n+}\n+\n+bool\n+PublicInterface::is_crate_public (const HIR::VisItem &item)\n+{\n+  const HIR::Visibility &visibility = item.get_visibility ();\n+\n+  bool is_public\n+    = visibility.get_vis_type () == HIR::Visibility::VisType::PUBLIC;\n+  bool has_path = !visibility.get_path ().is_error ();\n+\n+  // FIXME this might be pub(crate)\n+  // Arthur magic required here\n+\n+  return is_public && !has_path;\n+}\n+\n+std::string\n+PublicInterface::expected_metadata_filename ()\n+{\n+  auto mappings = Analysis::Mappings::get ();\n+\n+  const std::string current_crate_name = mappings->get_current_crate_name ();\n+  return current_crate_name + extension_path;\n+}\n+\n+} // namespace Metadata\n+} // namespace Rust"}, {"sha": "cbb6ecd65a6826d8542caed892ba6cb6dc3c4f0a", "filename": "gcc/rust/metadata/rust-export-metadata.h", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-export-metadata.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_EXPORT_METADATA_H\n+#define RUST_EXPORT_METADATA_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-hir-full-decls.h\"\n+#include \"rust-hir-map.h\"\n+\n+namespace Rust {\n+namespace Metadata {\n+\n+static const char kMagicHeader[4] = {'G', 'R', 'S', 'T'};\n+static const char kSzDelim[1] = {'$'};\n+\n+class ExportContext\n+{\n+public:\n+  ExportContext ();\n+\n+  ~ExportContext ();\n+\n+  void push_module_scope (const HIR::Module &module);\n+\n+  const HIR::Module &pop_module_scope ();\n+\n+  void emit_trait (const HIR::Trait &trait);\n+\n+  void emit_function (const HIR::Function &fn);\n+\n+  const std::string &get_interface_buffer () const;\n+\n+private:\n+  Analysis::Mappings *mappings;\n+\n+  std::vector<std::reference_wrapper<const HIR::Module>> module_stack;\n+  std::string public_interface_buffer;\n+};\n+\n+class PublicInterface\n+{\n+public:\n+  static void Export (HIR::Crate &crate);\n+\n+  static void ExportTo (HIR::Crate &crate, const std::string &output_path);\n+\n+  static bool is_crate_public (const HIR::VisItem &item);\n+\n+  static std::string expected_metadata_filename ();\n+\n+protected:\n+  void gather_export_data ();\n+\n+  void write_to_object_file () const;\n+\n+  void write_to_path (const std::string &path) const;\n+\n+private:\n+  PublicInterface (HIR::Crate &crate);\n+\n+  HIR::Crate &crate;\n+  Analysis::Mappings &mappings;\n+  ExportContext context;\n+};\n+\n+} // namespace Metadata\n+} // namespace Rust\n+\n+#endif // RUST_EXPORT_METADATA_H"}, {"sha": "614a6d917297da54c802d13564a5aa9b66170d84", "filename": "gcc/rust/metadata/rust-extern-crate.cc", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-extern-crate.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,173 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-extern-crate.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-export-metadata.h\"\n+\n+#include \"md5.h\"\n+\n+namespace Rust {\n+namespace Imports {\n+\n+ExternCrate::ExternCrate (Import::Stream &stream) : import_stream (stream) {}\n+\n+ExternCrate::~ExternCrate () {}\n+\n+bool\n+ExternCrate::ok () const\n+{\n+  return !import_stream.saw_error ();\n+}\n+\n+bool\n+ExternCrate::load (Location locus)\n+{\n+  // match header\n+  import_stream.require_bytes (locus, Metadata::kMagicHeader,\n+\t\t\t       sizeof (Metadata::kMagicHeader));\n+  if (import_stream.saw_error ())\n+    return false;\n+\n+  // parse 16 bytes md5\n+  unsigned char checksum[16];\n+  bool ok\n+    = import_stream.do_peek (sizeof (checksum), (const char **) &checksum);\n+  if (!ok)\n+    return false;\n+\n+  import_stream.advance (sizeof (checksum));\n+\n+  // parse delim\n+  import_stream.require_bytes (locus, Metadata::kSzDelim,\n+\t\t\t       sizeof (Metadata::kSzDelim));\n+  if (import_stream.saw_error ())\n+    return false;\n+\n+  // parse crate name\n+  bool saw_delim = false;\n+  while (!import_stream.saw_error () && !import_stream.at_eof ())\n+    {\n+      unsigned char byte = import_stream.get_char ();\n+      saw_delim\n+\t= memcmp (&byte, Metadata::kSzDelim, sizeof (Metadata::kSzDelim)) == 0;\n+      if (saw_delim)\n+\tbreak;\n+\n+      crate_name += byte;\n+    }\n+  if (!saw_delim || crate_name.empty ())\n+    {\n+      import_stream.set_saw_error ();\n+      rust_error_at (locus, \"failed to read crate name field\");\n+\n+      return false;\n+    }\n+\n+  // read until delim which is the size of the meta data\n+  std::string metadata_length_buffer;\n+  saw_delim = false;\n+  while (!import_stream.saw_error () && !import_stream.at_eof ())\n+    {\n+      unsigned char byte = import_stream.get_char ();\n+      saw_delim\n+\t= memcmp (&byte, Metadata::kSzDelim, sizeof (Metadata::kSzDelim)) == 0;\n+      if (saw_delim)\n+\tbreak;\n+\n+      metadata_length_buffer += byte;\n+    }\n+  if (!saw_delim || metadata_length_buffer.empty ())\n+    {\n+      import_stream.set_saw_error ();\n+      rust_error_at (locus, \"failed to read metatadata size\");\n+\n+      return false;\n+    }\n+\n+  // interpret the string size\n+  int expected_buffer_length = -1;\n+  ok = ExternCrate::string_to_int (locus, metadata_length_buffer, false,\n+\t\t\t\t   &expected_buffer_length);\n+  if (!ok)\n+    return false;\n+\n+  // read the parsed size and it should be eof\n+  metadata_buffer.reserve (expected_buffer_length);\n+  for (int i = 0; i < expected_buffer_length && !import_stream.saw_error ()\n+\t\t  && !import_stream.at_eof ();\n+       i++)\n+    {\n+      metadata_buffer += import_stream.get_char ();\n+    }\n+\n+  // compute the md5\n+  struct md5_ctx chksm;\n+  unsigned char computed_checksum[16];\n+\n+  md5_init_ctx (&chksm);\n+  md5_process_bytes (metadata_buffer.c_str (), metadata_buffer.size (), &chksm);\n+  md5_finish_ctx (&chksm, computed_checksum);\n+\n+  // FIXME i think the encoding and decoding of md5 is going wrong or else we\n+  // are not computing it correctly\n+  //\n+  // compare the checksums\n+  // if (memcmp(computed_checksum, checksum, sizeof (checksum)) != 0)\n+  //   {\n+  //     rust_error_at (locus,\n+  //       \t     \"checksum mismatch in metadata: %<%.*s%> vs %<%.*s%>\",\n+  //       \t     sizeof (computed_checksum), computed_checksum,\n+  //       \t     sizeof (checksum), checksum);\n+  //     return false;\n+  //   }\n+\n+  // all good\n+  return true;\n+}\n+\n+const std::string &\n+ExternCrate::get_crate_name () const\n+{\n+  return crate_name;\n+}\n+\n+const std::string &\n+ExternCrate::get_metadata () const\n+{\n+  return metadata_buffer;\n+}\n+\n+// Turn a string into a integer with appropriate error handling.\n+bool\n+ExternCrate::string_to_int (Location locus, const std::string &s,\n+\t\t\t    bool is_neg_ok, int *ret)\n+{\n+  char *end;\n+  long prio = strtol (s.c_str (), &end, 10);\n+  if (*end != '\\0' || prio > 0x7fffffff || (prio < 0 && !is_neg_ok))\n+    {\n+      rust_error_at (locus, \"invalid integer in import data\");\n+      return false;\n+    }\n+  *ret = prio;\n+  return true;\n+}\n+\n+} // namespace Imports\n+} // namespace Rust"}, {"sha": "66da83894c1bade306733e95822999dbcdef8db8", "filename": "gcc/rust/metadata/rust-extern-crate.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-extern-crate.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,55 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_EXTERN_CRATE_H\n+#define RUST_EXTERN_CRATE_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-imports.h\"\n+\n+namespace Rust {\n+namespace Imports {\n+\n+class ExternCrate\n+{\n+public:\n+  ExternCrate (Import::Stream &stream);\n+  ~ExternCrate ();\n+\n+  bool ok () const;\n+\n+  bool load (Location locus);\n+\n+  const std::string &get_crate_name () const;\n+\n+  const std::string &get_metadata () const;\n+\n+  static bool string_to_int (Location locus, const std::string &s,\n+\t\t\t     bool is_neg_ok, int *ret);\n+\n+private:\n+  Import::Stream &import_stream;\n+\n+  std::string crate_name;\n+  std::string metadata_buffer;\n+};\n+\n+} // namespace Imports\n+} // namespace Rust\n+\n+#endif // RUST_EXTERN_CRATE_H"}, {"sha": "5678d486f17d38b78a5f87fbbb8194b4b9095492", "filename": "gcc/rust/metadata/rust-import-archive.cc", "status": "added", "additions": 885, "deletions": 0, "changes": 885, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-import-archive.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,885 @@\n+// import-archive.cc -- Go frontend read import data from an archive file.\n+\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-imports.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+// Archive magic numbers.\n+\n+static const char armag[] = {'!', '<', 'a', 'r', 'c', 'h', '>', '\\n'};\n+static const char armagt[] = {'!', '<', 't', 'h', 'i', 'n', '>', '\\n'};\n+static const char armagb[] = {'<', 'b', 'i', 'g', 'a', 'f', '>', '\\n'};\n+static const char arfmag[2] = {'`', '\\n'};\n+\n+namespace Rust {\n+\n+// Archive fixed length header for AIX big format.\n+\n+struct Archive_fl_header\n+{\n+  // Archive magic string.\n+  char fl_magic[8];\n+  // Offset to member table.\n+  char fl_memoff[20];\n+  // Offset to global symbol table.\n+  char fl_gstoff[20];\n+  // Offset to global symbol table for 64-bit objects.\n+  char fl_gst64off[20];\n+  // Offset to first archive member.\n+  char fl_fstmoff[20];\n+  // Offset to last archive member.\n+  char fl_lstmoff[20];\n+  // Offset to first member on free list.\n+  char fl_freeoff[20];\n+};\n+\n+// The header of an entry in an archive.  This is all readable text,\n+// padded with spaces where necesary.\n+\n+struct Archive_header\n+{\n+  // The entry name.\n+  char ar_name[16];\n+  // The file modification time.\n+  char ar_date[12];\n+  // The user's UID in decimal.\n+  char ar_uid[6];\n+  // The user's GID in decimal.\n+  char ar_gid[6];\n+  // The file mode in octal.\n+  char ar_mode[8];\n+  // The file size in decimal.\n+  char ar_size[10];\n+  // The final magic code.\n+  char ar_fmag[2];\n+};\n+\n+// The header of an entry in an AIX big archive.\n+// This is followed by ar_namlen bytes + 2 bytes for arfmag.\n+\n+struct Archive_big_header\n+{\n+  // The file size in decimal.\n+  char ar_size[20];\n+  // The next member offset in decimal.\n+  char ar_nxtmem[20];\n+  // The previous member offset in decimal.\n+  char ar_prvmem[20];\n+  // The file modification time in decimal.\n+  char ar_date[12];\n+  // The user's UID in decimal.\n+  char ar_uid[12];\n+  // The user's GID in decimal.\n+  char ar_gid[12];\n+  // The file mode in octal.\n+  char ar_mode[12];\n+  // The file name length in decimal.\n+  char ar_namlen[4];\n+};\n+\n+// Return true if BYTES, which are from the start of the file, are an\n+// archive magic number.\n+\n+bool\n+Import::is_archive_magic (const char *bytes)\n+{\n+  const int archive_magic_len = 8;\n+  return (memcmp (bytes, armag, archive_magic_len) == 0\n+\t  || memcmp (bytes, armagt, archive_magic_len) == 0\n+\t  || memcmp (bytes, armagb, archive_magic_len) == 0);\n+}\n+\n+// An object used to read an archive file.\n+\n+class Archive_file\n+{\n+public:\n+  Archive_file (const std::string &filename, int fd, Location location)\n+    : filename_ (filename), fd_ (fd), filesize_ (-1), first_member_offset_ (0),\n+      extended_names_ (), is_thin_archive_ (false), is_big_archive_ (false),\n+      location_ (location), nested_archives_ ()\n+  {}\n+\n+  // Initialize.\n+  bool initialize ();\n+\n+  // Return the file name.\n+  const std::string &filename () const { return this->filename_; }\n+\n+  // Get the file size.\n+  off_t filesize () const { return this->filesize_; }\n+\n+  // Return the offset of the first member.\n+  off_t first_member_offset () const { return this->first_member_offset_; }\n+\n+  // Return whether this is a thin archive.\n+  bool is_thin_archive () const { return this->is_thin_archive_; }\n+\n+  // Return whether this is a big archive.\n+  bool is_big_archive () const { return this->is_big_archive_; }\n+\n+  // Return the location of the import statement.\n+  Location location () const { return this->location_; }\n+\n+  // Read bytes.\n+  bool read (off_t offset, off_t size, char *);\n+\n+  // Parse a decimal in readable text.\n+  bool parse_decimal (const char *str, off_t size, long *res) const;\n+\n+  // Read the archive header at OFF, setting *PNAME, *SIZE,\n+  // *NESTED_OFF and *NEXT_OFF.\n+  bool read_header (off_t off, std::string *pname, off_t *size,\n+\t\t    off_t *nested_off, off_t *next_off);\n+\n+  // Interpret the header of HDR, the header of the archive member at\n+  // file offset OFF.  Return whether it succeeded.  Set *SIZE to the\n+  // size of the member.  Set *PNAME to the name of the member.  Set\n+  // *NESTED_OFF to the offset in a nested archive.\n+  bool interpret_header (const Archive_header *hdr, off_t off,\n+\t\t\t std::string *pname, off_t *size,\n+\t\t\t off_t *nested_off) const;\n+\n+  // Get the file and offset for an archive member.\n+  bool get_file_and_offset (off_t off, const std::string &hdrname,\n+\t\t\t    off_t nested_off, int *memfd, off_t *memoff,\n+\t\t\t    std::string *memname);\n+\n+private:\n+  // Initialize a big archive (AIX)\n+  bool initialize_big_archive ();\n+\n+  // Initialize a normal archive\n+  bool initialize_archive ();\n+\n+  // Read the big archive header at OFF, setting *PNAME, *SIZE and *NEXT_OFF.\n+  bool read_big_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t\toff_t *next_off);\n+\n+  // Read the normal archive header at OFF, setting *PNAME, *SIZE,\n+  // *NESTED_OFF and *NEXT_OFF.\n+  bool read_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t    off_t *nested_off, off_t *next_off);\n+\n+  // For keeping track of open nested archives in a thin archive file.\n+  typedef std::map<std::string, Archive_file *> Nested_archive_table;\n+\n+  // The name of the file.\n+  std::string filename_;\n+  // The file descriptor.\n+  int fd_;\n+  // The file size;\n+  off_t filesize_;\n+  // The first member offset;\n+  off_t first_member_offset_;\n+  // The extended name table.\n+  std::string extended_names_;\n+  // Whether this is a thin archive.\n+  bool is_thin_archive_;\n+  // Whether this is a big archive.\n+  bool is_big_archive_;\n+  // The location of the import statements.\n+  Location location_;\n+  // Table of nested archives.\n+  Nested_archive_table nested_archives_;\n+};\n+\n+bool\n+Archive_file::initialize ()\n+{\n+  struct stat st;\n+  if (fstat (this->fd_, &st) < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  this->filesize_ = st.st_size;\n+\n+  char buf[sizeof (armagt)];\n+  if (::lseek (this->fd_, 0, SEEK_SET) < 0\n+      || ::read (this->fd_, buf, sizeof (armagt)) != sizeof (armagt))\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  if (memcmp (buf, armagt, sizeof (armagt)) == 0)\n+    this->is_thin_archive_ = true;\n+  else if (memcmp (buf, armagb, sizeof (armagb)) == 0)\n+    this->is_big_archive_ = true;\n+\n+  if (this->is_big_archive_)\n+    return this->initialize_big_archive ();\n+  else\n+    return this->initialize_archive ();\n+}\n+\n+// Initialize a big archive (AIX).\n+\n+bool\n+Archive_file::initialize_big_archive ()\n+{\n+  Archive_fl_header flhdr;\n+\n+  // Read the fixed length header.\n+  if (::lseek (this->fd_, 0, SEEK_SET) < 0\n+      || ::read (this->fd_, &flhdr, sizeof (flhdr)) != sizeof (flhdr))\n+    {\n+      rust_error_at (this->location_, \"%s: could not read archive header\",\n+\t\t     this->filename_.c_str ());\n+      return false;\n+    }\n+\n+  // Parse offset of the first member.\n+  long off;\n+  if (!this->parse_decimal (flhdr.fl_fstmoff, sizeof (flhdr.fl_fstmoff), &off))\n+    {\n+      char *buf = new char[sizeof (flhdr.fl_fstmoff) + 1];\n+      memcpy (buf, flhdr.fl_fstmoff, sizeof (flhdr.fl_fstmoff));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed first member offset in archive header\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  if (off == 0) // Empty archive.\n+    this->first_member_offset_ = this->filesize_;\n+  else\n+    this->first_member_offset_ = off;\n+  return true;\n+}\n+\n+// Initialize a normal archive.\n+\n+bool\n+Archive_file::initialize_archive ()\n+{\n+  this->first_member_offset_ = sizeof (armag);\n+  if (this->first_member_offset_ == this->filesize_)\n+    {\n+      // Empty archive.\n+      return true;\n+    }\n+\n+  // Look for the extended name table.\n+  std::string filename;\n+  off_t size;\n+  off_t next_off;\n+  if (!this->read_header (this->first_member_offset_, &filename, &size, NULL,\n+\t\t\t  &next_off))\n+    return false;\n+  if (filename.empty ())\n+    {\n+      // We found the symbol table.\n+      if (!this->read_header (next_off, &filename, &size, NULL, NULL))\n+\tfilename.clear ();\n+    }\n+  if (filename == \"/\")\n+    {\n+      char *rdbuf = new char[size];\n+      if (::read (this->fd_, rdbuf, size) != size)\n+\t{\n+\t  rust_error_at (this->location_, \"%s: could not read extended names\",\n+\t\t\t filename.c_str ());\n+\t  delete[] rdbuf;\n+\t  return false;\n+\t}\n+      this->extended_names_.assign (rdbuf, size);\n+      delete[] rdbuf;\n+    }\n+\n+  return true;\n+}\n+\n+// Read bytes from the file.\n+\n+bool\n+Archive_file::read (off_t offset, off_t size, char *buf)\n+{\n+  if (::lseek (this->fd_, offset, SEEK_SET) < 0\n+      || ::read (this->fd_, buf, size) != size)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  return true;\n+}\n+\n+// Parse a decimal in readable text.\n+\n+bool\n+Archive_file::parse_decimal (const char *str, off_t size, long *res) const\n+{\n+  char *buf = new char[size + 1];\n+  memcpy (buf, str, size);\n+  char *ps = buf + size;\n+  while (ps > buf && ps[-1] == ' ')\n+    --ps;\n+  *ps = '\\0';\n+\n+  errno = 0;\n+  char *end;\n+  *res = strtol (buf, &end, 10);\n+  if (*end != '\\0' || *res < 0 || (*res == LONG_MAX && errno == ERANGE))\n+    {\n+      delete[] buf;\n+      return false;\n+    }\n+  delete[] buf;\n+  return true;\n+}\n+\n+// Read the header at OFF.  Set *PNAME to the name, *SIZE to the size,\n+// *NESTED_OFF to the nested offset, and *NEXT_OFF to the next member offset.\n+\n+bool\n+Archive_file::read_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t   off_t *nested_off, off_t *next_off)\n+{\n+  if (::lseek (this->fd_, off, SEEK_SET) < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      return false;\n+    }\n+  if (this->is_big_archive_)\n+    return this->read_big_archive_header (off, pname, size, next_off);\n+  else\n+    return this->read_archive_header (off, pname, size, nested_off, next_off);\n+}\n+\n+// Read the big archive header at OFF, setting *PNAME, *SIZE and *NEXT_OFF.\n+\n+bool\n+Archive_file::read_big_archive_header (off_t off, std::string *pname,\n+\t\t\t\t       off_t *size, off_t *next_off)\n+{\n+  Archive_big_header hdr;\n+  ssize_t got;\n+\n+  got = ::read (this->fd_, &hdr, sizeof hdr);\n+  if (got != sizeof hdr)\n+    {\n+      if (got < 0)\n+\trust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      else if (got > 0)\n+\trust_error_at (this->location_, \"%s: short entry header at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+      else\n+\trust_error_at (this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+    }\n+\n+  long local_size;\n+  if (!this->parse_decimal (hdr.ar_size, sizeof (hdr.ar_size), &local_size))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_size) + 1];\n+      memcpy (buf, hdr.ar_size, sizeof (hdr.ar_size));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed size in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  *size = local_size;\n+\n+  long namlen;\n+  if (!this->parse_decimal (hdr.ar_namlen, sizeof (hdr.ar_namlen), &namlen))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_namlen) + 1];\n+      memcpy (buf, hdr.ar_namlen, sizeof (hdr.ar_namlen));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed name length in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  // Read member name following member header.\n+  char *rdbuf = new char[namlen];\n+  got = ::read (this->fd_, rdbuf, namlen);\n+  if (got != namlen)\n+    {\n+      rust_error_at (this->location_,\n+\t\t     \"%s: malformed member name in entry header at %ld\",\n+\t\t     this->filename_.c_str (), static_cast<long> (off));\n+      delete[] rdbuf;\n+      return false;\n+    }\n+  pname->assign (rdbuf, namlen);\n+  delete[] rdbuf;\n+\n+  long local_next_off;\n+  if (!this->parse_decimal (hdr.ar_nxtmem, sizeof (hdr.ar_nxtmem),\n+\t\t\t    &local_next_off))\n+    {\n+      char *buf = new char[sizeof (hdr.ar_nxtmem) + 1];\n+      memcpy (buf, hdr.ar_nxtmem, sizeof (hdr.ar_nxtmem));\n+      rust_error_at (this->location_,\n+\t\t     (\"%s: malformed next member offset in entry header at %ld\"\n+\t\t      \" (expected decimal, got %s)\"),\n+\t\t     this->filename_.c_str (), static_cast<long> (off), buf);\n+      delete[] buf;\n+      return false;\n+    }\n+  if (next_off != NULL)\n+    {\n+      if (local_next_off == 0) // Last member.\n+\t*next_off = this->filesize_;\n+      else\n+\t*next_off = local_next_off;\n+    }\n+  return true;\n+}\n+\n+// Read the normal archive header at OFF, setting *PNAME, *SIZE,\n+// *NESTED_OFF and *NEXT_OFF.\n+\n+bool\n+Archive_file::read_archive_header (off_t off, std::string *pname, off_t *size,\n+\t\t\t\t   off_t *nested_off, off_t *next_off)\n+{\n+  Archive_header hdr;\n+  ssize_t got = ::read (this->fd_, &hdr, sizeof hdr);\n+  if (got != sizeof hdr)\n+    {\n+      if (got < 0)\n+\trust_error_at (this->location_, \"%s: %m\", this->filename_.c_str ());\n+      else if (got > 0)\n+\trust_error_at (this->location_, \"%s: short archive header at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+      else\n+\trust_error_at (this->location_, \"%s: unexpected EOF at %ld\",\n+\t\t       this->filename_.c_str (), static_cast<long> (off));\n+    }\n+  off_t local_nested_off;\n+  if (!this->interpret_header (&hdr, off, pname, size, &local_nested_off))\n+    return false;\n+  if (nested_off != NULL)\n+    *nested_off = local_nested_off;\n+\n+  off_t local_next_off;\n+  local_next_off = off + sizeof (Archive_header);\n+  if (!this->is_thin_archive_ || pname->empty () || *pname == \"/\")\n+    local_next_off += *size;\n+  if ((local_next_off & 1) != 0)\n+    ++local_next_off;\n+  if (local_next_off > this->filesize_) // Last member.\n+    local_next_off = this->filesize_;\n+  if (next_off != NULL)\n+    *next_off = local_next_off;\n+  return true;\n+}\n+\n+// Interpret the header of HDR, the header of the archive member at\n+// file offset OFF.\n+\n+bool\n+Archive_file::interpret_header (const Archive_header *hdr, off_t off,\n+\t\t\t\tstd::string *pname, off_t *size,\n+\t\t\t\toff_t *nested_off) const\n+{\n+  if (memcmp (hdr->ar_fmag, arfmag, sizeof arfmag) != 0)\n+    {\n+      rust_error_at (this->location_, \"%s: malformed archive header at %lu\",\n+\t\t     this->filename_.c_str (),\n+\t\t     static_cast<unsigned long> (off));\n+      return false;\n+    }\n+\n+  long local_size;\n+  if (!this->parse_decimal (hdr->ar_size, sizeof hdr->ar_size, &local_size))\n+    {\n+      rust_error_at (this->location_,\n+\t\t     \"%s: malformed archive header size at %lu\",\n+\t\t     this->filename_.c_str (),\n+\t\t     static_cast<unsigned long> (off));\n+      return false;\n+    }\n+  *size = local_size;\n+\n+  *nested_off = 0;\n+  if (hdr->ar_name[0] != '/')\n+    {\n+      const char *name_end = strchr (hdr->ar_name, '/');\n+      if (name_end == NULL\n+\t  || name_end - hdr->ar_name >= static_cast<int> (sizeof hdr->ar_name))\n+\t{\n+\t  rust_error_at (this->location_,\n+\t\t\t \"%s: malformed archive header name at %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+      pname->assign (hdr->ar_name, name_end - hdr->ar_name);\n+    }\n+  else if (hdr->ar_name[1] == ' ')\n+    {\n+      // This is the symbol table.\n+      pname->clear ();\n+    }\n+  else if (hdr->ar_name[1] == 'S' && hdr->ar_name[2] == 'Y'\n+\t   && hdr->ar_name[3] == 'M' && hdr->ar_name[4] == '6'\n+\t   && hdr->ar_name[5] == '4' && hdr->ar_name[6] == '/'\n+\t   && hdr->ar_name[7] == ' ')\n+    {\n+      // 64-bit symbol table.\n+      pname->clear ();\n+    }\n+  else if (hdr->ar_name[1] == '/')\n+    {\n+      // This is the extended name table.\n+      pname->assign (1, '/');\n+    }\n+  else\n+    {\n+      char *end;\n+      errno = 0;\n+      long x = strtol (hdr->ar_name + 1, &end, 10);\n+      long y = 0;\n+      if (*end == ':')\n+\ty = strtol (end + 1, &end, 10);\n+      if (*end != ' ' || x < 0 || (x == LONG_MAX && errno == ERANGE)\n+\t  || static_cast<size_t> (x) >= this->extended_names_.size ())\n+\t{\n+\t  rust_error_at (this->location_, \"%s: bad extended name index at %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+\n+      const char *name = this->extended_names_.data () + x;\n+      const char *name_end = strchr (name, '\\n');\n+      if (static_cast<size_t> (name_end - name) > this->extended_names_.size ()\n+\t  || name_end[-1] != '/')\n+\t{\n+\t  rust_error_at (this->location_,\n+\t\t\t \"%s: bad extended name entry at header %lu\",\n+\t\t\t this->filename_.c_str (),\n+\t\t\t static_cast<unsigned long> (off));\n+\t  return false;\n+\t}\n+      pname->assign (name, name_end - 1 - name);\n+      *nested_off = y;\n+    }\n+\n+  return true;\n+}\n+\n+// Get the file and offset for an archive member.\n+\n+bool\n+Archive_file::get_file_and_offset (off_t off, const std::string &hdrname,\n+\t\t\t\t   off_t nested_off, int *memfd, off_t *memoff,\n+\t\t\t\t   std::string *memname)\n+{\n+  if (this->is_big_archive_)\n+    {\n+      *memfd = this->fd_;\n+      *memoff = (off + sizeof (Archive_big_header) + hdrname.length ()\n+\t\t + sizeof (arfmag));\n+      if ((*memoff & 1) != 0)\n+\t++*memoff;\n+      *memname = this->filename_ + '(' + hdrname + ')';\n+      return true;\n+    }\n+  else if (!this->is_thin_archive_)\n+    {\n+      *memfd = this->fd_;\n+      *memoff = off + sizeof (Archive_header);\n+      *memname = this->filename_ + '(' + hdrname + ')';\n+      return true;\n+    }\n+\n+  std::string filename = hdrname;\n+  if (!IS_ABSOLUTE_PATH (filename.c_str ()))\n+    {\n+      const char *archive_path = this->filename_.c_str ();\n+      const char *basename = lbasename (archive_path);\n+      if (basename > archive_path)\n+\tfilename.replace (0, 0,\n+\t\t\t  this->filename_.substr (0, basename - archive_path));\n+    }\n+\n+  if (nested_off > 0)\n+    {\n+      // This is a member of a nested archive.\n+      Archive_file *nfile;\n+      Nested_archive_table::const_iterator p\n+\t= this->nested_archives_.find (filename);\n+      if (p != this->nested_archives_.end ())\n+\tnfile = p->second;\n+      else\n+\t{\n+\t  int nfd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+\t  if (nfd < 0)\n+\t    {\n+\t      rust_error_at (this->location_,\n+\t\t\t     \"%s: cannot open nested archive %s\",\n+\t\t\t     this->filename_.c_str (), filename.c_str ());\n+\t      return false;\n+\t    }\n+\t  nfile = new Archive_file (filename, nfd, this->location_);\n+\t  if (!nfile->initialize ())\n+\t    {\n+\t      delete nfile;\n+\t      return false;\n+\t    }\n+\t  this->nested_archives_[filename] = nfile;\n+\t}\n+\n+      std::string nname;\n+      off_t nsize;\n+      off_t nnested_off;\n+      if (!nfile->read_header (nested_off, &nname, &nsize, &nnested_off, NULL))\n+\treturn false;\n+      return nfile->get_file_and_offset (nested_off, nname, nnested_off, memfd,\n+\t\t\t\t\t memoff, memname);\n+    }\n+\n+  // An external member of a thin archive.\n+  *memfd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (*memfd < 0)\n+    {\n+      rust_error_at (this->location_, \"%s: %m\", filename.c_str ());\n+      return false;\n+    }\n+  *memoff = 0;\n+  *memname = filename;\n+  return true;\n+}\n+\n+// An archive member iterator.  This is more-or-less copied from gold.\n+\n+class Archive_iterator\n+{\n+public:\n+  // The header of an archive member.  This is what this iterator\n+  // points to.\n+  struct Header\n+  {\n+    // The name of the member.\n+    std::string name;\n+    // The file offset of the member.\n+    off_t off;\n+    // The file offset of a nested archive member.\n+    off_t nested_off;\n+    // The size of the member.\n+    off_t size;\n+  };\n+\n+  Archive_iterator (Archive_file *afile, off_t off) : afile_ (afile), off_ (off)\n+  {\n+    this->read_next_header ();\n+  }\n+\n+  const Header &operator* () const { return this->header_; }\n+\n+  const Header *operator-> () const { return &this->header_; }\n+\n+  Archive_iterator &operator++ ()\n+  {\n+    if (this->off_ == this->afile_->filesize ())\n+      return *this;\n+    this->off_ = this->next_off_;\n+    this->read_next_header ();\n+    return *this;\n+  }\n+\n+  Archive_iterator operator++ (int)\n+  {\n+    Archive_iterator ret = *this;\n+    ++*this;\n+    return ret;\n+  }\n+\n+  bool operator== (const Archive_iterator &p) const\n+  {\n+    return this->off_ == p->off;\n+  }\n+\n+  bool operator!= (const Archive_iterator &p) const\n+  {\n+    return this->off_ != p->off;\n+  }\n+\n+private:\n+  void read_next_header ();\n+\n+  // The underlying archive file.\n+  Archive_file *afile_;\n+  // The current offset in the file.\n+  off_t off_;\n+  // The offset of the next member.\n+  off_t next_off_;\n+  // The current archive header.\n+  Header header_;\n+};\n+\n+// Read the next archive header.\n+\n+void\n+Archive_iterator::read_next_header ()\n+{\n+  off_t filesize = this->afile_->filesize ();\n+  while (true)\n+    {\n+      if (this->off_ == filesize)\n+\t{\n+\t  this->header_.off = filesize;\n+\t  return;\n+\t}\n+\n+      if (!this->afile_->read_header (this->off_, &this->header_.name,\n+\t\t\t\t      &this->header_.size,\n+\t\t\t\t      &this->header_.nested_off,\n+\t\t\t\t      &this->next_off_))\n+\t{\n+\t  this->header_.off = filesize;\n+\t  this->off_ = filesize;\n+\t  return;\n+\t}\n+      this->header_.off = this->off_;\n+\n+      // Skip special members.\n+      if (!this->header_.name.empty () && this->header_.name != \"/\")\n+\treturn;\n+\n+      this->off_ = this->next_off_;\n+    }\n+}\n+\n+// Initial iterator.\n+\n+Archive_iterator\n+archive_begin (Archive_file *afile)\n+{\n+  return Archive_iterator (afile, afile->first_member_offset ());\n+}\n+\n+// Final iterator.\n+\n+Archive_iterator\n+archive_end (Archive_file *afile)\n+{\n+  return Archive_iterator (afile, afile->filesize ());\n+}\n+\n+// A type of Import_stream which concatenates other Import_streams\n+// together.\n+\n+class Stream_concatenate : public Import::Stream\n+{\n+public:\n+  Stream_concatenate () : inputs_ () {}\n+\n+  // Add a new stream.\n+  void add (Import::Stream *is) { this->inputs_.push_back (is); }\n+\n+protected:\n+  bool do_peek (size_t, const char **);\n+\n+  void do_advance (size_t);\n+\n+private:\n+  std::list<Import::Stream *> inputs_;\n+};\n+\n+// Peek ahead.\n+\n+bool\n+Stream_concatenate::do_peek (size_t length, const char **bytes)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty ())\n+\treturn false;\n+      if (this->inputs_.front ()->peek (length, bytes))\n+\treturn true;\n+      delete this->inputs_.front ();\n+      this->inputs_.pop_front ();\n+    }\n+}\n+\n+// Advance.\n+\n+void\n+Stream_concatenate::do_advance (size_t skip)\n+{\n+  while (true)\n+    {\n+      if (this->inputs_.empty ())\n+\treturn;\n+      if (!this->inputs_.front ()->at_eof ())\n+\t{\n+\t  // We just assume that this will do the right thing.  It\n+\t  // should be OK since we should never want to skip past\n+\t  // multiple streams.\n+\t  this->inputs_.front ()->advance (skip);\n+\t  return;\n+\t}\n+      delete this->inputs_.front ();\n+      this->inputs_.pop_front ();\n+    }\n+}\n+\n+// Import data from an archive.  We walk through the archive and\n+// import data from each member.\n+\n+Import::Stream *\n+Import::find_archive_export_data (const std::string &filename, int fd,\n+\t\t\t\t  Location location)\n+{\n+  Archive_file afile (filename, fd, location);\n+  if (!afile.initialize ())\n+    return NULL;\n+\n+  Stream_concatenate *ret = new Stream_concatenate;\n+\n+  bool any_data = false;\n+  bool any_members = false;\n+  Archive_iterator pend = archive_end (&afile);\n+  for (Archive_iterator p = archive_begin (&afile); p != pend; p++)\n+    {\n+      any_members = true;\n+      int member_fd;\n+      off_t member_off;\n+      std::string member_name;\n+      if (!afile.get_file_and_offset (p->off, p->name, p->nested_off,\n+\t\t\t\t      &member_fd, &member_off, &member_name))\n+\treturn NULL;\n+\n+      Import::Stream *is\n+\t= Import::find_object_export_data (member_name, member_fd, member_off,\n+\t\t\t\t\t   location);\n+      if (is != NULL)\n+\t{\n+\t  ret->add (is);\n+\t  any_data = true;\n+\t}\n+    }\n+\n+  if (!any_members)\n+    {\n+      // It's normal to have an empty archive file when using gobuild.\n+      return new Stream_from_string (\"\");\n+    }\n+\n+  if (!any_data)\n+    {\n+      delete ret;\n+      return NULL;\n+    }\n+\n+  return ret;\n+}\n+\n+} // namespace Rust"}, {"sha": "b44165b1fa2ce39ba2efdd241b22ad5d18d05ba2", "filename": "gcc/rust/metadata/rust-imports.cc", "status": "added", "additions": 441, "deletions": 0, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-imports.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-imports.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-imports.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,441 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-system.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-imports.h\"\n+#include \"rust-object-export.h\"\n+#include \"rust-export-metadata.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+namespace Rust {\n+\n+// The list of paths we search for import files.\n+static std::vector<std::string> search_path;\n+\n+// Add a directory to the search path.  This is called from the option\n+// handling language hook.\n+void\n+add_search_path (const std::string &path)\n+{\n+  search_path.push_back (path);\n+}\n+\n+// Find import data.  This searches the file system for FILENAME and\n+// returns a pointer to a Stream object to read the data that it\n+// exports.  If the file is not found, it returns NULL.\n+\n+// When FILENAME is not an absolute path and does not start with ./ or\n+// ../, we use the search path provided by -I and -L options.\n+\n+// When FILENAME does start with ./ or ../, we use\n+// RELATIVE_IMPORT_PATH as a prefix.\n+\n+// When FILENAME does not exist, we try modifying FILENAME to find the\n+// file.  We use the first of these which exists:\n+//   * We append \".gox\".\n+//   * We turn the base of FILENAME into libFILENAME.so.\n+//   * We turn the base of FILENAME into libFILENAME.a.\n+//   * We append \".o\".\n+\n+// When using a search path, we apply each of these transformations at\n+// each entry on the search path before moving on to the next entry.\n+// If the file exists, but does not contain any Go export data, we\n+// stop; we do not keep looking for another file with the same name\n+// later in the search path.\n+\n+Import::Stream *\n+Import::open_package (const std::string &filename, Location location,\n+\t\t      const std::string &relative_import_path)\n+{\n+  bool is_local;\n+  if (IS_ABSOLUTE_PATH (filename))\n+    is_local = true;\n+  else if (filename[0] == '.'\n+\t   && (filename[1] == '\\0' || IS_DIR_SEPARATOR (filename[1])))\n+    is_local = true;\n+  else if (filename[0] == '.' && filename[1] == '.'\n+\t   && (filename[2] == '\\0' || IS_DIR_SEPARATOR (filename[2])))\n+    is_local = true;\n+  else\n+    is_local = false;\n+\n+  std::string fn = filename;\n+  if (is_local && !IS_ABSOLUTE_PATH (filename)\n+      && !relative_import_path.empty ())\n+    {\n+      if (fn == \".\")\n+\t{\n+\t  // A special case.\n+\t  fn = relative_import_path;\n+\t}\n+      else if (fn[0] == '.' && fn[1] == '.'\n+\t       && (fn[2] == '\\0' || IS_DIR_SEPARATOR (fn[2])))\n+\t{\n+\t  // We are going to join relative_import_path and fn, and it\n+\t  // will look like DIR/../PATH.  But DIR does not necessarily\n+\t  // exist in this case, and if it doesn't the use of .. will\n+\t  // fail although it shouldn't.  The gc compiler uses\n+\t  // path.Join here, which cleans up the .., so we need to do\n+\t  // the same.\n+\t  size_t index;\n+\t  for (index = relative_import_path.length () - 1;\n+\t       index > 0 && !IS_DIR_SEPARATOR (relative_import_path[index]);\n+\t       index--)\n+\t    ;\n+\t  if (index > 0)\n+\t    fn = relative_import_path.substr (0, index) + fn.substr (2);\n+\t  else\n+\t    fn = relative_import_path + '/' + fn;\n+\t}\n+      else\n+\tfn = relative_import_path + '/' + fn;\n+      is_local = false;\n+    }\n+\n+  if (!is_local)\n+    {\n+      for (std::vector<std::string>::const_iterator p = search_path.begin ();\n+\t   p != search_path.end (); ++p)\n+\t{\n+\t  std::string indir = *p;\n+\t  if (!indir.empty () && indir[indir.size () - 1] != '/')\n+\t    indir += '/';\n+\t  indir += fn;\n+\t  Stream *s = Import::try_package_in_directory (indir, location);\n+\t  if (s != NULL)\n+\t    return s;\n+\t}\n+    }\n+\n+  Stream *s = Import::try_package_in_directory (fn, location);\n+  if (s != NULL)\n+    return s;\n+\n+  return NULL;\n+}\n+\n+// Try to find the export data for FILENAME.\n+\n+Import::Stream *\n+Import::try_package_in_directory (const std::string &filename,\n+\t\t\t\t  Location location)\n+{\n+  std::string found_filename = filename;\n+  int fd = open (found_filename.c_str (), O_RDONLY | O_BINARY);\n+\n+  if (fd >= 0)\n+    {\n+      struct stat s;\n+      if (fstat (fd, &s) >= 0 && S_ISDIR (s.st_mode))\n+\t{\n+\t  close (fd);\n+\t  fd = -1;\n+\t  errno = EISDIR;\n+\t}\n+    }\n+\n+  if (fd < 0)\n+    {\n+      if (errno != ENOENT && errno != EISDIR)\n+\trust_warning_at (location, 0, \"%s: %m\", filename.c_str ());\n+\n+      fd = Import::try_suffixes (&found_filename);\n+      if (fd < 0)\n+\treturn NULL;\n+    }\n+\n+  // The export data may not be in this file.\n+  Stream *s = Import::find_export_data (found_filename, fd, location);\n+  if (s != NULL)\n+    return s;\n+\n+  close (fd);\n+\n+  rust_error_at (location, \"%s exists but does not contain any Go export data\",\n+\t\t found_filename.c_str ());\n+\n+  return NULL;\n+}\n+\n+// Given import \"*PFILENAME\", where *PFILENAME does not exist, try\n+// various suffixes.  If we find one, set *PFILENAME to the one we\n+// found.  Return the open file descriptor.\n+\n+int\n+Import::try_suffixes (std::string *pfilename)\n+{\n+  std::string filename = *pfilename + \".rox\";\n+  int fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  const char *basename = lbasename (pfilename->c_str ());\n+  size_t basename_pos = basename - pfilename->c_str ();\n+  filename = pfilename->substr (0, basename_pos) + \"lib\" + basename + \".so\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = pfilename->substr (0, basename_pos) + \"lib\" + basename + \".a\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  filename = *pfilename + \".o\";\n+  fd = open (filename.c_str (), O_RDONLY | O_BINARY);\n+  if (fd >= 0)\n+    {\n+      *pfilename = filename;\n+      return fd;\n+    }\n+\n+  return -1;\n+}\n+\n+// Look for export data in the file descriptor FD.\n+\n+Import::Stream *\n+Import::find_export_data (const std::string &filename, int fd,\n+\t\t\t  Location location)\n+{\n+  // See if we can read this as an object file.\n+  Import::Stream *stream\n+    = Import::find_object_export_data (filename, fd, 0, location);\n+  if (stream != NULL)\n+    return stream;\n+\n+  const int len = sizeof (Metadata::kMagicHeader);\n+  if (lseek (fd, 0, SEEK_SET) < 0)\n+    {\n+      rust_error_at (location, \"lseek %s failed: %m\", filename.c_str ());\n+      return NULL;\n+    }\n+\n+  char buf[len];\n+  ssize_t c = ::read (fd, buf, len);\n+  if (c < len)\n+    return NULL;\n+\n+  // Check for a file containing nothing but Go export data.\n+  // if (memcmp (buf, Export::cur_magic, Export::magic_len) == 0\n+  //     || memcmp (buf, Export::v1_magic, Export::magic_len) == 0\n+  //     || memcmp (buf, Export::v2_magic, Export::magic_len) == 0)\n+  //\n+  // FIXME we need to work out a better header\n+  //\n+  if (memcmp (buf, Metadata::kMagicHeader, sizeof (Metadata::kMagicHeader))\n+      == 0)\n+    return new Stream_from_file (fd);\n+\n+  // See if we can read this as an archive.\n+  if (Import::is_archive_magic (buf))\n+    return Import::find_archive_export_data (filename, fd, location);\n+\n+  return NULL;\n+}\n+\n+// Look for export data in an object file.\n+\n+Import::Stream *\n+Import::find_object_export_data (const std::string &filename, int fd,\n+\t\t\t\t off_t offset, Location location)\n+{\n+  char *buf;\n+  size_t len;\n+  int err;\n+  const char *errmsg = rust_read_export_data (fd, offset, &buf, &len, &err);\n+  if (errmsg != NULL)\n+    {\n+      if (err == 0)\n+\trust_error_at (location, \"%s: %s\", filename.c_str (), errmsg);\n+      else\n+\trust_error_at (location, \"%s: %s: %s\", filename.c_str (), errmsg,\n+\t\t       xstrerror (err));\n+      return NULL;\n+    }\n+\n+  if (buf == NULL)\n+    return NULL;\n+\n+  return new Stream_from_buffer (buf, len);\n+}\n+\n+// Class Import.\n+\n+// Construct an Import object.  We make the builtin_types_ vector\n+// large enough to hold all the builtin types.\n+\n+Import::Import (Stream *stream, Location location)\n+  : stream_ (stream), location_ (location)\n+{}\n+\n+// Import the data in the associated stream.\n+\n+// Read LENGTH bytes from the stream.\n+\n+void\n+Import::read (size_t length, std::string *out)\n+{\n+  const char *data;\n+  if (!this->stream_->peek (length, &data))\n+    {\n+      if (!this->stream_->saw_error ())\n+\trust_error_at (this->location_, \"import error at %d: expected %d bytes\",\n+\t\t       this->stream_->pos (), static_cast<int> (length));\n+      this->stream_->set_saw_error ();\n+      *out = std::string (\"\");\n+      return;\n+    }\n+  *out = std::string (data, length);\n+  this->advance (length);\n+}\n+\n+// Class Import::Stream.\n+\n+Import::Stream::Stream () : pos_ (0), saw_error_ (false) {}\n+\n+Import::Stream::~Stream () {}\n+\n+// Return the next character to come from the stream.\n+\n+int\n+Import::Stream::peek_char ()\n+{\n+  const char *read;\n+  if (!this->do_peek (1, &read))\n+    return -1;\n+  // Make sure we return an unsigned char, so that we don't get\n+  // confused by \\xff.\n+  unsigned char ret = *read;\n+  return ret;\n+}\n+\n+// Return true if the next LENGTH characters from the stream match\n+// BYTES\n+\n+bool\n+Import::Stream::match_bytes (const char *bytes, size_t length)\n+{\n+  const char *read;\n+  if (!this->do_peek (length, &read))\n+    return false;\n+  return memcmp (bytes, read, length) == 0;\n+}\n+\n+// Require that the next LENGTH bytes from the stream match BYTES.\n+\n+void\n+Import::Stream::require_bytes (Location location, const char *bytes,\n+\t\t\t       size_t length)\n+{\n+  const char *read;\n+  if (!this->do_peek (length, &read) || memcmp (bytes, read, length) != 0)\n+    {\n+      if (!this->saw_error_)\n+\trust_error_at (location, \"import error at %d: expected %<%.*s%>\",\n+\t\t       this->pos (), static_cast<int> (length), bytes);\n+      this->saw_error_ = true;\n+      return;\n+    }\n+  this->advance (length);\n+}\n+\n+// Class Stream_from_file.\n+\n+Stream_from_file::Stream_from_file (int fd) : fd_ (fd), data_ ()\n+{\n+  if (lseek (fd, 0, SEEK_SET) != 0)\n+    {\n+      rust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+    }\n+}\n+\n+Stream_from_file::~Stream_from_file () { close (this->fd_); }\n+\n+// Read next bytes.\n+\n+bool\n+Stream_from_file::do_peek (size_t length, const char **bytes)\n+{\n+  if (this->data_.length () >= length)\n+    {\n+      *bytes = this->data_.data ();\n+      return true;\n+    }\n+\n+  this->data_.resize (length);\n+  ssize_t got = ::read (this->fd_, &this->data_[0], length);\n+\n+  if (got < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"read failed: %m\");\n+      this->set_saw_error ();\n+      return false;\n+    }\n+\n+  if (lseek (this->fd_, -got, SEEK_CUR) < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+      return false;\n+    }\n+\n+  if (static_cast<size_t> (got) < length)\n+    return false;\n+\n+  *bytes = this->data_.data ();\n+  return true;\n+}\n+\n+// Advance.\n+\n+void\n+Stream_from_file::do_advance (size_t skip)\n+{\n+  if (lseek (this->fd_, skip, SEEK_CUR) < 0)\n+    {\n+      if (!this->saw_error ())\n+\trust_fatal_error (Linemap::unknown_location (), \"lseek failed: %m\");\n+      this->set_saw_error ();\n+    }\n+  if (!this->data_.empty ())\n+    {\n+      if (this->data_.length () > skip)\n+\tthis->data_.erase (0, skip);\n+      else\n+\tthis->data_.clear ();\n+    }\n+}\n+\n+} // namespace Rust"}, {"sha": "51cc4fc761383292112d135b9194ebc0a51806c1", "filename": "gcc/rust/metadata/rust-imports.h", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-imports.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fmetadata%2Frust-imports.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmetadata%2Frust-imports.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,257 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef RUST_IMPORTS_H\n+#define RUST_IMPORTS_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+\n+extern void\n+add_search_path (const std::string &path);\n+\n+class Import\n+{\n+public:\n+  // The Stream class is an interface used to read the data.  The\n+  // caller should instantiate a child of this class.\n+  class Stream\n+  {\n+  public:\n+    Stream ();\n+    virtual ~Stream ();\n+\n+    // Set the position, for error messages.\n+    void set_pos (int pos) { this->pos_ = pos; }\n+\n+    // Return whether we have seen an error.\n+    bool saw_error () const { return this->saw_error_; }\n+\n+    // Record that we've seen an error.\n+    void set_saw_error () { this->saw_error_ = true; }\n+\n+    // Return the next character (a value from 0 to 0xff) without\n+    // advancing.  Returns -1 at end of stream.\n+    int peek_char ();\n+\n+    // Look for LENGTH characters, setting *BYTES to point to them.\n+    // Returns false if the bytes are not available.  Does not\n+    // advance.\n+    bool peek (size_t length, const char **bytes)\n+    {\n+      return this->do_peek (length, bytes);\n+    }\n+\n+    // Return the next character (a value from 0 to 0xff) and advance\n+    // the read position by 1.  Returns -1 at end of stream.\n+    int get_char ()\n+    {\n+      int c = this->peek_char ();\n+      this->advance (1);\n+      return c;\n+    }\n+\n+    // Return true if at the end of the stream.\n+    bool at_eof () { return this->peek_char () == -1; }\n+\n+    // Return true if the next bytes match STR.\n+    bool match_c_string (const char *str)\n+    {\n+      return this->match_bytes (str, strlen (str));\n+    }\n+\n+    // Return true if the next LENGTH bytes match BYTES.\n+    bool match_bytes (const char *bytes, size_t length);\n+\n+    // Give an error if the next bytes do not match STR.  Advance the\n+    // read position by the length of STR.\n+    void require_c_string (Location location, const char *str)\n+    {\n+      this->require_bytes (location, str, strlen (str));\n+    }\n+\n+    // Given an error if the next LENGTH bytes do not match BYTES.\n+    // Advance the read position by LENGTH.\n+    void require_bytes (Location, const char *bytes, size_t length);\n+\n+    // Advance the read position by SKIP bytes.\n+    void advance (size_t skip)\n+    {\n+      this->do_advance (skip);\n+      this->pos_ += skip;\n+    }\n+\n+    // Return the current read position.  This returns int because it\n+    // is more convenient in error reporting.  FIXME.\n+    int pos () { return static_cast<int> (this->pos_); }\n+\n+    // This function should set *BYTES to point to a buffer holding\n+    // the LENGTH bytes at the current read position.  It should\n+    // return false if the bytes are not available.  This should not\n+    // change the current read position.\n+    virtual bool do_peek (size_t length, const char **bytes) = 0;\n+\n+    // This function should advance the current read position LENGTH\n+    // bytes.\n+    virtual void do_advance (size_t skip) = 0;\n+\n+  private:\n+    // The current read position.\n+    size_t pos_;\n+    // True if we've seen an error reading from this stream.\n+    bool saw_error_;\n+  };\n+\n+  // Find import data.  This searches the file system for FILENAME and\n+  // returns a pointer to a Stream object to read the data that it\n+  // exports.  LOCATION is the location of the import statement.\n+  // RELATIVE_IMPORT_PATH is used as a prefix for a relative import.\n+  static Stream *open_package (const std::string &filename, Location location,\n+\t\t\t       const std::string &relative_import_path);\n+\n+  // Constructor.\n+  Import (Stream *, Location);\n+\n+  // The location of the import statement.\n+  Location location () const { return this->location_; }\n+\n+  // Return the next character.\n+  int peek_char () { return this->stream_->peek_char (); }\n+\n+  // Return the next character and advance.\n+  int get_char () { return this->stream_->get_char (); }\n+\n+  // Read LENGTH characters into *OUT and advance past them.  On\n+  // EOF reports an error and sets *OUT to an empty string.\n+  void read (size_t length, std::string *out);\n+\n+  // Return true at the end of the stream.\n+  bool at_eof () { return this->stream_->at_eof (); }\n+\n+  // Return whether the next bytes match STR.\n+  bool match_c_string (const char *str)\n+  {\n+    return this->stream_->match_c_string (str);\n+  }\n+\n+  // Require that the next bytes match STR.\n+  void require_c_string (const char *str)\n+  {\n+    this->stream_->require_c_string (this->location_, str);\n+  }\n+\n+  // Advance the stream SKIP bytes.\n+  void advance (size_t skip) { this->stream_->advance (skip); }\n+\n+  // Stream position, for error reporting.\n+  int pos () { return this->stream_->pos (); }\n+\n+  // Clear the stream when it is no longer accessible.\n+  void clear_stream () { this->stream_ = NULL; }\n+\n+private:\n+  static Stream *try_package_in_directory (const std::string &, Location);\n+\n+  static int try_suffixes (std::string *);\n+\n+  static Stream *find_export_data (const std::string &filename, int fd,\n+\t\t\t\t   Location);\n+\n+  static Stream *find_object_export_data (const std::string &filename, int fd,\n+\t\t\t\t\t  off_t offset, Location);\n+\n+  static bool is_archive_magic (const char *);\n+\n+  static Stream *find_archive_export_data (const std::string &filename, int fd,\n+\t\t\t\t\t   Location);\n+\n+  // The stream from which to read import data.\n+  Stream *stream_;\n+  // The location of the import statement we are processing.\n+  Location location_;\n+};\n+\n+// Read import data from a string.\n+\n+class Stream_from_string : public Import::Stream\n+{\n+public:\n+  Stream_from_string (const std::string &str) : str_ (str), pos_ (0) {}\n+\n+  bool do_peek (size_t length, const char **bytes)\n+  {\n+    if (this->pos_ + length > this->str_.length ())\n+      return false;\n+    *bytes = this->str_.data () + this->pos_;\n+    return true;\n+  }\n+\n+  void do_advance (size_t len) { this->pos_ += len; }\n+\n+private:\n+  // The string of data we are reading.\n+  std::string str_;\n+  // The current position within the string.\n+  size_t pos_;\n+};\n+\n+// Read import data from a buffer allocated using malloc.\n+\n+class Stream_from_buffer : public Import::Stream\n+{\n+public:\n+  Stream_from_buffer (char *buf, size_t length)\n+    : buf_ (buf), length_ (length), pos_ (0)\n+  {}\n+\n+  ~Stream_from_buffer () { free (this->buf_); }\n+\n+  bool do_peek (size_t length, const char **bytes)\n+  {\n+    if (this->pos_ + length > this->length_)\n+      return false;\n+    *bytes = this->buf_ + this->pos_;\n+    return true;\n+  }\n+\n+  void do_advance (size_t len) { this->pos_ += len; }\n+\n+private:\n+  // The data we are reading.\n+  char *buf_;\n+  // The length of the buffer.\n+  size_t length_;\n+  // The current position within the buffer.\n+  size_t pos_;\n+};\n+\n+// Read import data from an open file descriptor.\n+\n+class Stream_from_file : public Import::Stream\n+{\n+public:\n+  Stream_from_file (int fd);\n+\n+  ~Stream_from_file ();\n+\n+  bool do_peek (size_t, const char **);\n+\n+  void do_advance (size_t);\n+\n+private:\n+  // No copying.\n+  Stream_from_file (const Stream_from_file &);\n+  Stream_from_file &operator= (const Stream_from_file &);\n+\n+  // The file descriptor.\n+  int fd_;\n+  // Data read from the file.\n+  std::string data_;\n+};\n+\n+} // namespace Rust\n+\n+#endif // RUST_IMPORTS_H"}, {"sha": "43ae8e476733c713b9ae77b201456a5f40b1c0a8", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 35, "deletions": 25, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -392,21 +392,31 @@ class ResolveTopLevel : public ResolverBase\n     NodeId resolved_crate = UNKNOWN_NODEID;\n     if (extern_crate.references_self ())\n       {\n-\t// FIXME\n-\t// then this resolves to current crate_node_id\n-\t// need to expose on the session object a reference to the current\n-\t// AST::Crate& to get node_id\n-\tgcc_unreachable ();\n-\treturn;\n+\tCrateNum crate_num = mappings->get_current_crate ();\n+\tbool ok = mappings->crate_num_to_nodeid (crate_num, resolved_crate);\n+\trust_assert (ok);\n       }\n     else\n       {\n-\trust_debug_loc (extern_crate.get_locus (), \"load extern crate: [%s]\",\n-\t\t\textern_crate.as_string ().c_str ());\n-\n-\tSession &session = Session::get_instance ();\n-\tresolved_crate\n-\t  = session.load_extern_crate (extern_crate.get_referenced_crate ());\n+\tCrateNum found_crate_num = UNKNOWN_CREATENUM;\n+\tbool found\n+\t  = mappings->lookup_crate_name (extern_crate.get_referenced_crate (),\n+\t\t\t\t\t found_crate_num);\n+\tif (!found)\n+\t  {\n+\t    rust_error_at (extern_crate.get_locus (), \"unknown crate %<%s%>\",\n+\t\t\t   extern_crate.get_referenced_crate ().c_str ());\n+\t    return;\n+\t  }\n+\n+\tbool ok\n+\t  = mappings->crate_num_to_nodeid (found_crate_num, resolved_crate);\n+\tif (!ok)\n+\t  {\n+\t    rust_internal_error_at (extern_crate.get_locus (),\n+\t\t\t\t    \"failed to resolve crate to nodeid\");\n+\t    return;\n+\t  }\n       }\n \n     if (resolved_crate == UNKNOWN_NODEID)\n@@ -418,20 +428,20 @@ class ResolveTopLevel : public ResolverBase\n     // mark the node as resolved\n     resolver->insert_resolved_name (extern_crate.get_node_id (),\n \t\t\t\t    resolved_crate);\n+    CanonicalPath decl\n+      = extern_crate.has_as_clause ()\n+\t  ? CanonicalPath::new_seg (extern_crate.get_node_id (),\n+\t\t\t\t    extern_crate.get_as_clause ())\n+\t  : CanonicalPath::new_seg (extern_crate.get_node_id (),\n+\t\t\t\t    extern_crate.get_referenced_crate ());\n \n-    // does it has an as clause\n-    if (extern_crate.has_as_clause ())\n-      {\n-\tauto decl = CanonicalPath::new_seg (extern_crate.get_node_id (),\n-\t\t\t\t\t    extern_crate.get_as_clause ());\n-\tresolver->get_type_scope ().insert (\n-\t  decl, extern_crate.get_node_id (), extern_crate.get_locus (), false,\n-\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\t    RichLocation r (extern_crate.get_locus ());\n-\t    r.add_range (locus);\n-\t    rust_error_at (r, \"redefined multiple times\");\n-\t  });\n-      }\n+    resolver->get_type_scope ().insert (\n+      decl, resolved_crate, extern_crate.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\tRichLocation r (extern_crate.get_locus ());\n+\tr.add_range (locus);\n+\trust_error_at (r, \"redefined multiple times\");\n+      });\n   }\n \n private:"}, {"sha": "f3007289eadf7374c4fe5de4ca7192ec1cfc975e", "filename": "gcc/rust/rust-object-export.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-object-export.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-object-export.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -17,9 +17,6 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-// FIXME: doesn't this duplicate lots of code from rust-backend.c? Is one meant\n-// to be a replacement?\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -54,9 +51,6 @@\n #define TARGET_AIX 0\n #endif\n \n-/* This file holds all the cases where the Rust frontend needs\n-   information from gcc's backend.  */\n-\n /* Return whether or not GCC has reported any errors.  */\n \n bool"}, {"sha": "eb4240a447fe35fddd91ce9f5fd7ccba05b21850", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 98, "deletions": 12, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -15,7 +15,6 @@\n // You should have received a copy of the GNU General Public License\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n-// #include \"rust-session-manager.h\"\n \n #include \"rust-session-manager.h\"\n #include \"rust-diagnostics.h\"\n@@ -33,6 +32,9 @@\n #include \"rust-lint-unused-var.h\"\n #include \"rust-hir-dump.h\"\n #include \"rust-ast-dump.h\"\n+#include \"rust-export-metadata.h\"\n+#include \"rust-imports.h\"\n+#include \"rust-extern-crate.h\"\n \n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -406,11 +408,11 @@ Session::handle_option (\n   switch (code)\n     {\n     case OPT_I:\n-      // TODO: add search path\n-      break;\n-\n-    case OPT_L:\n-      // TODO: add library link path or something\n+      case OPT_L: {\n+\t// TODO: add search path\n+\tconst std::string p = std::string (arg);\n+\tadd_search_path (p);\n+      }\n       break;\n \n     case OPT_frust_crate_:\n@@ -459,6 +461,10 @@ Session::handle_option (\n       options.set_edition (flag_rust_edition);\n       break;\n \n+    case OPT_frust_metadata_output_:\n+      options.set_metadata_output (arg);\n+      break;\n+\n     default:\n       break;\n     }\n@@ -793,6 +799,23 @@ Session::parse_file (const char *filename)\n       // lints\n       Analysis::ScanDeadcode::Scan (hir);\n       Analysis::UnusedVariables::Lint (ctx);\n+\n+      // metadata\n+      bool specified_emit_metadata\n+\t= flag_rust_embed_metadata || options.metadata_output_path_set ();\n+      if (!specified_emit_metadata)\n+\t{\n+\t  Metadata::PublicInterface::ExportTo (\n+\t    hir, Metadata::PublicInterface::expected_metadata_filename ());\n+\t}\n+      else\n+\t{\n+\t  if (flag_rust_embed_metadata)\n+\t    Metadata::PublicInterface::Export (hir);\n+\t  if (options.metadata_output_path_set ())\n+\t    Metadata::PublicInterface::ExportTo (\n+\t      hir, options.get_metadata_output ());\n+\t}\n     }\n \n   // pass to GCC middle-end\n@@ -947,6 +970,8 @@ Session::injection (AST::Crate &crate)\n    * an invalid crate type is not specified, so maybe just do that. Valid\n    * crate types: bin lib dylib staticlib cdylib rlib proc-macro */\n \n+  // this crate type will have options affecting the metadata ouput\n+\n   rust_debug (\"finished injection\");\n }\n \n@@ -1097,15 +1122,76 @@ Session::dump_type_resolution (HIR::Crate &hir) const\n // imports\n \n NodeId\n-Session::load_extern_crate (const std::string &crate_name)\n+Session::load_extern_crate (const std::string &crate_name, Location locus)\n {\n-  // check if it was already loaded\n-  // ....\n+  // has it already been loaded?\n+  CrateNum found_crate_num = UNKNOWN_CREATENUM;\n+  bool found = mappings->lookup_crate_name (crate_name, found_crate_num);\n+  if (found)\n+    {\n+      NodeId resolved_node_id = UNKNOWN_NODEID;\n+      bool resolved\n+\t= mappings->crate_num_to_nodeid (found_crate_num, resolved_node_id);\n+      rust_assert (resolved);\n+\n+      return resolved_node_id;\n+    }\n+\n+  std::string relative_import_path = \"\";\n+  Import::Stream *s\n+    = Import::open_package (crate_name, locus, relative_import_path);\n+  if (s == NULL)\n+    {\n+      rust_error_at (locus, \"failed to locate crate %<%s%>\",\n+\t\t     crate_name.c_str ());\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  Imports::ExternCrate extern_crate (*s);\n+  bool ok = extern_crate.load (locus);\n+  if (!ok)\n+    {\n+      rust_error_at (locus, \"failed to load crate metadata\");\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  // ensure the current vs this crate name don't collide\n+  const std::string current_crate_name = mappings->get_current_crate_name ();\n+  if (current_crate_name.compare (extern_crate.get_crate_name ()) == 0)\n+    {\n+      rust_error_at (locus, \"current crate name %<%s%> collides with this\",\n+\t\t     current_crate_name.c_str ());\n+      return UNKNOWN_NODEID;\n+    }\n+\n+  // setup mappings\n+  CrateNum saved_crate_num = mappings->get_current_crate ();\n+  CrateNum crate_num\n+    = mappings->get_next_crate_num (extern_crate.get_crate_name ());\n+  mappings->set_current_crate (crate_num);\n+\n+  // then lets parse this as a 2nd crate\n+  Lexer lex (extern_crate.get_metadata ());\n+  Parser<Lexer> parser (lex);\n+  std::unique_ptr<AST::Crate> metadata_crate = parser.parse_crate ();\n+  AST::Crate &parsed_crate\n+    = mappings->insert_ast_crate (std::move (metadata_crate), crate_num);\n+\n+  // name resolve it\n+  Resolver::NameResolution::Resolve (parsed_crate);\n+\n+  // perform hir lowering\n+  std::unique_ptr<HIR::Crate> lowered\n+    = HIR::ASTLowering::Resolve (parsed_crate);\n+  HIR::Crate &hir = mappings->insert_hir_crate (std::move (lowered));\n+\n+  // perform type resolution\n+  Resolver::TypeResolution::Resolve (hir);\n \n-  rust_debug (\"load_extern_crate: %s\", crate_name.c_str ());\n-  gcc_unreachable ();\n+  // always restore the crate_num\n+  mappings->set_current_crate (saved_crate_num);\n \n-  return UNKNOWN_NODEID;\n+  return parsed_crate.get_node_id ();\n }\n //\n "}, {"sha": "c68e796461fec697cfe58f82ab3bcaf9fc064911", "filename": "gcc/rust/rust-session-manager.h", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -189,6 +189,8 @@ struct CompileOptions\n   bool enable_test = false;\n   bool debug_assertions = false;\n   bool proc_macro = false;\n+  std::string metadata_output_path;\n+\n   enum Edition\n   {\n     E2015 = 0,\n@@ -236,6 +238,21 @@ struct CompileOptions\n   {\n     edition = static_cast<Edition> (raw_edition);\n   }\n+\n+  void set_metadata_output (const std::string &path)\n+  {\n+    metadata_output_path = path;\n+  }\n+\n+  const std::string &get_metadata_output () const\n+  {\n+    return metadata_output_path;\n+  }\n+\n+  bool metadata_output_path_set () const\n+  {\n+    return !metadata_output_path.empty ();\n+  }\n };\n \n /* Defines a compiler session. This is for a single compiler invocation, so\n@@ -292,7 +309,7 @@ struct Session\n     return extra_files.back ().c_str ();\n   }\n \n-  NodeId load_extern_crate (const std::string &crate_name);\n+  NodeId load_extern_crate (const std::string &crate_name, Location locus);\n \n private:\n   void parse_file (const char *filename);"}, {"sha": "58b8eb13db66ae52a4178327eef0c34b80513246", "filename": "gcc/testsuite/rust/link/generic_function_0.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_0.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_0.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_0.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,7 @@\n+extern crate generic_function_1;\n+use generic_function_1::generic_function;\n+\n+fn main() -> i32 {\n+    let a = generic_function(123);\n+    a - 123\n+}"}, {"sha": "8fb0788e388eea037b55c29e33210982a1559d0c", "filename": "gcc/testsuite/rust/link/generic_function_1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Fgeneric_function_1.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,3 @@\n+pub fn generic_function<X>(a: X) -> X {\n+    a\n+}"}, {"sha": "b504e4c4cd10b18b7326ef14c54d5c69c7fb6697", "filename": "gcc/testsuite/rust/link/link.exp", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Flink.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Flink.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Flink.exp?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,163 @@\n+# Copyright (C) 2021-2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Execute tests, torture testing.\n+\n+# Load support procs.\n+load_lib rust-dg.exp\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+set saved-dg-do-what-default ${dg-do-what-default}\n+\n+set dg-do-what-default \"assemble\"\n+\n+# rs-obj -- compile to an object file\n+#\n+# SOURCE is the source file\n+# DEST is the object file\n+# OPTALL is the list of compiler options to use with all tests\n+# OPTFILE is the list of compiler options to use with this file\n+# OPTSTR is the options to print with test messages\n+# XFAILDATA is the xfail data to be passed to the compiler\n+proc rs-obj { source dest optall optfile optstr xfaildata } {\n+    global tool\n+    global compiler_conditional_xfail_data\n+\n+    # Set up the options for compiling this file.\n+    set options \"\"\n+    lappend options \"additional_flags=$optall $optfile\"\n+\n+    set compiler_conditional_xfail_data $xfaildata\n+    set comp_output [${tool}_target_compile \"$source\" \"$dest\" object $options]\n+}\n+\n+# rs-execute -- compile multi-file tests\n+#\n+# SRC1 is the full pathname of the main file of the testcase.\n+# SID identifies a test suite in the names of temporary files.\n+proc rs-execute-1 { src1 } {\n+    global srcdir tmpdir\n+    \n+    # Get extra flags for this test from the primary source file, and\n+    # process other dg-* options that this suite supports.  Warn about\n+    # unsupported flags.\n+    verbose \"rs-execute: $src1\" 1\n+    set compile_type \"run\"\n+    set compile_xfail(0) \"\" \n+\n+    # Set up the names of the other source files.\n+    set dir [file dirname $src1]\n+    set base [file rootname $src1]\n+    set base [string range $base [string length $dir] end]\n+    regsub \"_0\" $base \"\" base\n+    regsub \"/\" $base \"\" base\n+    set src_list $src1\n+    set i 1\n+    set done 0\n+    while { !$done } {\n+\tset names [glob -nocomplain -types f -- \"${dir}/${base}_${i}.*\"]\n+\tif { [llength ${names}] > 1 } {\n+\t    warning \"rs-link-execute: more than one file matched ${dir}/${base}_${i}.*\"\n+\t}\n+\tif { [llength ${names}] == 1 } {\n+\t    lappend src_list [lindex ${names} 0]\n+\t    incr i\n+\t} else {\n+\t    set num_srcs ${i}\n+\t    set done 1\n+\t}\n+    }\n+\n+\n+    # Define the names of the object files.\n+    set obj_list \"\"\n+    for {set i 0} {$i < $num_srcs} {incr i} {\n+\tlappend obj_list \"${base}_${i}.o\"\n+    }\n+\n+    # Get the base name of this test, for use in messages.\n+    set testcase [lindex ${src_list} 0]\n+\n+    # Remove the $srcdir and $tmpdir prefixes from $src1.  (It would\n+    # be possible to use \"regsub\" here, if we were careful to escape\n+    # all regular expression characters in $srcdir and $tmpdir, but\n+    # that would be more complicated that this approach.) \n+    if {[string first \"$srcdir/\" \"${testcase}\"] == 0} {\n+\tset testcase [string range \"${testcase}\" [string length \"$srcdir/\"] end]\n+    }\n+    if {[string first \"$tmpdir/\" \"$testcase\"] == 0} {\n+\tset testcase [string range \"$testcase\" [string length \"$tmpdir/\"] end]\n+\tset testcase \"tmpdir-$testcase\"\n+    }\n+    # If we couldn't rip $srcdir out of `src1' then just do the best we can.\n+    # The point is to reduce the unnecessary noise in the logs.  Don't strip\n+    # out too much because different testcases with the same name can confuse\n+    # `test-tool'.\n+    if [string match \"/*\" $testcase] then {\n+        set testcase \"[file tail [file dirname $src1]]/[file tail $src1]\"\n+    }\n+\n+    # Set up the base name of executable files so they'll be unique.\n+    regsub -all \"\\[./\\]\" $testcase \"-\" execbase\n+\n+    verbose \"Testing $testcase - $obj_list - $src_list\"\n+    \n+    # There's a unique name for each executable we generate.\n+    set execname \"${execbase}-1.exe\"\n+\n+    # The LTO tests don't use dg-test, so testname_with_flags and\n+    # output_file need to be defined explicitly for each file.  scan-symbol\n+    # directives rely on both of these to be defined to find the symbol to\n+    # scan and for the text to print in the PASS/FAIL since they can also\n+    # be called from dg-test.  testname_with_flags is also used via\n+    # testname-for-summary when calling into generic function below to\n+    # clean temporary files.\n+    set output_file $execname\n+    set testname_with_flags $execname\n+\n+    file_on_host delete $execname\n+    \n+    rs-obj [lindex ${src_list} 1] [lindex ${obj_list} 1] \"\" \"\" \"\" \"\"\n+    rs-obj [lindex ${src_list} 0] [lindex ${obj_list} 0] \"\" \"\" \"\" \"\"\n+\n+    gcc-dg-runtest [lindex ${src_list} 0] \"\" \"\"\n+\n+    # FIXME it would be ideal if we could link then execute these tests.\n+    # I was not able to figure out how to specify gc-dg-runtest to link\n+    # against the first object.\n+}\n+\n+proc rs-link-execute { src1 } {\n+    rs-execute-1 $src1\n+}\n+\n+# Main loop.\n+foreach src [lsort [find $srcdir/$subdir *_0.rs]] {\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $src] then {\n+\tcontinue\n+    }\n+\n+    rs-link-execute $src\n+}\n+\n+set dg-do-what-default ${saved-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "5bd3238a7f0e656c9c44770d77f9d54bca49b2cd", "filename": "gcc/testsuite/rust/link/simple_function_0.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_0.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_0.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_0.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,7 @@\n+extern crate simple_function_1;\n+use simple_function_1::test_func;\n+\n+fn main() -> i32 {\n+    let a = test_func(123);\n+    a - 124\n+}"}, {"sha": "aaa1fc3936700a21176e8a46cd6f8c5577984df8", "filename": "gcc/testsuite/rust/link/simple_function_1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Fsimple_function_1.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,3 @@\n+pub fn test_func(a: i32) -> i32 {\n+    a + 1\n+}"}, {"sha": "ac8c5811d22b40068fa9b462cfaa8b26f11edaf8", "filename": "gcc/testsuite/rust/link/trait_import_0.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_0.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_0.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_0.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,19 @@\n+extern crate trait_import_1;\n+use trait_import_1::Add;\n+\n+struct Foo(i32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        Foo(self.0 + other.0)\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "fc7f5168ede14777d10de3bde7f2115ab553263d", "filename": "gcc/testsuite/rust/link/trait_import_1.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd2bd659e44e5b7fea92bc34a4864f057f387490/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Flink%2Ftrait_import_1.rs?ref=fd2bd659e44e5b7fea92bc34a4864f057f387490", "patch": "@@ -0,0 +1,6 @@\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+}"}]}