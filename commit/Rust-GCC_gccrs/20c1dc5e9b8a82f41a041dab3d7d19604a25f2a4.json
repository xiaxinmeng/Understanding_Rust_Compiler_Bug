{"sha": "20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBjMWRjNWU5YjhhODJmNDFhMDQxZGFiM2Q3ZDE5NjA0YTI1ZjJhNA==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-06-07T18:35:35Z"}, "committer": {"name": "Andreas Jaeger", "email": "aj@gcc.gnu.org", "date": "2003-06-07T18:35:35Z"}, "message": "ggc.h: Convert to ISO C90 prototypes.\n\n\t* ggc.h: Convert to ISO C90 prototypes.\n\t* ggc-none.c: Likewise.\n\t* ggc-common.c: Likewise.\n\t* ggc-page.c: Likewise.\n\t* ggc-simple.c: Likewise.\n\nFrom-SVN: r67596", "tree": {"sha": "e38d1bc08b7ca1fda6e483c32e4bc387f3fc87a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e38d1bc08b7ca1fda6e483c32e4bc387f3fc87a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "60e9f0d726fd28b960c5674a3c7beaf7015dbd34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60e9f0d726fd28b960c5674a3c7beaf7015dbd34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60e9f0d726fd28b960c5674a3c7beaf7015dbd34"}], "stats": {"total": 628, "additions": 264, "deletions": 364}, "files": [{"sha": "b7925e5fcad29f8d57a71f9c01e8e0101182b5d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -1,5 +1,11 @@\n 2003-06-07  Andreas Jaeger  <aj@suse.de>\n \n+\t* ggc.h: Convert to ISO C90 prototypes.\n+\t* ggc-none.c: Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* ggc-page.c: Likewise.\n+\t* ggc-simple.c: Likewise.\n+\n \t* crtstuff.c: Remove undefined usage of INIT_SECTION_PREAMBLE.\n \n \t* system.h: Poison INIT_SECTION_PREAMBLE."}, {"sha": "8e5be8ca299b7c2873f770e08395255e86020477", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 63, "deletions": 93, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -54,25 +54,23 @@ static ggc_statistics *ggc_stats;\n \n struct traversal_state;\n \n-static int ggc_htab_delete PARAMS ((void **, void *));\n-static hashval_t saving_htab_hash PARAMS ((const PTR));\n-static int saving_htab_eq PARAMS ((const PTR, const PTR));\n-static int call_count PARAMS ((void **, void *));\n-static int call_alloc PARAMS ((void **, void *));\n-static int compare_ptr_data PARAMS ((const void *, const void *));\n-static void relocate_ptrs PARAMS ((void *, void *));\n-static void write_pch_globals PARAMS ((const struct ggc_root_tab * const *tab,\n-\t\t\t\t       struct traversal_state *state));\n-static double ggc_rlimit_bound PARAMS ((double));\n+static int ggc_htab_delete (void **, void *);\n+static hashval_t saving_htab_hash (const void *);\n+static int saving_htab_eq (const void *, const void *);\n+static int call_count (void **, void *);\n+static int call_alloc (void **, void *);\n+static int compare_ptr_data (const void *, const void *);\n+static void relocate_ptrs (void *, void *);\n+static void write_pch_globals (const struct ggc_root_tab * const *tab,\n+\t\t\t       struct traversal_state *state);\n+static double ggc_rlimit_bound (double);\n \n /* Maintain global roots that are preserved during GC.  */\n \n /* Process a slot of an htab by deleting it if it has not been marked.  */\n \n static int\n-ggc_htab_delete (slot, info)\n-     void **slot;\n-     void *info;\n+ggc_htab_delete (void **slot, void *info)\n {\n   const struct ggc_cache_tab *r = (const struct ggc_cache_tab *) info;\n \n@@ -87,7 +85,7 @@ ggc_htab_delete (slot, info)\n /* Iterate through all registered roots and mark each element.  */\n \n void\n-ggc_mark_roots ()\n+ggc_mark_roots (void)\n {\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n@@ -113,15 +111,14 @@ ggc_mark_roots ()\n       if (*cti->base)\n \t{\n \t  ggc_set_mark (*cti->base);\n-\t  htab_traverse_noresize (*cti->base, ggc_htab_delete, (PTR) cti);\n+\t  htab_traverse_noresize (*cti->base, ggc_htab_delete, (void *) cti);\n \t  ggc_set_mark ((*cti->base)->entries);\n \t}\n }\n \n /* Allocate a block of memory, then clear it.  */\n void *\n-ggc_alloc_cleared (size)\n-     size_t size;\n+ggc_alloc_cleared (size_t size)\n {\n   void *buf = ggc_alloc (size);\n   memset (buf, 0, size);\n@@ -130,9 +127,7 @@ ggc_alloc_cleared (size)\n \n /* Resize a block of memory, possibly re-allocating it.  */\n void *\n-ggc_realloc (x, size)\n-     void *x;\n-     size_t size;\n+ggc_realloc (void *x, size_t size)\n {\n   void *r;\n   size_t old_size;\n@@ -150,7 +145,7 @@ ggc_realloc (x, size)\n \t don't know that previously allocated size.  Without that\n \t knowledge we have to lose some initialization-tracking for the\n \t old parts of the object.  An alternative is to mark the whole\n-\t old_size as reachable, but that would lose tracking of writes \n+\t old_size as reachable, but that would lose tracking of writes\n \t after the end of the object (by small offsets).  Discard the\n \t handle to avoid handle leak.  */\n       VALGRIND_DISCARD (VALGRIND_MAKE_NOACCESS ((char *) x + size,\n@@ -177,27 +172,22 @@ ggc_realloc (x, size)\n \n /* Like ggc_alloc_cleared, but performs a multiplication.  */\n void *\n-ggc_calloc (s1, s2)\n-     size_t s1, s2;\n+ggc_calloc (size_t s1, size_t s2)\n {\n   return ggc_alloc_cleared (s1 * s2);\n }\n \n /* These are for splay_tree_new_ggc.  */\n-PTR \n-ggc_splay_alloc (sz, nl)\n-     int sz;\n-     PTR nl;\n+void *\n+ggc_splay_alloc (int sz, void *nl)\n {\n   if (nl != NULL)\n     abort ();\n   return ggc_alloc (sz);\n }\n \n void\n-ggc_splay_dont_free (x, nl)\n-     PTR x ATTRIBUTE_UNUSED;\n-     PTR nl;\n+ggc_splay_dont_free (void * x ATTRIBUTE_UNUSED, void *nl)\n {\n   if (nl != NULL)\n     abort ();\n@@ -212,9 +202,8 @@ ggc_splay_dont_free (x, nl)\n #define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n \n void\n-ggc_print_common_statistics (stream, stats)\n-     FILE *stream ATTRIBUTE_UNUSED;\n-     ggc_statistics *stats;\n+ggc_print_common_statistics (FILE *stream ATTRIBUTE_UNUSED,\n+\t\t\t     ggc_statistics *stats)\n {\n   /* Set the pointer so that during collection we will actually gather\n      the statistics.  */\n@@ -233,7 +222,7 @@ ggc_print_common_statistics (stream, stats)\n \n static htab_t saving_htab;\n \n-struct ptr_data \n+struct ptr_data\n {\n   void *obj;\n   void *note_ptr_cookie;\n@@ -248,13 +237,11 @@ struct ptr_data\n /* Register an object in the hash table.  */\n \n int\n-gt_pch_note_object (obj, note_ptr_cookie, note_ptr_fn)\n-     void *obj;\n-     void *note_ptr_cookie;\n-     gt_note_pointers note_ptr_fn;\n+gt_pch_note_object (void *obj, void *note_ptr_cookie,\n+\t\t    gt_note_pointers note_ptr_fn)\n {\n   struct ptr_data **slot;\n-  \n+\n   if (obj == NULL || obj == (void *) 1)\n     return 0;\n \n@@ -268,7 +255,7 @@ gt_pch_note_object (obj, note_ptr_cookie, note_ptr_fn)\n \tabort ();\n       return 0;\n     }\n-  \n+\n   *slot = xcalloc (sizeof (struct ptr_data), 1);\n   (*slot)->obj = obj;\n   (*slot)->note_ptr_fn = note_ptr_fn;\n@@ -283,44 +270,39 @@ gt_pch_note_object (obj, note_ptr_cookie, note_ptr_fn)\n /* Register an object in the hash table.  */\n \n void\n-gt_pch_note_reorder (obj, note_ptr_cookie, reorder_fn)\n-     void *obj;\n-     void *note_ptr_cookie;\n-     gt_handle_reorder reorder_fn;\n+gt_pch_note_reorder (void *obj, void *note_ptr_cookie,\n+\t\t     gt_handle_reorder reorder_fn)\n {\n   struct ptr_data *data;\n-  \n+\n   if (obj == NULL || obj == (void *) 1)\n     return;\n \n   data = htab_find_with_hash (saving_htab, obj, POINTER_HASH (obj));\n   if (data == NULL\n       || data->note_ptr_cookie != note_ptr_cookie)\n     abort ();\n-  \n+\n   data->reorder_fn = reorder_fn;\n }\n \n /* Hash and equality functions for saving_htab, callbacks for htab_create.  */\n \n static hashval_t\n-saving_htab_hash (p)\n-     const PTR p;\n+saving_htab_hash (const void *p)\n {\n   return POINTER_HASH (((struct ptr_data *)p)->obj);\n }\n \n static int\n-saving_htab_eq (p1, p2)\n-     const PTR p1;\n-     const PTR p2;\n+saving_htab_eq (const void *p1, const void *p2)\n {\n   return ((struct ptr_data *)p1)->obj == p2;\n }\n \n /* Handy state for the traversal functions.  */\n \n-struct traversal_state \n+struct traversal_state\n {\n   FILE *f;\n   struct ggc_pch_data *d;\n@@ -332,26 +314,22 @@ struct traversal_state\n /* Callbacks for htab_traverse.  */\n \n static int\n-call_count (slot, state_p)\n-     void **slot;\n-     void *state_p;\n+call_count (void **slot, void *state_p)\n {\n   struct ptr_data *d = (struct ptr_data *)*slot;\n   struct traversal_state *state = (struct traversal_state *)state_p;\n-  \n+\n   ggc_pch_count_object (state->d, d->obj, d->size);\n   state->count++;\n   return 1;\n }\n \n static int\n-call_alloc (slot, state_p)\n-     void **slot;\n-     void *state_p;\n+call_alloc (void **slot, void *state_p)\n {\n   struct ptr_data *d = (struct ptr_data *)*slot;\n   struct traversal_state *state = (struct traversal_state *)state_p;\n-  \n+\n   d->new_addr = ggc_pch_alloc_object (state->d, d->obj, d->size);\n   state->ptrs[state->ptrs_i++] = d;\n   return 1;\n@@ -360,9 +338,7 @@ call_alloc (slot, state_p)\n /* Callback for qsort.  */\n \n static int\n-compare_ptr_data (p1_p, p2_p)\n-     const void *p1_p;\n-     const void *p2_p;\n+compare_ptr_data (const void *p1_p, const void *p2_p)\n {\n   struct ptr_data *p1 = *(struct ptr_data *const *)p1_p;\n   struct ptr_data *p2 = *(struct ptr_data *const *)p2_p;\n@@ -373,18 +349,16 @@ compare_ptr_data (p1_p, p2_p)\n /* Callbacks for note_ptr_fn.  */\n \n static void\n-relocate_ptrs (ptr_p, state_p)\n-     void *ptr_p;\n-     void *state_p;\n+relocate_ptrs (void *ptr_p, void *state_p)\n {\n   void **ptr = (void **)ptr_p;\n-  struct traversal_state *state ATTRIBUTE_UNUSED \n+  struct traversal_state *state ATTRIBUTE_UNUSED\n     = (struct traversal_state *)state_p;\n   struct ptr_data *result;\n \n   if (*ptr == NULL || *ptr == (void *)1)\n     return;\n-  \n+\n   result = htab_find_with_hash (saving_htab, *ptr, POINTER_HASH (*ptr));\n   if (result == NULL)\n     abort ();\n@@ -393,9 +367,8 @@ relocate_ptrs (ptr_p, state_p)\n \n /* Write out, after relocation, the pointers in TAB.  */\n static void\n-write_pch_globals (tab, state)\n-     const struct ggc_root_tab * const *tab;\n-     struct traversal_state *state;\n+write_pch_globals (const struct ggc_root_tab * const *tab,\n+\t\t   struct traversal_state *state)\n {\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n@@ -409,15 +382,15 @@ write_pch_globals (tab, state)\n \t  struct ptr_data *new_ptr;\n \t  if (ptr == NULL || ptr == (void *)1)\n \t    {\n-\t      if (fwrite (&ptr, sizeof (void *), 1, state->f) \n+\t      if (fwrite (&ptr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n \t\tfatal_error (\"can't write PCH file: %m\");\n \t    }\n \t  else\n \t    {\n-\t      new_ptr = htab_find_with_hash (saving_htab, ptr, \n+\t      new_ptr = htab_find_with_hash (saving_htab, ptr,\n \t\t\t\t\t     POINTER_HASH (ptr));\n-\t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f) \n+\t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n \t\tfatal_error (\"can't write PCH file: %m\");\n \t    }\n@@ -426,7 +399,7 @@ write_pch_globals (tab, state)\n \n /* Hold the information we need to mmap the file back in.  */\n \n-struct mmap_info \n+struct mmap_info\n {\n   size_t offset;\n   size_t size;\n@@ -436,8 +409,7 @@ struct mmap_info\n /* Write out the state of the compiler to F.  */\n \n void\n-gt_pch_save (f)\n-     FILE *f;\n+gt_pch_save (FILE *f)\n {\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n@@ -474,7 +446,7 @@ gt_pch_save (f)\n      but don't try very hard.  On most platforms, this will always work,\n      and on the rest it's a lot of work to do better.  */\n #if HAVE_MMAP_FILE\n-  mmi.preferred_base = mmap (NULL, mmi.size, \n+  mmi.preferred_base = mmap (NULL, mmi.size,\n \t\t\t     PROT_READ | PROT_WRITE, MAP_PRIVATE,\n \t\t\t     fileno (state.f), 0);\n   if (mmi.preferred_base == (void *)-1)\n@@ -503,7 +475,7 @@ gt_pch_save (f)\n   write_pch_globals (gt_pch_cache_rtab, &state);\n \n   ggc_pch_prepare_write (state.d, state.f);\n-  \n+\n   /* Pad the PCH file so that the mmaped area starts on a page boundary.  */\n   {\n     long o;\n@@ -531,10 +503,10 @@ gt_pch_save (f)\n \t}\n       memcpy (this_object, state.ptrs[i]->obj, state.ptrs[i]->size);\n       if (state.ptrs[i]->reorder_fn != NULL)\n-\tstate.ptrs[i]->reorder_fn (state.ptrs[i]->obj, \n+\tstate.ptrs[i]->reorder_fn (state.ptrs[i]->obj,\n \t\t\t\t   state.ptrs[i]->note_ptr_cookie,\n \t\t\t\t   relocate_ptrs, &state);\n-      state.ptrs[i]->note_ptr_fn (state.ptrs[i]->obj, \n+      state.ptrs[i]->note_ptr_fn (state.ptrs[i]->obj,\n \t\t\t\t  state.ptrs[i]->note_ptr_cookie,\n \t\t\t\t  relocate_ptrs, &state);\n       ggc_pch_write_object (state.d, state.f, state.ptrs[i]->obj,\n@@ -552,8 +524,7 @@ gt_pch_save (f)\n /* Read the state of the compiler back in from F.  */\n \n void\n-gt_pch_restore (f)\n-     FILE *f;\n+gt_pch_restore (FILE *f)\n {\n   const struct ggc_root_tab *const *rt;\n   const struct ggc_root_tab *rti;\n@@ -591,9 +562,9 @@ gt_pch_restore (f)\n \n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (\"can't read PCH file: %m\");\n-  \n+\n #if HAVE_MMAP_FILE\n-  addr = mmap (mmi.preferred_base, mmi.size, \n+  addr = mmap (mmi.preferred_base, mmi.size,\n \t       PROT_READ | PROT_WRITE, MAP_PRIVATE,\n \t       fileno (f), mmi.offset);\n #else\n@@ -621,7 +592,7 @@ gt_pch_restore (f)\n \t      if (*ptr != NULL)\n \t\t*ptr += (size_t)addr - (size_t)mmi.preferred_base;\n \t    }\n-      \n+\n       for (rt = gt_pch_cache_rtab; *rt; rt++)\n \tfor (rti = *rt; rti->base != NULL; rti++)\n \t  for (i = 0; i < rti->nelt; i++)\n@@ -639,8 +610,7 @@ gt_pch_restore (f)\n \n /* Modify the bound based on rlimits.  Keep the smallest number found.  */\n static double\n-ggc_rlimit_bound (limit)\n-     double limit;\n+ggc_rlimit_bound (double limit)\n {\n #if defined(HAVE_GETRLIMIT)\n   struct rlimit rlim;\n@@ -669,13 +639,13 @@ ggc_rlimit_bound (limit)\n \n /* Heuristic to set a default for GGC_MIN_EXPAND.  */\n int\n-ggc_min_expand_heuristic()\n+ggc_min_expand_heuristic (void)\n {\n   double min_expand = physmem_total();\n \n   /* Adjust for rlimits.  */\n   min_expand = ggc_rlimit_bound (min_expand);\n-  \n+\n   /* The heuristic is a percentage equal to 30% + 70%*(RAM/1GB), yielding\n      a lower bound of 30% and an upper bound of 100% (when RAM >= 1GB).  */\n   min_expand /= 1024*1024*1024;\n@@ -688,15 +658,15 @@ ggc_min_expand_heuristic()\n \n /* Heuristic to set a default for GGC_MIN_HEAPSIZE.  */\n int\n-ggc_min_heapsize_heuristic()\n+ggc_min_heapsize_heuristic (void)\n {\n   double min_heap_kbytes = physmem_total();\n \n   /* Adjust for rlimits.  */\n   min_heap_kbytes = ggc_rlimit_bound (min_heap_kbytes);\n \n   min_heap_kbytes /= 1024; /* convert to Kbytes.  */\n-  \n+\n   /* The heuristic is RAM/8, with a lower bound of 4M and an upper\n      bound of 128M (when RAM >= 1GB).  */\n   min_heap_kbytes /= 8;\n@@ -707,7 +677,7 @@ ggc_min_heapsize_heuristic()\n }\n \n void\n-init_ggc_heuristics ()\n+init_ggc_heuristics (void)\n {\n #ifndef ENABLE_GC_ALWAYS_COLLECT\n   set_param_value (\"ggc-min-expand\", ggc_min_expand_heuristic());"}, {"sha": "ee53e761a85b844513669627f2aa0f682b95e7f9", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -1,5 +1,6 @@\n /* Null garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2003\n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -29,23 +30,19 @@\n #include \"ggc.h\"\n \n void *\n-ggc_alloc (size)\n-     size_t size;\n+ggc_alloc (size_t size)\n {\n   return xmalloc (size);\n }\n \n void *\n-ggc_alloc_cleared (size)\n-     size_t size;\n+ggc_alloc_cleared (size_t size)\n {\n   return xcalloc (size, 1);\n }\n \n void *\n-ggc_realloc (x, size)\n-     void *x;\n-     size_t size;\n+ggc_realloc (void *x, size_t size)\n {\n   return xrealloc (x, size);\n }"}, {"sha": "929ef8e41cc6d19e59c862bdc7c2fbf06b408744", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 87, "deletions": 127, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -420,40 +420,39 @@ static struct globals\n /* Initial guess as to how many page table entries we might need.  */\n #define INITIAL_PTE_COUNT 128\n \f\n-static int ggc_allocated_p PARAMS ((const void *));\n-static page_entry *lookup_page_table_entry PARAMS ((const void *));\n-static void set_page_table_entry PARAMS ((void *, page_entry *));\n+static int ggc_allocated_p (const void *);\n+static page_entry *lookup_page_table_entry (const void *);\n+static void set_page_table_entry (void *, page_entry *);\n #ifdef USING_MMAP\n-static char *alloc_anon PARAMS ((char *, size_t));\n+static char *alloc_anon (char *, size_t);\n #endif\n #ifdef USING_MALLOC_PAGE_GROUPS\n-static size_t page_group_index PARAMS ((char *, char *));\n-static void set_page_group_in_use PARAMS ((page_group *, char *));\n-static void clear_page_group_in_use PARAMS ((page_group *, char *));\n+static size_t page_group_index (char *, char *);\n+static void set_page_group_in_use (page_group *, char *);\n+static void clear_page_group_in_use (page_group *, char *);\n #endif\n-static struct page_entry * alloc_page PARAMS ((unsigned));\n-static void free_page PARAMS ((struct page_entry *));\n-static void release_pages PARAMS ((void));\n-static void clear_marks PARAMS ((void));\n-static void sweep_pages PARAMS ((void));\n-static void ggc_recalculate_in_use_p PARAMS ((page_entry *));\n-static void compute_inverse PARAMS ((unsigned));\n-static inline void adjust_depth PARAMS ((void));\n-static void move_ptes_to_front PARAMS ((int, int));\n+static struct page_entry * alloc_page (unsigned);\n+static void free_page (struct page_entry *);\n+static void release_pages (void);\n+static void clear_marks (void);\n+static void sweep_pages (void);\n+static void ggc_recalculate_in_use_p (page_entry *);\n+static void compute_inverse (unsigned);\n+static inline void adjust_depth (void);\n+static void move_ptes_to_front (int, int);\n \n #ifdef ENABLE_GC_CHECKING\n-static void poison_pages PARAMS ((void));\n+static void poison_pages (void);\n #endif\n \n-void debug_print_page_list PARAMS ((int));\n-static void push_depth PARAMS ((unsigned int));\n-static void push_by_depth PARAMS ((page_entry *, unsigned long *));\n+void debug_print_page_list (int);\n+static void push_depth (unsigned int);\n+static void push_by_depth (page_entry *, unsigned long *);\n \f\n /* Push an entry onto G.depth.  */\n \n inline static void\n-push_depth (i)\n-     unsigned int i;\n+push_depth (unsigned int i)\n {\n   if (G.depth_in_use >= G.depth_max)\n     {\n@@ -467,9 +466,7 @@ push_depth (i)\n /* Push an entry onto G.by_depth and G.save_in_use.  */\n \n inline static void\n-push_by_depth (p, s)\n-     page_entry *p;\n-     unsigned long *s;\n+push_by_depth (page_entry *p, unsigned long *s)\n {\n   if (G.by_depth_in_use >= G.by_depth_max)\n     {\n@@ -497,8 +494,7 @@ push_by_depth (p, s)\n /* Returns nonzero if P was allocated in GC'able memory.  */\n \n static inline int\n-ggc_allocated_p (p)\n-     const void *p;\n+ggc_allocated_p (const void *p)\n {\n   page_entry ***base;\n   size_t L1, L2;\n@@ -530,8 +526,7 @@ ggc_allocated_p (p)\n    Die (probably) if the object wasn't allocated via GC.  */\n \n static inline page_entry *\n-lookup_page_table_entry(p)\n-     const void *p;\n+lookup_page_table_entry (const void *p)\n {\n   page_entry ***base;\n   size_t L1, L2;\n@@ -556,9 +551,7 @@ lookup_page_table_entry(p)\n /* Set the page table entry for a page.  */\n \n static void\n-set_page_table_entry(p, entry)\n-     void *p;\n-     page_entry *entry;\n+set_page_table_entry (void *p, page_entry *entry)\n {\n   page_entry ***base;\n   size_t L1, L2;\n@@ -594,16 +587,15 @@ set_page_table_entry(p, entry)\n /* Prints the page-entry for object size ORDER, for debugging.  */\n \n void\n-debug_print_page_list (order)\n-     int order;\n+debug_print_page_list (int order)\n {\n   page_entry *p;\n-  printf (\"Head=%p, Tail=%p:\\n\", (PTR) G.pages[order],\n-\t  (PTR) G.page_tails[order]);\n+  printf (\"Head=%p, Tail=%p:\\n\", (void *) G.pages[order],\n+\t  (void *) G.page_tails[order]);\n   p = G.pages[order];\n   while (p != NULL)\n     {\n-      printf (\"%p(%1d|%3d) -> \", (PTR) p, p->context_depth,\n+      printf (\"%p(%1d|%3d) -> \", (void *) p, p->context_depth,\n \t      p->num_free_objects);\n       p = p->next;\n     }\n@@ -617,9 +609,7 @@ debug_print_page_list (order)\n    compile error unless exactly one of the HAVE_* is defined.  */\n \n static inline char *\n-alloc_anon (pref, size)\n-     char *pref ATTRIBUTE_UNUSED;\n-     size_t size;\n+alloc_anon (char *pref ATTRIBUTE_UNUSED, size_t size)\n {\n #ifdef HAVE_MMAP_ANON\n   char *page = (char *) mmap (pref, size, PROT_READ | PROT_WRITE,\n@@ -651,26 +641,21 @@ alloc_anon (pref, size)\n /* Compute the index for this page into the page group.  */\n \n static inline size_t\n-page_group_index (allocation, page)\n-     char *allocation, *page;\n+page_group_index (char *allocation, char *page)\n {\n   return (size_t) (page - allocation) >> G.lg_pagesize;\n }\n \n /* Set and clear the in_use bit for this page in the page group.  */\n \n static inline void\n-set_page_group_in_use (group, page)\n-     page_group *group;\n-     char *page;\n+set_page_group_in_use (page_group *group, char *page)\n {\n   group->in_use |= 1 << page_group_index (group->allocation, page);\n }\n \n static inline void\n-clear_page_group_in_use (group, page)\n-     page_group *group;\n-     char *page;\n+clear_page_group_in_use (page_group *group, char *page)\n {\n   group->in_use &= ~(1 << page_group_index (group->allocation, page));\n }\n@@ -681,8 +666,7 @@ clear_page_group_in_use (group, page)\n    appropriate page_table list.  */\n \n static inline struct page_entry *\n-alloc_page (order)\n-     unsigned order;\n+alloc_page (unsigned order)\n {\n   struct page_entry *entry, *p, **pp;\n   char *page;\n@@ -855,7 +839,7 @@ alloc_page (order)\n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file,\n \t     \"Allocating page at %p, object size=%lu, data %p-%p\\n\",\n-\t     (PTR) entry, (unsigned long) OBJECT_SIZE (order), page,\n+\t     (void *) entry, (unsigned long) OBJECT_SIZE (order), page,\n \t     page + entry_size - 1);\n \n   return entry;\n@@ -865,7 +849,7 @@ alloc_page (order)\n    used by the top of the G.by_depth is used.  */\n \n static inline void\n-adjust_depth ()\n+adjust_depth (void)\n {\n   page_entry *top;\n \n@@ -884,12 +868,11 @@ adjust_depth ()\n /* For a page that is no longer needed, put it on the free page list.  */\n \n static inline void\n-free_page (entry)\n-     page_entry *entry;\n+free_page (page_entry *entry)\n {\n   if (GGC_DEBUG_LEVEL >= 2)\n     fprintf (G.debug_file,\n-\t     \"Deallocating page at %p, data %p-%p\\n\", (PTR) entry,\n+\t     \"Deallocating page at %p, data %p-%p\\n\", (void *) entry,\n \t     entry->page, entry->page + entry->bytes - 1);\n \n   /* Mark the page as inaccessible.  Discard the handle to avoid handle\n@@ -933,7 +916,7 @@ free_page (entry)\n /* Release the free page cache to the system.  */\n \n static void\n-release_pages ()\n+release_pages (void)\n {\n #ifdef USING_MMAP\n   page_entry *p, *next;\n@@ -1021,8 +1004,7 @@ static unsigned char size_lookup[257] =\n /* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */\n \n void *\n-ggc_alloc (size)\n-     size_t size;\n+ggc_alloc (size_t size)\n {\n   unsigned order, word, bit, object_offset;\n   struct page_entry *entry;\n@@ -1149,7 +1131,7 @@ ggc_alloc (size)\n     fprintf (G.debug_file,\n \t     \"Allocating object, requested size=%lu, actual=%lu at %p on %p\\n\",\n \t     (unsigned long) size, (unsigned long) OBJECT_SIZE (order), result,\n-\t     (PTR) entry);\n+\t     (void *) entry);\n \n   return result;\n }\n@@ -1159,8 +1141,7 @@ ggc_alloc (size)\n    static objects, stack variables, or memory allocated with malloc.  */\n \n int\n-ggc_set_mark (p)\n-     const void *p;\n+ggc_set_mark (const void *p)\n {\n   page_entry *entry;\n   unsigned bit, word;\n@@ -1199,8 +1180,7 @@ ggc_set_mark (p)\n    static objects, stack variables, or memory allocated with malloc.  */\n \n int\n-ggc_marked_p (p)\n-     const void *p;\n+ggc_marked_p (const void *p)\n {\n   page_entry *entry;\n   unsigned bit, word;\n@@ -1226,8 +1206,7 @@ ggc_marked_p (p)\n /* Return the size of the gc-able object P.  */\n \n size_t\n-ggc_get_size (p)\n-     const void *p;\n+ggc_get_size (const void *p)\n {\n   page_entry *pe = lookup_page_table_entry (p);\n   return OBJECT_SIZE (pe->order);\n@@ -1242,8 +1221,7 @@ ggc_get_size (p)\n    constants).  */\n \n static void\n-compute_inverse (order)\n-     unsigned order;\n+compute_inverse (unsigned order)\n {\n   unsigned size, inv, e;\n \n@@ -1277,7 +1255,7 @@ compute_inverse (order)\n \n /* Initialize the ggc-mmap allocator.  */\n void\n-init_ggc ()\n+init_ggc (void)\n {\n   unsigned order;\n \n@@ -1373,7 +1351,7 @@ init_ggc ()\n    are never freed, eliminating the need to register their roots.  */\n \n void\n-ggc_push_context ()\n+ggc_push_context (void)\n {\n   ++G.context_depth;\n \n@@ -1386,8 +1364,7 @@ ggc_push_context ()\n    reflects reality.  Recalculate NUM_FREE_OBJECTS as well.  */\n \n static void\n-ggc_recalculate_in_use_p (p)\n-     page_entry *p;\n+ggc_recalculate_in_use_p (page_entry *p)\n {\n   unsigned int i;\n   size_t num_objects;\n@@ -1424,7 +1401,7 @@ ggc_recalculate_in_use_p (p)\n    previous ggc_push_context are migrated to the outer context.  */\n \n void\n-ggc_pop_context ()\n+ggc_pop_context (void)\n {\n   unsigned long omask;\n   unsigned int depth, i, e;\n@@ -1451,7 +1428,7 @@ ggc_pop_context ()\n \n   /* We might not have any PTEs of depth depth.  */\n   if (depth < G.depth_in_use)\n-    {    \n+    {\n \n       /* First we go through all the pages at depth depth to\n \t recalculate the in use bits.  */\n@@ -1520,7 +1497,7 @@ ggc_pop_context ()\n /* Unmark all objects.  */\n \n static inline void\n-clear_marks ()\n+clear_marks (void)\n {\n   unsigned order;\n \n@@ -1565,7 +1542,7 @@ clear_marks ()\n    because the `mark' bit doubles as an `unused' bit.  */\n \n static inline void\n-sweep_pages ()\n+sweep_pages (void)\n {\n   unsigned order;\n \n@@ -1591,7 +1568,7 @@ sweep_pages ()\n \n \t  /* Loop until all entries have been examined.  */\n \t  done = (p == last);\n-\t  \n+\n \t  num_objects = OBJECTS_IN_PAGE (p);\n \n \t  /* Add all live objects on this page to the count of\n@@ -1674,7 +1651,7 @@ sweep_pages ()\n /* Clobber all free objects.  */\n \n static inline void\n-poison_pages ()\n+poison_pages (void)\n {\n   unsigned order;\n \n@@ -1724,7 +1701,7 @@ poison_pages ()\n /* Top level mark-and-sweep routine.  */\n \n void\n-ggc_collect ()\n+ggc_collect (void)\n {\n   /* Avoid frequent unnecessary work by skipping collection if the\n      total allocations haven't expanded much since the last\n@@ -1778,7 +1755,7 @@ ggc_collect ()\n #define LABEL(x) ((x) < 1024*10 ? ' ' : ((x) < 1024*1024*10 ? 'k' : 'M'))\n \n void\n-ggc_print_statistics ()\n+ggc_print_statistics (void)\n {\n   struct ggc_statistics stats;\n   unsigned int i;\n@@ -1820,7 +1797,7 @@ ggc_print_statistics ()\n       for (p = G.pages[i]; p; p = p->next)\n \t{\n \t  allocated += p->bytes;\n-\t  in_use += \n+\t  in_use +=\n \t    (OBJECTS_IN_PAGE (p) - p->num_free_objects) * OBJECT_SIZE (i);\n \n \t  overhead += (sizeof (page_entry) - sizeof (long)\n@@ -1841,7 +1818,7 @@ ggc_print_statistics ()\n \f\n struct ggc_pch_data\n {\n-  struct ggc_pch_ondisk \n+  struct ggc_pch_ondisk\n   {\n     unsigned totals[NUM_ORDERS];\n   } d;\n@@ -1850,16 +1827,14 @@ struct ggc_pch_data\n };\n \n struct ggc_pch_data *\n-init_ggc_pch ()\n+init_ggc_pch (void)\n {\n   return xcalloc (sizeof (struct ggc_pch_data), 1);\n }\n \n-void \n-ggc_pch_count_object (d, x, size)\n-     struct ggc_pch_data *d;\n-     void *x ATTRIBUTE_UNUSED;\n-     size_t size;\n+void\n+ggc_pch_count_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n+\t\t      size_t size)\n {\n   unsigned order;\n \n@@ -1871,13 +1846,12 @@ ggc_pch_count_object (d, x, size)\n       while (size > OBJECT_SIZE (order))\n \torder++;\n     }\n-  \n+\n   d->d.totals[order]++;\n }\n-     \n+\n size_t\n-ggc_pch_total_size (d)\n-     struct ggc_pch_data *d;\n+ggc_pch_total_size (struct ggc_pch_data *d)\n {\n   size_t a = 0;\n   unsigned i;\n@@ -1888,13 +1862,11 @@ ggc_pch_total_size (d)\n }\n \n void\n-ggc_pch_this_base (d, base)\n-     struct ggc_pch_data *d;\n-     void *base;\n+ggc_pch_this_base (struct ggc_pch_data *d, void *base)\n {\n   size_t a = (size_t) base;\n   unsigned i;\n-  \n+\n   for (i = 0; i < NUM_ORDERS; i++)\n     {\n       d->base[i] = a;\n@@ -1904,14 +1876,12 @@ ggc_pch_this_base (d, base)\n \n \n char *\n-ggc_pch_alloc_object (d, x, size)\n-     struct ggc_pch_data *d;\n-     void *x ATTRIBUTE_UNUSED;\n-     size_t size;\n+ggc_pch_alloc_object (struct ggc_pch_data *d, void *x ATTRIBUTE_UNUSED,\n+\t\t      size_t size)\n {\n   unsigned order;\n   char *result;\n-  \n+\n   if (size <= 256)\n     order = size_lookup[size];\n   else\n@@ -1926,21 +1896,17 @@ ggc_pch_alloc_object (d, x, size)\n   return result;\n }\n \n-void \n-ggc_pch_prepare_write (d, f)\n-     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n-     FILE * f ATTRIBUTE_UNUSED;\n+void\n+ggc_pch_prepare_write (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t       FILE *f ATTRIBUTE_UNUSED)\n {\n   /* Nothing to do.  */\n }\n \n void\n-ggc_pch_write_object (d, f, x, newx, size)\n-     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n-     FILE *f;\n-     void *x;\n-     void *newx ATTRIBUTE_UNUSED;\n-     size_t size;\n+ggc_pch_write_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t      FILE *f, void *x, void *newx ATTRIBUTE_UNUSED,\n+\t\t      size_t size)\n {\n   unsigned order;\n \n@@ -1952,7 +1918,7 @@ ggc_pch_write_object (d, f, x, newx, size)\n       while (size > OBJECT_SIZE (order))\n \torder++;\n     }\n-  \n+\n   if (fwrite (x, size, 1, f) != 1)\n     fatal_error (\"can't write PCH file: %m\");\n \n@@ -1971,9 +1937,7 @@ ggc_pch_write_object (d, f, x, newx, size)\n }\n \n void\n-ggc_pch_finish (d, f)\n-     struct ggc_pch_data * d;\n-     FILE *f;\n+ggc_pch_finish (struct ggc_pch_data *d, FILE *f)\n {\n   if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)\n     fatal_error (\"can't write PCH file: %m\");\n@@ -1984,9 +1948,7 @@ ggc_pch_finish (d, f)\n    front.  */\n \n static void\n-move_ptes_to_front (count_old_page_tables, count_new_page_tables)\n-     int count_old_page_tables;\n-     int count_new_page_tables;\n+move_ptes_to_front (int count_old_page_tables, int count_new_page_tables)\n {\n   unsigned i;\n \n@@ -2012,7 +1974,7 @@ move_ptes_to_front (count_old_page_tables, count_new_page_tables)\n \n   free (G.by_depth);\n   free (G.save_in_use);\n-    \n+\n   G.by_depth = new_by_depth;\n   G.save_in_use = new_save_in_use;\n \n@@ -2033,9 +1995,7 @@ move_ptes_to_front (count_old_page_tables, count_new_page_tables)\n }\n \n void\n-ggc_pch_read (f, addr)\n-     FILE *f;\n-     void *addr;\n+ggc_pch_read (FILE *f, void *addr)\n {\n   struct ggc_pch_ondisk d;\n   unsigned i;\n@@ -2069,7 +2029,7 @@ ggc_pch_read (f, addr)\n      the PCH file.  */\n   if (fread (&d, sizeof (d), 1, f) != 1)\n     fatal_error (\"can't read PCH file: %m\");\n-  \n+\n   for (i = 0; i < NUM_ORDERS; i++)\n     {\n       struct page_entry *entry;\n@@ -2083,7 +2043,7 @@ ggc_pch_read (f, addr)\n \n       bytes = ROUND_UP (d.totals[i] * OBJECT_SIZE (i), G.pagesize);\n       num_objs = bytes / OBJECT_SIZE (i);\n-      entry = xcalloc (1, (sizeof (struct page_entry) \n+      entry = xcalloc (1, (sizeof (struct page_entry)\n \t\t\t   - sizeof (long)\n \t\t\t   + BITMAP_SIZE (num_objs + 1)));\n       entry->bytes = bytes;\n@@ -2093,16 +2053,16 @@ ggc_pch_read (f, addr)\n       entry->num_free_objects = 0;\n       entry->order = i;\n \n-      for (j = 0; \n+      for (j = 0;\n \t   j + HOST_BITS_PER_LONG <= num_objs + 1;\n \t   j += HOST_BITS_PER_LONG)\n \tentry->in_use_p[j / HOST_BITS_PER_LONG] = -1;\n       for (; j < num_objs + 1; j++)\n-\tentry->in_use_p[j / HOST_BITS_PER_LONG] \n+\tentry->in_use_p[j / HOST_BITS_PER_LONG]\n \t  |= 1L << (j % HOST_BITS_PER_LONG);\n \n-      for (pte = entry->page; \n-\t   pte < entry->page + entry->bytes; \n+      for (pte = entry->page;\n+\t   pte < entry->page + entry->bytes;\n \t   pte += G.pagesize)\n \tset_page_table_entry (pte, entry);\n "}, {"sha": "4bcc099760f790baae854d5f88054788fecc0178", "filename": "gcc/ggc-simple.c", "status": "modified", "additions": 50, "deletions": 75, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-simple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc-simple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-simple.c?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -1,5 +1,6 @@\n /* Simple garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -113,25 +114,24 @@ static struct globals\n \n /* Local function prototypes.  */\n \n-static void tree_insert PARAMS ((struct ggc_mem *));\n-static int tree_lookup PARAMS ((struct ggc_mem *));\n-static void clear_marks PARAMS ((struct ggc_mem *));\n-static void sweep_objs PARAMS ((struct ggc_mem **));\n-static void ggc_pop_context_1 PARAMS ((struct ggc_mem *, int));\n+static void tree_insert (struct ggc_mem *);\n+static int tree_lookup (struct ggc_mem *);\n+static void clear_marks (struct ggc_mem *);\n+static void sweep_objs (struct ggc_mem **);\n+static void ggc_pop_context_1 (struct ggc_mem *, int);\n \n /* For use from debugger.  */\n-extern void debug_ggc_tree PARAMS ((struct ggc_mem *, int));\n+extern void debug_ggc_tree (struct ggc_mem *, int);\n \n #ifdef GGC_BALANCE\n-extern void debug_ggc_balance PARAMS ((void));\n+extern void debug_ggc_balance (void);\n #endif\n-static void tally_leaves PARAMS ((struct ggc_mem *, int, size_t *, size_t *));\n+static void tally_leaves (struct ggc_mem *, int, size_t *, size_t *);\n \n /* Insert V into the search tree.  */\n \n static inline void\n-tree_insert (v)\n-     struct ggc_mem *v;\n+tree_insert (struct ggc_mem *v)\n {\n   size_t v_key = PTR_KEY (v);\n   struct ggc_mem *p, **pp;\n@@ -147,8 +147,7 @@ tree_insert (v)\n /* Return true if V is in the tree.  */\n \n static inline int\n-tree_lookup (v)\n-     struct ggc_mem *v;\n+tree_lookup (struct ggc_mem *v)\n {\n   size_t v_key = PTR_KEY (v);\n   struct ggc_mem *p = G.root;\n@@ -167,8 +166,7 @@ tree_lookup (v)\n /* Alloc SIZE bytes of GC'able memory.  If ZERO, clear the memory.  */\n \n void *\n-ggc_alloc (size)\n-     size_t size;\n+ggc_alloc (size_t size)\n {\n   struct ggc_mem *x;\n \n@@ -193,8 +191,7 @@ ggc_alloc (size)\n /* Mark a node.  */\n \n int\n-ggc_set_mark (p)\n-     const void *p;\n+ggc_set_mark (const void *p)\n {\n   struct ggc_mem *x;\n \n@@ -217,8 +214,7 @@ ggc_set_mark (p)\n /* Return 1 if P has been marked, zero otherwise.  */\n \n int\n-ggc_marked_p (p)\n-     const void *p;\n+ggc_marked_p (const void *p)\n {\n   struct ggc_mem *x;\n \n@@ -234,8 +230,7 @@ ggc_marked_p (p)\n /* Return the size of the gc-able object P.  */\n \n size_t\n-ggc_get_size (p)\n-     const void *p;\n+ggc_get_size (const void *p)\n {\n   struct ggc_mem *x\n     = (struct ggc_mem *) ((const char *)p - offsetof (struct ggc_mem, u));\n@@ -245,8 +240,7 @@ ggc_get_size (p)\n /* Unmark all objects.  */\n \n static void\n-clear_marks (x)\n-     struct ggc_mem *x;\n+clear_marks (struct ggc_mem *x)\n {\n   x->mark = 0;\n   if (x->sub[0])\n@@ -258,8 +252,7 @@ clear_marks (x)\n /* Free all objects in the current context that are not marked.  */\n \n static void\n-sweep_objs (root)\n-     struct ggc_mem **root;\n+sweep_objs (struct ggc_mem **root)\n {\n   struct ggc_mem *x = *root;\n   if (!x)\n@@ -308,7 +301,7 @@ sweep_objs (root)\n /* The top level mark-and-sweep routine.  */\n \n void\n-ggc_collect ()\n+ggc_collect (void)\n {\n   /* Avoid frequent unnecessary work by skipping collection if the\n      total allocations haven't expanded much since the last\n@@ -351,15 +344,15 @@ ggc_collect ()\n /* Called once to initialize the garbage collector.  */\n \n void\n-init_ggc ()\n+init_ggc (void)\n {\n }\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n \n void\n-ggc_push_context ()\n+ggc_push_context (void)\n {\n   G.context++;\n \n@@ -373,17 +366,15 @@ ggc_push_context ()\n    will be merged with the old context.  */\n \n void\n-ggc_pop_context ()\n+ggc_pop_context (void)\n {\n   G.context--;\n   if (G.root)\n     ggc_pop_context_1 (G.root, G.context);\n }\n \n static void\n-ggc_pop_context_1 (x, c)\n-     struct ggc_mem *x;\n-     int c;\n+ggc_pop_context_1 (struct ggc_mem *x, int c)\n {\n   if (x->context > c)\n     x->context = c;\n@@ -396,9 +387,7 @@ ggc_pop_context_1 (x, c)\n /* Dump a tree.  */\n \n void\n-debug_ggc_tree (p, indent)\n-     struct ggc_mem *p;\n-     int indent;\n+debug_ggc_tree (struct ggc_mem *p, int indent)\n {\n   int i;\n \n@@ -413,7 +402,7 @@ debug_ggc_tree (p, indent)\n \n   for (i = 0; i < indent; ++i)\n     putc (' ', stderr);\n-  fprintf (stderr, \"%lx %p\\n\", (unsigned long)PTR_KEY (p), (PTR) p);\n+  fprintf (stderr, \"%lx %p\\n\", (unsigned long)PTR_KEY (p), (void *) p);\n \n   if (p->sub[1])\n     debug_ggc_tree (p->sub[1], indent + 1);\n@@ -425,7 +414,7 @@ debug_ggc_tree (p, indent)\n #include <math.h>\n \n void\n-debug_ggc_balance ()\n+debug_ggc_balance (void)\n {\n   size_t nleaf, sumdepth;\n \n@@ -443,11 +432,7 @@ debug_ggc_balance ()\n \n /* Used by debug_ggc_balance, and also by ggc_print_statistics.  */\n static void\n-tally_leaves (x, depth, nleaf, sumdepth)\n-     struct ggc_mem *x;\n-     int depth;\n-     size_t *nleaf;\n-     size_t *sumdepth;\n+tally_leaves (struct ggc_mem *x, int depth, size_t *nleaf, size_t *sumdepth)\n {\n   if (! x->sub[0] && !x->sub[1])\n     {\n@@ -472,7 +457,7 @@ tally_leaves (x, depth, nleaf, sumdepth)\n \n /* Report on GC memory usage.  */\n void\n-ggc_print_statistics ()\n+ggc_print_statistics (void)\n {\n   struct ggc_statistics stats;\n   size_t nleaf = 0, sumdepth = 0;\n@@ -506,73 +491,63 @@ Total memory in GC arena\\t%ld%c\\n\",\n }\n \f\n struct ggc_pch_data *\n-init_ggc_pch ()\n+init_ggc_pch (void)\n {\n   sorry (\"Generating PCH files is not supported when using ggc-simple.c\");\n   /* It could be supported, but the code is not yet written.  */\n   return NULL;\n }\n \n-void \n-ggc_pch_count_object (d, x, size)\n-     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n-     void *x ATTRIBUTE_UNUSED;\n-     size_t size ATTRIBUTE_UNUSED;\n+void\n+ggc_pch_count_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t      void *x ATTRIBUTE_UNUSED,\n+\t\t      size_t size ATTRIBUTE_UNUSED)\n {\n }\n-     \n+\n size_t\n-ggc_pch_total_size (d)\n-     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n+ggc_pch_total_size (struct ggc_pch_data *d ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n \n void\n-ggc_pch_this_base (d, base)\n-     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n-     void *base ATTRIBUTE_UNUSED;\n+ggc_pch_this_base (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t   void *base ATTRIBUTE_UNUSED)\n {\n }\n \n \n char *\n-ggc_pch_alloc_object (d, x, size)\n-     struct ggc_pch_data *d ATTRIBUTE_UNUSED;\n-     void *x ATTRIBUTE_UNUSED;\n-     size_t size ATTRIBUTE_UNUSED;\n+ggc_pch_alloc_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t      void *x ATTRIBUTE_UNUSED,\n+\t\t      size_t size ATTRIBUTE_UNUSED)\n {\n   return NULL;\n }\n \n-void \n-ggc_pch_prepare_write (d, f)\n-     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n-     FILE * f ATTRIBUTE_UNUSED;\n+void\n+ggc_pch_prepare_write (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t       FILE * f ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-ggc_pch_write_object (d, f, x, newx, size)\n-     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n-     FILE *f ATTRIBUTE_UNUSED;\n-     void *x ATTRIBUTE_UNUSED;\n-     void *newx ATTRIBUTE_UNUSED;\n-     size_t size ATTRIBUTE_UNUSED;\n+ggc_pch_write_object (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\t      FILE *f ATTRIBUTE_UNUSED, void *x ATTRIBUTE_UNUSED,\n+\t\t      void *newx ATTRIBUTE_UNUSED,\n+\t\t      size_t size ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-ggc_pch_finish (d, f)\n-     struct ggc_pch_data * d ATTRIBUTE_UNUSED;\n-     FILE *f ATTRIBUTE_UNUSED;\n+ggc_pch_finish (struct ggc_pch_data *d ATTRIBUTE_UNUSED,\n+\t\tFILE *f ATTRIBUTE_UNUSED)\n {\n }\n \n void\n-ggc_pch_read (f, addr)\n-     FILE *f ATTRIBUTE_UNUSED;\n-     void *addr ATTRIBUTE_UNUSED;\n+ggc_pch_read (FILE *f ATTRIBUTE_UNUSED, void *addr ATTRIBUTE_UNUSED)\n {\n   /* This should be impossible, since we won't generate any valid PCH\n      files for this configuration.  */"}, {"sha": "2f7d09c3d6f74c8bf7a07670afa06964da261597", "filename": "gcc/ggc.h", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=20c1dc5e9b8a82f41a041dab3d7d19604a25f2a4", "patch": "@@ -1,5 +1,6 @@\n /* Garbage collection for the GNU compiler.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -30,35 +31,33 @@ extern const char digit_vector[];\t/* \"0\" .. \"9\" */\n    machinery.  */\n \n /* The first parameter is a pointer to a pointer, the second a cookie.  */\n-typedef void (*gt_pointer_operator) PARAMS ((void *, void *));\n+typedef void (*gt_pointer_operator) (void *, void *);\n \n #include \"gtype-desc.h\"\n \n /* One of these applies its third parameter (with cookie in the fourth\n    parameter) to each pointer in the object pointed to by the first\n    parameter, using the second parameter.  */\n-typedef void (*gt_note_pointers) \n-     PARAMS ((void *, void *, gt_pointer_operator, void *));\n+typedef void (*gt_note_pointers) (void *, void *, gt_pointer_operator,\n+\t\t\t\t  void *);\n \n /* One of these is called before objects are re-ordered in memory.\n    The first parameter is the original object, the second is the\n    subobject that has had its pointers reordered, the third parameter\n    can compute the new values of a pointer when given the cookie in\n    the fourth parameter.  */\n-typedef void (*gt_handle_reorder)\n-     PARAMS ((void *, void *, gt_pointer_operator, void *));\n+typedef void (*gt_handle_reorder) (void *, void *, gt_pointer_operator,\n+\t\t\t\t   void *);\n \n /* Used by the gt_pch_n_* routines.  Register an object in the hash table.  */\n-extern int gt_pch_note_object \n-     PARAMS ((void *, void *, gt_note_pointers));\n+extern int gt_pch_note_object (void *, void *, gt_note_pointers);\n \n-/* Used by the gt_pch_n_* routines.  Register that an object has a reorder \n+/* Used by the gt_pch_n_* routines.  Register that an object has a reorder\n    function.  */\n-extern void gt_pch_note_reorder\n-     PARAMS ((void *, void *, gt_handle_reorder));\n+extern void gt_pch_note_reorder (void *, void *, gt_handle_reorder);\n \n /* Mark the object in the first parameter and anything it points to.  */\n-typedef void (*gt_pointer_walker) PARAMS ((void *));\n+typedef void (*gt_pointer_walker) (void *);\n \n /* Structures for the easy way to mark roots.\n    In an array, terminated by having base == NULL.*/\n@@ -84,7 +83,7 @@ struct ggc_cache_tab {\n   size_t stride;\n   gt_pointer_walker cb;\n   gt_pointer_walker pchw;\n-  int (*marked_p) PARAMS ((const void *));\n+  int (*marked_p) (const void *);\n };\n #define LAST_GGC_CACHE_TAB { NULL, 0, 0, NULL, NULL, NULL }\n /* Pointers to arrays of ggc_cache_tab, terminated by NULL.  */\n@@ -107,102 +106,95 @@ extern const struct ggc_cache_tab * const gt_ggc_cache_rtab[];\n    returns zero if the object was not previously marked; non-zero if\n    the object was already marked, or if, for any other reason,\n    pointers in this data structure should not be traversed.  */\n-extern int ggc_set_mark\t\t\tPARAMS ((const void *));\n+extern int ggc_set_mark\t(const void *);\n \n /* Return 1 if P has been marked, zero otherwise.\n    P must have been allocated by the GC allocator; it mustn't point to\n    static objects, stack variables, or memory allocated with malloc.  */\n-extern int ggc_marked_p\t\t\tPARAMS ((const void *));\n+extern int ggc_marked_p\t(const void *);\n \n /* Mark the entries in the string pool.  */\n-extern void ggc_mark_stringpool\t\tPARAMS ((void));\n+extern void ggc_mark_stringpool\t(void);\n \n /* Call ggc_set_mark on all the roots.  */\n \n-extern void ggc_mark_roots\t\tPARAMS ((void));\n+extern void ggc_mark_roots (void);\n \n /* Save and restore the string pool entries for PCH.  */\n \n-extern void gt_pch_save_stringpool\tPARAMS ((void));\n-extern void gt_pch_fixup_stringpool     PARAMS ((void));\n-extern void gt_pch_restore_stringpool\tPARAMS ((void));\n+extern void gt_pch_save_stringpool (void);\n+extern void gt_pch_fixup_stringpool (void);\n+extern void gt_pch_restore_stringpool (void);\n \n /* PCH and GGC handling for strings, mostly trivial.  */\n \n-extern void gt_pch_p_S\t\t\tPARAMS ((void *, void *,\n-\t\t\t\t\t\t gt_pointer_operator, void *));\n-extern void gt_pch_n_S\t\t\tPARAMS ((const void *));\n-extern void gt_ggc_m_S\t\t\tPARAMS ((void *));\n+extern void gt_pch_p_S (void *, void *, gt_pointer_operator, void *);\n+extern void gt_pch_n_S (const void *);\n+extern void gt_ggc_m_S (void *);\n \n /* Initialise the string pool.  */\n-extern void init_stringpool\tPARAMS ((void));\n+extern void init_stringpool (void);\n \n /* A GC implementation must provide these functions.  They are internal\n    to the GC system.  */\n \n /* Initialize the garbage collector.  */\n-extern void init_ggc\t\tPARAMS ((void));\n+extern void init_ggc (void);\n \n /* Start a new GGC context.  Memory allocated in previous contexts\n    will not be collected while the new context is active.  */\n-extern void ggc_push_context\tPARAMS ((void));\n+extern void ggc_push_context (void);\n \n /* Finish a GC context.  Any uncollected memory in the new context\n    will be merged with the old context.  */\n-extern void ggc_pop_context \tPARAMS ((void));\n+extern void ggc_pop_context (void);\n \n struct ggc_pch_data;\n \n /* Return a new ggc_pch_data structure.  */\n-extern struct ggc_pch_data *init_ggc_pch PARAMS ((void));\n+extern struct ggc_pch_data *init_ggc_pch (void);\n \n /* The second parameter and third parameters give the address and size\n    of an object.  Update the ggc_pch_data structure with as much of\n    that information as is necessary.  */\n-extern void ggc_pch_count_object\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t void *, size_t));\n+extern void ggc_pch_count_object (struct ggc_pch_data *, void *, size_t);\n \n-/* Return the total size of the data to be written to hold all \n+/* Return the total size of the data to be written to hold all\n    the objects previously passed to ggc_pch_count_object.  */\n-extern size_t ggc_pch_total_size\tPARAMS ((struct ggc_pch_data *));\n+extern size_t ggc_pch_total_size (struct ggc_pch_data *);\n \n /* The objects, when read, will most likely be at the address\n    in the second parameter.  */\n-extern void ggc_pch_this_base\t\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t void *));\n+extern void ggc_pch_this_base (struct ggc_pch_data *, void *);\n \n /* Assuming that the objects really do end up at the address\n    passed to ggc_pch_this_base, return the address of this object.  */\n-extern char *ggc_pch_alloc_object\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t void *, size_t));\n+extern char *ggc_pch_alloc_object (struct ggc_pch_data *, void *, size_t);\n \n /* Write out any initial information required.  */\n-extern void ggc_pch_prepare_write\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t FILE *));\n+extern void ggc_pch_prepare_write (struct ggc_pch_data *, FILE *);\n /* Write out this object, including any padding.  */\n-extern void ggc_pch_write_object\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t FILE *, void *, void *,\n-\t\t\t\t\t\t size_t));\n+extern void ggc_pch_write_object (struct ggc_pch_data *, FILE *, void *,\n+\t\t\t\t  void *, size_t);\n /* All objects have been written, write out any final information\n    required.  */\n-extern void ggc_pch_finish\t\tPARAMS ((struct ggc_pch_data *,\n-\t\t\t\t\t\t FILE *));\n+extern void ggc_pch_finish (struct ggc_pch_data *, FILE *);\n \n /* A PCH file has just been read in at the address specified second\n    parameter.  Set up the GC implementation for the new objects.  */\n-extern void ggc_pch_read PARAMS ((FILE *, void *));\n+extern void ggc_pch_read (FILE *, void *);\n \n \f\n /* Allocation.  */\n \n /* The internal primitive.  */\n-extern void *ggc_alloc\t\tPARAMS ((size_t));\n+extern void *ggc_alloc (size_t);\n /* Like ggc_alloc, but allocates cleared memory.  */\n-extern void *ggc_alloc_cleared\tPARAMS ((size_t));\n+extern void *ggc_alloc_cleared (size_t);\n /* Resize a block.  */\n-extern void *ggc_realloc\tPARAMS ((void *, size_t));\n+extern void *ggc_realloc (void *, size_t);\n /* Like ggc_alloc_cleared, but performs a multiplication.  */\n-extern void *ggc_calloc\t\tPARAMS ((size_t, size_t));\n+extern void *ggc_calloc (size_t, size_t);\n \n #define ggc_alloc_rtx(NSLOTS)\t\t\t\t\t\t  \\\n   ((struct rtx_def *) ggc_alloc (sizeof (struct rtx_def)\t\t  \\\n@@ -221,8 +213,8 @@ extern void *ggc_calloc\t\tPARAMS ((size_t, size_t));\n   splay_tree_new_with_allocator (COMPARE, NULL, NULL,\t\t\t \\\n                                  &ggc_splay_alloc, &ggc_splay_dont_free, \\\n \t\t\t\t NULL)\n-extern PTR ggc_splay_alloc PARAMS ((int, void *));\n-extern void ggc_splay_dont_free PARAMS ((void *, void *));\n+extern void *ggc_splay_alloc (int, void *);\n+extern void ggc_splay_dont_free (void *, void *);\n \n /* Allocate a gc-able string, and fill it with LENGTH bytes from CONTENTS.\n    If LENGTH is -1, then CONTENTS is assumed to be a\n@@ -235,16 +227,16 @@ extern const char *ggc_alloc_string\tPARAMS ((const char *contents,\n \n /* Invoke the collector.  Garbage collection occurs only when this\n    function is called, not during allocations.  */\n-extern void ggc_collect\t\t\tPARAMS ((void));\n+extern void ggc_collect\t(void);\n \n /* Return the number of bytes allocated at the indicated address.  */\n-extern size_t ggc_get_size\t\tPARAMS ((const void *));\n+extern size_t ggc_get_size (const void *);\n \n /* Write out all GCed objects to F.  */\n-extern void gt_pch_save\t\t\tPARAMS ((FILE *f));\n+extern void gt_pch_save (FILE *f);\n \n /* Read objects previously saved with gt_pch_save from F.  */\n-extern void gt_pch_restore\t\tPARAMS ((FILE *f));\n+extern void gt_pch_restore (FILE *f);\n \f\n /* Statistics.  */\n \n@@ -258,13 +250,13 @@ typedef struct ggc_statistics\n \n /* Used by the various collectors to gather and print statistics that\n    do not depend on the collector in use.  */\n-extern void ggc_print_common_statistics PARAMS ((FILE *, ggc_statistics *));\n+extern void ggc_print_common_statistics (FILE *, ggc_statistics *);\n \n /* Print allocation statistics.  */\n-extern void ggc_print_statistics\tPARAMS ((void));\n-extern void stringpool_statistics\tPARAMS ((void));\n+extern void ggc_print_statistics (void);\n+extern void stringpool_statistics (void);\n \n /* Heuristics.  */\n-extern int ggc_min_expand_heuristic PARAMS ((void));\n-extern int ggc_min_heapsize_heuristic PARAMS ((void));\n-extern void init_ggc_heuristics PARAMS ((void));\n+extern int ggc_min_expand_heuristic (void);\n+extern int ggc_min_heapsize_heuristic (void);\n+extern void init_ggc_heuristics (void);"}]}