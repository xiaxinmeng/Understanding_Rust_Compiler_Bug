{"sha": "be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5YzNjNmU5MzFkNzdlMDZkNWVjNjM2NmQ3Mzc5ZjI3ZGQzNWRkMw==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-11-24T00:25:01Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2007-11-24T00:25:01Z"}, "message": "re PR libfortran/34209 (run-time lib: NEAREST(0.0_8, -1.0) produces wrong numbers)\n\n2007-11-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR fortran/34209\n\t* iresolve.c (gfc_resolve_nearest): If sign variable kind does not match\n\tkind of input variable, convert it to match.\n\n\tPR fortran/33317\n\t* trans.h: Modify prototype for gfc_conv_missing_dummy.\n\t* trans-expr.c (gfc_conv_missing_dummy): Modify to pass an integer kind\n\tparameter in.  Set the type of the dummy to the kind given.\n\t(gfc_conv_function_call): Pass representation.length to\n\tgfc_conv_missing_dummy.\n\t* iresolve.c (gfc_resolve_cshift): Determine the correct kind to use and\n\tif appropriate set representation.length to this kind value.\n\t(gfc_resolve_eoshift): Likewise.\n\t* check.c (gfc_check_cshift): Enable dim_check to allow DIM as an\n\toptional argument. (gfc_check_eoshift): Likewise.\n\t* trans_intrinsic.c (gfc_conv_intrinsic_function_args): Update call to\n\tgfc_conv_missing_dummy.\n\nFrom-SVN: r130391", "tree": {"sha": "ddbdb823d91156c4576ecc437fb5a3fac2a14cde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ddbdb823d91156c4576ecc437fb5a3fac2a14cde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/comments", "author": null, "committer": null, "parents": [{"sha": "a98a436fdf4451837a3c564048ddfaef5a53b1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a98a436fdf4451837a3c564048ddfaef5a53b1e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a98a436fdf4451837a3c564048ddfaef5a53b1e6"}], "stats": {"total": 117, "additions": 86, "deletions": 31}, "files": [{"sha": "ce45d6041be71bfd3d12f84011f823783cbbff7c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -1,3 +1,23 @@\n+2007-11-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR fortran/34209\n+\t* iresolve.c (gfc_resolve_nearest): If sign variable kind does not match\n+\tkind of input variable, convert it to match.\n+\n+\tPR fortran/33317\n+\t* trans.h: Modify prototype for gfc_conv_missing_dummy.\n+\t* trans-expr.c (gfc_conv_missing_dummy): Modify to pass an integer kind\n+\tparameter in.  Set the type of the dummy to the kind given.\n+\t(gfc_conv_function_call): Pass representation.length to\n+\tgfc_conv_missing_dummy.\n+\t* iresolve.c (gfc_resolve_cshift): Determine the correct kind to use and\n+\tif appropriate set representation.length to this kind value.\n+\t(gfc_resolve_eoshift): Likewise.\n+\t* check.c (gfc_check_cshift): Enable dim_check to allow DIM as an\n+\toptional argument. (gfc_check_eoshift): Likewise.\n+\t* trans_intrinsic.c (gfc_conv_intrinsic_function_args): Update call to\n+\tgfc_conv_missing_dummy.\n+\n 2007-11-23  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/34187"}, {"sha": "511dce63c12e54e1e1dac7ba3c1cddd58d7d6c72", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -863,8 +863,7 @@ gfc_check_cshift (gfc_expr *array, gfc_expr *shift, gfc_expr *dim)\n       /* TODO: more requirements on shift parameter.  */\n     }\n \n-  /* FIXME (PR33317): Allow optional DIM=.  */\n-  if (dim_check (dim, 2, false) == FAILURE)\n+  if (dim_check (dim, 2, true) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;\n@@ -1033,8 +1032,7 @@ gfc_check_eoshift (gfc_expr *array, gfc_expr *shift, gfc_expr *boundary,\n       /* TODO: more restrictions on boundary.  */\n     }\n \n-  /* FIXME (PR33317): Allow optional DIM=.  */\n-  if (dim_check (dim, 4, false) == FAILURE)\n+  if (dim_check (dim, 4, true) == FAILURE)\n     return FAILURE;\n \n   return SUCCESS;"}, {"sha": "b8470441885c732d6b121312bf3c6b0164a9b00a", "filename": "gcc/fortran/iresolve.c", "status": "modified", "additions": 50, "deletions": 21, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -559,7 +559,7 @@ void\n gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n \t\t    gfc_expr *dim)\n {\n-  int n;\n+  int n, m;\n \n   if (array->ts.type == BT_CHARACTER && array->ref)\n     gfc_resolve_substring_charlen (array);\n@@ -573,22 +573,35 @@ gfc_resolve_cshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n   else\n     n = 0;\n \n-  /* Convert shift to at least gfc_default_integer_kind, so we don't need\n-     kind=1 and kind=2 versions of the library functions.  */\n-  if (shift->ts.kind < gfc_default_integer_kind)\n+  /* If dim kind is greater than default integer we need to use the larger.  */\n+  m = gfc_default_integer_kind;\n+  if (dim != NULL)\n+    m = m < dim->ts.kind ? dim->ts.kind : m;\n+  \n+  /* Convert shift to at least m, so we don't need\n+      kind=1 and kind=2 versions of the library functions.  */\n+  if (shift->ts.kind < m)\n     {\n       gfc_typespec ts;\n       ts.type = BT_INTEGER;\n-      ts.kind = gfc_default_integer_kind;\n+      ts.kind = m;\n       gfc_convert_type_warn (shift, &ts, 2, 0);\n     }\n-\n+ \n   if (dim != NULL)\n     {\n-      gfc_resolve_dim_arg (dim);\n-      /* Convert dim to shift's kind, so we don't need so many variations.  */\n-      if (dim->ts.kind != shift->ts.kind)\n-\tgfc_convert_type_warn (dim, &shift->ts, 2, 0);\n+      if (dim->expr_type != EXPR_CONSTANT)\n+\t{\n+\t  /* Mark this for later setting the type in gfc_conv_missing_dummy.  */\n+\t  dim->representation.length = shift->ts.kind;\n+\t}\n+      else\n+\t{\n+\t  gfc_resolve_dim_arg (dim);\n+\t  /* Convert dim to shift's kind to reduce variations.  */\n+\t  if (dim->ts.kind != shift->ts.kind)\n+\t    gfc_convert_type_warn (dim, &shift->ts, 2, 0);\n+        }\n     }\n \n   f->value.function.name\n@@ -683,7 +696,7 @@ void\n gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n \t\t     gfc_expr *boundary, gfc_expr *dim)\n {\n-  int n;\n+  int n, m;\n \n   if (array->ts.type == BT_CHARACTER && array->ref)\n     gfc_resolve_substring_charlen (array);\n@@ -698,22 +711,35 @@ gfc_resolve_eoshift (gfc_expr *f, gfc_expr *array, gfc_expr *shift,\n   if (boundary && boundary->rank > 0)\n     n = n | 2;\n \n-  /* Convert shift to at least gfc_default_integer_kind, so we don't need\n-     kind=1 and kind=2 versions of the library functions.  */\n-  if (shift->ts.kind < gfc_default_integer_kind)\n+  /* If dim kind is greater than default integer we need to use the larger.  */\n+  m = gfc_default_integer_kind;\n+  if (dim != NULL)\n+    m = m < dim->ts.kind ? dim->ts.kind : m;\n+  \n+  /* Convert shift to at least m, so we don't need\n+      kind=1 and kind=2 versions of the library functions.  */\n+  if (shift->ts.kind < m)\n     {\n       gfc_typespec ts;\n       ts.type = BT_INTEGER;\n-      ts.kind = gfc_default_integer_kind;\n+      ts.kind = m;\n       gfc_convert_type_warn (shift, &ts, 2, 0);\n     }\n-\n+ \n   if (dim != NULL)\n     {\n-      gfc_resolve_dim_arg (dim);\n-      /* Convert dim to shift's kind, so we don't need so many variations.  */\n-      if (dim->ts.kind != shift->ts.kind)\n-\tgfc_convert_type_warn (dim, &shift->ts, 2, 0);\n+      if (dim->expr_type != EXPR_CONSTANT)\n+\t{\n+\t  /* Mark this for later setting the type in gfc_conv_missing_dummy.  */\n+\t  dim->representation.length = shift->ts.kind;\n+\t}\n+      else\n+\t{\n+\t  gfc_resolve_dim_arg (dim);\n+\t  /* Convert dim to shift's kind to reduce variations.  */\n+\t  if (dim->ts.kind != shift->ts.kind)\n+\t    gfc_convert_type_warn (dim, &shift->ts, 2, 0);\n+        }\n     }\n \n   f->value.function.name\n@@ -1580,8 +1606,11 @@ gfc_resolve_modulo (gfc_expr *f, gfc_expr *a, gfc_expr *p)\n }\n \n void\n-gfc_resolve_nearest (gfc_expr *f, gfc_expr *a, gfc_expr *p ATTRIBUTE_UNUSED)\n+gfc_resolve_nearest (gfc_expr *f, gfc_expr *a, gfc_expr *p)\n {\n+  if (p->ts.kind != a->ts.kind)\n+    gfc_convert_type (p, &a->ts, 2);\n+\n   f->ts = a->ts;\n   f->value.function.name\n     = gfc_get_string (\"__nearest_%c%d\", gfc_type_letter (a->ts.type),"}, {"sha": "231fef5bf7bdd58ebd632e95b74909107f2fa4b7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -146,17 +146,24 @@ gfc_conv_expr_present (gfc_symbol * sym)\n /* Converts a missing, dummy argument into a null or zero.  */\n \n void\n-gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts)\n+gfc_conv_missing_dummy (gfc_se * se, gfc_expr * arg, gfc_typespec ts, int kind)\n {\n   tree present;\n   tree tmp;\n \n   present = gfc_conv_expr_present (arg->symtree->n.sym);\n \n   tmp = build3 (COND_EXPR, TREE_TYPE (se->expr), present, se->expr,\n-\t\tfold_convert (TREE_TYPE (se->expr), integer_zero_node));\n-\n+\t\t  fold_convert (TREE_TYPE (se->expr), integer_zero_node));\n   tmp = gfc_evaluate_now (tmp, &se->pre);\n+\n+  if (kind > 0)\n+    {\n+      tmp = gfc_get_int_type (kind);\n+      tmp = fold_convert (tmp, se->expr);\n+      tmp = gfc_evaluate_now (tmp, &se->pre); \n+    }\n+\n   se->expr = tmp;\n \n   if (ts.type == BT_CHARACTER)\n@@ -2324,7 +2331,8 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t     check its presence and substitute a null if absent.  */\n \t  if (e->expr_type == EXPR_VARIABLE\n \t      && e->symtree->n.sym->attr.optional)\n-\t    gfc_conv_missing_dummy (&parmse, e, fsym ? fsym->ts : e->ts);\n+\t    gfc_conv_missing_dummy (&parmse, e, fsym ? fsym->ts : e->ts,\n+\t\t\t\t    e->representation.length);\n \t}\n \n       if (fsym && e)"}, {"sha": "63c56040eb2d2b6a44dd72a579ed34eb249f6c08", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -214,7 +214,7 @@ gfc_conv_intrinsic_function_args (gfc_se *se, gfc_expr *expr,\n \t    && e->symtree->n.sym->attr.optional\n \t    && formal\n \t    && formal->optional)\n-\tgfc_conv_missing_dummy (&argse, e, formal->ts);\n+\tgfc_conv_missing_dummy (&argse, e, formal->ts, 0);\n \n       gfc_add_block_to_block (&se->pre, &argse.pre);\n       gfc_add_block_to_block (&se->post, &argse.post);"}, {"sha": "658dcd0e87db8e81f12df9057c41450b52d46790", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be9c3c6e931d77e06d5ec6366d7379f27dd35dd3/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=be9c3c6e931d77e06d5ec6366d7379f27dd35dd3", "patch": "@@ -332,7 +332,7 @@ void gfc_conv_structure (gfc_se *, gfc_expr *, int);\n /* Return an expression which determines if a dummy parameter is present.  */\n tree gfc_conv_expr_present (gfc_symbol *);\n /* Convert a missing, dummy argument into a null or zero.  */\n-void gfc_conv_missing_dummy (gfc_se *, gfc_expr *, gfc_typespec);\n+void gfc_conv_missing_dummy (gfc_se *, gfc_expr *, gfc_typespec, int);\n \n /* Generate code to allocate a string temporary.  */\n tree gfc_conv_string_tmp (gfc_se *, tree, tree);"}]}