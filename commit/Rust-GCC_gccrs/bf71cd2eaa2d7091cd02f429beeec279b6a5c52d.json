{"sha": "bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY3MWNkMmVhYTJkNzA5MWNkMDJmNDI5YmVlZWMyNzliNmE1YzUyZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@cygnus.com", "date": "1998-09-15T11:20:52Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "1998-09-15T11:20:52Z"}, "message": "[multiple changes]\n\nTue Sep 15 14:10:54 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n        * except.h (struct eh_entry): Add false_label field.\n        (end_catch_handler): Add prototype.\n        * except.c (push_eh_entry): Set false_label field to NULL_RTX.\n        (start_catch_handler): When using old style exceptions, issue\n        runtime typematch code before continuing with the handler.\n        (end_catch_handler): New function, generates label after handler\n        if needed by older style exceptions.\n        (expand_start_all_catch): No need to check for new style exceptions.\n        (output_exception_table_entry): Only output the first handler label\n        for old style exceptions.\n        * libgcc2.c (__eh_rtime_match): New routine to lump runtime matching\n        mechanism into one function, if a runtime matcher is provided.\n1998-09-15  Andrew MacLeod  <amacleod@cygnus.com>\n        * cp/except.c (expand_start_catch_block): No need to check for new\n        exception model.\n        (process_start_catch_block_old): Deleted.\n        (process_start_catch_block): Add call to start_decl_1().\n        (expand_end_catch_block): Add call to end_catch_handler().\n        * cp/exception.cc (__cplus_type_matcher): Only check the exception\n        language if there is an exception table.\n\nFrom-SVN: r22425", "tree": {"sha": "6b24980704695c7ec0f059391cfe4c686deb5c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b24980704695c7ec0f059391cfe4c686deb5c76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/comments", "author": null, "committer": null, "parents": [{"sha": "8a21007c9409ad2be041c05c304295ff449538b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a21007c9409ad2be041c05c304295ff449538b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a21007c9409ad2be041c05c304295ff449538b7"}], "stats": {"total": 239, "additions": 108, "deletions": 131}, "files": [{"sha": "44e65f40e87354c43a581a9cf67f53a942102f2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -1,3 +1,18 @@\n+Tue Sep 15 14:10:54 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* except.h (struct eh_entry): Add false_label field.\n+\t(end_catch_handler): Add prototype.\n+\t* except.c (push_eh_entry): Set false_label field to NULL_RTX.\n+\t(start_catch_handler): When using old style exceptions, issue\n+\truntime typematch code before continuing with the handler.\n+\t(end_catch_handler): New function, generates label after handler\n+\tif needed by older style exceptions.\n+\t(expand_start_all_catch): No need to check for new style exceptions.\n+\t(output_exception_table_entry): Only output the first handler label\n+\tfor old style exceptions.\n+\t* libgcc2.c (__eh_rtime_match): New routine to lump runtime matching\n+\tmechanism into one function, if a runtime matcher is provided.\n+\n Tue Sep 15 13:53:59 EDT 1998  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* config/i960/i960.h (SLOW_BYTE_ACCESS): Change definition to 1."}, {"sha": "9ed5652f39f885e2ea63363c7a7d93b95715151a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -1,3 +1,13 @@\n+1998-09-15  Andrew MacLeod  <amacleod@cygnus.com>\n+\n+\t* except.c (expand_start_catch_block): No need to check for new\n+\texception model.\n+\t(process_start_catch_block_old): Deleted.\n+\t(process_start_catch_block): Add call to start_decl_1().\n+\t(expand_end_catch_block): Add call to end_catch_handler().\n+\t* exception.cc (__cplus_type_matcher): Only check the exception \n+\tlanguage if there is an exception table.\n+\n 1998-09-15  Andrew MacLeod  <amacleod@cygnus.com>\n \n \t* search.c (expand_indirect_vtbls_init): Mark temporary stack slots"}, {"sha": "c3ae3575d6598c6e749ea9b4e98af793cdc33b14", "filename": "gcc/cp/except.c", "status": "modified", "additions": 4, "deletions": 127, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -597,135 +597,14 @@ expand_start_catch_block (declspecs, declarator)\n   if (! doing_eh (1))\n     return;\n \n-  if (flag_new_exceptions)\n-    process_start_catch_block (declspecs, declarator);\n-  else\n-    process_start_catch_block_old (declspecs, declarator);\n+  process_start_catch_block (declspecs, declarator);\n }\n \n \n-/* This function performs the expand_start_catch_block functionality for \n-   exceptions implemented in the old style, where catch blocks were all\n-   called, and had to check the runtime information themselves. */\n-\n-static void \n-process_start_catch_block_old (declspecs, declarator)\n-     tree declspecs, declarator;\n-{\n-  rtx false_label_rtx;\n-  tree decl = NULL_TREE;\n-  tree init;\n-\n-  /* Create a binding level for the eh_info and the exception object\n-     cleanup.  */\n-  pushlevel (0);\n-  expand_start_bindings (0);\n-\n-  false_label_rtx = gen_label_rtx ();\n-  push_label_entry (&false_label_stack, false_label_rtx, NULL_TREE);\n-\n-  emit_line_note (input_filename, lineno);\n-\n-  push_eh_info ();\n-\n-  if (declspecs)\n-    {\n-      decl = grokdeclarator (declarator, declspecs, CATCHPARM, 1, NULL_TREE);\n-\n-      if (decl == NULL_TREE)\n-\terror (\"invalid catch parameter\");\n-    }\n-\n-  if (decl)\n-    {\n-      tree exp;\n-      rtx call_rtx, return_value_rtx;\n-      tree init_type;\n-\n-      /* Make sure we mark the catch param as used, otherwise we'll get\n-\t a warning about an unused ((anonymous)).  */\n-      TREE_USED (decl) = 1;\n-\n-      /* Figure out the type that the initializer is.  */\n-      init_type = TREE_TYPE (decl);\n-      if (TREE_CODE (init_type) != REFERENCE_TYPE\n-\t  && TREE_CODE (init_type) != POINTER_TYPE)\n-\tinit_type = build_reference_type (init_type);\n-\n-      exp = get_eh_value ();\n-\n-      /* Since pointers are passed by value, initialize a reference to\n-\t pointer catch parm with the address of the value slot.  */\n-      if (TREE_CODE (init_type) == REFERENCE_TYPE\n-\t  && TREE_CODE (TREE_TYPE (init_type)) == POINTER_TYPE)\n-\texp = build_unary_op (ADDR_EXPR, exp, 1);\n-\n-      exp = expr_tree_cons (NULL_TREE,\n-\t\t       build_eh_type_type (TREE_TYPE (decl)),\n-\t\t       expr_tree_cons (NULL_TREE,\n-\t\t\t\t  get_eh_type (),\n-\t\t\t\t  expr_tree_cons (NULL_TREE, exp, NULL_TREE)));\n-      exp = build_function_call (CatchMatch, exp);\n-      call_rtx = expand_call (exp, NULL_RTX, 0);\n-\n-      return_value_rtx = hard_function_value (ptr_type_node, exp);\n-\n-      /* did the throw type match function return TRUE? */\n-      emit_cmp_insn (return_value_rtx, const0_rtx, EQ, NULL_RTX,\n-\t\t    GET_MODE (return_value_rtx), 0, 0);\n-\n-      /* if it returned FALSE, jump over the catch block, else fall into it */\n-      emit_jump_insn (gen_beq (false_label_rtx));\n-\n-      push_eh_cleanup ();\n-\n-      /* Create a binding level for the parm.  */\n-      pushlevel (0);\n-      expand_start_bindings (0);\n-\n-      init = convert_from_reference (make_tree (init_type, call_rtx));\n-\n-      /* If the constructor for the catch parm exits via an exception, we\n-         must call terminate.  See eh23.C.  */\n-      if (TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (decl)))\n-\t{\n-\t  /* Generate the copy constructor call directly so we can wrap it.\n-\t     See also expand_default_init.  */\n-\t  init = ocp_convert (TREE_TYPE (decl), init,\n-\t\t\t      CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n-\t  init = build (TRY_CATCH_EXPR, TREE_TYPE (init), init,\n-\t\t\tbuild_terminate_handler ());\n-\t}\n-\n-      /* Let `cp_finish_decl' know that this initializer is ok.  */\n-      DECL_INITIAL (decl) = init;\n-      decl = pushdecl (decl);\n-\n-      start_decl_1 (decl);\n-      cp_finish_decl (decl, DECL_INITIAL (decl),\n-\t\t      NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n-    }\n-  else\n-    {\n-      push_eh_cleanup ();\n-\n-      /* Create a binding level for the parm.  */\n-      pushlevel (0);\n-      expand_start_bindings (0);\n-\n-      /* Fall into the catch all section.  */\n-    }\n-\n-  init = build_modify_expr (get_eh_caught (), NOP_EXPR, integer_one_node);\n-  expand_expr (init, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-\n-  emit_line_note (input_filename, lineno);\n-}\n-\n /* This function performs the expand_start_catch_block functionality for \n    exceptions implemented in the new style. __throw determines whether\n    a handler needs to be called or not, so the handler itself has to do\n-   nothing additionaal. */\n+   nothing additional. */\n \n static void \n process_start_catch_block (declspecs, declarator)\n@@ -806,6 +685,7 @@ process_start_catch_block (declspecs, declarator)\n       DECL_INITIAL (decl) = init;\n       decl = pushdecl (decl);\n \n+      start_decl_1 (decl);\n       cp_finish_decl (decl, init, NULL_TREE, 0, LOOKUP_ONLYCONVERTING);\n     }\n   else\n@@ -849,10 +729,7 @@ expand_end_catch_block ()\n      documentation.  */\n   expand_goto (top_label_entry (&caught_return_label_stack));\n \n-  /* label we emit to jump to if this catch block didn't match.  */\n-  /* This the closing } in the `if (eq) {' of the documentation.  */\n-  if (! flag_new_exceptions)\n-    emit_label (pop_label_entry (&false_label_stack));\n+  end_catch_handler ();\n }\n \n /* An exception spec is implemented more or less like:"}, {"sha": "5fafd1f06837e9b4d6e38aed7a9fe9f0a3b00ec6", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -157,7 +157,9 @@ __cplus_type_matcher (cp_eh_info *info, rtimetype match_info,\n {\n   void *ret;\n \n-  if (exception_table->lang.language != EH_LANG_C_plus_plus)\n+  /* No exception table implies the old style mechanism, so don't check. */\n+  if (exception_table != NULL && \n+                        exception_table->lang.language != EH_LANG_C_plus_plus)\n     return NULL;\n \n   if (match_info == CATCH_ALL_TYPE)"}, {"sha": "f0d00094f8595a687e3698c51a6f0620abbcee85", "filename": "gcc/except.c", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -597,6 +597,7 @@ push_eh_entry (stack)\n   entry->finalization = NULL_TREE;\n   entry->label_used = 0;\n   entry->exception_handler_label = gen_exception_label ();\n+  entry->false_label = NULL_RTX;\n \n   node->entry = entry;\n   node->chain = stack->top;\n@@ -1600,6 +1601,54 @@ start_catch_handler (rtime)\n   receive_exception_label (handler_label);\n \n   add_new_handler (eh_region_entry, get_new_handler (handler_label, rtime));\n+\n+  if (flag_new_exceptions && ! exceptions_via_longjmp)\n+    return;\n+\n+  /* Under the old mechanism, as well as setjmp/longjmp, we need to\n+     issue code to compare 'rtime' to the value in eh_info, via the\n+     matching function in eh_info. If its is false, we branch around\n+     the handler we are about to issue. */\n+\n+  if (rtime != NULL_TREE && rtime != CATCH_ALL_TYPE)\n+    {\n+      rtx call_rtx, rtime_address;\n+\n+      if (catchstack.top->entry->false_label != NULL_RTX)\n+        error (\"never issued previous false_label\");\n+      catchstack.top->entry->false_label = gen_exception_label ();\n+\n+      rtime_address = expand_expr (rtime, NULL_RTX, Pmode, EXPAND_INITIALIZER);\n+      rtime_address = force_reg (Pmode, rtime_address);\n+\n+      /* Now issue the call, and branch around handler if needed */\n+      call_rtx = emit_library_call_value (\n+        gen_rtx_SYMBOL_REF (Pmode, \"__eh_rtime_match\"), NULL_RTX, \n+                                        0, SImode, 1, rtime_address, Pmode);\n+\n+      /* Did the function return true? */\n+      emit_cmp_insn (call_rtx, const0_rtx, EQ, NULL_RTX,\n+                                                GET_MODE (call_rtx), 0 ,0);\n+      emit_jump_insn (gen_beq (catchstack.top->entry->false_label));\n+    }\n+}\n+\n+/* Called to end a catch clause. If we aren't using the new exception\n+   model tabel mechanism, we need to issue the branch-around label\n+   for the end of the catch block. */\n+\n+void \n+end_catch_handler ()\n+{\n+  if (! doing_eh (1) || (flag_new_exceptions && ! exceptions_via_longjmp))\n+    return;\n+  \n+  /* A NULL label implies the catch clause was a catch all or cleanup */\n+  if (catchstack.top->entry->false_label == NULL_RTX)\n+    return;\n+\n+  emit_label (catchstack.top->entry->false_label);\n+  catchstack.top->entry->false_label = NULL_RTX;\n }\n \n /* Generate RTL for the start of a group of catch clauses. \n@@ -1693,9 +1742,6 @@ expand_start_all_catch ()\n       ehstack.top->entry->outer_context = outer_context;\n     }\n \n-  /* We also have to start the handler if we aren't using the new model. */\n-  if (! flag_new_exceptions)\n-    start_catch_handler (NULL);\n }\n \n /* Finish up the catch block.  At this point all the insns for the\n@@ -1927,6 +1973,9 @@ output_exception_table_entry (file, n)\n                                                 POINTER_SIZE / BITS_PER_UNIT);\n         }\n       putc ('\\n', file);\t\t/* blank line */\n+      /* We only output the first label under the old scheme */\n+      if (! flag_new_exceptions)\n+        break;\n     }\n }\n "}, {"sha": "5416e5987605e593afecdbeffd80421f28fff993", "filename": "gcc/except.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -53,6 +53,10 @@ struct label_node {\n    label or not. New ones are needed for additional catch blocks if\n    it has.\n \n+   FALSE_LABEL is used when either setjmp/longjmp exceptions are in\n+   use, or old style table exceptions. It contains the label for \n+   branching to the next runtime type check as handlers are processed.\n+\n    FINALIZATION is the tree codes for the handler, or is NULL_TREE if\n    one hasn't been generated yet, or is integer_zero_node to mark the\n    end of a group of try blocks.  */\n@@ -62,6 +66,7 @@ struct eh_entry {\n   rtx exception_handler_label;\n   tree finalization;\n   int label_used;\n+  rtx false_label;\n };\n \n /* A list of EH_ENTRYs. ENTRY is the entry; CHAIN points to the next\n@@ -237,6 +242,10 @@ extern void add_eh_table_entry\t\t\tPROTO((int n));\n extern void start_catch_handler                 PROTO((tree));\n #endif\n \n+/* End an individual catch clause. */\n+\n+extern void end_catch_handler                   PROTO((void));\n+\n /* Returns a non-zero value if we need to output an exception table.  */\n \n extern int exception_table_p\t\t\tPROTO((void));"}, {"sha": "6f2fcfd97962d5df6db871ce97cddd8c8604ddb5", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf71cd2eaa2d7091cd02f429beeec279b6a5c52d/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=bf71cd2eaa2d7091cd02f429beeec279b6a5c52d", "patch": "@@ -3355,6 +3355,21 @@ __sjpopnthrow ()\n \f\n /* Support code for all exception region-based exception handling.  */\n \n+int\n+__eh_rtime_match (void *rtime)\n+{\n+  void *info;\n+  __eh_matcher matcher;\n+  void *ret;\n+\n+  info = *(__get_eh_info ());\n+  matcher = ((__eh_info *)info)->match_function;\n+  if (!matcher)\n+    perror (\"No runtime type matcher available\");\n+  ret = (*matcher) (info, rtime, (void *)0);\n+  return ((int)ret);\n+}\n+\n /* This value identifies the place from which an exception is being\n    thrown.  */\n "}]}