{"sha": "20427c6b9b8288eef21c79df4f60b85cf04a39a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0MjdjNmI5YjgyODhlZWYyMWM3OWRmNGY2MGI4NWNmMDRhMzlhNw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@purist.soma.redhat.com", "date": "2000-07-02T02:16:35Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2000-07-02T02:16:35Z"}, "message": "Sync libio to glibc-2.2 current CVS.\n\n\n2000-07-01  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n\t    Ulrich Drepper  <drepper@purist.soma.redhat.com>\n\n\tSync libio to glibc-2.2 current CVS.\n\t* libio/_G_config.h: New file.\n\t* libio/wfileops.c: New file.\n\t* libio/wfiledoalloc.c: New file.\n\t* libio/wgenops.c: New file.\n\t* libio/iofwide.c: New file.\n\t* libio/Makefile.am: Tweaks.\n\t* libio/Makefile.in: Regenerate.\n\t* libio/gen-params: Remove. Generic replacement for this yet undone.\n\t* libio/[filedoalloc.c, fileops.c, genops.c, iolibio.h, libio.h,\n\tlibioP.h, stdfiles.c]: Update.\n\t* config/c_io_libio.cc: Tweaks.\n\t* acinclude.m4: Complete hacks to test wide io.\n\t* aclocal.m4: Regenerate.\n\t* configure: Regenerate.\n\t* src/Makefile.am: Update.\n\t* src/Makefile.in: Regenerate.\n\n\t* math/cargl.c: Remove underscores.\n\n\t* bits/locale_facets.h: Tweaks. Start adding iconv details\n\tand notes.\n\t* bits/locale_facets.tcc: Tweaks.\n\t* bits/std_cwchar.h: Tweaks.\n\nCo-Authored-By: Ulrich Drepper <drepper@purist.soma.redhat.com>\n\nFrom-SVN: r34822", "tree": {"sha": "c2f535612778d94f37c18a9b782ab69a48afa4fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2f535612778d94f37c18a9b782ab69a48afa4fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20427c6b9b8288eef21c79df4f60b85cf04a39a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20427c6b9b8288eef21c79df4f60b85cf04a39a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20427c6b9b8288eef21c79df4f60b85cf04a39a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20427c6b9b8288eef21c79df4f60b85cf04a39a7/comments", "author": null, "committer": null, "parents": [{"sha": "dee4095a023e08b724ff60729643a62639cb43b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dee4095a023e08b724ff60729643a62639cb43b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dee4095a023e08b724ff60729643a62639cb43b6"}], "stats": {"total": 6829, "additions": 4551, "deletions": 2278}, "files": [{"sha": "d98deaf37f10967ed9301ebfbcbb237debcde9c3", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,3 +1,31 @@\n+2000-07-01  Benjamin Kosnik  <bkoz@purist.soma.redhat.com>\n+\t    Ulrich Drepper  <drepper@purist.soma.redhat.com>\n+\n+\tSync libio to glibc-2.2 current CVS. \n+\t* libio/_G_config.h: New file.\n+\t* libio/wfileops.c: New file.\n+\t* libio/wfiledoalloc.c: New file.\n+\t* libio/wgenops.c: New file.\n+\t* libio/iofwide.c: New file.\n+\t* libio/Makefile.am: Tweaks.\n+\t* libio/Makefile.in: Regenerate.\n+\t* libio/gen-params: Remove. Generic replacement for this yet undone.\n+\t* libio/[filedoalloc.c, fileops.c, genops.c, iolibio.h, libio.h,\n+\tlibioP.h, stdfiles.c]: Update.\n+\t* config/c_io_libio.cc: Tweaks.\n+\t* acinclude.m4: Complete hacks to test wide io.\n+\t* aclocal.m4: Regenerate.\n+\t* configure: Regenerate.\n+\t* src/Makefile.am: Update.\n+\t* src/Makefile.in: Regenerate.\n+\n+\t* math/cargl.c: Remove underscores.\n+\t\n+\t* bits/locale_facets.h: Tweaks. Start adding iconv details\n+\tand notes.\n+\t* bits/locale_facets.tcc: Tweaks.\n+\t* bits/std_cwchar.h: Tweaks.\n+\t\n 2000-06-29  scott snyder  <snyder@fnal.gov>\n \n         * bits/concept_checks.h\n@@ -18,7 +46,7 @@\n \tfunction, uglify to __eos. Return char_type().\n \t* bits/std_ostream.h: Change.\n \n-\t* testsuite/27_io/ostream_seeks.cc (test01): New file.\n+\t* testsuite/27_io/ostream_seeks.cc: New file.\n \t* testsuite/27_io/ostream_seeks-1.tst: New file.\n \t* testsuite/27_io/istream_unformatted.cc (main): Move test04 and\n \ttest05 to..."}, {"sha": "f5582f278e4af4517696c0ba917493189c9a54b8", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1173,6 +1173,10 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \n \t\t# see if we are on a system with libio native (ie, linux)\n   \t\tAC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n+\n+\t\t# bkoz XXX hack hack need version checks, this is temporary\n+\t\thas_libio=no\n+\n   \t\tif test $has_libio = \"yes\"; then\n    \t\t  BUILD_LIBIO_INCLUDE=\n \t\t  need_libio=no\n@@ -1186,6 +1190,11 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \t\t# NB: This replaces the _G_CONFIG_H machinery in libio-v2\n \t\tAC_CHECK_HEADER(_G_config.h,  has_gconf_h=yes, has_gconf_h=no)\n   \t\tAM_CONDITIONAL(GLIBCPP_NEED_LIBIO_CONFIG_H, test \"$has_gconf_h\" = no)\n+\t\t# bkoz XXX hack need to add support for non-glibc systems here\n+\t \thas_gconf=no\n+\n+\t\t# bkoz XXX need to add checks for this\n+\t\tneed_wlibio=yes\n \t\t;;\n         xwince)\n                 CSTDIO_H=c_io_wince.h\n@@ -1204,6 +1213,7 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n   AC_SUBST(CSTDIO_H)\n   AC_SUBST(CSTDIO_CC)\n   AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n+  AM_CONDITIONAL(GLIBCPP_NEED_WLIBIO, test \"$need_wlibio\" = yes)\n ])\n \n "}, {"sha": "3f7a8b21e74c2ab489f24637360259406925a8a4", "filename": "libstdc++-v3/aclocal.m4", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Faclocal.m4?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1185,6 +1185,10 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \n \t\t# see if we are on a system with libio native (ie, linux)\n   \t\tAC_CHECK_HEADER(libio.h,  has_libio=yes, has_libio=no)\n+\n+\t\t# bkoz XXX hack hack need version checks, this is temporary\n+\t\thas_libio=no\n+\n   \t\tif test $has_libio = \"yes\"; then\n    \t\t  BUILD_LIBIO_INCLUDE=\n \t\t  need_libio=no\n@@ -1198,6 +1202,11 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n \t\t# NB: This replaces the _G_CONFIG_H machinery in libio-v2\n \t\tAC_CHECK_HEADER(_G_config.h,  has_gconf_h=yes, has_gconf_h=no)\n   \t\tAM_CONDITIONAL(GLIBCPP_NEED_LIBIO_CONFIG_H, test \"$has_gconf_h\" = no)\n+\t\t# bkoz XXX hack need to add support for non-glibc systems here\n+\t \thas_gconf=no\n+\n+\t\t# bkoz XXX need to add checks for this\n+\t\tneed_wlibio=yes\n \t\t;;\n         xwince)\n                 CSTDIO_H=c_io_wince.h\n@@ -1216,6 +1225,7 @@ AC_DEFUN(GLIBCPP_ENABLE_CSTDIO, [\n   AC_SUBST(CSTDIO_H)\n   AC_SUBST(CSTDIO_CC)\n   AM_CONDITIONAL(GLIBCPP_NEED_LIBIO, test \"$need_libio\" = yes)\n+  AM_CONDITIONAL(GLIBCPP_NEED_WLIBIO, test \"$need_wlibio\" = yes)\n ])\n \n "}, {"sha": "1c73ab9e2bb5a7dec4a9846f123e2acccf0c7483", "filename": "libstdc++-v3/bits/locale_facets.h", "status": "modified", "additions": 66, "deletions": 9, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -39,6 +39,10 @@\n #include <bits/std_ctime.h>\t// For struct tm\n #include <bits/std_typeinfo.h> \t// For bad_cast, which shouldn't be here.\n #include <bits/std_ios.h>\t// For ios_base\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+// XXX should break this out??\n+#include <iconv.h>\t\t// For iconv, iconv_t\n+#endif\n \n namespace std\n {\n@@ -76,6 +80,60 @@ namespace std\n     _Use_facet_failure_handler(const locale&)\n     { throw _Bad_use_facet(); }\n \n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  // Extensions to use icov for dealing with character encodings,\n+  // including conversions and comparisons between various character\n+  // sets.  This object encapsulates data that codecvt and possibly\n+  // ctype will use.\n+  template<typename _IntT, typename _ExtT>\n+  class __enc_traits\n+  {\n+  public:\n+    // Types:\n+    typedef iconv_t\t__conv_type;\n+    typedef _IntT\t__intc_type;\n+    typedef _ExtT\t__extc_type;\n+\n+    // max size of charset encoding name\n+    static const int \t__max_size = 32;\n+    // name of internal character set encoding.\n+    char\t       \t__intc_enc[__max_size];\n+    // name of external character set encoding.\n+    char  \t       \t__extc_enc[__max_size];\n+\n+    const char* \n+    _M_get_intc_enc(void)\n+    { return __intc_enc; }\n+\n+    void\n+    _M_set_intc_enc(const char* __c)\n+    { strcpy(__intc_enc, __c); }\n+\n+    const char* \n+    _M_get_extc_enc(void)\n+    { return __extc_enc; }\n+\n+    void\n+    _M_set_extc_enc(const char* __c)\n+    { strcpy(__extc_enc, __c); }\n+\n+    __enc_traits(const char* __int, const char* __ext)\n+    {\n+      // __intc_end = whatever we are using internally, which is\n+      // almost alwyas UCS4 (linux) or UCS2 (microsoft, aix,\n+      // whatever...)\n+      // __extc_end = nl_langinfo(CODESET)\n+      strcpy(__intc_enc, __int);\n+      strcpy(__extc_enc, __ext);\n+    }\n+\n+  protected:\n+    __enc_traits();\n+    __enc_traits(const __enc_traits&);\n+  };\n+#endif //_GLIBCPP_USE_WCHAR_T\n+\n   // 22.2.1  The ctype category\n   // Include host-specific ctype enums for ctype_base.\n   #include <bits/ctype_base.h>\n@@ -86,10 +144,10 @@ namespace std\n   template<typename _CharT>\n     class _Ctype_nois : public locale::facet, public ctype_base\n     {\n+    public:\n       // Types:\n       typedef _CharT char_type;\n \n-    public:\n       char_type \n       toupper(char_type __c) const\n       { return this->do_toupper(__c); }\n@@ -162,7 +220,6 @@ namespace std\n     class _Ctype : public _Ctype_nois<_CharT>\n     {\n     public:\n-\n       // Types:\n       typedef _CharT \t\t\t\t\tchar_type;\n       typedef typename _Ctype_nois<_CharT>::mask \tmask;\n@@ -644,8 +701,8 @@ namespace std\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<>\n-    class codecvt<wchar_t,char,mbstate_t> \n-    : public _Codecvt<wchar_t,char,mbstate_t>\n+    class codecvt<wchar_t, char, mbstate_t> \n+    : public _Codecvt<wchar_t, char, mbstate_t>\n     {\n     public:\n       // Types:\n@@ -687,7 +744,7 @@ namespace std\n \n   // 22.2.1.6  Template class codecvt_byname\n   template<typename _InternT, typename _ExternT, typename _StateT>\n-    class codecvt_byname : public codecvt<_InternT,_ExternT,_StateT>\n+    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>\n     {\n     public:\n       explicit \n@@ -699,8 +756,8 @@ namespace std\n     };\n \n   template<>\n-    class codecvt_byname<char,char,mbstate_t>\n-    : public codecvt<char,char,mbstate_t>\n+    class codecvt_byname<char, char, mbstate_t>\n+    : public codecvt<char, char, mbstate_t>\n     {\n     public:\n       explicit \n@@ -713,8 +770,8 @@ namespace std\n   \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<>\n-    class codecvt_byname<wchar_t,char,mbstate_t>\n-      : public codecvt<wchar_t,char,mbstate_t>\n+    class codecvt_byname<wchar_t, char, mbstate_t>\n+      : public codecvt<wchar_t, char, mbstate_t>\n     {\n     public:\n       explicit "}, {"sha": "a91d57f6d7ea5805eec90d438a5d6c977913e8da", "filename": "libstdc++-v3/bits/locale_facets.tcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Flocale_facets.tcc?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -606,7 +606,7 @@ namespace std\n           // Stage 1: extract and determine the conversion specifier.\n           // Assuming leading zeros eliminated, thus the size of 32 for\n           // integral types.\n-          char __xtrc[32]= {'\\0'};\n+          char __xtrc[32] = {'\\0'};\n           int __base;\n           _M_extract(__beg, __end, __io, __err, __xtrc, __base, false);\n "}, {"sha": "43470aed5d745757f00a7ec4545d8292c5eb80de", "filename": "libstdc++-v3/bits/std_cwchar.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fbits%2Fstd_cwchar.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -42,15 +42,17 @@\n  # pragma system_header\n  # include_next <wchar.h>\n #else\n-# ifdef _GLIBCPP_NEED_MBSTATE_T\n+# ifdef __cplusplus\n extern \"C\" \n {\n+#endif\n   typedef struct \n   {\n     int __fill[6];\n   } mbstate_t;\n+# ifdef __cplusplus\n }\n-#  endif\n+# endif\n #endif //_GLIBCPP_USE_WCHAR_T\n \n #endif // _CPP_CWCHAR"}, {"sha": "69a820009cefc976861eae173a053623b1d912ed", "filename": "libstdc++-v3/config/c_io_libio.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fc_io_libio.cc?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -41,7 +41,7 @@ namespace std {\n   {\n     _lock = __lock;\n     _IO_init(this, 0);     \n-    _IO_file_init(this); \n+    _IO_file_init((_IO_FILE_plus*) this); \n     _IO_file_attach(this, -1);\n   }\n \n@@ -55,7 +55,7 @@ namespace std {\n       {\n \t_IO_do_flush(this);\n \tif (!(_flags & _IO_DELETE_DONT_CLOSE))\n-\t  _IO_SYSCLOSE(this);\n+\t  _IO_SYSCLOSE((_IO_FILE*)this);\n       }\n     _IO_default_finish(this, 0);\n   }\n@@ -92,7 +92,7 @@ namespace std {\n \t_fileno = __fd;\n \tint __mask = _IO_NO_READS + _IO_NO_WRITES + _IO_IS_APPENDING;\n \t_flags = (_flags & ~__mask) | (__rw_mode & __mask);\n-\t_IO_link_in(this); \n+\t_IO_link_in((_IO_FILE_plus*) this); \n \t__retval = this;\n       }\n     return __retval;"}, {"sha": "f237730b18fab38a5f0011d4ce114f7aa76f6234", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 941, "deletions": 921, "changes": 1862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7"}, {"sha": "289afc238dda111903f069ddf2431fb4022d5de0", "filename": "libstdc++-v3/libio/Makefile.am", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.am?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -23,11 +23,27 @@\n \n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n+# Passed down for cross compilers, canadian crosses.\n+TOPLEVEL_INCLUDES = -I$(includedir)\n+\n+LIBIO_INCLUDES = @BUILD_LIBIO_INCLUDE@ -I$(top_srcdir)/libio \n+\n+CSHADOW_INCLUDES = @CSHADOWFLAGS@ @CSHADOW_INCLUDES@\n+\n+CONFIG_INCLUDES = \\\n+\t-I$(top_srcdir)/@cpu_include_dir@ \\\n+\t-I$(top_srcdir)/@ctype_include_dir@\n+\n+INCLUDES = \\\n+\t-D_GNU_SOURCE -nostdinc++ -I$(top_srcdir) \\\n+\t$(LIBIO_INCLUDES) $(CONFIG_INCLUDES) $(CSHADOW_INCLUDES) \\\n+\t$(TOPLEVEL_INCLUDES)\t\n+\n noinst_LTLIBRARIES = libio.la\n \n LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n \n-includes = \n+#includes = \n \n libio_headers = \\\n         libio.h libioP.h iolibio.h\n@@ -39,35 +55,17 @@ else\n LIBIO_SRCS =\n endif\n \n-EXTRA_DIST = iostreamP.h\n-\n-libio_la_LIBADD = $(LIBIO_SRCS) \n-libio_la_DEPENDENCIES = $(libio_la_LIBADD)\n-libio_la_SOURCES = $(LIBIO_SRCS)\n-\n-if GLIBCPP_NEED_LIBIO_CONFIG_H\n-LIBIO_CONFIG_H = _G_config.h\n+if GLIBCPP_NEED_WLIBIO\n+LIBIO_WSRCS = \\\n+\tiofwide.c wfiledoalloc.c wfileops.c wgenops.c\n else\n-LIBIO_CONFIG_H = \n+LIBIO_WSRCS =\n endif\n \n-# Specify that *.o depend on this one header\n-$(libio_la_OBJECTS): $(LIBIO_CONFIG_H)\n-\n-# Generate this file.\n-_G_config.h: $(srcdir)/gen-params\n-\trootme=`pwd`/ ; export rootme; \\\n-\tCC=\"$(CC) $(CINCLUDES)\"; export CC; \\\n-\tCXX=\"$(CXX) $(CXXINCLUDES) $(NOSTDINC) $(CXXFLAGS)\"; export CXX; \\\n-\tCONFIG_NM=\"$(NM)\"; export CONFIG_NM; \\\n-\t$(SHELL) $(srcdir)/gen-params LIB_VERSION=$(VERSION) $(G_CONFIG_ARGS) >tmp-params.h\n-\tmv tmp-params.h _G_config.h\n-\n-\n-\n-\n-\n-\n \n+EXTRA_DIST = iostreamP.h\n \n+libio_la_LIBADD = $(LIBIO_SRCS) $(LIBIO_WSRCS) \n+libio_la_DEPENDENCIES = $(libio_la_LIBADD)\n+libio_la_SOURCES = $(LIBIO_SRCS) $(LIBIO_WSRCS) \n "}, {"sha": "9e298dd3477f9a418e1b73396f8aaafddab9768f", "filename": "libstdc++-v3/libio/Makefile.in", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FMakefile.in?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -70,7 +70,6 @@ CC = @CC@\n CPP = @CPP@\n CPU_FLAGS = @CPU_FLAGS@\n CSHADOWFLAGS = @CSHADOWFLAGS@\n-CSHADOW_INCLUDES = @CSHADOW_INCLUDES@\n CSTDIO_CC = @CSTDIO_CC@\n CSTDIO_H = @CSTDIO_H@\n CXX = @CXX@\n@@ -109,26 +108,45 @@ libinst_wstring_la = @libinst_wstring_la@\n \n AUTOMAKE_OPTIONS = 1.3 cygnus\n \n+# Passed down for cross compilers, canadian crosses.\n+TOPLEVEL_INCLUDES = -I$(includedir)\n+\n+LIBIO_INCLUDES = @BUILD_LIBIO_INCLUDE@ -I$(top_srcdir)/libio \n+\n+CSHADOW_INCLUDES = @CSHADOWFLAGS@ @CSHADOW_INCLUDES@\n+\n+CONFIG_INCLUDES = \\\n+\t-I$(top_srcdir)/@cpu_include_dir@ \\\n+\t-I$(top_srcdir)/@ctype_include_dir@\n+\n+\n+INCLUDES = \\\n+\t-D_GNU_SOURCE -nostdinc++ -I$(top_srcdir) \\\n+\t$(LIBIO_INCLUDES) $(CONFIG_INCLUDES) $(CSHADOW_INCLUDES) \\\n+\t$(TOPLEVEL_INCLUDES)\t\n+\n+\n noinst_LTLIBRARIES = libio.la\n \n LINK = $(LIBTOOL) --mode=link \"$(CCLD)\" $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n \n-includes = \n+#includes = \n \n libio_headers = \\\n         libio.h libioP.h iolibio.h\n \n @GLIBCPP_NEED_LIBIO_TRUE@LIBIO_SRCS = @GLIBCPP_NEED_LIBIO_TRUE@\\\n @GLIBCPP_NEED_LIBIO_TRUE@\tfiledoalloc.c genops.c fileops.c stdfiles.c cleanup.c\n @GLIBCPP_NEED_LIBIO_FALSE@LIBIO_SRCS = \n+@GLIBCPP_NEED_WLIBIO_TRUE@LIBIO_WSRCS = @GLIBCPP_NEED_WLIBIO_TRUE@\\\n+@GLIBCPP_NEED_WLIBIO_TRUE@\tiofwide.c wfiledoalloc.c wfileops.c wgenops.c\n+@GLIBCPP_NEED_WLIBIO_FALSE@LIBIO_WSRCS = \n \n EXTRA_DIST = iostreamP.h\n \n-libio_la_LIBADD = $(LIBIO_SRCS) \n+libio_la_LIBADD = $(LIBIO_SRCS) $(LIBIO_WSRCS) \n libio_la_DEPENDENCIES = $(libio_la_LIBADD)\n-libio_la_SOURCES = $(LIBIO_SRCS)\n-@GLIBCPP_NEED_LIBIO_CONFIG_H_TRUE@LIBIO_CONFIG_H = @GLIBCPP_NEED_LIBIO_CONFIG_H_TRUE@_G_config.h\n-@GLIBCPP_NEED_LIBIO_CONFIG_H_FALSE@LIBIO_CONFIG_H = \n+libio_la_SOURCES = $(LIBIO_SRCS) $(LIBIO_WSRCS) \n mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n CONFIG_HEADER = ../config.h\n CONFIG_CLEAN_FILES = \n@@ -140,9 +158,27 @@ CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libio_la_LDFLAGS = \n-@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  filedoalloc.lo genops.lo \\\n-@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo stdfiles.lo cleanup.lo\n-@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS = \n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@cleanup.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_TRUE@wgenops.lo\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@iofwide.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfiledoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wfileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_TRUE@@GLIBCPP_NEED_LIBIO_FALSE@wgenops.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@libio_la_OBJECTS =  \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@filedoalloc.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@genops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@fileops.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@stdfiles.lo \\\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_TRUE@cleanup.lo\n+@GLIBCPP_NEED_WLIBIO_FALSE@@GLIBCPP_NEED_LIBIO_FALSE@libio_la_OBJECTS = \n CFLAGS = @CFLAGS@\n COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n@@ -339,18 +375,6 @@ installdirs mostlyclean-generic distclean-generic clean-generic \\\n maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n \n-# Specify that *.o depend on this one header\n-$(libio_la_OBJECTS): $(LIBIO_CONFIG_H)\n-\n-# Generate this file.\n-_G_config.h: $(srcdir)/gen-params\n-\trootme=`pwd`/ ; export rootme; \\\n-\tCC=\"$(CC) $(CINCLUDES)\"; export CC; \\\n-\tCXX=\"$(CXX) $(CXXINCLUDES) $(NOSTDINC) $(CXXFLAGS)\"; export CXX; \\\n-\tCONFIG_NM=\"$(NM)\"; export CONFIG_NM; \\\n-\t$(SHELL) $(srcdir)/gen-params LIB_VERSION=$(VERSION) $(G_CONFIG_ARGS) >tmp-params.h\n-\tmv tmp-params.h _G_config.h\n-\n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded.\n .NOEXPORT:"}, {"sha": "a35d9f49aca07c9cb60b53a81bd559324150e5ae", "filename": "libstdc++-v3/libio/_G_config.h", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2F_G_config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2F_G_config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2F_G_config.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -0,0 +1,130 @@\n+/* This file is needed by libio to define various configuration parameters.\n+   These are always the same in the GNU C library.  */\n+\n+#ifndef _G_config_h\n+#define _G_config_h 1\n+\n+#ifndef _LIBC\n+# include <bits/c++config.h>\n+#endif\n+\n+/* Define types for libio in terms of the standard internal type names.  */\n+\n+#include <sys/types.h>\n+#define __need_size_t\n+#define __need_wchar_t\n+#define __need_wint_t\n+#define __need_NULL\n+#include <bits/std_cstddef.h>\n+\n+\n+/* For use as part of glibc (native) or as part of libstdc++ (maybe\n+   not glibc) */\n+#if __GLIBC__ < 2 || (__GLIBC__ == 2  && __GLIBC_MINOR__ <= 1)\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+#  include <bits/std_cwchar.h>\n+typedef mbstate_t __mbstate_t;\n+# endif\n+#endif\n+\n+#ifndef _WINT_T\n+/* Integral type unchanged by default argument promotions that can\n+   hold any value corresponding to members of the extended character\n+   set, as well as at least one value that does not correspond to any\n+   member of the extended character set.  */\n+# define _WINT_T\n+typedef unsigned int wint_t;\n+#endif\n+#define __need_mbstate_t\n+#include <bits/std_cwchar.h>\n+#define _G_size_t\tsize_t\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+typedef struct\n+{\n+  __off_t __pos;\n+  __mbstate_t __state;\n+} _G_fpos_t;\n+typedef struct\n+{\n+  __off64_t __pos;\n+  __mbstate_t __state;\n+} _G_fpos64_t;\n+#else\n+typedef __off_t _G_fpos_t;\n+typedef __off64_t _G_fpos64_t;\n+#endif\n+#define _G_ssize_t\t__ssize_t\n+#define _G_off_t\t__off_t\n+#define _G_off64_t\t__off64_t\n+#define\t_G_pid_t\t__pid_t\n+#define\t_G_uid_t\t__uid_t\n+#define _G_wchar_t\twchar_t\n+#define _G_wint_t\twint_t\n+#define _G_stat64\tstat64\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+# include <iconv.h>\n+typedef iconv_t _G_iconv_t;\n+# if 0\n+/* XXX Commented out because outside glibc we have to use iconv()\n+   and not gconv().  */\n+typedef union\n+{\n+  struct __gconv_info __cd;\n+  struct\n+  {\n+    struct __gconv_info __cd;\n+    struct __gconv_step_data __data;\n+  } __combined;\n+} _G_iconv_t;\n+# endif\n+#endif\n+\n+typedef int _G_int16_t __attribute__ ((__mode__ (__HI__)));\n+typedef int _G_int32_t __attribute__ ((__mode__ (__SI__)));\n+typedef unsigned int _G_uint16_t __attribute__ ((__mode__ (__HI__)));\n+typedef unsigned int _G_uint32_t __attribute__ ((__mode__ (__SI__)));\n+\n+#define _G_HAVE_BOOL 1\n+\n+\n+/* These library features are always available in the GNU C library.  */\n+#define _G_HAVE_ATEXIT 1\n+#define _G_HAVE_SYS_CDEFS 1\n+#define _G_HAVE_SYS_WAIT 1\n+#define _G_NEED_STDARG_H 1\n+#define _G_va_list __gnuc_va_list\n+\n+#define _G_HAVE_PRINTF_FP 1\n+#define _G_HAVE_MMAP 1\n+#define _G_HAVE_LONG_DOUBLE_IO 1\n+#define _G_HAVE_IO_FILE_OPEN 1\n+#define _G_HAVE_IO_GETLINE_INFO 1\n+\n+#define _G_IO_IO_FILE_VERSION 0x20001\n+\n+//#define _G_OPEN64\t__open64\n+//#define _G_LSEEK64\t__lseek64\n+//#define _G_FSTAT64(fd,buf) __fxstat64 (_STAT_VER, fd, buf)\n+\n+/* This is defined by <bits/stat.h> if `st_blksize' exists.  */\n+#define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE)\n+\n+#define _G_BUFSIZ 8192\n+\n+/* These are the vtbl details for ELF.  */\n+#define _G_NAMES_HAVE_UNDERSCORE 0\n+#define _G_VTABLE_LABEL_HAS_LENGTH 1\n+#define _G_USING_THUNKS\t1\n+#define _G_VTABLE_LABEL_PREFIX \"__vt_\"\n+#define _G_VTABLE_LABEL_PREFIX_ID __vt_\n+\n+#define _G_INTERNAL_CCS\t\"UCS4\"\n+\n+\n+#if defined __cplusplus || defined __STDC__\n+# define _G_ARGS(ARGLIST) ARGLIST\n+#else\n+# define _G_ARGS(ARGLIST) ()\n+#endif\n+\n+#endif\t/* _G_config.h */"}, {"sha": "6abab602d167bdd1d83fa2938c45cff2128143ec", "filename": "libstdc++-v3/libio/filedoalloc.c", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffiledoalloc.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -27,34 +27,24 @@\n  * Copyright (c) 1990 The Regents of the University of California.\n  * All rights reserved.\n  *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- * 3. [rescinded 22 July 1999]\n- * 4. Neither the name of the University nor the names of its contributors\n- *    may be used to endorse or promote products derived from this software\n- *    without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n+ * Redistribution and use in source and binary forms are permitted\n+ * provided that the above copyright notice and this paragraph are\n+ * duplicated in all such forms and that any documentation,\n+ * advertising materials, and other materials related to such\n+ * distribution and use acknowledge that the software was developed\n+ * by the University of California, Berkeley.  The name of the\n+ * University may not be used to endorse or promote products derived\n+ * from this software without specific prior written permission.\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n  */\n \n /* Modified for GNU iostream by Per Bothner 1991, 1992. */\n \n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n #include \"libioP.h\"\n #include <sys/types.h>\n #include <sys/stat.h>\n@@ -83,9 +73,9 @@ _IO_file_doallocate (fp)\n   _IO_size_t size;\n   int couldbetty;\n   char *p;\n-  struct stat st;\n+  struct _G_stat64 st;\n \n-#if !defined(_LIBC) && !defined(__linux__)\n+#ifndef _LIBC\n   /* If _IO_cleanup_registration_needed is non-zero, we should call the\n      function it points to.  This is to make sure _IO_cleanup gets called\n      on exit.  We call it from _IO_file_doallocate, since that is likely"}, {"sha": "122203e38bff0b30ae81f8ef3721f7d1cc18e506", "filename": "libstdc++-v3/libio/fileops.c", "status": "modified", "additions": 393, "deletions": 180, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Ffileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Ffileops.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1993, 1995, 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1993, 1995, 1997-1999, 2000 Free Software Foundation, Inc.\n    This file is part of the GNU IO Library.\n    Written by Per Bothner <bothner@cygnus.com>.\n \n@@ -25,25 +25,50 @@\n    General Public License.  */\n \n \n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n #include \"libioP.h\"\n #include <fcntl.h>\n #include <sys/types.h>\n #include <sys/stat.h>\n #include <string.h>\n-#include <unistd.h>\n #include <errno.h>\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#endif\n+#if _LIBC\n+# include \"../wcsmbs/wcsmbsload.h\"\n+# include <shlib-compat.h>\n+#endif\n #ifndef errno\n extern int errno;\n #endif\n+#ifndef __set_errno\n+# define __set_errno(Val) errno = (Val)\n+#endif\n \n \n #ifdef _LIBC\n # define open(Name, Flags, Prot) __open (Name, Flags, Prot)\n # define close(FD) __close (FD)\n-# define fstat(FD, Statbuf) __fstat (FD, Statbuf)\n # define lseek(FD, Offset, Whence) __lseek (FD, Offset, Whence)\n # define read(FD, Buf, NBytes) __read (FD, Buf, NBytes)\n # define write(FD, Buf, NBytes) __write (FD, Buf, NBytes)\n+#else\n+# define _IO_new_do_write _IO_do_write\n+# define _IO_new_file_attach _IO_file_attach\n+# define _IO_new_file_close_it _IO_file_close_it\n+# define _IO_new_file_finish _IO_file_finish\n+# define _IO_new_file_fopen _IO_file_fopen\n+# define _IO_new_file_init _IO_file_init\n+# define _IO_new_file_setbuf _IO_file_setbuf\n+# define _IO_new_file_sync _IO_file_sync\n+# define _IO_new_file_overflow _IO_file_overflow\n+# define _IO_new_file_seekoff _IO_file_seekoff\n+# define _IO_new_file_underflow _IO_file_underflow\n+# define _IO_new_file_write _IO_file_write\n+# define _IO_new_file_xsputn _IO_file_xsputn\n #endif\n \n /* An fstream can be in at most one of put mode, get mode, or putback mode.\n@@ -101,21 +126,21 @@ extern int errno;\n \n \n void\n-_IO_file_init (fp)\n-     _IO_FILE *fp;\n+_IO_new_file_init (fp)\n+     struct _IO_FILE_plus *fp;\n {\n   /* POSIX.1 allows another file handle to be used to change the position\n      of our file descriptor.  Hence we actually don't know the actual\n      position before we do the first fseek (and until a following fflush). */\n-  fp->_offset = _IO_pos_BAD;\n-  fp->_IO_file_flags |= CLOSED_FILEBUF_FLAGS;\n+  fp->file._offset = _IO_pos_BAD;\n+  fp->file._IO_file_flags |= CLOSED_FILEBUF_FLAGS;\n \n-  _IO_link_in(fp);\n-  fp->_fileno = -1;\n+  _IO_link_in (fp);\n+  fp->file._fileno = -1;\n }\n \n int\n-_IO_file_close_it (fp)\n+_IO_new_file_close_it (fp)\n      _IO_FILE *fp;\n {\n   int write_status, close_status;\n@@ -129,20 +154,31 @@ _IO_file_close_it (fp)\n   close_status = _IO_SYSCLOSE (fp);\n \n   /* Free buffer. */\n-  _IO_setb (fp, NULL, NULL, 0);\n-  _IO_setg (fp, NULL, NULL, NULL);\n-  _IO_setp (fp, NULL, NULL);\n+  if (fp->_mode <= 0)\n+    {\n+      _IO_setb (fp, NULL, NULL, 0);\n+      _IO_setg (fp, NULL, NULL, NULL);\n+      _IO_setp (fp, NULL, NULL);\n+    }\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  else\n+    {\n+      _IO_wsetb (fp, NULL, NULL, 0);\n+      _IO_wsetg (fp, NULL, NULL, NULL);\n+      _IO_wsetp (fp, NULL, NULL);\n+    }\n+#endif\n \n-  _IO_un_link (fp);\n+  _IO_un_link ((struct _IO_FILE_plus *) fp);\n   fp->_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;\n-  fp->_fileno = EOF;\n+  fp->_fileno = -1;\n   fp->_offset = _IO_pos_BAD;\n \n   return close_status ? close_status : write_status;\n }\n \n void\n-_IO_file_finish (fp, dummy)\n+_IO_new_file_finish (fp, dummy)\n      _IO_FILE *fp;\n      int dummy;\n {\n@@ -155,27 +191,57 @@ _IO_file_finish (fp, dummy)\n   _IO_default_finish (fp, 0);\n }\n \n-#if _G_IO_IO_FILE_VERSION == 0x20001\n+#if defined __GNUC__ && __GNUC__ >= 2\n+__inline__\n+#endif\n _IO_FILE *\n-_IO_file_fopen (fp, filename, mode, some_int)\n+_IO_file_open (fp, filename, posix_mode, prot, read_write, is32not64)\n      _IO_FILE *fp;\n      const char *filename;\n-     const char *mode;\n-     int some_int;\n+     int posix_mode;\n+     int prot;\n+     int read_write;\n+     int is32not64;\n+{\n+  int fdesc;\n+#ifdef _G_OPEN64\n+  fdesc = (is32not64\n+\t   ? open (filename, posix_mode, prot)\n+\t   : _G_OPEN64 (filename, posix_mode, prot));\n #else\n+  fdesc = open (filename, posix_mode, prot);\n+#endif\n+  if (fdesc < 0)\n+    return NULL;\n+  fp->_fileno = fdesc;\n+  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n+  if (read_write & _IO_IS_APPENDING)\n+    if (_IO_SEEKOFF (fp, (_IO_off64_t)0, _IO_seek_end, _IOS_INPUT|_IOS_OUTPUT)\n+\t== _IO_pos_BAD && errno != ESPIPE)\n+      return NULL;\n+  _IO_link_in ((struct _IO_FILE_plus *) fp);\n+  return fp;\n+}\n+\n _IO_FILE *\n-_IO_file_fopen (fp, filename, mode)\n+_IO_new_file_fopen (fp, filename, mode, is32not64)\n      _IO_FILE *fp;\n      const char *filename;\n      const char *mode;\n-#endif\n+     int is32not64;\n {\n   int oflags = 0, omode;\n-  int read_write, fdesc;\n+  int read_write;\n   int oprot = 0666;\n+  int i;\n+  _IO_FILE *result;\n+#if _LIBC\n+  const char *cs;\n+#endif\n+\n   if (_IO_file_is_open (fp))\n     return 0;\n-  switch (*mode++)\n+  switch (*mode)\n     {\n     case 'r':\n       omode = O_RDONLY;\n@@ -195,26 +261,81 @@ _IO_file_fopen (fp, filename, mode)\n       __set_errno (EINVAL);\n       return NULL;\n     }\n-  if (mode[0] == '+' || (mode[0] == 'b' && mode[1] == '+'))\n+  for (i = 1; i < 4; ++i)\n     {\n-      omode = O_RDWR;\n-      read_write &= _IO_IS_APPENDING;\n+      switch (*++mode)\n+\t{\n+\tcase '\\0':\n+\t  break;\n+\tcase '+':\n+\t  omode = O_RDWR;\n+\t  read_write &= _IO_IS_APPENDING;\n+\t  continue;\n+\tcase 'x':\n+\t  oflags |= O_EXCL;\n+\t  continue;\n+\tcase 'b':\n+\tdefault:\n+\t  /* Ignore.  */\n+\t  continue;\n+\t}\n+      break;\n     }\n-  fdesc = open (filename, omode|oflags, oprot);\n-  if (fdesc < 0)\n-    return NULL;\n-  fp->_fileno = fdesc;\n-  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n-  if (read_write & _IO_IS_APPENDING)\n-    if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_end, _IOS_INPUT|_IOS_OUTPUT)\n-\t== _IO_pos_BAD && errno != ESPIPE)\n-      return NULL;\n-  _IO_link_in (fp);\n-  return fp;\n+\n+  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,\n+\t\t\t  is32not64);\n+\n+\n+#if _LIBC\n+  /* Test whether the mode string specifies the conversion.  */\n+  cs = strstr (mode, \",ccs=\");\n+  if (cs != NULL)\n+    {\n+      /* Yep.  Load the appropriate conversions and set the orientation\n+\t to wide.  */\n+\tstruct gconv_fcts fcts;\n+\tstruct _IO_codecvt *cc;\n+\n+\tif (! _IO_CHECK_WIDE (fp) || __wcsmbs_named_conv (&fcts, cs + 5) != 0)\n+\t  {\n+\t    /* Something went wrong, we cannot load the conversion modules.\n+\t       This means we cannot proceed since the user explicitly asked\n+\t       for these.  */\n+\t    _IO_new_fclose (result);\n+\t    return NULL;\n+\t  }\n+\n+\tcc = &fp->_wide_data->_codecvt;\n+\n+\t/* The functions are always the same.  */\n+\t*cc = __libio_codecvt;\n+\n+\tcc->__cd_in.__cd.__nsteps = 1; /* Only one step allowed.  */\n+\tcc->__cd_in.__cd.__steps = fcts.towc;\n+\n+\tcc->__cd_in.__cd.__data[0].__invocation_counter = 0;\n+\tcc->__cd_in.__cd.__data[0].__internal_use = 1;\n+\tcc->__cd_in.__cd.__data[0].__flags = __GCONV_IS_LAST;\n+\tcc->__cd_in.__cd.__data[0].__statep = &result->_wide_data->_IO_state;\n+\n+\tcc->__cd_out.__cd.__nsteps = 1; /* Only one step allowed.  */\n+\tcc->__cd_out.__cd.__steps = fcts.tomb;\n+\n+\tcc->__cd_out.__cd.__data[0].__invocation_counter = 0;\n+\tcc->__cd_out.__cd.__data[0].__internal_use = 1;\n+\tcc->__cd_out.__cd.__data[0].__flags = __GCONV_IS_LAST;\n+\tcc->__cd_out.__cd.__data[0].__statep = &result->_wide_data->_IO_state;\n+\n+\t/* Set the mode now.  */\n+\tresult->_mode = 1;\n+    }\n+#endif\t/* GNU libc */\n+\n+  return result;\n }\n \n _IO_FILE *\n-_IO_file_attach (fp, fd)\n+_IO_new_file_attach (fp, fd)\n      _IO_FILE *fp;\n      int fd;\n {\n@@ -226,67 +347,79 @@ _IO_file_attach (fp, fd)\n   /* Get the current position of the file. */\n   /* We have to do that since that may be junk. */\n   fp->_offset = _IO_pos_BAD;\n-  if (_IO_SEEKOFF (fp, (_IO_off_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT)\n+  if (_IO_SEEKOFF (fp, (_IO_off64_t)0, _IO_seek_cur, _IOS_INPUT|_IOS_OUTPUT)\n       == _IO_pos_BAD && errno != ESPIPE)\n     return NULL;\n   return fp;\n }\n \n _IO_FILE *\n-_IO_file_setbuf (fp, p, len)\n+_IO_new_file_setbuf (fp, p, len)\n      _IO_FILE *fp;\n      char *p;\n      _IO_ssize_t len;\n {\n-    if (_IO_default_setbuf (fp, p, len) == NULL)\n-      return NULL;\n+  if (_IO_default_setbuf (fp, p, len) == NULL)\n+    return NULL;\n \n-    fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n-      = fp->_IO_buf_base;\n-    _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n+    = fp->_IO_buf_base;\n+  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n \n-    return fp;\n+  return fp;\n }\n \n+static int new_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n+\n /* Write TO_DO bytes from DATA to FP.\n    Then mark FP as having empty buffers. */\n \n int\n-_IO_do_write (fp, data, to_do)\n+_IO_new_do_write (fp, data, to_do)\n+     _IO_FILE *fp;\n+     const char *data;\n+     _IO_size_t to_do;\n+{\n+  return (to_do == 0 || new_do_write (fp, data, to_do) == to_do)\n+  \t ? 0 : EOF;\n+}\n+\n+static\n+int\n+new_do_write (fp, data, to_do)\n      _IO_FILE *fp;\n      const char *data;\n      _IO_size_t to_do;\n {\n   _IO_size_t count;\n-  if (to_do == 0)\n-    return 0;\n   if (fp->_flags & _IO_IS_APPENDING)\n     /* On a system without a proper O_APPEND implementation,\n-       you would need to sys_seek(0, SEEK_END) here, but it\n+       you would need to sys_seek(0, SEEK_END) here, but is\n        is not needed nor desirable for Unix- or Posix-like systems.\n        Instead, just indicate that offset (before and after) is\n        unpredictable. */\n     fp->_offset = _IO_pos_BAD;\n   else if (fp->_IO_read_end != fp->_IO_write_base)\n     {\n-      _IO_pos_t new_pos\n+      _IO_off64_t new_pos\n \t= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n       if (new_pos == _IO_pos_BAD)\n-\treturn EOF;\n+\treturn 0;\n       fp->_offset = new_pos;\n     }\n   count = _IO_SYSWRITE (fp, data, to_do);\n-  if (fp->_cur_column)\n-    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, to_do) + 1;\n+  if (fp->_cur_column && count)\n+    fp->_cur_column = _IO_adjust_column (fp->_cur_column - 1, data, count) + 1;\n   _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n   fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_buf_base;\n-  fp->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n+  fp->_IO_write_end = (fp->_mode < 0\n+\t\t       && (fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n \t\t       ? fp->_IO_buf_base : fp->_IO_buf_end);\n-  return count != to_do ? EOF : 0;\n+  return count;\n }\n \n int\n-_IO_file_underflow (fp)\n+_IO_new_file_underflow (fp)\n      _IO_FILE *fp;\n {\n   _IO_ssize_t count;\n@@ -298,14 +431,23 @@ _IO_file_underflow (fp)\n \n   if (fp->_flags & _IO_NO_READS)\n     {\n+      fp->_flags |= _IO_ERR_SEEN;\n       __set_errno (EBADF);\n       return EOF;\n     }\n   if (fp->_IO_read_ptr < fp->_IO_read_end)\n     return *(unsigned char *) fp->_IO_read_ptr;\n \n   if (fp->_IO_buf_base == NULL)\n-    _IO_doallocbuf (fp);\n+    {\n+      /* Maybe we already have a push back pointer.  */\n+      if (fp->_IO_save_base != NULL)\n+\t{\n+\t  free (fp->_IO_save_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n+      _IO_doallocbuf (fp);\n+    }\n \n   /* Flush all line buffered files before reading. */\n   /* FIXME This can/should be moved to genops ?? */\n@@ -341,7 +483,7 @@ _IO_file_underflow (fp)\n }\n \n int\n-_IO_file_overflow (f, ch)\n+_IO_new_file_overflow (f, ch)\n       _IO_FILE *f;\n       int ch;\n {\n@@ -352,7 +494,7 @@ _IO_file_overflow (f, ch)\n       return EOF;\n     }\n   /* If currently reading or no buffer allocated. */\n-  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n+  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == 0)\n     {\n       /* Allocate a buffer if needed. */\n       if (f->_IO_write_base == 0)\n@@ -374,32 +516,32 @@ _IO_file_overflow (f, ch)\n       f->_IO_write_end = f->_IO_buf_end;\n       f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n \n-      if (f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n-\tf->_IO_write_end = f->_IO_write_ptr;\n       f->_flags |= _IO_CURRENTLY_PUTTING;\n+      if (f->_mode < 0 && f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n+\tf->_IO_write_end = f->_IO_write_ptr;\n     }\n   if (ch == EOF)\n-    return _IO_do_flush (f);\n+    return _IO_new_do_write(f, f->_IO_write_base,\n+\t\t\t    f->_IO_write_ptr - f->_IO_write_base);\n   if (f->_IO_write_ptr == f->_IO_buf_end ) /* Buffer is really full */\n     if (_IO_do_flush (f) == EOF)\n       return EOF;\n   *f->_IO_write_ptr++ = ch;\n   if ((f->_flags & _IO_UNBUFFERED)\n       || ((f->_flags & _IO_LINE_BUF) && ch == '\\n'))\n-    if (_IO_do_flush (f) == EOF)\n+    if (_IO_new_do_write(f, f->_IO_write_base,\n+\t\t\t f->_IO_write_ptr - f->_IO_write_base) == EOF)\n       return EOF;\n   return (unsigned char) ch;\n }\n \n int\n-_IO_file_sync (fp)\n+_IO_new_file_sync (fp)\n      _IO_FILE *fp;\n {\n-  _IO_size_t delta;\n+  _IO_ssize_t delta;\n   int retval = 0;\n \n-  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n-  _IO_flockfile (fp);\n   /*    char* ptr = cur_ptr(); */\n   if (fp->_IO_write_ptr > fp->_IO_write_base)\n     if (_IO_do_flush(fp)) return EOF;\n@@ -410,8 +552,8 @@ _IO_file_sync (fp)\n       if (_IO_in_backup (fp))\n \tdelta -= eGptr () - Gbase ();\n #endif\n-      _IO_off_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n-      if (new_pos != (_IO_off_t) EOF)\n+      _IO_off64_t new_pos = _IO_SYSSEEK (fp, delta, 1);\n+      if (new_pos != (_IO_off64_t) EOF)\n \tfp->_IO_read_end = fp->_IO_read_ptr;\n #ifdef ESPIPE\n       else if (errno == ESPIPE)\n@@ -424,28 +566,18 @@ _IO_file_sync (fp)\n     fp->_offset = _IO_pos_BAD;\n   /* FIXME: Cleanup - can this be shared? */\n   /*    setg(base(), ptr, ptr); */\n-  _IO_cleanup_region_end (1);\n   return retval;\n }\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n _IO_off64_t\n-_IO_file_seekoff (fp, offset, dir, mode)\n+_IO_new_file_seekoff (fp, offset, dir, mode)\n      _IO_FILE *fp;\n      _IO_off64_t offset;\n      int dir;\n      int mode;\n-#else\n-_IO_off_t\n-_IO_file_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-     int mode;\n-#endif\n {\n-  _IO_pos_t result;\n-  _IO_off_t delta, new_offset;\n+  _IO_off64_t result;\n+  _IO_off64_t delta, new_offset;\n   long count;\n   /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n      offset of the underlying file must be exact.  */\n@@ -469,6 +601,12 @@ _IO_file_seekoff (fp, offset, dir, mode)\n \n   if (fp->_IO_buf_base == NULL)\n     {\n+      /* It could be that we already have a pushback buffer.  */\n+      if (fp->_IO_read_base != NULL)\n+\t{\n+\t  free (fp->_IO_read_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n       _IO_doallocbuf (fp);\n       _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n       _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n@@ -482,15 +620,15 @@ _IO_file_seekoff (fp, offset, dir, mode)\n       if (fp->_offset == _IO_pos_BAD)\n \tgoto dumb;\n       /* Make offset absolute, assuming current pointer is file_ptr(). */\n-      offset += _IO_pos_as_off (fp->_offset);\n+      offset += fp->_offset;\n \n       dir = _IO_seek_set;\n       break;\n     case _IO_seek_set:\n       break;\n     case _IO_seek_end:\n       {\n-\tstruct stat st;\n+\tstruct _G_stat64 st;\n \tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n \t  {\n \t    offset += st.st_size;\n@@ -502,13 +640,17 @@ _IO_file_seekoff (fp, offset, dir, mode)\n     }\n   /* At this point, dir==_IO_seek_set. */\n \n+  /* If we are only interested in the current position we've found it now.  */\n+  if (mode == 0)\n+    return offset;\n+\n   /* If destination is within current buffer, optimize: */\n   if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n       && !_IO_in_backup (fp))\n     {\n       /* Offset relative to start of main get area. */\n-      _IO_pos_t rel_offset = (offset - fp->_offset\n-\t\t\t      + (fp->_IO_read_end - fp->_IO_read_base));\n+      _IO_off64_t rel_offset = (offset - fp->_offset\n+\t\t\t\t+ (fp->_IO_read_end - fp->_IO_read_base));\n       if (rel_offset >= 0)\n \t{\n #if 0\n@@ -520,7 +662,10 @@ _IO_file_seekoff (fp, offset, dir, mode)\n \t      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + rel_offset,\n \t\t\tfp->_IO_read_end);\n \t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n-\t      return offset;\n+\t      {\n+\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t\tgoto resync;\n+\t      }\n \t    }\n #ifdef TODO\n \t    /* If we have streammarkers, seek forward by reading ahead. */\n@@ -530,7 +675,8 @@ _IO_file_seekoff (fp, offset, dir, mode)\n \t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n \t\tif (ignore (to_skip) != to_skip)\n \t\t  goto dumb;\n-\t\treturn offset;\n+\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t\tgoto resync;\n \t      }\n #endif\n \t}\n@@ -540,7 +686,8 @@ _IO_file_seekoff (fp, offset, dir, mode)\n \t  if (!_IO_in_backup (fp))\n \t    _IO_switch_to_backup_area (fp);\n \t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n-\t  return offset;\n+\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t  goto resync;\n \t}\n #endif\n     }\n@@ -589,11 +736,23 @@ _IO_file_seekoff (fp, offset, dir, mode)\n   _IO_unsave_markers (fp);\n   result = _IO_SYSSEEK (fp, offset, dir);\n   if (result != EOF)\n-    _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n-  fp->_offset = result;\n-  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n-  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+    {\n+      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+      fp->_offset = result;\n+      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+    }\n   return result;\n+\n+resync:\n+  /* We need to do it since it is possible that the file offset in\n+     the kernel may be changed behind our back. It may happen when\n+     we fopen a file and then do a fork. One process may access the\n+     the file and the kernel file offset will be changed. */\n+  if (fp->_offset >= 0)\n+    _IO_SYSSEEK (fp, fp->_offset, 0);\n+\n+  return offset;\n }\n \n _IO_ssize_t\n@@ -605,29 +764,29 @@ _IO_file_read (fp, buf, size)\n   return read (fp->_fileno, buf, size);\n }\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n _IO_off64_t\n _IO_file_seek (fp, offset, dir)\n      _IO_FILE *fp;\n      _IO_off64_t offset;\n      int dir;\n-#else\n-_IO_off_t\n-_IO_file_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-#endif\n {\n+#ifdef _G_LSEEK64\n+  return _G_LSEEK64 (fp->_fileno, offset, dir);\n+#else\n   return lseek (fp->_fileno, offset, dir);\n+#endif\n }\n \n int\n _IO_file_stat (fp, st)\n      _IO_FILE *fp;\n      void *st;\n {\n+#ifdef _G_FSTAT64\n+  return _G_FSTAT64 (fp->_fileno, (struct _G_stat64 *) st);\n+#else\n   return fstat (fp->_fileno, (struct stat *) st);\n+#endif\n }\n \n int\n@@ -638,7 +797,7 @@ _IO_file_close (fp)\n }\n \n _IO_ssize_t\n-_IO_file_write (f, data, n)\n+_IO_new_file_write (f, data, n)\n      _IO_FILE *f;\n      const void *data;\n      _IO_ssize_t n;\n@@ -647,7 +806,7 @@ _IO_file_write (f, data, n)\n   while (to_do > 0)\n     {\n       _IO_ssize_t count = write (f->_fileno, data, to_do);\n-      if (count == EOF)\n+      if (count < 0)\n \t{\n \t  f->_flags |= _IO_ERR_SEEN;\n \t  break;\n@@ -662,12 +821,12 @@ _IO_file_write (f, data, n)\n }\n \n _IO_size_t\n-_IO_file_xsputn (f, data, n)\n+_IO_new_file_xsputn (f, data, n)\n      _IO_FILE *f;\n      const void *data;\n      _IO_size_t n;\n {\n-  register const char *s = (char *) data;\n+  register const char *s = (const char *) data;\n   _IO_size_t to_do = n;\n   int must_flush = 0;\n   _IO_size_t count;\n@@ -704,7 +863,12 @@ _IO_file_xsputn (f, data, n)\n \tcount = to_do;\n       if (count > 20)\n \t{\n+#ifdef _LIBC\n+\t  f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n+#else\n \t  memcpy (f->_IO_write_ptr, s, count);\n+\t  f->_IO_write_ptr += count;\n+#endif\n \t  s += count;\n \t}\n       else\n@@ -713,125 +877,174 @@ _IO_file_xsputn (f, data, n)\n \t  register int i = (int) count;\n \t  while (--i >= 0)\n \t    *p++ = *s++;\n+\t  f->_IO_write_ptr = p;\n \t}\n-      f->_IO_write_ptr += count;\n       to_do -= count;\n     }\n   if (to_do + must_flush > 0)\n     {\n-      _IO_size_t block_size, dont_write;\n+      _IO_size_t block_size, do_write;\n       /* Next flush the (full) buffer. */\n-      if (__overflow (f, EOF) == EOF)\n+      if (_IO_OVERFLOW (f, EOF) == EOF)\n \treturn n - to_do;\n \n       /* Try to maintain alignment: write a whole number of blocks.\n \t dont_write is what gets left over. */\n       block_size = f->_IO_buf_end - f->_IO_buf_base;\n-      dont_write = block_size >= 128 ? to_do % block_size : 0;\n-\n-      count = to_do - dont_write;\n-      if (_IO_do_write (f, s, count) == EOF)\n-\treturn n - to_do;\n-      to_do = dont_write;\n+      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n+\n+      if (do_write)\n+        {\n+\t  count = new_do_write (f, s, do_write);\n+\t  to_do -= count;\n+\t  if (count < do_write)\n+\t    return n - to_do;\n+        }\n \n       /* Now write out the remainder.  Normally, this will fit in the\n \t buffer, but it's somewhat messier for line-buffered files,\n \t so we let _IO_default_xsputn handle the general case. */\n-      if (dont_write)\n-\tto_do -= _IO_default_xsputn (f, s+count, dont_write);\n+      if (to_do)\n+\tto_do -= _IO_default_xsputn (f, s+do_write, to_do);\n     }\n   return n - to_do;\n }\n \n-#if 0\n-/* Work in progress */\n _IO_size_t\n _IO_file_xsgetn (fp, data, n)\n      _IO_FILE *fp;\n      void *data;\n      _IO_size_t n;\n {\n-  register _IO_size_t more = n;\n+  register _IO_size_t want, have;\n+  register _IO_ssize_t count;\n   register char *s = data;\n-  for (;;)\n+\n+  want = n;\n+\n+  if (fp->_IO_buf_base == NULL)\n+    {\n+      /* Maybe we already have a push back pointer.  */\n+      if (fp->_IO_save_base != NULL)\n+\t{\n+\t  free (fp->_IO_save_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n+      _IO_doallocbuf (fp);\n+    }\n+\n+  while (want > 0)\n     {\n-      /* Data available. */\n-      _IO_ssize_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n-      if (count > 0)\n+      have = fp->_IO_read_end - fp->_IO_read_ptr;\n+      if (want <= have)\n \t{\n-\t  if (count > more)\n-\t    count = more;\n-\t  if (count > 20)\n+\t  memcpy (s, fp->_IO_read_ptr, want);\n+\t  fp->_IO_read_ptr += want;\n+\t  want = 0;\n+\t}\n+      else\n+\t{\n+\t  if (have > 0)\n \t    {\n-\t      memcpy (s, fp->_IO_read_ptr, count);\n-\t      s += count;\n-\t      fp->_IO_read_ptr += count;\n+#ifdef _LIBC\n+\t      s = __mempcpy (s, fp->_IO_read_ptr, have);\n+#else\n+\t      memcpy (s, fp->_IO_read_ptr, have);\n+\t      s += have;\n+#endif\n+\t      want -= have;\n+\t      fp->_IO_read_ptr += have;\n \t    }\n-\t  else if (count <= 0)\n-\t    count = 0;\n-\t  else\n+\n+\t  /* Check for backup and repeat */\n+\t  if (_IO_in_backup (fp))\n \t    {\n-\t      register char *p = fp->_IO_read_ptr;\n-\t      register int i = (int) count;\n-\t      while (--i >= 0)\n-\t\t*s++ = *p++;\n-\t      fp->_IO_read_ptr = p;\n-            }\n-            more -= count;\n-        }\n-#if 0\n-      if (! _IO_in put_mode (fp)\n-\t  && ! _IO_have_markers (fp) && ! IO_have_backup (fp))\n-\t{\n-\t  /* This is an optimization of _IO_file_underflow */\n-\t  if (fp->_flags & _IO_NO_READS)\n-\t    break;\n-\t  /* If we're reading a lot of data, don't bother allocating\n-\t     a buffer.  But if we're only reading a bit, perhaps we should ??*/\n-\t  if (count <= 512 && fp->_IO_buf_base == NULL)\n-\t    _IO_doallocbuf (fp);\n-\t  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n-\t    _IO_flush_all_linebuffered ();\n-\n-\t  _IO_switch_to_get_mode (fp); ???;\n-\t  count = _IO_SYSREAD (fp, s, more);\n+\t      _IO_switch_to_main_get_area (fp);\n+\t      continue;\n+\t    }\n+\n+\t  /* If we now want less than a buffer, underflow and repeat\n+\t     the copy.  Otherwise, _IO_SYSREAD directly to\n+\t     the user buffer. */\n+\t  if (fp->_IO_buf_base && want < fp->_IO_buf_end - fp->_IO_buf_base)\n+\t    {\n+\t      if (__underflow (fp) == EOF)\n+\t\tbreak;\n+\n+\t      continue;\n+\t    }\n+\n+\t  /* These must be set before the sysread as we might longjmp out\n+\t     waiting for input. */\n+\t  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+\t  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+\n+\t  /* Try to maintain alignment: read a whole number of blocks.  */\n+\t  count = want;\n+\t  if (fp->_IO_buf_base)\n+\t    {\n+\t      _IO_size_t block_size = fp->_IO_buf_end - fp->_IO_buf_base;\n+\t      if (block_size >= 128)\n+\t\tcount -= want % block_size;\n+\t    }\n+\n+\t  count = _IO_SYSREAD (fp, s, count);\n \t  if (count <= 0)\n-\t     {\n-\t       if (count == 0)\n-\t\t fp->_flags |= _IO_EOF_SEEN;\n-\t       else\n-\t\t fp->_flags |= _IO_ERR_SEEN, count = 0;\n-\t     }\n+\t    {\n+\t      if (count == 0)\n+\t\tfp->_flags |= _IO_EOF_SEEN;\n+\t      else\n+\t\tfp->_flags |= _IO_ERR_SEEN;\n+\n+\t      break;\n+\t    }\n \n \t  s += count;\n-\t  more -= count;\n+\t  want -= count;\n+\t  if (fp->_offset != _IO_pos_BAD)\n+\t    _IO_pos_adjust (fp->_offset, count);\n \t}\n-#endif\n-      if (more == 0 || __underflow (fp) == EOF)\n-\tbreak;\n     }\n-  return n - more;\n+\n+  return n - want;\n }\n-#endif\n \n struct _IO_jump_t _IO_file_jumps =\n {\n   JUMP_INIT_DUMMY,\n-  JUMP_INIT(finish, _IO_file_finish),\n-  JUMP_INIT(overflow, _IO_file_overflow),\n-  JUMP_INIT(underflow, _IO_file_underflow),\n+  JUMP_INIT(finish, _IO_new_file_finish),\n+  JUMP_INIT(overflow, _IO_new_file_overflow),\n+  JUMP_INIT(underflow, _IO_new_file_underflow),\n   JUMP_INIT(uflow, _IO_default_uflow),\n   JUMP_INIT(pbackfail, _IO_default_pbackfail),\n-  JUMP_INIT(xsputn, _IO_file_xsputn),\n-  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n-  JUMP_INIT(seekoff, _IO_file_seekoff),\n+  JUMP_INIT(xsputn, _IO_new_file_xsputn),\n+  JUMP_INIT(xsgetn, _IO_file_xsgetn),\n+  JUMP_INIT(seekoff, _IO_new_file_seekoff),\n   JUMP_INIT(seekpos, _IO_default_seekpos),\n-  JUMP_INIT(setbuf, _IO_file_setbuf),\n-  JUMP_INIT(sync, _IO_file_sync),\n+  JUMP_INIT(setbuf, _IO_new_file_setbuf),\n+  JUMP_INIT(sync, _IO_new_file_sync),\n   JUMP_INIT(doallocate, _IO_file_doallocate),\n   JUMP_INIT(read, _IO_file_read),\n-  JUMP_INIT(write, _IO_file_write),\n+  JUMP_INIT(write, _IO_new_file_write),\n   JUMP_INIT(seek, _IO_file_seek),\n   JUMP_INIT(close, _IO_file_close),\n-  JUMP_INIT(stat, _IO_file_stat)\n+  JUMP_INIT(stat, _IO_file_stat),\n+  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n+  JUMP_INIT(imbue, _IO_default_imbue)\n };\n+\n+#ifdef _LIBC\n+versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);\n+versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);\n+#endif"}, {"sha": "6c07b46b36bf97a6b5a60ca46aba768bd496a485", "filename": "libstdc++-v3/libio/gen-params", "status": "removed", "additions": 0, "deletions": 751, "changes": 751, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dee4095a023e08b724ff60729643a62639cb43b6/libstdc%2B%2B-v3%2Flibio%2Fgen-params", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dee4095a023e08b724ff60729643a62639cb43b6/libstdc%2B%2B-v3%2Flibio%2Fgen-params", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fgen-params?ref=dee4095a023e08b724ff60729643a62639cb43b6", "patch": "@@ -1,751 +0,0 @@\n-#!/bin/sh\n-# Copyright (C) 1992, 1993, 1994, 1997, 1998, 1999 Free Software Foundation\n-# \n-# This file is part of the GNU IO Library.  This library is free\n-# software; you can redistribute it and/or modify it under the\n-# terms of the GNU General Public License as published by the\n-# Free Software Foundation; either version 2, or (at your option)\n-# any later version.\n-# \n-# This library is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this library; see the file COPYING.  If not, write to the Free\n-# Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n-\n-#    Written by Per Bothner (bothner@cygnus.com)\n-\n-# This is a shell-script that figures out various things about a\n-# system, and writes (to stdout) a C-style include files with\n-# suitable definitions, including all the standard Posix types.\n-# It works by compiling various test programs -- some are run through\n-# the C pre-processor, and the output examined.\n-# The test programs are only compiled, not executed, so the script\n-# should even if you're cross-compiling.\n-# It uses $CC (which defaults to cc) to compile C programs (extension .c),\n-# and $CXX (which defaults to gcc) to compile C++ programs (extension .C).\n-# The shell-script is written for libg++.a.\n-\n-# Usage: gen-params [NAME1=name1 ...]\n-# - where an assignment (such as size_t=\"unsigned int\" means to\n-# use that value, instead of trying to figure it out.\n-\n-# Uncomment following line for debugging\n-# set -x\n-\n-SED=sed\n-\n-# Evaluate the arguments (which should be assignments):\n-for arg in \"$@\"; do\n-  # Quote arg (i.e. FOO=bar => FOO='bar'), then eval it.\n-  eval `echo \"$arg\" | ${SED} -e \"s|^\\(.*\\)=\\(.*\\)|\\1='\\2'|\"`\n-done\n-\n-macro_prefix=${macro_prefix-\"_G_\"}\n-rootdir=`pwd`/..\n-gccdir=${gccdir-${rootdir}/gcc}\n-binutilsdir=${binutilsdir-${rootdir}/binutils}\n-CC=${CC-`if [ -f ${gccdir}/xgcc ] ; \\\n-\tthen echo ${gccdir}/xgcc -B${gccdir}/ ; \\\n-\telse echo cc ; fi`}\n-CXX=${CXX-`if [ -f ${gccdir}/xgcc ] ; \\\n-\tthen echo ${gccdir}/xgcc -B${gccdir}/ ; \\\n-\telse echo gcc ; fi`}\n-CPP=${CPP-`echo ${CC} -E`}\n-CONFIG_NM=${CONFIG_NM-`if [ -f ${binutilsdir}/nm.new ] ; \\\n-\tthen echo ${binutilsdir}/nm.new ; \\\n-\telse echo nm ; fi`}\n-\n-# 2000-02-20 bkoz\n-# Eventually use AC_CHECK_PROG(NM,nm,nm) instead of this hackery.\n-# For now, as solaris and cygwin seem to require this, hardwire it.\n-if test -z \"$CONFIG_NM\"; then\n-  CONFIG_NM=nm\n-fi\n-\n-cat <<!EOF!\n-/* AUTOMATICALLY GENERATED; DO NOT EDIT! */ \n-#ifndef ${macro_prefix}config_h\n-#define ${macro_prefix}config_h\n-!EOF!\n-\n-if [ x\"${LIB_VERSION}\" != \"x\" ] ; then\n-  echo \"#define ${macro_prefix}LIB_VERSION\" '\"'${LIB_VERSION}'\"'\n-fi\n-\n-# This program is used to test if the compiler prepends '_' before identifiers.\n-# It is also used to check the g++ uses '$' or '.' various places.\n-\n-if test -z \"${NAMES_HAVE_UNDERSCORE}\" \\\n-   || test -z \"${DOLLAR_IN_LABEL}\" \\\n-   || test -z \"${VTABLE_LABEL_PREFIX}\"; then\n-  cat >dummy.h <<!EOF!\n-#ifdef __GNUG__\n-#pragma interface\n-#endif\n-  struct filebuf {\n-      virtual int foo();\n-  };\n-!EOF!\n-  cat >dummy.C <<!EOF!\n-#ifdef __GNUG__\n-#pragma implementation\n-#endif\n-#include \"dummy.h\"\n-  int filebuf::foo() { return 0; }\n-  extern \"C\" int FUNC(int);\n-  int FUNC(int i) { return i+10; }\n-!EOF!\n-\n-  if ${CXX} -O -c dummy.C ; then\n-    if test -z \"${NAMES_HAVE_UNDERSCORE}\" ; then\n-      if test \"`${CONFIG_NM} dummy.o | grep _FUNC`\" != \"\"; then\n-        NAMES_HAVE_UNDERSCORE=1\n-      elif test \"`${CONFIG_NM} dummy.o | grep FUNC`\" != \"\"; then\n-        NAMES_HAVE_UNDERSCORE=0\n-      else\n-        echo \"${CONFIG_NM} failed to find FUNC in dummy.o!\" 1>&2; exit -1;\n-      fi\n-    fi\n-    echo \"#define ${macro_prefix}NAMES_HAVE_UNDERSCORE ${NAMES_HAVE_UNDERSCORE}\"\n-\n-    if test -z \"${VTABLE_LABEL_PREFIX}\" ; then\n-      # Determine how virtual function tables are named.  This is fragile,\n-      # because different nm's produce output in different formats.\n-      ${CONFIG_NM} dummy.o >TMP\n-      if [ -n \"`${SED} -n -e 's/ virtual table/nope/p' <TMP`\" ] ; then\n-\t${CONFIG_NM} --no-cplus dummy.o >TMP 2>/dev/null ||\n-\t  ${CONFIG_NM} --no-demangle dummy.o >TMP 2>/dev/null ||\n-\t  ${CONFIG_NM} dummy.o >TMP 2>/dev/null\n-      fi\n-      # First we look for a pattern that matches historical output from g++.\n-      # We surround the actual label name by <> to separate it from\n-      # other nm junk. \n-      ${SED} -n -e 's/_*vt[$_.]7*filebuf/<&>/p' <TMP >dummy.out\n-      # For paranoia's sake (e.g. if we're using some other C++ compiler)\n-      # we try a more general pattern, and append the result.\n-      grep -v foo <TMP \\\n-\t| ${SED} -n -e 's/[a-zA-Z0-9_.$]*filebuf[a-zA-Z0-9_.$]*/<&>/p' \\\n-\t>>dummy.out\n-      # Now we get rid of the <>, and any other junk on the nm output line.\n-      # (We get rid of <filebuf> in case nm included debugging output for\n-      # class filebuf itself.)  On windows32, we also need to delete the \n-      # unique sections (.data$_vt$*), otherwise we get the wrong result.\n-      # Finally, we select the first line of the result, and hope that's \n-      # what we wanted!\n-      vtab_name=`${SED} -n -e '/<filebuf>/d' \\\n-        -e '/\\.data[$_.]<_vt\\$7filebuf>/d' \\\n-        -e 's/^.*<\\(.*\\)>.*$/\\1/p' \\\n-        <dummy.out | ${SED} -n -e '1p'`\n-      case \"${vtab_name}\" in\n-        *7filebuf) echo \"#define ${macro_prefix}VTABLE_LABEL_HAS_LENGTH 1\" ;;\n-        *) echo \"#define ${macro_prefix}VTABLE_LABEL_HAS_LENGTH 0\" ;;\n-      esac\n-      VTABLE_LABEL_PREFIX=`echo $vtab_name | ${SED} -e 's/7*filebuf//'`\n-    fi\n-    echo \"#define ${macro_prefix}VTABLE_LABEL_PREFIX\" '\"'\"${VTABLE_LABEL_PREFIX}\"'\"'\n-    if [ \"${VTABLE_LABEL_PREFIX}\" = \"__vt_\" -o \\\n-        \"${VTABLE_LABEL_PREFIX}\" = \"___vt_\" ] ; then\n-      echo \"#define ${macro_prefix}USING_THUNKS\"\n-    fi\n-\n-    # VTABLE_LABEL_PREFIX_ID is the same as VTABLE_LABEL_PREFIX,\n-    # but the former is a C identifier, while the latter is a quoted\n-    # st\n-    if [ -z \"\"`echo ${VTABLE_LABEL_PREFIX} | ${SED} -e 's/[a-zA-Z0-9_]//g'` ] ; then\n-      if [ \"${NAMES_HAVE_UNDERSCORE}\" = \"1\" ] ; then\n-\tVTABLE_LABEL_PREFIX=`echo ${VTABLE_LABEL_PREFIX} | ${SED} -e 's/^_//'`\n-      fi\n-      echo \"#define ${macro_prefix}VTABLE_LABEL_PREFIX_ID ${VTABLE_LABEL_PREFIX}\"\n-    fi\n-\n-#    if test -n \"${DOLLAR_IN_LABEL}\" ; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL ${DOLLAR_IN_LABEL}\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vt[$$]7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 1\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vt[.]7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 0\"\n-#    elif test \"`${CONFIG_NM} dummy.o | grep 'vtbl__7filebuf'`\" != \"\"; then\n-#      echo \"#define ${macro_prefix}DOLLAR_IN_LABEL 0\"\n-#    else\n-#      echo \"gen-params: ${CONFIG_NM} failed to find vt[.\\$]filebuf in dummy.o!\" 1>&2; exit 1\n-#    fi\n-  else\n-    # The compile failed for some reason (no C++?)\n-    echo \"gen-params: could not compile dummy.C with ${CXX}\" 1>&2; exit 1;\n-  fi\n-fi\n-\n-# A little test program to check if struct stat has st_blksize.\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-int BLKSIZE(struct stat *st)\n-{\n-    return st->st_blksize;\n-}\n-!EOF!\n-\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}HAVE_ST_BLKSIZE 1\"\n-else\n-  echo \"#define ${macro_prefix}HAVE_ST_BLKSIZE 0\"\n-fi\n-\n-# A little test program to check if the name 'clog' is defined in libm,\n-# as it is under DEC UNIX.\n-cat >dummy.c <<!EOF!\n-int clog;\n-main () {}\n-!EOF!\n-\n-if ${CC} dummy.c -lm 2>&1 >/dev/null | grep clog >/dev/null; then\n-  echo \"#define ${macro_prefix}CLOG_CONFLICT 1\"\n-fi\n-\n-echo \"\"\n-\n-# Next, generate definitions for the standard types (such as mode_t)\n-# compatible with those in the standard C header files.\n-# It works by a dummy program through the C pre-processor, and then\n-# using sed to search for typedefs in the output.\n-\n-for hdr in wchar wctype; do\n-  eval $hdr=0\n-  cat >dummy.c <<EOF\n-#include <${hdr}.h>\n-EOF\n-  if ${CPP} dummy.c >/dev/null 2>&1 ; then eval $hdr=1; fi\n-done\n-\n-cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <stddef.h>\n-#ifdef __STDC__\n-#include <stdarg.h>\n-#else /* !__STDC__ */\n-#include <varargs.h>\n-#endif /* __STDC__ */\n-#include <stdio.h>\n-#include <time.h>\n-#include <signal.h>\n-#ifdef __STDC__\n-#include <limits.h>\n-#endif\n-#if WCHAR == 1\n-#include <wchar.h>\n-#endif\n-#if WCTYPE == 1\n-#include <wctype.h>\n-#endif\n-#ifdef size_t\n-typedef size_t Xsize_t;\n-#elif defined(__SIZE_TYPE__)\n-typedef __SIZE_TYPE__ Xsize_t;\n-#endif\n-#ifdef ptrdiff_t\n-typedef ptrdiff_t Xptrdiff_t;\n-#elif defined(__PTRDIFF_TYPE__)\n-typedef __PTRDIFF_TYPE__ Xptrdiff_t;\n-#endif\n-#ifdef wchar_t\n-typedef wchar_t Xwchar_t;\n-#elif defined(__WCHAR_TYPE__)\n-typedef __WCHAR_TYPE__ Xwchar_t;\n-#endif\n-#ifdef va_list\n-typedef va_list XXXva_list;\n-#endif\n-#ifdef BUFSIZ\n-long XBUFSIZ=BUFSIZ;\n-#endif\n-#ifdef FOPEN_MAX\n-long XFOPEN_MAX=FOPEN_MAX;\n-#endif\n-#ifdef FILENAME_MAX\n-long XFILENAME_MAX=FILENAME_MAX;\n-#endif\n-#ifdef SHRT_MAX\n-long XSHRT_MAX=SHRT_MAX;\n-#endif\n-#ifdef INT_MAX\n-long XINT_MAX=INT_MAX;\n-#endif\n-#ifdef LONG_MAX\n-long XLONG_MAX=LONG_MAX;\n-#endif\n-#ifdef LONG_LONG_MAX\n-long XLONG_LONG_MAX=LONG_LONG_MAX;\n-#endif\n-!EOF!\n-\n-if ${CPP} dummy.c -DWCHAR=$wchar -DWCTYPE=$wctype >TMP ; then true\n-else\n-  echo \"gen-params: could not invoke ${CPP} on dummy.c\" 1>&2 ; exit 1\n-fi\n-tr '\t' ' ' <TMP >dummy.out\n-\n-for TYPE in dev_t clock_t fpos_t gid_t ino_t mode_t nlink_t off_t pid_t ptrdiff_t sigset_t size_t ssize_t time_t uid_t va_list wchar_t wint_t int16_t uint16_t int32_t uint_32_t u_int16_t u_int32_t; do\n-    eval IMPORTED=\\$$TYPE\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$TYPE='$IMPORTED'\"\n-    else\n-\tt=$TYPE\n-\tVALUE=''\n-\n-\t# Follow `typedef VALUE TYPE' chains, but don't loop indefinitely.\n-\tfor iteration in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20; do\n-\t    # Search dummy.out for a typedef for X*$t.\n-\t    sed_script=\"\n-\t\ts/unsigned long long int/_G_ullong/g\n-\t\ts/long long int/_G_llong/g\n-\t\ts/unsigned long long/_G_ullong/g\n-\t\ts/long long/_G_llong/g\n-\t\t/.*typedef  *\\\\(.*[^ ]\\\\)  *X*$t *;.*/{s||\\1|;p;q;}\n-\t\t/.*typedef  *\\\\(.*[^ a-zA-Z0-9_]\\\\)X*$t *;.*/{s||\\1|;p;q;}\n-\t    \"\n-\t    t=`${SED} -n \"$sed_script\" <dummy.out`\n-\t    case \"$t\" in\n-\t      '')\n-\t\tbreak;;\n-\t      *)\n-\t\t# Found a type $t; save it in VALUE.\n-\t\tVALUE=$t\n-\t\t# If it won't cause problems in matching,\n-\t\t# look for a typedef for it in turn.\n-\t\tcase \"$VALUE\" in\n-\t\t  *.* | */* | *\\ * | *\\** | *\\[* | *\\\\*) break;;\n-\t\tesac;;\n-\t    esac\n-\tdone\n-\n-\tcase \"$VALUE\" in\n-\t  ?*) eval \"$TYPE=\\\"$VALUE\\\"\"\n-\tesac\n-    fi\n-done\n-\n-# Look for some standard macros.\n-for NAME in BUFSIZ FOPEN_MAX FILENAME_MAX NULL; do\n-    eval IMPORTED=\\$$NAME\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$NAME='$IMPORTED /* specified */'\"\n-    else\n-\trm -f TMP\n-\t${SED} -n -e 's| *;|;|g' -e \"s|long X${NAME}= *\\(.*\\);|\\1|w TMP\" \\\n-\t  <dummy.out>/dev/null\n-\t# Now select the first definition.\n-\tif [ -s TMP ]; then\n-\t    eval \"$NAME='\"`${SED} -e '2,$d' <TMP`\"'\"\n-\tfi\n-    fi\n-done\n-\n-# These macros must be numerical constants; strip any trailing 'L's.\n-for NAME in SHRT_MAX INT_MAX LONG_MAX LONG_LONG_MAX; do\n-    eval IMPORTED=\\$$NAME\n-    if [ -n \"${IMPORTED}\" ] ; then\n-\teval \"$NAME='$IMPORTED /* specified */'\"\n-    else\n-\trm -f TMP\n-\t${SED} -n -e 's| *;|;|g' -e \"s|long X${NAME}= *\\([0-9]*\\)L* *;|\\1|w TMP\" \\\n-\t  <dummy.out>/dev/null\n-\t# Now select the first definition.\n-\tif [ -s TMP ]; then\n-\t    eval \"$NAME='\"`${SED} -e '2,$d' <TMP`\"'\"\n-\tfi\n-    fi\n-done\n-\n-# Figure out integral type sizes.\n-\n-default_int16='short /* deduction failed */'\n-default_int32='long /* deduction failed */'\n-INT16=32767\n-INT32=2147483647\n-\n-if [ \"${SHRT_MAX}\" = $INT16 ] ; then\n-  default_int16='short /* deduced */'\n-  if [ \"${LONG_MAX}\" = $INT32 ] ; then\n-    default_int32='long /* deduced */'\n-  elif [ \"${INT_MAX}\" = $INT32 ] ; then\n-    default_int32='int /* deduced */'\n-  fi\n-fi\n-\n-[ -n \"$u_int16_t\" ] && uint16_t=\"$u_int16_t\"\n-[ -n \"$u_int32_t\" ] && uint32_t=\"$u_int32_t\"\n-\n-[ -z  \"$int16_t\" ] &&  int16_t=\"$default_int16\"\n-[ -z \"$uint16_t\" ] && uint16_t=\"unsigned $int16_t\"\n-[ -z  \"$int32_t\" ] &&  int32_t=\"$default_int32\"\n-[ -z \"$uint32_t\" ] && uint32_t=\"unsigned $int32_t\"\n-\n-cat <<!EOF!\n-#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)\n-typedef          int   ${macro_prefix}int8_t __attribute__((__mode__(__QI__)));\n-typedef unsigned int  ${macro_prefix}uint8_t __attribute__((__mode__(__QI__)));\n-typedef          int  ${macro_prefix}int16_t __attribute__((__mode__(__HI__)));\n-typedef unsigned int ${macro_prefix}uint16_t __attribute__((__mode__(__HI__)));\n-typedef          int  ${macro_prefix}int32_t __attribute__((__mode__(__SI__)));\n-typedef unsigned int ${macro_prefix}uint32_t __attribute__((__mode__(__SI__)));\n-typedef          int  ${macro_prefix}int64_t __attribute__((__mode__(__DI__)));\n-typedef unsigned int ${macro_prefix}uint64_t __attribute__((__mode__(__DI__)));\n-#if __GNUC__ > 2 || __GNUC_MINOR__ >= 8\n-__extension__ typedef long long ${macro_prefix}llong;\n-__extension__ typedef unsigned long long ${macro_prefix}ullong;\n-#endif\n-#else\n-typedef  $int16_t  ${macro_prefix}int16_t;\n-typedef $uint16_t ${macro_prefix}uint16_t;\n-typedef  $int32_t  ${macro_prefix}int32_t;\n-typedef $uint32_t ${macro_prefix}uint32_t;\n-#endif\n-\n-typedef ${clock_t-int /* default */} ${macro_prefix}clock_t;\n-typedef ${dev_t-int /* default */} ${macro_prefix}dev_t;\n-typedef ${fpos_t-long /* default */} ${macro_prefix}fpos_t;\n-typedef ${gid_t-int /* default */} ${macro_prefix}gid_t;\n-typedef ${ino_t-int /* default */} ${macro_prefix}ino_t;\n-typedef ${mode_t-int /* default */} ${macro_prefix}mode_t;\n-typedef ${nlink_t-int /* default */} ${macro_prefix}nlink_t;\n-typedef ${off_t-long /* default */} ${macro_prefix}off_t;\n-typedef ${pid_t-int /* default */} ${macro_prefix}pid_t;\n-#ifndef __PTRDIFF_TYPE__\n-#define __PTRDIFF_TYPE__ ${ptrdiff_t-long int /* default */}\n-#endif\n-typedef __PTRDIFF_TYPE__ ${macro_prefix}ptrdiff_t;\n-typedef ${sigset_t-int /* default */} ${macro_prefix}sigset_t;\n-#ifndef __SIZE_TYPE__\n-#define __SIZE_TYPE__ ${size_t-unsigned long /* default */}\n-#endif\n-typedef __SIZE_TYPE__ ${macro_prefix}size_t;\n-typedef ${time_t-int /* default */} ${macro_prefix}time_t;\n-typedef ${uid_t-int /* default */} ${macro_prefix}uid_t;\n-typedef ${wchar_t-int /* default */} ${macro_prefix}wchar_t;\n-\n-#define ${macro_prefix}BUFSIZ ${BUFSIZ-1024 /* default */}\n-#define ${macro_prefix}FOPEN_MAX ${FOPEN_MAX-32 /* default */}\n-#define ${macro_prefix}FILENAME_MAX ${FILENAME_MAX-1024 /* default */}\n-#if defined (__cplusplus) || defined (__STDC__)\n-#define ${macro_prefix}ARGS(ARGLIST) ARGLIST\n-#else\n-#define ${macro_prefix}ARGS(ARGLIST) ()\n-#endif\n-#if !defined (__GNUG__) || defined (__STRICT_ANSI__)\n-#define ${macro_prefix}NO_NRV\n-#endif\n-#if !defined (__GNUG__)\n-#define _G_NO_EXTERN_TEMPLATES\n-#endif\n-!EOF!\n-\n-# ssize_t is the signed version of size_t\n-if [ -n \"${ssize_t}\" ] ; then\n-    echo \"typedef ${ssize_t} ${macro_prefix}ssize_t;\"\n-elif [ -z \"${size_t}\" ] ; then\n-    echo \"typedef long ${macro_prefix}ssize_t;\"\n-else\n-    # Remove \"unsigned\" from ${size_t} to get ${ssize_t}.\n-    tmp=\"`echo ${size_t} | ${SED} -e 's|unsigned||g' -e 's|  | |g'`\"\n-    if [ -z \"$tmp\" ] ; then\n-\ttmp=int\n-    else\n-\t# check $tmp doesn't conflict with <unistd.h>\n-\techo \"#include <unistd.h>\n-\textern $tmp read();\" >dummy.c\n-\t${CC} -c dummy.c >/dev/null 2>&1 || tmp=int\n-    fi\n-    echo \"typedef $tmp /* default */ ${macro_prefix}ssize_t;\"\n-fi\n-\n-# wint_t is often the integral type to which wchar_t promotes.\n-if [ -z \"${wint_t}\" ] ; then\n-  for TYPE in int 'unsigned int' 'long int' 'long unsigned int'; do\n-    cat >dummy.C <<!EOF!\n-#ifndef __WCHAR_TYPE__\n-#define __WCHAR_TYPE__ ${wchar_t-int /* default */}\n-#endif\n-typedef __WCHAR_TYPE__ ${macro_prefix}wchar_t;\n-void foo ($TYPE);\n-void foo (double);\n-void bar (${macro_prefix}wchar_t w)\n-{\n-  foo (w);\n-}\n-!EOF!\n-    if ${CXX} -c dummy.C >/dev/null 2>&1 ; then  \n-      wint_t=\"$TYPE /* default */\"\n-      break\n-    fi\n-  done\n-fi\n-echo \"typedef ${wint_t-int /* wchar_t is broken */} ${macro_prefix}wint_t;\"\n-\n-# va_list can cause problems (e.g. some systems have va_list as a struct).\n-# Check to see if ${va_list-char*} really is compatible with stdarg.h.\n-cat >dummy.C <<!EOF!\n-#define X_va_list ${va_list-char* /* default */}\n-extern long foo(X_va_list ap); /* Check that X_va_list compiles on its own */\n-extern \"C\" {\n-#include <stdarg.h>\n-}\n-long foo(X_va_list ap) { return va_arg(ap, long); }\n-long bar(int i, ...)\n-{ va_list ap; long j; va_start(ap, i); j = foo(ap); va_end(ap); return j; }\n-!EOF!\n-if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-  # Ok: We have something that works.\n-  echo \"typedef ${va_list-char* /* default */} ${macro_prefix}va_list;\"\n-else\n-  echo \"#define ${macro_prefix}NEED_STDARG_H\"\n-  # Check and see if we have __gnuc_va_list, as we might set up define\n-  # loops if we use va_list.\n-  cat >dummy.C <<!EOF!\n-#include <stdarg.h>\n-long foo(__gnuc_va_list ap) { return va_arg(ap, long); }\n-!EOF!\n-  if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}va_list __gnuc_va_list\"\n-  else\n-    echo \"#define ${macro_prefix}va_list va_list\"\n-  fi\n-fi\n-\n-cat >dummy.c <<!EOF!\n-#include <signal.h>\n-extern int (*signal())();\n-extern int dummy (int);\n-main()\n-{\n-    int (*oldsig)(int) = signal (1, dummy);\n-    (void) signal (2, oldsig);\n-    return 0;\n-}\n-!EOF!\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}signal_return_type int\"\n-else\n-  echo \"#define ${macro_prefix}signal_return_type void\"\n-fi\n-\n-# check sprintf return type\n-\n-cat >dummy.c <<!EOF!\n-#include <stdio.h>\n-extern int sprintf(); char buf[100];\n-int main() { return sprintf(buf, \"%d\", 34); }\n-!EOF!\n-if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-  echo \"#define ${macro_prefix}sprintf_return_type int\"\n-else\n-  echo \"#define ${macro_prefix}sprintf_return_type char*\"\n-fi\n-\n-if test -n \"${HAVE_ATEXIT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_ATEXIT ${HAVE_ATEXIT}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <stdlib.h>\n-int main()\n-{\n-  atexit (0);\n-}\n-!EOF!\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_ATEXIT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_ATEXIT 0\"\n-  fi\n-fi\n-\n-\n-# *** Check for presence of certain include files ***\n-\n-# check for sys/resource.h\n-\n-if test -n \"${HAVE_SYS_RESOURCE}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE ${HAVE_SYS_RESOURCE}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/time.h>\n-#include <sys/resource.h>\n-  int main()\n-  {\n-    struct rusage res;\n-    getrusage(RUSAGE_SELF, &res);\n-    return (int)(res.ru_utime.tv_sec + (res.ru_utime.tv_usec / 1000000.0));\n-  }\n-!EOF!\n-  # Note: We link because some systems have sys/resource, but not getrusage().\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_RESOURCE 0\"\n-  fi\n-fi\n-\n-# check for struct tms in sys/times.h\n-\n-if test -n \"${HAVE_SYS_TIMES}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_TIMES ${HAVE_SYS_TIMES}\"\n-else\n- cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/times.h>\n-  int main()\n-  {\n-    struct tms s;\n-    return s.tms_utime;\n-  }\n-!EOF!\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_TIMES 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_TIMES 0\"\n-  fi\n-fi\n-\n-# check for sys/socket.h\n-\n-if test -n \"${HAVE_SYS_SOCKET}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_SOCKET ${HAVE_SYS_SOCKET}\"\n-else\n-  echo '#include <sys/types.h>' >dummy.c\n-  echo '#include <sys/socket.h>' >>dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_SOCKET 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_SOCKET 0\"\n-  fi\n-fi\n-\n-# check for sys/cdefs.h\n-\n-if test -n \"${HAVE_SYS_CDEFS}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_CDEFS ${HAVE_SYS_CDEFS}\"\n-else\n-  echo '#include <sys/cdefs.h>' >dummy.c\n-  echo 'extern int myfunc __P((int, int));' >>dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_CDEFS 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_CDEFS 0\"\n-  fi\n-fi\n-\n-# Check for a (Posix-compatible) sys/wait.h */\n-\n-if test -n \"${HAVE_SYS_WAIT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_SYS_WAIT ${HAVE_SYS_WAIT}\"\n-else\n-  cat >dummy.c <<!EOF!\n-#include <sys/types.h>\n-#include <sys/wait.h>\n-  int f() { int i; wait(&i); return i; }\n-!EOF!\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_SYS_WAIT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_SYS_WAIT 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_UNISTD}\" ; then\n- echo \"#define ${macro_prefix}HAVE_UNISTD ${HAVE_UNISTD}\"\n-else\n-  echo '#include <unistd.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_UNISTD 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_UNISTD 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_DIRENT}\" ; then\n- echo \"#define ${macro_prefix}HAVE_DIRENT ${HAVE_DIRENT}\"\n-else\n-  echo '#include <sys/types.h>\n-#include <dirent.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_DIRENT 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_DIRENT 0\"\n-  fi\n-fi\n-\n-if test -n \"${HAVE_CURSES}\" ; then\n- echo \"#define ${macro_prefix}HAVE_CURSES ${HAVE_CURSES}\"\n-else\n-  echo '#include <curses.h>' >dummy.c\n-  if ${CC} -c dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_CURSES 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_CURSES 0\"\n-  fi\n-fi\n-\n-# There is no test for this at the moment; it is just set by the\n-# configuration files.\n-if test -n \"${MATH_H_INLINES}\" ; then\n-  echo \"#define ${macro_prefix}MATH_H_INLINES ${MATH_H_INLINES}\"\n-else\n-  echo \"#define ${macro_prefix}MATH_H_INLINES 0\"\n-fi\n-\n-if test -n \"${HAVE_BOOL}\" ; then\n- echo \"#define ${macro_prefix}HAVE_BOOL ${HAVE_BOOL}\"\n-else\n-  echo 'bool i=true,j=false;' >dummy.C\n-  if ${CXX} -c dummy.C >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_BOOL 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_BOOL 0\"\n-  fi\n-fi\n-\n-if test -n \"${NO_USE_DTOA}\" ; then\n-    echo \"#define ${macro_prefix}NO_USE_DTOA 1\"\n-fi\n-if test -n \"${USE_INT32_FLAGS}\" ; then\n-    echo \"#define ${macro_prefix}USE_INT32_FLAGS 1\"\n-fi\n-\n-if test -n \"$HAVE_PRINTF_FP\"; then\n-  echo \"#define ${macro_prefix}HAVE_PRINTF_FP $HAVE_PRINTF_FP\"\n-  echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO $HAVE_LONG_DOUBLE_IO\"\n-else\n-  # A little test program to check if __printf_fp is available.\n-  cat >dummy.c <<EOF\n-int main()\n-{\n-    return __printf_fp ();\n-}\n-EOF\n-\n-  if ${CC} dummy.c >/dev/null 2>&1 ; then\n-    echo \"#define ${macro_prefix}HAVE_PRINTF_FP 1\"\n-    echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO 1\"\n-  else\n-    echo \"#define ${macro_prefix}HAVE_PRINTF_FP 0\"\n-    echo \"#define ${macro_prefix}HAVE_LONG_DOUBLE_IO 0\"\n-  fi\n-fi\n-\n-# Uncomment the following line if you don't have working templates.\n-# echo \"#define ${macro_prefix}NO_TEMPLATES\"\n-\n-# Override bogus definitions of NULL in system headers.\n-cat <<EOF\n-#undef NULL\n-#define __need_NULL\n-#include <stddef.h>\n-EOF\n-\n-rm -f dummy.C dummy.o dummy.c dummy.out TMP core a.out\n-\n-echo \"#endif /* !${macro_prefix}config_h */\""}, {"sha": "0fb89f76cd976c5c8be966f7293e6d6ae3583c95", "filename": "libstdc++-v3/libio/genops.c", "status": "modified", "additions": 242, "deletions": 99, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fgenops.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1993, 1995, 1997, 1998 Free Software Foundation, Inc.\n+/* Copyright (C) 1993, 1995, 1997-1999, 2000 Free Software Foundation, Inc.\n    This file is part of the GNU IO Library.\n \n    This library is free software; you can redistribute it and/or\n@@ -31,46 +31,63 @@\n #endif\n #include <string.h>\n \n+#ifdef _IO_MTSAFE_IO\n+static _IO_lock_t list_all_lock = _IO_lock_initializer;\n+#endif\n+\n void\n _IO_un_link (fp)\n-     _IO_FILE *fp;\n+     struct _IO_FILE_plus *fp;\n {\n-  if (fp->_flags & _IO_LINKED)\n+  if (fp->file._flags & _IO_LINKED)\n     {\n-      _IO_FILE **f;\n-      for (f = &_IO_list_all; *f != NULL; f = &(*f)->_chain)\n+      struct _IO_FILE_plus **f;\n+#ifdef _IO_MTSAFE_IO\n+      _IO_lock_lock (list_all_lock);\n+#endif\n+      for (f = &_IO_list_all; *f != NULL; f = &(*f)->file._chain)\n \t{\n \t  if (*f == fp)\n \t    {\n-\t      *f = fp->_chain;\n+\t      *f = fp->file._chain;\n \t      break;\n \t    }\n \t}\n-      fp->_flags &= ~_IO_LINKED;\n+#ifdef _IO_MTSAFE_IO\n+      _IO_lock_unlock (list_all_lock);\n+#endif\n+      fp->file._flags &= ~_IO_LINKED;\n     }\n }\n \n void\n _IO_link_in (fp)\n-     _IO_FILE *fp;\n+     struct _IO_FILE_plus *fp;\n {\n-    if ((fp->_flags & _IO_LINKED) == 0)\n+    if ((fp->file._flags & _IO_LINKED) == 0)\n       {\n-\tfp->_flags |= _IO_LINKED;\n-\tfp->_chain = _IO_list_all;\n+\tfp->file._flags |= _IO_LINKED;\n+#ifdef _IO_MTSAFE_IO\n+\t_IO_lock_lock (list_all_lock);\n+#endif\n+\tfp->file._chain = _IO_list_all;\n \t_IO_list_all = fp;\n+#ifdef _IO_MTSAFE_IO\n+\t_IO_lock_unlock (list_all_lock);\n+#endif\n       }\n }\n \n /* Return minimum _pos markers\n    Assumes the current get area is the main get area. */\n-static _IO_size_t _IO_least_marker __P ((_IO_FILE *fp));\n+_IO_ssize_t _IO_least_marker __P ((_IO_FILE *fp, char *end_p));\n \n-static _IO_size_t\n-_IO_least_marker (fp)\n+_IO_ssize_t\n+_IO_least_marker (fp, end_p)\n      _IO_FILE *fp;\n+     char *end_p;\n {\n-  _IO_ssize_t least_so_far = fp->_IO_read_end - fp->_IO_read_base;\n+  _IO_ssize_t least_so_far = end_p - fp->_IO_read_base;\n   struct _IO_marker *mark;\n   for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n     if (mark->_pos < least_so_far)\n@@ -94,7 +111,7 @@ _IO_switch_to_main_get_area (fp)\n   tmp = fp->_IO_read_base;\n   fp->_IO_read_base = fp->_IO_save_base;\n   fp->_IO_save_base = tmp;\n-\n+  /* Set _IO_read_ptr. */\n   fp->_IO_read_ptr = fp->_IO_read_base;\n }\n \n@@ -110,11 +127,11 @@ _IO_switch_to_backup_area (fp)\n   tmp = fp->_IO_read_end;\n   fp->_IO_read_end = fp->_IO_save_end;\n   fp->_IO_save_end = tmp;\n-  /* Swap _gbase and _IO_save_base. */\n+  /* Swap _IO_read_base and _IO_save_base. */\n   tmp = fp->_IO_read_base;\n   fp->_IO_read_base = fp->_IO_save_base;\n   fp->_IO_save_base = tmp;\n-\n+  /* Set _IO_read_ptr.  */\n   fp->_IO_read_ptr = fp->_IO_read_end;\n }\n \n@@ -180,19 +197,28 @@ __overflow (f, ch)\n   return _IO_OVERFLOW (f, ch);\n }\n \n-static int save_for_backup __P ((_IO_FILE *fp));\n+static int save_for_backup __P ((_IO_FILE *fp, char *end_p))\n+#ifdef _LIBC\n+     internal_function\n+#endif\n+     ;\n \n-     static int\n-save_for_backup (fp)\n+static int\n+#ifdef _LIBC\n+internal_function\n+#endif\n+save_for_backup (fp, end_p)\n      _IO_FILE *fp;\n+     char *end_p;\n {\n-  /* Append [_IO_read_base.._IO_read_end] to backup area. */\n-  int least_mark = _IO_least_marker (fp);\n+  /* Append [_IO_read_base..end_p] to backup area. */\n+  _IO_ssize_t least_mark = _IO_least_marker (fp, end_p);\n   /* needed_size is how much space we need in the backup area. */\n-  int needed_size = (fp->_IO_read_end - fp->_IO_read_base) - least_mark;\n-  int current_Bsize = fp->_IO_save_end - fp->_IO_save_base;\n-  int avail; /* Extra space available for future expansion. */\n-  int delta;\n+  _IO_size_t needed_size = (end_p - fp->_IO_read_base) - least_mark;\n+  /* FIXME: Dubious arithmetic if pointers are NULL */\n+  _IO_size_t current_Bsize = fp->_IO_save_end - fp->_IO_save_base;\n+  _IO_size_t avail; /* Extra space available for future expansion. */\n+  _IO_ssize_t delta;\n   struct _IO_marker *mark;\n   if (needed_size > current_Bsize)\n     {\n@@ -203,12 +229,20 @@ save_for_backup (fp)\n \treturn EOF;\t\t/* FIXME */\n       if (least_mark < 0)\n \t{\n+#ifdef _LIBC\n+\t  __mempcpy (__mempcpy (new_buffer + avail,\n+\t\t\t\tfp->_IO_save_end + least_mark,\n+\t\t\t\t-least_mark),\n+\t\t     fp->_IO_read_base,\n+\t\t     end_p - fp->_IO_read_base);\n+#else\n \t  memcpy (new_buffer + avail,\n \t\t  fp->_IO_save_end + least_mark,\n \t\t  -least_mark);\n \t  memcpy (new_buffer + avail - least_mark,\n \t\t  fp->_IO_read_base,\n-\t\t  fp->_IO_read_end - fp->_IO_read_base);\n+\t\t  end_p - fp->_IO_read_base);\n+#endif\n \t}\n       else\n \tmemcpy (new_buffer + avail,\n@@ -229,17 +263,16 @@ save_for_backup (fp)\n \t\t   -least_mark);\n \t  memcpy (fp->_IO_save_base + avail - least_mark,\n \t\t  fp->_IO_read_base,\n-\t\t  fp->_IO_read_end - fp->_IO_read_base);\n+\t\t  end_p - fp->_IO_read_base);\n \t}\n       else if (needed_size > 0)\n \tmemcpy (fp->_IO_save_base + avail,\n \t\tfp->_IO_read_base + least_mark,\n \t\tneeded_size);\n     }\n-  /* FIXME: Dubious arithmetic if pointers are NULL */\n   fp->_IO_backup_base = fp->_IO_save_base + avail;\n   /* Adjust all the streammarkers. */\n-  delta = fp->_IO_read_end - fp->_IO_read_base;\n+  delta = end_p - fp->_IO_read_base;\n   for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n     mark->_pos -= delta;\n   return 0;\n@@ -249,6 +282,11 @@ int\n __underflow (fp)\n      _IO_FILE *fp;\n {\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  if (fp->_vtable_offset == 0 && _IO_fwide (fp, -1) != -1)\n+    return EOF;\n+#endif\n+\n   if (_IO_in_put_mode (fp))\n     if (_IO_switch_to_get_mode (fp) == EOF)\n       return EOF;\n@@ -262,7 +300,7 @@ __underflow (fp)\n     }\n   if (_IO_have_markers (fp))\n     {\n-      if (save_for_backup (fp))\n+      if (save_for_backup (fp, fp->_IO_read_end))\n \treturn EOF;\n     }\n   else if (_IO_have_backup (fp))\n@@ -274,6 +312,11 @@ int\n __uflow (fp)\n      _IO_FILE *fp;\n {\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  if (fp->_vtable_offset == 0 && _IO_fwide (fp, -1) != -1)\n+    return EOF;\n+#endif\n+\n   if (_IO_in_put_mode (fp))\n     if (_IO_switch_to_get_mode (fp) == EOF)\n       return EOF;\n@@ -287,7 +330,7 @@ __uflow (fp)\n     }\n   if (_IO_have_markers (fp))\n     {\n-      if (save_for_backup (fp))\n+      if (save_for_backup (fp, fp->_IO_read_end))\n \treturn EOF;\n     }\n   else if (_IO_have_backup (fp))\n@@ -361,9 +404,13 @@ _IO_default_xsputn (f, data, n)\n \t    count = more;\n \t  if (count > 20)\n \t    {\n+#ifdef _LIBC\n+\t      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n+#else\n \t      memcpy (f->_IO_write_ptr, s, count);\n-\t      s += count;\n \t      f->_IO_write_ptr += count;\n+#endif\n+\t      s += count;\n             }\n \t  else if (count <= 0)\n \t    count = 0;\n@@ -377,7 +424,7 @@ _IO_default_xsputn (f, data, n)\n             }\n \t  more -= count;\n         }\n-      if (more == 0 || __overflow (f, (unsigned char) *s++) == EOF)\n+      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)\n \tbreak;\n       more--;\n     }\n@@ -412,8 +459,12 @@ _IO_default_xsgetn (fp, data, n)\n \t    count = more;\n \t  if (count > 20)\n \t    {\n+#ifdef _LIBC\n+\t      s = __mempcpy (s, fp->_IO_read_ptr, count);\n+#else\n \t      memcpy (s, fp->_IO_read_ptr, count);\n \t      s += count;\n+#endif\n \t      fp->_IO_read_ptr += count;\n \t    }\n \t  else if (count <= 0)\n@@ -467,24 +518,15 @@ _IO_default_setbuf (fp, p, len)\n     return fp;\n }\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n _IO_off64_t\n _IO_default_seekpos (fp, pos, mode)\n      _IO_FILE *fp;\n      _IO_off64_t pos;\n      int mode;\n-#else\n-_IO_off_t\n-_IO_default_seekpos (fp, pos, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t pos;\n-     int mode;\n-#endif\n {\n   return _IO_SEEKOFF (fp, pos, 0, mode);\n }\n \n-\n int\n _IO_default_doallocate (fp)\n      _IO_FILE *fp;\n@@ -500,6 +542,17 @@ void\n _IO_init (fp, flags)\n      _IO_FILE *fp;\n      int flags;\n+{\n+  _IO_no_init (fp, flags, -1, NULL, NULL);\n+}\n+\n+void\n+_IO_no_init (fp, flags, orientation, wd, jmp)\n+     _IO_FILE *fp;\n+     int flags;\n+     int orientation;\n+     struct _IO_wide_data *wd;\n+     struct _IO_jump_t *jmp;\n {\n   fp->_flags = _IO_MAGIC|flags;\n   fp->_IO_buf_base = NULL;\n@@ -517,8 +570,31 @@ _IO_init (fp, flags)\n   fp->_IO_save_end = NULL;\n   fp->_markers = NULL;\n   fp->_cur_column = 0;\n+#if _IO_JUMPS_OFFSET\n+  fp->_vtable_offset = 0;\n+#endif\n #ifdef _IO_MTSAFE_IO\n   _IO_lock_init (*fp->_lock);\n+#endif\n+  fp->_mode = orientation;\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  if (orientation >= 0)\n+    {\n+      fp->_wide_data = wd;\n+      fp->_wide_data->_IO_buf_base = NULL;\n+      fp->_wide_data->_IO_buf_end = NULL;\n+      fp->_wide_data->_IO_read_base = NULL;\n+      fp->_wide_data->_IO_read_ptr = NULL;\n+      fp->_wide_data->_IO_read_end = NULL;\n+      fp->_wide_data->_IO_write_base = NULL;\n+      fp->_wide_data->_IO_write_ptr = NULL;\n+      fp->_wide_data->_IO_write_end = NULL;\n+      fp->_wide_data->_IO_save_base = NULL;\n+      fp->_wide_data->_IO_backup_base = NULL;\n+      fp->_wide_data->_IO_save_end = NULL;\n+\n+      fp->_wide_data->_wide_vtable = jmp;\n+    }\n #endif\n }\n \n@@ -557,24 +633,15 @@ _IO_default_finish (fp, dummy)\n   _IO_lock_fini (*fp->_lock);\n #endif\n \n-  _IO_un_link (fp);\n+  _IO_un_link ((struct _IO_FILE_plus *) fp);\n }\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n _IO_off64_t\n _IO_default_seekoff (fp, offset, dir, mode)\n      _IO_FILE *fp;\n      _IO_off64_t offset;\n      int dir;\n      int mode;\n-#else\n-_IO_off_t\n-_IO_default_seekoff (fp, offset, dir, mode)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-     int mode;\n-#endif\n {\n     return _IO_pos_BAD;\n }\n@@ -678,38 +745,47 @@ int\n _IO_flush_all ()\n {\n   int result = 0;\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if (fp->_IO_write_ptr > fp->_IO_write_base\n-\t&& _IO_OVERFLOW (fp, EOF) == EOF)\n+  struct _IO_FILE_plus *fp;\n+  for (fp = _IO_list_all; fp != NULL; fp = fp->file._chain)\n+    if (((fp->file._mode < 0 && fp->file._IO_write_ptr > fp->file._IO_write_base)\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+\n+\t || (fp->file._vtable_offset == 0\n+\t     && fp->file._mode > 0 && (fp->file._wide_data->_IO_write_ptr\n+\t\t\t\t  > fp->file._wide_data->_IO_write_base))\n+#endif\n+\t )\n+\t&& _IO_OVERFLOW (&fp->file, EOF) == EOF)\n       result = EOF;\n   return result;\n }\n \n void\n _IO_flush_all_linebuffered ()\n {\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if ((fp->_flags & _IO_NO_WRITES) == 0 && fp->_flags & _IO_LINE_BUF)\n-      _IO_OVERFLOW (fp, EOF);\n+  struct _IO_FILE_plus *fp;\n+  for (fp = _IO_list_all; fp != NULL; fp = fp->file._chain)\n+    if ((fp->file._flags & _IO_NO_WRITES) == 0 && fp->file._flags & _IO_LINE_BUF)\n+      _IO_OVERFLOW (&fp->file, EOF);\n }\n \n-static void _IO_unbuffer_all __P ((void));\n+static void _IO_unbuffer_write __P ((void));\n \n static void\n-_IO_unbuffer_all ()\n+_IO_unbuffer_write ()\n {\n-  _IO_FILE *fp;\n-  for (fp = _IO_list_all; fp != NULL; fp = fp->_chain)\n-    if (! (fp->_flags & _IO_UNBUFFERED))\n-      _IO_SETBUF (fp, NULL, 0);\n+  struct _IO_FILE_plus *fp;\n+  for (fp = _IO_list_all; fp != NULL; fp = fp->file._chain)\n+    if (! (fp->file._flags & _IO_UNBUFFERED)\n+\t&& (! (fp->file._flags & _IO_NO_WRITES)\n+\t    || (fp->file._flags & _IO_IS_APPENDING)))\n+      _IO_SETBUF (&fp->file, NULL, 0);\n }\n \n-void\n+int\n _IO_cleanup ()\n {\n-  _IO_flush_all ();\n+  int result = _IO_flush_all ();\n \n   /* We currently don't have a reliable mechanism for making sure that\n      C++ static destructors are executed in the correct order.\n@@ -718,9 +794,12 @@ _IO_cleanup ()\n \n      The following will make the standard streambufs be unbuffered,\n      which forces any output from late destructors to be written out. */\n-  _IO_unbuffer_all ();\n+  _IO_unbuffer_write ();\n+\n+  return result;\n }\n \n+\n void\n _IO_init_marker (marker, fp)\n      struct _IO_marker *marker;\n@@ -857,23 +936,34 @@ _IO_default_pbackfail (fp, c)\n      _IO_FILE *fp;\n      int c;\n {\n-  if (fp->_IO_read_ptr <= fp->_IO_read_base)\n+  if (fp->_IO_read_ptr > fp->_IO_read_base && !_IO_in_backup (fp)\n+      && (unsigned char) fp->_IO_read_ptr[-1] == c)\n+    --fp->_IO_read_ptr;\n+  else\n     {\n       /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n-      if (_IO_have_backup (fp) && !_IO_in_backup (fp))\n-\t_IO_switch_to_backup_area (fp);\n-\n-      if (!_IO_have_backup (fp))\n+      if (!_IO_in_backup (fp))\n \t{\n-\t  /* No backup buffer: allocate one. */\n-\t  /* Use nshort buffer, if unused? (probably not)  FIXME */\n-\t  int backup_size = 128;\n-\t  char *bbuf = (char *) malloc (backup_size);\n-\t  if (bbuf == NULL)\n-\t    return EOF;\n-\t  fp->_IO_save_base = bbuf;\n-\t  fp->_IO_save_end = fp->_IO_save_base + backup_size;\n-\t  fp->_IO_backup_base = fp->_IO_save_end;\n+\t  /* We need to keep the invariant that the main get area\n+\t     logically follows the backup area.  */\n+\t  if (fp->_IO_read_ptr > fp->_IO_read_base && _IO_have_backup (fp))\n+\t    {\n+\t      if (save_for_backup (fp, fp->_IO_read_ptr))\n+\t\treturn EOF;\n+\t    }\n+\t  else if (!_IO_have_backup (fp))\n+\t    {\n+\t      /* No backup buffer: allocate one. */\n+\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n+\t      int backup_size = 128;\n+\t      char *bbuf = (char *) malloc (backup_size);\n+\t      if (bbuf == NULL)\n+\t\treturn EOF;\n+\t      fp->_IO_save_base = bbuf;\n+\t      fp->_IO_save_end = fp->_IO_save_base + backup_size;\n+\t      fp->_IO_backup_base = fp->_IO_save_end;\n+\t    }\n+\t  fp->_IO_read_base = fp->_IO_read_ptr;\n \t  _IO_switch_to_backup_area (fp);\n \t}\n       else if (fp->_IO_read_ptr <= fp->_IO_read_base)\n@@ -893,26 +983,17 @@ _IO_default_pbackfail (fp, c)\n \t\t    new_buf + new_size);\n \t  fp->_IO_backup_base = fp->_IO_read_ptr;\n \t}\n+\n+      *--fp->_IO_read_ptr = c;\n     }\n-  --fp->_IO_read_ptr;\n-  if (c != EOF && *fp->_IO_read_ptr != c)\n-    *fp->_IO_read_ptr = c;\n-  return (unsigned char) *fp->_IO_read_ptr;\n+  return (unsigned char) c;\n }\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n _IO_off64_t\n _IO_default_seek (fp, offset, dir)\n      _IO_FILE *fp;\n      _IO_off64_t offset;\n      int dir;\n-#else\n-_IO_off_t\n-_IO_default_seek (fp, offset, dir)\n-     _IO_FILE *fp;\n-     _IO_off_t offset;\n-     int dir;\n-#endif\n {\n   return _IO_pos_BAD;\n }\n@@ -943,6 +1024,70 @@ _IO_default_write (fp, data, n)\n   return 0;\n }\n \n+int\n+_IO_default_showmanyc (fp)\n+     _IO_FILE *fp;\n+{\n+  return -1;\n+}\n+\n+void\n+_IO_default_imbue (fp, locale)\n+     _IO_FILE *fp;\n+     void *locale;\n+{\n+}\n+\n+_IO_ITER\n+_IO_iter_begin()\n+{\n+  return _IO_list_all;\n+}\n+\n+_IO_ITER\n+_IO_iter_end()\n+{\n+  return NULL;\n+}\n+\n+_IO_ITER\n+_IO_iter_next(iter)\n+    _IO_ITER iter;\n+{\n+  return iter->file._chain;\n+}\n+\n+_IO_FILE *\n+_IO_iter_file(iter)\n+    _IO_ITER iter;\n+{\n+  return (_IO_FILE *) iter;\n+}\n+\n+void\n+_IO_list_lock()\n+{\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_lock (list_all_lock);\n+#endif\n+}\n+\n+void\n+_IO_list_unlock()\n+{\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_unlock (list_all_lock);\n+#endif\n+}\n+\n+void\n+_IO_list_resetlock()\n+{\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_init (list_all_lock);\n+#endif\n+}\n+\n \n #ifdef TODO\n #if defined(linux)\n@@ -963,8 +1108,6 @@ __io_defs io_defs__;\n \n #ifdef weak_alias\n weak_alias (_IO_cleanup, _cleanup)\n-#elif defined(_G_STDIO_USES_LIBIO) && defined(_G_HAVE_WEAK_SYMBOL)\n-void _cleanup () __attribute__ ((weak, alias (\"_IO_cleanup\")));\n #endif\n \n #ifdef text_set_element"}, {"sha": "39c7b02ee9d9aabafc1ebce531ad3c86837644aa", "filename": "libstdc++-v3/libio/iofwide.c", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiofwide.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -0,0 +1,472 @@\n+/* Copyright (C) 1999, 2000 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include <libioP.h>\n+#ifdef _LIBC\n+# include <dlfcn.h>\n+# include <wchar.h>\n+#endif\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#ifdef _LIBC\n+# include <langinfo.h>\n+# include <locale/localeinfo.h>\n+# include <wcsmbs/wcsmbsload.h>\n+#endif\n+\n+\n+/* Prototypes of libio's codecvt functions.  */\n+static enum __codecvt_result do_out (struct _IO_codecvt *codecvt,\n+\t\t\t\t     __mbstate_t *statep,\n+\t\t\t\t     const wchar_t *from_start,\n+\t\t\t\t     const wchar_t *from_end,\n+\t\t\t\t     const wchar_t **from_stop, char *to_start,\n+\t\t\t\t     char *to_end, char **to_stop);\n+static enum __codecvt_result do_unshift (struct _IO_codecvt *codecvt,\n+\t\t\t\t\t __mbstate_t *statep, char *to_start,\n+\t\t\t\t\t char *to_end, char **to_stop);\n+static enum __codecvt_result do_in (struct _IO_codecvt *codecvt,\n+\t\t\t\t    __mbstate_t *statep,\n+\t\t\t\t    const char *from_start,\n+\t\t\t\t    const char *from_end,\n+\t\t\t\t    const char **from_stop, wchar_t *to_start,\n+\t\t\t\t    wchar_t *to_end, wchar_t **to_stop);\n+static int do_encoding (struct _IO_codecvt *codecvt);\n+static int do_length (struct _IO_codecvt *codecvt, __mbstate_t *statep,\n+\t\t      const char *from_start,\n+\t\t      const char *from_end, _IO_size_t max);\n+static int do_max_length (struct _IO_codecvt *codecvt);\n+static int do_always_noconv (struct _IO_codecvt *codecvt);\n+\n+\n+/* The functions used in `codecvt' for libio are always the same.  */\n+struct _IO_codecvt __libio_codecvt =\n+{\n+  .__codecvt_destr = NULL,\t\t/* Destructor, never used.  */\n+  .__codecvt_do_out = do_out,\n+  .__codecvt_do_unshift = do_unshift,\n+  .__codecvt_do_in = do_in,\n+  .__codecvt_do_encoding = do_encoding,\n+  .__codecvt_do_always_noconv = do_always_noconv,\n+  .__codecvt_do_length = do_length,\n+  .__codecvt_do_max_length = do_max_length\n+};\n+\n+\n+/* Return orientation of stream.  If mode is nonzero try to change\n+   the orientation first.  */\n+#undef _IO_fwide\n+int\n+_IO_fwide (fp, mode)\n+     _IO_FILE *fp;\n+     int mode;\n+{\n+  /* Normalize the value.  */\n+  mode = mode < 0 ? -1 : (mode == 0 ? 0 : 1);\n+\n+  if (mode == 0 || fp->_mode != 0)\n+    /* The caller simply wants to know about the current orientation\n+       or the orientation already has been determined.  */\n+    return fp->_mode;\n+\n+  _IO_cleanup_region_start ((void (*) __P ((void *))) _IO_funlockfile, fp);\n+  _IO_flockfile (fp);\n+\n+  /* Set the orientation appropriately.  */\n+  if (mode > 0)\n+    {\n+      struct _IO_codecvt *cc = &fp->_wide_data->_codecvt;\n+\n+      fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n+      fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_write_base;\n+\n+      /* The functions are always the same.  */\n+      *cc = __libio_codecvt;\n+\n+      /* Get the character conversion functions based on the currently\n+\t selected locale for LC_CTYPE.  */\n+#ifdef _LIBC\n+      {\n+\tstruct gconv_fcts fcts;\n+\n+\t/* Clear the state.  We start all over again.  */\n+\tmemset (&fp->_wide_data->_IO_state, '\\0', sizeof (__mbstate_t));\n+\tmemset (&fp->_wide_data->_IO_last_state, '\\0', sizeof (__mbstate_t));\n+\n+\t__wcsmbs_clone_conv (&fcts);\n+\n+\tcc->__cd_in.__cd.__nsteps = 1; /* Only one step allowed.  */\n+\tcc->__cd_in.__cd.__steps = fcts.towc;\n+\n+\tcc->__cd_in.__cd.__data[0].__invocation_counter = 0;\n+\tcc->__cd_in.__cd.__data[0].__internal_use = 1;\n+\tcc->__cd_in.__cd.__data[0].__flags = __GCONV_IS_LAST;\n+\tcc->__cd_in.__cd.__data[0].__statep = &fp->_wide_data->_IO_state;\n+\n+\t/* XXX For now no transliteration.  */\n+\tcc->__cd_in.__cd.__data[0].__trans = NULL;\n+\n+\tcc->__cd_out.__cd.__nsteps = 1; /* Only one step allowed.  */\n+\tcc->__cd_out.__cd.__steps = fcts.tomb;\n+\n+\tcc->__cd_out.__cd.__data[0].__invocation_counter = 0;\n+\tcc->__cd_out.__cd.__data[0].__internal_use = 1;\n+\tcc->__cd_out.__cd.__data[0].__flags = __GCONV_IS_LAST;\n+\tcc->__cd_out.__cd.__data[0].__statep = &fp->_wide_data->_IO_state;\n+\n+\t/* XXX For now no transliteration.  */\n+\tcc->__cd_out.__cd.__data[0].__trans = NULL;\n+      }\n+#else\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+      {\n+\t/* Determine internal and external character sets.\n+\n+\t   XXX For now we make our life easy: we assume a fixed internal\n+\t   encoding (as most sane systems have; hi HP/UX!).  If somebody\n+\t   cares about systems which changing internal charsets they\n+\t   should come up with a solution for the determination of the\n+\t   currently used internal character set.  */\n+\tconst char *internal_ccs = _G_INTERNAL_CCS;\n+\tconst char *external_ccs = NULL;\n+\n+#  ifdef HAVE_NL_LANGINFO\n+\texternal_ccs = nl_langinfo (CODESET);\n+#  endif\n+\tif (external_ccs == NULL)\n+\t  external_ccs = \"ISO-8859-1\";\n+\n+\tcc->__cd_in = iconv_open (internal_ccs, external_ccs);\n+\tif (cc->__cd_in != (iconv_t) -1)\n+\t  cc->__cd_out = iconv_open (external_ccs, internal_ccs);\n+\n+\tif (cc->__cd_in != (iconv_t) -1 || cc->__cd_out != (iconv_t) -1)\n+\t  /* XXX */\n+\t  abort ();\n+      }\n+# else\n+#  error \"somehow determine this from LC_CTYPE\"\n+# endif\n+#endif\n+\n+      /* From now on use the wide character callback functions.  */\n+      ((struct _IO_FILE_plus *) fp)->vtable = fp->_wide_data->_wide_vtable;\n+    }\n+\n+  /* Set the mode now.  */\n+  fp->_mode = mode;\n+\n+  _IO_funlockfile (fp);\n+  _IO_cleanup_region_end (0);\n+\n+  return mode;\n+}\n+\n+#ifdef weak_alias\n+weak_alias (_IO_fwide, fwide)\n+#endif\n+\n+\n+static enum __codecvt_result\n+do_out (struct _IO_codecvt *codecvt, __mbstate_t *statep,\n+\tconst wchar_t *from_start, const wchar_t *from_end,\n+\tconst wchar_t **from_stop, char *to_start, char *to_end,\n+\tchar **to_stop)\n+{\n+  enum __codecvt_result result;\n+\n+#ifdef _LIBC\n+  struct __gconv_step *gs = codecvt->__cd_out.__cd.__steps;\n+  int status;\n+  size_t dummy;\n+  const unsigned char *from_start_copy = (unsigned char *) from_start;\n+\n+  codecvt->__cd_out.__cd.__data[0].__outbuf = to_start;\n+  codecvt->__cd_out.__cd.__data[0].__outbufend = to_end;\n+  codecvt->__cd_out.__cd.__data[0].__statep = statep;\n+\n+  status = DL_CALL_FCT (gs->__fct,\n+\t\t\t(gs, codecvt->__cd_out.__cd.__data, &from_start_copy,\n+\t\t\t (const unsigned char *) from_end, NULL,\n+\t\t\t &dummy, 0, 0));\n+\n+  *from_stop = (wchar_t *) from_start_copy;\n+  *to_stop = codecvt->__cd_out.__cd.__data[0].__outbuf;\n+\n+  switch (status)\n+    {\n+    case __GCONV_OK:\n+    case __GCONV_EMPTY_INPUT:\n+      result = __codecvt_ok;\n+      break;\n+\n+    case __GCONV_FULL_OUTPUT:\n+    case __GCONV_INCOMPLETE_INPUT:\n+      result = __codecvt_partial;\n+      break;\n+\n+    default:\n+      result = __codecvt_error;\n+      break;\n+    }\n+#else\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  size_t res;\n+  const char *from_start_copy = (const char *) from_start;\n+  size_t from_len = from_end - from_start;\n+  char *to_start_copy = (char *) from_start;\n+  size_t to_len = to_end - to_start;\n+\n+  res = iconv (codecvt->__cd_out, &from_start_copy, &from_len,\n+\t       &to_start_copy, &to_len);\n+  \n+  if (res == 0 || from_len == 0)\n+    result = __codecvt_ok;\n+  else if (to_len < codecvt->__codecvt_do_max_length (codecvt))\n+    result = __codecvt_partial;\n+  else\n+    result = __codecvt_error;\n+# else\n+  /* Decide what to do.  */\n+  result = __codecvt_error;\n+# endif\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static enum __codecvt_result\n+do_unshift (struct _IO_codecvt *codecvt, __mbstate_t *statep,\n+\t    char *to_start, char *to_end, char **to_stop)\n+{\n+  enum __codecvt_result result;\n+\n+#ifdef _LIBC\n+  struct __gconv_step *gs = codecvt->__cd_out.__cd.__steps;\n+  int status;\n+  size_t dummy;\n+\n+  codecvt->__cd_out.__cd.__data[0].__outbuf = to_start;\n+  codecvt->__cd_out.__cd.__data[0].__outbufend = to_end;\n+  codecvt->__cd_out.__cd.__data[0].__statep = statep;\n+\n+  status = DL_CALL_FCT (gs->__fct,\n+\t\t\t(gs, codecvt->__cd_out.__cd.__data, NULL, NULL,\n+\t\t\t NULL, &dummy, 1, 0));\n+\n+  *to_stop = codecvt->__cd_out.__cd.__data[0].__outbuf;\n+\n+  switch (status)\n+    {\n+    case __GCONV_OK:\n+    case __GCONV_EMPTY_INPUT:\n+      result = __codecvt_ok;\n+      break;\n+\n+    case __GCONV_FULL_OUTPUT:\n+    case __GCONV_INCOMPLETE_INPUT:\n+      result = __codecvt_partial;\n+      break;\n+\n+    default:\n+      result = __codecvt_error;\n+      break;\n+    }\n+#else\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  size_t res;\n+  char *to_start_copy = (char *) to_start;\n+  size_t to_len = to_end - to_start;\n+\n+  res = iconv (codecvt->__cd_out, NULL, NULL, &to_start_copy, &to_len);\n+  \n+  if (res == 0)\n+    result = __codecvt_ok;\n+  else if (to_len < codecvt->__codecvt_do_max_length (codecvt))\n+    result = __codecvt_partial;\n+  else\n+    result = __codecvt_error;\n+# else\n+  /* Decide what to do.  */\n+  result = __codecvt_error;\n+# endif\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static enum __codecvt_result\n+do_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,\n+       const char *from_start, const char *from_end, const char **from_stop,\n+       wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)\n+{\n+  enum __codecvt_result result;\n+\n+#ifdef _LIBC\n+  struct __gconv_step *gs = codecvt->__cd_in.__cd.__steps;\n+  int status;\n+  size_t dummy;\n+  const unsigned char *from_start_copy = (unsigned char *) from_start;\n+\n+  codecvt->__cd_in.__cd.__data[0].__outbuf = (char *) to_start;\n+  codecvt->__cd_in.__cd.__data[0].__outbufend = (char *) to_end;\n+  codecvt->__cd_in.__cd.__data[0].__statep = statep;\n+\n+  status = DL_CALL_FCT (gs->__fct,\n+\t\t\t(gs, codecvt->__cd_in.__cd.__data, &from_start_copy,\n+\t\t\t from_end, NULL, &dummy, 0, 0));\n+\n+  *from_stop = from_start_copy;\n+  *to_stop = (wchar_t *) codecvt->__cd_in.__cd.__data[0].__outbuf;\n+\n+  switch (status)\n+    {\n+    case __GCONV_OK:\n+    case __GCONV_EMPTY_INPUT:\n+      result = __codecvt_ok;\n+      break;\n+\n+    case __GCONV_FULL_OUTPUT:\n+    case __GCONV_INCOMPLETE_INPUT:\n+      result = __codecvt_partial;\n+      break;\n+\n+    default:\n+      result = __codecvt_error;\n+      break;\n+    }\n+#else\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  size_t res;\n+  const char *from_start_copy = (const char *) from_start;\n+  size_t from_len = from_end - from_start;\n+  char *to_start_copy = (char *) from_start;\n+  size_t to_len = to_end - to_start;\n+\n+  res = iconv (codecvt->__cd_in, &from_start_copy, &from_len,\n+\t       &to_start_copy, &to_len);\n+  \n+  if (res == 0)\n+    result = __codecvt_ok;\n+  else if (to_len == 0)\n+    result = __codecvt_partial;\n+  else if (from_len < codecvt->__codecvt_do_max_length (codecvt))\n+    result = __codecvt_partial;\n+  else\n+    result = __codecvt_error;\n+# else\n+  /* Decide what to do.  */\n+  result = __codecvt_error;\n+# endif\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static int\n+do_encoding (struct _IO_codecvt *codecvt)\n+{\n+#ifdef _LIBC\n+  /* See whether the encoding is stateful.  */\n+  if (codecvt->__cd_in.__cd.__steps[0].__stateful)\n+    return -1;\n+  /* Fortunately not.  Now determine the input bytes for the conversion\n+     necessary for each wide character.  */\n+  if (codecvt->__cd_in.__cd.__steps[0].__min_needed_from\n+      != codecvt->__cd_in.__cd.__steps[0].__max_needed_from)\n+    /* Not a constant value.  */\n+    return 0;\n+\n+  return codecvt->__cd_in.__cd.__steps[0].__min_needed_from;\n+#else\n+  /* Worst case scenario.  */\n+  return -1;\n+#endif\n+}\n+\n+\n+static int\n+do_always_noconv (struct _IO_codecvt *codecvt)\n+{\n+  return 0;\n+}\n+\n+\n+static int\n+do_length (struct _IO_codecvt *codecvt, __mbstate_t *statep,\n+\t   const char *from_start, const char *from_end, _IO_size_t max)\n+{\n+  int result;\n+#ifdef _LIBC\n+  const unsigned char *cp = (const unsigned char *) from_start;\n+  wchar_t to_buf[max];\n+  struct __gconv_step *gs = codecvt->__cd_in.__cd.__steps;\n+  int status;\n+  size_t dummy;\n+\n+  codecvt->__cd_in.__cd.__data[0].__outbuf = (char *) to_buf;\n+  codecvt->__cd_in.__cd.__data[0].__outbufend = (char *) &to_buf[max];\n+  codecvt->__cd_in.__cd.__data[0].__statep = statep;\n+\n+  status = DL_CALL_FCT (gs->__fct,\n+\t\t\t(gs, codecvt->__cd_in.__cd.__data, &cp, from_end,\n+\t\t\t NULL, &dummy, 0, 0));\n+\n+  result = cp - (const unsigned char *) from_start;\n+#else\n+# ifdef _GLIBCPP_USE_WCHAR_T\n+  const char *from_start_copy = (const char *) from_start;\n+  size_t from_len = from_end - from_start;\n+  wchar_t to_buf[max];\n+  size_t res;\n+  char *to_start = (char *) to_buf;\n+\n+  res = iconv (codecvt->__cd_in, &from_start_copy, &from_len,\n+\t       &to_start, &max);\n+  \n+  result = from_start_copy - (char *) from_start;\n+# else\n+  /* Decide what to do.  */\n+  result = 0;\n+# endif\n+#endif\n+\n+  return result;\n+}\n+\n+\n+static int\n+do_max_length (struct _IO_codecvt *codecvt)\n+{\n+#ifdef _LIBC\n+  return codecvt->__cd_in.__cd.__steps[0].__max_needed_from;\n+#else\n+  return MB_CUR_MAX;\n+#endif\n+}"}, {"sha": "92f25cf9f9dde9a22a081fa3bacba15e286fdb9c", "filename": "libstdc++-v3/libio/iolibio.h", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fiolibio.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -8,14 +8,23 @@ extern \"C\" {\n #endif\n \n extern int _IO_fclose __P((_IO_FILE*));\n+extern int _IO_new_fclose __P((_IO_FILE*));\n+extern int _IO_old_fclose __P((_IO_FILE*));\n extern _IO_FILE *_IO_fdopen __P((int, const char*));\n+extern _IO_FILE *_IO_old_fdopen __P((int, const char*));\n+extern _IO_FILE *_IO_new_fdopen __P((int, const char*));\n extern int _IO_fflush __P((_IO_FILE*));\n extern int _IO_fgetpos __P((_IO_FILE*, _IO_fpos_t*));\n+extern int _IO_fgetpos64 __P((_IO_FILE*, _IO_fpos64_t*));\n extern char* _IO_fgets __P((char*, int, _IO_FILE*));\n extern _IO_FILE *_IO_fopen __P((const char*, const char*));\n+extern _IO_FILE *_IO_old_fopen __P((const char*, const char*));\n+extern _IO_FILE *_IO_new_fopen __P((const char*, const char*));\n+extern _IO_FILE *_IO_fopen64 __P((const char*, const char*));\n extern int _IO_fprintf __P((_IO_FILE*, const char*, ...));\n extern int _IO_fputs __P((const char*, _IO_FILE*));\n extern int _IO_fsetpos __P((_IO_FILE*, const _IO_fpos_t *));\n+extern int _IO_fsetpos64 __P((_IO_FILE*, const _IO_fpos64_t *));\n extern long int _IO_ftell __P((_IO_FILE*));\n extern _IO_size_t _IO_fread __P((void*, _IO_size_t, _IO_size_t, _IO_FILE*));\n extern _IO_size_t _IO_fwrite __P((const void*,\n@@ -32,32 +41,40 @@ extern int _IO_sprintf __P((char *, const char*, ...));\n extern int _IO_ungetc __P((int, _IO_FILE*));\n extern int _IO_vsscanf __P((const char *, const char *, _IO_va_list));\n extern int _IO_vsprintf __P((char*, const char*, _IO_va_list));\n+extern int _IO_vswprintf __P((wchar_t*, _IO_size_t, const wchar_t*,\n+\t\t\t      _IO_va_list));\n \n struct obstack;\n extern int _IO_obstack_vprintf __P ((struct obstack *, const char *,\n-                                    _IO_va_list));\n+\t\t\t\t     _IO_va_list));\n extern int _IO_obstack_printf __P ((struct obstack *, const char *, ...));\n #ifndef _IO_pos_BAD\n-#define _IO_pos_BAD ((_IO_fpos_t)(-1))\n+#define _IO_pos_BAD ((_IO_off64_t)(-1))\n #endif\n #define _IO_clearerr(FP) ((FP)->_flags &= ~(_IO_ERR_SEEN|_IO_EOF_SEEN))\n #define _IO_fseek(__fp, __offset, __whence) \\\n   (_IO_seekoff(__fp, __offset, __whence, _IOS_INPUT|_IOS_OUTPUT) == _IO_pos_BAD ? EOF : 0)\n #define _IO_rewind(FILE) (void)_IO_seekoff(FILE, 0, 0, _IOS_INPUT|_IOS_OUTPUT)\n #define _IO_vprintf(FORMAT, ARGS) _IO_vfprintf(_IO_stdout, FORMAT, ARGS)\n-#if _G_IO_IO_FILE_VERSION == 0x20001\n #define _IO_freopen(FILENAME, MODE, FP) \\\n   (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE, 0))\n-#else\n-#define _IO_freopen(FILENAME, MODE, FP) \\\n-  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE))\n-#endif\n+#define _IO_old_freopen(FILENAME, MODE, FP) \\\n+  (_IO_old_file_close_it (FP), _IO_old_file_fopen(FP, FILENAME, MODE))\n+#define _IO_freopen64(FILENAME, MODE, FP) \\\n+  (_IO_file_close_it(FP), _IO_file_fopen(FP, FILENAME, MODE, 1))\n #define _IO_fileno(FP) ((FP)->_fileno)\n extern _IO_FILE* _IO_popen __P((const char*, const char*));\n+extern _IO_FILE* _IO_new_popen __P((const char*, const char*));\n+extern _IO_FILE* _IO_old_popen __P((const char*, const char*));\n+extern int __new_pclose __P((_IO_FILE *));\n+extern int __old_pclose __P((_IO_FILE *));\n #define _IO_pclose _IO_fclose\n #define _IO_setbuf(_FP, _BUF) _IO_setbuffer(_FP, _BUF, _IO_BUFSIZ)\n #define _IO_setlinebuf(_FP) _IO_setvbuf(_FP, NULL, 1, 0)\n \n+_IO_FILE *__new_freopen __P ((const char *, const char *, _IO_FILE *));\n+_IO_FILE *__old_freopen __P ((const char *, const char *, _IO_FILE *));\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "409da88eb7566f2e64381dc426e313c8b926c035", "filename": "libstdc++-v3/libio/libio.h", "status": "modified", "additions": 223, "deletions": 91, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Flibio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Flibio.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1991, 92, 93, 94, 95, 97, 98 Free Software Foundation, Inc.\n+/* Copyright (C) 1991,92,93,94,95,97,98,99,2000 Free Software Foundation, Inc.\n    This file is part of the GNU IO Library.\n    Written by Per Bothner <bothner@cygnus.com>.\n \n@@ -28,21 +28,22 @@\n #define _IO_STDIO_H\n \n #include <_G_config.h>\n+/* ALL of these should be defined in _G_config.h */\n #define _IO_pos_t _G_fpos_t /* obsolete */\n #define _IO_fpos_t _G_fpos_t\n+#define _IO_fpos64_t _G_fpos64_t\n #define _IO_size_t _G_size_t\n #define _IO_ssize_t _G_ssize_t\n #define _IO_off_t _G_off_t\n+#define _IO_off64_t _G_off64_t\n #define _IO_pid_t _G_pid_t\n #define _IO_uid_t _G_uid_t\n+#define _IO_iconv_t _G_iconv_t\n #define _IO_HAVE_SYS_WAIT _G_HAVE_SYS_WAIT\n #define _IO_HAVE_ST_BLKSIZE _G_HAVE_ST_BLKSIZE\n #define _IO_BUFSIZ _G_BUFSIZ\n #define _IO_va_list _G_va_list\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#define _IO_fpos64_t _G_fpos64_t\n-#define _IO_off64_t _G_off64_t\n-#endif\n+#define _IO_wint_t _G_wint_t\n \n #ifdef _G_NEED_STDARG_H\n /* This define avoids name pollution if we're using GNU stdarg.h */\n@@ -60,30 +61,26 @@\n # else\n #  ifdef __STDC__\n #   define __P(p) p\n+#   define __PMT(p) p\n #  else\n #   define __P(p) ()\n+#   define __PMT(p) ()\n #  endif\n # endif\n #endif /*!__P*/\n \n-#ifndef __PMT\n-# ifdef __STDC__\n-#  define __PMT(p) p\n-# else\n-#  define __PMT(p) ()\n-# endif\n-#endif /*!__P*/\n-\n /* For backward compatibility */\n #ifndef _PARAMS\n # define _PARAMS(protos) __P(protos)\n #endif /*!_PARAMS*/\n \n #ifndef __STDC__\n-# define const\n+# ifndef const\n+#  define const\n+# endif\n #endif\n #define _IO_UNIFIED_JUMPTABLES 1\n-#if !_G_HAVE_PRINTF_FP\n+#ifndef _G_HAVE_PRINTF_FP\n # define _IO_USE_DTOA 1\n #endif\n \n@@ -162,28 +159,12 @@ struct _IO_jump_t;  struct _IO_FILE;\n /* Handle lock.  */\n #ifdef _IO_MTSAFE_IO\n # if defined __GLIBC__ && __GLIBC__ >= 2\n-#  if __GLIBC_MINOR__ > 0\n-#   include <bits/stdio-lock.h>\n-#  else\n-#   include <stdio-lock.h>\n-#  endif\n-#  define _IO_LOCK_T _IO_lock_t *\n+#  include <bits/stdio-lock.h>\n # else\n /*# include <comthread.h>*/\n # endif\n #else\n-# if defined(__GLIBC__) && __GLIBC__ >= 2\n-   typedef void _IO_lock_t;\n-#  define _IO_LOCK_T void *\n-# else\n-#  ifdef __linux__\n-    struct _IO_lock_t { void *ptr; short int field1; short int field2; };\n-#   define _IO_LOCK_T struct _IO_lock_t\n-#  else\n-    typedef void _IO_lock_t;\n-#   define _IO_LOCK_T void *\n-#  endif\n-# endif\n+typedef void _IO_lock_t;\n #endif\n \n \n@@ -208,6 +189,78 @@ struct _IO_marker {\n #endif\n };\n \n+/* This is the structure from the libstdc++ codecvt class.  */\n+enum __codecvt_result\n+{\n+  __codecvt_ok,\n+  __codecvt_partial,\n+  __codecvt_error,\n+  __codecvt_noconv\n+};\n+\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+/* The order of the elements in the following struct must match the order\n+   of the virtual functions in the libstdc++ codecvt class.  */\n+struct _IO_codecvt\n+{\n+  void (*__codecvt_destr) (struct _IO_codecvt *);\n+  enum __codecvt_result (*__codecvt_do_out) (struct _IO_codecvt *,\n+\t\t\t\t\t     __mbstate_t *,\n+\t\t\t\t\t     const wchar_t *,\n+\t\t\t\t\t     const wchar_t *,\n+\t\t\t\t\t     const wchar_t **, char *,\n+\t\t\t\t\t     char *, char **);\n+  enum __codecvt_result (*__codecvt_do_unshift) (struct _IO_codecvt *,\n+\t\t\t\t\t\t __mbstate_t *, char *,\n+\t\t\t\t\t\t char *, char **);\n+  enum __codecvt_result (*__codecvt_do_in) (struct _IO_codecvt *,\n+\t\t\t\t\t    __mbstate_t *,\n+\t\t\t\t\t    const char *, const char *,\n+\t\t\t\t\t    const char **, wchar_t *,\n+\t\t\t\t\t    wchar_t *, wchar_t **);\n+  int (*__codecvt_do_encoding) (struct _IO_codecvt *);\n+  int (*__codecvt_do_always_noconv) (struct _IO_codecvt *);\n+  int (*__codecvt_do_length) (struct _IO_codecvt *, __mbstate_t *,\n+\t\t\t      const char *, const char *, _IO_size_t);\n+  int (*__codecvt_do_max_length) (struct _IO_codecvt *);\n+\n+  _IO_iconv_t __cd_in;\n+  _IO_iconv_t __cd_out;\n+};\n+#endif\n+\n+/* Extra data for wide character streams.  */\n+struct _IO_wide_data\n+{\n+  wchar_t *_IO_read_ptr;\t/* Current read pointer */\n+  wchar_t *_IO_read_end;\t/* End of get area. */\n+  wchar_t *_IO_read_base;\t/* Start of putback+get area. */\n+  wchar_t *_IO_write_base;\t/* Start of put area. */\n+  wchar_t *_IO_write_ptr;\t/* Current put pointer. */\n+  wchar_t *_IO_write_end;\t/* End of put area. */\n+  wchar_t *_IO_buf_base;\t/* Start of reserve area. */\n+  wchar_t *_IO_buf_end;\t\t/* End of reserve area. */\n+  /* The following fields are used to support backing up and undo. */\n+  wchar_t *_IO_save_base;\t/* Pointer to start of non-current get area. */\n+  wchar_t *_IO_backup_base;\t/* Pointer to first valid character of\n+\t\t\t\t   backup area */\n+  wchar_t *_IO_save_end;\t/* Pointer to end of non-current get area. */\n+\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  __mbstate_t _IO_state;\n+  __mbstate_t _IO_last_state;\n+  struct _IO_codecvt _codecvt;\n+#endif\n+\n+  wchar_t _shortbuf[1];\n+\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  struct _IO_jump_t *_wide_vtable;\n+#endif\n+};\n+\n+struct _IO_FILE_plus;\n+\n struct _IO_FILE {\n   int _flags;\t\t/* High-order word is _IO_MAGIC; rest is flags. */\n #define _IO_file_flags _flags\n@@ -229,76 +282,121 @@ struct _IO_FILE {\n \n   struct _IO_marker *_markers;\n \n-  struct _IO_FILE *_chain;\n+  struct _IO_FILE_plus *_chain;\n \n   int _fileno;\n   int _blksize;\n-#ifdef _G_IO_IO_FILE_VERSION\n-  _IO_off_t _old_offset;\n-#else\n-  _IO_off_t _offset;\n-#endif\n+  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n \n #define __HAVE_COLUMN /* temporary */\n   /* 1+column number of pbase(); 0 is unknown. */\n   unsigned short _cur_column;\n-  char _unused;\n+  signed char _vtable_offset;\n   char _shortbuf[1];\n \n   /*  char* _save_gptr;  char* _save_egptr; */\n \n-#ifdef _IO_LOCK_T\n-  _IO_LOCK_T _lock;\n+  _IO_lock_t *_lock;\n+#ifdef _IO_USE_OLD_IO_FILE\n+};\n+\n+struct _IO_FILE_complete\n+{\n+  struct _IO_FILE _file;\n #endif\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n+#if defined _G_IO_IO_FILE_VERSION && _G_IO_IO_FILE_VERSION == 0x20001\n   _IO_off64_t _offset;\n-  int _unused2[16];\t/* Make sure we don't get into trouble again.  */\n+# if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+  /* Wide character stream stuff.  */\n+  struct _IO_codecvt *_codecvt;\n+  struct _IO_wide_data *_wide_data;\n+# endif\n+  int _mode;\n+  /* Make sure we don't get into trouble again.  */\n+  char _unused2[15 * sizeof (int) - 2 * sizeof (void *)];\n #endif\n };\n \n #ifndef __cplusplus\n typedef struct _IO_FILE _IO_FILE;\n #endif\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#define _IO_stdin_ _IO_2_1_stdin_\n-#define _IO_stdout_ _IO_2_1_stdout_\n-#define _IO_stderr_ _IO_2_1_stderr_\n+extern struct _IO_FILE_plus _IO_2_1_stdin_;\n+extern struct _IO_FILE_plus _IO_2_1_stdout_;\n+extern struct _IO_FILE_plus _IO_2_1_stderr_;\n+#ifndef _LIBC\n+#define _IO_stdin ((_IO_FILE*)(&_IO_2_1_stdin_))\n+#define _IO_stdout ((_IO_FILE*)(&_IO_2_1_stdout_))\n+#define _IO_stderr ((_IO_FILE*)(&_IO_2_1_stderr_))\n+#else\n+extern _IO_FILE *_IO_stdin;\n+extern _IO_FILE *_IO_stdout;\n+extern _IO_FILE *_IO_stderr;\n #endif\n \n-struct _IO_FILE_plus;\n-extern struct _IO_FILE_plus _IO_stdin_, _IO_stdout_, _IO_stderr_;\n-#define _IO_stdin ((_IO_FILE*)(&_IO_stdin_))\n-#define _IO_stdout ((_IO_FILE*)(&_IO_stdout_))\n-#define _IO_stderr ((_IO_FILE*)(&_IO_stderr_))\n \n+/* Functions to do I/O and file management for a stream.  */\n+\n+/* Read NBYTES bytes from COOKIE into a buffer pointed to by BUF.\n+   Return number of bytes read.  */\n+typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);\n+\n+/* Write N bytes pointed to by BUF to COOKIE.  Write all N bytes\n+   unless there is an error.  Return number of bytes written, or -1 if\n+   there is an error without writing anything.  If the file has been\n+   opened for append (__mode.__append set), then set the file pointer\n+   to the end of the file and then do the write; if not, just write at\n+   the current file pointer.  */\n+typedef __ssize_t __io_write_fn (void *__cookie, __const char *__buf,\n+\t\t\t\t size_t __n);\n+\n+/* Move COOKIE's file position to *POS bytes from the\n+   beginning of the file (if W is SEEK_SET),\n+   the current position (if W is SEEK_CUR),\n+   or the end of the file (if W is SEEK_END).\n+   Set *POS to the new file position.\n+   Returns zero if successful, nonzero if not.  */\n+typedef int __io_seek_fn (void *__cookie, _IO_off64_t *__pos, int __w);\n+\n+/* Close COOKIE.  */\n+typedef int __io_close_fn (void *__cookie);\n \n-/* Define the user-visible type, with user-friendly member names.  */\n+\n+#ifdef _GNU_SOURCE\n+/* User-visible names for the above.  */\n+typedef __io_read_fn cookie_read_function_t;\n+typedef __io_write_fn cookie_write_function_t;\n+typedef __io_seek_fn cookie_seek_function_t;\n+typedef __io_close_fn cookie_close_function_t;\n+\n+/* The structure with the cookie function pointers.  */\n typedef struct\n {\n-  _IO_ssize_t (*read) __PMT ((struct _IO_FILE *, void *, _IO_ssize_t));\n-  _IO_ssize_t (*write) __PMT ((struct _IO_FILE *, const void *, _IO_ssize_t));\n-  _IO_off_t (*seek) __PMT ((struct _IO_FILE *, _IO_off_t, int));\n-  int (*close) __PMT ((struct _IO_FILE *));\n+  __io_read_fn *read;\t\t/* Read bytes.  */\n+  __io_write_fn *write;\t\t/* Write bytes.  */\n+  __io_seek_fn *seek;\t\t/* Seek/tell file position.  */\n+  __io_close_fn *close;\t\t/* Close file.  */\n } _IO_cookie_io_functions_t;\n+typedef _IO_cookie_io_functions_t cookie_io_functions_t;\n \n-/* Special file type for fopencookie function.  */\n-struct _IO_cookie_file\n-{\n-  struct _IO_FILE file;\n-  const void *vtable;\n-  void *cookie;\n-  _IO_cookie_io_functions_t io_functions;\n-};\n+struct _IO_cookie_file;\n+\n+/* Initialize one of those.  */\n+extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,\n+\t\t\t     void *__cookie, _IO_cookie_io_functions_t __fns);\n+#endif\n \n \n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-extern int __underflow __P ((_IO_FILE *));\n-extern int __uflow __P ((_IO_FILE *));\n-extern int __overflow __P ((_IO_FILE *, int));\n+extern int __underflow (_IO_FILE *) __THROW;\n+extern int __uflow (_IO_FILE *) __THROW;\n+extern int __overflow (_IO_FILE *, int) __THROW;\n+extern _IO_wint_t __wunderflow (_IO_FILE *) __THROW;\n+extern _IO_wint_t __wuflow (_IO_FILE *) __THROW;\n+extern _IO_wint_t __woverflow (_IO_FILE *, _IO_wint_t) __THROW;\n \n #define _IO_getc_unlocked(_fp) \\\n        ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end ? __uflow (_fp) \\\n@@ -307,29 +405,36 @@ extern int __overflow __P ((_IO_FILE *, int));\n        ((_fp)->_IO_read_ptr >= (_fp)->_IO_read_end \\\n \t  && __underflow (_fp) == EOF ? EOF \\\n \t: *(unsigned char *) (_fp)->_IO_read_ptr)\n-\n #define _IO_putc_unlocked(_ch, _fp) \\\n    (((_fp)->_IO_write_ptr >= (_fp)->_IO_write_end) \\\n     ? __overflow (_fp, (unsigned char) (_ch)) \\\n     : (unsigned char) (*(_fp)->_IO_write_ptr++ = (_ch)))\n \n+#define _IO_getwc_unlocked(_fp) \\\n+  ((_fp)->_wide_data->_IO_read_ptr >= (_fp)->_wide_data->_IO_read_end \\\n+   ? __wuflow (_fp) : (_IO_wint_t) *(_fp)->_wide_data->_IO_read_ptr++)\n+#define _IO_putwc_unlocked(_wch, _fp) \\\n+  ((_fp)->_wide_data->_IO_write_ptr >= (_fp)->_wide_data->_IO_write_end \\\n+   ? __woverflow (_fp, _wch) \\\n+   : (_IO_wint_t) (*(_fp)->_wide_data->_IO_write_ptr++ = (_wch)))\n+\n #define _IO_feof_unlocked(__fp) (((__fp)->_flags & _IO_EOF_SEEN) != 0)\n #define _IO_ferror_unlocked(__fp) (((__fp)->_flags & _IO_ERR_SEEN) != 0)\n \n-extern int _IO_getc __P ((_IO_FILE *__fp));\n-extern int _IO_putc __P ((int __c, _IO_FILE *__fp));\n-extern int _IO_feof __P ((_IO_FILE *__fp));\n-extern int _IO_ferror __P ((_IO_FILE *__fp));\n+extern int _IO_getc (_IO_FILE *__fp) __THROW;\n+extern int _IO_putc (int __c, _IO_FILE *__fp) __THROW;\n+extern int _IO_feof (_IO_FILE *__fp) __THROW;\n+extern int _IO_ferror (_IO_FILE *__fp) __THROW;\n \n-extern int _IO_peekc_locked __P ((_IO_FILE *__fp));\n+extern int _IO_peekc_locked (_IO_FILE *__fp) __THROW;\n \n /* This one is for Emacs. */\n #define _IO_PENDING_OUTPUT_COUNT(_fp)\t\\\n \t((_fp)->_IO_write_ptr - (_fp)->_IO_write_base)\n \n-extern void _IO_flockfile __P ((_IO_FILE *));\n-extern void _IO_funlockfile __P ((_IO_FILE *));\n-extern int _IO_ftrylockfile __P ((_IO_FILE *));\n+extern void _IO_flockfile (_IO_FILE *) __THROW;\n+extern void _IO_funlockfile (_IO_FILE *) __THROW;\n+extern int _IO_ftrylockfile (_IO_FILE *) __THROW;\n \n #ifdef _IO_MTSAFE_IO\n # define _IO_peekc(_fp) _IO_peekc_locked (_fp)\n@@ -342,24 +447,51 @@ extern int _IO_ftrylockfile __P ((_IO_FILE *));\n # define _IO_cleanup_region_end(_Doit) /**/\n #endif /* !_IO_MTSAFE_IO */\n \n+extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,\n+\t\t\t_IO_va_list, int *__restrict) __THROW;\n+extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,\n+\t\t\t _IO_va_list) __THROW;\n+extern _IO_ssize_t _IO_padn (_IO_FILE *, int, _IO_ssize_t) __THROW;\n+extern _IO_size_t _IO_sgetn (_IO_FILE *, void *, _IO_size_t) __THROW;\n+\n+extern _IO_off64_t _IO_seekoff (_IO_FILE *, _IO_off64_t, int, int) __THROW;\n+extern _IO_off64_t _IO_seekpos (_IO_FILE *, _IO_off64_t, int) __THROW;\n+\n+extern void _IO_free_backup_area (_IO_FILE *) __THROW;\n+\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+extern _IO_wint_t _IO_getwc (_IO_FILE *__fp) __THROW;\n+extern _IO_wint_t _IO_putwc (wchar_t __wc, _IO_FILE *__fp) __THROW;\n+extern int _IO_fwide (_IO_FILE *__fp, int __mode) __THROW;\n+# if __GNUC__ >= 2\n+/* A special optimized version of the function above.  It optimizes the\n+   case of initializing an unoriented byte stream.  */\n+#  define _IO_fwide(__fp, __mode) \\\n+  ({ int __result = (__mode);\t\t\t\t\t\t      \\\n+     if (__result < 0)\t\t\t\t\t\t\t      \\\n+       {\t\t\t\t\t\t\t\t      \\\n+\t if ((__fp)->_mode == 0)\t\t\t\t\t      \\\n+\t   /* We know that all we have to do is to set the flag.  */\t      \\\n+\t   (__fp)->_mode = -1;\t\t\t\t\t\t      \\\n+\t __result = (__fp)->_mode;\t\t\t\t\t      \\\n+       }\t\t\t\t\t\t\t\t      \\\n+     else\t\t\t\t\t\t\t\t      \\\n+       __result = _IO_fwide (__fp, __result);\t\t\t\t      \\\n+     __result; })\n+# endif\n \n-extern int _IO_vfscanf __P ((_IO_FILE *, const char *, _IO_va_list, int *));\n-extern int _IO_vfprintf __P ((_IO_FILE *, const char *, _IO_va_list));\n-extern _IO_ssize_t _IO_padn __P ((_IO_FILE *, int, _IO_ssize_t));\n-extern _IO_size_t _IO_sgetn __P ((_IO_FILE *, void *, _IO_size_t));\n-\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-extern _IO_off64_t _IO_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_off64_t _IO_seekpos __P ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-extern _IO_off_t _IO_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n-extern _IO_off_t _IO_seekpos __P ((_IO_FILE *, _IO_off_t, int));\n+extern int _IO_vfwscanf (_IO_FILE * __restrict, const wchar_t * __restrict,\n+\t\t\t _IO_va_list, int *__restrict) __THROW;\n+extern int _IO_vfwprintf (_IO_FILE *__restrict, const wchar_t *__restrict,\n+\t\t\t  _IO_va_list) __THROW;\n+extern _IO_ssize_t _IO_wpadn (_IO_FILE *, wint_t, _IO_ssize_t) __THROW;\n+extern void _IO_free_wbackup_area (_IO_FILE *) __THROW;\n #endif\n \n-extern void _IO_free_backup_area __P ((_IO_FILE *));\n-\n #ifdef __cplusplus\n }\n #endif\n \n #endif /* _IO_STDIO_H */\n+\n+"}, {"sha": "a9681a3ec5d7352fd2d90286aa3e8552028178e5", "filename": "libstdc++-v3/libio/libioP.h", "status": "modified", "additions": 291, "deletions": 125, "changes": 416, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2FlibioP.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2FlibioP.h?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1993, 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1993, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n    This file is part of the GNU IO Library.\n \n    This library is free software; you can redistribute it and/or\n@@ -23,25 +23,14 @@\n    other reasons why the executable file might be covered by the GNU\n    General Public License.  */\n \n-#ifndef _POSIX_SOURCE\n-# define _POSIX_SOURCE\n-#endif\n-\n #include <errno.h>\n #ifndef __set_errno\n # define __set_errno(Val) errno = (Val)\n #endif\n-\n-#ifdef _IO_MTSAFE_IO\n-# if defined __GLIBC__ && __GLIBC__ >= 2\n-#  if __GLIBC_MINOR__ > 0\n-#   include <bits/libc-lock.h>\n-#  else\n-#   include <libc-lock.h>\n-#  endif\n-# else\n+#if defined __GLIBC__ && __GLIBC__ >= 2\n+# include <bits/libc-lock.h>\n+#else\n /*# include <comthread.h>*/\n-# endif\n #endif\n \n #include \"iolibio.h\"\n@@ -75,113 +64,142 @@ extern \"C\" {\n  * object being acted on (i.e. the 'this' parameter).\n  */\n \n+#if (!defined _IO_USE_OLD_IO_FILE \\\n+     && (!defined _G_IO_NO_BACKWARD_COMPAT || _G_IO_NO_BACKWARD_COMPAT == 0))\n+# define _IO_JUMPS_OFFSET 1\n+#endif\n+\n #define _IO_JUMPS(THIS) ((struct _IO_FILE_plus *) (THIS))->vtable\n+#define _IO_WIDE_JUMPS(THIS) ((struct _IO_FILE *) (THIS))->_wide_data->_wide_vtable\n+#define _IO_CHECK_WIDE(THIS) (((struct _IO_FILE *) (THIS))->_wide_data != NULL)\n+\n+#if _IO_JUMPS_OFFSET\n+# define _IO_JUMPS_FUNC(THIS) \\\n+ (*(struct _IO_jump_t **) ((char *) &_IO_JUMPS ((struct _IO_FILE_plus *) (THIS)) \\\n+\t\t\t   + (THIS)->_vtable_offset))\n+#else\n+# define _IO_JUMPS_FUNC(THIS) _IO_JUMPS ((struct _IO_FILE_plus *) (THIS))\n+#endif\n+#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n #ifdef _G_USING_THUNKS\n # define JUMP_FIELD(TYPE, NAME) TYPE NAME\n-# define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC (THIS)\n-# define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC (THIS, X1)\n-# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC (THIS, X1, X2)\n-# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC (THIS, X1,X2, X3)\n+# define JUMP0(FUNC, THIS) _IO_JUMPS_FUNC(THIS)->FUNC (THIS)\n+# define JUMP1(FUNC, THIS, X1) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1)\n+# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)\n+# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)\n # define JUMP_INIT(NAME, VALUE) VALUE\n # define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0), JUMP_INIT (dummy2, 0)\n+\n+# define WJUMP0(FUNC, THIS) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS)\n+# define WJUMP1(FUNC, THIS, X1) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1)\n+# define WJUMP2(FUNC, THIS, X1, X2) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1, X2)\n+# define WJUMP3(FUNC, THIS, X1,X2,X3) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC (THIS, X1,X2, X3)\n #else\n /* These macros will change when we re-implement vtables to use \"thunks\"! */\n # define JUMP_FIELD(TYPE, NAME) struct { short delta1, delta2; TYPE pfn; } NAME\n-# define JUMP0(FUNC, THIS) _IO_JUMPS(THIS)->FUNC.pfn (THIS)\n-# define JUMP1(FUNC, THIS, X1) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1)\n-# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1, X2)\n-# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n+# define JUMP0(FUNC, THIS) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)\n+# define JUMP1(FUNC, THIS, X1) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)\n+# define JUMP2(FUNC, THIS, X1, X2) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)\n+# define JUMP3(FUNC, THIS, X1,X2,X3) _IO_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n # define JUMP_INIT(NAME, VALUE) {0, 0, VALUE}\n # define JUMP_INIT_DUMMY JUMP_INIT(dummy, 0)\n+\n+# define WJUMP0(FUNC, THIS) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS)\n+# define WJUMP1(FUNC, THIS, X1) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1)\n+# define WJUMP2(FUNC, THIS, X1, X2) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1, X2)\n+# define WJUMP3(FUNC, THIS, X1,X2,X3) _IO_WIDE_JUMPS_FUNC(THIS)->FUNC.pfn (THIS, X1,X2,X3)\n #endif\n \n /* The 'finish' function does any final cleaning up of an _IO_FILE object.\n-   It does not delete (free) it, but does everything else to finalize it/\n+   It does not delete (free) it, but does everything else to finalize it.\n    It matches the streambuf::~streambuf virtual destructor.  */\n typedef void (*_IO_finish_t) __PMT ((_IO_FILE *, int)); /* finalize */\n #define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)\n+#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)\n \n /* The 'overflow' hook flushes the buffer.\n    The second argument is a character, or EOF.\n    It matches the streambuf::overflow virtual function. */\n typedef int (*_IO_overflow_t) __PMT ((_IO_FILE *, int));\n #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n+#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)\n \n /* The 'underflow' hook tries to fills the get buffer.\n    It returns the next character (as an unsigned char) or EOF.  The next\n    character remains in the get buffer, and the get position is not changed.\n    It matches the streambuf::underflow virtual function. */\n typedef int (*_IO_underflow_t) __PMT ((_IO_FILE *));\n #define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)\n+#define _IO_WUNDERFLOW(FP) WJUMP0 (__underflow, FP)\n \n /* The 'uflow' hook returns the next character in the input stream\n    (cast to unsigned char), and increments the read position;\n    EOF is returned on failure.\n    It matches the streambuf::uflow virtual function, which is not in the\n    cfront implementation, but was added to C++ by the ANSI/ISO committee. */\n #define _IO_UFLOW(FP) JUMP0 (__uflow, FP)\n+#define _IO_WUFLOW(FP) WJUMP0 (__uflow, FP)\n \n /* The 'pbackfail' hook handles backing up.\n    It matches the streambuf::pbackfail virtual function. */\n typedef int (*_IO_pbackfail_t) __PMT ((_IO_FILE *, int));\n #define _IO_PBACKFAIL(FP, CH) JUMP1 (__pbackfail, FP, CH)\n+#define _IO_WPBACKFAIL(FP, CH) WJUMP1 (__pbackfail, FP, CH)\n \n /* The 'xsputn' hook writes upto N characters from buffer DATA.\n    Returns the number of character actually written.\n    It matches the streambuf::xsputn virtual function. */\n typedef _IO_size_t (*_IO_xsputn_t) __PMT ((_IO_FILE *FP, const void *DATA,\n-\t\t\t\t\t _IO_size_t N));\n+\t\t\t\t\t   _IO_size_t N));\n #define _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)\n+#define _IO_WXSPUTN(FP, DATA, N) WJUMP2 (__xsputn, FP, DATA, N)\n \n /* The 'xsgetn' hook reads upto N characters into buffer DATA.\n    Returns the number of character actually read.\n    It matches the streambuf::xsgetn virtual function. */\n typedef _IO_size_t (*_IO_xsgetn_t) __PMT ((_IO_FILE *FP, void *DATA,\n-\t\t\t\t\t _IO_size_t N));\n+\t\t\t\t\t   _IO_size_t N));\n #define _IO_XSGETN(FP, DATA, N) JUMP2 (__xsgetn, FP, DATA, N)\n+#define _IO_WXSGETN(FP, DATA, N) WJUMP2 (__xsgetn, FP, DATA, N)\n \n /* The 'seekoff' hook moves the stream position to a new position\n    relative to the start of the file (if DIR==0), the current position\n    (MODE==1), or the end of the file (MODE==2).\n    It matches the streambuf::seekoff virtual function.\n    It is also used for the ANSI fseek function. */\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n typedef _IO_off64_t (*_IO_seekoff_t) __PMT ((_IO_FILE *FP, _IO_off64_t OFF,\n-\t\t\t\t\t  int DIR, int MODE));\n-#else\n-typedef _IO_off_t (*_IO_seekoff_t) __PMT ((_IO_FILE *FP, _IO_off_t OFF,\n-\t\t\t\t\t  int DIR, int MODE));\n-#endif\n+\t\t\t\t\t     int DIR, int MODE));\n #define _IO_SEEKOFF(FP, OFF, DIR, MODE) JUMP3 (__seekoff, FP, OFF, DIR, MODE)\n+#define _IO_WSEEKOFF(FP, OFF, DIR, MODE) WJUMP3 (__seekoff, FP, OFF, DIR, MODE)\n \n /* The 'seekpos' hook also moves the stream position,\n-   but to an absolute position given by a fpos_t (seekpos).\n+   but to an absolute position given by a fpos64_t (seekpos).\n    It matches the streambuf::seekpos virtual function.\n    It is also used for the ANSI fgetpos and fsetpos functions.  */\n /* The _IO_seek_cur and _IO_seek_end options are not allowed. */\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n typedef _IO_off64_t (*_IO_seekpos_t) __PMT ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-typedef _IO_off_t (*_IO_seekpos_t) __PMT ((_IO_FILE *, _IO_off_t, int));\n-#endif\n #define _IO_SEEKPOS(FP, POS, FLAGS) JUMP2 (__seekpos, FP, POS, FLAGS)\n+#define _IO_WSEEKPOS(FP, POS, FLAGS) WJUMP2 (__seekpos, FP, POS, FLAGS)\n \n /* The 'setbuf' hook gives a buffer to the file.\n    It matches the streambuf::setbuf virtual function. */\n typedef _IO_FILE* (*_IO_setbuf_t) __PMT ((_IO_FILE *, char *, _IO_ssize_t));\n #define _IO_SETBUF(FP, BUFFER, LENGTH) JUMP2 (__setbuf, FP, BUFFER, LENGTH)\n+#define _IO_WSETBUF(FP, BUFFER, LENGTH) WJUMP2 (__setbuf, FP, BUFFER, LENGTH)\n \n /* The 'sync' hook attempts to synchronize the internal data structures\n    of the file with the external state.\n    It matches the streambuf::sync virtual function. */\n typedef int (*_IO_sync_t) __PMT ((_IO_FILE *));\n #define _IO_SYNC(FP) JUMP0 (__sync, FP)\n+#define _IO_WSYNC(FP) WJUMP0 (__sync, FP)\n \n /* The 'doallocate' hook is used to tell the file to allocate a buffer.\n    It matches the streambuf::doallocate virtual function, which is not\n    in the ANSI/ISO C++ standard, but is part traditional implementations. */\n typedef int (*_IO_doallocate_t) __PMT ((_IO_FILE *));\n #define _IO_DOALLOCATE(FP) JUMP0 (__doallocate, FP)\n+#define _IO_WDOALLOCATE(FP) WJUMP0 (__doallocate, FP)\n \n /* The following four hooks (sysread, syswrite, sysclose, sysseek, and\n    sysstat) are low-level hooks specific to this implementation.\n@@ -200,51 +218,53 @@ typedef int (*_IO_doallocate_t) __PMT ((_IO_FILE *));\n    specific to this implementation. */\n typedef _IO_ssize_t (*_IO_read_t) __PMT ((_IO_FILE *, void *, _IO_ssize_t));\n #define _IO_SYSREAD(FP, DATA, LEN) JUMP2 (__read, FP, DATA, LEN)\n+#define _IO_WSYSREAD(FP, DATA, LEN) WJUMP2 (__read, FP, DATA, LEN)\n \n /* The 'syswrite' hook is used to write data from an existing buffer\n    to an external file.  It generalizes the Unix write(2) function.\n    It matches the streambuf::sys_write virtual function, which is\n    specific to this implementation. */\n-typedef _IO_ssize_t (*_IO_write_t) __PMT ((_IO_FILE *,const void *,_IO_ssize_t));\n+typedef _IO_ssize_t (*_IO_write_t) __PMT ((_IO_FILE *, const void *,\n+\t\t\t\t\t   _IO_ssize_t));\n #define _IO_SYSWRITE(FP, DATA, LEN) JUMP2 (__write, FP, DATA, LEN)\n+#define _IO_WSYSWRITE(FP, DATA, LEN) WJUMP2 (__write, FP, DATA, LEN)\n \n /* The 'sysseek' hook is used to re-position an external file.\n    It generalizes the Unix lseek(2) function.\n    It matches the streambuf::sys_seek virtual function, which is\n    specific to this implementation. */\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n typedef _IO_off64_t (*_IO_seek_t) __PMT ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-typedef _IO_off_t (*_IO_seek_t) __PMT ((_IO_FILE *, _IO_off_t, int));\n-#endif\n #define _IO_SYSSEEK(FP, OFFSET, MODE) JUMP2 (__seek, FP, OFFSET, MODE)\n+#define _IO_WSYSSEEK(FP, OFFSET, MODE) WJUMP2 (__seek, FP, OFFSET, MODE)\n \n /* The 'sysclose' hook is used to finalize (close, finish up) an\n    external file.  It generalizes the Unix close(2) function.\n    It matches the streambuf::sys_close virtual function, which is\n    specific to this implementation. */\n typedef int (*_IO_close_t) __PMT ((_IO_FILE *)); /* finalize */\n #define _IO_SYSCLOSE(FP) JUMP0 (__close, FP)\n+#define _IO_WSYSCLOSE(FP) WJUMP0 (__close, FP)\n \n /* The 'sysstat' hook is used to get information about an external file\n    into a struct stat buffer.  It generalizes the Unix fstat(2) call.\n    It matches the streambuf::sys_stat virtual function, which is\n    specific to this implementation. */\n typedef int (*_IO_stat_t) __PMT ((_IO_FILE *, void *));\n #define _IO_SYSSTAT(FP, BUF) JUMP1 (__stat, FP, BUF)\n+#define _IO_WSYSSTAT(FP, BUF) WJUMP1 (__stat, FP, BUF)\n \n-#if _G_IO_IO_FILE_VERSION == 0x20001\n /* The 'showmany' hook can be used to get an image how much input is\n    available.  In many cases the answer will be 0 which means unknown\n    but some cases one can provide real information.  */\n typedef int (*_IO_showmanyc_t) __PMT ((_IO_FILE *));\n #define _IO_SHOWMANYC(FP) JUMP0 (__showmanyc, FP)\n+#define _IO_WSHOWMANYC(FP) WJUMP0 (__showmanyc, FP)\n \n /* The 'imbue' hook is used to get information about the currently\n    installed locales.  */\n typedef void (*_IO_imbue_t) __PMT ((_IO_FILE *, void *));\n #define _IO_IMBUE(FP, LOCALE) JUMP1 (__imbue, FP, LOCALE)\n-#endif\n+#define _IO_WIMBUE(FP, LOCALE) WJUMP1 (__imbue, FP, LOCALE)\n \n \n #define _IO_CHAR_TYPE char /* unsigned char ? */\n@@ -274,10 +294,8 @@ struct _IO_jump_t\n     JUMP_FIELD(_IO_seek_t, __seek);\n     JUMP_FIELD(_IO_close_t, __close);\n     JUMP_FIELD(_IO_stat_t, __stat);\n-#if _G_IO_IO_FILE_VERSION == 0x20001\n     JUMP_FIELD(_IO_showmanyc_t, __showmanyc);\n     JUMP_FIELD(_IO_imbue_t, __imbue);\n-#endif\n #if 0\n     get_column;\n     set_column;\n@@ -295,146 +313,265 @@ struct _IO_FILE_plus\n   const struct _IO_jump_t *vtable;\n };\n \n-/* Generic functions */\n+/* Special file type for fopencookie function.  */\n+struct _IO_cookie_file\n+{\n+  struct _IO_FILE_plus __fp;\n+  void *__cookie;\n+  _IO_cookie_io_functions_t __io_functions;\n+};\n \n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-extern _IO_off64_t _IO_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_off64_t _IO_seekpos __P ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-extern _IO_off_t _IO_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n-extern _IO_off_t _IO_seekpos __P ((_IO_FILE *, _IO_off_t, int));\n-#endif\n+/* Iterator type for walking global linked list of _IO_FILE objects. */\n+\n+typedef struct _IO_FILE_plus *_IO_ITER;\n+\n+/* Generic functions */\n \n extern void _IO_switch_to_main_get_area __P ((_IO_FILE *));\n extern void _IO_switch_to_backup_area __P ((_IO_FILE *));\n extern int _IO_switch_to_get_mode __P ((_IO_FILE *));\n extern void _IO_init __P ((_IO_FILE *, int));\n extern int _IO_sputbackc __P ((_IO_FILE *, int));\n extern int _IO_sungetc __P ((_IO_FILE *));\n-extern void _IO_un_link __P ((_IO_FILE *));\n-extern void _IO_link_in __P ((_IO_FILE *));\n+extern void _IO_un_link __P ((struct _IO_FILE_plus *));\n+extern void _IO_link_in __P ((struct _IO_FILE_plus *));\n extern void _IO_doallocbuf __P ((_IO_FILE *));\n extern void _IO_unsave_markers __P ((_IO_FILE *));\n extern void _IO_setb __P ((_IO_FILE *, char *, char *, int));\n extern unsigned _IO_adjust_column __P ((unsigned, const char *, int));\n #define _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)\n \n+extern void _IO_switch_to_main_wget_area __P ((_IO_FILE *));\n+extern void _IO_switch_to_wbackup_area __P ((_IO_FILE *));\n+extern int _IO_switch_to_wget_mode __P ((_IO_FILE *));\n+extern void _IO_wsetb __P ((_IO_FILE *, wchar_t *, wchar_t *, int));\n+extern wint_t _IO_sputbackwc __P ((_IO_FILE *, wint_t));\n+extern wint_t _IO_sungetwc __P ((_IO_FILE *));\n+extern void _IO_wdoallocbuf __P ((_IO_FILE *));\n+extern void _IO_unsave_wmarkers __P ((_IO_FILE *));\n+extern unsigned _IO_adjust_wcolumn __P ((unsigned, const wchar_t *, int));\n+\n /* Marker-related function. */\n \n extern void _IO_init_marker __P ((struct _IO_marker *, _IO_FILE *));\n+extern void _IO_init_wmarker __P ((struct _IO_marker *, _IO_FILE *));\n extern void _IO_remove_marker __P ((struct _IO_marker *));\n extern int _IO_marker_difference __P ((struct _IO_marker *,\n \t\t\t\t       struct _IO_marker *));\n extern int _IO_marker_delta __P ((struct _IO_marker *));\n+extern int _IO_wmarker_delta __P ((struct _IO_marker *));\n extern int _IO_seekmark __P ((_IO_FILE *, struct _IO_marker *, int));\n+extern int _IO_seekwmark __P ((_IO_FILE *, struct _IO_marker *, int));\n+\n+/* Functions for iterating global list and dealing with\n+   its lock */\n+\n+extern _IO_ITER _IO_iter_begin __P ((void));\n+extern _IO_ITER _IO_iter_end __P ((void));\n+extern _IO_ITER _IO_iter_next __P ((_IO_ITER));\n+extern _IO_FILE *_IO_iter_file __P ((_IO_ITER));\n+extern void _IO_list_lock __P ((void));\n+extern void _IO_list_unlock __P ((void));\n+extern void _IO_list_resetlock __P ((void));\n \n /* Default jumptable functions. */\n \n extern int _IO_default_underflow __P ((_IO_FILE *));\n extern int _IO_default_uflow __P ((_IO_FILE *));\n+extern wint_t _IO_wdefault_uflow __P ((_IO_FILE *));\n extern int _IO_default_doallocate __P ((_IO_FILE *));\n+extern int _IO_wdefault_doallocate __P ((_IO_FILE *));\n extern void _IO_default_finish __P ((_IO_FILE *, int));\n+extern void _IO_wdefault_finish __P ((_IO_FILE *, int));\n extern int _IO_default_pbackfail __P ((_IO_FILE *, int));\n+extern wint_t _IO_wdefault_pbackfail __P ((_IO_FILE *, wint_t));\n extern _IO_FILE* _IO_default_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n+extern _IO_FILE* _IO_wdefault_setbuf __P ((_IO_FILE *, wchar_t *,\n+\t\t\t\t\t   _IO_ssize_t));\n extern _IO_size_t _IO_default_xsputn __P ((_IO_FILE *, const void *,\n \t\t\t\t\t   _IO_size_t));\n+extern _IO_size_t _IO_wdefault_xsputn __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t    _IO_size_t));\n extern _IO_size_t _IO_default_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n+extern _IO_size_t _IO_wdefault_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n extern _IO_off64_t _IO_default_seekoff __P ((_IO_FILE *,\n-\t\t\t\t\t      _IO_off64_t, int, int));\n-extern _IO_off64_t _IO_default_seekpos __P ((_IO_FILE *,\n-\t\t\t\t\t      _IO_off64_t, int));\n-extern _IO_off64_t _IO_default_seek __P ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-extern _IO_off_t _IO_default_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n-extern _IO_off_t _IO_default_seekpos __P ((_IO_FILE *, _IO_off_t, int));\n-extern _IO_off_t _IO_default_seek __P ((_IO_FILE *, _IO_off_t, int));\n-#endif\n+\t\t\t\t\t     _IO_off64_t, int, int));\n+extern _IO_off64_t _IO_default_seekpos __P ((_IO_FILE *, _IO_off64_t, int));\n extern _IO_ssize_t _IO_default_write __P ((_IO_FILE *, const void *,\n \t\t\t\t\t   _IO_ssize_t));\n extern _IO_ssize_t _IO_default_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n extern int _IO_default_stat __P ((_IO_FILE *, void *));\n+extern _IO_off64_t _IO_default_seek __P ((_IO_FILE *, _IO_off64_t, int));\n extern int _IO_default_sync __P ((_IO_FILE *));\n #define _IO_default_close ((_IO_close_t) _IO_default_sync)\n+extern int _IO_default_showmanyc __P ((_IO_FILE *));\n+extern void _IO_default_imbue __P ((_IO_FILE *, void *));\n \n extern struct _IO_jump_t _IO_file_jumps;\n+extern struct _IO_jump_t _IO_wfile_jumps;\n+extern struct _IO_jump_t _IO_old_file_jumps;\n extern struct _IO_jump_t _IO_streambuf_jumps;\n extern struct _IO_jump_t _IO_proc_jumps;\n+extern struct _IO_jump_t _IO_old_proc_jumps;\n extern struct _IO_jump_t _IO_str_jumps;\n+extern struct _IO_jump_t _IO_wstr_jumps;\n+extern struct _IO_codecvt __libio_codecvt;\n extern int _IO_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n+extern int _IO_new_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n+extern int _IO_old_do_write __P ((_IO_FILE *, const char *, _IO_size_t));\n+extern int _IO_wdo_write __P ((_IO_FILE *, const wchar_t *, _IO_size_t));\n extern int _IO_flush_all __P ((void));\n-extern void _IO_cleanup __P ((void));\n+extern int _IO_cleanup __P ((void));\n extern void _IO_flush_all_linebuffered __P ((void));\n-\n-#define _IO_do_flush(_f) \\\n-  _IO_do_write(_f, (_f)->_IO_write_base, \\\n-\t       (_f)->_IO_write_ptr-(_f)->_IO_write_base)\n+extern int _IO_new_fgetpos __P ((_IO_FILE *, _IO_fpos_t *));\n+extern int _IO_old_fgetpos __P ((_IO_FILE *, _IO_fpos_t *));\n+extern int _IO_new_fsetpos __P ((_IO_FILE *, const _IO_fpos_t *));\n+extern int _IO_old_fsetpos __P ((_IO_FILE *, const _IO_fpos_t *));\n+extern int _IO_new_fgetpos64 __P ((_IO_FILE *, _IO_fpos64_t *));\n+extern int _IO_old_fgetpos64 __P ((_IO_FILE *, _IO_fpos64_t *));\n+extern int _IO_new_fsetpos64 __P ((_IO_FILE *, const _IO_fpos64_t *));\n+extern int _IO_old_fsetpos64 __P ((_IO_FILE *, const _IO_fpos64_t *));\n+\n+\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+# define _IO_do_flush(_f) \\\n+  ((_f)->_mode <= 0\t\t\t\t\t\t\t      \\\n+   ? _IO_do_write(_f, (_f)->_IO_write_base,\t\t\t\t      \\\n+\t\t  (_f)->_IO_write_ptr-(_f)->_IO_write_base)\t\t      \\\n+   : _IO_wdo_write(_f, (_f)->_wide_data->_IO_write_base,\t\t      \\\n+\t\t   ((_f)->_wide_data->_IO_write_ptr\t\t\t      \\\n+\t\t    - (_f)->_wide_data->_IO_write_base)))\n+#else\n+# define _IO_do_flush(_f) \\\n+   _IO_do_write(_f, (_f)->_IO_write_base,\t\t\t\t      \\\n+\t\t(_f)->_IO_write_ptr-(_f)->_IO_write_base)\n+#endif\n+#define _IO_old_do_flush(_f) \\\n+  _IO_old_do_write(_f, (_f)->_IO_write_base, \\\n+\t\t   (_f)->_IO_write_ptr-(_f)->_IO_write_base)\n #define _IO_in_put_mode(_fp) ((_fp)->_flags & _IO_CURRENTLY_PUTTING)\n #define _IO_mask_flags(fp, f, mask) \\\n        ((fp)->_flags = ((fp)->_flags & ~(mask)) | ((f) & (mask)))\n #define _IO_setg(fp, eb, g, eg)  ((fp)->_IO_read_base = (eb),\\\n \t(fp)->_IO_read_ptr = (g), (fp)->_IO_read_end = (eg))\n+#define _IO_wsetg(fp, eb, g, eg)  ((fp)->_wide_data->_IO_read_base = (eb),\\\n+\t(fp)->_wide_data->_IO_read_ptr = (g), \\\n+\t(fp)->_wide_data->_IO_read_end = (eg))\n #define _IO_setp(__fp, __p, __ep) \\\n-       ((__fp)->_IO_write_base = (__fp)->_IO_write_ptr = __p, (__fp)->_IO_write_end = (__ep))\n+       ((__fp)->_IO_write_base = (__fp)->_IO_write_ptr \\\n+\t= __p, (__fp)->_IO_write_end = (__ep))\n+#define _IO_wsetp(__fp, __p, __ep) \\\n+       ((__fp)->_wide_data->_IO_write_base \\\n+\t= (__fp)->_wide_data->_IO_write_ptr = __p, \\\n+\t(__fp)->_wide_data->_IO_write_end = (__ep))\n #define _IO_have_backup(fp) ((fp)->_IO_save_base != NULL)\n+#define _IO_have_wbackup(fp) ((fp)->_wide_data->_IO_save_base != NULL)\n #define _IO_in_backup(fp) ((fp)->_flags & _IO_IN_BACKUP)\n #define _IO_have_markers(fp) ((fp)->_markers != NULL)\n #define _IO_blen(fp) ((fp)->_IO_buf_end - (fp)->_IO_buf_base)\n+#define _IO_wblen(fp) ((fp)->_wide_data->_IO_buf_end \\\n+\t\t       - (fp)->_wide_data->_IO_buf_base)\n \n /* Jumptable functions for files. */\n \n extern int _IO_file_doallocate __P ((_IO_FILE *));\n extern _IO_FILE* _IO_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n extern _IO_off64_t _IO_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-extern _IO_off64_t _IO_file_seek __P ((_IO_FILE *, _IO_off64_t, int));\n-#else\n-extern _IO_off_t _IO_file_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n-extern _IO_off_t _IO_file_seek __P ((_IO_FILE *, _IO_off_t, int));\n-#endif\n extern _IO_size_t _IO_file_xsputn __P ((_IO_FILE *, const void *, _IO_size_t));\n+extern _IO_size_t _IO_file_xsgetn __P ((_IO_FILE *, void *, _IO_size_t));\n extern int _IO_file_stat __P ((_IO_FILE *, void *));\n extern int _IO_file_close __P ((_IO_FILE *));\n extern int _IO_file_underflow __P ((_IO_FILE *));\n extern int _IO_file_overflow __P ((_IO_FILE *, int));\n-#define _IO_file_is_open(__fp) ((__fp)->_fileno >= 0)\n-extern void _IO_file_init __P ((_IO_FILE *));\n+#define _IO_file_is_open(__fp) ((__fp)->_fileno != -1)\n+extern void _IO_file_init __P ((struct _IO_FILE_plus *));\n extern _IO_FILE* _IO_file_attach __P ((_IO_FILE *, int));\n extern _IO_FILE* _IO_file_open __P ((_IO_FILE *, const char *, int, int,\n \t\t\t\t     int, int));\n-#if _G_IO_IO_FILE_VERSION == 0x20001\n extern _IO_FILE* _IO_file_fopen __P ((_IO_FILE *, const char *, const char *,\n \t\t\t\t      int));\n-#else\n-extern _IO_FILE* _IO_file_fopen __P ((_IO_FILE *, const char *, const char *));\n-#endif\n extern _IO_ssize_t _IO_file_write __P ((_IO_FILE *, const void *,\n \t\t\t\t\t_IO_ssize_t));\n extern _IO_ssize_t _IO_file_read __P ((_IO_FILE *, void *, _IO_ssize_t));\n extern int _IO_file_sync __P ((_IO_FILE *));\n extern int _IO_file_close_it __P ((_IO_FILE *));\n+extern _IO_off64_t _IO_file_seek __P ((_IO_FILE *, _IO_off64_t, int));\n extern void _IO_file_finish __P ((_IO_FILE *, int));\n \n+extern _IO_FILE* _IO_new_file_attach __P ((_IO_FILE *, int));\n+extern int _IO_new_file_close_it __P ((_IO_FILE *));\n+extern void _IO_new_file_finish __P ((_IO_FILE *, int));\n+extern _IO_FILE* _IO_new_file_fopen __P ((_IO_FILE *, const char *, const char *,\n+\t\t\t\t\t  int));\n+extern void _IO_no_init __P ((_IO_FILE *, int, int, struct _IO_wide_data *,\n+\t\t\t      struct _IO_jump_t *));\n+extern void _IO_new_file_init __P ((struct _IO_FILE_plus *));\n+extern _IO_FILE* _IO_new_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n+extern int _IO_new_file_sync __P ((_IO_FILE *));\n+extern int _IO_new_file_underflow __P ((_IO_FILE *));\n+extern int _IO_new_file_overflow __P ((_IO_FILE *, int));\n+extern _IO_off64_t _IO_new_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n+extern _IO_ssize_t _IO_new_file_write __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t    _IO_ssize_t));\n+extern _IO_size_t _IO_new_file_xsputn __P ((_IO_FILE *, const void *, _IO_size_t));\n+\n+extern _IO_FILE* _IO_old_file_setbuf __P ((_IO_FILE *, char *, _IO_ssize_t));\n+extern _IO_off64_t _IO_old_file_seekoff __P ((_IO_FILE *, _IO_off64_t, int,\n+\t\t\t\t\t      int));\n+extern _IO_size_t _IO_old_file_xsputn __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t    _IO_size_t));\n+extern int _IO_old_file_underflow __P ((_IO_FILE *));\n+extern int _IO_old_file_overflow __P ((_IO_FILE *, int));\n+extern void _IO_old_file_init __P ((struct _IO_FILE_plus *));\n+extern _IO_FILE* _IO_old_file_attach __P ((_IO_FILE *, int));\n+extern _IO_FILE* _IO_old_file_fopen __P ((_IO_FILE *, const char *,\n+\t\t\t\t\t  const char *));\n+extern _IO_ssize_t _IO_old_file_write __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t    _IO_ssize_t));\n+extern int _IO_old_file_sync __P ((_IO_FILE *));\n+extern int _IO_old_file_close_it __P ((_IO_FILE *));\n+extern void _IO_old_file_finish __P ((_IO_FILE *, int));\n+\n+extern int _IO_wfile_doallocate __P ((_IO_FILE *));\n+extern _IO_size_t _IO_wfile_xsputn __P ((_IO_FILE *, const void *,\n+\t\t\t\t\t _IO_size_t));\n+extern _IO_FILE* _IO_wfile_setbuf __P ((_IO_FILE *, wchar_t *, _IO_ssize_t));\n+extern wint_t _IO_wfile_sync __P ((_IO_FILE *));\n+extern wint_t _IO_wfile_underflow __P ((_IO_FILE *));\n+extern wint_t _IO_wfile_overflow __P ((_IO_FILE *, wint_t));\n+extern _IO_off64_t _IO_wfile_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n+\n /* Jumptable functions for proc_files. */\n extern _IO_FILE* _IO_proc_open __P ((_IO_FILE *, const char *, const char *));\n+extern _IO_FILE* _IO_new_proc_open __P ((_IO_FILE *, const char *, const char *));\n+extern _IO_FILE* _IO_old_proc_open __P ((_IO_FILE *, const char *, const char *));\n extern int _IO_proc_close __P ((_IO_FILE *));\n+extern int _IO_new_proc_close __P ((_IO_FILE *));\n+extern int _IO_old_proc_close __P ((_IO_FILE *));\n \n /* Jumptable functions for strfiles. */\n extern int _IO_str_underflow __P ((_IO_FILE *));\n extern int _IO_str_overflow __P ((_IO_FILE *, int));\n extern int _IO_str_pbackfail __P ((_IO_FILE *, int));\n-#if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n extern _IO_off64_t _IO_str_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n-#else\n-extern _IO_off_t _IO_str_seekoff __P ((_IO_FILE *, _IO_off_t, int, int));\n-#endif\n extern void _IO_str_finish __P ((_IO_FILE *, int));\n \n /* Other strfile functions */\n-extern void _IO_str_init_static __P ((_IO_FILE *, char *, int, char *));\n-extern void _IO_str_init_readonly __P ((_IO_FILE *, const char *, int));\n+struct _IO_strfile_;\n+extern void _IO_str_init_static __P ((struct _IO_strfile_ *, char *, int, char *));\n+extern void _IO_str_init_readonly __P ((struct _IO_strfile_ *, const char *, int));\n extern _IO_ssize_t _IO_str_count __P ((_IO_FILE *));\n \n+/* And the wide character versions.  */\n+extern void _IO_wstr_init_static __P ((_IO_FILE *, wchar_t *, int, wchar_t *));\n+extern void _IO_wstr_init_readonly __P ((_IO_FILE *, const char *, int));\n+extern _IO_ssize_t _IO_wstr_count __P ((_IO_FILE *));\n+extern _IO_wint_t _IO_wstr_overflow __P ((_IO_FILE *, _IO_wint_t));\n+extern _IO_wint_t _IO_wstr_underflow __P ((_IO_FILE *));\n+extern _IO_off64_t _IO_wstr_seekoff __P ((_IO_FILE *, _IO_off64_t, int, int));\n+extern _IO_wint_t _IO_wstr_pbackfail __P ((_IO_FILE *, _IO_wint_t));\n+extern void _IO_wstr_finish __P ((_IO_FILE *, int));\n+\n extern int _IO_vasprintf __P ((char **result_ptr, __const char *format,\n \t\t\t       _IO_va_list args));\n extern int _IO_vdprintf __P ((int d, __const char *format, _IO_va_list arg));\n@@ -446,14 +583,18 @@ extern _IO_size_t _IO_getline __P ((_IO_FILE *,char *, _IO_size_t, int, int));\n extern _IO_size_t _IO_getline_info __P ((_IO_FILE *,char *, _IO_size_t,\n \t\t\t\t\t int, int, int *));\n extern _IO_ssize_t _IO_getdelim __P ((char **, _IO_size_t *, int, _IO_FILE *));\n+extern _IO_size_t _IO_getwline __P ((_IO_FILE *,wchar_t *, _IO_size_t, wint_t,\n+\t\t\t\t     int));\n+extern _IO_size_t _IO_getwline_info __P ((_IO_FILE *,wchar_t *, _IO_size_t,\n+\t\t\t\t\t  wint_t, int, wint_t *));\n extern double _IO_strtod __P ((const char *, char **));\n extern char *_IO_dtoa __P ((double __d, int __mode, int __ndigits,\n \t\t\t    int *__decpt, int *__sign, char **__rve));\n extern int _IO_outfloat __P ((double __value, _IO_FILE *__sb, int __type,\n \t\t\t      int __width, int __precision, int __flags,\n \t\t\t      int __sign_mode, int __fill));\n \n-extern _IO_FILE *_IO_list_all;\n+extern struct _IO_FILE_plus *_IO_list_all;\n extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n \n #ifndef EOF\n@@ -496,6 +637,7 @@ extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n /* When using this code in the GNU libc we must not pollute the name space.  */\n #  define mmap __mmap\n #  define munmap __munmap\n+#  define ftruncate __ftruncate\n # endif\n \n # define ROUND_TO_PAGE(_S) \\\n@@ -508,7 +650,15 @@ extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n \t  (_B) = (char *) mmap (0, ROUND_TO_PAGE (_S),\t\t\t      \\\n \t\t\t\tPROT_READ | PROT_WRITE,\t\t\t      \\\n \t\t\t\tMAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n-\t  if ((_B) == (char *) -1)\t\t\t\t\t      \\\n+\t  if ((_B) == (char *) MAP_FAILED)\t\t\t\t      \\\n+\t    return (_R);\t\t\t\t\t\t      \\\n+       } while (0)\n+# define ALLOC_WBUF(_B, _S, _R) \\\n+       do {\t\t\t\t\t\t\t\t      \\\n+\t  (_B) = (wchar_t *) mmap (0, ROUND_TO_PAGE (_S),\t\t      \\\n+\t\t\t\t   PROT_READ | PROT_WRITE,\t\t      \\\n+\t\t\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\t      \\\n+\t  if ((_B) == (wchar_t *) MAP_FAILED)\t\t\t\t      \\\n \t    return (_R);\t\t\t\t\t\t      \\\n        } while (0)\n \n@@ -522,6 +672,12 @@ extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n \t  if ((_B) == NULL)\t\t\t\t\t\t      \\\n \t    return (_R);\t\t\t\t\t\t      \\\n        } while (0)\n+# define ALLOC_WBUF(_B, _S, _R) \\\n+       do {\t\t\t\t\t\t\t\t      \\\n+\t  (_B) = (wchar_t *)malloc(_S);\t\t\t\t\t      \\\n+\t  if ((_B) == NULL)\t\t\t\t\t\t      \\\n+\t    return (_R);\t\t\t\t\t\t      \\\n+       } while (0)\n \n #endif /* _G_HAVE_MMAP */\n \n@@ -531,43 +687,22 @@ extern void (*_IO_cleanup_registration_needed) __PMT ((void));\n struct stat;\n extern _IO_ssize_t _IO_read __P ((int, void *, _IO_size_t));\n extern _IO_ssize_t _IO_write __P ((int, const void *, _IO_size_t));\n-extern _IO_off_t _IO_lseek __P ((int, _IO_off_t, int));\n+extern _IO_off64_t _IO_lseek __P ((int, _IO_off64_t, int));\n extern int _IO_close __P ((int));\n extern int _IO_fstat __P ((int, struct stat *));\n extern int _IO_vscanf __P ((const char *, _IO_va_list));\n \n-/* Operations on _IO_fpos_t.\n-   Normally, these are trivial, but we provide hooks for configurations\n-   where an _IO_fpos_t is a struct.\n-   Note that _IO_off_t must be an integral type. */\n-\n-/* _IO_pos_BAD is an _IO_off_t value indicating error, unknown, or EOF. */\n+/* _IO_pos_BAD is an _IO_off64_t value indicating error, unknown, or EOF. */\n #ifndef _IO_pos_BAD\n-# if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#  define _IO_pos_BAD ((_IO_off64_t) -1)\n-# else\n-#  define _IO_pos_BAD ((_IO_off_t) -1)\n-# endif\n+# define _IO_pos_BAD ((_IO_off64_t) -1)\n #endif\n-/* _IO_pos_as_off converts an _IO_fpos_t value to an _IO_off_t value. */\n-#ifndef _IO_pos_as_off\n-# if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#  define _IO_pos_as_off(__pos) ((_IO_off64_t) (__pos))\n-# else\n-#  define _IO_pos_as_off(__pos) ((_IO_off_t) (__pos))\n-# endif\n-#endif\n-/* _IO_pos_adjust adjust an _IO_fpos_t by some number of bytes. */\n+/* _IO_pos_adjust adjust an _IO_off64_t by some number of bytes. */\n #ifndef _IO_pos_adjust\n-# define _IO_pos_adjust(__pos, __delta) ((__pos) += (__delta))\n+# define _IO_pos_adjust(pos, delta) ((pos) += (delta))\n #endif\n-/* _IO_pos_0 is an _IO_fpos_t value indicating beginning of file. */\n+/* _IO_pos_0 is an _IO_off64_t value indicating beginning of file. */\n #ifndef _IO_pos_0\n-# if defined(_G_IO_IO_FILE_VERSION) && _G_IO_IO_FILE_VERSION == 0x20001\n-#  define _IO_pos_0 ((_IO_fpos64_t) 0)\n-# else\n-#  define _IO_pos_0 ((_IO_fpos_t) 0)\n-# endif\n+# define _IO_pos_0 ((_IO_off64_t) 0)\n #endif\n \n #ifdef __cplusplus\n@@ -576,15 +711,46 @@ extern int _IO_vscanf __P ((const char *, _IO_va_list));\n \n #ifdef _IO_MTSAFE_IO\n /* check following! */\n-# define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n+# ifdef _IO_USE_OLD_IO_FILE\n+#  define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n        { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n-\t   0, 0, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n+\t   0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock }\n+# else\n+#  if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n+       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t 0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock, _IO_pos_BAD,\\\n+\t NULL, WDP, 0 }\n+#  else\n+#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n+       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t 0, _IO_pos_BAD, 0, 0, { 0 }, &_IO_stdfile_##FD##_lock, _IO_pos_BAD,\\\n+\t 0 }\n+#  endif\n+# endif\n #else\n-/* check following! */\n-# define FILEBUF_LITERAL(CHAIN, FLAGS, FD) \\\n+# ifdef _IO_USE_OLD_IO_FILE\n+#  define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n+       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+\t   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, 0, _IO_pos_BAD }\n+# else\n+#  if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n+       { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \\\n+\t NULL, WDP, 0 }\n+#  else\n+#   define FILEBUF_LITERAL(CHAIN, FLAGS, FD, WDP) \\\n        { _IO_MAGIC+_IO_LINKED+_IO_IS_FILEBUF+FLAGS, \\\n-\t   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD }\n+         0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, CHAIN, FD, \\\n+\t 0, _IO_pos_BAD, 0, 0, { 0 }, 0, _IO_pos_BAD, \\\n+\t 0 }\n+#  endif\n+# endif\n #endif\n \n /* VTABLE_LABEL defines NAME as of the CLASS class."}, {"sha": "6441bfb0da971b0c6e152ca318dfbfc3389e01d4", "filename": "libstdc++-v3/libio/stdfiles.c", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fstdfiles.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1993, 1994, 1996, 1997 Free Software Foundation, Inc.\n+/* Copyright (C) 1993, 1994, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.\n    This file is part of the GNU IO Library.\n \n    This library is free software; you can redistribute it and/or\n@@ -31,21 +31,44 @@\n    hand, we don't need a C++ compiler to build this file.) */\n \n #include \"libioP.h\"\n+#ifndef _LIBC\n+# include <bits/c++config.h>\n+#endif\n \n-#ifdef _IO_MTSAFE_IO\n-#define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T\n+# ifdef _IO_MTSAFE_IO\n+#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n   static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n+  static struct _IO_wide_data _IO_wide_data_##FD \\\n+    = { ._wide_vtable = &_IO_wfile_jumps }; \\\n+  struct _IO_FILE_plus NAME \\\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, &_IO_wide_data_##FD), \\\n+       &_IO_file_jumps};\n+# else\n+#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+  static struct _IO_wide_data _IO_wide_data_##FD \\\n+    = { ._wide_vtable = &_IO_wfile_jumps }; \\\n   struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), &_IO_file_jumps}\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, &_IO_wide_data_##FD), \\\n+       &_IO_file_jumps};\n+# endif\n #else\n-#define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+# ifdef _IO_MTSAFE_IO\n+#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n+  static _IO_lock_t _IO_stdfile_##FD##_lock = _IO_lock_initializer; \\\n+  struct _IO_FILE_plus NAME \\\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, NULL), \\\n+       &_IO_file_jumps};\n+# else\n+#  define DEF_STDFILE(NAME, FD, CHAIN, FLAGS) \\\n   struct _IO_FILE_plus NAME \\\n-    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD), &_IO_file_jumps}\n+    = {FILEBUF_LITERAL(CHAIN, FLAGS, FD, NULL), \\\n+       &_IO_file_jumps};\n+# endif\n #endif\n \n-DEF_STDFILE(_IO_stdin_, 0, 0, _IO_NO_WRITES);\n-DEF_STDFILE(_IO_stdout_, 1, &_IO_stdin_.file, _IO_NO_READS);\n-DEF_STDFILE(_IO_stderr_, 2, &_IO_stdout_.file,\n-            _IO_NO_READS+_IO_UNBUFFERED);\n+DEF_STDFILE(_IO_2_1_stdin_, 0, 0, _IO_NO_WRITES);\n+DEF_STDFILE(_IO_2_1_stdout_, 1, &_IO_2_1_stdin_, _IO_NO_READS);\n+DEF_STDFILE(_IO_2_1_stderr_, 2, &_IO_2_1_stdout_, _IO_NO_READS+_IO_UNBUFFERED);\n \n-_IO_FILE *_IO_list_all = &_IO_stderr_.file;\n+struct _IO_FILE_plus *_IO_list_all = &_IO_2_1_stderr_;"}, {"sha": "7f5cb7f960b4bc42f1a400e921985a147fbdc83e", "filename": "libstdc++-v3/libio/wfiledoalloc.c", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwfiledoalloc.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -0,0 +1,105 @@\n+/* Copyright (C) 1993, 1997, 1999 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/*\n+ * Copyright (c) 1990 The Regents of the University of California.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms are permitted\n+ * provided that the above copyright notice and this paragraph are\n+ * duplicated in all such forms and that any documentation,\n+ * advertising materials, and other materials related to such\n+ * distribution and use acknowledge that the software was developed\n+ * by the University of California, Berkeley.  The name of the\n+ * University may not be used to endorse or promote products derived\n+ * from this software without specific prior written permission.\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n+ */\n+\n+/* Modified for GNU iostream by Per Bothner 1991, 1992. */\n+\n+#ifndef _POSIX_SOURCE\n+# define _POSIX_SOURCE\n+#endif\n+#include \"libioP.h\"\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#include <unistd.h>\n+#endif\n+\n+#ifdef _LIBC\n+# undef isatty\n+# define isatty(Fd) __isatty (Fd)\n+#endif\n+\n+/*\n+ * Allocate a file buffer, or switch to unbuffered I/O.\n+ * Per the ANSI C standard, ALL tty devices default to line buffered.\n+ *\n+ * As a side effect, we set __SOPT or __SNPT (en/dis-able fseek\n+ * optimisation) right after the _fstat() that finds the buffer size.\n+ */\n+\n+int\n+_IO_wfile_doallocate (fp)\n+     _IO_FILE *fp;\n+{\n+  _IO_size_t size;\n+  int couldbetty;\n+  wchar_t *p;\n+  struct _G_stat64 st;\n+\n+  /* Allocate room for the external buffer.  */\n+  _IO_file_doallocate (fp);\n+\n+  if (fp->_fileno < 0 || _IO_SYSSTAT (fp, &st) < 0)\n+    {\n+      couldbetty = 0;\n+      size = _IO_BUFSIZ * sizeof (wchar_t);\n+#if 0\n+      /* do not try to optimise fseek() */\n+      fp->_flags |= __SNPT;\n+#endif\n+    }\n+  else\n+    {\n+      couldbetty = S_ISCHR (st.st_mode);\n+#if _IO_HAVE_ST_BLKSIZE\n+      size = ((st.st_blksize <= 0 ? _IO_BUFSIZ : st.st_blksize)\n+\t      * sizeof (wchar_t));\n+#else\n+      size = _IO_BUFSIZ * sizeof (wchar_t);\n+#endif\n+    }\n+  ALLOC_WBUF (p, size, EOF);\n+  _IO_wsetb (fp, p, p + size, 1);\n+  if (couldbetty && isatty (fp->_fileno))\n+    fp->_flags |= _IO_LINE_BUF;\n+  return 1;\n+}"}, {"sha": "ad46c7c9f78229a005a32ee49aba007888bcb48b", "filename": "libstdc++-v3/libio/wfileops.c", "status": "added", "additions": 734, "deletions": 0, "changes": 734, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwfileops.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -0,0 +1,734 @@\n+/* Copyright (C) 1993, 1995, 1997, 1998, 1999 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+   Written by Ulrich Drepper <drepper@cygnus.com>.\n+   Based on the single byte version by Per Bothner <bothner@cygnus.com>.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+#include <assert.h>\n+#include <libioP.h>\n+#include <wchar.h>\n+#include <gconv.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+\n+#ifndef _LIBC\n+# define _IO_new_do_write _IO_do_write\n+# define _IO_new_file_attach _IO_file_attach\n+# define _IO_new_file_close_it _IO_file_close_it\n+# define _IO_new_file_finish _IO_file_finish\n+# define _IO_new_file_fopen _IO_file_fopen\n+# define _IO_new_file_init _IO_file_init\n+# define _IO_new_file_setbuf _IO_file_setbuf\n+# define _IO_new_file_sync _IO_file_sync\n+# define _IO_new_file_overflow _IO_file_overflow\n+# define _IO_new_file_seekoff _IO_file_seekoff\n+# define _IO_new_file_underflow _IO_file_underflow\n+# define _IO_new_file_write _IO_file_write\n+# define _IO_new_file_xsputn _IO_file_xsputn\n+#endif\n+\n+\n+_IO_FILE *\n+_IO_wfile_setbuf (fp, p, len)\n+     _IO_FILE *fp;\n+     wchar_t *p;\n+     _IO_ssize_t len;\n+{\n+  if (_IO_wdefault_setbuf (fp, p, len) == NULL)\n+    return NULL;\n+\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =\n+    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;\n+  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n+\t     fp->_wide_data->_IO_buf_base);\n+\n+  return fp;\n+}\n+\n+\n+/* Convert TO_DO wide character from DATA to FP.\n+   Then mark FP as having empty buffers. */\n+int\n+_IO_wdo_write (fp, data, to_do)\n+     _IO_FILE *fp;\n+     const wchar_t *data;\n+     _IO_size_t to_do;\n+{\n+  struct _IO_codecvt *cc = &fp->_wide_data->_codecvt;\n+  _IO_size_t count = 0;\n+\n+  while (to_do > 0)\n+    {\n+      enum __codecvt_result result;\n+      const wchar_t *new_data;\n+\n+      if (fp->_IO_write_end == fp->_IO_write_ptr)\n+\t{\n+\t  _IO_new_file_overflow (fp, EOF);\n+\t  assert (fp->_IO_write_end > fp->_IO_write_ptr);\n+\t}\n+\n+      /* Now convert from the internal format into the external buffer.  */\n+      result = (*cc->__codecvt_do_out) (cc, &fp->_wide_data->_IO_state,\n+\t\t\t\t\tdata, data + to_do, &new_data,\n+\t\t\t\t\tfp->_IO_write_ptr,\n+\t\t\t\t\tfp->_IO_write_end,\n+\t\t\t\t\t&fp->_IO_write_ptr);\n+\n+      /* Write out what we produced so far.  */\n+      if (_IO_new_do_write (fp, fp->_IO_write_base,\n+\t\t\t    fp->_IO_write_ptr - fp->_IO_write_base) == EOF)\n+\t/* Something went wrong.  */\n+\treturn EOF;\n+\n+      count += new_data - data;\n+      to_do -= new_data - data;\n+      data = new_data;\n+\n+      /* Next see whether we had problems during the conversion.  If yes,\n+\t we cannot go on.  */\n+      if (result != __codecvt_ok)\n+\tbreak;\n+    }\n+\n+  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n+\t     fp->_wide_data->_IO_buf_base);\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n+    = fp->_wide_data->_IO_buf_base;\n+  fp->_wide_data->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n+\t\t\t\t   ? fp->_wide_data->_IO_buf_base\n+\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n+\n+  return count;\n+}\n+\n+\n+wint_t\n+_IO_wfile_underflow (fp)\n+     _IO_FILE *fp;\n+{\n+  struct _IO_codecvt *cd;\n+  enum __codecvt_result status;\n+  _IO_ssize_t count;\n+  int tries;\n+  const char *read_ptr_copy;\n+\n+  if (fp->_flags & _IO_NO_READS)\n+    {\n+      fp->_flags |= _IO_ERR_SEEN;\n+      __set_errno (EBADF);\n+      return WEOF;\n+    }\n+  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+    return *fp->_wide_data->_IO_read_ptr;\n+\n+  cd = &fp->_wide_data->_codecvt;\n+\n+  /* Maybe there is something left in the external buffer.  */\n+  if (fp->_IO_read_ptr < fp->_IO_read_end)\n+    {\n+      /* Convert it.  */\n+      size_t avail_bytes = fp->_IO_read_end - fp->_IO_read_ptr;\n+\n+      if (avail_bytes >= (*cd->__codecvt_do_max_length) (cd))\n+\t{\n+\t  /* There is more in the external.  */\n+\t  const char *read_stop = (const char *) fp->_IO_read_ptr;\n+\n+\t  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n+\t  status = (*cd->__codecvt_do_in) (cd, &fp->_wide_data->_IO_state,\n+\t\t\t\t\t   fp->_IO_read_ptr, fp->_IO_read_end,\n+\t\t\t\t\t   &read_stop,\n+\t\t\t\t\t   fp->_wide_data->_IO_read_end,\n+\t\t\t\t\t   fp->_wide_data->_IO_buf_end,\n+\t\t\t\t\t   &fp->_wide_data->_IO_read_end);\n+\n+\t  fp->_IO_read_ptr = (char *) read_stop;\n+\n+\t  /* If we managed to generate some text return the next character.  */\n+\t  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+\t    return *fp->_wide_data->_IO_read_ptr;\n+\n+\t  if (status == __codecvt_error)\n+\t    {\n+\t      __set_errno (EILSEQ);\n+\t      fp->_flags |= _IO_ERR_SEEN;\n+\t      return WEOF;\n+\t    }\n+\t}\n+\n+      /* Move the remaining content of the read buffer to the beginning.  */\n+      memmove (fp->_IO_buf_base, fp->_IO_read_ptr,\n+\t       fp->_IO_read_end - fp->_IO_read_ptr);\n+      fp->_IO_read_end = (fp->_IO_buf_base\n+\t\t\t  + (fp->_IO_read_end - fp->_IO_read_ptr));\n+      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n+    }\n+  else\n+    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =\n+      fp->_IO_buf_base;\n+\n+  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end =\n+    fp->_IO_buf_base;\n+\n+  if (fp->_IO_buf_base == NULL)\n+    {\n+      /* Maybe we already have a push back pointer.  */\n+      if (fp->_IO_save_base != NULL)\n+\t{\n+\t  free (fp->_IO_save_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n+      _IO_doallocbuf (fp);\n+    }\n+\n+  if (fp->_wide_data->_IO_buf_base == NULL)\n+    {\n+      /* Maybe we already have a push back pointer.  */\n+      if (fp->_wide_data->_IO_save_base != NULL)\n+\t{\n+\t  free (fp->_wide_data->_IO_save_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n+      _IO_wdoallocbuf (fp);\n+    }\n+\n+  /* Flush all line buffered files before reading. */\n+  /* FIXME This can/should be moved to genops ?? */\n+  if (fp->_flags & (_IO_LINE_BUF|_IO_UNBUFFERED))\n+    _IO_flush_all_linebuffered ();\n+\n+  _IO_switch_to_get_mode (fp);\n+\n+  fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n+  fp->_IO_read_end = fp->_IO_buf_base;\n+  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end\n+    = fp->_IO_buf_base;\n+\n+  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =\n+    fp->_wide_data->_IO_buf_base;\n+  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_buf_base;\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =\n+    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;\n+\n+  tries = 0;\n+ again:\n+  count = _IO_SYSREAD (fp, fp->_IO_read_end,\n+\t\t       fp->_IO_buf_end - fp->_IO_read_end);\n+  if (count <= 0)\n+    {\n+      if (count == 0 && tries == 0)\n+\tfp->_flags |= _IO_EOF_SEEN;\n+      else\n+\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n+    }\n+  fp->_IO_read_end += count;\n+  if (count == 0)\n+    {\n+      if (tries != 0)\n+\t/* There are some bytes in the external buffer but they don't\n+           convert to anything.  */\n+\t__set_errno (EILSEQ);\n+      return WEOF;\n+    }\n+  if (fp->_offset != _IO_pos_BAD)\n+    _IO_pos_adjust (fp->_offset, count);\n+\n+  /* Now convert the read input.  */\n+  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n+  fp->_IO_read_base = fp->_IO_read_ptr;\n+  status = (*cd->__codecvt_do_in) (cd, &fp->_wide_data->_IO_state,\n+\t\t\t\t   fp->_IO_read_ptr, fp->_IO_read_end,\n+\t\t\t\t   &read_ptr_copy,\n+\t\t\t\t   fp->_wide_data->_IO_read_end,\n+\t\t\t\t   fp->_wide_data->_IO_buf_end,\n+\t\t\t\t   &fp->_wide_data->_IO_read_end);\n+\n+  fp->_IO_read_ptr = (char *) read_ptr_copy;\n+  if (fp->_wide_data->_IO_read_end == fp->_wide_data->_IO_buf_base)\n+    {\n+      if (status == __codecvt_error || fp->_IO_read_end == fp->_IO_buf_end)\n+\t{\n+\t  __set_errno (EILSEQ);\n+\t  fp->_flags |= _IO_ERR_SEEN;\n+\t  return WEOF;\n+\t}\n+\n+      /* The read bytes make no complete character.  Try reading again.  */\n+      assert (status == __codecvt_partial);\n+      ++tries;\n+      goto again;\n+    }\n+\n+  return *fp->_wide_data->_IO_read_ptr;\n+}\n+\n+\n+wint_t\n+_IO_wfile_overflow (f, wch)\n+     _IO_FILE *f;\n+     wint_t wch;\n+{\n+  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n+    {\n+      f->_flags |= _IO_ERR_SEEN;\n+      __set_errno (EBADF);\n+      return WEOF;\n+    }\n+  /* If currently reading or no buffer allocated. */\n+  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n+    {\n+      /* Allocate a buffer if needed. */\n+      if (f->_wide_data->_IO_write_base == 0)\n+\t{\n+\t  _IO_wdoallocbuf (f);\n+\t  _IO_wsetg (f, f->_wide_data->_IO_buf_base,\n+\t\t     f->_wide_data->_IO_buf_base, f->_wide_data->_IO_buf_base);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n+\t     (and hence also _IO_read_end) is at the buffer end,\n+\t     logically slide the buffer forwards one block (by setting\n+\t     the read pointers to all point at the beginning of the\n+\t     block).  This makes room for subsequent output.\n+\t     Otherwise, set the read pointers to _IO_read_end (leaving\n+\t     that alone, so it can continue to correspond to the\n+\t     external position). */\n+\t  if (f->_wide_data->_IO_read_ptr == f->_wide_data->_IO_buf_end)\n+\t    {\n+\t      f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n+\t      f->_wide_data->_IO_read_end = f->_wide_data->_IO_read_ptr =\n+\t\tf->_wide_data->_IO_buf_base;\n+\t    }\n+\t}\n+      f->_wide_data->_IO_write_ptr = f->_wide_data->_IO_read_ptr;\n+      f->_wide_data->_IO_write_base = f->_wide_data->_IO_write_ptr;\n+      f->_wide_data->_IO_write_end = f->_wide_data->_IO_buf_end;\n+      f->_wide_data->_IO_read_base = f->_wide_data->_IO_read_ptr =\n+\tf->_wide_data->_IO_read_end;\n+\n+      f->_flags |= _IO_CURRENTLY_PUTTING;\n+      if (f->_flags & (_IO_LINE_BUF+_IO_UNBUFFERED))\n+\tf->_wide_data->_IO_write_end = f->_wide_data->_IO_write_ptr;\n+    }\n+  if (wch == WEOF)\n+    return _IO_do_flush (f);\n+  if (f->_wide_data->_IO_write_ptr == f->_wide_data->_IO_buf_end )\n+    /* Buffer is really full */\n+    if (_IO_do_flush (f) == WEOF)\n+      return WEOF;\n+  *f->_wide_data->_IO_write_ptr++ = wch;\n+  if ((f->_flags & _IO_UNBUFFERED)\n+      || ((f->_flags & _IO_LINE_BUF) && wch == L'\\n'))\n+    if (_IO_do_flush (f) == WEOF)\n+      return WEOF;\n+  return wch;\n+}\n+\n+wint_t\n+_IO_wfile_sync (fp)\n+     _IO_FILE *fp;\n+{\n+  _IO_ssize_t delta;\n+  wint_t retval = 0;\n+\n+  /*    char* ptr = cur_ptr(); */\n+  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n+    if (_IO_do_flush (fp))\n+      return WEOF;\n+  delta = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n+  if (delta != 0)\n+    {\n+      /* We have to find out how many bytes we have to go back in the\n+\t external buffer.  */\n+      struct _IO_codecvt *cv = &fp->_wide_data->_codecvt;\n+      _IO_off64_t new_pos;\n+\n+      int clen = (*cv->__codecvt_do_encoding) (cv);\n+\n+      if (clen > 0)\n+\t/* It is easy, a fixed number of input bytes are used for each\n+\t   wide character.  */\n+\tdelta *= clen;\n+      else\n+\t{\n+\t  /* We have to find out the hard way how much to back off.\n+             To do this we determine how much input we needed to\n+             generate the wide characters up to the current reading\n+             position.  */\n+\t  int nread;\n+\n+\t  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n+\t  nread = (*cv->__codecvt_do_length) (cv, &fp->_wide_data->_IO_state,\n+\t\t\t\t\t      fp->_IO_read_base,\n+\t\t\t\t\t      fp->_IO_read_end, delta);\n+\t  fp->_IO_read_ptr = fp->_IO_read_base + nread;\n+\t  delta = -(fp->_IO_read_end - fp->_IO_read_base - nread);\n+\t}\n+\n+      new_pos = _IO_SYSSEEK (fp, delta, 1);\n+      if (new_pos != (_IO_off64_t) EOF)\n+\t{\n+\t  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n+\t  fp->_IO_read_end = fp->_IO_read_ptr;\n+\t}\n+#ifdef ESPIPE\n+      else if (errno == ESPIPE)\n+\t; /* Ignore error from unseekable devices. */\n+#endif\n+      else\n+\tretval = WEOF;\n+    }\n+  if (retval != WEOF)\n+    fp->_offset = _IO_pos_BAD;\n+  /* FIXME: Cleanup - can this be shared? */\n+  /*    setg(base(), ptr, ptr); */\n+  return retval;\n+}\n+\n+_IO_off64_t\n+_IO_wfile_seekoff (fp, offset, dir, mode)\n+     _IO_FILE *fp;\n+     _IO_off64_t offset;\n+     int dir;\n+     int mode;\n+{\n+  _IO_off64_t result;\n+  _IO_off64_t delta, new_offset;\n+  long int count;\n+  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n+     offset of the underlying file must be exact.  */\n+  int must_be_exact = ((fp->_wide_data->_IO_read_base\n+\t\t\t== fp->_wide_data->_IO_read_end)\n+\t\t       && (fp->_wide_data->_IO_write_base\n+\t\t\t   == fp->_wide_data->_IO_write_ptr));\n+\n+  if (mode == 0)\n+    dir = _IO_seek_cur, offset = 0; /* Don't move any pointers. */\n+\n+  /* Flush unwritten characters.\n+     (This may do an unneeded write if we seek within the buffer.\n+     But to be able to switch to reading, we would need to set\n+     egptr to ptr.  That can't be done in the current design,\n+     which assumes file_ptr() is eGptr.  Anyway, since we probably\n+     end up flushing when we close(), it doesn't make much difference.)\n+     FIXME: simulate mem-papped files. */\n+\n+  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base\n+      || _IO_in_put_mode (fp))\n+    if (_IO_switch_to_wget_mode (fp))\n+      return WEOF;\n+\n+  if (fp->_wide_data->_IO_buf_base == NULL)\n+    {\n+      /* It could be that we already have a pushback buffer.  */\n+      if (fp->_wide_data->_IO_read_base != NULL)\n+\t{\n+\t  free (fp->_wide_data->_IO_read_base);\n+\t  fp->_flags &= ~_IO_IN_BACKUP;\n+\t}\n+      _IO_doallocbuf (fp);\n+      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n+\t\t fp->_wide_data->_IO_buf_base);\n+      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n+\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n+    }\n+\n+  switch (dir)\n+    {\n+      struct _IO_codecvt *cv;\n+      int clen;\n+\n+    case _IO_seek_cur:\n+      /* Adjust for read-ahead (bytes is buffer).  To do this we must\n+         find out which position in the external buffer corresponds to\n+         the current position in the internal buffer.  */\n+      cv = &fp->_wide_data->_codecvt;\n+      clen = (*cv->__codecvt_do_encoding) (cv);\n+\n+      if (clen > 0)\n+\toffset -= (fp->_wide_data->_IO_read_end\n+\t\t   - fp->_wide_data->_IO_read_ptr) * clen;\n+      else\n+\t{\n+\t  int nread;\n+\n+\t  delta = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n+\t  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n+\t  nread = (*cv->__codecvt_do_length) (cv, &fp->_wide_data->_IO_state,\n+\t\t\t\t\t      fp->_IO_read_base,\n+\t\t\t\t\t      fp->_IO_read_end, delta);\n+\t  fp->_IO_read_ptr = fp->_IO_read_base + nread;\n+\t  offset -= fp->_IO_read_end - fp->_IO_read_base - nread;\n+\t}\n+\n+      if (fp->_offset == _IO_pos_BAD)\n+\tgoto dumb;\n+      /* Make offset absolute, assuming current pointer is file_ptr(). */\n+      offset += fp->_offset;\n+\n+      dir = _IO_seek_set;\n+      break;\n+    case _IO_seek_set:\n+      break;\n+    case _IO_seek_end:\n+      {\n+\tstruct _G_stat64 st;\n+\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n+\t  {\n+\t    offset += st.st_size;\n+\t    dir = _IO_seek_set;\n+\t  }\n+\telse\n+\t  goto dumb;\n+      }\n+    }\n+  /* At this point, dir==_IO_seek_set. */\n+\n+  /* If we are only interested in the current position we've found it now.  */\n+  if (mode == 0)\n+    return offset;\n+\n+  /* If destination is within current buffer, optimize: */\n+  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n+      && !_IO_in_backup (fp))\n+    {\n+      /* Offset relative to start of main get area. */\n+      _IO_off64_t rel_offset = (offset - fp->_offset\n+\t\t\t\t+ (fp->_IO_read_end - fp->_IO_read_base));\n+      if (rel_offset >= 0)\n+\t{\n+#if 0\n+\t  if (_IO_in_backup (fp))\n+\t    _IO_switch_to_main_get_area (fp);\n+#endif\n+\t  if (rel_offset <= fp->_IO_read_end - fp->_IO_read_base)\n+\t    {\n+\t      fp->_IO_read_ptr = fp->_IO_read_base + rel_offset;\n+\t      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+\n+\t      /* Now set the pointer for the internal buffer.  This\n+                 might be an iterative process.  Though the read\n+                 pointer is somewhere in the current external buffer\n+                 this does not mean we can convert this whole buffer\n+                 at once fitting in the internal buffer.  */\n+\t      do\n+\t\t{\n+\n+\t\t}\n+\t      while (0);\n+\n+\t      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t      goto resync;\n+\t    }\n+#ifdef TODO\n+\t    /* If we have streammarkers, seek forward by reading ahead. */\n+\t    if (_IO_have_markers (fp))\n+\t      {\n+\t\tint to_skip = rel_offset\n+\t\t  - (fp->_IO_read_ptr - fp->_IO_read_base);\n+\t\tif (ignore (to_skip) != to_skip)\n+\t\t  goto dumb;\n+\t\t_IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t\tgoto resync;\n+\t      }\n+#endif\n+\t}\n+#ifdef TODO\n+      if (rel_offset < 0 && rel_offset >= Bbase () - Bptr ())\n+\t{\n+\t  if (!_IO_in_backup (fp))\n+\t    _IO_switch_to_backup_area (fp);\n+\t  gbump (fp->_IO_read_end + rel_offset - fp->_IO_read_ptr);\n+\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+\t  goto resync;\n+\t}\n+#endif\n+    }\n+\n+#ifdef TODO\n+  _IO_unsave_markers (fp);\n+#endif\n+\n+  if (fp->_flags & _IO_NO_READS)\n+    goto dumb;\n+\n+  /* Try to seek to a block boundary, to improve kernel page management. */\n+  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n+  delta = offset - new_offset;\n+  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n+    {\n+      new_offset = offset;\n+      delta = 0;\n+    }\n+  result = _IO_SYSSEEK (fp, new_offset, 0);\n+  if (result < 0)\n+    return EOF;\n+  if (delta == 0)\n+    count = 0;\n+  else\n+    {\n+      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n+\t\t\t   (must_be_exact\n+\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n+      if (count < delta)\n+\t{\n+\t  /* We weren't allowed to read, but try to seek the remainder. */\n+\t  offset = count == EOF ? delta : delta-count;\n+\t  dir = _IO_seek_cur;\n+\t  goto dumb;\n+\t}\n+    }\n+  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n+\t    fp->_IO_buf_base + count);\n+  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+  fp->_offset = result + count;\n+  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+  return offset;\n+ dumb:\n+\n+  _IO_unsave_markers (fp);\n+  result = _IO_SYSSEEK (fp, offset, dir);\n+  if (result != EOF)\n+    {\n+      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n+      fp->_offset = result;\n+      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n+      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n+    }\n+  return result;\n+\n+resync:\n+  /* We need to do it since it is possible that the file offset in\n+     the kernel may be changed behind our back. It may happen when\n+     we fopen a file and then do a fork. One process may access the\n+     the file and the kernel file offset will be changed. */\n+  if (fp->_offset >= 0)\n+    _IO_SYSSEEK (fp, fp->_offset, 0);\n+\n+  return offset;\n+}\n+\n+\n+_IO_size_t\n+_IO_wfile_xsputn (f, data, n)\n+     _IO_FILE *f;\n+     const void *data;\n+     _IO_size_t n;\n+{\n+  register const wchar_t *s = (const wchar_t *) data;\n+  _IO_size_t to_do = n;\n+  int must_flush = 0;\n+  _IO_size_t count;\n+\n+  if (n <= 0)\n+    return 0;\n+  /* This is an optimized implementation.\n+     If the amount to be written straddles a block boundary\n+     (or the filebuf is unbuffered), use sys_write directly. */\n+\n+  /* First figure out how much space is available in the buffer. */\n+  count = f->_wide_data->_IO_write_end - f->_wide_data->_IO_write_ptr;\n+  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n+    {\n+      count = f->_wide_data->_IO_buf_end - f->_wide_data->_IO_write_ptr;\n+      if (count >= n)\n+\t{\n+\t  register const wchar_t *p;\n+\t  for (p = s + n; p > s; )\n+\t    {\n+\t      if (*--p == L'\\n')\n+\t\t{\n+\t\t  count = p - s + 1;\n+\t\t  must_flush = 1;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  /* Then fill the buffer. */\n+  if (count > 0)\n+    {\n+      if (count > to_do)\n+\tcount = to_do;\n+      if (count > 20)\n+\t{\n+#ifdef _LIBC\n+\t  f->_wide_data->_IO_write_ptr =\n+\t    __wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n+#else\n+\t  wmemcpy (f->_wide_data->_IO_write_ptr, s, count);\n+\t  f->_wide_data->_IO_write_ptr += count;\n+#endif\n+\t  s += count;\n+\t}\n+      else\n+\t{\n+\t  register wchar_t *p = f->_wide_data->_IO_write_ptr;\n+\t  register int i = (int) count;\n+\t  while (--i >= 0)\n+\t    *p++ = *s++;\n+\t  f->_wide_data->_IO_write_ptr = p;\n+\t}\n+      to_do -= count;\n+    }\n+  if (to_do > 0)\n+    to_do -= _IO_wdefault_xsputn (f, s, to_do);\n+  if (must_flush\n+      && f->_wide_data->_IO_write_ptr != f->_wide_data->_IO_write_base)\n+    _IO_wdo_write (f, f->_wide_data->_IO_write_base,\n+\t\t   f->_wide_data->_IO_write_ptr\n+\t\t   - f->_wide_data->_IO_write_base);\n+\n+  return n - to_do;\n+}\n+\n+\n+struct _IO_jump_t _IO_wfile_jumps =\n+{\n+  JUMP_INIT_DUMMY,\n+  JUMP_INIT(finish, _IO_new_file_finish),\n+  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),\n+  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),\n+  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),\n+  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),\n+  JUMP_INIT(xsputn, _IO_wfile_xsputn),\n+  JUMP_INIT(xsgetn, _IO_file_xsgetn),\n+  JUMP_INIT(seekoff, _IO_wfile_seekoff),\n+  JUMP_INIT(seekpos, _IO_default_seekpos),\n+  JUMP_INIT(setbuf, _IO_new_file_setbuf),\n+  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),\n+  JUMP_INIT(doallocate, _IO_wfile_doallocate),\n+  JUMP_INIT(read, _IO_file_read),\n+  JUMP_INIT(write, _IO_new_file_write),\n+  JUMP_INIT(seek, _IO_file_seek),\n+  JUMP_INIT(close, _IO_file_close),\n+  JUMP_INIT(stat, _IO_file_stat),\n+  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n+  JUMP_INIT(imbue, _IO_default_imbue)\n+};"}, {"sha": "22a38f01ad7e73746210d53fc49aaaf9b77ec128", "filename": "libstdc++-v3/libio/wgenops.c", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibio%2Fwgenops.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -0,0 +1,750 @@\n+/* Copyright (C) 1993, 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   This file is part of the GNU IO Library.\n+   Written by Ulrich Drepper <drepper@cygnus.com>.\n+   Based on the single byte version by Per Bothner <bothner@cygnus.com>.\n+\n+   This library is free software; you can redistribute it and/or\n+   modify it under the terms of the GNU General Public License as\n+   published by the Free Software Foundation; either version 2, or (at\n+   your option) any later version.\n+\n+   This library is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this library; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330, Boston,\n+   MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files\n+   compiled with a GNU compiler to produce an executable, this does\n+   not cause the resulting executable to be covered by the GNU General\n+   Public License.  This exception does not however invalidate any\n+   other reasons why the executable file might be covered by the GNU\n+   General Public License.  */\n+\n+/* Generic or default I/O operations. */\n+\n+#include \"libioP.h\"\n+#ifdef __STDC__\n+#include <stdlib.h>\n+#endif\n+#include <string.h>\n+#include <wchar.h>\n+\n+\n+#ifndef _LIBC\n+# define __wmemcpy(dst, src, n) wmemcpy (dst, src, n)\n+#endif\n+\n+static int save_for_wbackup __P ((_IO_FILE *fp, wchar_t *end_p))\n+#ifdef _LIBC\n+     internal_function\n+#endif\n+     ;\n+\n+/* Return minimum _pos markers\n+   Assumes the current get area is the main get area. */\n+_IO_ssize_t _IO_least_wmarker __P ((_IO_FILE *fp, wchar_t *end_p));\n+\n+_IO_ssize_t\n+_IO_least_wmarker (fp, end_p)\n+     _IO_FILE *fp;\n+     wchar_t *end_p;\n+{\n+  _IO_ssize_t least_so_far = end_p - fp->_wide_data->_IO_read_base;\n+  struct _IO_marker *mark;\n+  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n+    if (mark->_pos < least_so_far)\n+      least_so_far = mark->_pos;\n+  return least_so_far;\n+}\n+\n+/* Switch current get area from backup buffer to (start of) main get area. */\n+void\n+_IO_switch_to_main_wget_area (fp)\n+     _IO_FILE *fp;\n+{\n+  wchar_t *tmp;\n+  fp->_flags &= ~_IO_IN_BACKUP;\n+  /* Swap _IO_read_end and _IO_save_end. */\n+  tmp = fp->_wide_data->_IO_read_end;\n+  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n+  fp->_wide_data->_IO_save_end= tmp;\n+  /* Swap _IO_read_base and _IO_save_base. */\n+  tmp = fp->_wide_data->_IO_read_base;\n+  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n+  fp->_wide_data->_IO_save_base = tmp;\n+  /* Set _IO_read_ptr. */\n+  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_base;\n+}\n+\n+\n+/* Switch current get area from main get area to (end of) backup area. */\n+void\n+_IO_switch_to_wbackup_area (fp)\n+     _IO_FILE *fp;\n+{\n+  wchar_t *tmp;\n+  fp->_flags |= _IO_IN_BACKUP;\n+  /* Swap _IO_read_end and _IO_save_end. */\n+  tmp = fp->_wide_data->_IO_read_end;\n+  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n+  fp->_wide_data->_IO_save_end = tmp;\n+  /* Swap _IO_read_base and _IO_save_base. */\n+  tmp = fp->_wide_data->_IO_read_base;\n+  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n+  fp->_wide_data->_IO_save_base = tmp;\n+  /* Set _IO_read_ptr.  */\n+  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n+}\n+\n+\n+void\n+_IO_wsetb (f, b, eb, a)\n+     _IO_FILE *f;\n+     wchar_t *b;\n+     wchar_t *eb;\n+     int a;\n+{\n+  if (f->_wide_data->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n+    FREE_BUF (f->_wide_data->_IO_buf_base, _IO_wblen (f));\n+  f->_wide_data->_IO_buf_base = b;\n+  f->_wide_data->_IO_buf_end = eb;\n+  if (a)\n+    f->_flags &= ~_IO_USER_BUF;\n+  else\n+    f->_flags |= _IO_USER_BUF;\n+}\n+\n+\n+wint_t\n+_IO_wdefault_pbackfail (fp, c)\n+     _IO_FILE *fp;\n+     wint_t c;\n+{\n+  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n+      && !_IO_in_backup (fp)\n+      && (wint_t) fp->_IO_read_ptr[-1] == c)\n+    --fp->_IO_read_ptr;\n+  else\n+    {\n+      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n+      if (!_IO_in_backup (fp))\n+\t{\n+\t  /* We need to keep the invariant that the main get area\n+\t     logically follows the backup area.  */\n+\t  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n+\t      && _IO_have_wbackup (fp))\n+\t    {\n+\t      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_ptr))\n+\t\treturn WEOF;\n+\t    }\n+\t  else if (!_IO_have_wbackup (fp))\n+\t    {\n+\t      /* No backup buffer: allocate one. */\n+\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n+\t      int backup_size = 128;\n+\t      wchar_t *bbuf = (wchar_t *) malloc (backup_size\n+\t\t\t\t\t\t  * sizeof (wchar_t));\n+\t      if (bbuf == NULL)\n+\t\treturn WEOF;\n+\t      fp->_wide_data->_IO_save_base = bbuf;\n+\t      fp->_wide_data->_IO_save_end = (fp->_wide_data->_IO_save_base\n+\t\t\t\t\t      + backup_size);\n+\t      fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_save_end;\n+\t    }\n+\t  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr;\n+\t  _IO_switch_to_wbackup_area (fp);\n+\t}\n+      else if (fp->_wide_data->_IO_read_ptr <= fp->_wide_data->_IO_read_base)\n+\t{\n+\t  /* Increase size of existing backup buffer. */\n+\t  _IO_size_t new_size;\n+\t  _IO_size_t old_size = (fp->_wide_data->_IO_read_end\n+\t\t\t\t - fp->_wide_data->_IO_read_base);\n+\t  wchar_t *new_buf;\n+\t  new_size = 2 * old_size;\n+\t  new_buf = (wchar_t *) malloc (new_size * sizeof (wchar_t));\n+\t  if (new_buf == NULL)\n+\t    return WEOF;\n+\t  __wmemcpy (new_buf + (new_size - old_size),\n+\t\t     fp->_wide_data->_IO_read_base, old_size);\n+\t  free (fp->_wide_data->_IO_read_base);\n+\t  _IO_wsetg (fp, new_buf, new_buf + (new_size - old_size),\n+\t\t     new_buf + new_size);\n+\t  fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_read_ptr;\n+\t}\n+\n+      *--fp->_wide_data->_IO_read_ptr = c;\n+    }\n+  return c;\n+}\n+\n+\n+void\n+_IO_wdefault_finish (fp, dummy)\n+     _IO_FILE *fp;\n+     int dummy;\n+{\n+  struct _IO_marker *mark;\n+  if (fp->_wide_data->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n+    {\n+      FREE_BUF (fp->_wide_data->_IO_buf_base,\n+\t\t_IO_wblen (fp) * sizeof (wchar_t));\n+      fp->_wide_data->_IO_buf_base = fp->_wide_data->_IO_buf_end = NULL;\n+    }\n+\n+  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n+    mark->_sbuf = NULL;\n+\n+  if (fp->_IO_save_base)\n+    {\n+      free (fp->_wide_data->_IO_save_base);\n+      fp->_IO_save_base = NULL;\n+    }\n+\n+#ifdef _IO_MTSAFE_IO\n+  _IO_lock_fini (*fp->_lock);\n+#endif\n+\n+  _IO_un_link ((struct _IO_FILE_plus *) fp);\n+}\n+\n+\n+wint_t\n+_IO_wdefault_uflow (fp)\n+     _IO_FILE *fp;\n+{\n+  wint_t wch;\n+  wch = _IO_UNDERFLOW (fp);\n+  if (wch == WEOF)\n+    return WEOF;\n+  return *fp->_wide_data->_IO_read_ptr++;\n+}\n+\n+\n+wint_t\n+__woverflow (f, wch)\n+     _IO_FILE *f;\n+     wint_t wch;\n+{\n+  if (f->_mode == 0)\n+    _IO_fwide (f, 1);\n+  return _IO_OVERFLOW (f, wch);\n+}\n+\n+\n+wint_t\n+__wuflow (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n+    return WEOF;\n+\n+  if (fp->_mode == 0)\n+    _IO_fwide (fp, 1);\n+  if (_IO_in_put_mode (fp))\n+    if (_IO_switch_to_wget_mode (fp) == EOF)\n+      return WEOF;\n+  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+    return *fp->_wide_data->_IO_read_ptr++;\n+  if (_IO_in_backup (fp))\n+    {\n+      _IO_switch_to_main_wget_area (fp);\n+      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+\treturn *fp->_wide_data->_IO_read_ptr++;\n+    }\n+  if (_IO_have_markers (fp))\n+    {\n+      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n+\treturn WEOF;\n+    }\n+  else if (_IO_have_wbackup (fp))\n+    _IO_free_wbackup_area (fp);\n+  return _IO_UFLOW (fp);\n+}\n+\n+\n+wint_t\n+__wunderflow (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n+    return WEOF;\n+\n+  if (_IO_in_put_mode (fp))\n+    if (_IO_switch_to_wget_mode (fp) == EOF)\n+      return WEOF;\n+  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+    return *fp->_wide_data->_IO_read_ptr;\n+  if (_IO_in_backup (fp))\n+    {\n+      _IO_switch_to_main_wget_area (fp);\n+      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n+\treturn *fp->_wide_data->_IO_read_ptr;\n+    }\n+  if (_IO_have_markers (fp))\n+    {\n+      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n+\treturn WEOF;\n+    }\n+  else if (_IO_have_backup (fp))\n+    _IO_free_wbackup_area (fp);\n+  return _IO_UNDERFLOW (fp);\n+}\n+\n+\n+_IO_size_t\n+_IO_wdefault_xsputn (f, data, n)\n+     _IO_FILE *f;\n+     const void *data;\n+     _IO_size_t n;\n+{\n+  const wchar_t *s = (const wchar_t *) data;\n+  _IO_size_t more = n;\n+  if (more <= 0)\n+    return 0;\n+  for (;;)\n+    {\n+      /* Space available. */\n+      _IO_ssize_t count = (f->_wide_data->_IO_write_end\n+\t\t\t   - f->_wide_data->_IO_write_ptr);\n+      if (count > 0)\n+\t{\n+\t  if ((_IO_size_t) count > more)\n+\t    count = more;\n+\t  if (count > 20)\n+\t    {\n+#ifdef _LIBC\n+\t      f->_wide_data->_IO_write_ptr =\n+\t\t__wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n+#else\n+\t      memcpy (f->_wide_data->_IO_write_ptr, s, count);\n+\t      f->_wide_data->_IO_write_ptr += count;\n+#endif\n+\t      s += count;\n+            }\n+\t  else if (count <= 0)\n+\t    count = 0;\n+\t  else\n+\t    {\n+\t      wchar_t *p = f->_wide_data->_IO_write_ptr;\n+\t      _IO_ssize_t i;\n+\t      for (i = count; --i >= 0; )\n+\t\t*p++ = *s++;\n+\t      f->_wide_data->_IO_write_ptr = p;\n+            }\n+\t  more -= count;\n+        }\n+      if (more == 0 || __woverflow (f, *s++) == WEOF)\n+\tbreak;\n+      more--;\n+    }\n+  return n - more;\n+}\n+\n+\n+_IO_size_t\n+_IO_wdefault_xsgetn (fp, data, n)\n+     _IO_FILE *fp;\n+     void *data;\n+     _IO_size_t n;\n+{\n+  _IO_size_t more = n;\n+  wchar_t *s = (wchar_t*) data;\n+  for (;;)\n+    {\n+      /* Data available. */\n+      _IO_ssize_t count = (fp->_wide_data->_IO_read_end\n+\t\t\t   - fp->_wide_data->_IO_read_ptr);\n+      if (count > 0)\n+\t{\n+\t  if ((_IO_size_t) count > more)\n+\t    count = more;\n+\t  if (count > 20)\n+\t    {\n+#ifdef _LIBC\n+\t      s = __wmempcpy (s, fp->_wide_data->_IO_read_ptr, count);\n+#else\n+\t      memcpy (s, fp->_wide_data->_IO_read_ptr, count);\n+\t      s += count;\n+#endif\n+\t      fp->_wide_data->_IO_read_ptr += count;\n+\t    }\n+\t  else if (count <= 0)\n+\t    count = 0;\n+\t  else\n+\t    {\n+\t      wchar_t *p = fp->_wide_data->_IO_read_ptr;\n+\t      int i = (int) count;\n+\t      while (--i >= 0)\n+\t\t*s++ = *p++;\n+\t      fp->_wide_data->_IO_read_ptr = p;\n+            }\n+            more -= count;\n+        }\n+      if (more == 0 || __wunderflow (fp) == WEOF)\n+\tbreak;\n+    }\n+  return n - more;\n+}\n+\n+\n+void\n+_IO_wdoallocbuf (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp->_wide_data->_IO_buf_base)\n+    return;\n+  if (!(fp->_flags & _IO_UNBUFFERED))\n+    if (_IO_DOALLOCATE (fp) != WEOF)\n+      return;\n+  _IO_wsetb (fp, fp->_wide_data->_shortbuf, fp->_wide_data->_shortbuf + 1, 0);\n+}\n+\n+\n+_IO_FILE *\n+_IO_wdefault_setbuf (fp, p, len)\n+     _IO_FILE *fp;\n+     wchar_t *p;\n+     _IO_ssize_t len;\n+{\n+  if (_IO_SYNC (fp) == EOF)\n+    return NULL;\n+  if (p == NULL || len == 0)\n+    {\n+      fp->_flags |= _IO_UNBUFFERED;\n+      _IO_wsetb (fp, fp->_wide_data->_shortbuf, fp->_wide_data->_shortbuf + 1,\n+\t\t 0);\n+    }\n+  else\n+    {\n+      fp->_flags &= ~_IO_UNBUFFERED;\n+      _IO_wsetb (fp, p, p + len, 0);\n+    }\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n+    = fp->_wide_data->_IO_write_end = 0;\n+  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr\n+    = fp->_wide_data->_IO_read_end = 0;\n+  return fp;\n+}\n+\n+\n+int\n+_IO_wdefault_doallocate (fp)\n+     _IO_FILE *fp;\n+{\n+  wchar_t *buf;\n+\n+  ALLOC_WBUF (buf, _IO_BUFSIZ, EOF);\n+  _IO_wsetb (fp, buf, buf + _IO_BUFSIZ, 1);\n+  return 1;\n+}\n+\n+\n+int\n+_IO_switch_to_wget_mode (fp)\n+     _IO_FILE *fp;\n+{\n+  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n+    if (_IO_OVERFLOW (fp, WEOF) == WEOF)\n+      return EOF;\n+  if (_IO_in_backup (fp))\n+    fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_backup_base;\n+  else\n+    {\n+      fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_buf_base;\n+      if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_read_end)\n+\tfp->_wide_data->_IO_read_end = fp->_wide_data->_IO_write_ptr;\n+    }\n+  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_write_ptr;\n+\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n+    = fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_read_ptr;\n+\n+  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n+  return 0;\n+}\n+\n+void\n+_IO_free_wbackup_area (fp)\n+     _IO_FILE *fp;\n+{\n+  if (_IO_in_backup (fp))\n+    _IO_switch_to_main_wget_area (fp);  /* Just in case. */\n+  free (fp->_wide_data->_IO_save_base);\n+  fp->_wide_data->_IO_save_base = NULL;\n+  fp->_wide_data->_IO_save_end = NULL;\n+  fp->_wide_data->_IO_backup_base = NULL;\n+}\n+\n+#if 0\n+int\n+_IO_switch_to_wput_mode (fp)\n+     _IO_FILE *fp;\n+{\n+  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_read_ptr;\n+  fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_read_ptr;\n+  /* Following is wrong if line- or un-buffered? */\n+  fp->_wide_data->_IO_write_end = (fp->_flags & _IO_IN_BACKUP\n+\t\t\t\t   ? fp->_wide_data->_IO_read_end\n+\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n+\n+  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n+  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_end;\n+\n+  fp->_flags |= _IO_CURRENTLY_PUTTING;\n+  return 0;\n+}\n+#endif\n+\n+\n+static int\n+#ifdef _LIBC\n+internal_function\n+#endif\n+save_for_wbackup (fp, end_p)\n+     _IO_FILE *fp;\n+     wchar_t *end_p;\n+{\n+  /* Append [_IO_read_base..end_p] to backup area. */\n+  _IO_ssize_t least_mark = _IO_least_wmarker (fp, end_p);\n+  /* needed_size is how much space we need in the backup area. */\n+  _IO_size_t needed_size = ((end_p - fp->_wide_data->_IO_read_base)\n+\t\t\t    - least_mark);\n+  /* FIXME: Dubious arithmetic if pointers are NULL */\n+  _IO_size_t current_Bsize = (fp->_wide_data->_IO_save_end\n+\t\t\t      - fp->_wide_data->_IO_save_base);\n+  _IO_size_t avail; /* Extra space available for future expansion. */\n+  _IO_ssize_t delta;\n+  struct _IO_marker *mark;\n+  if (needed_size > current_Bsize)\n+    {\n+      wchar_t *new_buffer;\n+      avail = 100;\n+      new_buffer = (wchar_t *) malloc ((avail + needed_size)\n+\t\t\t\t       * sizeof (wchar_t));\n+      if (new_buffer == NULL)\n+\treturn EOF;\t\t/* FIXME */\n+      if (least_mark < 0)\n+\t{\n+#ifdef _LIBC\n+\t  __wmempcpy (__wmempcpy (new_buffer + avail,\n+\t\t\t\t  fp->_wide_data->_IO_save_end + least_mark,\n+\t\t\t\t  -least_mark),\n+\t\t      fp->_wide_data->_IO_read_base,\n+\t\t      end_p - fp->_wide_data->_IO_read_base);\n+#else\n+\t  memcpy (new_buffer + avail,\n+\t\t  fp->_wide_data->_IO_save_end + least_mark,\n+\t\t  -least_mark * sizeof (wchar_t));\n+\t  memcpy (new_buffer + avail - least_mark,\n+\t\t  fp->_wide_data->_IO_read_base,\n+\t\t  (end_p - fp->_wide_data->_IO_read_base) * sizeof (wchar_t));\n+#endif\n+\t}\n+      else\n+\t{\n+#ifdef _LIBC\n+\t  __wmemcpy (new_buffer + avail,\n+\t\t     fp->_wide_data->_IO_read_base + least_mark,\n+\t\t     needed_size);\n+#else\n+\t  memcpy (new_buffer + avail,\n+\t\t  fp->_wide_data->_IO_read_base + least_mark,\n+\t\t  needed_size * sizeof (wchar_t));\n+#endif\n+\t}\n+      if (fp->_wide_data->_IO_save_base)\n+\tfree (fp->_wide_data->_IO_save_base);\n+      fp->_wide_data->_IO_save_base = new_buffer;\n+      fp->_wide_data->_IO_save_end = new_buffer + avail + needed_size;\n+    }\n+  else\n+    {\n+      avail = current_Bsize - needed_size;\n+      if (least_mark < 0)\n+\t{\n+#ifdef _LIBC\n+\t  __wmemmove (fp->_wide_data->_IO_save_base + avail,\n+\t\t      fp->_wide_data->_IO_save_end + least_mark,\n+\t\t      -least_mark);\n+\t  __wmemcpy (fp->_wide_data->_IO_save_base + avail - least_mark,\n+\t\t     fp->_wide_data->_IO_read_base,\n+\t\t     end_p - fp->_wide_data->_IO_read_base);\n+#else\n+\t  memmove (fp->_wide_data->_IO_save_base + avail,\n+\t\t   fp->_wide_data->_IO_save_end + least_mark,\n+\t\t   -least_mark * sizeof (wchar_t));\n+\t  memcpy (fp->_wide_data->_IO_save_base + avail - least_mark,\n+\t\t  fp->_wide_data->_IO_read_base,\n+\t\t  (end_p - fp->_wide_data->_IO_read_base) * sizeof (wchar_t));\n+#endif\n+\t}\n+      else if (needed_size > 0)\n+#ifdef _LIBC\n+\t__wmemcpy (fp->_wide_data->_IO_save_base + avail,\n+\t\t   fp->_wide_data->_IO_read_base + least_mark,\n+\t\t   needed_size);\n+#else\n+\tmemcpy (fp->_wide_data->_IO_save_base + avail,\n+\t\tfp->_wide_data->_IO_read_base + least_mark,\n+\t\tneeded_size * sizeof (wchar_t));\n+#endif\n+    }\n+  fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_save_base + avail;\n+  /* Adjust all the streammarkers. */\n+  delta = end_p - fp->_wide_data->_IO_read_base;\n+  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n+    mark->_pos -= delta;\n+  return 0;\n+}\n+\n+wint_t\n+_IO_sputbackwc (fp, c)\n+     _IO_FILE *fp;\n+     wint_t c;\n+{\n+  wint_t result;\n+\n+  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n+      && (wchar_t)fp->_wide_data->_IO_read_ptr[-1] == (wchar_t) c)\n+    {\n+      fp->_wide_data->_IO_read_ptr--;\n+      result = c;\n+    }\n+  else\n+    result = _IO_PBACKFAIL (fp, c);\n+\n+  if (result != EOF)\n+    fp->_flags &= ~_IO_EOF_SEEN;\n+\n+  return result;\n+}\n+\n+wint_t\n+_IO_sungetwc (fp)\n+     _IO_FILE *fp;\n+{\n+  int result;\n+\n+  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base)\n+    {\n+      fp->_wide_data->_IO_read_ptr--;\n+      result = *fp->_wide_data->_IO_read_ptr;\n+    }\n+  else\n+    result = _IO_PBACKFAIL (fp, EOF);\n+\n+  if (result != WEOF)\n+    fp->_flags &= ~_IO_EOF_SEEN;\n+\n+  return result;\n+}\n+\n+\n+unsigned\n+_IO_adjust_wcolumn (start, line, count)\n+     unsigned start;\n+     const wchar_t *line;\n+     int count;\n+{\n+  const wchar_t *ptr = line + count;\n+  while (ptr > line)\n+    if (*--ptr == L'\\n')\n+      return line + count - ptr - 1;\n+  return start + count;\n+}\n+\n+void\n+_IO_init_wmarker (marker, fp)\n+     struct _IO_marker *marker;\n+     _IO_FILE *fp;\n+{\n+  marker->_sbuf = fp;\n+  if (_IO_in_put_mode (fp))\n+    _IO_switch_to_wget_mode (fp);\n+  if (_IO_in_backup (fp))\n+    marker->_pos = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n+  else\n+    marker->_pos = (fp->_wide_data->_IO_read_ptr\n+\t\t    - fp->_wide_data->_IO_read_base);\n+\n+  /* Should perhaps sort the chain? */\n+  marker->_next = fp->_markers;\n+  fp->_markers = marker;\n+}\n+\n+#define BAD_DELTA EOF\n+\n+/* Return difference between MARK and current position of MARK's stream. */\n+int\n+_IO_wmarker_delta (mark)\n+     struct _IO_marker *mark;\n+{\n+  int cur_pos;\n+  if (mark->_sbuf == NULL)\n+    return BAD_DELTA;\n+  if (_IO_in_backup (mark->_sbuf))\n+    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n+\t       - mark->_sbuf->_wide_data->_IO_read_end);\n+  else\n+    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n+\t       - mark->_sbuf->_wide_data->_IO_read_base);\n+  return mark->_pos - cur_pos;\n+}\n+\n+int\n+_IO_seekwmark (fp, mark, delta)\n+     _IO_FILE *fp;\n+     struct _IO_marker *mark;\n+     int delta;\n+{\n+  if (mark->_sbuf != fp)\n+    return EOF;\n+ if (mark->_pos >= 0)\n+    {\n+      if (_IO_in_backup (fp))\n+\t_IO_switch_to_main_wget_area (fp);\n+      fp->_wide_data->_IO_read_ptr = (fp->_wide_data->_IO_read_base\n+\t\t\t\t      + mark->_pos);\n+    }\n+  else\n+    {\n+      if (!_IO_in_backup (fp))\n+\t_IO_switch_to_wbackup_area (fp);\n+      fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end + mark->_pos;\n+    }\n+  return 0;\n+}\n+\n+void\n+_IO_unsave_wmarkers (fp)\n+     _IO_FILE *fp;\n+{\n+  struct _IO_marker *mark = fp->_markers;\n+  if (mark)\n+    {\n+#ifdef TODO\n+      streampos offset = seekoff (0, ios::cur, ios::in);\n+      if (offset != EOF)\n+\t{\n+\t  offset += eGptr () - Gbase ();\n+\t  for ( ; mark != NULL; mark = mark->_next)\n+\t    mark->set_streampos (mark->_pos + offset);\n+\t}\n+    else\n+      {\n+\tfor ( ; mark != NULL; mark = mark->_next)\n+\t  mark->set_streampos (EOF);\n+      }\n+#endif\n+      fp->_markers = 0;\n+    }\n+\n+  if (_IO_have_backup (fp))\n+    _IO_free_wbackup_area (fp);\n+}"}, {"sha": "ede84a1c854b0d0b5492da47691d9824d386f756", "filename": "libstdc++-v3/math/cargl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fmath%2Fcargl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fmath%2Fcargl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fmath%2Fcargl.c?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -34,5 +34,5 @@\n long double\n cargl (__complex__ long double x)\n {\n-  return __atan2l (__imag__ x, __real__ x);\n+  return atan2l (__imag__ x, __real__ x);\n }"}, {"sha": "07036c4bb4c91dea8e82bfd7577875516558007a", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -52,7 +52,7 @@ AC_CXXFLAGS = \\\n # the end of the compile line so that -O2 can be overridden as the\n # occasion call for it. (ie, --enable-debug)\n AM_CXXFLAGS = \\\n-\t-fno-implicit-templates $(OPTIMIZE_CXXFLAGS) \\\n+\t-D_GNU_SOURCE -fno-implicit-templates $(OPTIMIZE_CXXFLAGS) \\\n \t-Wall -Wno-format -W -Wwrite-strings -Winline \\\n \t$(AC_CXXFLAGS) \n "}, {"sha": "e3e9954fec373f86dd27aee48f61c6342e8935a6", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20427c6b9b8288eef21c79df4f60b85cf04a39a7/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=20427c6b9b8288eef21c79df4f60b85cf04a39a7", "patch": "@@ -130,7 +130,7 @@ AC_CXXFLAGS = \\\n # the end of the compile line so that -O2 can be overridden as the\n # occasion call for it. (ie, --enable-debug)\n AM_CXXFLAGS = \\\n-\t-fno-implicit-templates $(OPTIMIZE_CXXFLAGS) \\\n+\t-D_GNU_SOURCE -fno-implicit-templates $(OPTIMIZE_CXXFLAGS) \\\n \t-Wall -Wno-format -W -Wwrite-strings -Winline \\\n \t$(AC_CXXFLAGS) \n "}]}