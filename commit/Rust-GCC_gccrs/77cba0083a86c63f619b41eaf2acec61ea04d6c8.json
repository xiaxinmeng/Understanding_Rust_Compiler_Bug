{"sha": "77cba0083a86c63f619b41eaf2acec61ea04d6c8", "node_id": "C_kwDOANBUbNoAKDc3Y2JhMDA4M2E4NmM2M2Y2MTliNDFlYWYyYWNlYzYxZWEwNGQ2Yzg", "commit": {"author": {"name": "Jakub Dupak", "email": "dev@jakubdupak.com", "date": "2022-10-27T23:37:48Z"}, "committer": {"name": "Jakub Dupak", "email": "dev@jakubdupak.com", "date": "2022-11-04T12:48:06Z"}, "message": "ast: transform helper methods to visits and add methods to simplify repeated patterns\n\nSigned-off-by: Jakub Dupak <dev@jakubdupak.com>", "tree": {"sha": "68c75c1f8495c736584d28087e896221ffaa206f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68c75c1f8495c736584d28087e896221ffaa206f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77cba0083a86c63f619b41eaf2acec61ea04d6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77cba0083a86c63f619b41eaf2acec61ea04d6c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77cba0083a86c63f619b41eaf2acec61ea04d6c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77cba0083a86c63f619b41eaf2acec61ea04d6c8/comments", "author": {"login": "jdupak", "id": 22683640, "node_id": "MDQ6VXNlcjIyNjgzNjQw", "avatar_url": "https://avatars.githubusercontent.com/u/22683640?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdupak", "html_url": "https://github.com/jdupak", "followers_url": "https://api.github.com/users/jdupak/followers", "following_url": "https://api.github.com/users/jdupak/following{/other_user}", "gists_url": "https://api.github.com/users/jdupak/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdupak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdupak/subscriptions", "organizations_url": "https://api.github.com/users/jdupak/orgs", "repos_url": "https://api.github.com/users/jdupak/repos", "events_url": "https://api.github.com/users/jdupak/events{/privacy}", "received_events_url": "https://api.github.com/users/jdupak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdupak", "id": 22683640, "node_id": "MDQ6VXNlcjIyNjgzNjQw", "avatar_url": "https://avatars.githubusercontent.com/u/22683640?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdupak", "html_url": "https://github.com/jdupak", "followers_url": "https://api.github.com/users/jdupak/followers", "following_url": "https://api.github.com/users/jdupak/following{/other_user}", "gists_url": "https://api.github.com/users/jdupak/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdupak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdupak/subscriptions", "organizations_url": "https://api.github.com/users/jdupak/orgs", "repos_url": "https://api.github.com/users/jdupak/repos", "events_url": "https://api.github.com/users/jdupak/events{/privacy}", "received_events_url": "https://api.github.com/users/jdupak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56a227a63b3843fd5eadc093079b833fe1f93ef9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56a227a63b3843fd5eadc093079b833fe1f93ef9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56a227a63b3843fd5eadc093079b833fe1f93ef9"}], "stats": {"total": 621, "additions": 234, "deletions": 387}, "files": [{"sha": "986a8b3ed139050d756a854382c9d6e9a55c80a6", "filename": "gcc/rust/ast/rust-ast-dump.cc", "status": "modified", "additions": 198, "deletions": 360, "changes": 558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77cba0083a86c63f619b41eaf2acec61ea04d6c8/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77cba0083a86c63f619b41eaf2acec61ea04d6c8/gcc%2Frust%2Fast%2Frust-ast-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.cc?ref=77cba0083a86c63f619b41eaf2acec61ea04d6c8", "patch": "@@ -48,12 +48,7 @@ Dump::Dump (std::ostream &stream) : stream (stream), indentation (Indent ()) {}\n void\n Dump::go (AST::Crate &crate)\n {\n-  for (auto &item : crate.items)\n-    {\n-      stream << indentation;\n-      item->accept_vis (*this);\n-      stream << '\\n';\n-    }\n+  visit_items_as_lines (crate.items, \"\");\n }\n \n void\n@@ -69,28 +64,74 @@ Dump::visit (std::unique_ptr<T> &node)\n   node->accept_vis (*this);\n }\n \n+template <typename T>\n void\n-Dump::format_function_param (FunctionParam &param)\n+Dump::visit_items_joined_by_separator (T &collection,\n+\t\t\t\t       const std::string &separator,\n+\t\t\t\t       size_t start_offset, size_t end_offset)\n {\n-  param.get_pattern ()->accept_vis (*this);\n-  stream << \": \";\n-  param.get_type ()->accept_vis (*this);\n+  if (collection.size () > start_offset)\n+    {\n+      visit (collection.at (start_offset));\n+      auto size = collection.size () - end_offset;\n+      for (size_t i = start_offset + 1; i < size; i++)\n+\t{\n+\t  stream << separator;\n+\t  visit (collection.at (i));\n+\t}\n+    }\n }\n \n+template <typename T>\n void\n-Dump::emit_attrib (const Attribute &attrib)\n+Dump::visit_as_line (T &item, const std::string &trailing)\n {\n-  stream << \"#[\";\n+  stream << indentation;\n+  visit (item);\n+  stream << trailing << '\\n';\n+}\n \n-  for (size_t i = 0; i < attrib.get_path ().get_segments ().size (); i++)\n+template <typename T>\n+void\n+Dump::visit_items_as_lines (T &collection, const std::string &trailing)\n+{\n+  for (auto &item : collection)\n+    visit_as_line (item, trailing);\n+}\n+\n+template <typename T>\n+void\n+Dump::visit_items_as_block (T &collection, char left_brace, char right_brace)\n+{\n+  if (collection.empty ())\n     {\n-      const auto &seg = attrib.get_path ().get_segments ().at (i);\n-      bool has_next = (i + 1) < attrib.get_path ().get_segments ().size ();\n+      stream << left_brace << right_brace << '\\n';\n+    }\n+  else\n+    {\n+      stream << left_brace << '\\n';\n+\n+      indentation.increment ();\n+      visit_items_as_lines (collection, \",\");\n+      indentation.decrement ();\n \n-      stream << seg.get_segment_name ();\n-      if (has_next)\n-\tstream << \"::\";\n+      stream << indentation << right_brace << '\\n';\n     }\n+}\n+\n+void\n+Dump::visit (FunctionParam &param)\n+{\n+  visit (param.get_pattern ());\n+  stream << \": \";\n+  visit (param.get_type ());\n+}\n+\n+void\n+Dump::visit (const Attribute &attrib)\n+{\n+  stream << \"#[\";\n+  visit_items_joined_by_separator (attrib.get_path ().get_segments (), \"::\");\n \n   if (attrib.has_attr_input ())\n     {\n@@ -116,7 +157,13 @@ Dump::emit_attrib (const Attribute &attrib)\n }\n \n void\n-Dump::emit_visibility (const Visibility &vis)\n+Dump::visit (const SimplePathSegment &segment)\n+{\n+  stream << segment.get_segment_name ();\n+}\n+\n+void\n+Dump::visit (const Visibility &vis)\n {\n   switch (vis.get_vis_type ())\n     {\n@@ -140,44 +187,36 @@ Dump::emit_visibility (const Visibility &vis)\n     }\n }\n \n-std::ostream &\n-Dump::emit_indented_string (const std::string &value,\n-\t\t\t    const std::string &comment)\n+void\n+Dump::visit (NamedFunctionParam &param)\n {\n-  return stream << indentation << value << comment;\n+  stream << param.get_name () << \": \";\n+  visit (param.get_type ());\n }\n \n void\n-Dump::emit_generic_params (std::vector<std::unique_ptr<GenericParam>> &params)\n+Dump::visit (std::vector<std::unique_ptr<GenericParam>> &params)\n {\n   stream << \"<\";\n-  for (size_t i = 0; i < params.size (); i++)\n-    {\n-      auto &param = params.at (i);\n-      param->accept_vis (*this);\n-\n-      bool has_next = (i + 1) < params.size ();\n-      if (has_next)\n-\tstream << \", \";\n-    }\n+  visit_items_joined_by_separator (params, \", \");\n   stream << \">\";\n }\n \n void\n-Dump::format_tuple_field (TupleField &field)\n+Dump::visit (TupleField &field)\n {\n   // TODO: do we need to emit outer attrs here?\n-  emit_visibility (field.get_visibility ());\n-  field.get_field_type ()->accept_vis (*this);\n+  visit (field.get_visibility ());\n+  visit (field.get_field_type ());\n }\n \n void\n-Dump::format_struct_field (StructField &field)\n+Dump::visit (StructField &field)\n {\n   // TODO: do we need to emit outer attrs here?\n-  emit_visibility (field.get_visibility ());\n+  visit (field.get_visibility ());\n   stream << field.get_field_name () << \": \";\n-  field.get_field_type ()->accept_vis (*this);\n+  visit (field.get_field_type ());\n }\n \n void\n@@ -189,16 +228,11 @@ Dump::visit (Token &tok)\n void\n Dump::visit (DelimTokenTree &delim_tok_tree)\n {\n-  auto tokens = delim_tok_tree.to_token_stream ();\n-\n   indentation.increment ();\n   stream << '\\n' << indentation;\n \n-  for (const auto &tok : tokens)\n-    {\n-      stream << ' ';\n-      tok->accept_vis (*this);\n-    }\n+  auto tokens = delim_tok_tree.to_token_stream ();\n+  visit_items_joined_by_separator (tokens, \" \");\n \n   indentation.decrement ();\n   stream << '\\n' << indentation;\n@@ -289,20 +323,20 @@ Dump::visit (BorrowExpr &expr)\n   if (expr.get_is_mut ())\n     stream << \"mut \";\n \n-  expr.get_borrowed_expr ()->accept_vis (*this);\n+  visit (expr.get_borrowed_expr ());\n }\n \n void\n Dump::visit (DereferenceExpr &expr)\n {\n   stream << '*';\n-  expr.get_dereferenced_expr ()->accept_vis (*this);\n+  visit (expr.get_dereferenced_expr ());\n }\n \n void\n Dump::visit (ErrorPropagationExpr &expr)\n {\n-  expr.get_propagating_expr ()->accept_vis (*this);\n+  visit (expr.get_propagating_expr ());\n   stream << '?';\n }\n \n@@ -318,7 +352,7 @@ Dump::visit (NegationExpr &expr)\n       stream << '!';\n       break;\n     }\n-  expr.get_negated_expr ()->accept_vis (*this);\n+  visit (expr.get_negated_expr ());\n }\n \n void\n@@ -368,9 +402,9 @@ Dump::visit (ArithmeticOrLogicalExpr &expr)\n       break;\n     }\n \n-  expr.get_left_expr ()->accept_vis (*this);\n+  visit (expr.get_left_expr ());\n   stream << \" \" << op << \" \";\n-  expr.get_right_expr ()->accept_vis (*this);\n+  visit (expr.get_right_expr ());\n }\n \n void\n@@ -403,9 +437,9 @@ Dump::visit (ComparisonExpr &expr)\n       break;\n     }\n \n-  expr.get_left_expr ()->accept_vis (*this);\n+  visit (expr.get_left_expr ());\n   stream << \" \" << op << \" \";\n-  expr.get_right_expr ()->accept_vis (*this);\n+  visit (expr.get_right_expr ());\n }\n \n void\n@@ -422,17 +456,17 @@ Dump::visit (LazyBooleanExpr &expr)\n       break;\n     }\n \n-  expr.get_left_expr ()->accept_vis (*this);\n+  visit (expr.get_left_expr ());\n   stream << \" \" << op << \" \";\n-  expr.get_right_expr ()->accept_vis (*this);\n+  visit (expr.get_right_expr ());\n }\n \n void\n Dump::visit (TypeCastExpr &expr)\n {\n-  expr.get_casted_expr ()->accept_vis (*this);\n+  visit (expr.get_casted_expr ());\n   stream << \" as \";\n-  expr.get_type_to_cast_to ()->accept_vis (*this);\n+  visit (expr.get_type_to_cast_to ());\n }\n \n void\n@@ -490,56 +524,47 @@ Dump::visit (CompoundAssignmentExpr &expr)\n       break;\n     }\n \n-  expr.get_left_expr ()->accept_vis (*this);\n+  visit (expr.get_left_expr ());\n   stream << \" \" << op << \"= \";\n-  expr.get_right_expr ()->accept_vis (*this);\n+  visit (expr.get_right_expr ());\n }\n \n void\n Dump::visit (GroupedExpr &expr)\n {\n   stream << '(';\n-  expr.get_expr_in_parens ()->accept_vis (*this);\n+  visit (expr.get_expr_in_parens ());\n   stream << ')';\n }\n \n void\n Dump::visit (ArrayElemsValues &elems)\n {\n-  auto &vals = elems.get_values ();\n-  if (vals.size () >= 1)\n-    {\n-      vals[0]->accept_vis (*this);\n-      for (size_t i = 1; i < vals.size (); i++)\n-\t{\n-\t  stream << \", \";\n-\t  vals[i]->accept_vis (*this);\n-\t}\n-    }\n+  visit_items_joined_by_separator (elems.get_values (), \", \");\n }\n \n void\n Dump::visit (ArrayElemsCopied &elems)\n {\n-  elems.get_elem_to_copy ()->accept_vis (*this);\n+  visit (elems.get_elem_to_copy ());\n   stream << \"; \";\n-  elems.get_num_copies ()->accept_vis (*this);\n+  visit (elems.get_num_copies ());\n }\n \n void\n Dump::visit (ArrayExpr &expr)\n {\n   stream << '[';\n-  expr.get_array_elems ()->accept_vis (*this);\n+  visit (expr.get_array_elems ());\n   stream << ']';\n }\n \n void\n Dump::visit (ArrayIndexExpr &expr)\n {\n-  expr.get_array_expr ()->accept_vis (*this);\n+  visit (expr.get_array_expr ());\n   stream << '[';\n-  expr.get_index_expr ()->accept_vis (*this);\n+  visit (expr.get_index_expr ());\n   stream << ']';\n }\n \n@@ -578,21 +603,15 @@ Dump::visit (StructExprStructBase &expr)\n void\n Dump::visit (CallExpr &expr)\n {\n-  expr.get_function_expr ()->accept_vis (*this);\n-  stream << '(';\n+  visit (expr.get_function_expr ());\n \n+  stream << '(' << '\\n';\n   indentation.increment ();\n \n-  for (auto &arg : expr.get_params ())\n-    {\n-      stream << '\\n' << indentation;\n-      arg->accept_vis (*this);\n-      stream << ',';\n-    }\n+  visit_items_as_lines (expr.get_params (), \",\");\n \n   indentation.decrement ();\n-\n-  stream << '\\n' << indentation << ')';\n+  stream << indentation << ')';\n }\n \n void\n@@ -613,19 +632,10 @@ Dump::visit (BlockExpr &expr)\n   stream << \"{\\n\";\n   indentation.increment ();\n \n-  for (auto &stmt : expr.get_statements ())\n-    {\n-      stream << indentation;\n-      stmt->accept_vis (*this);\n-      stream << \"; /* stmt */\\n\";\n-    }\n+  visit_items_as_lines (expr.get_statements (), \"; /* stmt */\");\n \n   if (expr.has_tail_expr ())\n-    {\n-      stream << indentation;\n-      expr.get_tail_expr ()->accept_vis (*this);\n-      stream << \" /* tail expr */\\n\";\n-    }\n+    visit_as_line (expr.get_tail_expr (), \" /* tail expr */\\n\");\n \n   indentation.decrement ();\n   stream << indentation << \"}\\n\";\n@@ -646,23 +656,23 @@ Dump::visit (BreakExpr &expr)\n void\n Dump::visit (RangeFromToExpr &expr)\n {\n-  expr.get_from_expr ()->accept_vis (*this);\n+  visit (expr.get_from_expr ());\n   stream << \"..\";\n-  expr.get_to_expr ()->accept_vis (*this);\n+  visit (expr.get_to_expr ());\n }\n \n void\n Dump::visit (RangeFromExpr &expr)\n {\n-  expr.get_from_expr ()->accept_vis (*this);\n+  visit (expr.get_from_expr ());\n   stream << \"..\";\n }\n \n void\n Dump::visit (RangeToExpr &expr)\n {\n   stream << \"..\";\n-  expr.get_to_expr ()->accept_vis (*this);\n+  visit (expr.get_to_expr ());\n }\n \n void\n@@ -674,16 +684,16 @@ Dump::visit (RangeFullExpr &expr)\n void\n Dump::visit (RangeFromToInclExpr &expr)\n {\n-  expr.get_from_expr ()->accept_vis (*this);\n+  visit (expr.get_from_expr ());\n   stream << \"..=\";\n-  expr.get_to_expr ()->accept_vis (*this);\n+  visit (expr.get_to_expr ());\n }\n \n void\n Dump::visit (RangeToInclExpr &expr)\n {\n   stream << \"..=\";\n-  expr.get_to_expr ()->accept_vis (*this);\n+  visit (expr.get_to_expr ());\n }\n \n void\n@@ -714,32 +724,32 @@ void\n Dump::visit (IfExpr &expr)\n {\n   stream << \"if \";\n-  expr.vis_if_condition (*this);\n+  visit (expr.get_condition_expr ());\n   stream << \" \";\n-  expr.vis_if_block (*this);\n+  visit (expr.get_if_block ());\n }\n \n void\n Dump::visit (IfExprConseqElse &expr)\n {\n   stream << \"if \";\n-  expr.vis_if_condition (*this);\n+  visit (expr.get_condition_expr ());\n   stream << \" \";\n-  expr.vis_if_block (*this);\n+  visit (expr.get_if_block ());\n   stream << indentation << \"else \";\n-  expr.vis_else_block (*this);\n+  visit (expr.get_else_block ());\n }\n \n void\n Dump::visit (IfExprConseqIf &expr)\n {\n   stream << \"if \";\n-  expr.vis_if_condition (*this);\n+  visit (expr.get_condition_expr ());\n   stream << \" \";\n-  expr.vis_if_block (*this);\n+  visit (expr.get_if_block ());\n   stream << indentation << \"else \";\n   // The \"if\" part of the \"else if\" is printed by the next visitor\n-  expr.vis_conseq_if_expr (*this);\n+  visit (expr.get_conseq_if_expr ());\n }\n \n void\n@@ -782,7 +792,7 @@ Dump::visit (TypeParam &param)\n   if (param.has_type ())\n     {\n       stream << \" = \";\n-      param.get_type ()->accept_vis (*this);\n+      visit (param.get_type ());\n     }\n }\n \n@@ -799,33 +809,26 @@ Dump::visit (Method &method)\n {\n   // FIXME: Do we really need to dump the indentation here?\n   stream << indentation;\n-  emit_visibility (method.get_visibility ());\n+  visit (method.get_visibility ());\n   stream << \"fn \" << method.get_method_name () << '(';\n \n-  auto &self = method.get_self_param ();\n-  stream << self.as_string ();\n-\n-  auto &params = method.get_function_params ();\n-  for (auto &param : params)\n-    {\n-      stream << \", \";\n-      format_function_param (param);\n-    }\n+  stream << method.get_self_param ().as_string () << \", \";\n+  visit_items_joined_by_separator (method.get_function_params (), \", \");\n \n   stream << \") \";\n \n   if (method.has_return_type ())\n     {\n       stream << \"-> \";\n-      method.get_return_type ()->accept_vis (*this);\n+      visit (method.get_return_type ());\n       stream << \" \";\n     }\n \n   auto &block = method.get_definition ();\n   if (!block)\n     stream << ';';\n   else\n-    block->accept_vis (*this);\n+    visit (block);\n \n   stream << '\\n';\n }\n@@ -840,7 +843,7 @@ Dump::visit (Module &module)\n   //\t  Item*\n   //\t}\n \n-  emit_visibility (module.get_visibility ());\n+  visit (module.get_visibility ());\n   stream << \"mod \" << module.get_name ();\n \n   if (module.get_kind () == Module::UNLOADED)\n@@ -853,19 +856,8 @@ Dump::visit (Module &module)\n \n       indentation.increment ();\n \n-      for (auto &item : module.get_inner_attrs ())\n-\t{\n-\t  stream << indentation;\n-\t  emit_attrib (item);\n-\t  stream << '\\n';\n-\t}\n-\n-      for (auto &item : module.get_items ())\n-\t{\n-\t  stream << indentation;\n-\t  item->accept_vis (*this);\n-\t  stream << '\\n';\n-\t}\n+      visit_items_as_lines (module.get_inner_attrs ());\n+      visit_items_as_lines (module.get_items ());\n \n       indentation.decrement ();\n \n@@ -896,38 +888,28 @@ Dump::visit (UseDeclaration &use_decl)\n void\n Dump::visit (Function &function)\n {\n-  emit_visibility (function.get_visibility ());\n+  visit (function.get_visibility ());\n \n   stream << \"fn \" << function.get_function_name ();\n   if (function.has_generics ())\n-    emit_generic_params (function.get_generic_params ());\n+    visit (function.get_generic_params ());\n \n   stream << '(';\n-  auto &params = function.get_function_params ();\n-  if (params.size () >= 1)\n-    {\n-      format_function_param (params[0]);\n-      for (size_t i = 1; i < params.size (); i++)\n-\t{\n-\t  stream << \", \";\n-\t  format_function_param (params[i]);\n-\t}\n-    }\n-\n+  visit_items_joined_by_separator (function.get_function_params ());\n   stream << \") \";\n \n   if (function.has_return_type ())\n     {\n       stream << \"-> \";\n-      function.get_return_type ()->accept_vis (*this);\n+      visit (function.get_return_type ());\n       stream << \" \";\n     }\n \n   auto &block = function.get_definition ();\n   if (!block)\n     stream << ';';\n   else\n-    block->accept_vis (*this);\n+    visit (block);\n \n   stream << '\\n';\n }\n@@ -941,15 +923,15 @@ Dump::visit (TypeAlias &type_alias)\n   // Note: Associated types are handled by `AST::TraitItemType`.\n \n   if (type_alias.has_visibility ())\n-    emit_visibility (type_alias.get_visibility ());\n+    visit (type_alias.get_visibility ());\n   stream << \"type \" << type_alias.get_new_type_name ();\n   if (type_alias.has_generics ())\n-    emit_generic_params (type_alias.get_generic_params ());\n+    visit (type_alias.get_generic_params ());\n   if (type_alias.has_where_clause ())\n     {\n     } // FIXME: WhereClause\n   stream << \" = \";\n-  type_alias.get_type_aliased ()->accept_vis (*this);\n+  visit (type_alias.get_type_aliased ());\n   stream << \";\\n\";\n }\n \n@@ -958,49 +940,24 @@ Dump::visit (StructStruct &struct_item)\n {\n   stream << \"struct \" << struct_item.get_identifier ();\n   if (struct_item.has_generics ())\n-    emit_generic_params (struct_item.get_generic_params ());\n+    visit (struct_item.get_generic_params ());\n \n   // FIXME: where-clause\n \n-  stream << \" {\";\n-\n-  auto &fields = struct_item.get_fields ();\n-\n-  indentation.increment ();\n-  for (auto &field : fields)\n-    {\n-      stream << '\\n' << indentation;\n-      format_struct_field (field);\n-      stream << ',';\n-    }\n-  indentation.decrement ();\n-\n-  if (fields.size () > 0)\n-    stream << '\\n' << indentation;\n-  stream << \"}\\n\";\n+  visit_items_as_block (struct_item.get_fields ());\n }\n \n void\n Dump::visit (TupleStruct &tuple_struct)\n {\n   stream << \"struct \" << tuple_struct.get_identifier ();\n   if (tuple_struct.has_generics ())\n-    emit_generic_params (tuple_struct.get_generic_params ());\n+    visit (tuple_struct.get_generic_params ());\n \n   // FIXME: where-clause\n \n   stream << '(';\n-\n-  auto &fields = tuple_struct.get_fields ();\n-  if (fields.size () >= 1)\n-    {\n-      format_tuple_field (fields[0]);\n-      for (size_t i = 1; i < fields.size (); i++)\n-\t{\n-\t  stream << \", \";\n-\t  format_tuple_field (fields[i]);\n-\t}\n-    }\n+  visit_items_joined_by_separator (tuple_struct.get_fields (), \", \");\n   stream << \");\\n\";\n }\n \n@@ -1014,94 +971,46 @@ void\n Dump::visit (EnumItemTuple &item)\n {\n   stream << item.get_identifier () << '(';\n-  auto &fields = item.get_tuple_fields ();\n-  if (fields.size () >= 1)\n-    {\n-      format_tuple_field (fields[0]);\n-      for (size_t i = 1; i < fields.size (); i++)\n-\t{\n-\t  stream << \", \";\n-\t  format_tuple_field (fields[i]);\n-\t}\n-    }\n+  visit_items_joined_by_separator (item.get_tuple_fields (), \", \");\n   stream << ')';\n }\n \n void\n Dump::visit (EnumItemStruct &item)\n {\n-  stream << item.get_identifier () << \" {\";\n-\n-  auto &fields = item.get_struct_fields ();\n-\n-  indentation.increment ();\n-  for (auto &field : fields)\n-    {\n-      stream << '\\n' << indentation;\n-      format_struct_field (field);\n-      stream << ',';\n-    }\n-  indentation.decrement ();\n-\n-  if (fields.size () > 0)\n-    stream << '\\n' << indentation;\n-  stream << '}';\n+  stream << item.get_identifier ();\n+  visit_items_as_block (item.get_struct_fields ());\n }\n \n void\n Dump::visit (EnumItemDiscriminant &item)\n {\n   stream << item.get_identifier () << \" = \";\n-  item.get_expr ()->accept_vis (*this);\n+  visit (item.get_expr ());\n }\n \n void\n Dump::visit (Enum &enum_item)\n {\n   stream << \"enum \" << enum_item.get_identifier ();\n   if (enum_item.has_generics ())\n-    emit_generic_params (enum_item.get_generic_params ());\n+    visit (enum_item.get_generic_params ());\n \n   // FIXME: where-clause\n \n-  stream << \" {\";\n-  auto &variants = enum_item.get_variants ();\n-  if (variants.size () >= 1)\n-    {\n-      stream << '\\n';\n-      indentation.increment ();\n-      for (auto &var : variants)\n-\t{\n-\t  stream << indentation;\n-\t  var->accept_vis (*this);\n-\t  stream << \",\\n\";\n-\t}\n-      indentation.decrement ();\n-    }\n-\n-  stream << \"}\\n\";\n+  visit_items_as_block (enum_item.get_variants ());\n }\n \n void\n Dump::visit (Union &union_item)\n {\n   stream << \"union \" << union_item.get_identifier ();\n   if (union_item.has_generics ())\n-    emit_generic_params (union_item.get_generic_params ());\n+    visit (union_item.get_generic_params ());\n \n   // FIXME: where-clause\n \n-  stream << \" {\";\n-  indentation.increment ();\n-  for (auto &field : union_item.get_variants ())\n-    {\n-      stream << '\\n' << indentation;\n-      format_struct_field (field);\n-      stream << ',';\n-    }\n-  indentation.decrement ();\n-\n-  stream << '\\n' << indentation << \"}\\n\";\n+  visit_items_as_block (union_item.get_variants ());\n }\n \n void\n@@ -1113,22 +1022,22 @@ Dump::visit (StaticItem &static_item)\n {}\n \n void\n-Dump::format_function_common (std::unique_ptr<Type> &return_type,\n-\t\t\t      std::unique_ptr<BlockExpr> &block)\n+Dump::visit_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t     std::unique_ptr<BlockExpr> &block)\n {\n   // FIXME: This should format the `<vis> fn <name> ( [args] )` as well\n   if (return_type)\n     {\n       stream << \"-> \";\n-      return_type->accept_vis (*this);\n+      visit (return_type);\n     }\n \n   if (block)\n     {\n       if (return_type)\n \t{\n \t  stream << ' ';\n-\t  block->accept_vis (*this);\n+\t  visit (block);\n \t}\n     }\n   else\n@@ -1141,16 +1050,11 @@ Dump::visit (TraitItemFunc &item)\n   auto func = item.get_trait_function_decl ();\n   stream << indentation << \"fn \" << func.get_identifier () << '(';\n \n-  auto &params = func.get_function_params ();\n-  for (auto &param : params)\n-    {\n-      stream << \", \";\n-      format_function_param (param);\n-    }\n+  visit_items_joined_by_separator (func.get_function_params ());\n \n   stream << \") \";\n \n-  format_function_common (func.get_return_type (), item.get_definition ());\n+  visit_function_common (func.get_return_type (), item.get_definition ());\n }\n \n void\n@@ -1165,26 +1069,20 @@ Dump::visit (TraitItemMethod &item)\n   // emit_visibility (method.get_visibility ());\n   stream << \"fn \" << method.get_identifier () << '(';\n \n-  auto &self = method.get_self_param ();\n-  stream << self.as_string ();\n+  stream << method.get_self_param ().as_string () << \", \";\n \n-  auto &params = method.get_function_params ();\n-  for (auto &param : params)\n-    {\n-      stream << \", \";\n-      format_function_param (param);\n-    }\n+  visit_items_joined_by_separator (method.get_function_params (), \", \");\n \n   stream << \") \";\n \n-  format_function_common (method.get_return_type (), item.get_definition ());\n+  visit_function_common (method.get_return_type (), item.get_definition ());\n }\n \n void\n Dump::visit (TraitItemConst &item)\n {\n   stream << indentation << \"const \" << item.get_identifier () << \": \";\n-  item.get_type ()->accept_vis (*this);\n+  visit (item.get_type ());\n   stream << \";\\n\";\n }\n \n@@ -1199,40 +1097,24 @@ Dump::visit (Trait &trait)\n {\n   for (const auto &attr : trait.get_outer_attrs ())\n     {\n-      emit_attrib (attr);\n+      visit (attr);\n       stream << \"\\n\" << indentation;\n     }\n \n-  emit_visibility (trait.get_visibility ());\n+  visit (trait.get_visibility ());\n \n   stream << \"trait \" << trait.get_identifier ();\n \n-  // Traits actually have an implicit Self thrown at the start so we must expect\n-  // the number of generic params to be > 1\n+  // Traits actually have an implicit Self thrown at the start, so we must\n+  // expect the number of generic params to be > 1\n   if (trait.get_generic_params ().size () > 1)\n     {\n       stream << \"<\";\n-      for (size_t i = 1; i < trait.get_generic_params ().size (); i++)\n-\t{\n-\t  auto &param = trait.get_generic_params ().at (i);\n-\t  param->accept_vis (*this);\n-\n-\t  bool has_next = (i + 1) < trait.get_generic_params ().size ();\n-\t  if (has_next)\n-\t    stream << \", \";\n-\t}\n+      visit_items_joined_by_separator (trait.get_generic_params (), \", \", 1);\n       stream << \">\";\n     }\n \n-  stream << \" {\\n\";\n-\n-  indentation.increment ();\n-\n-  for (auto &item : trait.get_trait_items ())\n-    item->accept_vis (*this);\n-\n-  indentation.decrement ();\n-  stream << \"\\n}\\n\";\n+  visit_items_as_block (trait.get_trait_items ());\n }\n \n void\n@@ -1242,36 +1124,29 @@ Dump::visit (InherentImpl &impl)\n \n   // FIXME: Handle generics\n \n-  impl.get_type ()->accept_vis (*this);\n+  visit (impl.get_type ());\n \n   // FIXME: Handle where-clause\n   // FIXME: Handle inner attributes\n \n-  stream << \" {\\n\";\n-  indentation.increment ();\n-\n-  for (auto &item : impl.get_impl_items ())\n-    item->accept_vis (*this);\n-\n-  indentation.decrement ();\n-  stream << \"\\n}\\n\";\n+  visit_items_as_block (impl.get_impl_items ());\n }\n \n void\n Dump::visit (TraitImpl &impl)\n {\n   stream << \"impl \";\n-  impl.get_trait_path ().accept_vis (*this);\n+  visit (impl.get_trait_path ());\n   stream << \" for \";\n-  impl.get_type ()->accept_vis (*this);\n+  visit (impl.get_type ());\n   stream << \" {\\n\";\n \n   indentation.increment ();\n \n   for (auto &item : impl.get_impl_items ())\n     {\n       stream << indentation;\n-      item->accept_vis (*this);\n+      visit (item);\n     }\n \n   indentation.decrement ();\n@@ -1285,27 +1160,17 @@ Dump::visit (ExternalStaticItem &item)\n void\n Dump::visit (ExternalFunctionItem &function)\n {\n-  emit_visibility (function.get_visibility ());\n+  visit (function.get_visibility ());\n \n   stream << \"fn \" << function.get_identifier () << '(';\n \n-  for (size_t i = 0; i < function.get_function_params ().size (); i++)\n-    {\n-      auto &param = function.get_function_params ().at (i);\n-      bool has_next = (i + 1) < function.get_function_params ().size ();\n-\n-      stream << param.get_name () << \": \";\n-      param.get_type ()->accept_vis (*this);\n-\n-      if (has_next)\n-\tstream << \", \";\n-    }\n+  visit_items_joined_by_separator (function.get_function_params ());\n \n   stream << ')';\n   if (function.has_return_type ())\n     {\n       stream << \"-> \";\n-      function.get_return_type ()->accept_vis (*this);\n+      visit (function.get_return_type ());\n     }\n }\n \n@@ -1317,18 +1182,7 @@ Dump::visit (ExternBlock &block)\n   if (block.has_abi ())\n     stream << \"\\\"\" << block.get_abi () << \"\\\" \";\n \n-  stream << \"{\\n\";\n-  indentation.increment ();\n-\n-  for (auto &item : block.get_extern_items ())\n-    {\n-      stream << indentation;\n-      item->accept_vis (*this);\n-      stream << \";\\n\";\n-    }\n-\n-  indentation.decrement ();\n-  stream << \"\\n\" << indentation << \"}\\n\";\n+  visit_items_as_block (block.get_extern_items ());\n }\n \n static std::pair<char, char>\n@@ -1368,11 +1222,7 @@ Dump::visit (MacroMatchRepetition &repetition)\n {\n   stream << \"$(\";\n \n-  for (auto &match : repetition.get_matches ())\n-    {\n-      match->accept_vis (*this);\n-      stream << ' ';\n-    }\n+  visit_items_joined_by_separator (repetition.get_matches (), \" \");\n \n   auto op_char = '\\0';\n   switch (repetition.get_op ())\n@@ -1405,41 +1255,29 @@ Dump::visit (MacroMatcher &matcher)\n \n   stream << delimiters.first;\n \n-  for (auto &match : matcher.get_matches ())\n-    {\n-      match->accept_vis (*this);\n-      stream << ' ';\n-    }\n+  visit_items_joined_by_separator (matcher.get_matches (), \" \");\n \n   stream << delimiters.second;\n }\n \n+void\n+Dump::visit (MacroRule &rule)\n+{\n+  visit (rule.get_matcher ());\n+  stream << \" => \";\n+  visit (rule.get_transcriber ().get_token_tree ());\n+  stream << \";\";\n+}\n+\n void\n Dump::visit (MacroRulesDefinition &rules_def)\n {\n   for (auto &outer_attr : rules_def.get_outer_attrs ())\n-    emit_attrib (outer_attr);\n-\n-  stream << \"macro_rules! \" << rules_def.get_rule_name () << \" {\\n\";\n-\n-  indentation.increment ();\n+    visit (outer_attr);\n \n-  for (auto &rule : rules_def.get_rules ())\n-    {\n-      stream << indentation;\n-\n-      rule.get_matcher ().accept_vis (*this);\n-\n-      stream << \" => \";\n-\n-      rule.get_transcriber ().get_token_tree ().accept_vis (*this);\n-\n-      stream << \";\\n\";\n-    }\n-\n-  indentation.decrement ();\n+  stream << \"macro_rules! \" << rules_def.get_rule_name ();\n \n-  stream << \"}\\n\";\n+  visit_items_as_block (rules_def.get_rules ());\n }\n \n void\n@@ -1572,31 +1410,31 @@ Dump::visit (LetStmt &stmt)\n   stream << \"let \";\n   auto &pattern = stmt.get_pattern ();\n   if (pattern)\n-    pattern->accept_vis (*this);\n+    visit (pattern);\n \n   if (stmt.has_type ())\n     {\n       stream << \": \";\n-      stmt.get_type ()->accept_vis (*this);\n+      visit (stmt.get_type ());\n     }\n \n   if (stmt.has_init_expr ())\n     {\n       stream << \" = \";\n-      stmt.get_init_expr ()->accept_vis (*this);\n+      visit (stmt.get_init_expr ());\n     }\n }\n \n void\n Dump::visit (ExprStmtWithoutBlock &stmt)\n {\n-  stmt.get_expr ()->accept_vis (*this);\n+  visit (stmt.get_expr ());\n }\n \n void\n Dump::visit (ExprStmtWithBlock &stmt)\n {\n-  stmt.get_expr ()->accept_vis (*this);\n+  visit (stmt.get_expr ());\n }\n \n // rust-type.h\n@@ -1639,19 +1477,19 @@ Dump::visit (RawPointerType &type)\n void\n Dump::visit (ReferenceType &type)\n {\n-  type.get_type_referenced ()->accept_vis (*this);\n+  visit (type.get_type_referenced ());\n }\n \n void\n Dump::visit (ArrayType &type)\n {\n-  type.get_elem_type ()->accept_vis (*this);\n+  visit (type.get_elem_type ());\n }\n \n void\n Dump::visit (SliceType &type)\n {\n-  type.get_elem_type ()->accept_vis (*this);\n+  visit (type.get_elem_type ());\n }\n \n void"}, {"sha": "fa8417d57a5ba1ec896452741bd768eae1afe26c", "filename": "gcc/rust/ast/rust-ast-dump.h", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77cba0083a86c63f619b41eaf2acec61ea04d6c8/gcc%2Frust%2Fast%2Frust-ast-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77cba0083a86c63f619b41eaf2acec61ea04d6c8/gcc%2Frust%2Fast%2Frust-ast-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-dump.h?ref=77cba0083a86c63f619b41eaf2acec61ea04d6c8", "patch": "@@ -81,46 +81,55 @@ class Dump : public ASTVisitor\n   template <typename T> void visit (std::unique_ptr<T> &node);\n \n   /**\n-   * Format together common items of functions: Parameters, return type, block\n+   * Visit all items in given collection, placing the separator in between but\n+   * not at the end.\n+   * Start and end offset allow to visit only a \"slice\" from the collection.\n    */\n-  void format_function_common (std::unique_ptr<Type> &return_type,\n-\t\t\t       std::unique_ptr<BlockExpr> &block);\n+  template <typename T>\n+  void visit_items_joined_by_separator (T &collection,\n+\t\t\t\t\tconst std::string &separator = \"\",\n+\t\t\t\t\tsize_t start_offset = 0,\n+\t\t\t\t\tsize_t end_offset = 0);\n \n   /**\n-   * Format a function's definition parameter\n+   * Visit item placing indentation before and trailing string + end of line\n+   * after.\n    */\n-  void format_function_param (FunctionParam &param);\n+  template <typename T>\n+  void visit_as_line (T &item, const std::string &trailing = \"\");\n \n   /**\n-   * Emit an attribute\n+   * Visit each item in a collection \"as line\".\n+   *\n+   * @see visit_as_line\n    */\n-  void emit_attrib (const Attribute &attrib);\n+  template <typename T>\n+  void visit_items_as_lines (T &collection, const std::string &trailing = \"\");\n \n   /**\n-   * Emit an item's visibility\n+   * Visit each item in collection as lines inside a block delimited by braces\n+   * with increased indentation. Also includes special handling for empty\n+   * collection to print only the delimiters with no new line inside.\n    */\n-  void emit_visibility (const Visibility &vis);\n+  template <typename T>\n+  void visit_items_as_block (T &collection, char left_brace = '{',\n+\t\t\t     char right_brace = '}');\n \n   /**\n-   * Emit an indented string with an optional extra comment\n+   * Visit common items of functions: Parameters, return type, block\n    */\n-  std::ostream &emit_indented_string (const std::string &value,\n-\t\t\t\t      const std::string &comment = \"\");\n-\n-  /**\n-   * Emit formatted string for generic parameters\n-   */\n-  void emit_generic_params (std::vector<std::unique_ptr<GenericParam>> &params);\n-\n-  /**\n-   * Format a single field of a tuple\n-   */\n-  void format_tuple_field (TupleField &field);\n-\n-  /**\n-   * Format a single field of a struct\n-   */\n-  void format_struct_field (StructField &field);\n+  void visit_function_common (std::unique_ptr<Type> &return_type,\n+\t\t\t      std::unique_ptr<BlockExpr> &block);\n+\n+  void visit (FunctionParam &param);\n+  void visit (const Attribute &attrib);\n+  void visit (const Visibility &vis);\n+  void visit (std::vector<std::unique_ptr<GenericParam>> &params);\n+  void visit (TupleField &field);\n+  void visit (StructField &field);\n+  void visit (const SimplePathSegment &segment);\n+  void visit (NamedFunctionParam &param);\n+  void visit (MacroRule &rule);\n \n   // rust-ast.h\n   void visit (Token &tok);"}]}