{"sha": "98032cd46ffc18adfdbf6fb7b585998283ada9f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwMzJjZDQ2ZmZjMThhZGZkYmY2ZmI3YjU4NTk5ODI4M2FkYTlmNQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-12-02T19:14:25Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-12-17T10:49:25Z"}, "message": "[Ada] Code cleanup: remove Old_Requires_Transient_Scope\n\ngcc/ada/\n\n\t* sem_util.adb (New_Requires_Transient_Scope): Renamed\n\tRequires_Transient_Scope.\n\t(Requires_Transient_Scope, Old_Requires_Transient_Scope,\n\tResults_Differ): Removed.\n\t* debug.adb: Remove -gnatdQ.", "tree": {"sha": "9d936e6e08221fefa1ed906ac7c0bb3cd08fdf46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d936e6e08221fefa1ed906ac7c0bb3cd08fdf46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98032cd46ffc18adfdbf6fb7b585998283ada9f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98032cd46ffc18adfdbf6fb7b585998283ada9f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98032cd46ffc18adfdbf6fb7b585998283ada9f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98032cd46ffc18adfdbf6fb7b585998283ada9f5/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2ff35b910f0c9a59d1ae64c142fb5866126f09f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2ff35b910f0c9a59d1ae64c142fb5866126f09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2ff35b910f0c9a59d1ae64c142fb5866126f09f"}], "stats": {"total": 670, "additions": 244, "deletions": 426}, "files": [{"sha": "2c7c7127fa2a4881b9e5df8a9537553cc38c238c", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98032cd46ffc18adfdbf6fb7b585998283ada9f5/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98032cd46ffc18adfdbf6fb7b585998283ada9f5/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=98032cd46ffc18adfdbf6fb7b585998283ada9f5", "patch": "@@ -74,7 +74,7 @@ package body Debug is\n    --  dN   No file name information in exception messages\n    --  dO   Output immediate error messages\n    --  dP   Do not check for controlled objects in preelaborable packages\n-   --  dQ   Use old secondary stack method\n+   --  dQ\n    --  dR   Bypass check for correct version of s-rpc\n    --  dS   Never convert numbers to machine numbers in Sem_Eval\n    --  dT   Convert to machine numbers only for constant declarations\n@@ -643,11 +643,6 @@ package body Debug is\n    --       in preelaborable packages, but this restriction is a huge pain,\n    --       especially in the predefined library units.\n \n-   --  dQ   Use old method for determining what goes on the secondary stack.\n-   --       This disables some newer optimizations. The intent is to use this\n-   --       temporarily to measure before/after efficiency. ???Remove this\n-   --       when we are done (see Sem_Util.Requires_Transient_Scope).\n-\n    --  dR   Bypass the check for a proper version of s-rpc being present\n    --       to use the -gnatz? switch. This allows debugging of the use\n    --       of stubs generation without needing to have GLADE (or some"}, {"sha": "01b8dccecaa87ad479e02ceff16d484acfc3bf60", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 243, "deletions": 420, "changes": 663, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98032cd46ffc18adfdbf6fb7b585998283ada9f5/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98032cd46ffc18adfdbf6fb7b585998283ada9f5/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=98032cd46ffc18adfdbf6fb7b585998283ada9f5", "patch": "@@ -23,8 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Treepr; -- ???For debugging code below\n-\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -170,24 +168,6 @@ package body Sem_Util is\n    --  routine does not take simple flow diagnostics into account, it relies on\n    --  static facts such as the presence of null exclusions.\n \n-   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n-   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean;\n-   --  ???We retain the old and new algorithms for Requires_Transient_Scope for\n-   --  the time being. New_Requires_Transient_Scope is used by default; the\n-   --  debug switch -gnatdQ can be used to do Old_Requires_Transient_Scope\n-   --  instead. The intent is to use this temporarily to measure before/after\n-   --  efficiency. Note: when this temporary code is removed, the documentation\n-   --  of dQ in debug.adb should be removed.\n-\n-   procedure Results_Differ\n-     (Id      : Entity_Id;\n-      Old_Val : Boolean;\n-      New_Val : Boolean);\n-   --  ???Debugging code. Called when the Old_Val and New_Val differ. This\n-   --  routine will be removed eventially when New_Requires_Transient_Scope\n-   --  becomes Requires_Transient_Scope and Old_Requires_Transient_Scope is\n-   --  eliminated.\n-\n    function Subprogram_Name (N : Node_Id) return String;\n    --  Return the fully qualified name of the enclosing subprogram for the\n    --  given node N, with file:line:col information appended, e.g.\n@@ -24420,228 +24400,6 @@ package body Sem_Util is\n       Node := Next_Global (Node);\n    end Next_Global;\n \n-   ----------------------------------\n-   -- New_Requires_Transient_Scope --\n-   ----------------------------------\n-\n-   function New_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n-      --  This is called for untagged records and protected types, with\n-      --  nondefaulted discriminants. Returns True if the size of function\n-      --  results is known at the call site, False otherwise. Returns False\n-      --  if there is a variant part that depends on the discriminants of\n-      --  this type, or if there is an array constrained by the discriminants\n-      --  of this type. ???Currently, this is overly conservative (the array\n-      --  could be nested inside some other record that is constrained by\n-      --  nondiscriminants). That is, the recursive calls are too conservative.\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n-      --  Returns True if Typ is a nonlimited record with defaulted\n-      --  discriminants whose max size makes it unsuitable for allocating on\n-      --  the primary stack.\n-\n-      ------------------------------\n-      -- Caller_Known_Size_Record --\n-      ------------------------------\n-\n-      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-      begin\n-         if Has_Variant_Part (Typ) and then not Is_Definite_Subtype (Typ) then\n-            return False;\n-         end if;\n-\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            Comp := First_Component (Typ);\n-            while Present (Comp) loop\n-\n-               --  Only look at E_Component entities. No need to look at\n-               --  E_Discriminant entities, and we must ignore internal\n-               --  subtypes generated for constrained components.\n-\n-               declare\n-                  Comp_Type : constant Entity_Id :=\n-                                Underlying_Type (Etype (Comp));\n-\n-               begin\n-                  if Is_Record_Type (Comp_Type)\n-                        or else\n-                     Is_Protected_Type (Comp_Type)\n-                  then\n-                     if not Caller_Known_Size_Record (Comp_Type) then\n-                        return False;\n-                     end if;\n-\n-                  elsif Is_Array_Type (Comp_Type) then\n-                     if Size_Depends_On_Discriminant (Comp_Type) then\n-                        return False;\n-                     end if;\n-                  end if;\n-               end;\n-\n-               Next_Component (Comp);\n-            end loop;\n-         end;\n-\n-         return True;\n-      end Caller_Known_Size_Record;\n-\n-      ------------------------------\n-      -- Large_Max_Size_Mutable --\n-      ------------------------------\n-\n-      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n-         pragma Assert (Typ = Underlying_Type (Typ));\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n-         --  Returns true if the discrete type T has a large range\n-\n-         ----------------------------\n-         -- Is_Large_Discrete_Type --\n-         ----------------------------\n-\n-         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n-            Threshold : constant Int := 16;\n-            --  Arbitrary threshold above which we consider it \"large\". We want\n-            --  a fairly large threshold, because these large types really\n-            --  shouldn't have default discriminants in the first place, in\n-            --  most cases.\n-\n-         begin\n-            return UI_To_Int (RM_Size (T)) > Threshold;\n-         end Is_Large_Discrete_Type;\n-\n-      --  Start of processing for Large_Max_Size_Mutable\n-\n-      begin\n-         if Is_Record_Type (Typ)\n-           and then not Is_Limited_View (Typ)\n-           and then Has_Defaulted_Discriminants (Typ)\n-         then\n-            --  Loop through the components, looking for an array whose upper\n-            --  bound(s) depends on discriminants, where both the subtype of\n-            --  the discriminant and the index subtype are too large.\n-\n-            declare\n-               Comp : Entity_Id;\n-\n-            begin\n-               Comp := First_Component (Typ);\n-               while Present (Comp) loop\n-                  declare\n-                     Comp_Type : constant Entity_Id :=\n-                                   Underlying_Type (Etype (Comp));\n-\n-                     Hi   : Node_Id;\n-                     Indx : Node_Id;\n-                     Ityp : Entity_Id;\n-\n-                  begin\n-                     if Is_Array_Type (Comp_Type) then\n-                        Indx := First_Index (Comp_Type);\n-\n-                        while Present (Indx) loop\n-                           Ityp := Etype (Indx);\n-                           Hi := Type_High_Bound (Ityp);\n-\n-                           if Nkind (Hi) = N_Identifier\n-                             and then Ekind (Entity (Hi)) = E_Discriminant\n-                             and then Is_Large_Discrete_Type (Ityp)\n-                             and then Is_Large_Discrete_Type\n-                                        (Etype (Entity (Hi)))\n-                           then\n-                              return True;\n-                           end if;\n-\n-                           Next_Index (Indx);\n-                        end loop;\n-                     end if;\n-                  end;\n-\n-                  Next_Component (Comp);\n-               end loop;\n-            end;\n-         end if;\n-\n-         return False;\n-      end Large_Max_Size_Mutable;\n-\n-      --  Local declarations\n-\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n-\n-   --  Start of processing for New_Requires_Transient_Scope\n-\n-   begin\n-      --  This is a private type which is not completed yet. This can only\n-      --  happen in a default expression (of a formal parameter or of a\n-      --  record component). Do not expand transient scope in this case.\n-\n-      if No (Typ) then\n-         return False;\n-\n-      --  Do not expand transient scope for non-existent procedure return or\n-      --  string literal types.\n-\n-      elsif Typ = Standard_Void_Type\n-        or else Ekind (Typ) = E_String_Literal_Subtype\n-      then\n-         return False;\n-\n-      --  If Typ is a generic formal incomplete type, then we want to look at\n-      --  the actual type.\n-\n-      elsif Ekind (Typ) = E_Record_Subtype\n-        and then Present (Cloned_Subtype (Typ))\n-      then\n-         return New_Requires_Transient_Scope (Cloned_Subtype (Typ));\n-\n-      --  Functions returning specific tagged types may dispatch on result, so\n-      --  their returned value is allocated on the secondary stack, even in the\n-      --  definite case. We must treat nondispatching functions the same way,\n-      --  because access-to-function types can point at both, so the calling\n-      --  conventions must be compatible. Is_Tagged_Type includes controlled\n-      --  types and class-wide types. Controlled type temporaries need\n-      --  finalization.\n-\n-      --  ???It's not clear why we need to return noncontrolled types with\n-      --  controlled components on the secondary stack.\n-\n-      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return True;\n-\n-      --  Untagged definite subtypes are known size. This includes all\n-      --  elementary [sub]types. Tasks are known size even if they have\n-      --  discriminants. So we return False here, with one exception:\n-      --  For a type like:\n-      --    type T (Last : Natural := 0) is\n-      --       X : String (1 .. Last);\n-      --    end record;\n-      --  we return True. That's because for \"P(F(...));\", where F returns T,\n-      --  we don't know the size of the result at the call site, so if we\n-      --  allocated it on the primary stack, we would have to allocate the\n-      --  maximum size, which is way too big.\n-\n-      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n-         return Large_Max_Size_Mutable (Typ);\n-\n-      --  Indefinite (discriminated) untagged record or protected type\n-\n-      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n-         return not Caller_Known_Size_Record (Typ);\n-\n-      --  Unconstrained array\n-\n-      else\n-         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n-         return True;\n-      end if;\n-   end New_Requires_Transient_Scope;\n-\n    ------------------------\n    -- No_Caching_Enabled --\n    ------------------------\n@@ -25516,140 +25274,41 @@ package body Sem_Util is\n       return Num;\n    end Number_Of_Elements_In_Array;\n \n-   ----------------------------------\n-   -- Old_Requires_Transient_Scope --\n-   ----------------------------------\n+   ---------------------------------\n+   -- Original_Aspect_Pragma_Name --\n+   ---------------------------------\n \n-   function Old_Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-      Typ : constant Entity_Id := Underlying_Type (Id);\n+   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id is\n+      Item     : Node_Id;\n+      Item_Nam : Name_Id;\n \n    begin\n-      --  This is a private type which is not completed yet. This can only\n-      --  happen in a default expression (of a formal parameter or of a\n-      --  record component). Do not expand transient scope in this case.\n+      pragma Assert (Nkind (N) in N_Aspect_Specification | N_Pragma);\n \n-      if No (Typ) then\n-         return False;\n+      Item := N;\n \n-      --  Do not expand transient scope for non-existent procedure return\n+      --  The pragma was generated to emulate an aspect, use the original\n+      --  aspect specification.\n \n-      elsif Typ = Standard_Void_Type then\n-         return False;\n+      if Nkind (Item) = N_Pragma and then From_Aspect_Specification (Item) then\n+         Item := Corresponding_Aspect (Item);\n+      end if;\n \n-      --  Elementary types do not require a transient scope\n+      --  Retrieve the name of the aspect/pragma. As assertion pragmas from\n+      --  a generic instantiation might have been rewritten into pragma Check,\n+      --  we look at the original node for Item. Note also that Pre, Pre_Class,\n+      --  Post and Post_Class rewrite their pragma identifier to preserve the\n+      --  original name, so we look at the original node for the identifier.\n+      --  ??? this is kludgey\n \n-      elsif Is_Elementary_Type (Typ) then\n-         return False;\n+      if Nkind (Item) = N_Pragma then\n+         Item_Nam :=\n+           Chars (Original_Node (Pragma_Identifier (Original_Node (Item))));\n \n-      --  Generally, indefinite subtypes require a transient scope, since the\n-      --  back end cannot generate temporaries, since this is not a valid type\n-      --  for declaring an object. It might be possible to relax this in the\n-      --  future, e.g. by declaring the maximum possible space for the type.\n-\n-      elsif not Is_Definite_Subtype (Typ) then\n-         return True;\n-\n-      --  Functions returning tagged types may dispatch on result so their\n-      --  returned value is allocated on the secondary stack. Controlled\n-      --  type temporaries need finalization.\n-\n-      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n-         return True;\n-\n-      --  Record type\n-\n-      elsif Is_Record_Type (Typ) then\n-         declare\n-            Comp : Entity_Id;\n-\n-         begin\n-            Comp := First_Entity (Typ);\n-            while Present (Comp) loop\n-               if Ekind (Comp) = E_Component then\n-\n-                  --  ???It's not clear we need a full recursive call to\n-                  --  Old_Requires_Transient_Scope here. Note that the\n-                  --  following can't happen.\n-\n-                  pragma Assert (Is_Definite_Subtype (Etype (Comp)));\n-                  pragma Assert (not Has_Controlled_Component (Etype (Comp)));\n-\n-                  if Old_Requires_Transient_Scope (Etype (Comp)) then\n-                     return True;\n-                  end if;\n-               end if;\n-\n-               Next_Entity (Comp);\n-            end loop;\n-         end;\n-\n-         return False;\n-\n-      --  String literal types never require transient scope\n-\n-      elsif Ekind (Typ) = E_String_Literal_Subtype then\n-         return False;\n-\n-      --  Array type. Note that we already know that this is a constrained\n-      --  array, since unconstrained arrays will fail the indefinite test.\n-\n-      elsif Is_Array_Type (Typ) then\n-\n-         --  If component type requires a transient scope, the array does too\n-\n-         if Old_Requires_Transient_Scope (Component_Type (Typ)) then\n-            return True;\n-\n-         --  Otherwise, we only need a transient scope if the size depends on\n-         --  the value of one or more discriminants.\n-\n-         else\n-            return Size_Depends_On_Discriminant (Typ);\n-         end if;\n-\n-      --  All other cases do not require a transient scope\n-\n-      else\n-         pragma Assert (Is_Concurrent_Type (Typ));\n-         return False;\n-      end if;\n-   end Old_Requires_Transient_Scope;\n-\n-   ---------------------------------\n-   -- Original_Aspect_Pragma_Name --\n-   ---------------------------------\n-\n-   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id is\n-      Item     : Node_Id;\n-      Item_Nam : Name_Id;\n-\n-   begin\n-      pragma Assert (Nkind (N) in N_Aspect_Specification | N_Pragma);\n-\n-      Item := N;\n-\n-      --  The pragma was generated to emulate an aspect, use the original\n-      --  aspect specification.\n-\n-      if Nkind (Item) = N_Pragma and then From_Aspect_Specification (Item) then\n-         Item := Corresponding_Aspect (Item);\n-      end if;\n-\n-      --  Retrieve the name of the aspect/pragma. As assertion pragmas from\n-      --  a generic instantiation might have been rewritten into pragma Check,\n-      --  we look at the original node for Item. Note also that Pre, Pre_Class,\n-      --  Post and Post_Class rewrite their pragma identifier to preserve the\n-      --  original name, so we look at the original node for the identifier.\n-      --  ??? this is kludgey\n-\n-      if Nkind (Item) = N_Pragma then\n-         Item_Nam :=\n-           Chars (Original_Node (Pragma_Identifier (Original_Node (Item))));\n-\n-      else\n-         pragma Assert (Nkind (Item) = N_Aspect_Specification);\n-         Item_Nam := Chars (Identifier (Item));\n-      end if;\n+      else\n+         pragma Assert (Nkind (Item) = N_Aspect_Specification);\n+         Item_Nam := Chars (Identifier (Item));\n+      end if;\n \n       --  Deal with 'Class by converting the name to its _XXX form\n \n@@ -26712,18 +26371,82 @@ package body Sem_Util is\n    --  generated before the next instruction.\n \n    function Requires_Transient_Scope (Id : Entity_Id) return Boolean is\n-      Old_Result : constant Boolean := Old_Requires_Transient_Scope (Id);\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean;\n+      --  This is called for untagged records and protected types, with\n+      --  nondefaulted discriminants. Returns True if the size of function\n+      --  results is known at the call site, False otherwise. Returns False\n+      --  if there is a variant part that depends on the discriminants of\n+      --  this type, or if there is an array constrained by the discriminants\n+      --  of this type. ???Currently, this is overly conservative (the array\n+      --  could be nested inside some other record that is constrained by\n+      --  nondiscriminants). That is, the recursive calls are too conservative.\n \n       procedure Ensure_Minimum_Decoration (Typ : Entity_Id);\n       --  If Typ is not frozen then add to Typ the minimum decoration required\n       --  by Requires_Transient_Scope to reliably provide its functionality;\n       --  otherwise no action is performed.\n \n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean;\n+      --  Returns True if Typ is a nonlimited record with defaulted\n+      --  discriminants whose max size makes it unsuitable for allocating on\n+      --  the primary stack.\n+\n+      ------------------------------\n+      -- Caller_Known_Size_Record --\n+      ------------------------------\n+\n+      function Caller_Known_Size_Record (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+      begin\n+         if Has_Variant_Part (Typ) and then not Is_Definite_Subtype (Typ) then\n+            return False;\n+         end if;\n+\n+         declare\n+            Comp : Entity_Id;\n+\n+         begin\n+            Comp := First_Component (Typ);\n+            while Present (Comp) loop\n+\n+               --  Only look at E_Component entities. No need to look at\n+               --  E_Discriminant entities, and we must ignore internal\n+               --  subtypes generated for constrained components.\n+\n+               declare\n+                  Comp_Type : constant Entity_Id :=\n+                                Underlying_Type (Etype (Comp));\n+\n+               begin\n+                  if Is_Record_Type (Comp_Type)\n+                        or else\n+                     Is_Protected_Type (Comp_Type)\n+                  then\n+                     if not Caller_Known_Size_Record (Comp_Type) then\n+                        return False;\n+                     end if;\n+\n+                  elsif Is_Array_Type (Comp_Type) then\n+                     if Size_Depends_On_Discriminant (Comp_Type) then\n+                        return False;\n+                     end if;\n+                  end if;\n+               end;\n+\n+               Next_Component (Comp);\n+            end loop;\n+         end;\n+\n+         return True;\n+      end Caller_Known_Size_Record;\n+\n       -------------------------------\n       -- Ensure_Minimum_Decoration --\n       -------------------------------\n \n       procedure Ensure_Minimum_Decoration (Typ : Entity_Id) is\n+         Comp : Entity_Id;\n       begin\n          --  Do not set Has_Controlled_Component on a class-wide equivalent\n          --  type. See Make_CW_Equivalent_Type.\n@@ -26735,82 +26458,182 @@ package body Sem_Util is\n                        or else Is_Incomplete_Or_Private_Type (Typ))\n            and then not Is_Class_Wide_Equivalent_Type (Typ)\n          then\n+            Comp := First_Component (Typ);\n+            while Present (Comp) loop\n+               if Has_Controlled_Component (Etype (Comp))\n+                 or else\n+                   (Chars (Comp) /= Name_uParent\n+                      and then Is_Controlled (Etype (Comp)))\n+                 or else\n+                   (Is_Protected_Type (Etype (Comp))\n+                      and then\n+                        Present (Corresponding_Record_Type (Etype (Comp)))\n+                      and then\n+                        Has_Controlled_Component\n+                          (Corresponding_Record_Type (Etype (Comp))))\n+               then\n+                  Set_Has_Controlled_Component (Typ);\n+                  exit;\n+               end if;\n+\n+               Next_Component (Comp);\n+            end loop;\n+         end if;\n+      end Ensure_Minimum_Decoration;\n+\n+      ------------------------------\n+      -- Large_Max_Size_Mutable --\n+      ------------------------------\n+\n+      function Large_Max_Size_Mutable (Typ : Entity_Id) return Boolean is\n+         pragma Assert (Typ = Underlying_Type (Typ));\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean;\n+         --  Returns true if the discrete type T has a large range\n+\n+         ----------------------------\n+         -- Is_Large_Discrete_Type --\n+         ----------------------------\n+\n+         function Is_Large_Discrete_Type (T : Entity_Id) return Boolean is\n+            Threshold : constant Int := 16;\n+            --  Arbitrary threshold above which we consider it \"large\". We want\n+            --  a fairly large threshold, because these large types really\n+            --  shouldn't have default discriminants in the first place, in\n+            --  most cases.\n+\n+         begin\n+            return UI_To_Int (RM_Size (T)) > Threshold;\n+         end Is_Large_Discrete_Type;\n+\n+      --  Start of processing for Large_Max_Size_Mutable\n+\n+      begin\n+         if Is_Record_Type (Typ)\n+           and then not Is_Limited_View (Typ)\n+           and then Has_Defaulted_Discriminants (Typ)\n+         then\n+            --  Loop through the components, looking for an array whose upper\n+            --  bound(s) depends on discriminants, where both the subtype of\n+            --  the discriminant and the index subtype are too large.\n+\n             declare\n                Comp : Entity_Id;\n \n             begin\n                Comp := First_Component (Typ);\n                while Present (Comp) loop\n-                  if Has_Controlled_Component (Etype (Comp))\n-                    or else\n-                      (Chars (Comp) /= Name_uParent\n-                         and then Is_Controlled (Etype (Comp)))\n-                    or else\n-                      (Is_Protected_Type (Etype (Comp))\n-                         and then\n-                           Present (Corresponding_Record_Type (Etype (Comp)))\n-                         and then\n-                           Has_Controlled_Component\n-                             (Corresponding_Record_Type (Etype (Comp))))\n-                  then\n-                     Set_Has_Controlled_Component (Typ);\n-                     exit;\n-                  end if;\n+                  declare\n+                     Comp_Type : constant Entity_Id :=\n+                                   Underlying_Type (Etype (Comp));\n+\n+                     Hi   : Node_Id;\n+                     Indx : Node_Id;\n+                     Ityp : Entity_Id;\n+\n+                  begin\n+                     if Is_Array_Type (Comp_Type) then\n+                        Indx := First_Index (Comp_Type);\n+\n+                        while Present (Indx) loop\n+                           Ityp := Etype (Indx);\n+                           Hi := Type_High_Bound (Ityp);\n+\n+                           if Nkind (Hi) = N_Identifier\n+                             and then Ekind (Entity (Hi)) = E_Discriminant\n+                             and then Is_Large_Discrete_Type (Ityp)\n+                             and then Is_Large_Discrete_Type\n+                                        (Etype (Entity (Hi)))\n+                           then\n+                              return True;\n+                           end if;\n+\n+                           Next_Index (Indx);\n+                        end loop;\n+                     end if;\n+                  end;\n \n                   Next_Component (Comp);\n                end loop;\n             end;\n          end if;\n-      end Ensure_Minimum_Decoration;\n+\n+         return False;\n+      end Large_Max_Size_Mutable;\n+\n+      --  Local declarations\n+\n+      Typ : constant Entity_Id := Underlying_Type (Id);\n \n    --  Start of processing for Requires_Transient_Scope\n \n    begin\n-      if Debug_Flag_QQ then\n-         return Old_Result;\n-      end if;\n-\n       Ensure_Minimum_Decoration (Id);\n \n-      declare\n-         New_Result : constant Boolean := New_Requires_Transient_Scope (Id);\n+      --  This is a private type which is not completed yet. This can only\n+      --  happen in a default expression (of a formal parameter or of a\n+      --  record component). Do not expand transient scope in this case.\n \n-      begin\n-         --  Assert that we're not putting things on the secondary stack if we\n-         --  didn't before; we are trying to AVOID secondary stack when\n-         --  possible.\n+      if No (Typ) then\n+         return False;\n \n-         if not Old_Result then\n-            pragma Assert (not New_Result);\n-            null;\n-         end if;\n+      --  Do not expand transient scope for non-existent procedure return or\n+      --  string literal types.\n \n-         if New_Result /= Old_Result then\n-            Results_Differ (Id, Old_Result, New_Result);\n-         end if;\n+      elsif Typ = Standard_Void_Type\n+        or else Ekind (Typ) = E_String_Literal_Subtype\n+      then\n+         return False;\n \n-         return New_Result;\n-      end;\n-   end Requires_Transient_Scope;\n+      --  If Typ is a generic formal incomplete type, then we want to look at\n+      --  the actual type.\n \n-   --------------------\n-   -- Results_Differ --\n-   --------------------\n+      elsif Ekind (Typ) = E_Record_Subtype\n+        and then Present (Cloned_Subtype (Typ))\n+      then\n+         return Requires_Transient_Scope (Cloned_Subtype (Typ));\n \n-   procedure Results_Differ\n-     (Id      : Entity_Id;\n-      Old_Val : Boolean;\n-      New_Val : Boolean)\n-   is\n-   begin\n-      if False then -- False to disable; True for debugging\n-         Treepr.Print_Tree_Node (Id);\n+      --  Functions returning specific tagged types may dispatch on result, so\n+      --  their returned value is allocated on the secondary stack, even in the\n+      --  definite case. We must treat nondispatching functions the same way,\n+      --  because access-to-function types can point at both, so the calling\n+      --  conventions must be compatible. Is_Tagged_Type includes controlled\n+      --  types and class-wide types. Controlled type temporaries need\n+      --  finalization.\n \n-         if Old_Val = New_Val then\n-            raise Program_Error;\n-         end if;\n+      --  ???It's not clear why we need to return noncontrolled types with\n+      --  controlled components on the secondary stack.\n+\n+      elsif Is_Tagged_Type (Typ) or else Has_Controlled_Component (Typ) then\n+         return True;\n+\n+      --  Untagged definite subtypes are known size. This includes all\n+      --  elementary [sub]types. Tasks are known size even if they have\n+      --  discriminants. So we return False here, with one exception:\n+      --  For a type like:\n+      --    type T (Last : Natural := 0) is\n+      --       X : String (1 .. Last);\n+      --    end record;\n+      --  we return True. That's because for \"P(F(...));\", where F returns T,\n+      --  we don't know the size of the result at the call site, so if we\n+      --  allocated it on the primary stack, we would have to allocate the\n+      --  maximum size, which is way too big.\n+\n+      elsif Is_Definite_Subtype (Typ) or else Is_Task_Type (Typ) then\n+         return Large_Max_Size_Mutable (Typ);\n+\n+      --  Indefinite (discriminated) untagged record or protected type\n+\n+      elsif Is_Record_Type (Typ) or else Is_Protected_Type (Typ) then\n+         return not Caller_Known_Size_Record (Typ);\n+\n+      --  Unconstrained array\n+\n+      else\n+         pragma Assert (Is_Array_Type (Typ) and not Is_Definite_Subtype (Typ));\n+         return True;\n       end if;\n-   end Results_Differ;\n+   end Requires_Transient_Scope;\n \n    --------------------------\n    -- Reset_Analyzed_Flags --\n@@ -31238,7 +31061,7 @@ package body Sem_Util is\n             --\n             --  See Large_Max_Size_Mutable function elsewhere in this\n             --  file (currently declared inside of\n-            --  New_Requires_Transient_Scope, so it would have to be\n+            --  Requires_Transient_Scope, so it would have to be\n             --  moved if we want it to be callable from here).\n \n          end Indirect_Temp_Needed;"}]}