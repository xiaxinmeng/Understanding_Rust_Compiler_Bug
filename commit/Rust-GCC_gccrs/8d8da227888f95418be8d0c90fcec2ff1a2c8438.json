{"sha": "8d8da227888f95418be8d0c90fcec2ff1a2c8438", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4ZGEyMjc4ODhmOTU0MThiZThkMGM5MGZjZWMyZmYxYTJjODQzOA==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2008-01-25T20:49:04Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2008-01-25T20:49:04Z"}, "message": "MAINTAINERS (c4x port): Remove.\n\n\t* MAINTAINERS (c4x port): Remove.\n\ncontrib:\n\t* paranoia.cc (main): Remove handling of c4x_single and\n\tc4x_extended formats.\n\ngcc:\n\t* config/c4x: Remove directory.\n\t* config.gcc (crx-*, mt-*): Mark obsolete.\n\t(c4x-*, tic4x-*, c4x-*-rtems*, tic4x-*-rtems*, c4x-*, tic4x-*,\n\th8300-*-rtemscoff*, ns32k-*-netbsdelf*, ns32k-*-netbsd*,\n\tsh-*-rtemscoff*): Remove cases.\n\t* defaults.h (C4X_FLOAT_FORMAT): Remove.\n\t* real.c (encode_c4x_single, decode_c4x_single,\n\tencode_c4x_extended, decode_c4x_extended, c4x_single_format,\n\tc4x_extended_format): Remove.\n\t* real.h (c4x_single_format, c4x_extended_format): Remove.\n\t* doc/extend.texi (interrupt, naked): Remove mention of attributes\n\ton C4x.\n\t(Pragmas): Remove comment about c4x pragmas.\n\t* doc/install.texi (c4x): Remove target-specific instructions.\n\t* doc/invoke.texi (TMS320C3x/C4x Options): Remove.\n\t* doc/md.texi (Machine Constraints): Remove C4x documentation.\n\t* doc/tm.texi (MEMBER_TYPE_FORCES_BLK, c_register_pragma): Do not\n\trefer to C4x source files as examples.\n\t(C4X_FLOAT_FORMAT): Remove documentation.\n\ngcc/testsuite:\n\t* gcc.dg/builtin-inf-1.c, gcc.dg/compare6.c, gcc.dg/sibcall-3.c,\n\tgcc.dg/sibcall-4.c, gcc.dg/torture/builtin-attr-1.c: Don't handle\n\tc4x-*-* targets.\n\nlibgcc:\n\t* config.host (tic4x-*-*, c4x-*-rtems*, tic4x-*-rtems*, c4x-*,\n\ttic4x-*, h8300-*-rtemscoff*, ns32k-*-netbsdelf*, ns32k-*-netbsd*,\n\tsh-*-rtemscoff*): Remove cases.\n\nFrom-SVN: r131835", "tree": {"sha": "c661d734edca52044b7e928322867308ff62a8d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c661d734edca52044b7e928322867308ff62a8d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d8da227888f95418be8d0c90fcec2ff1a2c8438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8da227888f95418be8d0c90fcec2ff1a2c8438", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8da227888f95418be8d0c90fcec2ff1a2c8438", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8da227888f95418be8d0c90fcec2ff1a2c8438/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d555e263297673f544484d6f9dd82ee50958bd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d555e263297673f544484d6f9dd82ee50958bd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d555e263297673f544484d6f9dd82ee50958bd7"}], "stats": {"total": 16839, "additions": 68, "deletions": 16771}, "files": [{"sha": "3b8b8420d73d6d27bc79c2b720ff8d72a6d99c09", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,3 +1,7 @@\n+2008-01-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* MAINTAINERS (c4x port): Remove.\n+\n 2008-01-24  David Edelsohn  <edelsohn@gnu.org>\n \n \t* libtool.m4: Backport AIX 6 support from ToT Libtool."}, {"sha": "0e216ee14466d9c91463a3ca13e5fc10a3c83911", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -42,7 +42,6 @@ arm port\t\tPaul Brook\t\tpaul@codesourcery.com\n avr port\t\tDenis Chertykov\t\tdenisc@overta.ru\n avr port\t\tAnatoly Sokolov\t\taesok@post.ru\n bfin port\t\tBernd Schmidt\t\tbernd.schmidt@analog.com\n-c4x port\t\tMichael Hayes\t\tm.hayes@elec.canterbury.ac.nz\n cris port\t\tHans-Peter Nilsson\thp@axis.com\n crx port\t\tPaul Woegerer\t\tpaul.woegerer@nsc.com\n fr30 port\t\tNick Clifton\t\tnickc@redhat.com"}, {"sha": "1449506e50942b79b09584f9ba592706d41ef507", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,3 +1,8 @@\n+2008-01-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* paranoia.cc (main): Remove handling of c4x_single and\n+\tc4x_extended formats.\n+\n 2007-12-26  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* compareSumTests3: Changed to GPLv3."}, {"sha": "ce21d3520caeddce2f6155a360677beda52c5a28", "filename": "contrib/paranoia.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/contrib%2Fparanoia.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/contrib%2Fparanoia.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fparanoia.cc?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -2643,8 +2643,6 @@ int main(int ac, char **av)\n \t    F(vax_g),\n \t    F(i370_single),\n \t    F(i370_double),\n-\t    F(c4x_single),\n-\t    F(c4x_extended),\n \t    F(real_internal),\n #undef F\n \t  };"}, {"sha": "516d6855784d80173a5a0534708244728aae3425", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,3 +1,25 @@\n+2008-01-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/c4x: Remove directory.\n+\t* config.gcc (crx-*, mt-*): Mark obsolete.\n+\t(c4x-*, tic4x-*, c4x-*-rtems*, tic4x-*-rtems*, c4x-*, tic4x-*,\n+\th8300-*-rtemscoff*, ns32k-*-netbsdelf*, ns32k-*-netbsd*,\n+\tsh-*-rtemscoff*): Remove cases.\n+\t* defaults.h (C4X_FLOAT_FORMAT): Remove.\n+\t* real.c (encode_c4x_single, decode_c4x_single,\n+\tencode_c4x_extended, decode_c4x_extended, c4x_single_format,\n+\tc4x_extended_format): Remove.\n+\t* real.h (c4x_single_format, c4x_extended_format): Remove.\n+\t* doc/extend.texi (interrupt, naked): Remove mention of attributes\n+\ton C4x.\n+\t(Pragmas): Remove comment about c4x pragmas.\n+\t* doc/install.texi (c4x): Remove target-specific instructions.\n+\t* doc/invoke.texi (TMS320C3x/C4x Options): Remove.\n+\t* doc/md.texi (Machine Constraints): Remove C4x documentation.\n+\t* doc/tm.texi (MEMBER_TYPE_FORCES_BLK, c_register_pragma): Do not\n+\trefer to C4x source files as examples.\n+\t(C4X_FLOAT_FORMAT): Remove documentation.\n+\n 2008-01-25  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (override_options): Reorder tests so that"}, {"sha": "555e2eb1d2f9d6cf1ef71c2269e69915c225ebdc", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 36, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,6 +1,6 @@\n # GCC target-specific configuration file.\n-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n-# Free Software Foundation, Inc.\n+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+# 2008 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -195,8 +195,8 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n-   c4x-*\t\t\\\n- | tic4x-*\t\t\\\n+   crx-*\t\t\\\n+ | mt-*\t\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration ${target} is obsolete.\" >&2\n@@ -351,9 +351,6 @@ sh[123456789lbe]*-*-*)\n \tcpu_type=sh\n \tneed_64bit_hwint=yes\n \t;;\n-tic4x-*-*)\n-        cpu_type=c4x\n-        ;;\n esac\n \n tm_file=${cpu_type}/${cpu_type}.h\n@@ -830,17 +827,6 @@ bfin*-*)\n \ttmake_file=bfin/t-bfin\n \tuse_collect2=no\n \t;;\n-c4x-*-rtems* | tic4x-*-rtems*)\n-\ttmake_file=\"c4x/t-c4x t-rtems c4x/t-rtems\"\n-\ttm_file=\"c4x/c4x.h c4x/rtems.h rtems.h\"\n-\tc_target_objs=\"c4x-c.o\"\n-\tcxx_target_objs=\"c4x-c.o\"\n-\t;;\n-c4x-* | tic4x-*)\n-\ttmake_file=c4x/t-c4x\n-\tc_target_objs=\"c4x-c.o\"\n-\tcxx_target_objs=\"c4x-c.o\"\n-\t;;\n cris-*-aout)\n \ttm_file=\"dbxelf.h ${tm_file} cris/aout.h\"\n \tgas=yes\n@@ -895,10 +881,6 @@ frv-*-*linux*)\n \t         linux.h frv/linux.h frv/frv-abi.h\"\n \ttmake_file=\"${tmake_file} frv/t-frv frv/t-linux\"\n \t;;\n-h8300-*-rtemscoff*)\n-\ttmake_file=\"h8300/t-h8300 t-rtems h8300/t-rtems\"\n-\ttm_file=\"h8300/h8300.h dbxcoff.h h8300/coff.h h8300/rtems.h rtems.h\"\n-\t;;\n h8300-*-rtems*)\n \ttmake_file=\"h8300/t-h8300 h8300/t-elf t-rtems h8300/t-rtems\"\n \ttm_file=\"h8300/h8300.h dbxelf.h elfos.h h8300/elf.h h8300/rtems.h rtems.h\"\n@@ -1828,16 +1810,6 @@ mt-*-elf)\n         tm_file=\"dbxelf.h elfos.h svr4.h ${tm_file}\"\n         tmake_file=\"${tmake_file} mt/t-mt\"\n         ;;\n-ns32k-*-netbsdelf*)\n-\techo \"GCC does not yet support the ${target} target\"; exit 1\n-\t;;\n-ns32k-*-netbsd*)\n-\ttm_file=\"${tm_file} netbsd.h netbsd-aout.h ns32k/netbsd.h\"\n-\t# On NetBSD, the headers are already okay, except for math.h.\n-\ttmake_file=\"t-netbsd ns32k/t-ns32k\"\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n pdp11-*-bsd)\n \ttm_file=\"${tm_file} pdp11/2bsd.h\"\n \tuse_fixproto=yes\n@@ -2304,10 +2276,6 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \tfi\n \tuse_fixproto=yes\n \t;;\n-sh-*-rtemscoff*)\n-\ttmake_file=\"sh/t-sh t-rtems sh/t-rtems\"\n-\ttm_file=\"${tm_file} dbxcoff.h sh/coff.h sh/rtems.h rtems.h\"\n-\t;;\n sh-*-rtems*)\n \ttmake_file=\"sh/t-sh sh/t-elf t-rtems sh/t-rtems\"\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sh/elf.h sh/embed-elf.h sh/rtemself.h rtems.h\""}, {"sha": "3e132b5d9fd1540cb78a479f82687212c0ae2050", "filename": "gcc/config/c4x/c4x-c.c", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-c.c?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,151 +0,0 @@\n-/* Subroutines for the C front end on the TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2007 Free Software Foundation, Inc.\n-\n-   Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n-              and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"toplev.h\"\n-#include \"cpplib.h\"\n-#include \"c-pragma.h\"\n-#include \"tm_p.h\"\n-\n-static int c4x_parse_pragma (const char *, tree *, tree *);\n-\n-/* Handle machine specific pragmas for compatibility with existing\n-   compilers for the C3x/C4x.\n-\n-   pragma\t\t\t\t   attribute\n-   ----------------------------------------------------------\n-   CODE_SECTION(symbol,\"section\")          section(\"section\")\n-   DATA_SECTION(symbol,\"section\")          section(\"section\")\n-   FUNC_CANNOT_INLINE(function)            \n-   FUNC_EXT_CALLED(function)               \n-   FUNC_IS_PURE(function)                  const\n-   FUNC_IS_SYSTEM(function)                \n-   FUNC_NEVER_RETURNS(function)            noreturn\n-   FUNC_NO_GLOBAL_ASG(function)            \n-   FUNC_NO_IND_ASG(function)               \n-   INTERRUPT(function)                     interrupt\n-\n-   */\n-\n-/* Parse a C4x pragma, of the form ( function [, \"section\"] ) \\n.\n-   FUNC is loaded with the IDENTIFIER_NODE of the function, SECT with\n-   the STRING_CST node of the string.  If SECT is null, then this\n-   pragma doesn't take a section string.  Returns 0 for a good pragma,\n-   -1 for a malformed pragma.  */\n-#define BAD(gmsgid, arg) \\\n-  do { warning (OPT_Wpragmas, gmsgid, arg); return -1; } while (0)\n-\n-static int\n-c4x_parse_pragma (const char *name, tree *func, tree *sect)\n-{\n-  tree f, s, x;\n-\n-  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n-    BAD (\"missing '(' after '#pragma %s' - ignored\", name);\n-\n-  if (pragma_lex (&f) != CPP_NAME)\n-    BAD (\"missing function name in '#pragma %s' - ignored\", name);\n-\n-  if (sect)\n-    {\n-      if (pragma_lex (&x) != CPP_COMMA)\n-\tBAD (\"malformed '#pragma %s' - ignored\", name);\n-      if (pragma_lex (&s) != CPP_STRING)\n-\tBAD (\"missing section name in '#pragma %s' - ignored\", name);\n-      *sect = s;\n-    }\n-\n-  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n-    BAD (\"missing ')' for '#pragma %s' - ignored\", name);\n-\n-  if (pragma_lex (&x) != CPP_EOF)\n-    warning (OPT_Wpragmas, \"junk at end of '#pragma %s'\", name);\n-\n-  *func = f;\n-  return 0;\n-}\n-\n-void\n-c4x_pr_CODE_SECTION (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  tree func, sect;\n-\n-  if (c4x_parse_pragma (\"CODE_SECTION\", &func, &sect))\n-    return;\n-  code_tree = chainon (code_tree,\n-\t\t       build_tree_list (func,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, sect)));\n-}\n-\n-void\n-c4x_pr_DATA_SECTION (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  tree func, sect;\n-\n-  if (c4x_parse_pragma (\"DATA_SECTION\", &func, &sect))\n-    return;\n-  data_tree = chainon (data_tree,\n-\t\t       build_tree_list (func,\n-\t\t\t\t\tbuild_tree_list (NULL_TREE, sect)));\n-}\n-\n-void\n-c4x_pr_FUNC_IS_PURE (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  tree func;\n-\n-  if (c4x_parse_pragma (\"FUNC_IS_PURE\", &func, 0))\n-    return;\n-  pure_tree = chainon (pure_tree, build_tree_list (func, NULL_TREE));\n-}\n-\n-void\n-c4x_pr_FUNC_NEVER_RETURNS (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  tree func;\n-\n-  if (c4x_parse_pragma (\"FUNC_NEVER_RETURNS\", &func, 0))\n-    return;\n-  noreturn_tree = chainon (noreturn_tree, build_tree_list (func, NULL_TREE));\n-}\n-\n-void\n-c4x_pr_INTERRUPT (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-  tree func;\n-\n-  if (c4x_parse_pragma (\"INTERRUPT\", &func, 0))\n-    return;\n-  interrupt_tree = chainon (interrupt_tree, build_tree_list (func, NULL_TREE));\n-}\n-\n-/* Used for FUNC_CANNOT_INLINE, FUNC_EXT_CALLED, FUNC_IS_SYSTEM,\n-   FUNC_NO_GLOBAL_ASG, and FUNC_NO_IND_ASG.  */\n-void\n-c4x_pr_ignored (cpp_reader *pfile ATTRIBUTE_UNUSED)\n-{\n-}"}, {"sha": "57bfd1267ff68f7949efd22a87babcb1278b3889", "filename": "gcc/config/c4x/c4x-modes.def", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-modes.def?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,108 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 2002, 2004, 2007 Free Software Foundation, Inc.\n-\n-   Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n-              and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* C4x wants 1- and 2-word float modes, in its own peculiar format.\n-   FIXME: Give this port a way to get rid of SFmode, DFmode, and all\n-   the other modes it doesn't use.  */\n-FLOAT_MODE (QF, 1, c4x_single_format);\n-FLOAT_MODE (HF, 2, c4x_extended_format);\n-RESET_FLOAT_FORMAT (SF, 0);  /* not used */\n-RESET_FLOAT_FORMAT (DF, 0);  /* not used */\n-\n-/* Add any extra modes needed to represent the condition code.\n-\n-   On the C4x, we have a \"no-overflow\" mode which is used when an ADD,\n-   SUB, NEG, or MPY insn is used to set the condition code.  This is\n-   to prevent the combiner from optimizing away a following CMP of the\n-   result with zero when a signed conditional branch or load insn\n-   follows.\n-\n-   The problem is a subtle one and deals with the manner in which the\n-   negative condition (N) flag is used on the C4x.  This flag does not\n-   reflect the status of the actual result but of the ideal result had\n-   no overflow occurred (when considering signed operands).\n-\n-   For example, 0x7fffffff + 1 => 0x80000000 Z=0 V=1 N=0 C=0.  Here\n-   the flags reflect the untruncated result, not the actual result.\n-   While the actual result is less than zero, the N flag is not set\n-   since the ideal result of the addition without truncation would\n-   have been positive.\n-   \n-   Note that the while the N flag is handled differently to most other\n-   architectures, the use of it is self consistent and is not the\n-   cause of the problem.\n-\n-   Logical operations set the N flag to the MSB of the result so if\n-   the result is negative, N is 1.  However, integer and floating\n-   point operations set the N flag to be the MSB of the result\n-   exclusive ored with the overflow (V) flag.  Thus if an overflow\n-   occurs and the result does not have the MSB set (i.e., the result\n-   looks like a positive number), the N flag is set.  Conversely, if\n-   an overflow occurs and the MSB of the result is set, N is set to 0.\n-   Thus the N flag represents the sign of the result if it could have\n-   been stored without overflow but does not represent the apparent\n-   sign of the result.  Note that most architectures set the N flag to\n-   be the MSB of the result.\n-\n-   The C4x approach to setting the N flag simplifies signed\n-   conditional branches and loads which only have to test the state of\n-   the N flag, whereas most architectures have to look at both the N\n-   and V flags.  The disadvantage is that there is no flag giving the\n-   status of the sign bit of the operation.  However, there are no\n-   conditional load or branch instructions that make use of this\n-   feature (e.g., BMI---branch minus) instruction.  Note that BN and\n-   BLT are identical in the C4x.\n-   \n-   To handle the problem where the N flag is set differently whenever\n-   there is an overflow we use a different CC mode, CC_NOOVmode which\n-   says that the CC reflects the comparison of the result against zero\n-   if no overflow occurred.\n-\n-   For example, \n-\n-   [(set (reg:CC_NOOV 21)\n-         (compare:CC_NOOV (minus:QI (match_operand:QI 1 \"src_operand\" \"\")\n-                                    (match_operand:QI 2 \"src_operand\" \"\"))\n-                          (const_int 0)))\n-    (set (match_operand:QI 0 \"ext_reg_operand\" \"\")\n-         (minus:QI (match_dup 1)\n-                   (match_dup 2)))]\n-\n-   Note that there is no problem for insns that don't return a result\n-   like CMP, since the CC reflects the effect of operation.\n-\n-   An example of a potential problem is when GCC\n-   converts   (LTU (MINUS (0x80000000) (0x7fffffff) (0x80000000)))\n-   to         (LEU (MINUS (0x80000000) (0x7fffffff) (0x7fffffff)))\n-   to         (GE  (MINUS (0x80000000) (0x7fffffff) (0x00000000)))\n-\n-   Now (MINUS (0x80000000) (0x7fffffff)) returns 0x00000001 but the\n-   C4x sets the N flag since the result without overflow would have\n-   been 0xffffffff when treating the operands as signed integers.\n-   Thus (GE (MINUS (0x80000000) (0x7fffffff) (0x00000000))) sets the N\n-   flag but (GE (0x00000001)) does not set the N flag.\n-\n-   The upshot is that we cannot use signed branch and conditional\n-   load instructions after an add, subtract, neg, abs or multiply.\n-   We must emit a compare insn to check the result against 0.  */\n-\n-CC_MODE (CC_NOOV);"}, {"sha": "78542f9a43374a845db77445dad9e065eefd8acf", "filename": "gcc/config/c4x/c4x-protos.h", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x-protos.h?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,246 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2003, 2004, 2005,\n-   2007 Free Software Foundation, Inc.\n-\n-   Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n-              and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_C4X_PROTOS_H\n-#define GCC_C4X_PROTOS_H\n-\n-extern void c4x_override_options (void);\n-\n-extern void c4x_optimization_options (int, int);\n-\n-extern void c4x_output_ascii (FILE *, const char *, int);\n-\n-extern int c4x_interrupt_function_p (void);\n-\n-extern void c4x_expand_prologue (void);\n-\n-extern void c4x_expand_epilogue (void);\n-\n-extern int c4x_null_epilogue_p (void);\n-\n-extern void c4x_global_label (const char *);\n-\n-extern void c4x_external_ref (const char *);\n-\n-#ifdef TREE_CODE\n-extern void c4x_function_arg_advance (CUMULATIVE_ARGS *, \n-\t\t\t\t      enum machine_mode, tree, int);\n-\n-extern struct rtx_def *c4x_function_arg (CUMULATIVE_ARGS *,\n-\t\t\t\t\t enum machine_mode, tree, int);\n-\n-#endif /* TREE_CODE */\n-\n-\n-#if defined(RTX_CODE) && defined(TREE_CODE)\n-extern void c4x_init_cumulative_args (CUMULATIVE_ARGS *c, tree, rtx);\n-\n-extern rtx c4x_expand_builtin (tree, rtx, rtx, enum machine_mode, int);\n-\n-extern void c4x_init_builtins (void);\n-\n-#endif /* TREE_CODE and RTX_CODE*/\n-\n-\n-#ifdef RTX_CODE\n-extern struct rtx_def *c4x_gen_compare_reg (enum rtx_code, rtx, rtx);\n-\n-extern int c4x_legitimate_address_p (enum machine_mode, rtx, int);\n-\n-extern int c4x_hard_regno_mode_ok (unsigned int, enum machine_mode);\n-\n-extern int c4x_hard_regno_rename_ok (unsigned int, unsigned int);\n-\n-extern struct rtx_def *c4x_legitimize_address (rtx, enum machine_mode);\n-\n-extern void c4x_print_operand (FILE *, rtx, int);\n-\n-extern void c4x_print_operand_address (FILE *, rtx);\n-\n-extern enum reg_class c4x_preferred_reload_class (rtx, enum reg_class);\n-\n-extern struct rtx_def *c4x_operand_subword (rtx, int, int, enum machine_mode);\n-\n-extern char *c4x_output_cbranch (const char *, rtx);\n-\n-extern int c4x_label_conflict (rtx, rtx, rtx);\n-\n-extern int c4x_address_conflict (rtx, rtx, int, int);\n-\n-extern void c4x_rptb_insert (rtx insn);\n-\n-extern int c4x_rptb_nop_p (rtx);\n-\n-extern int c4x_rptb_rpts_p (rtx, rtx);\n-\n-extern int c4x_check_laj_p (rtx);\n-\n-extern int c4x_autoinc_operand (rtx, enum machine_mode);\n-\n-extern int reg_or_const_operand (rtx, enum machine_mode);\n-\n-extern int mixed_subreg_operand (rtx, enum machine_mode);\n-\n-extern int reg_imm_operand (rtx, enum machine_mode);\n-\n-extern int ar0_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar0_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar1_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar1_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar2_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar2_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar3_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar3_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar4_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar4_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar5_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar5_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar6_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar6_mem_operand (rtx, enum machine_mode);\n-\n-extern int ar7_reg_operand (rtx, enum machine_mode);\n-\n-extern int ar7_mem_operand (rtx, enum machine_mode);\n-\n-extern int ir0_reg_operand (rtx, enum machine_mode);\n-\n-extern int ir0_mem_operand (rtx, enum machine_mode);\n-\n-extern int ir1_reg_operand (rtx, enum machine_mode);\n-\n-extern int ir1_mem_operand (rtx, enum machine_mode);\n-\n-extern int group1_reg_operand (rtx, enum machine_mode);\n-\n-extern int group1_mem_operand (rtx, enum machine_mode);\n-\n-extern int arx_reg_operand (rtx, enum machine_mode);\n-\n-extern int not_rc_reg (rtx, enum machine_mode);\n-\n-extern int not_modify_reg (rtx, enum machine_mode);\n-\n-extern int c4x_shiftable_constant (rtx);\n-\n-extern int c4x_immed_float_p (rtx);\n-\n-extern int c4x_a_register (rtx);\n-\n-extern int c4x_x_register (rtx);\n-\n-extern int c4x_H_constant (rtx);\n-\n-extern int c4x_I_constant (rtx);\n-\n-extern int c4x_J_constant (rtx);\n-\n-extern int c4x_K_constant (rtx);\n-\n-extern int c4x_L_constant (rtx);\n-\n-extern int c4x_N_constant (rtx);\n-\n-extern int c4x_O_constant (rtx);\n-\n-extern int c4x_Q_constraint (rtx);\n-\n-extern int c4x_R_constraint (rtx);\n-\n-extern int c4x_S_indirect (rtx);\n-\n-extern int c4x_S_constraint (rtx);\n-\n-extern int c4x_T_constraint (rtx);\n-\n-extern int c4x_U_constraint (rtx);\n-\n-extern void c4x_emit_libcall (rtx, enum rtx_code, enum machine_mode,\n-\t\t\t      enum machine_mode, int, rtx *);\n-\n-extern void c4x_emit_libcall3 (rtx, enum rtx_code, enum machine_mode, rtx *);\n-\n-extern void c4x_emit_libcall_mulhi (rtx, enum rtx_code,\n-\t\t\t\t    enum machine_mode, rtx *);\n-\n-extern int c4x_emit_move_sequence (rtx *, enum machine_mode);\n-\n-extern int legitimize_operands (enum rtx_code, rtx *, enum machine_mode);\n-\n-extern int valid_operands (enum rtx_code, rtx *, enum machine_mode);\n-\n-extern int valid_parallel_load_store (rtx *, enum machine_mode);\n-\n-extern int valid_parallel_operands_4 (rtx *, enum machine_mode);\n-\n-extern int valid_parallel_operands_5 (rtx *, enum machine_mode);\n-\n-extern int valid_parallel_operands_6 (rtx *, enum machine_mode);\n-\n-extern GTY(()) rtx smulhi3_libfunc;\n-extern GTY(()) rtx umulhi3_libfunc;\n-extern GTY(()) rtx fix_truncqfhi2_libfunc;\n-extern GTY(()) rtx fixuns_truncqfhi2_libfunc;\n-extern GTY(()) rtx fix_trunchfhi2_libfunc;\n-extern GTY(()) rtx fixuns_trunchfhi2_libfunc;\n-extern GTY(()) rtx floathiqf2_libfunc;\n-extern GTY(()) rtx floatunshiqf2_libfunc;\n-extern GTY(()) rtx floathihf2_libfunc;\n-extern GTY(()) rtx floatunshihf2_libfunc;\n-\n-extern GTY(()) rtx c4x_compare_op0;\t/* Operand 0 for comparisons.  */\n-extern GTY(()) rtx c4x_compare_op1;\t/* Operand 1 for comparisons.  */\n-\n-#endif /* RTX_CODE */\n-\n-/* Smallest class containing REGNO.  */\n-extern enum reg_class c4x_regclass_map[FIRST_PSEUDO_REGISTER];\n-extern enum machine_mode c4x_caller_save_map[FIRST_PSEUDO_REGISTER];\n-\n-extern void c4x_pr_CODE_SECTION (struct cpp_reader *);\n-extern void c4x_pr_DATA_SECTION (struct cpp_reader *);\n-extern void c4x_pr_FUNC_IS_PURE (struct cpp_reader *);\n-extern void c4x_pr_FUNC_NEVER_RETURNS (struct cpp_reader *);\n-extern void c4x_pr_INTERRUPT (struct cpp_reader *);\n-extern void c4x_pr_ignored (struct cpp_reader *);\n-extern void c4x_init_pragma (int (*) (tree *));\n-\n-extern GTY(()) tree code_tree;\n-extern GTY(()) tree data_tree;\n-extern GTY(()) tree pure_tree;\n-extern GTY(()) tree noreturn_tree;\n-extern GTY(()) tree interrupt_tree;\n-\n-#endif /* ! GCC_C4X_PROTOS_H */"}, {"sha": "3cef36b4b399c0ef71e0493fd703ae6c66ea5dff", "filename": "gcc/config/c4x/c4x.c", "status": "removed", "additions": 0, "deletions": 4618, "changes": 4618, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=1d555e263297673f544484d6f9dd82ee50958bd7"}, {"sha": "09a7672b15a8ae28da40848f429da7d65cd29f1b", "filename": "gcc/config/c4x/c4x.h", "status": "removed", "additions": 0, "deletions": 1649, "changes": 1649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,1649 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  TMS320C[34]x\n-   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n-\n-   Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n-              and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* RUN-TIME TARGET SPECIFICATION.  */\n-\n-#define C4x   1\n-\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      extern int flag_inline_trees;\t\t\\\n-      if (!TARGET_SMALL)\t\t\t\\\n-\tbuiltin_define (\"_BIGMODEL\");\t\t\\\n-      if (!TARGET_MEMPARM)\t\t\t\\\n-\tbuiltin_define (\"_REGPARM\");\t\t\\\n-      if (flag_inline_functions)\t\t\\\n-\tbuiltin_define (\"_INLINE\");\t\t\\\n-      if (TARGET_C3X)\t\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  builtin_define (\"_TMS320C3x\");\t\\\n-\t  builtin_define (\"_C3x\");\t\t\\\n-\t  if (TARGET_C30)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C30\");\t\\\n-\t      builtin_define (\"_C30\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t  else if (TARGET_C31)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C31\");\t\\\n-\t      builtin_define (\"_C31\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t  else if (TARGET_C32)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C32\");\t\\\n-\t      builtin_define (\"_C32\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t  else if (TARGET_C33)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C33\");\t\\\n-\t      builtin_define (\"_C33\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-      else\t\t\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  builtin_define (\"_TMS320C4x\");\t\\\n-\t  builtin_define (\"_C4x\");\t\t\\\n-\t  if (TARGET_C40)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C40\");\t\\\n-\t      builtin_define (\"_C40\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t  else if (TARGET_C44)\t\t\t\\\n-\t    {\t\t\t\t\t\\\n-\t      builtin_define (\"_TMS320C44\");\t\\\n-\t      builtin_define (\"_C44\");\t\t\\\n-\t    }\t\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Define assembler options.  */\n-\n-#define ASM_SPEC \"\\\n-%{!mcpu=30:%{!mcpu=31:%{!mcpu=32:%{!mcpu=33:%{!mcpu=40:%{!mcpu=44:\\\n-%{!m30:%{!m31:%{!m32:%{!m33:%{!m40:%{!m44:-m40}}}}}}}}}}}} \\\n-%{mcpu=30} \\\n-%{mcpu=31} \\\n-%{mcpu=32} \\\n-%{mcpu=33} \\\n-%{mcpu=40} \\\n-%{mcpu=44} \\\n-%{m30} \\\n-%{m31} \\\n-%{m32} \\\n-%{m33} \\\n-%{m40} \\\n-%{m44} \\\n-%{mmemparm} %{mregparm} %{!mmemparm:%{!mregparm:-mregparm}} \\\n-%{mbig} %{msmall} %{!msmall:%{!mbig:-mbig}}\"\n-\n-/* Define linker options.  */\n-\n-#define LINK_SPEC \"\\\n-%{m30:--architecture c3x} \\\n-%{m31:--architecture c3x} \\\n-%{m32:--architecture c3x} \\\n-%{m33:--architecture c3x} \\\n-%{mcpu=30:--architecture c3x} \\\n-%{mcpu=31:--architecture c3x} \\\n-%{mcpu=32:--architecture c3x} \\\n-%{mcpu=33:--architecture c3x}\"\n-\n-/* Specify the end file to link with.  */\n-\n-#define ENDFILE_SPEC \"\"\n-\n-/* Caveats:\n-   Max iteration count for RPTB/RPTS is 2^31 + 1.\n-   Max iteration count for DB is 2^31 + 1 for C40, but 2^23 + 1 for C30.\n-   RPTS blocks interrupts.  */\n-\n-\n-extern int c4x_cpu_version;\t\t/* Cpu version C30/31/32/33/40/44.  */\n-\n-#define TARGET_INLINE\t\t(! optimize_size) /* Inline MPYI.  */\n-#define TARGET_SMALL_REG_CLASS\t0\n-\n-#define TARGET_C3X\t\t(c4x_cpu_version >= 30 \\\n-\t\t\t\t && c4x_cpu_version <= 39)\n-\n-#define TARGET_C30\t\t(c4x_cpu_version == 30)\n-#define TARGET_C31\t\t(c4x_cpu_version == 31)\n-#define TARGET_C32\t\t(c4x_cpu_version == 32)\n-#define TARGET_C33\t\t(c4x_cpu_version == 33)\n-#define TARGET_C40\t\t(c4x_cpu_version == 40)\n-#define TARGET_C44\t\t(c4x_cpu_version == 44)\n-\n-/* Nonzero to use load_immed_addr pattern rather than forcing memory\n-   addresses into memory.  */\n-#define TARGET_LOAD_ADDRESS\t(1 || (! TARGET_C3X && ! TARGET_SMALL))\n-\n-/* Nonzero to convert direct memory references into HIGH/LO_SUM pairs\n-   during RTL generation.  */\n-#define TARGET_EXPOSE_LDP\t0\n-\n-/* Nonzero to force loading of direct memory references into a register.  */\n-#define TARGET_LOAD_DIRECT_MEMS\t0\n-\n-/* -mrpts            allows the use of the RPTS instruction irregardless.\n-   -mrpts=max-cycles will use RPTS if the number of cycles is constant\n-   and less than max-cycles.  */\n-\n-#define TARGET_RPTS_CYCLES(CYCLES) (TARGET_RPTS || (CYCLES) < c4x_rpts_cycles)\n-\n-/* Sometimes certain combinations of command options do not make sense\n-   on a particular target machine.  You can define a macro\n-   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n-   defined, is executed once just after all the command options have\n-   been parsed.  */\n-\n-#define OVERRIDE_OPTIONS c4x_override_options ()\n-\n-/* Define this to change the optimizations performed by default.  */\n-\n-#define OPTIMIZATION_OPTIONS(LEVEL,SIZE) c4x_optimization_options(LEVEL, SIZE)\n-\n-/* Run Time Target Specification.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (TMS320C[34]x, TI syntax)\");\n-\n-/* Storage Layout.  */\n-\n-#define BITS_BIG_ENDIAN\t\t0\n-#define BYTES_BIG_ENDIAN\t0\n-#define WORDS_BIG_ENDIAN\t0\n-\n-/* Technically, we are little endian, but we put the floats out as\n-   whole longs and this makes GCC put them out in the right order.  */\n-\n-#define FLOAT_WORDS_BIG_ENDIAN\t1\n-\n-/* Note the ANSI C standard requires sizeof(char) = 1.  On the C[34]x\n-   all integral and floating point data types are stored in memory as\n-   32-bits (floating point types can be stored as 40-bits in the\n-   extended precision registers), so sizeof(char) = sizeof(short) =\n-   sizeof(int) = sizeof(long) = sizeof(float) = sizeof(double) = 1.  */\n-\n-#define BITS_PER_UNIT\t\t32\n-#define UNITS_PER_WORD\t\t1\n-#define PARM_BOUNDARY\t        32\n-#define STACK_BOUNDARY\t\t32\n-#define FUNCTION_BOUNDARY\t32\n-#define BIGGEST_ALIGNMENT\t32\n-#define EMPTY_FIELD_BOUNDARY\t32\n-#define STRICT_ALIGNMENT\t0\n-#define TARGET_FLOAT_FORMAT\tC4X_FLOAT_FORMAT\n-#define MAX_FIXED_MODE_SIZE\t64 /* HImode.  */\n-\n-/* If a structure has a floating point field then force structure\n-   to have BLKMODE, unless it is the only field.  */\n-#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) \\\n-  (TREE_CODE (TREE_TYPE (FIELD)) == REAL_TYPE && (MODE) == VOIDmode)\n-\n-/* Number of bits in the high and low parts of a two stage\n-   load of an immediate constant.  */\n-#define BITS_PER_HIGH 16\n-#define BITS_PER_LO_SUM 16\n-\n-/* Define register numbers.  */\n-\n-/* Extended-precision registers.  */\n-\n-#define R0_REGNO   0\n-#define R1_REGNO   1\n-#define R2_REGNO   2\n-#define R3_REGNO   3\n-#define R4_REGNO   4\n-#define R5_REGNO   5\n-#define R6_REGNO   6\n-#define R7_REGNO   7\n-\n-/* Auxiliary (address) registers.  */\n-\n-#define AR0_REGNO  8\n-#define AR1_REGNO  9\n-#define AR2_REGNO 10\n-#define AR3_REGNO 11\n-#define AR4_REGNO 12\n-#define AR5_REGNO 13\n-#define AR6_REGNO 14\n-#define AR7_REGNO 15\n-\n-/* Data page register.  */\n-\n-#define DP_REGNO  16\n-\n-/* Index registers.  */\n-\n-#define IR0_REGNO 17\n-#define IR1_REGNO 18\n-\n-/* Block size register.  */\n-\n-#define BK_REGNO  19\n-\n-/* Stack pointer.  */\n-\n-#define SP_REGNO  20\n-\n-/* Status register.  */\n-\n-#define ST_REGNO  21\n-\n-/* Misc. interrupt registers.  */\n-\n-#define DIE_REGNO 22\t\t/* C4x only.  */\n-#define IE_REGNO  22\t\t/* C3x only.  */\n-#define IIE_REGNO 23\t\t/* C4x only.  */\n-#define IF_REGNO  23\t\t/* C3x only.  */\n-#define IIF_REGNO 24\t\t/* C4x only.  */\n-#define IOF_REGNO 24\t\t/* C3x only.  */\n-\n-/* Repeat block registers.  */\n-\n-#define RS_REGNO  25\n-#define RE_REGNO  26\n-#define RC_REGNO  27\n-\n-/* Additional extended-precision registers.  */\n-\n-#define R8_REGNO  28\t\t/* C4x only.  */\n-#define R9_REGNO  29\t\t/* C4x only.  */\n-#define R10_REGNO 30\t\t/* C4x only.  */\n-#define R11_REGNO 31\t\t/* C4x only.  */\n-\n-#define FIRST_PSEUDO_REGISTER\t32\n-\n-/* Extended precision registers (low set).  */\n-\n-#define IS_R0R1_REGNO(r) \\\n-     ((unsigned int)((r) - R0_REGNO) <= (R1_REGNO - R0_REGNO))\n-#define IS_R2R3_REGNO(r) \\\n-     ((unsigned int)((r) - R2_REGNO) <= (R3_REGNO - R2_REGNO))   \n-#define IS_EXT_LOW_REGNO(r) \\\n-     ((unsigned int)((r) - R0_REGNO) <= (R7_REGNO - R0_REGNO))   \n-\n-/* Extended precision registers (high set).  */\n-\n-#define IS_EXT_HIGH_REGNO(r) \\\n-(! TARGET_C3X \\\n- && ((unsigned int) ((r) - R8_REGNO) <= (R11_REGNO - R8_REGNO)))\n-\n-/* Address registers.  */\n-\n-#define IS_AUX_REGNO(r) \\\n-    ((unsigned int)((r) - AR0_REGNO) <= (AR7_REGNO - AR0_REGNO))   \n-#define IS_ADDR_REGNO(r)   IS_AUX_REGNO(r)\n-#define IS_DP_REGNO(r)     ((r) == DP_REGNO)\n-#define IS_INDEX_REGNO(r)  (((r) == IR0_REGNO) || ((r) == IR1_REGNO))\n-#define IS_SP_REGNO(r)     ((r) == SP_REGNO)\n-#define IS_BK_REGNO(r)     (TARGET_BK && (r) == BK_REGNO)\n-\n-/* Misc registers.  */\n-\n-#define IS_ST_REGNO(r)     ((r) == ST_REGNO)\n-#define IS_RC_REGNO(r)     ((r) == RC_REGNO)\n-#define IS_REPEAT_REGNO(r) (((r) >= RS_REGNO) && ((r) <= RC_REGNO))\n-\n-/* Composite register sets.  */\n-\n-#define IS_ADDR_OR_INDEX_REGNO(r) (IS_ADDR_REGNO(r) || IS_INDEX_REGNO(r))\n-#define IS_EXT_REGNO(r)           (IS_EXT_LOW_REGNO(r) || IS_EXT_HIGH_REGNO(r))\n-#define IS_STD_REGNO(r)           (IS_ADDR_OR_INDEX_REGNO(r) \\\n-\t\t\t\t   || IS_REPEAT_REGNO(r) \\\n-                                   || IS_SP_REGNO(r) \\\n-\t\t       \t\t   || IS_BK_REGNO(r))\n-#define IS_INT_REGNO(r)           (IS_EXT_REGNO(r) || IS_STD_REGNO(r))\n-#define IS_GROUP1_REGNO(r)        (IS_ADDR_OR_INDEX_REGNO(r) || IS_BK_REGNO(r))\n-#define IS_INT_CALL_SAVED_REGNO(r) (((r) == R4_REGNO) || ((r) == R5_REGNO) \\\n-                                    || ((r) == R8_REGNO))\n-#define IS_FLOAT_CALL_SAVED_REGNO(r) (((r) == R6_REGNO) || ((r) == R7_REGNO))\n-\n-#define IS_PSEUDO_REGNO(r)            ((r) >= FIRST_PSEUDO_REGISTER)\n-#define IS_R0R1_OR_PSEUDO_REGNO(r)    (IS_R0R1_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_R2R3_OR_PSEUDO_REGNO(r)    (IS_R2R3_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_EXT_OR_PSEUDO_REGNO(r)     (IS_EXT_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_STD_OR_PSEUDO_REGNO(r)     (IS_STD_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_INT_OR_PSEUDO_REGNO(r)     (IS_INT_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_ADDR_OR_PSEUDO_REGNO(r)    (IS_ADDR_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_INDEX_OR_PSEUDO_REGNO(r)   (IS_INDEX_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_EXT_LOW_OR_PSEUDO_REGNO(r) (IS_EXT_LOW_REGNO(r) \\\n-\t\t\t\t       || IS_PSEUDO_REGNO(r))\n-#define IS_DP_OR_PSEUDO_REGNO(r)      (IS_DP_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_SP_OR_PSEUDO_REGNO(r)      (IS_SP_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_ST_OR_PSEUDO_REGNO(r)      (IS_ST_REGNO(r) || IS_PSEUDO_REGNO(r))\n-#define IS_RC_OR_PSEUDO_REGNO(r)      (IS_RC_REGNO(r) || IS_PSEUDO_REGNO(r))\n-\n-#define IS_PSEUDO_REG(op)          (IS_PSEUDO_REGNO(REGNO(op)))\n-#define IS_ADDR_REG(op)            (IS_ADDR_REGNO(REGNO(op)))\n-#define IS_INDEX_REG(op)           (IS_INDEX_REGNO(REGNO(op)))\n-#define IS_GROUP1_REG(r)           (IS_GROUP1_REGNO(REGNO(op)))\n-#define IS_SP_REG(op)              (IS_SP_REGNO(REGNO(op)))\n-#define IS_STD_REG(op)             (IS_STD_REGNO(REGNO(op)))\n-#define IS_EXT_REG(op)             (IS_EXT_REGNO(REGNO(op)))\n-\n-#define IS_R0R1_OR_PSEUDO_REG(op)  (IS_R0R1_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_R2R3_OR_PSEUDO_REG(op)  (IS_R2R3_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_EXT_OR_PSEUDO_REG(op)   (IS_EXT_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_STD_OR_PSEUDO_REG(op)   (IS_STD_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_EXT_LOW_OR_PSEUDO_REG(op) (IS_EXT_LOW_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_INT_OR_PSEUDO_REG(op)   (IS_INT_OR_PSEUDO_REGNO(REGNO(op)))\n-\n-#define IS_ADDR_OR_PSEUDO_REG(op)  (IS_ADDR_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_INDEX_OR_PSEUDO_REG(op) (IS_INDEX_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_DP_OR_PSEUDO_REG(op)    (IS_DP_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_SP_OR_PSEUDO_REG(op)    (IS_SP_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_ST_OR_PSEUDO_REG(op)    (IS_ST_OR_PSEUDO_REGNO(REGNO(op)))\n-#define IS_RC_OR_PSEUDO_REG(op)    (IS_RC_OR_PSEUDO_REGNO(REGNO(op)))\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.  */\n-\n-#define FIXED_REGISTERS \\\n-{\t\t\t\t\t\t\t\t\t\\\n-/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7.  */\t\\\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\t\\\n-/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11.  */\t\\\n-    1,  0,  0,  0,  1,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0\t\\\n-}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  \n-   \n-   Note that the extended precision registers are only saved in some\n-   modes.  The macro HARD_REGNO_CALL_CLOBBERED specifies which modes\n-   get clobbered for a given regno.  */\n-\n-#define CALL_USED_REGISTERS \\\n-{\t\t\t\t\t\t\t\t\t\\\n-/* R0  R1  R2  R3  R4  R5  R6  R7 AR0 AR1 AR2 AR3 AR4 AR5 AR6 AR7.  */\t\\\n-    1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  0,  0,  0,  0,  0,\t\\\n-/* DP IR0 IR1  BK  SP  ST DIE IIE IIF  RS  RE  RC  R8  R9 R10 R11.  */\t\\\n-    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1\t\\\n-}\n-\n-/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n-\n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    if (! TARGET_BK)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tfixed_regs[BK_REGNO] = 1;\t\t\t\\\n-        call_used_regs[BK_REGNO] = 1;\t\t\t\\\n-        c4x_regclass_map[BK_REGNO] = NO_REGS;\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (TARGET_C3X)\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\t int i;                                          \\\n-\t\t\t\t\t\t\t \\\n-\t reg_names[DIE_REGNO] = \"ie\";  /* Clobber die.  */ \\\n-\t reg_names[IF_REGNO] = \"if\";   /* Clobber iie.  */ \\\n-\t reg_names[IOF_REGNO] = \"iof\"; /* Clobber iif.  */ \\\n-\t \t\t\t\t\t\t\\\n-\t for (i = R8_REGNO; i <= R11_REGNO; i++)\t\\\n-\t {\t\t\t\t\t\t\\\n-\t     fixed_regs[i] = call_used_regs[i] = 1;\t\\\n-\t     c4x_regclass_map[i] = NO_REGS;\t\t\\\n-\t }\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-    if (TARGET_PRESERVE_FLOAT)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\\\n-\tc4x_caller_save_map[R6_REGNO] = HFmode;\t\t\\\n-\tc4x_caller_save_map[R7_REGNO] = HFmode;\t\t\\\n-      }\t\t\t\t\t\t\t\\\n-   }\n-\n-/* Order of Allocation of Registers.  */\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.\n-\n-   First allocate registers that don't need preservation across calls,\n-   except index and address registers.  Then allocate data registers\n-   that require preservation across calls (even though this invokes an\n-   extra overhead of having to save/restore these registers).  Next\n-   allocate the address and index registers, since using these\n-   registers for arithmetic can cause pipeline stalls.  Finally\n-   allocated the fixed registers which won't be allocated anyhow.  */\n-\n-#define REG_ALLOC_ORDER\t\t\t\t\t\\\n-{R0_REGNO, R1_REGNO, R2_REGNO, R3_REGNO, \t\t\\\n- R9_REGNO, R10_REGNO, R11_REGNO,\t\t\t\\\n- RS_REGNO, RE_REGNO, RC_REGNO, BK_REGNO,\t\t\\\n- R4_REGNO, R5_REGNO, R6_REGNO, R7_REGNO, R8_REGNO,\t\\\n- AR0_REGNO, AR1_REGNO, AR2_REGNO, AR3_REGNO,\t\t\\\n- AR4_REGNO, AR5_REGNO, AR6_REGNO, AR7_REGNO,\t\t\\\n- IR0_REGNO, IR1_REGNO,\t\t\t\t\t\\\n- SP_REGNO, DP_REGNO, ST_REGNO, IE_REGNO, IF_REGNO, IOF_REGNO}\n-\n-/* A C expression that is nonzero if hard register number REGNO2 can be\n-   considered for use as a rename register for REGNO1 */\n-\n-#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \\\n-  c4x_hard_regno_rename_ok((REGNO1), (REGNO2))\n-\n-/* Determine which register classes are very likely used by spill registers.\n-   local-alloc.c won't allocate pseudos that have these classes as their\n-   preferred class unless they are \"preferred or nothing\".  */\n-\n-#define CLASS_LIKELY_SPILLED_P(CLASS) ((CLASS) == INDEX_REGS)\n-\n-/* CCmode is wrongly defined in machmode.def.  It should have a size\n-   of UNITS_PER_WORD.  HFmode is 40-bits and thus fits within a single\n-   extended precision register.  Similarly, HCmode fits within two\n-   extended precision registers.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\\\n-(((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : \\\n- ((MODE) == HFmode) ? 1 : \\\n- ((MODE) == HCmode) ? 2 : \\\n- ((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-\n-/* A C expression that is nonzero if the hard register REGNO is preserved\n-   across a call in mode MODE.  This does not have to include the call used\n-   registers.  */\n-\n-#define HARD_REGNO_CALL_PART_CLOBBERED(REGNO, MODE)\t\t              \\\n-     ((IS_FLOAT_CALL_SAVED_REGNO (REGNO) && ! ((MODE) == QFmode))  \t      \\\n-      || (IS_INT_CALL_SAVED_REGNO (REGNO)\t\t\t\t      \\\n-\t  && ! ((MODE) == QImode || (MODE) == HImode || (MODE) == Pmode)))\n-\n-/* Specify the modes required to caller save a given hard regno.  */\n-\n-#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) (c4x_caller_save_map[REGNO])\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) c4x_hard_regno_mode_ok(REGNO, MODE)\n-\n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) 0\n-\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-enum reg_class\n-  {\n-    NO_REGS,\n-    R0R1_REGS,\t\t\t/* 't'.  */\n-    R2R3_REGS,\t\t\t/* 'u'.  */\n-    EXT_LOW_REGS,\t\t/* 'q'.  */\n-    EXT_REGS,\t\t\t/* 'f'.  */\n-    ADDR_REGS,\t\t\t/* 'a'.  */\n-    INDEX_REGS,\t\t\t/* 'x'.  */\n-    BK_REG,\t\t\t/* 'k'.  */\n-    SP_REG,\t\t\t/* 'b'.  */\n-    RC_REG,\t\t\t/* 'v'.  */\n-    COUNTER_REGS,\t\t/*  */\n-    INT_REGS,\t\t\t/* 'c'.  */\n-    GENERAL_REGS,\t\t/* 'r'.  */\n-    DP_REG,\t\t\t/* 'z'.  */\n-    ST_REG,\t\t\t/* 'y'.  */\n-    ALL_REGS,\n-    LIM_REG_CLASSES\n-  };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-#define REG_CLASS_NAMES \\\n-{\t\t\t\\\n-   \"NO_REGS\",\t\t\\\n-   \"R0R1_REGS\",\t\t\\\n-   \"R2R3_REGS\",\t\t\\\n-   \"EXT_LOW_REGS\",\t\\\n-   \"EXT_REGS\",\t\t\\\n-   \"ADDR_REGS\",\t\t\\\n-   \"INDEX_REGS\",\t\\\n-   \"BK_REG\",\t\t\\\n-   \"SP_REG\",\t\t\\\n-   \"RC_REG\",\t\t\\\n-   \"COUNTER_REGS\",\t\\\n-   \"INT_REGS\",\t\t\\\n-   \"GENERAL_REGS\",\t\\\n-   \"DP_REG\",\t\t\\\n-   \"ST_REG\",\t\t\\\n-   \"ALL_REGS\"\t\t\\\n-}\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  RC is not included in GENERAL_REGS\n-   since the register allocator will often choose a general register\n-   in preference to RC for the decrement_and_branch_on_count pattern.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-{\t\t\t\t\t\t\\\n- {0x00000000}, /*     No registers.  */\t\t\\\n- {0x00000003}, /* 't' R0-R1\t.  */\t\t\\\n- {0x0000000c}, /* 'u' R2-R3\t.  */\t\t\\\n- {0x000000ff}, /* 'q' R0-R7\t.  */\t\t\\\n- {0xf00000ff}, /* 'f' R0-R11       */\t\t\\\n- {0x0000ff00}, /* 'a' AR0-AR7.  */\t\t\\\n- {0x00060000}, /* 'x' IR0-IR1.  */\t\t\\\n- {0x00080000}, /* 'k' BK.  */\t\t\t\\\n- {0x00100000}, /* 'b' SP.  */\t\t\t\\\n- {0x08000000}, /* 'v' RC.  */\t\t\t\\\n- {0x0800ff00}, /*     RC,AR0-AR7.  */\t\t\\\n- {0x0e1eff00}, /* 'c' AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC.  */\t\\\n- {0xfe1effff}, /* 'r' R0-R11, AR0-AR7, IR0-IR1, BK, SP, RS, RE, RC.  */\\\n- {0x00010000}, /* 'z' DP.  */\t\t\t\\\n- {0x00200000}, /* 'y' ST.  */\t\t\t\\\n- {0xffffffff}, /*     All registers.  */\t\t\\\n-}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) (c4x_regclass_map[REGNO])\n-\n-/* When SMALL_REGISTER_CLASSES is defined, the lifetime of registers\n-   explicitly used in the rtl is kept as short as possible.\n-\n-   We only need to define SMALL_REGISTER_CLASSES if TARGET_PARALLEL_MPY\n-   is defined since the MPY|ADD insns require the classes R0R1_REGS and\n-   R2R3_REGS which are used by the function return registers (R0,R1) and\n-   the register arguments (R2,R3), respectively.  I'm reluctant to define\n-   this macro since it stomps on many potential optimizations.  Ideally\n-   it should have a register class argument so that not all the register\n-   classes gets penalized for the sake of a naughty few...  For long\n-   double arithmetic we need two additional registers that we can use as\n-   spill registers.  */\n-\n-#define SMALL_REGISTER_CLASSES (TARGET_SMALL_REG_CLASS && TARGET_PARALLEL_MPY)\n-\n-#define BASE_REG_CLASS\tADDR_REGS\n-#define INDEX_REG_CLASS INDEX_REGS\n-\n-/*\n-  Register constraints for the C4x\n- \n-  a - address reg (ar0-ar7)\n-  b - stack reg (sp)\n-  c - other gp int-only reg\n-  d - data/int reg (equiv. to f)\n-  f - data/float reg\n-  h - data/long double reg (equiv. to f)\n-  k - block count (bk)\n-  q - r0-r7\n-  t - r0-r1\n-  u - r2-r3\n-  v - repeat count (rc)\n-  x - index register (ir0-ir1)\n-  y - status register (st)\n-  z - dp reg (dp) \n-\n-  Memory/constant constraints for the C4x\n-\n-  G - short float 16-bit\n-  I - signed 16-bit constant (sign extended)\n-  J - signed 8-bit constant (sign extended)  (C4x only)\n-  K - signed 5-bit constant (sign extended)  (C4x only for stik)\n-  L - unsigned 16-bit constant\n-  M - unsigned 8-bit constant                (C4x only)\n-  N - ones complement of unsigned 16-bit constant\n-  Q - indirect arx + 9-bit signed displacement\n-      (a *-arx(n) or *+arx(n) is used to account for the sign bit)\n-  R - indirect arx + 5-bit unsigned displacement  (C4x only)\n-  S - indirect arx + 0, 1, or irn displacement\n-  T - direct symbol ref\n-  > - indirect with autoincrement\n-  < - indirect with autodecrement\n-  } - indirect with post-modify\n-  { - indirect with pre-modify\n-  */\n-\n-#define REG_CLASS_FROM_LETTER(CC)\t\t\t\t\\\n-     ( ((CC) == 'a') ? ADDR_REGS\t\t\t\t\\\n-     : ((CC) == 'b') ? SP_REG\t\t\t\t\t\\\n-     : ((CC) == 'c') ? INT_REGS\t\t\t\t\t\\\n-     : ((CC) == 'd') ? EXT_REGS\t\t\t\t\t\\\n-     : ((CC) == 'f') ? EXT_REGS\t\t\t\t\t\\\n-     : ((CC) == 'h') ? EXT_REGS\t\t\t\t\t\\\n-     : ((CC) == 'k') ? BK_REG\t\t\t\t\t\\\n-     : ((CC) == 'q') ? EXT_LOW_REGS\t\t\t\t\\\n-     : ((CC) == 't') ? R0R1_REGS\t\t\t\t\\\n-     : ((CC) == 'u') ? R2R3_REGS\t\t\t\t\\\n-     : ((CC) == 'v') ? RC_REG\t\t\t\t\t\\\n-     : ((CC) == 'x') ? INDEX_REGS\t\t\t\t\\\n-     : ((CC) == 'y') ? ST_REG\t\t\t\t\t\\\n-     : ((CC) == 'z') ? DP_REG\t\t\t\t\t\\\n-     : NO_REGS )\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO)  \\\n-     (IS_ADDR_REGNO(REGNO) || IS_ADDR_REGNO((unsigned)reg_renumber[REGNO]))\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-     (IS_INDEX_REGNO(REGNO) || IS_INDEX_REGNO((unsigned)reg_renumber[REGNO]))\n-\n-/* If we have to generate framepointer + constant prefer an ADDR_REGS\n-   register.  This avoids using EXT_REGS in addqi3_noclobber_reload.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\\\n-     (GET_CODE (X) == PLUS\t\t\t\t\t\\\n-      && GET_MODE (X) == Pmode\t\t\t\t\t\\\n-      && GET_CODE (XEXP ((X), 0)) == REG\t\t\t\\\n-      && GET_MODE (XEXP ((X), 0)) == Pmode\t\t\t\\\n-      && REGNO (XEXP ((X), 0)) == FRAME_POINTER_REGNUM\t\t\\\n-      && GET_CODE (XEXP ((X), 1)) == CONST_INT\t\t\t\\\n-\t? ADDR_REGS : (CLASS))\n-\n-#define LIMIT_RELOAD_CLASS(X, CLASS) (CLASS)\n-\n-#define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) 0\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\\\n-(((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : ((MODE) == HFmode) ? 1 : \\\n-((GET_MODE_SIZE(MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-#define IS_INT5_CONST(VAL) (((VAL) <= 15) && ((VAL) >= -16))\t/* 'K'.  */\n-\n-#define IS_UINT5_CONST(VAL) (((VAL) <= 31) && ((VAL) >= 0))\t/* 'R'.  */\n-\n-#define IS_INT8_CONST(VAL) (((VAL) <= 127) && ((VAL) >= -128))\t/* 'J'.  */\n-\n-#define IS_UINT8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= 0))\t/* 'M'.  */\n-\n-#define IS_INT16_CONST(VAL) (((VAL) <= 32767) && ((VAL) >= -32768)) /* 'I'.  */\n-\n-#define IS_UINT16_CONST(VAL) (((VAL) <= 65535) && ((VAL) >= 0))\t/* 'L'.  */\n-\n-#define IS_NOT_UINT16_CONST(VAL) IS_UINT16_CONST(~(VAL))\t/* 'N'.  */\n-\n-#define IS_HIGH_CONST(VAL) \\\n-(! TARGET_C3X && (((VAL) & 0xffff) == 0)) /* 'O'.  */\n-\n-\n-#define IS_DISP1_CONST(VAL) (((VAL) <= 1) && ((VAL) >= -1)) /* 'S'.  */\n-\n-#define IS_DISP8_CONST(VAL) (((VAL) <= 255) && ((VAL) >= -255))\t/* 'Q'.  */\n-\n-#define IS_DISP1_OFF_CONST(VAL) (IS_DISP1_CONST (VAL) \\\n-\t\t\t\t && IS_DISP1_CONST (VAL + 1))\n-\n-#define IS_DISP8_OFF_CONST(VAL) (IS_DISP8_CONST (VAL) \\\n-\t\t\t\t && IS_DISP8_CONST (VAL + 1))\n-\n-#define CONST_OK_FOR_LETTER_P(VAL, C)\t\t\t\t\t\\\n-        ( ((C) == 'I') ? (IS_INT16_CONST (VAL))\t\t\t\t\\\n-\t: ((C) == 'J') ? (! TARGET_C3X && IS_INT8_CONST (VAL))\t\t\\\n-\t: ((C) == 'K') ? (! TARGET_C3X && IS_INT5_CONST (VAL))\t\t\\\n-        : ((C) == 'L') ? (IS_UINT16_CONST (VAL))\t\t\t\\\n-\t: ((C) == 'M') ? (! TARGET_C3X && IS_UINT8_CONST (VAL))\t\t\\\n-\t: ((C) == 'N') ? (IS_NOT_UINT16_CONST (VAL))\t\t        \\\n-\t: ((C) == 'O') ? (IS_HIGH_CONST (VAL))\t\t\t        \\\n-        : 0 )\t\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(OP, C) \t\t\t\t\\\n-        ( ((C) == 'G') ? (fp_zero_operand (OP, QFmode))\t\t\t\\\n-\t: ((C) == 'H') ? (c4x_H_constant (OP)) \t\t\t\t\\\n-\t: 0 )\n-\n-#define EXTRA_CONSTRAINT(OP, C) \\\n-        ( ((C) == 'Q') ? (c4x_Q_constraint (OP))\t\t\t\\\n-\t: ((C) == 'R') ? (c4x_R_constraint (OP))\t\t\t\\\n-\t: ((C) == 'S') ? (c4x_S_constraint (OP))\t\t\t\\\n-\t: ((C) == 'T') ? (c4x_T_constraint (OP))\t\t\t\\\n-\t: ((C) == 'U') ? (c4x_U_constraint (OP))\t\t\t\\\n-\t: 0 )\n-\n-#define SMALL_CONST(VAL, insn)\t\t\t\t\t\t\\\n-     (  ((insn == NULL_RTX) || (get_attr_data (insn) == DATA_INT16))\t\\\n-\t? IS_INT16_CONST (VAL)\t\t\t\t\t\t\\\n-\t: ( (get_attr_data (insn) == DATA_NOT_UINT16)\t\t\t\\\n-\t    ? IS_NOT_UINT16_CONST (VAL)\t\t\t\t\t\\\n-\t    :  ( (get_attr_data (insn) == DATA_HIGH_16)\t\t\t\\\n-\t       ? IS_HIGH_CONST (VAL)\t\t\t\t\t\\\n-\t       : IS_UINT16_CONST (VAL)\t\t\t\t\t\\\n-\t    )\t\t\t\t\t\t\t\t\\\n-\t  )\t\t\t\t\t\t\t\t\\\n-\t)\n-\n-/*\n-   I. Routine calling with arguments in registers\n-   ----------------------------------------------\n-\n-   The TI C3x compiler has a rather unusual register passing algorithm.\n-   Data is passed in the following registers (in order):\n-\n-   AR2, R2, R3, RC, RS, RE\n-\n-   However, the first and second floating point values are always in R2\n-   and R3 (and all other floats are on the stack).  Structs are always\n-   passed on the stack.  If the last argument is an ellipsis, the\n-   previous argument is passed on the stack so that its address can be\n-   taken for the stdargs macros.\n-\n-   Because of this, we have to pre-scan the list of arguments to figure\n-   out what goes where in the list.\n-\n-   II. Routine calling with arguments on stack\n-   -------------------------------------------\n-\n-   Let the subroutine declared as \"foo(arg0, arg1, arg2);\" have local\n-   variables loc0, loc1, and loc2.  After the function prologue has\n-   been executed, the stack frame will look like:\n-\n-   [stack grows towards increasing addresses]\n-       I-------------I\n-   5   I saved reg1  I  <= SP points here\n-       I-------------I\n-   4   I saved reg0  I  \n-       I-------------I\n-   3   I       loc2  I  \n-       I-------------I  \n-   2   I       loc1  I  \n-       I-------------I  \n-   1   I       loc0  I  \n-       I-------------I\n-   0   I     old FP  I <= FP (AR3) points here\n-       I-------------I\n-   -1  I  return PC  I\n-       I-------------I\n-   -2  I       arg0  I  \n-       I-------------I  \n-   -3  I       arg1  I\n-       I-------------I  \n-   -4  I       arg2  I \n-       I-------------I  \n-\n-   All local variables (locn) are accessible by means of +FP(n+1)\n-   addressing, where n is the local variable number.\n-\n-   All stack arguments (argn) are accessible by means of -FP(n-2).\n-\n-   The stack pointer (SP) points to the last register saved in the\n-   prologue (regn).\n-\n-   Note that a push instruction performs a preincrement of the stack\n-   pointer.  (STACK_PUSH_CODE == PRE_INC)\n-\n-   III. Registers used in function calling convention\n-   --------------------------------------------------\n-\n-   Preserved across calls: R4...R5 (only by PUSH,  i.e. lower 32 bits)\n-   R6...R7 (only by PUSHF, i.e. upper 32 bits)\n-   AR3...AR7\n-\n-   (Because of this model, we only assign FP values in R6, R7 and\n-   only assign integer values in R4, R5.)\n-\n-   These registers are saved at each function entry and restored at\n-   the exit. Also it is expected any of these not affected by any\n-   call to user-defined (not service) functions.\n-\n-   Not preserved across calls: R0...R3\n-   R4...R5 (upper 8 bits)\n-   R6...R7 (lower 8 bits)\n-   AR0...AR2, IR0, IR1, BK, ST, RS, RE, RC\n-\n-   These registers are used arbitrary in a function without being preserved.\n-   It is also expected that any of these can be clobbered by any call.\n-\n-   Not used by GCC (except for in user \"asm\" statements):\n-   IE (DIE), IF (IIE), IOF (IIF)\n-\n-   These registers are never used by GCC for any data, but can be used\n-   with \"asm\" statements.  */\n-\n-#define C4X_ARG0 -2\n-#define C4X_LOC0 1\n-\n-/* Basic Stack Layout.  */\n-     \n-/* The stack grows upward, stack frame grows upward, and args grow\n-   downward.  */\n-\n-#define STARTING_FRAME_OFFSET\t\tC4X_LOC0\n-#define FIRST_PARM_OFFSET(FNDECL)      (C4X_ARG0 + 1)\n-#define ARGS_GROW_DOWNWARD\n-#define STACK_POINTER_OFFSET 1\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-\n-/* #define STACK_GROWS_DOWNWARD.  */\n-/* Like the dsp16xx, i370, i960, and we32k ports.  */\n-\n-/* Define this to nonzero if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-\n-#define FRAME_GROWS_DOWNWARD 0\n-\n-\n-/* Registers That Address the Stack Frame.  */\n-\n-#define STACK_POINTER_REGNUM\tSP_REGNO\t/* SP.  */\n-#define FRAME_POINTER_REGNUM\tAR3_REGNO\t/* AR3.  */\n-#define ARG_POINTER_REGNUM\tAR3_REGNO\t/* AR3.  */\n-#define STATIC_CHAIN_REGNUM\tAR0_REGNO\t/* AR0.  */\n-\n-/* Eliminating Frame Pointer and Arg Pointer.  */\n-\n-#define FRAME_POINTER_REQUIRED\t0\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n- int regno;\t\t\t\t\t\t\t\\\n- int offset = 0;\t\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n-      offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n-\t\t&& IS_FLOAT_CALL_SAVED_REGNO (regno) ? 2 : 1;\t\\\n-  (DEPTH) = -(offset + get_frame_size ());\t\t\t\\\n-}\n-\n-/* This is a hack...  We need to specify a register.  */\n-#define\tELIMINABLE_REGS \t\t\t\t\t\\\n-  {{ FRAME_POINTER_REGNUM, FRAME_POINTER_REGNUM }}\n-\n-#define\tCAN_ELIMINATE(FROM, TO)\t\t\t\t\t\\\n-  (! (((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM) \\\n-  || ((FROM) == FRAME_POINTER_REGNUM && (TO) == FRAME_POINTER_REGNUM)))\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t \t\\\n-{\t\t\t\t\t\t\t\t\\\n- int regno;\t\t\t\t\t\t\t\\\n- int offset = 0;\t\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (df_regs_ever_live_p (regno) && ! call_used_regs[regno])\t\\\n-      offset += TARGET_PRESERVE_FLOAT\t\t\t\t\\\n-\t\t&& IS_FLOAT_CALL_SAVED_REGNO (regno) ? 2 : 1;\t\\\n-  (OFFSET) = -(offset + get_frame_size ());\t\t\t\\\n-}\n-\n-\n-/* Passing Function Arguments on the Stack.  */\n-\n-#define\tPUSH_ARGS 1\n-#define PUSH_ROUNDING(BYTES) (BYTES)\n-#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACK_SIZE) 0\n-\n-/* The following structure is used by calls.c, function.c, c4x.c.  */\n-\n-typedef struct c4x_args\n-{\n-  int floats;\n-  int ints;\n-  int maxfloats;\n-  int maxints;\n-  int init;\n-  int var;\n-  int prototype;\n-  int args;\n-}\n-CUMULATIVE_ARGS;\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-  (c4x_init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n-  (c4x_function_arg_advance (&CUM, MODE, TYPE, NAMED))\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-  (c4x_function_arg(&CUM, MODE, TYPE, NAMED))\n-\n-/* Define the profitability of saving registers around calls.\n-   We disable caller save to avoid a bug in flow.c (this also affects\n-   other targets such as m68k).  Since we must use stf/sti,\n-   the profitability is marginal anyway.  */\n-\n-#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-\n-#define FUNCTION_ARG_REGNO_P(REGNO) \\\n-\t(  (   ((REGNO) == AR2_REGNO)\t/* AR2.  */\t\\\n-\t    || ((REGNO) == R2_REGNO)\t/* R2.  */\t\\\n-\t    || ((REGNO) == R3_REGNO)\t/* R3.  */\t\\\n-\t    || ((REGNO) == RC_REGNO)\t/* RC.  */\t\\\n-\t    || ((REGNO) == RS_REGNO)\t/* RS.  */\t\\\n-\t    || ((REGNO) == RE_REGNO))\t/* RE.  */\t\\\n-\t ? 1\t\t\t\t\t\t\\\n-\t : 0)\n-\n-/* How Scalar Function Values Are Returned.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-\tgen_rtx_REG (TYPE_MODE(VALTYPE), R0_REGNO)\t/* Return in R0.  */\n-\n-#define LIBCALL_VALUE(MODE) \\\n-\tgen_rtx_REG (MODE, R0_REGNO)\t/* Return in R0.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(REGNO) ((REGNO) == R0_REGNO)\n-\n-/* How Large Values Are Returned.  */\n-\n-#define DEFAULT_PCC_STRUCT_RETURN\t0\n-\n-/* Generating Code for Profiling.  */\n-\n-/* Note that the generated assembly uses the ^ operator to load the 16\n-   MSBs of the address.  This is not supported by the TI assembler. \n-   The FUNCTION profiler needs a function mcount which gets passed\n-   a pointer to the LABELNO.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\\\n-     if (! TARGET_C3X)\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldhi\\t^LP%d,ar2\\n\", (LABELNO));\t\\\n-\tfprintf (FILE, \"\\tor\\t#LP%d,ar2\\n\", (LABELNO));\t\t\\\n-\tfprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\\\n-     {\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"\\tpush\\tar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tldiu\\t^LP%d,ar2\\n\", (LABELNO));\t\\\n-\tfprintf (FILE, \"\\tlsh\\t16,ar2\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tor\\t#LP%d,ar2\\n\", (LABELNO));\t\t\\\n-\tfprintf (FILE, \"\\tcall\\tmcount\\n\");\t\t\t\\\n-\tfprintf (FILE, \"\\tpop\\tar2\\n\");\t\t\t\t\\\n-     }\n-\n-/* CC_NOOVmode should be used when the first operand is a PLUS, MINUS, NEG\n-   or MULT.\n-   CCmode should be used when no special processing is needed.  */\n-#define SELECT_CC_MODE(OP,X,Y) \\\n-  ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\\\n-    || GET_CODE (X) == NEG || GET_CODE (X) == MULT\t\t\\\n-    || GET_MODE (X) == ABS\t\t\t\t\t\\\n-    || GET_CODE (Y) == PLUS || GET_CODE (Y) == MINUS\t\t\\\n-    || GET_CODE (Y) == NEG || GET_CODE (Y) == MULT\t\t\\\n-    || GET_MODE (Y) == ABS)\t\t\t\t\t\\\n-    ? CC_NOOVmode : CCmode)\n-\n-/* Addressing Modes.  */\n-\n-#define HAVE_POST_INCREMENT 1\n-#define HAVE_PRE_INCREMENT 1\n-#define HAVE_POST_DECREMENT 1\n-#define HAVE_PRE_DECREMENT 1\n-#define HAVE_PRE_MODIFY_REG 1\n-#define HAVE_POST_MODIFY_REG 1\n-#define HAVE_PRE_MODIFY_DISP 1\n-#define HAVE_POST_MODIFY_DISP 1\n-\n-/* The number of insns that can be packed into a single opcode.  */\n-#define PACK_INSNS 2\n-\n-/* Recognize any constant value that is a valid address. \n-   We could allow arbitrary constant addresses in the large memory\n-   model but for the small memory model we can only accept addresses\n-   within the data page.  I suppose we could also allow\n-   CONST PLUS SYMBOL_REF.  */\n-#define CONSTANT_ADDRESS_P(X) (GET_CODE (X) == SYMBOL_REF)\n-\n-/* Maximum number of registers that can appear in a valid memory\n-   address.  */\n-#define MAX_REGS_PER_ADDRESS\t2\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard or pseudo reg that can be used as a base.  */\n-\n-#define REG_OK_FOR_BASE_P(X) IS_ADDR_OR_PSEUDO_REG(X)\n-\n-/* Nonzero if X is a hard or pseudo reg that can be used as an index.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) IS_INDEX_OR_PSEUDO_REG(X)\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (c4x_legitimate_address_p (MODE, X, 0))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (c4x_legitimate_address_p (MODE, X, 1))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-}\n-\n-#endif\n-\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  rtx new;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  new = c4x_legitimize_address (X, MODE);\t\t\t\t\\\n-  if (new != NULL_RTX)\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    (X) = new;\t\t\t\t\t\t\t\t\\\n-    goto WIN;\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (MODE != HImode\t\t\t\t\t\t\t\\\n-      && MODE != HFmode\t\t\t\t\t\t\t\\\n-      && GET_MODE (X) != HImode\t\t\t\t\t\t\\\n-      && GET_MODE (X) != HFmode\t\t\t\t\t\t\\\n-      && (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-          || GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n-          || GET_CODE (X) == LABEL_REF))\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_SMALL)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-          int i;\t\t\t\t\t\t\t\\\n-      \t  (X) = gen_rtx_LO_SUM (GET_MODE (X),\t\t\t\t\\\n-\t\t\t      gen_rtx_HIGH (GET_MODE (X), X), X);\t\\\n-          i = push_reload (XEXP (X, 0), NULL_RTX,\t\t\t\\\n-\t\t\t   &XEXP (X, 0), NULL,\t\t\t\t\\\n-\t\t           DP_REG, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-\t\t           OPNUM, TYPE);\t\t\t\t\\\n-          /* The only valid reg is DP. This is a fixed reg and will\t\\\n-\t     normally not be used so force it.  */\t\t\t\\\n-          rld[i].reg_rtx = gen_rtx_REG (Pmode, DP_REGNO); \t\t\\\n-          rld[i].nocombine = 1; \t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          /* make_memloc in reload will substitute invalid memory       \\\n-             references.  We need to fix them up.  */                   \\\n-          (X) = gen_rtx_LO_SUM (Pmode, gen_rtx_REG (Pmode, DP_REGNO), (X)); \\\n-        }\t\t\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n-  else if (MODE != HImode\t\t\t\t\t\t\\\n-           && MODE != HFmode\t\t\t\t\t\t\\\n-           && GET_MODE (X) != HImode\t\t\t\t\t\\\n-           && GET_MODE (X) != HFmode\t\t\t\t\t\\\n-           && GET_CODE (X) == LO_SUM\t\t\t\t\t\\\n-           && GET_CODE (XEXP (X,0)) == HIGH\t\t\t\t\\\n-           && (GET_CODE (XEXP (XEXP (X,0),0)) == CONST\t\t\t\\\n-               || GET_CODE (XEXP (XEXP (X,0),0)) == SYMBOL_REF\t\t\\\n-               || GET_CODE (XEXP (XEXP (X,0),0)) == LABEL_REF))\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (! TARGET_SMALL)\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-          int i = push_reload (XEXP (X, 0), NULL_RTX,\t\t\t\\\n-\t\t\t       &XEXP (X, 0), NULL,\t\t\t\\\n-\t\t               DP_REG, GET_MODE (X), VOIDmode, 0, 0,\t\\\n-\t\t               OPNUM, TYPE);\t\t\t\t\\\n-          /* The only valid reg is DP. This is a fixed reg and will\t\\\n-\t     normally not be used so force it.  */\t\t\t\\\n-          rld[i].reg_rtx = gen_rtx_REG (Pmode, DP_REGNO); \t\t\\\n-          rld[i].nocombine = 1; \t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n-      goto WIN;\t\t\t\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* No mode-dependent addresses on the C4x are autoincrements.  */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n-  if (GET_CODE (ADDR) == POST_MODIFY\t\\\n-      || GET_CODE (ADDR) == PRE_MODIFY)\t\\\n-    goto LABEL\n-\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE. \n-\n-   The C4x can only load 16-bit immediate values, so we only allow a\n-   restricted subset of CONST_INT and CONST_DOUBLE.  Disallow\n-   LABEL_REF and SYMBOL_REF (except on the C40 with the big memory\n-   model) so that the symbols will be forced into the constant pool.\n-   On second thoughts, let's do this with the move expanders since\n-   the alias analysis has trouble if we force constant addresses\n-   into memory.\n-*/\n-\n-#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n-  ((GET_CODE (X) == CONST_DOUBLE && c4x_H_constant (X))\t\t\\\n-  || (GET_CODE (X) == CONST_INT)\t\t\t\t\\\n-  || (GET_CODE (X) == SYMBOL_REF)\t\t\t\t\\\n-  || (GET_CODE (X) == LABEL_REF)\t\t\t\t\\\n-  || (GET_CODE (X) == CONST)\t\t\t\t\t\\\n-  || (GET_CODE (X) == HIGH && ! TARGET_C3X)\t\t\t\\\n-  || (GET_CODE (X) == LO_SUM && ! TARGET_C3X))\n-\n-#define LEGITIMATE_DISPLACEMENT_P(X) IS_DISP8_CONST (INTVAL (X))\n-\n-/* Describing Relative Cost of Operations.  */\n-\n-#define\tCANONICALIZE_COMPARISON(CODE, OP0, OP1)\t\t\\\n-if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-  rtx tmp = OP0; OP0 = OP1 ; OP1 = tmp;\t\t\t\\\n-  CODE = swap_condition (CODE);\t\t\t\t\\\n-}\n-\n-#define EXT_CLASS_P(CLASS) (reg_class_subset_p (CLASS, EXT_REGS))\n-#define ADDR_CLASS_P(CLASS) (reg_class_subset_p (CLASS, ADDR_REGS))\n-#define INDEX_CLASS_P(CLASS) (reg_class_subset_p (CLASS, INDEX_REGS))\n-#define EXPENSIVE_CLASS_P(CLASS) (ADDR_CLASS_P(CLASS) \\\n-                          || INDEX_CLASS_P(CLASS) || (CLASS) == SP_REG)\n-\n-/* Compute extra cost of moving data between one register class\n-   and another.  */\n-\n-#define REGISTER_MOVE_COST(MODE, FROM, TO)\t2\n-\n-/* Memory move cost is same as fast register move.  Maybe this should\n-   be bumped up?.  */\n-\n-#define MEMORY_MOVE_COST(M,C,I)\t\t4\n-\n-/* Branches are kind of expensive (even with delayed branching) so\n-   make their cost higher.  */\n-\n-#define BRANCH_COST\t\t\t8\n-\n-#define\tWORD_REGISTER_OPERATIONS\n-\n-/* Dividing the Output into Sections.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-#define READONLY_DATA_SECTION_ASM_OP \"\\t.sect\\t\\\".const\\\"\"\n-\n-/* Do not use .init section so __main will be called on startup. This will\n-   call __do_global_ctors and prepare for __do_global_dtors on exit.  */\n-\n-#if 0\n-#define INIT_SECTION_ASM_OP  \"\\t.sect\\t\\\".init\\\"\"\n-#endif\n-\n-#define FINI_SECTION_ASM_OP  \"\\t.sect\\t\\\".fini\\\"\"\n-\n-/* Switch into a generic section.  */\n-#define TARGET_ASM_NAMED_SECTION c4x_asm_named_section\n-\n-\n-/* Overall Framework of an Assembler File.  */\n-\n-#define ASM_COMMENT_START \";\"\n-\n-#define ASM_APP_ON \"\"\n-#define ASM_APP_OFF \"\"\n-\n-#define ASM_OUTPUT_ASCII(FILE, PTR, LEN) c4x_output_ascii (FILE, PTR, LEN)\n-\n-/* Output and Generation of Labels.  */\n-\n-#define NO_DOT_IN_LABEL\t\t/* Only required for TI format.  */\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.global\\t\"\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME) \\\n-c4x_external_ref (NAME)\n-\n-/* The prefix to add to user-visible assembler symbols.  */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(BUFFER, PREFIX, NUM) \\\n-    sprintf (BUFFER, \"*%s%lu\", PREFIX, (unsigned long)(NUM))\n-\n-/* A C statement to output to the stdio stream STREAM assembler code which\n-   defines (equates) the symbol NAME to have the value VALUE.  */\n-\n-#define ASM_OUTPUT_DEF(STREAM, NAME, VALUE) \t\\\n-do {\t\t\t\t\t\t\\\n-  assemble_name (STREAM, NAME);\t\t\t\\\n-  fprintf (STREAM, \"\\t.set\\t%s\\n\", VALUE);\t\\\n-} while (0)\n-\n-/* Output of Dispatch Tables.  */\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n-    fprintf (FILE, \"\\t.long\\tL%d\\n\", VALUE);\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-    fprintf (FILE, \"\\t.long\\tL%d-L%d\\n\", VALUE, REL);\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef WCHAR_TYPE\n-#define WCHAR_TYPE \"long int\"\n-\n-#undef WCHAR_TYPE_SIZE\n-#define WCHAR_TYPE_SIZE 32\n-\n-#define INT_TYPE_SIZE\t\t32\n-#define LONG_LONG_TYPE_SIZE\t64\n-#define FLOAT_TYPE_SIZE\t\t32\n-#define DOUBLE_TYPE_SIZE\t32\n-#define LONG_DOUBLE_TYPE_SIZE\t64 /* Actually only 40.  */\n-\n-/* Output #ident as a .ident.  */\n-\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n-\n-/* Output of Uninitialized Variables.  */\n-\n-/* This says how to output an assembler line to define a local\n-   uninitialized variable.  */\n-\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.bss\\t\", FILE),\t\t\t\\\n-  assemble_name (FILE, (NAME)),\t\t\\\n-  fprintf (FILE, \",%u\\n\", (int)(ROUNDED)))\n-\n-/* This says how to output an assembler line to define a global\n-   uninitialized variable.  */\n-\n-#undef ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-(  fputs (\"\\t.globl\\t\", FILE),\t\\\n-   assemble_name (FILE, (NAME)),\t\\\n-   fputs (\"\\n\\t.bss\\t\", FILE),\t\\\n-   assemble_name (FILE, (NAME)),\t\\\n-   fprintf (FILE, \",%u\\n\", (int)(ROUNDED)))\n-\n-#undef ASM_OUTPUT_BSS\n-#define ASM_OUTPUT_BSS(FILE, DECL, NAME, SIZE, ALIGN)   \\\n-(  fputs (\"\\t.globl\\t\", FILE),\t\\\n-   assemble_name (FILE, (NAME)),\t\\\n-   fputs (\"\\n\\t.bss\\t\", FILE),\t\\\n-   assemble_name (FILE, (NAME)),\t\\\n-   fprintf (FILE, \",%u\\n\", (int)(SIZE)))\n-\n-/* Macros Controlling Initialization Routines.  */\n-\n-#define OBJECT_FORMAT_COFF\n-#define REAL_NM_FILE_NAME \"c4x-nm\"\n-\n-/* Output of Assembler Instructions.  */\n-\n-/* Register names when used for integer modes.  */\n-\n-#define REGISTER_NAMES \\\n-{\t\t\t\t\t\t\t\t\\\n- \"r0\",   \"r1\", \"r2\",   \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\", \"ar4\", \"ar5\", \"ar6\", \"ar7\",\t\\\n- \"dp\",  \"ir0\", \"ir1\",  \"bk\",  \"sp\",  \"st\", \"die\", \"iie\",\t\\\n- \"iif\",\t \"rs\",  \"re\",  \"rc\",  \"r8\",  \"r9\", \"r10\", \"r11\"\t\t\\\n-}\n-\n-/* Alternate register names when used for floating point modes.  */\n-\n-#define FLOAT_REGISTER_NAMES \\\n-{\t\t\t\t\t\t\t\t\\\n- \"f0\",   \"f1\", \"f2\",   \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\\\n- \"ar0\", \"ar1\", \"ar2\", \"ar3\", \"ar4\", \"ar5\", \"ar6\", \"ar7\",\t\\\n- \"dp\",  \"ir0\", \"ir1\",  \"bk\",  \"sp\",  \"st\", \"die\", \"iie\",\t\\\n- \"iif\",\t \"rs\",  \"re\",  \"rc\",  \"f8\",  \"f9\", \"f10\", \"f11\"\t\t\\\n-}\n-\n-#define PRINT_OPERAND(FILE, X, CODE) c4x_print_operand(FILE, X, CODE)\n-\n-/* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic.  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, X) c4x_print_operand_address(FILE, X)\n-\n-/* C4x specific pragmas.  */\n-#define REGISTER_TARGET_PRAGMAS() do {\t\t\t\t\t  \\\n-  c_register_pragma (0, \"CODE_SECTION\", c4x_pr_CODE_SECTION);\t\t  \\\n-  c_register_pragma (0, \"DATA_SECTION\", c4x_pr_DATA_SECTION);\t\t  \\\n-  c_register_pragma (0, \"FUNC_CANNOT_INLINE\", c4x_pr_ignored);\t\t  \\\n-  c_register_pragma (0, \"FUNC_EXT_CALLED\", c4x_pr_ignored);\t\t  \\\n-  c_register_pragma (0, \"FUNC_IS_PURE\", c4x_pr_FUNC_IS_PURE);\t\t  \\\n-  c_register_pragma (0, \"FUNC_IS_SYSTEM\", c4x_pr_ignored);\t\t  \\\n-  c_register_pragma (0, \"FUNC_NEVER_RETURNS\", c4x_pr_FUNC_NEVER_RETURNS); \\\n-  c_register_pragma (0, \"FUNC_NO_GLOBAL_ASG\", c4x_pr_ignored);\t\t  \\\n-  c_register_pragma (0, \"FUNC_NO_IND_ASG\", c4x_pr_ignored);\t\t  \\\n-  c_register_pragma (0, \"INTERRUPT\", c4x_pr_INTERRUPT);\t\t\t  \\\n-} while (0)\n-\n-/* Assembler Commands for Alignment.  */\n-\n-#define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n-{ int c = SIZE; \\\n-  for (; c > 0; --c) \\\n-   fprintf (FILE,\"\\t.word\\t0\\n\"); \\\n-}\n-\n-#define ASM_NO_SKIP_IN_TEXT 1\n-\n-/* I'm not sure about this one.  FIXME.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align\\t%d\\n\", (1 << (LOG)))\n-\n-\n-/* Macros for SDB and DWARF Output  (use .sdef instead of .def\n-   to avoid conflict with TI's use of .def).  */\n-\n-#define SDB_DELIM \"\\n\"\n-#define SDB_DEBUGGING_INFO 1\n-\n-/* Don't use octal since this can confuse gas for the c4x.  */\n-#define PUT_SDB_TYPE(a) fprintf(asm_out_file, \"\\t.type\\t0x%x%s\", a, SDB_DELIM)\n-\n-#define PUT_SDB_DEF(A)\t\t\t\t\\\n-do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, A); \t\\\n-     fprintf (asm_out_file, SDB_DELIM); } while (0)\n-\n-#define PUT_SDB_PLAIN_DEF(A)\t\t\t\\\n-  fprintf (asm_out_file,\"\\t.sdef\\t.%s%s\", A, SDB_DELIM)\n-\n-#define PUT_SDB_BLOCK_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.sdef\\t.bb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-\n-#define PUT_SDB_BLOCK_END(LINE)\t\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.sdef\\t.eb%s\\t.val\\t.%s\\t.scl\\t100%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-\n-#define PUT_SDB_FUNCTION_START(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.sdef\\t.bf%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, (LINE), SDB_DELIM)\n-\n-/* Note we output relative line numbers for .ef which gas converts\n-   to absolute line numbers.  The TI compiler outputs absolute line numbers\n-   in the .sym directive which gas does not support.  */\n-#define PUT_SDB_FUNCTION_END(LINE)\t\t\\\n-  fprintf (asm_out_file,\t\t\t\\\n-\t   \"\\t.sdef\\t.ef%s\\t.val\\t.%s\\t.scl\\t101%s\\t.line\\t%d%s\\t.endef\\n\", \\\n-\t   SDB_DELIM, SDB_DELIM, SDB_DELIM, \\\n-           (LINE), SDB_DELIM)\n-\n-#define PUT_SDB_EPILOGUE_END(NAME)\t\t\t\\\n-do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n-     ASM_OUTPUT_LABELREF (asm_out_file, NAME);\t\t\\\n-     fprintf (asm_out_file,\t\t\t\t\\\n-\t      \"%s\\t.val\\t.%s\\t.scl\\t-1%s\\t.endef\\n\",\t\\\n-\t      SDB_DELIM, SDB_DELIM, SDB_DELIM); } while (0)\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* A function address in a call instruction is a byte address (for\n-   indexing purposes) so give the MEM rtx a byte's mode.  */\n-\n-#define FUNCTION_MODE QImode\n-\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Specify the machine mode that pointers have.  After generation of\n-   RTL, the compiler makes no further distinction between pointers and\n-   any other objects of this machine mode.  */\n-\n-#define Pmode QImode\n-\n-/* On the C4x we can write the following code. We have to clear the cache\n-   every time we execute it because the data in the stack could change.\n-\n-   laj   $+4\n-   addi3 4,r11,ar0\n-   lda   *ar0,ar1\n-   lda   *+ar0(1),ar0\n-   bud   ar1\n-   nop\n-   nop\n-   or   1000h,st\n-   .word FNADDR\n-   .word CXT\n-\n-   On the c3x this is a bit more difficult. We have to write self\n-   modifying code here. So we have to clear the cache every time\n-   we execute it because the data in the stack could change.\n-\n-   ldiu TOP_OF_FUNCTION,ar1\n-   lsh  16,ar1\n-   or   BOTTOM_OF_FUNCTION,ar1\n-   ldiu TOP_OF_STATIC,ar0\n-   bud  ar1\n-   lsh  16,ar0\n-   or   BOTTOM_OF_STATIC,ar0\n-   or   1000h,st\n-   \n-  */\n-\n-#define TRAMPOLINE_SIZE (TARGET_C3X ? 8 : 10)\n-\n-#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  if (TARGET_C3X)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tldiu\\t0,ar1\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tlsh\\t16,ar1\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tor\\t0,ar1\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tldiu\\t0,ar0\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tbud\\tar1\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tlsh\\t16,ar0\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tor\\t0,ar0\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tor\\t1000h,st\\n\");\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tlaj\\t$+4\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\taddi3\\t4,r11,ar0\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tlda\\t*ar0,ar1\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tlda\\t*+ar0(1),ar0\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\tbud\\tar1\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tnop\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\tor\\t1000h,st\\n\");\t\t\t\\\n-      fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\t\t\\\n-      fprintf (FILE, \"\\t.word\\t0\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_C3X)\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx tmp1, tmp2;\t\t\t\t\t\t\t\\\n-      tmp1 = expand_shift (RSHIFT_EXPR, QImode, FNADDR,\t\t\t\\\n-\t\t\t   size_int (16), 0, 1);\t\t\t\\\n-      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n-\t\t\t   GEN_INT (0x5069), size_int (16), 0, 1);\t\\\n-      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 0)), tmp1);\t\\\n-      tmp1 = expand_and (QImode, FNADDR, GEN_INT (0xffff), 0);\t\t\\\n-      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n-\t\t\t   GEN_INT (0x1069), size_int (16), 0, 1);\t\\\n-      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 2)), tmp1);\t\\\n-      tmp1 = expand_shift (RSHIFT_EXPR, QImode, CXT,\t\t\t\\\n-\t\t\t   size_int (16), 0, 1);\t\t\t\\\n-      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n-\t\t\t   GEN_INT (0x5068), size_int (16), 0, 1);\t\\\n-      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 3)), tmp1);\t\\\n-      tmp1 = expand_and (QImode, CXT, GEN_INT (0xffff), 0);\t\t\\\n-      tmp2 = expand_shift (LSHIFT_EXPR, QImode,\t\t\t\t\\\n-\t\t\t   GEN_INT (0x1068), size_int (16), 0, 1);\t\\\n-      emit_insn (gen_iorqi3 (tmp1, tmp1, tmp2));\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 6)), tmp1);\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 8)), FNADDR); \t\\\n-      emit_move_insn (gen_rtx_MEM (QImode,\t\t\t\t\\\n-\t\t\t       plus_constant (TRAMP, 9)), CXT); \t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Specify the machine mode that this machine uses for the index in\n-   the tablejump instruction.  */\n-\n-#define CASE_VECTOR_MODE Pmode\n-\n-/* Max number of (32-bit) bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-\n-#define MOVE_MAX 1\n-\n-/* MOVE_RATIO is the number of move instructions that is better than a\n-   block move.  */\n-\n-#define MOVE_RATIO 3\n-\n-#define BSS_SECTION_ASM_OP \"\\t.bss\"\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE, REGNO)  \\\n-  fprintf (FILE, \"\\tpush\\t%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE, REGNO)  \\\n-  fprintf (FILE, \"\\tpop\\t%s\\n\", reg_names[REGNO])\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-#define DBR_OUTPUT_SEQEND(FILE)\t\t\t\t\\\n-if (final_sequence != NULL_RTX)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n- int count;\t\t\t\t\t\t\\\n- rtx insn = XVECEXP (final_sequence, 0, 0); \t\t\\\n- int laj = GET_CODE (insn) == CALL_INSN \t\t\\\n-\t   || (GET_CODE (insn) == INSN\t\t\t\\\n-\t       && GET_CODE (PATTERN (insn)) == TRAP_IF);\\\n-\t\t\t\t\t\t\t\\\n- count = dbr_sequence_length();\t\t\t\t\\\n- while (count < (laj ? 2 : 3))\t\t\t\t\\\n- {\t\t\t\t\t\t\t\\\n-    fputs(\"\\tnop\\n\", FILE);\t\t\t\t\\\n-    count++;\t\t\t\t\t\t\\\n- }\t\t\t\t\t\t\t\\\n- if (laj)\t\t\t\t\t\t\\\n-    fputs(\"\\tpush\\tr11\\n\", FILE);\t\t\t\\\n-}\n-\n-#define NO_FUNCTION_CSE\n-\n-/* We don't want a leading tab.  */\n-\n-#define ASM_OUTPUT_ASM(FILE, STRING) fprintf (FILE, \"%s\\n\", STRING)\n-\n-/* Define the intrinsic functions for the c3x/c4x.  */\n-\n-enum c4x_builtins\n-{\n-\t\t\t/*\tintrinsic name\t\t*/\n-  C4X_BUILTIN_FIX,\t/*\tfast_ftoi\t\t*/\n-  C4X_BUILTIN_FIX_ANSI,\t/*\tansi_ftoi\t\t*/\n-  C4X_BUILTIN_MPYI,\t/*\tfast_imult (only C3x)\t*/\n-  C4X_BUILTIN_TOIEEE,\t/*\ttoieee\t   (only C4x)\t*/\n-  C4X_BUILTIN_FRIEEE,\t/*\tfrieee\t   (only C4x)\t*/\n-  C4X_BUILTIN_RCPF\t/*\tfast_invf  (only C4x)\t*/\n-};\n-\n-\n-/* Hack to overcome use of libgcc2.c using auto-host.h to determine\n-   HAVE_GAS_HIDDEN.  */\n-#undef HAVE_GAS_HIDDEN"}, {"sha": "364457d9347791f31d06c9856d793df587034918", "filename": "gcc/config/c4x/c4x.md", "status": "removed", "additions": 0, "deletions": 7306, "changes": 7306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=1d555e263297673f544484d6f9dd82ee50958bd7"}, {"sha": "b52f6f6bdd65c5cbb06a7347163de0a329d2a4b4", "filename": "gcc/config/c4x/c4x.opt", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fc4x.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.opt?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,139 +0,0 @@\n-; Options for the TMS320C[34]x port of the compiler.\n-\n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-m30\n-Target RejectNegative\n-Generate code for C30 CPU\n-\n-m31\n-Target RejectNegative\n-Generate code for C31 CPU\n-\n-m32\n-Target RejectNegative\n-Generate code for C32 CPU\n-\n-m33\n-Target RejectNegative\n-Generate code for C33 CPU\n-\n-m40\n-Target RejectNegative\n-Generate code for C40 CPU\n-\n-m44\n-Target RejectNegative\n-Generate code for C44 CPU\n-\n-maliases\n-Target Report Mask(ALIASES)\n-Assume that pointers may be aliased\n-\n-mbig\n-Target RejectNegative Report InverseMask(SMALL)\n-Big memory model\n-\n-mbk\n-Target Report Mask(BK)\n-Use the BK register as a general purpose register\n-\n-mcpu=\n-Target RejectNegative Joined\n--mcpu=CPU\tGenerate code for CPU\n-\n-mdb\n-Target Report Mask(DB)\n-Enable use of DB instruction\n-\n-mdebug\n-Target Report Mask(DEBUG)\n-Enable debugging\n-\n-mdevel\n-Target Report Mask(DEVEL)\n-Enable new features under development\n-\n-mfast-fix\n-Target Report Mask(FAST_FIX)\n-Use fast but approximate float to integer conversion\n-\n-mforce\n-Target Report Mask(FORCE)\n-Force RTL generation to emit valid 3 operand insns\n-\n-mhoist\n-Target Report Mask(HOIST)\n-Force constants into registers to improve hoisting\n-\n-misr-dp-reload\n-Target Mask(PARANOID) MaskExists\n-Save DP across ISR in small memory model\n-\n-mloop-unsigned\n-Target Report Mask(LOOP_UNSIGNED)\n-Allow unsigned iteration counts for RPTB/DB\n-\n-mmemparm\n-Target RejectNegative Report Mask(MEMPARM)\n-Pass arguments on the stack\n-\n-mmpyi\n-Target Report Mask(MPYI)\n-Use MPYI instruction for C3x\n-\n-mparallel-insns\n-Target Report Mask(PARALLEL)\n-Enable parallel instructions\n-\n-mparallel-mpy\n-Target Report Mask(PARALLEL_MPY)\n-Enable MPY||ADD and MPY||SUB instructions\n-\n-mparanoid\n-Target Report Mask(PARANOID)\n-Save DP across ISR in small memory model\n-\n-mpreserve-float\n-Target Report Mask(PRESERVE_FLOAT)\n-Preserve all 40 bits of FP reg across call\n-\n-mregparm\n-Target RejectNegative Report InverseMask(MEMPARM)\n-Pass arguments in registers\n-\n-mrptb\n-Target Report Mask(RPTB)\n-Enable use of RTPB instruction\n-\n-mrpts\n-Target Report Mask(RPTS)\n-Enable use of RTPS instruction\n-\n-mrpts=\n-Target RejectNegative Joined UInteger Var(c4x_rpts_cycles)\n--mrpts=N\tSet the maximum number of iterations for RPTS to N\n-\n-msmall\n-Target RejectNegative Report Mask(SMALL)\n-Small memory model\n-\n-mti\n-Target Report Mask(TI)\n-Emit code compatible with TI tools"}, {"sha": "8f801da6af76e3357f3e87793b8b7ab4b13d4523", "filename": "gcc/config/c4x/libgcc.S", "status": "removed", "additions": 0, "deletions": 1502, "changes": 1502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Flibgcc.S?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,1502 +0,0 @@\n-/* libgcc routines for the Texas Instruments TMS320C[34]x\n-   Copyright (C) 1997,98, 1999 Free Software Foundation, Inc.\n-\n- Contributed by Michael Hayes (m.hayes@elec.canterbury.ac.nz)\n-            and Herman Ten Brugge (Haj.Ten.Brugge@net.HCC.nl).\n-\n-\t\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 2, or (at your option) any\n-later version.\n-\n-In addition to the permissions in the GNU General Public License, the\n-Free Software Foundation gives you unlimited permission to link the\n-compiled version of this file into combinations with other programs,\n-and to distribute those combinations without any restriction coming\n-from the use of this file.  (The General Public License restrictions\n-do apply in other respects; for example, they cover modification of\n-the file, and distribution when not linked into a combine\n-executable.)\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with this program; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.  */\n-\n-; These routines are called using the standard TI register argument\n-; passing model.\n-; The following registers do not have to be saved:\n-; r0, r1, r2, r3, ar0, ar1, ar2, ir0, ir1, bk, rs, rc, re, (r9, r10, r11)\n-;\n-; Perform floating point divqf3\n-;\n-; This routine performs a reciprocal of the divisor using the method\n-; described in the C30/C40 user manuals.  It then multiplies that\n-; result by the dividend.\n-; \n-; Let r be the reciprocal of the divisor v and let the ith estimate\n-; of r be denoted by r[i].  An iterative approach can be used to\n-; improve the estimate of r, given an initial estimate r[0], where\n-;\n-; r[i + 1] = r[i] * (2.0 - v * r[i])\n-;\n-; The normalized error e[i] at the ith iteration is\n-;\n-; e[i] = (r - r[i]) / r = (1 / v - r[i]) * v = (1 - v * r[i])\n-;\n-; Note that \n-;\n-; e[i + 1]  = (1 - v * r[i + 1]) = 1 - 2 * v * r[i] + v^2 + (r[i])^2\n-;           = (1 - v * r[i])^2 = (e[i])^2\n-\n-; r2 dividend, r3 divisor, r0 quotient\n-; clobbers r1, ar1\n-#ifdef L_divsf3\n-\t.text\n-        .global ___divqf3\n-___divqf3:\n-\n-#ifdef _TMS320C4x\n-\t.if .REGPARM == 0\n-\tlda\tsp,ar0\n-\tldf\t*-ar0(2), r3\n-\t.endif\n-\n-\tpop\tar1\t\t; Pop return address\n-\n-; r0 = estimate of r, r1 = tmp, r2 = dividend, r3 = divisor\n-        rcpf    r3, r0\t\t; Compute initial estimate r[0]\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n-; End of 1st iteration (16 bits accuracy)\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n-\n-\tbud\tar1\t\t; Delayed branch\n-\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n-; End of 2nd iteration (32 bits accuracy)\n-\t.if .REGPARM == 0\n-\tmpyf\t*-ar0(1), r0\t; Multiply by the dividend\n-\t.else\n-\tmpyf\tr2, r0\t\t; Multiply by the dividend\n-\t.endif\n-\trnd\tr0\n-\t; Branch occurs here\n-#else\n-\t.if .REGPARM == 0\n-\tldiu\tsp,ar0\n-\tldf\t*-ar0(2), r3\n-\t.endif\n-\n-\tpop\tar1\t\t; Pop return address\n-\n-; Initial estimate       r[0] = 1.0 * 2^(-e - 1)\n-; where                  v = m * 2^e\n-\n-; r0 = estimate of r, r1 = tmp, r2 = dividend, r3 = divisor\n-\n-; Calculate initial estimate r[0]\n-\tpushf\tr3\n-\tpop\tr0\n-\tnot\tr0\t\t; r0 = -e\n-\t\t\t\t; complement exponent = -e -1\n-\t\t\t\t; complement sign (side effect)\n-\t\t\t\t; complement mantissa (almost 3 bit accurate)\n-\tpush\tr0\n-\tpopf\tr0\t\t; r0 = 1.0 * e^(-e - 1) + inverted mantissa\n-\tldf\t-1.0, r1\t; undo complement sign bit\n-\txor\tr1, r0\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n-; End of 1st iteration\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n-; End of 2nd iteration\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[2] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[2] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[2] * (2.0 - r[2] * v) = r[3]\n-; End of 3rd iteration\n-\n-\trnd\tr0\t\t; Minimize error in x[3]'s LSBs\n-\n-; Use modified last iteration\n-; r[4] = (r[3] * (1.0 - (v * r[3]))) + r[3]\n-\tmpyf3\tr0, r3, r1\t; r1 = r[3] * v\n-\tsubrf\t1.0, r1\t\t; r1 = 1.0 - r[3] * v\n-\tmpyf\tr0, r1\t\t; r1 = r[3] * (1.0 - r[3] * v)\n-\taddf\tr1, r0\t\t; r0 = r[3] * (1.0 - r[3] * v) + r[3] = r[4]\n-\n-        rnd     r0              ; Minimize error in x[4]'s LSBs\n-\n-\tbud\tar1\t\t; Delayed branch\n-\n-        .if .REGPARM == 0\n-        ldfu    *-ar0(1), r2    ; Dividend in mem has only 24 bits significance\n-        .else\n-        rnd     r2              ; Minimize error in reg dividend's LSBs\n-\t\t\t\t; since this may have 32 bit significance\n-        .endif\n-\n-        mpyf    r2, r0          ; Multiply by the dividend\n-        rnd     r0              ; Round result to 32 bits\n-\n-\t; Branch occurs here\n-#endif\n-\n-#endif\n-;\n-; Integer signed division\n-;\n-; ar2 dividend, r2 divisor, r0 quotient\n-; clobbers r1, r3, ar0, ar1, ir0, ir1, rc, rs, re\n-#ifdef L_divsi3\n-\t.text\n-\t.global ___divqi3\n-\t.ref\tudivqi3n\n-___divqi3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-\txor3\tar2, r2, r3\t; Get the sign\n-\tabsi\tar2, r0\n-\tbvd\tdivq32\n-\tldi\tr0, ar2\n-\tabsi\tr2, r2\n-\tcmpi\tar2, r2\t\t; Divisor > dividend?\n-\n-\tpop\tir1\n-\tbhid\tzero\t\t; If so, return 0\n-\n-;\n-; Normalize oeprands.  Use difference exponents as shift count\n-; for divisor, and as repeat count for \"subc\"\n-;\n-\tfloat\tar2, r1\t\t; Normalize dividend\n-\tpushf\tr1\t\t; Get as integer\n-\tpop\tar0\n-\tlsh\t-24, ar0\t; Get exponent\n-\t\n-\tfloat\tr2, r1\t\t; Normalize divisor\n-\tpushf\tr1\t\t; Get as integer\n-\tpop\tir0\n-\tlsh\t-24, ir0\t; Get exponent\n-\n-\tsubi\tir0, ar0\t; Get difference of exponents\n-\tlsh\tar0, r2\t\t; Align divisor with dividend\n-\n-;\n-; Do count + 1 subtracts and shifts\n-;\n-\trpts\tar0\n-\t\tsubc\tr2, ar2\n-\n-;\n-; Mask off the lower count+1 bits of ar2\n-;\n-\tsubri\t31, ar0\t\t; Shift count is (32 - (ar0 + 1))\n-\tlsh\tar0, ar2\t; Shift left\n-\tnegi\tar0, ar0\n-\tlsh3\tar0, ar2, r0\t; Shift right and put result in r0\n-\n-;\n-; Check sign and negate result if necessary\n-;\n-\tbud\tir1\t\t; Delayed return\n-\tnegi\tr0, r1\t\t; Negate result\n-\tash\t-31, r3\t\t; Check sign\n-\tldinz\tr1, r0\t\t; If set, use negative result\n-\t; Branch occurs here\n-\n-zero:\tbud\tir1\t\t; Delayed branch\n-\tldi\t0, r0\n-\tnop\n-\tnop\n-\t; Branch occurs here\n-;\n-; special case where ar2 = abs(ar2) = 0x80000000.  We handle this by\n-; calling unsigned divide and negating the result if necessary.\n-;\n-divq32:\n-\tpush\tr3\t\t; Save sign\n-\tcall\tudivqi3n\n-\tpop\tr3\n-\tpop\tir1\n-\tbd\tir1\n-\tnegi\tr0, r1\t\t; Negate result\n-\tash\t-31, r3\t\t; Check sign\n-\tldinz\tr1, r0\t\t; If set, use negative result\n-\t; Branch occurs here\n-#endif\n-;\n-;\n-; ar2 dividend, r2 divisor, r0 quotient, \n-; clobbers r1, r3, ar0, ar1, ir0, ir1, rc, rs, re\n-#ifdef L_udivsi3\n-\t.text\n-\t.global ___udivqi3\n-\t.global udivqi3n\n-___udivqi3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-udivqi3n:\n-\tpop\tir1\n-\n-\tcmpi\tar2, r2\t\t; If divisor > dividend\n-\tbhi\tqzero\t\t; return zero\n-\tldi\tr2, ar1\t\t; Store divisor in ar1\n-\n-\ttstb\tar2, ar2\t; Check top bit, jump if set to special handler\n-\tbld\tdiv_32\t\t; Delayed branch\n-\n-;\n-; Get divisor exponent\n-;\n-\tfloat\tar1, r1\t\t; Normalize the divisor\n-\tpushf\tr1\t\t; Get into int register\n-\tpop\trc\n-\t; branch occurs here\n-\n-\tbzd\tqzero\t\t; if (float) divisor zero, return zero\n-\n-\tfloat\tar2, r1\t\t; Normalize the dividend\n-\tpushf\tr1\t\t; Get into int register\n-\tpop\tar0\n-\tlsh\t-24, ar0\t; Get both the exponents\n-\tlsh\t-24, rc\n-\n-\tsubi\trc, ar0\t\t; Get the difference between the exponents\n-\tlsh\tar0, ar1\t; Normalize the divisor with the dividend\n-\n-;\n-; Do count_1 subtracts and shifts\n-;\n-\trpts\tar0\n-\t\tsubc\tar1, ar2\n-\n-;\n-; mask off the lower count+1 bits\n-;\n-\tsubri\t31, ar0\t\t; Shift count (31 - (ar0+1))\n-\tbud\tir1\t\t; Delayed return\n-\tlsh3\tar0, ar2, r0\n-\tnegi\tar0, ar0\n-\tlsh\tar0, r0\n-\t; Branch occurs here\n-\n-;\n-; Handle a full 32-bit dividend\n-;\n-div_32:\ttstb\tar1, ar1\n-\tbld\tqone\t\t; if divisor high bit is one, the result is one\n-\tlsh\t-24, rc\n-\tsubri\t31, rc\n-\tlsh\trc, ar1\t\t; Line up the divisor\n-\n-;\n-; Now divisor and dividend are aligned.  Do first SUBC by hand, save\n-; of the forst quotient digit.  Then, shift divisor right rather\n-; than shifting dividend left.  This leaves a zero in the top bit of\n-; the dividend\n-;\n-\tldi\t1, ar0\t\t; Initizialize MSB of quotient\n-\tlsh\trc, ar0\t\t; create a mask for MSBs\n-\tsubi\t1, ar0\t\t; mask is (2 << count) - 1\n-\n-\tsubi3\tar1, ar2, r1\n-\tldihs\tr1, ar2\n-\tldihs\t1, r1\n-\tldilo\t0, r1\n-\tlsh\trc, r1\n-\n-\tlsh\t-1, ar1\n-\tsubi\t1, rc\n-;\n-; do the rest of the shifts and subtracts\n-;\n-\trpts\trc\n-\t\tsubc\tar1, ar2\n-\n-\tbud\tir1\n-\tand\tar0, ar2\n-\tor3\tr1, ar2, r0\n-\tnop\n-\n-qone:\n-\tbud\tir1\n-\tldi\t1, r0\n-\tnop\n-\tnop\n-\n-qzero:\n-\tbud\tir1\n-\tldi\t0, r0\n-\tnop\n-\tnop\n-#endif\n-\n-#ifdef L_umodsi3\n-\t.text\n-\t.global\t___umodqi3\n-\t.global\tumodqi3n\n-___umodqi3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-umodqi3n:\n-\tpop     ir1\t\t; return address\n-        cmpi    ar2, r2\t\t; divisor > dividend ? \n-\tbhi     uzero\t\t;    if so, return dividend\n-\tldi     r2, ar1\t\t; load divisor\n-;\n-; If top bit of dividend is set, handle specially.\n-;\n-        tstb    ar2, ar2\t; check top bit\n-\tbld     umod_32\t\t; get divisor exponent, then jump.\n-;\n-; Get divisor exponent by converting to float.\n-;\n-\tfloat   ar1, r1\t\t; normalize divisor\n-\tpushf   r1\t\t; push as float\n-\tpop     rc\t\t; pop as int to get exponent\n-        bzd     uzero\t\t; if (float)divisor was zero, return\n-;\n-; 31 or less bits in dividend.  Get dividend exponent.\n-;\n-        float   ar2, r1\t\t; normalize dividend\n-\tpushf   r1\t\t; push as float\n-\tpop     ar0\t\t; pop as int to get exponent\n-;\n-; Use difference in exponents as shift count to line up MSBs.\n-;\n-\tlsh     -24, rc\t\t; divisor exponent\n-\tlsh     -24, ar0\t; dividend exponent\n-\tsubi    rc, ar0\t\t; difference\n-        lsh     ar0, ar1\t; shift divisor up\n-; \n-; Do COUNT+1 subtract & shifts.\n-;\n-\trpts    ar0\n-\t\tsubc    ar1, ar2  \n-;\n-;  Remainder is in upper 31-COUNT bits.\n-;\n-\tbud     ir1\t\t; delayed branch to return\n-\taddi    1, ar0\t\t; shift count is COUNT+1\n-\tnegi    ar0, ar0\t; negate for right shift\n-\tlsh3    ar0, ar2, r0\t; shift to get result\n-\t; Return occurs here\n-\n-;\n-; The following code handles cases of a full 32-bit dividend.  Before\n-; SUBC can be used, the top bit must be cleared (otherwise SUBC can\n-; possibly shift a significant 1 out the top of the dividend).  This\n-; is accomplished by first doing a normal subtraction, then proceeding\n-; with SUBCs. \n-;\n-umod_32:\n-;\n-; If the top bit of the divisor is set too, the remainder is simply\n-; the difference between the dividend and divisor.  Otherwise, shift \n-; the divisor up to line up the MSBs.\n-;\n-\ttstb    ar1, ar1\t; check divisor\n-\tbld     uone\t\t; if negative, remainder is diff\n-\n-\tlsh     -24, rc\t\t; divisor exponent\n-\tsubri   31, rc\t\t; shift count = 31 - exp\n-\tnegi    rc, ar0\t\t; used later as shift count\n-\tlsh     rc, ar1\t\t; shift up to line up MSBs\n-;\n-; Now MSBs are aligned.  Do first SUBC by hand using a plain subtraction.\n-; Then, shift divisor right rather than shifting dividend left.  This leaves\n-; a 0 in the top bit of the dividend.\n-;\n-\tsubi3   ar1, ar2, r1\t; subtract \n-\tldihs   r1, ar2\t\t; if positive, replace dividend\n-\tsubi    1, rc\t\t; first iteration is done\n-\tlsh     -1, ar1\t\t; shift divisor down\n-; \n-; Do EXP subtract & shifts.\n-;\n-\trpts    rc  \n-\t\tsubc    ar1, ar2   \n-;\n-;  Quotient is in EXP+1 LSBs; shift remainder (in MSBs) down.\n-;\n-\tbud\tir1\n-\tlsh3    ar0, ar2, r0\t; COUNT contains -(EXP+1)\n-\tnop\n-\tnop\n-;\n-;  Return (dividend - divisor).\n-;\n-uone:\tbud\tir1\n-\tsubi3   r2, ar2, r0  \n-\tnop\n-\tnop\n-;\n-;  Return dividend.\n-;\n-uzero:\tbud\tir1\n-\tldi     ar2, r0\t\t; set status from result\n-\tnop\n-\tnop\n-#endif\n-\n-#ifdef L_modsi3\n-\t.text\n-\t.global\t___modqi3\n-\t.ref umodqi3n\n-___modqi3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-; \n-; Determine sign of result.  Get absolute value of operands.\n-; \n-\tldi     ar2, ar0\t; sign of result same as dividend\n-\tabsi    ar2, r0\t\t; make dividend positive\n-\tbvd     mod_32\t\t; if still negative, escape\n-\tabsi    r2, r1\t\t; make divisor positive\n-\tldi     r1, ar1\t\t; save in ar1       \n-        cmpi    r0, ar1\t\t; divisor > dividend ? \n-\n-        pop     ir1            ; return address\n-\tbhid    return \t\t;   if so, return dividend\n-; \n-; Normalize operands.  Use difference in exponents as shift count\n-; for divisor, and as repeat count for SUBC.\n-;\n-        float   r1, r1\t\t; normalize divisor\n-        pushf   r1\t\t; push as float \n-\tpop     rc\t\t; pop as int\n-        bzd     return\t\t; if (float)divisor was zero, return\n-\n-        float   r0, r1\t\t; normalize dividend\n-        pushf   r1\t\t; push as float\n-        pop     r1\t\t; pop as int \n-\n-\tlsh     -24, rc\t\t; get divisor exponent\n-\tlsh     -24, r1\t\t; get dividend exponent\n-\tsubi    rc, r1\t\t; get difference in exponents\n-\tlsh     r1, ar1\t\t; align divisor with dividend\n-; \n-; Do COUNT+1 subtract & shifts.\n-;\n-\trpts    r1\n-\t\tsubc    ar1, r0\n-;\n-;  Remainder is in upper bits of R0\n-;\n-\taddi    1, r1\t\t; shift count is -(r1+1)\n-\tnegi    r1, r1 \n-\tlsh     r1, r0\t\t; shift right\n-;\n-;  Check sign and negate result if necessary.\n-;\n-return:\n-\tbud     ir1\t\t; delayed branch to return\n-        negi    r0, r1\t\t; negate result\n-\tcmpi    0, ar0\t\t; check sign\n-\tldin    r1, r0\t\t; if set, use negative result\n-\t; Return occurs here\n-;\n-; The following code handles cases of a full 32-bit dividend.  This occurs\n-; when R0 = abs(R0) = 080000000h.  Handle this by calling the unsigned mod\n-; function, then negating the result if necessary.\n-;\n-mod_32:\n-        push    ar0\t\t; remember sign\n-\tcall    umodqi3n\t; do divide\n-\n-\tbrd     return\t\t; return\n-\tpop     ar0\t\t; restore sign\n-        pop     ir1             ; return address\n-\tnop\n-#endif\n-\n-#ifdef L_unsfltconst\n-\t.section .const\n-        .global ___unsfltconst\n-___unsfltconst:   .float 4294967296.0\n-#endif\n-\n-#ifdef L_unsfltcompare\n-\t.section .const\n-        .global ___unsfltcompare\n-___unsfltcompare: .float 2147483648.0\n-#endif\n-\n-; Integer 32-bit signed multiplication\n-;\n-; The TMS320C3x MPYI instruction takes two 24-bit signed integers\n-; and produces a 48-bit signed result which is truncated to 32-bits.\n-;\n-; A 32-bit by 32-bit multiplication thus requires a number of steps.\n-;\n-; Consider the product of two 32-bit signed integers,\n-;\n-;\tz = x * y\n-;\n-; where x = (b << 16) + a,  y = (d << 16) + c\n-;\n-; This can be expressed as\n-;\n-;\tz = ((b << 16) + a) * ((d << 16) + c)\n-;\n-;          = ((b * d) << 32) + ((b * c + a * d) << 16) + a * c\n-;\n-; Let z = (f << 16) + e where f < (1 << 16).\n-;\n-; Since we are only interested in a 32-bit result, we can ignore the \n-; (b * d) << 32 term, and thus\n-;\n-;\tf = b * c + a * d,  e = a * c\n-;\n-; We can simplify things if we have some a priori knowledge of the\n-; operands, for example, if -32768 <= y <= 32767, then y = c and d = 0 and thus\n-;\n-;\tf = b * c,  e = a * c\n-;\n-; ar2 multiplier, r2 multiplicand, r0 product\n-; clobbers r1, r2, r3\n-#ifdef L_mulsi3\t\n-\t.text\n-\t.global\t___mulqi3\n-___mulqi3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-        pop     ir1\t\t; return address\n-\tldi\tar2, r0\t\t;\n-\tand\t0ffffh, r0\t; a\n-\tlsh\t-16, ar2\t; b\n-\tldi\tr2, r3\t\t; \n-\tand\t0ffffh, r3\t; c\n-\tmpyi\tr3, ar2\t\t; c * b\t\t\n-\tlsh\t-16, r2\t\t; d\n-\tmpyi\tr0, r2\t\t; a * d\n-\taddi\tar2, r2\t\t; c * b + a * d\n-\tbd\tir1\t\t; delayed branch to return\n-\tlsh\t16, r2\t\t; (c * b + a * d) << 16\n-\tmpyi\tr3, r0\t\t; a * c\n-\taddi\tr2, r0\t\t; a * c + (c * b + a * d) << 16\n-; branch occurs here\n-\n-#endif\t\n-\n-;\n-; Integer 64 by 64 multiply\n-; long1 and long2 on stack\n-; result in r0,r1\n-;\n-#ifdef L_muldi3\n-\t.text\n-\t.global\t___mulhi3\n-#ifdef _TMS320C4x\n-___mulhi3:\n-\tpop\tar0\n-\tldi\tsp,ar2\n-\tldi\t*-ar2(1),r2\n-\tldi\t*-ar2(3),r3\n-\tmpyi3\tr2,r3,r0\n-\tmpyuhi3\tr2,r3,r1\n-\tmpyi\t*-ar2(2),r2\n-\tbd\tar0\n-\tmpyi\t*-ar2(0),r3\n-\taddi\tr2,r1\n-\taddi\tr3,r1\n-#else\n-___mulhi3:\n-\tldi\tsp,ar2\n-\tldi\t-16,rs\n-\tldi\t*-ar2(2),ar0\n-\tldi\t*-ar2(4),ar1\n-\tldi\tar0,r2\n-\tand\t0ffffh,r2\n-\tldi\tar1,r3\n-\tand\t0ffffh,r3\n-\tlsh\trs,ar0\n-\tlsh\trs,ar1\n-\n-\tmpyi\tr2,r3,r0\n-\tmpyi\tar0,ar1,r1\n-\tmpyi\tr2,ar1,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r1\n-\tlsh\t16,rc\n-\taddi\trc,r0\n-\taddc\t0,r1\n-\tmpyi\tr3,ar0,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r1\n-\tlsh\t16,rc\n-\taddi\trc,r0\n-\taddc\t0,r1\n-\n-\tldi\t*-ar2(1),ar0\n-\tldi\tar0,r2\n-\tand\t0ffffh,r2\n-\tlsh\trs,ar0\n-\tmpyi\tr2,r3,rc\n-\taddi\trc,r1\n-\tmpyi\tr2,ar1,rc\n-\tmpyi\tr3,ar0,re\n-\taddi\tre,rc\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-\n-\tldi\t*-ar2(2),ar0\n-\tldi\t*-ar2(3),ar1\n-\tldi\tar0,r2\n-\tand\t0ffffh,r2\n-\tldi\tar1,r3\n-\tand\t0ffffh,r3\n-\tlsh\trs,ar0\n-\tlsh\trs,ar1\n-\tmpyi\tr2,r3,rc\n-\taddi\trc,r1\n-\tmpyi\tr2,ar1,rc\n-\tmpyi\tr3,ar0,re\n-\tpop\tar0\n-\tbd\tar0\n-\taddi\tre,rc\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-#endif\n-#endif\n-\n-;\n-; Integer 32 by 32 multiply highpart unsigned\n-; src1 in ar2\n-; src2 in r2\n-; result in r0\n-;\n-#ifdef L_umuldi3_high\n-\t.text\n-\t.global\t___umulhi3_high\n-___umulhi3_high:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-\tldi\t-16,rs\n-\tldi\tr2,r3\n-\tand\t0ffffh,r2\n-\tldi\tar2,ar1\n-\tand\t0ffffh,ar2\n-\tlsh\trs,r3\n-\tlsh\trs,ar1\n-\n-\tmpyi\tar2,r2,r1\n-\tmpyi\tar1,r3,r0\n-\tmpyi\tar2,r3,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r0\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-\taddc\t0,r0\n-\tmpyi\tr2,ar1,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r0\n-\tpop\tar0\n-\tbd\tar0\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-\taddc\t0,r0\n-#endif\n-\n-;\n-; Integer 32 by 32 multiply highpart signed\n-; src1 in ar2\n-; src2 in r2\n-; result in r0\n-;\n-#ifdef L_smuldi3_high\n-\t.text\n-\t.global\t___smulhi3_high\n-___smulhi3_high:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\tldi\t*-ar0(2), r2\n-\t.endif\n-\n-\tldi\t-16,rs\n-\tldi\t0,rc\n-\tsubi3\tar2,rc,r0\n-\tldi\tr2,r3\n-\tldilt\tr0,rc\n-\tsubi3\tr2,rc,r0\n-\tldi\tar2,ar1\n-\ttstb\tar1,ar1\n-\tldilt\tr0,rc\n-\tand\t0ffffh,r2\n-\tand\t0ffffh,ar2\n-\tlsh\trs,r3\n-\tlsh\trs,ar1\n-\n-\tmpyi\tar2,r2,r1\n-\tmpyi\tar1,r3,r0\n-\taddi\trc,r0\n-\tmpyi\tar2,r3,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r0\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-\taddc\t0,r0\n-\tmpyi\tr2,ar1,rc\n-\tlsh\trs,rc,re\n-\taddi\tre,r0\n-\tpop\tar0\n-\tbd\tar0\n-\tlsh\t16,rc\n-\taddi\trc,r1\n-\taddc\t0,r0\n-#endif\n-\n-;\n-; Integer 64 by 64 unsigned divide\n-; long1 and long2 on stack\n-; divide in r0,r1\n-; modulo in r2,r3\n-; routine takes a maximum of 64*8+23=535 cycles = 21.4 us @ 50Mhz\n-;\n-#ifdef L_udivdi3\n-\t.text\n-\t.global\t___udivhi3\n-\t.global\t___udivide\n-\t.global\t___umodulo\n-\t.ref udivqi3n\n-\t.ref umodqi3n\n-___udivhi3:\n-\tldi\tsp,ar2\n-\tldi     *-ar2(4),ar0\n-\tldi     *-ar2(3),ar1\n-\tldi     *-ar2(2),r0\n-\tldi     *-ar2(1),r1\n-\n-___udivide:\n-\tor\tr1,ar1,r2\n-\tbne\tudiv0\n-\tldi\tar0,r2\n-\tldi\tr0,ar2\n-\tcall\tudivqi3n\n-\tldiu\t0,r1\n-\trets\n-\n-___umodulo:\n-\tor\tr1,ar1,r2\n-\tbne\tudiv0\n-\tldi\tar0,r2\n-\tldi\tr0,ar2\n-\tcall\tumodqi3n\n-\tldi\tr0,r2\n-\tldiu\t0,r3\n-\trets\n-\n-udiv0:\n-\ttstb\tar1,ar1\n-\tbne\tudiv1\n-\ttstb\tar0,ar0\n-\tbn\tudiv1\n-\n-\tldiu\t63,rc\n-#ifdef _TMS320C4x\n-\trptbd\tudivend0\n-\tldiu\t0,r2\n-\taddi\tr0,r0\n-\trolc\tr1\n-#else\n-\tldiu\t0,r2\n-\taddi\tr0,r0\n-\trolc\tr1\n-\trptb\tudivend0\n-#endif\n-\n-\trolc\tr2\n-\tsubi3\tar0,r2,r3\n-\tldinc\tr3,r2\n-\trolc\tr0\n-udivend0:\n-\trolc\tr1\n-\n-\tnot\tr0\n-\tnot\tr1\n-\tldiu\t0,r3\n-\trets\n-udiv1:\n-\tpush\tr4\n-\tpush\tr5\n-\tldiu\t63,rc\n-\tldiu\t0,r2\n-#ifdef _TMS320C4x\n-\trptbd\tudivend1\n-\tldiu\t0,r3\n-\taddi\tr0,r0\n-\trolc\tr1\n-#else\n-\tldiu\t0,r3\n-\taddi\tr0,r0\n-\trolc\tr1\n-\trptb\tudivend1\n-#endif\n-\n-\trolc\tr2\n-\trolc\tr3\n-\tsubi3\tar0,r2,r4\n-\tsubb3\tar1,r3,r5\n-\tldinc\tr4,r2\n-\tldinc\tr5,r3\n-\trolc\tr0\n-udivend1:\n-\trolc\tr1\n-\n-\tnot\tr0\n-\tnot\tr1\n-\tpop\tr5\n-\tpop\tr4\n-\trets\n-#endif\n-\n-;\n-; Integer 64 by 64 unsigned modulo\n-; long1 and long2 on stack\n-; result in r0,r1\n-;\n-#ifdef L_umoddi3\n-\t.text\n-\t.global\t___umodhi3\n-\t.ref ___modulo\n-___umodhi3:\n-\tldi\tsp,ar2\n-\tldi     *-ar2(4),ar0\n-\tldi     *-ar2(3),ar1\n-\tldi     *-ar2(2),r0\n-\tldi     *-ar2(1),r1\n-\tcall\t___umodulo\n-\tpop\tar0\n-\tbd\tar0\n-\tldi\tr2,r0\n-\tldi\tr3,r1\n-\tnop\n-#endif\n-\n-;\n-; Integer 64 by 64 signed divide\n-; long1 and long2 on stack\n-; result in r0,r1\n-;\n-#ifdef L_divdi3\n-\t.text\n-\t.global\t___divhi3\n-\t.ref ___udivide\n-___divhi3:\n-\tldi\t0,ir0\n-\tldi\tsp,ar2\n-\tldi     *-ar2(4),r0\n-\tldi     *-ar2(3),r1\n-\tbge\tdiv1\n-\tnot\tir0\n-\tnegi\tr0\n-\tnegb\tr1\n-div1:\n-\tldi\tr0,ar0\n-\tldi\tr1,ar1\n-\tldi     *-ar2(2),r0\n-\tldi     *-ar2(1),r1\n-\tbge\tdiv2\n-\tnot\tir0\n-\tnegi\tr0\n-\tnegb\tr1\n-div2:\n-\tcall\t___udivide\n-\ttstb\tir0,ir0\n-\tbge\tdiv3\n-\tnegi\tr0\n-\tnegb\tr1\n-div3:\t\n-\trets\n-#endif\n-\n-;\n-; Integer 64 by 64 signed modulo\n-; long1 and long2 on stack\n-; result in r0,r1\n-;\n-#ifdef L_moddi3\n-\t.text\n-\t.global\t___modhi3\n-\t.ref ___umodulo\n-___modhi3:\n-\tldi\t0,ir0\n-\tldi\tsp,ar2\n-\tldi     *-ar2(4),r0\n-\tldi     *-ar2(3),r1\n-\tbge\tmod1\n-\tnot\tir0\n-\tnegi\tr0\n-\tnegb\tr1\n-mod1:\n-\tldi\tr0,ar0\n-\tldi\tr1,ar1\n-\tldi     *-ar2(2),r0\n-\tldi     *-ar2(1),r1\n-\tbge\tmod2\n-\tnot\tir0\n-\tnegi\tr0\n-\tnegb\tr1\n-mod2:\n-\tcall\t___umodulo\n-\tldi\tr2,r0\n-\tldi\tr3,r1\n-\ttstb\tir0,ir0\n-\tbge\tmod3\n-\tnegi\tr0\n-\tnegb\tr1\n-mod3:\t\n-\trets\n-#endif\n-\n-;\n-; double to signed long long conversion\n-; input in r2\n-; result in r0,r1\n-;\n-#ifdef L_fix_truncsfdi2\n-\t.text\n-\t.global\t___fix_truncqfhi2\n-\t.ref ufix_truncqfhi2n\n-___fix_truncqfhi2:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(1), r2\n-\t.endif\n-\n-\tcmpf\t0.0,r2\n-\tbge\tufix_truncqfhi2n\n-\tnegf\tr2\n-\tcall\tufix_truncqfhi2n\n-\tnegi\tr0\n-\tnegb\tr1\n-\trets\n-#endif\n-\n-;\n-; double to unsigned long long conversion\n-; input in r2\n-; result in r0,r1\n-;\n-#ifdef L_ufix_truncsfdi2\n-\t.text\n-\t.global\t___ufix_truncqfhi2\n-\t.global\tufix_truncqfhi2n\n-___ufix_truncqfhi2:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(1), r2\n-\t.endif\n-\n-ufix_truncqfhi2n:\n-\tcmpf\t0.0,r2\n-\tble\tufix1\n-\tpushf\tr2\n-\tpop\tr3\n-\tash\t-24,r3\n-\tsubi\t31,r3\n-\tcmpi\t32,r3\n-\tbgt\tufix1\n-\tcmpi\t-32,r3\n-\tble\tufix1\n-\tldi\t1,r0\n-\tash\t31,r0\n-\tor3\tr0,r2,r0\n-\tldi\tr0,r1\n-\tlsh3\tr3,r0,r0\n-\tsubi\t32,r3\n-\tcmpi\t-32,r3\n-\tldile\t0,r1\n-\tlsh3\tr3,r1,r1\n-\trets\n-ufix1:\n-\tldi\t0,r0\n-\tldi\t0,r1\n-\trets\n-#endif\n-\n-;\n-; signed long long to double conversion\n-; input on stack\n-; result in r0\n-;\n-#ifdef L_floatdisf2\n-\t.text\n-\t.global\t___floathiqf2\n-\t.ref ufloathiqf2n\n-___floathiqf2:\n-\tldi\tsp,ar2\n-\tldi\t*-ar2(2),r0\n-\tldi\t*-ar2(1),r1\n-\tbge\tufloathiqf2n\n-\tnegi\tr0\n-\tnegb\tr1\n-\tcall\tufloathiqf2n\n-\tnegf\tr0\n-\trets\n-#endif\n-\n-;\n-; unsigned long long to double conversion\n-; input on stack\n-; result in r0\n-;\n-#ifdef L_ufloatdisf2\n-\t.text\n-\t.global\t___ufloathiqf2\n-\t.global\tufloathiqf2n\n-\t.ref ___unsfltconst\n-___ufloathiqf2:\n-\tldi\tsp,ar2\n-\tldi\t*-ar2(2),r0\n-\tldi\t*-ar2(1),r1\n-ufloathiqf2n:\n-\t.if .BIGMODEL\n-#ifdef _TMS320C4x\n-\tldpk\t@___unsfltconst\n-#else\n-\tldp\t@___unsfltconst\n-#endif\n-\t.endif\n-\tldf\t@___unsfltconst,r2\n-\tfloat\tr0\n-\tbge\tuflt1\n-\taddf\tr2,r0\n-uflt1:\n-\tfloat\tr1\n-\tbge\tuflt2\n-\taddf\tr2,r1\n-uflt2:\n-#ifdef _TMS320C4x\n-\tpop\tr3\n-\tbd\tr3\n-\tmpyf\tr2,r1\n-\taddf\tr1,r0\n-\tnop\n-#else\n-\tldf\tr1,r3\n-\tand\t0ffh,r3\n-\tnorm\tr3,r3\n-\tmpyf\tr2,r3\n-\tpop\tar2\n-\tbd\tar2\n-\taddf\tr3,r0\n-\tmpyf\tr2,r1\n-\taddf\tr1,r0\n-#endif\n-#endif\n-\n-;\n-; long double to signed long long conversion\n-; input in r2\n-; result in r0,r1\n-;\n-#ifdef L_fix_truncdfdi2\n-\t.text\n-\t.global\t___fix_trunchfhi2\n-\t.ref ufix_trunchfhi2n\n-___fix_trunchfhi2:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(2), r2\n-\tldi\t*-ar0(1), r2\n-\t.endif\n-\n-\tcmpf\t0.0,r2\n-\tbge\tufix_trunchfhi2n\n-\tnegf\tr2\n-\tcall\tufix_trunchfhi2n\n-\tnegi\tr0\n-\tnegb\tr1\n-\trets\n-#endif\n-\n-;\n-; long double to unsigned long long conversion\n-; input in r2\n-; result in r0,r1\n-;\n-#ifdef L_ufix_truncdfdi2\n-\t.text\n-\t.global\t___ufix_trunchfhi2\n-\t.global\tufix_trunchfhi2n\n-___ufix_trunchfhi2:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(2), r2\n-\tldi\t*-ar0(1), r2\n-\t.endif\n-\n-ufix_trunchfhi2n:\n-\tcmpf\t0.0,r2\n-\tble\tufixh1\n-\tpushf\tr2\n-\tpop\tr3\n-\tash\t-24,r3\n-\tsubi\t31,r3\n-\tcmpi\t32,r3\n-\tbgt\tufixh1\n-\tcmpi\t-32,r3\n-\tble\tufixh1\n-\tldi\t1,r0\n-\tash\t31,r0\n-\tor3\tr0,r2,r0\n-\tldi\tr0,r1\n-\tlsh3\tr3,r0,r0\n-\tsubi\t32,r3\n-\tcmpi\t-32,r3\n-\tldile\t0,r1\n-\tlsh3\tr3,r1,r1\n-\trets\n-ufixh1:\n-\tldi\t0,r0\n-\tldi\t0,r1\n-\trets\n-#endif\n-\n-;\n-; signed long long to long double conversion\n-; input on stack\n-; result in r0\n-;\n-#ifdef L_floatdidf2\n-\t.text\n-\t.global\t___floathihf2\n-\t.ref ufloathihf2n\n-___floathihf2:\n-\tldi\tsp,ar2\n-\tldi\t*-ar2(2),r0\n-\tldi\t*-ar2(1),r1\n-\tbge\tufloathihf2n\n-\tnegi\tr0\n-\tnegb\tr1\n-\tcall\tufloathihf2n\n-\tnegf\tr0\n-\trets\n-#endif\n-\n-;\n-; unsigned long long to double conversion\n-; input on stack\n-; result in r0\n-;\n-#ifdef L_ufloatdidf2\n-\t.text\n-\t.global\t___ufloathihf2\n-\t.global\tufloathihf2n\n-\t.ref ___unsfltconst\n-___ufloathihf2:\n-\tldi\tsp,ar2\n-\tldi\t*-ar2(2),r0\n-\tldi\t*-ar2(1),r1\n-ufloathihf2n\n-\t.if .BIGMODEL\n-#ifdef _TMS320C4x\n-\tldpk\t@___unsfltconst\n-#else\n-\tldp\t@___unsfltconst\n-#endif\n-\t.endif\n-\tldf\t@___unsfltconst,r2\n-\tfloat\tr0\n-\tbge\tuflth1\n-\taddf\tr2,r0\n-uflth1:\n-\tfloat\tr1\n-\tbge\tuflth2\n-\taddf\tr2,r1\n-uflth2:\n-#ifdef _TMS320C4x\n-\tpop\tr3\n-\tbd\tr3\n-\tmpyf\tr2,r1\n-\taddf\tr1,r0\n-\tnop\n-#else\n-\tldf\tr1,r3\n-\tand\t0ffh,r3\n-\tnorm\tr3,r3\n-\tmpyf\tr2,r3\n-\tpop\tar2\n-\tbd\tar2\n-\taddf\tr3,r0\n-\tmpyf\tr2,r1\n-\taddf\tr1,r0\n-#endif\n-#endif\n-\n-;\n-; calculate ffs\n-; input in ar2\n-; result in r0\n-;\n-#ifdef L_ffs\n-\t.global\t___ffs\n-\t.ref ___unsfltconst\n-\t.text\n-___ffs:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldi\t*-ar0(1), ar2\n-\t.endif\n-\n-\tnegi\tar2,r0\n-\tand\tar2,r0\n-\tfloat\tr0,r0\n-\tldfu\t0.0,r1\n-\t.if .BIGMODEL\n-#ifdef _TMS320C4x\n-\tldpk\t@___unsfltconst\n-#else\n-\tldp\t@___unsfltconst\n-#endif\n-\t.endif\n-\tldflt\t@___unsfltconst,r1\n-\taddf\tr1,r0\n-\tpushf\tr0\n-\tpop\tr0\n-\tpop\tar0\n-\tbd\tar0\n-\tash\t-24,r0\n-\tldilt\t-1,r0\n-\taddi\t1,r0\n-#endif\n-\n-;\n-; calculate long double * long double\n-; input in r2, r3\n-; output in r0\n-;\n-#ifdef L_muldf3\n-\t.global ___mulhf3\n-\t.text\n-___mulhf3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(2), r2\n-\tldi\t*-ar0(1), r2\n-\tldf\t*-ar0(4), r3\n-\tldi\t*-ar0(3), r3\n-\t.endif\n-\n-\tpop\tar2\t\t; return ad\n-\tldf\tr2,r0\t\t; copy lsb0\n-\tldf\tr3,r1\t\t; copy lsb1\n-\tand\t0ffh,r0\t\t; mask lsb0\n-\tand\t0ffh,r1\t\t; mask lsb1\n-\tnorm\tr0,r0\t\t; correct lsb0\n-\tnorm\tr1,r1\t\t; correct lsb1\n-\tmpyf\tr2,r1\t\t; arg0*lsb1\n-\tmpyf\tr3,r0\t\t; arg1*lsb0\n-\tbd\tar2\t\t; return (delayed)\n-\taddf\tr0,r1\t\t; arg0*lsb1 + arg1*lsb0\n-\tmpyf\tr2,r3,r0\t; msb0*msb1\n-\taddf\tr1,r0\t\t; msb0*msb1 + arg0*lsb1 + arg1*lsb0\n-#endif\n-\n-;\n-; calculate long double / long double\n-; r2 dividend, r3 divisor, r0 quotient\n-;\n-#ifdef L_divdf3\n-\t.global ___divhf3\n-\t.text\n-___divhf3:\n-\t.if .REGPARM == 0\n-#ifdef _TMS320C4x\n-\tlda\tsp,ar0\n-#else\n-\tldiu\tsp,ar0\n-#endif\n-\tldf\t*-ar0(2), r2\n-\tldi\t*-ar0(1), r2\n-\tldf\t*-ar0(4), r3\n-\tldi\t*-ar0(3), r3\n-\t.endif\n-\n-#ifdef _TMS320C4x\n-\tpop\tar1\n-        rcpf    r3, r0\n-\tmpyf3\tr0, r3, r1\n-\tsubrf\t2.0, r1\t\t\n-\tmpyf\tr1, r0\t\n-\tmpyf3\tr0, r3, r1\n-\tbud\tar1\n-\tsubrf\t2.0, r1\t\n-\tmpyf\tr1, r0\n-\tmpyf\tr2, r0\n-#else\n-\tpop\tar1\n-\tpushf\tr3\n-\tpop\tr0\n-\tnot\tr0\t\n-\tpush\tr0\n-\tpopf\tr0\n-\tldf\t-1.0, r1\n-\txor\tr1, r0\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[0] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[0] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[0] * (2.0 - r[0] * v) = r[1]\n-; End of 1st iteration\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[1] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[1] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[1] * (2.0 - r[1] * v) = r[2]\n-; End of 2nd iteration\n-\n-\tmpyf3\tr0, r3, r1\t; r1 = r[2] * v\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[2] * v\n-\tmpyf\tr1, r0\t\t; r0 = r[2] * (2.0 - r[2] * v) = r[3]\n-; End of 3rd iteration\n-\n-\tor\t080h, r0\n-\trnd\tr0\n-\n-;\tmpyf3\tr0, r3, r1\t; r1 = r[3] * v\n-\tpush\tr4\n-\tpushf\tr4\n-\tmpyf\tr0, r3, r1\n-\n-\tldf\tr0, r4\n-\tand\t0ffh, r4\n-\tnorm\tr4, r4\n-\tmpyf\tr3, r4\n-\taddf\tr4, r1\n-\n-\tldf\tr3, r4\n-\tand\t0ffh, r4\n-\tnorm \tr4, r4\n-\tmpyf\tr0, r4\n-\taddf\tr4, r1\n-\t\n-\tsubrf\t2.0, r1\t\t; r1 = 2.0 - r[3] * v\n-\n-\tmpyf\tr1, r0, r3\t; r3 = r[3] * (2.0 - r[3] * v) = r[5]\n-\n-\tldf\tr1, r4\n-\tand\t0ffh, r4\n-\tnorm\tr4, r4\n-\tmpyf\tr0, r4\n-\taddf\tr4, r3\n-\n-\tldf\tr0, r4\n-\tand\t0ffh, r4\n-\tnorm \tr4, r4\n-\tmpyf\tr1, r4\n-\taddf\tr4, r3\n-\n-\tmpyf\tr2, r3, r0\t; Multiply by the dividend\n-\n-\tldf\tr2, r4\n-\tand\t0ffh, r4\n-\tnorm\tr4, r4\n-\tmpyf\tr3, r4\n-\taddf\tr4, r0\n-\n-\tldf\tr3, r4\n-\tand\t0ffh, r4\n-\tnorm \tr4, r4\n-\tmpyf\tr2, r4\n-\tbd\tar1\n-\taddf\tr4, r0\n-\n-\tpopf\tr4\n-\tpop\tr4\n-#endif\n-#endif"}, {"sha": "a4e04d7a710454dd9d79288f820de1e54adcf901", "filename": "gcc/config/c4x/predicates.md", "status": "removed", "additions": 0, "deletions": 403, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fpredicates.md?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,403 +0,0 @@\n-;; Predicate definitions for TMS320C[34]x.\n-;; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; Nonzero if OP is a floating point value with value 0.0.\n-\n-(define_predicate \"fp_zero_operand\"\n-  (match_code \"const_double\")\n-{\n-  REAL_VALUE_TYPE r;\n-\n-  if (GET_CODE (op) != CONST_DOUBLE)\n-    return 0;\n-  REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-  return REAL_VALUES_EQUAL (r, dconst0);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"const_operand\"\n-  (match_code \"const_int,const_double\")\n-{\n-  switch (mode)\n-    {\n-    case QFmode:\n-    case HFmode:\n-      if (GET_CODE (op) != CONST_DOUBLE\n-\t  || GET_MODE (op) != mode\n-\t  || GET_MODE_CLASS (mode) != MODE_FLOAT)\n-\treturn 0;\n-\n-      return c4x_immed_float_p (op);\n-\n-#if Pmode != QImode\n-    case Pmode:\n-#endif\n-    case QImode:\n-      if (GET_CODE (op) != CONST_INT\n-\t  || (GET_MODE (op) != VOIDmode && GET_MODE (op) != mode)\n-\t  || GET_MODE_CLASS (mode) != MODE_INT)\n-\treturn 0;\n-\n-      return IS_HIGH_CONST (INTVAL (op)) || IS_INT16_CONST (INTVAL (op));\n-\n-    case HImode:\n-      return 0;\n-\n-    default:\n-      return 0;\n-    }\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"stik_const_operand\"\n-  (match_code \"const_int\")\n-{\n-  return c4x_K_constant (op);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"not_const_operand\"\n-  (match_code \"const_int\")\n-{\n-  return c4x_N_constant (op);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && GET_MODE (op) == QFmode)\n-    return 0;\n-  return register_operand (op, mode);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"reg_or_const_operand\"\n-  (match_code \"reg,subreg,const_int,const_double\")\n-{\n-  return reg_operand (op, mode) || const_operand (op, mode);\n-})\n-\n-;; Extended precision register R0-R1.\n-\n-(define_predicate \"r0r1_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R0R1_OR_PSEUDO_REG (op);\n-})\n-\n-;; Extended precision register R2-R3.\n-\n-(define_predicate \"r2r3_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_R2R3_OR_PSEUDO_REG (op);\n-})\n-\n-;; Low extended precision register R0-R7.\n-\n-(define_predicate \"ext_low_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_EXT_LOW_OR_PSEUDO_REG (op);\n-})\n-\n-;; Extended precision register.\n-\n-(define_predicate \"ext_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (! REG_P (op))\n-    return 0;\n-  return IS_EXT_OR_PSEUDO_REG (op);\n-})\n-\n-;; Standard precision register.\n-\n-(define_predicate \"std_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return REG_P (op) && IS_STD_OR_PSEUDO_REG (op);\n-})\n-\n-;; Standard precision or normal register.\n-\n-(define_predicate \"std_or_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (reload_in_progress)\n-    return std_reg_operand (op, mode);\n-  return reg_operand (op, mode);\n-})\n-\n-;; Address register.\n-\n-(define_predicate \"addr_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  return c4x_a_register (op);\n-})\n-\n-;; Index register.\n-\n-(define_predicate \"index_reg_operand\"\n-  (match_code \"reg,subreg\")\n-{\n-  if (! reg_operand (op, mode))\n-    return 0;\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  return c4x_x_register (op);\n-})\n-\n-;; DP register.\n-\n-(define_predicate \"dp_reg_operand\"\n-  (match_code \"reg\")\n-{\n-  return REG_P (op) && IS_DP_OR_PSEUDO_REG (op);\n-})\n-\n-;; SP register.\n-\n-(define_predicate \"sp_reg_operand\"\n-  (match_code \"reg\")\n-{\n-  return REG_P (op) && IS_SP_OR_PSEUDO_REG (op);\n-})\n-\n-;; ST register.\n-\n-(define_predicate \"st_reg_operand\"\n-  (match_code \"reg\")\n-{\n-  return REG_P (op) && IS_ST_OR_PSEUDO_REG (op);\n-})\n-\n-;; RC register.\n-\n-(define_predicate \"rc_reg_operand\"\n-  (match_code \"reg\")\n-{\n-  return REG_P (op) && IS_RC_OR_PSEUDO_REG (op);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"call_address_operand\"\n-  (match_code \"reg,symbol_ref,label_ref,const\")\n-{\n-  return (REG_P (op) || symbolic_address_operand (op, mode));\n-})\n-\n-;; Check dst operand of a move instruction.\n-\n-(define_predicate \"dst_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && mixed_subreg_operand (op, mode))\n-    return 0;\n-\n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n-  return nonimmediate_operand (op, mode);\n-})\n-\n-;; Check src operand of two operand arithmetic instructions.\n-\n-(define_predicate \"src_operand\"\n-  (match_code \"subreg,reg,mem,const_int,const_double\")\n-{\n-  if (GET_CODE (op) == SUBREG\n-      && mixed_subreg_operand (op, mode))\n-    return 0;\n-\n-  if (REG_P (op))\n-    return reg_operand (op, mode);\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return (mode == QImode || mode == Pmode || mode == HImode)\n-      && c4x_I_constant (op);\n-\n-  /* We don't like CONST_DOUBLE integers.  */\n-  if (GET_CODE (op) == CONST_DOUBLE)\n-    return c4x_H_constant (op);\n-\n-  /* Disallow symbolic addresses.  Only the predicate\n-     symbolic_address_operand will match these.  */\n-  if (GET_CODE (op) == SYMBOL_REF\n-      || GET_CODE (op) == LABEL_REF\n-      || GET_CODE (op) == CONST)\n-    return 0;\n-\n-  /* If TARGET_LOAD_DIRECT_MEMS is nonzero, disallow direct memory\n-     access to symbolic addresses.  These operands will get forced\n-     into a register and the movqi expander will generate a\n-     HIGH/LO_SUM pair if TARGET_EXPOSE_LDP is nonzero.  */\n-  if (GET_CODE (op) == MEM\n-      && ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t   || GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t   || GET_CODE (XEXP (op, 0)) == CONST)))\n-    return !TARGET_EXPOSE_LDP &&\n-      ! TARGET_LOAD_DIRECT_MEMS && GET_MODE (op) == mode;\n-\n-  return general_operand (op, mode);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"src_hi_operand\"\n-  (match_code \"subreg,reg,mem,const_double\")\n-{\n-  if (c4x_O_constant (op))\n-    return 1;\n-  return src_operand (op, mode);\n-})\n-\n-;; Check src operand of two operand logical instructions.\n-\n-(define_predicate \"lsrc_operand\"\n-  (match_code \"subreg,reg,mem,const_int,const_double\")\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode != QImode && mode != Pmode)\n-    fatal_insn (\"mode not QImode\", op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return c4x_L_constant (op) || c4x_J_constant (op);\n-\n-  return src_operand (op, mode);\n-})\n-\n-;; Check src operand of two operand tricky instructions.\n-\n-(define_predicate \"tsrc_operand\"\n-  (match_code \"subreg,reg,mem,const_int,const_double\")\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode != QImode && mode != Pmode)\n-    fatal_insn (\"mode not QImode\", op);\n-\n-  if (GET_CODE (op) == CONST_INT)\n-    return c4x_L_constant (op) || c4x_N_constant (op) || c4x_J_constant (op);\n-\n-  return src_operand (op, mode);\n-})\n-\n-;; Check src operand of two operand non immediate instructions.\n-\n-(define_predicate \"nonimmediate_src_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n-    return 0;\n-\n-  return src_operand (op, mode);\n-})\n-\n-;; Check logical src operand of two operand non immediate instructions.\n-\n-(define_predicate \"nonimmediate_lsrc_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE)\n-    return 0;\n-\n-  return lsrc_operand (op, mode);\n-})\n-\n-;; Match any operand.\n-\n-(define_predicate \"any_operand\"\n-  (match_code \"subreg,reg,mem,const_int,const_double\")\n-{\n-  return 1;\n-})\n-\n-;; Check for indirect operands allowable in parallel instruction.\n-\n-(define_predicate \"par_ind_operand\"\n-  (match_code \"mem\")\n-{\n-  if (mode != VOIDmode && mode != GET_MODE (op))\n-    return 0;\n-\n-  return c4x_S_indirect (op);\n-})\n-\n-;; Check for operands allowable in parallel instruction.\n-\n-(define_predicate \"parallel_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  return ext_low_reg_operand (op, mode) || par_ind_operand (op, mode);\n-})\n-\n-;; Symbolic address operand.\n-\n-(define_predicate \"symbolic_address_operand\"\n-  (match_code \"symbol_ref,label_ref,const\")\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-})"}, {"sha": "ea44707e2f2d8fdc903ec4c4acbed0c1f574ec5b", "filename": "gcc/config/c4x/rtems.h", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Frtems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Frtems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Frtems.h?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,28 +0,0 @@\n-/* Definitions of RTEMS executing on an TMS320C[34]x using coff\n-   Copyright (C) 1996, 1997, 1999, 2002, 2007 Free Software Foundation, Inc.\n-   Contributed by Joel Sherrill (joel@OARcorp.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Specify predefined symbols in preprocessor.  */\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tbuiltin_define (\"__rtems__\");\t\t\\\n-\tbuiltin_define (\"__USE_INIT_FINI__\");\t\\\n-\tbuiltin_assert (\"system=rtems\");\t\\\n-    } while (0)"}, {"sha": "befadccc39ec6682445150a6f26ade26c0935755", "filename": "gcc/config/c4x/t-c4x", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Ft-c4x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Ft-c4x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Ft-c4x?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,20 +0,0 @@\n-LIB1ASMSRC = c4x/libgcc.S\n-LIB1ASMFUNCS = _divsf3 _divsi3 _udivsi3 _umodsi3 _modsi3 _mulsi3 \\\n-\t_muldf3 _divdf3 _unsfltconst _unsfltcompare \\\n-\t_muldi3 _umuldi3_high _smuldi3_high _divdi3 _moddi3 _umoddi3 _udivdi3 \\\n-\t_fix_truncsfdi2 _ufix_truncsfdi2 _floatdisf2 _ufloatdisf2 \\\n-\t_floatdidf2 _ufloatdidf2 _fix_truncdfdi2 _ufix_truncdfdi2 _ffs\n-\n-TARGET_LIBGCC2_CFLAGS = -Dexit=unused_exit\n-\n-c4x-c.o: $(srcdir)/config/c4x/c4x-c.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-  $(TM_H) $(TREE_H) toplev.h $(CPPLIB_H) c-pragma.h $(TM_P_H) \n-\t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(srcdir)/config/c4x/c4x-c.c\n-\n-MULTILIB_OPTIONS = m30 msmall mmemparm\n-MULTILIB_DIRNAMES = c3x small mem\n-MULTILIB_MATCHES = m30=mcpu?30 m30=mcpu?31 m30=mcpu?32 m30=mcpu?33 m30=m31 m30=m32 m30=m33\n-MULTILIB_EXCEPTIONS =\n-MULTILIB_EXTRA_OPTS =\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib"}, {"sha": "52dc7eaf3a383d888352f3b21f345393a9756194", "filename": "gcc/config/c4x/t-rtems", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Ft-rtems", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d555e263297673f544484d6f9dd82ee50958bd7/gcc%2Fconfig%2Fc4x%2Ft-rtems", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Ft-rtems?ref=1d555e263297673f544484d6f9dd82ee50958bd7", "patch": "@@ -1,10 +0,0 @@\n-# Custom RTEMS multilibs\n-\n-# We'd actually want to support -msmall, but it trips a bug in gcc\n-# http://gcc.gnu.org/bugzilla/show_bug.cgi?id=14436\n-#\n-# MULTILIB_OPTIONS = m30 msmall mmemparm\n-# MULTILIB_DIRNAMES = c3x small mem\n-\n-MULTILIB_OPTIONS = m30 mmemparm\n-MULTILIB_DIRNAMES = c3x mem"}, {"sha": "ef2dcb7698139357b79f16afeb80a89707b80fe5", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of various defaults for tm.h macros.\n    Copyright (C) 1992, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-   2005, 2007\n+   2005, 2007, 2008\n    Free Software Foundation, Inc.\n    Contributed by Ron Guilmette (rfg@monkeys.com)\n \n@@ -655,7 +655,6 @@ along with GCC; see the file COPYING3.  If not see\n #define UNKNOWN_FLOAT_FORMAT 0\n #define IEEE_FLOAT_FORMAT 1\n #define VAX_FLOAT_FORMAT 2\n-#define C4X_FLOAT_FORMAT 3\n \n /* Default to IEEE float if not specified.  Nearly all machines use it.  */\n #ifndef TARGET_FLOAT_FORMAT"}, {"sha": "73c823fa45ca0914b6f61aa77f033d0f8b8d2b75", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,5 +1,5 @@\n-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000,\n-@c 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,\n+@c 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n \n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n@@ -2336,7 +2336,7 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, C4x, CRX, M32C, M32R/D, m68k, MS1,\n+Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MS1,\n and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n@@ -2484,7 +2484,7 @@ defined by shared libraries.\n \n @item naked\n @cindex function without a prologue/epilogue code\n-Use this attribute on the ARM, AVR, C4x, IP2K and SPU ports to indicate that\n+Use this attribute on the ARM, AVR, IP2K and SPU ports to indicate that\n the specified function does not need prologue/epilogue sequences generated by\n the compiler.  It is up to the programmer to provide these sequences.\n \n@@ -10892,7 +10892,6 @@ Do not apply the @code{longcall} attribute to subsequent function\n declarations.\n @end table\n \n-@c Describe c4x pragmas here.\n @c Describe h8300 pragmas here.\n @c Describe sh pragmas here.\n @c Describe v850 pragmas here."}, {"sha": "65d203e195030d2f11e8277c1ca6d8b9c7145106", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -45,7 +45,7 @@\n @end ifset\n \n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-@c 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+@c 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n @c *** Converted to texinfo by Dean Wakerley, dean@wakerley.com\n \n @c IMPORTANT: whenever you modify this file, run `install.texi2html' to\n@@ -71,7 +71,7 @@\n @c Part 2 Summary Description and Copyright\n @copying\n Copyright @copyright{} 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n @sp 1\n Permission is granted to copy, distribute and/or modify this document\n under the terms of the GNU Free Documentation License, Version 1.2 or\n@@ -2492,8 +2492,6 @@ information are.\n @item\n @uref{#bfin,,Blackfin}\n @item\n-@uref{#c4x,,c4x}\n-@item\n @uref{#dos,,DOS}\n @item\n @uref{#x-x-freebsd,,*-*-freebsd*}\n@@ -2821,36 +2819,6 @@ See ``Blackfin Options'' in the main manual\n More information, and a version of binutils with support for this processor,\n is available at @uref{http://blackfin.uclinux.org}\n \n-@html\n-<hr />\n-@end html\n-@heading @anchor{c4x}c4x\n-\n-Texas Instruments TMS320C3x and TMS320C4x Floating Point Digital Signal\n-Processors.  These are used in embedded applications.  There are no\n-standard Unix configurations.\n-@ifnothtml\n-@xref{TMS320C3x/C4x Options,, TMS320C3x/C4x Options, gcc, Using the\n-GNU Compiler Collection (GCC)},\n-@end ifnothtml\n-@ifhtml\n-See ``TMS320C3x/C4x Options'' in the main manual\n-@end ifhtml\n-for the list of supported MCU types.\n-\n-GCC can be configured as a cross compiler for both the C3x and C4x\n-architectures on the same system.  Use @samp{configure --target=c4x\n---enable-languages=\"c,c++\"} to configure.\n-\n-\n-Further installation notes and other useful information about C4x tools\n-can also be obtained from:\n-\n-@itemize @bullet\n-@item\n-@uref{http://www.elec.canterbury.ac.nz/c4x/,,http://www.elec.canterbury.ac.nz/c4x/}\n-@end itemize\n-\n @html\n <hr />\n @end html"}, {"sha": "a6bf47d495e81e6ba23ecdedb6402e63124af665", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -772,12 +772,6 @@ See RS/6000 and PowerPC Options.\n @emph{System V Options}\n @gccoptlist{-Qy  -Qn  -YP,@var{paths}  -Ym,@var{dir}}\n \n-@emph{TMS320C3x/C4x Options}\n-@gccoptlist{-mcpu=@var{cpu}  -mbig  -msmall  -mregparm  -mmemparm @gol\n--mfast-fix  -mmpyi  -mbk  -mti  -mdp-isr-reload @gol\n--mrpts=@var{count}  -mrptb  -mdb  -mloop-unsigned @gol\n--mparallel-insns  -mparallel-mpy  -mpreserve-float}\n-\n @emph{V850 Options}\n @gccoptlist{-mlong-calls  -mno-long-calls  -mep  -mno-ep @gol\n -mprolog-function  -mno-prolog-function  -mspace @gol\n@@ -8257,7 +8251,6 @@ platform.\n * SPARC Options::\n * SPU Options::\n * System V Options::\n-* TMS320C3x/C4x Options::\n * V850 Options::\n * VAX Options::\n * VxWorks Options::\n@@ -14335,158 +14328,6 @@ The assembler uses this option.\n @c the generic assembler that comes with Solaris takes just -Ym.\n @end table\n \n-@node TMS320C3x/C4x Options\n-@subsection TMS320C3x/C4x Options\n-@cindex TMS320C3x/C4x Options\n-\n-These @samp{-m} options are defined for TMS320C3x/C4x implementations:\n-\n-@table @gcctabopt\n-\n-@item -mcpu=@var{cpu_type}\n-@opindex mcpu\n-Set the instruction set, register set, and instruction scheduling\n-parameters for machine type @var{cpu_type}.  Supported values for\n-@var{cpu_type} are @samp{c30}, @samp{c31}, @samp{c32}, @samp{c40}, and\n-@samp{c44}.  The default is @samp{c40} to generate code for the\n-TMS320C40.\n-\n-@item -mbig-memory\n-@itemx -mbig\n-@itemx -msmall-memory\n-@itemx -msmall\n-@opindex mbig-memory\n-@opindex mbig\n-@opindex msmall-memory\n-@opindex msmall\n-Generates code for the big or small memory model.  The small memory\n-model assumed that all data fits into one 64K word page.  At run-time\n-the data page (DP) register must be set to point to the 64K page\n-containing the .bss and .data program sections.  The big memory model is\n-the default and requires reloading of the DP register for every direct\n-memory access.\n-\n-@item -mbk\n-@itemx -mno-bk\n-@opindex mbk\n-@opindex mno-bk\n-Allow (disallow) allocation of general integer operands into the block\n-count register BK@.\n-\n-@item -mdb\n-@itemx -mno-db\n-@opindex mdb\n-@opindex mno-db\n-Enable (disable) generation of code using decrement and branch,\n-DBcond(D), instructions.  This is enabled by default for the C4x.  To be\n-on the safe side, this is disabled for the C3x, since the maximum\n-iteration count on the C3x is @math{2^{23} + 1} (but who iterates loops more than\n-@math{2^{23}} times on the C3x?).  Note that GCC will try to reverse a loop so\n-that it can utilize the decrement and branch instruction, but will give\n-up if there is more than one memory reference in the loop.  Thus a loop\n-where the loop counter is decremented can generate slightly more\n-efficient code, in cases where the RPTB instruction cannot be utilized.\n-\n-@item -mdp-isr-reload\n-@itemx -mparanoid\n-@opindex mdp-isr-reload\n-@opindex mparanoid\n-Force the DP register to be saved on entry to an interrupt service\n-routine (ISR), reloaded to point to the data section, and restored on\n-exit from the ISR@.  This should not be required unless someone has\n-violated the small memory model by modifying the DP register, say within\n-an object library.\n-\n-@item -mmpyi\n-@itemx -mno-mpyi\n-@opindex mmpyi\n-@opindex mno-mpyi\n-For the C3x use the 24-bit MPYI instruction for integer multiplies\n-instead of a library call to guarantee 32-bit results.  Note that if one\n-of the operands is a constant, then the multiplication will be performed\n-using shifts and adds.  If the @option{-mmpyi} option is not specified for the C3x,\n-then squaring operations are performed inline instead of a library call.\n-\n-@item -mfast-fix\n-@itemx -mno-fast-fix\n-@opindex mfast-fix\n-@opindex mno-fast-fix\n-The C3x/C4x FIX instruction to convert a floating point value to an\n-integer value chooses the nearest integer less than or equal to the\n-floating point value rather than to the nearest integer.  Thus if the\n-floating point number is negative, the result will be incorrectly\n-truncated an additional code is necessary to detect and correct this\n-case.  This option can be used to disable generation of the additional\n-code required to correct the result.\n-\n-@item -mrptb\n-@itemx -mno-rptb\n-@opindex mrptb\n-@opindex mno-rptb\n-Enable (disable) generation of repeat block sequences using the RPTB\n-instruction for zero overhead looping.  The RPTB construct is only used\n-for innermost loops that do not call functions or jump across the loop\n-boundaries.  There is no advantage having nested RPTB loops due to the\n-overhead required to save and restore the RC, RS, and RE registers.\n-This is enabled by default with @option{-O2}.\n-\n-@item -mrpts=@var{count}\n-@itemx -mno-rpts\n-@opindex mrpts\n-@opindex mno-rpts\n-Enable (disable) the use of the single instruction repeat instruction\n-RPTS@.  If a repeat block contains a single instruction, and the loop\n-count can be guaranteed to be less than the value @var{count}, GCC will\n-emit a RPTS instruction instead of a RPTB@.  If no value is specified,\n-then a RPTS will be emitted even if the loop count cannot be determined\n-at compile time.  Note that the repeated instruction following RPTS does\n-not have to be reloaded from memory each iteration, thus freeing up the\n-CPU buses for operands.  However, since interrupts are blocked by this\n-instruction, it is disabled by default.\n-\n-@item -mloop-unsigned\n-@itemx -mno-loop-unsigned\n-@opindex mloop-unsigned\n-@opindex mno-loop-unsigned\n-The maximum iteration count when using RPTS and RPTB (and DB on the C40)\n-is @math{2^{31} + 1} since these instructions test if the iteration count is\n-negative to terminate the loop.  If the iteration count is unsigned\n-there is a possibility than the @math{2^{31} + 1} maximum iteration count may be\n-exceeded.  This switch allows an unsigned iteration count.\n-\n-@item -mti\n-@opindex mti\n-Try to emit an assembler syntax that the TI assembler (asm30) is happy\n-with.  This also enforces compatibility with the API employed by the TI\n-C3x C compiler.  For example, long doubles are passed as structures\n-rather than in floating point registers.\n-\n-@item -mregparm\n-@itemx -mmemparm\n-@opindex mregparm\n-@opindex mmemparm\n-Generate code that uses registers (stack) for passing arguments to functions.\n-By default, arguments are passed in registers where possible rather\n-than by pushing arguments on to the stack.\n-\n-@item -mparallel-insns\n-@itemx -mno-parallel-insns\n-@opindex mparallel-insns\n-@opindex mno-parallel-insns\n-Allow the generation of parallel instructions.  This is enabled by\n-default with @option{-O2}.\n-\n-@item -mparallel-mpy\n-@itemx -mno-parallel-mpy\n-@opindex mparallel-mpy\n-@opindex mno-parallel-mpy\n-Allow the generation of MPY||ADD and MPY||SUB parallel instructions,\n-provided @option{-mparallel-insns} is also specified.  These instructions have\n-tight register constraints which can pessimize the code generation\n-of large functions.\n-\n-@end table\n-\n @node V850 Options\n @subsection V850 Options\n @cindex V850 Options"}, {"sha": "fba9f9448fb6b4cd7b6bd2ddb9a14b2b3d1ba3ae", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 1, "deletions": 83, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1996, 1998, 1999, 2000, 2001,\n-@c 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+@c 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -2847,88 +2847,6 @@ An immediate for the @code{iohl} instruction.  const_int is sign extended to 128\n \n @end table\n \n-@item TMS320C3x/C4x---@file{config/c4x/c4x.h}\n-@table @code\n-@item a\n-Auxiliary (address) register (ar0-ar7)\n-\n-@item b\n-Stack pointer register (sp)\n-\n-@item c\n-Standard (32-bit) precision integer register\n-\n-@item f\n-Extended (40-bit) precision register (r0-r11)\n-\n-@item k\n-Block count register (bk)\n-\n-@item q\n-Extended (40-bit) precision low register (r0-r7)\n-\n-@item t\n-Extended (40-bit) precision register (r0-r1)\n-\n-@item u\n-Extended (40-bit) precision register (r2-r3)\n-\n-@item v\n-Repeat count register (rc)\n-\n-@item x\n-Index register (ir0-ir1)\n-\n-@item y\n-Status (condition code) register (st)\n-\n-@item z\n-Data page register (dp)\n-\n-@item G\n-Floating-point zero\n-\n-@item H\n-Immediate 16-bit floating-point constant\n-\n-@item I\n-Signed 16-bit constant\n-\n-@item J\n-Signed 8-bit constant\n-\n-@item K\n-Signed 5-bit constant\n-\n-@item L\n-Unsigned 16-bit constant\n-\n-@item M\n-Unsigned 8-bit constant\n-\n-@item N\n-Ones complement of unsigned 16-bit constant\n-\n-@item O\n-High 16-bit constant (32-bit constant with 16 LSBs zero)\n-\n-@item Q\n-Indirect memory reference with signed 8-bit or index register displacement\n-\n-@item R\n-Indirect memory reference with unsigned 5-bit displacement\n-\n-@item S\n-Indirect memory reference with 1 bit or index register displacement\n-\n-@item T\n-Direct memory reference\n-\n-@item U\n-Symbolic address\n-\n-@end table\n-\n @item S/390 and zSeries---@file{config/s390/s390.h}\n @table @code\n @item a"}, {"sha": "e6449225e821541bfe9b34a61ecb3e2019cbe9c2", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,5 +1,5 @@\n @c Copyright (C) 1988,1989,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,\n-@c 2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n+@c 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -1288,9 +1288,7 @@ mode, otherwise @var{mode} is VOIDmode.  @var{mode} is provided in the\n case where structures of one field would require the structure's mode to\n retain the field's mode.\n \n-Normally, this is not needed.  See the file @file{c4x.h} for an example\n-of how to use this macro to prevent a structure having a floating point\n-field from being accessed in an integer mode.\n+Normally, this is not needed.\n @end defmac\n \n @defmac ROUND_TYPE_ALIGN (@var{type}, @var{computed}, @var{specified})\n@@ -1351,7 +1349,7 @@ targets.\n \n @defmac TARGET_FLOAT_FORMAT\n A code distinguishing the floating point format of the target machine.\n-There are four defined values:\n+There are two defined values:\n \n @ftable @code\n @item IEEE_FLOAT_FORMAT\n@@ -1361,9 +1359,6 @@ need to define @code{TARGET_FLOAT_FORMAT} when the format is IEEE@.\n @item VAX_FLOAT_FORMAT\n This code indicates the ``F float'' (for @code{float}) and ``D float''\n or ``G float'' formats (for @code{double}) used on the VAX and PDP-11@.\n-\n-@item C4X_FLOAT_FORMAT\n-This code indicates the format used on the TMS320C3x/C4x.\n @end ftable\n \n If your target uses a floating point format other than these, you must\n@@ -9807,9 +9802,6 @@ arguments of pragmas registered with\n @code{c_register_pragma_with_expansion} but not on the arguments of\n pragmas registered with @code{c_register_pragma}.\n \n-For an example use of this routine, see @file{c4x.h} and the callback\n-routines defined in @file{c4x-c.c}.\n-\n Note that the use of @code{pragma_lex} is specific to the C and C++\n compilers.  It will not work in the Java or Fortran compilers, or any\n other language compilers for that matter.  Thus if @code{pragma_lex} is going"}, {"sha": "38f18a8462a173895ed57ca7f91fbd6776b2bf66", "filename": "gcc/real.c", "status": "modified", "additions": 1, "deletions": 230, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,6 +1,6 @@\n /* real.c - software floating point emulation.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   2000, 2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n    Contributed by Stephen L. Moshier (moshier@world.std.com).\n    Re-written by Richard Henderson <rth@redhat.com>\n \n@@ -4278,235 +4278,6 @@ const struct real_format decimal_quad_format =\n     false\n   };\n \f\n-/* The \"twos-complement\" c4x format is officially defined as\n-\n-\tx = s(~s).f * 2**e\n-\n-   This is rather misleading.  One must remember that F is signed.\n-   A better description would be\n-\n-\tx = -1**s * ((s + 1 + .f) * 2**e\n-\n-   So if we have a (4 bit) fraction of .1000 with a sign bit of 1,\n-   that's -1 * (1+1+(-.5)) == -1.5.  I think.\n-\n-   The constructions here are taken from Tables 5-1 and 5-2 of the\n-   TMS320C4x User's Guide wherein step-by-step instructions for\n-   conversion from IEEE are presented.  That's close enough to our\n-   internal representation so as to make things easy.\n-\n-   See http://www-s.ti.com/sc/psheets/spru063c/spru063c.pdf  */\n-\n-static void encode_c4x_single (const struct real_format *fmt,\n-\t\t\t       long *, const REAL_VALUE_TYPE *);\n-static void decode_c4x_single (const struct real_format *,\n-\t\t\t       REAL_VALUE_TYPE *, const long *);\n-static void encode_c4x_extended (const struct real_format *fmt,\n-\t\t\t\t long *, const REAL_VALUE_TYPE *);\n-static void decode_c4x_extended (const struct real_format *,\n-\t\t\t\t REAL_VALUE_TYPE *, const long *);\n-\n-static void\n-encode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n-\t\t   long *buf, const REAL_VALUE_TYPE *r)\n-{\n-  unsigned long image, exp, sig;\n-\n-  switch (r->cl)\n-    {\n-    case rvc_zero:\n-      exp = -128;\n-      sig = 0;\n-      break;\n-\n-    case rvc_inf:\n-    case rvc_nan:\n-      exp = 127;\n-      sig = 0x800000 - r->sign;\n-      break;\n-\n-    case rvc_normal:\n-      exp = REAL_EXP (r) - 1;\n-      sig = (r->sig[SIGSZ-1] >> (HOST_BITS_PER_LONG - 24)) & 0x7fffff;\n-      if (r->sign)\n-\t{\n-\t  if (sig)\n-\t    sig = -sig;\n-\t  else\n-\t    exp--;\n-\t  sig |= 0x800000;\n-\t}\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  image = ((exp & 0xff) << 24) | (sig & 0xffffff);\n-  buf[0] = image;\n-}\n-\n-static void\n-decode_c4x_single (const struct real_format *fmt ATTRIBUTE_UNUSED,\n-\t\t   REAL_VALUE_TYPE *r, const long *buf)\n-{\n-  unsigned long image = buf[0];\n-  unsigned long sig;\n-  int exp, sf;\n-\n-  exp = (((image >> 24) & 0xff) ^ 0x80) - 0x80;\n-  sf = ((image & 0xffffff) ^ 0x800000) - 0x800000;\n-\n-  memset (r, 0, sizeof (*r));\n-\n-  if (exp != -128)\n-    {\n-      r->cl = rvc_normal;\n-\n-      sig = sf & 0x7fffff;\n-      if (sf < 0)\n-\t{\n-\t  r->sign = 1;\n-\t  if (sig)\n-\t    sig = -sig;\n-\t  else\n-\t    exp++;\n-\t}\n-      sig = (sig << (HOST_BITS_PER_LONG - 24)) | SIG_MSB;\n-\n-      SET_REAL_EXP (r, exp + 1);\n-      r->sig[SIGSZ-1] = sig;\n-    }\n-}\n-\n-static void\n-encode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n-\t\t     long *buf, const REAL_VALUE_TYPE *r)\n-{\n-  unsigned long exp, sig;\n-\n-  switch (r->cl)\n-    {\n-    case rvc_zero:\n-      exp = -128;\n-      sig = 0;\n-      break;\n-\n-    case rvc_inf:\n-    case rvc_nan:\n-      exp = 127;\n-      sig = 0x80000000 - r->sign;\n-      break;\n-\n-    case rvc_normal:\n-      exp = REAL_EXP (r) - 1;\n-\n-      sig = r->sig[SIGSZ-1];\n-      if (HOST_BITS_PER_LONG == 64)\n-\tsig = sig >> 1 >> 31;\n-      sig &= 0x7fffffff;\n-\n-      if (r->sign)\n-\t{\n-\t  if (sig)\n-\t    sig = -sig;\n-\t  else\n-\t    exp--;\n-\t  sig |= 0x80000000;\n-\t}\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  exp = (exp & 0xff) << 24;\n-  sig &= 0xffffffff;\n-\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    buf[0] = exp, buf[1] = sig;\n-  else\n-    buf[0] = sig, buf[0] = exp;\n-}\n-\n-static void\n-decode_c4x_extended (const struct real_format *fmt ATTRIBUTE_UNUSED,\n-\t\t     REAL_VALUE_TYPE *r, const long *buf)\n-{\n-  unsigned long sig;\n-  int exp, sf;\n-\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n-    exp = buf[0], sf = buf[1];\n-  else\n-    sf = buf[0], exp = buf[1];\n-\n-  exp = (((exp >> 24) & 0xff) & 0x80) - 0x80;\n-  sf = ((sf & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-\n-  memset (r, 0, sizeof (*r));\n-\n-  if (exp != -128)\n-    {\n-      r->cl = rvc_normal;\n-\n-      sig = sf & 0x7fffffff;\n-      if (sf < 0)\n-\t{\n-\t  r->sign = 1;\n-\t  if (sig)\n-\t    sig = -sig;\n-\t  else\n-\t    exp++;\n-\t}\n-      if (HOST_BITS_PER_LONG == 64)\n-\tsig = sig << 1 << 31;\n-      sig |= SIG_MSB;\n-\n-      SET_REAL_EXP (r, exp + 1);\n-      r->sig[SIGSZ-1] = sig;\n-    }\n-}\n-\n-const struct real_format c4x_single_format =\n-  {\n-    encode_c4x_single,\n-    decode_c4x_single,\n-    2,\n-    24,\n-    24,\n-    -126,\n-    128,\n-    23,\n-    -1,\n-    false,\n-    false,\n-    false,\n-    false,\n-    false,\n-    false\n-  };\n-\n-const struct real_format c4x_extended_format =\n-  {\n-    encode_c4x_extended,\n-    decode_c4x_extended,\n-    2,\n-    32,\n-    32,\n-    -126,\n-    128,\n-    31,\n-    -1,\n-    false,\n-    false,\n-    false,\n-    false,\n-    false,\n-    false\n-  };\n-\n-\f\n /* A synthetic \"format\" for internal arithmetic.  It's the size of the\n    internal significand minus the two bits needed for proper rounding.\n    The encode and decode routines exist only to satisfy our paranoia"}, {"sha": "e482c888f34da044562004ebcbc29e2f1a2e30a1", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of floating-point access for GNU compiler.\n    Copyright (C) 1989, 1991, 1994, 1996, 1997, 1998, 1999,\n-   2000, 2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.\n+   2000, 2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n \n    This file is part of GCC.\n \n@@ -271,8 +271,6 @@ extern const struct real_format mips_quad_format;\n extern const struct real_format vax_f_format;\n extern const struct real_format vax_d_format;\n extern const struct real_format vax_g_format;\n-extern const struct real_format c4x_single_format;\n-extern const struct real_format c4x_extended_format;\n extern const struct real_format real_internal_format;\n extern const struct real_format decimal_single_format;\n extern const struct real_format decimal_double_format;"}, {"sha": "9c7af4ee89dc4db5bd538f36e004eef9ffe7af4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,3 +1,9 @@\n+2008-01-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/builtin-inf-1.c, gcc.dg/compare6.c, gcc.dg/sibcall-3.c,\n+\tgcc.dg/sibcall-4.c, gcc.dg/torture/builtin-attr-1.c: Don't handle\n+\tc4x-*-* targets.\n+\n 2008-01-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/32244"}, {"sha": "fdb4612274cb226afe7018c8a1f89bf3d9f4d1c6", "filename": "gcc/testsuite/gcc.dg/builtin-inf-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-inf-1.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -8,6 +8,6 @@ float fh = __builtin_huge_valf();\n double dh = __builtin_huge_val();\n long double lh = __builtin_huge_vall();\n \n-/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* c4x-*-* } 3 } */\n-/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* c4x-*-* } 4 } */\n-/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* c4x-*-* } 5 } */\n+/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* } 3 } */\n+/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* } 4 } */\n+/* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* } 5 } */"}, {"sha": "945d2823955c4b2b2230f5808e5a278b576414a0", "filename": "gcc/testsuite/gcc.dg/compare6.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcompare6.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,7 +1,6 @@\n /* PR c/2098 */\n /* Test for a warning on comparison on out-of-range data.  */\n /* { dg-do compile } */\n-/* { dg-xfail-if \"\" { c4x-*-* } { \"*\" } { \"\" } } */\n /* { dg-options \"-Wtype-limits\" } */\n \n signed char sc;"}, {"sha": "38f3e37622d4cad15b1d87dee359113ed94fc09c", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */"}, {"sha": "535efb6450440d70cf95d1ceb09be2aaf29148c7", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail arc-*-* avr-*-* c4x-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n+/* { dg-do run { xfail arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa-*-* } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */"}, {"sha": "bd383a2b34b13493338ad53de6ff28a75efdfdfa", "filename": "gcc/testsuite/gcc.dg/torture/builtin-attr-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fbuiltin-attr-1.c?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -339,7 +339,7 @@ FPTEST2            (fmod)\n BUILTIN_FPTEST0    (huge_val)\n FPTEST2            (hypot)\n FPTEST1T           (ilogb, int)\n-BUILTIN_FPTEST0    (inf) /* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* c4x-*-* pdp11-*-* spu-*-* } } */\n+BUILTIN_FPTEST0    (inf) /* { dg-warning \"does not support infinity\" \"INF unsupported\" { target vax-*-* pdp11-*-* spu-*-* } } */\n FPTEST1            (j0)\n FPTEST1            (j1)\n FPTEST2ARG1        (jn, int)"}, {"sha": "e418769c4a545add1dfaac0fbe700e852de7960c", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,3 +1,9 @@\n+2008-01-25  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config.host (tic4x-*-*, c4x-*-rtems*, tic4x-*-rtems*, c4x-*,\n+\ttic4x-*, h8300-*-rtemscoff*, ns32k-*-netbsdelf*, ns32k-*-netbsd*,\n+\tsh-*-rtemscoff*): Remove cases.\n+\n 2007-12-27  Richard Sandiford  <rsandifo@nildram.co.uk>\n \n \t* Makefile.in (all): Use install-leaf rather than install."}, {"sha": "9496842f9bb6ed96729c4d043ddf88197948d1e3", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8da227888f95418be8d0c90fcec2ff1a2c8438/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8da227888f95418be8d0c90fcec2ff1a2c8438/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=8d8da227888f95418be8d0c90fcec2ff1a2c8438", "patch": "@@ -1,6 +1,6 @@\n # libgcc host-specific configuration file.\n-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n-# Free Software Foundation, Inc.\n+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n+# 2008 Free Software Foundation, Inc.\n \n #This file is part of GCC.\n \n@@ -137,9 +137,6 @@ s390*-*-*)\n sh[123456789lbe]*-*-*)\n \tcpu_type=sh\n \t;;\n-tic4x-*-*)\n-        cpu_type=c4x\n-        ;;\n esac\n \n # Common parts for widely ported systems.\n@@ -258,10 +255,6 @@ bfin*-linux-uclibc*)\n \t;;\n bfin*-*)\n         ;;\n-c4x-*-rtems* | tic4x-*-rtems*)\n-\t;;\n-c4x-* | tic4x-*)\n-\t;;\n cris-*-aout)\n \t;;\n crisv32-*-elf | crisv32-*-none | cris-*-elf | cris-*-none)\n@@ -279,8 +272,6 @@ frv-*-elf)\n \t;;\n frv-*-*linux*)\n \t;;\n-h8300-*-rtemscoff*)\n-\t;;\n h8300-*-rtems*)\n \t;;\n h8300-*-elf*)\n@@ -473,11 +464,6 @@ mn10300-*-*)\n \t;;\n mt-*-elf)\n         ;;\n-ns32k-*-netbsdelf*)\n-\techo \"GCC does not yet support the ${host} target\"; exit 1\n-\t;;\n-ns32k-*-netbsd*)\n-\t;;\n pdp11-*-bsd)\n         ;;\n pdp11-*-*)\n@@ -574,8 +560,6 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t\t;;\n \tesac\n \t;;\n-sh-*-rtemscoff*)\n-\t;;\n sh-*-rtems*)\n \t;;\n sh-wrs-vxworks)"}]}