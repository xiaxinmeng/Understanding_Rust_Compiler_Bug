{"sha": "2ec62529e94905195af24c630872c0f6df062c63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVjNjI1MjllOTQ5MDUxOTVhZjI0YzYzMDg3MmMwZjZkZjA2MmM2Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2009-02-21T09:15:13Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2009-02-21T09:15:13Z"}, "message": "loop-iv.c (truncate_value): New function.\n\ngcc/\n\t* loop-iv.c (truncate_value): New function.\n\t(iv_subreg, get_iv_value, iv_number_of_iterations): Use it instead\n\tof lowpart_subreg.\n\t(lowpart_subreg): Move to...\n\t* emit-rtl.c: ...here.\n\nFrom-SVN: r144348", "tree": {"sha": "16be1ac483a5866d5751cfc152a11e3026b59279", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16be1ac483a5866d5751cfc152a11e3026b59279"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ec62529e94905195af24c630872c0f6df062c63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec62529e94905195af24c630872c0f6df062c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ec62529e94905195af24c630872c0f6df062c63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ec62529e94905195af24c630872c0f6df062c63/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e0bdc5e2265896a7dcc1630eed536cc47d7771c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e0bdc5e2265896a7dcc1630eed536cc47d7771c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e0bdc5e2265896a7dcc1630eed536cc47d7771c"}], "stats": {"total": 81, "additions": 48, "deletions": 33}, "files": [{"sha": "ba600055f908fe7085cfc371d489c99fc29d118b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec62529e94905195af24c630872c0f6df062c63/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec62529e94905195af24c630872c0f6df062c63/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ec62529e94905195af24c630872c0f6df062c63", "patch": "@@ -1,3 +1,11 @@\n+2009-02-21  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* loop-iv.c (truncate_value): New function.\n+\t(iv_subreg, get_iv_value, iv_number_of_iterations): Use it instead\n+\tof lowpart_subreg.\n+\t(lowpart_subreg): Move to...\n+\t* emit-rtl.c: ...here.\n+\n 2009-02-21  Danny Smith  <dannysmith@users.sourceforge.net>\n \t* config/i386/winnt.c (i386_pe_asm_output_aligned_decl_common): Revert\n \taccidental and undocumented change at revision 140860."}, {"sha": "2d6851528e7aaa1c227d769c9681a4f48fe6108a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec62529e94905195af24c630872c0f6df062c63/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec62529e94905195af24c630872c0f6df062c63/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2ec62529e94905195af24c630872c0f6df062c63", "patch": "@@ -1232,6 +1232,17 @@ gen_lowpart_common (enum machine_mode mode, rtx x)\n   /* Otherwise, we can't do this.  */\n   return 0;\n }\n+\n+/* Generates a subreg to get the least significant part of EXPR (in mode\n+   INNER_MODE) to OUTER_MODE.  */\n+\n+rtx\n+lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n+\t\tenum machine_mode inner_mode)\n+{\n+  return simplify_gen_subreg (outer_mode, expr, inner_mode,\n+\t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n+}\n \f\n rtx\n gen_highpart (enum machine_mode mode, rtx x)"}, {"sha": "eacf32b097e8c6276934fa83133e5e96a43707ba", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 29, "deletions": 33, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ec62529e94905195af24c630872c0f6df062c63/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ec62529e94905195af24c630872c0f6df062c63/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=2ec62529e94905195af24c630872c0f6df062c63", "patch": "@@ -157,15 +157,12 @@ dump_iv_info (FILE *file, struct rtx_iv *iv)\n     fprintf (file, \" (first special)\");\n }\n \n-/* Generates a subreg to get the least significant part of EXPR (in mode\n-   INNER_MODE) to OUTER_MODE.  */\n+/* Truncate EXPR (which has mode EXPR_MODE) to MODE.  */\n \n-rtx\n-lowpart_subreg (enum machine_mode outer_mode, rtx expr,\n-\t\tenum machine_mode inner_mode)\n+static rtx\n+truncate_value (enum machine_mode mode, rtx expr, enum machine_mode expr_mode)\n {\n-  return simplify_gen_subreg (outer_mode, expr, inner_mode,\n-\t\t\t      subreg_lowpart_offset (outer_mode, inner_mode));\n+  return simplify_gen_unary (TRUNCATE, mode, expr, expr_mode);\n }\n \n static void \n@@ -408,7 +405,7 @@ iv_subreg (struct rtx_iv *iv, enum machine_mode mode)\n       && !iv->first_special)\n     {\n       rtx val = get_iv_value (iv, const0_rtx);\n-      val = lowpart_subreg (mode, val, iv->extend_mode);\n+      val = truncate_value (mode, val, iv->extend_mode);\n \n       iv->base = val;\n       iv->extend = UNKNOWN;\n@@ -1247,7 +1244,7 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n   if (iv->extend_mode == iv->mode)\n     return val;\n \n-  val = lowpart_subreg (iv->mode, val, iv->extend_mode);\n+  val = truncate_value (iv->mode, val, iv->extend_mode);\n \n   if (iv->extend == UNKNOWN)\n     return val;\n@@ -2200,8 +2197,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n   mode = iv0.mode;\n   size = GET_MODE_BITSIZE (mode);\n   get_mode_bounds (mode, (cond == LE || cond == LT), comp_mode, &mmin, &mmax);\n-  mode_mmin = lowpart_subreg (mode, mmin, comp_mode);\n-  mode_mmax = lowpart_subreg (mode, mmax, comp_mode);\n+  mode_mmin = truncate_value (mode, mmin, comp_mode);\n+  mode_mmax = truncate_value (mode, mmax, comp_mode);\n \n   if (GET_CODE (iv0.step) != CONST_INT || GET_CODE (iv1.step) != CONST_INT)\n     goto fail;\n@@ -2258,7 +2255,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t   difficult due to possibly infinite loops.  */\n \tif (iv0.step == const0_rtx)\n \t  {\n-\t    tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t    tmp = truncate_value (mode, iv0.base, comp_mode);\n \t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n \t\t\t\t\t\t  mode_mmax);\n \t    if (assumption == const_true_rtx)\n@@ -2268,7 +2265,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  }\n \telse\n \t  {\n-\t    tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t    tmp = truncate_value (mode, iv1.base, comp_mode);\n \t    assumption = simplify_gen_relational (EQ, SImode, mode, tmp,\n \t\t\t\t\t\t  mode_mmin);\n \t    if (assumption == const_true_rtx)\n@@ -2294,7 +2291,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n     {\n       if (iv0.step == const0_rtx)\n \t{\n-\t  tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t  tmp = truncate_value (mode, iv0.base, comp_mode);\n \t  if (rtx_equal_p (tmp, mode_mmin))\n \t    {\n \t      desc->infinite =\n@@ -2305,7 +2302,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t}\n       else\n \t{\n-\t  tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t  tmp = truncate_value (mode, iv1.base, comp_mode);\n \t  if (rtx_equal_p (tmp, mode_mmax))\n \t    {\n \t      desc->infinite =\n@@ -2329,7 +2326,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n       else\n \tstep = iv0.step;\n       delta = simplify_gen_binary (MINUS, comp_mode, iv1.base, iv0.base);\n-      delta = lowpart_subreg (mode, delta, comp_mode);\n+      delta = truncate_value (mode, delta, comp_mode);\n       delta = simplify_gen_binary (UMOD, mode, delta, step);\n       may_xform = const0_rtx;\n       may_not_xform = const_true_rtx;\n@@ -2353,8 +2350,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    {\n \t      bound = simplify_gen_binary (PLUS, comp_mode, mmin, step);\n \t      bound = simplify_gen_binary (MINUS, comp_mode, bound, delta);\n-\t      bound = lowpart_subreg (mode, bound, comp_mode);\n-\t      tmp = lowpart_subreg (mode, iv0.base, comp_mode);\n+\t      bound = truncate_value (mode, bound, comp_mode);\n+\t      tmp = truncate_value (mode, iv0.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   bound, tmp);\n \t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n@@ -2365,8 +2362,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    {\n \t      bound = simplify_gen_binary (MINUS, comp_mode, mmax, step);\n \t      bound = simplify_gen_binary (PLUS, comp_mode, bound, delta);\n-\t      bound = lowpart_subreg (mode, bound, comp_mode);\n-\t      tmp = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t      bound = truncate_value (mode, bound, comp_mode);\n+\t      tmp = truncate_value (mode, iv1.base, comp_mode);\n \t      may_xform = simplify_gen_relational (cond, SImode, mode,\n \t\t\t\t\t\t   tmp, bound);\n \t      may_not_xform = simplify_gen_relational (reverse_condition (cond),\n@@ -2417,8 +2414,8 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t      iv1.base = simplify_gen_binary (PLUS, comp_mode, iv1.base, step);\n \t    }\n \n-\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n-\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n+\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode, tmp0, tmp1);\n \t  if (assumption == const_true_rtx)\n@@ -2446,7 +2443,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t  iv0.step = simplify_gen_unary (NEG, comp_mode, iv0.step, mode);\n \t  iv1.base = simplify_gen_unary (NEG, comp_mode, iv1.base, mode);\n \t}\n-      iv0.step = lowpart_subreg (mode, iv0.step, comp_mode);\n+      iv0.step = truncate_value (mode, iv0.step, comp_mode);\n \n       /* Let nsd (s, size of mode) = d.  If d does not divide c, the loop\n \t is infinite.  Otherwise, the number of iterations is\n@@ -2460,7 +2457,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t}\n       bound = GEN_INT (((unsigned HOST_WIDEST_INT) 1 << (size - 1 ) << 1) - 1);\n \n-      tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n+      tmp1 = truncate_value (mode, iv1.base, comp_mode);\n       tmp = simplify_gen_binary (UMOD, mode, tmp1, GEN_INT (d));\n       assumption = simplify_gen_relational (NE, SImode, mode, tmp, const0_rtx);\n       desc->infinite = alloc_EXPR_LIST (0, assumption, desc->infinite);\n@@ -2481,12 +2478,11 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t   but it was already taken into account during LE -> NE transform).  */\n \t{\n \t  step = iv0.step;\n-\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n-\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n+\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n \n \t  bound = simplify_gen_binary (MINUS, mode, mode_mmax,\n-\t\t\t\t       lowpart_subreg (mode, step,\n-\t\t\t\t\t\t       comp_mode));\n+\t\t\t\t       truncate_value (mode, step, comp_mode));\n \t  if (step_is_pow2)\n \t    {\n \t      rtx t0, t1;\n@@ -2513,7 +2509,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv1.base, iv0.step);\n-\t  tmp = lowpart_subreg (mode, tmp, comp_mode);\n+\t  tmp = truncate_value (mode, tmp, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode, tmp0, tmp);\n \n@@ -2526,11 +2522,11 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t     We must know that a - s does not overflow and a - s <= b and then\n \t     we can again compute number of iterations as (b - (a - s)) / s.  */\n \t  step = simplify_gen_unary (NEG, mode, iv1.step, mode);\n-\t  tmp0 = lowpart_subreg (mode, iv0.base, comp_mode);\n-\t  tmp1 = lowpart_subreg (mode, iv1.base, comp_mode);\n+\t  tmp0 = truncate_value (mode, iv0.base, comp_mode);\n+\t  tmp1 = truncate_value (mode, iv1.base, comp_mode);\n \n \t  bound = simplify_gen_binary (PLUS, mode, mode_mmin,\n-\t\t\t\t       lowpart_subreg (mode, step, comp_mode));\n+\t\t\t\t       truncate_value (mode, step, comp_mode));\n \t  if (step_is_pow2)\n \t    {\n \t      rtx t0, t1;\n@@ -2557,7 +2553,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n \t    }\n \n \t  tmp = simplify_gen_binary (PLUS, comp_mode, iv0.base, iv1.step);\n-\t  tmp = lowpart_subreg (mode, tmp, comp_mode);\n+\t  tmp = truncate_value (mode, tmp, comp_mode);\n \t  assumption = simplify_gen_relational (reverse_condition (cond),\n \t\t\t\t\t\tSImode, mode,\n \t\t\t\t\t\ttmp, tmp1);"}]}