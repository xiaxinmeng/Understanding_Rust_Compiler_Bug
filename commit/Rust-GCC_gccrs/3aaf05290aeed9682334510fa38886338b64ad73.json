{"sha": "3aaf05290aeed9682334510fa38886338b64ad73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FhZjA1MjkwYWVlZDk2ODIzMzQ1MTBmYTM4ODg2MzM4YjY0YWQ3Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-05-21T06:16:03Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-05-21T06:16:03Z"}, "message": "re PR tree-optimization/60899 (undef reference generated with -fdevirtualize-speculatively)\n\n\n\tPR tree-optimization/60899\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Cleanup;\n\tassume all static symbols will have definition wile parsing and\n\tcheck the do have definition later in compilation; check that\n\tvariable referring symbol will be output before concluding that\n\treference is safe; be conservative for referring local statics;\n\tbe more precise about when comdat is output in other partition.\n\n\tg++.dg/ipa/devirt-11.C: Update template.\n\nFrom-SVN: r210676", "tree": {"sha": "f9b7b26bf37f8b8b8a0af6d7e07c72c009bebcb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f9b7b26bf37f8b8b8a0af6d7e07c72c009bebcb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3aaf05290aeed9682334510fa38886338b64ad73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaf05290aeed9682334510fa38886338b64ad73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3aaf05290aeed9682334510fa38886338b64ad73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3aaf05290aeed9682334510fa38886338b64ad73/comments", "author": null, "committer": null, "parents": [{"sha": "1bbb87c4b25c0366ce2a53713ea1a9c97136e7b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bbb87c4b25c0366ce2a53713ea1a9c97136e7b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bbb87c4b25c0366ce2a53713ea1a9c97136e7b1"}], "stats": {"total": 76, "additions": 39, "deletions": 37}, "files": [{"sha": "fe3e7ec8febd0dfae39a78ee0d7125f3496542b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3aaf05290aeed9682334510fa38886338b64ad73", "patch": "@@ -1,3 +1,13 @@\n+2014-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/60899\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Cleanup;\n+\tassume all static symbols will have definition wile parsing and\n+\tcheck the do have definition later in compilation; check that\n+\tvariable referring symbol will be output before concluding that\n+\treference is safe; be conservative for referring local statics;\n+\tbe more precise about when comdat is output in other partition.\n+\n 2014-05-20  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR bootstrap/60984"}, {"sha": "44bb0e2b1879e25e4ccdc93a0c493a0dc306f230", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3aaf05290aeed9682334510fa38886338b64ad73", "patch": "@@ -94,19 +94,25 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n   /* Static objects can be referred only if they was not optimized out yet.  */\n   if (!TREE_PUBLIC (decl) && !DECL_EXTERNAL (decl))\n     {\n+      /* Before we start optimizing unreachable code we can be sure all\n+\t static objects are defined.  */\n+      if (cgraph_function_flags_ready)\n+\treturn true;\n       snode = symtab_get_node (decl);\n-      if (!snode)\n+      if (!snode || !snode->definition)\n \treturn false;\n       node = dyn_cast <cgraph_node *> (snode);\n       return !node || !node->global.inlined_to;\n     }\n \n   /* We will later output the initializer, so we can refer to it.\n      So we are concerned only when DECL comes from initializer of\n-     external var.  */\n+     external var or var that has been optimized out.  */\n   if (!from_decl\n       || TREE_CODE (from_decl) != VAR_DECL\n-      || !DECL_EXTERNAL (from_decl)\n+      || (!DECL_EXTERNAL (from_decl)\n+\t  && (vnode = varpool_get_node (from_decl)) != NULL\n+\t  && vnode->definition)\n       || (flag_ltrans\n \t  && symtab_get_node (from_decl)->in_other_partition))\n     return true;\n@@ -123,9 +129,9 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n      reference imply need to include function body in the curren tunit.  */\n   if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl))\n     return true;\n-  /* We are not at ltrans stage; so don't worry about WHOPR.\n-     Also when still gimplifying all referred comdat functions will be\n-     produced.\n+  /* We have COMDAT.  We are going to check if we still have definition\n+     or if the definition is going to be output in other partition.\n+     Bypass this when gimplifying; all needed functions will be produced.\n \n      As observed in PR20991 for already optimized out comdat virtual functions\n      it may be tempting to not necessarily give up because the copy will be\n@@ -134,35 +140,17 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n      units where they are used and when the other unit was compiled with LTO\n      it is possible that vtable was kept public while the function itself\n      was privatized. */\n-  if (!flag_ltrans && (!DECL_COMDAT (decl) || !cgraph_function_flags_ready))\n+  if (!cgraph_function_flags_ready)\n     return true;\n \n-  /* OK we are seeing either COMDAT or static variable.  In this case we must\n-     check that the definition is still around so we can refer it.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      node = cgraph_get_node (decl);\n-      /* Check that we still have function body and that we didn't took\n-         the decision to eliminate offline copy of the function yet.\n-         The second is important when devirtualization happens during final\n-         compilation stage when making a new reference no longer makes callee\n-         to be compiled.  */\n-      if (!node || !node->definition || node->global.inlined_to)\n-\t{\n-\t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n-\t  return false;\n-\t}\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL)\n-    {\n-      vnode = varpool_get_node (decl);\n-      if (!vnode || !vnode->definition)\n-\t{\n-\t  gcc_checking_assert (!TREE_ASM_WRITTEN (decl));\n-\t  return false;\n-\t}\n-    }\n-  return true;\n+  snode = symtab_get_node (decl);\n+  if (!snode\n+      || ((!snode->definition || DECL_EXTERNAL (decl))\n+\t  && (!snode->in_other_partition\n+\t      || (!snode->forced_by_abi && !snode->force_output))))\n+    return false;\n+  node = dyn_cast <cgraph_node *> (snode);\n+  return !node || !node->global.inlined_to;\n }\n \n /* CVAL is value taken from DECL_INITIAL of variable.  Try to transform it into"}, {"sha": "117c65f7701750a47f14c09fdd28989550899450", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3aaf05290aeed9682334510fa38886338b64ad73", "patch": "@@ -1,3 +1,8 @@\n+2014-05-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR tree-optimization/60899\n+\tg++.dg/ipa/devirt-11.C: Update template.\n+\n 2014-05-20  Edward Smith-Rowland  <3dw4rd@verizon.net>\n \n \tPR C++/61038"}, {"sha": "3246e214f141087a97efa90908c9feea20148e29", "filename": "gcc/testsuite/g++.dg/ipa/devirt-11.C", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3aaf05290aeed9682334510fa38886338b64ad73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-11.C?ref=3aaf05290aeed9682334510fa38886338b64ad73", "patch": "@@ -42,8 +42,7 @@ bar ()\n   baz ();\n   c + d;\n }\n-/* While inlining function called once we should devirtualize a new call to fn2\n-   and two to fn3. While doing so the new symbol for fn2 needs to be\n-   introduced.  */\n-/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 3 \"inline\"  } } */\n+/* While inlining function called once we should devirtualize a new call to fn3.\n+   Because fn2 is already removed, we should not devirtualize.  */\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n /* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}