{"sha": "ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE4NWM4YzNmY2IxOWM3NzZmNmUyMjA5ZDViMDA0NGM5ZTFjZGQzZA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-30T13:27:49Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-11-30T13:27:49Z"}, "message": "libcaf.h: Add new action types for (de-)registration of allocatable components in derived...\n\nlibgfortran/ChangeLog:\n\n2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* caf/libcaf.h: Add new action types for (de-)registration of\n\tallocatable components in derived type coarrays.  Add _caf_is_present\n\tprototype.\n\t* caf/single.c (_gfortran_caf_register): Add support for registration\n\tonly and allocation of already registered allocatable components in\n\tderived type coarrays.\n\t(_gfortran_caf_deregister): Add mode to deallocate but not deregister\n\tan allocatable component in a derived type coarray.\n\t(_gfortran_caf_is_present): New function.  Query whether an\n\tallocatable component in a derived type coarray on a remote image is\n\tallocated.\n\n\ngcc/testsuite/ChangeLog:\n\n2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/coarray/alloc_comp_1.f90: Fix tree-dump scans to adhere\n\tto the changed interfaces.\n\t* gfortran.dg/coarray_alloc_comp_1.f08: Likewise.\n\t* gfortran.dg/coarray_allocate_7.f08: Likewise.\n\t* gfortran.dg/coarray_lib_alloc_1.f90: Likewise.\n\t* gfortran.dg/coarray_lib_alloc_2.f90: Likewise.\n\t* gfortran.dg/coarray_lib_alloc_3.f90: Likewise.\n\t* gfortran.dg/coarray_lib_comm_1.f90: Likewise.\n\t* gfortran.dg/coarray_lib_alloc_4.f90: New test.\n\ngcc/fortran/ChangeLog:\n\n2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* check.c (gfc_check_allocated): By pass the caf_get call and check on\n\tthe array.\n\t* gfortran.h: Add optional flag to gfc_caf_attr.\n\t* gfortran.texi: Document new enum values and _caf_is_present function.\n\t* primary.c (caf_variable_attr): Add optional flag to indicate that the\n\texpression is reffing a component.\n\t(gfc_caf_attr): Likewise.\n\t* trans-array.c (gfc_array_deallocate): Handle deallocation mode for\n\tcoarray deregistration.\n\t(gfc_trans_dealloc_allocated): Likewise.\n\t(duplicate_allocatable): Use constants instead of\n        creating custom constant tree node of zero or one.  Use gfc_add_modify\n        convenience function.\n\t(duplicate_allocatable_coarray): This function is similar to\n\tduplicate_allocatable but tailored to handle coarrays.\n\t(caf_enabled): Check whether in-derived-type coarray processing is\n\tenabled.\n\t(caf_in_coarray): Check that in-derived-type coarray processing is\n\tenabled and currently in a derived-typed coarray.\n\t(gfc_caf_is_dealloc_only): Return true, when deallocate only is\n\tdesired for components in derived typed coarrays.\n\t(structure_alloc_comps): A mode for handling coarrays, that is no\n\tlonger encode in the purpose.  This makes the use cases of the\n\troutine more flexible without repeating.  Allocatable components in\n\tderived type coarrays are now registered only when nullifying an\n\tobject and allocated before copying data into them.\n\t(gfc_nullify_alloc_comp): Use the caf_mode of structure_alloc_comps\n\tnow.\n\t(gfc_deallocate_alloc_comp): Likewise.\n\t(gfc_deallocate_alloc_comp_no_caf): Likewise.\n\t(gfc_reassign_alloc_comp_caf): Likewise.\n\t(gfc_copy_alloc_comp): Likewise.\n\t(gfc_copy_only_alloc_comp): Likewise.\n\t(gfc_alloc_allocatable_for_assignment): Make use to the cheaper way of\n\treallocating a coarray without deregistering and reregistering it.\n\t(gfc_trans_deferred_array): Initialize the coarray token correctly for\n\tdeferred variables and tear them down on exit.\n\t* trans-array.h: Change some prototypes to add the coarray (de-)\n\tregistration modes.  Add prototype for checking if deallocate only is\n\tselected for components in derived typed coarrays.\n\t* trans-decl.c (gfc_build_builtin_function_decls): Generate the\n\tdeclarations for the changed/new caf-lib routines.\n\t(gfc_trans_deferred_vars): Ensure deferred variables are (de-)\n\tregistered correctly on procedure entry/exit.\n\t(generate_coarray_sym_init): Use constants.\n\t* trans-expr.c (gfc_conv_procedure_call): Propagate coarray allocation\n\tmodes accordingly.\n\t(gfc_trans_alloc_subarray_assign): Likewise.\n\t(gfc_trans_subcomponent_assign): Likewise.\n\t(gfc_trans_structure_assign): Generate code to register the components\n\tof a derived type coarray prior to initialization.\n\t(gfc_conv_structure): Set flag that the structure is in a coarray.\n\t(gfc_trans_scalar_assign): Add flag to indicate being in a coarray and\n\tset the structure_alloc_comps modes correctly.\n\t(gfc_trans_assignment_1): Figure being in a coarray expression.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get): Adapt to new\n\tstructure_alloc_comps interface.\n\t(conv_caf_send): Use the old API as long as possible.\n\t(trans_caf_is_present): Generate code to check whether an allocatable\n\tcomponent in a derived typed coarray is allocated on a remote image.\n\t(caf_this_image_ref): Return true, when only reffing this image.\n\t(gfc_conv_allocated): Convert allocated queries on allocatable\n\tcomponents to the library API.\n\t(conv_intrinsic_move_alloc): Adapt to new interface of\n\tstructure_alloc_comps.\n\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n\t(gfc_omp_clause_assign_op): Likewise.\n\t(gfc_omp_clause_dtor): Likewise.\n\t* trans-stmt.c (gfc_trans_deallocate): Figure which mode to use when\n\tdeallocating allocatable components in derived type coarras.\n\t* trans.c (gfc_allocate_using_lib): Renamed to\n\tgfc_allcate_using_caf_lib.\n\t(gfc_allocate_allocatable): Set the registration mode/type of caf-\n\tregister calls adapting to all the possible allocatable objects.\n\t(gfc_deallocate_with_status): Add deregistration mode for allocatable\n\tcomponents in derived type coarrays.\n\t(gfc_deallocate_scalar_with_status): Likewise.\n\t* trans.h (enum gfc_coarray_type): Renamed to gfc_coarray_regtype to\n\tavoid collision with gfc_coarray_deregtype.\n\nFrom-SVN: r243021", "tree": {"sha": "b2eb87602c8c315d1323a3da70856a653afbf967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2eb87602c8c315d1323a3da70856a653afbf967"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/comments", "author": null, "committer": null, "parents": [{"sha": "d5c50b024fbfe4255270fa4c7845b222466d2e79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c50b024fbfe4255270fa4c7845b222466d2e79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c50b024fbfe4255270fa4c7845b222466d2e79"}], "stats": {"total": 1394, "additions": 1142, "deletions": 252}, "files": [{"sha": "278c08f0c892f0027dc003fb0b20748974033180", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -1,3 +1,85 @@\n+2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* check.c (gfc_check_allocated): By pass the caf_get call and check on\n+\tthe array.\n+\t* gfortran.h: Add optional flag to gfc_caf_attr.\n+\t* gfortran.texi: Document new enum values and _caf_is_present function.\n+\t* primary.c (caf_variable_attr): Add optional flag to indicate that the\n+\texpression is reffing a component.\n+\t(gfc_caf_attr): Likewise.\n+\t* trans-array.c (gfc_array_deallocate): Handle deallocation mode for\n+\tcoarray deregistration.\n+\t(gfc_trans_dealloc_allocated): Likewise.\n+\t(duplicate_allocatable): Use constants instead of\n+        creating custom constant tree node of zero or one.  Use gfc_add_modify\n+        convenience function.\n+\t(duplicate_allocatable_coarray): This function is similar to\n+\tduplicate_allocatable but tailored to handle coarrays.\n+\t(caf_enabled): Check whether in-derived-type coarray processing is\n+\tenabled.\n+\t(caf_in_coarray): Check that in-derived-type coarray processing is\n+\tenabled and currently in a derived-typed coarray.\n+\t(gfc_caf_is_dealloc_only): Return true, when deallocate only is\n+\tdesired for components in derived typed coarrays.\n+\t(structure_alloc_comps): A mode for handling coarrays, that is no\n+\tlonger encode in the purpose.  This makes the use cases of the\n+\troutine more flexible without repeating.  Allocatable components in\n+\tderived type coarrays are now registered only when nullifying an\n+\tobject and allocated before copying data into them.\n+\t(gfc_nullify_alloc_comp): Use the caf_mode of structure_alloc_comps\n+\tnow.\n+\t(gfc_deallocate_alloc_comp): Likewise.\n+\t(gfc_deallocate_alloc_comp_no_caf): Likewise.\n+\t(gfc_reassign_alloc_comp_caf): Likewise.\n+\t(gfc_copy_alloc_comp): Likewise.\n+\t(gfc_copy_only_alloc_comp): Likewise.\n+\t(gfc_alloc_allocatable_for_assignment): Make use to the cheaper way of\n+\treallocating a coarray without deregistering and reregistering it.\n+\t(gfc_trans_deferred_array): Initialize the coarray token correctly for\n+\tdeferred variables and tear them down on exit.\n+\t* trans-array.h: Change some prototypes to add the coarray (de-)\n+\tregistration modes.  Add prototype for checking if deallocate only is\n+\tselected for components in derived typed coarrays.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): Generate the\n+\tdeclarations for the changed/new caf-lib routines.\n+\t(gfc_trans_deferred_vars): Ensure deferred variables are (de-)\n+\tregistered correctly on procedure entry/exit.\n+\t(generate_coarray_sym_init): Use constants.\n+\t* trans-expr.c (gfc_conv_procedure_call): Propagate coarray allocation\n+\tmodes accordingly.\n+\t(gfc_trans_alloc_subarray_assign): Likewise.\n+\t(gfc_trans_subcomponent_assign): Likewise.\n+\t(gfc_trans_structure_assign): Generate code to register the components\n+\tof a derived type coarray prior to initialization.\n+\t(gfc_conv_structure): Set flag that the structure is in a coarray.\n+\t(gfc_trans_scalar_assign): Add flag to indicate being in a coarray and\n+\tset the structure_alloc_comps modes correctly.\n+\t(gfc_trans_assignment_1): Figure being in a coarray expression.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_caf_get): Adapt to new\n+\tstructure_alloc_comps interface.\n+\t(conv_caf_send): Use the old API as long as possible.\n+\t(trans_caf_is_present): Generate code to check whether an allocatable\n+\tcomponent in a derived typed coarray is allocated on a remote image.\n+\t(caf_this_image_ref): Return true, when only reffing this image.\n+\t(gfc_conv_allocated): Convert allocated queries on allocatable\n+\tcomponents to the library API.\n+\t(conv_intrinsic_move_alloc): Adapt to new interface of\n+\tstructure_alloc_comps.\n+\t* trans-openmp.c (gfc_walk_alloc_comps): Likewise.\n+\t(gfc_omp_clause_assign_op): Likewise.\n+\t(gfc_omp_clause_dtor): Likewise.\n+\t* trans-stmt.c (gfc_trans_deallocate): Figure which mode to use when\n+\tdeallocating allocatable components in derived type coarras.\n+\t* trans.c (gfc_allocate_using_lib): Renamed to\n+\tgfc_allcate_using_caf_lib.\n+\t(gfc_allocate_allocatable): Set the registration mode/type of caf-\n+\tregister calls adapting to all the possible allocatable objects.\n+\t(gfc_deallocate_with_status): Add deregistration mode for allocatable\n+\tcomponents in derived type coarrays.\n+\t(gfc_deallocate_scalar_with_status): Likewise.\n+\t* trans.h (enum gfc_coarray_type): Renamed to gfc_coarray_regtype to\n+\tavoid collision with gfc_coarray_deregtype.\n+\n 2016-11-30  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/78593"}, {"sha": "3b80156e3c8a93700475d1d8f086afc4cdce6d72", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -851,6 +851,17 @@ gfc_check_all_any (gfc_expr *mask, gfc_expr *dim)\n bool\n gfc_check_allocated (gfc_expr *array)\n {\n+  /* Tests on allocated components of coarrays need to detour the check to\n+     argument of the _caf_get.  */\n+  if (flag_coarray == GFC_FCOARRAY_LIB && array->expr_type == EXPR_FUNCTION\n+      && array->value.function.isym\n+      && array->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    {\n+      array = array->value.function.actual->expr;\n+      if (!array->ref)\n+\treturn false;\n+    }\n+\n   if (!variable_check (array, 0, false))\n     return false;\n   if (!allocatable_check (array, 0))"}, {"sha": "370b2a0e89ca2e46fb31e268cf5e13de81d5795e", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -3274,7 +3274,7 @@ const char *gfc_dt_upper_string (const char *);\n /* primary.c */\n symbol_attribute gfc_variable_attr (gfc_expr *, gfc_typespec *);\n symbol_attribute gfc_expr_attr (gfc_expr *);\n-symbol_attribute gfc_caf_attr (gfc_expr *, bool in_allocate = false);\n+symbol_attribute gfc_caf_attr (gfc_expr *, bool i = false, bool *r = NULL);\n match gfc_match_rvalue (gfc_expr **);\n match gfc_match_varspec (gfc_expr*, int, bool, bool);\n int gfc_check_digit (char, int);"}, {"sha": "5e2a750f98d076f817667d506ae89f21881b9380", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -3871,6 +3871,7 @@ of such a type\n @menu\n * caf_token_t::\n * caf_register_t::\n+* caf_deregister_t::\n * caf_reference_t::\n @end menu\n \n@@ -3893,11 +3894,39 @@ typedef enum caf_register_t {\n   CAF_REGTYPE_LOCK_ALLOC,\n   CAF_REGTYPE_CRITICAL,\n   CAF_REGTYPE_EVENT_STATIC,\n-  CAF_REGTYPE_EVENT_ALLOC\n+  CAF_REGTYPE_EVENT_ALLOC,\n+  CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY,\n+  CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY\n }\n caf_register_t;\n @end verbatim\n \n+The values @code{CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY} and\n+@code{CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY} are for allocatable components\n+in derived type coarrays only.  The first one sets up the token without\n+allocating memory for allocatable component.  The latter one only allocates the\n+memory for an allocatable component in a derived type coarray.  The token\n+needs to be setup previously by the REGISTER_ONLY.  This allows to have\n+allocatable components un-allocated on some images.  The status whether an\n+allocatable component is allocated on a remote image can be queried by\n+@code{_caf_is_present} which used internally by the @code{ALLOCATED}\n+intrinsic.\n+\n+@node caf_deregister_t\n+@subsection @code{caf_deregister_t}\n+\n+@verbatim\n+typedef enum caf_deregister_t {\n+  CAF_DEREGTYPE_COARRAY_DEREGISTER,\n+  CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY\n+}\n+caf_deregister_t;\n+@end verbatim\n+\n+Allows to specifiy the type of deregistration of a coarray object.  The\n+@code{CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY} flag is only allowed for\n+allocatable components in derived type coarrays.\n+\n @node caf_reference_t\n @subsection @code{caf_reference_t}\n \n@@ -4017,6 +4046,7 @@ descriptor-less arrays.  The library caf_single has untested support for it.\n * _gfortran_caf_num_images:: Querying the maximal number of images\n * _gfortran_caf_register:: Registering coarrays\n * _gfortran_caf_deregister:: Deregistering coarrays\n+* _gfortran_caf_is_present:: Query whether an allocatable component in a derived type coarray is allocated\n * _gfortran_caf_send:: Sending data from a local image to a remote image\n * _gfortran_caf_get:: Getting data from a remote image\n * _gfortran_caf_sendget:: Sending data between remote images\n@@ -4218,6 +4248,7 @@ section) such as the value false; for event types, the initial state should\n be no event, e.g. zero.\n @end table\n \n+\n @node _gfortran_caf_deregister\n @subsection @code{_gfortran_caf_deregister} --- Deregistering coarrays\n @cindex Coarray, _gfortran_caf_deregister\n@@ -4231,12 +4262,16 @@ library is only expected to free memory it allocated itself during a call to\n @code{_gfortran_caf_register}.\n \n @item @emph{Syntax}:\n-@code{void caf_deregister (caf_token_t *token, int *stat, char *errmsg,\n-int errmsg_len)}\n+@code{void caf_deregister (caf_token_t *token, caf_deregister_t type,\n+int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{token} @tab the token to free.\n+@item @var{type} @tab the type of action to take for the coarray.  A\n+@code{CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY} is allowed only for allocatable\n+components of derived type coarrays.  The action only deallocates the local\n+memory without deleting the token.\n @item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set\n to an error message; may be NULL\n@@ -4250,6 +4285,31 @@ and via destructors.\n @end table\n \n \n+@node _gfortran_caf_is_present\n+@subsection @code{_gfortran_caf_is_present} --- Query whether an allocatable component in a derived type coarray is allocated\n+@cindex Coarray, _gfortran_caf_is_present\n+\n+@table @asis\n+@item @emph{Description}:\n+Used to query the coarray library whether an allocatable component in a derived\n+type coarray is allocated on a remote image.\n+\n+@item @emph{Syntax}:\n+@code{void _gfortran_caf_is_present (caf_token_t token, int image_index,\n+gfc_reference_t *ref)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{token} @tab An opaque pointer identifying the coarray.\n+@item @var{image_index} @tab The ID of the remote image; must be a positive\n+number.\n+@item @var{ref} @tab A chain of references to address the allocatable component\n+in the derived type coarray.  The object reffed needs to be a scalar or a full\n+array ref, respectively.\n+@end multitable\n+\n+@end table\n+\n @node _gfortran_caf_send\n @subsection @code{_gfortran_caf_send} --- Sending data from a local image to a remote image\n @cindex Coarray, _gfortran_caf_send"}, {"sha": "eb2d780943202cf19302268cd32dafcf1406cb8a", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -2418,10 +2418,15 @@ gfc_expr_attr (gfc_expr *e)\n    attribute is.  This routine is similar to gfc_variable_attr with\n    parts of gfc_expr_attr, but focuses more on the needs of\n    coarrays.  For coarrays a codimension attribute is kind of\n-   \"infectious\" being propagated once set and never cleared.  */\n+   \"infectious\" being propagated once set and never cleared.\n+   The coarray_comp is only set, when the expression refs a coarray\n+   component.  REFS_COMP is set when present to true only, when this EXPR\n+   refs a (non-_data) component.  To check whether EXPR refs an allocatable\n+   component in a derived type coarray *refs_comp needs to be set and\n+   coarray_comp has to false.  */\n \n static symbol_attribute\n-caf_variable_attr (gfc_expr *expr, bool in_allocate)\n+caf_variable_attr (gfc_expr *expr, bool in_allocate, bool *refs_comp)\n {\n   int dimension, codimension, pointer, allocatable, target, coarray_comp,\n       alloc_comp;\n@@ -2436,13 +2441,15 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate)\n   sym = expr->symtree->n.sym;\n   gfc_clear_attr (&attr);\n \n+  if (refs_comp)\n+    *refs_comp = 0;\n+\n   if (sym->ts.type == BT_CLASS && sym->attr.class_ok)\n     {\n       dimension = CLASS_DATA (sym)->attr.dimension;\n       codimension = CLASS_DATA (sym)->attr.codimension;\n       pointer = CLASS_DATA (sym)->attr.class_pointer;\n       allocatable = CLASS_DATA (sym)->attr.allocatable;\n-      coarray_comp = CLASS_DATA (sym)->attr.coarray_comp;\n       alloc_comp = CLASS_DATA (sym)->ts.u.derived->attr.alloc_comp;\n     }\n   else\n@@ -2451,12 +2458,11 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate)\n       codimension = sym->attr.codimension;\n       pointer = sym->attr.pointer;\n       allocatable = sym->attr.allocatable;\n-      coarray_comp = sym->attr.coarray_comp;\n       alloc_comp = sym->ts.type == BT_DERIVED\n \t  ? sym->ts.u.derived->attr.alloc_comp : 0;\n     }\n \n-  target = attr.target;\n+  target = coarray_comp = 0;\n   if (pointer || attr.proc_pointer)\n     target = 1;\n \n@@ -2494,19 +2500,26 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate)\n \n \tif (comp->ts.type == BT_CLASS)\n \t  {\n+\t    /* Set coarray_comp only, when this component introduces the\n+\t       coarray.  */\n+\t    coarray_comp = !codimension && CLASS_DATA (comp)->attr.codimension;\n \t    codimension |= CLASS_DATA (comp)->attr.codimension;\n \t    pointer = CLASS_DATA (comp)->attr.class_pointer;\n \t    allocatable = CLASS_DATA (comp)->attr.allocatable;\n-\t    coarray_comp |= CLASS_DATA (comp)->attr.coarray_comp;\n \t  }\n \telse\n \t  {\n+\t    /* Set coarray_comp only, when this component introduces the\n+\t       coarray.  */\n+\t    coarray_comp = !codimension && comp->attr.codimension;\n \t    codimension |= comp->attr.codimension;\n \t    pointer = comp->attr.pointer;\n \t    allocatable = comp->attr.allocatable;\n-\t    coarray_comp |= comp->attr.coarray_comp;\n \t  }\n \n+\tif (refs_comp && strcmp (comp->name, \"_data\") != 0)\n+\t  *refs_comp = 1;\n+\n \tif (pointer || attr.proc_pointer)\n \t  target = 1;\n \n@@ -2531,14 +2544,14 @@ caf_variable_attr (gfc_expr *expr, bool in_allocate)\n \n \n symbol_attribute\n-gfc_caf_attr (gfc_expr *e, bool in_allocate)\n+gfc_caf_attr (gfc_expr *e, bool in_allocate, bool *refs_comp)\n {\n   symbol_attribute attr;\n \n   switch (e->expr_type)\n     {\n     case EXPR_VARIABLE:\n-      attr = caf_variable_attr (e, in_allocate);\n+      attr = caf_variable_attr (e, in_allocate, refs_comp);\n       break;\n \n     case EXPR_FUNCTION:\n@@ -2557,7 +2570,7 @@ gfc_caf_attr (gfc_expr *e, bool in_allocate)\n \t    }\n \t}\n       else if (e->symtree)\n-\tattr = caf_variable_attr (e, in_allocate);\n+\tattr = caf_variable_attr (e, in_allocate, refs_comp);\n       else\n \tgfc_clear_attr (&attr);\n       break;"}, {"sha": "803462a4ec80ab63010a5220f4c45a42fafbc8d0", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 358, "deletions": 90, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -5633,12 +5633,13 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n tree\n gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n-\t\t      tree label_finish, gfc_expr* expr)\n+\t\t      tree label_finish, gfc_expr* expr,\n+\t\t      int coarray_dealloc_mode)\n {\n   tree var;\n   tree tmp;\n   stmtblock_t block;\n-  bool coarray = gfc_caf_attr (expr).codimension;\n+  bool coarray = coarray_dealloc_mode != GFC_CAF_COARRAY_NOCOARRAY;\n \n   gfc_start_block (&block);\n \n@@ -5648,7 +5649,8 @@ gfc_array_deallocate (tree descriptor, tree pstat, tree errmsg, tree errlen,\n \n   /* Parameter is the address of the data component.  */\n   tmp = gfc_deallocate_with_status (coarray ? descriptor : var, pstat, errmsg,\n-\t\t\t\t    errlen, label_finish, false, expr, coarray);\n+\t\t\t\t    errlen, label_finish, false, expr,\n+\t\t\t\t    coarray_dealloc_mode);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer; only for coarrays an error can occur and then\n@@ -7782,11 +7784,13 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, bool g77,\n /* Generate code to deallocate an array, if it is allocated.  */\n \n tree\n-gfc_trans_dealloc_allocated (tree descriptor, bool coarray, gfc_expr *expr)\n+gfc_trans_dealloc_allocated (tree descriptor, gfc_expr *expr,\n+\t\t\t     int coarray_dealloc_mode)\n {\n   tree tmp;\n   tree var;\n   stmtblock_t block;\n+  bool coarray = coarray_dealloc_mode != GFC_CAF_COARRAY_NOCOARRAY;\n \n   gfc_start_block (&block);\n \n@@ -7797,8 +7801,8 @@ gfc_trans_dealloc_allocated (tree descriptor, bool coarray, gfc_expr *expr)\n      Although it is ignored here, it's presence ensures that arrays that\n      are already deallocated are ignored.  */\n   tmp = gfc_deallocate_with_status (coarray ? descriptor : var, NULL_TREE,\n-\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE, true,\n-\t\t\t\t    expr, coarray);\n+\t\t\t\t    NULL_TREE, NULL_TREE, NULL_TREE, true, expr,\n+\t\t\t\t    coarray_dealloc_mode);\n   gfc_add_expr_to_block (&block, tmp);\n \n   /* Zero the data pointer.  */\n@@ -7855,9 +7859,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n \n   if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))\n     {\n-      tmp = null_pointer_node;\n-      tmp = fold_build2_loc (input_location, MODIFY_EXPR, type, dest, tmp);\n-      gfc_add_expr_to_block (&block, tmp);\n+      gfc_add_modify (&block, dest, fold_convert (type, null_pointer_node));\n       null_data = gfc_finish_block (&block);\n \n       gfc_init_block (&block);\n@@ -7869,9 +7871,7 @@ duplicate_allocatable (tree dest, tree src, tree type, int rank,\n       if (!no_malloc)\n \t{\n \t  tmp = gfc_call_malloc (&block, type, size);\n-\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, void_type_node,\n-\t\t\t\t dest, fold_convert (type, tmp));\n-\t  gfc_add_expr_to_block (&block, tmp);\n+\t  gfc_add_modify (&block, dest, fold_convert (type, tmp));\n \t}\n \n       if (!no_memcpy)\n@@ -7967,17 +7967,152 @@ gfc_duplicate_allocatable_nocopy (tree dest, tree src, tree type, int rank)\n }\n \n \n+static tree\n+duplicate_allocatable_coarray (tree dest, tree dest_tok, tree src,\n+\t\t\t       tree type, int rank)\n+{\n+  tree tmp;\n+  tree size;\n+  tree nelems;\n+  tree null_cond;\n+  tree null_data;\n+  stmtblock_t block, globalblock;\n+\n+  /* If the source is null, set the destination to null.  Then,\n+     allocate memory to the destination.  */\n+  gfc_init_block (&block);\n+  gfc_init_block (&globalblock);\n+\n+  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (dest)))\n+    {\n+      gfc_se se;\n+      symbol_attribute attr;\n+      tree dummy_desc;\n+\n+      gfc_init_se (&se, NULL);\n+      dummy_desc = gfc_conv_scalar_to_descriptor (&se, dest, attr);\n+      gfc_add_block_to_block (&globalblock, &se.pre);\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (type));\n+\n+      gfc_add_modify (&block, dest, fold_convert (type, null_pointer_node));\n+      gfc_allocate_using_caf_lib (&block, dummy_desc, size,\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, dest_tok),\n+\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t  GFC_CAF_COARRAY_ALLOC_REGISTER_ONLY);\n+      null_data = gfc_finish_block (&block);\n+\n+      gfc_init_block (&block);\n+\n+      gfc_allocate_using_caf_lib (&block, dummy_desc,\n+\t\t\t\t  fold_convert (size_type_node, size),\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, dest_tok),\n+\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t  GFC_CAF_COARRAY_ALLOC);\n+\n+      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+      tmp = build_call_expr_loc (input_location, tmp, 3, dest, src,\n+\t\t\t\t fold_convert (size_type_node, size));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+  else\n+    {\n+      /* Set the rank or unitialized memory access may be reported.  */\n+      tmp = gfc_conv_descriptor_dtype (dest);\n+      gfc_add_modify (&globalblock, tmp, build_int_cst (TREE_TYPE (tmp), rank));\n+\n+      if (rank)\n+\tnelems = gfc_full_array_size (&block, src, rank);\n+      else\n+\tnelems = integer_one_node;\n+\n+      tmp = fold_convert (size_type_node,\n+\t\t\t  TYPE_SIZE_UNIT (gfc_get_element_type (type)));\n+      size = fold_build2_loc (input_location, MULT_EXPR, size_type_node,\n+\t\t\t      fold_convert (size_type_node, nelems), tmp);\n+\n+      gfc_conv_descriptor_data_set (&block, dest, null_pointer_node);\n+      gfc_allocate_using_caf_lib (&block, dest, fold_convert (size_type_node,\n+\t\t\t\t\t\t\t      size),\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, dest_tok),\n+\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t  GFC_CAF_COARRAY_ALLOC_REGISTER_ONLY);\n+      null_data = gfc_finish_block (&block);\n+\n+      gfc_init_block (&block);\n+      gfc_allocate_using_caf_lib (&block, dest,\n+\t\t\t\t  fold_convert (size_type_node, size),\n+\t\t\t\t  gfc_build_addr_expr (NULL_TREE, dest_tok),\n+\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t  GFC_CAF_COARRAY_ALLOC);\n+\n+      tmp = builtin_decl_explicit (BUILT_IN_MEMCPY);\n+      tmp = build_call_expr_loc (input_location, tmp, 3,\n+\t\t\t\t gfc_conv_descriptor_data_get (dest),\n+\t\t\t\t gfc_conv_descriptor_data_get (src),\n+\t\t\t\t fold_convert (size_type_node, size));\n+      gfc_add_expr_to_block (&block, tmp);\n+    }\n+\n+  tmp = gfc_finish_block (&block);\n+\n+  /* Null the destination if the source is null; otherwise do\n+     the register and copy.  */\n+  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (src)))\n+    null_cond = src;\n+  else\n+    null_cond = gfc_conv_descriptor_data_get (src);\n+\n+  null_cond = convert (pvoid_type_node, null_cond);\n+  null_cond = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t       null_cond, null_pointer_node);\n+  gfc_add_expr_to_block (&globalblock, build3_v (COND_EXPR, null_cond, tmp,\n+\t\t\t\t\t\t null_data));\n+  return gfc_finish_block (&globalblock);\n+}\n+\n+\n+/* Helper function to abstract whether coarray processing is enabled.  */\n+\n+static bool\n+caf_enabled (int caf_mode)\n+{\n+  return (caf_mode & GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY)\n+      == GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY;\n+}\n+\n+\n+/* Helper function to abstract whether coarray processing is enabled\n+   and we are in a derived type coarray.  */\n+\n+static bool\n+caf_in_coarray (int caf_mode)\n+{\n+  static const int pat = GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY\n+\t\t\t | GFC_STRUCTURE_CAF_MODE_IN_COARRAY;\n+  return (caf_mode & pat) == pat;\n+}\n+\n+\n+/* Helper function to abstract whether coarray is to deallocate only.  */\n+\n+bool\n+gfc_caf_is_dealloc_only (int caf_mode)\n+{\n+  return (caf_mode & GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY)\n+      == GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY;\n+}\n+\n+\n /* Recursively traverse an object of derived type, generating code to\n    deallocate, nullify or copy allocatable components.  This is the work horse\n    function for the functions named in this enum.  */\n \n-enum {DEALLOCATE_ALLOC_COMP = 1, DEALLOCATE_ALLOC_COMP_NO_CAF,\n-      NULLIFY_ALLOC_COMP, COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP,\n-      COPY_ALLOC_COMP_CAF};\n+enum {DEALLOCATE_ALLOC_COMP = 1, NULLIFY_ALLOC_COMP,\n+      COPY_ALLOC_COMP, COPY_ONLY_ALLOC_COMP, REASSIGN_CAF_COMP};\n \n static tree\n structure_alloc_comps (gfc_symbol * der_type, tree decl,\n-\t\t       tree dest, int rank, int purpose)\n+\t\t       tree dest, int rank, int purpose, int caf_mode)\n {\n   gfc_component *c;\n   gfc_loopinfo loop;\n@@ -8011,10 +8146,10 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       /* Deref dest in sync with decl, but only when it is not NULL.  */\n       if (dest)\n \tdest = build_fold_indirect_ref_loc (input_location, dest);\n-    }\n \n-  /* Just in case it gets dereferenced.  */\n-  decl_type = TREE_TYPE (decl);\n+      /* Update the decl_type because it got dereferenced.  */\n+      decl_type = TREE_TYPE (decl);\n+    }\n \n   /* If this is an array of derived types with allocatable components\n      build a loop and recursively call this function.  */\n@@ -8056,16 +8191,18 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n       vref = gfc_build_array_ref (var, index, NULL);\n \n-      if (purpose == COPY_ALLOC_COMP || purpose == COPY_ONLY_ALLOC_COMP)\n-        {\n+      if ((purpose == COPY_ALLOC_COMP || purpose == COPY_ONLY_ALLOC_COMP)\n+\t  && !caf_enabled (caf_mode))\n+\t{\n \t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t gfc_conv_array_data (dest));\n \t  dref = gfc_build_array_ref (tmp, index, NULL);\n \t  tmp = structure_alloc_comps (der_type, vref, dref, rank,\n-\t\t\t\t       COPY_ALLOC_COMP);\n+\t\t\t\t       COPY_ALLOC_COMP, 0);\n \t}\n       else\n-        tmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose);\n+\ttmp = structure_alloc_comps (der_type, vref, NULL_TREE, rank, purpose,\n+\t\t\t\t     caf_mode);\n \n       gfc_add_expr_to_block (&loopbody, tmp);\n \n@@ -8111,7 +8248,6 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n       switch (purpose)\n \t{\n \tcase DEALLOCATE_ALLOC_COMP:\n-\tcase DEALLOCATE_ALLOC_COMP_NO_CAF:\n \n \t  /* gfc_deallocate_scalar_with_status calls gfc_deallocate_alloc_comp\n \t     (i.e. this function) so generate all the calls and suppress the\n@@ -8128,21 +8264,57 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      /* The finalizer frees allocatable components.  */\n \t      called_dealloc_with_status\n \t\t= gfc_add_comp_finalizer_call (&tmpblock, comp, c,\n-\t\t\t\t\t       purpose == DEALLOCATE_ALLOC_COMP);\n+\t\t\t\t\t       purpose == DEALLOCATE_ALLOC_COMP\n+\t\t\t\t\t       && caf_enabled (caf_mode));\n \t    }\n \t  else\n \t    comp = NULL_TREE;\n \n-\t  if (c->attr.allocatable && !c->attr.proc_pointer\n+\t  if (c->attr.allocatable && !c->attr.proc_pointer && !same_type\n \t      && (c->attr.dimension\n-\t\t  || (c->attr.codimension\n-\t\t      && purpose != DEALLOCATE_ALLOC_COMP_NO_CAF))\n-\t      && !same_type)\n+\t\t  || (caf_enabled (caf_mode)\n+\t\t      && (caf_in_coarray (caf_mode) || c->attr.codimension))))\n \t    {\n+\t      /* Allocatable arrays or coarray'ed components (scalar or\n+\t\t array).  */\n+\t      int caf_dereg_mode\n+\t\t  = (caf_in_coarray (caf_mode) || c->attr.codimension)\n+\t\t  ? (gfc_caf_is_dealloc_only (caf_mode)\n+\t\t     ? GFC_CAF_COARRAY_DEALLOCATE_ONLY\n+\t\t     : GFC_CAF_COARRAY_DEREGISTER)\n+\t\t  : GFC_CAF_COARRAY_NOCOARRAY;\n \t      if (comp == NULL_TREE)\n \t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t\tdecl, cdecl, NULL_TREE);\n-\t      tmp = gfc_trans_dealloc_allocated (comp, c->attr.codimension, NULL);\n+\n+\t      if (c->attr.dimension || c->attr.codimension)\n+\t\t/* Deallocate array.  */\n+\t\ttmp = gfc_trans_dealloc_allocated (comp, NULL, caf_dereg_mode);\n+\t      else\n+\t\t{\n+\t\t  /* Deallocate scalar.  */\n+\t\t  tree cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t\t\t       boolean_type_node, comp,\n+\t\t\t\t\t       build_int_cst (TREE_TYPE (comp),\n+\t\t\t\t\t\t\t      0));\n+\n+\t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t pvoid_type_node, decl, c->caf_token,\n+\t\t\t\t\t NULL_TREE);\n+\t\t  tmp = build_call_expr_loc (input_location,\n+\t\t\t\t\t     gfor_fndecl_caf_deregister, 5,\n+\t\t\t\t\t     gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\t\t\t  tmp),\n+\t\t\t\t\t     build_int_cst (integer_type_node,\n+\t\t\t\t\t\t\t    caf_dereg_mode),\n+\t\t\t\t\t     null_pointer_node,\n+\t\t\t\t\t     null_pointer_node,\n+\t\t\t\t\t     integer_zero_node);\n+\t\t  tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t\t\t void_type_node, cond, tmp,\n+\t\t\t\t\t build_empty_stmt (input_location));\n+\t\t}\n+\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable && !c->attr.codimension && !same_type)\n@@ -8152,7 +8324,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\tcomp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t\tdecl, cdecl, NULL_TREE);\n \n-\t      tmp = gfc_deallocate_scalar_with_status (comp, NULL, true, NULL,\n+\t      tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE,\n+\t\t\t\t\t\t       NULL_TREE, true, NULL,\n \t\t\t\t\t\t       c->ts);\n \t      gfc_add_expr_to_block (&tmpblock, tmp);\n \t      called_dealloc_with_status = true;\n@@ -8168,8 +8341,6 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      tree is_allocated;\n \t      tree ubound;\n \t      tree cdesc;\n-\t      tree zero = build_int_cst (gfc_array_index_type, 0);\n-\t      tree unity = build_int_cst (gfc_array_index_type, 1);\n \t      tree data;\n \t      stmtblock_t dealloc_block;\n \n@@ -8191,8 +8362,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t  ubound = build_int_cst (gfc_array_index_type, 1);\n \t\t}\n \n-\t      cdesc = gfc_get_array_type_bounds (tmp, 1, 0,\n-\t\t\t\t\t\t &unity, &ubound, 1,\n+\t      cdesc = gfc_get_array_type_bounds (tmp, 1, 0, &gfc_index_one_node,\n+\t\t\t\t\t\t &ubound, 1,\n \t\t\t\t\t\t GFC_ARRAY_ALLOCATABLE, false);\n \n \t      cdesc = gfc_create_var (cdesc, \"cdesc\");\n@@ -8201,11 +8372,13 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_modify (&dealloc_block, gfc_conv_descriptor_dtype (cdesc),\n \t\t\t      gfc_get_dtype_rank_type (1, tmp));\n \t      gfc_conv_descriptor_lbound_set (&dealloc_block, cdesc,\n-\t\t\t\t\t      zero, unity);\n+\t\t\t\t\t      gfc_index_zero_node,\n+\t\t\t\t\t      gfc_index_one_node);\n \t      gfc_conv_descriptor_stride_set (&dealloc_block, cdesc,\n-\t\t\t\t\t      zero, unity);\n+\t\t\t\t\t      gfc_index_zero_node,\n+\t\t\t\t\t      gfc_index_one_node);\n \t      gfc_conv_descriptor_ubound_set (&dealloc_block, cdesc,\n-\t\t\t\t\t      zero, ubound);\n+\t\t\t\t\t      gfc_index_zero_node, ubound);\n \n \t      if (c->attr.dimension)\n \t\tdata = gfc_conv_descriptor_data_get (comp);\n@@ -8247,7 +8420,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable\n \t\t   && (!CLASS_DATA (c)->attr.codimension\n-\t\t       || purpose != DEALLOCATE_ALLOC_COMP_NO_CAF))\n+\t\t    || !caf_enabled (caf_mode)))\n \t    {\n \t      /* Allocatable CLASS components.  */\n \n@@ -8257,11 +8430,15 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      TREE_TYPE (tmp), comp, tmp, NULL_TREE);\n \n \t      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (comp)))\n-\t        tmp = gfc_trans_dealloc_allocated (comp,\n-\t\t\t\t\tCLASS_DATA (c)->attr.codimension, NULL);\n+\t\ttmp = gfc_trans_dealloc_allocated (comp, NULL,\n+\t\t\t\t\t\tCLASS_DATA (c)->attr.codimension\n+\t\t\t\t\t\t? GFC_CAF_COARRAY_DEREGISTER\n+\t\t\t\t\t\t: GFC_CAF_COARRAY_NOCOARRAY);\n \t      else\n \t\t{\n-\t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE, true, NULL,\n+\t\t  tmp = gfc_deallocate_scalar_with_status (comp, NULL_TREE,\n+\t\t\t\t\t\t\t   NULL_TREE, true,\n+\t\t\t\t\t\t\t   NULL,\n \t\t\t\t\t\t\t   CLASS_DATA (c)->ts);\n \t\t  gfc_add_expr_to_block (&tmpblock, tmp);\n \t\t  called_dealloc_with_status = true;\n@@ -8317,7 +8494,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose);\n+\t\t\t\t\t   rank, purpose, caf_mode);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \n@@ -8326,14 +8503,20 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t  break;\n \n \tcase NULLIFY_ALLOC_COMP:\n-\t  if (c->attr.pointer || c->attr.proc_pointer)\n+\t  if (c->attr.pointer || c->attr.proc_pointer\n+\t      || !(c->attr.allocatable || (c->ts.type == BT_CLASS\n+\t\t\t\t\t   && CLASS_DATA (c)->attr.allocatable)\n+\t\t   || cmp_has_alloc_comps))\n \t    continue;\n-\t  else if (c->attr.allocatable\n-\t\t   && (c->attr.dimension|| c->attr.codimension))\n+\n+\t  /* Coarrays need the component to be initialized before the api-call\n+\t     is made.  */\n+\t  if (c->attr.allocatable && (c->attr.dimension || c->attr.codimension))\n \t    {\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      gfc_conv_descriptor_data_set (&fnblock, comp, null_pointer_node);\n+\t      cmp_has_alloc_comps = false;\n \t    }\n \t  else if (c->attr.allocatable)\n \t    {\n@@ -8354,6 +8537,7 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n+\t      cmp_has_alloc_comps = false;\n \t    }\n \t  else if (c->ts.type == BT_CLASS && CLASS_DATA (c)->attr.allocatable)\n \t    {\n@@ -8371,46 +8555,92 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t\t\t\t\t build_int_cst (TREE_TYPE (comp), 0));\n \t\t  gfc_add_expr_to_block (&fnblock, tmp);\n \t\t}\n+\t      cmp_has_alloc_comps = false;\n+\t    }\n+\n+\t  if (flag_coarray == GFC_FCOARRAY_LIB\n+\t      && (caf_in_coarray (caf_mode) || c->attr.codimension))\n+\t    {\n+\t      /* Register the component with the coarray library.  */\n+\t      tree token;\n+\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n+\t      if (c->attr.dimension || c->attr.codimension)\n+\t\t{\n+\t\t  tmp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t\t decl, cdecl, NULL_TREE);\n+\t\t  token = gfc_conv_descriptor_token (tmp);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gfc_se se;\n+\t\t  symbol_attribute attr;\n+\n+\t\t  gfc_init_se (&se, NULL);\n+\t\t  gfc_clear_attr (&attr);\n+\t\t  token = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t   pvoid_type_node, decl, c->caf_token,\n+\t\t\t\t\t   NULL_TREE);\n+\t\t  comp = gfc_conv_scalar_to_descriptor (&se, comp, attr);\n+\t\t  gfc_add_block_to_block (&fnblock, &se.pre);\n+\t\t}\n+\n+\t      /* NULL the member-token before registering it or uninitialized\n+\t\t memory accesses may occur.  */\n+\t      gfc_add_modify (&fnblock, token, fold_convert (TREE_TYPE (token),\n+\t\t\t\t\t\t\t    null_pointer_node));\n+\t      gfc_allocate_using_caf_lib (&fnblock, comp, size_zero_node,\n+\t\t\t\t\t  gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\t\t\t       token),\n+\t\t\t\t\t  NULL_TREE, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t  GFC_CAF_COARRAY_ALLOC_REGISTER_ONLY);\n \t    }\n-          else if (cmp_has_alloc_comps)\n+\n+\t  if (cmp_has_alloc_comps)\n \t    {\n \t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n \t\t\t\t      decl, cdecl, NULL_TREE);\n \t      rank = c->as ? c->as->rank : 0;\n \t      tmp = structure_alloc_comps (c->ts.u.derived, comp, NULL_TREE,\n-\t\t\t\t\t   rank, purpose);\n+\t\t\t\t\t   rank, purpose, caf_mode);\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  break;\n \n-\tcase COPY_ALLOC_COMP_CAF:\n-\t  if (!c->attr.codimension\n-\t      && (c->ts.type != BT_CLASS || CLASS_DATA (c)->attr.coarray_comp)\n-\t      && (c->ts.type != BT_DERIVED\n-\t\t  || !c->ts.u.derived->attr.coarray_comp))\n-\t    continue;\n-\n-\t  comp = fold_build3_loc (input_location, COMPONENT_REF, ctype, decl,\n-\t\t\t\t  cdecl, NULL_TREE);\n-\t  dcmp = fold_build3_loc (input_location, COMPONENT_REF, ctype, dest,\n-\t\t\t\t  cdecl, NULL_TREE);\n-\n-\t  if (c->attr.codimension)\n+\tcase REASSIGN_CAF_COMP:\n+\t  if (caf_enabled (caf_mode)\n+\t      && (c->attr.codimension\n+\t\t  || (c->ts.type == BT_CLASS\n+\t\t      && (CLASS_DATA (c)->attr.coarray_comp\n+\t\t\t  || caf_in_coarray (caf_mode)))\n+\t\t  || (c->ts.type == BT_DERIVED\n+\t\t      && (c->ts.u.derived->attr.coarray_comp\n+\t\t\t  || caf_in_coarray (caf_mode))))\n+\t      && !same_type)\n \t    {\n-\t      if (c->ts.type == BT_CLASS)\n+\t      comp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      decl, cdecl, NULL_TREE);\n+\t      dcmp = fold_build3_loc (input_location, COMPONENT_REF, ctype,\n+\t\t\t\t      dest, cdecl, NULL_TREE);\n+\n+\t      if (c->attr.codimension)\n \t\t{\n-\t\t  comp = gfc_class_data_get (comp);\n-\t\t  dcmp = gfc_class_data_get (dcmp);\n-\t\t}\n-\t      gfc_conv_descriptor_data_set (&fnblock, dcmp,\n+\t\t  if (c->ts.type == BT_CLASS)\n+\t\t    {\n+\t\t      comp = gfc_class_data_get (comp);\n+\t\t      dcmp = gfc_class_data_get (dcmp);\n+\t\t    }\n+\t\t  gfc_conv_descriptor_data_set (&fnblock, dcmp,\n \t\t\t\t\t   gfc_conv_descriptor_data_get (comp));\n-\t    }\n-\t  else\n-\t    {\n-\t      tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n-\t\t\t\t\t   rank, purpose);\n-\t      gfc_add_expr_to_block (&fnblock, tmp);\n-\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  tmp = structure_alloc_comps (c->ts.u.derived, comp, dcmp,\n+\t\t\t\t\t       rank, purpose, caf_mode\n+\t\t\t\t\t   | GFC_STRUCTURE_CAF_MODE_IN_COARRAY);\n+\t\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t\t}\n \t    }\n \t  break;\n \n@@ -8503,7 +8733,8 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_modify (&fnblock, dcmp, tmp);\n \t      add_when_allocated = structure_alloc_comps (c->ts.u.derived,\n \t\t\t\t\t\t\t  comp, dcmp,\n-\t\t\t\t\t\t\t  rank, purpose);\n+\t\t\t\t\t\t\t  rank, purpose,\n+\t\t\t\t\t\t\t  caf_mode);\n \t    }\n \t  else\n \t    add_when_allocated = NULL_TREE;\n@@ -8530,11 +8761,24 @@ structure_alloc_comps (gfc_symbol * der_type, tree decl,\n \t      gfc_add_expr_to_block (&fnblock, tmp);\n \t    }\n \t  else if (c->attr.allocatable && !c->attr.proc_pointer && !same_type\n-\t\t   && (!(cmp_has_alloc_comps && c->as) || c->attr.codimension))\n+\t\t   && (!(cmp_has_alloc_comps && c->as) || c->attr.codimension\n+\t\t       || caf_in_coarray (caf_mode)))\n \t    {\n \t      rank = c->as ? c->as->rank : 0;\n \t      if (c->attr.codimension)\n \t\ttmp = gfc_copy_allocatable_data (dcmp, comp, ctype, rank);\n+\t      else if (flag_coarray == GFC_FCOARRAY_LIB\n+\t\t       && caf_in_coarray (caf_mode))\n+\t\t{\n+\t\t  tree dst_tok = c->as ? gfc_conv_descriptor_token (dcmp)\n+\t\t\t\t       : fold_build3_loc (input_location,\n+\t\t\t\t\t\t\t  COMPONENT_REF,\n+\t\t\t\t\t\t\t  pvoid_type_node, dest,\n+\t\t\t\t\t\t\t  c->caf_token,\n+\t\t\t\t\t\t\t  NULL_TREE);\n+\t\t  tmp = duplicate_allocatable_coarray (dcmp, dst_tok, comp,\n+\t\t\t\t\t\t       ctype, rank);\n+\t\t}\n \t      else\n \t\ttmp = gfc_duplicate_allocatable (dcmp, comp, ctype, rank,\n \t\t\t\t\t\t add_when_allocated);\n@@ -8562,18 +8806,21 @@ tree\n gfc_nullify_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tNULLIFY_ALLOC_COMP);\n+\t\t\t\tNULLIFY_ALLOC_COMP,\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY);\n }\n \n \n /* Recursively traverse an object of derived type, generating code to\n    deallocate allocatable components.  */\n \n tree\n-gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank)\n+gfc_deallocate_alloc_comp (gfc_symbol * der_type, tree decl, int rank,\n+\t\t\t   int caf_mode)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tDEALLOCATE_ALLOC_COMP);\n+\t\t\t\tDEALLOCATE_ALLOC_COMP,\n+\t\t\t      GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY | caf_mode);\n }\n \n \n@@ -8586,24 +8833,27 @@ tree\n gfc_deallocate_alloc_comp_no_caf (gfc_symbol * der_type, tree decl, int rank)\n {\n   return structure_alloc_comps (der_type, decl, NULL_TREE, rank,\n-\t\t\t\tDEALLOCATE_ALLOC_COMP_NO_CAF);\n+\t\t\t\tDEALLOCATE_ALLOC_COMP, 0);\n }\n \n \n tree\n gfc_reassign_alloc_comp_caf (gfc_symbol *der_type, tree decl, tree dest)\n {\n-  return structure_alloc_comps (der_type, decl, dest, 0, COPY_ALLOC_COMP_CAF);\n+  return structure_alloc_comps (der_type, decl, dest, 0, REASSIGN_CAF_COMP,\n+\t\t\t\tGFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY);\n }\n \n \n /* Recursively traverse an object of derived type, generating code to\n    copy it and its allocatable components.  */\n \n tree\n-gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n+gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank,\n+\t\t     int caf_mode)\n {\n-  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ALLOC_COMP);\n+  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ALLOC_COMP,\n+\t\t\t\tcaf_mode);\n }\n \n \n@@ -8613,7 +8863,8 @@ gfc_copy_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n tree\n gfc_copy_only_alloc_comp (gfc_symbol * der_type, tree decl, tree dest, int rank)\n {\n-  return structure_alloc_comps (der_type, decl, dest, rank, COPY_ONLY_ALLOC_COMP);\n+  return structure_alloc_comps (der_type, decl, dest, rank,\n+\t\t\t\tCOPY_ONLY_ALLOC_COMP, 0);\n }\n \n \n@@ -9205,15 +9456,17 @@ gfc_alloc_allocatable_for_assignment (gfc_loopinfo *loop,\n   else\n     {\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t\t gfor_fndecl_caf_deregister,\n-\t\t\t\t 4, token, null_pointer_node,\n-\t\t\t\t null_pointer_node, integer_zero_node);\n+\t\t\t\t gfor_fndecl_caf_deregister, 5, token,\n+\t\t\t\t build_int_cst (integer_type_node,\n+\t\t\t\t\t       GFC_CAF_COARRAY_DEALLOCATE_ONLY),\n+\t\t\t\t null_pointer_node, null_pointer_node,\n+\t\t\t\t integer_zero_node);\n       gfc_add_expr_to_block (&realloc_block, tmp);\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t gfor_fndecl_caf_register,\n \t\t\t\t 7, size2,\n \t\t\t\t build_int_cst (integer_type_node,\n-\t\t\t\t\t\tGFC_CAF_COARRAY_ALLOC),\n+\t\t\t\t\t   GFC_CAF_COARRAY_ALLOC_ALLOCATE_ONLY),\n \t\t\t\t token, gfc_build_addr_expr (NULL_TREE, desc),\n \t\t\t\t null_pointer_node, null_pointer_node,\n \t\t\t\t integer_zero_node);\n@@ -9398,7 +9651,20 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n \n   /* NULLIFY the data pointer, for non-saved allocatables.  */\n   if (GFC_DESCRIPTOR_TYPE_P (type) && !sym->attr.save && sym->attr.allocatable)\n-    gfc_conv_descriptor_data_set (&init, descriptor, null_pointer_node);\n+    {\n+      gfc_conv_descriptor_data_set (&init, descriptor, null_pointer_node);\n+      if (flag_coarray == GFC_FCOARRAY_LIB && sym->attr.codimension)\n+\t{\n+\t  /* Declare the variable static so its array descriptor stays present\n+\t     after leaving the scope.  It may still be accessed through another\n+\t     image.  This may happen, for example, with the caf_mpi\n+\t     implementation.  */\n+\t  TREE_STATIC (descriptor) = 1;\n+\t  tmp = gfc_conv_descriptor_token (descriptor);\n+\t  gfc_add_modify (&init, tmp, fold_convert (TREE_TYPE (tmp),\n+\t\t\t\t\t\t    null_pointer_node));\n+\t}\n+    }\n \n   gfc_restore_backend_locus (&loc);\n   gfc_init_block (&cleanup);\n@@ -9432,8 +9698,10 @@ gfc_trans_deferred_array (gfc_symbol * sym, gfc_wrapped_block * block)\n     {\n       gfc_expr *e;\n       e = has_finalizer ? gfc_lval_expr_from_sym (sym) : NULL;\n-      tmp = gfc_trans_dealloc_allocated (sym->backend_decl,\n-\t\t\t\t\t sym->attr.codimension, e);\n+      tmp = gfc_trans_dealloc_allocated (sym->backend_decl, e,\n+\t\t\t\t\t sym->attr.codimension\n+\t\t\t\t\t ? GFC_CAF_COARRAY_DEREGISTER\n+\t\t\t\t\t : GFC_CAF_COARRAY_NOCOARRAY);\n       if (e)\n \tgfc_free_expr (e);\n       gfc_add_expr_to_block (&cleanup, tmp);"}, {"sha": "0a6621b0a63666871637dcf456a32ee0735d340d", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -19,7 +19,7 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* Generate code to free an array.  */\n-tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*);\n+tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*, int c = -2);\n \n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n@@ -42,7 +42,7 @@ void gfc_trans_dummy_array_bias (gfc_symbol *, tree, gfc_wrapped_block *);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n void gfc_trans_g77_array (gfc_symbol *, gfc_wrapped_block *);\n /* Generate code to deallocate an array, if it is allocated.  */\n-tree gfc_trans_dealloc_allocated (tree, bool, gfc_expr *);\n+tree gfc_trans_dealloc_allocated (tree, gfc_expr *, int);\n \n tree gfc_full_array_size (stmtblock_t *, tree, int);\n \n@@ -52,13 +52,15 @@ tree gfc_copy_allocatable_data (tree dest, tree src, tree type, int rank);\n \n tree gfc_duplicate_allocatable_nocopy (tree, tree, tree, int);\n \n+bool gfc_caf_is_dealloc_only (int);\n+\n tree gfc_nullify_alloc_comp (gfc_symbol *, tree, int);\n \n-tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int);\n+tree gfc_deallocate_alloc_comp (gfc_symbol *, tree, int, int cm = 0);\n tree gfc_deallocate_alloc_comp_no_caf (gfc_symbol *, tree, int);\n tree gfc_reassign_alloc_comp_caf (gfc_symbol *, tree, tree);\n \n-tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int);\n+tree gfc_copy_alloc_comp (gfc_symbol *, tree, tree, int, int);\n \n tree gfc_copy_only_alloc_comp (gfc_symbol *, tree, tree, int);\n "}, {"sha": "2e6ef2a2bfcb97dcefa7ce089fdb67c5fe8dc83a", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -159,6 +159,7 @@ tree gfor_fndecl_co_max;\n tree gfor_fndecl_co_min;\n tree gfor_fndecl_co_reduce;\n tree gfor_fndecl_co_sum;\n+tree gfor_fndecl_caf_is_present;\n \n \n /* Math functions.  Many other math functions are handled in\n@@ -3573,8 +3574,9 @@ gfc_build_builtin_function_decls (void)\n \tpint_type, pchar_type_node, integer_type_node);\n \n       gfor_fndecl_caf_deregister = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_deregister\")), \"WWWR\", void_type_node, 4,\n-\tppvoid_type_node, pint_type, pchar_type_node, integer_type_node);\n+\tget_identifier (PREFIX(\"caf_deregister\")), \"WRWWR\", void_type_node, 5,\n+\tppvoid_type_node, integer_type_node, pint_type, pchar_type_node,\n+\tinteger_type_node);\n \n       gfor_fndecl_caf_get = gfc_build_library_function_decl_with_spec (\n \tget_identifier (PREFIX(\"caf_get\")), \".R.RRWRRRW\", void_type_node, 10,\n@@ -3726,6 +3728,11 @@ gfc_build_builtin_function_decls (void)\n \tget_identifier (PREFIX(\"caf_co_sum\")), \"W.WW\",\n \tvoid_type_node, 5, pvoid_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_is_present = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_is_present\")), \"RRR\",\n+\tinteger_type_node, 3, pvoid_type_node, integer_type_node,\n+\tpvoid_type_node);\n     }\n \n   gfc_build_intrinsic_function_decls ();\n@@ -4447,12 +4454,15 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t    tmp = gfc_deallocate_with_status (descriptor, NULL_TREE,\n \t\t\t\t\t\t      NULL_TREE, NULL_TREE,\n \t\t\t\t\t\t      NULL_TREE, true, NULL,\n-\t\t\t\t\t\t      true);\n+\t\t\t\t\t\t      GFC_CAF_COARRAY_ANALYZE);\n \t\t  else\n \t\t    {\n \t\t      gfc_expr *expr = gfc_lval_expr_from_sym (sym);\n-\t\t      tmp = gfc_deallocate_scalar_with_status (se.expr, NULL_TREE,\n-\t\t\t\t\t\t   true, expr, sym->ts);\n+\t\t      tmp = gfc_deallocate_scalar_with_status (se.expr,\n+\t\t\t\t\t\t\t       NULL_TREE,\n+\t\t\t\t\t\t\t       NULL_TREE,\n+\t\t\t\t\t\t\t       true, expr,\n+\t\t\t\t\t\t\t       sym->ts);\n \t\t      gfc_free_expr (expr);\n \t\t    }\n \t\t}\n@@ -5093,8 +5103,8 @@ generate_coarray_sym_init (gfc_symbol *sym)\n \t\t\t     build_int_cst (integer_type_node, reg_type),\n \t\t\t     token, gfc_build_addr_expr (pvoid_type_node, desc),\n \t\t\t     null_pointer_node, /* stat.  */\n-\t\t\t     null_pointer_node, /* errgmsg, errmsg_len.  */\n-\t\t\t     build_int_cst (integer_type_node, 0));\n+\t\t\t     null_pointer_node, /* errgmsg.  */\n+\t\t\t     integer_zero_node); /* errmsg_len.  */\n   gfc_add_expr_to_block (&caf_init_block, tmp);\n   gfc_add_modify (&caf_init_block, decl, fold_convert (TREE_TYPE (decl),\n \t\t\t\t\t  gfc_conv_descriptor_data_get (desc)));"}, {"sha": "78bff87cd1c99afebd72fd456124948161c70f98", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -5208,7 +5208,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\tptr = gfc_class_data_get (ptr);\n \n \t\t      tmp = gfc_deallocate_scalar_with_status (ptr, NULL_TREE,\n-\t\t\t\t\t\t\t       true, e, e->ts);\n+\t\t\t\t\t\t\t       NULL_TREE, true,\n+\t\t\t\t\t\t\t       e, e->ts);\n \t\t      gfc_add_expr_to_block (&block, tmp);\n \t\t      tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t\t     void_type_node, ptr,\n@@ -5317,7 +5318,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t  tmp = gfc_deallocate_with_status (ptr, NULL_TREE,\n \t\t\t\t\t\t    NULL_TREE, NULL_TREE,\n \t\t\t\t\t\t    NULL_TREE, true, e,\n-\t\t\t\t\t\t    false);\n+\t\t\t\t\t\t    GFC_CAF_COARRAY_NOCOARRAY);\n \t\t  gfc_add_expr_to_block (&block, tmp);\n \t\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR,\n \t\t\t\t\t void_type_node, ptr,\n@@ -5440,7 +5441,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  tmp = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\t     parmse.expr);\n-\t\t  tmp = gfc_trans_dealloc_allocated (tmp, false, e);\n+\t\t  tmp = gfc_trans_dealloc_allocated (tmp, e,\n+\t\t\t\t\t\t     GFC_CAF_COARRAY_NOCOARRAY);\n \t\t  if (fsym->attr.optional\n \t\t      && e->expr_type == EXPR_VARIABLE\n \t\t      && e->symtree->n.sym->attr.optional)\n@@ -5552,7 +5554,8 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t    {\n \t      tree local_tmp;\n \t      local_tmp = gfc_evaluate_now (tmp, &se->pre);\n-\t      local_tmp = gfc_copy_alloc_comp (e->ts.u.derived, local_tmp, tmp, parm_rank);\n+\t      local_tmp = gfc_copy_alloc_comp (e->ts.u.derived, local_tmp, tmp,\n+\t\t\t\t\t       parm_rank, 0);\n \t      gfc_add_expr_to_block (&se->post, local_tmp);\n \t    }\n \n@@ -6207,7 +6210,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t     from being corrupted.  */\n \t  tmp2 = gfc_evaluate_now (result, &se->pre);\n \t  tmp = gfc_copy_alloc_comp (arg->expr->ts.u.derived,\n-\t\t\t\t     result, tmp2, expr->rank);\n+\t\t\t\t     result, tmp2, expr->rank, 0);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t  tmp = gfc_copy_allocatable_data (result, tmp2, TREE_TYPE(tmp2),\n \t\t\t\t           expr->rank);\n@@ -6217,7 +6220,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tmp = gfc_conv_descriptor_data_get (tmp2);\n \t  tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE,\n \t\t\t\t\t    NULL_TREE, NULL_TREE, true,\n-\t\t\t\t\t    NULL, false);\n+\t\t\t\t\t    NULL, GFC_CAF_COARRAY_NOCOARRAY);\n \t  gfc_add_expr_to_block (&se->pre, tmp);\n \t}\n     }\n@@ -6932,16 +6935,18 @@ gfc_trans_alloc_subarray_assign (tree dest, gfc_component * cm,\n   /* Deal with arrays of derived types with allocatable components.  */\n   if (gfc_bt_struct (cm->ts.type)\n \t&& cm->ts.u.derived->attr.alloc_comp)\n+    // TODO: Fix caf_mode\n     tmp = gfc_copy_alloc_comp (cm->ts.u.derived,\n \t\t\t       se.expr, dest,\n-\t\t\t       cm->as->rank);\n+\t\t\t       cm->as->rank, 0);\n   else if (cm->ts.type == BT_CLASS && expr->ts.type == BT_DERIVED\n \t   && CLASS_DATA(cm)->attr.allocatable)\n     {\n       if (cm->ts.u.derived->attr.alloc_comp)\n+\t// TODO: Fix caf_mode\n \ttmp = gfc_copy_alloc_comp (expr->ts.u.derived,\n \t\t\t\t   se.expr, dest,\n-\t\t\t\t   expr->rank);\n+\t\t\t\t   expr->rank, 0);\n       else\n \t{\n \t  tmp = TREE_TYPE (dest);\n@@ -7367,8 +7372,9 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n \t  if (cm->ts.u.derived->attr.alloc_comp\n \t      && expr->expr_type != EXPR_NULL)\n \t    {\n+\t      // TODO: Fix caf_mode\n \t      tmp = gfc_copy_alloc_comp (cm->ts.u.derived, se.expr,\n-\t\t\t\t\t dest, expr->rank);\n+\t\t\t\t\t dest, expr->rank, 0);\n \t      gfc_add_expr_to_block (&block, tmp);\n \t      if (dealloc != NULL_TREE)\n \t\tgfc_add_expr_to_block (&block, dealloc);\n@@ -7434,13 +7440,14 @@ gfc_trans_subcomponent_assign (tree dest, gfc_component * cm, gfc_expr * expr,\n /* Assign a derived type constructor to a variable.  */\n \n tree\n-gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n+gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init, bool coarray)\n {\n   gfc_constructor *c;\n   gfc_component *cm;\n   stmtblock_t block;\n   tree field;\n   tree tmp;\n+  gfc_se se;\n \n   gfc_start_block (&block);\n   cm = expr->ts.u.derived->components;\n@@ -7449,7 +7456,7 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n       && (expr->ts.u.derived->intmod_sym_id == ISOCBINDING_PTR\n           || expr->ts.u.derived->intmod_sym_id == ISOCBINDING_FUNPTR))\n     {\n-      gfc_se se, lse;\n+      gfc_se lse;\n \n       gfc_init_se (&se, NULL);\n       gfc_init_se (&lse, NULL);\n@@ -7461,13 +7468,72 @@ gfc_trans_structure_assign (tree dest, gfc_expr * expr, bool init)\n       return gfc_finish_block (&block);\n     }\n \n+  if (coarray)\n+    gfc_init_se (&se, NULL);\n+\n   for (c = gfc_constructor_first (expr->value.constructor);\n        c; c = gfc_constructor_next (c), cm = cm->next)\n     {\n       /* Skip absent members in default initializers.  */\n       if (!c->expr && !cm->attr.allocatable)\n \tcontinue;\n \n+      /* Register the component with the caf-lib before it is initialized.\n+\t Register only allocatable components, that are not coarray'ed\n+\t components (%comp[*]).  Only register when the constructor is not the\n+\t null-expression.  */\n+      if (coarray && !cm->attr.codimension && cm->attr.allocatable\n+\t  && (!c->expr || c->expr->expr_type == EXPR_NULL))\n+\t{\n+\t  tree token, desc, size;\n+\t  symbol_attribute attr;\n+\t  bool is_array = cm->ts.type == BT_CLASS\n+\t      ? CLASS_DATA (cm)->attr.dimension : cm->attr.dimension;\n+\n+\t  field = cm->backend_decl;\n+\t  field = fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t   TREE_TYPE (field), dest, field, NULL_TREE);\n+\t  if (cm->ts.type == BT_CLASS)\n+\t    field = gfc_class_data_get (field);\n+\n+\t  token = is_array ? gfc_conv_descriptor_token (field)\n+\t\t\t   : fold_build3_loc (input_location, COMPONENT_REF,\n+\t\t\t\t\t      TREE_TYPE (cm->caf_token), dest,\n+\t\t\t\t\t      cm->caf_token, NULL_TREE);\n+\n+\t  if (is_array)\n+\t    {\n+\t      /* The _caf_register routine looks at the rank of the array\n+\t\t descriptor to decide whether the data registered is an array\n+\t\t or not.  */\n+\t      int rank = cm->ts.type == BT_CLASS ? CLASS_DATA (cm)->as->rank\n+\t\t\t\t\t\t : cm->as->rank;\n+\t      /* When the rank is not known just set a positive rank, which\n+\t\t suffices to recognize the data as array.  */\n+\t      if (rank < 0)\n+\t\trank = 1;\n+\t      size = integer_zero_node;\n+\t      desc = field;\n+\t      gfc_add_modify (&block, gfc_conv_descriptor_dtype (desc),\n+\t\t\t      build_int_cst (gfc_array_index_type, rank));\n+\t    }\n+\t  else\n+\t    {\n+\t      desc = gfc_conv_scalar_to_descriptor (&se, field, attr);\n+\t      size = TYPE_SIZE_UNIT (TREE_TYPE (field));\n+\t    }\n+\t  gfc_add_block_to_block (&block, &se.pre);\n+\t  tmp =  build_call_expr_loc (input_location, gfor_fndecl_caf_register,\n+\t\t\t\t      7, size, build_int_cst (\n+\t\t\t\t\tinteger_type_node,\n+\t\t\t\t\tGFC_CAF_COARRAY_ALLOC_REGISTER_ONLY),\n+\t\t\t\t      gfc_build_addr_expr (pvoid_type_node,\n+\t\t\t\t\t\t\t   token),\n+\t\t\t\t      gfc_build_addr_expr (NULL_TREE, desc),\n+\t\t\t\t      null_pointer_node, null_pointer_node,\n+\t\t\t\t      integer_zero_node);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t}\n       field = cm->backend_decl;\n       tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t     dest, field, NULL_TREE);\n@@ -7546,7 +7612,8 @@ gfc_conv_structure (gfc_se * se, gfc_expr * expr, int init)\n       se->expr = gfc_create_var (type, expr->ts.u.derived->name);\n       /* The symtree in expr is NULL, if the code to generate is for\n \t initializing the static members only.  */\n-      tmp = gfc_trans_structure_assign (se->expr, expr, expr->symtree != NULL);\n+      tmp = gfc_trans_structure_assign (se->expr, expr, expr->symtree != NULL,\n+\t\t\t\t\tse->want_coarray);\n       gfc_add_expr_to_block (&se->pre, tmp);\n       return;\n     }\n@@ -8540,7 +8607,7 @@ gfc_conv_string_parameter (gfc_se * se)\n \n tree\n gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n-\t\t\t bool deep_copy, bool dealloc)\n+\t\t\t bool deep_copy, bool dealloc, bool in_coarray)\n {\n   stmtblock_t block;\n   tree tmp;\n@@ -8617,7 +8684,10 @@ gfc_trans_scalar_assign (gfc_se * lse, gfc_se * rse, gfc_typespec ts,\n \t same as the lhs.  */\n       if (deep_copy)\n \t{\n-\t  tmp = gfc_copy_alloc_comp (ts.u.derived, rse->expr, lse->expr, 0);\n+\t  int caf_mode = in_coarray ? (GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY\n+\t\t\t\t       | GFC_STRUCTURE_CAF_MODE_IN_COARRAY) : 0;\n+\t  tmp = gfc_copy_alloc_comp (ts.u.derived, rse->expr, lse->expr, 0,\n+\t\t\t\t     caf_mode);\n \t  tmp = build3_v (COND_EXPR, cond, build_empty_stmt (input_location),\n \t\t\t  tmp);\n \t  gfc_add_expr_to_block (&block, tmp);\n@@ -9746,6 +9816,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   l_is_temp = (lss != gfc_ss_terminator && loop.temp_ss != NULL);\n \n   /* Translate the expression.  */\n+  rse.want_coarray = flag_coarray == GFC_FCOARRAY_LIB && init_flag\n+      && lhs_caf_attr.codimension;\n   gfc_conv_expr (&rse, expr2);\n \n   /* Deal with the case of a scalar class function assigned to a derived type.  */\n@@ -9882,7 +9954,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n \t\t\t\t   gfc_expr_is_variable (expr2)\n \t\t\t\t   || scalar_to_array\n \t\t\t\t   || expr2->expr_type == EXPR_ARRAY,\n-\t\t\t\t   !(l_is_temp || init_flag) && dealloc);\n+\t\t\t\t   !(l_is_temp || init_flag) && dealloc,\n+\t\t\t\t   expr1->symtree->n.sym->attr.codimension);\n   /* Add the pre blocks to the body.  */\n   gfc_add_block_to_block (&body, &rse.pre);\n   gfc_add_block_to_block (&body, &lse.pre);"}, {"sha": "d7612f63162380edbc25bce9ddc8dcfc427211a1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 78, "deletions": 22, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -1674,7 +1674,8 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \t\t      tmp = gfc_deallocate_with_status (tmp, NULL_TREE,\n \t\t\t\t\t\t\tNULL_TREE, NULL_TREE,\n \t\t\t\t\t\t\tNULL_TREE, true,\n-\t\t\t\t\t\t\tNULL, false);\n+\t\t\t\t\t\t\tNULL,\n+\t\t\t\t\t\t     GFC_CAF_COARRAY_NOCOARRAY);\n \t\t      gfc_add_expr_to_block (&se->post, tmp);\n \t\t    }\n \t\t}\n@@ -1764,6 +1765,7 @@ gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind,\n \t  ar->as = ar2.as;\n \t  ar->type = AR_FULL;\n \t}\n+      // TODO: Check whether argse.want_coarray = 1 can help with the below.\n       gfc_conv_expr_descriptor (&argse, array_expr);\n       /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that\n \t has the wrong type if component references are done.  */\n@@ -1926,7 +1928,9 @@ conv_caf_send (gfc_code *code) {\n \n   /* Special case: RHS is a coarray but LHS is not; this code path avoids a\n      temporary and a loop.  */\n-  if (!gfc_is_coindexed (lhs_expr) && !lhs_caf_attr.codimension)\n+  if (!gfc_is_coindexed (lhs_expr)\n+      && (!lhs_caf_attr.codimension\n+\t  || !(lhs_expr->rank > 0 && lhs_caf_attr.allocatable)))\n     {\n       bool lhs_may_realloc = lhs_expr->rank > 0 && lhs_caf_attr.allocatable;\n       gcc_assert (gfc_is_coindexed (rhs_expr));\n@@ -1957,7 +1961,7 @@ conv_caf_send (gfc_code *code) {\n       gfc_add_block_to_block (&block, &lhs_se.pre);\n       gfc_conv_intrinsic_caf_get (&rhs_se, rhs_expr, lhs_se.expr, lhs_kind,\n \t\t\t\t  may_require_tmp, lhs_may_realloc,\n-\t\t\t\t  &lhs_caf_attr);\n+\t\t\t\t  &rhs_caf_attr);\n       gfc_add_block_to_block (&block, &rhs_se.pre);\n       gfc_add_block_to_block (&block, &rhs_se.post);\n       gfc_add_block_to_block (&block, &lhs_se.post);\n@@ -2059,7 +2063,7 @@ conv_caf_send (gfc_code *code) {\n       gfc_add_block_to_block (&block, &stat_se.post);\n     }\n \n-  if (!gfc_is_coindexed (rhs_expr) && !rhs_caf_attr.codimension)\n+  if (!gfc_is_coindexed (rhs_expr))\n     {\n       if (lhs_caf_attr.alloc_comp)\n \t{\n@@ -7318,6 +7322,42 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n }\n \n \n+/* Generate a call to caf_is_present.  */\n+\n+static tree\n+trans_caf_is_present (gfc_se *se, gfc_expr *expr)\n+{\n+  tree caf_reference, caf_decl, token, image_index;\n+\n+  /* Compile the reference chain.  */\n+  caf_reference = conv_expr_ref_to_caf_ref (&se->pre, expr);\n+  gcc_assert (caf_reference != NULL_TREE);\n+\n+  caf_decl = gfc_get_tree_for_caf_expr (expr);\n+  if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+    caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+  image_index = gfc_caf_get_image_index (&se->pre, expr, caf_decl);\n+  gfc_get_caf_token_offset (se, &token, NULL, caf_decl, NULL,\n+\t\t\t    expr);\n+\n+  return build_call_expr_loc (input_location, gfor_fndecl_caf_is_present,\n+\t\t\t      3, token, image_index, caf_reference);\n+}\n+\n+\n+/* Test whether this ref-chain refs this image only.  */\n+\n+static bool\n+caf_this_image_ref (gfc_ref *ref)\n+{\n+  for ( ; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen)\n+      return ref->u.ar.dimen_type[ref->u.ar.dimen] == DIMEN_THIS_IMAGE;\n+\n+  return false;\n+}\n+\n+\n /* Generate code for the ALLOCATED intrinsic.\n    Generate inline code that directly check the address of the argument.  */\n \n@@ -7327,6 +7367,7 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n   gfc_actual_arglist *arg1;\n   gfc_se arg1se;\n   tree tmp;\n+  symbol_attribute caf_attr;\n \n   gfc_init_se (&arg1se, NULL);\n   arg1 = expr->value.function.actual;\n@@ -7342,23 +7383,37 @@ gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n \tgfc_add_data_component (arg1->expr);\n     }\n \n-  if (arg1->expr->rank == 0)\n-    {\n-      /* Allocatable scalar.  */\n-      arg1se.want_pointer = 1;\n-      gfc_conv_expr (&arg1se, arg1->expr);\n-      tmp = arg1se.expr;\n-    }\n+  /* When arg1 references an allocatable component in a coarray, then call\n+     the caf-library function caf_is_present ().  */\n+  if (flag_coarray == GFC_FCOARRAY_LIB && arg1->expr->expr_type == EXPR_FUNCTION\n+      && arg1->expr->value.function.isym\n+      && arg1->expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    caf_attr = gfc_caf_attr (arg1->expr->value.function.actual->expr);\n+  else\n+    gfc_clear_attr (&caf_attr);\n+  if (flag_coarray == GFC_FCOARRAY_LIB && caf_attr.codimension\n+      && !caf_this_image_ref (arg1->expr->value.function.actual->expr->ref))\n+    tmp = trans_caf_is_present (se, arg1->expr->value.function.actual->expr);\n   else\n     {\n-      /* Allocatable array.  */\n-      arg1se.descriptor_only = 1;\n-      gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n-      tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n-    }\n+      if (arg1->expr->rank == 0)\n+\t{\n+\t  /* Allocatable scalar.  */\n+\t  arg1se.want_pointer = 1;\n+\t  gfc_conv_expr (&arg1se, arg1->expr);\n+\t  tmp = arg1se.expr;\n+\t}\n+      else\n+\t{\n+\t  /* Allocatable array.  */\n+\t  arg1se.descriptor_only = 1;\n+\t  gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n+\t  tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n+\t}\n \n-  tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n-\t\t\t fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+      tmp = fold_build2_loc (input_location, NE_EXPR, boolean_type_node, tmp,\n+\t\t\t     fold_convert (TREE_TYPE (tmp), null_pointer_node));\n+    }\n   se->expr = convert (gfc_typenode_for_spec (&expr->ts), tmp);\n }\n \n@@ -10270,8 +10325,8 @@ conv_intrinsic_move_alloc (gfc_code *code)\n       gfc_add_block_to_block (&block, &to_se.pre);\n \n       /* Deallocate \"to\".  */\n-      tmp = gfc_deallocate_scalar_with_status (to_se.expr, NULL_TREE, true,\n-\t\t\t\t\t       to_expr, to_expr->ts);\n+      tmp = gfc_deallocate_scalar_with_status (to_se.expr, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t       true, to_expr, to_expr->ts);\n       gfc_add_expr_to_block (&block, tmp);\n \n       /* Assign (_data) pointers.  */\n@@ -10429,7 +10484,7 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \n       tmp = gfc_deallocate_with_status (to_se.expr, NULL_TREE, NULL_TREE,\n \t\t\t\t\tNULL_TREE, NULL_TREE, true, to_expr,\n-\t\t\t\t\ttrue);\n+\t\t\t\t\tGFC_CAF_COARRAY_DEALLOCATE_ONLY);\n       gfc_add_expr_to_block (&block, tmp);\n \n       tmp = gfc_conv_descriptor_data_get (to_se.expr);\n@@ -10457,7 +10512,8 @@ conv_intrinsic_move_alloc (gfc_code *code)\n \n       tmp = gfc_conv_descriptor_data_get (to_se.expr);\n       tmp = gfc_deallocate_with_status (tmp, NULL_TREE, NULL_TREE, NULL_TREE,\n-\t\t\t\t\tNULL_TREE, true, to_expr, false);\n+\t\t\t\t\tNULL_TREE, true, to_expr,\n+\t\t\t\t\tGFC_CAF_COARRAY_NOCOARRAY);\n       gfc_add_expr_to_block (&block, tmp);\n     }\n "}, {"sha": "d460048d20d4e195d3482e457fd3266ec3770f48", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -420,8 +420,8 @@ gfc_walk_alloc_comps (tree decl, tree dest, tree var,\n \t  if (GFC_DESCRIPTOR_TYPE_P (ftype)\n \t      && GFC_TYPE_ARRAY_AKIND (ftype) == GFC_ARRAY_ALLOCATABLE)\n \t    {\n-\t      tem = gfc_trans_dealloc_allocated (unshare_expr (declf),\n-\t\t\t\t\t\t false, NULL);\n+\t      tem = gfc_trans_dealloc_allocated (unshare_expr (declf), NULL,\n+\t\t\t\t\t\t GFC_CAF_COARRAY_NOCOARRAY);\n \t      gfc_add_expr_to_block (&block, gfc_omp_unshare_expr (tem));\n \t    }\n \t  else if (GFC_DECL_GET_SCALAR_ALLOCATABLE (field))\n@@ -812,7 +812,8 @@ gfc_omp_clause_assign_op (tree clause, tree dest, tree src)\n       if (GFC_DESCRIPTOR_TYPE_P (type))\n \tgfc_add_expr_to_block (&cond_block,\n \t\t\t       gfc_trans_dealloc_allocated (unshare_expr (dest),\n-\t\t\t\t\t\t\t    false, NULL));\n+\t\t\t\t\t\t\t    NULL,\n+\t\t\t\t\t\t    GFC_CAF_COARRAY_NOCOARRAY));\n       else\n \t{\n \t  destptr = gfc_evaluate_now (destptr, &cond_block);\n@@ -988,7 +989,7 @@ gfc_omp_clause_dtor (tree clause, tree decl)\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n     /* Allocatable arrays in FIRSTPRIVATE/LASTPRIVATE etc. clauses need\n        to be deallocated if they were allocated.  */\n-    tem = gfc_trans_dealloc_allocated (decl, false, NULL);\n+    tem = gfc_trans_dealloc_allocated (decl, NULL, GFC_CAF_COARRAY_NOCOARRAY);\n   else\n     tem = gfc_call_free (decl);\n   tem = gfc_omp_unshare_expr (tem);"}, {"sha": "514db287478f5a89d17d3304fb7372e6f30f4719", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -6409,6 +6409,9 @@ gfc_trans_deallocate (gfc_code *code)\n   for (al = code->ext.alloc.list; al != NULL; al = al->next)\n     {\n       gfc_expr *expr = gfc_copy_expr (al->expr);\n+      bool is_coarray = false, is_coarray_array = false;\n+      int caf_mode = 0;\n+\n       gcc_assert (expr->expr_type == EXPR_VARIABLE);\n \n       if (expr->ts.type == BT_CLASS)\n@@ -6421,11 +6424,32 @@ gfc_trans_deallocate (gfc_code *code)\n       se.descriptor_only = 1;\n       gfc_conv_expr (&se, expr);\n \n-      if (expr->rank || gfc_caf_attr (expr).codimension)\n+      if (flag_coarray == GFC_FCOARRAY_LIB)\n+\t{\n+\t  bool comp_ref;\n+\t  symbol_attribute caf_attr = gfc_caf_attr (expr, false, &comp_ref);\n+\t  if (caf_attr.codimension)\n+\t    {\n+\t      is_coarray = true;\n+\t      is_coarray_array = caf_attr.dimension || !comp_ref\n+\t\t  || caf_attr.coarray_comp;\n+\n+\t      /* When the expression to deallocate is referencing a\n+\t\t component, then only deallocate it, but do not deregister.  */\n+\t      caf_mode = GFC_STRUCTURE_CAF_MODE_IN_COARRAY\n+\t\t  | (comp_ref && !caf_attr.coarray_comp\n+\t\t     ? GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY : 0);\n+\t    }\n+\t}\n+      else if (flag_coarray == GFC_FCOARRAY_SINGLE)\n+\tis_coarray = is_coarray_array = gfc_caf_attr (expr).codimension;\n+\n+      if (expr->rank || is_coarray_array)\n \t{\n \t  gfc_ref *ref;\n \n-\t  if (gfc_bt_struct (expr->ts.type) && expr->ts.u.derived->attr.alloc_comp\n+\t  if (gfc_bt_struct (expr->ts.type)\n+\t      && expr->ts.u.derived->attr.alloc_comp\n \t      && !gfc_is_finalizable (expr->ts.u.derived, NULL))\n \t    {\n \t      gfc_ref *last = NULL;\n@@ -6439,16 +6463,34 @@ gfc_trans_deallocate (gfc_code *code)\n \t      if (!(last && last->u.c.component->attr.pointer)\n \t\t    && !(!last && expr->symtree->n.sym->attr.pointer))\n \t\t{\n-\t\t  tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, se.expr,\n-\t\t\t\t\t\t   expr->rank);\n+\t\t  if (is_coarray && expr->rank == 0\n+\t\t      && (!last || !last->u.c.component->attr.dimension))\n+\t\t    {\n+\t\t      /* Add the ref to the data member only, when this is not\n+\t\t\t a regular array or deallocate_alloc_comp will try to\n+\t\t\t add another one.  */\n+\t\t      tmp = gfc_conv_descriptor_data_get (se.expr);\n+\t\t    }\n+\t\t  else\n+\t\t    tmp = se.expr;\n+\t\t  tmp = gfc_deallocate_alloc_comp (expr->ts.u.derived, tmp,\n+\t\t\t\t\t\t   expr->rank, caf_mode);\n \t\t  gfc_add_expr_to_block (&se.pre, tmp);\n \t\t}\n \t    }\n \n \t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))\n \t    {\n+\t      gfc_coarray_deregtype caf_dtype;\n+\n+\t      if (is_coarray)\n+\t\tcaf_dtype = gfc_caf_is_dealloc_only (caf_mode)\n+\t\t    ? GFC_CAF_COARRAY_DEALLOCATE_ONLY\n+\t\t    : GFC_CAF_COARRAY_DEREGISTER;\n+\t      else\n+\t\tcaf_dtype = GFC_CAF_COARRAY_NOCOARRAY;\n \t      tmp = gfc_array_deallocate (se.expr, pstat, errmsg, errlen,\n-\t\t\t\t          label_finish, expr);\n+\t\t\t\t\t  label_finish, expr, caf_dtype);\n \t      gfc_add_expr_to_block (&se.pre, tmp);\n \t    }\n \t  else if (TREE_CODE (se.expr) == COMPONENT_REF\n@@ -6491,8 +6533,9 @@ gfc_trans_deallocate (gfc_code *code)\n \t}\n       else\n \t{\n-\t  tmp = gfc_deallocate_scalar_with_status (se.expr, pstat, false,\n-\t\t\t\t\t\t   al->expr, al->expr->ts);\n+\t  tmp = gfc_deallocate_scalar_with_status (se.expr, pstat, label_finish,\n+\t\t\t\t\t\t   false, al->expr,\n+\t\t\t\t\t\t   al->expr->ts, is_coarray);\n \t  gfc_add_expr_to_block (&se.pre, tmp);\n \n \t  /* Set to zero after deallocation.  */"}, {"sha": "6a1d4819ca699b5c462711572217bb720b5b0816", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 141, "deletions": 57, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -709,10 +709,10 @@ gfc_allocate_using_malloc (stmtblock_t * block, tree pointer,\n       newmem = _caf_register (size, regtype, token, &stat, errmsg, errlen);\n       return newmem;\n     }  */\n-static void\n-gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n-\t\t\ttree token, tree status, tree errmsg, tree errlen,\n-\t\t\tbool lock_var, bool event_var)\n+void\n+gfc_allocate_using_caf_lib (stmtblock_t * block, tree pointer, tree size,\n+\t\t\t    tree token, tree status, tree errmsg, tree errlen,\n+\t\t\t    gfc_coarray_regtype alloc_type)\n {\n   tree tmp, pstat;\n \n@@ -735,12 +735,8 @@ gfc_allocate_using_lib (stmtblock_t * block, tree pointer, tree size,\n   tmp = build_call_expr_loc (input_location,\n \t     gfor_fndecl_caf_register, 7,\n \t     fold_build2_loc (input_location,\n-\t\t\t      MAX_EXPR, size_type_node, size,\n-\t\t\t      build_int_cst (size_type_node, 1)),\n-\t     build_int_cst (integer_type_node,\n-\t\t\t    lock_var ? GFC_CAF_LOCK_ALLOC\n-                            : event_var ? GFC_CAF_EVENT_ALLOC\n-\t\t\t\t\t: GFC_CAF_COARRAY_ALLOC),\n+\t\t\t      MAX_EXPR, size_type_node, size, size_one_node),\n+\t     build_int_cst (integer_type_node, alloc_type),\n \t     token, gfc_build_addr_expr (pvoid_type_node, pointer),\n \t     pstat, errmsg, errlen);\n \n@@ -787,7 +783,8 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n   tree tmp, null_mem, alloc, error;\n   tree type = TREE_TYPE (mem);\n   symbol_attribute caf_attr;\n-  bool need_assign = false;\n+  bool need_assign = false, refs_comp = false;\n+  gfc_coarray_regtype caf_alloc_type = GFC_CAF_COARRAY_ALLOC;\n \n   size = fold_convert (size_type_node, size);\n   null_mem = gfc_unlikely (fold_build2_loc (input_location, NE_EXPR,\n@@ -800,27 +797,36 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n   gfc_start_block (&alloc_block);\n \n   if (flag_coarray == GFC_FCOARRAY_LIB)\n-    caf_attr = gfc_caf_attr (expr, true);\n+    caf_attr = gfc_caf_attr (expr, true, &refs_comp);\n \n   if (flag_coarray == GFC_FCOARRAY_LIB\n       && (corank > 0 || caf_attr.codimension))\n     {\n-      tree cond;\n-      bool lock_var = expr->ts.type == BT_DERIVED\n-\t\t      && expr->ts.u.derived->from_intmod\n-\t\t\t == INTMOD_ISO_FORTRAN_ENV\n-\t\t      && expr->ts.u.derived->intmod_sym_id\n-\t\t         == ISOFORTRAN_LOCK_TYPE;\n-      bool event_var = expr->ts.type == BT_DERIVED\n-\t\t       && expr->ts.u.derived->from_intmod\n-\t\t\t == INTMOD_ISO_FORTRAN_ENV\n-\t\t       && expr->ts.u.derived->intmod_sym_id\n-\t\t         == ISOFORTRAN_EVENT_TYPE;\n+      tree cond, sub_caf_tree;\n       gfc_se se;\n-      gfc_init_se (&se, NULL);\n+      bool compute_special_caf_types_size = false;\n \n-      tree sub_caf_tree = gfc_get_ultimate_alloc_ptr_comps_caf_token (&se,\n-\t\t\t\t\t\t\t\t      expr);\n+      if (expr->ts.type == BT_DERIVED\n+\t  && expr->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t  && expr->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+\t{\n+\t  compute_special_caf_types_size = true;\n+\t  caf_alloc_type = GFC_CAF_LOCK_ALLOC;\n+\t}\n+      else if (expr->ts.type == BT_DERIVED\n+\t       && expr->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t       && expr->ts.u.derived->intmod_sym_id == ISOFORTRAN_EVENT_TYPE)\n+\t{\n+\t  compute_special_caf_types_size = true;\n+\t  caf_alloc_type = GFC_CAF_EVENT_ALLOC;\n+\t}\n+      else if (!caf_attr.coarray_comp && refs_comp)\n+\t/* Only allocatable components in a derived type coarray can be\n+\t   allocate only.  */\n+\tcaf_alloc_type = GFC_CAF_COARRAY_ALLOC_ALLOCATE_ONLY;\n+\n+      gfc_init_se (&se, NULL);\n+      sub_caf_tree = gfc_get_ultimate_alloc_ptr_comps_caf_token (&se, expr);\n       if (sub_caf_tree == NULL_TREE)\n \tsub_caf_tree = token;\n \n@@ -847,12 +853,12 @@ gfc_allocate_allocatable (stmtblock_t * block, tree mem, tree size,\n \t the FE only passes the pointer around and leaves the actual\n \t representation to the library. Hence, we have to convert back to the\n \t number of elements.  */\n-      if (lock_var || event_var)\n+      if (compute_special_caf_types_size)\n \tsize = fold_build2_loc (input_location, TRUNC_DIV_EXPR, size_type_node,\n \t\t\t\tsize, TYPE_SIZE_UNIT (ptr_type_node));\n \n-      gfc_allocate_using_lib (&alloc_block, tmp, size, sub_caf_tree,\n-\t\t\t      status, errmsg, errlen, lock_var, event_var);\n+      gfc_allocate_using_caf_lib (&alloc_block, tmp, size, sub_caf_tree,\n+\t\t\t\t  status, errmsg, errlen, caf_alloc_type);\n       if (need_assign)\n \tgfc_add_modify (&alloc_block, mem, fold_convert (TREE_TYPE (mem),\n \t\t\t\t\t   gfc_conv_descriptor_data_get (tmp)));\n@@ -1265,23 +1271,40 @@ gfc_add_finalizer_call (stmtblock_t *block, gfc_expr *expr2)\n    expression being deallocated for its locus and variable name.\n \n    For coarrays, \"pointer\" must be the array descriptor and not its\n-   \"data\" component.  */\n+   \"data\" component.\n+\n+   COARRAY_DEALLOC_MODE gives the mode unregister coarrays.  Available modes are\n+   the ones of GFC_CAF_DEREGTYPE, -1 when the mode for deregistration is to be\n+   analyzed and set by this routine, and -2 to indicate that a non-coarray is to\n+   be deallocated.  */\n tree\n gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t\t\t    tree errlen, tree label_finish,\n-\t\t\t    bool can_fail, gfc_expr* expr, bool coarray)\n+\t\t\t    bool can_fail, gfc_expr* expr,\n+\t\t\t    int coarray_dealloc_mode)\n {\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n   tree status_type = NULL_TREE;\n   tree caf_decl = NULL_TREE;\n+  gfc_coarray_deregtype caf_dereg_type = GFC_CAF_COARRAY_DEREGISTER;\n \n-  if (coarray)\n+  if (coarray_dealloc_mode >= GFC_CAF_COARRAY_ANALYZE)\n     {\n       gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (pointer)));\n       caf_decl = pointer;\n       pointer = gfc_conv_descriptor_data_get (caf_decl);\n       STRIP_NOPS (pointer);\n+      if (coarray_dealloc_mode == GFC_CAF_COARRAY_ANALYZE)\n+\t{\n+\t  bool comp_ref;\n+\t  if (expr && !gfc_caf_attr (expr, false, &comp_ref).coarray_comp\n+\t      && comp_ref)\n+\t    caf_dereg_type = GFC_CAF_COARRAY_DEALLOCATE_ONLY;\n+\t  // else do a deregister as set by default.\n+\t}\n+      else\n+\tcaf_dereg_type = (enum gfc_coarray_deregtype) coarray_dealloc_mode;\n     }\n \n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n@@ -1326,7 +1349,8 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n   /* When POINTER is not NULL, we free it.  */\n   gfc_start_block (&non_null);\n   gfc_add_finalizer_call (&non_null, expr);\n-  if (!coarray || flag_coarray != GFC_FCOARRAY_LIB)\n+  if (coarray_dealloc_mode == GFC_CAF_COARRAY_NOCOARRAY\n+      || flag_coarray != GFC_FCOARRAY_LIB)\n     {\n       tmp = build_call_expr_loc (input_location,\n \t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,\n@@ -1392,9 +1416,12 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n \t}\n \n       token = gfc_build_addr_expr  (NULL_TREE, token);\n+      gcc_assert (caf_dereg_type > GFC_CAF_COARRAY_ANALYZE);\n       tmp = build_call_expr_loc (input_location,\n-\t\t\t\t gfor_fndecl_caf_deregister, 4,\n-\t\t\t\t token, pstat, errmsg, errlen);\n+\t\t\t\t gfor_fndecl_caf_deregister, 5,\n+\t\t\t\t token, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t       caf_dereg_type),\n+\t\t\t\t pstat, errmsg, errlen);\n       gfc_add_expr_to_block (&non_null, tmp);\n \n       /* It guarantees memory consistency within the same segment */\n@@ -1431,12 +1458,18 @@ gfc_deallocate_with_status (tree pointer, tree status, tree errmsg,\n    subcomponents are being deallocated.  */\n \n tree\n-gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n-\t\t\t\t   gfc_expr* expr, gfc_typespec ts)\n+gfc_deallocate_scalar_with_status (tree pointer, tree status, tree label_finish,\n+\t\t\t\t   bool can_fail, gfc_expr* expr,\n+\t\t\t\t   gfc_typespec ts, bool coarray)\n {\n   stmtblock_t null, non_null;\n   tree cond, tmp, error;\n-  bool finalizable;\n+  bool finalizable, comp_ref;\n+  gfc_coarray_deregtype caf_dereg_type = GFC_CAF_COARRAY_DEREGISTER;\n+\n+  if (coarray && expr && !gfc_caf_attr (expr, false, &comp_ref).coarray_comp\n+      && comp_ref)\n+    caf_dereg_type = GFC_CAF_COARRAY_DEALLOCATE_ONLY;\n \n   cond = fold_build2_loc (input_location, EQ_EXPR, boolean_type_node, pointer,\n \t\t\t  build_int_cst (TREE_TYPE (pointer), 0));\n@@ -1474,7 +1507,6 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n       error = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n \t\t\t       cond2, tmp, error);\n     }\n-\n   gfc_add_expr_to_block (&null, error);\n \n   /* When POINTER is not NULL, we free it.  */\n@@ -1484,39 +1516,91 @@ gfc_deallocate_scalar_with_status (tree pointer, tree status, bool can_fail,\n   finalizable = gfc_add_finalizer_call (&non_null, expr);\n   if (!finalizable && ts.type == BT_DERIVED && ts.u.derived->attr.alloc_comp)\n     {\n-      tmp = build_fold_indirect_ref_loc (input_location, pointer);\n+      if (coarray)\n+\ttmp = gfc_conv_descriptor_data_get (pointer);\n+      else\n+\ttmp = build_fold_indirect_ref_loc (input_location, pointer);\n       tmp = gfc_deallocate_alloc_comp (ts.u.derived, tmp, 0);\n       gfc_add_expr_to_block (&non_null, tmp);\n     }\n \n-  tmp = build_call_expr_loc (input_location,\n-\t\t\t     builtin_decl_explicit (BUILT_IN_FREE), 1,\n-\t\t\t     fold_convert (pvoid_type_node, pointer));\n-  gfc_add_expr_to_block (&non_null, tmp);\n+  if (!coarray)\n+    {\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_FREE), 1,\n+\t\t\t\t fold_convert (pvoid_type_node, pointer));\n+      gfc_add_expr_to_block (&non_null, tmp);\n \n-  if (status != NULL_TREE && !integer_zerop (status))\n+      if (status != NULL_TREE && !integer_zerop (status))\n+\t{\n+\t  /* We set STATUS to zero if it is present.  */\n+\t  tree status_type = TREE_TYPE (TREE_TYPE (status));\n+\t  tree cond2;\n+\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   status,\n+\t\t\t\t   build_int_cst (TREE_TYPE (status), 0));\n+\t  tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n+\t\t\t\t fold_build1_loc (input_location, INDIRECT_REF,\n+\t\t\t\t\t\t  status_type, status),\n+\t\t\t\t build_int_cst (status_type, 0));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t cond2, tmp, build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&non_null, tmp);\n+\t}\n+    }\n+  else\n     {\n-      /* We set STATUS to zero if it is present.  */\n-      tree status_type = TREE_TYPE (TREE_TYPE (status));\n-      tree cond2;\n+      tree token;\n+      tree pstat = null_pointer_node;\n+      gfc_se se;\n \n-      cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n-\t\t\t       status, build_int_cst (TREE_TYPE (status), 0));\n-      tmp = fold_build2_loc (input_location, MODIFY_EXPR, status_type,\n-\t\t\t     fold_build1_loc (input_location, INDIRECT_REF,\n-\t\t\t\t\t      status_type, status),\n-\t\t\t     build_int_cst (status_type, 0));\n-      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node, cond2,\n-\t\t\t     tmp, build_empty_stmt (input_location));\n+      gfc_init_se (&se, NULL);\n+      token = gfc_get_ultimate_alloc_ptr_comps_caf_token (&se, expr);\n+      gcc_assert (token != NULL_TREE);\n+\n+      if (status != NULL_TREE && !integer_zerop (status))\n+\t{\n+\t  gcc_assert (TREE_TYPE (TREE_TYPE (status)) == integer_type_node);\n+\t  pstat = status;\n+\t}\n+\n+      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t gfor_fndecl_caf_deregister, 5,\n+\t\t\t\t token, build_int_cst (integer_type_node,\n+\t\t\t\t\t\t       caf_dereg_type),\n+\t\t\t\t pstat, null_pointer_node, integer_zero_node);\n       gfc_add_expr_to_block (&non_null, tmp);\n+\n+      /* It guarantees memory consistency within the same segment.  */\n+      tmp = gfc_build_string_const (strlen (\"memory\")+1, \"memory\"),\n+      tmp = build5_loc (input_location, ASM_EXPR, void_type_node,\n+\t\t\tgfc_build_string_const (1, \"\"), NULL_TREE, NULL_TREE,\n+\t\t\ttree_cons (NULL_TREE, tmp, NULL_TREE), NULL_TREE);\n+      ASM_VOLATILE_P (tmp) = 1;\n+      gfc_add_expr_to_block (&non_null, tmp);\n+\n+      if (status != NULL_TREE)\n+\t{\n+\t  tree stat = build_fold_indirect_ref_loc (input_location, status);\n+\t  tree cond2;\n+\n+\t  TREE_USED (label_finish) = 1;\n+\t  tmp = build1_v (GOTO_EXPR, label_finish);\n+\t  cond2 = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t   stat, build_zero_cst (TREE_TYPE (stat)));\n+\t  tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t\t gfc_unlikely (cond2, PRED_FORTRAN_REALLOC),\n+\t\t\t\t tmp, build_empty_stmt (input_location));\n+\t  gfc_add_expr_to_block (&non_null, tmp);\n+\t}\n     }\n \n   return fold_build3_loc (input_location, COND_EXPR, void_type_node, cond,\n \t\t\t  gfc_finish_block (&null),\n \t\t\t  gfc_finish_block (&non_null));\n }\n \n-\n /* Reallocate MEM so it has SIZE bytes of data.  This behaves like the\n    following pseudo-code:\n "}, {"sha": "ae1f15651ef6c88a67ec4224e62718842c6f1051", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -107,15 +107,30 @@ gfc_se;\n \n /* Denotes different types of coarray.\n    Please keep in sync with libgfortran/caf/libcaf.h.  */\n-enum gfc_coarray_type\n+enum gfc_coarray_regtype\n {\n   GFC_CAF_COARRAY_STATIC,\n   GFC_CAF_COARRAY_ALLOC,\n   GFC_CAF_LOCK_STATIC,\n   GFC_CAF_LOCK_ALLOC,\n   GFC_CAF_CRITICAL,\n   GFC_CAF_EVENT_STATIC,\n-  GFC_CAF_EVENT_ALLOC\n+  GFC_CAF_EVENT_ALLOC,\n+  GFC_CAF_COARRAY_ALLOC_REGISTER_ONLY,\n+  GFC_CAF_COARRAY_ALLOC_ALLOCATE_ONLY\n+};\n+\n+\n+/* Describes the action to take on _caf_deregister.  Keep in sync with\n+   gcc/fortran/trans.h.  The negative values are not valid for the library and\n+   are used by the drivers for building the correct call.  */\n+enum gfc_coarray_deregtype {\n+  /* This is no coarray, i.e. build a call to a free ().  */\n+  GFC_CAF_COARRAY_NOCOARRAY = -2,\n+  /* The driver is to analyze which _caf_deregister ()-call to generate.  */\n+  GFC_CAF_COARRAY_ANALYZE = -1,\n+  GFC_CAF_COARRAY_DEREGISTER = 0,\n+  GFC_CAF_COARRAY_DEALLOCATE_ONLY\n };\n \n \n@@ -140,6 +155,15 @@ enum gfc_caf_array_ref_t {\n   GFC_CAF_ARR_REF_OPEN_START\n };\n \n+\n+/* trans-array (structure_alloc_comps) caf_mode bits.  */\n+enum gfc_structure_caf_mode_t {\n+  GFC_STRUCTURE_CAF_MODE_ENABLE_COARRAY = 1 << 0,\n+  GFC_STRUCTURE_CAF_MODE_IN_COARRAY = 1 << 1,\n+  GFC_STRUCTURE_CAF_MODE_DEALLOC_ONLY = 1 << 2\n+};\n+\n+\n /* The array-specific scalarization information.  The array members of\n    this struct are indexed by actual array index, and thus can be sparse.  */\n \n@@ -506,7 +530,8 @@ int gfc_conv_procedure_call (gfc_se *, gfc_symbol *, gfc_actual_arglist *,\n void gfc_conv_subref_array_arg (gfc_se *, gfc_expr *, int, sym_intent, bool);\n \n /* Generate code for a scalar assignment.  */\n-tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, gfc_typespec, bool, bool);\n+tree gfc_trans_scalar_assign (gfc_se *, gfc_se *, gfc_typespec, bool, bool,\n+\t\t\t      bool c = false);\n \n /* Translate COMMON blocks.  */\n void gfc_trans_common (gfc_namespace *);\n@@ -681,6 +706,10 @@ tree gfc_call_malloc (stmtblock_t *, tree, tree);\n /* Build a memcpy call.  */\n tree gfc_build_memcpy_call (tree, tree, tree);\n \n+/* Register memory with the coarray library.  */\n+void gfc_allocate_using_caf_lib (stmtblock_t *, tree, tree, tree, tree, tree,\n+\t\t\t\t tree, gfc_coarray_regtype);\n+\n /* Allocate memory for allocatable variables, with optional status variable.  */\n void gfc_allocate_allocatable (stmtblock_t*, tree, tree, tree, tree,\n \t\t\t       tree, tree, tree, gfc_expr*, int);\n@@ -690,14 +719,15 @@ void gfc_allocate_using_malloc (stmtblock_t *, tree, tree, tree);\n \n /* Generate code to deallocate an array.  */\n tree gfc_deallocate_with_status (tree, tree, tree, tree, tree, bool,\n-\t\t\t\t gfc_expr *, bool);\n-tree gfc_deallocate_scalar_with_status (tree, tree, bool, gfc_expr*, gfc_typespec);\n+\t\t\t\t gfc_expr *, int);\n+tree gfc_deallocate_scalar_with_status (tree, tree, tree, bool, gfc_expr*,\n+\t\t\t\t\tgfc_typespec, bool c = false);\n \n /* Generate code to call realloc().  */\n tree gfc_call_realloc (stmtblock_t *, tree, tree);\n \n /* Assign a derived type constructor to a variable.  */\n-tree gfc_trans_structure_assign (tree, gfc_expr *, bool);\n+tree gfc_trans_structure_assign (tree, gfc_expr *, bool, bool c = false);\n \n /* Generate code for an assignment, includes scalarization.  */\n tree gfc_trans_assignment (gfc_expr *, gfc_expr *, bool, bool, bool p = false,\n@@ -808,7 +838,7 @@ extern GTY(()) tree gfor_fndecl_co_max;\n extern GTY(()) tree gfor_fndecl_co_min;\n extern GTY(()) tree gfor_fndecl_co_reduce;\n extern GTY(()) tree gfor_fndecl_co_sum;\n-\n+extern GTY(()) tree gfor_fndecl_caf_is_present;\n \n /* Math functions.  Many other math functions are handled in\n    trans-intrinsic.c.  */"}, {"sha": "a9cfb56a7aceab649774979a1251f868b25d09eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -1,3 +1,15 @@\n+2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/coarray/alloc_comp_1.f90: Fix tree-dump scans to adhere\n+\tto the changed interfaces.\n+\t* gfortran.dg/coarray_alloc_comp_1.f08: Likewise.\n+\t* gfortran.dg/coarray_allocate_7.f08: Likewise.\n+\t* gfortran.dg/coarray_lib_alloc_1.f90: Likewise.\n+\t* gfortran.dg/coarray_lib_alloc_2.f90: Likewise.\n+\t* gfortran.dg/coarray_lib_alloc_3.f90: Likewise.\n+\t* gfortran.dg/coarray_lib_comm_1.f90: Likewise.\n+\t* gfortran.dg/coarray_lib_alloc_4.f90: New test.\n+\n 2016-11-30  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/78593"}, {"sha": "f1136e30e60b22972217946a8ba0ab2ac4b2d116", "filename": "gcc/testsuite/gfortran.dg/coarray/alloc_comp_1.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Falloc_comp_1.f90?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -8,9 +8,9 @@\n type(t) :: a\n allocate (a%caf[3:*])\n a%caf = 7\n-!print *, a%caf\n if (a%caf /= 7) call abort ()\n if (any (lcobound (a%caf) /= [ 3 ]) &\n     .or. ucobound (a%caf, dim=1) /= this_image ()+2)  &\n   call abort ()\n+deallocate (a%caf)\n end"}, {"sha": "8c35fc8093bdc6bd9e5ddc74f181b01766d98d96", "filename": "gcc/testsuite/gfortran.dg/coarray_alloc_comp_1.f08", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_alloc_comp_1.f08?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -90,4 +90,7 @@ program main\n if (any(bar[me]%vec(2)%indices /= 89)) call abort()\n \n if (any (bar[neighbor]%vec(1)%indices /= [ 3,4,15])) call abort()\n+\n+deallocate(bar%vec(2)%indices, object%scalar, object%matrix)\n+deallocate(bar%vec)\n end program"}, {"sha": "d9241768cc120d8a14fffa9dc56f4294e31a11fc", "filename": "gcc/testsuite/gfortran.dg/coarray_allocate_7.f08", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_allocate_7.f08?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -23,6 +23,7 @@ program main\n   if ( object%indices(1) /= 1 ) call abort()\n end program\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(D.\\[0-9\\]+, 1, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices, 0B, 0B, 0\\\\);\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister \\\\(&\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(D.\\[0-9\\]+, 1, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(D.\\[0-9\\]+, 8, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, &\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister \\\\(&\\\\(\\\\(struct mytype\\\\) \\\\*object\\\\).indices.token, 1, 0B, 0B, 0\\\\);\" 1 \"original\" } }\n "}, {"sha": "4f90bdfbdaa505a2ff0ed5c2e17b6e6b5fc86fea", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_1.f90?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -15,7 +15,7 @@ subroutine test()\n \n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(4, 1, &xx.token, \\\\(void \\\\*\\\\) &xx, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(8, 1, &yy.token, \\\\(void \\\\*\\\\) &yy, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, 0B, 0B, 0.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "90998ee39aa01ab5b906276aba70ac556d2c0b16", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_2.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_2.f90?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -17,7 +17,7 @@ subroutine test()\n \n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &xx._data.token, \\\\(void \\\\*\\\\) &xx._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &yy._data.token, \\\\(void \\\\*\\\\) &yy._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "17f800ffe7006b494d9cbf0fee47d6714b9c21a2", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_alloc_3.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_alloc_3.f90?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -18,7 +18,7 @@ subroutine test\n \n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &xx._data.token, \\\\(void \\\\*\\\\) &xx._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_register \\\\(1, 1, &yy._data.token, \\\\(void \\\\*\\\\) &yy._data, &stat.., &errmsg, 200\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0, &stat.., &errmsg, 200.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&yy._data.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_deregister .&xx._data.token, 0, 0B, 0B, 0.;\" 1 \"original\" } }"}, {"sha": "8ad6b081a132835eea3efea9a496388fb70c118c", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -38,8 +38,8 @@\n if (any (A-B /= 0)) call abort\n end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, _gfortran_caf_this_image \\\\\\(0\\\\\\), &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, _gfortran_caf_this_image \\\\\\(0\\\\\\), &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.1, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) b, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }"}, {"sha": "97dda7b92d979f1ac461b70d89fa1bd9da43f589", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -1,3 +1,17 @@\n+2016-11-30  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* caf/libcaf.h: Add new action types for (de-)registration of\n+\tallocatable components in derived type coarrays.  Add _caf_is_present\n+\tprototype.\n+\t* caf/single.c (_gfortran_caf_register): Add support for registration\n+\tonly and allocation of already registered allocatable components in\n+\tderived type coarrays.\n+\t(_gfortran_caf_deregister): Add mode to deallocate but not deregister\n+\tan allocatable component in a derived type coarray.\n+\t(_gfortran_caf_is_present): New function.  Query whether an\n+\tallocatable component in a derived type coarray on a remote image is\n+\tallocated.\n+\n 2016-11-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/51119"}, {"sha": "1bb5176a6c1f6c49cf2ff2d684b86b860f06a762", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -50,7 +50,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define STAT_STOPPED_IMAGE \t6000\n #endif\n \n-/* Describes what type of array we are registerring. Keep in sync with\n+/* Describes what type of array we are registerring.  Keep in sync with\n    gcc/fortran/trans.h.  */\n typedef enum caf_register_t {\n   CAF_REGTYPE_COARRAY_STATIC,\n@@ -59,10 +59,20 @@ typedef enum caf_register_t {\n   CAF_REGTYPE_LOCK_ALLOC,\n   CAF_REGTYPE_CRITICAL,\n   CAF_REGTYPE_EVENT_STATIC,\n-  CAF_REGTYPE_EVENT_ALLOC\n+  CAF_REGTYPE_EVENT_ALLOC,\n+  CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY,\n+  CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY\n }\n caf_register_t;\n \n+/* Describes the action to take on _caf_deregister.  Keep in sync with\n+   gcc/fortran/trans.h.  */\n+typedef enum caf_deregister_t {\n+  CAF_DEREGTYPE_COARRAY_DEREGISTER,\n+  CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY\n+}\n+caf_deregister_t;\n+\n typedef void* caf_token_t;\n typedef gfc_array_void gfc_descriptor_t;\n \n@@ -174,7 +184,8 @@ int _gfortran_caf_num_images (int, int);\n \n void _gfortran_caf_register (size_t, caf_register_t, caf_token_t *,\n \t\t\t     gfc_descriptor_t *, int *, char *, int);\n-void _gfortran_caf_deregister (caf_token_t *, int *, char *, int);\n+void _gfortran_caf_deregister (caf_token_t *, caf_deregister_t, int *, char *,\n+\t\t\t       int);\n \n void _gfortran_caf_sync_all (int *, char *, int);\n void _gfortran_caf_sync_memory (int *, char *, int);\n@@ -232,4 +243,6 @@ void _gfortran_caf_event_post (caf_token_t, size_t, int, int *, char *, int);\n void _gfortran_caf_event_wait (caf_token_t, size_t, int, int *, char *, int);\n void _gfortran_caf_event_query (caf_token_t, size_t, int, int *, int *);\n \n+int _gfortran_caf_is_present (caf_token_t, int, caf_reference_t *);\n+\n #endif  /* LIBCAF_H  */"}, {"sha": "5e2932ca007eca41da135bde997206400973e1d9", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=ba85c8c3fcb19c776f6e2209d5b0044c9e1cdd3d", "patch": "@@ -144,11 +144,17 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n       || type == CAF_REGTYPE_CRITICAL || type == CAF_REGTYPE_EVENT_STATIC\n       || type == CAF_REGTYPE_EVENT_ALLOC)\n     local = calloc (size, sizeof (bool));\n+  else if (type == CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY)\n+    local = NULL;\n   else\n     local = malloc (size);\n-  *token = malloc (sizeof (struct caf_single_token));\n \n-  if (unlikely (local == NULL || *token == NULL))\n+  if (type != CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY)\n+    *token = malloc (sizeof (struct caf_single_token));\n+\n+  if (unlikely (*token == NULL\n+\t\t|| (local == NULL\n+\t\t    && type != CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY)))\n     {\n       /* Freeing the memory conditionally seems pointless, but\n \t caf_internal_error () may return, when a stat is given and then the\n@@ -163,7 +169,7 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n \n   single_token = TOKEN (*token);\n   single_token->memptr = local;\n-  single_token->owning_memory = true;\n+  single_token->owning_memory = type != CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY;\n   single_token->desc = GFC_DESCRIPTOR_RANK (data) > 0 ? data : NULL;\n \n \n@@ -184,7 +190,7 @@ _gfortran_caf_register (size_t size, caf_register_t type, caf_token_t *token,\n \n \n void\n-_gfortran_caf_deregister (caf_token_t *token, int *stat,\n+_gfortran_caf_deregister (caf_token_t *token, caf_deregister_t type, int *stat,\n \t\t\t  char *errmsg __attribute__ ((unused)),\n \t\t\t  int errmsg_len __attribute__ ((unused)))\n {\n@@ -193,7 +199,16 @@ _gfortran_caf_deregister (caf_token_t *token, int *stat,\n   if (single_token->owning_memory && single_token->memptr)\n     free (single_token->memptr);\n \n-  free (TOKEN (*token));\n+  if (type != CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY)\n+    {\n+      free (TOKEN (*token));\n+      *token = NULL;\n+    }\n+  else\n+    {\n+      single_token->memptr = NULL;\n+      single_token->owning_memory = false;\n+    }\n \n   if (stat)\n     *stat = 0;\n@@ -2882,3 +2897,102 @@ _gfortran_caf_unlock (caf_token_t token, size_t index,\n     }\n   _gfortran_caf_error_stop_str (msg, (int32_t) strlen (msg));\n }\n+\n+int\n+_gfortran_caf_is_present (caf_token_t token,\n+\t\t\t  int image_index __attribute__ ((unused)),\n+\t\t\t  caf_reference_t *refs)\n+{\n+  const char arraddressingnotallowed[] = \"libcaf_single::caf_is_present(): \"\n+\t\t\t\t   \"only scalar indexes allowed.\\n\";\n+  const char unknownreftype[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t\"unknown reference type.\\n\";\n+  const char unknownarrreftype[] = \"libcaf_single::caf_get_by_ref(): \"\n+\t\t\t\t   \"unknown array reference type.\\n\";\n+  size_t i;\n+  caf_single_token_t single_token = TOKEN (token);\n+  void *memptr = single_token->memptr;\n+  gfc_descriptor_t *src = single_token->desc;\n+  caf_reference_t *riter = refs;\n+\n+  while (riter)\n+    {\n+      switch (riter->type)\n+\t{\n+\tcase CAF_REF_COMPONENT:\n+\t  if (riter->u.c.caf_token_offset)\n+\t    {\n+\t      single_token = *(caf_single_token_t*)\n+\t\t\t\t\t (memptr + riter->u.c.caf_token_offset);\n+\t      memptr = single_token->memptr;\n+\t      src = single_token->desc;\n+\t    }\n+\t  else\n+\t    {\n+\t      memptr += riter->u.c.offset;\n+\t      src = (gfc_descriptor_t *)memptr;\n+\t    }\n+\t  break;\n+\tcase CAF_REF_ARRAY:\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  memptr += (riter->u.a.dim[i].s.start\n+\t\t\t     - GFC_DIMENSION_LBOUND (src->dim[i]))\n+\t\t      * GFC_DIMENSION_STRIDE (src->dim[i])\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  /* A full array ref is allowed on the last reference only.  */\n+\t\t  if (riter->next == NULL)\n+\t\t    break;\n+\t\t  /* else fall through reporting an error.  */\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\t  caf_internal_error (arraddressingnotallowed, 0, NULL, 0);\n+\t\t  return 0;\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, 0, NULL, 0);\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t  break;\n+\tcase CAF_REF_STATIC_ARRAY:\n+\t  for (i = 0; riter->u.a.mode[i] != CAF_ARR_REF_NONE; ++i)\n+\t    {\n+\t      switch (riter->u.a.mode[i])\n+\t\t{\n+\t\tcase CAF_ARR_REF_SINGLE:\n+\t\t  memptr += riter->u.a.dim[i].s.start\n+\t\t      * riter->u.a.dim[i].s.stride\n+\t\t      * riter->item_size;\n+\t\t  break;\n+\t\tcase CAF_ARR_REF_FULL:\n+\t\t  /* A full array ref is allowed on the last reference only.  */\n+\t\t  if (riter->next == NULL)\n+\t\t    break;\n+\t\t  /* else fall through reporting an error.  */\n+\t\tcase CAF_ARR_REF_VECTOR:\n+\t\tcase CAF_ARR_REF_RANGE:\n+\t\tcase CAF_ARR_REF_OPEN_END:\n+\t\tcase CAF_ARR_REF_OPEN_START:\n+\t\t  caf_internal_error (arraddressingnotallowed, 0, NULL, 0);\n+\t\t  return 0;\n+\t\tdefault:\n+\t\t  caf_internal_error (unknownarrreftype, 0, NULL, 0);\n+\t\t  return 0;\n+\t\t}\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  caf_internal_error (unknownreftype, 0, NULL, 0);\n+\t  return 0;\n+\t}\n+      riter = riter->next;\n+    }\n+  return memptr != NULL;\n+}"}]}