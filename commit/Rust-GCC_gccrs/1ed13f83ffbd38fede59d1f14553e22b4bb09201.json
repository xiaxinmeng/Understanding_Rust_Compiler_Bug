{"sha": "1ed13f83ffbd38fede59d1f14553e22b4bb09201", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVkMTNmODNmZmJkMzhmZWRlNTlkMWYxNDU1M2UyMmI0YmIwOTIwMQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-04-05T12:02:55Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-04-05T12:02:55Z"}, "message": "debug.h (debug_flush_symbol_queue, [...]): Delete.\n\n\t* debug.h (debug_flush_symbol_queue, debug_queue_symbol): Delete.\n\t(debug_free_queue, debug_nesting, symbol_queue_index): Delete.\n\t* final.c (debug_flush_symbol_queue, debug_queue_symbol):\n\tMove these...\n\t(debug_free_queue, debug_nesting, symbol_queue_index):\n\t...and these...\n\t* dbxout.c: ...to here.  Make static.\n\nFrom-SVN: r171981", "tree": {"sha": "daf4336ca9d37c03a6ce3bfe198ce256db2a1af5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daf4336ca9d37c03a6ce3bfe198ce256db2a1af5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ed13f83ffbd38fede59d1f14553e22b4bb09201", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed13f83ffbd38fede59d1f14553e22b4bb09201", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed13f83ffbd38fede59d1f14553e22b4bb09201", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed13f83ffbd38fede59d1f14553e22b4bb09201/comments", "author": null, "committer": null, "parents": [{"sha": "6ce1edcf6164b4447a39d06cda08a55f26759273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ce1edcf6164b4447a39d06cda08a55f26759273", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ce1edcf6164b4447a39d06cda08a55f26759273"}], "stats": {"total": 178, "additions": 91, "deletions": 87}, "files": [{"sha": "f309bcc876d405888e34b481a88fcdfd51ce7143", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ed13f83ffbd38fede59d1f14553e22b4bb09201", "patch": "@@ -1,3 +1,13 @@\n+2011-04-05  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* debug.h (debug_flush_symbol_queue, debug_queue_symbol): Delete.\n+\t(debug_free_queue, debug_nesting, symbol_queue_index): Delete.\n+\t* final.c (debug_flush_symbol_queue, debug_queue_symbol):\n+\tMove these...\n+\t(debug_free_queue, debug_nesting, symbol_queue_index):\n+\t...and these...\n+\t* dbxout.c: ...to here.  Make static.\n+\n 2011-04-05  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* gcse.c (modify_pair): Define.  Define a VEC of it."}, {"sha": "5ed9b69e7cdf28c9092230f82fe999a0d3ccbc90", "filename": "gcc/dbxout.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=1ed13f83ffbd38fede59d1f14553e22b4bb09201", "patch": "@@ -96,6 +96,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"xcoffout.h\"\n #endif\n \n+/* When -gused is used, emit debug info for only used symbols. But in\n+   addition to the standard intercepted debug_hooks there are some\n+   direct calls into this file, i.e., dbxout_symbol, dbxout_parms, and\n+   dbxout_reg_params.  Those routines may also be called from a higher\n+   level intercepted routine. So to prevent recording data for an inner\n+   call to one of these for an intercept, we maintain an intercept\n+   nesting counter (debug_nesting). We only save the intercepted\n+   arguments if the nesting is 1.  */\n+static int debug_nesting = 0;\n+\n+static tree *symbol_queue;\n+static int symbol_queue_index = 0;\n+static int symbol_queue_size = 0;\n+\n #define DBXOUT_DECR_NESTING \\\n   if (--debug_nesting == 0 && symbol_queue_index > 0) \\\n     { emit_pending_bincls_if_required (); debug_flush_symbol_queue (); }\n@@ -333,6 +347,7 @@ static const char *dbxout_common_check (tree, int *);\n static void dbxout_global_decl (tree);\n static void dbxout_type_decl (tree, int);\n static void dbxout_handle_pch (unsigned);\n+static void debug_free_queue (void);\n \f\n /* The debug hooks structure.  */\n #if defined (DBX_DEBUGGING_INFO)\n@@ -1403,7 +1418,73 @@ dbxout_type_index (tree type)\n }\n \n \f\n+/* Generate the symbols for any queued up type symbols we encountered\n+   while generating the type info for some originally used symbol.\n+   This might generate additional entries in the queue.  Only when\n+   the nesting depth goes to 0 is this routine called.  */\n+\n+static void\n+debug_flush_symbol_queue (void)\n+{\n+  int i;\n+\n+  /* Make sure that additionally queued items are not flushed\n+     prematurely.  */\n+\n+  ++debug_nesting;\n+\n+  for (i = 0; i < symbol_queue_index; ++i)\n+    {\n+      /* If we pushed queued symbols then such symbols must be\n+         output no matter what anyone else says.  Specifically,\n+         we need to make sure dbxout_symbol() thinks the symbol was\n+         used and also we need to override TYPE_DECL_SUPPRESS_DEBUG\n+         which may be set for outside reasons.  */\n+      int saved_tree_used = TREE_USED (symbol_queue[i]);\n+      int saved_suppress_debug = TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]);\n+      TREE_USED (symbol_queue[i]) = 1;\n+      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = 0;\n+\n+#ifdef DBX_DEBUGGING_INFO\n+      dbxout_symbol (symbol_queue[i], 0);\n+#endif\n+\n+      TREE_USED (symbol_queue[i]) = saved_tree_used;\n+      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = saved_suppress_debug;\n+    }\n+\n+  symbol_queue_index = 0;\n+  --debug_nesting;\n+}\n \n+/* Queue a type symbol needed as part of the definition of a decl\n+   symbol.  These symbols are generated when debug_flush_symbol_queue()\n+   is called.  */\n+\n+static void\n+debug_queue_symbol (tree decl)\n+{\n+  if (symbol_queue_index >= symbol_queue_size)\n+    {\n+      symbol_queue_size += 10;\n+      symbol_queue = XRESIZEVEC (tree, symbol_queue, symbol_queue_size);\n+    }\n+\n+  symbol_queue[symbol_queue_index++] = decl;\n+}\n+\n+/* Free symbol queue.  */\n+static void\n+debug_free_queue (void)\n+{\n+  if (symbol_queue)\n+    {\n+      free (symbol_queue);\n+      symbol_queue = NULL;\n+      symbol_queue_size = 0;\n+    }\n+}\n+\f\n /* Used in several places: evaluates to '0' for a private decl,\n    '1' for a protected decl, '2' for a public decl.  */\n #define DECL_ACCESSIBILITY_CHAR(DECL) \\"}, {"sha": "efdffe1889ab8a91fc720bc73248e5178bfdebe0", "filename": "gcc/debug.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdebug.h?ref=1ed13f83ffbd38fede59d1f14553e22b4bb09201", "patch": "@@ -186,12 +186,6 @@ extern int dwarf2out_do_frame (void);\n extern int dwarf2out_do_cfi_asm (void);\n extern void dwarf2out_switch_text_section (void);\n \n-extern void debug_flush_symbol_queue (void);\n-extern void debug_queue_symbol (tree);\n-extern void debug_free_queue (void);\n-extern int debug_nesting;\n-extern int symbol_queue_index;\n-\n const char *remap_debug_filename (const char *);\n void add_debug_prefix_map (const char *);\n "}, {"sha": "3d97397f9af11e1dcd0549199f6c0bbd06a46293", "filename": "gcc/final.c", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ed13f83ffbd38fede59d1f14553e22b4bb09201/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=1ed13f83ffbd38fede59d1f14553e22b4bb09201", "patch": "@@ -4146,87 +4146,6 @@ leaf_renumber_regs_insn (rtx in_rtx)\n       }\n }\n #endif\n-\n-\n-/* When -gused is used, emit debug info for only used symbols. But in\n-   addition to the standard intercepted debug_hooks there are some direct\n-   calls into this file, i.e., dbxout_symbol, dbxout_parms, and dbxout_reg_params.\n-   Those routines may also be called from a higher level intercepted routine. So\n-   to prevent recording data for an inner call to one of these for an intercept,\n-   we maintain an intercept nesting counter (debug_nesting). We only save the\n-   intercepted arguments if the nesting is 1.  */\n-int debug_nesting = 0;\n-\n-static tree *symbol_queue;\n-int symbol_queue_index = 0;\n-static int symbol_queue_size = 0;\n-\n-/* Generate the symbols for any queued up type symbols we encountered\n-   while generating the type info for some originally used symbol.\n-   This might generate additional entries in the queue.  Only when\n-   the nesting depth goes to 0 is this routine called.  */\n-\n-void\n-debug_flush_symbol_queue (void)\n-{\n-  int i;\n-\n-  /* Make sure that additionally queued items are not flushed\n-     prematurely.  */\n-\n-  ++debug_nesting;\n-\n-  for (i = 0; i < symbol_queue_index; ++i)\n-    {\n-      /* If we pushed queued symbols then such symbols must be\n-         output no matter what anyone else says.  Specifically,\n-         we need to make sure dbxout_symbol() thinks the symbol was\n-         used and also we need to override TYPE_DECL_SUPPRESS_DEBUG\n-         which may be set for outside reasons.  */\n-      int saved_tree_used = TREE_USED (symbol_queue[i]);\n-      int saved_suppress_debug = TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]);\n-      TREE_USED (symbol_queue[i]) = 1;\n-      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = 0;\n-\n-#ifdef DBX_DEBUGGING_INFO\n-      dbxout_symbol (symbol_queue[i], 0);\n-#endif\n-\n-      TREE_USED (symbol_queue[i]) = saved_tree_used;\n-      TYPE_DECL_SUPPRESS_DEBUG (symbol_queue[i]) = saved_suppress_debug;\n-    }\n-\n-  symbol_queue_index = 0;\n-  --debug_nesting;\n-}\n-\n-/* Queue a type symbol needed as part of the definition of a decl\n-   symbol.  These symbols are generated when debug_flush_symbol_queue()\n-   is called.  */\n-\n-void\n-debug_queue_symbol (tree decl)\n-{\n-  if (symbol_queue_index >= symbol_queue_size)\n-    {\n-      symbol_queue_size += 10;\n-      symbol_queue = XRESIZEVEC (tree, symbol_queue, symbol_queue_size);\n-    }\n-\n-  symbol_queue[symbol_queue_index++] = decl;\n-}\n-\n-/* Free symbol queue.  */\n-void\n-debug_free_queue (void)\n-{\n-  if (symbol_queue)\n-    {\n-      free (symbol_queue);\n-      symbol_queue = NULL;\n-      symbol_queue_size = 0;\n-    }\n-}\n \f\n /* Turn the RTL into assembly.  */\n static unsigned int"}]}