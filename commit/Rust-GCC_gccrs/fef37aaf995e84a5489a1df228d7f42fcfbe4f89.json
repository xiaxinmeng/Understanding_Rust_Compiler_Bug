{"sha": "fef37aaf995e84a5489a1df228d7f42fcfbe4f89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmVmMzdhYWY5OTVlODRhNTQ4OWExZGYyMjhkN2Y0MmZjZmJlNGY4OQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1997-05-08T22:17:34Z"}, "message": "(attr cpu): Add new cpu types for arm8 and strongarm.\n\n(attr ldsched): New attribute, set if processor has a load_delay slot.\n(function_unit core): Rework to handle load delay slots.\n(function_unit loader): New function unit.\n(movsi): Handle pic.\n(pic_load_addr): New expand.\n(*pic_load_addr_based_insn, pic_add_dot_plus_eight): New patterns.\n(peepholes to cause flow to return to a label after a function call):\nDelete, these have been disabled for a while now.\n\nFrom-SVN: r14052", "tree": {"sha": "2e7da468a1bd2ca7861c8a0457e489243140cc8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e7da468a1bd2ca7861c8a0457e489243140cc8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fef37aaf995e84a5489a1df228d7f42fcfbe4f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef37aaf995e84a5489a1df228d7f42fcfbe4f89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef37aaf995e84a5489a1df228d7f42fcfbe4f89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef37aaf995e84a5489a1df228d7f42fcfbe4f89/comments", "author": null, "committer": null, "parents": [{"sha": "7a80182693f336b67212ca927e8d7307dff2f737", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a80182693f336b67212ca927e8d7307dff2f737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a80182693f336b67212ca927e8d7307dff2f737"}], "stats": {"total": 164, "additions": 68, "deletions": 96}, "files": [{"sha": "d28a3a0bf328aacc22d6226a1b5a3ca8f572e7ea", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 68, "deletions": 96, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fef37aaf995e84a5489a1df228d7f42fcfbe4f89/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fef37aaf995e84a5489a1df228d7f42fcfbe4f89/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=fef37aaf995e84a5489a1df228d7f42fcfbe4f89", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for Advanced RISC Machines' ARM for GNU compiler\n-;;  Copyright (C) 1991, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.\n+;;  Copyright (C) 1991, 93, 94, 95, 96, 1997 Free Software Foundation, Inc.\n ;;  Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)\n ;;             and Martin Simmons (@harleqn.co.uk).\n ;;  More major hacks by Richard Earnshaw (rwe11@cl.cam.ac.uk)\n@@ -49,7 +49,7 @@\n ; by a call insn: on the arm6 they are if in 32-bit addressing mode; on the\n ; arm2 and arm3 the condition codes are restored by the return.\n \n-(define_attr \"cpu\" \"arm2,arm3,arm6,arm7\"\n+(define_attr \"cpu\" \"arm2,arm3,arm6,arm7,arm8,st_arm\"\n \t(const (symbol_ref \"arm_cpu_attr\")))\n \n ; Floating Point Unit.  If we only have floating point emulation, then there\n@@ -102,6 +102,12 @@\n \t\"normal,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,float_em,f_load,f_store,f_mem_r,r_mem_f,f_2_r,r_2_f,call,load,store1,store2,store3,store4\" \n \t(const_string \"normal\"))\n \n+; Load scheduling, set from the cpu characteristic\n+(define_attr \"ldsched\" \"no,yes\"\n+  (if_then_else (eq_attr \"cpu\" \"arm8,st_arm\")\n+\t\t(const_string \"yes\")\n+\t\t(const_string \"no\")))\n+\n ; condition codes: this one is used by final_prescan_insn to speed up\n ; conditionalizing instructions.  It saves having to scan the rtl to see if\n ; it uses or alters the condition codes.\n@@ -210,13 +216,23 @@\n (define_function_unit \"write_blockage\" 1 0 \n \t(eq_attr \"write_conflict\" \"yes\") 1 1)\n \n+\n+\n (define_function_unit \"core\" 1 1 (eq_attr \"core_cycles\" \"single\") 1 1)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"load\") 2 2)\n+(define_function_unit \"core\" 1 1 \n+  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 1 1)\n+\n+(define_function_unit \"core\" 1 1 \n+  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"load\")) 2 2)\n \n (define_function_unit \"core\" 1 1 (eq_attr \"type\" \"mult\") 16 16)\n \n-(define_function_unit \"core\" 1 1 (eq_attr \"type\" \"store1\") 2 2)\n+(define_function_unit \"core\" 1 1 \n+  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"store1\")) 1 1)\n+\n+(define_function_unit \"core\" 1 1 \n+  (and (eq_attr \"ldsched\" \"!yes\") (eq_attr \"type\" \"store1\")) 2 2)\n \n (define_function_unit \"core\" 1 1 (eq_attr \"type\" \"store2\") 3 3)\n \n@@ -228,6 +244,9 @@\n   (and (eq_attr \"core_cycles\" \"multi\")\n        (eq_attr \"type\" \"!mult,load,store2,store3,store4\")) 32 32)\n \n+(define_function_unit \"loader\" 1 0 \n+  (and (eq_attr \"ldsched\" \"yes\") (eq_attr \"type\" \"load\")) 2 1)\n+\n \f\n ;; Note: For DImode insns, there is normally no reason why operands should\n ;; not be in the same register, what we don't want is for something being\n@@ -2420,6 +2439,11 @@\n \t\t\t   : preserve_subexpressions_p ()));\n       DONE;\n     }\n+  if (CONSTANT_P (operands[1]) && flag_pic)\n+    operands[1] = legitimize_pic_address (operands[1], SImode,\n+\t\t\t\t\t  ((reload_in_progress\n+\t\t\t\t\t    || reload_completed)\n+\t\t\t\t\t   ? operands[0] : 0));\n \")\n \n (define_insn \"*movsi_insn\"\n@@ -2463,6 +2487,46 @@\n \t   && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT))\"\n   \"adr%?\\\\t%0, %a1\")\n \n+/* When generating pic, we need to load the symbol offset into a register.\n+   So that the optimizer does not confuse this with a normal symbol load\n+   we use an unspec.  The offset will be loaded from a constant pool entry,\n+   since that is the only type of relocation we can use.  */\n+\n+(define_insn \"pic_load_addr\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\")] 3))]\n+  \"flag_pic\"\n+  \"ldr%?\\\\t%0, %a1\"\n+ [(set_attr \"type\" \"load\")])\n+\n+;; This variant is used for AOF assembly, since it needs to mention the\n+;; pic register in the rtl.\n+(define_expand \"pic_load_addr_based\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\") (match_dup 2)] 3))]\n+  \"flag_pic\"\n+  \"operands[2] = pic_offset_table_rtx;\")\n+\n+(define_insn \"*pic_load_addr_based_insn\"\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand 1 \"\" \"\")\n+\t\t    (match_operand 2 \"s_register_operand\" \"r\")] 3))]\n+  \"flag_pic && operands[2] == pic_offset_table_rtx\"\n+  \"*\n+#ifdef AOF_ASSEMBLER\n+  operands[1] = aof_pic_entry (operands[1]);\n+#endif\n+  output_asm_insn (\\\"ldr%?\\\\t%0, %a1\\\", operands);\n+  return \\\"\\\";\n+\" [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"pic_add_dot_plus_eight\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))\n+   (set (match_operand 1 \"register_operand\" \"+r\")\n+\t(plus:SI (match_dup 1) (const (plus:SI (pc) (const_int 8)))))]\n+  \"flag_pic\"\n+  \"add%?\\\\t%1, %|pc, %1\")\n+\n ;; If copying one reg to another we can set the condition codes according to\n ;; its value.  Such a move is common after a return from subroutine and the\n ;; result is being tested against zero.\n@@ -5775,98 +5839,6 @@\n [(set_attr \"type\" \"call\")\n  (set_attr \"length\" \"8\")])\n \n-;; If calling a subroutine and then jumping back to somewhere else, but not\n-;; too far away, then we can set the link register with the branch address\n-;; and jump direct to the subroutine.  On return from the subroutine\n-;; execution continues at the branch; this avoids a prefetch stall.\n-;; We use the length attribute (via short_branch ()) to establish whether or\n-;; not this is possible, this is the same as the sparc does.\n-\n-(define_peephole\n-  [(parallel[(call (mem:SI (match_operand:SI 0 \"\" \"X\"))\n-                   (match_operand:SI 1 \"general_operand\" \"g\"))\n-             (clobber (reg:SI 14))])\n-   (set (pc)\n-        (label_ref (match_operand 2 \"\" \"\")))]\n-  \"0 && GET_CODE (operands[0]) == SYMBOL_REF \n-   && short_branch (INSN_UID (insn), INSN_UID (operands[2]))\n-   && arm_insn_not_targeted (insn)\"\n-  \"*\n-{\n-  int backward = arm_backwards_branch (INSN_UID (insn),\n-\t\t\t\t       INSN_UID (operands[2]));\n-\n-#if 0\n-  /* Putting this in means that TARGET_6 code will ONLY run on an arm6 or\n-   * above, leaving it out means that the code will still run on an arm 2 or 3\n-   */\n-  if (TARGET_6)\n-    {\n-      if (backward)\n-\toutput_asm_insn (\\\"sub%?\\\\t%|lr, %|pc, #(8 + . -%l2)\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"add%?\\\\t%|lr, %|pc, #(%l2 - . -8)\\\", operands);\n-    }\n-  else\n-#endif\n-    {\n-      output_asm_insn (\\\"mov%?\\\\t%|lr, %|pc\\\\t%@ protect cc\\\", operands);\n-      if (backward)\n-\toutput_asm_insn (\\\"sub%?\\\\t%|lr, %|lr, #(4 + . -%l2)\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"add%?\\\\t%|lr, %|lr, #(%l2 - . -4)\\\", operands);\n-    }\n-  return \\\"b%?\\\\t%a0\\\";\n-}\"\n-[(set_attr \"type\" \"call\")\n- (set (attr \"length\")\n-      (if_then_else (eq_attr \"prog_mode\" \"prog32\")\n-\t\t    (const_int 8)\n-\t\t    (const_int 12)))])\n-\n-(define_peephole\n-  [(parallel[(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t\t  (call (mem:SI (match_operand:SI 1 \"\" \"X\"))\n-                        (match_operand:SI 2 \"general_operand\" \"g\")))\n-             (clobber (reg:SI 14))])\n-   (set (pc)\n-        (label_ref (match_operand 3 \"\" \"\")))]\n-  \"0 && GET_CODE (operands[0]) == SYMBOL_REF\n-   && short_branch (INSN_UID (insn), INSN_UID (operands[3]))\n-   && arm_insn_not_targeted (insn)\"\n-  \"*\n-{\n-  int backward = arm_backwards_branch (INSN_UID (insn),\n-\t\t\t\t       INSN_UID (operands[3]));\n-\n-#if 0\n-  /* Putting this in means that TARGET_6 code will ONLY run on an arm6 or\n-   * above, leaving it out means that the code will still run on an arm 2 or 3\n-   */\n-  if (TARGET_6)\n-    {\n-      if (backward)\n-\toutput_asm_insn (\\\"sub%?\\\\t%|lr, %|pc, #(8 + . -%l3)\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"add%?\\\\t%|lr, %|pc, #(%l3 - . -8)\\\", operands);\n-    }\n-  else\n-#endif\n-    {\n-      output_asm_insn (\\\"mov%?\\\\t%|lr, %|pc\\\\t%@ protect cc\\\", operands);\n-      if (backward)\n-\toutput_asm_insn (\\\"sub%?\\\\t%|lr, %|lr, #(4 + . -%l3)\\\", operands);\n-      else\n-\toutput_asm_insn (\\\"add%?\\\\t%|lr, %|lr, #(%l3 - . -4)\\\", operands);\n-    }\n-  return \\\"b%?\\\\t%a1\\\";\n-}\"\n-[(set_attr \"type\" \"call\")\n- (set (attr \"length\")\n-      (if_then_else (eq_attr \"prog_mode\" \"prog32\")\n-\t\t    (const_int 8)\n-\t\t    (const_int 12)))])\n-\n (define_split\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(and:SI (ge:SI (match_operand:SI 1 \"s_register_operand\" \"\")"}]}