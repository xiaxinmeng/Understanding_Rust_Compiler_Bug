{"sha": "3a538a6668acdfe94dd05fa36ef0341cb2382a88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E1MzhhNjY2OGFjZGZlOTRkZDA1ZmEzNmVmMDM0MWNiMjM4MmE4OA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-11T10:47:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-11T10:47:05Z"}, "message": "dbxout.c: Fix formatting.\n\n\t* dbxout.c: Fix formatting.\n\t* dependence.c: Likewise.\n\t* df.c: Likewise.\n\t* diagnostic.c: Likewise.\n\t* doloop.c: Likewise.\n\t* dominance.c: Likewise.\n\t* doschk.c: Likewise.\n\t* dwarf2asm.c: Likewise.\n\t* dwarf2out.c: Likewise.\n\t* dwarfout.c: Likewise.\n\nFrom-SVN: r53380", "tree": {"sha": "da16232d8b5f58baa59884c0e12dc7f8fef82993", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da16232d8b5f58baa59884c0e12dc7f8fef82993"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a538a6668acdfe94dd05fa36ef0341cb2382a88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a538a6668acdfe94dd05fa36ef0341cb2382a88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a538a6668acdfe94dd05fa36ef0341cb2382a88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a538a6668acdfe94dd05fa36ef0341cb2382a88/comments", "author": null, "committer": null, "parents": [{"sha": "c9c2cb7c995ab5a0756a7c6a606e18206b368903", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9c2cb7c995ab5a0756a7c6a606e18206b368903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9c2cb7c995ab5a0756a7c6a606e18206b368903"}], "stats": {"total": 757, "additions": 388, "deletions": 369}, "files": [{"sha": "272472033ad02a2e7b24c82f79eee7ac0e8811f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -1,3 +1,16 @@\n+2002-05-11  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* dbxout.c: Fix formatting.\n+\t* dependence.c: Likewise.\n+\t* df.c: Likewise.\n+\t* diagnostic.c: Likewise.\n+\t* doloop.c: Likewise.\n+\t* dominance.c: Likewise.\n+\t* doschk.c: Likewise.\n+\t* dwarf2asm.c: Likewise.\n+\t* dwarf2out.c: Likewise.\n+\t* dwarfout.c: Likewise.\n+\n 2002-05-10  Richard Henderson  <rth@redhat.com>\n \n \t* final.c (end_final): Tidy whitespace.  Don't honor flag_pack_struct."}, {"sha": "fc49ad70a5a6ec1fc262b62b7cf12dafc7d56963", "filename": "gcc/dbxout.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -669,7 +669,7 @@ dbxout_global_decl (decl)\n       && ! DECL_EXTERNAL (decl)\n       && DECL_RTL_SET_P (decl))\t/* Not necessary?  */\n     dbxout_symbol (decl, 0);\n-} \n+}\n \n /* At the end of compilation, finish writing the symbol table.\n    Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is\n@@ -959,7 +959,7 @@ dbxout_type_methods (type)\n \t}\n       if (!need_prefix)\n \t{\n-          putc (';', asmfile);\n+\t  putc (';', asmfile);\n \t  CHARS (1);\n \t}\n     }\n@@ -1219,7 +1219,7 @@ dbxout_type (type, full)\n \t write it as a subtype.  */\n       else if (TREE_TYPE (type) != 0\n \t       && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n-        {\n+\t{\n \t  /* If the size is non-standard, say what it is if we can use\n \t     GDB extensions.  */\n \n@@ -1232,10 +1232,10 @@ dbxout_type (type, full)\n \t    }\n \n \t  dbxout_range_type (type);\n-        }\n+\t}\n \n       else\n-  \t{\n+\t{\n \t  /* If the size is non-standard, say what it is if we can use\n \t     GDB extensions.  */\n \n@@ -1259,7 +1259,7 @@ dbxout_type (type, full)\n \t     larger.  This is because we print the bounds as signed decimal,\n \t     and hence they can't span same size unsigned types.  */\n \n- \t  if (use_gnu_debug_info_extensions\n+\t  if (use_gnu_debug_info_extensions\n \t      && TYPE_MIN_VALUE (type) != 0\n \t      && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST\n \t      && TYPE_MAX_VALUE (type) != 0\n@@ -1288,7 +1288,7 @@ dbxout_type (type, full)\n \t  else\n \t    /* Output other integer types as subranges of `int'.  */\n \t    dbxout_range_type (type);\n-  \t}\n+\t}\n \n       break;\n \n@@ -1801,7 +1801,7 @@ print_wide_int (c)\n \n   CHARS (digs);\n }\n-      \n+\n /* Output the name of type TYPE, with no punctuation.\n    Such names can be set up either by typedef declarations\n    or by struct, enum and union tags.  */\n@@ -1947,7 +1947,7 @@ dbxout_symbol (decl, local)\n \t\t&& !TREE_ASM_WRITTEN (TYPE_NAME (type))\n \t\t/* Distinguish the implicit typedefs of C++\n \t\t   from explicit ones that might be found in C.  */\n-                && DECL_ARTIFICIAL (decl)\n+\t\t&& DECL_ARTIFICIAL (decl)\n \t\t/* Do not generate a tag for records of variable size,\n \t\t   since this type can not be properly described in the\n \t\t   DBX format, and it confuses some tools such as objdump.  */\n@@ -1979,7 +1979,7 @@ dbxout_symbol (decl, local)\n \t\t&& TYPE_NAME (type) == decl\n \t\t/* Distinguish the implicit typedefs of C++\n \t\t   from explicit ones that might be found in C.  */\n-                && DECL_ARTIFICIAL (decl))\n+\t\t&& DECL_ARTIFICIAL (decl))\n \t      {\n \t\tif (use_gnu_debug_info_extensions && have_used_extensions)\n \t\t  {\n@@ -2112,7 +2112,7 @@ dbxout_symbol (decl, local)\n \n       result = dbxout_symbol_location (decl, type, 0, DECL_RTL (decl));\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -2136,7 +2136,7 @@ dbxout_symbol_location (decl, type, suffix, home)\n \n   /* Don't mention a variable at all\n      if it was completely optimized into nothingness.\n-     \n+\n      If the decl was from an inline function, then its rtl\n      is not identically the rtl that was used in this\n      particular compilation.  */\n@@ -2215,7 +2215,7 @@ dbxout_symbol_location (decl, type, suffix, home)\n \t\t      || GET_CODE (tmp) == LABEL_REF)\n \t\t    current_sym_addr = tmp;\n \t\t}\n-  \n+\n \t      /* Ultrix `as' seems to need this.  */\n #ifdef DBX_STATIC_STAB_DATA_SECTION\n \t      data_section ();\n@@ -2504,7 +2504,7 @@ dbxout_parms (parms)\n \t      }\n \n \t    /* It is quite tempting to use:\n-\t       \n+\n \t           dbxout_type (TREE_TYPE (parms), 0);\n \n \t       as the next statement, rather than using DECL_ARG_TYPE(), so\n@@ -2517,7 +2517,7 @@ dbxout_parms (parms)\n \t       double on the stack, but if we emit a stab saying the type is a\n \t       float, then gdb will only read in a single value, and this will\n \t       produce an erroneous value.  */\n- \t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n+\t    dbxout_type (DECL_ARG_TYPE (parms), 0);\n \t    current_sym_value = DEBUGGER_ARG_OFFSET (current_sym_value, addr);\n \t    dbxout_finish_symbol (parms);\n \t  }\n@@ -2635,13 +2635,13 @@ dbxout_parms (parms)\n \t    const char *const decl_name = (DECL_NAME (parms)\n \t\t\t\t     ? IDENTIFIER_POINTER (DECL_NAME (parms))\n \t\t\t\t     : \"(anon)\");\n-           if (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 0)) == REG)\n-              current_sym_value = 0;\n+\t    if (GET_CODE (XEXP (XEXP (DECL_RTL (parms), 0), 0)) == REG)\n+\t      current_sym_value = 0;\n \t    else\n \t      current_sym_value\n \t        = INTVAL (XEXP (XEXP (XEXP (DECL_RTL (parms), 0), 0), 1));\n \t    current_sym_addr = 0;\n-\t      \n+\n \t    FORCE_TEXT;\n \t    fprintf (asmfile, \"%s\\\"%s:v\", ASM_STABS_OP, decl_name);\n \n@@ -2679,7 +2679,7 @@ dbxout_parms (parms)\n \t\t&& TYPE_MODE (TREE_TYPE (parms)) != GET_MODE (DECL_RTL (parms))\n \t\t&& GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms))) < UNITS_PER_WORD)\n \t      {\n-\t\tcurrent_sym_value += \n+\t\tcurrent_sym_value +=\n \t\t    GET_MODE_SIZE (GET_MODE (DECL_RTL (parms)))\n \t\t    - GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (parms)));\n \t      }\n@@ -2789,7 +2789,7 @@ dbxout_block (block, depth, args)\n   int blocknum = -1;\n \n #if DBX_BLOCKS_FUNCTION_RELATIVE\n-  const char *begin_label; \n+  const char *begin_label;\n   if (current_function_func_begin_label != NULL_TREE)\n     begin_label = IDENTIFIER_POINTER (current_function_func_begin_label);\n   else"}, {"sha": "d4bb2eac4fa95bf713540a906cf1a5836474a1fd", "filename": "gcc/dependence.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdependence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdependence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdependence.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -149,7 +149,7 @@ typedef struct dependence\n   int distance[MAX_SUBSCRIPTS];\n   struct dependence *next;\n } dependence;\n-  \n+\n /* subscripts are represented by an array of these.  Each reflects one\n    X * i + Y term, where X and Y are constants.  */\n \n@@ -255,7 +255,7 @@ init_dependence_analysis (exp)\n }\n \n /* Build ARRAY_REF def/use info 'def_use_chain' starting at EXP which is a def\n-   or use DU_TYPE */ \n+   or use DU_TYPE */\n \n static void\n build_def_use (exp, du_type)\n@@ -277,7 +277,7 @@ build_def_use (exp, du_type)\n       nloop = 0;\n       du_idx = 0;\n     }\n-  \n+\n   while (node)\n     switch (TREE_CODE (node))\n       {\n@@ -301,15 +301,15 @@ build_def_use (exp, du_type)\n \t\t\t\t     TREE_OPERAND (node, 2), loop_def)\n \t    == 0)\n \t  loop_def->status = unnormal;\n-\t  \n+\n \tbuild_def_use (TREE_OPERAND (node, 3), 0);\n \tnloop--;\n \tcurrent_loop = 0;\n \tnode = TREE_CHAIN (node);\n \tbreak;\n       case MODIFY_EXPR:\n \t/* Is an induction variable modified? */\n-\tif (loop_def \n+\tif (loop_def\n \t    && TREE_CODE (TREE_OPERAND (node, 0)) == VAR_DECL\n \t    && have_induction_variable\n \t       (loop_def->outer_loop,\n@@ -362,7 +362,7 @@ build_def_use (exp, du_type)\n \t\t    break;\n \t\t  }\n \t      }\n-\t    \n+\n \t    for (i = 0;\n \t\t i < du_idx\n \t\t   && strcmp (IDENTIFIER_POINTER (DECL_NAME (array_ref)),\n@@ -388,7 +388,7 @@ build_def_use (exp, du_type)\n       case DECL_STMT:\n \tnode = TREE_CHAIN (node);\n \tbreak;\n-\t\n+\n       case EXPR_STMT:\n \tif (TREE_CODE (TREE_OPERAND (node, 0)) == MODIFY_EXPR)\n \t  build_def_use (TREE_OPERAND (node, 0), def);\n@@ -514,7 +514,7 @@ find_induction_variable (init_node, cond_node, incr_node, loop_def)\n \n       ind_ptr->low_bound = get_low_bound (init_node, ind_ptr->variable);\n       if (TREE_CODE (TREE_OPERAND (cond_node, 0)) == VAR_DECL\n-\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 0))) \n+\t  && IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (cond_node, 0)))\n \t     == ind_ptr->variable)\n \t{\n \t  if (TREE_CODE (TREE_OPERAND (cond_node, 1)) == INTEGER_CST)\n@@ -732,7 +732,7 @@ check_node_dependence (du)\n \t\t\t      ck_loop_ptr, j);\n \t\t  /* ?? Add other tests: single variable exact test, banerjee */\n \t\t}\n-\t    \n+\n \t      ck_loop_ptr = ck_loop_ptr->next_nest;\n \t    }\n \n@@ -752,8 +752,8 @@ check_node_dependence (du)\n \t  dep_ptr->source = use_ptr->expression;\n \t  dep_ptr->destination = def_ptr->expression;\n \t  dep_ptr->next = 0;\n-\t  \n-\t  if (def_ptr < use_ptr && use_ptr->type == use) \n+\n+\t  if (def_ptr < use_ptr && use_ptr->type == use)\n \t    dep_ptr->dependence = dt_flow;\n \t  else if (def_ptr > use_ptr && use_ptr->type == use)\n \t    dep_ptr->dependence = dt_anti;\n@@ -832,7 +832,7 @@ get_coefficients (du, coefficients)\n       coefficients[i].variable = 0;\n       coefficients[i].next = 0;\n     }\n-  \n+\n   for (array_ref = du->expression;\n        TREE_CODE (array_ref) == ARRAY_REF;\n        array_ref = TREE_OPERAND (array_ref, 0))\n@@ -951,7 +951,7 @@ normalize_coefficients (coefficients, loop_ptr, count)\n \n   for (i = 1; i <= count; i++)\n     {\n-      for (ck_loop_ptr = loop_ptr; ck_loop_ptr; \n+      for (ck_loop_ptr = loop_ptr; ck_loop_ptr;\n \t   ck_loop_ptr = ck_loop_ptr->next_nest)\n \tfor (ind_ptr = ck_loop_ptr->ind; ind_ptr; ind_ptr = ind_ptr->next)\n \t  {\n@@ -1014,7 +1014,7 @@ classify_dependence (icoefficients, ocoefficients, complexity, separability,\n \t    }\n \t}\n     }\n-  \n+\n   for (idx = 1; idx <= count; idx++)\n     {\n       if (iiv_used[idx] == 0 && oiv_used[idx] == 0)\n@@ -1178,7 +1178,7 @@ gcd_test (icoefficients, ocoefficients, direction, distance, loop_ptr, sub)\n     }\n   /* ?? gcd does not yield direction and distance.  Wolfe's direction\n      vector hierarchy can be used to give this.  */\n-}     \n+}\n \n /* Find the gcd of X and Y using Euclid's algorithm */\n \n@@ -1213,7 +1213,7 @@ find_gcd (x, y)\n }\n \n /* Merge SUBSCRIPT_COUNT DIRECTIONs and DISTANCEs for LOOP_COUNT loops.\n-   We use a predefined array to handle the direction merge.  \n+   We use a predefined array to handle the direction merge.\n    The distance merge makes use of the fact that distances default to\n    INT_MAX.  Distances are '&' together.  Watch out for a negative distance.\n */\n@@ -1228,7 +1228,7 @@ merge_dependencies (direction, distance, loop_count, subscript_count)\n   int i, j;\n   int sign;\n \n-  static const enum direction_type direction_merge [8][8] = \n+  static const enum direction_type direction_merge [8][8] =\n   {{lt, le, le, star, star, lt, independent, lt},\n    {le, le, le, star, star, le, independent, le},\n    {le, le, eq, ge, ge, eq, independent, eq},\n@@ -1238,7 +1238,7 @@ merge_dependencies (direction, distance, loop_count, subscript_count)\n    {independent, independent, independent, independent, independent},\n    {independent, independent, independent}\n   };\n-  \n+\n   for (i = 1; i <= loop_count; i++)\n     {\n       distance[i][0] = INT_MAX;\n@@ -1314,7 +1314,7 @@ dump_one_node (du, seen)\n       for (array_ref = du_ptr->expression;\n \t   TREE_CODE (array_ref) == ARRAY_REF;\n \t   array_ref = TREE_OPERAND (array_ref, 0))\n-\t{\t\n+\t{\n \t  printf (\"[\");\n \t  dump_array_ref (TREE_OPERAND (array_ref, 1));\n \t  printf (\"]\");\n@@ -1395,7 +1395,7 @@ search_dependence (node)\n \t    return dep_idx + 1;\n \t}\n     }\n-  \n+\n   return 0;\n }\n \n@@ -1418,7 +1418,7 @@ remember_dest_for_dependence (node)\n #define MEM_DEPENDENCY(RTX) XCWINT (RTX, 2, MEM)\n #endif\n \n-/* Return 1 along with the dependence DIRECTION and DISTANCE if there is a \n+/* Return 1 along with the dependence DIRECTION and DISTANCE if there is a\n    dependence from dest_rtx to src_rtx.  */\n \n int"}, {"sha": "be36febfea95c528bdee1bb70f1f6b21fe257d81", "filename": "gcc/df.c", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -153,7 +153,7 @@ when optimising a loop, only certain registers are of interest.\n Perhaps there should be a bitmap argument to df_analyse to specify\n  which registers should be analysed?   */\n \n-#define HANDLE_SUBREG \n+#define HANDLE_SUBREG\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -295,16 +295,16 @@ static void df_chain_dump PARAMS((struct df_link *, FILE *file));\n static void df_chain_dump_regno PARAMS((struct df_link *, FILE *file));\n static void df_regno_debug PARAMS ((struct df *, unsigned int, FILE *));\n static void df_ref_debug PARAMS ((struct df *, struct ref *, FILE *));\n-static void df_rd_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+static void df_rd_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n-static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n-static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n+static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n-static void hybrid_search_bitmap PARAMS ((basic_block, bitmap *, bitmap *, \n-\t\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir, \n-\t\t\t\t\t  enum df_confluence_op, \n-\t\t\t\t\t  transfer_function_bitmap, \n+static void hybrid_search_bitmap PARAMS ((basic_block, bitmap *, bitmap *,\n+\t\t\t\t\t  bitmap *, bitmap *, enum df_flow_dir,\n+\t\t\t\t\t  enum df_confluence_op,\n+\t\t\t\t\t  transfer_function_bitmap,\n \t\t\t\t\t  sbitmap, sbitmap, void *));\n static void hybrid_search_sbitmap PARAMS ((basic_block, sbitmap *, sbitmap *,\n \t\t\t\t\t   sbitmap *, sbitmap *, enum df_flow_dir,\n@@ -881,7 +881,7 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n      XXX Is that true?  We could also use the global word_mode variable.  */\n   if (GET_CODE (reg) == SUBREG\n       && (GET_MODE_SIZE (GET_MODE (reg)) < GET_MODE_SIZE (word_mode)\n-          || GET_MODE_SIZE (GET_MODE (reg))\n+\t  || GET_MODE_SIZE (GET_MODE (reg))\n \t       >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (reg)))))\n     {\n       loc = &SUBREG_REG (reg);\n@@ -956,7 +956,7 @@ df_def_record_1 (df, x, bb, insn)\n   /* May be, we should flag the use of strict_low_part somehow.  Might be\n      handy for the reg allocator.  */\n   while (GET_CODE (dst) == STRICT_LOW_PART\n-         || GET_CODE (dst) == ZERO_EXTRACT\n+\t || GET_CODE (dst) == ZERO_EXTRACT\n \t || GET_CODE (dst) == SIGN_EXTRACT\n \t || read_modify_subreg_p (dst))\n     {\n@@ -971,9 +971,9 @@ df_def_record_1 (df, x, bb, insn)\n       dst = *loc;\n       flags |= DF_REF_READ_WRITE;\n     }\n-  \n+\n     if (GET_CODE (dst) == REG\n-        || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n+\t|| (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n       df_ref_record (df, dst, loc, insn, DF_REF_REG_DEF, flags);\n }\n \n@@ -1090,7 +1090,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t    case PC:\n \t      break;\n \t    case MEM:\n-\t      df_uses_record (df, &XEXP (dst, 0), \n+\t      df_uses_record (df, &XEXP (dst, 0),\n \t\t\t      DF_REF_REG_MEM_STORE,\n \t\t\t      bb, insn, 0);\n \t      break;\n@@ -1135,7 +1135,7 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t   For now, just mark any regs we can find in ASM_OPERANDS as\n \t   used.  */\n \n-        /* For all ASM_OPERANDS, we must traverse the vector of input operands.\n+\t/* For all ASM_OPERANDS, we must traverse the vector of input operands.\n \t   We can not just fall through here since then we would be confused\n \t   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate\n \t   traditional asms unlike their normal usage.  */\n@@ -1253,7 +1253,7 @@ df_insn_refs_record (df, bb, insn)\n \t\t  {\n \t\t    x = df_reg_use_gen (i);\n \t\t    df_uses_record (df, &SET_DEST (x),\n- \t\t\t\t    DF_REF_REG_USE, bb, insn, 0);\n+\t\t\t\t    DF_REF_REG_USE, bb, insn, 0);\n \t\t  }\n \t    }\n \t}\n@@ -1673,7 +1673,7 @@ df_bb_rd_local_compute (df, bb)\n \t  bitmap_set_bit (bb_info->rd_gen, DF_REF_ID (def));\n \t}\n     }\n-  \n+\n   bb_info->rd_valid = 1;\n }\n \n@@ -1703,7 +1703,7 @@ df_bb_ru_local_compute (df, bb)\n   /* This is much more tricky than computing reaching defs.  With\n      reaching defs, defs get killed by other defs.  With upwards\n      exposed uses, these get killed by defs with the same regno.  */\n-  \n+\n   struct bb_info *bb_info = DF_BB_INFO (df, bb);\n   rtx insn;\n \n@@ -2015,7 +2015,7 @@ df_analyse_1 (df, blocks, flags, update)\n   df->inverse_dfs_map = xmalloc (sizeof(int) * n_basic_blocks);\n   df->inverse_rc_map = xmalloc (sizeof(int) * n_basic_blocks);\n   df->inverse_rts_map = xmalloc (sizeof(int) * n_basic_blocks);\n-  \n+\n   flow_depth_first_order_compute (df->dfs_order, df->rc_order);\n   flow_reverse_top_sort_order_compute (df->rts_order);\n   for (i = 0; i < n_basic_blocks; i ++)\n@@ -2041,7 +2041,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_gen;\n \t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->rd_kill;\n \t  }\n-\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks, \n+\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n \t\t\t\t   FORWARD, UNION, df_rd_transfer_function,\n \t\t\t\t   df->inverse_rc_map, NULL);\n \tfree (in);\n@@ -2078,7 +2078,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    gen[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_gen;\n \t    kill[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->ru_kill;\n \t  }\n-\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks, \n+\titerative_dataflow_bitmap (in, out, gen, kill, df->all_blocks,\n \t\t\t\t   BACKWARD, UNION, df_ru_transfer_function,\n \t\t\t\t   df->inverse_rts_map, NULL);\n \tfree (in);\n@@ -2104,7 +2104,7 @@ df_analyse_1 (df, blocks, flags, update)\n   if (aflags & DF_LR)\n     {\n       /* Compute the sets of defs and uses of live variables.  */\n-      df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);      \n+      df_lr_local_compute (df, df->flags & DF_LR ? blocks : df->all_blocks);\n       {\n \tint i;\n \tbitmap *in = xmalloc (sizeof (bitmap) * n_basic_blocks);\n@@ -2118,7 +2118,7 @@ df_analyse_1 (df, blocks, flags, update)\n \t    use[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_use;\n \t    def[i] = DF_BB_INFO (df, BASIC_BLOCK (i))->lr_def;\n \t  }\n-\titerative_dataflow_bitmap (in, out, use, def, df->all_blocks, \n+\titerative_dataflow_bitmap (in, out, use, def, df->all_blocks,\n \t\t\t\t   BACKWARD, UNION, df_lr_transfer_function,\n \t\t\t\t   df->inverse_rts_map, NULL);\n \tfree (in);\n@@ -3260,9 +3260,9 @@ df_chain_dump_regno (link, file)\n   for (; link; link = link->next)\n     {\n       fprintf (file, \"%c%d(%d) \",\n-               DF_REF_REG_DEF_P (link->ref) ? 'd' : 'u',\n-               DF_REF_ID (link->ref),\n-               DF_REF_REGNO (link->ref));\n+\t       DF_REF_REG_DEF_P (link->ref) ? 'd' : 'u',\n+\t       DF_REF_ID (link->ref),\n+\t       DF_REF_REGNO (link->ref));\n     }\n   fprintf (file, \"}\");\n }\n@@ -3492,7 +3492,7 @@ df_insn_debug_regno (df, insn, file)\n     bbi = -1;\n \n   fprintf (file, \"insn %d bb %d luid %d defs \",\n-           uid, bbi, DF_INSN_LUID (df, insn));\n+\t   uid, bbi, DF_INSN_LUID (df, insn));\n   df_chain_dump_regno (df->insns[uid].defs, file);\n   fprintf (file, \" uses \");\n   df_chain_dump_regno (df->insns[uid].uses, file);\n@@ -3595,9 +3595,9 @@ debug_df_chain (link)\n \n /* Hybrid search algorithm from \"Implementation Techniques for\n    Efficient Data-Flow Analysis of Large Programs\".  */\n-static void \n-hybrid_search_bitmap (block, in, out, gen, kill, dir, \n-\t\t      conf_op, transfun, visited, pending, \n+static void\n+hybrid_search_bitmap (block, in, out, gen, kill, dir,\n+\t\t      conf_op, transfun, visited, pending,\n \t\t      data)\n      basic_block block;\n      bitmap *in, *out, *gen, *kill;\n@@ -3634,7 +3634,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t\t}\n \t    }\n \t}\n-      else \n+      else\n \t{\n \t  /* Calculate <conf_op> of successor ins */\n \t  bitmap_zero(out[i]);\n@@ -3643,7 +3643,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n-\t\t{\t\n+\t\t{\n \t\tcase UNION:\n \t\t  bitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n@@ -3652,7 +3652,7 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t\t  break;\n \t\t}\n \t    }\n-\t}      \n+\t}\n       /* Common part */\n       (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n       RESET_BIT (pending, i);\n@@ -3685,8 +3685,8 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n \t    continue;\n \t  if (!TEST_BIT (visited, e->dest->index))\n-\t    hybrid_search_bitmap (e->dest, in, out, gen, kill, dir, \n-\t\t\t\t  conf_op, transfun, visited, pending, \n+\t    hybrid_search_bitmap (e->dest, in, out, gen, kill, dir,\n+\t\t\t\t  conf_op, transfun, visited, pending,\n \t\t\t\t  data);\n \t}\n     }\n@@ -3697,17 +3697,17 @@ hybrid_search_bitmap (block, in, out, gen, kill, dir,\n \t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n \t    continue;\n \t  if (!TEST_BIT (visited, e->src->index))\n-\t    hybrid_search_bitmap (e->src, in, out, gen, kill, dir, \n-\t\t\t\t  conf_op, transfun, visited, pending, \n+\t    hybrid_search_bitmap (e->src, in, out, gen, kill, dir,\n+\t\t\t\t  conf_op, transfun, visited, pending,\n \t\t\t\t  data);\n \t}\n     }\n }\n \n \n /* Hybrid search for sbitmaps, rather than bitmaps.  */\n-static void \n-hybrid_search_sbitmap (block, in, out, gen, kill, dir, \n+static void\n+hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t\t       conf_op, transfun, visited, pending,\n \t\t       data)\n      basic_block block;\n@@ -3745,7 +3745,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t\t}\n \t    }\n \t}\n-      else \n+      else\n \t{\n \t  /* Calculate <conf_op> of successor ins */\n \t  sbitmap_zero(out[i]);\n@@ -3754,7 +3754,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \t      switch (conf_op)\n-\t\t{\t\n+\t\t{\n \t\tcase UNION:\n \t\t  sbitmap_a_or_b (out[i], out[i], in[e->dest->index]);\n \t\t  break;\n@@ -3763,7 +3763,7 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t\t  break;\n \t\t}\n \t    }\n-\t}      \n+\t}\n       /* Common part */\n       (*transfun)(i, &changed, in[i], out[i], gen[i], kill[i], data);\n       RESET_BIT (pending, i);\n@@ -3796,8 +3796,8 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t  if (e->dest == EXIT_BLOCK_PTR || e->dest->index == i)\n \t    continue;\n \t  if (!TEST_BIT (visited, e->dest->index))\n-\t    hybrid_search_sbitmap (e->dest, in, out, gen, kill, dir, \n-\t\t\t\t   conf_op, transfun, visited, pending, \n+\t    hybrid_search_sbitmap (e->dest, in, out, gen, kill, dir,\n+\t\t\t\t   conf_op, transfun, visited, pending,\n \t\t\t\t   data);\n \t}\n     }\n@@ -3808,8 +3808,8 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n \t  if (e->src == ENTRY_BLOCK_PTR || e->src->index == i)\n \t    continue;\n \t  if (!TEST_BIT (visited, e->src->index))\n-\t    hybrid_search_sbitmap (e->src, in, out, gen, kill, dir, \n-\t\t\t\t   conf_op, transfun, visited, pending, \n+\t    hybrid_search_sbitmap (e->src, in, out, gen, kill, dir,\n+\t\t\t\t   conf_op, transfun, visited, pending,\n \t\t\t\t   data);\n \t}\n     }\n@@ -3827,20 +3827,20 @@ hybrid_search_sbitmap (block, in, out, gen, kill, dir,\n    transfun = Transfer function.\n    order = Order to iterate in. (Should map block numbers -> order)\n    data = Whatever you want.  It's passed to the transfer function.\n-   \n+\n    This function will perform iterative bitvector dataflow, producing\n    the in and out sets.  Even if you only want to perform it for a\n    small number of blocks, the vectors for in and out must be large\n    enough for *all* blocks, because changing one block might affect\n    others.  However, it'll only put what you say to analyze on the\n    initial worklist.\n-   \n+\n    For forward problems, you probably want to pass in a mapping of\n    block number to rc_order (like df->inverse_rc_map).\n */\n void\n-iterative_dataflow_sbitmap (in, out, gen, kill, blocks, \n-\t\t\t    dir, conf_op, transfun, order, data)     \n+iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n+\t\t\t    dir, conf_op, transfun, order, data)\n      sbitmap *in, *out, *gen, *kill;\n      bitmap blocks;\n      enum df_flow_dir dir;\n@@ -3860,7 +3860,7 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n   worklist = fibheap_new ();\n   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, i,\n   {\n-    fibheap_insert (worklist, order[i], (void *) (size_t) i); \n+    fibheap_insert (worklist, order[i], (void *) (size_t) i);\n     SET_BIT (pending, i);\n     if (dir == FORWARD)\n       sbitmap_copy (out[i], gen[i]);\n@@ -3874,7 +3874,7 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n \t  i = (size_t) fibheap_extract_min (worklist);\n \t  bb = BASIC_BLOCK (i);\n \t  if (!TEST_BIT (visited, bb->index))\n-\t    hybrid_search_sbitmap (bb, in, out, gen, kill, dir, \n+\t    hybrid_search_sbitmap (bb, in, out, gen, kill, dir,\n \t\t\t\t   conf_op, transfun, visited, pending, data);\n \t}\n       if (sbitmap_first_set_bit (pending) != -1)\n@@ -3888,7 +3888,7 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n       else\n \t{\n \t  break;\n-\t}      \n+\t}\n     }\n   sbitmap_free (pending);\n   sbitmap_free (visited);\n@@ -3898,8 +3898,8 @@ iterative_dataflow_sbitmap (in, out, gen, kill, blocks,\n /* Exactly the same as iterative_dataflow_sbitmap, except it works on\n    bitmaps instead */\n void\n-iterative_dataflow_bitmap (in, out, gen, kill, blocks, \n-\t\t\t   dir, conf_op, transfun, order, data)     \n+iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n+\t\t\t   dir, conf_op, transfun, order, data)\n      bitmap *in, *out, *gen, *kill;\n      bitmap blocks;\n      enum df_flow_dir dir;\n@@ -3933,7 +3933,7 @@ iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n \t  i = (size_t) fibheap_extract_min (worklist);\n \t  bb = BASIC_BLOCK (i);\n \t  if (!TEST_BIT (visited, bb->index))\n-\t    hybrid_search_bitmap (bb, in, out, gen, kill, dir, \n+\t    hybrid_search_bitmap (bb, in, out, gen, kill, dir,\n \t\t\t\t  conf_op, transfun, visited, pending, data);\n \t}\n       if (sbitmap_first_set_bit (pending) != -1)\n@@ -3947,9 +3947,9 @@ iterative_dataflow_bitmap (in, out, gen, kill, blocks,\n       else\n \t{\n \t  break;\n-\t}     \n+\t}\n     }\n   sbitmap_free (pending);\n   sbitmap_free (visited);\n-  fibheap_delete (worklist);  \n+  fibheap_delete (worklist);\n }"}, {"sha": "b4f0fade0f7f9e9fbbc96a1d74904e7b0c670743", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 171, "deletions": 169, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -40,11 +40,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free  free\n \n-#define output_formatted_integer(BUFFER, FORMAT, INTEGER) \\\n-  do {                                                    \\\n-    sprintf ((BUFFER)->digit_buffer, FORMAT, INTEGER);    \\\n-    output_add_string (BUFFER, (BUFFER)->digit_buffer);   \\\n-  } while (0)\n+#define output_formatted_integer(BUFFER, FORMAT, INTEGER)\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      sprintf ((BUFFER)->digit_buffer, FORMAT, INTEGER);\t\\\n+      output_add_string (BUFFER, (BUFFER)->digit_buffer);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n #define output_text_length(BUFFER) (BUFFER)->line_length\n #define is_starting_newline(BUFFER) (output_text_length (BUFFER) == 0)\n@@ -59,7 +61,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Prototypes.  */\n static void diagnostic_finish PARAMS ((output_buffer *));\n static void output_do_verbatim PARAMS ((output_buffer *,\n-                                        const char *, va_list *));\n+\t\t\t\t\tconst char *, va_list *));\n static void output_buffer_to_stream PARAMS ((output_buffer *));\n static void output_format PARAMS ((output_buffer *));\n static void output_indent PARAMS ((output_buffer *));\n@@ -77,22 +79,22 @@ static void set_real_maximum_length PARAMS ((output_buffer *));\n static void output_unsigned_decimal PARAMS ((output_buffer *, unsigned int));\n static void output_long_decimal PARAMS ((output_buffer *, long int));\n static void output_long_unsigned_decimal PARAMS ((output_buffer *,\n-                                                  long unsigned int));\n+\t\t\t\t\t\t  long unsigned int));\n static void output_octal PARAMS ((output_buffer *, unsigned int));\n static void output_long_octal PARAMS ((output_buffer *, unsigned long int));\n static void output_hexadecimal PARAMS ((output_buffer *, unsigned int));\n static void output_long_hexadecimal PARAMS ((output_buffer *,\n-                                             unsigned long int));\n+\t\t\t\t\t     unsigned long int));\n static void output_append_r PARAMS ((output_buffer *, const char *, int));\n static void wrap_text PARAMS ((output_buffer *, const char *, const char *));\n static void maybe_wrap_text PARAMS ((output_buffer *, const char *,\n-                                     const char *));\n+\t\t\t\t     const char *));\n static void clear_diagnostic_info PARAMS ((output_buffer *));\n \n static void default_diagnostic_starter PARAMS ((output_buffer *,\n-                                                diagnostic_context *));\n+\t\t\t\t\t\tdiagnostic_context *));\n static void default_diagnostic_finalizer PARAMS ((output_buffer *,\n-                                                  diagnostic_context *));\n+\t\t\t\t\t\t  diagnostic_context *));\n \n static void error_recursion PARAMS ((void)) ATTRIBUTE_NORETURN;\n \n@@ -203,13 +205,13 @@ set_real_maximum_length (buffer)\n   else\n     {\n       int prefix_length =\n-        output_prefix (buffer) ? strlen (output_prefix (buffer)) : 0;\n+\toutput_prefix (buffer) ? strlen (output_prefix (buffer)) : 0;\n       /* If the prefix is ridiculously too long, output at least\n          32 characters.  */\n       if (output_line_cutoff (buffer) - prefix_length < 32)\n-        line_wrap_cutoff (buffer) = output_line_cutoff (buffer) + 32;\n+\tline_wrap_cutoff (buffer) = output_line_cutoff (buffer) + 32;\n       else\n-        line_wrap_cutoff (buffer) = output_line_cutoff (buffer);\n+\tline_wrap_cutoff (buffer) = output_line_cutoff (buffer);\n     }\n }\n \n@@ -245,7 +247,7 @@ output_last_position (buffer)\n      const output_buffer *buffer;\n {\n   const char *p = NULL;\n-  \n+\n   if (obstack_base (&buffer->obstack) != obstack_next_free (&buffer->obstack))\n     p = ((const char *) obstack_next_free (&buffer->obstack)) - 1;\n   return p;\n@@ -302,7 +304,7 @@ init_output_buffer (buffer, prefix, maximum_length)\n   output_prefixing_rule (buffer) = diagnostic_prefixing_rule (global_dc);\n   output_set_prefix (buffer, prefix);\n   output_text_length (buffer) = 0;\n-  clear_diagnostic_info (buffer);  \n+  clear_diagnostic_info (buffer);\n }\n \n /* Reinitialize BUFFER.  */\n@@ -352,28 +354,28 @@ output_emit_prefix (buffer)\n   if (output_prefix (buffer) != NULL)\n     {\n       switch (output_prefixing_rule (buffer))\n-        {\n-        default:\n-        case DIAGNOSTICS_SHOW_PREFIX_NEVER:\n-          break;\n-\n-        case DIAGNOSTICS_SHOW_PREFIX_ONCE:\n-          if (prefix_was_emitted_for (buffer))\n-            {\n-              output_indent (buffer);\n-              break;\n-            }\n-          output_indentation (buffer) += 3;          \n-          /* Fall through.  */\n-\n-        case DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n-          {\n-            int prefix_length = strlen (output_prefix (buffer));\n-            output_append_r (buffer, output_prefix (buffer), prefix_length);\n-            prefix_was_emitted_for (buffer) = 1;\n-          }\n-          break;\n-        }\n+\t{\n+\tdefault:\n+\tcase DIAGNOSTICS_SHOW_PREFIX_NEVER:\n+\t  break;\n+\n+\tcase DIAGNOSTICS_SHOW_PREFIX_ONCE:\n+\t  if (prefix_was_emitted_for (buffer))\n+\t    {\n+\t      output_indent (buffer);\n+\t      break;\n+\t    }\n+\t  output_indentation (buffer) += 3;\n+\t  /* Fall through.  */\n+\n+\tcase DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE:\n+\t  {\n+\t    int prefix_length = strlen (output_prefix (buffer));\n+\t    output_append_r (buffer, output_prefix (buffer), prefix_length);\n+\t    prefix_was_emitted_for (buffer) = 1;\n+\t  }\n+\t  break;\n+\t}\n     }\n }\n \n@@ -511,8 +513,8 @@ output_append (buffer, start, end)\n     {\n       output_emit_prefix (buffer);\n       if (output_is_line_wrapping (buffer))\n-        while (start != end && *start == ' ')\n-          ++start;\n+\twhile (start != end && *start == ' ')\n+\t  ++start;\n     }\n   output_append_r (buffer, start, end - start);\n }\n@@ -537,30 +539,30 @@ wrap_text (buffer, start, end)\n      const char *end;\n {\n   int is_wrapping = output_is_line_wrapping (buffer);\n-  \n+\n   while (start != end)\n     {\n-      /* Dump anything bordered by whitespaces.  */ \n+      /* Dump anything bordered by whitespaces.  */\n       {\n-        const char *p = start;\n-        while (p != end && *p != ' ' && *p != '\\n')\n-          ++p;\n-        if (is_wrapping && p - start >= output_space_left (buffer))\n-          output_add_newline (buffer);\n-        output_append (buffer, start, p);\n-        start = p;\n+\tconst char *p = start;\n+\twhile (p != end && *p != ' ' && *p != '\\n')\n+\t  ++p;\n+\tif (is_wrapping && p - start >= output_space_left (buffer))\n+\t  output_add_newline (buffer);\n+\toutput_append (buffer, start, p);\n+\tstart = p;\n       }\n \n       if (start != end && *start == ' ')\n-        {\n-          output_add_space (buffer);\n-          ++start;\n-        }\n+\t{\n+\t  output_add_space (buffer);\n+\t  ++start;\n+\t}\n       if (start != end && *start == '\\n')\n-        {\n-          output_add_newline (buffer);\n-          ++start;\n-        }\n+\t{\n+\t  output_add_newline (buffer);\n+\t  ++start;\n+\t}\n     }\n }\n \n@@ -626,110 +628,110 @@ output_format (buffer)\n \n       /* Ignore text.  */\n       {\n-        const char *p = output_buffer_text_cursor (buffer);\n-        while (*p && *p != '%')\n-          ++p;\n-        wrap_text (buffer, output_buffer_text_cursor (buffer), p);\n-        output_buffer_text_cursor (buffer) = p;\n+\tconst char *p = output_buffer_text_cursor (buffer);\n+\twhile (*p && *p != '%')\n+\t  ++p;\n+\twrap_text (buffer, output_buffer_text_cursor (buffer), p);\n+\toutput_buffer_text_cursor (buffer) = p;\n       }\n \n       if (!*output_buffer_text_cursor (buffer))\n-        break;\n+\tbreak;\n \n       /* We got a '%'.  Let's see what happens. Record whether we're\n          parsing a long integer format specifier.  */\n       if (*++output_buffer_text_cursor (buffer) == 'l')\n-        {\n-          long_integer = 1;\n-          ++output_buffer_text_cursor (buffer);\n-        }\n+\t{\n+\t  long_integer = 1;\n+\t  ++output_buffer_text_cursor (buffer);\n+\t}\n \n       /* Handle %c, %d, %i, %ld, %li, %lo, %lu, %lx, %o, %s, %u,\n          %x, %.*s; %%.  And nothing else.  Front-ends should install\n          printers to grok language specific format specifiers.  */\n       switch (*output_buffer_text_cursor (buffer))\n-        {\n-        case 'c':\n-          output_add_character\n-            (buffer, va_arg (output_buffer_format_args (buffer), int));\n-          break;\n-          \n-        case 'd':\n-        case 'i':\n-          if (long_integer)\n-            output_long_decimal\n-              (buffer, va_arg (output_buffer_format_args (buffer), long int));\n-          else\n-            output_decimal\n-              (buffer, va_arg (output_buffer_format_args (buffer), int));\n-          break;\n-\n-        case 'o':\n-          if (long_integer)\n-            output_long_octal (buffer,\n-                               va_arg (output_buffer_format_args (buffer),\n-                                       unsigned long int));\n-          else\n-            output_octal (buffer,\n-                          va_arg (output_buffer_format_args (buffer),\n-                                  unsigned int));\n-          break;\n-\n-        case 's':\n-          output_add_string (buffer,\n-                             va_arg (output_buffer_format_args (buffer),\n-                                     const char *));\n-          break;\n-\n-        case 'u':\n-          if (long_integer)\n-            output_long_unsigned_decimal\n-              (buffer, va_arg (output_buffer_format_args (buffer),\n-                               long unsigned int));\n-          else\n-            output_unsigned_decimal\n-              (buffer, va_arg (output_buffer_format_args (buffer),\n-                               unsigned int));\n-          break;\n-          \n-        case 'x':\n-          if (long_integer)\n-            output_long_hexadecimal\n-              (buffer, va_arg (output_buffer_format_args (buffer),\n-                               unsigned long int));\n-          else\n-            output_hexadecimal\n-              (buffer, va_arg (output_buffer_format_args (buffer),\n-                               unsigned int));\n-          break;\n-\n-        case '%':\n-          output_add_character (buffer, '%');\n-          break;\n-\n-        case '.':\n-          {\n-            int n;\n-            const char *s;\n-            /* We handle no precision specifier but `%.*s'.  */\n-            if (*++output_buffer_text_cursor (buffer) != '*')\n-              abort ();\n-            else if (*++output_buffer_text_cursor (buffer) != 's')\n-              abort ();\n-            n = va_arg (output_buffer_format_args (buffer), int);\n-            s = va_arg (output_buffer_format_args (buffer), const char *);\n-            output_append (buffer, s, s + n);\n-          }\n-          break;\n-\n-        default:\n-          if (!buffer->format_decoder || !(*buffer->format_decoder) (buffer))\n-            {\n-              /* Hmmm.  The front-end failed to install a format translator\n+\t{\n+\tcase 'c':\n+\t  output_add_character\n+\t    (buffer, va_arg (output_buffer_format_args (buffer), int));\n+\t  break;\n+\n+\tcase 'd':\n+\tcase 'i':\n+\t  if (long_integer)\n+\t    output_long_decimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer), long int));\n+\t  else\n+\t    output_decimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer), int));\n+\t  break;\n+\n+\tcase 'o':\n+\t  if (long_integer)\n+\t    output_long_octal (buffer,\n+\t\t\t       va_arg (output_buffer_format_args (buffer),\n+\t\t\t\t       unsigned long int));\n+\t  else\n+\t    output_octal (buffer,\n+\t\t\t  va_arg (output_buffer_format_args (buffer),\n+\t\t\t\t  unsigned int));\n+\t  break;\n+\n+\tcase 's':\n+\t  output_add_string (buffer,\n+\t\t\t     va_arg (output_buffer_format_args (buffer),\n+\t\t\t\t     const char *));\n+\t  break;\n+\n+\tcase 'u':\n+\t  if (long_integer)\n+\t    output_long_unsigned_decimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer),\n+\t\t\t       long unsigned int));\n+\t  else\n+\t    output_unsigned_decimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer),\n+\t\t\t       unsigned int));\n+\t  break;\n+\n+\tcase 'x':\n+\t  if (long_integer)\n+\t    output_long_hexadecimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer),\n+\t\t\t       unsigned long int));\n+\t  else\n+\t    output_hexadecimal\n+\t      (buffer, va_arg (output_buffer_format_args (buffer),\n+\t\t\t       unsigned int));\n+\t  break;\n+\n+\tcase '%':\n+\t  output_add_character (buffer, '%');\n+\t  break;\n+\n+\tcase '.':\n+\t  {\n+\t    int n;\n+\t    const char *s;\n+\t    /* We handle no precision specifier but `%.*s'.  */\n+\t    if (*++output_buffer_text_cursor (buffer) != '*')\n+\t      abort ();\n+\t    else if (*++output_buffer_text_cursor (buffer) != 's')\n+\t      abort ();\n+\t    n = va_arg (output_buffer_format_args (buffer), int);\n+\t    s = va_arg (output_buffer_format_args (buffer), const char *);\n+\t    output_append (buffer, s, s + n);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  if (!buffer->format_decoder || !(*buffer->format_decoder) (buffer))\n+\t    {\n+\t      /* Hmmm.  The front-end failed to install a format translator\n                  but called us with an unrecognized format.  Sorry.  */\n-              abort ();\n-            }\n-        }\n+\t      abort ();\n+\t    }\n+\t}\n     }\n }\n \n@@ -804,7 +806,7 @@ output_do_printf (buffer, msg)\n      const char *msg;\n {\n   char *message = vbuild_message_string (msg,\n-                                         output_buffer_format_args (buffer));\n+\t\t\t\t\t output_buffer_format_args (buffer));\n \n   wrap_text (buffer, message, message + strlen (message));\n   free (message);\n@@ -837,7 +839,7 @@ format_with_decl (buffer, decl)\n      tree decl;\n {\n   const char *p;\n-  \n+\n   /* Do magic to get around lack of varargs support for insertion\n      of arguments into existing list.  We know that the decl is first;\n      we ass_u_me that it will be printed with \"%s\".  */\n@@ -856,7 +858,7 @@ format_with_decl (buffer, decl)\n \n   /* Print the left-hand substring.  */\n   maybe_wrap_text (buffer, output_buffer_text_cursor (buffer), p);\n-  \n+\n   if (*p == '%')\t\t/* Print the name.  */\n     {\n       const char *const n = (DECL_NAME (decl)\n@@ -907,7 +909,7 @@ diagnostic_for_decl (decl, msgid, args_ptr, warn)\n       format_with_decl (diagnostic_buffer, decl);\n       diagnostic_finish ((output_buffer *) global_dc);\n       output_destroy_prefix (diagnostic_buffer);\n-  \n+\n       output_buffer_state (diagnostic_buffer) = os;\n     }\n   diagnostic_lock--;\n@@ -1068,7 +1070,7 @@ announce_function (decl)\n       if (rtl_dump_and_exit)\n \tverbatim (\"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n-        verbatim (\" %s\", (*lang_hooks.decl_printable_name) (decl, 2));\n+\tverbatim (\" %s\", (*lang_hooks.decl_printable_name) (decl, 2));\n       fflush (stderr);\n       output_needs_newline (diagnostic_buffer) = 1;\n       record_last_error_function ();\n@@ -1090,19 +1092,19 @@ lhd_print_error_function (context, file)\n \n       os = diagnostic_state (context);\n       output_set_prefix ((output_buffer *) context, prefix);\n-      \n+\n       if (current_function_decl == NULL)\n-          output_add_string ((output_buffer *) context, _(\"At top level:\"));\n+\toutput_add_string ((output_buffer *) context, _(\"At top level:\"));\n       else\n \t{\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n-            output_printf\n-              ((output_buffer *) context, \"In member function `%s':\",\n-               (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n+\t    output_printf\n+\t      ((output_buffer *) context, \"In member function `%s':\",\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t  else\n-            output_printf\n-              ((output_buffer *) context, \"In function `%s':\",\n-               (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n+\t    output_printf\n+\t      ((output_buffer *) context, \"In function `%s':\",\n+\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n \t}\n       output_add_newline ((output_buffer *) context);\n \n@@ -1225,7 +1227,7 @@ internal_error VPARAMS ((const char *msgid, ...))\n \n   if (internal_error_function != 0)\n     (*internal_error_function) (_(msgid), &ap);\n-  \n+\n   set_diagnostic_context\n     (&dc, msgid, &ap, input_filename, lineno, /* warn = */0);\n   report_diagnostic (&dc);\n@@ -1487,10 +1489,10 @@ report_problematic_module (buffer)\n       for (p = input_file_stack->next; p; p = p->next)\n \tif (p == input_file_stack->next)\n \t  output_verbatim\n-            (buffer, \"In file included from %s:%d\", p->name, p->line);\n+\t    (buffer, \"In file included from %s:%d\", p->name, p->line);\n \telse\n \t  output_verbatim\n-            (buffer, \",\\n                 from %s:%d\", p->name, p->line);\n+\t    (buffer, \",\\n                 from %s:%d\", p->name, p->line);\n       output_verbatim (buffer, \":\\n\");\n       record_last_error_module ();\n     }\n@@ -1503,9 +1505,9 @@ default_diagnostic_starter (buffer, dc)\n {\n   report_error_function (diagnostic_file_location (dc));\n   output_set_prefix (buffer,\n-                     context_as_prefix (diagnostic_file_location (dc),\n-                                        diagnostic_line_location (dc),\n-                                        diagnostic_is_warning (dc)));\n+\t\t     context_as_prefix (diagnostic_file_location (dc),\n+\t\t\t\t\tdiagnostic_line_location (dc),\n+\t\t\t\t\tdiagnostic_is_warning (dc)));\n }\n \n static void\n@@ -1516,7 +1518,7 @@ default_diagnostic_finalizer (buffer, dc)\n   output_destroy_prefix (buffer);\n }\n \n-void \n+void\n warn_deprecated_use (node)\n      tree node;\n {\n@@ -1537,7 +1539,7 @@ warn_deprecated_use (node)\n       else if (TREE_CODE (TYPE_NAME (node)) == TYPE_DECL\n \t       && DECL_NAME (TYPE_NAME (node)))\n \twhat = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node)));\n-\t\n+\n       if (what)\n \t{\n \t  if (decl)"}, {"sha": "f3946dcb9a06b2023e28a3aea1c0ffe5d160e5f3", "filename": "gcc/doloop.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdoloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdoloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoloop.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -263,7 +263,7 @@ doloop_valid_p (loop, jump_insn)\n       || ! onlyjump_p (jump_insn))\n     {\n       if (loop_dump_stream)\n-  \tfprintf (loop_dump_stream,\n+\tfprintf (loop_dump_stream,\n \t\t \"Doloop: Invalid jump at loop end.\\n\");\n       return 0;\n     }\n@@ -801,7 +801,7 @@ doloop_optimize (loop)\n \t\t\t     &increment, &mode))\n     {\n       if (loop_dump_stream)\n-      \tfprintf (loop_dump_stream,\n+\tfprintf (loop_dump_stream,\n \t\t \"Doloop: Cannot precondition loop.\\n\");\n       return 0;\n     }"}, {"sha": "3b8abdb28e8734e8d0bb301730fdc9552c4fa7be", "filename": "gcc/dominance.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -1,9 +1,9 @@\n /* Calculate (post)dominators in slightly super-linear time.\n    Copyright (C) 2000 Free Software Foundation, Inc.\n    Contributed by Michael Matz (matz@ifh.de).\n-  \n+\n    This file is part of GCC.\n- \n+\n    GCC is free software; you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2, or (at your option)\n@@ -119,17 +119,19 @@ static void idoms_to_doms\t\tPARAMS ((struct dom_info *,\n /* Helper macro for allocating and initializing an array,\n    for aesthetic reasons.  */\n #define init_ar(var, type, num, content)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\\\n-    unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n-    if (! (content))\t\t\t\t\t\t\\\n-      (var) = (type *) xcalloc ((num), sizeof (type));\t\t\\\n-    else\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        (var) = (type *) xmalloc ((num) * sizeof (type));\t\\\n-\tfor (i = 0; i < num; i++)\t\t\t\t\\\n-\t  (var)[i] = (content);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } while (0)\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      unsigned int i = 1;    /* Catch content == i.  */\t\t\\\n+      if (! (content))\t\t\t\t\t\t\\\n+\t(var) = (type *) xcalloc ((num), sizeof (type));\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  (var) = (type *) xmalloc ((num) * sizeof (type));\t\\\n+\t  for (i = 0; i < num; i++)\t\t\t\t\\\n+\t    (var)[i] = (content);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n \n /* Allocate all needed memory in a pessimistic fashion (so we round up).\n    This initialises the contents of DI, which already must be allocated.  */"}, {"sha": "d024efc14ce110f619606455a05e093ac1a797ab", "filename": "gcc/doschk.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdoschk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdoschk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoschk.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -71,13 +71,13 @@ char *path;\n   char *last_slash = strrchr (path, '/');\n   char *cp, *dp;\n   int dots_seen, chars_seen;\n-  \n+\n   if (last_slash+1 == null)\n     {\n       * --null = '\\0';\n       last_slash = strrchr (path, '/');\n     }\n-  \n+\n   if (!last_slash)\n     {\n       last_slash = first-1;\n@@ -239,7 +239,7 @@ display_problems ()\n {\n   ENT **elist, *ent;\n   int ecount, i, first, first_err;\n-  \n+\n   for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++);\n   elist = (ENT **)malloc (sizeof (ENT *) * ecount);\n   for (ecount=0, ent=eroot; ent; ent=ent->next, ecount++)"}, {"sha": "53a02c7fcd5d42ca75f6f1f2ed02a3daa6a10f13", "filename": "gcc/dwarf2asm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarf2asm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarf2asm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2asm.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -60,7 +60,7 @@ dw2_assemble_integer (size, x)\n   else\n     assemble_integer (x, size, BITS_PER_UNIT, 1);\n }\n-     \n+\n \n /* Output an immediate constant in a given size.  */\n \n@@ -316,7 +316,7 @@ size_of_sleb128 (value)\n }\n \n /* Given an encoding, return the number of bytes the format occupies.\n-   This is only defined for fixed-size encodings, and so does not \n+   This is only defined for fixed-size encodings, and so does not\n    include leb128.  */\n \n int\n@@ -845,7 +845,7 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n     {\n     restart:\n       /* Allow the target first crack at emitting this.  Some of the\n-\t special relocations require special directives instead of \n+\t special relocations require special directives instead of\n \t just \".4byte\" or whatever.  */\n #ifdef ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX\n       ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX (asm_out_file, encoding, size,\n@@ -883,7 +883,7 @@ dw2_asm_output_encoded_addr_rtx VPARAMS ((int encoding,\n \t  break;\n \n \tdefault:\n-\t  /* Other encodings should have been handled by \n+\t  /* Other encodings should have been handled by\n \t     ASM_MAYBE_OUTPUT_ENCODED_ADDR_RTX.  */\n \t  abort ();\n \t}"}, {"sha": "47edc4339e7aa13f1ec1d4f9ace37820b9d96f3b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -344,15 +344,17 @@ static void def_cfa_1\t\t \tPARAMS ((const char *,\n \n #ifdef SET_ASM_OP\n #ifndef ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL\n-#define ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL(FILE, SY, HI, LO)    \t\\\n- do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"%s\", SET_ASM_OP);\t\t\t\t\t\\\n-  assemble_name (FILE, SY);\t\t\t\t\t\t\\\n-  fputc (',', FILE);\t\t\t\t\t\t\t\\\n-  assemble_name (FILE, HI);\t\t\t\t\t\t\\\n-  fputc ('-', FILE);\t\t\t\t\t\t\t\\\n-  assemble_name (FILE, LO);\t\t\t\t\t\t\\\n- } while (0)\n+#define ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL(FILE, SY, HI, LO)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\", SET_ASM_OP);\t\t\t\t\t\\\n+      assemble_name (FILE, SY);\t\t\t\t\t\t\\\n+      fputc (',', FILE);\t\t\t\t\t\t\\\n+      assemble_name (FILE, HI);\t\t\t\t\t\t\\\n+      fputc ('-', FILE);\t\t\t\t\t\t\\\n+      assemble_name (FILE, LO);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n #endif\n #endif\n "}, {"sha": "b63e16c4cb4959f2ede998dd75138285acebb42f", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a538a6668acdfe94dd05fa36ef0341cb2382a88/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=3a538a6668acdfe94dd05fa36ef0341cb2382a88", "patch": "@@ -523,7 +523,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n  are still being discussed.  Also, we in the PLSIG are still discussing\n  whether or not we need to do anything special for C++ templates.  (At this\n  time it is not yet clear whether we even need to do anything special for\n- these.) \n+ these.)\n \n  With regard to FORTRAN, the UI/PLSIG has defined what is believed to be a\n  complete and sufficient set of codes and rules for adequately representing\n@@ -560,7 +560,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \t Other possible `compacting' transformations designed to save disk\n \t space and to reduce linker & debugger I/O activity.\n \n-*/  \n+*/\n \n #include \"config.h\"\n \n@@ -1287,7 +1287,7 @@ static void retry_incomplete_types\tPARAMS ((void));\n   ASM_OUTPUT_ASCII ((FILE), P, strlen (P)+1)\n #else\n #define ASM_OUTPUT_DWARF_STRING_NEWLINE(FILE,P) \\\n-  ASM_OUTPUT_DWARF_STRING (FILE,P), ASM_OUTPUT_DWARF_STRING (FILE,\"\\n\") \n+  ASM_OUTPUT_DWARF_STRING (FILE,P), ASM_OUTPUT_DWARF_STRING (FILE,\"\\n\")\n #endif\n \n \f\n@@ -1323,7 +1323,7 @@ is_pseudo_reg (rtl)\n      rtx rtl;\n {\n   return (((GET_CODE (rtl) == REG) && (REGNO (rtl) >= FIRST_PSEUDO_REGISTER))\n-          || ((GET_CODE (rtl) == SUBREG)\n+\t  || ((GET_CODE (rtl) == SUBREG)\n \t      && (REGNO (SUBREG_REG (rtl)) >= FIRST_PSEUDO_REGISTER)));\n }\n \n@@ -1341,7 +1341,7 @@ type_main_variant (type)\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       while (type != TYPE_MAIN_VARIANT (type))\n-        type = TYPE_MAIN_VARIANT (type);\n+\ttype = TYPE_MAIN_VARIANT (type);\n     }\n \n   return type;\n@@ -1607,7 +1607,7 @@ static tree\n decl_ultimate_origin (decl)\n      tree decl;\n {\n-#ifdef ENABLE_CHECKING \n+#ifdef ENABLE_CHECKING\n   if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n     /* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the\n        most distant ancestor, this should never happen.  */\n@@ -1705,7 +1705,7 @@ output_signed_leb128 (value)\n       if (negative)\n \tvalue |= 0xfe000000;  /* manually sign extend */\n       if (((value == 0) && ((byte & 0x40) == 0))\n-          || ((value == -1) && ((byte & 0x40) == 1)))\n+\t  || ((value == -1) && ((byte & 0x40) == 1)))\n \tmore = 0;\n       else\n \t{\n@@ -2839,8 +2839,8 @@ location_or_const_value_attribute (decl)\n     if (rtl == NULL_RTX || is_pseudo_reg (rtl))\n       {\n \t/* This decl represents a formal parameter which was optimized out.  */\n-        tree declared_type = type_main_variant (TREE_TYPE (decl));\n-        tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n+\ttree declared_type = type_main_variant (TREE_TYPE (decl));\n+\ttree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n \n \t/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle\n \t   *all* cases where (rtl == NULL_RTX) just below.  */\n@@ -3464,10 +3464,10 @@ pure_or_virtual_attribute (func_decl)\n     {\n #if 0 /* DECL_ABSTRACT_VIRTUAL_P is C++-specific.  */\n       if (DECL_ABSTRACT_VIRTUAL_P (func_decl))\n-        ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);\n+\tASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_pure_virtual);\n       else\n #endif\n-        ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_virtual);\n+\tASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_virtual);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n     }\n }\n@@ -3506,7 +3506,7 @@ name_and_src_coords_attributes (decl)\n \tfile_index = lookup_filename (DECL_SOURCE_FILE (decl));\n \tASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_SECTION);\n \n-        src_coords_attribute (file_index, DECL_SOURCE_LINE (decl));\n+\tsrc_coords_attribute (file_index, DECL_SOURCE_LINE (decl));\n       }\n #endif /* defined(DWARF_DECL_COORDINATES) */\n     }\n@@ -3587,7 +3587,7 @@ type_tag (type)\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n \tt = TYPE_NAME (type);\n \n-      /* The g++ front end makes the TYPE_NAME of *each* tagged type point to \n+      /* The g++ front end makes the TYPE_NAME of *each* tagged type point to\n          a TYPE_DECL node, regardless of whether or not a `typedef' was\n          involved.  */\n       else if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n@@ -4168,7 +4168,7 @@ output_compile_unit_die (arg)\n       sf_names_attribute (SFNAMES_BEGIN_LABEL);\n       src_info_attribute (SRCINFO_BEGIN_LABEL);\n       if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n-        mac_info_attribute (MACINFO_BEGIN_LABEL);\n+\tmac_info_attribute (MACINFO_BEGIN_LABEL);\n     }\n }\n \n@@ -4211,7 +4211,7 @@ output_inheritance_die (arg)\n       ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_protected);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n     }\n-}  \n+}\n \n static void\n output_structure_type_die (arg)\n@@ -4795,7 +4795,7 @@ output_type (type, containing_scope)\n \tend_sibling_chain ();\n \tbreak;\n \n-      case ARRAY_TYPE:\t\n+      case ARRAY_TYPE:\n \tif (TYPE_STRING_FLAG (type) && TREE_CODE(TREE_TYPE(type)) == CHAR_TYPE)\n \t  {\n \t    output_type (TREE_TYPE (type), containing_scope);\n@@ -5150,8 +5150,8 @@ output_decls_for_scope (stmt, depth)\n     tree subblocks;\n \n     for (subblocks = BLOCK_SUBBLOCKS (stmt);\n-         subblocks;\n-         subblocks = BLOCK_CHAIN (subblocks))\n+\t subblocks;\n+\t subblocks = BLOCK_CHAIN (subblocks))\n       output_block (subblocks, depth + 1);\n   }\n }\n@@ -5197,10 +5197,10 @@ output_decl (decl, containing_scope)\n   if ((TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE\n        || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE)\n       && ((DECL_NAME (decl) == 0 && TYPE_NAME (TREE_TYPE (decl)) == 0)\n-\t  || (TYPE_FIELDS (TREE_TYPE (decl)) \n+\t  || (TYPE_FIELDS (TREE_TYPE (decl))\n \t      && (TREE_CODE (TYPE_FIELDS (TREE_TYPE (decl))) == ERROR_MARK))))\n     return;\n-  \n+\n   /* If this ..._DECL node is marked to be ignored, then ignore it.  */\n \n   if (DECL_IGNORED_P (decl))\n@@ -5325,7 +5325,7 @@ output_decl (decl, containing_scope)\n \n \t  for (parm = arg_decls; parm; parm = TREE_CHAIN (parm))\n \t    if (TREE_CODE (parm) == PARM_DECL)\n-              {\n+\t      {\n \t\tif (DECL_NAME(parm) &&\n \t\t    !strcmp(IDENTIFIER_POINTER(DECL_NAME(parm)),\n \t\t\t    \"__builtin_va_alist\") )\n@@ -5362,13 +5362,13 @@ output_decl (decl, containing_scope)\n \t      /* this is the prototyped case, check for ...  */\n \t      if (TREE_VALUE (tree_last (fn_arg_types)) != void_type_node)\n \t        output_die (output_unspecified_parameters_die, decl);\n-              }\n-            else\n-              {\n-\t      /* this is unprototyped, check for undefined (just declaration) */\n-              if (!DECL_INITIAL (decl))\n-                output_die (output_unspecified_parameters_die, decl);\n-              }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* this is unprototyped, check for undefined (just declaration) */\n+\t\tif (!DECL_INITIAL (decl))\n+\t\t  output_die (output_unspecified_parameters_die, decl);\n+\t      }\n \t  }\n \n \t  /* Output Dwarf info for all of the stuff within the body of the\n@@ -5427,7 +5427,7 @@ output_decl (decl, containing_scope)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tif (! TYPE_DECL_IS_STUB (decl)\n \t    || (! TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)) && ! in_class))\n-          return;\n+\t  return;\n \n       /* In the special case of a TYPE_DECL node representing\n \t the declaration of some type tag, if the given TYPE_DECL is\n@@ -5468,7 +5468,7 @@ output_decl (decl, containing_scope)\n \t any variable declarations or definitions.  */\n \n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-        break;\n+\tbreak;\n \n       /* Output any DIEs that are needed to specify the type of this data\n \t object.  */\n@@ -5502,7 +5502,7 @@ output_decl (decl, containing_scope)\n \t function.  */\n \n       {\n-        void (*func) PARAMS ((void *));\n+\tvoid (*func) PARAMS ((void *));\n \tregister tree origin = decl_ultimate_origin (decl);\n \n \tif (origin != NULL && TREE_CODE (origin) == PARM_DECL)\n@@ -5523,7 +5523,7 @@ output_decl (decl, containing_scope)\n       if (DECL_NAME (decl) != 0)\n \t{\n \t  output_type (member_declared_type (decl), containing_scope);\n-          output_die (output_member_die, decl);\n+\t  output_die (output_member_die, decl);\n \t}\n       break;\n \n@@ -5623,7 +5623,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t these same functions should NOT be ignored however.  */\n \n       if (DECL_EXTERNAL (decl) && DECL_FUNCTION_CODE (decl))\n-        return;\n+\treturn;\n \n       /* What we would really like to do here is to filter out all mere\n \t file-scope declarations of file-scope functions which are never\n@@ -5723,7 +5723,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t      ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_ARANGES_SECTION);\n \t      ASM_OUTPUT_DWARF_ADDR (asm_out_file,\n \t\t\t      IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n-\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file, \n+\t      ASM_OUTPUT_DWARF_DATA4 (asm_out_file,\n \t\t\t(unsigned) int_size_in_bytes (TREE_TYPE (decl)));\n \t      ASM_OUTPUT_POP_SECTION (asm_out_file);\n \t    }\n@@ -5733,7 +5733,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n \t any variable declarations or definitions.  */\n \n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n-        return;\n+\treturn;\n \n       break;\n \n@@ -5771,7 +5771,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       if (debug_info_level <= DINFO_LEVEL_TERSE)\n \tif (! TYPE_DECL_IS_STUB (decl)\n \t    || ! TYPE_USED_FOR_FUNCTION (TREE_TYPE (decl)))\n-          return;\n+\t  return;\n \n       break;\n \n@@ -5801,7 +5801,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n      if this is not a nested function or class.  If this is a nested type,\n      then the remaining pending_types will be emitted when the containing type\n      is handled.  */\n-  \n+\n   if (! DECL_CONTEXT (decl))\n     {\n       if (pending_types != 0)\n@@ -5930,9 +5930,9 @@ generate_new_sfname_entry ()\n   sprintf (label, SFNAMES_ENTRY_LABEL_FMT, filename_table[0].number);\n   ASM_OUTPUT_LABEL (asm_out_file, label);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file,\n-    \t\t\t   filename_table[0].name\n-\t\t\t     ? filename_table[0].name\n-\t\t\t     : \"\");\n+\t\t\t\t   filename_table[0].name\n+\t\t\t\t   ? filename_table[0].name\n+\t\t\t\t   : \"\");\n   ASM_OUTPUT_POP_SECTION (asm_out_file);\n }\n \n@@ -5984,7 +5984,7 @@ lookup_filename (file_name)\n \t   same filename will find it as quickly as possible.  */\n \n \tshuffle_filename_entry (search_p);\n-        return filename_table[0].number;\n+\treturn filename_table[0].number;\n       }\n \n   /* We come here whenever we have a new filename which is not registered\n@@ -6062,18 +6062,18 @@ dwarfout_source_line (line, filename)\n \n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, LINE_SECTION);\n       if (this_file_entry_num != prev_file_entry_num)\n-        {\n-          char line_entry_label[MAX_ARTIFICIAL_LABEL_BYTES];\n+\t{\n+\t  char line_entry_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n-          sprintf (line_entry_label, LINE_ENTRY_LABEL_FMT, last_line_entry_num);\n-          ASM_OUTPUT_LABEL (asm_out_file, line_entry_label);\n-        }\n+\t  sprintf (line_entry_label, LINE_ENTRY_LABEL_FMT, last_line_entry_num);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, line_entry_label);\n+\t}\n \n       {\n-        const char *tail = strrchr (filename, '/');\n+\tconst char *tail = strrchr (filename, '/');\n \n-        if (tail != NULL)\n-          filename = tail;\n+\tif (tail != NULL)\n+\t  filename = tail;\n       }\n \n       dw2_asm_output_data (4, line, \"%s:%u\", filename, line);\n@@ -6082,7 +6082,7 @@ dwarfout_source_line (line, filename)\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n \n       if (this_file_entry_num != prev_file_entry_num)\n-        generate_srcinfo_entry (last_line_entry_num, this_file_entry_num);\n+\tgenerate_srcinfo_entry (last_line_entry_num, this_file_entry_num);\n       prev_file_entry_num = this_file_entry_num;\n     }\n }\n@@ -6275,7 +6275,7 @@ dwarfout_init (main_input_filename)\n \t  /* Output a starting label and an initial (compilation directory)\n \t     entry for the .debug_sfnames section.  The starting label will be\n \t     referenced by the initial entry in the .debug_srcinfo section.  */\n-    \n+\n \t  fputc ('\\n', asm_out_file);\n \t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_SFNAMES_SECTION);\n \t  ASM_OUTPUT_LABEL (asm_out_file, SFNAMES_BEGIN_LABEL);\n@@ -6292,29 +6292,29 @@ dwarfout_init (main_input_filename)\n \t  }\n \t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n \t}\n-    \n+\n       if (debug_info_level >= DINFO_LEVEL_VERBOSE\n \t  && use_gnu_debug_info_extensions)\n \t{\n-          /* Output a starting label for the .debug_macinfo section.  This\n+\t  /* Output a starting label for the .debug_macinfo section.  This\n \t     label will be referenced by the AT_mac_info attribute in the\n \t     TAG_compile_unit DIE.  */\n-        \n-          fputc ('\\n', asm_out_file);\n-          ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n-          ASM_OUTPUT_LABEL (asm_out_file, MACINFO_BEGIN_LABEL);\n-          ASM_OUTPUT_POP_SECTION (asm_out_file);\n+\n+\t  fputc ('\\n', asm_out_file);\n+\t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_MACINFO_SECTION);\n+\t  ASM_OUTPUT_LABEL (asm_out_file, MACINFO_BEGIN_LABEL);\n+\t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n \t}\n \n       /* Generate the initial entry for the .line section.  */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, LINE_SECTION);\n       ASM_OUTPUT_LABEL (asm_out_file, LINE_BEGIN_LABEL);\n       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, LINE_END_LABEL, LINE_BEGIN_LABEL);\n       ASM_OUTPUT_DWARF_ADDR (asm_out_file, TEXT_BEGIN_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n-    \n+\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  /* Generate the initial entry for the .debug_srcinfo section.  */\n@@ -6333,16 +6333,16 @@ dwarfout_init (main_input_filename)\n #endif\n \t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n \t}\n-    \n+\n       /* Generate the initial entry for the .debug_pubnames section.  */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_PUBNAMES_SECTION);\n       ASM_OUTPUT_DWARF_ADDR (asm_out_file, DEBUG_BEGIN_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n-    \n+\n       /* Generate the initial entry for the .debug_aranges section.  */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_ARANGES_SECTION);\n       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file,\n@@ -6468,7 +6468,7 @@ dwarfout_finish (main_input_filename)\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n       /* Output a terminating entry for the .line section.  */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, LINE_SECTION);\n       ASM_OUTPUT_LABEL (asm_out_file, LINE_LAST_ENTRY_LABEL);\n@@ -6477,7 +6477,7 @@ dwarfout_finish (main_input_filename)\n       ASM_OUTPUT_DWARF_DELTA4 (asm_out_file, TEXT_END_LABEL, TEXT_BEGIN_LABEL);\n       ASM_OUTPUT_LABEL (asm_out_file, LINE_END_LABEL);\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n-    \n+\n       if (use_gnu_debug_info_extensions)\n \t{\n \t  /* Output a terminating entry for the .debug_srcinfo section.  */\n@@ -6493,7 +6493,7 @@ dwarfout_finish (main_input_filename)\n       if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n \t{\n \t  /* Output terminating entries for the .debug_macinfo section.  */\n-\t\n+\n \t  dwarfout_end_source_file (0);\n \n \t  fputc ('\\n', asm_out_file);\n@@ -6502,15 +6502,15 @@ dwarfout_finish (main_input_filename)\n \t  ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n \t  ASM_OUTPUT_POP_SECTION (asm_out_file);\n \t}\n-    \n+\n       /* Generate the terminating entry for the .debug_pubnames section.  */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_PUBNAMES_SECTION);\n       ASM_OUTPUT_DWARF_DATA4 (asm_out_file, 0);\n       ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, \"\");\n       ASM_OUTPUT_POP_SECTION (asm_out_file);\n-    \n+\n       /* Generate the terminating entries for the .debug_aranges section.\n \n \t Note that we want to do this only *after* we have output the end\n@@ -6524,7 +6524,7 @@ dwarfout_finish (main_input_filename)\n \t entries at this late point in the assembly output, we skirt the\n \t issue simply by avoiding forward-references.\n       */\n-    \n+\n       fputc ('\\n', asm_out_file);\n       ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_ARANGES_SECTION);\n "}]}