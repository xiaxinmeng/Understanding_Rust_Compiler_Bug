{"sha": "37bf20eeb00f4cb848b2533b037c101964ac3c4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzdiZjIwZWViMDBmNGNiODQ4YjI1MzNiMDM3YzEwMTk2NGFjM2M0Yg==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-10-06T23:09:28Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-06T23:09:28Z"}, "message": "optabs.c (prepare_float_lib_cmp): Avoid searching for REG_RETVAL instruction by using LCT_CONST and then calling...\n\n\n\t* optabs.c (prepare_float_lib_cmp): Avoid searching for REG_RETVAL\n\tinstruction by using LCT_CONST and then calling emit_libcall_block\n\tourselves.\n\nCo-Authored-By: Zack Weinberg <zack@codesourcery.com>\n\nFrom-SVN: r72171", "tree": {"sha": "c1d94a7feee91cefe5fd6511bcd4566bf6170943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1d94a7feee91cefe5fd6511bcd4566bf6170943"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37bf20eeb00f4cb848b2533b037c101964ac3c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bf20eeb00f4cb848b2533b037c101964ac3c4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bf20eeb00f4cb848b2533b037c101964ac3c4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bf20eeb00f4cb848b2533b037c101964ac3c4b/comments", "author": null, "committer": null, "parents": [{"sha": "cd2ac05b77794ac29ad70a469437c258c43fc432", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd2ac05b77794ac29ad70a469437c258c43fc432", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd2ac05b77794ac29ad70a469437c258c43fc432"}], "stats": {"total": 138, "additions": 66, "deletions": 72}, "files": [{"sha": "06ea6114c54ec4c6e1cc23dbe966dc3ded9ba297", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bf20eeb00f4cb848b2533b037c101964ac3c4b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bf20eeb00f4cb848b2533b037c101964ac3c4b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=37bf20eeb00f4cb848b2533b037c101964ac3c4b", "patch": "@@ -1,3 +1,10 @@\n+2003-10-06  Roger Sayle  <roger@eyesopen.com>\n+\t    Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* optabs.c (prepare_float_lib_cmp): Avoid searching for REG_RETVAL\n+\tinstruction by using LCT_CONST and then calling emit_libcall_block\n+\tourselves.\n+\n 2003-10-06  Falk Hueffner  <falk.hueffner@student.uni-tuebingen.de>\n \n         PR optimization/11974"}, {"sha": "b0953ebe77b7ff45801c5e8b2d77fa9033efc417", "filename": "gcc/optabs.c", "status": "modified", "additions": 59, "deletions": 72, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37bf20eeb00f4cb848b2533b037c101964ac3c4b/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37bf20eeb00f4cb848b2533b037c101964ac3c4b/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=37bf20eeb00f4cb848b2533b037c101964ac3c4b", "patch": "@@ -3878,9 +3878,8 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n   rtx y = protect_from_queue (*py, 0);\n   enum machine_mode orig_mode = GET_MODE (x);\n   enum machine_mode mode;\n-  rtx before_call;\n+  rtx value, target, insns, equiv;\n   rtx libfunc = 0;\n-  rtx result;\n \n   for (mode = orig_mode; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n     {\n@@ -3905,98 +3904,86 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n       y = convert_to_mode (mode, y, 0);\n     }\n \n-  before_call = get_last_insn ();\n-\n-  result = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST_MAKE_BLOCK,\n-\t\t\t\t    word_mode, 2, x, mode, y, mode);\n-\n   /* If we're optimizing attach a REG_EQUAL note describing the semantics\n      of the libcall to the RTL.  The allows the RTL optimizers to delete\n      the libcall if the condition can be determined at compile-time.  */\n   if (optimize\n       && ! side_effects_p (x)\n       && ! side_effects_p (y))\n     {\n-      /* Search backwards through the insns emitted above looking for\n-\t the instruction with the REG_RETVAL note.  */\n-      rtx last = get_last_insn ();\n-      while (last != before_call)\n+      if (comparison == UNORDERED)\n \t{\n-\t  if (find_reg_note (last, REG_RETVAL, NULL))\n-\t    break;\n-\t  last = PREV_INSN (last);\n+\t  rtx temp = simplify_gen_relational (NE, word_mode, mode, x, x);\n+\t  equiv = simplify_gen_relational (NE, word_mode, mode, y, y);\n+\t  equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode, word_mode,\n+\t\t\t\t\ttemp, const_true_rtx, equiv);\n \t}\n-\n-      if (last != before_call)\n+      else\n \t{\n-\t  rtx equiv;\n-\t  if (comparison == UNORDERED)\n+\t  equiv = simplify_gen_relational (comparison, word_mode, mode, x, y);\n+\t  if (! FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n \t    {\n-\t      rtx temp = simplify_gen_relational (NE, word_mode,\n-\t\t\t\t\t\t  mode, x, x);\n-\t      equiv = simplify_gen_relational (NE, word_mode,\n-\t\t\t\t\t       mode, y, y);\n-\t      equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode,\n-\t\t\t\t\t    word_mode, temp,\n-\t\t\t\t\t    const_true_rtx, equiv);\n-\t    }\n-\t  else\n-\t    {\n-\t      equiv = simplify_gen_relational (comparison, word_mode,\n-\t\t\t\t\t       mode, x, y);\n-\t      if (! FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n+\t      rtx true_rtx, false_rtx;\n+\n+\t      switch (comparison)\n \t\t{\n-\t\t  rtx true_rtx, false_rtx;\n+\t\tcase EQ:\n+\t\t  true_rtx = const0_rtx;\n+\t\t  false_rtx = const_true_rtx;\n+\t\t  break;\n \n-\t\t  switch (comparison)\n-\t\t    {\n-\t\t    case EQ:\n-\t\t      true_rtx = const0_rtx;\n-\t\t      false_rtx = const_true_rtx;\n-\t\t      break;\n-\n-\t\t    case NE:\n-\t\t      true_rtx = const_true_rtx;\n-\t\t      false_rtx = const0_rtx;\n-\t\t      break;\n-\n-\t\t    case GT:\n-\t\t      true_rtx = const1_rtx;\n-\t\t      false_rtx = const0_rtx;\n-\t\t      break;\n-\n-\t\t    case GE:\n-\t\t      true_rtx = const0_rtx;\n-\t\t      false_rtx = constm1_rtx;\n-\t\t      break;\n-\n-\t\t    case LT:\n-\t\t      true_rtx = constm1_rtx;\n-\t\t      false_rtx = const0_rtx;\n-\t\t      break;\n-\n-\t\t    case LE:\n-\t\t      true_rtx = const0_rtx;\n-\t\t      false_rtx = const1_rtx;\n-\t\t      break;\n-\n-\t\t    default:\n-\t\t      abort ();\n-\t\t    }\n-\t\t  equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode,\n-\t\t\t\t\t\tword_mode, equiv,\n-\t\t\t\t\t\ttrue_rtx, false_rtx);\n+\t\tcase NE:\n+\t\t  true_rtx = const_true_rtx;\n+\t\t  false_rtx = const0_rtx;\n+\t\t  break;\n+\n+\t\tcase GT:\n+\t\t  true_rtx = const1_rtx;\n+\t\t  false_rtx = const0_rtx;\n+\t\t  break;\n+\n+\t\tcase GE:\n+\t\t  true_rtx = const0_rtx;\n+\t\t  false_rtx = constm1_rtx;\n+\t\t  break;\n+\n+\t\tcase LT:\n+\t\t  true_rtx = constm1_rtx;\n+\t\t  false_rtx = const0_rtx;\n+\t\t  break;\n+\n+\t\tcase LE:\n+\t\t  true_rtx = const0_rtx;\n+\t\t  false_rtx = const1_rtx;\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  abort ();\n \t\t}\n+\t      equiv = simplify_gen_ternary (IF_THEN_ELSE, word_mode,\n+\t\t\t\t\t    word_mode, equiv,\n+\t\t\t\t\t    true_rtx, false_rtx);\n \t    }\n-\t  set_unique_reg_note (last, REG_EQUAL, equiv);\n \t}\n     }\n+  else\n+    equiv = NULL_RTX;\n+\n+  start_sequence ();\n+  value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST,\n+\t\t\t\t   word_mode, 2, x, mode, y, mode);\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  target = gen_reg_rtx (word_mode);\n+  emit_libcall_block (insns, target, value, equiv);\n+\n \n   if (comparison == UNORDERED\n       || FLOAT_LIB_COMPARE_RETURNS_BOOL (mode, comparison))\n     comparison = NE;\n \n-  *px = result;\n+  *px = target;\n   *py = const0_rtx;\n   *pmode = word_mode;\n   *pcomparison = comparison;"}]}