{"sha": "6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEwYzhlNzdmMjg5YTVjMmUxYjFhZDBmMmM4YTVjNTEwNWY1OTlhNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-15T20:32:39Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-15T20:32:39Z"}, "message": "compiler, runtime: panic on uncomparable map key, even if map is empty\n    \n    This ports https://golang.org/cl/155918 from the master repo.\n    \n        runtime: panic on uncomparable map key, even if map is empty\n    \n        Reorg map flags a bit so we don't need any extra space for the extra flag.\n    \n    This is a pre-req for updating libgo to the Go 1.12beta2 release.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/157858\n\nFrom-SVN: r267950", "tree": {"sha": "ed17062ac88ccb7fdf858eb98d80b5880065061a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed17062ac88ccb7fdf858eb98d80b5880065061a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/comments", "author": null, "committer": null, "parents": [{"sha": "a81a6d58367e63f3c7314eb793002e5feb379428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a81a6d58367e63f3c7314eb793002e5feb379428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a81a6d58367e63f3c7314eb793002e5feb379428"}], "stats": {"total": 254, "additions": 170, "deletions": 84}, "files": [{"sha": "4d76c547bdce5955a19a34a8d8d81ec20f2efa73", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -1,4 +1,4 @@\n-0d64279c01a37b2579c0c62ca4f2c3e3f81de07c\n+87005025fcd0d7e7908b3aae7062b52cb80eb0f3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "5a45bb2c3f4b04c47075c3d0e73089a877a90884", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -5839,6 +5839,25 @@ Struct_type::do_needs_key_update()\n   return false;\n }\n \n+// Return whether computing the hash value of an instance of this\n+// struct type might panic.\n+\n+bool\n+Struct_type::do_hash_might_panic()\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL)\n+    return false;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      if (pf->type()->hash_might_panic())\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n // Return whether this struct type is permitted to be in the heap.\n \n bool\n@@ -7979,21 +7998,18 @@ Map_type::make_map_type_descriptor_type()\n       Type* ptdt = Type::make_type_descriptor_ptr_type();\n       Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n       Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n-      Type* bool_type = Type::lookup_bool_type();\n+      Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n \n       Struct_type* sf =\n-\tType::make_builtin_struct_type(11,\n+\tType::make_builtin_struct_type(8,\n \t\t\t\t       \"\", tdt,\n \t\t\t\t       \"key\", ptdt,\n \t\t\t\t       \"elem\", ptdt,\n \t\t\t\t       \"bucket\", ptdt,\n \t\t\t\t       \"keysize\", uint8_type,\n-\t\t\t\t       \"indirectkey\", bool_type,\n \t\t\t\t       \"valuesize\", uint8_type,\n-\t\t\t\t       \"indirectvalue\", bool_type,\n \t\t\t\t       \"bucketsize\", uint16_type,\n-\t\t\t\t       \"reflexivekey\", bool_type,\n-\t\t\t\t       \"needkeyupdate\", bool_type);\n+\t\t\t\t       \"flags\", uint32_type);\n \n       ret = Type::make_builtin_named_type(\"MapType\", sf);\n     }\n@@ -8011,6 +8027,7 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   Type* mtdt = Map_type::make_map_type_descriptor_type();\n   Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n   Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+  Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n \n   int64_t keysize;\n   if (!this->key_type_->backend_type_size(gogo, &keysize))\n@@ -8077,37 +8094,34 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   else\n     vals->push_back(Expression::make_integer_int64(keysize, uint8_type, bloc));\n \n-  ++p;\n-  go_assert(p->is_field_name(\"indirectkey\"));\n-  vals->push_back(Expression::make_boolean(keysize > Map_type::max_key_size,\n-\t\t\t\t\t   bloc));\n-\n   ++p;\n   go_assert(p->is_field_name(\"valuesize\"));\n   if (valsize > Map_type::max_val_size)\n     vals->push_back(Expression::make_integer_int64(ptrsize, uint8_type, bloc));\n   else\n     vals->push_back(Expression::make_integer_int64(valsize, uint8_type, bloc));\n \n-  ++p;\n-  go_assert(p->is_field_name(\"indirectvalue\"));\n-  vals->push_back(Expression::make_boolean(valsize > Map_type::max_val_size,\n-\t\t\t\t\t   bloc));\n-\n   ++p;\n   go_assert(p->is_field_name(\"bucketsize\"));\n   vals->push_back(Expression::make_integer_int64(bucketsize, uint16_type,\n \t\t\t\t\t\t bloc));\n \n   ++p;\n-  go_assert(p->is_field_name(\"reflexivekey\"));\n-  vals->push_back(Expression::make_boolean(this->key_type_->is_reflexive(),\n-\t\t\t\t\t   bloc));\n-\n-  ++p;\n-  go_assert(p->is_field_name(\"needkeyupdate\"));\n-  vals->push_back(Expression::make_boolean(this->key_type_->needs_key_update(),\n-\t\t\t\t\t   bloc));\n+  go_assert(p->is_field_name(\"flags\"));\n+  // As with the other fields, the flag bits must match the reflect\n+  // and runtime packages.\n+  unsigned long flags = 0;\n+  if (keysize > Map_type::max_key_size)\n+    flags |= 1;\n+  if (valsize > Map_type::max_val_size)\n+    flags |= 2;\n+  if (this->key_type_->is_reflexive())\n+    flags |= 4;\n+  if (this->key_type_->needs_key_update())\n+    flags |= 8;\n+  if (this->key_type_->hash_might_panic())\n+    flags |= 16;\n+  vals->push_back(Expression::make_integer_ul(flags, uint32_type, bloc));\n \n   ++p;\n   go_assert(p == fields->end());"}, {"sha": "cc92471d24c5662fc517032d902849fab3e169c2", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -635,6 +635,12 @@ class Type\n   needs_key_update()\n   { return this->do_needs_key_update(); }\n \n+  // Return whether the hash function of this type might panic.  This\n+  // is only called for types used as a key in a map type.\n+  bool\n+  hash_might_panic()\n+  { return this->do_hash_might_panic(); }\n+\n   // Whether the type is permitted in the heap.\n   bool\n   in_heap()\n@@ -1073,6 +1079,10 @@ class Type\n   do_needs_key_update()\n   { return false; }\n \n+  virtual bool\n+  do_hash_might_panic()\n+  { return false; }\n+\n   virtual bool\n   do_in_heap()\n   { return true; }\n@@ -2600,6 +2610,9 @@ class Struct_type : public Type\n   bool\n   do_needs_key_update();\n \n+  bool\n+  do_hash_might_panic();\n+\n   bool\n   do_in_heap();\n \n@@ -2778,6 +2791,10 @@ class Array_type : public Type\n   do_needs_key_update()\n   { return this->element_type_->needs_key_update(); }\n \n+  bool\n+  do_hash_might_panic()\n+  { return this->length_ != NULL && this->element_type_->hash_might_panic(); }\n+\n   bool\n   do_in_heap()\n   { return this->length_ == NULL || this->element_type_->in_heap(); }\n@@ -3170,6 +3187,11 @@ class Interface_type : public Type\n   do_needs_key_update()\n   { return true; }\n \n+  // Hashing an unhashable type stored in an interface might panic.\n+  bool\n+  do_hash_might_panic()\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*, int) const;\n "}, {"sha": "e4a9326d08357508bd19b8dc5f4553d96c3948a0", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -347,16 +347,13 @@ type interfaceType struct {\n // mapType represents a map type.\n type mapType struct {\n \trtype\n-\tkey           *rtype // map key type\n-\telem          *rtype // map element (value) type\n-\tbucket        *rtype // internal bucket structure\n-\tkeysize       uint8  // size of key slot\n-\tindirectkey   uint8  // store ptr to key instead of key itself\n-\tvaluesize     uint8  // size of value slot\n-\tindirectvalue uint8  // store ptr to value instead of value itself\n-\tbucketsize    uint16 // size of bucket\n-\treflexivekey  bool   // true if k==k for all keys\n-\tneedkeyupdate bool   // true if we need to update key on an overwrite\n+\tkey        *rtype // map key type\n+\telem       *rtype // map element (value) type\n+\tbucket     *rtype // internal bucket structure\n+\tkeysize    uint8  // size of key slot\n+\tvaluesize  uint8  // size of value slot\n+\tbucketsize uint16 // size of bucket\n+\tflags      uint32\n }\n \n // ptrType represents a pointer type.\n@@ -1506,6 +1503,8 @@ func MapOf(key, elem Type) Type {\n \ts := \"map[\" + *ktyp.string + \"]\" + *etyp.string\n \n \t// Make a map type.\n+\t// Note: flag values must match those used in the TMAP case\n+\t// in ../cmd/compile/internal/gc/reflect.go:dtypesym.\n \tvar imap interface{} = (map[unsafe.Pointer]unsafe.Pointer)(nil)\n \tmt := **(**mapType)(unsafe.Pointer(&imap))\n \tmt.string = &s\n@@ -1520,23 +1519,29 @@ func MapOf(key, elem Type) Type {\n \tmt.ptrToThis = nil\n \n \tmt.bucket = bucketOf(ktyp, etyp)\n+\tmt.flags = 0\n \tif ktyp.size > maxKeySize {\n \t\tmt.keysize = uint8(ptrSize)\n-\t\tmt.indirectkey = 1\n+\t\tmt.flags |= 1 // indirect key\n \t} else {\n \t\tmt.keysize = uint8(ktyp.size)\n-\t\tmt.indirectkey = 0\n \t}\n \tif etyp.size > maxValSize {\n \t\tmt.valuesize = uint8(ptrSize)\n-\t\tmt.indirectvalue = 1\n+\t\tmt.flags |= 2 // indirect value\n \t} else {\n \t\tmt.valuesize = uint8(etyp.size)\n-\t\tmt.indirectvalue = 0\n \t}\n \tmt.bucketsize = uint16(mt.bucket.size)\n-\tmt.reflexivekey = isReflexive(ktyp)\n-\tmt.needkeyupdate = needKeyUpdate(ktyp)\n+\tif isReflexive(ktyp) {\n+\t\tmt.flags |= 4\n+\t}\n+\tif needKeyUpdate(ktyp) {\n+\t\tmt.flags |= 8\n+\t}\n+\tif hashMightPanic(ktyp) {\n+\t\tmt.flags |= 16\n+\t}\n \n \t// Canonicalize before storing in lookupCache\n \tti := toType(&mt.rtype)\n@@ -1715,6 +1720,27 @@ func needKeyUpdate(t *rtype) bool {\n \t}\n }\n \n+// hashMightPanic reports whether the hash of a map key of type t might panic.\n+func hashMightPanic(t *rtype) bool {\n+\tswitch t.Kind() {\n+\tcase Interface:\n+\t\treturn true\n+\tcase Array:\n+\t\ttt := (*arrayType)(unsafe.Pointer(t))\n+\t\treturn hashMightPanic(tt.elem)\n+\tcase Struct:\n+\t\ttt := (*structType)(unsafe.Pointer(t))\n+\t\tfor _, f := range tt.fields {\n+\t\t\tif hashMightPanic(f.typ) {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t\treturn false\n+\tdefault:\n+\t\treturn false\n+\t}\n+}\n+\n // Make sure these routines stay in sync with ../../runtime/map.go!\n // These types exist only for GC, so we only fill out GC relevant info.\n // Currently, that's just size and the GC program. We also fill in string"}, {"sha": "52462c7e1170b073dfd9d46979a4385bc20f8cb8", "filename": "libgo/go/runtime/map.go", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Fruntime%2Fmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Fruntime%2Fmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap.go?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -414,14 +414,17 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n+\t\tif t.hashMightPanic() {\n+\t\t\thashfn(key, 0) // see issue 23734\n+\t\t}\n \t\treturn unsafe.Pointer(&zeroVal[0])\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map read and map write\")\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \thash := hashfn(key, uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n@@ -442,12 +445,12 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n \t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n-\t\t\t\tif t.indirectvalue {\n+\t\t\t\tif t.indirectvalue() {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n \t\t\t\t}\n \t\t\t\treturn v\n@@ -472,14 +475,17 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n+\t\tif t.hashMightPanic() {\n+\t\t\thashfn(key, 0) // see issue 23734\n+\t\t}\n \t\treturn unsafe.Pointer(&zeroVal[0]), false\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map read and map write\")\n \t}\n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \thash := hashfn(key, uintptr(h.hash0))\n \tm := bucketMask(h.B)\n \tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n@@ -500,12 +506,12 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n \t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n-\t\t\t\tif t.indirectvalue {\n+\t\t\t\tif t.indirectvalue() {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n \t\t\t\t}\n \t\t\t\treturn v, true\n@@ -547,12 +553,12 @@ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n \t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n-\t\t\t\tif t.indirectvalue {\n+\t\t\t\tif t.indirectvalue() {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n \t\t\t\t}\n \t\t\t\treturn k, v\n@@ -634,14 +640,14 @@ again:\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n \t\t\tif !equalfn(key, k) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// already have a mapping for key. Update it.\n-\t\t\tif t.needkeyupdate {\n+\t\t\tif t.needkeyupdate() {\n \t\t\t\ttypedmemmove(t.key, k, key)\n \t\t\t}\n \t\t\tval = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n@@ -672,12 +678,12 @@ again:\n \t}\n \n \t// store new key/value at insert position\n-\tif t.indirectkey {\n+\tif t.indirectkey() {\n \t\tkmem := newobject(t.key)\n \t\t*(*unsafe.Pointer)(insertk) = kmem\n \t\tinsertk = kmem\n \t}\n-\tif t.indirectvalue {\n+\tif t.indirectvalue() {\n \t\tvmem := newobject(t.elem)\n \t\t*(*unsafe.Pointer)(val) = vmem\n \t}\n@@ -690,7 +696,7 @@ done:\n \t\tthrow(\"concurrent map writes\")\n \t}\n \th.flags &^= hashWriting\n-\tif t.indirectvalue {\n+\tif t.indirectvalue() {\n \t\tval = *((*unsafe.Pointer)(val))\n \t}\n \treturn val\n@@ -706,15 +712,18 @@ func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n \tif msanenabled && h != nil {\n \t\tmsanread(key, t.key.size)\n \t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n \tif h == nil || h.count == 0 {\n+\t\tif t.hashMightPanic() {\n+\t\t\thashfn(key, 0) // see issue 23734\n+\t\t}\n \t\treturn\n \t}\n \tif h.flags&hashWriting != 0 {\n \t\tthrow(\"concurrent map writes\")\n \t}\n \n-\thashfn := t.key.hashfn\n-\tequalfn := t.key.equalfn\n \thash := hashfn(key, uintptr(h.hash0))\n \n \t// Set hashWriting after calling alg.hash, since alg.hash may panic,\n@@ -735,20 +744,20 @@ search:\n \t\t\t}\n \t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n \t\t\tk2 := k\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t}\n \t\t\tif !equalfn(key, k2) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// Only clear key if there are pointers in it.\n-\t\t\tif t.indirectkey {\n+\t\t\tif t.indirectkey() {\n \t\t\t\t*(*unsafe.Pointer)(k) = nil\n \t\t\t} else if t.key.kind&kindNoPointers == 0 {\n \t\t\t\tmemclrHasPointers(k, t.key.size)\n \t\t\t}\n \t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n-\t\t\tif t.indirectvalue {\n+\t\t\tif t.indirectvalue() {\n \t\t\t\t*(*unsafe.Pointer)(v) = nil\n \t\t\t} else if t.elem.kind&kindNoPointers == 0 {\n \t\t\t\tmemclrHasPointers(v, t.elem.size)\n@@ -894,7 +903,7 @@ next:\n \t\t\tcontinue\n \t\t}\n \t\tk := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))\n-\t\tif t.indirectkey {\n+\t\tif t.indirectkey() {\n \t\t\tk = *((*unsafe.Pointer)(k))\n \t\t}\n \t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))\n@@ -906,7 +915,7 @@ next:\n \t\t\t// through the oldbucket, skipping any keys that will go\n \t\t\t// to the other new bucket (each oldbucket expands to two\n \t\t\t// buckets during a grow).\n-\t\t\tif t.reflexivekey || equalfn(k, k) {\n+\t\t\tif t.reflexivekey() || equalfn(k, k) {\n \t\t\t\t// If the item in the oldbucket is not destined for\n \t\t\t\t// the current new bucket in the iteration, skip it.\n \t\t\t\thash := hashfn(k, uintptr(h.hash0))\n@@ -927,13 +936,13 @@ next:\n \t\t\t}\n \t\t}\n \t\tif (b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY) ||\n-\t\t\t!(t.reflexivekey || equalfn(k, k)) {\n+\t\t\t!(t.reflexivekey() || equalfn(k, k)) {\n \t\t\t// This is the golden data, we can return it.\n \t\t\t// OR\n \t\t\t// key!=key, so the entry can't be deleted or updated, so we can just return it.\n \t\t\t// That's lucky for us because when key!=key we can't look it up successfully.\n \t\t\tit.key = k\n-\t\t\tif t.indirectvalue {\n+\t\t\tif t.indirectvalue() {\n \t\t\t\tv = *((*unsafe.Pointer)(v))\n \t\t\t}\n \t\t\tit.value = v\n@@ -1157,15 +1166,15 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\t\tthrow(\"bad map state\")\n \t\t\t\t}\n \t\t\t\tk2 := k\n-\t\t\t\tif t.indirectkey {\n+\t\t\t\tif t.indirectkey() {\n \t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t\t}\n \t\t\t\tvar useY uint8\n \t\t\t\tif !h.sameSizeGrow() {\n \t\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t\t// to send this key/value to bucket x or bucket y).\n \t\t\t\t\thash := t.key.hashfn(k2, uintptr(h.hash0))\n-\t\t\t\t\tif h.flags&iterator != 0 && !t.reflexivekey && !t.key.equalfn(k2, k2) {\n+\t\t\t\t\tif h.flags&iterator != 0 && !t.reflexivekey() && !t.key.equalfn(k2, k2) {\n \t\t\t\t\t\t// If key != key (NaNs), then the hash could be (and probably\n \t\t\t\t\t\t// will be) entirely different from the old hash. Moreover,\n \t\t\t\t\t\t// it isn't reproducible. Reproducibility is required in the\n@@ -1200,12 +1209,12 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\t\tdst.v = add(dst.k, bucketCnt*uintptr(t.keysize))\n \t\t\t\t}\n \t\t\t\tdst.b.tophash[dst.i&(bucketCnt-1)] = top // mask dst.i as an optimization, to avoid a bounds check\n-\t\t\t\tif t.indirectkey {\n+\t\t\t\tif t.indirectkey() {\n \t\t\t\t\t*(*unsafe.Pointer)(dst.k) = k2 // copy pointer\n \t\t\t\t} else {\n \t\t\t\t\ttypedmemmove(t.key, dst.k, k) // copy value\n \t\t\t\t}\n-\t\t\t\tif t.indirectvalue {\n+\t\t\t\tif t.indirectvalue() {\n \t\t\t\t\t*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)\n \t\t\t\t} else {\n \t\t\t\t\ttypedmemmove(t.elem, dst.v, v)\n@@ -1271,12 +1280,12 @@ func reflect_makemap(t *maptype, cap int) *hmap {\n \tif !ismapkey(t.key) {\n \t\tthrow(\"runtime.reflect_makemap: unsupported map key type\")\n \t}\n-\tif t.key.size > maxKeySize && (!t.indirectkey || t.keysize != uint8(sys.PtrSize)) ||\n-\t\tt.key.size <= maxKeySize && (t.indirectkey || t.keysize != uint8(t.key.size)) {\n+\tif t.key.size > maxKeySize && (!t.indirectkey() || t.keysize != uint8(sys.PtrSize)) ||\n+\t\tt.key.size <= maxKeySize && (t.indirectkey() || t.keysize != uint8(t.key.size)) {\n \t\tthrow(\"key size wrong\")\n \t}\n-\tif t.elem.size > maxValueSize && (!t.indirectvalue || t.valuesize != uint8(sys.PtrSize)) ||\n-\t\tt.elem.size <= maxValueSize && (t.indirectvalue || t.valuesize != uint8(t.elem.size)) {\n+\tif t.elem.size > maxValueSize && (!t.indirectvalue() || t.valuesize != uint8(sys.PtrSize)) ||\n+\t\tt.elem.size <= maxValueSize && (t.indirectvalue() || t.valuesize != uint8(t.elem.size)) {\n \t\tthrow(\"value size wrong\")\n \t}\n \tif t.key.align > bucketCnt {"}, {"sha": "5cafa38e18b7c087fe13a01125ad7f0e588723b0", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=6a0c8e77f289a5c2e1b1ad0f2c8a5c5105f599a6", "patch": "@@ -86,17 +86,32 @@ type interfacetype struct {\n }\n \n type maptype struct {\n-\ttyp           _type\n-\tkey           *_type\n-\telem          *_type\n-\tbucket        *_type // internal type representing a hash bucket\n-\tkeysize       uint8  // size of key slot\n-\tindirectkey   bool   // store ptr to key instead of key itself\n-\tvaluesize     uint8  // size of value slot\n-\tindirectvalue bool   // store ptr to value instead of value itself\n-\tbucketsize    uint16 // size of bucket\n-\treflexivekey  bool   // true if k==k for all keys\n-\tneedkeyupdate bool   // true if we need to update key on an overwrite\n+\ttyp        _type\n+\tkey        *_type\n+\telem       *_type\n+\tbucket     *_type // internal type representing a hash bucket\n+\tkeysize    uint8  // size of key slot\n+\tvaluesize  uint8  // size of value slot\n+\tbucketsize uint16 // size of bucket\n+\tflags      uint32\n+}\n+\n+// Note: flag values must match those used in the TMAP case\n+// in ../cmd/compile/internal/gc/reflect.go:dtypesym.\n+func (mt *maptype) indirectkey() bool { // store ptr to key instead of key itself\n+\treturn mt.flags&1 != 0\n+}\n+func (mt *maptype) indirectvalue() bool { // store ptr to value instead of value itself\n+\treturn mt.flags&2 != 0\n+}\n+func (mt *maptype) reflexivekey() bool { // true if k==k for all keys\n+\treturn mt.flags&4 != 0\n+}\n+func (mt *maptype) needkeyupdate() bool { // true if we need to update key on an overwrite\n+\treturn mt.flags&8 != 0\n+}\n+func (mt *maptype) hashMightPanic() bool { // true if hash function might panic\n+\treturn mt.flags&16 != 0\n }\n \n type arraytype struct {"}]}