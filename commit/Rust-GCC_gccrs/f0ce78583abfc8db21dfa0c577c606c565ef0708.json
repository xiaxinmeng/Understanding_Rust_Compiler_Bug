{"sha": "f0ce78583abfc8db21dfa0c577c606c565ef0708", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjBjZTc4NTgzYWJmYzhkYjIxZGZhMGM1NzdjNjA2YzU2NWVmMDcwOA==", "commit": {"author": {"name": "Josh Conner", "email": "jconner@apple.com", "date": "2006-09-01T16:56:14Z"}, "committer": {"name": "Josh Conner", "email": "jconner@gcc.gnu.org", "date": "2006-09-01T16:56:14Z"}, "message": "re PR middle-end/25505 (gcc uses way too much stack space for this code)\n\n2006-09-01  Josh Conner  <jconner@apple.com>\n\n\tPR c++/25505\n\t* tree-nrv.c (dest_safe_for_nrv_p): New function.\n\t(execute_return_slot_opt): Use it.\n\nFrom-SVN: r116633", "tree": {"sha": "286ce80371b7865cb1da34874fff2c1465e4f864", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/286ce80371b7865cb1da34874fff2c1465e4f864"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f0ce78583abfc8db21dfa0c577c606c565ef0708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ce78583abfc8db21dfa0c577c606c565ef0708", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0ce78583abfc8db21dfa0c577c606c565ef0708", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0ce78583abfc8db21dfa0c577c606c565ef0708/comments", "author": null, "committer": null, "parents": [{"sha": "69afd3217ed5b3a232363a518bb1e2174e8797fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69afd3217ed5b3a232363a518bb1e2174e8797fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69afd3217ed5b3a232363a518bb1e2174e8797fc"}], "stats": {"total": 68, "additions": 43, "deletions": 25}, "files": [{"sha": "922caa534c7ee098a2be6fa9b46c7bd9064722e4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ce78583abfc8db21dfa0c577c606c565ef0708/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ce78583abfc8db21dfa0c577c606c565ef0708/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f0ce78583abfc8db21dfa0c577c606c565ef0708", "patch": "@@ -1,3 +1,9 @@\n+2006-09-01  Josh Conner  <jconner@apple.com>\n+\n+\tPR c++/25505\n+\t* tree-nrv.c (dest_safe_for_nrv_p): New function.\n+\t(execute_return_slot_opt): Use it.\n+\n 2006-08-31  Josh Conner  <jconner@apple.com>\n \n \tPR c++/25505"}, {"sha": "f51afdb258c2d9d554ad4bd2e95772ce4be5a00a", "filename": "gcc/tree-nrv.c", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f0ce78583abfc8db21dfa0c577c606c565ef0708/gcc%2Ftree-nrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f0ce78583abfc8db21dfa0c577c606c565ef0708/gcc%2Ftree-nrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nrv.c?ref=f0ce78583abfc8db21dfa0c577c606c565ef0708", "patch": "@@ -231,6 +231,39 @@ struct tree_opt_pass pass_nrv =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Determine (pessimistically) whether DEST is available for NRV\n+   optimization, where DEST is expected to be the LHS of a modify\n+   expression where the RHS is a function returning an aggregate.\n+\n+   We search for a base VAR_DECL and look to see if it, or any of its\n+   subvars are clobbered.  Note that we could do better, for example, by\n+   attempting to doing points-to analysis on INDIRECT_REFs.  */\n+\n+static bool\n+dest_safe_for_nrv_p (tree dest)\n+{\n+  switch (TREE_CODE (dest))\n+    {\n+      case VAR_DECL:\n+\t{\n+\t  subvar_t subvar;\n+\t  if (is_call_clobbered (dest))\n+\t    return false;\n+\t  for (subvar = get_subvars_for_var (dest);\n+\t       subvar;\n+\t       subvar = subvar->next)\n+\t    if (is_call_clobbered (subvar->var))\n+\t      return false;\n+\t  return true;\n+\t}\n+      case ARRAY_REF:\n+      case COMPONENT_REF:\n+\treturn dest_safe_for_nrv_p (TREE_OPERAND (dest, 0));\n+      default:\n+\treturn false;\n+    }\n+}\n+\n /* Walk through the function looking for MODIFY_EXPRs with calls that\n    return in memory on the RHS.  For each of these, determine whether it is\n    safe to pass the address of the LHS as the return slot, and mark the\n@@ -261,31 +294,10 @@ execute_return_slot_opt (void)\n \t\t  TREE_CODE (call) == CALL_EXPR)\n \t      && !CALL_EXPR_RETURN_SLOT_OPT (call)\n \t      && aggregate_value_p (call, call))\n-\t    {\n-\t      def_operand_p def_p;\n-\t      ssa_op_iter op_iter;\n-\n-\t      /* We determine whether or not the LHS address escapes by\n-\t\t asking whether it is call clobbered.  When the LHS isn't a\n-\t\t simple decl, we need to check the VDEFs, so it's simplest\n-\t\t to just loop through all the DEFs.  */\n-\t      FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n-\t\t{\n-\t\t  tree def = DEF_FROM_PTR (def_p);\n-\t\t  if (TREE_CODE (def) == SSA_NAME)\n-\t\t    def = SSA_NAME_VAR (def);\n-\t\t  if (is_call_clobbered (def))\n-\t\t    goto unsafe;\n-\t\t}\n-\n-\t      /* No defs are call clobbered, so the optimization is safe.  */\n-\t      CALL_EXPR_RETURN_SLOT_OPT (call) = 1;\n-\t      /* This is too late to mark the target addressable like we do\n-\t\t in gimplify_modify_expr_rhs, but that's OK; anything that\n-\t\t wasn't already addressable was handled there.  */\n-\n-\t      unsafe:;\n-\t    }\n+\t    /* Check if the location being assigned to is\n+\t       call-clobbered.  */\n+\t    CALL_EXPR_RETURN_SLOT_OPT (call) =\n+\t      dest_safe_for_nrv_p (TREE_OPERAND (stmt, 0)) ? 1 : 0;\n \t}\n     }\n   return 0;"}]}