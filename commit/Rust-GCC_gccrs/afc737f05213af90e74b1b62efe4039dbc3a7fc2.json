{"sha": "afc737f05213af90e74b1b62efe4039dbc3a7fc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjNzM3ZjA1MjEzYWY5MGU3NGIxYjYyZWZlNDAzOWRiYzNhN2ZjMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-04-27T10:49:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-04-27T10:49:35Z"}, "message": "gigi.h (gnat_to_gnu_entity): Adjust prototype.\n\n\t* gcc-interface/gigi.h (gnat_to_gnu_entity): Adjust prototype.\n\t(maybe_pad_type): Adjust comment.\n\t(finish_record_type): Likewise.\n\t(rest_of_record_type_compilation): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Change DEFINITION type\n\tparameter from integer to boolean.  Adjust recursive calls.\n\t<E_Subprogram_Type>: Use copy_type and remove redundant assignments.\n\t<E_Signed_Integer_Subtype>:  Adjust comment.  Remove call to\n\trest_of_record_type_compilation.  Set TYPE_PADDING_P flag earlier.\n\tPass false to finish_record_type.  Set the debug type later.\n\t<E_Record_Subtype>: Remove call to rest_of_record_type_compilation.\n\t(gnat_to_gnu_component_type): Fix formatting.\n\t(gnat_to_gnu_field_decl): Adjust call to gnat_to_gnu_entity.\n\t(gnat_to_gnu_type): Likewise.\n\t* gcc-interface/trans.c (Identifier_to_gnu): Likewise.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(Subprogram_Body_to_gnu): Likewise.\n\t(Exception_Handler_to_gnu_fe_sjlj): Likewise.\n\t(Exception_Handler_to_gnu_gcc): Likewise.\n\t(Compilation_Unit_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(push_exception_label_stack): Likewise.\n\t(elaborate_all_entities_for_package): Likewise.\n\t(process_freeze_entity): Likewise.\n\t(process_decls): Likewise.\n\t(process_type): Likewise.\n\t* gcc-interface/utils.c (struct deferred_decl_context_node): Tweak.\n\t(maybe_pad_type): Adjust comments.  Set the debug type later.  Remove\n\tcall to rest_of_record_type_compilation.\n\t(rest_of_record_type_compilation): Use copy_type.\n\t(copy_type): Use correctly typed constants.\n\t(gnat_signed_or_unsigned_type_for): Use copy_type.\n\t* gcc-interface/utils2.c (nonbinary_modular_operation): Likewise.\n\t(build_goto_raise): Adjust call tognat_to_gnu_entity.\n\nFrom-SVN: r235479", "tree": {"sha": "2dbbe4060eceb145e54f50961129a316f38fc56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dbbe4060eceb145e54f50961129a316f38fc56c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afc737f05213af90e74b1b62efe4039dbc3a7fc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc737f05213af90e74b1b62efe4039dbc3a7fc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc737f05213af90e74b1b62efe4039dbc3a7fc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc737f05213af90e74b1b62efe4039dbc3a7fc2/comments", "author": null, "committer": null, "parents": [{"sha": "a2e76867ad58dd0d7b5e09b95533029ad0659202", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e76867ad58dd0d7b5e09b95533029ad0659202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e76867ad58dd0d7b5e09b95533029ad0659202"}], "stats": {"total": 278, "additions": 158, "deletions": 120}, "files": [{"sha": "8d418bf89b91980151f5446e9355f8cbca7f71a7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -1,3 +1,40 @@\n+2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_to_gnu_entity): Adjust prototype.\n+\t(maybe_pad_type): Adjust comment.\n+\t(finish_record_type): Likewise.\n+\t(rest_of_record_type_compilation): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Change DEFINITION type\n+\tparameter from integer to boolean.  Adjust recursive calls.\n+\t<E_Subprogram_Type>: Use copy_type and remove redundant assignments.\n+\t<E_Signed_Integer_Subtype>:  Adjust comment.  Remove call to\n+\trest_of_record_type_compilation.  Set TYPE_PADDING_P flag earlier.\n+\tPass false to finish_record_type.  Set the debug type later.\n+\t<E_Record_Subtype>: Remove call to rest_of_record_type_compilation.\n+\t(gnat_to_gnu_component_type): Fix formatting.\n+\t(gnat_to_gnu_field_decl): Adjust call to gnat_to_gnu_entity.\n+\t(gnat_to_gnu_type): Likewise.\n+\t* gcc-interface/trans.c (Identifier_to_gnu): Likewise.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(Subprogram_Body_to_gnu): Likewise.\n+\t(Exception_Handler_to_gnu_fe_sjlj): Likewise.\n+\t(Exception_Handler_to_gnu_gcc): Likewise.\n+\t(Compilation_Unit_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(push_exception_label_stack): Likewise.\n+\t(elaborate_all_entities_for_package): Likewise.\n+\t(process_freeze_entity): Likewise.\n+\t(process_decls): Likewise.\n+\t(process_type): Likewise.\n+\t* gcc-interface/utils.c (struct deferred_decl_context_node): Tweak.\n+\t(maybe_pad_type): Adjust comments.  Set the debug type later.  Remove\n+\tcall to rest_of_record_type_compilation.\n+\t(rest_of_record_type_compilation): Use copy_type.\n+\t(copy_type): Use correctly typed constants.\n+\t(gnat_signed_or_unsigned_type_for): Use copy_type.\n+\t* gcc-interface/utils2.c (nonbinary_modular_operation): Likewise.\n+\t(build_goto_raise): Adjust call tognat_to_gnu_entity.\n+\n 2016-04-27  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/misc.c (gnat_init): Do not call"}, {"sha": "226f13f9ef3a64f396615bb07a76f2fca1b8a2ed", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -217,15 +217,13 @@ static bool intrin_profiles_compatible_p (intrin_binding_t *);\n    initial value (in GCC tree form).  This is optional for a variable.  For\n    a renamed entity, GNU_EXPR gives the object being renamed.\n \n-   DEFINITION is nonzero if this call is intended for a definition.  This is\n-   used for separate compilation where it is necessary to know whether an\n-   external declaration or a definition must be created if the GCC equivalent\n-   was not created previously.  The value of 1 is normally used for a nonzero\n-   DEFINITION, but a value of 2 is used in special circumstances, defined in\n-   the code.  */\n+   DEFINITION is true if this call is intended for a definition.  This is used\n+   for separate compilation where it is necessary to know whether an external\n+   declaration or a definition must be created if the GCC equivalent was not\n+   created previously.  */\n \n tree\n-gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n+gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n {\n   /* Contains the kind of the input GNAT node.  */\n   const Entity_Kind kind = Ekind (gnat_entity);\n@@ -306,7 +304,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      || (IN (Ekind (gnat_temp), Subprogram_Kind)\n \t\t  && present_gnu_tree (gnat_temp)\n \t\t  && (current_function_decl\n-\t\t      == gnat_to_gnu_entity (gnat_temp, NULL_TREE, 0))))\n+\t\t      == gnat_to_gnu_entity (gnat_temp, NULL_TREE, false))))\n \t    {\n \t      process_type (gnat_entity);\n \t      return get_gnu_tree (gnat_entity);\n@@ -337,7 +335,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      || No (Freeze_Node (Full_View (gnat_entity)))))\n \t{\n \t  gnu_decl\n-\t    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, 0);\n+\t    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, false);\n \t  save_gnu_tree (gnat_entity, NULL_TREE, false);\n \t  save_gnu_tree (gnat_entity, gnu_decl, false);\n \t}\n@@ -485,12 +483,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_decl\n \t\t  = gnat_to_gnu_entity (Original_Record_Component\n \t\t\t\t\t(gnat_entity),\n-\t\t\t\t\tgnu_expr, 0);\n+\t\t\t\t\tgnu_expr, false);\n \t\tsaved = true;\n \t\tbreak;\n \t      }\n \n-\t    gnat_to_gnu_entity (Scope (gnat_entity), NULL_TREE, 0);\n+\t    gnat_to_gnu_entity (Scope (gnat_entity), NULL_TREE, false);\n \t    gnu_decl = get_gnu_tree (gnat_entity);\n \t    saved = true;\n \t    break;\n@@ -537,7 +535,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && Present (Full_View (gnat_entity)))\n \t{\n \t  gnu_decl\n-\t    = gnat_to_gnu_entity (Full_View (gnat_entity), gnu_expr, 0);\n+\t    = gnat_to_gnu_entity (Full_View (gnat_entity), gnu_expr, false);\n \t  saved = true;\n \t  break;\n \t}\n@@ -598,7 +596,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    if (kind == E_Exception)\n \t      gnu_expr = gnat_to_gnu_entity (Renamed_Entity (gnat_entity),\n-\t\t\t\t\t     NULL_TREE, 0);\n+\t\t\t\t\t     NULL_TREE, false);\n \t    else\n \t      gnu_expr = gnat_to_gnu_external (Renamed_Object (gnat_entity));\n \t  }\n@@ -1771,7 +1769,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n \t  && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n \t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n-\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n+\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, false);\n \n       /* Set the precision to the Esize except for bit-packed arrays.  */\n       if (Is_Packed_Array_Impl_Type (gnat_entity)\n@@ -1906,7 +1904,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    = create_field_decl (get_identifier (\"OBJECT\"), gnu_field_type,\n \t\t\t\t gnu_type, NULL_TREE, bitsize_zero_node, 1, 0);\n \n-\t  /* Do not emit debug info until after the parallel type is added.  */\n+\t  /* We will output additional debug info manually below.  */\n \t  finish_record_type (gnu_type, gnu_field, 2, false);\n \t  compute_record_mode (gnu_type);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n@@ -1920,8 +1918,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t implementation type, the padded type is its debug type.  */\n \t      if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\tSET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n-\n-\t      rest_of_record_type_compilation (gnu_type);\n \t    }\n \t}\n \n@@ -1946,9 +1942,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  gnu_field_type = gnu_type;\n \n \t  gnu_type = make_node (RECORD_TYPE);\n+\t  TYPE_PADDING_P (gnu_type) = 1;\n \t  TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"PAD\");\n-\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    SET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n \t  TYPE_PACKED (gnu_type) = 1;\n \t  TYPE_SIZE (gnu_type) = TYPE_SIZE (gnu_field_type);\n \t  TYPE_SIZE_UNIT (gnu_type) = TYPE_SIZE_UNIT (gnu_field_type);\n@@ -1964,9 +1959,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t gnu_type, TYPE_SIZE (gnu_field_type),\n \t\t\t\t bitsize_zero_node, 0, 0);\n \n-\t  finish_record_type (gnu_type, gnu_field, 2, debug_info_p);\n+\t  finish_record_type (gnu_type, gnu_field, 2, false);\n \t  compute_record_mode (gnu_type);\n-\t  TYPE_PADDING_P (gnu_type) = 1;\n+\n+\t  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    SET_TYPE_DEBUG_TYPE (gnu_type, gnu_field_type);\n \t}\n \n       break;\n@@ -1986,7 +1983,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && !In_Extended_Main_Code_Unit (Ancestor_Subtype (gnat_entity))\n \t  && (!Compile_Time_Known_Value (Type_Low_Bound (gnat_entity))\n \t      || !Compile_Time_Known_Value (Type_High_Bound (gnat_entity))))\n-\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, 0);\n+\tgnat_to_gnu_entity (Ancestor_Subtype (gnat_entity), gnu_expr, false);\n \n       gnu_type = make_node (REAL_TYPE);\n       TREE_TYPE (gnu_type) = get_unpadded_type (Etype (gnat_entity));\n@@ -2739,7 +2736,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      else\n \t\t{\n \t\t  tree gnu_base_decl\n-\t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, 0);\n+\t\t    = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE,\n+\t\t\t\t\t  false);\n \t\t  if (!DECL_ARTIFICIAL (gnu_base_decl)\n \t\t      && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n \t\t    add_parallel_type (gnu_type,\n@@ -2812,7 +2810,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      gnu_decl\n \t\t= gnat_to_gnu_entity (Packed_Array_Impl_Type (gnat_entity),\n-\t\t\t\t      NULL_TREE, 0);\n+\t\t\t\t      NULL_TREE, false);\n \t      this_made_decl = true;\n \t      gnu_type = TREE_TYPE (gnu_decl);\n \n@@ -3114,7 +3112,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif (definition)\n \t\t  gcc_assert (present_gnu_tree (gnat_uview));\n \t\telse\n-\t\t  gnat_to_gnu_entity (gnat_uview, NULL_TREE, 0);\n+\t\t  gnat_to_gnu_entity (gnat_uview, NULL_TREE, false);\n \n \t\tgnu_parent = gnat_to_gnu_type (Parent_Subtype (gnat_uview));\n \n@@ -3277,7 +3275,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tgnu_discr_type = gnat_to_gnu_type (Etype (gnat_discr));\n \t\tgnu_ref\n \t\t  = gnat_to_gnu_entity (Original_Record_Component (gnat_discr),\n-\t\t\t\t\tNULL_TREE, 0);\n+\t\t\t\t\tNULL_TREE, false);\n \n \t\t/* GNU_REF must be an expression using a PLACEHOLDER_EXPR built\n \t\t   just above for one of the stored discriminants.  */\n@@ -3321,7 +3319,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       || Ekind (gnat_temp) == E_Discriminant)\n \t      && Is_Itype (Etype (gnat_temp))\n \t      && !present_gnu_tree (gnat_temp))\n-\t    gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n+\t    gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n \n \t/* If this is a record type associated with an exception definition,\n \t   equate its fields to those of the standard exception type.  This\n@@ -3346,7 +3344,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t since it may have constraints.  */\n       if (gnat_equiv_type != gnat_entity)\n \t{\n-\t  gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, 0);\n+\t  gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, false);\n \t  maybe_present = true;\n \t  break;\n \t}\n@@ -3361,7 +3359,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       if (Present (Cloned_Subtype (gnat_entity)))\n \t{\n \t  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),\n-\t\t\t\t\t NULL_TREE, 0);\n+\t\t\t\t\t NULL_TREE, false);\n \t  maybe_present = true;\n \t  break;\n \t}\n@@ -3700,10 +3698,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tif ((Ekind (gnat_field) == E_Discriminant\n \t\t     || Ekind (gnat_field) == E_Component)\n \t\t    && !present_gnu_tree (Etype (gnat_field)))\n-\t\t  gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, 0);\n+\t\t  gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, false);\n \n-\t      /* Do not emit debug info for the type yet since we're going to\n-\t\t modify it below.  */\n+\t      /* We will output additional debug info manually below.  */\n \t      finish_record_type (gnu_type, nreverse (gnu_field_list), 2,\n \t\t\t\t  false);\n \t      compute_record_mode (gnu_type);\n@@ -3749,9 +3746,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      gnu_variant_list.release ();\n \t      gnu_subst_list.release ();\n-\n-\t      /* Now we can finalize it.  */\n-\t      rest_of_record_type_compilation (gnu_type);\n \t    }\n \n \t  /* Otherwise, go down all the components in the new type and make\n@@ -4084,7 +4078,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && No (Freeze_Node (Directly_Designated_Type (gnat_entity)))\n \t  && !Is_Record_Type (Scope (Directly_Designated_Type (gnat_entity))))\n \tgnat_to_gnu_entity (Directly_Designated_Type (gnat_entity),\n-\t\t\t    NULL_TREE, 0);\n+\t\t\t    NULL_TREE, false);\n \n       break;\n \n@@ -4125,7 +4119,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t       (Directly_Designated_Type (gnat_entity))),\n \t\t        Incomplete_Or_Private_Kind))\n \t    gnat_to_gnu_entity (Directly_Designated_Type (gnat_entity),\n-\t\t\t\tNULL_TREE, 0);\n+\t\t\t\tNULL_TREE, false);\n \t}\n \n       maybe_present = true;\n@@ -4246,16 +4240,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    const Entity_Id gnat_renamed = Renamed_Object (gnat_entity);\n \n \t    if (Ekind (Alias (gnat_entity)) == E_Enumeration_Literal)\n-\t      gnat_to_gnu_entity (Etype (Alias (gnat_entity)), NULL_TREE, 0);\n+\t      gnat_to_gnu_entity (Etype (Alias (gnat_entity)), NULL_TREE,\n+\t\t\t\t  false);\n \n-\t    gnu_decl = gnat_to_gnu_entity (Alias (gnat_entity), gnu_expr, 0);\n+\t    gnu_decl\n+\t      = gnat_to_gnu_entity (Alias (gnat_entity), gnu_expr, false);\n \n \t    /* Elaborate any Itypes in the parameters of this entity.  */\n \t    for (gnat_temp = First_Formal_With_Extras (gnat_entity);\n \t\t Present (gnat_temp);\n \t\t gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \t      if (Is_Itype (Etype (gnat_temp)))\n-\t\tgnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n+\t\tgnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n \n \t    /* Materialize renamed subprograms in the debugging information\n \t       when the renamed object is compile time known.  We can consider\n@@ -4419,11 +4415,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      {\n \t\tpost_error (\"cannot return type whose size overflows\",\n \t\t\t    gnat_entity);\n-\t\tgnu_return_type = copy_node (gnu_return_type);\n+\t\tgnu_return_type = copy_type (gnu_return_type);\n \t\tTYPE_SIZE (gnu_return_type) = bitsize_zero_node;\n \t\tTYPE_SIZE_UNIT (gnu_return_type) = size_zero_node;\n-\t\tTYPE_MAIN_VARIANT (gnu_return_type) = gnu_return_type;\n-\t\tTYPE_NEXT_VARIANT (gnu_return_type) = NULL_TREE;\n \t      }\n \t  }\n \n@@ -4812,8 +4806,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      }\n \t    else\n \t      {\n-\t\tgnu_decl = gnat_to_gnu_entity (Etype (gnat_entity),\n-\t\t\t\t\t       NULL_TREE, 0);\n+\t\tgnu_decl\n+\t\t  = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, false);\n \t\tmaybe_present = true;\n \t      }\n \t    break;\n@@ -4838,7 +4832,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t || (is_from_limited_with\n \t\t     && !In_Extended_Main_Code_Unit (full_view)))\n \t  {\n-\t    gnu_decl = gnat_to_gnu_entity (full_view, NULL_TREE, 0);\n+\t    gnu_decl = gnat_to_gnu_entity (full_view, NULL_TREE, false);\n \t    maybe_present = true;\n \t    break;\n \t  }\n@@ -4856,7 +4850,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n     case E_Class_Wide_Type:\n       /* Class-wide types are always transformed into their root type.  */\n-      gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, 0);\n+      gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, false);\n       maybe_present = true;\n       break;\n \n@@ -4907,7 +4901,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n       /* Concurrent types are always transformed into their record type.  */\n       else\n-\tgnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, 0);\n+\tgnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, false);\n       maybe_present = true;\n       break;\n \n@@ -5480,7 +5474,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       && Is_Itype (Original_Array_Type (gnat_entity))\n       && No (Freeze_Node (Original_Array_Type (gnat_entity)))\n       && !present_gnu_tree (Original_Array_Type (gnat_entity)))\n-    gnat_to_gnu_entity (Original_Array_Type (gnat_entity), NULL_TREE, 0);\n+    gnat_to_gnu_entity (Original_Array_Type (gnat_entity), NULL_TREE, false);\n \n   return gnu_decl;\n }\n@@ -5491,7 +5485,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n tree\n gnat_to_gnu_field_decl (Entity_Id gnat_entity)\n {\n-  tree gnu_field = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+  tree gnu_field = gnat_to_gnu_entity (gnat_entity, NULL_TREE, false);\n \n   if (TREE_CODE (gnu_field) == COMPONENT_REF)\n     gnu_field = TREE_OPERAND (gnu_field, 1);\n@@ -5511,7 +5505,7 @@ gnat_to_gnu_type (Entity_Id gnat_entity)\n   if (Is_Generic_Type (gnat_entity) && type_annotate_only)\n      return void_type_node;\n \n-  gnu_decl = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+  gnu_decl = gnat_to_gnu_entity (gnat_entity, NULL_TREE, false);\n   gcc_assert (TREE_CODE (gnu_decl) == TYPE_DECL);\n \n   return TREE_TYPE (gnu_decl);\n@@ -5703,8 +5697,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   tree gnu_comp_size;\n \n   /* Try to get a smaller form of the component if needed.  */\n-  if ((Is_Packed (gnat_array)\n-       || Has_Component_Size_Clause (gnat_array))\n+  if ((Is_Packed (gnat_array) || Has_Component_Size_Clause (gnat_array))\n       && !Is_Bit_Packed_Array (gnat_array)\n       && !Has_Aliased_Components (gnat_array)\n       && !Strict_Alignment (gnat_type)"}, {"sha": "4fb2fc4f447e050ba8dc8f65f55d88aa1cbcca4a", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -34,14 +34,12 @@\n    initial value (in GCC tree form). This is optional for variables.\n    For renamed entities, GNU_EXPR gives the object being renamed.\n \n-   DEFINITION is nonzero if this call is intended for a definition.  This is\n-   used for separate compilation where it necessary to know whether an\n-   external declaration or a definition should be created if the GCC equivalent\n-   was not created previously.  The value of 1 is normally used for a nonzero\n-   DEFINITION, but a value of 2 is used in special circumstances, defined in\n-   the code.  */\n+   DEFINITION is true if this call is intended for a definition.  This is used\n+   for separate compilation where it is necessary to know whether an external\n+   declaration or a definition must be created if the GCC equivalent was not\n+   created previously.  */\n extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n-                                int definition);\n+                                bool definition);\n \n /* Similar, but if the returned value is a COMPONENT_REF, return the\n    FIELD_DECL.  */\n@@ -148,7 +146,8 @@ extern tree make_type_from_size (tree type, tree size_tree, bool for_biased);\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n    an array.  IS_USER_TYPE is true if the original type needs to be completed.\n    DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n-   the RM size of the resulting type is to be set to SIZE too.  */\n+   the RM size of the resulting type is to be set to SIZE too; in this case,\n+   the padded type is canonicalized before being returned.  */\n extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t    Entity_Id gnat_entity, bool is_component_type,\n \t\t\t    bool is_user_type, bool definition,\n@@ -620,14 +619,13 @@ extern void finish_fat_pointer_type (tree record_type, tree field_list);\n    laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n    this record is derived from a parent record and thus inherits its layout;\n    only make a pass on the fields to finalize them.  DEBUG_INFO_P is true if\n-   we need to write debug information about this type.  */\n+   additional debug info needs to be output for this type.  */\n extern void finish_record_type (tree record_type, tree field_list,\n \t\t\t\tint rep_level, bool debug_info_p);\n \n-/* Wrap up compilation of RECORD_TYPE, i.e. output all the debug information\n-   associated with it.  It need not be invoked directly in most cases since\n-   finish_record_type takes care of doing so, but this can be necessary if\n-   a parallel type is to be attached to the record type.  */\n+/* Wrap up compilation of RECORD_TYPE, i.e. output additional debug info\n+   associated with it.  It need not be invoked directly in most cases as\n+   finish_record_type takes care of doing so.  */\n extern void rest_of_record_type_compilation (tree record_type);\n \n /* Append PARALLEL_TYPE on the chain of parallel types for TYPE.  */"}, {"sha": "e6442a8b44c9c8155a2e38f0450a06ea7baa4561", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -1120,7 +1120,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       gnu_result = gnat_to_gnu (Expression (Declaration_Node (gnat_temp)));\n     }\n   else\n-    gnu_result = gnat_to_gnu_entity (gnat_temp, NULL_TREE, 0);\n+    gnu_result = gnat_to_gnu_entity (gnat_temp, NULL_TREE, false);\n \n   /* Some objects (such as parameters passed by reference, globals of\n      variable size, and renamed objects) actually represent the address\n@@ -3027,7 +3027,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n \tgnu_loop_iv = NULL_TREE;\n \n       /* Declare the iteration variable and set it to its initial value.  */\n-      gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, 1);\n+      gnu_loop_var = gnat_to_gnu_entity (gnat_loop_var, gnu_first, true);\n       if (DECL_BY_REF_P (gnu_loop_var))\n \tgnu_loop_var = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_loop_var);\n       else if (use_iv)\n@@ -3792,7 +3792,7 @@ Subprogram_Body_to_gnu (Node_Id gnat_node)\n \t      gnu_cico_entry = TREE_CHAIN (gnu_cico_entry);\n \n \t    /* Do any needed dereferences for by-ref objects.  */\n-\t    gnu_decl = gnat_to_gnu_entity (gnat_param, NULL_TREE, 1);\n+\t    gnu_decl = gnat_to_gnu_entity (gnat_param, NULL_TREE, true);\n \t    gcc_assert (DECL_P (gnu_decl));\n \t    if (DECL_BY_REF_P (gnu_decl))\n \t      gnu_decl = build_unary_op (INDIRECT_REF, NULL_TREE, gnu_decl);\n@@ -5193,7 +5193,7 @@ Exception_Handler_to_gnu_fe_sjlj (Node_Id gnat_node)\n \t  if (Present (Renamed_Object (gnat_ex_id)))\n \t    gnat_ex_id = Renamed_Object (gnat_ex_id);\n \n-\t  gnu_expr = gnat_to_gnu_entity (gnat_ex_id, NULL_TREE, 0);\n+\t  gnu_expr = gnat_to_gnu_entity (gnat_ex_id, NULL_TREE, false);\n \n \t  this_choice\n \t    = build_binary_op\n@@ -5248,7 +5248,7 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n \t  if (Present (Renamed_Object (gnat_ex_id)))\n \t    gnat_ex_id = Renamed_Object (gnat_ex_id);\n \n-\t  gnu_expr = gnat_to_gnu_entity (gnat_ex_id, NULL_TREE, 0);\n+\t  gnu_expr = gnat_to_gnu_entity (gnat_ex_id, NULL_TREE, false);\n \t  gnu_etype = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);\n \t}\n       else\n@@ -5303,7 +5303,7 @@ Exception_Handler_to_gnu_gcc (Node_Id gnat_node)\n   if (Present (Choice_Parameter (gnat_node)))\n     {\n       tree gnu_param\n-\t= gnat_to_gnu_entity (Choice_Parameter (gnat_node), NULL_TREE, 1);\n+\t= gnat_to_gnu_entity (Choice_Parameter (gnat_node), NULL_TREE, true);\n \n       add_stmt (build_call_n_expr\n \t\t(set_exception_parameter_decl, 2,\n@@ -5406,7 +5406,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n \t}\n \n       /* Define the entity first so we set DECL_EXTERNAL.  */\n-      gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+      gnat_to_gnu_entity (gnat_entity, NULL_TREE, false);\n       add_stmt (gnat_to_gnu (gnat_body));\n     }\n \n@@ -6045,7 +6045,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    }\n \t}\n       else\n-\tgnat_to_gnu_entity (gnat_temp, gnu_expr, 1);\n+\tgnat_to_gnu_entity (gnat_temp, gnu_expr, true);\n       break;\n \n     case N_Object_Renaming_Declaration:\n@@ -6063,7 +6063,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  tree gnu_temp\n \t    = gnat_to_gnu_entity (gnat_temp,\n-\t\t\t\t  gnat_to_gnu (Renamed_Object (gnat_temp)), 1);\n+\t\t\t\t  gnat_to_gnu (Renamed_Object (gnat_temp)),\n+\t\t\t\t  true);\n \t  /* See case 2 of renaming in gnat_to_gnu_entity.  */\n \t  if (TREE_SIDE_EFFECTS (gnu_temp))\n \t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n@@ -6079,7 +6080,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  tree gnu_temp\n \t    = gnat_to_gnu_entity (gnat_temp,\n-\t\t\t\t  gnat_to_gnu (Renamed_Entity (gnat_temp)), 1);\n+\t\t\t\t  gnat_to_gnu (Renamed_Entity (gnat_temp)),\n+\t\t\t\t  true);\n \t  if (TREE_SIDE_EFFECTS (gnu_temp))\n \t    gnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_temp);\n \t}\n@@ -6109,12 +6111,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t|| Ekind (gnat_renamed) == E_Procedure)\n \t    && !Is_Intrinsic_Subprogram (gnat_renaming)\n \t    && !Is_Intrinsic_Subprogram (gnat_renamed))\n-\t  gnat_to_gnu_entity (gnat_renaming, gnat_to_gnu (gnat_renamed), 1);\n+\t  gnat_to_gnu_entity (gnat_renaming, gnat_to_gnu (gnat_renamed), true);\n \tbreak;\n       }\n \n     case N_Implicit_Label_Declaration:\n-      gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, 1);\n+      gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, true);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7146,7 +7148,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n \tgnat_to_gnu_entity (Defining_Entity (Specification (gnat_node)),\n-\t\t\t    NULL_TREE, 1);\n+\t\t\t    NULL_TREE, true);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7168,15 +7170,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   gnat_temp = Next_Formal_With_Extras (gnat_temp))\n \tif (Is_Itype (Etype (gnat_temp))\n \t    && !From_Limited_With (Etype (gnat_temp)))\n-\t  gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, 0);\n+\t  gnat_to_gnu_entity (Etype (gnat_temp), NULL_TREE, false);\n \n       /* Then the result type, set to Standard_Void_Type for procedures.  */\n       {\n \tEntity_Id gnat_temp_type\n \t  = Etype (Defining_Entity (Specification (gnat_node)));\n \n \tif (Is_Itype (gnat_temp_type) && !From_Limited_With (gnat_temp_type))\n-\t  gnat_to_gnu_entity (Etype (gnat_temp_type), NULL_TREE, 0);\n+\t  gnat_to_gnu_entity (Etype (gnat_temp_type), NULL_TREE, false);\n       }\n \n       gnu_result = alloc_stmt_list ();\n@@ -7253,7 +7255,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Single_Task_Declaration:\n-      gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, 1);\n+      gnat_to_gnu_entity (Defining_Entity (gnat_node), NULL_TREE, true);\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -7864,7 +7866,7 @@ static void\n push_exception_label_stack (vec<tree, va_gc> **gnu_stack, Entity_Id gnat_label)\n {\n   tree gnu_label = (Present (gnat_label)\n-\t\t    ? gnat_to_gnu_entity (gnat_label, NULL_TREE, 0)\n+\t\t    ? gnat_to_gnu_entity (gnat_label, NULL_TREE, false)\n \t\t    : NULL_TREE);\n \n   vec_safe_push (*gnu_stack, gnu_label);\n@@ -8470,7 +8472,7 @@ elaborate_all_entities_for_package (Entity_Id gnat_package)\n \t    elaborate_all_entities_for_package (gnat_entity);\n \t}\n       else\n-\tgnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+\tgnat_to_gnu_entity (gnat_entity, NULL_TREE, false);\n     }\n }\n \n@@ -8628,7 +8630,7 @@ process_freeze_entity (Node_Id gnat_node)\n \t  && Present (Underlying_Full_View (full_view)))\n \tfull_view = Underlying_Full_View (full_view);\n \n-      gnu_new = gnat_to_gnu_entity (full_view, NULL_TREE, 1);\n+      gnu_new = gnat_to_gnu_entity (full_view, NULL_TREE, true);\n \n       /* Propagate back-annotations from full view to partial view.  */\n       if (Unknown_Alignment (gnat_entity))\n@@ -8653,7 +8655,7 @@ process_freeze_entity (Node_Id gnat_node)\n \t   && present_gnu_tree (Declaration_Node (gnat_entity)))\n \t  ? get_gnu_tree (Declaration_Node (gnat_entity)) : NULL_TREE;\n \n-      gnu_new = gnat_to_gnu_entity (gnat_entity, gnu_init, 1);\n+      gnu_new = gnat_to_gnu_entity (gnat_entity, gnu_init, true);\n     }\n \n   if (IN (kind, Type_Kind)\n@@ -8745,7 +8747,7 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \n \t\t    if (Ekind (gnat_subprog_id) != E_Generic_Procedure\n \t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n-\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, 1);\n+\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, true);\n \t\t  }\n \t      }\n \n@@ -8760,7 +8762,7 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t    if (Ekind (gnat_subprog_id) != E_Subprogram_Body\n \t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Procedure\n \t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n-\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, 1);\n+\t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, true);\n \t      }\n \n \t    /* Concurrent stubs stand for the corresponding subprogram bodies,\n@@ -9509,7 +9511,7 @@ process_type (Entity_Id gnat_entity)\n     }\n \n   /* Now fully elaborate the type.  */\n-  gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 1);\n+  gnu_new = gnat_to_gnu_entity (gnat_entity, NULL_TREE, true);\n   gcc_assert (TREE_CODE (gnu_new) == TYPE_DECL);\n \n   /* If we have an old type and we've made pointers to this type, update those"}, {"sha": "db38701b43698f2eb193b72d7cc2bc3866203adf", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -239,17 +239,24 @@ static tree convert_to_fat_pointer (tree, tree);\n static unsigned int scale_by_factor_of (tree, unsigned int);\n static bool potential_alignment_gap (tree, tree, tree);\n \n-/* A linked list used as a queue to defer the initialization of the\n-   DECL_CONTEXT attribute of ..._DECL nodes and of the TYPE_CONTEXT attribute\n-   of ..._TYPE nodes.  */\n+/* Linked list used as a queue to defer the initialization of the DECL_CONTEXT\n+   of ..._DECL nodes and of the TYPE_CONTEXT of ..._TYPE nodes.  */\n struct deferred_decl_context_node\n {\n-  tree decl;\t\t    /* The ..._DECL node to work on.  */\n-  Entity_Id gnat_scope;     /* The corresponding entity's Scope attribute.  */\n-  int force_global;\t    /* force_global value when pushing DECL. */\n-  vec<tree, va_heap, vl_ptr> types;\t    /* A list of ..._TYPE nodes to propagate the\n-\t\t\t       context to.  */\n-  struct deferred_decl_context_node *next;  /* The next queue item.  */\n+  /* The ..._DECL node to work on.  */\n+  tree decl;\n+\n+  /* The corresponding entity's Scope.  */\n+  Entity_Id gnat_scope;\n+\n+  /* The value of force_global when DECL was pushed.  */\n+  int force_global;\n+\n+  /* The list of ..._TYPE nodes to propagate the context to.  */\n+  vec<tree> types;\n+\n+  /* The next queue item.  */\n+  struct deferred_decl_context_node *next;\n };\n \n static struct deferred_decl_context_node *deferred_decl_context_queue = NULL;\n@@ -1217,7 +1224,8 @@ lookup_and_insert_pad_type (tree type)\n    IS_COMPONENT_TYPE is true if this is being done for the component type of\n    an array.  IS_USER_TYPE is true if the original type needs to be completed.\n    DEFINITION is true if this type is being defined.  SET_RM_SIZE is true if\n-   the RM size of the resulting type is to be set to SIZE too.  */\n+   the RM size of the resulting type is to be set to SIZE too; in this case,\n+   the padded type is canonicalized before being returned.  */\n \n tree\n maybe_pad_type (tree type, tree size, unsigned int align,\n@@ -1280,8 +1288,6 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n      type and name.  */\n   record = make_node (RECORD_TYPE);\n   TYPE_PADDING_P (record) = 1;\n-  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-    SET_TYPE_DEBUG_TYPE (record, type);\n \n   /* ??? Padding types around packed array implementation types will be\n      considered as root types in the array descriptor language hook (see\n@@ -1337,9 +1343,12 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t\t\t     bitsize_zero_node, 0, 1);\n   DECL_INTERNAL_P (field) = 1;\n \n-  /* Do not emit debug info until after the auxiliary record is built.  */\n+  /* We will output additional debug info manually below.  */\n   finish_record_type (record, field, 1, false);\n \n+  if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n+    SET_TYPE_DEBUG_TYPE (record, type);\n+\n   /* Set the RM size if requested.  */\n   if (set_rm_size)\n     {\n@@ -1409,8 +1418,6 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t}\n     }\n \n-  rest_of_record_type_compilation (record);\n-\n built:\n   /* If a simple size was explicitly given, maybe issue a warning.  */\n   if (!size\n@@ -1672,7 +1679,7 @@ finish_fat_pointer_type (tree record_type, tree field_list)\n    laid out already; only set the sizes and alignment.  If REP_LEVEL is two,\n    this record is derived from a parent record and thus inherits its layout;\n    only make a pass on the fields to finalize them.  DEBUG_INFO_P is true if\n-   we need to write debug information about this type.  */\n+   additional debug info needs to be output for this type.  */\n \n void\n finish_record_type (tree record_type, tree field_list, int rep_level,\n@@ -1927,10 +1934,9 @@ has_parallel_type (tree type)\n   return DECL_PARALLEL_TYPE (decl) != NULL_TREE;\n }\n \n-/* Wrap up compilation of RECORD_TYPE, i.e. output all the debug information\n-   associated with it.  It need not be invoked directly in most cases since\n-   finish_record_type takes care of doing so, but this can be necessary if\n-   a parallel type is to be attached to the record type.  */\n+/* Wrap up compilation of RECORD_TYPE, i.e. output additional debug info\n+   associated with it.  It need not be invoked directly in most cases as\n+   finish_record_type takes care of doing so.  */\n \n void\n rest_of_record_type_compilation (tree record_type)\n@@ -2072,7 +2078,7 @@ rest_of_record_type_compilation (tree record_type)\n \t      field_type = build_pointer_type (field_type);\n \t      if (align != 0 && TYPE_ALIGN (field_type) > align)\n \t\t{\n-\t\t  field_type = copy_node (field_type);\n+\t\t  field_type = copy_type (field_type);\n \t\t  SET_TYPE_ALIGN (field_type, align);\n \t\t}\n \t      var = true;\n@@ -2284,10 +2290,10 @@ copy_type (tree type)\n      aliased with TREE_CHAIN.  */\n   TYPE_STUB_DECL (new_type) = TYPE_STUB_DECL (type);\n \n-  TYPE_POINTER_TO (new_type) = 0;\n-  TYPE_REFERENCE_TO (new_type) = 0;\n+  TYPE_POINTER_TO (new_type) = NULL_TREE;\n+  TYPE_REFERENCE_TO (new_type) = NULL_TREE;\n   TYPE_MAIN_VARIANT (new_type) = new_type;\n-  TYPE_NEXT_VARIANT (new_type) = 0;\n+  TYPE_NEXT_VARIANT (new_type) = NULL_TREE;\n   TYPE_CANONICAL (new_type) = new_type;\n \n   return new_type;\n@@ -3431,14 +3437,14 @@ gnat_signed_or_unsigned_type_for (int unsignedp, tree type_node)\n \n   if (TREE_CODE (type_node) == INTEGER_TYPE && TYPE_MODULAR_P (type_node))\n     {\n-      type = copy_node (type);\n+      type = copy_type (type);\n       TREE_TYPE (type) = type_node;\n     }\n   else if (TREE_TYPE (type_node)\n \t   && TREE_CODE (TREE_TYPE (type_node)) == INTEGER_TYPE\n \t   && TYPE_MODULAR_P (TREE_TYPE (type_node)))\n     {\n-      type = copy_node (type);\n+      type = copy_type (type);\n       TREE_TYPE (type) = TREE_TYPE (type_node);\n     }\n "}, {"sha": "d5dd436d48e5a8091207ba46f40992bdcaf8e88d", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc737f05213af90e74b1b62efe4039dbc3a7fc2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=afc737f05213af90e74b1b62efe4039dbc3a7fc2", "patch": "@@ -560,8 +560,8 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   if (TYPE_PRECISION (op_type) < precision\n       || TYPE_UNSIGNED (op_type) != unsignedp)\n     {\n-      /* Copy the node so we ensure it can be modified to make it modular.  */\n-      op_type = copy_node (gnat_type_for_size (precision, unsignedp));\n+      /* Copy the type so we ensure it can be modified to make it modular.  */\n+      op_type = copy_type (gnat_type_for_size (precision, unsignedp));\n       modulus = convert (op_type, modulus);\n       SET_TYPE_MODULUS (op_type, modulus);\n       TYPE_MODULAR_P (op_type) = 1;\n@@ -577,7 +577,8 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n      possible size.  */\n   if (op_code == MULT_EXPR)\n     {\n-      tree div_type = copy_node (gnat_type_for_size (needed_precision, 1));\n+      /* Copy the type so we ensure it can be modified to make it modular.  */\n+      tree div_type = copy_type (gnat_type_for_size (needed_precision, 1));\n       modulus = convert (div_type, modulus);\n       SET_TYPE_MODULUS (div_type, modulus);\n       TYPE_MODULAR_P (div_type) = 1;\n@@ -1761,9 +1762,10 @@ build_goto_raise (tree label, int msg)\n   /* If Local_Raise is present, build Local_Raise (Exception'Identity).  */\n   if (Present (local_raise))\n     {\n-      tree gnu_local_raise = gnat_to_gnu_entity (local_raise, NULL_TREE, 0);\n+      tree gnu_local_raise\n+\t= gnat_to_gnu_entity (local_raise, NULL_TREE, false);\n       tree gnu_exception_entity\n-\t= gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, 0);\n+\t= gnat_to_gnu_entity (Get_RT_Exception_Entity (msg), NULL_TREE, false);\n       tree gnu_call\n \t= build_call_n_expr (gnu_local_raise, 1,\n \t\t\t     build_unary_op (ADDR_EXPR, NULL_TREE,"}]}