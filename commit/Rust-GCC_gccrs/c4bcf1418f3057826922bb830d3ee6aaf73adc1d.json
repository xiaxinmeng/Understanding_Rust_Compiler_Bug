{"sha": "c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRiY2YxNDE4ZjMwNTc4MjY5MjJiYjgzMGQzZWU2YWFmNzNhZGMxZA==", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@redhat.com", "date": "2003-10-25T18:41:45Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@gcc.gnu.org", "date": "2003-10-25T18:41:45Z"}, "message": "ClasspathToolkit.java: New abstract class.\n\n2003-10-14  Graydon Hoare  <graydon@redhat.com>\n\n\t* gnu/java/awt/ClasspathToolkit.java: New abstract class.\n\t* gnu/java/awt/peer/ClasspathFontPeer.java: New abstract class.\n\t* gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c:\n\tNew concrete implementation of ClasspathFontPeer, with native part.\n\t* gnu/java/awt/peer/gtk/GdkGlyphVector.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c:\n\tNew class, with native part.\n\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n\timplement setFont, cairoSetFont, drawGlyphVector, cairoShowGlyphs.\n\nFrom-SVN: r72931", "tree": {"sha": "a86497db03f846687cb8c6b5f16cc08c970a7a17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a86497db03f846687cb8c6b5f16cc08c970a7a17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/comments", "author": null, "committer": null, "parents": [{"sha": "11f9a0ed8f5cdd0214075bc8501a91c06a835d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11f9a0ed8f5cdd0214075bc8501a91c06a835d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11f9a0ed8f5cdd0214075bc8501a91c06a835d2a"}], "stats": {"total": 2582, "additions": 2568, "deletions": 14}, "files": [{"sha": "b628831f1e35932cb3ab971dc8a83543c5fb34db", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -1,3 +1,17 @@\n+2003-10-25  Graydon Hoare  <graydon@redhat.com>\n+\n+\t* gnu/java/awt/ClasspathToolkit.java: New abstract class.\n+\t* gnu/java/awt/peer/ClasspathFontPeer.java: New abstract class.\n+\t* gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c:\n+\tNew concrete implementation of ClasspathFontPeer, with native part.\n+\t* gnu/java/awt/peer/gtk/GdkGlyphVector.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c:\n+\tNew class, with native part.\n+\t* gnu/java/awt/peer/gtk/GdkGraphics2D.java,\n+\tjni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c:\n+\timplement setFont, cairoSetFont, drawGlyphVector, cairoShowGlyphs.\n+\n 2003-10-25  Bryce McKinlay  <bryce@mckinlay.net.nz>\n \n \t* java/lang/reflect/Method.java (toString): Avoid extra whitespace"}, {"sha": "91401f4d5a2bb3b03d74c89a0dc4c66016fa9f3a", "filename": "libjava/gnu/java/awt/ClasspathToolkit.java", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2FClasspathToolkit.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2FClasspathToolkit.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2FClasspathToolkit.java?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,334 @@\n+/* ClasspathToolkit.java -- Abstract superclass for Classpath toolkits.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt;\n+\n+import java.awt.Image;\n+import java.awt.Dimension;\n+import java.awt.DisplayMode;\n+import java.awt.Font;\n+import java.awt.FontFormatException;\n+import java.awt.FontMetrics;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.HeadlessException;\n+import java.awt.Toolkit;\n+import java.awt.image.ColorModel;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import gnu.java.awt.peer.ClasspathFontPeer;\n+\n+\n+/**\n+ * An abstract superclass for Classpath toolkits.\n+ *\n+ * <p>There exist some parts of AWT and Java2D that are specific to\n+ * the underlying platform, but for which the {@link Toolkit} class\n+ * does not provide suitable abstractions. Examples include some\n+ * methods of {@link Font} or {@link GraphicsEnvironment}. Those\n+ * methods use ClasspathToolkit as a central place for obtaining\n+ * platform-specific functionality.\n+ *\n+ * <p>In addition, ClasspathToolkit implements some abstract methods\n+ * of {@link java.awt.Toolkit} that are not really platform-specific,\n+ * such as the maintenance of a cache of loaded images.\n+ *\n+ * <p><b>Thread Safety:</b> The methods of this class may safely be\n+ * called without external synchronization. This also hold for any\n+ * inherited {@link Toolkit} methods. Subclasses are responsible for\n+ * the necessary synchronization.\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ */\n+public abstract class ClasspathToolkit\n+  extends Toolkit\n+{\n+  /**\n+   * A map from URLs to previously loaded images, used by {@link\n+   * #getImage(java.net.URL)}. For images that were loaded via a path\n+   * to an image file, the map contains a key with a file URL.\n+   */\n+  private Map imageCache;\n+\n+\n+  /**\n+   * Returns a shared instance of the local, platform-specific\n+   * graphics environment.\n+   *\n+   * <p>This method is specific to GNU Classpath. It gets called by\n+   * the Classpath implementation of {@link\n+   * GraphicsEnvironment.getLocalGraphcisEnvironment()}.\n+   */\n+  public abstract GraphicsEnvironment getLocalGraphicsEnvironment();\n+\n+\n+  /**\n+   * Determines the current size of the default, primary screen.\n+   *\n+   * @throws HeadlessException if the local graphics environment is\n+   * headless, which means that no screen is attached and no user\n+   * interaction is allowed.\n+   */\n+  public Dimension getScreenSize()\n+  {\n+    DisplayMode mode;\n+\n+    // getDefaultScreenDevice throws HeadlessException if the\n+    // local graphics environment is headless.\n+    mode = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+      .getDefaultScreenDevice().getDisplayMode();\n+\n+    return new Dimension(mode.getWidth(), mode.getHeight());\n+  }\n+\n+\n+  /**\n+   * Determines the current color model of the default, primary\n+   * screen.\n+   *\n+   * @see GraphicsEnvironment#getDefaultScreenDevice()\n+   * @see java.awt.GraphicsDevice#getDefaultConfiguration()\n+   * @see java.awt.GraphicsConfiguration#getColorModel()\n+   *\n+   * @throws HeadlessException if the local graphics environment is\n+   * headless, which means that no screen is attached and no user\n+   * interaction is allowed.\n+   */\n+  public ColorModel getColorModel()\n+  {\n+    // getDefaultScreenDevice throws HeadlessException if the\n+    // local graphics environment is headless.\n+    return GraphicsEnvironment.getLocalGraphicsEnvironment()\n+      .getDefaultScreenDevice().getDefaultConfiguration()\n+      .getColorModel();\n+  }\n+\n+  /**\n+   * Retrieves the metrics for rendering a font on the screen.\n+   *\n+   * @param font the font whose metrics are requested.\n+   */\n+  public FontMetrics getFontMetrics(Font font)\n+  {\n+    return ((ClasspathFontPeer) font.getPeer ()).getFontMetrics (font);\n+  }\n+\n+\n+  /**\n+   * Acquires an appropriate {@link ClasspathFontPeer}, for use in\n+   * classpath's implementation of {@link java.awt.Font}.\n+   *\n+   * @param name The logical name of the font. This may be either a face\n+   * name or a logical font name, or may even be null. A default\n+   * implementation of name decoding is provided in \n+   * {@link ClasspathFontPeer}, but may be overridden in other toolkits.\n+   *\n+   * @param attrs Any extra {@link java.awt.font.TextAttribute} attributes\n+   * this font peer should have, such as size, weight, family name, or\n+   * transformation.\n+   */\n+\n+  public abstract ClasspathFontPeer getClasspathFontPeer (String name, Map attrs); \n+\n+\n+  /** \n+   * Creates a {@link Font}, in a platform-specific manner.\n+   * \n+   * The default implementation simply constructs a {@link Font}, but some\n+   * toolkits may wish to override this, to return {@link Font} subclasses which\n+   * implement {@link java.awt.font.OpenType} or\n+   * {@link java.awt.font.MultipleMaster}.\n+   */\n+\n+  public Font getFont (String name, Map attrs) \n+  {\n+    return new Font (name, attrs);\n+  }\n+\n+\n+  /**\n+   * Creates a font, reading the glyph definitions from a stream.\n+   *\n+   * <p>This method provides the platform-specific implementation for\n+   * the static factory method {@link Font#createFont(int,\n+   * java.io.InputStream)}.\n+   *\n+   * @param format the format of the font data, such as {@link\n+   * Font#TRUETYPE_FONT}. An implementation may ignore this argument\n+   * if it is able to automatically recognize the font format from the\n+   * provided data.\n+   *\n+   * @param stream an input stream from where the font data is read\n+   * in. The stream will be advanced to the position after the font\n+   * data, but not closed.\n+   *\n+   * @throws IllegalArgumentException if <code>format</code> is\n+   * not supported.\n+   * \n+   * @throws FontFormatException if <code>stream</code> does not\n+   * contain data in the expected format, or if required tables are\n+   * missing from a font.\n+   *\n+   * @throws IOException if a problem occurs while reading in the\n+   * contents of <code>stream</code>.\n+   */\n+  public abstract Font createFont(int format, InputStream stream);\n+\n+\n+  /**\n+   * Returns an image from the specified file, which must be in a\n+   * recognized format. The set of recognized image formats may vary\n+   * from toolkit to toolkit.\n+   *\n+   * <p>This method maintains a cache for images. If an image has been\n+   * loaded from the same path before, the cached copy will be\n+   * returned. The implementation may hold cached copies for an\n+   * indefinite time, which can consume substantial resources with\n+   * large images. Users are therefore advised to use {@link\n+   * #createImage(java.lang.String)} instead.\n+   *\n+   * <p>The default implementation creates a file URL for the\n+   * specified path and invokes {@link #getImage(URL)}.\n+   *\n+   * @param path A path to the image file.\n+   *\n+   * @return IllegalArgumentException if <code>path</code> does not\n+   * designate a valid path.\n+   */\n+  public Image getImage(String path)\n+  {\n+    try\n+    {\n+      return getImage(new File(path).toURL());\n+    }\n+    catch (MalformedURLException muex)\n+    {\n+      throw (IllegalArgumentException) new IllegalArgumentException(path)\n+        .initCause(muex);\n+    }\n+  }\n+\n+\n+  /**\n+   * Loads an image from the specified URL. The image data must be in\n+   * a recognized format. The set of recognized image formats may vary\n+   * from toolkit to toolkit.\n+   *\n+   * <p>This method maintains a cache for images. If an image has been\n+   * loaded from the same URL before, the cached copy will be\n+   * returned. The implementation may hold cached copies for an\n+   * indefinite time, which can consume substantial resources with\n+   * large images. Users are therefore advised to use {@link\n+   * #createImage(java.net.URL)} instead.\n+   *\n+   * @param url the URL from where the image is read.\n+   */\n+  public Image getImage(URL url)\n+  {\n+    Image result;\n+\n+    synchronized (this)\n+    {\n+      // Many applications never call getImage. Therefore, we lazily\n+      // create the image cache when it is actually needed.\n+      if (imageCache == null)\n+        imageCache = new HashMap();\n+      else\n+      {\n+        result = (Image) imageCache.get(url);\n+        if (result != null)\n+          return result;\n+      }\n+\n+      // The createImage(URL) method, which is specified by\n+      // java.awt.Toolkit, is not implemented by this abstract class\n+      // because it is platform-dependent. Once Classpath has support\n+      // for the javax.imageio package, it might be worth considering\n+      // that toolkits provide native stream readers. Then, the class\n+      // ClasspathToolkit could provide a general implementation that\n+      // delegates the image format parsing to javax.imageio.\n+      result = createImage(url);\n+\n+      // It is not clear whether it would be a good idea to use weak\n+      // references here. The advantage would be reduced memory\n+      // consumption, since loaded images would not be kept\n+      // forever. But on VMs that frequently perform garbage\n+      // collection (which includes VMs with a parallel or incremental\n+      // collector), the image might frequently need to be re-loaded,\n+      // possibly over a slow network connection.\n+      imageCache.put(url, result);\n+\n+      return result;\n+    }\n+  }\n+\n+\n+  /**\n+   * Returns an image from the specified file, which must be in a\n+   * recognized format.  The set of recognized image formats may vary\n+   * from toolkit to toolkit.\n+   *\n+   * <p>A new image is created every time this method gets called,\n+   * even if the same path has been passed before.\n+   *\n+   * <p>The default implementation creates a file URL for the\n+   * specified path and invokes {@link #createImage(URL)}.\n+   *\n+   * @param path A path to the file to be read in.\n+   */\n+  public Image createImage(String path)\n+  {\n+    try\n+    {\n+      // The abstract method createImage(URL) is defined by\n+      // java.awt.Toolkit, but intentionally not implemented by\n+      // ClasspathToolkit because it is platform specific.\n+      return createImage(new File(path).toURL());\n+    }\n+    catch (MalformedURLException muex)\n+    {\n+      throw (IllegalArgumentException) new IllegalArgumentException(path)\n+        .initCause(muex);\n+    }\n+  }\n+}"}, {"sha": "3d151c89e8359a21baa46a3f5e3c74d870e563e1", "filename": "libjava/gnu/java/awt/peer/ClasspathFontPeer.java", "status": "added", "additions": 795, "deletions": 0, "changes": 795, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2FClasspathFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2FClasspathFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2FClasspathFontPeer.java?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,795 @@\n+/* ClasspathFontPeer.java -- Font peer used by GNU Classpath.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer;\n+\n+import java.awt.*;\n+import java.awt.peer.*;\n+import java.awt.font.*;\n+import java.awt.geom.*;\n+import java.text.*;\n+import java.util.*;\n+import gnu.java.awt.*;\n+\n+\n+/**\n+ * A peer for fonts that are used inside Classpath. The purpose of\n+ * this interface is to abstract from platform-specific font handling\n+ * in the Classpath implementation of java.awt.Font and related\n+ * classes.\n+ *\n+ * <p><b>State kept by the peer:</b> a peer is generated for each Font\n+ * object in the default implementation. If you wish to share peers between\n+ * fonts, you will need to subclass both ClasspathFontPeer and\n+ * {@link ClasspathToolKit}.\n+ * \n+ * <p><b>Thread Safety:</b> Methods of this interface may be called\n+ * from arbitrary threads at any time. Implementations of the\n+ * <code>ClasspathFontPeer</code> interface are required to perform\n+ * the necessary synchronization.\n+ *\n+ * @see java.awt.Font#getPeer\n+ * @see java.awt.Toolkit#getFontPeer\n+ *\n+ * @author Sascha Brawer (brawer@dandelis.ch)\n+ * @author Graydon Hoare (graydon@redhat.com)\n+ */\n+public abstract class ClasspathFontPeer\n+  implements FontPeer\n+{\n+\n+  /*************************************************************************/\n+  \n+  /*\n+   * Instance Variables\n+   */\n+  \n+  /**\n+   * The 3 names of this font. all fonts have 3 names, some of which\n+   * may be equal:\n+   *\n+   * logical -- name the font was constructed from\n+   * family  -- a designer or brand name (Helvetica)\n+   * face -- specific instance of a design (Helvetica Regular)\n+   *\n+   * @see isLogicalFontName \n+   */\n+  \n+  protected String logicalName;\n+  protected String familyName;\n+  protected String faceName;\n+  \n+  /**\n+   * The font style, which is a combination (by OR-ing) of the font style\n+   * constants PLAIN, BOLD and ITALIC, in this class.\n+   */\n+  protected int style;\n+  \n+  /**\n+   * The font point size. A point is 1/72 of an inch.\n+   */\n+  protected float size;\n+\n+  /**\n+   * The affine transformation the font is currently subject to.\n+   */\n+  protected AffineTransform transform;\n+\n+  protected static ClasspathToolkit tk()\n+  {\n+    return (ClasspathToolkit)(Toolkit.getDefaultToolkit ());\n+  }\n+\n+  /* \n+   * Confusingly, a Logical Font is a concept unrelated to\n+   * a Font's Logical Name. \n+   *\n+   * A Logical Font is one of 6 built-in, abstract font types\n+   * which must be supported by any java environment: SansSerif,\n+   * Serif, Monospaced, Dialog, and DialogInput. \n+   *\n+   * A Font's Logical Name is the name the font was constructed\n+   * from. This might be the name of a Logical Font, or it might\n+   * be the name of a Font Face.\n+   */\n+\n+  protected static boolean isLogicalFontName(String name)\n+  {\n+    String uname = name.toUpperCase ();\n+    return (uname.equals (\"SANSSERIF\") ||\n+            uname.equals (\"SERIF\") ||\n+            uname.equals (\"MONOSPACED\") ||\n+            uname.equals (\"DIALOG\") ||\n+            uname.equals (\"DIALOGINPUT\"));\n+  }\n+\n+  protected static String logicalFontNameToFaceName (String name)\n+  {\n+    String uname = name.toUpperCase ();\n+    if (uname.equals(\"SANSSERIF\"))\n+      return \"Helvetica\";\n+    else if (uname.equals (\"SERIF\"))\n+      return \"Times\";\n+    else if (uname.equals (\"MONOSPACED\"))\n+      return \"Courier\";\n+    else if (uname.equals (\"DIALOG\"))\n+      return \"Helvetica\";\n+    else if (uname.equals (\"DIALOGINPUT\"))\n+      return \"Helvetica\";\n+    else\n+      return \"Helvetica\";\n+  }\n+\n+  protected static String faceNameToFamilyName (String name)\n+  {\n+    return name;\n+  }\n+\n+  protected static void copyStyleToAttrs (int style, Map attrs)\n+  {\n+    if ((style & Font.BOLD) == Font.BOLD)\n+      attrs.put (TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);\n+    else\n+      attrs.put (TextAttribute.WEIGHT, TextAttribute.WEIGHT_REGULAR);\n+\n+    if ((style & Font.ITALIC) == Font.ITALIC)\n+      attrs.put (TextAttribute.POSTURE, TextAttribute.POSTURE_OBLIQUE);\n+    else\n+      attrs.put (TextAttribute.POSTURE, TextAttribute.POSTURE_REGULAR);\n+  }\n+\n+  protected static void copyFamilyToAttrs (String fam, Map attrs)\n+  {\n+    if (fam != null)\n+      attrs.put (TextAttribute.FAMILY, fam);\n+  }\n+  \n+  protected static void copySizeToAttrs (float size, Map attrs)\n+  {\n+    attrs.put (TextAttribute.SIZE, new Float (size));\n+  }\n+  \n+  protected static void copyTransformToAttrs (AffineTransform trans, Map attrs)\n+  {\n+    if (trans != null)\n+      attrs.put(TextAttribute.TRANSFORM, new TransformAttribute (trans));\n+  }\n+\n+\n+  protected void setStandardAttributes (String name, String family, int style, \n+                                        float size, AffineTransform trans)\n+  {\n+    this.logicalName = name;\n+\n+    if (isLogicalFontName (name))\n+      this.faceName = logicalFontNameToFaceName (name);\n+    else\n+      this.faceName = name;\n+\n+    if (family != null)\n+      this.familyName = family;\n+    else\n+      this.familyName = faceNameToFamilyName (faceName);\n+    \n+    this.style = style;\n+    this.size = size;\n+    this.transform = trans;\n+  }\n+\n+\n+  protected void setStandardAttributes (String name, Map attribs)\n+  {\n+    String family = this.familyName;\n+    AffineTransform trans = this.transform;\n+    float size = this.size;\n+    int style = this.style;\n+    \n+    if (attribs.containsKey (TextAttribute.FAMILY))\n+      family = (String) attribs.get (TextAttribute.FAMILY);\n+\n+    if (name == null)\n+      name = \"SansSerif\";\n+\n+    if (attribs.containsKey (TextAttribute.WEIGHT))\n+      {\n+        Float weight = (Float) attribs.get (TextAttribute.WEIGHT);\n+        if (weight.floatValue () >= TextAttribute.WEIGHT_BOLD.floatValue ())\n+          style += Font.BOLD;\n+      }\n+\n+    if (attribs.containsKey (TextAttribute.POSTURE))\n+      {\n+        Float posture = (Float) attribs.get (TextAttribute.POSTURE);\n+        if (posture.floatValue () >= TextAttribute.POSTURE_OBLIQUE.floatValue ())\n+          style += Font.ITALIC;\n+      }\n+\n+    if (attribs.containsKey (TextAttribute.SIZE))\n+      {\n+        Float sz = (Float) attribs.get (TextAttribute.SIZE);\n+        size = sz.floatValue ();\n+      }\n+\n+    if (attribs.containsKey (TextAttribute.TRANSFORM))\n+      {\n+        TransformAttribute ta = (TransformAttribute) \n+          attribs.get(TextAttribute.TRANSFORM);\n+        trans = ta.getTransform ();        \n+      }\n+\n+    setStandardAttributes (name, family, style, size, trans);\n+  }\n+\n+  protected void getStandardAttributes (Map attrs)\n+  {    \n+    copyFamilyToAttrs (this.familyName, attrs);\n+    copySizeToAttrs (this.size, attrs);\n+    copyStyleToAttrs (this.style, attrs);\n+    copyTransformToAttrs (this.transform, attrs);\n+  }\n+\n+\n+  /* Begin public API */\n+\n+  public ClasspathFontPeer (String name, Map attrs)\n+  {\n+    setStandardAttributes (name, attrs);\n+  }\n+\n+  public ClasspathFontPeer (String name, int style, int size)\n+  {\n+    setStandardAttributes (name, (String)null, style, \n+                           (float)size, (AffineTransform)null);\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getName}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public String getName (Font font) \n+  { \n+    return logicalName; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getFamily()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public String getFamily (Font font) \n+  { \n+    return familyName; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getFamily(Locale)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public String getFamily (Font font, Locale lc) \n+  { \n+    return familyName; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getFontName()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public String getFontName (Font font) \n+  { \n+    return faceName; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getFontName(Locale)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public String getFontName (Font font, Locale lc) \n+  { \n+    return faceName; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getSize}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public float getSize (Font font) \n+  { \n+    return size; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#isPlain}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  \n+  public boolean isPlain (Font font) \n+  { \n+    return style == Font.PLAIN; \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#isBold}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+  \n+  public boolean isBold (Font font) \n+  { \n+    return ((style & Font.BOLD) == Font.BOLD); \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#isItalic}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public boolean isItalic (Font font) \n+  { \n+    return ((style & Font.ITALIC) == Font.ITALIC); \n+  }\n+\n+  /** \n+   * Implementation of {@link Font#deriveFont(float)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public Font deriveFont (Font font, float size)\n+  {\n+    Map attrs = new HashMap ();\n+    getStandardAttributes (attrs);\n+    copySizeToAttrs (size, attrs);\n+    return tk().getFont (logicalName, attrs);\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#deriveFont(int)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public Font deriveFont (Font font, int style)\n+  {\n+    Map attrs = new HashMap ();\n+    getStandardAttributes (attrs);\n+    copyStyleToAttrs (style, attrs);\n+    return tk().getFont (logicalName, attrs);\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#deriveFont(int, AffineTransform)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public Font deriveFont (Font font, int style, AffineTransform t)\n+  {\n+    Map attrs = new HashMap ();\n+    getStandardAttributes (attrs);\n+    copyStyleToAttrs (style, attrs);\n+    copyTransformToAttrs (t, attrs);\n+    return tk().getFont (logicalName, attrs);\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#deriveFont(Map)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public Font deriveFont (Font font, Map attrs)\n+  {\n+    return tk().getFont (logicalName, attrs);\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getAttributes()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public Map getAttributes (Font font)\n+  {\n+    HashMap h = new HashMap ();\n+    getStandardAttributes (h);\n+    return h;\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getAvailableAttributes()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public AttributedCharacterIterator.Attribute[] getAvailableAttributes(Font font)\n+  {\n+    AttributedCharacterIterator.Attribute a[] = \n+      new AttributedCharacterIterator.Attribute[5];\n+    a[0] = TextAttribute.FAMILY;\n+    a[1] = TextAttribute.SIZE;\n+    a[2] = TextAttribute.POSTURE;\n+    a[3] = TextAttribute.WEIGHT;\n+    a[4] = TextAttribute.TRANSFORM;\n+    return a;\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getTransform()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public AffineTransform getTransform (Font font)\n+  {\n+    return transform;\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#isTransformed()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public boolean isTransformed (Font font)\n+  {\n+    return ! transform.isIdentity ();\n+  }\n+\n+  /** \n+   * Implementation of {@link Font#getItalicAngle()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public float getItalicAngle (Font font)\n+  {\n+    if ((style & Font.ITALIC) == Font.ITALIC)\n+      return TextAttribute.POSTURE_OBLIQUE.floatValue ();\n+    else\n+      return TextAttribute.POSTURE_REGULAR.floatValue ();\n+  }\n+\n+\n+  /** \n+   * Implementation of {@link Font#getStyle()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public int getStyle (Font font) \n+  { \n+    return style; \n+  }\n+\n+\n+\n+\n+  /* Remaining methods are abstract */\n+\n+  /** \n+   * Implementation of {@link Font#canDisplay(char)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract boolean canDisplay (Font font, char c);\n+\n+  /** \n+   * Implementation of {@link Font#canDisplay(String)},\n+   * {@link Font#canDisplay(char [], int, int)}, and\n+   * {@link Font#canDisplay(CharacterIterator, int, int)}.\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract int canDisplayUpTo (Font font, CharacterIterator i, int start, int limit);\n+\n+\n+  /**\n+   * Returns the name of this font face inside the family, for example\n+   * <i>&#x201c;Light&#x201d;</i>.\n+   *\n+   * <p>This method is currently not used by {@link Font}. However,\n+   * this name would be needed by any serious desktop publishing\n+   * application.\n+   *\n+   * @param font the font whose sub-family name is requested.\n+   *\n+   * @param locale the locale for which to localize the name.  If\n+   * <code>locale</code> is <code>null</code>, the returned name is\n+   * localized to the user&#x2019;s default locale.\n+   *\n+   * @return the name of the face inside its family, or\n+   * <code>null</code> if the font does not provide a sub-family name.\n+   */\n+\n+  public abstract String getSubFamilyName (Font font, Locale locale);\n+  \n+\n+  /** \n+   * Implementation of {@link Font#getPSName()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract String getPostScriptName (Font font);\n+\n+\n+  /** \n+   * Implementation of {@link Font#getNumGlyphs()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract int getNumGlyphs (Font font);\n+\n+\n+  /** \n+   * Implementation of {@link Font#getMissingGlyphCode()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract int getMissingGlyphCode (Font font);\n+\n+\n+  /** \n+   * Implementation of {@link Font#getBaselineFor(char)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract byte getBaselineFor (Font font, char c);\n+\n+\n+  /**\n+   * Returns a name for the specified glyph. This is useful for\n+   * generating PostScript or PDF files that embed some glyphs of a\n+   * font. If the implementation follows glyph naming conventions\n+   * specified by Adobe, search engines can extract the original text\n+   * from the generated PostScript and PDF files.\n+   *\n+   * <p>This method is currently not used by GNU Classpath. However,\n+   * it would be very useful for someone wishing to write a good\n+   * PostScript or PDF stream provider for the\n+   * <code>javax.print</code> package.\n+   *\n+   * <p><b>Names are not unique:</b> Under some rare circumstances,\n+   * the same name can be returned for different glyphs. It is\n+   * therefore recommended that printer drivers check whether the same\n+   * name has already been returned for antoher glyph, and make the\n+   * name unique by adding the string \".alt\" followed by the glyph\n+   * index.</p>\n+   *\n+   * <p>This situation would occur for an OpenType or TrueType font\n+   * that has a <code>post</code> table of format 3 and provides a\n+   * mapping from glyph IDs to Unicode sequences through a\n+   * <code>Zapf</code> table. If the same sequence of Unicode\n+   * codepoints leads to different glyphs (depending on contextual\n+   * position, for example, or on typographic sophistication level),\n+   * the same name would get synthesized for those glyphs. To avoid\n+   * this, the font peer would have to go through the names of all\n+   * glyphs, which would make this operation very inefficient with\n+   * large fonts.\n+   *\n+   * @param font the font containing the glyph whose name is\n+   * requested.\n+   *\n+   * @param glyphIndex the glyph whose name the caller wants to\n+   * retrieve.\n+   *\n+   * @return the glyph name, or <code>null</code> if a font does not\n+   * provide glyph names.\n+   */\n+\n+  public abstract String getGlyphName (Font font, int glyphIndex);\n+\n+\n+  /** \n+   * Implementation of {@link\n+   * Font#createGlyphVector(FontRenderContext, String)}, {@link\n+   * Font#createGlyphVector(FontRenderContext, char[])}, and {@link\n+   * Font#createGlyphVector(FontRenderContext, CharacterIterator)}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+\n+  public abstract GlyphVector createGlyphVector (Font font,\n+                                                 FontRenderContext frc,\n+                                                 CharacterIterator ci);\n+  \n+\n+  /** \n+   * Implementation of {@link Font#createGlyphVector(FontRenderContext,\n+   * int[])}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+\n+  public abstract GlyphVector createGlyphVector (Font font, \n+                                                 FontRenderContext ctx, \n+                                                 int[] glyphCodes);\n+\n+\n+  /** \n+   * Implementation of {@link Font#layoutGlyphVector(FontRenderContext,\n+   * char[], int, int, int)}.\n+   *\n+   * @param font the font object that the created GlyphVector will return\n+   * when it gets asked for its font. This argument is needed because the\n+   * public API of {@link GlyphVector} works with {@link java.awt.Font},\n+   * not with font peers.\n+   */\n+\n+  public abstract GlyphVector layoutGlyphVector (Font font, \n+                                                 FontRenderContext frc, \n+                                                 char[] chars, int start, \n+                                                 int limit, int flags);\n+\n+\n+  /** \n+   * Implementation of {@link Font#getFontMetrics()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract FontMetrics getFontMetrics (Font font);\n+\n+\n+  /** \n+   * Implementation of {@link Font#hasUniformLineMetrics()}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract boolean hasUniformLineMetrics (Font font);\n+\n+\n+  /** \n+   * Implementation of {@link Font#getLineMetrics(CharacterIterator, int,\n+   * int, FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract LineMetrics getLineMetrics (Font font, \n+                                              CharacterIterator ci, \n+                                              int begin, int limit, \n+                                              FontRenderContext rc);\n+\n+  /** \n+   * Implementation of {@link Font#getMaxCharBounds(FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract Rectangle2D getMaxCharBounds (Font font, \n+                                                FontRenderContext rc);\n+\n+  /** \n+   * Implementation of {@link Font#getStringBounds(CharacterIterator, int,\n+   * int, FontRenderContext)}\n+   *\n+   * @param font the font this peer is being called from. This may be\n+   * useful if you are sharing peers between Font objects. Otherwise it may\n+   * be ignored.\n+   */\n+\n+  public abstract Rectangle2D getStringBounds (Font font, \n+                                               CharacterIterator ci, \n+                                               int begin, int limit, \n+                                               FontRenderContext frc);\n+\n+}"}, {"sha": "7e317003d27799ddc589fadd64c32317e4a057d6", "filename": "libjava/gnu/java/awt/peer/gtk/GdkClasspathFontPeer.java", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkClasspathFontPeer.java?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,239 @@\n+/* GdkClasspathFontPeer.java -- backend implementation for Font object\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.*;\n+import java.awt.font.*;\n+import java.awt.geom.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.text.CharacterIterator;\n+import java.text.AttributedCharacterIterator;\n+import java.awt.font.TextAttribute;\n+import gnu.classpath.Configuration;\n+import gnu.java.awt.peer.ClasspathFontPeer;\n+\n+/**\n+ * This class represents a windowing system font using the Pango\n+ * unicode/glyph/font library and the Cairo rendering library.\n+ *\n+ * @author Graydon Hoare (graydon@redhat.com)\n+ */\n+\n+public class GdkClasspathFontPeer extends ClasspathFontPeer\n+{\n+  \n+  static \n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"gtkpeer\");\n+      }\n+    initStaticState ();\n+  }\n+  native static void initStaticState ();\n+  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+\n+\n+  /* Instance Variables */\n+\n+  private native void initState ();\n+  private native void dispose ();\n+  private native void setFont (String family, int style, int size);\n+\n+  protected void sync ()\n+  {\n+    this.setFont (this.familyName, this.style, (int)this.size);\n+  }\n+\n+  protected void finalize ()\n+  {\n+    dispose ();\n+  }\n+\n+  /* \n+   * Helpers for the 3-way overloading that this class seems to suffer\n+   * from. Remove them if you feel like they're a performance bottleneck,\n+   * for the time being I prefer my code not be written and debugged in\n+   * triplicate.\n+   */\n+\n+  private String buildString(CharacterIterator i) {\n+    String s = new String ();\n+    for(char c = i.first(); c != CharacterIterator.DONE; c = i.next()) \n+      s += c;\n+    return s;\n+  }\n+\n+  private String buildString(CharacterIterator iter, int begin, int limit) {\n+    String s = new String ();\n+    int i = 0;\n+    for(char c = iter.first(); c != CharacterIterator.DONE; c = iter.next(), i++) \n+      {\n+        if (begin <= i)\n+          s += c;\n+        if (limit <= i)\n+          break;\n+      }\n+    return s;\n+  }\n+  \n+  private String buildString(char[] chars, int begin, int limit) {\n+    String s = new String ();\n+    for(int i = begin; i <= limit; i++)\n+      s += chars[i];\n+    return s;\n+  }\n+\n+  /* Public API */\n+\n+  public GdkClasspathFontPeer (String name, int style, int size)\n+  {  \n+    super(name, style, size);    \n+    initState ();\n+    setFont (this.familyName, this.style, (int)this.size);\n+  }\n+\n+  public GdkClasspathFontPeer (String name, Map attributes)\n+  {\n+    super(name, attributes);\n+    initState ();\n+    setFont (this.familyName, this.style, (int)this.size);\n+  }\n+\n+  public String getSubFamilyName(Font font, Locale locale)\n+  {\n+    return null;\n+  }\n+\n+  public String getPostScriptName(Font font)\n+  {\n+    return null;\n+  }\n+\n+  public boolean canDisplay (Font font, char c)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public int canDisplayUpTo (Font font, CharacterIterator i, int start, int limit)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public GlyphVector createGlyphVector (Font font, \n+                                        FontRenderContext ctx, \n+                                        CharacterIterator i)\n+  {\n+    return new GdkGlyphVector(font, this, ctx, buildString (i));\n+  }\n+\n+  public GlyphVector createGlyphVector (Font font, \n+                                        FontRenderContext ctx, \n+                                        int[] glyphCodes)\n+  {\n+    return new GdkGlyphVector (font, this, ctx, glyphCodes);\n+  }\n+\n+  public byte getBaselineFor (Font font, char c)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public LineMetrics getLineMetrics (Font font, CharacterIterator ci, \n+                                     int begin, int limit, FontRenderContext rc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public Rectangle2D getMaxCharBounds (Font font, FontRenderContext rc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public int getMissingGlyphCode (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public String getGlyphName (Font font, int glyphIndex)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public int getNumGlyphs (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public Rectangle2D getStringBounds (Font font, CharacterIterator ci, \n+                                      int begin, int limit, FontRenderContext frc)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public boolean hasUniformLineMetrics (Font font)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public GlyphVector layoutGlyphVector (Font font, FontRenderContext frc, \n+                                        char[] chars, int start, int limit, \n+                                        int flags)\n+  {\n+    throw new UnsupportedOperationException ();  \n+  }\n+\n+  public LineMetrics getLineMetrics (Font font, String str, \n+                                     FontRenderContext frc)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public FontMetrics getFontMetrics (Font font)\n+  {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+}\n+"}, {"sha": "0ba45396b4f2b2d0178a83ce68f71c9f57c7d93a", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGlyphVector.java", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGlyphVector.java?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,342 @@\n+/* GdkGlyphVector.java -- Glyph vector object\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+   This file is part of GNU Classpath.\n+\n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+\n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+\n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+\n+package gnu.java.awt.peer.gtk;\n+\n+import java.awt.*;\n+import java.awt.font.*;\n+import java.awt.geom.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+import java.text.CharacterIterator;\n+import java.text.AttributedCharacterIterator;\n+import gnu.classpath.Configuration;\n+\n+public class GdkGlyphVector extends GlyphVector \n+{\n+\n+  static \n+  {\n+    if (Configuration.INIT_LOAD_LIBRARY)\n+      {\n+        System.loadLibrary(\"gtkpeer\");\n+      }\n+    initStaticState ();\n+  }\n+  native static void initStaticState ();\n+  private final int native_state = GtkGenericPeer.getUniqueInteger ();\n+\n+  private Font font;\n+  private FontRenderContext ctx;\n+    \n+  private native void initState (GdkClasspathFontPeer peer, FontRenderContext ctx);\n+  private native void setChars (String s);\n+  private native void setGlyphCodes (int codes[]);\n+  private native void dispose ();\n+  private native int glyphCode (int idx);\n+  private native int numGlyphs ();\n+  private native int glyphCharIndex (int idx);\n+  private native double[] allLogicalExtents ();\n+  private native double[] allInkExtents ();\n+  private native double[] glyphLogicalExtents (int idx);\n+  private native double[] glyphInkExtents (int idx);\n+  private native boolean glyphIsHorizontal (int idx);\n+  private native boolean isEqual (GdkGlyphVector ggv);\n+\n+\n+  /* \n+     geometric notes:\n+\n+     the FRC contains a mapping from points -> pixels.\n+\n+     typographics points are typically 1/72 of an inch.\n+\n+     pixel displays are often around 72 dpi.\n+\n+     so the FRC can get away with using an identity transform on a screen,\n+     often. behavior is documented by sun to fall back to an identity\n+     transform if the internal transformation is null.\n+\n+     coordinates coming up from pango are expressed as floats -- in device\n+     space, so basically pixels-with-fractional-bits -- derived from their\n+     storage format in pango (1024ths of pixels). \n+\n+     it is not clear from the javadocs whether the results of methods like\n+     getGlyphPositions ought to return coordinates in device space, or\n+     \"point\" space, or what. for now I'm returning them in device space.\n+     \n+   */\n+\n+\n+  public GdkGlyphVector (Font f, GdkClasspathFontPeer peer, FontRenderContext c, String s)\n+  {\n+    font = f;\n+    ctx = c;\n+    initState (peer, ctx);\n+    setChars (s);\n+  }\n+\n+  public GdkGlyphVector (Font f, GdkClasspathFontPeer peer, FontRenderContext c, int codes[])\n+  {\n+    font = f;\n+    ctx = c;\n+    initState (peer, ctx);\n+    setGlyphCodes (codes);\n+  }\n+\n+  protected void finalize ()\n+  {\n+    dispose ();\n+  }\n+\n+  public Font getFont () \n+  { \n+    return font; \n+  }\n+\n+  public FontRenderContext getFontRenderContext () \n+  { \n+    return ctx; \n+  }\n+\n+  public int getGlyphCharIndex (int glyphIndex) \n+  { \n+    return glyphCharIndex (glyphIndex); \n+  }\n+\n+  public int[] getGlyphCharIndices (int beginGlyphIndex, \n+                                    int numEntries,\n+                                    int[] codeReturn)\n+  {\n+    int ix[] = codeReturn;\n+    if (ix == null)\n+      ix = new int[numEntries];\n+\n+    for (int i = 0; i < numEntries; i++)\n+      ix[i] = glyphCharIndex (beginGlyphIndex + i);\n+    return ix;\n+  }\n+\n+  public int getGlyphCode (int glyphIndex) \n+  { \n+    return glyphCode (glyphIndex); \n+  }\n+\n+  public int[] getGlyphCodes (int beginGlyphIndex, int numEntries,\n+                              int[] codeReturn)\n+  {\n+    int ix[] = codeReturn;\n+    if (ix == null)\n+      ix = new int[numEntries];\n+\n+    for (int i = 0; i < numEntries; i++)\n+      ix[i] = glyphCode (beginGlyphIndex + i);\n+    return ix;\n+  }\n+\n+  public Shape getGlyphLogicalBounds (int glyphIndex)\n+  {\n+    double extents[] = glyphLogicalExtents (glyphIndex);\n+    return new Rectangle2D.Double (extents[0], extents[1],\n+                                   extents[2], extents[3]);\n+  }\n+    \n+  public GlyphMetrics getGlyphMetrics (int glyphIndex)\n+  {\n+    double extents[] = glyphLogicalExtents (glyphIndex);\n+    Rectangle2D log_bounds = new Rectangle2D.Double (extents[0], extents[1],\n+                                                     extents[2], extents[3]);\n+\n+    extents = glyphInkExtents (glyphIndex);\n+    Rectangle2D ink_bounds = new Rectangle2D.Double (extents[0], extents[1],\n+                                                     extents[2], extents[3]);\n+      \n+    boolean is_horizontal = glyphIsHorizontal (glyphIndex);\n+\n+    return new GlyphMetrics (is_horizontal,\n+                             (float)(log_bounds.getWidth() + log_bounds.getX()), \n+                             (float)(log_bounds.getHeight() + log_bounds.getY()),\n+                             ink_bounds, GlyphMetrics.STANDARD);\n+  }\n+\n+  public Shape getGlyphOutline (int glyphIndex)\n+  {\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+  public Shape getGlyphOutline (int glyphIndex, float x, float y)\n+  {\n+    throw new UnsupportedOperationException ();\n+  }\n+\n+  public Rectangle getGlyphPixelBounds (int glyphIndex, \n+                                        FontRenderContext renderFRC,\n+                                        float x, float y)\n+  {\n+    double extents[] = glyphInkExtents(glyphIndex);\n+    return new Rectangle ((int)x, (int)y, (int)extents[2], (int)extents[3]);\n+  }\n+    \n+  public Point2D getGlyphPosition (int glyphIndex)\n+  {\n+    float[] ret = new float[2 * (glyphIndex + 1)];\n+    getGlyphPositions (0, glyphIndex + 1, ret);\n+    return new Point2D.Float (ret[2 * glyphIndex], \n+                              ret[2 * glyphIndex + 1]);\n+  }\n+\n+  public float[] getGlyphPositions (int beginGlyphIndex,\n+                                    int numEntries,\n+                                    float[] positionReturn)\n+  {\n+    float fx[] = positionReturn;\n+    if (fx == null)\n+      fx = new float[numEntries * 2];\n+\n+\n+    float x = 0.0f;\n+    float y = 0.0f;\n+    for (int i = 0; i < numEntries; ++i)\n+      {\n+        boolean is_horizontal = glyphIsHorizontal (beginGlyphIndex + i);\n+        double log_extents[] = glyphLogicalExtents (beginGlyphIndex + i);\n+        fx[2*i]     = x + (float)log_extents[0]; // x offset\n+        fx[2*i + 1] = y + (float)log_extents[1]; // y offset\n+        if (is_horizontal)\n+          x += (float)log_extents[2]; // x advance (\"logical width\") in pango-ese\n+        else\n+          y += (float)log_extents[3]; // y advance (\"logical height\") in pango-ese\n+      }\n+    return fx;\n+  }\n+\n+  public AffineTransform getGlyphTransform (int glyphIndex)\n+  {\n+    // glyphs don't have independent transforms in these simple glyph\n+    // vectors; docs specify null is an ok return here.\n+    return null;  \n+  }\n+    \n+  public Shape getGlyphVisualBounds (int glyphIndex)\n+  {\n+    double extents[] = glyphInkExtents (glyphIndex);\n+    return new Rectangle2D.Double (extents[0], extents[1], \n+                                   extents[2], extents[3]);\n+  }\n+    \n+  public int getLayoutFlags ()\n+  {\n+    return 0;\n+  }\n+\n+  public Rectangle2D getLogicalBounds ()\n+  {\n+    double extents[] = allLogicalExtents ();\n+    return new Rectangle2D.Double (extents[0], extents[1], \n+                                   extents[2], extents[3]);\n+  }\n+\n+  public int getNumGlyphs ()\n+  {\n+    return numGlyphs ();\n+  }\n+\n+  public Shape getOutline ()\n+  {\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+  public Rectangle getPixelBounds (FontRenderContext renderFRC,\n+                                   float x, float y)\n+  {\n+    double extents[] = allInkExtents();\n+    return new Rectangle ((int)x, (int)y, \n+                          (int)extents[2], (int)extents[3]);\n+  }\n+    \n+  public Rectangle2D getVisualBounds ()\n+  {\n+    double extents[] = allInkExtents();\n+    return new Rectangle2D.Double (extents[0], extents[1], \n+                                   extents[2], extents[3]);\n+  }\n+\n+  public void performDefaultLayout ()\n+  {\n+  }\n+    \n+  public void setGlyphPosition (int glyphIndex, Point2D newPos)\n+  {\n+    // should we be ok twiddling pango's structure here?\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+  public void setGlyphTransform (int glyphIndex,\n+                                 AffineTransform newTX)\n+  {\n+    // not yet.. maybe not ever?\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+  public boolean equals(GlyphVector gv)\n+  {\n+    if (gv == null)\n+      return false;\n+\n+    if (! (gv instanceof GdkGlyphVector))\n+      return false;\n+\n+    GdkGlyphVector ggv = (GdkGlyphVector)gv;\n+    return isEqual(ggv);\n+  }\n+\n+  public GlyphJustificationInfo getGlyphJustificationInfo(int idx)\n+  {\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+  public Shape getOutline(float x, float y)    \n+  {\n+    throw new UnsupportedOperationException ();      \n+  }\n+\n+}"}, {"sha": "7adb307b75a94880130971ede12fcf3eec955b0e", "filename": "libjava/gnu/java/awt/peer/gtk/GdkGraphics2D.java", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fawt%2Fpeer%2Fgtk%2FGdkGraphics2D.java?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -48,6 +48,8 @@\n import java.text.AttributedCharacterIterator;\n import java.util.Map;\n import java.lang.Integer;\n+import gnu.java.awt.ClasspathToolkit;\n+import gnu.java.awt.peer.ClasspathFontPeer;\n import gnu.classpath.Configuration;\n \n public class GdkGraphics2D extends Graphics2D\n@@ -75,8 +77,8 @@ public class GdkGraphics2D extends Graphics2D\n   private Shape clip;\n   private AffineTransform transform;\n   private GtkComponentPeer component;\n-  private GdkFont font;  \n-\n+  private Font font;  \n+  \n   native private int[] initState (GtkComponentPeer component);\n   native private void initState (int width, int height);\n   native private void copyState (GdkGraphics2D g);\n@@ -172,6 +174,10 @@ private native void setGradient (double x1, double y1,\n   private native void cairoSetMatrix (double m00, double m10, \n                                       double m01, double m11,\n                                       double m02, double m12);\n+  private native void cairoSetFont (GdkClasspathFontPeer peer);\n+  private native void cairoShowGlyphs (int codes[],\n+                                       float positions[],\n+                                       int nglyphs);\n   private native void cairoSetOperator (int cairoOperator);\n   private native void cairoSetRGBColor (double red, double green, double blue);\n   private native void cairoSetAlpha (double alpha);\n@@ -1024,8 +1030,14 @@ public FontRenderContext getFontRenderContext ()\n   }\n \n   public void drawGlyphVector (GlyphVector g, float x, float y)\n-  {\n-    throw new java.lang.UnsupportedOperationException ();\n+  {    \n+    cairoSave ();\n+    cairoTranslate ((double)x, (double)y);\n+    int nglyphs = g.getNumGlyphs ();\n+    int codes[] = g.getGlyphCodes (0, nglyphs, (int []) null);\n+    float posns[] = g.getGlyphPositions (0, nglyphs, (float []) null);\n+    cairoShowGlyphs (codes, posns, nglyphs);\n+    cairoRestore ();\n   }\n \n   public void copyArea (int x, int y, int width, int height, int dx, int dy)\n@@ -1132,10 +1144,16 @@ public FontMetrics getFontMetrics (Font f)\n \n   public void setFont (Font f)\n   {\n-    if (f instanceof GdkFont)\n-      font = (GdkFont) f;\n+    if (f.getPeer() instanceof GdkClasspathFontPeer)\n+      font = f;\n     else\n-      font = new GdkFont (f.getAttributes ());\n+      font = \n+        ((ClasspathToolkit)(Toolkit.getDefaultToolkit ()))\n+        .getFont (f.getName(), f.getAttributes ());\n+\n+    if (f != null && \n+        f.getPeer() instanceof GdkClasspathFontPeer)\n+      cairoSetFont ((GdkClasspathFontPeer) f.getPeer());\n   }\n \n   public String toString()"}, {"sha": "092979b2fc2727023e02db0076168e135ff95347", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkClasspathFontPeer.c?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,160 @@\n+/* gnu_java_awt_GdkFont.c\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   \n+   This file is part of GNU Classpath.\n+   \n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+   \n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+   \n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+#include \"gdkfont.h\"\n+#include \"gnu_java_awt_peer_gtk_GdkClasspathFontPeer.h\"\n+\n+struct state_table *native_font_state_table;\n+\n+/*\n+rough sketch of the mapping between java and \n+pango text objects:\n+  \n+  Font              <->    - PangoFont\n+                           - PangoFontDescription\n+                           - PangoContext\n+\n+  GlyphVector       <->    - GList of PangoGlyphItem\n+                           - PangoFontDescription\n+                           - PangoContext\n+\n+  FontRenderContext <->    stays in plain java\n+\n+*/\n+\n+enum java_awt_font_style {\n+  java_awt_font_PLAIN = 0,\n+  java_awt_font_BOLD = 1,\n+  java_awt_font_ITALIC = 2\n+};\n+\n+enum java_awt_font_baseline {\n+  java_awt_font_ROMAN_BASELINE = 0,\n+  java_awt_font_CENTER_BASELINE = 1,\n+  java_awt_font_HANGING_BASELINE = 2\n+};\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeer_initStaticState \n+  (JNIEnv *env, jclass clazz)\n+{\n+  NSA_FONT_INIT (env, clazz);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeer_initState\n+  (JNIEnv *env, jobject self)\n+{\n+  struct peerfont *pfont = NULL;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  pfont = (struct peerfont *) g_malloc0 (sizeof (struct peerfont));\n+  g_assert (pfont != NULL);\n+  NSA_SET_FONT_PTR (env, self, pfont);\n+  gdk_threads_leave ();\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeer_dispose\n+  (JNIEnv *env, jobject self)\n+{\n+  struct peerfont *pfont = NULL;\n+\n+  gdk_threads_enter ();\n+  pfont = (struct peerfont *)NSA_DEL_FONT_PTR (env, self);\n+  g_assert (pfont != NULL);\n+  if (pfont->ctx != NULL)\n+    g_object_unref (pfont->ctx);\n+  if (pfont->font != NULL)\n+    g_object_unref (pfont->font);\n+  if (pfont->desc != NULL)\n+    pango_font_description_free (pfont->desc);\n+  g_free (pfont);\n+  gdk_threads_leave ();\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkClasspathFontPeer_setFont\n+  (JNIEnv *env, jobject self, jstring family_name_str, jint style_int, jint size)\n+{\n+  struct peerfont *pfont = NULL;\n+  PangoFontMap *map = NULL; \n+  char const *family_name = NULL;\n+\n+  gdk_threads_enter ();\n+  enum java_awt_font_style style = (enum java_awt_font_style) style_int;\n+\n+  g_assert (self != NULL);\n+  pfont = (struct peerfont *)NSA_GET_FONT_PTR (env, self);\n+  g_assert (pfont != NULL);\n+\n+  pfont->desc = pango_font_description_new ();\n+  g_assert (pfont->desc != NULL);\n+\n+  family_name = (*env)->GetStringUTFChars(env, family_name_str, 0);\n+  g_assert (family_name != NULL);\n+  pango_font_description_set_family (pfont->desc, family_name);\n+  (*env)->ReleaseStringUTFChars(env, family_name_str, family_name);\n+\n+  pango_font_description_set_size (pfont->desc, size * PANGO_SCALE);  \n+\n+  if (style & java_awt_font_BOLD)\n+    pango_font_description_set_weight (pfont->desc, PANGO_WEIGHT_BOLD);\n+\n+  if (style & java_awt_font_ITALIC)\n+    pango_font_description_set_style (pfont->desc, PANGO_STYLE_ITALIC);\n+  \n+  /* \n+     FIXME: these are possibly wrong, and should in any case\n+     probably be cached between calls.\n+   */\n+\n+  map = pango_ft2_font_map_for_display ();\n+  g_assert (map != NULL);\n+  \n+  if (pfont->ctx == NULL)\n+    pfont->ctx = pango_ft2_font_map_create_context (PANGO_FT2_FONT_MAP (map));  \n+  g_assert (pfont->ctx != NULL);\n+\n+  if (pfont->font != NULL)\n+    g_object_unref (pfont->font);\n+\n+  pfont->font = pango_font_map_load_font (map, pfont->ctx, pfont->desc);\n+  g_assert (pfont->font != NULL);\n+  \n+  gdk_threads_leave ();\n+}\n+\n+"}, {"sha": "052f7e9ff6d3b74624662df01accfaa8edc78277", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGlyphVector.c", "status": "added", "additions": 571, "deletions": 0, "changes": 571, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGlyphVector.c?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -0,0 +1,571 @@\n+/* gdkglyphvector.c\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   \n+   This file is part of GNU Classpath.\n+   \n+   GNU Classpath is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+   \n+   GNU Classpath is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GNU Classpath; see the file COPYING.  If not, write to the\n+   Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+   02111-1307 USA.\n+   \n+   Linking this library statically or dynamically with other modules is\n+   making a combined work based on this library.  Thus, the terms and\n+   conditions of the GNU General Public License cover the whole\n+   combination.\n+   \n+   As a special exception, the copyright holders of this library give you\n+   permission to link this library with independent modules to produce an\n+   executable, regardless of the license terms of these independent\n+   modules, and to copy and distribute the resulting executable under\n+   terms of your choice, provided that you also meet, for each linked\n+   independent module, the terms and conditions of the license of that\n+   module.  An independent module is a module which is not derived from\n+   or based on this library.  If you modify this library, you may extend\n+   this exception to your version of the library, but you are not\n+   obligated to do so.  If you do not wish to do so, delete this\n+   exception statement from your version. */\n+\n+#include \"gdkfont.h\"\n+#include \"gnu_java_awt_peer_gtk_GdkGlyphVector.h\"\n+\n+struct state_table *native_glyphvector_state_table;\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_initStaticState \n+  (JNIEnv *env, jclass clazz)\n+{\n+  NSA_GV_INIT (env, clazz);\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_initState \n+  (JNIEnv *env, jobject self, jobject font, jobject ctx)\n+{\n+  struct glyphvec *vec = NULL;\n+  struct peerfont *pfont = NULL;\n+\n+  gdk_threads_enter ();\n+  g_assert (font != NULL);\n+  pfont = (struct peerfont *)NSA_GET_FONT_PTR (env, font);\n+  g_assert (pfont != NULL);\n+  g_assert (pfont->ctx != NULL);\n+  g_assert (pfont->desc != NULL);\n+\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *) g_malloc0 (sizeof (struct glyphvec));\n+  g_assert (vec != NULL);\n+\n+  vec->desc = pango_font_description_copy (pfont->desc);\n+  g_assert (vec->desc != NULL);\n+    \n+  vec->ctx = pfont->ctx;\n+  g_object_ref (vec->ctx);\n+\n+  NSA_SET_GV_PTR (env, self, vec);\n+  gdk_threads_leave ();\n+}\n+\n+static void free_glyphitems (GList *list)\n+{\n+  GList *i = NULL;\n+  PangoGlyphItem *gi = NULL;\n+\n+  for (i = g_list_first (list); i != NULL; i = g_list_next (i))\n+    {\n+      g_assert (i->data != NULL);\n+      gi = (PangoGlyphItem *)i->data;\n+\n+      if (gi->glyphs != NULL)\n+\tpango_glyph_string_free (gi->glyphs);\n+\n+      if (gi->item != NULL)\n+\tg_free (gi->item);\n+    }      \n+  g_list_free (list);\n+}\n+\n+static void seek_glyphstring_idx (GList *list, int idx, \n+\t\t\t\t  int *nidx, \n+\t\t\t\t  PangoGlyphString **gs,\n+\t\t\t\t  PangoFont **fnt)\n+{\n+  GList *i = NULL;\n+  PangoGlyphItem *gi = NULL;\n+\n+  g_assert (list != NULL);\n+  g_assert (gs != NULL);\n+  g_assert (nidx != NULL);\n+\n+  int begin = 0;\n+  for (i = g_list_first (list); i != NULL; i = g_list_next (i))\n+    {\n+      g_assert (i->data != NULL);\n+      gi = (PangoGlyphItem *)i->data;\n+\n+      g_assert (gi->glyphs != NULL);\n+      \n+      if (begin <= idx && idx < begin + gi->glyphs->num_glyphs)\n+\t{\t  \n+\t  *gs = gi->glyphs;\n+\t  *nidx = idx - begin;\n+\t  if (fnt && gi->item)\n+\t    *fnt = gi->item->analysis.font;\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  begin += gi->glyphs->num_glyphs;\n+\t}\n+    }\n+  *gs = NULL;\n+  *nidx = -1;\n+}\n+\n+static void seek_glyph_idx (GList *list, int idx, \n+\t\t\t    PangoGlyphInfo **g,\n+\t\t\t    PangoFont **fnt)\n+{\n+  PangoGlyphString *gs = NULL;\n+  int nidx = -1;\n+\n+  g_assert (list != NULL);\n+  g_assert (g != NULL);\n+\n+  seek_glyphstring_idx (list, idx, &nidx, &gs, fnt);\n+\n+  g_assert (gs != NULL);\n+  g_assert (nidx != -1);\n+  g_assert (nidx < gs->num_glyphs);\n+  g_assert (gs->glyphs != NULL);\n+\n+  *g = gs->glyphs + nidx;\n+}\n+\n+static void union_rects (PangoRectangle *r1, \n+\t\t\t const PangoRectangle *r2)\n+{\n+  PangoRectangle r;\n+\n+  g_assert (r1 != NULL);\n+  g_assert (r2 != NULL);\n+\n+  /* \n+     x is the left edge of the rect,\n+     y is the top edge of the rect\n+  */\n+\n+#ifndef min\n+#define min(x,y) ((x) < (y) ? (x) : (y))\n+#endif\n+\n+#ifndef max\n+#define max(x,y) ((x) < (y) ? (y) : (x))\n+#endif\n+\n+  r.x = min(r1->x, r2->x);\n+\n+  r.y = min(r1->y, r2->y);\n+\n+  r.width = max(r1->x + r1->width,\n+\t\tr2->x + r2->width) - r.x;\n+\n+  r.height = max(r1->y + r1->height,\n+\t\t r2->y + r2->height) - r.y;\n+\n+  *r1 = r;  \n+}\n+\n+static jdoubleArray rect_to_array (JNIEnv *env, const PangoRectangle *r)\n+{\n+  /* We often return rectangles as arrays : { x, y, w, h } */\n+  jdoubleArray ret;\n+  double *rp = NULL;\n+  g_assert (r != NULL);\n+  ret = (*env)->NewDoubleArray (env, 4);\n+  rp = (*env)->GetDoubleArrayElements (env, ret, NULL);\n+  g_assert (rp != NULL);\n+  rp[0] = r->x / (double)PANGO_SCALE;\n+  /* freetype and pango's view of space is upside down from java2d's */\n+  rp[1] = (r->y / (double)PANGO_SCALE) * -1;\n+  rp[2] = r->width / (double)PANGO_SCALE;\n+  rp[3] = r->height / (double)PANGO_SCALE;\n+  (*env)->ReleaseDoubleArrayElements (env, ret, rp, 0);\n+  return ret;\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_dispose\n+  (JNIEnv *env, jobject self)\n+{\n+  struct glyphvec *vec = NULL;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_DEL_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+\n+  if (vec->glyphitems != NULL)\n+    {\n+      free_glyphitems (vec->glyphitems);\n+      vec->glyphitems = NULL;\n+    }\n+      \n+  if (vec->desc != NULL)\n+    pango_font_description_free (vec->desc);\n+\n+  if (vec->ctx != NULL)\n+    g_object_unref (vec->ctx);\n+\n+  g_free (vec);\n+  gdk_threads_leave ();\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_setChars \n+  (JNIEnv *env, jobject self, jstring chars)\n+{\n+  struct glyphvec *vec = NULL;\n+  gchar *str = NULL;\n+  GList *items = NULL, *item = NULL;\n+  PangoGlyphItem *gi;\n+  PangoAttrList *attrs = NULL; \n+  gint len = 0;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->desc != NULL);\n+  g_assert (vec->ctx != NULL);\n+  \n+  len = (*gdk_env)->GetStringUTFLength (env, chars);\n+  str = (gchar *)(*env)->GetStringUTFChars (env, chars, NULL);\n+  g_assert (str != NULL);\n+\n+  /* step 1: mark the text as having our FontFescription as an \n+     attribute, then \"itemize\" the text */\n+\n+  attrs = pango_attr_list_new ();\n+  g_assert (attrs != NULL);\n+  \n+  PangoAttribute *da = pango_attr_font_desc_new(vec->desc);\n+  g_assert (da != NULL);\n+  da->start_index = 0;\n+  da->end_index = len;\n+  \n+  pango_attr_list_insert (attrs, da);\n+  items = pango_itemize (vec->ctx, str, 0, len, attrs, NULL);\n+  g_assert (items != NULL);\n+  \n+  /*\n+    step 2: for each item:\n+    - shape the item into a glyphstring\n+    - store the (item, glyphstring) pair in the vec->glyphitems list\n+  */\n+  \n+  if (vec->glyphitems != NULL)\n+    {\n+      free_glyphitems (vec->glyphitems);\n+      vec->glyphitems = NULL;\n+    }\n+\n+  for (item = g_list_first (items); item != NULL; item = g_list_next (item))\n+    {\n+      g_assert (item->data != NULL);\n+\n+      gi = NULL;\n+      gi = g_malloc0 (sizeof(PangoGlyphItem));\n+      g_assert (gi != NULL);\n+\n+      gi->item = (PangoItem *)item->data;\n+      gi->glyphs = pango_glyph_string_new ();\n+      g_assert (gi->glyphs != NULL);\n+\n+      pango_shape (str + gi->item->offset, \n+\t\t   gi->item->length, \n+\t\t   &(gi->item->analysis), \n+\t\t   gi->glyphs);\n+\n+      vec->glyphitems = g_list_append (vec->glyphitems, gi);\n+    }\n+\n+  /* \n+     ownership of each item has been transferred to glyphitems, \n+     but the list should be freed.\n+  */\n+\n+  g_list_free (items);\n+  pango_attr_list_unref (attrs);\n+\n+  (*env)->ReleaseStringUTFChars (env, chars, str);\n+  gdk_threads_leave ();\n+}\n+\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_setGlyphCodes \n+  (JNIEnv *env, jobject self, jintArray codes)\n+{\n+  struct glyphvec *vec = NULL;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+\n+  /*\n+    FIXME: setting glyph codes doesn't seem particularly plausible at the\n+    moment. \n+   */\n+\n+  gdk_threads_leave ();\n+\n+}\n+\n+\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphCode \n+  (JNIEnv *env, jobject self, jint idx)\n+{\n+  struct glyphvec *vec = NULL;\n+  PangoGlyphInfo *gi = NULL;\n+  jint ret = 0;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->glyphitems != NULL);\n+\n+  seek_glyph_idx (vec->glyphitems, idx, &gi, NULL);\n+  g_assert (gi != NULL);\n+  ret = gi->glyph;\n+  gdk_threads_leave ();\n+\n+  return (jint)(ret);  \n+}\n+\n+\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_numGlyphs \n+  (JNIEnv *env, jobject self)\n+{\n+  GList *i = NULL;\n+  PangoGlyphItem *gi = NULL;\n+  struct glyphvec *vec = NULL;\n+  jint count = 0;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+\n+  for (i = g_list_first (vec->glyphitems); i != NULL; i = g_list_next (i))\n+    {\n+      g_assert (i->data != NULL);\n+      gi = (PangoGlyphItem *)i->data;\n+      g_assert (gi->glyphs != NULL);\n+      count += gi->glyphs->num_glyphs;\n+    }      \n+  gdk_threads_leave ();\n+\n+  return count;\n+}\n+\n+\n+JNIEXPORT jint JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphCharIndex \n+  (JNIEnv *env, jobject self, jint idx)\n+{\n+  /* \n+     FIXME: this is not correct, rather it assumes a (broken) 1:1\n+     glyph:char model. it can be implemented in terms of bytes (also\n+     broken) using pango's current interface, or perhaps in terms of\n+     characters if some better byte->character conversion operator is\n+     found. for the time being we leave it broken.\n+  */\n+  return idx;\n+}\n+\n+\n+JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_allLogicalExtents \n+  (JNIEnv *env, jobject self)\n+{\n+  struct glyphvec *vec = NULL;\n+  GList *i;\n+  PangoGlyphItem *gi = NULL;\n+  PangoRectangle rect = {0,0,0,0};\n+  PangoRectangle tmp, dummy;  \n+  jdoubleArray ret;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->glyphitems != NULL);\n+\n+  for (i = g_list_first (vec->glyphitems); i != NULL; i = g_list_next (i))\n+    {\n+      g_assert (i->data != NULL);\n+      gi = (PangoGlyphItem *)i->data;\n+      g_assert (gi->glyphs != NULL);\n+      \n+      pango_glyph_string_extents (gi->glyphs,\n+\t\t\t\t  gi->item->analysis.font,\n+\t\t\t\t  &dummy,\n+\t\t\t\t  &tmp);\n+      union_rects (&rect, &tmp);\n+    }      \n+\n+  ret = rect_to_array (env, &rect);\n+  gdk_threads_leave ();\n+  return ret;\n+}\n+\n+\n+JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_allInkExtents \n+  (JNIEnv *env, jobject self)\n+{\n+  struct glyphvec *vec = NULL;\n+  GList *i;\n+  PangoGlyphItem *gi = NULL;\n+  PangoRectangle rect = {0,0,0,0};\n+  PangoRectangle tmp, dummy;  \n+  jdoubleArray ret;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->glyphitems != NULL);\n+\n+  for (i = g_list_first (vec->glyphitems); i != NULL; i = g_list_next (i))\n+    {\n+      g_assert (i->data != NULL);\n+      gi = (PangoGlyphItem *)i->data;\n+      g_assert (gi->glyphs != NULL);\n+      \n+      pango_glyph_string_extents (gi->glyphs,\n+\t\t\t\t  gi->item->analysis.font,\n+\t\t\t\t  &tmp,\n+\t\t\t\t  &dummy);\n+      union_rects (&rect, &tmp);\n+    }      \n+\n+  ret = rect_to_array (env, &rect);\n+  gdk_threads_leave ();\n+  return ret;\n+}\n+\n+JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphLogicalExtents \n+  (JNIEnv *env, jobject self, jint idx)\n+{\n+  struct glyphvec *vec = NULL;\n+  PangoRectangle rect = {0,0,0,0};\n+  PangoRectangle dummy;  \n+  PangoGlyphInfo *gi = NULL;\n+  PangoFont *font = NULL;\n+  jdoubleArray ret;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->glyphitems != NULL);\n+\n+  seek_glyph_idx (vec->glyphitems, idx, &gi, &font);\n+  g_assert (gi != NULL);\n+  g_assert (font != NULL);\n+\n+  pango_font_get_glyph_extents (font, gi->glyph, &dummy, &rect);\n+\n+  ret = rect_to_array (env, &rect);\n+  gdk_threads_leave ();\n+  return ret;\n+}\n+\n+\n+JNIEXPORT jdoubleArray JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphInkExtents \n+  (JNIEnv *env, jobject self, jint idx)\n+{\n+  struct glyphvec *vec = NULL;\n+  PangoRectangle rect = {0,0,0,0};\n+  PangoRectangle dummy;  \n+  PangoGlyphInfo *gi = NULL;\n+  PangoFont *font = NULL;\n+  jdoubleArray ret;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->glyphitems != NULL);\n+\n+  seek_glyph_idx (vec->glyphitems, idx, &gi, &font);\n+  g_assert (gi != NULL);\n+  g_assert (font != NULL);\n+\n+  pango_font_get_glyph_extents (font, gi->glyph, &rect, &dummy);\n+\n+  ret = rect_to_array (env, &rect);\n+  gdk_threads_leave ();\n+  return ret;\n+}\n+\n+JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_glyphIsHorizontal \n+  (JNIEnv *env, jobject self, jint idx)\n+{\n+  struct glyphvec *vec = NULL;\n+  PangoDirection dir;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  g_assert (vec != NULL);\n+  g_assert (vec->desc != NULL);\n+  g_assert (vec->ctx != NULL);\n+\n+  /* \n+     FIXME: this is an approximation; it's not clear to me whether\n+     glyphs themselves are horizontal or vertical so much as the\n+     writing system or writing context. pango thinks it's a context\n+     issue, so we use that for now.\n+   */\n+\n+  dir = pango_context_get_base_dir (vec->ctx);\n+\n+  gdk_threads_leave ();\n+\n+  return \n+    ((dir == PANGO_DIRECTION_LTR) ||\n+     (dir == PANGO_DIRECTION_RTL));    \n+}\n+\n+\n+JNIEXPORT jboolean JNICALL Java_gnu_java_awt_peer_gtk_GdkGlyphVector_isEqual \n+  (JNIEnv *env, jobject self, jobject other)\n+{\n+  struct glyphvec *vec1 = NULL, *vec2 = NULL;\n+  jboolean eq = 0;\n+\n+  gdk_threads_enter ();\n+  g_assert (self != NULL);\n+  vec1 = (struct glyphvec *)NSA_GET_GV_PTR (env, self);\n+  vec2 = (struct glyphvec *)NSA_GET_GV_PTR (env, other);\n+  g_assert (vec1 != NULL);\n+  g_assert (vec2 != NULL);\n+  \n+  /* FIXME: is there some more advantageous definition of equality for\n+     glyph vectors? */\n+  eq = (vec1 == vec2);\n+  \n+  gdk_threads_leave ();\n+  return eq;\n+}\n+\n+"}, {"sha": "08a9742b69ee1fc4c07154a2a737e26800102514", "filename": "libjava/jni/gtk-peer/gnu_java_awt_peer_gtk_GdkGraphics2D.c", "status": "modified", "additions": 88, "deletions": 7, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4bcf1418f3057826922bb830d3ee6aaf73adc1d/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni%2Fgtk-peer%2Fgnu_java_awt_peer_gtk_GdkGraphics2D.c?ref=c4bcf1418f3057826922bb830d3ee6aaf73adc1d", "patch": "@@ -36,6 +36,7 @@\n    exception statement from your version. */\n \n #include \"gtkpeer.h\"\n+#include \"gdkfont.h\"\n #include \"gnu_java_awt_peer_gtk_GdkGraphics2D.h\"\n #include <gdk/gdktypes.h>\n #include <gdk/gdkprivate.h>\n@@ -45,6 +46,8 @@\n #include <gdk-pixbuf/gdk-pixdata.h>\n \n #include <cairo.h>\n+#include <cairo-xlib.h>\n+\n #include <stdio.h>\n #include <stdlib.h>\n \n@@ -198,9 +201,9 @@ init_graphics2d_as_renderable (struct graphics2d *gr)\n   vis = gdk_x11_visual_get_xvisual (gdk_drawable_get_visual (gr->drawable));\n   g_assert (vis != NULL);\n   \n-  gr->surface = cairo_surface_create_for_drawable (dpy, draw, vis, \n-\t\t\t\t\t\t   CAIRO_FORMAT_ARGB32,\n-\t\t\t\t\t\t   DefaultColormap (dpy, DefaultScreen (dpy)));\n+  gr->surface = cairo_xlib_surface_create (dpy, draw, vis, \n+\t\t\t\t\t   CAIRO_FORMAT_ARGB32,\n+\t\t\t\t\t   DefaultColormap (dpy, DefaultScreen (dpy)));\n   g_assert (gr->surface != NULL);\n   g_assert (gr->cr != NULL);\n   cairo_set_target_surface (gr->cr, gr->surface);\n@@ -378,8 +381,8 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_gdkDrawDrawable\n   gc = gdk_gc_new (dst->drawable);\n   g_assert (gc != NULL);\n \n-  gdk_draw_drawable(dst->drawable, gc, src->drawable,\n-\t\t    0, 0, x, y, width, height);\n+  gdk_draw_drawable(dst->drawable, gc, src->drawable, \n+ \t\t    0, 0, x, y, width, height); \n \n   g_object_unref (gc);\n \n@@ -474,7 +477,6 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_dispose\n     g_object_unref (gr->drawbuf); \n \n   g_object_unref (gr->drawable);\n-  free (gr);\n \n   if (gr->pattern)\n     cairo_surface_destroy (gr->pattern);\n@@ -483,6 +485,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_dispose\n     free (gr->pattern_pixels);\n \n   if (gr->debug) printf (\"disposed of graphics2d\\n\");\n+  free (gr);\n \n   gdk_threads_leave ();\n }\n@@ -662,6 +665,7 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_drawPixels\n \n   begin_drawing_operation (gr);\n \n+  \n  {\n    cairo_surface_t *surf = cairo_surface_create_for_image ((char *)jpixels, \n \t\t\t\t\t\t\t   CAIRO_FORMAT_ARGB32, \n@@ -670,8 +674,9 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_drawPixels\n    cairo_show_surface (gr->cr, surf, w, h);\n    cairo_surface_destroy (surf);\n  }\n+  \n \n-  end_drawing_operation (gr);\n+ end_drawing_operation (gr);\n \n   (*env)->ReleaseIntArrayElements (env, jarr, jpixels, 0);\n \n@@ -723,6 +728,82 @@ JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetMatrix\n   update_pattern_transform (gr);\n }\n \n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetFont \n+   (JNIEnv *env, jobject obj, jobject font)\n+{\n+  struct graphics2d *gr = NULL;\n+  struct peerfont *pfont = NULL;\n+  cairo_font_t *ft = NULL;\n+  FT_Face face = NULL;\n+\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  pfont = (struct peerfont *)NSA_GET_FONT_PTR (env, font);\n+  g_assert (pfont != NULL);\n+\n+  gdk_threads_enter ();\n+\n+  face = pango_ft2_font_get_face (pfont->font);\n+  g_assert (face != NULL);\n+\n+  ft = cairo_ft_font_create_for_ft_face (face);\n+  g_assert (ft != NULL);\n+\n+  if (gr->debug) printf (\"cairo_set_font '%s'\\n\", \n+\t\t\t face->family_name);\n+  \n+  cairo_set_font (gr->cr, ft);\n+\n+  cairo_scale_font (gr->cr, \n+\t\t    pango_font_description_get_size (pfont->desc) / \n+\t\t    (double)PANGO_SCALE);\n+\n+  cairo_font_destroy (ft);\n+\n+  gdk_threads_leave ();\n+}\n+\n+JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoShowGlyphs\n+   (JNIEnv *env, jobject obj, jintArray jcodes, jfloatArray jposns, jint nglyphs)\n+{\n+  struct graphics2d *gr = NULL;\n+  cairo_glyph_t *glyphs = NULL;\n+  jfloat *posns = NULL;\n+  jint *codes = NULL;\n+  jint i;\n+\n+  gr = (struct graphics2d *) NSA_GET_G2D_PTR (env, obj);\n+  g_assert (gr != NULL);\n+\n+  if (gr->debug) printf (\"cairo_show_glyphs (%d glyphs)\\n\", nglyphs);\n+\n+  glyphs = malloc (sizeof(cairo_glyph_t) * nglyphs);\n+  g_assert (glyphs);\n+\n+  codes = (*env)->GetIntArrayElements (env, jcodes, NULL);  \n+  g_assert (codes != NULL);\n+\n+  posns = (*env)->GetFloatArrayElements (env, jposns, NULL);  \n+  g_assert (posns != NULL);\n+\n+  for (i = 0; i < nglyphs; ++i)\n+    {\n+      glyphs[i].index = codes[i];\n+      glyphs[i].x = (double) posns[2*i];\n+      glyphs[i].y = (double) posns[2*i + 1];\n+    }\n+\n+  (*env)->ReleaseIntArrayElements (env, jcodes, codes, 0);\n+  (*env)->ReleaseFloatArrayElements (env, jposns, posns, 0);\n+\n+  begin_drawing_operation (gr);\n+  cairo_show_glyphs (gr->cr, glyphs, nglyphs);\n+  end_drawing_operation (gr);\n+\n+  free(glyphs);\n+}\n+\n JNIEXPORT void JNICALL Java_gnu_java_awt_peer_gtk_GdkGraphics2D_cairoSetOperator \n    (JNIEnv *env, jobject obj, jint op)\n {"}]}