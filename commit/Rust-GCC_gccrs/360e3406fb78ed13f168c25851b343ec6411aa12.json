{"sha": "360e3406fb78ed13f168c25851b343ec6411aa12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzYwZTM0MDZmYjc4ZWQxM2YxNjhjMjU4NTFiMzQzZWM2NDExYWExMg==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2015-11-13T10:51:34Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2015-11-13T10:51:34Z"}, "message": "Optimize condition reductions where the result is an integer induction variable\n\n2015-11-13  Alan Hayward <alan.hayward@arm.com>\n\ngcc/\n\tPR tree-optimization/66558\n\t* tree-vect-loop.c (is_integer_induction):Add.\n\t(vectorizable_reduction): Add integer induction checks.\n\ngcc/testsuite/\n\tPR tree-optimization/66558\n\t* gcc.dg/vect/pr65947-1.c: Add checks.\n\t* gcc.dg/vect/pr65947-2.c: Add checks.\n\t* gcc.dg/vect/pr65947-3.c: Add checks.\n\t* gcc.dg/vect/pr65947-4.c: Add checks.\n\t* gcc.dg/vect/pr65947-5.c: Add checks.\n\t* gcc.dg/vect/pr65947-6.c: Add checks.\n\t* gcc.dg/vect/pr65947-10.c: Add checks.\n\t* gcc.dg/vect/pr65947-12.c: New test.\n\t* gcc.dg/vect/pr65947-13.c: New test.\n\nFrom-SVN: r230297", "tree": {"sha": "b61189c71f01d29decdb64e849a2f12a4403817f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b61189c71f01d29decdb64e849a2f12a4403817f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/360e3406fb78ed13f168c25851b343ec6411aa12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360e3406fb78ed13f168c25851b343ec6411aa12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/360e3406fb78ed13f168c25851b343ec6411aa12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/360e3406fb78ed13f168c25851b343ec6411aa12/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8f215e0f07c33e511ed478152330451ede1e6285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f215e0f07c33e511ed478152330451ede1e6285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f215e0f07c33e511ed478152330451ede1e6285"}], "stats": {"total": 255, "additions": 243, "deletions": 12}, "files": [{"sha": "9d4758ba9277fe245455e59be4ddd01b801c9eb3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -1,3 +1,9 @@\n+2015-11-13  Alan Hayward <alan.hayward@arm.com>\n+\n+\tPR tree-optimization/66558\n+\t* tree-vect-loop.c (is_integer_induction):Add.\n+\t(vectorizable_reduction): Add integer induction checks.\n+\n 2015-11-13  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tRevert [ARM] Remove neon-testgen.ml and generated tests."}, {"sha": "66b3d181606bd28943c19723edcce2e3d0085b88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -1,3 +1,16 @@\n+2015-11-13  Alan Hayward <alan.hayward@arm.com>\n+\n+\tPR tree-optimization/66558\n+\t* gcc.dg/vect/pr65947-1.c: Add checks.\n+\t* gcc.dg/vect/pr65947-2.c: Add checks.\n+\t* gcc.dg/vect/pr65947-3.c: Add checks.\n+\t* gcc.dg/vect/pr65947-4.c: Add checks.\n+\t* gcc.dg/vect/pr65947-5.c: Add checks.\n+\t* gcc.dg/vect/pr65947-6.c: Add checks.\n+\t* gcc.dg/vect/pr65947-10.c: Add checks.\n+\t* gcc.dg/vect/pr65947-12.c: New test.\n+\t* gcc.dg/vect/pr65947-13.c: New test.\n+\n 2015-11-13  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tRevert [ARM] Remove neon-testgen.ml and generated tests."}, {"sha": "1e7a05dc8cc6f00fee265b9b8ad65beaa520f1e8", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-1.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -9,7 +9,7 @@ extern void abort (void) __attribute__ ((noreturn));\n int\n condition_reduction (int *a, int min_v)\n {\n-  int last = -1;\n+  int last = 66; /* High start value.  */\n \n   for (int i = 0; i < N; i++)\n     if (a[i] < min_v)\n@@ -28,12 +28,13 @@ main (void)\n   31, 32\n   };\n \n-  int ret = condition_reduction (a, 16);\n+  int ret = condition_reduction (a, 1);\n \n-  if (ret != 19)\n+  if (ret != 17)\n     abort ();\n \n   return 0;\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { xfail { ! vect_max_reduc } } } } */"}, {"sha": "b4c6659b77ccbbafd77c62976e408dda37a2f4c4", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-10.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-10.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -37,4 +37,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */\n "}, {"sha": "fb5ffd48c7bb87f6e2f9e055e90e4f121a202d5e", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-12.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-12.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 32\n+\n+/* Simple condition reduction where the result is a negative of the induction.\n+   Will fail to vectorize to a simple case.  */\n+\n+signed int\n+condition_reduction (signed int *a, signed int min_v)\n+{\n+  signed int last = -1;\n+\n+  for (signed int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = -i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  signed int a[N] = {\n+  11, -12, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, -3, 4, 5, 6, 7, -8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+\n+  signed int ret = condition_reduction (a, 16);\n+\n+  if (ret != -19)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "8c6faddd189dabf9b96b4e665c59cf268cf9a3aa", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-13.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-13.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+extern void abort (void) __attribute__ ((noreturn));\n+\n+#define N 32\n+\n+/* Simple condition reduction with a reversed loop.\n+   Will fail to vectorize to a simple case.  */\n+\n+int\n+condition_reduction (int *a, int min_v)\n+{\n+  int last = -1;\n+\n+  for (int i = N-1; i >=0; i--)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int a[N] = {\n+  17, 28, 13, 14, 15, 16, 17, 18, 19, 20,\n+  1, 2, -3, 4, 5, 6, 7, -8, 9, 10,\n+  21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+  31, 32\n+  };\n+\n+  int ret = condition_reduction (a, 16);\n+\n+  if (ret != 2)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "9e9ff53828609b19e6fe97ae2d640294cb980c14", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-2.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-2.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -38,3 +38,4 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "4b6aa9216b0c200c43a227bf8b4954ecbe4f0090", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-3.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-3.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -48,3 +48,4 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "f4e7fdc97c89866b19838593cb84fc1754f87494", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-4.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-4.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -37,4 +37,5 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-times \"condition expression based on integer induction.\" 4 \"vect\" { xfail { ! vect_max_reduc } } } } */\n "}, {"sha": "21be8d0b749a4c1f2f29b6aed17533ec26b7aede", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-5.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-5.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -39,3 +39,4 @@ main (void)\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 1 \"vect\" { xfail { ! vect_max_reduc } } } } */\n /* { dg-final { scan-tree-dump \"loop size is greater than data size\" \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "e1432403b2dd227a7e13db6e228d819780b89ad6", "filename": "gcc/testsuite/gcc.dg/vect/pr65947-6.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65947-6.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -37,3 +37,4 @@ main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 2 \"vect\" { xfail { ! vect_max_reduc } } } } */\n+/* { dg-final { scan-tree-dump-not \"condition expression based on integer induction.\" \"vect\" } } */"}, {"sha": "4630c86724e9f5df2b33eee4c60d3e7021b777b9", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 130, "deletions": 8, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -4191,7 +4191,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   tree bitsize;\n   tree adjustment_def = NULL;\n   tree vec_initial_def = NULL;\n-  tree reduction_op, expr, def;\n+  tree reduction_op, expr, def, initial_def = NULL;\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n@@ -4252,9 +4252,10 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       /* Get at the scalar def before the loop, that defines the initial value\n \t of the reduction variable.  */\n       gimple *def_stmt = SSA_NAME_DEF_STMT (reduction_op);\n-      tree op = PHI_ARG_DEF_FROM_EDGE (def_stmt, loop_preheader_edge (loop));\n+      initial_def = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+\t\t\t\t\t   loop_preheader_edge (loop));\n       vec_initial_defs.create (1);\n-      vec_initial_def = get_initial_def_for_reduction (stmt, op,\n+      vec_initial_def = get_initial_def_for_reduction (stmt, initial_def,\n \t\t\t\t\t\t       &adjustment_def);\n       vec_initial_defs.quick_push (vec_initial_def);\n     }\n@@ -4270,9 +4271,25 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       def = vect_defs[i];\n       for (j = 0; j < ncopies; j++)\n         {\n-          /* Set the loop-entry arg of the reduction-phi.  */\n-          add_phi_arg (as_a <gphi *> (phi), vec_init_def,\n-\t\t       loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\t  /* Set the loop-entry arg of the reduction-phi.  */\n+\n+\t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t      == INTEGER_INDUC_COND_REDUCTION)\n+\t    {\n+\t      /* Initialise the reduction phi to zero.  This prevents initial\n+\t\t values of non-zero interferring with the reduction op.  */\n+\t      gcc_assert (ncopies == 1);\n+\t      gcc_assert (i == 0);\n+\n+\t      tree vec_init_def_type = TREE_TYPE (vec_init_def);\n+\t      tree zero_vec = build_zero_cst (vec_init_def_type);\n+\n+\t      add_phi_arg (as_a <gphi *> (phi), zero_vec,\n+\t\t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\t    }\n+\t  else\n+\t    add_phi_arg (as_a <gphi *> (phi), vec_init_def,\n+\t\t\t loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \n           /* Set the loop-latch arg for the reduction-phi.  */\n           if (j > 0)\n@@ -4614,10 +4631,28 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t}\n       else\n \ttmp = build1 (reduc_code, scalar_type, new_phi_result);\n+\n       epilog_stmt = gimple_build_assign (new_scalar_dest, tmp);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n       gimple_assign_set_lhs (epilog_stmt, new_temp);\n       gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t  == INTEGER_INDUC_COND_REDUCTION)\n+\t{\n+\t  /* Earlier we set the initial value to be zero.  Check the result\n+\t     and if it is zero then replace with the original initial\n+\t     value.  */\n+\t  tree zero = build_zero_cst (scalar_type);\n+\t  tree zcompare = build2 (EQ_EXPR, boolean_type_node, new_temp, zero);\n+\n+\t  tmp = make_ssa_name (new_scalar_dest);\n+\t  epilog_stmt = gimple_build_assign (tmp, COND_EXPR, zcompare,\n+\t\t\t\t\t     initial_def, new_temp);\n+\t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n+\t  new_temp = tmp;\n+\t}\n+\n       scalar_results.safe_push (new_temp);\n     }\n   else\n@@ -5094,6 +5129,52 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n }\n \n \n+/* Function is_nonwrapping_integer_induction.\n+\n+   Check if STMT (which is part of loop LOOP) both increments and\n+   does not cause overflow.  */\n+\n+static bool\n+is_nonwrapping_integer_induction (gimple *stmt, struct loop *loop)\n+{\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  tree base = PHI_ARG_DEF_FROM_EDGE (stmt, loop_preheader_edge (loop));\n+  tree step = STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo);\n+  tree lhs_type = TREE_TYPE (gimple_phi_result (stmt));\n+  widest_int ni, max_loop_value, lhs_max;\n+  bool overflow = false;\n+\n+  /* Make sure the loop is integer based.  */\n+  if (TREE_CODE (base) != INTEGER_CST\n+      || TREE_CODE (step) != INTEGER_CST)\n+    return false;\n+\n+  /* Check that the induction increments.  */\n+  if (tree_int_cst_sgn (step) == -1)\n+    return false;\n+\n+  /* Check that the max size of the loop will not wrap.  */\n+\n+  if (TYPE_OVERFLOW_UNDEFINED (lhs_type))\n+    return true;\n+\n+  if (! max_stmt_executions (loop, &ni))\n+    return false;\n+\n+  max_loop_value = wi::mul (wi::to_widest (step), ni, TYPE_SIGN (lhs_type),\n+\t\t\t    &overflow);\n+  if (overflow)\n+    return false;\n+\n+  max_loop_value = wi::add (wi::to_widest (base), max_loop_value,\n+\t\t\t    TYPE_SIGN (lhs_type), &overflow);\n+  if (overflow)\n+    return false;\n+\n+  return (wi::min_precision (max_loop_value, TYPE_SIGN (lhs_type))\n+\t  <= TYPE_PRECISION (lhs_type));\n+}\n+\n /* Function vectorizable_reduction.\n \n    Check if STMT performs a reduction operation that can be vectorized.\n@@ -5192,6 +5273,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree def0, def1, tem, op0, op1 = NULL_TREE;\n   bool first_p = true;\n   tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;\n+  bool cond_expr_is_nonwrapping_integer_induction = false;\n \n   /* In case of reduction chain we switch to the first stmt in the chain, but\n      we don't update STMT_INFO, since only the last stmt is marked as reduction\n@@ -5335,6 +5417,16 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n           reduc_def_stmt = def_stmt;\n           reduc_index = i;\n         }\n+\n+      if (i == 1 && code == COND_EXPR && dt == vect_induction_def\n+\t  && is_nonwrapping_integer_induction (def_stmt, loop))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"condition expression based on integer \"\n+\t\t\t     \"induction.\\n\");\n+\t  cond_expr_is_nonwrapping_integer_induction = true;\n+\t}\n     }\n \n   is_simple_use = vect_is_simple_use (ops[i], loop_vinfo, &def_stmt, &dt, &tem);\n@@ -5364,6 +5456,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  (loop_vinfo, reduc_def_stmt,\n \t\t  !nested_cycle, &dummy, false,\n \t\t  &STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info));\n+\n+  if (cond_expr_is_nonwrapping_integer_induction\n+      && STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+    STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) = INTEGER_INDUC_COND_REDUCTION;\n+\n   if (orig_stmt)\n     gcc_assert (tmp == orig_stmt\n \t\t|| GROUP_FIRST_ELEMENT (vinfo_for_stmt (tmp)) == orig_stmt);\n@@ -5491,6 +5588,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       /* This is a reduction pattern: get the vectype from the type of the\n          reduction variable, and get the tree-code from orig_stmt.  */\n+      gcc_assert (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t  == TREE_CODE_REDUCTION);\n       orig_code = gimple_assign_rhs_code (orig_stmt);\n       gcc_assert (vectype_out);\n       vec_mode = TYPE_MODE (vectype_out);\n@@ -5500,6 +5599,12 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       /* Regular reduction: use the same vectype and tree-code as used for\n          the vector code inside the loop can be used for the epilog code. */\n       orig_code = code;\n+\n+      /* For simple condition reductions, replace with the actual expression\n+\t we want to base our reduction around.  */\n+      if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t  == INTEGER_INDUC_COND_REDUCTION)\n+\torig_code = MAX_EXPR;\n     }\n \n   if (nested_cycle)\n@@ -5520,7 +5625,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   epilog_reduc_code = ERROR_MARK;\n \n-  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == TREE_CODE_REDUCTION)\n+  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == TREE_CODE_REDUCTION\n+      || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t== INTEGER_INDUC_COND_REDUCTION)\n     {\n       if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n \t{\n@@ -5546,6 +5653,19 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  epilog_reduc_code = ERROR_MARK;\n \t\t}\n \t    }\n+\n+\t  /* When epilog_reduc_code is ERROR_MARK then a reduction will be\n+\t     generated in the epilog using multiple expressions.  This does not\n+\t     work for condition reductions.  */\n+\t  if (epilog_reduc_code == ERROR_MARK\n+\t      && STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t\t== INTEGER_INDUC_COND_REDUCTION)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"no reduc code for scalar code.\\n\");\n+\t      return false;\n+\t    }\n \t}\n       else\n \t{\n@@ -5580,7 +5700,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   if ((double_reduc\n-       || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n+       || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION\n+       || STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n+\t\t== INTEGER_INDUC_COND_REDUCTION)\n       && ncopies > 1)\n     {\n       if (dump_enabled_p ())"}, {"sha": "1b5c95c10f4d1f03f1a68abb1e862a8c708f75c7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/360e3406fb78ed13f168c25851b343ec6411aa12/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=360e3406fb78ed13f168c25851b343ec6411aa12", "patch": "@@ -64,7 +64,8 @@ enum vect_def_type {\n /* Define type of reduction.  */\n enum vect_reduction_type {\n   TREE_CODE_REDUCTION,\n-  COND_REDUCTION\n+  COND_REDUCTION,\n+  INTEGER_INDUC_COND_REDUCTION\n };\n \n #define VECTORIZABLE_CYCLE_DEF(D) (((D) == vect_reduction_def)           \\"}]}