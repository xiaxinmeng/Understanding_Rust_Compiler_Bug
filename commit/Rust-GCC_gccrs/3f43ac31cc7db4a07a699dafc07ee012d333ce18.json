{"sha": "3f43ac31cc7db4a07a699dafc07ee012d333ce18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y0M2FjMzFjYzdkYjRhMDdhNjk5ZGFmYzA3ZWUwMTJkMzMzY2UxOA==", "commit": {"author": {"name": "Rodrigo Rivas Costa", "email": "rodrigorivascosta@gmail.com", "date": "2011-01-12T23:52:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-01-12T23:52:56Z"}, "message": "cp-tree.h (begin_for_scope): New prototype.\n\n\t* cp-tree.h (begin_for_scope): New prototype.\n\t(begin_for_stmt): Update prototype.\n\t(begin_range_for_stmt): Update prototype.\n\t* init.c (build_vec_init): Update call to begin_for_stmt.\n\t* parser.c (cp_parser_for): New.\n\t(cp_parser_c_for): Add three new parameters.\n\t(cp_parser_range_for): Likewise. Most parsing code removed.\n\t(cp_parser_iteration_statement): Call cp_parser_for instead of\n\tcp_parser_c_for and cp_parser_range_for.\n\t(cp_parser_for_init_statement): Add new parameter and return type.\n\t(cp_parser_block_declaration): Update call to\n\tcp_parser_simple_declaration.\n\t(cp_parser_simple_declaration): Add new parameter.\n\tUpdate call to cp_parser_init_declarator.\n\t(cp_parser_init_declarator): Add new parameter.\n\t* pt.c (tsubst_expr): Update call to begin_for_stmt.\n\t* semantics.c (begin_for_scope): New.\n\t(begin_for_stmt): Add two new parameters.\n\t(begin_range_for_stmt): Likewise.\n\nFrom-SVN: r168731", "tree": {"sha": "998d4ba3e58c9a683f96187fd1478eaad3bcbd80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/998d4ba3e58c9a683f96187fd1478eaad3bcbd80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f43ac31cc7db4a07a699dafc07ee012d333ce18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f43ac31cc7db4a07a699dafc07ee012d333ce18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f43ac31cc7db4a07a699dafc07ee012d333ce18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f43ac31cc7db4a07a699dafc07ee012d333ce18/comments", "author": {"login": "rodrigorc", "id": 1128630, "node_id": "MDQ6VXNlcjExMjg2MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1128630?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rodrigorc", "html_url": "https://github.com/rodrigorc", "followers_url": "https://api.github.com/users/rodrigorc/followers", "following_url": "https://api.github.com/users/rodrigorc/following{/other_user}", "gists_url": "https://api.github.com/users/rodrigorc/gists{/gist_id}", "starred_url": "https://api.github.com/users/rodrigorc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rodrigorc/subscriptions", "organizations_url": "https://api.github.com/users/rodrigorc/orgs", "repos_url": "https://api.github.com/users/rodrigorc/repos", "events_url": "https://api.github.com/users/rodrigorc/events{/privacy}", "received_events_url": "https://api.github.com/users/rodrigorc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7aca2ff21800e3101a0c177151d70fda008484c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7aca2ff21800e3101a0c177151d70fda008484c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7aca2ff21800e3101a0c177151d70fda008484c"}], "stats": {"total": 486, "additions": 306, "deletions": 180}, "files": [{"sha": "5088ba06f716d62de6ff6037642b65c081ba602e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -1,3 +1,25 @@\n+2011-01-12  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\t* cp-tree.h (begin_for_scope): New prototype.\n+\t(begin_for_stmt): Update prototype.\n+\t(begin_range_for_stmt): Update prototype.\n+\t* init.c (build_vec_init): Update call to begin_for_stmt.\n+\t* parser.c (cp_parser_for): New.\n+\t(cp_parser_c_for): Add three new parameters.\n+\t(cp_parser_range_for): Likewise. Most parsing code removed.\n+\t(cp_parser_iteration_statement): Call cp_parser_for instead of\n+\tcp_parser_c_for and cp_parser_range_for.\n+\t(cp_parser_for_init_statement): Add new parameter and return type.\n+\t(cp_parser_block_declaration): Update call to\n+\tcp_parser_simple_declaration.\n+\t(cp_parser_simple_declaration): Add new parameter.\n+\tUpdate call to cp_parser_init_declarator.\n+\t(cp_parser_init_declarator): Add new parameter.\n+\t* pt.c (tsubst_expr): Update call to begin_for_stmt.\n+\t* semantics.c (begin_for_scope): New.\n+\t(begin_for_stmt): Add two new parameters.\n+\t(begin_range_for_stmt): Likewise.\n+\n 2011-01-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* parser.c (cp_parser_objc_at_property_declaration): Improved"}, {"sha": "dddbc01fb4a98c3c3fca4c06a21596e93c1bad23", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -5214,12 +5214,13 @@ extern tree begin_do_stmt\t\t\t(void);\n extern void finish_do_body\t\t\t(tree);\n extern void finish_do_stmt\t\t\t(tree, tree);\n extern tree finish_return_stmt\t\t\t(tree);\n-extern tree begin_for_stmt\t\t\t(void);\n+extern tree begin_for_scope\t\t\t(tree *);\n+extern tree begin_for_stmt\t\t\t(tree, tree);\n extern void finish_for_init_stmt\t\t(tree);\n extern void finish_for_cond\t\t\t(tree, tree);\n extern void finish_for_expr\t\t\t(tree, tree);\n extern void finish_for_stmt\t\t\t(tree);\n-extern tree begin_range_for_stmt\t\t(void);\n+extern tree begin_range_for_stmt\t\t(tree, tree);\n extern void finish_range_for_decl\t\t(tree, tree, tree);\n extern void finish_range_for_stmt\t\t(tree);\n extern tree finish_break_stmt\t\t\t(void);"}, {"sha": "6ffdc2f3f364efeee5857fae919b83fe557bfa7d", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -3125,7 +3125,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n       tree elt_init;\n       tree to;\n \n-      for_stmt = begin_for_stmt ();\n+      for_stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n       finish_for_init_stmt (for_stmt);\n       finish_for_cond (build2 (NE_EXPR, boolean_type_node, iterator,\n \t\t\t       build_int_cst (TREE_TYPE (iterator), -1)),"}, {"sha": "061e8cc7fee3c972ce8c760002c2ecb8dc9961ea", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 200, "deletions": 162, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -1863,12 +1863,14 @@ static tree cp_parser_condition\n   (cp_parser *);\n static tree cp_parser_iteration_statement\n   (cp_parser *);\n-static void cp_parser_for_init_statement\n-  (cp_parser *);\n-static tree  cp_parser_c_for\n-  (cp_parser *);\n-static tree  cp_parser_range_for\n+static bool cp_parser_for_init_statement\n+  (cp_parser *, tree *decl);\n+static tree cp_parser_for\n   (cp_parser *);\n+static tree cp_parser_c_for\n+  (cp_parser *, tree, tree);\n+static tree cp_parser_range_for\n+  (cp_parser *, tree, tree, tree);\n static tree cp_parser_jump_statement\n   (cp_parser *);\n static void cp_parser_declaration_statement\n@@ -1888,7 +1890,7 @@ static void cp_parser_declaration\n static void cp_parser_block_declaration\n   (cp_parser *, bool);\n static void cp_parser_simple_declaration\n-  (cp_parser *, bool);\n+  (cp_parser *, bool, tree *);\n static void cp_parser_decl_specifier_seq\n   (cp_parser *, cp_parser_flags, cp_decl_specifier_seq *, int *);\n static tree cp_parser_storage_class_specifier_opt\n@@ -1938,7 +1940,7 @@ static tree cp_parser_decltype\n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  (cp_parser *, cp_decl_specifier_seq *, VEC (deferred_access_check,gc)*, bool, bool, int, bool *);\n+  (cp_parser *, cp_decl_specifier_seq *, VEC (deferred_access_check,gc)*, bool, bool, int, bool *, tree *);\n static cp_declarator *cp_parser_declarator\n   (cp_parser *, cp_parser_declarator_kind, int *, bool *, bool);\n static cp_declarator *cp_parser_direct_declarator\n@@ -8694,21 +8696,38 @@ cp_parser_condition (cp_parser* parser)\n   return cp_parser_expression (parser, /*cast_p=*/false, NULL);\n }\n \n-/* Parses a traditional for-statement until the closing ')', not included. */\n+/* Parses a for-statement or range-for-statement until the closing ')',\n+   not included. */\n \n static tree\n-cp_parser_c_for (cp_parser *parser)\n+cp_parser_for (cp_parser *parser)\n {\n-  /* Normal for loop */\n-  tree stmt;\n-  tree condition = NULL_TREE;\n-  tree expression = NULL_TREE;\n+  tree init, scope, decl;\n+  bool is_range_for;\n \n   /* Begin the for-statement.  */\n-  stmt = begin_for_stmt ();\n+  scope = begin_for_scope (&init);\n \n   /* Parse the initialization.  */\n-  cp_parser_for_init_statement (parser);\n+  is_range_for = cp_parser_for_init_statement (parser, &decl);\n+\n+  if (is_range_for)\n+    return cp_parser_range_for (parser, scope, init, decl);\n+  else\n+    return cp_parser_c_for (parser, scope, init);\n+}\n+\n+static tree\n+cp_parser_c_for (cp_parser *parser, tree scope, tree init)\n+{\n+  /* Normal for loop */\n+  tree condition = NULL_TREE;\n+  tree expression = NULL_TREE;\n+  tree stmt;\n+\n+  stmt = begin_for_stmt (scope, init);\n+  /* The for-init-statement has already been parsed in\n+     cp_parser_for_init_statement, so no work is needed here.  */\n   finish_for_init_stmt (stmt);\n \n   /* If there's a condition, process it.  */\n@@ -8729,60 +8748,27 @@ cp_parser_c_for (cp_parser *parser)\n /* Tries to parse a range-based for-statement:\n \n   range-based-for:\n-    type-specifier-seq declarator : expression\n-\n-  If succesful, assigns to *DECL the DECLARATOR and to *EXPR the\n-  expression. Note that the *DECL is returned unfinished, so\n-  later you should call cp_finish_decl().\n+    decl-specifier-seq declarator : expression\n \n-  Returns TRUE iff a range-based for is parsed. */\n+  The decl-specifier-seq declarator and the `:' are already parsed by\n+  cp_parser_for_init_statement. If processing_template_decl it returns a\n+  newly created RANGE_FOR_STMT; if not, it is converted to a\n+  regular FOR_STMT.  */\n \n static tree\n-cp_parser_range_for (cp_parser *parser)\n+cp_parser_range_for (cp_parser *parser, tree scope, tree init, tree range_decl)\n {\n-  tree stmt, range_decl, range_expr;\n-  cp_decl_specifier_seq type_specifiers;\n-  cp_declarator *declarator;\n-  const char *saved_message;\n-  tree attributes, pushed_scope;\n-  bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+  tree stmt, range_expr;\n \n-  parser->colon_corrects_to_scope_p = false;\n-  cp_parser_parse_tentatively (parser);\n-  /* New types are not allowed in the type-specifier-seq for a\n-     range-based for loop.  */\n-  saved_message = parser->type_definition_forbidden_message;\n-  parser->type_definition_forbidden_message\n-    = G_(\"types may not be defined in range-based for loops\");\n-  /* Parse the type-specifier-seq.  */\n-  cp_parser_type_specifier_seq (parser, /*is_declaration==*/true,\n-\t\t\t\t/*is_trailing_return=*/false,\n-\t\t\t\t&type_specifiers);\n-  /* Restore the saved message.  */\n-  parser->type_definition_forbidden_message = saved_message;\n-  /* If all is well, we might be looking at a declaration.  */\n-  if (cp_parser_error_occurred (parser))\n+  /* If the variable from a range-for is not actually used, GCC would issue\n+     \"unused variable\" warnings, and the user could do little to prevent them.\n+     So we always mark it as used.  */\n+  if (range_decl != error_mark_node)\n     {\n-      cp_parser_abort_tentative_parse (parser);\n-      stmt = NULL_TREE;\n-      goto out;\n+      TREE_USED (range_decl) = 1;\n+      DECL_READ_P (range_decl) = 1;\n     }\n-  /* Parse the declarator.  */\n-  declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t     /*ctor_dtor_or_conv_p=*/NULL,\n-\t\t\t\t     /*parenthesized_p=*/NULL,\n-\t\t\t\t     /*member_p=*/false);\n-  /* Parse the attributes.  */\n-  attributes = cp_parser_attributes_opt (parser);\n-  /* The next token should be `:'. */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-    cp_parser_simulate_error (parser);\n \n-  /* Check if it is a range-based for */\n-  if (!cp_parser_parse_definitely (parser))\n-    return NULL_TREE;\n-\n-  cp_parser_require (parser, CPP_COLON, RT_COLON);\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n       bool expr_non_constant_p;\n@@ -8791,29 +8777,18 @@ cp_parser_range_for (cp_parser *parser)\n   else\n     range_expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n \n-  /* If in template, STMT is converted to a normal for-statements\n+  /* If in template, STMT is converted to a normal for-statement\n      at instantiation. If not, it is done just ahead. */\n   if (processing_template_decl)\n-    stmt = begin_range_for_stmt ();\n-  else\n-    stmt = begin_for_stmt ();\n-\n-  /* Create the declaration. It must be after begin{,_range}_for_stmt(). */\n-  range_decl = start_decl (declarator, &type_specifiers,\n-\t\t\t   /*initialized_p=*/SD_INITIALIZED,\n-\t\t\t   attributes, /*prefix_attributes=*/NULL_TREE,\n-\t\t\t   &pushed_scope);\n-  /* No scope allowed here */\n-  pop_scope (pushed_scope);\n-\n-  if (TREE_CODE (stmt) == RANGE_FOR_STMT)\n-    finish_range_for_decl (stmt, range_decl, range_expr);\n+    {\n+      stmt = begin_range_for_stmt (scope, init);\n+      finish_range_for_decl (stmt, range_decl, range_expr);\n+    }\n   else\n-    /* Convert the range-based for loop into a normal for-statement. */\n-    stmt = cp_convert_range_for (stmt, range_decl, range_expr);\n-\n- out:\n-  parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+    {\n+      stmt = begin_for_stmt (scope, init);\n+      stmt = cp_convert_range_for (stmt, range_decl, range_expr);\n+    }\n   return stmt;\n }\n \n@@ -8854,63 +8829,71 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n   tree iter_type, begin_expr, end_expr;\n   tree condition, expression;\n \n-  /* Find out the type deduced by the declaration\n-   * `auto &&__range = range_expr' */\n-  range_type = cp_build_reference_type (make_auto (), true);\n-  range_type = do_auto_deduction (range_type, range_expr,\n-\t\t\t\t  type_uses_auto (range_type));\n-\n-  /* Create the __range variable */\n-  range_temp = build_decl (input_location, VAR_DECL,\n-\t\t\t   get_identifier (\"__for_range\"), range_type);\n-  TREE_USED (range_temp) = 1;\n-  DECL_ARTIFICIAL (range_temp) = 1;\n-  pushdecl (range_temp);\n-  cp_finish_decl (range_temp, range_expr,\n-\t\t  /*is_constant_init*/false, NULL_TREE,\n-\t\t  LOOKUP_ONLYCONVERTING);\n-\n-  range_temp = convert_from_reference (range_temp);\n-\n-  if (TREE_CODE (TREE_TYPE (range_temp)) == ARRAY_TYPE)\n-    {\n-      /* If RANGE_TEMP is an array we will use pointer arithmetic */\n-      iter_type = build_pointer_type (TREE_TYPE (TREE_TYPE (range_temp)));\n-      begin_expr = range_temp;\n-      end_expr\n-\t= build_binary_op (input_location, PLUS_EXPR,\n-\t\t\t   range_temp,\n-\t\t\t   array_type_nelts_top (TREE_TYPE (range_temp)), 0);\n-    }\n+  if (range_decl == error_mark_node || range_expr == error_mark_node)\n+    /* If an error happened previously do nothing or else a lot of\n+       unhelpful errors would be issued.  */\n+    begin_expr = end_expr = iter_type = error_mark_node;\n   else\n     {\n-      /* If it is not an array, we must call begin(__range)/end__range() */\n-      VEC(tree,gc) *vec;\n-\n-      begin_expr = get_identifier (\"begin\");\n-      vec = make_tree_vector ();\n-      VEC_safe_push (tree, gc, vec, range_temp);\n-      begin_expr = perform_koenig_lookup (begin_expr, vec,\n-\t\t\t\t\t  /*include_std=*/true);\n-      begin_expr = finish_call_expr (begin_expr, &vec, false, true,\n-\t\t\t\t     tf_warning_or_error);\n-      release_tree_vector (vec);\n-\n-      end_expr = get_identifier (\"end\");\n-      vec = make_tree_vector ();\n-      VEC_safe_push (tree, gc, vec, range_temp);\n-      end_expr = perform_koenig_lookup (end_expr, vec,\n-\t\t\t\t\t/*include_std=*/true);\n-      end_expr = finish_call_expr (end_expr, &vec, false, true,\n-\t\t\t\t   tf_warning_or_error);\n-      release_tree_vector (vec);\n-\n-      /* The unqualified type of the __begin and __end temporaries should\n-      * be the same as required by the multiple auto declaration */\n-      iter_type = cv_unqualified (TREE_TYPE (begin_expr));\n-      if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (end_expr))))\n-\terror (\"inconsistent begin/end types in range-based for: %qT and %qT\",\n-\t       TREE_TYPE (begin_expr), TREE_TYPE (end_expr));\n+      /* Find out the type deduced by the declaration\n+       * `auto &&__range = range_expr' */\n+      range_type = cp_build_reference_type (make_auto (), true);\n+      range_type = do_auto_deduction (range_type, range_expr,\n+\t\t\t\t      type_uses_auto (range_type));\n+\n+      /* Create the __range variable */\n+      range_temp = build_decl (input_location, VAR_DECL,\n+\t\t\t       get_identifier (\"__for_range\"), range_type);\n+      TREE_USED (range_temp) = 1;\n+      DECL_ARTIFICIAL (range_temp) = 1;\n+      pushdecl (range_temp);\n+      cp_finish_decl (range_temp, range_expr,\n+\t\t      /*is_constant_init*/false, NULL_TREE,\n+\t\t      LOOKUP_ONLYCONVERTING);\n+\n+      range_temp = convert_from_reference (range_temp);\n+\n+      if (TREE_CODE (TREE_TYPE (range_temp)) == ARRAY_TYPE)\n+\t{\n+\t  /* If RANGE_TEMP is an array we will use pointer arithmetic */\n+\t  iter_type = build_pointer_type (TREE_TYPE (TREE_TYPE (range_temp)));\n+\t  begin_expr = range_temp;\n+\t  end_expr\n+\t      = build_binary_op (input_location, PLUS_EXPR,\n+\t\t\t\t range_temp,\n+\t\t\t\t array_type_nelts_top (TREE_TYPE (range_temp)),\n+\t\t\t\t 0);\n+\t}\n+      else\n+\t{\n+\t  /* If it is not an array, we must call begin(__range)/end__range() */\n+\t  VEC(tree,gc) *vec;\n+\n+\t  begin_expr = get_identifier (\"begin\");\n+\t  vec = make_tree_vector ();\n+\t  VEC_safe_push (tree, gc, vec, range_temp);\n+\t  begin_expr = perform_koenig_lookup (begin_expr, vec,\n+\t\t\t\t\t      /*include_std=*/true);\n+\t  begin_expr = finish_call_expr (begin_expr, &vec, false, true,\n+\t\t\t\t\t tf_warning_or_error);\n+\t  release_tree_vector (vec);\n+\n+\t  end_expr = get_identifier (\"end\");\n+\t  vec = make_tree_vector ();\n+\t  VEC_safe_push (tree, gc, vec, range_temp);\n+\t  end_expr = perform_koenig_lookup (end_expr, vec,\n+\t\t\t\t\t    /*include_std=*/true);\n+\t  end_expr = finish_call_expr (end_expr, &vec, false, true,\n+\t\t\t\t       tf_warning_or_error);\n+\t  release_tree_vector (vec);\n+\n+\t  /* The unqualified type of the __begin and __end temporaries should\n+\t   * be the same as required by the multiple auto declaration */\n+\t  iter_type = cv_unqualified (TREE_TYPE (begin_expr));\n+\t  if (!same_type_p (iter_type, cv_unqualified (TREE_TYPE (end_expr))))\n+\t    error (\"inconsistent begin/end types in range-based for: %qT and %qT\",\n+\t\t   TREE_TYPE (begin_expr), TREE_TYPE (end_expr));\n+\t}\n     }\n \n   /* The new for initialization statement */\n@@ -9039,12 +9022,7 @@ cp_parser_iteration_statement (cp_parser* parser)\n \t/* Look for the `('.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n-\tif (cxx_dialect == cxx0x)\n-\t  statement = cp_parser_range_for (parser);\n-\telse\n-\t  statement = NULL_TREE;\n-\tif (statement == NULL_TREE)\n-\t  statement = cp_parser_c_for (parser);\n+\tstatement = cp_parser_for (parser);\n \n \t/* Look for the `)'.  */\n \tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n@@ -9068,14 +9046,15 @@ cp_parser_iteration_statement (cp_parser* parser)\n   return statement;\n }\n \n-/* Parse a for-init-statement.\n+/* Parse a for-init-statement or the declarator of a range-based-for.\n+   Returns true if a range-based-for declaration is seen.\n \n    for-init-statement:\n      expression-statement\n      simple-declaration  */\n \n-static void\n-cp_parser_for_init_statement (cp_parser* parser)\n+static bool\n+cp_parser_for_init_statement (cp_parser* parser, tree *decl)\n {\n   /* If the next token is a `;', then we have an empty\n      expression-statement.  Grammatically, this is also a\n@@ -9085,19 +9064,45 @@ cp_parser_for_init_statement (cp_parser* parser)\n      declaration.  */\n   if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n     {\n+      bool is_range_for = false;\n+      bool saved_colon_corrects_to_scope_p = parser->colon_corrects_to_scope_p;\n+\n+      parser->colon_corrects_to_scope_p = false;\n+\n       /* We're going to speculatively look for a declaration, falling back\n \t to an expression, if necessary.  */\n       cp_parser_parse_tentatively (parser);\n       /* Parse the declaration.  */\n       cp_parser_simple_declaration (parser,\n-\t\t\t\t    /*function_definition_allowed_p=*/false);\n+\t\t\t\t    /*function_definition_allowed_p=*/false,\n+\t\t\t\t    decl);\n+      parser->colon_corrects_to_scope_p = saved_colon_corrects_to_scope_p;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COLON))\n+\t{\n+\t  /* It is a range-for, consume the ':' */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  is_range_for = true;\n+\t  if (cxx_dialect < cxx0x)\n+\t    {\n+\t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n+\t\t\t\"range-based-for loops are not allowed \"\n+\t\t\t\"in C++98 mode\");\n+\t      *decl = error_mark_node;\n+\t    }\n+\t}\n+      else\n+\t  /* The ';' is not consumed yet because we told\n+\t     cp_parser_simple_declaration not to.  */\n+\t  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+\n+      if (cp_parser_parse_definitely (parser))\n+\treturn is_range_for;\n       /* If the tentative parse failed, then we shall need to look for an\n \t expression-statement.  */\n-      if (cp_parser_parse_definitely (parser))\n-\treturn;\n     }\n-\n+  /* If we are here, it is an expression-statement.  */\n   cp_parser_expression_statement (parser, NULL_TREE);\n+  return false;\n }\n \n /* Parse a jump-statement.\n@@ -9584,7 +9589,8 @@ cp_parser_block_declaration (cp_parser *parser,\n     cp_parser_static_assert (parser, /*member_p=*/false);\n   /* Anything else must be a simple-declaration.  */\n   else\n-    cp_parser_simple_declaration (parser, !statement_p);\n+    cp_parser_simple_declaration (parser, !statement_p,\n+\t\t\t\t  /*maybe_range_for_decl*/NULL);\n }\n \n /* Parse a simple-declaration.\n@@ -9597,16 +9603,25 @@ cp_parser_block_declaration (cp_parser *parser,\n      init-declarator-list , init-declarator\n \n    If FUNCTION_DEFINITION_ALLOWED_P is TRUE, then we also recognize a\n-   function-definition as a simple-declaration.  */\n+   function-definition as a simple-declaration.\n+\n+   If MAYBE_RANGE_FOR_DECL is not NULL, the pointed tree will be set to the\n+   parsed declaration if it is an uninitialized single declarator not followed\n+   by a `;', or to error_mark_node otherwise. Either way, the trailing `;',\n+   if present, will not be consumed.  */\n \n static void\n cp_parser_simple_declaration (cp_parser* parser,\n-\t\t\t      bool function_definition_allowed_p)\n+\t\t\t      bool function_definition_allowed_p,\n+\t\t\t      tree *maybe_range_for_decl)\n {\n   cp_decl_specifier_seq decl_specifiers;\n   int declares_class_or_enum;\n   bool saw_declarator;\n \n+  if (maybe_range_for_decl)\n+    *maybe_range_for_decl = NULL_TREE;\n+\n   /* Defer access checks until we know what is being declared; the\n      checks for names appearing in the decl-specifier-seq should be\n      done as if we were in the scope of the thing being declared.  */\n@@ -9681,6 +9696,8 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t  token = cp_lexer_peek_token (parser->lexer);\n \t  gcc_assert (token->type == CPP_COMMA);\n \t  cp_lexer_consume_token (parser->lexer);\n+\t  if (maybe_range_for_decl)\n+\t    *maybe_range_for_decl = error_mark_node;\n \t}\n       else\n \tsaw_declarator = true;\n@@ -9691,7 +9708,8 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t\t\t\t\tfunction_definition_allowed_p,\n \t\t\t\t\t/*member_p=*/false,\n \t\t\t\t\tdeclares_class_or_enum,\n-\t\t\t\t\t&function_definition_p);\n+\t\t\t\t\t&function_definition_p,\n+\t\t\t\t\tmaybe_range_for_decl);\n       /* If an error occurred while parsing tentatively, exit quickly.\n \t (That usually happens when in the body of a function; each\n \t statement is treated as a declaration-statement until proven\n@@ -9721,13 +9739,15 @@ cp_parser_simple_declaration (cp_parser* parser,\n \t      return;\n \t    }\n \t}\n+      if (maybe_range_for_decl && *maybe_range_for_decl == NULL_TREE)\n+\t*maybe_range_for_decl = decl;\n       /* The next token should be either a `,' or a `;'.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       /* If it's a `,', there are more declarators to come.  */\n       if (token->type == CPP_COMMA)\n \t/* will be consumed next time around */;\n       /* If it's a `;', we are done.  */\n-      else if (token->type == CPP_SEMICOLON)\n+      else if (token->type == CPP_SEMICOLON || maybe_range_for_decl)\n \tbreak;\n       /* Anything else is an error.  */\n       else\n@@ -9765,7 +9785,8 @@ cp_parser_simple_declaration (cp_parser* parser,\n     }\n \n   /* Consume the `;'.  */\n-  cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n+  if (!maybe_range_for_decl)\n+      cp_parser_require (parser, CPP_SEMICOLON, RT_SEMICOLON);\n \n  done:\n   pop_deferring_access_checks ();\n@@ -14378,7 +14399,13 @@ cp_parser_asm_definition (cp_parser* parser)\n    have been completely parsed.\n \n    FUNCTION_DEFINITION_P may be NULL if FUNCTION_DEFINITION_ALLOWED_P\n-   is FALSE.  */\n+   is FALSE.\n+\n+   If MAYBE_RANGE_FOR_DECL is not NULL, the pointed tree will be set to the\n+   parsed declaration if it is an uninitialized single declarator not followed\n+   by a `;', or to error_mark_node otherwise. Either way, the trailing `;',\n+   if present, will not be consumed.  If returned, this declarator will be\n+   created with SD_INITIALIZED but will not call cp_finish_decl.  */\n \n static tree\n cp_parser_init_declarator (cp_parser* parser,\n@@ -14387,7 +14414,8 @@ cp_parser_init_declarator (cp_parser* parser,\n \t\t\t   bool function_definition_allowed_p,\n \t\t\t   bool member_p,\n \t\t\t   int declares_class_or_enum,\n-\t\t\t   bool* function_definition_p)\n+\t\t\t   bool* function_definition_p,\n+\t\t\t   tree* maybe_range_for_decl)\n {\n   cp_token *token = NULL, *asm_spec_start_token = NULL,\n            *attributes_start_token = NULL;\n@@ -14408,6 +14436,7 @@ cp_parser_init_declarator (cp_parser* parser,\n   int ctor_dtor_or_conv_p;\n   bool friend_p;\n   tree pushed_scope = NULL;\n+  bool range_for_decl_p = false;\n \n   /* Gather the attributes that were provided with the\n      decl-specifiers.  */\n@@ -14551,6 +14580,8 @@ cp_parser_init_declarator (cp_parser* parser,\n     {\n       is_initialized = SD_INITIALIZED;\n       initialization_kind = token->type;\n+      if (maybe_range_for_decl)\n+\t*maybe_range_for_decl = error_mark_node;\n \n       if (token->type == CPP_EQ\n \t  && function_declarator_p (declarator))\n@@ -14569,8 +14600,13 @@ cp_parser_init_declarator (cp_parser* parser,\n       if (token->type != CPP_COMMA\n \t  && token->type != CPP_SEMICOLON)\n \t{\n-\t  cp_parser_error (parser, \"expected initializer\");\n-\t  return error_mark_node;\n+\t  if (maybe_range_for_decl && *maybe_range_for_decl != error_mark_node)\n+\t    range_for_decl_p = true;\n+\t  else\n+\t    {\n+\t      cp_parser_error (parser, \"expected initializer\");\n+\t      return error_mark_node;\n+\t    }\n \t}\n       is_initialized = SD_UNINITIALIZED;\n       initialization_kind = CPP_EOF;\n@@ -14603,7 +14639,8 @@ cp_parser_init_declarator (cp_parser* parser,\n       if (parser->in_unbraced_linkage_specification_p)\n \tdecl_specifiers->storage_class = sc_extern;\n       decl = start_decl (declarator, decl_specifiers,\n-\t\t\t is_initialized, attributes, prefix_attributes,\n+\t\t\t range_for_decl_p? SD_INITIALIZED : is_initialized,\n+\t\t\t attributes, prefix_attributes,\n \t\t\t &pushed_scope);\n       /* Adjust location of decl if declarator->id_loc is more appropriate:\n \t set, and decl wasn't merged with another decl, in which case its\n@@ -14717,7 +14754,7 @@ cp_parser_init_declarator (cp_parser* parser,\n \n   /* Finish processing the declaration.  But, skip friend\n      declarations.  */\n-  if (!friend_p && decl && decl != error_mark_node)\n+  if (!friend_p && decl && decl != error_mark_node && !range_for_decl_p)\n     {\n       cp_finish_decl (decl,\n \t\t      initializer, !is_non_constant_init,\n@@ -20071,7 +20108,8 @@ cp_parser_single_declaration (cp_parser* parser,\n \t\t\t\t        /*function_definition_allowed_p=*/true,\n \t\t\t\t        member_p,\n \t\t\t\t        declares_class_or_enum,\n-\t\t\t\t        &function_definition_p);\n+\t\t\t\t        &function_definition_p,\n+\t\t\t\t\tNULL);\n \n     /* 7.1.1-1 [dcl.stc]\n "}, {"sha": "54c1a59a5eb4978e1fcd50a6852c8b1541519809", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -12052,7 +12052,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       }\n \n     case FOR_STMT:\n-      stmt = begin_for_stmt ();\n+      stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n       RECUR (FOR_INIT_STMT (t));\n       finish_for_init_stmt (stmt);\n       tmp = RECUR (FOR_COND (t));\n@@ -12066,7 +12066,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n     case RANGE_FOR_STMT:\n       {\n         tree decl, expr;\n-        stmt = begin_for_stmt ();\n+        stmt = begin_for_stmt (NULL_TREE, NULL_TREE);\n         decl = RANGE_FOR_DECL (t);\n         decl = tsubst (decl, args, complain, in_decl);\n         maybe_push_decl (decl);"}, {"sha": "b9775f4b90903ddf107c45e178c9208fd05bfa5c", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -827,21 +827,44 @@ finish_return_stmt (tree expr)\n   return r;\n }\n \n-/* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */\n+/* Begin the scope of a for-statement or a range-for-statement.\n+   Both the returned trees are to be used in a call to\n+   begin_for_stmt or begin_range_for_stmt.  */\n \n tree\n-begin_for_stmt (void)\n+begin_for_scope (tree *init)\n+{\n+  tree scope = NULL_TREE;\n+  if (flag_new_for_scope > 0)\n+    scope = do_pushlevel (sk_for);\n+\n+  if (processing_template_decl)\n+    *init = push_stmt_list ();\n+  else\n+    *init = NULL_TREE;\n+\n+  return scope;\n+}\n+\n+/* Begin a for-statement.  Returns a new FOR_STMT.\n+   SCOPE and INIT should be the return of begin_for_scope,\n+   or both NULL_TREE  */\n+\n+tree\n+begin_for_stmt (tree scope, tree init)\n {\n   tree r;\n \n   r = build_stmt (input_location, FOR_STMT, NULL_TREE, NULL_TREE,\n \t\t  NULL_TREE, NULL_TREE);\n \n-  if (flag_new_for_scope > 0)\n-    TREE_CHAIN (r) = do_pushlevel (sk_for);\n-\n-  if (processing_template_decl)\n-    FOR_INIT_STMT (r) = push_stmt_list ();\n+  if (scope == NULL_TREE)\n+    {\n+      gcc_assert (!init);\n+      scope = begin_for_scope (&init);\n+    }\n+  FOR_INIT_STMT (r) = init;\n+  TREE_CHAIN (r) = scope;\n \n   return r;\n }\n@@ -925,18 +948,29 @@ finish_for_stmt (tree for_stmt)\n }\n \n /* Begin a range-for-statement.  Returns a new RANGE_FOR_STMT.\n+   SCOPE and INIT should be the return of begin_for_scope,\n+   or both NULL_TREE  .\n    To finish it call finish_for_stmt(). */\n \n tree\n-begin_range_for_stmt (void)\n+begin_range_for_stmt (tree scope, tree init)\n {\n   tree r;\n \n   r = build_stmt (input_location, RANGE_FOR_STMT,\n \t\t  NULL_TREE, NULL_TREE, NULL_TREE);\n \n-  if (flag_new_for_scope > 0)\n-    TREE_CHAIN (r) = do_pushlevel (sk_for);\n+  if (scope == NULL_TREE)\n+    {\n+      gcc_assert (!init);\n+      scope = begin_for_scope (&init);\n+    }\n+\n+  /* RANGE_FOR_STMTs do not use nor save the init tree, so we\n+     pop it now.  */\n+  if (init)\n+    pop_stmt_list (init);\n+  TREE_CHAIN (r) = scope;\n \n   return r;\n }"}, {"sha": "eb0ffefc3026e62c6ffc652066b68ee2dc359218", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -1,3 +1,10 @@\n+2011-01-12  Rodrigo Rivas Costa <rodrigorivascosta@gmail.com>\n+\n+\t* g++.dg/cpp0x/range-for4.C: Delete useless include and duplicated\n+\tcomment.\n+\t* g++.dg/cpp0x/range-for8.C: New.\n+\t* g++.dg/cpp0x/range-for9.C: New.\n+\n 2011-01-12  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR debug/47209"}, {"sha": "afbcf14b26e3b84187e718c95467b812ad1815dd", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for4.C", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for4.C?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -3,8 +3,6 @@\n // { dg-do run }\n // { dg-options \"-std=c++0x\" }\n \n-#include <cstdio>\n-\n /* Preliminary declarations */\n namespace pre\n {\n@@ -47,7 +45,6 @@ container run_me_just_once()\n     return container(1,2);\n }\n \n-/* Template with dependent expression. */\n /* Template with dependent expression. */\n template<typename T> int test1(const T &r)\n {"}, {"sha": "641dfe052c2d402649b69c1e389f97968b9a4a98", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for8.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for8.C?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -0,0 +1,16 @@\n+// Test for range-based for loop when the declarator declares\n+// a new type\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+void test()\n+{\n+    for (struct S { } *x : { (S*)0, (S*)0 } )\n+        ;\n+\n+    for (struct S { } x : { S(), S() } )\n+        ;\n+}"}, {"sha": "96e9cb61fd6a199cc74461b318db348d466c613f", "filename": "gcc/testsuite/g++.dg/cpp0x/range-for9.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f43ac31cc7db4a07a699dafc07ee012d333ce18/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Frange-for9.C?ref=3f43ac31cc7db4a07a699dafc07ee012d333ce18", "patch": "@@ -0,0 +1,11 @@\n+// Test for range-based for loop error in C++98 mode\n+\n+// { dg-do compile }\n+// { dg-options \"-std=c++98\" }\n+\n+void test()\n+{\n+    int a[] = {0,1,2};\n+    for (int x : a)  // { dg-error \"range-based-for\" }\n+        ;\n+}"}]}