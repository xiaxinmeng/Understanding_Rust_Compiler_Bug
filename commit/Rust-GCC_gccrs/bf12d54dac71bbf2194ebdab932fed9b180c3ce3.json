{"sha": "bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYxMmQ1NGRhYzcxYmJmMjE5NGViZGFiOTMyZmVkOWIxODBjM2NlMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-10T15:10:35Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-10T15:10:35Z"}, "message": "cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): non-NULL NODE is always a TREE_VEC of non-zero size.\n\ncp:\n\t* cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): non-NULL\n\tNODE is always a TREE_VEC of non-zero size.\n\t(NUM_TMPL_ARGS): NODE is always a TREE_VEC.\n\t* decl2.c (arg_assoc): Template args will be a vec.\n\t* error.c (dump_decl) <TEMPLATE_ID_EXPR case>: Call\n\tdump_template_argument_list.\n\t(dump_template_parms): Args will be a vec.\n\t* parser.c (cp_parser_template_argument_list): Produce a\n\tvector, not a list.\n\t* pt.c (coerce_template_parms): Args are always vectors.\n\t(mangle_class_name_for_template): Likewise.\n\t(lookup_template_function): Likewise.\n\t(lookup_template_class): Likewise.\n\t(tsubst_template_args): Likewise.\n\t(tsubst_baselink): Use tsubst_template_args.\n\t(tsubst_qualified_id): Likewise.\n\t(tsubst_copy) <TEMPLATE_ID_EXPR case>: Likewise.\n\t(tsubst_copy_and_build) <TEMPLATE_ID_EXPR case>: Likewise.\n\t(any_dependent_template_args_p):  Args are always vectors.\n\t* tree.c (cp_tree_equal): Add TEMPLATE_ID_EXPR case.\n\nFrom-SVN: r70295", "tree": {"sha": "109c3a497d9166c241c1e9e9f64cc98e907d59a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/109c3a497d9166c241c1e9e9f64cc98e907d59a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/comments", "author": null, "committer": null, "parents": [{"sha": "ffc76561784fdb1f6607af45bd37aee531e193df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffc76561784fdb1f6607af45bd37aee531e193df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffc76561784fdb1f6607af45bd37aee531e193df"}], "stats": {"total": 268, "additions": 129, "deletions": 139}, "files": [{"sha": "47c1afc84d1728ed38c44b55d134b23b22d9278a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -1,5 +1,26 @@\n 2003-08-10  Nathan Sidwell  <nathan@codesourcery.com>\n \n+\t* cp-tree.h (TMPL_ARGS_HAVE_MULTIPLE_LEVELS): non-NULL\n+\tNODE is always a TREE_VEC of non-zero size.\n+\t(NUM_TMPL_ARGS): NODE is always a TREE_VEC.\n+\t* decl2.c (arg_assoc): Template args will be a vec.\n+\t* error.c (dump_decl) <TEMPLATE_ID_EXPR case>: Call\n+\tdump_template_argument_list.\n+\t(dump_template_parms): Args will be a vec.\n+\t* parser.c (cp_parser_template_argument_list): Produce a\n+\tvector, not a list.\n+\t* pt.c (coerce_template_parms): Args are always vectors.\n+\t(mangle_class_name_for_template): Likewise.\n+\t(lookup_template_function): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(tsubst_template_args): Likewise.\n+\t(tsubst_baselink): Use tsubst_template_args.\n+\t(tsubst_qualified_id): Likewise.\n+\t(tsubst_copy) <TEMPLATE_ID_EXPR case>: Likewise.\n+\t(tsubst_copy_and_build) <TEMPLATE_ID_EXPR case>: Likewise.\n+\t(any_dependent_template_args_p):  Args are always vectors.\n+\t* tree.c (cp_tree_equal): Add TEMPLATE_ID_EXPR case.\n+\n \tPR c++/11670\n \t* call.c (convert_like_real): Add rvalue binding error message.\n \t* error.c (dump_expr) <NOP_EXPR case>: Detect when the no expr is"}, {"sha": "a5fa243a167249b809968ad0980d9db1292a98f2", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -207,10 +207,10 @@ DEFTREECODE (USING_STMT, \"using_directive\", 'e', 1)\n DEFTREECODE (DEFAULT_ARG, \"default_arg\", 'x', 0)\n \n /* A template-id, like foo<int>.  The first operand is the template.\n-   The second is the TREE_LIST or TREE_VEC of explicitly specified\n-   arguments.  The template will be a FUNCTION_DECL, TEMPLATE_DECL, or\n-   an OVERLOAD.  If the template-id refers to a member template, the\n-   template may be an IDENTIFIER_NODE.  */\n+   The second is NULL if there are no explicit arguments, or a\n+   TREE_VEC of arguments.  The template will be a FUNCTION_DECL,\n+   TEMPLATE_DECL, or an OVERLOAD.  If the template-id refers to a\n+   member template, the template may be an IDENTIFIER_NODE.  */\n DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", 'e', 2)\n \n /* A list-like node for chaining overloading candidates. TREE_TYPE is "}, {"sha": "d47c3077d093a3e9515e7faa6ec7e7688f3c79d9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -2203,11 +2203,8 @@ struct lang_decl GTY(())\n \n /* Nonzero if the template arguments is actually a vector of vectors,\n    rather than just a vector.  */\n-#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \\\n-  ((NODE) != NULL_TREE\t\t\t\t\t\t\\\n-   && TREE_CODE (NODE) == TREE_VEC\t\t\t\t\\\n-   && TREE_VEC_LENGTH (NODE) > 0\t\t\t\t\\\n-   && TREE_VEC_ELT (NODE, 0) != NULL_TREE\t\t\t\\\n+#define TMPL_ARGS_HAVE_MULTIPLE_LEVELS(NODE) \t\t\\\n+  (NODE && TREE_VEC_ELT (NODE, 0)\t\t\t\\\n    && TREE_CODE (TREE_VEC_ELT (NODE, 0)) == TREE_VEC)\n \n /* The depth of a template argument vector.  When called directly by\n@@ -2241,9 +2238,7 @@ struct lang_decl GTY(())\n /* Given a single level of template arguments in NODE, return the\n    number of arguments.  */\n #define NUM_TMPL_ARGS(NODE)\t\t\t\t\\\n-  ((NODE) == NULL_TREE ? 0\t\t\t\t\\\n-   : (TREE_CODE (NODE) == TREE_VEC\t\t\t\\\n-      ? TREE_VEC_LENGTH (NODE) : list_length (NODE)))\n+  (TREE_VEC_LENGTH (NODE))\n \n /* Returns the innermost level of template arguments in ARGS.  */\n #define INNERMOST_TEMPLATE_ARGS(NODE) \\"}, {"sha": "556f62a1472554dfcb8b2b29f832970f98babebf", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -3716,7 +3716,7 @@ arg_assoc (struct arg_lookup *k, tree n)\n       tree template = TREE_OPERAND (n, 0);\n       tree args = TREE_OPERAND (n, 1);\n       tree ctx;\n-      tree arg;\n+      int ix;\n \n       if (TREE_CODE (template) == COMPONENT_REF)\n         template = TREE_OPERAND (template, 1);\n@@ -3739,8 +3739,8 @@ arg_assoc (struct arg_lookup *k, tree n)\n \treturn true;\n \n       /* Now the arguments.  */\n-      for (arg = args; arg != NULL_TREE; arg = TREE_CHAIN (arg))\n-\tif (arg_assoc_template_arg (k, TREE_VALUE (arg)) == 1)\n+      for (ix = TREE_VEC_LENGTH (args); ix--;)\n+\tif (arg_assoc_template_arg (k, TREE_VEC_ELT (args, ix)) == 1)\n \t  return true;\n     }\n   else"}, {"sha": "cd44f15cbb42e6af6ffb1a6f38bf240a8cc7c8b2", "filename": "gcc/cp/error.c", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -920,18 +920,14 @@ dump_decl (tree t, int flags)\n \n     case TEMPLATE_ID_EXPR:\n       {\n-\ttree args;\n \ttree name = TREE_OPERAND (t, 0);\n+\t\n \tif (is_overloaded_fn (name))\n \t  name = DECL_NAME (get_first_fn (name));\n \tdump_decl (name, flags);\n \tpp_template_argument_list_start (cxx_pp);\n-\tfor (args = TREE_OPERAND (t, 1); args; args = TREE_CHAIN (args))\n-\t  {\n-\t    dump_template_argument (TREE_VALUE (args), flags);\n-\t    if (TREE_CHAIN (args))\n-\t      pp_separate_with_comma (cxx_pp);\n-\t  }\n+\tif (TREE_OPERAND (t, 1))\n+\t  dump_template_argument_list (TREE_OPERAND (t, 1), flags);\n \tpp_template_argument_list_end (cxx_pp);\n       }\n       break;\n@@ -1256,41 +1252,24 @@ dump_template_parms (tree info, int primary, int flags)\n \t to crash producing error messages.  */\n   if (args && !primary)\n     {\n-      int len = 0;\n-      int ix = 0;\n-      int need_comma = 0;\n+      int len, ix;\n \n-      if (TREE_CODE (args) == TREE_VEC)\n-        {\n-          if (TREE_VEC_LENGTH (args) > 0\n-\t      && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n-\t    args = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+      if (TMPL_ARGS_HAVE_MULTIPLE_LEVELS (args))\n+\targs = TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1);\n+      \n+      len = TREE_VEC_LENGTH (args);\n \n-          len = TREE_VEC_LENGTH (args);\n-        }\n-      else if (TREE_CODE (args) == TREE_LIST)\n-        len = -1;\n-      while (ix != len && args)\n+      for (ix = 0; ix != len; ix++)\n         {\n-          tree arg;\n-          if (len >= 0)\n-            {\n-              arg = TREE_VEC_ELT (args, ix);\n-              ix++;\n-            }\n-          else\n-            {\n-              arg = TREE_VALUE (args);\n-              args = TREE_CHAIN (args);\n-            }\n-          if (need_comma)\n+          tree arg = TREE_VEC_ELT (args, ix);\n+\n+          if (ix)\n             pp_separate_with_comma (cxx_pp);\n           \n           if (!arg)\n             pp_identifier (cxx_pp, \"<template parameter error>\");\n           else\n             dump_template_argument (arg, flags);\n-          need_comma = 1;\n         }\n     }\n   else if (primary)"}, {"sha": "94fea3deb90df662d1c60effaacc68820fd289f1", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -7675,32 +7675,51 @@ cp_parser_template_name (cp_parser* parser,\n      template-argument\n      template-argument-list , template-argument\n \n-   Returns a TREE_LIST representing the arguments, in the order they\n-   appeared.  The TREE_VALUE of each node is a representation of the\n-   argument.  */\n+   Returns a TREE_VEC containing the arguments.   */\n \n static tree\n cp_parser_template_argument_list (cp_parser* parser)\n {\n-  tree arguments = NULL_TREE;\n+  tree fixed_args[10];\n+  unsigned n_args = 0;\n+  unsigned alloced = 10;\n+  tree *arg_ary = fixed_args;\n+  tree vec;\n \n-  while (true)\n+  do\n     {\n       tree argument;\n \n+      if (n_args)\n+\t/* Consume the comma. */\n+\tcp_lexer_consume_token (parser->lexer);\n+      \n       /* Parse the template-argument.  */\n       argument = cp_parser_template_argument (parser);\n-      /* Add it to the list.  */\n-      arguments = tree_cons (NULL_TREE, argument, arguments);\n-      /* If it is not a `,', then there are no more arguments.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n-\tbreak;\n-      /* Otherwise, consume the ','.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      if (n_args == alloced)\n+\t{\n+\t  alloced *= 2;\n+\t  \n+\t  if (arg_ary == fixed_args)\n+\t    {\n+\t      arg_ary = xmalloc (sizeof (tree) * alloced);\n+\t      memcpy (arg_ary, fixed_args, sizeof (tree) * n_args);\n+\t    }\n+\t  else\n+\t    arg_ary = xrealloc (arg_ary, sizeof (tree) * alloced);\n+\t}\n+      arg_ary[n_args++] = argument;\n     }\n+  while (cp_lexer_next_token_is (parser->lexer, CPP_COMMA));\n+\n+  vec = make_tree_vec (n_args);\n \n-  /* We built up the arguments in reverse order.  */\n-  return nreverse (arguments);\n+  while (n_args--)\n+    TREE_VEC_ELT (vec, n_args) = arg_ary[n_args];\n+  \n+  if (arg_ary != fixed_args)\n+    free (arg_ary);\n+  return vec;\n }\n \n /* Parse a template-argument."}, {"sha": "5eba7adf95240f7acd3d6a737e2827d828f1e283", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -3583,7 +3583,7 @@ coerce_template_parms (tree parms,\n   tree new_inner_args;\n \n   inner_args = INNERMOST_TEMPLATE_ARGS (args);\n-  nargs = NUM_TMPL_ARGS (inner_args);\n+  nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n   nparms = TREE_VEC_LENGTH (parms);\n \n   if (nargs > nparms\n@@ -3614,12 +3614,7 @@ coerce_template_parms (tree parms,\n       parm = TREE_VEC_ELT (parms, i);\n \n       /* Calculate the Ith argument.  */\n-      if (inner_args && TREE_CODE (inner_args) == TREE_LIST)\n-\t{\n-\t  arg = TREE_VALUE (inner_args);\n-\t  inner_args = TREE_CHAIN (inner_args);\n-\t}\n-      else if (i < nargs)\n+      if (i < nargs)\n \targ = TREE_VEC_ELT (inner_args, i);\n       else if (require_all_arguments)\n \t/* There must be a default arg in this case. */\n@@ -3752,13 +3747,6 @@ mangle_class_name_for_template (const char* name, tree parms, tree arglist)\n       else\n \tmy_friendly_assert (TREE_CODE (parm) == PARM_DECL, 269);\n \n-      if (TREE_CODE (arg) == TREE_LIST)\n-\t{\n-\t  /* New list cell was built because old chain link was in\n-\t     use.  */\n-\t  my_friendly_assert (TREE_PURPOSE (arg) == NULL_TREE, 270);\n-\t  arg = TREE_VALUE (arg);\n-\t}\n       /* No need to check arglist against parmlist here; we did that\n \t in coerce_template_parms, called from lookup_template_class.  */\n       cat (expr_as_string (arg, TFF_PLAIN_IDENTIFIER));\n@@ -3854,6 +3842,7 @@ lookup_template_function (tree fns, tree arglist)\n   if (fns == error_mark_node || arglist == error_mark_node)\n     return error_mark_node;\n \n+  my_friendly_assert (!arglist || TREE_CODE (arglist) == TREE_VEC, 20030726);\n   if (fns == NULL_TREE)\n     {\n       error (\"non-template used as template\");\n@@ -3904,9 +3893,6 @@ maybe_get_template_decl_from_type_decl (tree decl)\n    parameters, find the desired type.\n \n    D1 is the PTYPENAME terminal, and ARGLIST is the list of arguments.\n-   (Actually ARGLIST may be either a TREE_LIST or a TREE_VEC.  It will\n-   be a TREE_LIST if called directly from the parser, and a TREE_VEC\n-   otherwise.)\n \n    IN_DECL, if non-NULL, is the template declaration we are trying to\n    instantiate.  \n@@ -3932,8 +3918,6 @@ lookup_template_class (tree d1,\n   tree t;\n   \n   timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert ((!arglist || TREE_CODE (arglist) == TREE_LIST)\n-\t\t      == ((complain & tf_user) != 0), 20030724);\n   \n   if (TREE_CODE (d1) == IDENTIFIER_NODE)\n     {\n@@ -5492,30 +5476,18 @@ tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n static tree\n tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  int is_list = !(t && TREE_CODE (t) == TREE_VEC);\n-  int len = is_list ? list_length (t) : TREE_VEC_LENGTH (t);\n+  int len = TREE_VEC_LENGTH (t);\n   int need_new = 0, i;\n-  tree position = t;\n   tree *elts = alloca (len * sizeof (tree));\n   \n   for (i = 0; i < len; i++)\n     {\n-      tree orig_arg;\n-      tree new_arg = NULL_TREE;\n+      tree orig_arg = TREE_VEC_ELT (t, i);\n+      tree new_arg;\n \n-      if (is_list)\n-\t{\n-\t  orig_arg = TREE_VALUE (position);\n-\t  position = TREE_CHAIN (position);\n-\t}\n+      if (TREE_CODE (orig_arg) == TREE_VEC)\n+\tnew_arg = tsubst_template_args (orig_arg, args, complain, in_decl);\n       else\n-\t{\n-\t  orig_arg = TREE_VEC_ELT (t, i);\n-\t  if (TREE_CODE (orig_arg) == TREE_VEC)\n-\t    new_arg = tsubst_template_args (orig_arg, args, complain, in_decl);\n-\t}\n-\n-      if (!new_arg)\n \tnew_arg = tsubst_template_arg (orig_arg, args, complain, in_decl);\n       \n       if (new_arg == error_mark_node)\n@@ -5529,19 +5501,9 @@ tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n   if (!need_new)\n     return t;\n \n-  if (is_list)\n-    {\n-      t = NULL_TREE;\n-\n-      for (i = len; i--;)\n-\tt = tree_cons (NULL_TREE, elts[i], t);\n-    }\n-  else\n-    {\n-      t = make_tree_vec (len);\n-      for (i = 0; i < len; i++)\n-\tTREE_VEC_ELT (t, i) = elts[i];\n-    }\n+  t = make_tree_vec (len);\n+  for (i = 0; i < len; i++)\n+    TREE_VEC_ELT (t, i) = elts[i];\n   \n   return t;\n }\n@@ -7052,9 +7014,9 @@ tsubst_baselink (tree baselink, tree object_type,\n \ttemplate_id_p = true;\n \ttemplate_args = TREE_OPERAND (fns, 1);\n \tfns = TREE_OPERAND (fns, 0);\n-\ttemplate_args = tsubst_copy_and_build (template_args, args,\n-\t\t\t\t\t       complain, in_decl,\n-\t\t\t\t\t       /*function_p=*/false);\n+\tif (template_args)\n+\t  template_args = tsubst_template_args (template_args, args,\n+\t\t\t\t\t\tcomplain, in_decl);\n       }\n     name = DECL_NAME (get_first_fn (fns));\n     baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n@@ -7094,9 +7056,10 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n     {\n       is_template = true;\n-      template_args = tsubst_copy_and_build (TREE_OPERAND (name, 1), \n-\t\t\t\t\t     args, complain, in_decl,\n-\t\t\t\t\t     /*function_p=*/false);\n+      template_args = TREE_OPERAND (name, 1);\n+      if (template_args)\n+\ttemplate_args = tsubst_template_args (template_args, args,\n+\t\t\t\t\t      complain, in_decl);\n       name = TREE_OPERAND (name, 0);\n     }\n   else\n@@ -7431,7 +7394,8 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \ttree targs = TREE_OPERAND (t, 1);\n \n \tfn = tsubst_copy (fn, args, complain, in_decl);\n-\ttargs = tsubst_template_args (targs, args, complain, in_decl);\n+\tif (targs)\n+\t  targs = tsubst_template_args (targs, args, complain, in_decl);\n \t\n \treturn lookup_template_function (fn, targs);\n       }\n@@ -7930,7 +7894,10 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree object;\n \ttree template = RECUR (TREE_OPERAND (t, 0));\n-\ttree targs = RECUR (TREE_OPERAND (t, 1));\n+\ttree targs = TREE_OPERAND (t, 1);\n+\n+\tif (targs)\n+\t  targs = tsubst_template_args (targs, args, complain, in_decl);\n \t\n \tif (TREE_CODE (template) == COMPONENT_REF)\n \t  {\n@@ -11697,29 +11664,14 @@ dependent_template_arg_p (tree arg)\n bool\n any_dependent_template_arguments_p (tree args)\n {\n+  int i;\n+  \n   if (!args)\n     return false;\n \n-  my_friendly_assert (TREE_CODE (args) == TREE_LIST\n-\t\t      || TREE_CODE (args) == TREE_VEC,\n-\t\t      20030707);\n-\n-  if (TREE_CODE (args) == TREE_LIST)\n-    {\n-      while (args)\n-\t{\n-\t  if (dependent_template_arg_p (TREE_VALUE (args)))\n-\t    return true;\n-\t  args = TREE_CHAIN (args);\n-\t}\n-    }\n-  else\n-    {\n-      int i; \n-      for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-\tif (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-\t  return true;\n-    }\n+  for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+    if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n+      return true;\n \n   return false;\n }"}, {"sha": "64676fdf544a2830d48ce7d945710283537960d8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf12d54dac71bbf2194ebdab932fed9b180c3ce3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=bf12d54dac71bbf2194ebdab932fed9b180c3ce3", "patch": "@@ -1587,6 +1587,30 @@ cp_tree_equal (tree t1, tree t2)\n \t      && same_type_p (TREE_TYPE (TEMPLATE_PARM_DECL (t1)),\n \t\t\t      TREE_TYPE (TEMPLATE_PARM_DECL (t2))));\n \n+    case TEMPLATE_ID_EXPR:\n+      {\n+\tunsigned ix;\n+\ttree vec1, vec2;\n+\t\n+\tif (!cp_tree_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0)))\n+\t  return false;\n+\tvec1 = TREE_OPERAND (t1, 1);\n+\tvec2 = TREE_OPERAND (t2, 1);\n+\n+\tif (!vec1 || !vec2)\n+\t  return !vec1 && !vec2;\n+\t\n+\tif (TREE_VEC_LENGTH (vec1) != TREE_VEC_LENGTH (vec2))\n+\t  return false;\n+\n+\tfor (ix = TREE_VEC_LENGTH (vec1); ix--;)\n+\t  if (!cp_tree_equal (TREE_VEC_ELT (vec1, ix),\n+\t\t\t      TREE_VEC_ELT (vec2, ix)))\n+\t    return false;\n+\t\n+\treturn true;\n+      }\n+      \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n       {"}]}