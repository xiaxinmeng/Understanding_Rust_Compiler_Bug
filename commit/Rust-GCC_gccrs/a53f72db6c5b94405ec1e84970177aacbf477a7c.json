{"sha": "a53f72db6c5b94405ec1e84970177aacbf477a7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUzZjcyZGI2YzViOTQ0MDVlYzFlODQ5NzAxNzdhYWNiZjQ3N2E3Yw==", "commit": {"author": {"name": "Gavin Romig-Koch", "email": "gavin@cygnus.com", "date": "1998-11-23T14:43:41Z"}, "committer": {"name": "Gavin Romig-Koch", "email": "gavin@gcc.gnu.org", "date": "1998-11-23T14:43:41Z"}, "message": "Separate the 64 bit version of ABI_32 into ABI_O64.\n\n\t* config/mips/abi.h: Use ABI_O64, duplicating ABI_32 usage.\n\t* config/mips/iris6.h: Same.\n\t* config/mips/mips.md: Same.\n\t* config/mips/mips.c: Same; also add \"-mabi=o64\" option.\n\t* config/mips/mips.h: Same; also define ABI_O64.\n\nFrom-SVN: r23809", "tree": {"sha": "00f89b71d12a0e035d43dfb23e1b21cf939c0023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00f89b71d12a0e035d43dfb23e1b21cf939c0023"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a53f72db6c5b94405ec1e84970177aacbf477a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53f72db6c5b94405ec1e84970177aacbf477a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a53f72db6c5b94405ec1e84970177aacbf477a7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a53f72db6c5b94405ec1e84970177aacbf477a7c/comments", "author": null, "committer": null, "parents": [{"sha": "6bdb985fc9a573ed779448cf5e31abffe062823e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bdb985fc9a573ed779448cf5e31abffe062823e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bdb985fc9a573ed779448cf5e31abffe062823e"}], "stats": {"total": 147, "additions": 95, "deletions": 52}, "files": [{"sha": "94cd01bda8fc0c9e03e7babfec2a5a90868243c7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -1,3 +1,11 @@\n+Mon Nov 23 17:40:37 1998  Gavin Romig-Koch  <gavin@cygnus.com>\n+\n+\t* config/mips/abi.h: Use ABI_O64, duplicating ABI_32 usage.\n+\t* config/mips/iris6.h: Same.\n+\t* config/mips/mips.md: Same.\n+\t* config/mips/mips.c: Same; also add \"-mabi=o64\" option.\n+\t* config/mips/mips.h: Same; also define ABI_O64.\n+\n Mon Nov 23 17:02:27 1998  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t*  configure.in: Use AC_PREREQ(2.12.1)."}, {"sha": "5e5fa39bc59b0e0ab94620bd4a5299c73816b991", "filename": "gcc/config/mips/abi64.h", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fabi64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fabi64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fabi64.h?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -27,18 +27,21 @@ Boston, MA 02111-1307, USA.  */\n \n #undef STACK_BOUNDARY\n #define STACK_BOUNDARY \\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_EABI) ? 64 : 128)\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI) \\\n+   ? 64 : 128)\n \n #undef MIPS_STACK_ALIGN\n-#define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\\\n-  ((mips_abi == ABI_32 || mips_abi == ABI_EABI)\t\t\t\\\n-   ? ((LOC) + 7) & ~7\t\t\t\t\t\t\\\n+#define MIPS_STACK_ALIGN(LOC)\t\t\t\t\t\t\\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\t\\\n+   ? ((LOC) + 7) & ~7\t\t\t\t\t\t\t\\\n    : ((LOC) + 15) & ~15)\n \n #undef GP_ARG_LAST\n-#define GP_ARG_LAST  (mips_abi == ABI_32 ? GP_REG_FIRST + 7 : GP_REG_FIRST + 11)\n+#define GP_ARG_LAST  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\\\n+\t\t      ? GP_REG_FIRST + 7 : GP_REG_FIRST + 11)\n #undef FP_ARG_LAST\n-#define FP_ARG_LAST  (mips_abi == ABI_32 ? FP_REG_FIRST + 15 : FP_REG_FIRST + 19)\n+#define FP_ARG_LAST  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\\\n+\t\t      ? FP_REG_FIRST + 15 : FP_REG_FIRST + 19)\n \n #undef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n #define SUBTARGET_CONDITIONAL_REGISTER_USAGE \\\n@@ -60,11 +63,12 @@ Boston, MA 02111-1307, USA.  */\n }\n \n #undef MAX_ARGS_IN_REGISTERS\n-#define MAX_ARGS_IN_REGISTERS\t(mips_abi == ABI_32 ? 4 : 8)\n+#define MAX_ARGS_IN_REGISTERS ((mips_abi == ABI_32 || mips_abi == ABI_O64) \\\n+\t\t\t       ? 4 : 8)\n \n #undef REG_PARM_STACK_SPACE\n #define REG_PARM_STACK_SPACE(FNDECL) \t\t\t\t\t \\\n-  (mips_abi == ABI_32\t\t\t\t\t\t\t \\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\t \\\n    ? (MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL) \\\n    : 0)\n \n@@ -75,13 +79,15 @@ Boston, MA 02111-1307, USA.  */\n        ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n \t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT))\\\n        : (GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY\t\t\t\\\n-\t  && (mips_abi == ABI_32 || mips_abi == ABI_EABI\t\t\\\n+\t  && (mips_abi == ABI_32\t\t\t\t\t\\\n+\t      || mips_abi == ABI_O64\t\t\t\t\t\\\n+\t      || mips_abi == ABI_EABI\t\t\t\t\t\\\n \t      || GET_MODE_CLASS (MODE) == MODE_INT)))\t\t\t\\\n       ? downward : upward))\n \n #undef RETURN_IN_MEMORY\n #define RETURN_IN_MEMORY(TYPE)\t\t\t\t\t\t\\\n-  (mips_abi == ABI_32\t\t\t\t\t\t\t\\\n+  ((mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\t\\\n    ? TYPE_MODE (TYPE) == BLKmode\t\t\t\t\t\\\n    : (int_size_in_bytes (TYPE)\t\t\t\t\t\t\\\n       > (mips_abi == ABI_EABI ? 2 * UNITS_PER_WORD : 16)))\n@@ -97,7 +103,7 @@ extern struct rtx_def *mips_function_value ();\n #define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n { int mips_off = (! current_function_varargs) && (! (CUM).last_arg_fp);\t\\\n   int mips_fp_off = (! current_function_varargs) && ((CUM).last_arg_fp); \\\n-  if ((mips_abi != ABI_32\t\t\t\t\t\t\\\n+  if (((mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t\\\n        && (CUM).arg_words < MAX_ARGS_IN_REGISTERS - mips_off)\t\t\\\n       || (mips_abi == ABI_EABI\t\t\t\t\t\t\\\n \t  && ! TARGET_SOFT_FLOAT\t\t\t\t\t\\\n@@ -178,7 +184,7 @@ extern struct rtx_def *mips_function_value ();\n     }\t\t\t\t\t\t\t\t\t\\\n }\n \n-#define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32)\n+#define STRICT_ARGUMENT_NAMING (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \n /* A C expression that indicates when an argument must be passed by\n    reference.  If nonzero for an argument, a copy of that argument is"}, {"sha": "3a456b529c470397a46b350fb8e1469b09198597", "filename": "gcc/config/mips/iris6.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Firis6.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Firis6.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Firis6.h?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -303,7 +303,7 @@ rdata_section ()\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (in_section != in_rdata)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      if (mips_abi != ABI_32)\t\t\t\t\t\t\\\n+      if (mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t\\\n \tfprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP_64);\t\\\n       else\t\t\t\t\t\t\t\t\\\n \tfprintf (asm_out_file, \"%s\\n\", CONST_SECTION_ASM_OP_32);\t\\\n@@ -394,7 +394,7 @@ while (0)\n #define ASM_OUTPUT_ALIGNED_LOCAL(STREAM, NAME, SIZE, ALIGN)\t\t   \\\n do\t\t\t\t\t\t\t\t\t   \\\n   {\t\t\t\t\t\t\t\t\t   \\\n-    if (mips_abi != ABI_32)\t\t\t\t\t\t   \\\n+    if (mips_abi != ABI_32 && mips_abi != ABI_O64)\t\t\t   \\\n       {\t\t\t\t\t\t\t\t\t   \\\n \tfprintf (STREAM, \"%s\\n\", BSS_SECTION_ASM_OP);\t\t\t   \\\n \tmips_declare_object (STREAM, NAME, \"\", \":\\n\", 0);\t\t   \\\n@@ -455,7 +455,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n    } while (0)\n \n #undef LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX (mips_abi == ABI_32 ? \"$\" : \".\")\n+#define LOCAL_LABEL_PREFIX ((mips_abi == ABI_32 || mips_abi == ABI_O64) \\\n+\t\t\t    ? \"$\" : \".\")\n \n /* Profiling is supported via libprof1.a not -lc_p as in Irix 3.  */\n /* ??? If no mabi=X option give, but a mipsX option is, then should depend"}, {"sha": "f8b30660703e3ea010504255836993c46c5db59b", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -565,7 +565,7 @@ mips_const_double_ok (op, mode)\n     return 1;\n \n   /* ??? li.s does not work right with SGI's Irix 6 assembler.  */\n-  if (mips_abi != ABI_32 && mips_abi != ABI_EABI)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64 && mips_abi != ABI_EABI)\n     return 0;\n \n   REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n@@ -3690,7 +3690,7 @@ function_arg (cum, mode, type, named)\n   switch (mode)\n     {\n     case SFmode:\n-      if (mips_abi == ABI_32)\n+      if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n \t{\n \t  if (cum->gp_reg_found || cum->arg_number >= 2 || TARGET_SOFT_FLOAT)\n \t    regbase = GP_ARG_FIRST;\n@@ -3726,7 +3726,7 @@ function_arg (cum, mode, type, named)\n \t    cum->arg_words += cum->arg_words & 1;\n \t}\n \n-      if (mips_abi == ABI_32)\n+      if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n \tregbase = ((cum->gp_reg_found\n \t\t    || TARGET_SOFT_FLOAT || TARGET_SINGLE_FLOAT\n \t\t    || cum->arg_number >= 2)\n@@ -3782,7 +3782,7 @@ function_arg (cum, mode, type, named)\n \tabort ();\n \n       if (! type || TREE_CODE (type) != RECORD_TYPE || mips_abi == ABI_32\n-\t  || mips_abi == ABI_EABI || ! named)\n+\t  || mips_abi == ABI_EABI || mips_abi == ABI_O64 || ! named)\n \tret = gen_rtx (REG, mode, regbase + *arg_words + bias);\n       else\n \t{\n@@ -4042,11 +4042,13 @@ override_options ()\n     }\n \n #ifdef MIPS_ABI_DEFAULT\n-  /* Get the ABI to use.  Currently this code is only used for Irix 6.  */\n+  /* Get the ABI to use. */\n   if (mips_abi_string == (char *) 0)\n     mips_abi = MIPS_ABI_DEFAULT;\n   else if (! strcmp (mips_abi_string, \"32\"))\n     mips_abi = ABI_32;\n+  else if (! strcmp (mips_abi_string, \"o64\"))\n+    mips_abi = ABI_O64;\n   else if (! strcmp (mips_abi_string, \"n32\"))\n     mips_abi = ABI_N32;\n   else if (! strcmp (mips_abi_string, \"64\"))\n@@ -4057,7 +4059,8 @@ override_options ()\n     error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n \n   /* A specified ISA defaults the ABI if it was not specified.  */\n-  if (mips_abi_string == 0 && mips_isa_string && mips_abi != ABI_EABI)\n+  if (mips_abi_string == 0 && mips_isa_string \n+      && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n     {\n       if (mips_isa <= 2)\n \tmips_abi = ABI_32;\n@@ -4066,7 +4069,8 @@ override_options ()\n     }\n \n   /* A specified ABI defaults the ISA if it was not specified.  */\n-  else if (mips_isa_string == 0 && mips_abi_string && mips_abi != ABI_EABI)\n+  else if (mips_isa_string == 0 && mips_abi_string \n+\t   && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n     {\n       if (mips_abi == ABI_32)\n \tmips_isa = 1;\n@@ -4079,7 +4083,8 @@ override_options ()\n   /* If both ABI and ISA were specified, check for conflicts.  */\n   else if (mips_isa_string && mips_abi_string)\n     {\n-      if ((mips_isa <= 2 && (mips_abi == ABI_N32 || mips_abi == ABI_64))\n+      if ((mips_isa <= 2 && (mips_abi == ABI_N32 || mips_abi == ABI_64\n+\t\t\t     || mips_abi == ABI_O64))\n \t  || (mips_isa >= 3 && mips_abi == ABI_32))\n \terror (\"-mabi=%s does not support -mips%d\", mips_abi_string, mips_isa);\n     }\n@@ -4253,7 +4258,7 @@ override_options ()\n \tfatal (\"Only MIPS-III or MIPS-IV CPUs can support 64 bit gp registers\");\n     }\n \n-  if (mips_abi != ABI_32)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     flag_pcc_struct_return = 0;\n \n   /* Tell halfpic.c that we have half-pic code if we do.  */\n@@ -5247,7 +5252,7 @@ mips_asm_file_start (stream)\n \n   /* Start a section, so that the first .popsection directive is guaranteed\n      to have a previously defined section to pop back to.  */\n-  if (mips_abi != ABI_32 && mips_abi != ABI_EABI)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64 && mips_abi != ABI_EABI)\n     fprintf (stream, \"\\t.section\\t.text\\n\");\n \n   /* This code exists so that we can put all externs before all symbol\n@@ -5551,7 +5556,8 @@ compute_frame_size (size)\n      The gp reg is callee saved in the 64 bit ABI, so all routines must\n      save the gp reg.  This is not a leaf routine if -p, because of the\n      call to mcount.  */\n-  if (total_size == extra_size && (mips_abi == ABI_32 || mips_abi == ABI_EABI)\n+  if (total_size == extra_size \n+      && (mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\n       && ! profile_flag)\n     total_size = extra_size = 0;\n   else if (TARGET_ABICALLS)\n@@ -5566,7 +5572,7 @@ compute_frame_size (size)\n \n   /* Add in space reserved on the stack by the callee for storing arguments\n      passed in registers.  */\n-  if (mips_abi != ABI_32)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     total_size += MIPS_STACK_ALIGN (current_function_pretend_args_size);\n \n   /* The entry pseudo instruction will allocate 32 bytes on the stack.  */\n@@ -5821,7 +5827,8 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t    insn = emit_move_insn (mem_rtx, reg_rtx);\n \t\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  }\n-\t\telse if (!TARGET_ABICALLS || mips_abi != ABI_32\n+\t\telse if (!TARGET_ABICALLS \n+\t\t\t || (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \t\t\t || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t  {\n \t\t    emit_move_insn (reg_rtx, mem_rtx);\n@@ -5834,7 +5841,8 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t      }\n \t    else\n \t      {\n-\t\tif (store_p || !TARGET_ABICALLS || mips_abi != ABI_32\n+\t\tif (store_p || !TARGET_ABICALLS \n+\t\t    || (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \t\t    || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t  {\n \t\t    int r = regno;\n@@ -6208,7 +6216,7 @@ function_prologue (file, size)\n       fprintf (file, \"\\n\");\n     }\n \n-  if (TARGET_ABICALLS && mips_abi == ABI_32)\n+  if (TARGET_ABICALLS && (mips_abi == ABI_32 || mips_abi == ABI_O64))\n     {\n       char *sp_str = reg_names[STACK_POINTER_REGNUM];\n \n@@ -6336,7 +6344,7 @@ mips_expand_prologue ()\n \n   /* If this function is a varargs function, store any registers that\n      would normally hold arguments ($4 - $7) on the stack.  */\n-  if (mips_abi == ABI_32\n+  if ((mips_abi == ABI_32 || mips_abi == ABI_O64)\n       && (! mips_entry || mips_can_use_return_insn ())\n       && ((TYPE_ARG_TYPES (fntype) != 0\n \t   && (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n@@ -6449,7 +6457,7 @@ mips_expand_prologue ()\n       /* If we are doing svr4-abi, sp move is done by\n          function_prologue.  In mips16 mode with a large frame, we\n          save the registers before adjusting the stack.  */\n-      if ((!TARGET_ABICALLS || mips_abi != ABI_32)\n+      if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \t  && (!TARGET_MIPS16 || tsize <= 32767))\n \t{\n \t  rtx insn;\n@@ -6496,7 +6504,7 @@ mips_expand_prologue ()\n       else if (reg_18_save != NULL_RTX)\n \temit_insn (reg_18_save);\n \n-      if ((!TARGET_ABICALLS || mips_abi != ABI_32)\n+      if ((!TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \t  && TARGET_MIPS16\n \t  && tsize > 32767)\n \t{\n@@ -6527,7 +6535,7 @@ mips_expand_prologue ()\n              instructions when using the frame pointer by pointing the\n              frame pointer ahead of the argument space allocated on\n              the stack.  */\n-\t  if ((! TARGET_ABICALLS || mips_abi != ABI_32)\n+\t  if ((! TARGET_ABICALLS || (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \t      && TARGET_MIPS16\n \t      && tsize > 32767)\n \t    {\n@@ -6570,7 +6578,7 @@ mips_expand_prologue ()\n \t    RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n \n-      if (TARGET_ABICALLS && mips_abi != ABI_32)\n+      if (TARGET_ABICALLS && (mips_abi != ABI_32 && mips_abi != ABI_O64))\n \temit_insn (gen_loadgp (XEXP (DECL_RTL (current_function_decl), 0),\n \t\t\t       gen_rtx (REG, DImode, 25)));\n     }\n@@ -6754,7 +6762,7 @@ mips_expand_epilogue ()\n       /* The GP/PIC register is implicitly used by all SYMBOL_REFs, so if we\n \t are going to restore it, then we must emit a blockage insn to\n \t prevent the scheduler from moving the restore out of the epilogue.  */\n-      else if (TARGET_ABICALLS && mips_abi != ABI_32\n+      else if (TARGET_ABICALLS && mips_abi != ABI_32 && mips_abi != ABI_O64\n \t       && (current_frame_info.mask\n \t\t   & (1L << (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))))\n \temit_insn (gen_blockage ());\n@@ -6947,7 +6955,9 @@ mips_function_value (valtype, func)\n     }\n \n   else if (TREE_CODE (valtype) == RECORD_TYPE\n-\t   && mips_abi != ABI_32 && mips_abi != ABI_EABI)\n+\t   && mips_abi != ABI_32 \n+\t   && mips_abi != ABI_O64 \n+\t   && mips_abi != ABI_EABI)\n     {\n       /* A struct with only one or two floating point fields is returned in\n \t the floating point registers.  */\n@@ -7409,8 +7419,8 @@ mips16_fp_args (file, fp_code, from_fp_p)\n   int gparg, fparg;\n   unsigned int f;\n \n-  /* This code only works for the original 32 bit ABI.  */\n-  if (mips_abi != ABI_32)\n+  /* This code only works for the original 32 bit ABI and the O64 ABI.  */\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     abort ();\n \n   if (from_fp_p)\n@@ -7612,9 +7622,9 @@ build_mips16_call_stub (retval, fnmem, arg_size, fp_code)\n       && strncmp (XSTR (fn, 0), \"__mips16_\", 9) == 0)\n     return 0;\n \n-  /* This code will only work for the standard ABI.  The other ABI's\n+  /* This code will only work for o32 and o64 abis.  The other ABI's \n      require more sophisticated support.  */\n-  if (mips_abi != ABI_32)\n+  if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     abort ();\n \n   /* We can only handle SFmode and DFmode floating point return"}, {"sha": "271570d70c48b37b084bc3bb33983717e33de778", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -76,12 +76,16 @@ enum processor_type {\n #define mips_cpu_attr ((enum attr_cpu)mips_cpu)\n \n /* Which ABI to use.  These are constants because abi64.h must check their\n-   value at preprocessing time.  */\n+   value at preprocessing time.\n+\n+   ABI_32 (original 32, or o32), ABI_N32 (n32), ABI_64 (n64) are all\n+   defined by SGI.  ABI_O64 is o32 extended to work on a 64 bit machine. */\n \n #define ABI_32  0\n #define ABI_N32 1\n #define ABI_64  2\n #define ABI_EABI 3\n+#define ABI_O64  4\n \n #ifndef MIPS_ABI_DEFAULT\n /* We define this away so that there is no extra runtime cost if the target\n@@ -2187,12 +2191,16 @@ extern struct mips_frame_info current_frame_info;\n \t   && (TO) == HARD_FRAME_POINTER_REGNUM)\t\t\t \\\n     (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n \t\t- current_function_outgoing_args_size\t\t\t \\\n-\t\t- ((mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t \\\n+\t\t- ((mips_abi != ABI_32 \t\t\t\t\t \\\n+\t\t    && mips_abi != ABI_O64\t\t\t\t \\\n+\t\t    && mips_abi != ABI_EABI)\t\t\t\t \\\n \t\t   ? current_function_pretend_args_size\t\t\t \\\n \t\t   : 0));\t\t\t\t\t\t \\\n   else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t \\\n     (OFFSET) = (current_frame_info.total_size\t\t\t\t \\\n-\t\t- ((mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t \\\n+\t\t- ((mips_abi != ABI_32 \t\t\t\t\t \\\n+\t\t    && mips_abi != ABI_O64\t\t\t\t \\\n+\t\t    && mips_abi != ABI_EABI)\t\t\t\t \\\n \t\t   ? current_function_pretend_args_size\t\t\t \\\n \t\t   : 0));\t\t\t\t\t\t \\\n   /* Some ABIs store 64 bits to the stack, but Pmode is 32 bits,\t \\\n@@ -2825,7 +2833,9 @@ typedef struct mips_args {\n           /* ??? Reject combining an address with a register for the MIPS  \\\n \t     64 bit ABI, because the SGI assembler can not handle this.  */ \\\n \t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\\\n-\t      && (mips_abi == ABI_32 || mips_abi == ABI_EABI)\t\t\\\n+\t      && (mips_abi == ABI_32\t\t\t\t\t\\\n+\t\t  || mips_abi == ABI_O64\t\t\t\t\\\n+\t\t  || mips_abi == ABI_EABI)\t\t\t\t\\\n \t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\\\n \t      && ! mips_split_addresses\t\t\t\t\t\\\n \t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\\\n@@ -2856,7 +2866,9 @@ typedef struct mips_args {\n     || GET_CODE (X) == CONST_INT || GET_CODE (X) == HIGH\t\t\\\n     || (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n \t&& ! (flag_pic && pic_address_needs_scratch (X))\t\t\\\n-\t&& (mips_abi == ABI_32 || mips_abi == ABI_EABI)))\t\t\\\n+\t&& (mips_abi == ABI_32\t\t\t\t\t\t\\\n+\t    || mips_abi == ABI_O64\t\t\t\t\t\\\n+\t    || mips_abi == ABI_EABI)))\t\t\t\t\t\\\n    && (!HALF_PIC_P () || !HALF_PIC_ADDRESS_P (X)))\n \n /* Define this, so that when PIC, reload won't try to reload invalid\n@@ -2876,7 +2888,9 @@ typedef struct mips_args {\n   ((GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n     || mips_const_double_ok (X, GET_MODE (X)))\t\t\t\t\\\n    && ! (GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-\t && mips_abi != ABI_32 && mips_abi != ABI_EABI)\t\t\t\\\n+\t && mips_abi != ABI_32 \t\t\t\t\t\t\\\n+\t && mips_abi != ABI_O64 \t\t\t\t\t\\\n+         && mips_abi != ABI_EABI)\t\t\t\t\t\\\n    && (! TARGET_MIPS16 || mips16_constant (X, GET_MODE (X), 0, 0)))\n \n /* A C compound statement that attempts to replace X with a valid\n@@ -2939,7 +2953,9 @@ typedef struct mips_args {\n   if (GET_CODE (xinsn) == CONST\t\t\t\t\t\t\\\n       && ((flag_pic && pic_address_needs_scratch (xinsn))\t\t\\\n \t  /* ??? SGI's Irix 6 assembler can't handle CONST.  */\t\t\\\n-\t  || (mips_abi != ABI_32 && mips_abi != ABI_EABI)))\t\t\\\n+\t  || (mips_abi != ABI_32 \t\t\t\t\t\\\n+\t      && mips_abi != ABI_O64\t\t\t\t\t\\\n+\t      && mips_abi != ABI_EABI)))\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx ptr_reg = gen_reg_rtx (Pmode);\t\t\t\t\\\n       rtx constant = XEXP (XEXP (xinsn, 0), 1);\t\t\t\t\\\n@@ -4222,7 +4238,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d-%sLS%d\\n\",\t\t\t\t\\\n \t     Pmode == DImode ? \".dword\" : \".word\",\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n-  else if (mips_abi == ABI_32)\t\t\t\t\t\t\\\n+  else if (mips_abi == ABI_32 || mips_abi == ABI_O64)\t\t\t\\\n     fprintf (STREAM, \"\\t%s\\t%sL%d\\n\",\t\t\t\t\t\\\n \t     Pmode == DImode ? \".gpdword\" : \".gpword\",\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n@@ -4479,7 +4495,9 @@ while (0)\n /* See mips_expand_prologue's use of loadgp for when this should be\n    true.  */\n \n-#define DONT_ACCESS_GBLS_AFTER_EPILOGUE (TARGET_ABICALLS && mips_abi != ABI_32)\n+#define DONT_ACCESS_GBLS_AFTER_EPILOGUE (TARGET_ABICALLS \t\t\\\n+\t\t\t\t\t && mips_abi != ABI_32\t\t\\\n+\t\t\t\t\t && mips_abi != ABI_O64)\n \f\n /* In mips16 mode, we need to look through the function to check for\n    PC relative loads that are out of range.  */"}, {"sha": "5282fe0939d67e253aefae326482bba589bf4a80", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a53f72db6c5b94405ec1e84970177aacbf477a7c/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=a53f72db6c5b94405ec1e84970177aacbf477a7c", "patch": "@@ -8769,7 +8769,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   /* ??? I don't know why this is necessary.  This works around an\n      assembler problem that appears when a label is defined, then referenced\n      in a switch table, then used in a `j' instruction.  */\n-  else if (mips_abi != ABI_32)\n+  else if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     return \\\"%*b\\\\t%l0\\\";\n   else\t\n     return \\\"%*j\\\\t%l0\\\";\n@@ -8960,7 +8960,7 @@ move\\\\t%0,%z4\\\\n\\\\\n   \"*\n {\n   /* .cpadd expands to add REG,REG,$gp when pic, and nothing when not pic.  */\n-  if (mips_abi == ABI_32)\n+  if (mips_abi == ABI_32 || mips_abi == ABI_O64)\n     output_asm_insn (\\\".cpadd\\\\t%0\\\", operands);\n   return \\\"%*j\\\\t%0\\\";\n }\""}]}