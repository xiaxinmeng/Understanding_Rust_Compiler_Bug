{"sha": "eaf883710c0039eca5caea5115e848adb4ab67bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFmODgzNzEwYzAwMzllY2E1Y2FlYTUxMTVlODQ4YWRiNGFiNjdiZA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-01-21T10:00:00Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2021-01-21T10:00:49Z"}, "message": "Fortran: This patch fixes comments 23 and 24 of PR96320.\n\n2021-01-21  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/96320\n\t* decl.c (gfc_match_modproc): It is not an error to find a\n\tmodule procedure declaration within a contains block.\n\t* expr.c (gfc_check_vardef_context): Pure procedure result is\n\tassignable. Change 'own_scope' accordingly.\n\t* resolve.c (resolve_typebound_procedure): A procedure that\n\thas the module procedure attribute is almost certainly a\n\tmodule procedure, whatever its interface.\n\ngcc/testsuite/\n\tPR fortran/96320\n\t* gfortran.dg/module_procedure_5.f90 : New test.\n\t* gfortran.dg/module_procedure_6.f90 : New test.", "tree": {"sha": "fc7baa465ca84ce19178b9c6657ed0932ea636fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc7baa465ca84ce19178b9c6657ed0932ea636fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eaf883710c0039eca5caea5115e848adb4ab67bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf883710c0039eca5caea5115e848adb4ab67bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaf883710c0039eca5caea5115e848adb4ab67bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaf883710c0039eca5caea5115e848adb4ab67bd/comments", "author": null, "committer": null, "parents": [{"sha": "f46a40112caa7e039d949beda94386ff4e436a35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f46a40112caa7e039d949beda94386ff4e436a35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f46a40112caa7e039d949beda94386ff4e436a35"}], "stats": {"total": 91, "additions": 89, "deletions": 2}, "files": [{"sha": "723915822f33129bc44e218401b2c9382be0e150", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=eaf883710c0039eca5caea5115e848adb4ab67bd", "patch": "@@ -9856,7 +9856,8 @@ gfc_match_modproc (void)\n   gfc_namespace *module_ns;\n   gfc_interface *old_interface_head, *interface;\n \n-  if (gfc_state_stack->state != COMP_INTERFACE\n+  if ((gfc_state_stack->state != COMP_INTERFACE\n+       && gfc_state_stack->state != COMP_CONTAINS)\n       || gfc_state_stack->previous == NULL\n       || current_interface.type == INTERFACE_NAMELESS\n       || current_interface.type == INTERFACE_ABSTRACT)"}, {"sha": "4f456fc629a249827346357a97e15323788bef7c", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=eaf883710c0039eca5caea5115e848adb4ab67bd", "patch": "@@ -6243,6 +6243,9 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n \n   /* Variable not assignable from a PURE procedure but appears in\n      variable definition context.  */\n+  own_scope = own_scope\n+\t      || (sym->attr.result && sym->ns->proc_name\n+\t\t  && sym == sym->ns->proc_name->result);\n   if (!pointer && !own_scope && gfc_pure (NULL) && gfc_impure_variable (sym))\n     {\n       if (context)"}, {"sha": "c075d0fa0c4269c1fe81e1833371f322a32b9cca", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=eaf883710c0039eca5caea5115e848adb4ab67bd", "patch": "@@ -14025,7 +14025,8 @@ resolve_typebound_procedure (gfc_symtree* stree)\n       /* Check for F08:C465.  */\n       if ((!proc->attr.subroutine && !proc->attr.function)\n \t  || (proc->attr.proc != PROC_MODULE\n-\t      && proc->attr.if_source != IFSRC_IFBODY)\n+\t      && proc->attr.if_source != IFSRC_IFBODY\n+\t      && !proc->attr.module_procedure)\n \t  || proc->attr.abstract)\n \t{\n \t  gfc_error (\"%qs must be a module procedure or an external \""}, {"sha": "3dafa068100fbe88e0cdf1fe7eafaf53a67b5dbd", "filename": "gcc/testsuite/gfortran.dg/module_procedure_5.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_5.f90?ref=eaf883710c0039eca5caea5115e848adb4ab67bd", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do compile }\n+!\n+! Test the fix for the testcase in comment 23 of PR96320, which used to\n+! fail with the message: Variable \u2018new_foo\u2019 cannot appear in a variable\n+! definition context.\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module foobar\n+  implicit none\n+\n+  type foo\n+    integer bar\n+  end type\n+\n+  interface\n+    pure module function create() result(new_foo)\n+      implicit none\n+      type(foo) new_foo\n+    end function\n+  end interface\n+\n+contains\n+  module procedure create\n+    new_foo%bar = 1  ! Error here\n+  end procedure\n+end module\n+\n+  use foobar\n+  print *, create ()\n+end"}, {"sha": "e642d52ac5fbbe72512cd1a861bc8cf789d2b257", "filename": "gcc/testsuite/gfortran.dg/module_procedure_6.f90", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eaf883710c0039eca5caea5115e848adb4ab67bd/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmodule_procedure_6.f90?ref=eaf883710c0039eca5caea5115e848adb4ab67bd", "patch": "@@ -0,0 +1,51 @@\n+! { dg-do run }\n+!\n+! Test the fix for the testcase in comment 24 of PR96320, which used to\n+! fail with the message: \u2018set_user_defined\u2019 must be a module procedure or\n+! an external procedure with an explicit interface at (1)\n+!\n+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>\n+!\n+module hole_interface\n+  type hole_t\n+    integer :: user_defined\n+    real :: hole_diameter\n+  contains\n+    procedure set_user_defined\n+    procedure set_diameter\n+  end type\n+\n+  interface\n+    module subroutine set_diameter (this, diameter)\n+      class(hole_t) :: this\n+      real :: diameter\n+    end subroutine\n+\n+    module subroutine set_user_defined(this, user_defined)\n+      class(hole_t) :: this\n+      integer :: user_defined\n+    end subroutine\n+  end interface\n+\n+contains\n+  module procedure set_user_defined\n+    this%user_defined = user_defined\n+  end procedure\n+\n+  module procedure set_diameter\n+    this%hole_diameter = diameter\n+    if (this%user_defined .lt. 0) then\n+      call this%set_user_defined (0)\n+    end if\n+  end procedure\n+end module\n+\n+  use hole_interface ! Error was here\n+  type (hole_t) :: ht = hole_t (-1, 0.0)\n+  call ht%set_diameter(1.0)\n+  if ((ht%user_defined .ne. 0) .and. (ht%hole_diameter .ne. 1.0)) stop 1\n+  call ht%set_user_defined (5)\n+  if ((ht%user_defined .ne. 5) .and. (ht%hole_diameter .ne. 1.0)) stop 2\n+  call ht%set_diameter(2.0)\n+  if ((ht%user_defined .ne. 5) .and. (ht%hole_diameter .ne. 2.0)) stop 3\n+end"}]}