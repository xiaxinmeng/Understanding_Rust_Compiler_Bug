{"sha": "6a86928d9882c17b7526d657a38cb314fa0aaba6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE4NjkyOGQ5ODgyYzE3Yjc1MjZkNjU3YTM4Y2IzMTRmYTBhYWJhNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-07-12T13:01:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-12T13:01:17Z"}, "message": "Extend tree code folds to IFN_COND_*\n\nThis patch adds match.pd support for applying normal folds to their\nIFN_COND_* forms.  E.g. the rule:\n\n  (plus @0 (negate @1)) -> (minus @0 @1)\n\nalso allows the fold:\n\n  (IFN_COND_ADD @0 @1 (negate @2) @3) -> (IFN_COND_SUB @0 @1 @2 @3)\n\nActually doing this by direct matches in gimple-match.c would\nprobably lead to combinatorial explosion, so instead, the patch\nmakes gimple_match_op carry a condition under which the operation\nhappens (\"cond\"), and the value to use when the condition is false\n(\"else_value\").  Thus in the example above we'd do the following\n\n(a) convert:\n\n      cond:NULL_TREE (IFN_COND_ADD @0 @1 @4 @3) else_value:NULL_TREE\n\n    to:\n\n      cond:@0 (plus @1 @4) else_value:@3\n\n(b) apply gimple_resimplify to (plus @1 @4)\n\n(c) reintroduce cond and else_value when constructing the result.\n\nNested operations inherit the condition of the outer operation\n(so that we don't introduce extra faults) but have a null else_value.\nIf we try to build such an operation, the target gets to choose what\nelse_value it can handle efficiently: obvious choices include one of\nthe operands or a zero constant.  (The alternative would be to have some\nrepresentation for an undefined value, but that seems a bit invasive,\nand isn't likely to be useful here.)\n\nI've made the condition a mandatory part of the gimple_match_op\nconstructor so that it doesn't accidentally get dropped.\n\n2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* target.def (preferred_else_value): New target hook.\n\t* doc/tm.texi.in (TARGET_PREFERRED_ELSE_VALUE): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* targhooks.h (default_preferred_else_value): Declare.\n\t* targhooks.c (default_preferred_else_value): New function.\n\t* internal-fn.h (conditional_internal_fn_code): Declare.\n\t* internal-fn.c (FOR_EACH_CODE_MAPPING): New macro.\n\t(get_conditional_internal_fn): Use it.\n\t(conditional_internal_fn_code): New function.\n\t* gimple-match.h (gimple_match_cond): New struct.\n\t(gimple_match_op): Add a cond member function.\n\t(gimple_match_op::gimple_match_op): Update all forms to take a\n\tgimple_match_cond.\n\t* genmatch.c (expr::gen_transform): Use the same condition as res_op\n\tfor the suboperation, but don't specify a particular else_value.\n\t* tree-ssa-sccvn.c (vn_nary_simplify, vn_reference_lookup_3)\n\t(visit_nary_op, visit_reference_op_load): Pass\n\tgimple_match_cond::UNCOND to the gimple_match_op constructor.\n\t* gimple-match-head.c: Include tree-eh.h\n\t(convert_conditional_op): New function.\n\t(maybe_resimplify_conditional_op): Likewise.\n\t(gimple_resimplify1): Call maybe_resimplify_conditional_op.\n\t(gimple_resimplify2): Likewise.\n\t(gimple_resimplify3): Likewise.\n\t(gimple_resimplify4): Likewise.\n\t(maybe_push_res_to_seq): Return null for conditional operations.\n\t(try_conditional_simplification): New function.\n\t(gimple_simplify): Call it.  Pass conditions to the gimple_match_op\n\tconstructor.\n\t* match.pd: Fold VEC_COND_EXPRs of an IFN_COND_* call to a new\n\tIFN_COND_* call.\n\t* config/aarch64/aarch64.c (aarch64_preferred_else_value): New\n\tfunction.\n\t(TARGET_PREFERRED_ELSE_VALUE): Redefine.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-cond-arith-2.c: New test.\n\t* gcc.target/aarch64/sve/loop_add_6.c: Likewise.\n\nFrom-SVN: r262586", "tree": {"sha": "57cdf4000ddf7bace5fd55b3cfdb32a5457aa332", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57cdf4000ddf7bace5fd55b3cfdb32a5457aa332"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a86928d9882c17b7526d657a38cb314fa0aaba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a86928d9882c17b7526d657a38cb314fa0aaba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a86928d9882c17b7526d657a38cb314fa0aaba6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a86928d9882c17b7526d657a38cb314fa0aaba6/comments", "author": null, "committer": null, "parents": [{"sha": "d5cbbf873956db1c4eed15a88f935700e7d6012a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5cbbf873956db1c4eed15a88f935700e7d6012a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5cbbf873956db1c4eed15a88f935700e7d6012a"}], "stats": {"total": 532, "additions": 484, "deletions": 48}, "files": [{"sha": "a8694e2c2341390fff6a2bdfe828d519095f9c60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -1,3 +1,40 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* target.def (preferred_else_value): New target hook.\n+\t* doc/tm.texi.in (TARGET_PREFERRED_ELSE_VALUE): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* targhooks.h (default_preferred_else_value): Declare.\n+\t* targhooks.c (default_preferred_else_value): New function.\n+\t* internal-fn.h (conditional_internal_fn_code): Declare.\n+\t* internal-fn.c (FOR_EACH_CODE_MAPPING): New macro.\n+\t(get_conditional_internal_fn): Use it.\n+\t(conditional_internal_fn_code): New function.\n+\t* gimple-match.h (gimple_match_cond): New struct.\n+\t(gimple_match_op): Add a cond member function.\n+\t(gimple_match_op::gimple_match_op): Update all forms to take a\n+\tgimple_match_cond.\n+\t* genmatch.c (expr::gen_transform): Use the same condition as res_op\n+\tfor the suboperation, but don't specify a particular else_value.\n+\t* tree-ssa-sccvn.c (vn_nary_simplify, vn_reference_lookup_3)\n+\t(visit_nary_op, visit_reference_op_load): Pass\n+\tgimple_match_cond::UNCOND to the gimple_match_op constructor.\n+\t* gimple-match-head.c: Include tree-eh.h\n+\t(convert_conditional_op): New function.\n+\t(maybe_resimplify_conditional_op): Likewise.\n+\t(gimple_resimplify1): Call maybe_resimplify_conditional_op.\n+\t(gimple_resimplify2): Likewise.\n+\t(gimple_resimplify3): Likewise.\n+\t(gimple_resimplify4): Likewise.\n+\t(maybe_push_res_to_seq): Return null for conditional operations.\n+\t(try_conditional_simplification): New function.\n+\t(gimple_simplify): Call it.  Pass conditions to the gimple_match_op\n+\tconstructor.\n+\t* match.pd: Fold VEC_COND_EXPRs of an IFN_COND_* call to a new\n+\tIFN_COND_* call.\n+\t* config/aarch64/aarch64.c (aarch64_preferred_else_value): New\n+\tfunction.\n+\t(TARGET_PREFERRED_ELSE_VALUE): Redefine.\n+\n 2018-07-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-streamer-out.c (DFS::DFS_write_tree_body): Do not stream"}, {"sha": "6ef0cc7501840cb61104f973f9ab130477065cfe", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -1320,6 +1320,16 @@ aarch64_get_mask_mode (poly_uint64 nunits, poly_uint64 nbytes)\n   return default_get_mask_mode (nunits, nbytes);\n }\n \n+/* Implement TARGET_PREFERRED_ELSE_VALUE.  Prefer to use the first\n+   arithmetic operand as the else value if the else value doesn't matter,\n+   since that exactly matches the SVE destructive merging form.  */\n+\n+static tree\n+aarch64_preferred_else_value (unsigned, tree, unsigned int, tree *ops)\n+{\n+  return ops[0];\n+}\n+\n /* Implement TARGET_HARD_REGNO_NREGS.  */\n \n static unsigned int\n@@ -17990,6 +18000,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE\n #define TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE \\\n   aarch64_empty_mask_is_expensive\n+#undef TARGET_PREFERRED_ELSE_VALUE\n+#define TARGET_PREFERRED_ELSE_VALUE \\\n+  aarch64_preferred_else_value\n \n #undef TARGET_INIT_LIBFUNCS\n #define TARGET_INIT_LIBFUNCS aarch64_init_libfuncs"}, {"sha": "ff6d5146010baa075f97b5d9f67329ff10d5f8a7", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -6048,6 +6048,22 @@ expanded sequence has been inserted.  This hook is also responsible\n for allocating any storage for reductions when necessary.\n @end deftypefn\n \n+@deftypefn {Target Hook} tree TARGET_PREFERRED_ELSE_VALUE (unsigned @var{ifn}, tree @var{type}, unsigned @var{nops}, tree *@var{ops})\n+This hook returns the target's preferred final argument for a call\n+to conditional internal function @var{ifn} (really of type\n+@code{internal_fn}).  @var{type} specifies the return type of the\n+function and @var{ops} are the operands to the conditional operation,\n+of which there are @var{nops}.\n+\n+For example, if @var{ifn} is @code{IFN_COND_ADD}, the hook returns\n+a value of type @var{type} that should be used when @samp{@var{ops}[0]}\n+and @samp{@var{ops}[1]} are conditionally added together.\n+\n+This hook is only relevant if the target supports conditional patterns\n+like @code{cond_add@var{m}}.  The default implementation returns a zero\n+constant of type @var{type}.\n+@end deftypefn\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "2f97151f341aa26cffdde448790d362bb71d37a9", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -4149,6 +4149,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_GOACC_REDUCTION\n \n+@hook TARGET_PREFERRED_ELSE_VALUE\n+\n @node Anchored Addresses\n @section Anchored Addresses\n @cindex anchored addresses"}, {"sha": "0492e804fc30602336f8a375e4b90dcbe240d16b", "filename": "gcc/genmatch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -2497,8 +2497,8 @@ expr::gen_transform (FILE *f, int indent, const char *dest, bool gimple,\n       /* ???  Building a stmt can fail for various reasons here, seq being\n          NULL or the stmt referencing SSA names occuring in abnormal PHIs.\n \t So if we fail here we should continue matching other patterns.  */\n-      fprintf_indent (f, indent, \"gimple_match_op tem_op (%s, %s\",\n-\t\t      opr_name, type);\n+      fprintf_indent (f, indent, \"gimple_match_op tem_op \"\n+\t\t      \"(res_op->cond.any_else (), %s, %s\", opr_name, type);\n       for (unsigned i = 0; i < ops.length (); ++i)\n \tfprintf (f, \", ops%d[%u]\", depth, i);\n       fprintf (f, \");\\n\");"}, {"sha": "e165a77132bd057716b6ab0070d2034fb4009a6b", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"case-cfn-macros.h\"\n #include \"gimplify.h\"\n #include \"optabs-tree.h\"\n+#include \"tree-eh.h\"\n \n \n /* Forward declarations of the private auto-generated matchers.\n@@ -68,6 +69,95 @@ constant_for_folding (tree t)\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == STRING_CST));\n }\n \n+/* Try to convert conditional operation ORIG_OP into an IFN_COND_*\n+   operation.  Return true on success, storing the new operation in NEW_OP.  */\n+\n+static bool\n+convert_conditional_op (gimple_match_op *orig_op,\n+\t\t\tgimple_match_op *new_op)\n+{\n+  internal_fn ifn;\n+  if (orig_op->code.is_tree_code ())\n+    ifn = get_conditional_internal_fn ((tree_code) orig_op->code);\n+  else\n+    return false;\n+  if (ifn == IFN_LAST)\n+    return false;\n+  unsigned int num_ops = orig_op->num_ops;\n+  new_op->set_op (as_combined_fn (ifn), orig_op->type, num_ops + 2);\n+  new_op->ops[0] = orig_op->cond.cond;\n+  for (unsigned int i = 0; i < num_ops; ++i)\n+    new_op->ops[i + 1] = orig_op->ops[i];\n+  tree else_value = orig_op->cond.else_value;\n+  if (!else_value)\n+    else_value = targetm.preferred_else_value (ifn, orig_op->type,\n+\t\t\t\t\t       num_ops, orig_op->ops);\n+  new_op->ops[num_ops + 1] = else_value;\n+  return true;\n+}\n+\n+/* RES_OP is the result of a simplification.  If it is conditional,\n+   try to replace it with the equivalent UNCOND form, such as an\n+   IFN_COND_* call or a VEC_COND_EXPR.  Also try to resimplify the\n+   result of the replacement if appropriate, adding any new statements to\n+   SEQ and using VALUEIZE as the valueization function.  Return true if\n+   this resimplification occurred and resulted in at least one change.  */\n+\n+static bool\n+maybe_resimplify_conditional_op (gimple_seq *seq, gimple_match_op *res_op,\n+\t\t\t\t tree (*valueize) (tree))\n+{\n+  if (!res_op->cond.cond)\n+    return false;\n+\n+  if (!res_op->cond.else_value\n+      && res_op->code.is_tree_code ())\n+    {\n+      /* The \"else\" value doesn't matter.  If the \"then\" value is a\n+\t gimple value, just use it unconditionally.  This isn't a\n+\t simplification in itself, since there was no operation to\n+\t build in the first place.  */\n+      if (gimple_simplified_result_is_gimple_val (res_op))\n+\t{\n+\t  res_op->cond.cond = NULL_TREE;\n+\t  return false;\n+\t}\n+\n+      /* Likewise if the operation would not trap.  */\n+      bool honor_trapv = (INTEGRAL_TYPE_P (res_op->type)\n+\t\t\t  && TYPE_OVERFLOW_TRAPS (res_op->type));\n+      if (!operation_could_trap_p ((tree_code) res_op->code,\n+\t\t\t\t   FLOAT_TYPE_P (res_op->type),\n+\t\t\t\t   honor_trapv, res_op->op_or_null (1)))\n+\t{\n+\t  res_op->cond.cond = NULL_TREE;\n+\t  return false;\n+\t}\n+    }\n+\n+  /* If the \"then\" value is a gimple value and the \"else\" value matters,\n+     create a VEC_COND_EXPR between them, then see if it can be further\n+     simplified.  */\n+  gimple_match_op new_op;\n+  if (res_op->cond.else_value\n+      && VECTOR_TYPE_P (res_op->type)\n+      && gimple_simplified_result_is_gimple_val (res_op))\n+    {\n+      new_op.set_op (VEC_COND_EXPR, res_op->type,\n+\t\t     res_op->cond.cond, res_op->ops[0],\n+\t\t     res_op->cond.else_value);\n+      *res_op = new_op;\n+      return gimple_resimplify3 (seq, res_op, valueize);\n+    }\n+\n+  /* Otherwise try rewriting the operation as an IFN_COND_* call.\n+     Again, this isn't a simplification in itself, since it's what\n+     RES_OP already described.  */\n+  if (convert_conditional_op (res_op, &new_op))\n+    *res_op = new_op;\n+\n+  return false;\n+}\n \n /* Helper that matches and simplifies the toplevel result from\n    a gimple_simplify run (where we don't want to build\n@@ -93,6 +183,7 @@ gimple_resimplify1 (gimple_seq *seq, gimple_match_op *res_op,\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n \t  res_op->set_value (tem);\n+\t  maybe_resimplify_conditional_op (seq, res_op, valueize);\n \t  return true;\n \t}\n     }\n@@ -122,6 +213,9 @@ gimple_resimplify1 (gimple_seq *seq, gimple_match_op *res_op,\n     }\n   --depth;\n \n+  if (maybe_resimplify_conditional_op (seq, res_op, valueize))\n+    return true;\n+\n   return false;\n }\n \n@@ -151,6 +245,7 @@ gimple_resimplify2 (gimple_seq *seq, gimple_match_op *res_op,\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n \t  res_op->set_value (tem);\n+\t  maybe_resimplify_conditional_op (seq, res_op, valueize);\n \t  return true;\n \t}\n     }\n@@ -190,6 +285,9 @@ gimple_resimplify2 (gimple_seq *seq, gimple_match_op *res_op,\n     }\n   --depth;\n \n+  if (maybe_resimplify_conditional_op (seq, res_op, valueize))\n+    return true;\n+\n   return canonicalized;\n }\n \n@@ -221,6 +319,7 @@ gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n \t  if (TREE_OVERFLOW_P (tem))\n \t    tem = drop_tree_overflow (tem);\n \t  res_op->set_value (tem);\n+\t  maybe_resimplify_conditional_op (seq, res_op, valueize);\n \t  return true;\n \t}\n     }\n@@ -257,6 +356,9 @@ gimple_resimplify3 (gimple_seq *seq, gimple_match_op *res_op,\n     }\n   --depth;\n \n+  if (maybe_resimplify_conditional_op (seq, res_op, valueize))\n+    return true;\n+\n   return canonicalized;\n }\n \n@@ -295,6 +397,9 @@ gimple_resimplify4 (gimple_seq *seq, gimple_match_op *res_op,\n     }\n   --depth;\n \n+  if (maybe_resimplify_conditional_op (seq, res_op, valueize))\n+    return true;\n+\n   return false;\n }\n \n@@ -353,6 +458,12 @@ maybe_push_res_to_seq (gimple_match_op *res_op, gimple_seq *seq, tree res)\n   tree *ops = res_op->ops;\n   unsigned num_ops = res_op->num_ops;\n \n+  /* The caller should have converted conditional operations into an UNCOND\n+     form and resimplified as appropriate.  The conditional form only\n+     survives this far if that conversion failed.  */\n+  if (res_op->cond.cond)\n+    return NULL_TREE;\n+\n   if (res_op->code.is_tree_code ())\n     {\n       if (!res\n@@ -614,6 +725,50 @@ do_valueize (tree op, tree (*valueize)(tree), bool &valueized)\n   return op;\n }\n \n+/* If RES_OP is a call to a conditional internal function, try simplifying\n+   the associated unconditional operation and using the result to build\n+   a new conditional operation.  For example, if RES_OP is:\n+\n+     IFN_COND_ADD (COND, A, B, ELSE)\n+\n+   try simplifying (plus A B) and using the result to build a replacement\n+   for the whole IFN_COND_ADD.\n+\n+   Return true if this approach led to a simplification, otherwise leave\n+   RES_OP unchanged (and so suitable for other simplifications).  When\n+   returning true, add any new statements to SEQ and use VALUEIZE as the\n+   valueization function.\n+\n+   RES_OP is known to be a call to IFN.  */\n+\n+static bool\n+try_conditional_simplification (internal_fn ifn, gimple_match_op *res_op,\n+\t\t\t\tgimple_seq *seq, tree (*valueize) (tree))\n+{\n+  tree_code code = conditional_internal_fn_code (ifn);\n+  if (code == ERROR_MARK)\n+    return false;\n+\n+  unsigned int num_ops = res_op->num_ops;\n+  gimple_match_op cond_op (gimple_match_cond (res_op->ops[0],\n+\t\t\t\t\t      res_op->ops[num_ops - 1]),\n+\t\t\t   code, res_op->type, num_ops - 2);\n+  for (unsigned int i = 1; i < num_ops - 1; ++i)\n+    cond_op.ops[i - 1] = res_op->ops[i];\n+  switch (num_ops - 2)\n+    {\n+    case 2:\n+      if (!gimple_resimplify2 (seq, &cond_op, valueize))\n+\treturn false;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  *res_op = cond_op;\n+  maybe_resimplify_conditional_op (seq, res_op, valueize);\n+  return true;\n+}\n+\n /* The main STMT based simplification entry.  It is used by the fold_stmt\n    and the fold_stmt_to_constant APIs.  */\n \n@@ -699,7 +854,7 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t\t      tree rhs = TREE_OPERAND (rhs1, 1);\n \t\t      lhs = do_valueize (lhs, top_valueize, valueized);\n \t\t      rhs = do_valueize (rhs, top_valueize, valueized);\n-\t\t      gimple_match_op res_op2 (TREE_CODE (rhs1),\n+\t\t      gimple_match_op res_op2 (res_op->cond, TREE_CODE (rhs1),\n \t\t\t\t\t       TREE_TYPE (rhs1), lhs, rhs);\n \t\t      if ((gimple_resimplify2 (seq, &res_op2, valueize)\n \t\t\t   || valueized)\n@@ -770,6 +925,10 @@ gimple_simplify (gimple *stmt, gimple_match_op *res_op, gimple_seq *seq,\n \t      tree arg = gimple_call_arg (stmt, i);\n \t      res_op->ops[i] = do_valueize (arg, top_valueize, valueized);\n \t    }\n+\t  if (internal_fn_p (cfn)\n+\t      && try_conditional_simplification (as_internal_fn (cfn),\n+\t\t\t\t\t\t res_op, seq, valueize))\n+\t    return true;\n \t  switch (num_args)\n \t    {\n \t    case 1:"}, {"sha": "0fe394d169c85b876681bf94cc3cb02d8a9fb8d3", "filename": "gcc/gimple-match.h", "status": "modified", "additions": 74, "deletions": 18, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgimple-match.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fgimple-match.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match.h?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -40,16 +40,57 @@ class code_helper\n   int rep;\n };\n \n+/* Represents the condition under which an operation should happen,\n+   and the value to use otherwise.  The condition applies elementwise\n+   (as for VEC_COND_EXPR) if the values are vectors.  */\n+struct gimple_match_cond\n+{\n+  enum uncond { UNCOND };\n+\n+  /* Build an unconditional op.  */\n+  gimple_match_cond (uncond) : cond (NULL_TREE), else_value (NULL_TREE) {}\n+  gimple_match_cond (tree, tree);\n+\n+  gimple_match_cond any_else () const;\n+\n+  /* The condition under which the operation occurs, or NULL_TREE\n+     if the operation is unconditional.  */\n+  tree cond;\n+\n+  /* The value to use when the condition is false.  This is NULL_TREE if\n+     the operation is unconditional or if the value doesn't matter.  */\n+  tree else_value;\n+};\n+\n+inline\n+gimple_match_cond::gimple_match_cond (tree cond_in, tree else_value_in)\n+  : cond (cond_in), else_value (else_value_in)\n+{\n+}\n+\n+/* Return a gimple_match_cond with the same condition but with an\n+   arbitrary ELSE_VALUE.  */\n+\n+inline gimple_match_cond\n+gimple_match_cond::any_else () const\n+{\n+  return gimple_match_cond (cond, NULL_TREE);\n+}\n+\n /* Represents an operation to be simplified, or the result of the\n    simplification.  */\n struct gimple_match_op\n {\n-  gimple_match_op () : type (NULL_TREE), num_ops (0) {}\n-  gimple_match_op (code_helper, tree, unsigned int);\n-  gimple_match_op (code_helper, tree, tree);\n-  gimple_match_op (code_helper, tree, tree, tree);\n-  gimple_match_op (code_helper, tree, tree, tree, tree);\n-  gimple_match_op (code_helper, tree, tree, tree, tree, tree);\n+  gimple_match_op ();\n+  gimple_match_op (const gimple_match_cond &, code_helper, tree, unsigned int);\n+  gimple_match_op (const gimple_match_cond &,\n+\t\t   code_helper, tree, tree);\n+  gimple_match_op (const gimple_match_cond &,\n+\t\t   code_helper, tree, tree, tree);\n+  gimple_match_op (const gimple_match_cond &,\n+\t\t   code_helper, tree, tree, tree, tree);\n+  gimple_match_op (const gimple_match_cond &,\n+\t\t   code_helper, tree, tree, tree, tree, tree);\n \n   void set_op (code_helper, tree, unsigned int);\n   void set_op (code_helper, tree, tree);\n@@ -63,6 +104,10 @@ struct gimple_match_op\n   /* The maximum value of NUM_OPS.  */\n   static const unsigned int MAX_NUM_OPS = 4;\n \n+  /* The conditions under which the operation is performed, and the value to\n+     use as a fallback.  */\n+  gimple_match_cond cond;\n+\n   /* The operation being performed.  */\n   code_helper code;\n \n@@ -76,49 +121,60 @@ struct gimple_match_op\n   tree ops[MAX_NUM_OPS];\n };\n \n-/* Constructor that takes the code, type and number of operands, but leaves\n-   the caller to fill in the operands.  */\n+inline\n+gimple_match_op::gimple_match_op ()\n+  : cond (gimple_match_cond::UNCOND), type (NULL_TREE), num_ops (0)\n+{\n+}\n+\n+/* Constructor that takes the condition, code, type and number of\n+   operands, but leaves the caller to fill in the operands.  */\n \n inline\n-gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n \t\t\t\t  unsigned int num_ops_in)\n-  : code (code_in), type (type_in), num_ops (num_ops_in)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (num_ops_in)\n {\n }\n \n /* Constructors for various numbers of operands.  */\n \n inline\n-gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n \t\t\t\t  tree op0)\n-  : code (code_in), type (type_in), num_ops (1)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (1)\n {\n   ops[0] = op0;\n }\n \n inline\n-gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n \t\t\t\t  tree op0, tree op1)\n-  : code (code_in), type (type_in), num_ops (2)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (2)\n {\n   ops[0] = op0;\n   ops[1] = op1;\n }\n \n inline\n-gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n \t\t\t\t  tree op0, tree op1, tree op2)\n-  : code (code_in), type (type_in), num_ops (3)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (3)\n {\n   ops[0] = op0;\n   ops[1] = op1;\n   ops[2] = op2;\n }\n \n inline\n-gimple_match_op::gimple_match_op (code_helper code_in, tree type_in,\n+gimple_match_op::gimple_match_op (const gimple_match_cond &cond_in,\n+\t\t\t\t  code_helper code_in, tree type_in,\n \t\t\t\t  tree op0, tree op1, tree op2, tree op3)\n-  : code (code_in), type (type_in), num_ops (4)\n+  : cond (cond_in), code (code_in), type (type_in), num_ops (4)\n {\n   ops[0] = op0;\n   ops[1] = op1;"}, {"sha": "eb5493fcd81c2bc9269e0df92d385f684c12a994", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -3219,6 +3219,21 @@ static void (*const internal_fn_expanders[]) (internal_fn, gcall *) = {\n   0\n };\n \n+/* Invoke T(CODE, IFN) for each conditional function IFN that maps to a\n+   tree code CODE.  */\n+#define FOR_EACH_CODE_MAPPING(T) \\\n+  T (PLUS_EXPR, IFN_COND_ADD) \\\n+  T (MINUS_EXPR, IFN_COND_SUB) \\\n+  T (MULT_EXPR, IFN_COND_MUL) \\\n+  T (TRUNC_DIV_EXPR, IFN_COND_DIV) \\\n+  T (TRUNC_MOD_EXPR, IFN_COND_MOD) \\\n+  T (RDIV_EXPR, IFN_COND_RDIV) \\\n+  T (MIN_EXPR, IFN_COND_MIN) \\\n+  T (MAX_EXPR, IFN_COND_MAX) \\\n+  T (BIT_AND_EXPR, IFN_COND_AND) \\\n+  T (BIT_IOR_EXPR, IFN_COND_IOR) \\\n+  T (BIT_XOR_EXPR, IFN_COND_XOR)\n+\n /* Return a function that only performs CODE when a certain condition is met\n    and that uses a given fallback value otherwise.  For example, if CODE is\n    a binary operation associated with conditional function FN:\n@@ -3238,31 +3253,30 @@ get_conditional_internal_fn (tree_code code)\n {\n   switch (code)\n     {\n-    case PLUS_EXPR:\n-      return IFN_COND_ADD;\n-    case MINUS_EXPR:\n-      return IFN_COND_SUB;\n-    case MIN_EXPR:\n-      return IFN_COND_MIN;\n-    case MAX_EXPR:\n-      return IFN_COND_MAX;\n-    case TRUNC_DIV_EXPR:\n-      return IFN_COND_DIV;\n-    case TRUNC_MOD_EXPR:\n-      return IFN_COND_MOD;\n-    case RDIV_EXPR:\n-      return IFN_COND_RDIV;\n-    case BIT_AND_EXPR:\n-      return IFN_COND_AND;\n-    case BIT_IOR_EXPR:\n-      return IFN_COND_IOR;\n-    case BIT_XOR_EXPR:\n-      return IFN_COND_XOR;\n+#define CASE(CODE, IFN) case CODE: return IFN;\n+      FOR_EACH_CODE_MAPPING(CASE)\n+#undef CASE\n     default:\n       return IFN_LAST;\n     }\n }\n \n+/* If IFN implements the conditional form of a tree code, return that\n+   tree code, otherwise return ERROR_MARK.  */\n+\n+tree_code\n+conditional_internal_fn_code (internal_fn ifn)\n+{\n+  switch (ifn)\n+    {\n+#define CASE(CODE, IFN) case IFN: return CODE;\n+      FOR_EACH_CODE_MAPPING(CASE)\n+#undef CASE\n+    default:\n+      return ERROR_MARK;\n+    }\n+}\n+\n /* Return true if IFN is some form of load from memory.  */\n \n bool"}, {"sha": "a1c8b4cbef6641a6206dc7fb8755eb06a3de1fe0", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -193,6 +193,7 @@ direct_internal_fn_supported_p (internal_fn fn, tree type0, tree type1,\n extern bool set_edom_supported_p (void);\n \n extern internal_fn get_conditional_internal_fn (tree_code);\n+extern tree_code conditional_internal_fn_code (internal_fn);\n \n extern bool internal_load_fn_p (internal_fn);\n extern bool internal_store_fn_p (internal_fn);"}, {"sha": "7e4020eb3efc40591e0a2dde8485b32d14a503f5", "filename": "gcc/match.pd", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -4884,3 +4884,12 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (with { tree op_type = TREE_TYPE (@4); }\n    (if (element_precision (type) == element_precision (op_type))\n     (view_convert (cond_op (bit_not @0) @2 @3 (view_convert:op_type @1)))))))\n+\n+/* Detect cases in which a VEC_COND_EXPR effectively replaces the\n+   \"else\" value of an IFN_COND_*.  */\n+(for cond_op (COND_BINARY)\n+ (simplify\n+  (vec_cond @0 (view_convert? (cond_op @0 @1 @2 @3)) @4)\n+  (with { tree op_type = TREE_TYPE (@3); }\n+   (if (element_precision (type) == element_precision (op_type))\n+    (view_convert (cond_op @0 @1 @2 (view_convert:op_type @4)))))))"}, {"sha": "ff89e72dd2b24ae8bfcc07eea001efd0e297c1e5", "filename": "gcc/target.def", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -2039,6 +2039,25 @@ HOOK_VECTOR_END (vectorize)\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_\"\n \n+DEFHOOK\n+(preferred_else_value,\n+ \"This hook returns the target's preferred final argument for a call\\n\\\n+to conditional internal function @var{ifn} (really of type\\n\\\n+@code{internal_fn}).  @var{type} specifies the return type of the\\n\\\n+function and @var{ops} are the operands to the conditional operation,\\n\\\n+of which there are @var{nops}.\\n\\\n+\\n\\\n+For example, if @var{ifn} is @code{IFN_COND_ADD}, the hook returns\\n\\\n+a value of type @var{type} that should be used when @samp{@var{ops}[0]}\\n\\\n+and @samp{@var{ops}[1]} are conditionally added together.\\n\\\n+\\n\\\n+This hook is only relevant if the target supports conditional patterns\\n\\\n+like @code{cond_add@var{m}}.  The default implementation returns a zero\\n\\\n+constant of type @var{type}.\",\n+ tree,\n+ (unsigned ifn, tree type, unsigned nops, tree *ops),\n+ default_preferred_else_value)\n+\n DEFHOOK\n (record_offload_symbol,\n  \"Used when offloaded functions are seen in the compilation unit and no named\\n\\"}, {"sha": "9b06d7a8face163bc194e76bd8e16ba8776052e9", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -2306,4 +2306,12 @@ default_select_early_remat_modes (sbitmap)\n {\n }\n \n+/* The default implementation of TARGET_PREFERRED_ELSE_VALUE.  */\n+\n+tree\n+default_preferred_else_value (unsigned, tree type, unsigned, tree *)\n+{\n+  return build_zero_cst (type);\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "8d234cf946771e26a40698126d5c410fe695896f", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -283,5 +283,6 @@ extern enum flt_eval_method\n default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED);\n extern bool default_stack_clash_protection_final_dynamic_probe (rtx);\n extern void default_select_early_remat_modes (sbitmap);\n+extern tree default_preferred_else_value (unsigned, tree, unsigned, tree *);\n \n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "8ce8a41a351d3c0e194ed85d22fa2737e18208ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -1,3 +1,8 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-cond-arith-2.c: New test.\n+\t* gcc.target/aarch64/sve/loop_add_6.c: Likewise.\n+\n 2018-07-12  Richard Biener  <rguenther@suse.de>\n \n \tPR target/84829"}, {"sha": "15ec005df265a62863d1fa4acae3965f68ce00dd", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-2.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-2.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fgimple -fdump-tree-optimized -ffast-math\" } */\n+\n+double __GIMPLE (startwith(\"loop\"))\n+neg_xi (double *x)\n+{\n+  int i;\n+  long unsigned int index;\n+  long unsigned int offset;\n+  double * xi_ptr;\n+  double xi;\n+  double neg_xi;\n+  double res;\n+  unsigned int ivtmp;\n+\n+ bb_1:\n+  goto bb_2;\n+\n+ bb_2:\n+  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);\n+  i_4 = __PHI (bb_1: 0, bb_3: i_5);\n+  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);\n+  index = (long unsigned int) i_4;\n+  offset = index * 8UL;\n+  xi_ptr = x_8(D) + offset;\n+  xi = *xi_ptr;\n+  neg_xi = -xi;\n+  res_2 = neg_xi + res_1;\n+  i_5 = i_4 + 1;\n+  ivtmp_7 = ivtmp_6 - 1U;\n+  if (ivtmp_7 != 0U)\n+    goto bb_3;\n+  else\n+    goto bb_4;\n+\n+ bb_3:\n+  goto bb_2;\n+\n+ bb_4:\n+  res_3 = __PHI (bb_2: res_2);\n+  return res_3;\n+}\n+\n+/* { dg-final { scan-tree-dump { = \\.COND_ADD} \"vect\" { target { vect_double_cond_arith && vect_fully_masked } } } } */\n+/* { dg-final { scan-tree-dump { = \\.COND_SUB} \"optimized\" { target { vect_double_cond_arith && vect_fully_masked } } } } */"}, {"sha": "aab5eddddb0f3011d680051bb4852bbc552d8f37", "filename": "gcc/testsuite/gcc.target/aarch64/sve/loop_add_6.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Floop_add_6.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fgimple -ffast-math\" } */\n+\n+double __GIMPLE (startwith(\"loop\"))\n+neg_xi (double *x)\n+{\n+  int i;\n+  long unsigned int index;\n+  long unsigned int offset;\n+  double * xi_ptr;\n+  double xi;\n+  double neg_xi;\n+  double res;\n+  unsigned int ivtmp;\n+\n+ bb_1:\n+  goto bb_2;\n+\n+ bb_2:\n+  res_1 = __PHI (bb_1: 0.0, bb_3: res_2);\n+  i_4 = __PHI (bb_1: 0, bb_3: i_5);\n+  ivtmp_6 = __PHI (bb_1: 100U, bb_3: ivtmp_7);\n+  index = (long unsigned int) i_4;\n+  offset = index * 8UL;\n+  xi_ptr = x_8(D) + offset;\n+  xi = *xi_ptr;\n+  neg_xi = -xi;\n+  res_2 = neg_xi + res_1;\n+  i_5 = i_4 + 1;\n+  ivtmp_7 = ivtmp_6 - 1U;\n+  if (ivtmp_7 != 0U)\n+    goto bb_3;\n+  else\n+    goto bb_4;\n+\n+ bb_3:\n+  goto bb_2;\n+\n+ bb_4:\n+  res_3 = __PHI (bb_2: res_2);\n+  return res_3;\n+}\n+\n+/* { dg-final { scan-assembler {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m} } } */\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */\n+/* { dg-final { scan-assembler-not {\\tmovprfx\\t} } } */"}, {"sha": "4a2f70293b885bf6ba419bca62b760bdf9baadb6", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a86928d9882c17b7526d657a38cb314fa0aaba6/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=6a86928d9882c17b7526d657a38cb314fa0aaba6", "patch": "@@ -1786,7 +1786,8 @@ vn_nary_simplify (vn_nary_op_t nary)\n {\n   if (nary->length > gimple_match_op::MAX_NUM_OPS)\n     return NULL_TREE;\n-  gimple_match_op op (nary->opcode, nary->type, nary->length);\n+  gimple_match_op op (gimple_match_cond::UNCOND, nary->opcode,\n+\t\t      nary->type, nary->length);\n   memcpy (op.ops, nary->op, sizeof (tree) * nary->length);\n   return vn_nary_build_or_lookup_1 (&op, false);\n }\n@@ -2014,8 +2015,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t  else if (INTEGRAL_TYPE_P (vr->type)\n \t\t   && known_eq (ref->size, 8))\n \t    {\n-\t      gimple_match_op res_op (NOP_EXPR, vr->type,\n-\t\t\t\t      gimple_call_arg (def_stmt, 1));\n+\t      gimple_match_op res_op (gimple_match_cond::UNCOND, NOP_EXPR,\n+\t\t\t\t      vr->type, gimple_call_arg (def_stmt, 1));\n \t      val = vn_nary_build_or_lookup (&res_op);\n \t      if (!val\n \t\t  || (TREE_CODE (val) == SSA_NAME\n@@ -2155,7 +2156,8 @@ vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,\n \t      || known_eq (ref->size, TYPE_PRECISION (vr->type)))\n \t  && multiple_p (ref->size, BITS_PER_UNIT))\n \t{\n-\t  gimple_match_op op (BIT_FIELD_REF, vr->type,\n+\t  gimple_match_op op (gimple_match_cond::UNCOND,\n+\t\t\t      BIT_FIELD_REF, vr->type,\n \t\t\t      SSA_VAL (gimple_assign_rhs1 (def_stmt)),\n \t\t\t      bitsize_int (ref->size),\n \t\t\t      bitsize_int (offset - offset2));\n@@ -3686,7 +3688,8 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t      unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));\n \t\t      if (lhs_prec == rhs_prec)\n \t\t\t{\n-\t\t\t  gimple_match_op match_op (NOP_EXPR, type, ops[0]);\n+\t\t\t  gimple_match_op match_op (gimple_match_cond::UNCOND,\n+\t\t\t\t\t\t    NOP_EXPR, type, ops[0]);\n \t\t\t  result = vn_nary_build_or_lookup (&match_op);\n \t\t\t  if (result)\n \t\t\t    {\n@@ -3699,7 +3702,8 @@ visit_nary_op (tree lhs, gassign *stmt)\n \t\t\t{\n \t\t\t  tree mask = wide_int_to_tree\n \t\t\t    (type, wi::mask (rhs_prec, false, lhs_prec));\n-\t\t\t  gimple_match_op match_op (BIT_AND_EXPR,\n+\t\t\t  gimple_match_op match_op (gimple_match_cond::UNCOND,\n+\t\t\t\t\t\t    BIT_AND_EXPR,\n \t\t\t\t\t\t    TREE_TYPE (lhs),\n \t\t\t\t\t\t    ops[0], mask);\n \t\t\t  result = vn_nary_build_or_lookup (&match_op);\n@@ -3823,7 +3827,8 @@ visit_reference_op_load (tree lhs, tree op, gimple *stmt)\n \t of VIEW_CONVERT_EXPR <TREE_TYPE (result)> (result).\n \t So first simplify and lookup this expression to see if it\n \t is already available.  */\n-      gimple_match_op res_op (VIEW_CONVERT_EXPR, TREE_TYPE (op), result);\n+      gimple_match_op res_op (gimple_match_cond::UNCOND,\n+\t\t\t      VIEW_CONVERT_EXPR, TREE_TYPE (op), result);\n       result = vn_nary_build_or_lookup (&res_op);\n     }\n "}]}