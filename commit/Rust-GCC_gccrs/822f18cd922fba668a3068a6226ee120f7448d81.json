{"sha": "822f18cd922fba668a3068a6226ee120f7448d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyZjE4Y2Q5MjJmYmE2NjhhMzA2OGE2MjI2ZWUxMjBmNzQ0OGQ4MQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-09-23T09:47:52Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-09-23T09:47:52Z"}, "message": "tree-vect-loop-manip.c (create_intersect_range_checks_index): New.\n\n\t* tree-vect-loop-manip.c (create_intersect_range_checks_index): New.\n\t(create_intersect_range_checks): New.\n\t(vect_create_cond_for_alias_checks): Call above function.\n\nFrom-SVN: r240412", "tree": {"sha": "ed2386d29090e07f38271a79eed15ddcf498bb01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed2386d29090e07f38271a79eed15ddcf498bb01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/822f18cd922fba668a3068a6226ee120f7448d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822f18cd922fba668a3068a6226ee120f7448d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/822f18cd922fba668a3068a6226ee120f7448d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/822f18cd922fba668a3068a6226ee120f7448d81/comments", "author": null, "committer": null, "parents": [{"sha": "d403b8d4e8057e1e271013745992a191db32cacc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d403b8d4e8057e1e271013745992a191db32cacc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d403b8d4e8057e1e271013745992a191db32cacc"}], "stats": {"total": 243, "additions": 196, "deletions": 47}, "files": [{"sha": "1befd086d0647dde883270ab3cb48f927092027b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822f18cd922fba668a3068a6226ee120f7448d81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822f18cd922fba668a3068a6226ee120f7448d81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=822f18cd922fba668a3068a6226ee120f7448d81", "patch": "@@ -1,3 +1,9 @@\n+2016-09-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-vect-loop-manip.c (create_intersect_range_checks_index): New.\n+\t(create_intersect_range_checks): New.\n+\t(vect_create_cond_for_alias_checks): Call above function.\n+\n 2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* config/arm/iterators.md (Code iterators): Fix some white-space"}, {"sha": "82030406ded75df9d0745ccc3e66f5f00c27f273", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 190, "deletions": 47, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/822f18cd922fba668a3068a6226ee120f7448d81/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/822f18cd922fba668a3068a6226ee120f7448d81/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=822f18cd922fba668a3068a6226ee120f7448d81", "patch": "@@ -2263,6 +2263,194 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n     *cond_expr = part_cond_expr;\n }\n \n+/* Given two data references and segment lengths described by DR_A and DR_B,\n+   create expression checking if the two addresses ranges intersect with\n+   each other based on index of the two addresses.  This can only be done\n+   if DR_A and DR_B referring to the same (array) object and the index is\n+   the only difference.  For example:\n+\n+                       DR_A                           DR_B\n+      data-ref         arr[i]                         arr[j]\n+      base_object      arr                            arr\n+      index            {i_0, +, 1}_loop               {j_0, +, 1}_loop\n+\n+   The addresses and their index are like:\n+\n+        |<- ADDR_A    ->|          |<- ADDR_B    ->|\n+     ------------------------------------------------------->\n+        |   |   |   |   |          |   |   |   |   |\n+     ------------------------------------------------------->\n+        i_0 ...         i_0+4      j_0 ...         j_0+4\n+\n+   We can create expression based on index rather than address:\n+\n+     (i_0 + 4 < j_0 || j_0 + 4 < i_0)\n+\n+   Note evolution step of index needs to be considered in comparison.  */\n+\n+static bool\n+create_intersect_range_checks_index (loop_vec_info loop_vinfo, tree *cond_expr,\n+\t\t\t\t     const dr_with_seg_len& dr_a,\n+\t\t\t\t     const dr_with_seg_len& dr_b)\n+{\n+  if (integer_zerop (DR_STEP (dr_a.dr))\n+      || integer_zerop (DR_STEP (dr_b.dr))\n+      || DR_NUM_DIMENSIONS (dr_a.dr) != DR_NUM_DIMENSIONS (dr_b.dr))\n+    return false;\n+\n+  if (!tree_fits_uhwi_p (dr_a.seg_len) || !tree_fits_uhwi_p (dr_b.seg_len))\n+    return false;\n+\n+  if (!operand_equal_p (DR_BASE_OBJECT (dr_a.dr), DR_BASE_OBJECT (dr_b.dr), 0))\n+    return false;\n+\n+  if (!operand_equal_p (DR_STEP (dr_a.dr), DR_STEP (dr_b.dr), 0))\n+    return false;\n+\n+  gcc_assert (TREE_CODE (DR_STEP (dr_a.dr)) == INTEGER_CST);\n+\n+  bool neg_step = tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0;\n+  unsigned HOST_WIDE_INT abs_step = tree_to_uhwi (DR_STEP (dr_a.dr));\n+  if (neg_step)\n+    abs_step = -abs_step;\n+\n+  unsigned HOST_WIDE_INT seg_len1 = tree_to_uhwi (dr_a.seg_len);\n+  unsigned HOST_WIDE_INT seg_len2 = tree_to_uhwi (dr_b.seg_len);\n+  /* Infer the number of iterations with which the memory segment is accessed\n+     by DR.  In other words, alias is checked if memory segment accessed by\n+     DR_A in some iterations intersect with memory segment accessed by DR_B\n+     in the same amount iterations.\n+     Note segnment length is a linear function of number of iterations with\n+     DR_STEP as the coefficient.  */\n+  unsigned HOST_WIDE_INT niter_len1 = (seg_len1 + abs_step - 1) / abs_step;\n+  unsigned HOST_WIDE_INT niter_len2 = (seg_len2 + abs_step - 1) / abs_step;\n+\n+  unsigned int i;\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  for (i = 0; i < DR_NUM_DIMENSIONS (dr_a.dr); i++)\n+    {\n+      tree access1 = DR_ACCESS_FN (dr_a.dr, i);\n+      tree access2 = DR_ACCESS_FN (dr_b.dr, i);\n+      /* Two index must be the same if they are not scev, or not scev wrto\n+\t current loop being vecorized.  */\n+      if (TREE_CODE (access1) != POLYNOMIAL_CHREC\n+\t  || TREE_CODE (access2) != POLYNOMIAL_CHREC\n+\t  || CHREC_VARIABLE (access1) != (unsigned)loop->num\n+\t  || CHREC_VARIABLE (access2) != (unsigned)loop->num)\n+\t{\n+\t  if (operand_equal_p (access1, access2, 0))\n+\t    continue;\n+\n+\t  return false;\n+\t}\n+      /* Two index must have the same step.  */\n+      if (!operand_equal_p (CHREC_RIGHT (access1), CHREC_RIGHT (access2), 0))\n+\treturn false;\n+\n+      tree idx_step = CHREC_RIGHT (access1);\n+      /* Index must have const step, otherwise DR_STEP won't be constant.  */\n+      gcc_assert (TREE_CODE (idx_step) == INTEGER_CST);\n+      /* Index must evaluate in the same direction as DR.  */\n+      gcc_assert (!neg_step\n+\t\t  || tree_int_cst_compare (idx_step, size_zero_node) < 0);\n+\n+      tree min1 = CHREC_LEFT (access1);\n+      tree min2 = CHREC_LEFT (access2);\n+      if (!types_compatible_p (TREE_TYPE (min1), TREE_TYPE (min2)))\n+\treturn false;\n+\n+      /* Ideally, alias can be checked against loop's control IV, but we\n+\t need to prove linear mapping between control IV and reference\n+\t index.  Although that should be true, we check against (array)\n+\t index of data reference.  Like segment length, index length is\n+\t linear function of the number of iterations with index_step as\n+\t the coefficient, i.e, niter_len * idx_step.  */\n+      tree idx_len1 = fold_build2 (MULT_EXPR, TREE_TYPE (min1), idx_step,\n+\t\t\t\t   build_int_cst (TREE_TYPE (min1),\n+\t\t\t\t\t\t  niter_len1));\n+      tree idx_len2 = fold_build2 (MULT_EXPR, TREE_TYPE (min2), idx_step,\n+\t\t\t\t   build_int_cst (TREE_TYPE (min2),\n+\t\t\t\t\t\t  niter_len2));\n+      tree max1 = fold_build2 (PLUS_EXPR, TREE_TYPE (min1), min1, idx_len1);\n+      tree max2 = fold_build2 (PLUS_EXPR, TREE_TYPE (min2), min2, idx_len2);\n+      /* Adjust ranges for negative step.  */\n+      if (neg_step)\n+\t{\n+\t  min1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1), max1, idx_step);\n+\t  max1 = fold_build2 (MINUS_EXPR, TREE_TYPE (min1),\n+\t\t\t      CHREC_LEFT (access1), idx_step);\n+\t  min2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2), max2, idx_step);\n+\t  max2 = fold_build2 (MINUS_EXPR, TREE_TYPE (min2),\n+\t\t\t      CHREC_LEFT (access2), idx_step);\n+\t}\n+      tree part_cond_expr\n+\t= fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\t    fold_build2 (LE_EXPR, boolean_type_node, max1, min2),\n+\t    fold_build2 (LE_EXPR, boolean_type_node, max2, min1));\n+      if (*cond_expr)\n+\t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n+\t\t\t\t  *cond_expr, part_cond_expr);\n+      else\n+\t*cond_expr = part_cond_expr;\n+    }\n+  return true;\n+}\n+\n+/* Given two data references and segment lengths described by DR_A and DR_B,\n+   create expression checking if the two addresses ranges intersect with\n+   each other:\n+\n+     ((DR_A_addr_0 + DR_A_segment_length_0) <= DR_B_addr_0)\n+     || (DR_B_addr_0 + DER_B_segment_length_0) <= DR_A_addr_0))  */\n+\n+static void\n+create_intersect_range_checks (loop_vec_info loop_vinfo, tree *cond_expr,\n+\t\t\t       const dr_with_seg_len& dr_a,\n+\t\t\t       const dr_with_seg_len& dr_b)\n+{\n+  *cond_expr = NULL_TREE;\n+  if (create_intersect_range_checks_index (loop_vinfo, cond_expr, dr_a, dr_b))\n+    return;\n+\n+  tree segment_length_a = dr_a.seg_len;\n+  tree segment_length_b = dr_b.seg_len;\n+  tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n+  tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n+  tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n+\n+  offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n+\t\t\t  offset_a, DR_INIT (dr_a.dr));\n+  offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n+\t\t\t  offset_b, DR_INIT (dr_b.dr));\n+  addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n+  addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n+\n+  tree seg_a_min = addr_base_a;\n+  tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n+  /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n+     bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n+     [a, a+12) */\n+  if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a.dr)));\n+      seg_a_min = fold_build_pointer_plus (seg_a_max, unit_size);\n+      seg_a_max = fold_build_pointer_plus (addr_base_a, unit_size);\n+    }\n+\n+  tree seg_b_min = addr_base_b;\n+  tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n+  if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n+    {\n+      tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b.dr)));\n+      seg_b_min = fold_build_pointer_plus (seg_b_max, unit_size);\n+      seg_b_max = fold_build_pointer_plus (addr_base_b, unit_size);\n+    }\n+  *cond_expr\n+    = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n+\tfold_build2 (LE_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n+\tfold_build2 (LE_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n+}\n+\n /* Function vect_create_cond_for_alias_checks.\n \n    Create a conditional expression that represents the run-time checks for\n@@ -2290,34 +2478,13 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n     LOOP_VINFO_COMP_ALIAS_DDRS (loop_vinfo);\n   tree part_cond_expr;\n \n-  /* Create expression\n-     ((store_ptr_0 + store_segment_length_0) <= load_ptr_0)\n-     || (load_ptr_0 + load_segment_length_0) <= store_ptr_0))\n-     &&\n-     ...\n-     &&\n-     ((store_ptr_n + store_segment_length_n) <= load_ptr_n)\n-     || (load_ptr_n + load_segment_length_n) <= store_ptr_n))  */\n-\n   if (comp_alias_ddrs.is_empty ())\n     return;\n \n   for (size_t i = 0, s = comp_alias_ddrs.length (); i < s; ++i)\n     {\n       const dr_with_seg_len& dr_a = comp_alias_ddrs[i].first;\n       const dr_with_seg_len& dr_b = comp_alias_ddrs[i].second;\n-      tree segment_length_a = dr_a.seg_len;\n-      tree segment_length_b = dr_b.seg_len;\n-      tree addr_base_a = DR_BASE_ADDRESS (dr_a.dr);\n-      tree addr_base_b = DR_BASE_ADDRESS (dr_b.dr);\n-      tree offset_a = DR_OFFSET (dr_a.dr), offset_b = DR_OFFSET (dr_b.dr);\n-\n-      offset_a = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_a),\n-\t\t\t      offset_a, DR_INIT (dr_a.dr));\n-      offset_b = fold_build2 (PLUS_EXPR, TREE_TYPE (offset_b),\n-\t\t\t      offset_b, DR_INIT (dr_b.dr));\n-      addr_base_a = fold_build_pointer_plus (addr_base_a, offset_a);\n-      addr_base_b = fold_build_pointer_plus (addr_base_b, offset_b);\n \n       if (dump_enabled_p ())\n \t{\n@@ -2329,32 +2496,8 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n \t  dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n-      tree seg_a_min = addr_base_a;\n-      tree seg_a_max = fold_build_pointer_plus (addr_base_a, segment_length_a);\n-      /* For negative step, we need to adjust address range by TYPE_SIZE_UNIT\n-\t bytes, e.g., int a[3] -> a[1] range is [a+4, a+16) instead of\n-\t [a, a+12) */\n-      if (tree_int_cst_compare (DR_STEP (dr_a.dr), size_zero_node) < 0)\n-\t{\n-\t  tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_a.dr)));\n-\t  seg_a_min = fold_build_pointer_plus (seg_a_max, unit_size);\n-\t  seg_a_max = fold_build_pointer_plus (addr_base_a, unit_size);\n-\t}\n-\n-      tree seg_b_min = addr_base_b;\n-      tree seg_b_max = fold_build_pointer_plus (addr_base_b, segment_length_b);\n-      if (tree_int_cst_compare (DR_STEP (dr_b.dr), size_zero_node) < 0)\n-\t{\n-\t  tree unit_size = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr_b.dr)));\n-\t  seg_b_min = fold_build_pointer_plus (seg_b_max, unit_size);\n-\t  seg_b_max = fold_build_pointer_plus (addr_base_b, unit_size);\n-\t}\n-\n-      part_cond_expr =\n-      \tfold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n-\t  fold_build2 (LE_EXPR, boolean_type_node, seg_a_max, seg_b_min),\n-\t  fold_build2 (LE_EXPR, boolean_type_node, seg_b_max, seg_a_min));\n-\n+      /* Create condition expression for each pair data references.  */\n+      create_intersect_range_checks (loop_vinfo, &part_cond_expr, dr_a, dr_b);\n       if (*cond_expr)\n \t*cond_expr = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t  *cond_expr, part_cond_expr);"}]}