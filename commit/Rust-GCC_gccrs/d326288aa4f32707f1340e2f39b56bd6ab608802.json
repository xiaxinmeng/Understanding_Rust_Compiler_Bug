{"sha": "d326288aa4f32707f1340e2f39b56bd6ab608802", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyNjI4OGFhNGYzMjcwN2YxMzQwZTJmMzliNTZiZDZhYjYwODgwMg==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-13T10:50:31Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-05-13T11:56:30Z"}, "message": "Fix duplicated function generation for generics\n\nWhen emitting the backend IR we need to check if we have already compiled\none already. This is all due to the fact when we do generic substitutions\nin type resolution its only upon usage of a function the function is\nsubstituted it gains a new unique ty_ref HIR ID to make sure new\nsubstituted versions of a type have unique ids.\n\nThis means we can end up with multiple substitued versions of the same\nfunction which end up being compiled multiple times. This was also the case\nfor generic data types but is already fixed.\n\nFixes #403", "tree": {"sha": "8f987d715d879f369620061a5e2d4c336f5bae38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f987d715d879f369620061a5e2d4c336f5bae38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d326288aa4f32707f1340e2f39b56bd6ab608802", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d326288aa4f32707f1340e2f39b56bd6ab608802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d326288aa4f32707f1340e2f39b56bd6ab608802", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d326288aa4f32707f1340e2f39b56bd6ab608802/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1c148518de1cb8f60f779dc206f663e8593191a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c148518de1cb8f60f779dc206f663e8593191a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c148518de1cb8f60f779dc206f663e8593191a"}], "stats": {"total": 168, "additions": 103, "deletions": 65}, "files": [{"sha": "45fb6c221275a22052ff3fcf948c9852ab7457de", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=d326288aa4f32707f1340e2f39b56bd6ab608802", "patch": "@@ -157,13 +157,38 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (HirId id, ::Bfunction *fn)\n+  void insert_function_decl (HirId id, ::Bfunction *fn,\n+\t\t\t     const TyTy::BaseType *ref)\n   {\n+    rust_assert (compiled_fn_map.find (id) == compiled_fn_map.end ());\n     compiled_fn_map[id] = fn;\n+    if (ref != nullptr)\n+      {\n+\tstd::pair<HirId, ::Bfunction *> elem (id, fn);\n+\tmono_fns[ref] = std::move (elem);\n+      }\n   }\n \n-  bool lookup_function_decl (HirId id, ::Bfunction **fn)\n+  bool lookup_function_decl (HirId id, ::Bfunction **fn,\n+\t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n+    // for for any monomorphized fns\n+    if (ref != nullptr)\n+      {\n+\tfor (auto it = mono_fns.begin (); it != mono_fns.end (); it++)\n+\t  {\n+\t    std::pair<HirId, ::Bfunction *> &val = it->second;\n+\t    const TyTy::BaseType *r = it->first;\n+\t    if (ref->is_equal (*r))\n+\t      {\n+\t\t*fn = val.second;\n+\n+\t\treturn true;\n+\t      }\n+\t  }\n+\treturn false;\n+      }\n+\n     auto it = compiled_fn_map.find (id);\n     if (it == compiled_fn_map.end ())\n       return false;\n@@ -282,6 +307,7 @@ class Context\n   std::vector< ::Bvariable *> loop_value_stack;\n   std::vector< ::Blabel *> loop_begin_labels;\n   std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *> > mono;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, ::Bfunction *> > mono_fns;\n \n   // To GCC middle-end\n   std::vector< ::Btype *> type_decls;"}, {"sha": "b071d94676f0cde1f52445062188270539072561", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=d326288aa4f32707f1340e2f39b56bd6ab608802", "patch": "@@ -66,17 +66,6 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -86,28 +75,43 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -126,7 +130,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();\n@@ -247,17 +251,6 @@ class CompileInherentImplItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (method.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (method.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -267,28 +260,43 @@ class CompileInherentImplItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (method.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     // convert to the actual function type\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n@@ -307,7 +315,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, method.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}, {"sha": "c3dc279268c4d475682d3abdd9d163c2450feff1", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d326288aa4f32707f1340e2f39b56bd6ab608802/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=d326288aa4f32707f1340e2f39b56bd6ab608802", "patch": "@@ -92,17 +92,6 @@ class CompileItem : public HIRCompileBase\n     if (!compile_fns)\n       return;\n \n-    // items can be forward compiled which means we may not need to invoke this\n-    // code\n-    Bfunction *lookup = nullptr;\n-    if (ctx->lookup_function_decl (function.get_mappings ().get_hirid (),\n-\t\t\t\t   &lookup))\n-      {\n-\t// has this been added to the list then it must be finished\n-\tif (ctx->function_completed (lookup))\n-\t  return;\n-      }\n-\n     TyTy::BaseType *fntype_tyty;\n     if (!ctx->get_tyctx ()->lookup_type (function.get_mappings ().get_hirid (),\n \t\t\t\t\t &fntype_tyty))\n@@ -112,28 +101,43 @@ class CompileItem : public HIRCompileBase\n \treturn;\n       }\n \n-    if (fntype_tyty->get_kind () != TyTy::TypeKind::FNDEF)\n-      {\n-\trust_error_at (function.get_locus (), \"invalid TyTy for function item\");\n-\treturn;\n-      }\n-\n+    rust_assert (fntype_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n     TyTy::FnType *fntype = static_cast<TyTy::FnType *> (fntype_tyty);\n     if (fntype->has_subsititions_defined ())\n       {\n-\t// we cant do anything for this only when it is used\n+\t// we cant do anything for this only when it is used and a concrete type\n+\t// is given\n \tif (concrete == nullptr)\n \t  return;\n \telse\n \t  {\n \t    rust_assert (concrete->get_kind () == TyTy::TypeKind::FNDEF);\n \t    fntype = static_cast<TyTy::FnType *> (concrete);\n+\t  }\n+      }\n \n-\t    // override the Hir Lookups for the substituions in this context\n-\t    fntype->override_context ();\n+    // items can be forward compiled which means we may not need to invoke this\n+    // code. We might also have already compiled this generic function as well.\n+    Bfunction *lookup = nullptr;\n+    if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup, fntype))\n+      {\n+\t// has this been added to the list then it must be finished\n+\tif (ctx->function_completed (lookup))\n+\t  {\n+\t    Bfunction *dummy = nullptr;\n+\t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n+\t      ctx->insert_function_decl (fntype->get_ty_ref (), lookup, fntype);\n+\n+\t    return;\n \t  }\n       }\n \n+    if (fntype->has_subsititions_defined ())\n+      {\n+\t// override the Hir Lookups for the substituions in this context\n+\tfntype->override_context ();\n+      }\n+\n     ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n@@ -155,7 +159,7 @@ class CompileItem : public HIRCompileBase\n     Bfunction *fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n-    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl);\n+    ctx->insert_function_decl (fntype->get_ty_ref (), fndecl, fntype);\n \n     // setup the params\n     TyTy::BaseType *tyret = fntype->get_return_type ();"}]}