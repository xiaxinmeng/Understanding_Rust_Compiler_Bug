{"sha": "a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQxOGI2YzVhZWU2ODNhOGU1NzRiZTc4N2I4ZDJmZTJjMWJlZDBlOQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-07-19T20:01:07Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1996-07-19T20:01:07Z"}, "message": "Simplify movqi, add more !TARGET_5200 cases\n\nFrom-SVN: r12533", "tree": {"sha": "bac151b3c3e124be0557c63f23064b108073bd5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bac151b3c3e124be0557c63f23064b108073bd5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9/comments", "author": null, "committer": null, "parents": [{"sha": "4431168e146b885ded7414c296c3afe5edc73862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4431168e146b885ded7414c296c3afe5edc73862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4431168e146b885ded7414c296c3afe5edc73862"}], "stats": {"total": 144, "additions": 36, "deletions": 108}, "files": [{"sha": "da9ff37ce24286e607a1c51abbccbc28d0cab92c", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 36, "deletions": 108, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a418b6c5aee683a8e574be787b8d2fe2c1bed0e9/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=a418b6c5aee683a8e574be787b8d2fe2c1bed0e9", "patch": "@@ -946,8 +946,8 @@\n }\")\n \n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m,m,?*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi,?*a,m\"))]\n+  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m\")\n+\t(match_operand:QI 1 \"general_operand\" \"dmi*a,di*a,dmi\"))]\n   \"\"\n   \"*\n {\n@@ -970,106 +970,6 @@\n       return \\\"\\\";\n     }\n \n-  /* Moving a byte into an address register is not possible.  */\n-  /* Use d0 as an intermediate, but don't clobber its contents.  */\n-  if (ADDRESS_REG_P (operands[0]) && GET_CODE (operands[1]) == MEM)\n-    {\n-      /* ??? For 2.5, don't allow this choice and use secondary reloads\n-\t instead.\n-\n-\t See if the address register is used in the address.  If it\n-\t is, we have to generate a more complex sequence than those below.  */\n-      CC_STATUS_INIT;\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands[1], NULL_RTX))\n-\t{\n-\t  /* See if the stack pointer is used in the address.  If it isn't,\n-\t     we can push d0 or d1 (the insn can't use both of them) on\n-\t     the stack, perform our move into d0/d1, copy the byte from d0/1,\n-\t     and pop d0/1.  */\n-\t  if (! reg_mentioned_p (stack_pointer_rtx, operands[1]))\n-\t    {\n-\t      if (! refers_to_regno_p (0, 1, operands[1], NULL_RTX))\n-\t\treturn \\\"move%.l %/d0,%-\\;move%.b %1,%/d0\\;move%.l %/d0,%0\\;move%.l %+,%/d0\\\";\n-\t      else\n-\t\treturn \\\"move%.l %/d1,%-\\;move%.b %1,%/d1\\;move%.l %/d1,%0\\;move%.l %+,%/d1\\\";\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, we know that d0 cannot be used in the address\n-\t\t (since sp and one address register is).  Assume that sp is\n-\t\t being used as a base register and replace the address\n-\t\t register that is our operand[0] with d0.  */\n-\t      rtx reg_map[FIRST_PSEUDO_REGISTER];\n-\t      int i;\n-\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\treg_map[i] = 0;\n-\n-\t      reg_map[REGNO (operands[0])] = gen_rtx (REG, Pmode, 0);\n-\t      operands[1] = copy_rtx (operands[1]);\n-\t      replace_regs (operands[1], reg_map, FIRST_PSEUDO_REGISTER, 0);\n-\t      return \\\"exg %/d0,%0\\;move%.b %1,%/d0\\;exg %/d0,%0\\\";\n-\t    }\n-\t}\n-\n-      /* If the address of operand 1 uses d0, choose d1 as intermediate.  */\n-      if (refers_to_regno_p (0, 1, operands[1], NULL_RTX))\n-\treturn \\\"exg %/d1,%0\\;move%.b %1,%/d1\\;exg %/d1,%0\\\";\n-      /* Otherwise d0 is usable.\n-\t (An effective address on the 68k can't use two d-regs.)  */\n-      else\n-\treturn \\\"exg %/d0,%0\\;move%.b %1,%/d0\\;exg %/d0,%0\\\";\n-    }\n-\n-  /* Likewise for moving from an address reg.  */\n-  if (ADDRESS_REG_P (operands[1]) && GET_CODE (operands[0]) == MEM)\n-    {\n-      /* ??? For 2.5, don't allow this choice and use secondary reloads\n-\t instead.\n-\n-\t See if the address register is used in the address.  If it\n-\t is, we have to generate a more complex sequence than those below.  */\n-      CC_STATUS_INIT;\n-      if (refers_to_regno_p (REGNO (operands[1]), REGNO (operands[1]) + 1,\n-\t\t\t     operands[0], NULL_RTX))\n-\t{\n-\t  /* See if the stack pointer is used in the address.  If it isn't,\n-\t     we can push d0 or d1 (the insn can't use both of them) on\n-\t     the stack, copy the byte to d0/1, perform our move from d0/d1,\n-\t     and pop d0/1.  */\n-\t  if (! reg_mentioned_p (stack_pointer_rtx, operands[0]))\n-\t    {\n-\t      if (! refers_to_regno_p (0, 1, operands[0], NULL_RTX))\n-\t\treturn \\\"move%.l %/d0,%-\\;move%.l %1,%/d0\\;move%.b %/d0,%0\\;move%.l %+,%/d0\\\";\n-\t      else\n-\t\treturn \\\"move%.l %/d1,%-\\;move%.l %1,%/d1\\;move%.b %/d1,%0\\;move%.l %+,%/d1\\\";\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, we know that d0 cannot be used in the address\n-\t\t (since sp and one address register is).  Assume that sp is\n-\t\t being used as a base register and replace the address\n-\t\t register that is our operand[1] with d0.  */\n-\t      rtx reg_map[FIRST_PSEUDO_REGISTER];\n-\t      int i;\n-\n-\t      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\t\treg_map[i] = 0;\n-\n-\t      reg_map[REGNO (operands[1])] = gen_rtx (REG, Pmode, 0);\n-\t      operands[0] = copy_rtx (operands[0]);\n-\t      replace_regs (operands[0], reg_map, FIRST_PSEUDO_REGISTER, 0);\n-\t      return \\\"exg %/d0,%1\\;move%.b %/d0,%0\\;exg %/d0,%1\\\";\n-\t    }\n-\t}\n-\n-      if (refers_to_regno_p (0, 1, operands[0], NULL_RTX))\n-        return \\\"exg %/d1,%1\\;move%.b %/d1,%0\\;exg %/d1,%1\\\";\n-      else\n-        return \\\"exg %/d0,%1\\;move%.b %/d0,%0\\;exg %/d0,%1\\\";\n-    }\n-\n   /* clr and st insns on 68000 read before writing.\n      This isn't so on the 68010, but we have no TARGET_68010.  */\n   if (!ADDRESS_REG_P (operands[0])\n@@ -2051,7 +1951,7 @@\n             (const_int 32))\n         (match_operand:DI 2 \"general_operand\" \"0,0,0,0\")))\n    (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2660,7 +2560,7 @@\n         (ashift:DI (sign_extend:DI (match_operand:HI 2 \"general_operand\" \"rm,rm,rm,rm\"))\n             (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -3784,10 +3684,23 @@\n \f\n ;; negation instructions\n \n-(define_insn \"negdi2\"\n+(define_expand \"negdi2\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (TARGET_5200)\n+    emit_insn (gen_negdi2_5200 (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_negdi2_internal (operands[0], operands[1]));\n+  DONE;\n+}\")\n+\n+(define_insn \"negdi2_internal\"\n   [(set (match_operand:DI 0 \"general_operand\" \"=<,do,!*a\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"*\n {\n   if (which_alternative == 0)\n@@ -3802,6 +3715,21 @@\n     return \\\"neg%.l %1\\;negx%.l %0\\\";\n } \")\n \n+(define_insn \"negdi2_5200\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=<,do\")\n+\t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0\")))]\n+  \"TARGET_5200\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"neg%.l %0\\;negx%.l %0\\\";\n+  if (GET_CODE (operands[0]) == REG)\n+    operands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  else\n+    operands[1] = adj_offsettable_operand (operands[0], 4);\n+  return \\\"neg%.l %1\\;negx%.l %0\\\";\n+} \")\n+\n (define_insn \"negsi2\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n@@ -4411,7 +4339,7 @@\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"\n {\n   if (GET_CODE (operands[2]) != CONST_INT\n@@ -4445,7 +4373,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n+  \"!TARGET_5200\"\n   \"asr%.w %2,%0\")\n \n (define_insn \"\""}]}