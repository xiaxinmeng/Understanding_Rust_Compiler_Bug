{"sha": "f25161bdcc2b098a4678a42bb2c581ac47625b17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI1MTYxYmRjYzJiMDk4YTQ2NzhhNDJiYjJjNTgxYWM0NzYyNWIxNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-10T11:47:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-06-10T13:13:06Z"}, "message": "Make {SLP_TREE,STMT_VINFO}_VEC_STMTS a vector of gimple *\n\nThis makes {SLP_TREE,STMT_VINFO}_VEC_STMTS a vector of gimple * and\nnot allocate a stmt_vec_info for vectorizer generated stmts since\nthis is now possible after removing the only use which was chaining\nof vector stmts via STMT_VINFO_RELATED_STMT.\n\nThis also removes all stmt_vec_info allocations done for vector\nstmts, the remaining ones are for stmts in the scalar IL and for\npatterns which are not part of the IL.  Thus after this the stmt\nUIDs inside a basic-block are suitable for dominance checking\nif you ignore (or lazy-fill) UIDs of zero of the vector stmts\ninserted during transform.  This property is ensured by a new\nflag set when pattern analysis is complete.\n\n2020-06-10  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_slp_tree::vec_stmts): Make it a vector\n\tof gimple * stmts.\n\t(_stmt_vec_info::vec_stmts): Likewise.\n\t(vec_info::stmt_vec_info_ro): New flag.\n\t(vect_finish_replace_stmt): Adjust declaration.\n\t(vect_finish_stmt_generation): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vect_transform_reduction): Likewise.\n\t(vectorizable_lc_phi): Likewise.\n\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Do not\n\tallocate stmt infos for increments.\n\t(vect_record_grouped_load_vectors): Adjust.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Likewise.\n\t(vectorize_fold_left_reduction): Likewise.\n\t(vect_transform_reduction): Likewise.\n\t(vect_transform_cycle_phi): Likewise.\n\t(vectorizable_lc_phi): Likewise.\n\t(vectorizable_induction): Likewise.\n\t(vectorizable_live_operation): Likewise.\n\t(vect_transform_loop): Likewise.\n\t* tree-vect-patterns.c (vect_pattern_recog): Set stmt_vec_info_ro.\n\t* tree-vect-slp.c (vect_get_slp_vect_def): Adjust.\n\t(vect_get_slp_defs): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Likewise.\n\t(vectorize_slp_instance_root_stmt): Likewise.\n\t* tree-vect-stmts.c (vect_get_vec_defs_for_operand): Likewise.\n\t(vect_finish_stmt_generation_1): Do not allocate a stmt info.\n\t(vect_finish_replace_stmt): Do not return anything.\n\t(vect_finish_stmt_generation): Likewise.\n\t(vect_build_gather_load_calls): Adjust.\n\t(vectorizable_bswap): Likewise.\n\t(vectorizable_call): Likewise.\n\t(vectorizable_simd_clone_call): Likewise.\n\t(vect_create_vectorized_demotion_stmts): Likewise.\n\t(vectorizable_conversion): Likewise.\n\t(vectorizable_assignment): Likewise.\n\t(vectorizable_shift): Likewise.\n\t(vectorizable_operation): Likewise.\n\t(vectorizable_scan_store): Likewise.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(vectorizable_condition): Likewise.\n\t(vectorizable_comparison): Likewise.\n\t(vect_transform_stmt): Likewise.\n\t* tree-vectorizer.c (vec_info::vec_info): Initialize\n\tstmt_vec_info_ro.\n\t(vec_info::replace_stmt): Copy over stmt UID rather than\n\tunsetting/setting a stmt info allocating a new UID.\n\t(vec_info::set_vinfo_for_stmt): Assert !stmt_vec_info_ro.", "tree": {"sha": "e7fce2151918124618cb35ec4c741b3883af10a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7fce2151918124618cb35ec4c741b3883af10a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f25161bdcc2b098a4678a42bb2c581ac47625b17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25161bdcc2b098a4678a42bb2c581ac47625b17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f25161bdcc2b098a4678a42bb2c581ac47625b17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f25161bdcc2b098a4678a42bb2c581ac47625b17/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1396fa5b91cfa0b3708ec9df33c0bb84386081d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1396fa5b91cfa0b3708ec9df33c0bb84386081d6"}], "stats": {"total": 662, "additions": 282, "deletions": 380}, "files": [{"sha": "39d5a1b554c5422c529a947faa798e142cdfc7aa", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -4896,7 +4896,6 @@ vect_create_data_ref_ptr (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t aggr_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      loop_vinfo->add_stmt (incr);\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -4926,7 +4925,6 @@ vect_create_data_ref_ptr (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t containing_loop, &incr_gsi, insert_after, &indx_before_incr,\n \t\t &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n-      loop_vinfo->add_stmt (incr);\n \n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n@@ -6407,7 +6405,7 @@ vect_transform_grouped_load (vec_info *vinfo, stmt_vec_info stmt_info,\n    for each vector to the associated scalar statement.  */\n \n void\n-vect_record_grouped_load_vectors (vec_info *vinfo, stmt_vec_info stmt_info,\n+vect_record_grouped_load_vectors (vec_info *, stmt_vec_info stmt_info,\n \t\t\t\t  vec<tree> result_chain)\n {\n   stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n@@ -6441,10 +6439,10 @@ vect_record_grouped_load_vectors (vec_info *vinfo, stmt_vec_info stmt_info,\n          DR_GROUP_SAME_DR_STMT.  */\n       if (next_stmt_info)\n         {\n-\t  stmt_vec_info new_stmt_info = vinfo->lookup_def (tmp_data_ref);\n+\t  gimple *new_stmt = SSA_NAME_DEF_STMT (tmp_data_ref);\n \t  /* We assume that if VEC_STMT is not NULL, this is a case of multiple\n \t     copies, and we put the new vector statement last.  */\n-\t  STMT_VINFO_VEC_STMTS (next_stmt_info).safe_push (new_stmt_info);\n+\t  STMT_VINFO_VEC_STMTS (next_stmt_info).safe_push (new_stmt);\n \n \t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t  gap_count = 1;"}, {"sha": "f0b33258ac54b5d16399942cc33ff59b2e04056c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 46, "deletions": 66, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -4585,7 +4585,7 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t{\n \t  if (gimple_assign_rhs_code (cond_info->stmt) == COND_EXPR)\n \t    {\n-\t      gimple *vec_stmt = STMT_VINFO_VEC_STMTS (cond_info)[0]->stmt;\n+\t      gimple *vec_stmt = STMT_VINFO_VEC_STMTS (cond_info)[0];\n \t      gcc_assert (gimple_assign_rhs_code (vec_stmt) == VEC_COND_EXPR);\n \t      ccompares.safe_push\n \t\t(std::make_pair (unshare_expr (gimple_assign_rhs1 (vec_stmt)),\n@@ -4636,7 +4636,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       /* Create a vector phi node.  */\n       tree new_phi_tree = make_ssa_name (cr_index_vector_type);\n       new_phi = create_phi_node (new_phi_tree, loop->header);\n-      loop_vinfo->add_stmt (new_phi);\n       add_phi_arg (as_a <gphi *> (new_phi), vec_zero,\n \t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \n@@ -4663,9 +4662,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n \t\t\t\t\t new_phi_tree, indx_before_incr);\n \t}\n       gsi_insert_seq_before (&incr_gsi, stmts, GSI_SAME_STMT);\n-      stmt_vec_info index_vec_info\n-\t= loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (new_phi_tree));\n-      STMT_VINFO_VECTYPE (index_vec_info) = cr_index_vector_type;\n \n       /* Update the phi with the vec cond.  */\n       induction_index = new_phi_tree;\n@@ -4712,17 +4708,16 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       if (slp_node)\n \tdef = vect_get_slp_vect_def (slp_node, i);\n       else\n-\tdef = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[0]->stmt);\n+\tdef = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[0]);\n       for (j = 0; j < ncopies; j++)\n         {\n \t  tree new_def = copy_ssa_name (def);\n           phi = create_phi_node (new_def, exit_bb);\n-\t  loop_vinfo->add_stmt (phi);\n           if (j == 0)\n             new_phis.quick_push (phi);\n           else\n \t    {\n-\t      def = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[j]->stmt);\n+\t      def = gimple_get_lhs (STMT_VINFO_VEC_STMTS (rdef_info)[j]);\n \t      new_phis.quick_push (phi);\n \t    }\n \n@@ -5446,10 +5441,6 @@ vect_create_epilog_for_reduction (loop_vec_info loop_vinfo,\n       gsi_insert_seq_before (&exit_gsi, stmts, GSI_SAME_STMT);\n       if (nested_in_vect_loop)\n         {\n-\t  stmt_vec_info epilog_stmt_info = loop_vinfo->add_stmt (epilog_stmt);\n-\t  STMT_VINFO_RELATED_STMT (epilog_stmt_info)\n-\t    = STMT_VINFO_RELATED_STMT (loop_vinfo->lookup_stmt (new_phi));\n-\n           if (!double_reduc)\n             scalar_results.quick_push (new_temp);\n           else\n@@ -5666,15 +5657,14 @@ static bool\n vectorize_fold_left_reduction (loop_vec_info loop_vinfo,\n \t\t\t       stmt_vec_info stmt_info,\n \t\t\t       gimple_stmt_iterator *gsi,\n-\t\t\t       stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\t       gimple **vec_stmt, slp_tree slp_node,\n \t\t\t       gimple *reduc_def_stmt,\n \t\t\t       tree_code code, internal_fn reduc_fn,\n \t\t\t       tree ops[3], tree vectype_in,\n \t\t\t       int reduc_index, vec_loop_masks *masks)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n-  stmt_vec_info new_stmt_info = NULL;\n   internal_fn mask_reduc_fn = get_masked_reduction_fn (reduc_fn, vectype_in);\n \n   int ncopies;\n@@ -5785,23 +5775,22 @@ vectorize_fold_left_reduction (loop_vec_info loop_vinfo,\n       if (i == vec_num - 1)\n \t{\n \t  gimple_set_lhs (new_stmt, scalar_dest);\n-\t  new_stmt_info = vect_finish_replace_stmt (loop_vinfo,\n-\t\t\t\t\t\t    scalar_dest_def_info,\n-\t\t\t\t\t\t    new_stmt);\n+\t  vect_finish_replace_stmt (loop_vinfo,\n+\t\t\t\t    scalar_dest_def_info,\n+\t\t\t\t    new_stmt);\n \t}\n       else\n-\tnew_stmt_info = vect_finish_stmt_generation (loop_vinfo,\n-\t\t\t\t\t\t     scalar_dest_def_info,\n-\t\t\t\t\t\t     new_stmt, gsi);\n+\tvect_finish_stmt_generation (loop_vinfo,\n+\t\t\t\t     scalar_dest_def_info,\n+\t\t\t\t     new_stmt, gsi);\n \n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n-    }\n-\n-  if (!slp_node)\n-    {\n-      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n-      *vec_stmt = new_stmt_info;\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+      else\n+\t{\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n+\t  *vec_stmt = new_stmt;\n+\t}\n     }\n \n   return true;\n@@ -6822,7 +6811,7 @@ vectorizable_reduction (loop_vec_info loop_vinfo,\n bool\n vect_transform_reduction (loop_vec_info loop_vinfo,\n \t\t\t  stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t  stmt_vec_info *vec_stmt, slp_tree slp_node)\n+\t\t\t  gimple **vec_stmt, slp_tree slp_node)\n {\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -6883,7 +6872,6 @@ vect_transform_reduction (loop_vec_info loop_vinfo,\n   bool mask_by_cond_expr = use_mask_by_cond_expr_p (code, cond_fn, vectype_in);\n \n   /* Transform.  */\n-  stmt_vec_info new_stmt_info = NULL;\n   tree new_temp = NULL_TREE;\n   auto_vec<tree> vec_oprnds0;\n   auto_vec<tree> vec_oprnds1;\n@@ -6938,6 +6926,7 @@ vect_transform_reduction (loop_vec_info loop_vinfo,\n \n   FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n     {\n+      gimple *new_stmt;\n       tree vop[3] = { def0, vec_oprnds1[i], NULL_TREE };\n       if (masked_loop_p && !mask_by_cond_expr)\n \t{\n@@ -6954,8 +6943,8 @@ vect_transform_reduction (loop_vec_info loop_vinfo,\n \t  new_temp = make_ssa_name (vec_dest, call);\n \t  gimple_call_set_lhs (call, new_temp);\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt_info = vect_finish_stmt_generation (loop_vinfo,\n-\t\t\t\t\t\t       stmt_info, call, gsi);\n+\t  vect_finish_stmt_generation (loop_vinfo, stmt_info, call, gsi);\n+\t  new_stmt = call;\n \t}\n       else\n \t{\n@@ -6969,28 +6958,27 @@ vect_transform_reduction (loop_vec_info loop_vinfo,\n \t      build_vect_cond_expr (code, vop, mask, gsi);\n \t    }\n \n-\t  gassign *new_stmt = gimple_build_assign (vec_dest, code,\n-\t\t\t\t\t\t   vop[0], vop[1], vop[2]);\n+\t  new_stmt = gimple_build_assign (vec_dest, code,\n+\t\t\t\t\t  vop[0], vop[1], vop[2]);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t  new_stmt_info = vect_finish_stmt_generation (loop_vinfo, stmt_info,\n-\t\t\t\t\t\t       new_stmt, gsi);\n+\t  vect_finish_stmt_generation (loop_vinfo, stmt_info, new_stmt, gsi);\n \t}\n \n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else if (single_defuse_cycle\n \t       && i < ncopies - 1)\n \t{\n \t  if (reduc_index == 0)\n-\t    vec_oprnds0.safe_push (gimple_get_lhs (new_stmt_info->stmt));\n+\t    vec_oprnds0.safe_push (gimple_get_lhs (new_stmt));\n \t  else if (reduc_index == 1)\n-\t    vec_oprnds1.safe_push (gimple_get_lhs (new_stmt_info->stmt));\n+\t    vec_oprnds1.safe_push (gimple_get_lhs (new_stmt));\n \t  else if (reduc_index == 2)\n-\t    vec_oprnds2.safe_push (gimple_get_lhs (new_stmt_info->stmt));\n+\t    vec_oprnds2.safe_push (gimple_get_lhs (new_stmt));\n \t}\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -7003,7 +6991,7 @@ vect_transform_reduction (loop_vec_info loop_vinfo,\n \n bool\n vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n-\t\t\t  stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n+\t\t\t  stmt_vec_info stmt_info, gimple **vec_stmt,\n \t\t\t  slp_tree slp_node, slp_instance slp_node_instance)\n {\n   tree vectype_out = STMT_VINFO_VECTYPE (stmt_info);\n@@ -7138,7 +7126,6 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t  /* Create the reduction-phi that defines the reduction\n \t     operand.  */\n \t  gphi *new_phi = create_phi_node (vec_dest, loop->header);\n-\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n \n \t  /* Set the loop-entry arg of the reduction-phi.  */\n \t  if (j != 0 && nested_cycle)\n@@ -7149,12 +7136,12 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \t  /* The loop-latch arg is set in epilogue processing.  */\n \n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi);\n \t  else\n \t    {\n \t      if (j == 0)\n-\t\t*vec_stmt = new_phi_info;\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_phi_info);\n+\t\t*vec_stmt = new_phi;\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_phi);\n \t    }\n \t}\n     }\n@@ -7166,7 +7153,7 @@ vect_transform_cycle_phi (loop_vec_info loop_vinfo,\n \n bool\n vectorizable_lc_phi (loop_vec_info loop_vinfo,\n-\t\t     stmt_vec_info stmt_info, stmt_vec_info *vec_stmt,\n+\t\t     stmt_vec_info stmt_info, gimple **vec_stmt,\n \t\t     slp_tree slp_node)\n {\n   if (!loop_vinfo\n@@ -7198,11 +7185,10 @@ vectorizable_lc_phi (loop_vec_info loop_vinfo,\n       /* Create the vectorized LC PHI node.  */\n       gphi *new_phi = create_phi_node (vec_dest, bb);\n       add_phi_arg (new_phi, vec_oprnds[i], e, UNKNOWN_LOCATION);\n-      stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_phi_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_phi);\n     }\n   if (!slp_node)\n     *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n@@ -7262,7 +7248,7 @@ bool\n vectorizable_induction (loop_vec_info loop_vinfo,\n \t\t\tstmt_vec_info stmt_info,\n \t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\tgimple **vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -7495,8 +7481,6 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  /* Create the induction-phi that defines the induction-operand.  */\n \t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n \t  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n-\t  stmt_vec_info induction_phi_info\n-\t    = loop_vinfo->add_stmt (induction_phi);\n \t  induc_def = PHI_RESULT (induction_phi);\n \n \t  /* Create the iv update inside the loop  */\n@@ -7505,15 +7489,14 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  vec_def = gimple_build (&stmts,\n \t\t\t\t  PLUS_EXPR, step_vectype, vec_def, vec_step);\n \t  vec_def = gimple_convert (&stmts, vectype, vec_def);\n-\t  loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (vec_def));\n \t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n \n \t  /* Set the arguments of the phi node:  */\n \t  add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n \t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n \t\t       UNKNOWN_LOCATION);\n \n-\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi_info);\n+\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi);\n \t}\n       /* Fill up to the number of vectors we need for the whole group.  */\n       nivs = least_common_multiple (group_size,\n@@ -7545,7 +7528,7 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t\t\t\t       step_vectype, NULL);\n \t  for (; ivn < nvects; ++ivn)\n \t    {\n-\t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs]->stmt;\n+\t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs];\n \t      tree def;\n \t      if (gimple_code (iv) == GIMPLE_PHI)\n \t\tdef = gimple_phi_result (iv);\n@@ -7563,8 +7546,8 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t\t  gimple_stmt_iterator tgsi = gsi_for_stmt (iv);\n \t\t  gsi_insert_seq_after (&tgsi, stmts, GSI_CONTINUE_LINKING);\n \t\t}\n-\t      SLP_TREE_VEC_STMTS (slp_node).quick_push\n-\t\t(loop_vinfo->add_stmt (SSA_NAME_DEF_STMT (def)));\n+\t      SLP_TREE_VEC_STMTS (slp_node)\n+\t\t.quick_push (SSA_NAME_DEF_STMT (def));\n \t    }\n \t}\n \n@@ -7595,7 +7578,6 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n \t  new_bb = gsi_insert_on_edge_immediate (loop_preheader_edge (iv_loop),\n \t\t\t\t\t\t new_stmt);\n \t  gcc_assert (!new_bb);\n-\t  loop_vinfo->add_stmt (new_stmt);\n \t}\n     }\n   else\n@@ -7701,7 +7683,6 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   /* Create the induction-phi that defines the induction-operand.  */\n   vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n   induction_phi = create_phi_node (vec_dest, iv_loop->header);\n-  stmt_vec_info induction_phi_info = loop_vinfo->add_stmt (induction_phi);\n   induc_def = PHI_RESULT (induction_phi);\n \n   /* Create the iv update inside the loop  */\n@@ -7711,15 +7692,14 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n   vec_def = gimple_convert (&stmts, vectype, vec_def);\n   gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n   new_stmt = SSA_NAME_DEF_STMT (vec_def);\n-  stmt_vec_info new_stmt_info = loop_vinfo->add_stmt (new_stmt);\n \n   /* Set the arguments of the phi node:  */\n   add_phi_arg (induction_phi, vec_init, pe, UNKNOWN_LOCATION);\n   add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n \t       UNKNOWN_LOCATION);\n \n-  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (induction_phi_info);\n-  *vec_stmt = induction_phi_info;\n+  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (induction_phi);\n+  *vec_stmt = induction_phi;\n \n   /* In case that vectorization factor (VF) is bigger than the number\n      of elements that we can fit in a vectype (nunits), we have to generate\n@@ -7768,8 +7748,7 @@ vectorizable_induction (loop_vec_info loop_vinfo,\n  \n \t  gsi_insert_seq_before (&si, stmts, GSI_SAME_STMT);\n \t  new_stmt = SSA_NAME_DEF_STMT (vec_def);\n-\t  new_stmt_info = loop_vinfo->add_stmt (new_stmt);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n     }\n \n@@ -7944,7 +7923,7 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n \n       /* Get the correct slp vectorized stmt.  */\n-      gimple *vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry]->stmt;\n+      gimple *vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry];\n       if (gphi *phi = dyn_cast <gphi *> (vec_stmt))\n \tvec_lhs = gimple_phi_result (phi);\n       else\n@@ -7957,7 +7936,7 @@ vectorizable_live_operation (loop_vec_info loop_vinfo,\n   else\n     {\n       /* For multiple copies, get the last copy.  */\n-      vec_lhs = gimple_get_lhs (STMT_VINFO_VEC_STMTS (stmt_info).last ()->stmt);\n+      vec_lhs = gimple_get_lhs (STMT_VINFO_VEC_STMTS (stmt_info).last ());\n \n       /* Get the last lane in the vector.  */\n       bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);\n@@ -8683,6 +8662,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \t    }\n \t  else\n \t    {\n+\t      /* Ignore vector stmts created in the outer loop.  */\n \t      stmt_info = loop_vinfo->lookup_stmt (stmt);\n \n \t      /* vector stmts created in the outer-loop during vectorization of"}, {"sha": "930f47e0742a9a1177d2a6440134a728a960abd2", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -5503,4 +5503,7 @@ vect_pattern_recog (vec_info *vinfo)\n \t\t\t\t  &vect_vect_recog_func_ptrs[j], stmt_info);\n \t}\n     }\n+\n+  /* After this no more add_stmt calls are allowed.  */\n+  vinfo->stmt_vec_info_ro = true;\n }"}, {"sha": "0217a524f058535653b00b05ab7093ea792bb935", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -3666,7 +3666,7 @@ tree\n vect_get_slp_vect_def (slp_tree slp_node, unsigned i)\n {\n   if (SLP_TREE_VEC_STMTS (slp_node).exists ())\n-    return gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]->stmt);\n+    return gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[i]);\n   else\n     return SLP_TREE_VEC_DEFS (slp_node)[i];\n }\n@@ -3680,9 +3680,9 @@ vect_get_slp_defs (slp_tree slp_node, vec<tree> *vec_defs)\n   if (SLP_TREE_DEF_TYPE (slp_node) == vect_internal_def)\n     {\n       unsigned j;\n-      stmt_vec_info vec_def_stmt_info;\n-      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), j, vec_def_stmt_info)\n-\tvec_defs->quick_push (gimple_get_lhs (vec_def_stmt_info->stmt));\n+      gimple *vec_def_stmt;\n+      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), j, vec_def_stmt)\n+\tvec_defs->quick_push (gimple_get_lhs (vec_def_stmt));\n     }\n   else\n     vec_defs->splice (SLP_TREE_VEC_DEFS (slp_node));\n@@ -3880,31 +3880,28 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n \t\t  /* Generate the permute statement if necessary.  */\n \t\t  tree first_vec = dr_chain[first_vec_index + ri];\n \t\t  tree second_vec = dr_chain[second_vec_index + ri];\n-\t\t  stmt_vec_info perm_stmt_info;\n+\t\t  gimple *perm_stmt;\n \t\t  if (! noop_p)\n \t\t    {\n \t\t      gassign *stmt = as_a <gassign *> (stmt_info->stmt);\n \t\t      tree perm_dest\n \t\t\t= vect_create_destination_var (gimple_assign_lhs (stmt),\n \t\t\t\t\t\t       vectype);\n \t\t      perm_dest = make_ssa_name (perm_dest);\n-\t\t      gassign *perm_stmt\n+\t\t      perm_stmt\n \t\t\t= gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n \t\t\t\t\t       first_vec, second_vec,\n \t\t\t\t\t       mask_vec);\n-\t\t      perm_stmt_info\n-\t\t\t= vect_finish_stmt_generation (vinfo,\n-\t\t\t\t\t\t       stmt_info, perm_stmt,\n-\t\t\t\t\t\t       gsi);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info, perm_stmt,\n+\t\t\t\t\t\t   gsi);\n \t\t    }\n \t\t  else\n \t\t    /* If mask was NULL_TREE generate the requested\n \t\t       identity transform.  */\n-\t\t    perm_stmt_info = vinfo->lookup_def (first_vec);\n+\t\t    perm_stmt = SSA_NAME_DEF_STMT (first_vec);\n \n \t\t  /* Store the vector statement in NODE.  */\n-\t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++]\n-\t\t    = perm_stmt_info;\n+\t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++] = perm_stmt;\n \t\t}\n \t    }\n \n@@ -3995,8 +3992,8 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t}\n       if (ocode != ERROR_MARK)\n \t{\n-\t  vec<stmt_vec_info> v0;\n-\t  vec<stmt_vec_info> v1;\n+\t  vec<gimple *> v0;\n+\t  vec<gimple *> v1;\n \t  unsigned j;\n \t  tree tmask = NULL_TREE;\n \t  vect_transform_stmt (vinfo, stmt_info, &si, node, instance);\n@@ -4037,11 +4034,11 @@ vect_schedule_slp_instance (vec_info *vinfo,\n \t      gimple *vstmt;\n \t      vstmt = gimple_build_assign (make_ssa_name (vectype),\n \t\t\t\t\t   VEC_PERM_EXPR,\n-\t\t\t\t\t   gimple_assign_lhs (v0[j]->stmt),\n-\t\t\t\t\t   gimple_assign_lhs (v1[j]->stmt),\n+\t\t\t\t\t   gimple_assign_lhs (v0[j]),\n+\t\t\t\t\t   gimple_assign_lhs (v1[j]),\n \t\t\t\t\t   tmask);\n-\t      SLP_TREE_VEC_STMTS (node).quick_push\n-\t\t(vect_finish_stmt_generation (vinfo, stmt_info, vstmt, &si));\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, vstmt, &si);\n+\t      SLP_TREE_VEC_STMTS (node).quick_push (vstmt);\n \t    }\n \t  v0.release ();\n \t  v1.release ();\n@@ -4109,12 +4106,12 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n \n   if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) == 1)\n     {\n-      stmt_vec_info child_stmt_info;\n+      gimple *child_stmt;\n       int j;\n \n-      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt_info)\n+      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n \t{\n-\t  tree vect_lhs = gimple_get_lhs (child_stmt_info->stmt);\n+\t  tree vect_lhs = gimple_get_lhs (child_stmt);\n \t  tree root_lhs = gimple_get_lhs (instance->root_stmt->stmt);\n \t  if (!useless_type_conversion_p (TREE_TYPE (root_lhs),\n \t\t\t\t\t  TREE_TYPE (vect_lhs)))\n@@ -4127,16 +4124,16 @@ vectorize_slp_instance_root_stmt (slp_tree node, slp_instance instance)\n   else if (SLP_TREE_NUMBER_OF_VEC_STMTS (node) > 1)\n     {\n       int nelts = SLP_TREE_NUMBER_OF_VEC_STMTS (node);\n-      stmt_vec_info child_stmt_info;\n+      gimple *child_stmt;\n       int j;\n       vec<constructor_elt, va_gc> *v;\n       vec_alloc (v, nelts);\n \n-      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt_info)\n+      FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (node), j, child_stmt)\n \t{\n \t  CONSTRUCTOR_APPEND_ELT (v,\n \t\t\t\t  NULL_TREE,\n-\t\t\t\t  gimple_get_lhs (child_stmt_info->stmt));\n+\t\t\t\t  gimple_get_lhs (child_stmt));\n \t}\n       tree lhs = gimple_get_lhs (instance->root_stmt->stmt);\n       tree rtype = TREE_TYPE (gimple_assign_rhs1 (instance->root_stmt->stmt));"}, {"sha": "686eb389f0c98b717712a4c25435ca9f8b05877d", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 193, "deletions": 268, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -1478,7 +1478,7 @@ vect_get_vec_defs_for_operand (vec_info *vinfo, stmt_vec_info stmt_vinfo,\n       gcc_assert (STMT_VINFO_VEC_STMTS (def_stmt_info).length () == ncopies);\n       for (unsigned i = 0; i < ncopies; ++i)\n \tvec_oprnds->quick_push (gimple_get_lhs\n-\t\t\t\t  (STMT_VINFO_VEC_STMTS (def_stmt_info)[i]->stmt));\n+\t\t\t\t  (STMT_VINFO_VEC_STMTS (def_stmt_info)[i]));\n     }\n }\n \n@@ -1540,13 +1540,10 @@ vect_get_vec_defs (vec_info *vinfo, stmt_vec_info stmt_info, slp_tree slp_node,\n    vect_finish_stmt_generation.  Set the location of the new\n    statement and create and return a stmt_vec_info for it.  */\n \n-static stmt_vec_info\n-vect_finish_stmt_generation_1 (vec_info *vinfo,\n+static void\n+vect_finish_stmt_generation_1 (vec_info *,\n \t\t\t       stmt_vec_info stmt_info, gimple *vec_stmt)\n {\n-  stmt_vec_info vec_stmt_info = vinfo->add_stmt (vec_stmt);\n-  vec_stmt_info->vector_stmt = 1;\n-\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: %G\", vec_stmt);\n \n@@ -1563,15 +1560,13 @@ vect_finish_stmt_generation_1 (vec_info *vinfo,\n     }\n   else\n     gcc_assert (!stmt_could_throw_p (cfun, vec_stmt));\n-\n-  return vec_stmt_info;\n }\n \n /* Replace the scalar statement STMT_INFO with a new vector statement VEC_STMT,\n    which sets the same scalar result as STMT_INFO did.  Create and return a\n    stmt_vec_info for VEC_STMT.  */\n \n-stmt_vec_info\n+void\n vect_finish_replace_stmt (vec_info *vinfo,\n \t\t\t  stmt_vec_info stmt_info, gimple *vec_stmt)\n {\n@@ -1581,13 +1576,13 @@ vect_finish_replace_stmt (vec_info *vinfo,\n   gimple_stmt_iterator gsi = gsi_for_stmt (scalar_stmt);\n   gsi_replace (&gsi, vec_stmt, true);\n \n-  return vect_finish_stmt_generation_1 (vinfo, stmt_info, vec_stmt);\n+  vect_finish_stmt_generation_1 (vinfo, stmt_info, vec_stmt);\n }\n \n /* Add VEC_STMT to the vectorized implementation of STMT_INFO and insert it\n    before *GSI.  Create and return a stmt_vec_info for VEC_STMT.  */\n \n-stmt_vec_info\n+void\n vect_finish_stmt_generation (vec_info *vinfo,\n \t\t\t     stmt_vec_info stmt_info, gimple *vec_stmt,\n \t\t\t     gimple_stmt_iterator *gsi)\n@@ -1621,7 +1616,7 @@ vect_finish_stmt_generation (vec_info *vinfo,\n \t}\n     }\n   gsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n-  return vect_finish_stmt_generation_1 (vinfo, stmt_info, vec_stmt);\n+  vect_finish_stmt_generation_1 (vinfo, stmt_info, vec_stmt);\n }\n \n /* We want to vectorize a call to combined function CFN with function\n@@ -2564,7 +2559,7 @@ vect_build_zero_merge_argument (vec_info *vinfo,\n static void\n vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t\t      gimple_stmt_iterator *gsi,\n-\t\t\t      stmt_vec_info *vec_stmt,\n+\t\t\t      gimple **vec_stmt,\n \t\t\t      gather_scatter_info *gs_info,\n \t\t\t      tree mask)\n {\n@@ -2661,7 +2656,6 @@ vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n   tree src_op = NULL_TREE;\n   tree mask_op = NULL_TREE;\n   tree prev_res = NULL_TREE;\n-  stmt_vec_info prev_stmt_info = NULL;\n \n   if (!mask)\n     {\n@@ -2765,29 +2759,26 @@ vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n \t    }\n \t  src_op = build_zero_cst (srctype);\n \t}\n-      gcall *new_call = gimple_build_call (gs_info->decl, 5, src_op, ptr, op,\n-\t\t\t\t\t   mask_arg, scale);\n+      gimple *new_stmt = gimple_build_call (gs_info->decl, 5, src_op, ptr, op,\n+\t\t\t\t\t    mask_arg, scale);\n \n-      stmt_vec_info new_stmt_info;\n       if (!useless_type_conversion_p (vectype, rettype))\n \t{\n \t  gcc_assert (known_eq (TYPE_VECTOR_SUBPARTS (vectype),\n \t\t\t\tTYPE_VECTOR_SUBPARTS (rettype)));\n \t  op = vect_get_new_ssa_name (rettype, vect_simple_var);\n-\t  gimple_call_set_lhs (new_call, op);\n-\t  vect_finish_stmt_generation (vinfo, stmt_info, new_call, gsi);\n+\t  gimple_call_set_lhs (new_stmt, op);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t  var = make_ssa_name (vec_dest);\n \t  op = build1 (VIEW_CONVERT_EXPR, vectype, op);\n-\t  gassign *new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  new_stmt = gimple_build_assign (var, VIEW_CONVERT_EXPR, op);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t}\n       else\n \t{\n-\t  var = make_ssa_name (vec_dest, new_call);\n-\t  gimple_call_set_lhs (new_call, var);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_call, gsi);\n+\t  var = make_ssa_name (vec_dest, new_stmt);\n+\t  gimple_call_set_lhs (new_stmt, var);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t}\n \n       if (modifier == NARROW)\n@@ -2799,14 +2790,12 @@ vect_build_gather_load_calls (vec_info *vinfo, stmt_vec_info stmt_info,\n \t    }\n \t  var = permute_vec_elements (vinfo, prev_res, var, perm_mask,\n \t\t\t\t      stmt_info, gsi);\n-\t  new_stmt_info = loop_vinfo->lookup_def (var);\n+\t  new_stmt = SSA_NAME_DEF_STMT (var);\n \t}\n \n-      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n-      if (prev_stmt_info == NULL)\n-\t*vec_stmt = new_stmt_info;\n-      prev_stmt_info = new_stmt_info;\n+      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n+  *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n }\n \n /* Prepare the base and offset in GS_INFO for vectorization.\n@@ -2905,7 +2894,7 @@ vect_get_data_ptr_increment (vec_info *vinfo,\n static bool\n vectorizable_bswap (vec_info *vinfo,\n \t\t    stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t    gimple **vec_stmt, slp_tree slp_node,\n \t\t    slp_tree *slp_op,\n \t\t    tree vectype_in, stmt_vector_for_cost *cost_vec)\n {\n@@ -2993,12 +2982,11 @@ vectorizable_bswap (vec_info *vinfo,\n       tem = make_ssa_name (vectype);\n       new_stmt = gimple_build_assign (tem, build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t\t   vectype, tem2));\n-      stmt_vec_info new_stmt_info\n-\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -3043,7 +3031,7 @@ simple_integer_narrowing (tree vectype_out, tree vectype_in,\n static bool\n vectorizable_call (vec_info *vinfo,\n \t\t   stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t   gimple **vec_stmt, slp_tree slp_node,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n   gcall *stmt;\n@@ -3333,7 +3321,6 @@ vectorizable_call (vec_info *vinfo,\n \n   bool masked_loop_p = loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n \n-  stmt_vec_info new_stmt_info = NULL;\n   if (modifier == NONE || ifn != IFN_LAST)\n     {\n       tree prev_res = NULL_TREE;\n@@ -3359,6 +3346,7 @@ vectorizable_call (vec_info *vinfo,\n \t\t      vec<tree> vec_oprndsk = vec_defs[k];\n \t\t      vargs[k] = vec_oprndsk[i];\n \t\t    }\n+\t\t  gimple *new_stmt;\n \t\t  if (modifier == NARROW)\n \t\t    {\n \t\t      /* We don't define any narrowing conditional functions\n@@ -3376,12 +3364,10 @@ vectorizable_call (vec_info *vinfo,\n \t\t\t  continue;\n \t\t\t}\n \t\t      new_temp = make_ssa_name (vec_dest);\n-\t\t      gimple *new_stmt\n-\t\t\t= gimple_build_assign (new_temp, convert_code,\n-\t\t\t\t\t       prev_res, half_res);\n-\t\t      new_stmt_info\n-\t\t\t= vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t       new_stmt, gsi);\n+\t\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t\t      prev_res, half_res);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info,\n+\t\t\t\t\t\t   new_stmt, gsi);\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -3404,11 +3390,10 @@ vectorizable_call (vec_info *vinfo,\n \t\t      new_temp = make_ssa_name (vec_dest, call);\n \t\t      gimple_call_set_lhs (call, new_temp);\n \t\t      gimple_call_set_nothrow (call, true);\n-\t\t      new_stmt_info\n-\t\t\t= vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t       call, gsi);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t      new_stmt = call;\n \t\t    }\n-\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t\t}\n \t      continue;\n \t    }\n@@ -3434,6 +3419,7 @@ vectorizable_call (vec_info *vinfo,\n \t\t\t\t\t   vargs[mask_opno], gsi);\n \t    }\n \n+\t  gimple *new_stmt;\n \t  if (cfn == CFN_GOMP_SIMD_LANE)\n \t    {\n \t      tree cst = build_index_vector (vectype_out, j * nunits_out, 1);\n@@ -3442,9 +3428,8 @@ vectorizable_call (vec_info *vinfo,\n \t      gimple *init_stmt = gimple_build_assign (new_var, cst);\n \t      vect_init_vector_1 (vinfo, stmt_info, init_stmt, NULL);\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      gimple *new_stmt = gimple_build_assign (new_temp, new_var);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      new_stmt = gimple_build_assign (new_temp, new_var);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t    }\n \t  else if (modifier == NARROW)\n \t    {\n@@ -3462,10 +3447,9 @@ vectorizable_call (vec_info *vinfo,\n \t\t  continue;\n \t\t}\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      gassign *new_stmt = gimple_build_assign (new_temp, convert_code,\n-\t\t\t\t\t\t       prev_res, half_res);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      new_stmt = gimple_build_assign (new_temp, convert_code,\n+\t\t\t\t\t      prev_res, half_res);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t    }\n \t  else\n \t    {\n@@ -3477,13 +3461,13 @@ vectorizable_call (vec_info *vinfo,\n \t      new_temp = make_ssa_name (vec_dest, call);\n \t      gimple_call_set_lhs (call, new_temp);\n \t      gimple_call_set_nothrow (call, true);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t      new_stmt = call;\n \t    }\n \n \t  if (j == (modifier == NARROW ? 1 : 0))\n-\t    *vec_stmt = new_stmt_info;\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t    *vec_stmt = new_stmt;\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n       for (i = 0; i < nargs; i++)\n \t{\n@@ -3530,9 +3514,8 @@ vectorizable_call (vec_info *vinfo,\n \t\t  new_temp = make_ssa_name (vec_dest, call);\n \t\t  gimple_call_set_lhs (call, new_temp);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n-\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (call);\n \t\t}\n \t      continue;\n \t    }\n@@ -3556,10 +3539,9 @@ vectorizable_call (vec_info *vinfo,\n \t  gcall *new_stmt = gimple_build_call_vec (fndecl, vargs);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_call_set_lhs (new_stmt, new_temp);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n \n       if (!slp_node)\n@@ -3695,7 +3677,7 @@ simd_clone_subparts (tree vectype)\n static bool\n vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t\t      gimple_stmt_iterator *gsi,\n-\t\t\t      stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\t      gimple **vec_stmt, slp_tree slp_node,\n \t\t\t      stmt_vector_for_cost *)\n {\n   tree vec_dest;\n@@ -4154,7 +4136,6 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t    }\n \t\t  tree phi_res = copy_ssa_name (op);\n \t\t  gphi *new_phi = create_phi_node (phi_res, loop->header);\n-\t\t  loop_vinfo->add_stmt (new_phi);\n \t\t  add_phi_arg (new_phi, arginfo[i].op,\n \t\t\t       loop_preheader_edge (loop), UNKNOWN_LOCATION);\n \t\t  enum tree_code code\n@@ -4171,7 +4152,6 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t    = gimple_build_assign (phi_arg, code, phi_res, tcst);\n \t\t  gimple_stmt_iterator si = gsi_after_labels (loop->header);\n \t\t  gsi_insert_after (&si, new_stmt, GSI_NEW_STMT);\n-\t\t  loop_vinfo->add_stmt (new_stmt);\n \t\t  add_phi_arg (new_phi, phi_arg, loop_latch_edge (loop),\n \t\t\t       UNKNOWN_LOCATION);\n \t\t  arginfo[i].op = phi_res;\n@@ -4220,8 +4200,8 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t    new_temp = make_ssa_name (rtype, new_call);\n \t  gimple_call_set_lhs (new_call, new_temp);\n \t}\n-      stmt_vec_info new_stmt_info\n-\t= vect_finish_stmt_generation (vinfo, stmt_info, new_call, gsi);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_call, gsi);\n+      gimple *new_stmt = new_call;\n \n       if (vec_dest)\n \t{\n@@ -4244,15 +4224,12 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t  else\n \t\t    t = build3 (BIT_FIELD_REF, vectype, new_temp,\n \t\t\t\tbitsize_int (prec), bitsize_int (l * prec));\n-\t\t  gimple *new_stmt\n-\t\t    = gimple_build_assign (make_ssa_name (vectype), t);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t   new_stmt, gsi);\n+\t\t  new_stmt = gimple_build_assign (make_ssa_name (vectype), t);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n \t\t  if (j == 0 && l == 0)\n-\t\t    *vec_stmt = new_stmt_info;\n-\t\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t\t    *vec_stmt = new_stmt;\n+\t\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t\t}\n \n \t      if (ratype)\n@@ -4273,11 +4250,10 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t\t    {\n \t\t      tree tem = build4 (ARRAY_REF, rtype, new_temp,\n \t\t\t\t\t size_int (m), NULL_TREE, NULL_TREE);\n-\t\t      gimple *new_stmt\n-\t\t\t= gimple_build_assign (make_ssa_name (rtype), tem);\n-\t\t      new_stmt_info\n-\t\t\t= vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t       new_stmt, gsi);\n+\t\t      new_stmt = gimple_build_assign (make_ssa_name (rtype),\n+\t\t\t\t\t\t      tem);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info,\n+\t\t\t\t\t\t   new_stmt, gsi);\n \t\t      CONSTRUCTOR_APPEND_ELT (ret_ctor_elts, NULL_TREE,\n \t\t\t\t\t      gimple_assign_lhs (new_stmt));\n \t\t    }\n@@ -4288,32 +4264,29 @@ vectorizable_simd_clone_call (vec_info *vinfo, stmt_vec_info stmt_info,\n \t      if ((j & (k - 1)) != k - 1)\n \t\tcontinue;\n \t      vec_oprnd0 = build_constructor (vectype, ret_ctor_elts);\n-\t      gimple *new_stmt\n+\t      new_stmt\n \t\t= gimple_build_assign (make_ssa_name (vec_dest), vec_oprnd0);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n \t      if ((unsigned) j == k - 1)\n-\t\t*vec_stmt = new_stmt_info;\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t\t*vec_stmt = new_stmt;\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t      continue;\n \t    }\n \t  else if (ratype)\n \t    {\n \t      tree t = build_fold_addr_expr (new_temp);\n \t      t = build2 (MEM_REF, vectype, t,\n \t\t\t  build_int_cst (TREE_TYPE (t), 0));\n-\t      gimple *new_stmt\n-\t\t= gimple_build_assign (make_ssa_name (vec_dest), t);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      new_stmt = gimple_build_assign (make_ssa_name (vec_dest), t);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t      vect_clobber_variable (vinfo, stmt_info, gsi, new_temp);\n \t    }\n \t}\n \n       if (j == 0)\n-\t*vec_stmt = new_stmt_info;\n-      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t*vec_stmt = new_stmt;\n+      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   for (i = 0; i < nargs; ++i)\n@@ -4403,8 +4376,7 @@ vect_create_vectorized_demotion_stmts (vec_info *vinfo, vec<tree> *vec_oprnds,\n       gassign *new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n       new_tmp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_tmp);\n-      stmt_vec_info new_stmt_info\n-\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n       if (multi_step_cvt)\n \t/* Store the resulting vector for next recursive call.  */\n@@ -4415,9 +4387,9 @@ vect_create_vectorized_demotion_stmts (vec_info *vinfo, vec<tree> *vec_oprnds,\n \t     vectors in SLP_NODE or in vector info of the scalar statement\n \t     (or in STMT_VINFO_RELATED_STMT chain).  */\n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t  else\n-\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n     }\n \n@@ -4503,7 +4475,7 @@ vect_create_vectorized_promotion_stmts (vec_info *vinfo,\n static bool\n vectorizable_conversion (vec_info *vinfo,\n \t\t\t stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\t gimple **vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -4887,19 +4859,17 @@ vectorizable_conversion (vec_info *vinfo,\n \t\t\t op0, &vec_oprnds0);\n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t{\n-\t  stmt_vec_info new_stmt_info;\n \t  /* Arguments are ready, create the new vector stmt.  */\n \t  gcc_assert (TREE_CODE_LENGTH (code1) == unary_op);\n \t  gassign *new_stmt = gimple_build_assign (vec_dest, code1, vop0);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t  else\n-\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n       break;\n \n@@ -4936,23 +4906,21 @@ vectorizable_conversion (vec_info *vinfo,\n \n       FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n \t{\n-\t  stmt_vec_info new_stmt_info;\n+\t  gimple *new_stmt;\n \t  if (cvt_type)\n \t    {\n \t      gcc_assert (TREE_CODE_LENGTH (codecvt1) == unary_op);\n \t      new_temp = make_ssa_name (vec_dest);\n-\t      gassign *new_stmt\n-\t\t= gimple_build_assign (new_temp, codecvt1, vop0);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      new_stmt = gimple_build_assign (new_temp, codecvt1, vop0);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t    }\n \t  else\n-\t    new_stmt_info = vinfo->lookup_def (vop0);\n+\t    new_stmt = SSA_NAME_DEF_STMT (vop0);\n \n \t  if (slp_node)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t  else\n-\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t    STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n       break;\n \n@@ -5025,7 +4993,7 @@ vect_nop_conversion_p (stmt_vec_info stmt_info)\n static bool\n vectorizable_assignment (vec_info *vinfo,\n \t\t\t stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\t gimple **vec_stmt, slp_tree slp_node,\n \t\t\t stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -5155,7 +5123,6 @@ vectorizable_assignment (vec_info *vinfo,\n   vect_get_vec_defs (vinfo, stmt_info, slp_node, ncopies, op, &vec_oprnds);\n \n   /* Arguments are ready. create the new vector stmt.  */\n-  stmt_vec_info new_stmt_info = NULL;\n   FOR_EACH_VEC_ELT (vec_oprnds, i, vop)\n     {\n       if (CONVERT_EXPR_CODE_P (code)\n@@ -5164,12 +5131,11 @@ vectorizable_assignment (vec_info *vinfo,\n       gassign *new_stmt = gimple_build_assign (vec_dest, vop);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n-      new_stmt_info\n-\t  = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n   if (!slp_node)\n     *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n@@ -5225,7 +5191,7 @@ vect_supportable_shift (vec_info *vinfo, enum tree_code code, tree scalar_type)\n static bool\n vectorizable_shift (vec_info *vinfo,\n \t\t    stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t    gimple **vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -5606,19 +5572,17 @@ vectorizable_shift (vec_info *vinfo,\n \t\t     vec_oprnd1 ? NULL_TREE : op1, &vec_oprnds1);\n \n   /* Arguments are ready.  Create the new vector stmt.  */\n-  stmt_vec_info new_stmt_info = NULL;\n   FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n     {\n       vop1 = vec_oprnds1[i];\n       gassign *new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1);\n       new_temp = make_ssa_name (vec_dest, new_stmt);\n       gimple_assign_set_lhs (new_stmt, new_temp);\n-      new_stmt_info\n-\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -5642,7 +5606,7 @@ vectorizable_shift (vec_info *vinfo,\n static bool\n vectorizable_operation (vec_info *vinfo,\n \t\t\tstmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\tstmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t\tgimple **vec_stmt, slp_tree slp_node,\n \t\t\tstmt_vector_for_cost *cost_vec)\n {\n   tree vec_dest;\n@@ -6015,9 +5979,9 @@ vectorizable_operation (vec_info *vinfo,\n   vect_get_vec_defs (vinfo, stmt_info, slp_node, ncopies,\n \t\t     op0, &vec_oprnds0, op1, &vec_oprnds1, op2, &vec_oprnds2);\n   /* Arguments are ready.  Create the new vector stmt.  */\n-  stmt_vec_info new_stmt_info = NULL;\n   FOR_EACH_VEC_ELT (vec_oprnds0, i, vop0)\n     {\n+      gimple *new_stmt = NULL;\n       vop1 = ((op_type == binary_op || op_type == ternary_op)\n \t      ? vec_oprnds1[i] : NULL_TREE);\n       vop2 = ((op_type == ternary_op) ? vec_oprnds2[i] : NULL_TREE);\n@@ -6034,33 +5998,30 @@ vectorizable_operation (vec_info *vinfo,\n \t  new_temp = make_ssa_name (vec_dest, call);\n \t  gimple_call_set_lhs (call, new_temp);\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t  new_stmt = call;\n \t}\n       else\n \t{\n-\t  gassign *new_stmt = gimple_build_assign (vec_dest, code,\n-\t\t\t\t\t\t   vop0, vop1, vop2);\n+\t  new_stmt = gimple_build_assign (vec_dest, code, vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t  if (vec_cvt_dest)\n \t    {\n \t      new_temp = build1 (VIEW_CONVERT_EXPR, vectype_out, new_temp);\n-\t      gassign *new_stmt\n-\t\t= gimple_build_assign (vec_cvt_dest, VIEW_CONVERT_EXPR,\n-\t\t\t\t       new_temp);\n+\t      new_stmt = gimple_build_assign (vec_cvt_dest, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t      new_temp);\n \t      new_temp = make_ssa_name (vec_cvt_dest, new_stmt);\n \t      gimple_assign_set_lhs (new_stmt, new_temp);\n-\t      new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t\t   new_stmt, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info,\n+\t\t\t\t\t   new_stmt, gsi);\n \t    }\n \t}\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -6723,7 +6684,7 @@ check_scan_store (vec_info *vinfo, stmt_vec_info stmt_info, tree vectype,\n static bool\n vectorizable_scan_store (vec_info *vinfo,\n \t\t\t stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t stmt_vec_info *vec_stmt, int ncopies)\n+\t\t\t gimple **vec_stmt, int ncopies)\n {\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (stmt_info);\n@@ -6843,7 +6804,6 @@ vectorizable_scan_store (vec_info *vinfo,\n \t\t     rhs2, &vec_oprnds3);\n   for (int j = 0; j < ncopies; j++)\n     {\n-      stmt_vec_info new_stmt_info;\n       vec_oprnd1 = vec_oprnds1[j];\n       if (ldataref_ptr == NULL)\n \tvec_oprnd2 = vec_oprnds2[j];\n@@ -6861,8 +6821,8 @@ vectorizable_scan_store (vec_info *vinfo,\n \t\t\t\t       dataref_offset);\n \t  vect_copy_ref_info (data_ref, DR_REF (load1_dr_info->dr));\n \t  gimple *g = gimple_build_assign (vec_oprnd2, data_ref);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \t  *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n \t}\n \n@@ -6876,8 +6836,8 @@ vectorizable_scan_store (vec_info *vinfo,\n \t\t\t\t\t\t!= scan_store_kind_perm))\n \t\t\t\t\t   ? zero_vec : vec_oprnd1, v,\n \t\t\t\t\t   perms[i]);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \t  *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n \n \t  if (zero_vec && use_whole_vector[i] == scan_store_kind_lshift_cond)\n@@ -6893,9 +6853,9 @@ vectorizable_scan_store (vec_info *vinfo,\n \t      tree new_temp2 = make_ssa_name (vectype);\n \t      g = gimple_build_assign (new_temp2, VEC_COND_EXPR, vb.build (),\n \t\t\t\t       new_temp, vec_oprnd1);\n-\t      new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info,\n+\t      vect_finish_stmt_generation (vinfo, stmt_info,\n \t\t\t\t\t\t\t   g, gsi);\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \t      new_temp = new_temp2;\n \t    }\n \n@@ -6912,16 +6872,16 @@ vectorizable_scan_store (vec_info *vinfo,\n \n \t  tree new_temp2 = make_ssa_name (vectype);\n \t  g = gimple_build_assign (new_temp2, code, v, new_temp);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \n \t  v = new_temp2;\n \t}\n \n       tree new_temp = make_ssa_name (vectype);\n       gimple *g = gimple_build_assign (new_temp, code, orig, v);\n-      new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+      vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \n       tree last_perm_arg = new_temp;\n       /* For exclusive scan, new_temp computed above is the exclusive scan\n@@ -6931,15 +6891,15 @@ vectorizable_scan_store (vec_info *vinfo,\n \t{\n \t  last_perm_arg = make_ssa_name (vectype);\n \t  g = gimple_build_assign (last_perm_arg, code, new_temp, vec_oprnd2);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \t}\n \n       orig = make_ssa_name (vectype);\n       g = gimple_build_assign (orig, VEC_PERM_EXPR, last_perm_arg,\n \t\t\t       last_perm_arg, perms[units_log2]);\n-      new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+      vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \n       if (!inscan_var_store)\n \t{\n@@ -6948,8 +6908,8 @@ vectorizable_scan_store (vec_info *vinfo,\n \t\t\t\t       dataref_offset);\n \t  vect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n \t  g = gimple_build_assign (data_ref, new_temp);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n \t}\n     }\n \n@@ -6964,9 +6924,8 @@ vectorizable_scan_store (vec_info *vinfo,\n \t\t\t\t     dataref_offset);\n \tvect_copy_ref_info (data_ref, DR_REF (dr_info->dr));\n \tgimple *g = gimple_build_assign (data_ref, orig);\n-\tstmt_vec_info new_stmt_info\n-\t  = vect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tvect_finish_stmt_generation (vinfo, stmt_info, g, gsi);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (g);\n       }\n   return true;\n }\n@@ -6983,7 +6942,7 @@ vectorizable_scan_store (vec_info *vinfo,\n static bool\n vectorizable_store (vec_info *vinfo,\n \t\t    stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t    stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t    gimple **vec_stmt, slp_tree slp_node,\n \t\t    stmt_vector_for_cost *cost_vec)\n {\n   tree data_ref;\n@@ -7399,10 +7358,9 @@ vectorizable_store (vec_info *vinfo,\n \n \t  gcall *new_stmt\n \t    = gimple_build_call (gs_info.decl, 5, ptr, mask_arg, op, src, scale);\n-\t  stmt_vec_info new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t   vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n       *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n       return true;\n@@ -7580,7 +7538,6 @@ vectorizable_store (vec_info *vinfo,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n       incr = gsi_stmt (incr_gsi);\n-      loop_vinfo->add_stmt (incr);\n \n       stride_step = cse_and_gimplify_to_preheader (loop_vinfo, stride_step);\n \n@@ -7643,9 +7600,7 @@ vectorizable_store (vec_info *vinfo,\n \n \t\t  /* And store it to *running_off.  */\n \t\t  assign = gimple_build_assign (newref, elem);\n-\t\t  stmt_vec_info assign_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t   assign, gsi);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, assign, gsi);\n \n \t\t  group_el += lnel;\n \t\t  if (! slp\n@@ -7663,8 +7618,8 @@ vectorizable_store (vec_info *vinfo,\n \t\t      && !slp)\n \t\t    {\n \t\t      if (j == 0 && i == 0)\n-\t\t\t*vec_stmt = assign_info;\n-\t\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (assign_info);\n+\t\t\t*vec_stmt = assign;\n+\t\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (assign);\n \t\t    }\n \t\t}\n \t    }\n@@ -7777,7 +7732,7 @@ vectorizable_store (vec_info *vinfo,\n   gvec_oprnds.safe_grow_cleared (group_size);\n   for (j = 0; j < ncopies; j++)\n     {\n-      stmt_vec_info new_stmt_info;\n+      gimple *new_stmt;\n       if (j == 0)\n \t{\n           if (slp)\n@@ -7924,15 +7879,15 @@ vectorizable_store (vec_info *vinfo,\n \t      gimple_call_set_lhs (call, data_ref);\n \t    }\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t       call, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t  new_stmt = call;\n \n \t  /* Record that VEC_ARRAY is now dead.  */\n \t  vect_clobber_variable (vinfo, stmt_info, gsi, vec_array);\n \t}\n       else\n \t{\n-\t  new_stmt_info = NULL;\n+\t  new_stmt = NULL;\n \t  if (grouped_store)\n \t    {\n \t      if (j == 0)\n@@ -7970,8 +7925,8 @@ vectorizable_store (vec_info *vinfo,\n \t\t      (IFN_SCATTER_STORE, 4, dataref_ptr, vec_offset,\n \t\t       scale, vec_oprnd);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  new_stmt = call;\n \t\t  break;\n \t\t}\n \n@@ -8029,8 +7984,8 @@ vectorizable_store (vec_info *vinfo,\n \t\t\t\t\t\t  dataref_ptr, ptr,\n \t\t\t\t\t\t  final_mask, vec_oprnd);\n \t\t  gimple_call_set_nothrow (call, true);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  new_stmt = call;\n \t\t}\n \t      else\n \t\t{\n@@ -8050,10 +8005,8 @@ vectorizable_store (vec_info *vinfo,\n \t\t      = build_aligned_type (TREE_TYPE (data_ref),\n \t\t\t\t\t    TYPE_ALIGN (elem_type));\n \t\t  vect_copy_ref_info (data_ref, DR_REF (first_dr_info->dr));\n-\t\t  gassign *new_stmt\n-\t\t    = gimple_build_assign (data_ref, vec_oprnd);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t\t  new_stmt = gimple_build_assign (data_ref, vec_oprnd);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t\t}\n \n \t      if (slp)\n@@ -8067,8 +8020,8 @@ vectorizable_store (vec_info *vinfo,\n       if (!slp)\n \t{\n \t  if (j == 0)\n-\t    *vec_stmt = new_stmt_info;\n-\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t    *vec_stmt = new_stmt;\n+\t  STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t}\n     }\n \n@@ -8205,7 +8158,7 @@ hoist_defs_of_uses (stmt_vec_info stmt_info, class loop *loop)\n static bool\n vectorizable_load (vec_info *vinfo,\n \t\t   stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t   stmt_vec_info *vec_stmt, slp_tree slp_node,\n+\t\t   gimple **vec_stmt, slp_tree slp_node,\n \t\t   stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest;\n@@ -8535,27 +8488,20 @@ vectorizable_load (vec_info *vinfo,\n       gsi_next (&gsi2);\n       for (j = 0; j < ncopies; j++)\n \t{\n-\t  stmt_vec_info new_stmt_info;\n \t  if (hoist_p)\n-\t    {\n-\t      new_temp = vect_init_vector (vinfo, stmt_info, scalar_dest,\n-\t\t\t\t\t   vectype, NULL);\n-\t      gimple *new_stmt = SSA_NAME_DEF_STMT (new_temp);\n-\t      new_stmt_info = vinfo->add_stmt (new_stmt);\n-\t    }\n+\t    new_temp = vect_init_vector (vinfo, stmt_info, scalar_dest,\n+\t\t\t\t\t vectype, NULL);\n \t  else\n-\t    {\n-\t      new_temp = vect_init_vector (vinfo, stmt_info, scalar_dest,\n-\t\t\t\t\t   vectype, &gsi2);\n-\t      new_stmt_info = vinfo->lookup_def (new_temp);\n-\t    }\n+\t    new_temp = vect_init_vector (vinfo, stmt_info, scalar_dest,\n+\t\t\t\t\t vectype, &gsi2);\n+\t  gimple *new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t  if (slp)\n-\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t  else\n \t    {\n \t      if (j == 0)\n-\t\t*vec_stmt = new_stmt_info;\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t\t*vec_stmt = new_stmt;\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t    }\n \t}\n       return true;\n@@ -8566,7 +8512,6 @@ vectorizable_load (vec_info *vinfo,\n     {\n       gimple_stmt_iterator incr_gsi;\n       bool insert_after;\n-      gimple *incr;\n       tree offvar;\n       tree ivstep;\n       tree running_off;\n@@ -8641,8 +8586,6 @@ vectorizable_load (vec_info *vinfo,\n       create_iv (stride_base, ivstep, NULL,\n \t\t loop, &incr_gsi, insert_after,\n \t\t &offvar, NULL);\n-      incr = gsi_stmt (incr_gsi);\n-      loop_vinfo->add_stmt (incr);\n \n       stride_step = cse_and_gimplify_to_preheader (loop_vinfo, stride_step);\n \n@@ -8712,17 +8655,15 @@ vectorizable_load (vec_info *vinfo,\n \t{\n \t  if (nloads > 1)\n \t    vec_alloc (v, nloads);\n-\t  stmt_vec_info new_stmt_info = NULL;\n+\t  gimple *new_stmt = NULL;\n \t  for (i = 0; i < nloads; i++)\n \t    {\n \t      tree this_off = build_int_cst (TREE_TYPE (alias_off),\n \t\t\t\t\t     group_el * elsz + cst_offset);\n \t      tree data_ref = build2 (MEM_REF, ltype, running_off, this_off);\n \t      vect_copy_ref_info (data_ref, DR_REF (first_dr_info->dr));\n-\t      gassign *new_stmt\n-\t\t= gimple_build_assign (make_ssa_name (ltype), data_ref);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      new_stmt = gimple_build_assign (make_ssa_name (ltype), data_ref);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t      if (nloads > 1)\n \t\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t\t\tgimple_assign_lhs (new_stmt));\n@@ -8745,32 +8686,29 @@ vectorizable_load (vec_info *vinfo,\n \t      tree vec_inv = build_constructor (lvectype, v);\n \t      new_temp = vect_init_vector (vinfo, stmt_info,\n \t\t\t\t\t   vec_inv, lvectype, gsi);\n-\t      new_stmt_info = vinfo->lookup_def (new_temp);\n+\t      new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t      if (lvectype != vectype)\n \t\t{\n-\t\t  gassign *new_stmt\n-\t\t    = gimple_build_assign (make_ssa_name (vectype),\n-\t\t\t\t\t   VIEW_CONVERT_EXPR,\n-\t\t\t\t\t   build1 (VIEW_CONVERT_EXPR,\n-\t\t\t\t\t\t   vectype, new_temp));\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t   new_stmt, gsi);\n+\t\t  new_stmt = gimple_build_assign (make_ssa_name (vectype),\n+\t\t\t\t\t\t  VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t  build1 (VIEW_CONVERT_EXPR,\n+\t\t\t\t\t\t\t  vectype, new_temp));\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t\t}\n \t    }\n \n \t  if (slp)\n \t    {\n \t      if (slp_perm)\n-\t\tdr_chain.quick_push (gimple_assign_lhs (new_stmt_info->stmt));\n+\t\tdr_chain.quick_push (gimple_assign_lhs (new_stmt));\n \t      else\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \t    }\n \t  else\n \t    {\n \t      if (j == 0)\n-\t\t*vec_stmt = new_stmt_info;\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t\t*vec_stmt = new_stmt;\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t    }\n \t}\n       if (slp_perm)\n@@ -9052,7 +8990,6 @@ vectorizable_load (vec_info *vinfo,\n   poly_uint64 group_elt = 0;\n   for (j = 0; j < ncopies; j++)\n     {\n-      stmt_vec_info new_stmt_info = NULL;\n       /* 1. Create the vector or array pointer update chain.  */\n       if (j == 0)\n \t{\n@@ -9131,6 +9068,7 @@ vectorizable_load (vec_info *vinfo,\n       if (grouped_load || slp_perm)\n \tdr_chain.create (vec_num);\n \n+      gimple *new_stmt = NULL;\n       if (memory_access_type == VMAT_LOAD_STORE_LANES)\n \t{\n \t  tree vec_array;\n@@ -9166,8 +9104,8 @@ vectorizable_load (vec_info *vinfo,\n \t    }\n \t  gimple_call_set_lhs (call, vec_array);\n \t  gimple_call_set_nothrow (call, true);\n-\t  new_stmt_info = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t       call, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t  new_stmt = call;\n \n \t  /* Extract each vector into an SSA_NAME.  */\n \t  for (i = 0; i < vec_num; i++)\n@@ -9202,7 +9140,6 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t\t\t       gsi, stmt_info, bump);\n \n \t      /* 2. Create the vector-load in the loop.  */\n-\t      gimple *new_stmt = NULL;\n \t      switch (alignment_support_scheme)\n \t\t{\n \t\tcase dr_aligned:\n@@ -9448,9 +9385,7 @@ vectorizable_load (vec_info *vinfo,\n \t\t}\n \t      new_temp = make_ssa_name (vec_dest, new_stmt);\n \t      gimple_set_lhs (new_stmt, new_temp);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t       new_stmt, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n \t      /* 3. Handle explicit realignment if necessary/supported.\n \t\t Create in loop:\n@@ -9466,9 +9401,7 @@ vectorizable_load (vec_info *vinfo,\n \t\t\t\t\t\t  msq, lsq, realignment_token);\n \t\t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t\t  gimple_assign_set_lhs (new_stmt, new_temp);\n-\t\t  new_stmt_info\n-\t\t    = vect_finish_stmt_generation (vinfo, stmt_info,\n-\t\t\t\t\t\t   new_stmt, gsi);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \n \t\t  if (alignment_support_scheme == dr_explicit_realign_optimized)\n \t\t    {\n@@ -9486,7 +9419,7 @@ vectorizable_load (vec_info *vinfo,\n \t\t  tree perm_mask = perm_mask_for_reverse (vectype);\n \t\t  new_temp = permute_vec_elements (vinfo, new_temp, new_temp,\n \t\t\t\t\t\t   perm_mask, stmt_info, gsi);\n-\t\t  new_stmt_info = vinfo->lookup_def (new_temp);\n+\t\t  new_stmt = SSA_NAME_DEF_STMT (new_temp);\n \t\t}\n \n \t      /* Collect vector loads and later create their permutation in\n@@ -9496,7 +9429,7 @@ vectorizable_load (vec_info *vinfo,\n \n \t      /* Store vector loads in the corresponding SLP_NODE.  */\n \t      if (slp && !slp_perm)\n-\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\t\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n \n \t      /* With SLP permutation we load the gaps as well, without\n \t         we need to skip the gaps after we manage to fully load\n@@ -9549,13 +9482,13 @@ vectorizable_load (vec_info *vinfo,\n \t    }\n           else\n \t    {\n-\t      if (j == 0)\n-\t\t*vec_stmt = new_stmt_info;\n-\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\t      STMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n \t    }\n         }\n       dr_chain.release ();\n     }\n+  if (!slp)\n+    *vec_stmt = STMT_VINFO_VEC_STMTS (stmt_info)[0];\n \n   return true;\n }\n@@ -9667,7 +9600,7 @@ vect_is_simple_cond (tree cond, vec_info *vinfo, stmt_vec_info stmt_info,\n static bool\n vectorizable_condition (vec_info *vinfo,\n \t\t\tstmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\tstmt_vec_info *vec_stmt,\n+\t\t\tgimple **vec_stmt,\n \t\t\tslp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree scalar_dest = NULL_TREE;\n@@ -10090,43 +10023,39 @@ vectorizable_condition (vec_info *vinfo,\n \t    }\n \t}\n \n-      stmt_vec_info new_stmt_info;\n+      gimple *new_stmt;\n       if (reduction_type == EXTRACT_LAST_REDUCTION)\n \t{\n \t  gimple *old_stmt = vect_orig_stmt (stmt_info)->stmt;\n \t  tree lhs = gimple_get_lhs (old_stmt);\n-\t  gcall *new_stmt = gimple_build_call_internal\n+\t  new_stmt = gimple_build_call_internal\n \t      (IFN_FOLD_EXTRACT_LAST, 3, else_clause, vec_compare,\n \t       vec_then_clause);\n \t  gimple_call_set_lhs (new_stmt, lhs);\n \t  SSA_NAME_DEF_STMT (lhs) = new_stmt;\n \t  if (old_stmt == gsi_stmt (*gsi))\n-\t    new_stmt_info = vect_finish_replace_stmt (vinfo,\n-\t\t\t\t\t\t      stmt_info, new_stmt);\n+\t    vect_finish_replace_stmt (vinfo, stmt_info, new_stmt);\n \t  else\n \t    {\n \t      /* In this case we're moving the definition to later in the\n \t\t block.  That doesn't matter because the only uses of the\n \t\t lhs are in phi statements.  */\n \t      gimple_stmt_iterator old_gsi = gsi_for_stmt (old_stmt);\n \t      gsi_remove (&old_gsi, true);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t    }\n \t}\n       else\n \t{\n \t  new_temp = make_ssa_name (vec_dest);\n-\t  gassign *new_stmt\n-\t    = gimple_build_assign (new_temp, VEC_COND_EXPR, vec_compare,\n-\t\t\t\t   vec_then_clause, vec_else_clause);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  new_stmt = gimple_build_assign (new_temp, VEC_COND_EXPR, vec_compare,\n+\t\t\t\t\t  vec_then_clause, vec_else_clause);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t}\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -10151,7 +10080,7 @@ vectorizable_condition (vec_info *vinfo,\n static bool\n vectorizable_comparison (vec_info *vinfo,\n \t\t\t stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n-\t\t\t stmt_vec_info *vec_stmt,\n+\t\t\t gimple **vec_stmt,\n \t\t\t slp_tree slp_node, stmt_vector_for_cost *cost_vec)\n {\n   tree lhs, rhs1, rhs2;\n@@ -10344,27 +10273,24 @@ vectorizable_comparison (vec_info *vinfo,\n   /* Arguments are ready.  Create the new vector stmt.  */\n   FOR_EACH_VEC_ELT (vec_oprnds0, i, vec_rhs1)\n     {\n-      stmt_vec_info new_stmt_info;\n+      gimple *new_stmt;\n       vec_rhs2 = vec_oprnds1[i];\n \n       new_temp = make_ssa_name (mask);\n       if (bitop1 == NOP_EXPR)\n \t{\n-\t  gassign *new_stmt = gimple_build_assign (new_temp, code,\n-\t\t\t\t\t\t   vec_rhs1, vec_rhs2);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  new_stmt = gimple_build_assign (new_temp, code,\n+\t\t\t\t\t  vec_rhs1, vec_rhs2);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t}\n       else\n \t{\n-\t  gassign *new_stmt;\n \t  if (bitop1 == BIT_NOT_EXPR)\n \t    new_stmt = gimple_build_assign (new_temp, bitop1, vec_rhs2);\n \t  else\n \t    new_stmt = gimple_build_assign (new_temp, bitop1, vec_rhs1,\n \t\t\t\t\t    vec_rhs2);\n-\t  new_stmt_info\n-\t    = vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t  vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t  if (bitop2 != NOP_EXPR)\n \t    {\n \t      tree res = make_ssa_name (mask);\n@@ -10373,14 +10299,13 @@ vectorizable_comparison (vec_info *vinfo,\n \t      else\n \t\tnew_stmt = gimple_build_assign (res, bitop2, vec_rhs1,\n \t\t\t\t\t\tnew_temp);\n-\t      new_stmt_info\n-\t\t= vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n+\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt, gsi);\n \t    }\n \t}\n       if (slp_node)\n-\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt_info);\n+\tSLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n       else\n-\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt_info);\n+\tSTMT_VINFO_VEC_STMTS (stmt_info).safe_push (new_stmt);\n     }\n \n   if (!slp_node)\n@@ -10666,7 +10591,7 @@ vect_transform_stmt (vec_info *vinfo,\n \t\t     slp_tree slp_node, slp_instance slp_node_instance)\n {\n   bool is_store = false;\n-  stmt_vec_info vec_stmt = NULL;\n+  gimple *vec_stmt = NULL;\n   bool done;\n \n   gcc_assert (slp_node || !PURE_SLP_STMT (stmt_info));\n@@ -10808,14 +10733,14 @@ vect_transform_stmt (vec_info *vinfo,\n \t  && (PHI_ARG_DEF_FROM_EDGE (phi, e)\n \t      == gimple_get_lhs (orig_stmt_info->stmt)))\n \t{\n-\t  vec<stmt_vec_info> &phi_info\n+\t  vec<gimple *> &phi_info\n \t    = STMT_VINFO_VEC_STMTS (STMT_VINFO_REDUC_DEF (orig_stmt_info));\n-\t  vec<stmt_vec_info> &vec_stmt\n+\t  vec<gimple *> &vec_stmt\n \t    = STMT_VINFO_VEC_STMTS (stmt_info);\n \t  gcc_assert (phi_info.length () == vec_stmt.length ());\n \t  for (unsigned i = 0; i < phi_info.length (); ++i)\n-\t    add_phi_arg (as_a <gphi *> (phi_info[i]->stmt),\n-\t\t\t gimple_get_lhs (vec_stmt[i]->stmt), e,\n+\t    add_phi_arg (as_a <gphi *> (phi_info[i]),\n+\t\t\t gimple_get_lhs (vec_stmt[i]), e,\n \t\t\t gimple_phi_arg_location (phi, e->dest_idx));\n \t}\n       else if (slp_node\n@@ -10827,7 +10752,7 @@ vect_transform_stmt (vec_info *vinfo,\n \t  gcc_assert (SLP_TREE_VEC_STMTS (phi_node).length ()\n \t\t      == SLP_TREE_VEC_STMTS (slp_node).length ());\n \t  for (unsigned i = 0; i < SLP_TREE_VEC_STMTS (phi_node).length (); ++i)\n-\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]->stmt),\n+\t    add_phi_arg (as_a <gphi *> (SLP_TREE_VEC_STMTS (phi_node)[i]),\n \t\t\t vect_get_slp_vect_def (slp_node, i),\n \t\t\t e, gimple_phi_arg_location (phi, e->dest_idx));\n \t}"}, {"sha": "76cfba5d4974bbe97d3b0e888f480adc501b5817", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -461,6 +461,7 @@ vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in,\n \t\t    vec_info_shared *shared_)\n   : kind (kind_in),\n     shared (shared_),\n+    stmt_vec_info_ro (false),\n     target_cost_data (target_cost_data_in)\n {\n   stmt_vec_infos.create (50);\n@@ -619,8 +620,7 @@ vec_info::replace_stmt (gimple_stmt_iterator *gsi, stmt_vec_info stmt_info,\n {\n   gimple *old_stmt = stmt_info->stmt;\n   gcc_assert (!stmt_info->pattern_stmt_p && old_stmt == gsi_stmt (*gsi));\n-  set_vinfo_for_stmt (old_stmt, NULL);\n-  set_vinfo_for_stmt (new_stmt, stmt_info);\n+  gimple_set_uid (new_stmt, gimple_uid (old_stmt));\n   stmt_info->stmt = new_stmt;\n   gsi_replace (gsi, new_stmt, true);\n }\n@@ -666,6 +666,7 @@ vec_info::set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)\n   unsigned int uid = gimple_uid (stmt);\n   if (uid == 0)\n     {\n+      gcc_assert (!stmt_vec_info_ro);\n       gcc_checking_assert (info);\n       uid = stmt_vec_infos.length () + 1;\n       gimple_set_uid (stmt, uid);"}, {"sha": "14f68f7c4f652e10dca65b8a01efe54b44dcc3c7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f25161bdcc2b098a4678a42bb2c581ac47625b17/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f25161bdcc2b098a4678a42bb2c581ac47625b17", "patch": "@@ -138,7 +138,7 @@ struct _slp_tree {\n \n   tree vectype;\n   /* Vectorized stmt/s.  */\n-  vec<stmt_vec_info> vec_stmts;\n+  vec<gimple *> vec_stmts;\n   vec<tree> vec_defs;\n   /* Number of vector stmts that are created to replace the group of scalar\n      stmts. It is calculated during the transformation phase as the number of\n@@ -338,6 +338,8 @@ class vec_info {\n \n   /* The mapping of GIMPLE UID to stmt_vec_info.  */\n   vec<stmt_vec_info> stmt_vec_infos;\n+  /* Whether the above mapping is complete.  */\n+  bool stmt_vec_info_ro;\n \n   /* The SLP graph.  */\n   auto_vec<slp_instance> slp_instances;\n@@ -965,7 +967,7 @@ class _stmt_vec_info {\n   tree vectype;\n \n   /* The vectorized stmts.  */\n-  vec<stmt_vec_info> vec_stmts;\n+  vec<gimple *> vec_stmts;\n \n   /* The following is relevant only for stmts that contain a non-scalar\n      data-ref (array/pointer/struct access). A GIMPLE stmt is expected to have\n@@ -1126,8 +1128,6 @@ class _stmt_vec_info {\n \n   /* True if this is only suitable for SLP vectorization.  */\n   bool slp_vect_only_p;\n-\n-  bool vector_stmt;\n };\n \n /* Information about a gather/scatter call.  */\n@@ -1169,7 +1169,7 @@ struct gather_scatter_info {\n #define STMT_VINFO_RELEVANT(S)             (S)->relevant\n #define STMT_VINFO_LIVE_P(S)               (S)->live\n #define STMT_VINFO_VECTYPE(S)              (S)->vectype\n-#define STMT_VINFO_VEC_STMTS(S)             (S)->vec_stmts\n+#define STMT_VINFO_VEC_STMTS(S)            (S)->vec_stmts\n #define STMT_VINFO_VECTORIZABLE(S)         (S)->vectorizable\n #define STMT_VINFO_DATA_REF(S)             ((S)->dr_aux.dr + 0)\n #define STMT_VINFO_GATHER_SCATTER_P(S)\t   (S)->gather_scatter_p\n@@ -1737,11 +1737,9 @@ record_stmt_cost (stmt_vector_for_cost *body_cost_vec, int count,\n \t\t\t   STMT_VINFO_VECTYPE (stmt_info), misalign, where);\n }\n \n-extern stmt_vec_info vect_finish_replace_stmt (vec_info *,\n-\t\t\t\t\t       stmt_vec_info, gimple *);\n-extern stmt_vec_info vect_finish_stmt_generation (vec_info *,\n-\t\t\t\t\t\t  stmt_vec_info, gimple *,\n-\t\t\t\t\t\t  gimple_stmt_iterator *);\n+extern void vect_finish_replace_stmt (vec_info *, stmt_vec_info, gimple *);\n+extern void vect_finish_stmt_generation (vec_info *, stmt_vec_info, gimple *,\n+\t\t\t\t\t gimple_stmt_iterator *);\n extern opt_result vect_mark_stmts_to_be_vectorized (loop_vec_info, bool *);\n extern tree vect_get_store_rhs (stmt_vec_info);\n void vect_get_vec_defs_for_operand (vec_info *vinfo, stmt_vec_info, unsigned,\n@@ -1872,16 +1870,16 @@ extern bool vectorizable_reduction (loop_vec_info, stmt_vec_info,\n \t\t\t\t    stmt_vector_for_cost *);\n extern bool vectorizable_induction (loop_vec_info, stmt_vec_info,\n \t\t\t\t    gimple_stmt_iterator *,\n-\t\t\t\t    stmt_vec_info *, slp_tree,\n+\t\t\t\t    gimple **, slp_tree,\n \t\t\t\t    stmt_vector_for_cost *);\n extern bool vect_transform_reduction (loop_vec_info, stmt_vec_info,\n \t\t\t\t      gimple_stmt_iterator *,\n-\t\t\t\t      stmt_vec_info *, slp_tree);\n+\t\t\t\t      gimple **, slp_tree);\n extern bool vect_transform_cycle_phi (loop_vec_info, stmt_vec_info,\n-\t\t\t\t      stmt_vec_info *,\n+\t\t\t\t      gimple **,\n \t\t\t\t      slp_tree, slp_instance);\n extern bool vectorizable_lc_phi (loop_vec_info, stmt_vec_info,\n-\t\t\t\t stmt_vec_info *, slp_tree);\n+\t\t\t\t gimple **, slp_tree);\n extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);\n extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n \t\t\t\t\tstmt_vector_for_cost *,"}]}