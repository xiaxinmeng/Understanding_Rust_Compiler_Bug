{"sha": "1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTgxMGY2ZWRhYWQyOTBlNmM0YjgwMDNkZWFjOGEyYmUxZGQwZmI2OA==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-09-14T22:45:54Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-09-14T22:45:54Z"}, "message": "re PR tree-optimization/15262 ([tree-ssa] Alias analyzer cannot handle addressable fields)\n\n\n\tPR tree-optimization/15262\n\t* tree-dfa.c (dump_variable): Also print the type of the\n\tvariable.\n\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If two\n\tmemory tags are of conflicting alias sets but have no aliased\n\tsymbols in common, add one tag to the alias set of the other.\n\t(setup_pointers_and_addressables): Remove hack to deal with\n\tprograms with no aliased symbols.\n\t(may_alias_p): Don't special case aggregate types.\n\n\ntestsuite/ChangeLog\n\n\tPR tree-optimization/15262\n\t* gcc.c-torture/execute/pr15262-1.c: New test.\n\t* gcc.c-torture/execute/pr15262-2.c: New test.\n\nFrom-SVN: r87515", "tree": {"sha": "73cfebf5466c3fb2d5a5c937f32179fafde5c98a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73cfebf5466c3fb2d5a5c937f32179fafde5c98a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/comments", "author": null, "committer": null, "parents": [{"sha": "0e6d31fb864425c9070798db46d4975ba40de1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e6d31fb864425c9070798db46d4975ba40de1a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e6d31fb864425c9070798db46d4975ba40de1a6"}], "stats": {"total": 270, "additions": 181, "deletions": 89}, "files": [{"sha": "eb5533dbddcd08863f603b8caa14e81a4a3b8d4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -1,3 +1,15 @@\n+2004-09-14  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/15262\n+\t* tree-dfa.c (dump_variable): Also print the type of the\n+\tvariable.\n+\t* tree-ssa-alias.c (compute_flow_insensitive_aliasing): If two\n+\tmemory tags are of conflicting alias sets but have no aliased\n+\tsymbols in common, add one tag to the alias set of the other.\n+\t(setup_pointers_and_addressables): Remove hack to deal with\n+\tprograms with no aliased symbols.\n+\t(may_alias_p): Don't special case aggregate types.\n+\n 2004-09-14  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \tPR c/15498"}, {"sha": "6ac93c8b42f8a980e59246d3c5c2d72944e9c0a2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -1,3 +1,9 @@\n+2004-09-14  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/15262\n+\t* gcc.c-torture/execute/pr15262-1.c: New test.\n+\t* gcc.c-torture/execute/pr15262-2.c: New test.\n+\n 2004-09-14  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* gcc.dg/declspec-12.c: New test."}, {"sha": "f6a6fe40b73b8181eee778151e348dc0ab8ecb66", "filename": "gcc/testsuite/gcc.c-torture/execute/pr15262-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-1.c?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -0,0 +1,47 @@\n+/* PR 15262.\n+   The alias analyzer only considers relations between pointers and\n+   symbols.  If two pointers P and Q point to the same symbol S, then\n+   their respective memory tags will either be the same or they will\n+   have S in their alias set.\n+   \n+   However, if there are no common symbols between P and Q, TBAA will\n+   currently miss their alias relationship altogether.  */\n+struct A\n+{\n+  int t;\n+  int i;\n+};\n+\n+int foo () { return 3; }\n+\n+main ()\n+{\n+  struct A loc, *locp;\n+  float f, g, *p;\n+  int T355, *T356;\n+\n+  /* Avoid the partial hack in TBAA that would consider memory tags if\n+     the program had no addressable symbols.  */\n+  f = 3;\n+  g = 2;\n+  p = foo () ? &g : &f;\n+  if (*p > 0.0)\n+    g = 1;\n+\n+  /* Store into *locp and cache its current value.  */\n+  locp = malloc (sizeof (*locp));\n+  locp->i = 10;\n+  T355 = locp->i;\n+\n+  /* Take the address of one of locp's fields and write to it.  */\n+  T356 = &locp->i;\n+  *T356 = 1;\n+\n+  /* Read the recently stored value.  If TBAA fails, this will appear\n+     as a redundant load that will be replaced with '10'.  */\n+  T355 = locp->i;\n+  if (T355 != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "82e8aabd1aba0d2c7cfaea1469d70e55a9d12077", "filename": "gcc/testsuite/gcc.c-torture/execute/pr15262-2.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr15262-2.c?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -0,0 +1,37 @@\n+/* PR 15262.  Similar to pr15262-1.c but with no obvious addresses\n+   being taken in function foo().  Without IPA, by only looking inside\n+   foo() we cannot tell for certain whether 'q' and 'b' alias each\n+   other.  */\n+struct A\n+{\n+  int t;\n+  int i;\n+};\n+\n+struct B\n+{\n+  int *p;\n+  float b;\n+};\n+\n+float X;\n+\n+foo (struct B b, struct A *q, float *h)\n+{\n+  X += *h;\n+  *(b.p) = 3;\n+  q->t = 2;\n+  return *(b.p);\n+}\n+\n+main()\n+{\n+  struct A a;\n+  struct B b;\n+\n+  b.p = &a.t;\n+  if (foo (b, &a, &X) == 3)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "533b98884e66f17654a83641bf58056b23124dfc", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -528,6 +528,9 @@ dump_variable (FILE *file, tree var)\n \n   fprintf (file, \", UID %u\", (unsigned) ann->uid);\n \n+  fprintf (file, \", \");\n+  print_generic_expr (file, TREE_TYPE (var), dump_flags);\n+\n   if (ann->type_mem_tag)\n     {\n       fprintf (file, \", type memory tag: \");"}, {"sha": "65b0d7bc776e75f89c9883934ebf8cd236318c59", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 76, "deletions": 89, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1810f6edaad290e6c4b8003deac8a2be1dd0fb68/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1810f6edaad290e6c4b8003deac8a2be1dd0fb68", "patch": "@@ -875,6 +875,7 @@ static void\n compute_flow_insensitive_aliasing (struct alias_info *ai)\n {\n   size_t i;\n+  sbitmap res;\n \n   /* Initialize counter for the total number of virtual operands that\n      aliasing will introduce.  When AI->TOTAL_ALIAS_VOPS goes beyond the\n@@ -943,6 +944,75 @@ compute_flow_insensitive_aliasing (struct alias_info *ai)\n \t}\n     }\n \n+  /* Since this analysis is based exclusively on symbols, it fails to\n+     handle cases where two pointers P and Q have different memory\n+     tags with conflicting alias set numbers but no aliased symbols in\n+     common.\n+\n+     For example, suppose that we have two memory tags TMT.1 and TMT.2\n+     such that\n+     \n+     \t\tmay-aliases (TMT.1) = { a }\n+\t\tmay-aliases (TMT.2) = { b }\n+\n+     and the alias set number of TMT.1 conflicts with that of TMT.2.\n+     Since they don't have symbols in common, loads and stores from\n+     TMT.1 and TMT.2 will seem independent of each other, which will\n+     lead to the optimizers making invalid transformations (see\n+     testsuite/gcc.c-torture/execute/pr15262-[12].c).\n+\n+     To avoid this problem, we do a final traversal of AI->POINTERS\n+     looking for pairs of pointers that have no aliased symbols in\n+     common and yet have conflicting alias set numbers.  */\n+  res = sbitmap_alloc (num_referenced_vars);\n+\n+  for (i = 0; i < ai->num_pointers; i++)\n+    {\n+      size_t j;\n+      struct alias_map_d *p_map1 = ai->pointers[i];\n+      tree tag1 = var_ann (p_map1->var)->type_mem_tag;\n+      sbitmap may_aliases1 = p_map1->may_aliases;\n+\n+      for (j = i + 1; j < ai->num_pointers; j++)\n+\t{\n+\t  struct alias_map_d *p_map2 = ai->pointers[j];\n+\t  tree tag2 = var_ann (p_map2->var)->type_mem_tag;\n+\t  var_ann_t tag2_ann = var_ann (tag2);\n+\t  sbitmap may_aliases2 = p_map2->may_aliases;\n+\n+\t  /* If the pointers may not point to each other, do nothing.  */\n+\t  if (!may_alias_p (p_map1->var, p_map1->set, p_map2->var, p_map2->set))\n+\t    continue;\n+\n+\t  /* The two pointers may alias each other.  If they already have\n+\t     symbols in common, do nothing.  */\n+\t  sbitmap_a_and_b (res, may_aliases1, may_aliases2);\n+\t  if (sbitmap_first_set_bit (res) >= 0)\n+\t    continue;\n+\n+\t  if (sbitmap_first_set_bit (may_aliases2) >= 0)\n+\t    {\n+\t      size_t k;\n+\n+\t      /* Add all the aliases for TAG2 into TAG1's alias set.\n+\t\t FIXME, update grouping heuristic counters.  */\n+\t      EXECUTE_IF_SET_IN_SBITMAP (may_aliases2, 0, k,\n+\t\t  add_may_alias (tag1, referenced_var (k)));\n+\t      sbitmap_a_or_b (may_aliases1, may_aliases1, may_aliases2);\n+\t      sbitmap_zero (may_aliases2);\n+\t      tag2_ann->may_aliases = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Since TAG2 does not have any aliases of its own, add\n+\t\t TAG2 itself to the alias set of TAG1.  */\n+\t      add_may_alias (tag1, tag2);\n+\t    }\n+\t}\n+    }\n+\n+  sbitmap_free (res);\n+\n   if (dump_file)\n     fprintf (dump_file, \"%s: Total number of aliased vops: %ld\\n\",\n \t     get_name (current_function_decl),\n@@ -1262,8 +1332,9 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \n       /* Name memory tags already have flow-sensitive aliasing\n \t information, so they need not be processed by\n-\t compute_may_aliases.  Similarly, type memory tags are already\n-\t accounted for when we process their associated pointer.  */\n+\t compute_flow_insensitive_aliasing.  Similarly, type memory\n+\t tags are already accounted for when we process their\n+\t associated pointer.  */\n       if (v_ann->mem_tag_kind != NOT_A_TAG)\n \tcontinue;\n \n@@ -1367,41 +1438,6 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t    }\n \t}\n     }\n-\n-  /* If we found no addressable variables, but we have more than one\n-     pointer, we will need to check for conflicts between the\n-     pointers.  Otherwise, we would miss alias relations as in\n-     testsuite/gcc.dg/tree-ssa/20040319-1.c:\n-\n-\t\tstruct bar { int count;  int *arr;};\n-\n-\t\tvoid foo (struct bar *b)\n-\t\t{\n-\t\t  b->count = 0;\n-\t\t  *(b->arr) = 2;\n-\t\t  if (b->count == 0)\n-\t\t    abort ();\n-\t\t}\n-\n-     b->count and *(b->arr) could be aliased if b->arr == &b->count.\n-     To do this, we add all the memory tags for the pointers in\n-     AI->POINTERS to AI->ADDRESSABLE_VARS, so that\n-     compute_flow_insensitive_aliasing will naturally compare every\n-     pointer to every type tag.  */\n-  if (ai->num_addressable_vars == 0\n-      && ai->num_pointers > 1)\n-    {\n-      free (ai->addressable_vars);\n-      ai->addressable_vars = xcalloc (ai->num_pointers,\n-\t\t\t\t      sizeof (struct alias_map_d *));\n-      ai->num_addressable_vars = 0;\n-      for (i = 0; i < ai->num_pointers; i++)\n-\t{\n-\t  struct alias_map_d *p = ai->pointers[i];\n-\t  tree tag = var_ann (p->var)->type_mem_tag;\n-\t  create_alias_map_for (tag, ai);\n-\t}\n-    }\n }\n \n \n@@ -1536,58 +1572,9 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n   /* If the alias sets don't conflict then MEM cannot alias VAR.  */\n   if (!alias_sets_conflict_p (mem_alias_set, var_alias_set))\n     {\n-      /* Handle aliases to structure fields.  If either VAR or MEM are\n-\t aggregate types, they may not have conflicting types, but one of\n-\t the structures could contain a pointer to the other one.\n-\n-\t For instance, given\n-\n-\t\tMEM -> struct P *p;\n-\t\tVAR -> struct Q *q;\n-\n-\t It may happen that '*p' and '*q' can't alias because 'struct P'\n-\t and 'struct Q' have non-conflicting alias sets.  However, it could\n-\t happen that one of the fields in 'struct P' is a 'struct Q *' or\n-\t vice-versa.\n-\n-\t Therefore, we also need to check if 'struct P' aliases 'struct Q *'\n-\t or 'struct Q' aliases 'struct P *'.  Notice, that since GIMPLE\n-\t does not have more than one-level pointers, we don't need to\n-\t recurse into the structures.  */\n-      if (AGGREGATE_TYPE_P (TREE_TYPE (mem))\n-\t  || AGGREGATE_TYPE_P (TREE_TYPE (var)))\n-\t{\n-\t  tree ptr_to_var;\n-\t  \n-\t  if (TREE_CODE (TREE_TYPE (var)) == ARRAY_TYPE)\n-\t    ptr_to_var = TYPE_POINTER_TO (TREE_TYPE (TREE_TYPE (var)));\n-\t  else\n-\t    ptr_to_var = TYPE_POINTER_TO (TREE_TYPE (var));\n-\n-\t  /* If no pointer-to VAR exists, then MEM can't alias VAR.  */\n-\t  if (ptr_to_var == NULL_TREE)\n-\t    {\n-\t      alias_stats.alias_noalias++;\n-\t      alias_stats.tbaa_resolved++;\n-\t      return false;\n-\t    }\n-\n-\t  /* If MEM doesn't alias a pointer to VAR and VAR doesn't alias\n-\t     PTR, then PTR can't alias VAR.  */\n-\t  if (!alias_sets_conflict_p (mem_alias_set, get_alias_set (ptr_to_var))\n-\t      && !alias_sets_conflict_p (var_alias_set, get_alias_set (ptr)))\n-\t    {\n-\t      alias_stats.alias_noalias++;\n-\t      alias_stats.tbaa_resolved++;\n-\t      return false;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  alias_stats.alias_noalias++;\n-\t  alias_stats.tbaa_resolved++;\n-\t  return false;\n-\t}\n+      alias_stats.alias_noalias++;\n+      alias_stats.tbaa_resolved++;\n+      return false;\n     }\n \n   alias_stats.alias_mayalias++;"}]}