{"sha": "88b080739aec46faddff05bb6f13fb2886c36aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODhiMDgwNzM5YWVjNDZmYWRkZmYwNWJiNmYxM2ZiMjg4NmMzNmFmZg==", "commit": {"author": {"name": "James Greenhalgh", "email": "james.greenhalgh@arm.com", "date": "2012-12-05T11:36:00Z"}, "committer": {"name": "James Greenhalgh", "email": "jgreenhalgh@gcc.gnu.org", "date": "2012-12-05T11:36:00Z"}, "message": "[AARCH64] Implement Vector Permute Support.\n\ngcc/\n\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_split_combinev16qi): New.\n\t(aarch64_expand_vec_perm): Likewise.\n\t(aarch64_expand_vec_perm_const): Likewise.\n\t* config/aarch64/aarch64-simd.md (vec_perm_const<mode>): New.\n\t(vec_perm<mode>): Likewise.\n\t(aarch64_tbl1<mode>): Likewise.\n\t(aarch64_tbl2v16qi): Likewise.\n\t(aarch64_combinev16qi): New.\n\t* config/aarch64/aarch64.c\n\t(aarch64_vectorize_vec_perm_const_ok): New.\n\t(aarch64_split_combinev16qi): Likewise.\n\t(MAX_VECT_LEN): Define.\n\t(expand_vec_perm_d): New.\n\t(aarch64_expand_vec_perm_1): Likewise.\n\t(aarch64_expand_vec_perm): Likewise.\n\t(aarch64_evpc_tbl): Likewise.\n\t(aarch64_expand_vec_perm_const_1): Likewise.\n\t(aarch64_expand_vec_perm_const): Likewise.\n\t(aarch64_vectorize_vec_perm_const_ok): Likewise.\n\t(TARGET_VECTORIZE_VEC_PERM_CONST_OK): Likewise.\n\t* config/aarch64/iterators.md\n\t(unspec): Add UNSPEC_TBL, UNSPEC_CONCAT.\n\t(V_cmp_result): Add mapping for V2DF.\n\ngcc/testsuite/\n\n\t* lib/target-supports.exp\n\t(check_effective_target_vect_perm): Allow aarch64*-*-*.\n\t(check_effective_target_vect_perm_byte): Likewise.\n\t(check_effective_target_vect_perm_short): Likewise.\n\t(check_effective_target_vect_char_mult): Likewise.\n\t(check_effective_target_vect_extract_even_odd): Likewise.\n\t(check_effective_target_vect_interleave): Likewise.\n\nFrom-SVN: r194218", "tree": {"sha": "abb79c1489d6b5680d991f3814660661ba7e9c1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abb79c1489d6b5680d991f3814660661ba7e9c1a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/88b080739aec46faddff05bb6f13fb2886c36aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b080739aec46faddff05bb6f13fb2886c36aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b080739aec46faddff05bb6f13fb2886c36aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b080739aec46faddff05bb6f13fb2886c36aff/comments", "author": {"login": "jgreenhalgh-arm", "id": 6104025, "node_id": "MDQ6VXNlcjYxMDQwMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6104025?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jgreenhalgh-arm", "html_url": "https://github.com/jgreenhalgh-arm", "followers_url": "https://api.github.com/users/jgreenhalgh-arm/followers", "following_url": "https://api.github.com/users/jgreenhalgh-arm/following{/other_user}", "gists_url": "https://api.github.com/users/jgreenhalgh-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jgreenhalgh-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jgreenhalgh-arm/subscriptions", "organizations_url": "https://api.github.com/users/jgreenhalgh-arm/orgs", "repos_url": "https://api.github.com/users/jgreenhalgh-arm/repos", "events_url": "https://api.github.com/users/jgreenhalgh-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/jgreenhalgh-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "246ff1aef6e70580ad567c59d63f122aa3c2924a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/246ff1aef6e70580ad567c59d63f122aa3c2924a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/246ff1aef6e70580ad567c59d63f122aa3c2924a"}], "stats": {"total": 426, "additions": 420, "deletions": 6}, "files": [{"sha": "370149cf86d22cffb76d049655f7f7d782fef708", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -1,3 +1,30 @@\n+2012-12-05  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_split_combinev16qi): New.\n+\t(aarch64_expand_vec_perm): Likewise.\n+\t(aarch64_expand_vec_perm_const): Likewise.\n+\t* config/aarch64/aarch64-simd.md (vec_perm_const<mode>): New.\n+\t(vec_perm<mode>): Likewise.\n+\t(aarch64_tbl1<mode>): Likewise.\n+\t(aarch64_tbl2v16qi): Likewise.\n+\t(aarch64_combinev16qi): New.\n+\t* config/aarch64/aarch64.c\n+\t(aarch64_vectorize_vec_perm_const_ok): New.\n+\t(aarch64_split_combinev16qi): Likewise.\n+\t(MAX_VECT_LEN): Define.\n+\t(expand_vec_perm_d): New.\n+\t(aarch64_expand_vec_perm_1): Likewise.\n+\t(aarch64_expand_vec_perm): Likewise.\n+\t(aarch64_evpc_tbl): Likewise.\n+\t(aarch64_expand_vec_perm_const_1): Likewise.\n+\t(aarch64_expand_vec_perm_const): Likewise.\n+\t(aarch64_vectorize_vec_perm_const_ok): Likewise.\n+\t(TARGET_VECTORIZE_VEC_PERM_CONST_OK): Likewise.\n+\t* config/aarch64/iterators.md\n+\t(unspec): Add UNSPEC_TBL, UNSPEC_CONCAT.\n+\t(V_cmp_result): Add mapping for V2DF.\n+\n 2012-12-05  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_simd_mangle_map_entry): New"}, {"sha": "bcd3bb1b8b7f5f939554c9cf80dd4106b36e7ce2", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -241,4 +241,9 @@ aarch64_builtin_vectorized_function (tree fndecl,\n \t\t\t\t     tree type_out,\n \t\t\t\t     tree type_in);\n \n+extern void aarch64_split_combinev16qi (rtx operands[3]);\n+extern void aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n+extern bool\n+aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n+\n #endif /* GCC_AARCH64_PROTOS_H */"}, {"sha": "baee0cc8c5992814cce9b8110fe7c2cbd4044668", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -3338,6 +3338,74 @@\n \n ;; Permuted-store expanders for neon intrinsics.\n \n+;; Permute instructions\n+\n+;; vec_perm support\n+\n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:VALL 0 \"register_operand\")\n+   (match_operand:VALL 1 \"register_operand\")\n+   (match_operand:VALL 2 \"register_operand\")\n+   (match_operand:<V_cmp_result> 3)]\n+  \"TARGET_SIMD\"\n+{\n+  if (aarch64_expand_vec_perm_const (operands[0], operands[1],\n+\t\t\t\t     operands[2], operands[3]))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"vec_perm<mode>\"\n+  [(match_operand:VB 0 \"register_operand\")\n+   (match_operand:VB 1 \"register_operand\")\n+   (match_operand:VB 2 \"register_operand\")\n+   (match_operand:VB 3 \"register_operand\")]\n+  \"TARGET_SIMD\"\n+{\n+  aarch64_expand_vec_perm (operands[0], operands[1],\n+\t\t\t   operands[2], operands[3]);\n+  DONE;\n+})\n+\n+(define_insn \"aarch64_tbl1<mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=w\")\n+\t(unspec:VB [(match_operand:V16QI 1 \"register_operand\" \"w\")\n+\t\t    (match_operand:VB 2 \"register_operand\" \"w\")]\n+\t\t   UNSPEC_TBL))]\n+  \"TARGET_SIMD\"\n+  \"tbl\\\\t%0.<Vtype>, {%1.16b}, %2.<Vtype>\"\n+  [(set_attr \"simd_type\" \"simd_tbl\")\n+   (set_attr \"simd_mode\" \"<MODE>\")]\n+)\n+\n+;; Two source registers.\n+\n+(define_insn \"aarch64_tbl2v16qi\"\n+  [(set (match_operand:V16QI 0 \"register_operand\" \"=w\")\n+\t(unspec:V16QI [(match_operand:OI 1 \"register_operand\" \"w\")\n+\t\t       (match_operand:V16QI 2 \"register_operand\" \"w\")]\n+\t\t      UNSPEC_TBL))]\n+  \"TARGET_SIMD\"\n+  \"tbl\\\\t%0.16b, {%S1.16b - %T1.16b}, %2.16b\"\n+  [(set_attr \"simd_type\" \"simd_tbl\")\n+   (set_attr \"simd_mode\" \"V16QI\")]\n+)\n+\n+(define_insn_and_split \"aarch64_combinev16qi\"\n+  [(set (match_operand:OI 0 \"register_operand\" \"=w\")\n+\t(unspec:OI [(match_operand:V16QI 1 \"register_operand\" \"w\")\n+\t\t    (match_operand:V16QI 2 \"register_operand\" \"w\")]\n+\t\t   UNSPEC_CONCAT))]\n+  \"TARGET_SIMD\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  aarch64_split_combinev16qi (operands);\n+  DONE;\n+})\n+\n (define_insn \"aarch64_st2<mode>_dreg\"\n   [(set (match_operand:TI 0 \"aarch64_simd_struct_operand\" \"=Utv\")\n \t(unspec:TI [(match_operand:OI 1 \"register_operand\" \"w\")"}, {"sha": "ae1a037cf7853c1a56d622ae04c875b93a53cde3", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 295, "deletions": 0, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -110,6 +110,9 @@ static unsigned bit_count (unsigned HOST_WIDE_INT);\n static bool aarch64_const_vec_all_same_int_p (rtx,\n \t\t\t\t\t      HOST_WIDE_INT, HOST_WIDE_INT);\n \n+static bool aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t\t\t const unsigned char *sel);\n+\n /* The processor for which instructions should be scheduled.  */\n enum aarch64_processor aarch64_tune = generic;\n \n@@ -6782,6 +6785,292 @@ aarch64_c_mode_for_suffix (char suffix)\n   return VOIDmode;\n }\n \n+/* Split operands into moves from op[1] + op[2] into op[0].  */\n+\n+void\n+aarch64_split_combinev16qi (rtx operands[3])\n+{\n+  unsigned int dest = REGNO (operands[0]);\n+  unsigned int src1 = REGNO (operands[1]);\n+  unsigned int src2 = REGNO (operands[2]);\n+  enum machine_mode halfmode = GET_MODE (operands[1]);\n+  unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n+  rtx destlo, desthi;\n+\n+  gcc_assert (halfmode == V16QImode);\n+\n+  if (src1 == dest && src2 == dest + halfregs)\n+    {\n+      /* No-op move.  Can't split to nothing; emit something.  */\n+      emit_note (NOTE_INSN_DELETED);\n+      return;\n+    }\n+\n+  /* Preserve register attributes for variable tracking.  */\n+  destlo = gen_rtx_REG_offset (operands[0], halfmode, dest, 0);\n+  desthi = gen_rtx_REG_offset (operands[0], halfmode, dest + halfregs,\n+\t\t\t       GET_MODE_SIZE (halfmode));\n+\n+  /* Special case of reversed high/low parts.  */\n+  if (reg_overlap_mentioned_p (operands[2], destlo)\n+      && reg_overlap_mentioned_p (operands[1], desthi))\n+    {\n+      emit_insn (gen_xorv16qi3 (operands[1], operands[1], operands[2]));\n+      emit_insn (gen_xorv16qi3 (operands[2], operands[1], operands[2]));\n+      emit_insn (gen_xorv16qi3 (operands[1], operands[1], operands[2]));\n+    }\n+  else if (!reg_overlap_mentioned_p (operands[2], destlo))\n+    {\n+      /* Try to avoid unnecessary moves if part of the result\n+\t is in the right place already.  */\n+      if (src1 != dest)\n+\temit_move_insn (destlo, operands[1]);\n+      if (src2 != dest + halfregs)\n+\temit_move_insn (desthi, operands[2]);\n+    }\n+  else\n+    {\n+      if (src2 != dest + halfregs)\n+\temit_move_insn (desthi, operands[2]);\n+      if (src1 != dest)\n+\temit_move_insn (destlo, operands[1]);\n+    }\n+}\n+\n+/* vec_perm support.  */\n+\n+#define MAX_VECT_LEN 16\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_vector_p;\n+  bool testing_p;\n+};\n+\n+/* Generate a variable permutation.  */\n+\n+static void\n+aarch64_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n+\n+  gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n+  gcc_checking_assert (GET_MODE (op0) == vmode);\n+  gcc_checking_assert (GET_MODE (op1) == vmode);\n+  gcc_checking_assert (GET_MODE (sel) == vmode);\n+  gcc_checking_assert (TARGET_SIMD);\n+\n+  if (one_vector_p)\n+    {\n+      if (vmode == V8QImode)\n+\t{\n+\t  /* Expand the argument to a V16QI mode by duplicating it.  */\n+\t  rtx pair = gen_reg_rtx (V16QImode);\n+\t  emit_insn (gen_aarch64_combinev8qi (pair, op0, op0));\n+\t  emit_insn (gen_aarch64_tbl1v8qi (target, pair, sel));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_aarch64_tbl1v16qi (target, op0, sel));\n+\t}\n+    }\n+  else\n+    {\n+      rtx pair;\n+\n+      if (vmode == V8QImode)\n+\t{\n+\t  pair = gen_reg_rtx (V16QImode);\n+\t  emit_insn (gen_aarch64_combinev8qi (pair, op0, op1));\n+\t  emit_insn (gen_aarch64_tbl1v8qi (target, pair, sel));\n+\t}\n+      else\n+\t{\n+\t  pair = gen_reg_rtx (OImode);\n+\t  emit_insn (gen_aarch64_combinev16qi (pair, op0, op1));\n+\t  emit_insn (gen_aarch64_tbl2v16qi (target, pair, sel));\n+\t}\n+    }\n+}\n+\n+void\n+aarch64_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n+  bool one_vector_p = rtx_equal_p (op0, op1);\n+  rtx rmask[MAX_VECT_LEN], mask;\n+\n+  gcc_checking_assert (!BYTES_BIG_ENDIAN);\n+\n+  /* The TBL instruction does not use a modulo index, so we must take care\n+     of that ourselves.  */\n+  mask = GEN_INT (one_vector_p ? nelt - 1 : 2 * nelt - 1);\n+  for (i = 0; i < nelt; ++i)\n+    rmask[i] = mask;\n+  mask = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rmask));\n+  sel = expand_simple_binop (vmode, AND, sel, mask, NULL, 0, OPTAB_LIB_WIDEN);\n+\n+  aarch64_expand_vec_perm_1 (target, op0, op1, sel);\n+}\n+\n+static bool\n+aarch64_evpc_tbl (struct expand_vec_perm_d *d)\n+{\n+  rtx rperm[MAX_VECT_LEN], sel;\n+  enum machine_mode vmode = d->vmode;\n+  unsigned int i, nelt = d->nelt;\n+\n+  /* TODO: ARM's TBL indexing is little-endian.  In order to handle GCC's\n+     numbering of elements for big-endian, we must reverse the order.  */\n+  if (BYTES_BIG_ENDIAN)\n+    return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* Generic code will try constant permutation twice.  Once with the\n+     original mode and again with the elements lowered to QImode.\n+     So wait and don't do the selector expansion ourselves.  */\n+  if (vmode != V8QImode && vmode != V16QImode)\n+    return false;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (d->perm[i]);\n+  sel = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n+  sel = force_reg (vmode, sel);\n+\n+  aarch64_expand_vec_perm_1 (d->target, d->op0, d->op1, sel);\n+  return true;\n+}\n+\n+static bool\n+aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n+{\n+  /* The pattern matching functions above are written to look for a small\n+     number to begin the sequence (0, 1, N/2).  If we begin with an index\n+     from the second operand, we can swap the operands.  */\n+  if (d->perm[0] >= d->nelt)\n+    {\n+      unsigned i, nelt = d->nelt;\n+      rtx x;\n+\n+      for (i = 0; i < nelt; ++i)\n+\td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n+\n+      x = d->op0;\n+      d->op0 = d->op1;\n+      d->op1 = x;\n+    }\n+\n+  if (TARGET_SIMD)\n+    return aarch64_evpc_tbl (d);\n+  return false;\n+}\n+\n+/* Expand a vec_perm_const pattern.  */\n+\n+bool\n+aarch64_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n+{\n+  struct expand_vec_perm_d d;\n+  int i, nelt, which;\n+\n+  d.target = target;\n+  d.op0 = op0;\n+  d.op1 = op1;\n+\n+  d.vmode = GET_MODE (target);\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      rtx e = XVECEXP (sel, 0, i);\n+      int ei = INTVAL (e) & (2 * nelt - 1);\n+      which |= (ei < nelt ? 1 : 2);\n+      d.perm[i] = ei;\n+    }\n+\n+  switch (which)\n+    {\n+    default:\n+      gcc_unreachable ();\n+\n+    case 3:\n+      d.one_vector_p = false;\n+      if (!rtx_equal_p (op0, op1))\n+\tbreak;\n+\n+      /* The elements of PERM do not suggest that only the first operand\n+\t is used, but both operands are identical.  Allow easier matching\n+\t of the permutation by folding the permutation into the single\n+\t input vector.  */\n+      /* Fall Through.  */\n+    case 2:\n+      for (i = 0; i < nelt; ++i)\n+\td.perm[i] &= nelt - 1;\n+      d.op0 = op1;\n+      d.one_vector_p = true;\n+      break;\n+\n+    case 1:\n+      d.op1 = op0;\n+      d.one_vector_p = true;\n+      break;\n+    }\n+\n+  return aarch64_expand_vec_perm_const_1 (&d);\n+}\n+\n+static bool\n+aarch64_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t     const unsigned char *sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt, which;\n+  bool ret;\n+\n+  d.vmode = vmode;\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+  memcpy (d.perm, sel, nelt);\n+\n+  /* Calculate whether all elements are in one vector.  */\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      unsigned char e = d.perm[i];\n+      gcc_assert (e < 2 * nelt);\n+      which |= (e < nelt ? 1 : 2);\n+    }\n+\n+  /* If all elements are from the second vector, reindex as if from the\n+     first vector.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to a single vector.  */\n+  d.one_vector_p = (which != 3);\n+\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!d.one_vector_p)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = aarch64_expand_vec_perm_const_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST aarch64_address_cost\n \n@@ -6985,6 +7274,12 @@ aarch64_c_mode_for_suffix (char suffix)\n #define TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE \\\n   aarch64_simd_vector_alignment_reachable\n \n+/* vec_perm support.  */\n+\n+#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n+  aarch64_vectorize_vec_perm_const_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-aarch64.h\""}, {"sha": "7cd4cef0eef84c2c3fa2a75de4158445dbdcd5d3", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -228,6 +228,8 @@\n     UNSPEC_FMAX\t\t; Used in aarch64-simd.md.\n     UNSPEC_FMIN\t\t; Used in aarch64-simd.md.\n     UNSPEC_BSL\t\t; Used in aarch64-simd.md.\n+    UNSPEC_TBL\t\t; Used in vector permute patterns.\n+    UNSPEC_CONCAT\t; Used in vector permute patterns.\n ])\n \n ;; -------------------------------------------------------------------\n@@ -415,8 +417,9 @@\n (define_mode_attr V_cmp_result [(V8QI \"V8QI\") (V16QI \"V16QI\")\n \t\t\t\t(V4HI \"V4HI\") (V8HI  \"V8HI\")\n \t\t\t\t(V2SI \"V2SI\") (V4SI  \"V4SI\")\n+\t\t\t\t(DI   \"DI\")   (V2DI  \"V2DI\")\n \t\t\t\t(V2SF \"V2SI\") (V4SF  \"V4SI\")\n-\t\t\t\t(DI   \"DI\")   (V2DI  \"V2DI\")])\n+\t\t\t\t(V2DF \"V2DI\")])\n \n ;; Vm for lane instructions is restricted to FP_LO_REGS.\n (define_mode_attr vwx [(V4HI \"x\") (V8HI \"x\") (HI \"x\")"}, {"sha": "b010c1103e904b6b5e817ee878c009934cdf5f14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -1,3 +1,13 @@\n+2012-12-05  James Greenhalgh  <james.greenhalgh@arm.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_vect_perm): Allow aarch64*-*-*.\n+\t(check_effective_target_vect_perm_byte): Likewise.\n+\t(check_effective_target_vect_perm_short): Likewise.\n+\t(check_effective_target_vect_char_mult): Likewise.\n+\t(check_effective_target_vect_extract_even_odd): Likewise.\n+\t(check_effective_target_vect_interleave): Likewise.\n+\n 2012-12-05  Yufeng Zhang  <yufeng.zhang@arm.com>\n \n \t* g++.dg/abi/mangle-neon-aarch64.C: New test."}, {"sha": "5e830b102775c1ecf932d6b6536c8023fa089294", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/88b080739aec46faddff05bb6f13fb2886c36aff/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=88b080739aec46faddff05bb6f13fb2886c36aff", "patch": "@@ -3014,6 +3014,7 @@ proc check_effective_target_vect_perm { } {\n     } else {\n         set et_vect_perm_saved 0\n         if { [is-effective-target arm_neon_ok]\n+\t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n@@ -3040,6 +3041,7 @@ proc check_effective_target_vect_perm_byte { } {\n     } else {\n         set et_vect_perm_byte_saved 0\n         if { [is-effective-target arm_neon_ok]\n+\t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_byte_saved 1\n@@ -3062,6 +3064,7 @@ proc check_effective_target_vect_perm_short { } {\n     } else {\n         set et_vect_perm_short_saved 0\n         if { [is-effective-target arm_neon_ok]\n+\t     || [istarget aarch64*-*-*]\n \t     || [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_short_saved 1\n@@ -3697,7 +3700,8 @@ proc check_effective_target_vect_char_mult { } {\n \tverbose \"check_effective_target_vect_char_mult: using cached result\" 2\n     } else {\n \tset et_vect_char_mult_saved 0\n-\tif { [istarget ia64-*-*]\n+\tif { [istarget aarch64*-*-*]\n+\t     || [istarget ia64-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*]\n             || [check_effective_target_arm32] } {\n@@ -3768,8 +3772,9 @@ proc check_effective_target_vect_extract_even_odd { } {\n         verbose \"check_effective_target_vect_extract_even_odd: using cached result\" 2\n     } else {\n         set et_vect_extract_even_odd_saved 0 \n-        if { [istarget powerpc*-*-*] \n-            || [is-effective-target arm_neon_ok]\n+\tif { [istarget aarch64*-*-*]\n+\t     || [istarget powerpc*-*-*]\n+\t     || [is-effective-target arm_neon_ok]\n              || [istarget i?86-*-*]\n              || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]\n@@ -3793,8 +3798,9 @@ proc check_effective_target_vect_interleave { } {\n         verbose \"check_effective_target_vect_interleave: using cached result\" 2\n     } else {\n         set et_vect_interleave_saved 0\n-        if { [istarget powerpc*-*-*]\n-            || [is-effective-target arm_neon_ok]\n+\tif { [istarget aarch64*-*-*]\n+\t     || [istarget powerpc*-*-*]\n+\t     || [is-effective-target arm_neon_ok]\n              || [istarget i?86-*-*]\n              || [istarget x86_64-*-*]\n              || [istarget ia64-*-*]"}]}