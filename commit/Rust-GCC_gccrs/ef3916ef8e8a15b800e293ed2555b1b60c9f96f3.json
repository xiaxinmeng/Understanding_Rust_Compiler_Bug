{"sha": "ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYzOTE2ZWY4ZThhMTViODAwZTI5M2VkMjU1NWIxYjYwYzlmOTZmMw==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:12:15Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2004-02-29T19:12:15Z"}, "message": "FileDescriptor.java: Implement on top of FileChannel.\n\n\n\t* java/io/FileDescriptor.java:  Implement on top of FileChannel.\n\tRemove native methods.\n\n\t* java/io/natFileDescriptorEcos.cc:  Remove file.\n\t* java/io/natFileDescriptorPosix.cc:  Remove file.\n\t* java/io/natFileDescriptorWin32.cc:  Remove file.\n\t* java/io/FileInputStream.java (ch):  Change type to FileChannelImpl.\n\t(<init>(File)):  Allocate a FileChannelImpl, not a FileDescriptor.\n\t(<init>(FileChannelImpl)):  New package-private constructor.\n\t(<init>(FileDescriptor)):  Extract FileChannelImpl from arg.\n\t(available, close, read, skip):  Implement using FileChannelImpl.\n\t(getFD):  Allocate FileDescriptor if needed.\n\t(getChannel):  Is now trivial.\n\t* java/io/FileOutputStream.java:  Corresponding changes.\n\t* java/io/RandomAccessFile.java:  Corresponding changes.\n\nFrom-SVN: r78661", "tree": {"sha": "dac2f13072b5f9eb856b86bd0a047fabdd09419a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dac2f13072b5f9eb856b86bd0a047fabdd09419a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/comments", "author": null, "committer": null, "parents": [{"sha": "d5fe0403cc53ebf2b9303d8cb78f305584d02910", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fe0403cc53ebf2b9303d8cb78f305584d02910", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fe0403cc53ebf2b9303d8cb78f305584d02910"}], "stats": {"total": 1290, "additions": 106, "deletions": 1184}, "files": [{"sha": "be86593e76d82f70c3eef45d282babc0a2bfb895", "filename": "libjava/java/io/FileDescriptor.java", "status": "modified", "additions": 31, "deletions": 122, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileDescriptor.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileDescriptor.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileDescriptor.java?ref=ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "patch": "@@ -39,7 +39,9 @@\n \n package java.io;\n \n-import gnu.classpath.Configuration;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import gnu.java.nio.channels.FileChannelImpl;\n \n /**\n  * This class represents an opaque file handle as a Java class.  It should\n@@ -57,82 +59,35 @@\n    * stream.  This will usually be accessed through the\n    * <code>System.in</code>variable.\n    */\n-  public static final FileDescriptor in = null;\n+  public static final FileDescriptor in\n+  = new FileDescriptor (FileChannelImpl.in);\n \n   /**\n    * A <code>FileDescriptor</code> representing the system standard output\n    * stream.  This will usually be accessed through the\n    * <code>System.out</code>variable.\n    */\n-  public static final FileDescriptor out = null;\n+  public static final FileDescriptor out\n+  = new FileDescriptor (FileChannelImpl.out);\n \n   /**\n    * A <code>FileDescriptor</code> representing the system standard error\n    * stream.  This will usually be accessed through the\n    * <code>System.err</code>variable.\n    */\n-  public static final FileDescriptor err = null;\n+  public static final FileDescriptor err\n+  = new FileDescriptor (FileChannelImpl.err);\n \n-  private static native void init();\n-\n-  static\n-    {\n-      if (Configuration.INIT_LOAD_LIBRARY)\n-        {\n-          System.loadLibrary(\"javaio\");\n-        }\n-\n-      init();\n-    }\n-\n-  // These are WHENCE values for seek.\n-  static final int SET = 0;\n-  static final int CUR = 1;\n-\n-  // These are mode values for open().\n-  static final int READ   = 1;\n-  static final int WRITE  = 2;\n-  static final int APPEND = 4;\n-\n-  // EXCL is used only when making a temp file.\n-  static final int EXCL   = 8;\n-  static final int SYNC   = 16;\n-  static final int DSYNC  = 32;\n-\n-  /**\n-   * This is the actual native file descriptor value\n-   */\n-  // System's notion of file descriptor.  It might seem redundant to\n-  // initialize this given that it is reassigned in the constructors.\n-  // However, this is necessary because if open() throws an exception\n-  // we want to make sure this has the value -1.  This is the most\n-  // efficient way to accomplish that.\n-  private int fd = -1;\n-\n-  private long position = 0;\n+  final ByteChannel channel;\n \n   /**\n    * This method is used to initialize an invalid FileDescriptor object.\n    */\n-  public FileDescriptor()\n-  {\n-  }\n-\n-  // Open a file.  MODE is a combination of the above mode flags.\n-  FileDescriptor (String path, int mode) throws FileNotFoundException\n+  FileDescriptor(ByteChannel channel)\n   {\n-    fd = open (path, mode);\n+    this.channel = channel;\n   }\n \n-  // Attach to an already-opened file.  This is not private because we\n-  // need access to it from other packages, for instance java.net.\n-  // Ordinarily that wouldn't work, either, but in our case we know\n-  // the access comes from C++, where \"package private\" is translated\n-  // into \"public\".  Eww.\n-  FileDescriptor (int desc)\n-  {\n-    fd = desc;\n-  }\n \n   /**\n    * This method forces all data that has not yet been physically written to\n@@ -143,7 +98,23 @@ public FileDescriptor()\n    * support this functionality or if an error occurs, then an exception\n    * will be thrown.\n    */\n-  public native void sync() throws SyncFailedException;\n+  public void sync () throws SyncFailedException\n+  {\n+    if (channel instanceof FileChannel)\n+      {\n+\ttry\n+\t  {\n+\t    ((FileChannel) channel).force(true); \n+\t  }\n+\tcatch (IOException ex)\n+\t  {\n+\t    if (ex instanceof SyncFailedException)\n+\t      throw (SyncFailedException) ex;\n+\t    else\n+\t      throw new SyncFailedException(ex.getMessage());\n+\t  }\n+      }\n+  }\n \n   /**\n    * This methods tests whether or not this object represents a valid open\n@@ -152,70 +123,8 @@ public FileDescriptor()\n    * @return <code>true</code> if this object represents a valid \n    * native file handle, <code>false</code> otherwise\n    */\n-  public native boolean valid();\n-\n-  /**\n-   * Opens the specified file in the specified mode.  This can be done\n-   * in one of the specified modes:\n-   * <ul>\n-   * <li>r - Read Only\n-   * <li>rw - Read / Write\n-   * <li>ra - Read / Write - append to end of file\n-   * <li>rws - Read / Write - synchronous writes of data/metadata\n-   * <li>rwd - Read / Write - synchronous writes of data.\n-   *\n-   * @param path Name of the file to open\n-   * @param mode Mode to open\n-   *\n-   * @exception IOException If an error occurs.\n-   */\n-  native int open(String path, int mode) throws FileNotFoundException;\n-\n-  /**\n-   * Close the file descriptor.\n-   */\n-  native void close() throws IOException;\n-\n-  /**\n-   * Write oe byte of data.\n-   */\n-  native void write(int b) throws IOException;\n-\n-  /**\n-   * Write data.\n-   */\n-  native void write(byte[] b, int offset, int len)\n-    throws IOException, NullPointerException, IndexOutOfBoundsException;\n-\n-  /**\n-   * Read one byte of data.\n-   */\n-  native int read() throws IOException;\n-\n-  /**\n-   * Read data.\n-   */\n-  native int read(byte[] bytes, int offset, int len) throws IOException;\n-  native int available() throws IOException;\n-\n-  // EOF_TRUNC is true if a request to seek past the end of file\n-  // should actually stop at the end of file.  If false, then a seek\n-  // past the end is ok (and if a subsequent write occurs the file\n-  // will grow).\n-  native int seek(long pos, int whence, boolean eof_trunc) throws IOException;\n-\n-  native long getFilePointer() throws IOException;\n-  native long getLength() throws IOException;\n-  native void setLength(long pos) throws IOException;\n-\n-  native void lock(long pos, int len, boolean shared) throws IOException;\n-  native boolean tryLock(long pos, int lent, boolean shared) throws IOException;\n-  native void unlock(long pos, int len) throws IOException;\n-\n-  // When collected, close.\n-  protected void finalize() throws Throwable\n+  public boolean valid ()\n   {\n-    if (valid())\n-      close();\n+    return channel.isOpen();\n   }\n }"}, {"sha": "57f6143f6be68f055420ab92a2f046566d0df3bb", "filename": "libjava/java/io/FileInputStream.java", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileInputStream.java?ref=ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "patch": "@@ -1,5 +1,5 @@\n /* FileInputStream.java -- An input stream that reads from disk files.\n-   Copyright (C) 1998, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,7 +39,7 @@\n package java.io;\n \n import java.nio.channels.FileChannel;\n-import java.nio.channels.FileChannelImpl;\n+import gnu.java.nio.channels.FileChannelImpl;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n@@ -60,7 +60,7 @@ public class FileInputStream extends InputStream\n    */\n   private FileDescriptor fd;\n \n-  private FileChannel ch;  /* cached associated file-channel */\n+  private FileChannelImpl ch;\n \n   /**\n    * This method initializes a <code>FileInputStream</code> to read from the\n@@ -107,7 +107,7 @@ public FileInputStream(File file) throws FileNotFoundException\n     if (file.isDirectory())\n       throw new FileNotFoundException(file.getPath() + \" is a directory\");\n \n-    fd = new FileDescriptor(file.getPath(), FileDescriptor.READ);\n+    ch = new FileChannelImpl (file.getPath(), FileChannelImpl.READ);\n   }\n \n   /**\n@@ -133,6 +133,12 @@ public FileInputStream(FileDescriptor fdObj)\n       s.checkRead(fdObj);\n \n     fd = fdObj;\n+    ch = (FileChannelImpl) fdObj.channel;\n+  }\n+\n+  FileInputStream(FileChannelImpl ch)\n+  {\n+    this.ch = ch;\n   }\n \n   /**\n@@ -156,7 +162,7 @@ public FileInputStream(FileDescriptor fdObj)\n    */\n   public int available() throws IOException\n   {\n-    return fd.available();\n+    return ch.available();\n   }\n \n   /**\n@@ -168,8 +174,7 @@ public int available() throws IOException\n    */\n   public void close() throws IOException\n   {\n-    if (fd.valid())\n-      fd.close();\n+    ch.close();\n   }\n \n   protected void finalize() throws IOException\n@@ -189,9 +194,12 @@ protected void finalize() throws IOException\n    */\n   public final FileDescriptor getFD() throws IOException\n   {\n-    if (!fd.valid())\n-      throw new IOException();\n-    return fd;\n+    synchronized (this)\n+      {\n+\tif (fd == null)\n+\t  fd = new FileDescriptor (ch);\n+\treturn fd;\n+      }\n   }\n \n   /**\n@@ -207,7 +215,7 @@ public final FileDescriptor getFD() throws IOException\n    */\n   public int read() throws IOException\n   {\n-    return fd.read();\n+    return ch.read();\n   }\n \n   /**\n@@ -258,7 +266,7 @@ public int read(byte[] buf, int offset, int len) throws IOException\n         || offset + len > buf.length)\n       throw new ArrayIndexOutOfBoundsException();\n \n-    return fd.read(buf, offset, len);\n+    return ch.read(buf, offset, len);\n   }\n \n   /**\n@@ -281,9 +289,9 @@ public synchronized long skip (long numBytes) throws IOException\n     if (numBytes == 0)\n       return 0;\n \n-    long curPos = fd.getFilePointer ();\n-    long newPos = fd.seek (numBytes, FileDescriptor.CUR, true);\n-    return newPos - curPos;\n+    long oldPos = ch.position ();\n+    ch.position(oldPos + numBytes);\n+    return ch.position() - oldPos;\n   }\n \n   /**\n@@ -294,9 +302,6 @@ public synchronized long skip (long numBytes) throws IOException\n    */\n   public synchronized FileChannel getChannel () \n   {\n-    if (ch == null)\n-      ch = new FileChannelImpl (fd, false, this);\n-    \n     return ch;\n   }\n "}, {"sha": "a8c4b765ed2393ca928b57611920f9f9d3e15ef5", "filename": "libjava/java/io/FileOutputStream.java", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FFileOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFileOutputStream.java?ref=ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "patch": "@@ -1,5 +1,5 @@\n /* FileOutputStream.java -- Writes to a file on disk.\n-   Copyright (C) 1998, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,7 +39,7 @@\n package java.io;\n \n import java.nio.channels.FileChannel;\n-import java.nio.channels.FileChannelImpl;\n+import gnu.java.nio.channels.FileChannelImpl;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n@@ -57,7 +57,7 @@ public class FileOutputStream extends OutputStream\n {\n   private FileDescriptor fd;\n \n-  private FileChannel ch; /* cached associated file-channel */\n+  private FileChannelImpl ch;\n \n   /**\n    * This method initializes a <code>FileOutputStream</code> object to write\n@@ -84,10 +84,10 @@ public FileOutputStream (String path, boolean append)\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkWrite(path);\n-    fd = new FileDescriptor (path, (append\n-\t\t\t\t    ? FileDescriptor.WRITE\n-\t\t\t\t      | FileDescriptor.APPEND\n-\t\t\t\t    : FileDescriptor.WRITE));\n+    ch = new FileChannelImpl (path, (append\n+\t\t\t\t     ? FileChannelImpl.WRITE\n+\t\t\t\t     | FileChannelImpl.APPEND\n+\t\t\t\t     : FileChannelImpl.WRITE));\n   }\n \n   /**\n@@ -188,6 +188,12 @@ public FileOutputStream (FileDescriptor fdObj)\n       s.checkWrite(fdObj);\n \n     fd = fdObj;\n+    ch = (FileChannelImpl) fdObj.channel;\n+  }\n+\n+  FileOutputStream(FileChannelImpl ch)\n+  {\n+    this.ch = ch;\n   }\n \n   protected void finalize () throws IOException\n@@ -206,9 +212,12 @@ protected void finalize () throws IOException\n    */\n   public final FileDescriptor getFD () throws IOException\n   {\n-    if (! fd.valid())\n-      throw new IOException ();\n-    return fd;\n+    synchronized (this)\n+      {\n+\tif (fd == null)\n+\t  fd = new FileDescriptor (ch);\n+\treturn fd;\n+      }\n   }\n \n   /**\n@@ -220,7 +229,7 @@ public final FileDescriptor getFD () throws IOException\n    */\n   public void write (int b) throws IOException\n   {\n-    fd.write (b);\n+    ch.write (b);\n   }\n \n   /**\n@@ -255,7 +264,7 @@ public void write (byte[] buf, int offset, int len)\n         || offset + len > buf.length)\n       throw new ArrayIndexOutOfBoundsException ();\n     \n-    fd.write (buf, offset, len);\n+    ch.write (buf, offset, len);\n   }\n \n   /**\n@@ -267,8 +276,7 @@ public void write (byte[] buf, int offset, int len)\n    */\n   public void close () throws IOException\n   {\n-    if (fd.valid())\n-      fd.close();\n+    ch.close();\n   }\n \n   /**\n@@ -279,9 +287,6 @@ public void close () throws IOException\n    */\n   public synchronized FileChannel getChannel() \n   {\n-    if (ch == null)\n-      ch = new FileChannelImpl (fd, true, this);\n-\n     return ch;\n   }\n "}, {"sha": "f79c624755c24b4152b2a338836107cbd2e95de0", "filename": "libjava/java/io/RandomAccessFile.java", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef3916ef8e8a15b800e293ed2555b1b60c9f96f3/libjava%2Fjava%2Fio%2FRandomAccessFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FRandomAccessFile.java?ref=ef3916ef8e8a15b800e293ed2555b1b60c9f96f3", "patch": "@@ -1,5 +1,5 @@\n /* RandomAccessFile.java -- Class supporting random file I/O\n-   Copyright (C) 1998, 1999, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -39,7 +39,7 @@\n package java.io;\n \n import java.nio.channels.FileChannel;\n-import java.nio.channels.FileChannelImpl;\n+import gnu.java.nio.channels.FileChannelImpl;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n@@ -61,12 +61,12 @@ public class RandomAccessFile implements DataOutput, DataInput\n {\n \n   // The underlying file.\n+  private FileChannelImpl ch;\n   private FileDescriptor fd;\n   // The corresponding input and output streams.\n   private DataOutputStream out;\n   private DataInputStream in;\n   \n-  private FileChannel ch; /* cached associated file-channel */\n   \n   /**\n    * This method initializes a new instance of <code>RandomAccessFile</code>\n@@ -119,18 +119,18 @@ public RandomAccessFile (String fileName, String mode)\n   {\n     int fdmode;\n     if (mode.equals(\"r\"))\n-      fdmode = FileDescriptor.READ;\n+      fdmode = FileChannelImpl.READ;\n     else if (mode.equals(\"rw\"))\n-      fdmode = FileDescriptor.READ | FileDescriptor.WRITE;\n+      fdmode = FileChannelImpl.READ | FileChannelImpl.WRITE;\n     else if (mode.equals(\"rws\"))\n       {\n-\tfdmode = (FileDescriptor.READ | FileDescriptor.WRITE\n-\t\t  | FileDescriptor.SYNC);\n+\tfdmode = (FileChannelImpl.READ | FileChannelImpl.WRITE\n+\t\t  | FileChannelImpl.SYNC);\n       }\n     else if (mode.equals(\"rwd\"))\n       {\n-\tfdmode = (FileDescriptor.READ | FileDescriptor.WRITE\n-\t\t  | FileDescriptor.DSYNC);\n+\tfdmode = (FileChannelImpl.READ | FileChannelImpl.WRITE\n+\t\t  | FileChannelImpl.DSYNC);\n       }\n     else\n       throw new IllegalArgumentException (\"invalid mode: \" + mode);\n@@ -141,11 +141,12 @@ else if (mode.equals(\"rwd\"))\n       {\n         s.checkRead(fileName);\n \n-        if ((fdmode & FileDescriptor.WRITE) != 0)\n+        if ((fdmode & FileChannelImpl.WRITE) != 0)\n           s.checkWrite(fileName);\n       }\n \n-    fd = new FileDescriptor (fileName, fdmode);\n+    ch = new FileChannelImpl (fileName, fdmode);\n+    fd = new FileDescriptor(ch);\n     out = new DataOutputStream (new FileOutputStream (fd));\n     in = new DataInputStream (new FileInputStream (fd));\n   }\n@@ -158,8 +159,7 @@ else if (mode.equals(\"rwd\"))\n    */\n   public void close () throws IOException\n   {\n-    if (fd.valid())\n-      fd.close();\n+    ch.close();\n   }\n \n   /**\n@@ -172,10 +172,12 @@ public void close () throws IOException\n    */\n   public final FileDescriptor getFD () throws IOException\n   {\n-    if (! fd.valid())\n-      throw new IOException ();\n-\n-    return fd;\n+    synchronized (this)\n+      {\n+\tif (fd == null)\n+\t  fd = new FileDescriptor (ch);\n+\treturn fd;\n+      }\n   }\n \n   /**\n@@ -188,7 +190,7 @@ public final FileDescriptor getFD () throws IOException\n    */\n   public long getFilePointer () throws IOException\n   {\n-    return fd.getFilePointer();\n+    return ch.position();\n   }\n \n   /**\n@@ -206,7 +208,7 @@ public long getFilePointer () throws IOException\n    */\n   public void setLength (long newLen) throws IOException\n   {\n-    fd.setLength (newLen);\n+    ch.truncate (newLen);\n   }\n \n   /**\n@@ -218,7 +220,7 @@ public void setLength (long newLen) throws IOException\n    */\n   public long length () throws IOException\n   {\n-    return fd.getLength ();\n+    return ch.size();\n   }\n \n   /**\n@@ -702,7 +704,7 @@ public final String readUTF () throws IOException\n    */\n   public void seek (long pos) throws IOException\n   {\n-    fd.seek (pos, FileDescriptor.SET, false);\n+    ch.position(pos);\n   }\n \n   /**\n@@ -726,10 +728,13 @@ public int skipBytes (int numBytes) throws IOException\n     if (numBytes == 0)\n       return 0;\n     \n-    long curPos = fd.getFilePointer ();\n-    long newPos = fd.seek (numBytes, FileDescriptor.CUR, true);\n-    \n-    return (int) (newPos - curPos);\n+    long oldPos = ch.position();\n+    long newPos = oldPos + numBytes;\n+    long size = ch.size();\n+    if (newPos > size)\n+      newPos = size;\n+    ch.position(newPos);\n+    return (int) (ch.position() - oldPos);\n   }\n \n   /**\n@@ -962,9 +967,6 @@ public final void writeUTF (String s) throws IOException\n    */\n   public final synchronized FileChannel getChannel ()\n   {\n-    if (ch == null)\n-      ch = new FileChannelImpl (fd, true, this);\n-\n     return ch;\n   }\n "}, {"sha": "66713079a8600d1ea577e27b72764815feb88e52", "filename": "libjava/java/io/natFileDescriptorEcos.cc", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorEcos.cc?ref=d5fe0403cc53ebf2b9303d8cb78f305584d02910", "patch": "@@ -1,159 +0,0 @@\n-// natFileDescriptor.cc - Native part of FileDescriptor class.\n-\n-/* Copyright (C) 1998, 1999, 2001, 2002  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include <errno.h>\n-#include <string.h>\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <sys/param.h>\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/io/FileDescriptor.h>\n-#include <java/io/SyncFailedException.h>\n-#include <java/io/IOException.h>\n-#include <java/io/EOFException.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-#include <java/lang/NullPointerException.h>\n-#include <java/lang/String.h>\n-#include <java/io/FileNotFoundException.h>\n-\n-extern \"C\" void diag_write_char (char c);\n-\n-static void \n-diag_write (char *data, int len)\n-{\n-  while (len > 0)\n-    {\n-      diag_write_char (*data++);\n-      len--;\n-    }\n-}\n-\n-#define NO_FSYNC_MESSAGE \"sync unsupported\"\n-\n-void\n-java::io::FileDescriptor::init(void)\n-{\n-  in = new java::io::FileDescriptor(0);\n-  out = new java::io::FileDescriptor(1);\n-  err = new java::io::FileDescriptor(2);\n-}\n-\n-jboolean\n-java::io::FileDescriptor::valid (void)\n-{\n-  return true;\n-}\n-\n-void\n-java::io::FileDescriptor::sync (void)\n-{\n-  // Some files don't support fsync.  We don't bother reporting these\n-  // as errors.\n-#ifdef HAVE_FSYNC\n-#else\n-  throw new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE));\n-#endif\n-}\n-\n-jint\n-java::io::FileDescriptor::open (jstring path, jint jflags)\n-{\n-  return fd;\n-}\n-\n-void\n-java::io::FileDescriptor::write (jint b)\n-{\n-  char d = (char) b;\n-  ::diag_write (&d, 1);\n-}\n-\n-void\n-java::io::FileDescriptor::write (jbyteArray b, jint offset, jint len)\n-{\n-  if (! b)\n-    throw new java::lang::NullPointerException;\n-  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-  char *bytes = (char *)elements (b) + offset;\n-  ::diag_write (bytes, len);\n-}\n-\n-void\n-java::io::FileDescriptor::close (void)\n-{\n-}\n-\n-void\n-java::io::FileDescriptor::setLength (long)\n-{\n-}\n-\n-jint\n-java::io::FileDescriptor::seek (jlong pos, jint whence, jboolean)\n-{\n-  JvAssert (whence == SET || whence == CUR);\n-  return 0;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getLength (void)\n-{\n-  return 0;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getFilePointer (void)\n-{\n-  return 0;\n-}\n-\n-jint\n-java::io::FileDescriptor::read (void)\n-{\n-  return 0;\n-}\n-\n-jint\n-java::io::FileDescriptor::read (jbyteArray buffer, jint offset, jint count)\n-{\n-  return 0;\n-}\n-\n-jint\n-java::io::FileDescriptor::available (void)\n-{\n-  return 0;\n-}\n-\n-void\n-java::io::FileDescriptor::lock (jlong pos, jint len, jboolean shared)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.lock() not implemented\"));\n-}\n-\n-jboolean\n-java::io::FileDescriptor::tryLock (jlong pos, jint len, jboolean shared)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.tryLock() not implemented\"));\n-}\n-\n-void\n-java::io::FileDescriptor::unlock (jlong pos, jint len)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.unlock() not implemented\"));\n-}"}, {"sha": "7c36669d27f0902c804758e4d94bc442c9cffc0b", "filename": "libjava/java/io/natFileDescriptorPosix.cc", "status": "removed", "additions": 0, "deletions": 467, "changes": 467, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorPosix.cc?ref=d5fe0403cc53ebf2b9303d8cb78f305584d02910", "patch": "@@ -1,467 +0,0 @@\n-// natFileDescriptor.cc - Native part of FileDescriptor class.\n-\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software Foundation\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-#include <config.h>\n-\n-#include \"posix.h\"\n-\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <sys/stat.h>\n-#include <sys/param.h>\n-\n-#ifdef HAVE_SYS_IOCTL_H\n-#define BSD_COMP /* Get FIONREAD on Solaris2. */\n-#include <sys/ioctl.h>\n-#endif\n-\n-// Pick up FIONREAD on Solaris 2.5.\n-#ifdef HAVE_SYS_FILIO_H\n-#include <sys/filio.h>\n-#endif\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n-#include <java/io/FileDescriptor.h>\n-#include <java/io/SyncFailedException.h>\n-#include <java/io/IOException.h>\n-#include <java/io/InterruptedIOException.h>\n-#include <java/io/EOFException.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-#include <java/lang/NullPointerException.h>\n-#include <java/lang/System.h>\n-#include <java/lang/String.h>\n-#include <java/lang/Thread.h>\n-#include <java/io/FileNotFoundException.h>\n-\n-#define NO_FSYNC_MESSAGE \"sync unsupported\"\n-\n-void\n-java::io::FileDescriptor::init (void)\n-{\n-  in = new java::io::FileDescriptor(0);\n-  out = new java::io::FileDescriptor(1);\n-  err = new java::io::FileDescriptor(2);\n-}\n-\n-jboolean\n-java::io::FileDescriptor::valid (void)\n-{\n-  struct stat sb;\n-  return fd >= 0 && ::fstat (fd, &sb) == 0;\n-}\n-\n-void\n-java::io::FileDescriptor::sync (void)\n-{\n-  // Some files don't support fsync.  We don't bother reporting these\n-  // as errors.\n-#ifdef HAVE_FSYNC\n-  if (::fsync (fd) && errno != EROFS && errno != EINVAL)\n-    throw new SyncFailedException (JvNewStringLatin1 (strerror (errno)));\n-#else\n-  throw new SyncFailedException (JvNewStringLatin1 (NO_FSYNC_MESSAGE));\n-#endif\n-}\n-\n-jint\n-java::io::FileDescriptor::open (jstring path, jint jflags)\n-{\n-  char *buf = (char *) _Jv_AllocBytes (_Jv_GetStringUTFLength (path) + 1);\n-  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n-  buf[total] = '\\0';\n-  int flags = 0;\n-#ifdef O_BINARY\n-  flags |= O_BINARY;\n-#endif\n-\n-  JvAssert ((jflags & READ) || (jflags & WRITE));\n-  int mode = 0666;\n-  if ((jflags & READ) && (jflags & WRITE))\n-    flags |= O_RDWR | O_CREAT;\n-  else if ((jflags & READ))\n-    flags |= O_RDONLY;\n-  else\n-    {\n-      flags |= O_WRONLY | O_CREAT;\n-      if ((jflags & APPEND))\n-\tflags |= O_APPEND;\n-      else\n-\tflags |= O_TRUNC;\n-\n-      if ((jflags & EXCL))\n-\t{\n-\t  flags |= O_EXCL;\n-\t  // In this case we are making a temp file.\n-\t  mode = 0600;\n-\t}\n-    }\n-\n-  if ((jflags & SYNC))\n-    flags |= O_SYNC;\n-\n-  if ((jflags & DSYNC))\n-    flags |= O_DSYNC;\n-\n-  int fd = ::open (buf, flags, mode);\n-  if (fd == -1 && errno == EMFILE)\n-    {\n-      // Because finalize () calls close () we might be able to continue.\n-      java::lang::System::gc ();\n-      java::lang::System::runFinalization ();\n-      fd = ::open (buf, flags, mode);\n-    }\n-  if (fd == -1)\n-    {\n-      char msg[MAXPATHLEN + 200];\n-      // We choose the formatting here for JDK compatibility, believe\n-      // it or not.\n-      sprintf (msg, \"%s (%s)\", buf, strerror (errno));\n-      throw new FileNotFoundException (JvNewStringLatin1 (msg));\n-    }\n-\n-  _Jv_platform_close_on_exec (fd);\n-\n-  return fd;\n-}\n-\n-void\n-java::io::FileDescriptor::write (jint b)\n-{\n-  jbyte d = (jbyte) b;\n-  int r = 0;\n-  while (r != 1)\n-    {\n-      r = ::write (fd, &d, 1);\n-      if (r == -1)\n-        {\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      InterruptedIOException *iioe\n-\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n-\t      throw iioe;\n-\t    }\t    \n-\t  if (errno != EINTR)\n-\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\t}\n-    }\n-  position++;\n-}\n-\n-void\n-java::io::FileDescriptor::write (jbyteArray b, jint offset, jint len)\n-{\n-  if (! b)\n-    throw new java::lang::NullPointerException;\n-  if (offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-  jbyte *bytes = elements (b) + offset;\n-\n-  int written = 0;\n-  while (len > 0)\n-    {\n-      int r = ::write (fd, bytes, len);\n-      if (r == -1)\n-        {\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      InterruptedIOException *iioe\n-\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = written;\n-\t      throw iioe;\n-\t    }\n-\t  if (errno != EINTR)\n-\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\t}\n-\n-      written += r;\n-      len -= r;\n-      bytes += r;\n-      position += r;\n-    }\n-}\n-\n-void\n-java::io::FileDescriptor::close (void)\n-{\n-  jint save = fd;\n-  fd = -1;\n-  if (::close (save))\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-}\n-\n-void\n-java::io::FileDescriptor::setLength (jlong pos)\n-{\n-  struct stat sb;\n-\n-#ifdef HAVE_FTRUNCATE\n-  if (::fstat (fd, &sb))\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\n-  if ((jlong) sb.st_size == pos) \n-    return;\n-\n-  // If the file is too short, we extend it.  We can't rely on\n-  // ftruncate() extending the file.  So we lseek() to 1 byte less\n-  // than we want, and then we write a single byte at the end.\n-  if ((jlong) sb.st_size < pos)\n-    {\n-      if (::lseek (fd, (off_t) (pos - 1), SEEK_SET) == -1)\n-\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n-      char out = '\\0';\n-      int r = ::write (fd, &out, 1);\n-      if (r <= 0 || ::lseek (fd, position, SEEK_SET) == -1)\n-\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n-    }\n-  else\n-    {\n-      if (::ftruncate (fd, (off_t) pos))\n-\tthrow new IOException (JvNewStringLatin1 (strerror (errno)));\n-      position = pos;\n-    }\n-#else /* HAVE_FTRUNCATE */\n-  throw new IOException (JvNewStringLatin1 (\"FileDescriptor.setLength not implemented\"));\n-#endif /* HAVE_FTRUNCATE */\n-}\n-\n-jint\n-java::io::FileDescriptor::seek (jlong pos, jint whence, jboolean eof_trunc)\n-{\n-  JvAssert (whence == SET || whence == CUR);\n-\n-  if (eof_trunc)\n-    {\n-      jlong len = getLength ();\n-      if (whence == SET)\n-\t{\n-\t  if (pos > len)\n-\t    pos = len;\n-\t}\n-      else\n-\t{\n-\t  jlong here = getFilePointer ();\n-\t  if (here + pos > len)\n-\t    {\n-\t      pos = len;\n-\t      whence = SET;\n-\t    }\n-\t}\n-    }\n-\n-  off_t r = ::lseek (fd, (off_t) pos, whence == SET ? SEEK_SET : SEEK_CUR);\n-  if (r == -1)\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-  position = r;\n-  return r;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getLength (void)\n-{\n-  struct stat sb;\n-  if (::fstat (fd, &sb))\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-  return sb.st_size;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getFilePointer (void)\n-{\n-  return position;\n-}\n-\n-jint\n-java::io::FileDescriptor::read (void)\n-{\n-  jbyte b;\n-  int r;\n-  do\n-    {\n-      r = ::read (fd, &b, 1);\n-      if (r == 0)\n-\treturn -1;\n-      if (r == -1)\n-\t{\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      InterruptedIOException *iioe\n-\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n-\t      throw iioe;\n-\t    }\n-\t  if (errno != EINTR)\n-\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\t}\n-    }\n-  while (r != 1);\n-  position++;\n-  return b & 0xFF;\n-}\n-\n-jint\n-java::io::FileDescriptor::read (jbyteArray buffer, jint offset, jint count)\n-{\n-  if (! buffer)\n-    throw new java::lang::NullPointerException;\n-  jsize bsize = JvGetArrayLength (buffer);\n-  if (offset < 0 || count < 0 || offset + count > bsize)\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-\n-  // Must return 0 if an attempt is made to read 0 bytes.\n-  if (count == 0)\n-    return 0;\n-\n-  jbyte *bytes = elements (buffer) + offset;\n-  int r;\n-  do\n-    {\n-      r = ::read (fd, bytes, count);\n-      if (r == 0)\n-\treturn -1;\n-      if (r == -1)\n-\t{\n-\t  if (java::lang::Thread::interrupted())\n-\t    {\n-\t      InterruptedIOException *iioe\n-\t\t= new InterruptedIOException (JvNewStringLatin1 (strerror (errno)));\n-\t      iioe->bytesTransferred = r == -1 ? 0 : r;\n-\t      throw iioe;\n-\t    }\n-\t  if (errno != EINTR)\n-\t    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\t}\n-    }\n-  while (r <= 0);\n-  position += r;\n-  return r;\n-}\n-\n-jint\n-java::io::FileDescriptor::available (void)\n-{\n-#if defined (FIONREAD) || defined (HAVE_SELECT) || defined (HAVE_FSTAT)\n-  long num = 0;\n-  int r = 0;\n-  bool num_set = false;\n-\n-#if defined (FIONREAD)\n-  r = ::ioctl (fd, FIONREAD, &num);\n-  if (r == -1 && errno == ENOTTY)\n-    {\n-      // If the ioctl doesn't work, we don't care.\n-      r = 0;\n-      num = 0;\n-    }\n-  else\n-    num_set = true;\n-#elif defined (HAVE_SELECT)\n-  if (fd < 0)\n-    {\n-      errno = EBADF;\n-      r = -1;\n-    }\n-#endif\n-\n-  if (r == -1)\n-    {\n-    posix_error:\n-      throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-    }\n-\n-  // If we didn't get anything, and we have fstat, then see if see if\n-  // we're reading a regular file.  On many systems, FIONREAD does not\n-  // work on regular files; select() likewise returns a useless\n-  // result.  This is run incorrectly when FIONREAD does work on\n-  // regular files and we are at the end of the file.  However, this\n-  // case probably isn't very important.\n-#if defined (HAVE_FSTAT)\n-  if (! num_set)\n-    {\n-      struct stat sb;\n-      off_t where = 0;\n-      if (fstat (fd, &sb) != -1\n-\t  && S_ISREG (sb.st_mode)\n-\t  && (where = lseek (fd, 0, SEEK_CUR)) != (off_t) -1)\n-\t{\n-\t  num = (long) (sb.st_size - where);\n-\t  num_set = true;\n-\t}\n-    }\n-#endif /* HAVE_FSTAT */\n-\n-#if defined (HAVE_SELECT)\n-  if (! num_set)\n-    {\n-      fd_set rd;\n-      FD_ZERO (&rd);\n-      FD_SET (fd, &rd);\n-      struct timeval tv;\n-      tv.tv_sec = 0;\n-      tv.tv_usec = 0;\n-      r = _Jv_select (fd + 1, &rd, NULL, NULL, &tv);\n-      if (r == -1)\n-\tgoto posix_error;\n-      num = r == 0 ? 0 : 1;\n-    }\n-#endif /* HAVE_SELECT */\n-\n-  return (jint) num;\n-#else\n-  return 0;\n-#endif\n-}\n-\n-void\n-java::io::FileDescriptor::lock (jlong pos, jint len, jboolean shared)\n-{\n-  struct flock lockdata;\n-\n-  lockdata.l_type = shared ? F_WRLCK : F_RDLCK;\n-  lockdata.l_whence = SEEK_SET;\n-  lockdata.l_start = pos;\n-  lockdata.l_len = len;\n-\n-  if (::fcntl (fd, F_SETLK, &lockdata) == -1)\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-}\n-\n-jboolean\n-java::io::FileDescriptor::tryLock (jlong pos, jint len, jboolean shared)\n-{\n-  struct flock lockdata;\n-\n-  lockdata.l_type = shared ? F_WRLCK : F_RDLCK;\n-  lockdata.l_whence = SEEK_SET;\n-  lockdata.l_start = pos;\n-  lockdata.l_len = len;\n-\n-  if (::fcntl (fd, F_GETLK, &lockdata) == -1)\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-\n-  return lockdata.l_type == F_UNLCK;\n-}\n-\n-void\n-java::io::FileDescriptor::unlock (jlong pos, jint len)\n-{\n-  struct flock lockdata;\n-\n-  lockdata.l_type = F_UNLCK;\n-  lockdata.l_whence = SEEK_SET;\n-  lockdata.l_start = pos;\n-  lockdata.l_len = len;\n-\n-  if (::fcntl (fd, F_SETLK, &lockdata) == -1)\n-    throw new IOException (JvNewStringLatin1 (strerror (errno)));\n-}"}, {"sha": "fd9d9755e69fb00b3d6702a160531e3471055f83", "filename": "libjava/java/io/natFileDescriptorWin32.cc", "status": "removed", "additions": 0, "deletions": 373, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5fe0403cc53ebf2b9303d8cb78f305584d02910/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc?ref=d5fe0403cc53ebf2b9303d8cb78f305584d02910", "patch": "@@ -1,373 +0,0 @@\n-// natFileDescriptorWin32.cc - Native part of FileDescriptor class.\n-\n-/* Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003  Free Software \n-   Foundation, Inc.\n-\n-   This file is part of libgcj.\n-\n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n-\n-// FIXME: In order to support interrupting of IO operations, we\n-// need to change to use the windows asynchronous IO functions\n-\n-#include <config.h>\n-#include <platform.h>\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#undef STRICT\n-\n-#include <java/io/FileDescriptor.h>\n-#include <java/io/SyncFailedException.h>\n-#include <java/io/IOException.h>\n-#include <java/io/InterruptedIOException.h>\n-#include <java/io/EOFException.h>\n-#include <java/lang/ArrayIndexOutOfBoundsException.h>\n-#include <java/lang/NullPointerException.h>\n-#include <java/lang/String.h>\n-#include <java/lang/Thread.h>\n-#include <java/io/FileNotFoundException.h>\n-\n-static bool testCanUseGetHandleInfo()\n-{\n-  /* Test to see whether GetHandleInformation can be used\n-     for console input or screen buffers. This is better\n-     a kludgy OS version check. */\n-  DWORD dwFlags;\n-  return GetHandleInformation (GetStdHandle (STD_INPUT_HANDLE),\n-    &dwFlags) != 0;\n-}\n-\n-// FIXME: casting a FILE (pointer) to a jint will not work on Win64 --\n-//        we should be using gnu.gcj.RawData's.\n-\n-void\n-java::io::FileDescriptor::init(void)\n-{\n-  in = new java::io::FileDescriptor((jint)(GetStdHandle (STD_INPUT_HANDLE)));\n-  out = new java::io::FileDescriptor((jint)(GetStdHandle (STD_OUTPUT_HANDLE)));\n-  err = new java::io::FileDescriptor((jint)(GetStdHandle (STD_ERROR_HANDLE)));\n-}\n-\n-jboolean\n-java::io::FileDescriptor::valid (void) {\n-  static bool bCanUseGetHandleInfo = testCanUseGetHandleInfo();\n-  if (bCanUseGetHandleInfo)\n-  {\n-    /* As with UNIX, a \"file\" descriptor can be one of\n-       a gazillion possible underlying things like a pipe\n-       or socket, so we can't get too fancy here. */\n-    DWORD dwFlags;\n-    HANDLE h = (HANDLE) fd;\n-    return GetHandleInformation (h, &dwFlags) != 0;\n-  }\n-  else\n-  {\n-    /* Can't use GetHandleInformation() for console handles on < WinNT 5. */\n-    return true;\n-  }\n-}\n-\n-void\n-java::io::FileDescriptor::sync (void) {\n-  if (! FlushFileBuffers ((HANDLE)fd))\n-  {\n-    DWORD dwErrorCode = GetLastError ();\n-    throw new SyncFailedException (_Jv_WinStrError (dwErrorCode));\n-  }\n-}\n-\n-jint\n-java::io::FileDescriptor::open (jstring path, jint jflags) {\n-\n-  HANDLE handle = NULL;\n-  DWORD access = 0;\n-  DWORD create = OPEN_EXISTING;\n-  \n-  JV_TEMP_STRING_WIN32(cpath, path)\n-\n-  JvAssert((jflags & READ) || (jflags & WRITE));\n-\n-  if ((jflags & READ) && (jflags & WRITE))\n-    {\n-      access = GENERIC_READ | GENERIC_WRITE;\n-      if (jflags & EXCL)\n-        create = CREATE_NEW; // this will raise error if file exists.\n-      else\n-        create = OPEN_ALWAYS; // equivalent to O_CREAT\n-    }\n-  else if (jflags & READ)\n-    {\n-      access = GENERIC_READ;\n-      create = OPEN_EXISTING; // ignore EXCL\n-    }\n-  else\n-    { \n-      access = GENERIC_WRITE;\n-      if (jflags & EXCL)\n-        create = CREATE_NEW;\n-      else if (jflags & APPEND)\n-        create = OPEN_ALWAYS;\n-      else\n-        create = CREATE_ALWAYS;\n-    }\n-\n-  handle = CreateFile(cpath, access, FILE_SHARE_READ | FILE_SHARE_WRITE,\n-    NULL, create, 0, NULL);\n-\n-  if (handle == INVALID_HANDLE_VALUE)\n-    {\n-       DWORD dwErrorCode = GetLastError ();\n-       throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n-    }\n-\n-  // For APPEND mode, move the file pointer to the end of the file.\n-  if (jflags & APPEND)\n-    {\n-      DWORD low = SetFilePointer (handle, 0, NULL, FILE_END);\n-      if ((low == 0xffffffff) && (GetLastError () != NO_ERROR)) \n-      {\n-        DWORD dwErrorCode = GetLastError ();\n-        throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n-      }\n-    }\n-    \n-  // Make this handle non-inheritable so that child\n-  // processes don't inadvertently prevent us from\n-  // closing this file.\n-  _Jv_platform_close_on_exec (handle);\n-\n-  return (jint) handle;\n-}\n-\n-void\n-java::io::FileDescriptor::write (jint b)\n-{\n-  DWORD bytesWritten;\n-  jbyte buf = (jbyte)b;\n-\n-  if (WriteFile ((HANDLE)fd, &buf, 1, &bytesWritten, NULL))\n-    {\n-      if (java::lang::Thread::interrupted())\n-        {\n-          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n-          iioe->bytesTransferred = bytesWritten;\n-    throw iioe;\n-        }\n-      if (bytesWritten != 1)\n-        _Jv_ThrowIOException ();\n-    }\n-  else\n-    _Jv_ThrowIOException ();\n-  // FIXME: loop until bytesWritten == 1\n-}\n-\n-void\n-java::io::FileDescriptor::write(jbyteArray b, jint offset, jint len)\n-{\n-  if (! b)\n-    throw new java::lang::NullPointerException;\n-  if(offset < 0 || len < 0 || offset + len > JvGetArrayLength (b))\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-\n-  jbyte *buf = elements (b) + offset;\n-  DWORD bytesWritten;\n-\n-  if (WriteFile ((HANDLE)fd, buf, len, &bytesWritten, NULL))\n-    {\n-      if (java::lang::Thread::interrupted())\n-        {\n-          InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n-          iioe->bytesTransferred = bytesWritten;\n-          throw iioe;\n-        }\n-    }\n-  else\n-    _Jv_ThrowIOException ();\n-  // FIXME: loop until bytesWritten == len\n-}\n-\n-void\n-java::io::FileDescriptor::close (void)\n-{\n-  HANDLE save = (HANDLE)fd;\n-  fd = (jint)INVALID_HANDLE_VALUE;\n-  if (! CloseHandle (save))\n-    _Jv_ThrowIOException ();\n-}\n-\n-void\n-java::io::FileDescriptor::setLength(jlong pos)\n-{\n-  LONG liOrigFilePointer;\n-  LONG liNewFilePointer;\n-  LONG liEndFilePointer;\n-\n-  // Get the original file pointer.\n-  if (SetFilePointer((HANDLE) fd, (LONG) 0, &liOrigFilePointer,\n-         FILE_CURRENT) != (BOOL) 0\n-      && (GetLastError() != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-\n-  // Get the length of the file.\n-  if (SetFilePointer((HANDLE) fd, (LONG) 0, &liEndFilePointer,\n-         FILE_END) != (BOOL) 0\n-      && (GetLastError() != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-\n-  if ((jlong)liEndFilePointer == pos)\n-    {\n-      // Restore the file pointer.\n-      if (liOrigFilePointer != liEndFilePointer)\n-  {\n-    if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n-           FILE_BEGIN) != (BOOL) 0\n-        && (GetLastError() != NO_ERROR))\n-      _Jv_ThrowIOException ();\n-  }\n-      return;\n-    }\n-\n-  // Seek to the new end of file.\n-  if (SetFilePointer((HANDLE) fd, (LONG) pos, &liNewFilePointer,\n-         FILE_BEGIN) != (BOOL) 0\n-      && (GetLastError() != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-\n-  // Truncate the file at this point.\n-  if (SetEndOfFile((HANDLE) fd) != (BOOL) 0 && (GetLastError() != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-\n-  if (liOrigFilePointer < liNewFilePointer)\n-    {\n-      // Restore the file pointer.\n-      if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n-        FILE_BEGIN) != (BOOL) 0\n-        && (GetLastError() != NO_ERROR))\n-        _Jv_ThrowIOException ();\n-    }\n-}\n-\n-jint\n-java::io::FileDescriptor::seek (jlong pos, jint whence, jboolean eof_trunc)\n-{\n-  JvAssert (whence == SET || whence == CUR);\n-\n-  jlong len = getLength();\n-  jlong here = getFilePointer();\n-\n-  if (eof_trunc\n-      && ((whence == SET && pos > len) || (whence == CUR && here + pos > len)))\n-    {\n-      whence = SET;\n-      pos = len;\n-    }\n-\n-  LONG high = pos >> 32;\n-  DWORD low = SetFilePointer ((HANDLE)fd, (DWORD)(0xffffffff & pos), &high, whence == SET ? FILE_BEGIN : FILE_CURRENT);\n-  if ((low == 0xffffffff) && (GetLastError () != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-  return low;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getFilePointer(void)\n-{\n-  LONG high = 0;\n-  DWORD low = SetFilePointer ((HANDLE)fd, 0, &high, FILE_CURRENT);\n-  if ((low == 0xffffffff) && (GetLastError() != NO_ERROR))\n-    _Jv_ThrowIOException ();\n-  return (((jlong)high) << 32L) | (jlong)low;\n-}\n-\n-jlong\n-java::io::FileDescriptor::getLength(void)\n-{\n-  DWORD high;\n-  DWORD low;\n-\n-  low = GetFileSize ((HANDLE)fd, &high);\n-  // FIXME: Error checking\n-  return (((jlong)high) << 32L) | (jlong)low;\n-}\n-\n-jint\n-java::io::FileDescriptor::read(void)\n-{\n-  CHAR buf;\n-  DWORD read;\n-\n-  if (! ReadFile ((HANDLE)fd, &buf, 1, &read, NULL))\n-    {\n-      if (GetLastError () == ERROR_BROKEN_PIPE)\n-        return -1;\n-      else\n-        _Jv_ThrowIOException ();\n-    }\n-\n-  if (! read)\n-    return -1;\n-  else\n-    return (jint)(buf & 0xff);\n-}\n-\n-jint\n-java::io::FileDescriptor::read(jbyteArray buffer, jint offset, jint count)\n-{\n-  if (! buffer)\n-    throw new java::lang::NullPointerException;\n-\n-  jsize bsize = JvGetArrayLength (buffer);\n-  if (offset < 0 || count < 0 || offset + count > bsize)\n-    throw new java::lang::ArrayIndexOutOfBoundsException;\n-\n-  // Must return 0 if an attempt is made to read 0 bytes.\n-  if (count == 0)\n-    return 0;\n-\n-  jbyte *bytes = elements (buffer) + offset;\n-\n-  DWORD read;\n-  if (! ReadFile((HANDLE)fd, bytes, count, &read, NULL))\n-    {\n-      if (GetLastError () == ERROR_BROKEN_PIPE)\n-        return -1;\n-      else\n-        _Jv_ThrowIOException ();\n-    }\n-\n-  if (read == 0) return -1;\n-\n-  return (jint)read;\n-}\n-\n-jint\n-java::io::FileDescriptor::available(void)\n-{\n-  // FIXME:\n-  return getLength() - getFilePointer();\n-}\n-\n-void\n-java::io::FileDescriptor::lock (jlong pos, jint len, jboolean shared)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.lock() not implemented\"));\n-}\n-\n-jboolean\n-java::io::FileDescriptor::tryLock (jlong pos, jint len, jboolean shared)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.tryLock() not implemented\"));\n-}\n-\n-void\n-java::io::FileDescriptor::unlock (jlong pos, jint len)\n-{\n-  throw new IOException (JvNewStringLatin1\n-    (\"java.io.FileDescriptor.unlock() not implemented\"));\n-}"}]}