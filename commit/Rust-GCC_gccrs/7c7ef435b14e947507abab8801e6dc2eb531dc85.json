{"sha": "7c7ef435b14e947507abab8801e6dc2eb531dc85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2M3ZWY0MzViMTRlOTQ3NTA3YWJhYjg4MDFlNmRjMmViNTMxZGM4NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-01-11T15:44:34Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-01-11T15:44:34Z"}, "message": "i386.c (ix86_attr_length_default): Handle TYPE_STR and TYPE_CLD.\n\n\t* i386.c (ix86_attr_length_default): Handle TYPE_STR and TYPE_CLD.\n\t* i386.md (FIRST_PSEUDO_REGISTER): Set to 20.\n\t(FIXED_REGISTERS): Set dirflag as fixed.\n\t(CALL_USED_REGISTERS): Set dirflag as used.\n\t(REG_ALLOC_ORDER): Set dirflag as last one.\n\t(DIRFLAG_REG): New macro.\n\t(MD_ASM_CLOBBERS): Asm clobber dirflag for backward compatibility.\n\t(HI_REGISTER_NAMES): Add dirflag.\n\t(DEBUF_PRINT_REG): Handle dirflag.\n\t* i386.md (type attribute): New cld and str types.\n\t(length_opcode attribute): Set cld and str to 1.\n\t(memory attribute): Set str to unknown - it is not clear from the\n\tpatterns.\n\t(pent_np function unit): Prefixed string operations takes 12 cycles\n\tminimally; cld takes 2 cycles.\n\t(ppro_uops attribute): Str is \"many\" and cld is \"few\".\n\t(ppro_p0 unit): Handle cld here.\n\t(k6_alux unit): Handle cld and str types.\n\t(k6_load unit): It is ocupied by str opcodes.\n\t(k6_store unit): It is ocupied by str opcodes.\n\t(athlon_decode): Str is vector decoded.\n\t(athlon_ieu): Handle str and cld.\n\t(cld pattern): New.\n\t(movstrsi, clrstr, cmpstr, strlen expander): Emit cld instruction\n\t(movstrsi_1, clrstrsi_1, cmpstrsi_1, strlensi_1,\n\tcmpstrsi_nz_1 insn): Do not output cld instruction\n\nFrom-SVN: r31326", "tree": {"sha": "0c27101c36aedb9f44f8d169515ece811b136363", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c27101c36aedb9f44f8d169515ece811b136363"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c7ef435b14e947507abab8801e6dc2eb531dc85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c7ef435b14e947507abab8801e6dc2eb531dc85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c7ef435b14e947507abab8801e6dc2eb531dc85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c7ef435b14e947507abab8801e6dc2eb531dc85/comments", "author": null, "committer": null, "parents": [{"sha": "a500c31b2e3b80e6553a5362a1bbf9ebb4d6b40c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a500c31b2e3b80e6553a5362a1bbf9ebb4d6b40c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a500c31b2e3b80e6553a5362a1bbf9ebb4d6b40c"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "feb6f070ae83191fe46e347b5e78482be98da296", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c7ef435b14e947507abab8801e6dc2eb531dc85", "patch": "@@ -1,3 +1,32 @@\n+Tue Jan 11 16:26:47 MET 2000  Jan Hubicka <jh@suse.cz>\n+\n+\t* i386.c (ix86_attr_length_default): Handle TYPE_STR and TYPE_CLD.\n+\t* i386.md (FIRST_PSEUDO_REGISTER): Set to 20.\n+\t(FIXED_REGISTERS): Set dirflag as fixed.\n+\t(CALL_USED_REGISTERS): Set dirflag as used.\n+\t(REG_ALLOC_ORDER): Set dirflag as last one.\n+\t(DIRFLAG_REG): New macro.\n+\t(MD_ASM_CLOBBERS): Asm clobber dirflag for backward compatibility.\n+\t(HI_REGISTER_NAMES): Add dirflag.\n+\t(DEBUF_PRINT_REG): Handle dirflag.\n+\t* i386.md (type attribute): New cld and str types.\n+\t(length_opcode attribute): Set cld and str to 1.\n+\t(memory attribute): Set str to unknown - it is not clear from the\n+\tpatterns.\n+\t(pent_np function unit): Prefixed string operations takes 12 cycles\n+\tminimally; cld takes 2 cycles.\n+\t(ppro_uops attribute): Str is \"many\" and cld is \"few\".\n+\t(ppro_p0 unit): Handle cld here.\n+\t(k6_alux unit): Handle cld and str types.\n+\t(k6_load unit): It is ocupied by str opcodes.\n+\t(k6_store unit): It is ocupied by str opcodes.\n+\t(athlon_decode): Str is vector decoded.\n+\t(athlon_ieu): Handle str and cld.\n+\t(cld pattern): New.\n+\t(movstrsi, clrstr, cmpstr, strlen expander): Emit cld instruction\n+\t(movstrsi_1, clrstrsi_1, cmpstrsi_1, strlensi_1,\n+\tcmpstrsi_nz_1 insn): Do not output cld instruction\n+\n Tue Jan 11 06:14:39 2000  David Starner <dstarner98@aasaa.ofe.org>\n \n \t* gcc.texi (G++ and GCC): Add Java and Chill."}, {"sha": "d35bafb3ecf480c5ae462f1654c376e7b007cc98", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7c7ef435b14e947507abab8801e6dc2eb531dc85", "patch": "@@ -5452,6 +5452,9 @@ ix86_attr_length_default (insn)\n     case TYPE_FCMOV:\n     case TYPE_IBR:\n       break;\n+    case TYPE_STR:\n+    case TYPE_CLD:\n+      len = 0;\n \n     case TYPE_ALU1:\n     case TYPE_NEGNOT:"}, {"sha": "ed7f849ad42ee1e45132a742580f4d3a6641ba1a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=7c7ef435b14e947507abab8801e6dc2eb531dc85", "patch": "@@ -610,7 +610,7 @@ extern int ix86_arch;\n    eliminated during reloading in favor of either the stack or frame\n    pointer. */\n \n-#define FIRST_PSEUDO_REGISTER 19\n+#define FIRST_PSEUDO_REGISTER 20\n \n /* Number of hardware registers that go into the DWARF-2 unwind info.\n    If not defined, equals FIRST_PSEUDO_REGISTER.  */\n@@ -621,8 +621,8 @@ extern int ix86_arch;\n    and are not available for the register allocator.\n    On the 80386, the stack pointer is such, as is the arg pointer. */\n #define FIXED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr*/ \\\n-{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n+{  0, 0, 0, 0, 0, 0, 0, 1, 0,  0,  0,  0,  0,  0,  0,  0,  1,    0,   0,   0 }\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -632,8 +632,8 @@ extern int ix86_arch;\n    Aside from that, you can include as many other registers as you like.  */\n \n #define CALL_USED_REGISTERS \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr*/ \\\n-{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,flags,fpsr, dir*/ \\\n+{  1, 1, 1, 0, 0, 0, 0, 1, 1,  1,  1,  1,  1,  1,  1,  1,  1,    1,   1,   1 }\n \n /* Order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.  List frame pointer\n@@ -655,8 +655,8 @@ extern int ix86_arch;\n    generated by allocating edx first, so restore the 'natural' order of things. */\n \n #define REG_ALLOC_ORDER \\\n-/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,cc,fpsr*/ \\\n-{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18 }\n+/*ax,dx,cx,bx,si,di,bp,sp,st,st1,st2,st3,st4,st5,st6,st7,arg,cc,fpsr, dir*/ \\\n+{  0, 1, 2, 3, 4, 5, 6, 7, 8,  9, 10, 11, 12, 13, 14, 15, 16,17,  18,  19 }\n \n /* A C statement (sans semicolon) to choose the order in which to\n    allocate hard registers for pseudo-registers local to a basic\n@@ -764,6 +764,7 @@ extern int ix86_arch;\n \n #define FLAGS_REG 17\n #define FPSR_REG 18\n+#define DIRFLAG_REG 19\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n@@ -1067,6 +1068,7 @@ enum reg_class\n   do {\t\t\t\t\t\t\t\t\t      \\\n     (CLOBBERS) = tree_cons (NULL_TREE, build_string (5, \"flags\"), (CLOBBERS));\\\n     (CLOBBERS) = tree_cons (NULL_TREE, build_string (4, \"fpsr\"), (CLOBBERS)); \\\n+    (CLOBBERS) = tree_cons (NULL_TREE, build_string (7, \"dirflag\"), (CLOBBERS)); \\\n   } while (0)\n \f\n /* Stack layout; function entry, exit and calling.  */\n@@ -2169,7 +2171,7 @@ while (0)\n #define HI_REGISTER_NAMES\t\t\t\t\t\t\\\n {\"ax\",\"dx\",\"cx\",\"bx\",\"si\",\"di\",\"bp\",\"sp\",\t\t\t\t\\\n  \"st\",\"st(1)\",\"st(2)\",\"st(3)\",\"st(4)\",\"st(5)\",\"st(6)\",\"st(7)\",\"\",\t\\\n- \"flags\",\"fpsr\" }\n+ \"flags\",\"fpsr\", \"dirflag\" }\n \n #define REGISTER_NAMES HI_REGISTER_NAMES\n \n@@ -2382,6 +2384,8 @@ do { long l;\t\t\t\t\t\t\\\n        fprintf (FILE, \"%d \", REGNO (X));\t\t\\\n        if (REGNO (X) == FLAGS_REG)\t\t\t\\\n \t { fputs (\"flags\", FILE); break; }\t\t\\\n+       if (REGNO (X) == DIRFLAG_REG)\t\t\t\\\n+\t { fputs (\"dirflag\", FILE); break; }\t\t\\\n        if (REGNO (X) == FPSR_REG)\t\t\t\\\n \t { fputs (\"fpsr\", FILE); break; }\t\t\\\n        if (REGNO (X) == ARG_POINTER_REGNUM)\t\t\\"}, {"sha": "6fd7c8eb32b4192dcb8aaf5f394c866beeb0316f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 61, "deletions": 15, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c7ef435b14e947507abab8801e6dc2eb531dc85/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=7c7ef435b14e947507abab8801e6dc2eb531dc85", "patch": "@@ -83,7 +83,7 @@\n ;; A basic instruction type.  Refinements due to arguments to be\n ;; provided in other attributes.\n (define_attr \"type\"\n-  \"other,multi,alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch\"\n+  \"other,multi,alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,fmov,fop,fop1,fsgn,fmul,fdiv,fpspc,fcmov,fcmp,fxch,str,cld\"\n   (const_string \"other\"))\n \n ;; The (bounding maximum) length of an instruction in bytes.\n@@ -105,6 +105,8 @@\n (define_attr \"length_opcode\" \"\"\n   (cond [(eq_attr \"type\" \"imovx,setcc,icmov\")\n \t   (const_int 3)\n+\t (eq_attr \"type\" \"str,cld\")\n+\t   (const_int 1)\n          (and (eq_attr \"type\" \"incdec\")\n \t      (ior (match_operand:SI 1 \"register_operand\" \"\")\n \t\t   (match_operand:HI 1 \"register_operand\" \"\")))\n@@ -127,9 +129,9 @@\n ;; if the instruction is complex.\n \n (define_attr \"memory\" \"none,load,store,both,unknown\"\n-  (cond [(eq_attr \"type\" \"other,multi\")\n+  (cond [(eq_attr \"type\" \"other,multi,str\")\n \t   (const_string \"unknown\")\n-\t (eq_attr \"type\" \"lea,fcmov,fpspc\")\n+\t (eq_attr \"type\" \"lea,fcmov,fpspc,cld\")\n \t   (const_string \"none\")\n \t (eq_attr \"type\" \"push\")\n \t   (if_then_else (match_operand 1 \"memory_operand\" \"\")\n@@ -260,6 +262,12 @@\n        (eq_attr \"type\" \"imul\"))\n   11 11)\n \n+;; Rep movs takes minimally 12 cycles.\n+(define_function_unit \"pent_np\" 1 0\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"str\"))\n+  12 12)\n+\n ; ??? IDIV for SI takes 46 cycles, for HI 30, for QI 22\n (define_function_unit \"pent_np\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n@@ -304,6 +312,11 @@\n \t         (eq_attr \"memory\" \"store\"))))\n   2 2)\n \n+(define_function_unit \"pent_np\" 1 0\n+  (and (eq_attr \"cpu\" \"pentium\")\n+       (eq_attr \"type\" \"cld\"))\n+  2 2)\n+\n (define_function_unit \"fpu\" 1 0\n   (and (eq_attr \"cpu\" \"pentium\")\n        (and (eq_attr \"type\" \"fmov\")\n@@ -469,9 +482,9 @@\n ;;\t     cycles to decode in decoder 0.\n \n (define_attr \"ppro_uops\" \"one,few,many\"\n-  (cond [(eq_attr \"type\" \"other,multi,call,callv,fpspc\")\n+  (cond [(eq_attr \"type\" \"other,multi,call,callv,fpspc,str\")\n \t   (const_string \"many\")\n-\t (eq_attr \"type\" \"icmov,fcmov\")\n+\t (eq_attr \"type\" \"icmov,fcmov,str,cld\")\n \t   (const_string \"few\")\n \t (eq_attr \"type\" \"imov\")\n \t   (if_then_else (eq_attr \"memory\" \"store,both\")\n@@ -496,7 +509,7 @@\n \n (define_function_unit \"ppro_p0\" 1 0\n   (and (eq_attr \"cpu\" \"pentiumpro\")\n-       (eq_attr \"type\" \"ishift,lea,ibr\"))\n+       (eq_attr \"type\" \"ishift,lea,ibr,cld\"))\n   1 1)\n \n (define_function_unit \"ppro_p0\" 1 0\n@@ -611,7 +624,7 @@\n ;; Shift instructions and certain arithmetic are issued only to X pipe.\n (define_function_unit \"k6_alux\" 1 0\n   (and (eq_attr \"cpu\" \"k6\")\n-       (eq_attr \"type\" \"ishift,alu1,negnot\"))\n+       (eq_attr \"type\" \"ishift,alu1,negnot,cld\"))\n   1 1)\n \n ;; The QI mode arithmetic is issued to X pipe only.\n@@ -644,12 +657,23 @@\n \t    (eq_attr \"memory\" \"load,both\")))\n   1 1)\n \n+(define_function_unit \"k6_load\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (and (eq_attr \"type\" \"str\")\n+\t    (eq_attr \"memory\" \"load,both\")))\n+  10 10)\n+\n ;; Lea have two instructions, so latency is probably 2\n (define_function_unit \"k6_store\" 1 0\n   (and (eq_attr \"cpu\" \"k6\")\n        (eq_attr \"type\" \"lea\"))\n   2 1)\n \n+(define_function_unit \"k6_store\" 1 0\n+  (and (eq_attr \"cpu\" \"k6\")\n+       (eq_attr \"type\" \"str\"))\n+  10 10)\n+\n (define_function_unit \"k6_store\" 1 0\n   (and (eq_attr \"cpu\" \"k6\")\n        (ior (eq_attr \"type\" \"push\")\n@@ -713,7 +737,7 @@\n ;; communicates with all the execution units seperately instead.\n \n (define_attr \"athlon_decode\" \"direct,vector\"\n-  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc\")\n+  (cond [(eq_attr \"type\" \"call,imul,idiv,other,multi,fcmov,fpspc,str\")\n \t   (const_string \"vector\")\n          (and (eq_attr \"type\" \"push\")\n               (match_operand 1 \"memory_operand\" \"\"))\n@@ -741,9 +765,14 @@\n \n (define_function_unit \"athlon_ieu\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n-       (eq_attr \"type\" \"alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov\"))\n+       (eq_attr \"type\" \"alu1,negnot,alu,icmp,imov,imovx,lea,incdec,ishift,imul,idiv,ibr,setcc,push,pop,call,callv,icmov,str,cld\"))\n   1 1)\n \n+(define_function_unit \"athlon_ieu\" 3 0\n+  (and (eq_attr \"cpu\" \"athlon\")\n+       (eq_attr \"type\" \"str\"))\n+  15 15)\n+\n (define_function_unit \"athlon_ieu\" 3 0\n   (and (eq_attr \"cpu\" \"athlon\")\n        (eq_attr \"type\" \"imul\"))\n@@ -7789,11 +7818,18 @@\n \f\n ;; Block operation instructions\n \n+(define_insn \"cld\"\n+ [(set (reg:SI 19) (const_int 0))]\n+ \"\"\n+ \"cld\"\n+  [(set_attr \"type\" \"cld\")])\n+\n (define_expand \"movstrsi\"\n   [(parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (match_operand:BLK 1 \"memory_operand\" \"\"))\n \t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n \t      (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+\t      (use (reg:SI 19))\n \t      (clobber (match_scratch:SI 4 \"\"))\n \t      (clobber (match_dup 5))\n \t      (clobber (match_dup 6))])]\n@@ -7813,6 +7849,7 @@\n \n   operands[0] = change_address (operands[0], VOIDmode, addr0);\n   operands[1] = change_address (operands[1], VOIDmode, addr1);\n+  emit_insn (gen_cld ());\n }\")\n \n ;; It might seem that operands 0 & 1 could use predicate register_operand.\n@@ -7824,6 +7861,7 @@\n \t(mem:BLK (match_operand:SI 1 \"address_operand\" \"S\")))\n    (use (match_operand:SI 2 \"const_int_operand\" \"n\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (use (reg:SI 19))\n    (clobber (match_scratch:SI 4 \"=&c\"))\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))]\n@@ -7832,7 +7870,6 @@\n {\n   rtx xops[2];\n \n-  output_asm_insn (\\\"cld\\\", operands);\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       if (INTVAL (operands[2]) & ~0x03)\n@@ -7855,12 +7892,14 @@\n   [(set_attr \"type\" \"multi\")])\n \n (define_expand \"clrstrsi\"\n-  [(set (match_dup 3) (const_int 0))\n+  [(set (reg:SI 19) (const_int 0))\n+   (set (match_dup 3) (const_int 0))\n    (parallel [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n \t\t   (const_int 0))\n \t      (use (match_operand:SI 1 \"const_int_operand\" \"\"))\n \t      (use (match_operand:SI 2 \"const_int_operand\" \"\"))\n \t      (use (match_dup 3))\n+\t      (use (reg:SI 19))\n \t      (clobber (match_scratch:SI 4 \"\"))\n \t      (clobber (match_dup 5))])]\n   \"\"\n@@ -7877,6 +7916,8 @@\n   operands[5] = addr0;\n \n   operands[0] = gen_rtx_MEM (BLKmode, addr0);\n+\n+  emit_insn (gen_cld ());\n }\")\n \n ;; It might seem that operand 0 could use predicate register_operand.\n@@ -7889,14 +7930,14 @@\n    (use (match_operand:SI 1 \"const_int_operand\" \"n\"))\n    (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n    (use (match_operand:SI 3 \"register_operand\" \"a\"))\n+   (use (reg:SI 19))\n    (clobber (match_scratch:SI 4 \"=&c\"))\n    (clobber (match_dup 0))]\n   \"\"\n   \"*\n {\n   rtx xops[2];\n \n-  output_asm_insn (\\\"cld\\\", operands);\n   if (GET_CODE (operands[1]) == CONST_INT)\n     {\n       unsigned int count = INTVAL (operands[1]) & 0xffffffff;\n@@ -7958,6 +7999,7 @@\n      once cc0 is dead.  */\n   align = operands[4];\n \n+  emit_insn (gen_cld ());\n   if (GET_CODE (count) == CONST_INT)\n     {\n       if (INTVAL (count) == 0)\n@@ -8008,11 +8050,12 @@\n \t\t    (mem:BLK (match_operand:SI 1 \"address_operand\" \"D\"))))\n    (use (match_operand:SI 2 \"register_operand\" \"c\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (use (reg:SI 19))\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n    (clobber (match_dup 2))]\n   \"\"\n-  \"cld\\;repz{\\;| }cmpsb\"\n+  \"repz{\\;| }cmpsb\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"3\")])\n \n@@ -8026,12 +8069,13 @@\n \t\t      (mem:BLK (match_operand:SI 1 \"address_operand\" \"D\")))\n \t  (const_int 0)))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n+   (use (reg:SI 19))\n    (clobber (match_dup 0))\n    (clobber (match_dup 1))\n    (clobber (match_dup 2))]\n   \"\"\n   ;; The initial compare sets the zero flag.\n-  \"cmp{l}\\\\t%2, %2\\;cld\\;repz{\\;| }cmpsb\"\n+  \"cmp{l}\\\\t%2, %2\\;repz{\\;| }cmpsb\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \n@@ -8079,6 +8123,7 @@\n \n       emit_move_insn (scratch3, addr);\n \n+      emit_insn (gen_cld ());\n       emit_insn (gen_strlensi_1 (scratch1, scratch3, eoschar,\n \t\t\t\t align, constm1_rtx));\n       emit_insn (gen_one_cmplsi2 (scratch2, scratch1));\n@@ -8097,10 +8142,11 @@\n \t\t    (match_operand:QI 2 \"general_operand\" \"a\")\n \t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")\n \t\t    (match_operand:SI 4 \"immediate_operand\" \"0\")] 0))\n+   (use (reg:SI 19))\n    (clobber (match_dup 1))\n    (clobber (reg:CC 17))]\n   \"\"\n-  \"cld\\;repnz{\\;| }scasb\"\n+  \"repnz{\\;| }scasb\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"3\")])\n \f"}]}