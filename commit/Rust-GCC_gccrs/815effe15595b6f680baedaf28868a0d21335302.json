{"sha": "815effe15595b6f680baedaf28868a0d21335302", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE1ZWZmZTE1NTk1YjZmNjgwYmFlZGFmMjg4NjhhMGQyMTMzNTMwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-08-03T19:54:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-08-03T19:54:18Z"}, "message": "lto-cgraph.c (compute_ltrans_boundary): Add abstract origins into boundaries.\n\n\n\t* lto-cgraph.c (compute_ltrans_boundary): Add abstract origins into\n\tboundaries.\n\t* lto-streamer-out.c (tree_is_indexable): Results decls and\n\tparm decls are not indexable.\n\t(DFS_write_tree_body): Do not follow args and results.\n\t(hash_tree): Likewise.\n\t(output_functions): Rearrange so struct function is needed\n\tonly when real body is output; be able to also ouptut abstract\n\tfunctions; output DECL_ARGUMENTS and DECL_RESULT.\n\t(lto_output): When not in WPA, ale store abstract functions.\n\t(write_symbol): Do not care about RESULT_DECL.\n\t(output_symbol_p): Handle correctly sbtract decls.\n\t* lto-streamer-in.c (input_function): Rearrange so struct\n\tfunction can be NULL at entry; allow streaming of\n\tfunctions w/o body; store DECL_ARGUMENTS and DECL_RESULT.\n\t* ipa.c (symtab_remove_unreachable_nodes): Silence confused\n\tsanity check during LTO.\n\t* tree-streamer-out.c (write_ts_decl_non_common_tree_pointers): Skip\n\tRESULT_DECl and DECL_ARGUMENTS.\n\t* tree-streamer-in.c (lto_input_ts_decl_non_common_tree_pointers):\n\tLikewise.\n\n\t* lto.c (lto_materialize_function): Do not push struct function.\n\t* lto-partition.c (get_symbol_class): Handle abstracts correctly.\n\t(may_need_named_section_p): Even abstract origins may need\n\tnamed section.\n\nFrom-SVN: r201468", "tree": {"sha": "03ce7f28fa403515aaa2237e480f2c85c5013a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03ce7f28fa403515aaa2237e480f2c85c5013a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/815effe15595b6f680baedaf28868a0d21335302", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815effe15595b6f680baedaf28868a0d21335302", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815effe15595b6f680baedaf28868a0d21335302", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815effe15595b6f680baedaf28868a0d21335302/comments", "author": null, "committer": null, "parents": [{"sha": "07838b1363318105e615be10b016099c557927d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07838b1363318105e615be10b016099c557927d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07838b1363318105e615be10b016099c557927d9"}], "stats": {"total": 205, "additions": 124, "deletions": 81}, "files": [{"sha": "dbac14039bef0224115fb7e7b3f1091e6393c746", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -1,3 +1,27 @@\n+2013-08-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-cgraph.c (compute_ltrans_boundary): Add abstract origins into\n+\tboundaries.\n+\t* lto-streamer-out.c (tree_is_indexable): Results decls and\n+\tparm decls are not indexable.\n+\t(DFS_write_tree_body): Do not follow args and results.\n+\t(hash_tree): Likewise.\n+\t(output_functions): Rearrange so struct function is needed\n+\tonly when real body is output; be able to also ouptut abstract\n+\tfunctions; output DECL_ARGUMENTS and DECL_RESULT.\n+\t(lto_output): When not in WPA, ale store abstract functions.\n+\t(write_symbol): Do not care about RESULT_DECL.\n+\t(output_symbol_p): Handle correctly sbtract decls.\n+\t* lto-streamer-in.c (input_function): Rearrange so struct\n+\tfunction can be NULL at entry; allow streaming of\n+\tfunctions w/o body; store DECL_ARGUMENTS and DECL_RESULT.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Silence confused\n+\tsanity check during LTO.\n+\t* tree-streamer-out.c (write_ts_decl_non_common_tree_pointers): Skip\n+\tRESULT_DECl and DECL_ARGUMENTS.\n+\t* tree-streamer-in.c (lto_input_ts_decl_non_common_tree_pointers):\n+\tLikewise.\n+\n 2013-08-03  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* pretty-print.h (pp_underscore): New."}, {"sha": "2f60a98cb874f194da0b831ac9f7244a34558508", "filename": "gcc/ipa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -371,7 +371,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  if (!pointer_set_contains (body_needed_for_clonning, node->symbol.decl))\n \t    cgraph_release_function_body (node);\n \t  else if (!node->clone_of)\n-\t    gcc_assert (DECL_RESULT (node->symbol.decl));\n+\t    gcc_assert (in_lto_p || DECL_RESULT (node->symbol.decl));\n \t  if (node->symbol.definition)\n \t    {\n \t      if (file)\n@@ -382,7 +382,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       else\n \tgcc_assert (node->clone_of || !cgraph_function_with_gimple_body_p (node)\n-\t\t    || DECL_RESULT (node->symbol.decl));\n+\t\t    || in_lto_p || DECL_RESULT (node->symbol.decl));\n     }\n \n   /* Inline clones might be kept around so their materializing allows further"}, {"sha": "c3c393f6ec91c39d20cc4232a00cb6ed1190a62c", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -749,6 +749,13 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       add_node_to (encoder, node, true);\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)node);\n       add_references (encoder, &node->symbol.ref_list);\n+      /* For proper debug info, we need to ship the origins, too.  */\n+      if (DECL_ABSTRACT_ORIGIN (node->symbol.decl))\n+\t{\n+\t  struct cgraph_node *origin_node\n+\t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n+\t  add_node_to (encoder, origin_node, true);\n+\t}\n     }\n   for (lsei = lsei_start_variable_in_partition (in_encoder);\n        !lsei_end_p (lsei); lsei_next_variable_in_partition (&lsei))\n@@ -758,6 +765,13 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n       lto_set_symtab_encoder_in_partition (encoder, (symtab_node)vnode);\n       lto_set_symtab_encoder_encode_initializer (encoder, vnode);\n       add_references (encoder, &vnode->symbol.ref_list);\n+      /* For proper debug info, we need to ship the origins, too.  */\n+      if (DECL_ABSTRACT_ORIGIN (vnode->symbol.decl))\n+\t{\n+\t  struct varpool_node *origin_node\n+\t  = varpool_get_node (DECL_ABSTRACT_ORIGIN (node->symbol.decl));\n+\t  lto_set_symtab_encoder_in_partition (encoder, (symtab_node)origin_node);\n+\t}\n     }\n   /* Pickle in also the initializer of all referenced readonly variables\n      to help folding.  Constant pool variables are not shared, so we must"}, {"sha": "70a87d1738ba82b04c8fef292a5507ce65918c7c", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -851,33 +851,47 @@ input_struct_function_base (struct function *fn, struct data_in *data_in,\n \n static void\n input_function (tree fn_decl, struct data_in *data_in,\n-\t\tstruct lto_input_block *ib)\n+\t\tstruct lto_input_block *ib, struct lto_input_block *ib_cfg)\n {\n   struct function *fn;\n   enum LTO_tags tag;\n   gimple *stmts;\n   basic_block bb;\n   struct cgraph_node *node;\n \n-  fn = DECL_STRUCT_FUNCTION (fn_decl);\n   tag = streamer_read_record_start (ib);\n+  lto_tag_check (tag, LTO_function);\n+\n+  /* Read decls for parameters and args.  */\n+  DECL_RESULT (fn_decl) = stream_read_tree (ib, data_in);\n+  DECL_ARGUMENTS (fn_decl) = streamer_read_chain (ib, data_in);\n+\n+  /* Read the tree of lexical scopes for the function.  */\n+  DECL_INITIAL (fn_decl) = stream_read_tree (ib, data_in);\n+\n+  if (!streamer_read_uhwi (ib))\n+    return;\n+\n+  push_struct_function (fn_decl);\n+  fn = DECL_STRUCT_FUNCTION (fn_decl);\n+  init_tree_ssa (fn);\n+  /* We input IL in SSA form.  */\n+  cfun->gimple_df->in_ssa_p = true;\n \n   gimple_register_cfg_hooks ();\n-  lto_tag_check (tag, LTO_function);\n \n+  node = cgraph_get_create_node (fn_decl);\n   input_struct_function_base (fn, data_in, ib);\n+  input_cfg (ib_cfg, fn, node->count_materialization_scale);\n \n   /* Read all the SSA names.  */\n   input_ssa_names (ib, data_in, fn);\n \n   /* Read the exception handling regions in the function.  */\n   input_eh_regions (ib, data_in, fn);\n \n-  /* Read the tree of lexical scopes for the function.  */\n-  DECL_INITIAL (fn_decl) = stream_read_tree (ib, data_in);\n   gcc_assert (DECL_INITIAL (fn_decl));\n   DECL_SAVED_TREE (fn_decl) = NULL_TREE;\n-  node = cgraph_get_create_node (fn_decl);\n \n   /* Read all the basic blocks.  */\n   tag = streamer_read_record_start (ib);\n@@ -987,28 +1001,21 @@ lto_read_body (struct lto_file_decl_data *file_data, tree fn_decl,\n \n   if (section_type == LTO_section_function_body)\n     {\n-      struct function *fn = DECL_STRUCT_FUNCTION (fn_decl);\n       struct lto_in_decl_state *decl_state;\n       struct cgraph_node *node = cgraph_get_node (fn_decl);\n       unsigned from;\n \n       gcc_checking_assert (node);\n-      push_cfun (fn);\n-      init_tree_ssa (fn);\n-\n-      /* We input IL in SSA form.  */\n-      cfun->gimple_df->in_ssa_p = true;\n \n       /* Use the function's decl state. */\n       decl_state = lto_get_function_in_decl_state (file_data, fn_decl);\n       gcc_assert (decl_state);\n       file_data->current_decl_state = decl_state;\n \n-      input_cfg (&ib_cfg, fn, node->count_materialization_scale);\n \n       /* Set up the struct function.  */\n       from = data_in->reader_cache->nodes.length ();\n-      input_function (fn_decl, data_in, &ib_main);\n+      input_function (fn_decl, data_in, &ib_main, &ib_cfg);\n       /* And fixup types we streamed locally.  */\n \t{\n \t  struct streamer_tree_cache_d *cache = data_in->reader_cache;"}, {"sha": "ab7a89968612685f48756a633f5eaa465e74e901", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -124,8 +124,8 @@ output_type_ref (struct output_block *ob, tree node)\n static bool\n tree_is_indexable (tree t)\n {\n-  if (TREE_CODE (t) == PARM_DECL)\n-    return true;\n+  if (TREE_CODE (t) == PARM_DECL || TREE_CODE (t) == RESULT_DECL)\n+    return false;\n   else if (TREE_CODE (t) == VAR_DECL && decl_function_context (t)\n \t   && !TREE_STATIC (t))\n     return false;\n@@ -506,13 +506,7 @@ DFS_write_tree_body (struct output_block *ob,\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n     {\n-      if (TREE_CODE (expr) == FUNCTION_DECL)\n-\t{\n-\t  for (tree t = DECL_ARGUMENTS (expr); t; t = TREE_CHAIN (t))\n-\t    DFS_follow_tree_edge (t);\n-\t  DFS_follow_tree_edge (DECL_RESULT (expr));\n-\t}\n-      else if (TREE_CODE (expr) == TYPE_DECL)\n+      if (TREE_CODE (expr) == TYPE_DECL)\n \tDFS_follow_tree_edge (DECL_ORIGINAL_TYPE (expr));\n       DFS_follow_tree_edge (DECL_VINDEX (expr));\n     }\n@@ -936,13 +930,7 @@ hash_tree (struct streamer_tree_cache_d *cache, tree t)\n \n   if (CODE_CONTAINS_STRUCT (code, TS_DECL_NON_COMMON))\n     {\n-      if (code == FUNCTION_DECL)\n-\t{\n-\t  for (tree a = DECL_ARGUMENTS (t); a; a = DECL_CHAIN (a))\n-\t    visit (a);\n-\t  visit (DECL_RESULT (t));\n-\t}\n-      else if (code == TYPE_DECL)\n+      if (code == TYPE_DECL)\n \tvisit (DECL_ORIGINAL_TYPE (t));\n       visit (DECL_VINDEX (t));\n     }\n@@ -1772,50 +1760,63 @@ output_function (struct cgraph_node *node)\n \n   streamer_write_record_start (ob, LTO_function);\n \n-  output_struct_function_base (ob, fn);\n-\n-  /* Output all the SSA names used in the function.  */\n-  output_ssa_names (ob, fn);\n-\n-  /* Output any exception handling regions.  */\n-  output_eh_regions (ob, fn);\n+  /* Output decls for parameters and args.  */\n+  stream_write_tree (ob, DECL_RESULT (function), true);\n+  streamer_write_chain (ob, DECL_ARGUMENTS (function), true);\n \n   /* Output DECL_INITIAL for the function, which contains the tree of\n      lexical scopes.  */\n   stream_write_tree (ob, DECL_INITIAL (function), true);\n \n-  /* We will renumber the statements.  The code that does this uses\n-     the same ordering that we use for serializing them so we can use\n-     the same code on the other end and not have to write out the\n-     statement numbers.  We do not assign UIDs to PHIs here because\n-     virtual PHIs get re-computed on-the-fly which would make numbers\n-     inconsistent.  */\n-  set_gimple_stmt_max_uid (cfun, 0);\n-  FOR_ALL_BB (bb)\n-    {\n-      gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  /* We also stream abstract functions where we stream only stuff needed for\n+     debug info.  */\n+  if (gimple_has_body_p (function))\n+    {\n+      streamer_write_uhwi (ob, 1);\n+      output_struct_function_base (ob, fn);\n+\n+      /* Output all the SSA names used in the function.  */\n+      output_ssa_names (ob, fn);\n+\n+      /* Output any exception handling regions.  */\n+      output_eh_regions (ob, fn);\n+\n+\n+      /* We will renumber the statements.  The code that does this uses\n+\t the same ordering that we use for serializing them so we can use\n+\t the same code on the other end and not have to write out the\n+\t statement numbers.  We do not assign UIDs to PHIs here because\n+\t virtual PHIs get re-computed on-the-fly which would make numbers\n+\t inconsistent.  */\n+      set_gimple_stmt_max_uid (cfun, 0);\n+      FOR_ALL_BB (bb)\n \t{\n-\t  gimple stmt = gsi_stmt (gsi);\n-\t  gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple stmt = gsi_stmt (gsi);\n+\t      gimple_set_uid (stmt, inc_gimple_stmt_max_uid (cfun));\n+\t    }\n \t}\n-    }\n \n-  /* Output the code for the function.  */\n-  FOR_ALL_BB_FN (bb, fn)\n-    output_bb (ob, bb, fn);\n+      /* Output the code for the function.  */\n+      FOR_ALL_BB_FN (bb, fn)\n+\toutput_bb (ob, bb, fn);\n \n-  /* The terminator for this function.  */\n-  streamer_write_record_start (ob, LTO_null);\n+      /* The terminator for this function.  */\n+      streamer_write_record_start (ob, LTO_null);\n \n-  output_cfg (ob, fn);\n+      output_cfg (ob, fn);\n+\n+      pop_cfun ();\n+   }\n+  else\n+    streamer_write_uhwi (ob, 0);\n \n   /* Create a section to hold the pickled output of this function.   */\n   produce_asm (ob, function);\n \n   destroy_output_block (ob);\n-\n-  pop_cfun ();\n }\n \n \n@@ -1966,7 +1967,7 @@ lto_output (void)\n #endif\n \t  decl_state = lto_new_out_decl_state ();\n \t  lto_push_out_decl_state (decl_state);\n-\t  if (gimple_has_body_p (node->symbol.decl))\n+\t  if (gimple_has_body_p (node->symbol.decl) || !flag_wpa)\n \t    output_function (node);\n \t  else\n \t    copy_function (node);\n@@ -2149,9 +2150,9 @@ write_symbol (struct streamer_tree_cache_d *cache,\n   if (!TREE_PUBLIC (t)\n       || is_builtin_fn (t)\n       || DECL_ABSTRACT (t)\n-      || TREE_CODE (t) == RESULT_DECL\n       || (TREE_CODE (t) == VAR_DECL && DECL_HARD_REGISTER (t)))\n     return;\n+  gcc_assert (TREE_CODE (t) != RESULT_DECL);\n \n   gcc_assert (TREE_CODE (t) == VAR_DECL\n \t      || TREE_CODE (t) == FUNCTION_DECL);\n@@ -2254,15 +2255,15 @@ output_symbol_p (symtab_node node)\n      and devirtualization.  We do not want to see them in symbol table as\n      references unless they are really used.  */\n   cnode = dyn_cast <cgraph_node> (node);\n-  if (cnode && DECL_EXTERNAL (cnode->symbol.decl)\n+  if (cnode && (!node->symbol.definition || DECL_EXTERNAL (cnode->symbol.decl))\n       && cnode->callers)\n     return true;\n \n  /* Ignore all references from external vars initializers - they are not really\n     part of the compilation unit until they are used by folding.  Some symbols,\n     like references to external construction vtables can not be referred to at all.\n     We decide this at can_refer_decl_in_current_unit_p.  */\n- if (DECL_EXTERNAL (node->symbol.decl))\n+ if (!node->symbol.definition || DECL_EXTERNAL (node->symbol.decl))\n     {\n       int i;\n       struct ipa_ref *ref;"}, {"sha": "33f3b321d8155df0c39ee852ac5a1057b95b16b7", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -1,3 +1,10 @@\n+2013-08-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_materialize_function): Do not push struct function.\n+\t* lto-partition.c (get_symbol_class): Handle abstracts correctly.\n+\t(may_need_named_section_p): Even abstract origins may need\n+\tnamed section.\n+\n 2013-07-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Make-lang.in (lto/lto.o:): Depend on CONTEXT_H and"}, {"sha": "879218ce2fa9b7c967ce963cf4258ac46067913e", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -56,6 +56,10 @@ get_symbol_class (symtab_node node)\n   /* Inline clones are always duplicated.\n      This include external delcarations.   */\n   cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+\n+  if (DECL_ABSTRACT (node->symbol.decl))\n+    return SYMBOL_EXTERNAL;\n+\n   if (cnode && cnode->global.inlined_to)\n     return SYMBOL_DUPLICATE;\n \n@@ -840,8 +844,6 @@ may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node node)\n     return false;\n   if (symtab_real_symbol_p (node))\n     return false;\n-  if (!cnode->global.inlined_to && !cnode->clones)\n-    return false;\n   return (!encoder\n \t  || (lto_symtab_encoder_lookup (encoder, node) != LCC_NOT_FOUND\n               && lto_symtab_encoder_encode_body_p (encoder,"}, {"sha": "42d67f1bd3ddeaef40b61bd3700cf28c1ca78191", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -225,15 +225,13 @@ lto_materialize_function (struct cgraph_node *node)\n \n \t  gcc_assert (DECL_STRUCT_FUNCTION (decl) == NULL);\n \n-\t  push_struct_function (decl);\n \t  announce_function (decl);\n \t  lto_input_function_body (file_data, decl, data);\n \t  if (DECL_FUNCTION_PERSONALITY (decl) && !first_personality_decl)\n \t    first_personality_decl = DECL_FUNCTION_PERSONALITY (decl);\n \t  lto_stats.num_function_bodies++;\n \t  lto_free_section_data (file_data, LTO_section_function_body, name,\n \t\t\t\t data, len);\n-\t  pop_cfun ();\n \t  ggc_collect ();\n \t}\n     }"}, {"sha": "9efd099104149537ae24e98d1ed09d529311e8fb", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -678,12 +678,7 @@ static void\n lto_input_ts_decl_non_common_tree_pointers (struct lto_input_block *ib,\n \t\t\t\t\t    struct data_in *data_in, tree expr)\n {\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    {\n-      DECL_ARGUMENTS (expr) = streamer_read_chain (ib, data_in);\n-      DECL_RESULT (expr) = stream_read_tree (ib, data_in);\n-    }\n-  else if (TREE_CODE (expr) == TYPE_DECL)\n+  if (TREE_CODE (expr) == TYPE_DECL)\n     DECL_ORIGINAL_TYPE (expr) = stream_read_tree (ib, data_in);\n   DECL_VINDEX (expr) = stream_read_tree (ib, data_in);\n }"}, {"sha": "692a46aae859daf39744cc5567bb20aaf3ef1b2e", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815effe15595b6f680baedaf28868a0d21335302/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815effe15595b6f680baedaf28868a0d21335302/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=815effe15595b6f680baedaf28868a0d21335302", "patch": "@@ -606,12 +606,7 @@ static void\n write_ts_decl_non_common_tree_pointers (struct output_block *ob, tree expr,\n \t\t\t\t        bool ref_p)\n {\n-  if (TREE_CODE (expr) == FUNCTION_DECL)\n-    {\n-      streamer_write_chain (ob, DECL_ARGUMENTS (expr), ref_p);\n-      stream_write_tree (ob, DECL_RESULT (expr), ref_p);\n-    }\n-  else if (TREE_CODE (expr) == TYPE_DECL)\n+  if (TREE_CODE (expr) == TYPE_DECL)\n     stream_write_tree (ob, DECL_ORIGINAL_TYPE (expr), ref_p);\n   stream_write_tree (ob, DECL_VINDEX (expr), ref_p);\n }"}]}