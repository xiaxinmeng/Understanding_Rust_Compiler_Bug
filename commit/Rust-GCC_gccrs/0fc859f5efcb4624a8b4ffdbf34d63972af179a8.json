{"sha": "0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "node_id": "C_kwDOANBUbNoAKDBmYzg1OWY1ZWZjYjQ2MjRhOGI0ZmZkYmYzNGQ2Mzk3MmFmMTc5YTg", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-18T12:40:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-11-19T08:35:21Z"}, "message": "tree-optimization/102436 - restore loop store motion\n\nThis restores a case of conditional store motion we fail to handle\nafter the rewrite.  We can recognize the special case of all\nstores in a loop happening in a single conditionally executed\nblock which ensures stores are not re-ordered by executing them\nin different loop iterations.  Separating out the case avoids\ncomplicating the already complex main path.\n\n2021-11-18  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102436\n\t* tree-ssa-loop-im.c (execute_sm_if_changed): Add mode\n\tto just create the if structure and return the then block.\n\t(execute_sm): Add flag to indicate the var will re-use\n\tanother flag var.\n\t(hoist_memory_references): Support a single conditional\n\tblock with all stores as special case.\n\n\t* gcc.dg/torture/20211118-1.c: New testcase.\n\t* gcc.dg/tree-ssa/ssa-lim-18.c: Likewise.", "tree": {"sha": "edca5ac944ef0ed42fce6f17db03cb5f7b0c9558", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edca5ac944ef0ed42fce6f17db03cb5f7b0c9558"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09d462146b3107c665265b11ad925c61a91c6efb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09d462146b3107c665265b11ad925c61a91c6efb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09d462146b3107c665265b11ad925c61a91c6efb"}], "stats": {"total": 208, "additions": 199, "deletions": 9}, "files": [{"sha": "67ef68420df2fdda31ecb4807f82cd0f484b1e13", "filename": "gcc/testsuite/gcc.dg/torture/20211118-1.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20211118-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20211118-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20211118-1.c?ref=0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run } */\n+\n+unsigned p[3];\n+void __attribute__((noipa))\n+bar (float *q, int n, int m)\n+{\n+  for (int i = 0; i < m; ++i)\n+    {\n+      if (i == n)\n+        {\n+          unsigned a = p[1];\n+          p[1] = a + 1;\n+          *q = 1.;\n+        }\n+      q++;\n+    }\n+}\n+\n+int main()\n+{\n+#if __SIZEOF_FLOAT__ == __SIZEOF_INT__\n+  bar ((float *)p, 1, 3);\n+  if (((float *)p)[1] != 1.)\n+    __builtin_abort ();\n+#endif\n+  return 0;\n+}"}, {"sha": "da19806b712cb021d7486ce119712c68ca88c074", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-18.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-18.c?ref=0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fstrict-aliasing -fdump-tree-lim2-details\" } */\n+\n+unsigned p;\n+\n+void foo (float *q)\n+{\n+  for (int i = 0; i < 256; ++i)\n+    {\n+      if (p)\n+        {\n+          unsigned a = p;\n+          *(q++) = 1.;\n+          p = a + 1;\n+        }\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Executing store motion\" 1 \"lim2\" } } */"}, {"sha": "682406d26c1f09e62c67bc01a0bac06c64441ca2", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 153, "deletions": 9, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc859f5efcb4624a8b4ffdbf34d63972af179a8/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=0fc859f5efcb4624a8b4ffdbf34d63972af179a8", "patch": "@@ -1911,10 +1911,13 @@ first_mem_ref_loc (class loop *loop, im_mem_ref *ref)\n        }\n      }\n      if (lsm_flag)\t<--\n-       MEM = lsm;\t<--\n+       MEM = lsm;\t<-- (X)\n+\n+  In case MEM and TMP_VAR are NULL the function will return the then\n+  block so the caller can insert (X) and other related stmts. \n */\n \n-static void\n+static basic_block\n execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \t\t       edge preheader, hash_set <basic_block> *flag_bbs,\n \t\t       edge &append_cond_position, edge &last_cond_fallthru)\n@@ -2009,10 +2012,13 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \t\t\t    NULL_TREE, NULL_TREE);\n   gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n \n-  gsi = gsi_start_bb (then_bb);\n   /* Insert actual store.  */\n-  stmt = gimple_build_assign (unshare_expr (mem), tmp_var);\n-  gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+  if (mem)\n+    {\n+      gsi = gsi_start_bb (then_bb);\n+      stmt = gimple_build_assign (unshare_expr (mem), tmp_var);\n+      gsi_insert_after (&gsi, stmt, GSI_CONTINUE_LINKING);\n+    }\n \n   edge e1 = single_succ_edge (new_bb);\n   edge e2 = make_edge (new_bb, then_bb,\n@@ -2060,6 +2066,8 @@ execute_sm_if_changed (edge ex, tree mem, tree tmp_var, tree flag,\n \t      update_stmt (phi);\n \t    }\n       }\n+\n+  return then_bb;\n }\n \n /* When REF is set on the location, set flag indicating the store.  */\n@@ -2117,7 +2125,8 @@ struct sm_aux\n \n static void\n execute_sm (class loop *loop, im_mem_ref *ref,\n-\t    hash_map<im_mem_ref *, sm_aux *> &aux_map, bool maybe_mt)\n+\t    hash_map<im_mem_ref *, sm_aux *> &aux_map, bool maybe_mt,\n+\t    bool use_other_flag_var)\n {\n   gassign *load;\n   struct fmt_data fmt_data;\n@@ -2146,7 +2155,7 @@ execute_sm (class loop *loop, im_mem_ref *ref,\n \t  || (! flag_store_data_races && ! always_stored)))\n     multi_threaded_model_p = true;\n \n-  if (multi_threaded_model_p)\n+  if (multi_threaded_model_p && !use_other_flag_var)\n     aux->store_flag\n       = execute_sm_if_changed_flag_set (loop, ref, &aux->flag_bbs);\n   else\n@@ -2182,7 +2191,7 @@ execute_sm (class loop *loop, im_mem_ref *ref,\n   lim_data->tgt_loop = loop;\n   gsi_insert_before (&gsi, load, GSI_SAME_STMT);\n \n-  if (multi_threaded_model_p)\n+  if (aux->store_flag)\n     {\n       load = gimple_build_assign (aux->store_flag, boolean_false_node);\n       lim_data = init_lim_data (load);\n@@ -2555,6 +2564,140 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n   unsigned  i;\n   bitmap_iterator bi;\n \n+  /* There's a special case we can use ordered re-materialization for\n+     conditionally excuted stores which is when all stores in the loop\n+     happen in the same basic-block.  In that case we know we'll reach\n+     all stores and thus can simply process that BB and emit a single\n+     conditional block of ordered materializations.  See PR102436.  */\n+  basic_block single_store_bb = NULL;\n+  EXECUTE_IF_SET_IN_BITMAP (&memory_accesses.all_refs_stored_in_loop[loop->num],\n+\t\t\t    0, i, bi)\n+    {\n+      bool fail = false;\n+      ref = memory_accesses.refs_list[i];\n+      for (auto loc : ref->accesses_in_loop)\n+\tif (!gimple_vdef (loc.stmt))\n+\t  ;\n+\telse if (!single_store_bb)\n+\t  {\n+\t    single_store_bb = gimple_bb (loc.stmt);\n+\t    bool conditional = false;\n+\t    for (edge e : exits)\n+\t      if (!dominated_by_p (CDI_DOMINATORS, e->src, single_store_bb))\n+\t\t{\n+\t\t  /* Conditional as seen from e.  */\n+\t\t  conditional = true;\n+\t\t  break;\n+\t\t}\n+\t    if (!conditional)\n+\t      {\n+\t\tfail = true;\n+\t\tbreak;\n+\t      }\n+\t  }\n+\telse if (single_store_bb != gimple_bb (loc.stmt))\n+\t  {\n+\t    fail = true;\n+\t    break;\n+\t  }\n+      if (fail)\n+\t{\n+\t  single_store_bb = NULL;\n+\t  break;\n+\t}\n+    }\n+  if (single_store_bb)\n+    {\n+      /* Analyze the single block with stores.  */\n+      auto_bitmap fully_visited;\n+      auto_bitmap refs_not_supported;\n+      auto_bitmap refs_not_in_seq;\n+      auto_vec<seq_entry> seq;\n+      bitmap_copy (refs_not_in_seq, mem_refs);\n+      int res = sm_seq_valid_bb (loop, single_store_bb, NULL_TREE,\n+\t\t\t\t seq, refs_not_in_seq, refs_not_supported,\n+\t\t\t\t false, fully_visited);\n+      if (res != 1)\n+\t{\n+\t  /* Unhandled refs can still fail this.  */\n+\t  bitmap_clear (mem_refs);\n+\t  return;\n+\t}\n+\n+      /* We cannot handle sm_other since we neither remember the\n+\t stored location nor the value at the point we execute them.  */\n+      for (unsigned i = 0; i < seq.length (); ++i)\n+\t{\n+\t  unsigned new_i;\n+\t  if (seq[i].second == sm_other\n+\t      && seq[i].from != NULL_TREE)\n+\t    seq[i].from = NULL_TREE;\n+\t  else if ((seq[i].second == sm_ord\n+\t\t    || (seq[i].second == sm_other\n+\t\t\t&& seq[i].from != NULL_TREE))\n+\t\t   && !sm_seq_push_down (seq, i, &new_i))\n+\t    {\n+\t      bitmap_set_bit (refs_not_supported, seq[new_i].first);\n+\t      seq[new_i].second = sm_other;\n+\t      seq[new_i].from = NULL_TREE;\n+\t    }\n+\t}\n+      bitmap_and_compl_into (mem_refs, refs_not_supported);\n+      if (bitmap_empty_p (mem_refs))\n+\treturn;\n+\n+      /* Prune seq.  */\n+      while (seq.last ().second == sm_other\n+\t     && seq.last ().from == NULL_TREE)\n+\tseq.pop ();\n+\n+      hash_map<im_mem_ref *, sm_aux *> aux_map;\n+\n+      /* Execute SM but delay the store materialization for ordered\n+\t sequences on exit.  */\n+      bool first_p = true;\n+      EXECUTE_IF_SET_IN_BITMAP (mem_refs, 0, i, bi)\n+\t{\n+\t  ref = memory_accesses.refs_list[i];\n+\t  execute_sm (loop, ref, aux_map, true, !first_p);\n+\t  first_p = false;\n+\t}\n+\n+      /* Get at the single flag variable we eventually produced.  */\n+      im_mem_ref *ref\n+\t= memory_accesses.refs_list[bitmap_first_set_bit (mem_refs)];\n+      sm_aux *aux = *aux_map.get (ref);\n+\n+      /* Materialize ordered store sequences on exits.  */\n+      edge e;\n+      FOR_EACH_VEC_ELT (exits, i, e)\n+\t{\n+\t  edge append_cond_position = NULL;\n+\t  edge last_cond_fallthru = NULL;\n+\t  edge insert_e = e;\n+\t  /* Construct the single flag variable control flow and insert\n+\t     the ordered seq of stores in the then block.  With\n+\t     -fstore-data-races we can do the stores unconditionally.  */\n+\t  if (aux->store_flag)\n+\t    insert_e\n+\t      = single_pred_edge\n+\t\t  (execute_sm_if_changed (e, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t  aux->store_flag,\n+\t\t\t\t\t  loop_preheader_edge (loop),\n+\t\t\t\t\t  &aux->flag_bbs, append_cond_position,\n+\t\t\t\t\t  last_cond_fallthru));\n+\t  execute_sm_exit (loop, insert_e, seq, aux_map, sm_ord,\n+\t\t\t   append_cond_position, last_cond_fallthru);\n+\t  gsi_commit_one_edge_insert (insert_e, NULL);\n+\t}\n+\n+      for (hash_map<im_mem_ref *, sm_aux *>::iterator iter = aux_map.begin ();\n+\t   iter != aux_map.end (); ++iter)\n+\tdelete (*iter).second;\n+\n+      return;\n+    }\n+\n   /* To address PR57359 before actually applying store-motion check\n      the candidates found for validity with regards to reordering\n      relative to other stores which we until here disambiguated using\n@@ -2693,7 +2836,8 @@ hoist_memory_references (class loop *loop, bitmap mem_refs,\n   EXECUTE_IF_SET_IN_BITMAP (mem_refs, 0, i, bi)\n     {\n       ref = memory_accesses.refs_list[i];\n-      execute_sm (loop, ref, aux_map, bitmap_bit_p (refs_not_supported, i));\n+      execute_sm (loop, ref, aux_map, bitmap_bit_p (refs_not_supported, i),\n+\t\t  false);\n     }\n \n   /* Materialize ordered store sequences on exits.  */"}]}