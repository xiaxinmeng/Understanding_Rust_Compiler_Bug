{"sha": "5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxZTkxYzRmZGQ1OTQ2NTU2ZThkNGU0NTIwZGJiNjQzYTJlN2I1ZQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2018-04-19T16:36:34Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2018-04-19T16:36:34Z"}, "message": "i386: Add save_stack_nonlocal and restore_stack_nonlocal\n\nDefine STACK_SAVEAREA_MODE to hold both shadow stack and stack pointers.\nReplace builtin_setjmp_setup and builtin_longjmp with save_stack_nonlocal\nand restore_stack_nonlocal to support both builtin setjmp/longjmp as well\nas non-local goto in nested functions.\n\ngcc/\n\n\tPR target/85397\n\t* config/i386/i386.h (STACK_SAVEAREA_MODE): New.\n\t* config/i386/i386.md (builtin_setjmp_setup): Removed.\n\t(builtin_longjmp): Likewise.\n\t(save_stack_nonlocal): New pattern.\n\t(restore_stack_nonlocal): Likewise.\n\ngcc/testsuite/\n\n\tPR target/85397\n\t* gcc.dg/torture/pr85397-1.c: New test.\n\t* gcc.target/i386/cet-sjlj-6a.c: Adjusted.\n\t* gcc.target/i386/cet-sjlj-6b.c: Likewise.\n\nFrom-SVN: r259500", "tree": {"sha": "ed7f9067c97293bce49d41b27ec4b0d75a7b7b0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed7f9067c97293bce49d41b27ec4b0d75a7b7b0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2130a2afe7e45001936bb55b8ba1340c54953bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2130a2afe7e45001936bb55b8ba1340c54953bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2130a2afe7e45001936bb55b8ba1340c54953bbd"}], "stats": {"total": 171, "additions": 108, "deletions": 63}, "files": [{"sha": "6d676a19be614b3227fe12d261fbed520519ba5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -1,3 +1,12 @@\n+2018-04-19  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85397\n+\t* config/i386/i386.h (STACK_SAVEAREA_MODE): New.\n+\t* config/i386/i386.md (builtin_setjmp_setup): Removed.\n+\t(builtin_longjmp): Likewise.\n+\t(save_stack_nonlocal): New pattern.\n+\t(restore_stack_nonlocal): Likewise.\n+\n 2018-04-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85404"}, {"sha": "3734ba1bc127c389ccbdded503def7b77fe9dc05", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -1948,6 +1948,17 @@ do {\t\t\t\t\t\t\t\\\n    between pointers and any other objects of this machine mode.  */\n #define Pmode (ix86_pmode == PMODE_DI ? DImode : SImode)\n \n+/* Supply a definition of STACK_SAVEAREA_MODE for emit_stack_save.\n+   NONLOCAL needs space to save both shadow stack and stack pointers.\n+\n+   FIXME: We only need to save and restore stack pointer in ptr_mode.\n+   But expand_builtin_setjmp_setup and expand_builtin_longjmp use Pmode\n+   to save and restore stack pointer.  See\n+   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84150\n+ */\n+#define STACK_SAVEAREA_MODE(LEVEL)\t\t\t\\\n+  ((LEVEL) == SAVE_NONLOCAL ? (TARGET_64BIT ? TImode : DImode) : Pmode)\n+\n /* Specify the machine mode that bounds have.  */\n #define BNDmode (ix86_pmode == PMODE_DI ? BND64mode : BND32mode)\n "}, {"sha": "33e8060fa56c2aab1adc4c9dc0819c31462df8ab", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 48, "deletions": 59, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -18487,29 +18487,6 @@\n   \"* return output_probe_stack_range (operands[0], operands[2]);\"\n   [(set_attr \"type\" \"multi\")])\n \n-/* Additional processing for builtin_setjmp.  Store the shadow stack pointer\n-   as a forth element in jmpbuf.  */\n-(define_expand \"builtin_setjmp_setup\"\n-  [(match_operand 0 \"address_operand\")]\n-  \"TARGET_SHSTK\"\n-{\n-  if (flag_cf_protection & CF_RETURN)\n-    {\n-      rtx mem, reg_ssp;\n-\n-      mem = gen_rtx_MEM (word_mode,\n-\t\t\t plus_constant (Pmode, operands[0],\n-\t\t\t\t\t3 * GET_MODE_SIZE (ptr_mode)));\n-      reg_ssp = gen_reg_rtx (word_mode);\n-      emit_insn (gen_rtx_SET (reg_ssp, const0_rtx));\n-      emit_insn ((word_mode == SImode)\n-\t\t ? gen_rdsspsi (reg_ssp)\n-\t\t : gen_rdsspdi (reg_ssp));\n-      emit_move_insn (mem, reg_ssp);\n-    }\n-  DONE;\n-})\n-\n (define_expand \"builtin_setjmp_receiver\"\n   [(label_ref (match_operand 0))]\n   \"!TARGET_64BIT && flag_pic\"\n@@ -18530,19 +18507,46 @@\n   DONE;\n })\n \n-(define_expand \"builtin_longjmp\"\n-  [(match_operand 0 \"address_operand\")]\n-  \"TARGET_SHSTK\"\n+(define_expand \"save_stack_nonlocal\"\n+  [(set (match_operand 0 \"memory_operand\")\n+        (match_operand 1 \"register_operand\"))]\n+  \"\"\n {\n-  rtx fp, lab, stack;\n-  rtx flags, jump, noadj_label, inc_label, loop_label;\n-  rtx reg_adj, reg_ssp, mem_buf, tmp, clob;\n-  machine_mode sa_mode = STACK_SAVEAREA_MODE (SAVE_NONLOCAL);\n+  rtx stack_slot;\n+  if ((flag_cf_protection & CF_RETURN))\n+    {\n+      /* Copy shadow stack pointer to the first slot and stack ppointer\n+\t to the second slot.  */\n+      rtx ssp_slot = adjust_address (operands[0], word_mode, 0);\n+      stack_slot = adjust_address (operands[0], Pmode, UNITS_PER_WORD);\n+      rtx ssp = gen_reg_rtx (word_mode);\n+      emit_insn ((word_mode == SImode)\n+\t\t ? gen_rdsspsi (ssp)\n+\t\t : gen_rdsspdi (ssp));\n+      emit_move_insn (ssp_slot, ssp);\n+    }\n+  else\n+    stack_slot = adjust_address (operands[0], Pmode, 0);\n+  emit_move_insn (stack_slot, operands[1]);\n+  DONE;\n+})\n \n-  /* Adjust the shadow stack pointer (ssp) to the value saved in the\n-     jmp_buf.  The saving was done in the builtin_setjmp_setup.  */\n-  if (flag_cf_protection & CF_RETURN)\n+(define_expand \"restore_stack_nonlocal\"\n+  [(set (match_operand 0 \"register_operand\" \"\")\n+\t(match_operand 1 \"memory_operand\" \"\"))]\n+  \"\"\n+{\n+  rtx stack_slot;\n+  if ((flag_cf_protection & CF_RETURN))\n     {\n+      /* Restore shadow stack pointer from the first slot and stack\n+\t pointer from the second slot.  */\n+      rtx ssp_slot = adjust_address (operands[1], word_mode, 0);\n+      stack_slot = adjust_address (operands[1], Pmode, UNITS_PER_WORD);\n+\n+      rtx flags, jump, noadj_label, inc_label, loop_label;\n+      rtx reg_adj, reg_ssp, tmp, clob;\n+\n       /* Get the current shadow stack pointer.  The code below will check if\n \t SHSTK feature is enabled.  If it is not enabled the RDSSP instruction\n \t is a NOP.  */\n@@ -18551,13 +18555,11 @@\n       emit_insn ((word_mode == SImode)\n \t\t ? gen_rdsspsi (reg_ssp)\n \t\t : gen_rdsspdi (reg_ssp));\n-      mem_buf = gen_rtx_MEM (word_mode,\n-\t\t\t     plus_constant (Pmode, operands[0],\n-\t\t\t\t\t    3 * GET_MODE_SIZE (ptr_mode)));\n \n       /* Compare through substraction the saved and the current ssp to decide\n \t if ssp has to be adjusted.  */\n-      tmp = gen_rtx_SET (reg_ssp, gen_rtx_MINUS (word_mode, reg_ssp, mem_buf));\n+      tmp = gen_rtx_SET (reg_ssp, gen_rtx_MINUS (word_mode, reg_ssp,\n+\t\t\t\t\t\t ssp_slot));\n       clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n       tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n       emit_insn (tmp);\n@@ -18597,14 +18599,17 @@\n       jump = emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n       JUMP_LABEL (jump) = inc_label;\n \n+      rtx reg_255 = gen_reg_rtx (word_mode);\n+      emit_move_insn (reg_255, GEN_INT (255));\n+\n       /* Adjust the ssp in a loop.  */\n       loop_label = gen_label_rtx ();\n       emit_label (loop_label);\n       LABEL_NUSES (loop_label) = 1;\n \n       emit_insn ((word_mode == SImode)\n-\t\t ? gen_incsspsi (reg_ssp)\n-\t\t : gen_incsspdi (reg_ssp));\n+\t\t ? gen_incsspsi (reg_255)\n+\t\t : gen_incsspdi (reg_255));\n       tmp = gen_rtx_SET (reg_adj, gen_rtx_MINUS (ptr_mode,\n \t\t\t\t\t\t reg_adj,\n \t\t\t\t\t\t GEN_INT (255)));\n@@ -18633,26 +18638,10 @@\n       emit_label (noadj_label);\n       LABEL_NUSES (noadj_label) = 1;\n     }\n-\n-  /* This code is the same as in expand_buildin_longjmp.  */\n-  fp = gen_rtx_MEM (ptr_mode, operands[0]);\n-  lab = gen_rtx_MEM (ptr_mode, plus_constant (Pmode, operands[0],\n-\t\t\t\t\t      GET_MODE_SIZE (ptr_mode)));\n-  stack = gen_rtx_MEM (sa_mode, plus_constant (Pmode, operands[0],\n-\t\t\t\t\t       2 * GET_MODE_SIZE (ptr_mode)));\n-  lab = copy_to_reg (lab);\n-\n-  emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));\n-  emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));\n-\n-  if (GET_MODE (fp) != Pmode)\n-    fp = convert_to_mode (Pmode, fp, 1);\n-  emit_move_insn (hard_frame_pointer_rtx, fp);\n-  emit_stack_restore (SAVE_NONLOCAL, stack);\n-\n-  emit_use (hard_frame_pointer_rtx);\n-  emit_use (stack_pointer_rtx);\n-  emit_indirect_jump (lab);\n+  else\n+    stack_slot = adjust_address (operands[1], Pmode, 0);\n+  emit_move_insn (operands[0], stack_slot);\n+  DONE;\n })\n \n "}, {"sha": "a00911dd1728109814b8649bb05d780f566f632b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -1,3 +1,10 @@\n+2018-04-19  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/85397\n+\t* gcc.dg/torture/pr85397-1.c: New test.\n+\t* gcc.target/i386/cet-sjlj-6a.c: Adjusted.\n+\t* gcc.target/i386/cet-sjlj-6b.c: Likewise.\n+\n 2018-04-19  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/85404"}, {"sha": "650852402665782b88c586c182ed05ddb0e95ef8", "filename": "gcc/testsuite/gcc.dg/torture/pr85397-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85397-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85397-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr85397-1.c?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target cet } */\n+/* { dg-additional-options \"-fcf-protection -mcet\" } */\n+\n+#define DEPTH 1000\n+\n+int\n+x(int a)\n+{\n+  __label__ xlab;\n+  void y(int a)\n+    {\n+      if (a==0)\n+\tgoto xlab;\n+      y (a-1);\n+    }\n+  y (a);\n+ xlab:;\n+  return a;\n+}\n+\n+int\n+main ()\n+{\n+  if (x (DEPTH) != DEPTH)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "87fe2e6dc67876b50665d631c3ac62ab118e3e04", "filename": "gcc/testsuite/gcc.target/i386/cet-sjlj-6a.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6a.c?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -2,8 +2,8 @@\n /* { dg-require-effective-target maybe_x32 } */\n /* { dg-options \"-O -maddress-mode=short -fcf-protection -mcet -mx32\" } */\n /* { dg-final { scan-assembler-times \"endbr64\" 2 } } */\n-/* { dg-final { scan-assembler-times \"movq\\t.*buf\\\\+12\" 1 } } */\n-/* { dg-final { scan-assembler-times \"subq\\tbuf\\\\+12\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movq\\t.*buf\\\\+8\" 1 } } */\n+/* { dg-final { scan-assembler-times \"subq\\tbuf\\\\+8\" 1 } } */\n /* { dg-final { scan-assembler-times \"shrl\\t\\\\\\$3,\" 1 } } */\n /* { dg-final { scan-assembler-times \"rdsspq\" 2 } } */\n /* { dg-final { scan-assembler-times \"incsspq\" 2 } } */"}, {"sha": "b3866d52946fb864784f1d6ab46c1d35f50893db", "filename": "gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fcet-sjlj-6b.c?ref=5e1e91c4fdd5946556e8d4e4520dbb643a2e7b5e", "patch": "@@ -1,8 +1,8 @@\n /* { dg-do compile { target { ! ia32 } } } */\n /* { dg-options \"-O -maddress-mode=long -fcf-protection -mcet -mx32\" } */\n /* { dg-final { scan-assembler-times \"endbr64\" 2 } } */\n-/* { dg-final { scan-assembler-times \"movq\\t.*buf\\\\+12\" 1 } } */\n-/* { dg-final { scan-assembler-times \"subq\\tbuf\\\\+12\" 1 } } */\n+/* { dg-final { scan-assembler-times \"movq\\t.*buf\\\\+16\" 1 } } */\n+/* { dg-final { scan-assembler-times \"subq\\tbuf\\\\+16\" 1 } } */\n /* { dg-final { scan-assembler-times \"shrl\\t\\\\\\$3,\" 1 } } */\n /* { dg-final { scan-assembler-times \"rdsspq\" 2 } } */\n /* { dg-final { scan-assembler-times \"incsspq\" 2 } } */"}]}