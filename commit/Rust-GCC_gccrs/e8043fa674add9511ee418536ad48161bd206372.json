{"sha": "e8043fa674add9511ee418536ad48161bd206372", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwNDNmYTY3NGFkZDk1MTFlZTQxODUzNmFkNDgxNjFiZDIwNjM3Mg==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-06-14T16:00:56Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-06-14T16:00:56Z"}, "message": "status_cxx2014.xml: Update Fundamentals TS status.\n\n\t* doc/xml/manual/status_cxx2014.xml: Update Fundamentals TS status.\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/experimental/any: New.\n\t* include/ext/aligned_buffer.h (__aligned_buffer(nullptr_t)): New\n\tconstructor.\n\t* testsuite/experimental/any/assign/1.cc: New.\n\t* testsuite/experimental/any/assign/2.cc: New.\n\t* testsuite/experimental/any/cons/1.cc: New.\n\t* testsuite/experimental/any/cons/2.cc: New.\n\t* testsuite/experimental/any/cons/3.cc: New.\n\t* testsuite/experimental/any/misc/any_cast.cc: New.\n\t* testsuite/experimental/any/misc/any_cast_neg.cc: New.\n\t* testsuite/experimental/any/misc/any_cast_no_rtti.cc: New.\n\t* testsuite/experimental/any/misc/swap.cc: New.\n\t* testsuite/experimental/any/modifiers/1.cc: New.\n\t* testsuite/experimental/any/observers/type.cc: New.\n\nFrom-SVN: r211669", "tree": {"sha": "9d7935f468918c9e14cc65c3229114e7e59bc17d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d7935f468918c9e14cc65c3229114e7e59bc17d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8043fa674add9511ee418536ad48161bd206372", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8043fa674add9511ee418536ad48161bd206372", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8043fa674add9511ee418536ad48161bd206372", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8043fa674add9511ee418536ad48161bd206372/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab938b4135eec5527d41a938b1052177015e3d35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab938b4135eec5527d41a938b1052177015e3d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab938b4135eec5527d41a938b1052177015e3d35"}], "stats": {"total": 1270, "additions": 1268, "deletions": 2}, "files": [{"sha": "c44fad8b3ba4175ac76841a1c04ec2b22e1f8241", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -1,3 +1,23 @@\n+2014-06-14  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\t* doc/xml/manual/status_cxx2014.xml: Update Fundamentals TS status.\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/experimental/any: New.\n+\t* include/ext/aligned_buffer.h (__aligned_buffer(nullptr_t)): New\n+\tconstructor.\n+\t* testsuite/experimental/any/assign/1.cc: New.\n+\t* testsuite/experimental/any/assign/2.cc: New.\n+\t* testsuite/experimental/any/cons/1.cc: New.\n+\t* testsuite/experimental/any/cons/2.cc: New.\n+\t* testsuite/experimental/any/cons/3.cc: New.\n+\t* testsuite/experimental/any/misc/any_cast.cc: New.\n+\t* testsuite/experimental/any/misc/any_cast_neg.cc: New.\n+\t* testsuite/experimental/any/misc/any_cast_no_rtti.cc: New.\n+\t* testsuite/experimental/any/misc/swap.cc: New.\n+\t* testsuite/experimental/any/modifiers/1.cc: New.\n+\t* testsuite/experimental/any/observers/type.cc: New.\n+\n 2014-06-11  Maciej W. Rozycki  <macro@codesourcery.com>\n \n \t* testsuite/27_io/basic_ostream/inserters_arithmetic/wchar_t/4402.cc"}, {"sha": "82abd8867ca4a4010322426d13e90862839afd1d", "filename": "libstdc++-v3/doc/xml/manual/status_cxx2014.xml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fstatus_cxx2014.xml?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -306,14 +306,13 @@ not in any particular release.\n     </row>\n \n     <row>\n-      <?dbhtml bgcolor=\"#C8B0B0\" ?>\n       <entry>\n \t<link xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3804.html\">\n \t  N3804\n \t</link>\n       </entry>\n       <entry>Any library proposal</entry>\n-      <entry>N</entry>\n+      <entry>Y</entry>\n       <entry>Library Fundamentals TS</entry>\n     </row>\n "}, {"sha": "8fe82daae2d975ddd180b06f4b04bbf5472a6ca8", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -638,6 +638,7 @@ decimal_headers = \\\n experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n experimental_builddir = ./experimental\n experimental_headers = \\\n+\t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/string_view.tcc"}, {"sha": "51fde97e605f9425c4f2daf0965b69a3793e9868", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -904,6 +904,7 @@ decimal_headers = \\\n experimental_srcdir = ${glibcxx_srcdir}/include/experimental\n experimental_builddir = ./experimental\n experimental_headers = \\\n+\t${experimental_srcdir}/any \\\n \t${experimental_srcdir}/optional \\\n \t${experimental_srcdir}/string_view \\\n \t${experimental_srcdir}/string_view.tcc"}, {"sha": "2839af1eae60c374a9783fe607d065df55e61d70", "filename": "libstdc++-v3/include/experimental/any", "status": "added", "additions": 626, "deletions": 0, "changes": 626, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fany", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fany", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fany?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,626 @@\n+// <experimental/any> -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file experimental/any\n+ *  This is a TS C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_EXPERIMENTAL_ANY\n+#define _GLIBCXX_EXPERIMENTAL_ANY 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus <= 201103L\n+# include <bits/c++14_warning.h>\n+#else\n+\n+#include <typeinfo>\n+#include <memory>\n+#include <utility>\n+#include <type_traits>\n+#include <bits/alloc_traits.h>\n+#include <bits/uses_allocator.h>\n+#include <bits/functexcept.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+namespace experimental\n+{\n+inline namespace any_v1\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @defgroup any Type-safe container of any type\n+   * @ingroup experimental\n+   *\n+   * A type-safe container for single values of value types, as\n+   * described in n3804 \"Any Library Proposal (Revision 3)\".\n+   *\n+   * @{\n+   */\n+\n+  /**\n+   *  @brief Exception class thrown by a failed @c any_cast\n+   *  @ingroup exceptions\n+   */\n+  class bad_any_cast : public bad_cast\n+  {\n+  public:\n+    virtual const char* what() const noexcept { return \"bad_any_cast\"; }\n+  };\n+\n+  [[gnu::noreturn]] inline void __throw_bad_any_cast()\n+  {\n+#ifdef __EXCEPTIONS\n+    throw bad_any_cast{};\n+#else\n+    __builtin_abort();\n+#endif\n+  }\n+\n+  /**\n+    * @brief A type-safe container of any type.\n+    *\n+    * An @c any object's state is either empty or it stores a contained object\n+    * of CopyConstructible type.\n+    */\n+  class any\n+  {\n+    // Holds either pointer to a heap object or the contained object itself.\n+    union _Storage\n+    {\n+      void* _M_ptr;\n+      std::aligned_storage<sizeof(_M_ptr), sizeof(_M_ptr)>::type _M_buffer;\n+    };\n+\n+    template<typename _Tp, typename _Safe = is_nothrow_copy_constructible<_Tp>,\n+\t     bool _Fits = (sizeof(_Tp) <= sizeof(_Storage))>\n+      using _Internal = std::integral_constant<bool, _Safe::value && _Fits>;\n+\n+    template<typename _Tp>\n+      struct _Manager_internal; // uses small-object optimization\n+\n+    template<typename _Tp>\n+      struct _Manager_external; // creates contained object on the heap\n+\n+    template<typename _Tp>\n+      using _Manager = conditional_t<_Internal<_Tp>::value,\n+\t\t\t\t     _Manager_internal<_Tp>,\n+\t\t\t\t     _Manager_external<_Tp>>;\n+\n+#ifdef __GXX_RTTI\n+    // When RTTI is disabled __any_caster assumes the manager is either\n+    // _Manager_internal or _Manager_external, so this type must not be used.\n+    template<typename _Tp, typename _Alloc>\n+      struct _Manager_alloc; // creates contained object using an allocator\n+\n+    template<typename _Tp, typename _Alloc, typename _TpAlloc\n+\t     = typename allocator_traits<_Alloc>::template rebind_alloc<_Tp>>\n+      using _ManagerAlloc = conditional_t<_Internal<_Tp>::value,\n+\t\t\t\t\t  _Manager_internal<_Tp>,\n+\t\t\t\t\t  _Manager_alloc<_Tp, _TpAlloc>>;\n+#endif\n+\n+    template<typename _Tp, typename _Decayed = decay_t<_Tp>>\n+      using _Decay = enable_if_t<!is_same<_Decayed, any>::value, _Decayed>;\n+\n+  public:\n+    // construct/destruct\n+\n+    /// Default constructor, creates an empty object.\n+    any() noexcept : _M_manager(nullptr) { }\n+\n+    /// Copy constructor, copies the state of @p __other\n+    any(const any& __other) : _M_manager(__other._M_manager)\n+    {\n+      if (!__other.empty())\n+\t{\n+\t  _Arg __arg;\n+\t  __arg._M_any = this;\n+\t  _M_manager(_Op_clone, &__other, &__arg);\n+\t}\n+    }\n+\n+    /**\n+     * @brief Move constructor, transfer the state from @p __other\n+     *\n+     * @post @c __other.empty() (not guaranteed for other implementations)\n+     */\n+    any(any&& __other) noexcept\n+    : _M_manager(__other._M_manager),\n+      _M_storage(__other._M_storage)\n+    { __other._M_manager = nullptr; }\n+\n+    /// Construct with a copy of @p __value as the contained object.\n+    template <typename _ValueType, typename _Tp = _Decay<_ValueType>,\n+\t      typename _Mgr = _Manager<_Tp>>\n+      any(_ValueType&& __value)\n+      : _M_manager(&_Mgr::_S_manage),\n+        _M_storage(_Mgr::_S_create(std::forward<_ValueType>(__value)))\n+      {\n+\tstatic_assert(is_copy_constructible<_Tp>::value,\n+\t\t      \"The contained object must be CopyConstructible\");\n+      }\n+\n+    /// Allocator-extended default constructor (the allocator is ignored).\n+    template <typename _Allocator>\n+      any(allocator_arg_t, const _Allocator&) noexcept : any() { }\n+\n+#ifdef __GXX_RTTI\n+    /// Construct with a copy of @p __value as the contained object.\n+    template <typename _Allocator, typename _ValueType,\n+\t      typename _Tp = _Decay<_ValueType>,\n+\t      typename _Mgr = _ManagerAlloc<_Tp, _Allocator>>\n+      any(allocator_arg_t, const _Allocator& __a, _ValueType&& __value)\n+      : _M_manager(&_Mgr::_S_manage),\n+        _M_storage(_Mgr::_S_alloc(__a, std::forward<_ValueType>(__value)))\n+      {\n+\tstatic_assert(is_copy_constructible<_Tp>::value,\n+\t\t      \"The contained object must be CopyConstructible\");\n+      }\n+#endif\n+\n+    /* TODO: implement this somehow\n+    /// Allocator-extended copy constructor.\n+    template <class _Allocator>\n+      any(allocator_arg_t, const _Allocator& __a, const any& __other);\n+    */\n+\n+    /// Allocator-extended move constructor (the allocator is ignored).\n+    template <typename _Allocator>\n+      any(allocator_arg_t, const _Allocator&, any&& __other) noexcept\n+      : any(std::move(__other)) { }\n+\n+    /// Destructor, calls @c clear()\n+    ~any() { clear(); }\n+\n+    // assignments\n+\n+    /// Copy the state of \n+    any& operator=(const any& __rhs)\n+    {\n+      any(__rhs).swap(*this);\n+      return *this;\n+    }\n+\n+    /**\n+     * @brief Move assignment operator\n+     *\n+     * @post @c __rhs.empty() (not guaranteed for other implementations)\n+     */\n+    any& operator=(any&& __rhs) noexcept\n+    {\n+      any(std::move(__rhs)).swap(*this);\n+      return *this;\n+    }\n+\n+    /// Store a copy of @p __rhs as the contained object.\n+    template<typename _ValueType>\n+      any& operator=(_ValueType&& __rhs)\n+      {\n+\tany(std::forward<_ValueType>(__rhs)).swap(*this);\n+\treturn *this;\n+      }\n+\n+    // modifiers\n+\n+    /// If not empty, destroy the contained object.\n+    void clear() noexcept\n+    {\n+      if (!empty())\n+      {\n+\t_M_manager(_Op_destroy, this, nullptr);\n+\t_M_manager = nullptr;\n+      }\n+    }\n+\n+    /// Exchange state with another object.\n+    void swap(any& __rhs) noexcept\n+    {\n+      std::swap(_M_manager, __rhs._M_manager);\n+      std::swap(_M_storage, __rhs._M_storage);\n+    }\n+\n+    // observers\n+\n+    /// Reports whether there is a contained object or not.\n+    bool empty() const noexcept { return _M_manager == nullptr; }\n+\n+#ifdef __GXX_RTTI\n+    /// The @c typeid of the contained object, or @c typeid(void) if empty.\n+    const type_info& type() const noexcept\n+    {\n+      if (empty())\n+\treturn typeid(void);\n+      _Arg __arg;\n+      _M_manager(_Op_get_type_info, this, &__arg);\n+      return *__arg._M_typeinfo;\n+    }\n+#endif\n+\n+    template<typename _Tp>\n+      static constexpr bool __is_valid_cast()\n+      { return __or_<is_reference<_Tp>, is_copy_constructible<_Tp>>::value; }\n+\n+  private:\n+    enum _Op { _Op_access, _Op_get_type_info, _Op_clone, _Op_destroy };\n+\n+    union _Arg\n+    {\n+\tvoid* _M_obj;\n+\tconst std::type_info* _M_typeinfo;\n+\tany* _M_any;\n+    };\n+\n+    void (*_M_manager)(_Op, const any*, _Arg*);\n+    _Storage _M_storage;\n+\n+    template<typename _Tp>\n+      friend void* __any_caster(const any* __any)\n+      {\n+#ifdef __GXX_RTTI\n+\tif (__any->type() != typeid(_Tp))\n+\t  return nullptr;\n+#else\n+\tif (__any->_M_manager != &_Manager<decay_t<_Tp>>::_S_manage)\n+\t  return nullptr;\n+#endif\n+\t_Arg __arg;\n+\t__any->_M_manager(_Op_access, __any, &__arg);\n+\treturn __arg._M_obj;\n+      }\n+\n+    // Manage in-place contained object.\n+    template<typename _Tp>\n+      struct _Manager_internal\n+      {\n+\tstatic void\n+\t_S_manage(_Op __which, const any* __anyp, _Arg* __arg);\n+\n+\ttemplate<typename _Up>\n+\t  static _Storage\n+\t  _S_create(_Up&& __value)\n+\t  {\n+\t    _Storage __storage;\n+\t    void* __addr = &__storage._M_buffer;\n+\t    ::new (__addr) _Tp(std::forward<_Up>(__value));\n+\t    return __storage;\n+\t  }\n+\n+\ttemplate<typename _Alloc, typename _Up>\n+\t  static _Storage\n+\t  _S_alloc(const _Alloc&, _Up&& __value)\n+\t  {\n+\t    return _S_create(std::forward<_Up>(__value));\n+\t  }\n+      };\n+\n+    // Manage external contained object.\n+    template<typename _Tp>\n+      struct _Manager_external\n+      {\n+\tstatic void\n+\t_S_manage(_Op __which, const any* __anyp, _Arg* __arg);\n+\n+\ttemplate<typename _Up>\n+\t  static _Storage\n+\t  _S_create(_Up&& __value)\n+\t  {\n+\t    _Storage __storage;\n+\t    __storage._M_ptr = new _Tp(std::forward<_Up>(__value));\n+\t    return __storage;\n+\t  }\n+      };\n+\n+#ifdef __GXX_RTTI\n+    // Manage external contained object using an allocator\n+    template<typename _Tp, typename _Alloc>\n+      struct _Manager_alloc\n+      {\n+\tstatic_assert(std::is_same<_Tp, typename _Alloc::value_type>::value,\n+\t\t      \"Allocator's value_type is correct\");\n+\n+\t// Type that holds contained object and allocator\n+\tstruct _Data;\n+\n+\tusing _Traits = typename std::allocator_traits<_Alloc>::template\n+\t  rebind_traits<_Data>;\n+\n+\tstatic void\n+\t_S_manage(_Op __which, const any* __anyp, _Arg* __arg);\n+\n+\ttemplate<typename _Up>\n+\t  static _Storage\n+\t  _S_alloc(const _Alloc& __a, _Up&& __value);\n+      };\n+#endif\n+  };\n+\n+  /// Exchange the states of two @c any objects.\n+  inline void swap(any& __x, any& __y) noexcept { __x.swap(__y); }\n+\n+  /**\n+   * @brief Access the contained object.\n+   *\n+   * @tparam  _ValueType  A const-reference or CopyConstructible type.\n+   * @param   __any       The object to access.\n+   * @return  The contained object.\n+   * @throw   bad_any_cast If <code>\n+   *          __any.type() != typeid(remove_reference_t<_ValueType>)\n+   *          </code>\n+   */\n+  template<typename _ValueType>\n+    inline _ValueType any_cast(const any& __any)\n+    {\n+      static_assert(any::__is_valid_cast<_ValueType>(),\n+\t  \"Template argument must be a reference or CopyConstructible type\");\n+      auto __p = any_cast<add_const_t<remove_reference_t<_ValueType>>>(&__any);\n+      if (__p)\n+\treturn *__p;\n+      __throw_bad_any_cast();\n+    }\n+\n+  /**\n+   * @brief Access the contained object.\n+   *\n+   * @tparam  _ValueType  A reference or CopyConstructible type.\n+   * @param   __any       The object to access.\n+   * @return  The contained object.\n+   * @throw   bad_any_cast If <code>\n+   *          __any.type() != typeid(remove_reference_t<_ValueType>)\n+   *          </code>\n+   */\n+  template<typename _ValueType>\n+    inline _ValueType any_cast(any& __any)\n+    {\n+      static_assert(any::__is_valid_cast<_ValueType>(),\n+\t  \"Template argument must be a reference or CopyConstructible type\");\n+      auto __p = any_cast<remove_reference_t<_ValueType>>(&__any);\n+      if (__p)\n+\treturn *__p;\n+      __throw_bad_any_cast();\n+    }\n+\n+  /**\n+   * @brief Access the contained object.\n+   *\n+   * @tparam  _ValueType  A reference or CopyConstructible type.\n+   * @param   __any       The object to access.\n+   * @return  The contained object.\n+   * @throw   bad_any_cast If <code>\n+   *          __any.type() != typeid(remove_reference_t<_ValueType>)\n+   *          </code>\n+   */\n+  template<typename _ValueType>\n+    inline _ValueType any_cast(any&& __any)\n+    {\n+      static_assert(any::__is_valid_cast<_ValueType>(),\n+\t  \"Template argument must be a reference or CopyConstructible type\");\n+      auto __p = any_cast<remove_reference_t<_ValueType>>(&__any);\n+      if (__p)\n+\treturn *__p;\n+      __throw_bad_any_cast();\n+    }\n+\n+  /**\n+   * @brief Access the contained object.\n+   *\n+   * @tparam  _ValueType  The type of the contained object.\n+   * @param   __any       A pointer to the object to access.\n+   * @return  The address of the contained object if <code>\n+   *          __any != nullptr && __any.type() == typeid(_ValueType)\n+   *          </code>, otherwise a null pointer.\n+   */\n+  template<typename _ValueType>\n+    inline const _ValueType* any_cast(const any* __any) noexcept\n+    {\n+      if (__any)\n+\treturn static_cast<_ValueType*>(__any_caster<_ValueType>(__any));\n+      return nullptr;\n+    }\n+\n+  /**\n+   * @brief Access the contained object.\n+   *\n+   * @tparam  _ValueType  The type of the contained object.\n+   * @param   __any       A pointer to the object to access.\n+   * @return  The address of the contained object if <code>\n+   *          __any != nullptr && __any.type() == typeid(_ValueType)\n+   *          </code>, otherwise a null pointer.\n+   */\n+  template<typename _ValueType>\n+    inline _ValueType* any_cast(any* __any) noexcept\n+    {\n+      if (__any)\n+\treturn static_cast<_ValueType*>(__any_caster<_ValueType>(__any));\n+      return nullptr;\n+    }\n+\n+#ifdef __GXX_RTTI\n+  template<typename _Tp, typename _Alloc>\n+    struct any::_Manager_alloc<_Tp, _Alloc>::_Data\n+    {\n+      using _Traits = std::allocator_traits<_Alloc>;\n+\n+      std::tuple<_Alloc, __gnu_cxx::__aligned_buffer<_Tp>> _M_data;\n+\n+      _Alloc&       _M_alloc()       { return std::get<0>(_M_data); }\n+      const _Alloc& _M_alloc() const { return std::get<0>(_M_data); }\n+\n+      _Tp*       _M_obj()       { return std::get<1>(_M_data)._M_ptr(); }\n+      const _Tp* _M_obj() const { return std::get<1>(_M_data)._M_ptr(); }\n+\n+      template<typename _Up>\n+\t_Data(const _Alloc& __a, _Up&& __val) : _M_data(__a, nullptr)\n+\t{\n+\t  this->_M_construct(std::__use_alloc<_Tp>(_M_alloc()),\n+\t\t\t     std::forward<_Up>(__val));\n+\t}\n+\n+      ~_Data() { _Traits::destroy(_M_alloc(), _M_obj()); }\n+\n+      template<typename _Up>\n+\tvoid\n+\t_M_construct(__uses_alloc0, _Up&& __val)\n+\t{\n+\t  _Traits::construct(_M_alloc(), _M_obj(),\n+\t\t\t     std::forward<_Up>(__val));\n+\t}\n+\n+      template<typename _Up>\n+\tvoid\n+\t_M_construct(__uses_alloc1<_Alloc> __a, _Up&& __val)\n+\t{\n+\t  _Traits::construct(__a._M_a, _M_obj(),\n+\t\t\t     std::allocator_arg, __a._M_a,\n+\t\t\t     std::forward<_Up>(__val));\n+\t}\n+\n+      template<typename _Up>\n+\tvoid\n+\t_M_construct(__uses_alloc2<_Alloc> __a, _Up&& __val)\n+\t{\n+\t  _Traits::construct(__a._M_a, _M_obj(),\n+\t\t\t     std::forward<_Up>(__val), __a._M_a);\n+\t}\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+  template<typename _Up>\n+    any::_Storage\n+    any::_Manager_alloc<_Tp, _Alloc>::\n+    _S_alloc(const _Alloc& __a, _Up&& __value)\n+    {\n+      typename _Traits::allocator_type __a2(__a);\n+      auto __ptr = _Traits::allocate(__a2, 1);\n+      __try\n+\t{\n+\t  any::_Storage __storage;\n+\t  __storage._M_ptr = std::__addressof(*__ptr);\n+\t  ::new(__storage._M_ptr) _Data{__a, std::forward<_Up>(__value)};\n+\t  return __storage;\n+\t}\n+      __catch(...)\n+\t{\n+\t  _Traits::deallocate(__a2, __ptr, 1);\n+\t  __throw_exception_again;\n+\t}\n+    }\n+#endif\n+\n+  template<typename _Tp>\n+    void\n+    any::_Manager_internal<_Tp>::\n+    _S_manage(_Op __which, const any* __any, _Arg* __arg)\n+    {\n+      // The contained object is in _M_storage._M_buffer\n+      auto __ptr = reinterpret_cast<const _Tp*>(&__any->_M_storage._M_buffer);\n+      switch (__which)\n+      {\n+      case _Op_access:\n+\t__arg->_M_obj = const_cast<_Tp*>(__ptr);\n+\tbreak;\n+      case _Op_get_type_info:\n+#ifdef __GXX_RTTI\n+\t__arg->_M_typeinfo = &typeid(_Tp);\n+#endif\n+\tbreak;\n+      case _Op_clone:\n+\t::new(&__arg->_M_any->_M_storage._M_buffer) _Tp(*__ptr);\n+\tbreak;\n+      case _Op_destroy:\n+\t__ptr->~_Tp();\n+\tbreak;\n+      }\n+    }\n+\n+  template<typename _Tp>\n+    void\n+    any::_Manager_external<_Tp>::\n+    _S_manage(_Op __which, const any* __any, _Arg* __arg)\n+    {\n+      // The contained object is *_M_storage._M_ptr\n+      auto __ptr = static_cast<const _Tp*>(__any->_M_storage._M_ptr);\n+      switch (__which)\n+      {\n+      case _Op_access:\n+\t__arg->_M_obj = const_cast<_Tp*>(__ptr);\n+\tbreak;\n+      case _Op_get_type_info:\n+#ifdef __GXX_RTTI\n+\t__arg->_M_typeinfo = &typeid(_Tp);\n+#endif\n+\tbreak;\n+      case _Op_clone:\n+\t__arg->_M_any->_M_storage._M_ptr = new _Tp(*__ptr);\n+\tbreak;\n+      case _Op_destroy:\n+\tdelete __ptr;\n+\tbreak;\n+      }\n+    }\n+\n+#ifdef __GXX_RTTI\n+  template<typename _Tp, typename _Alloc>\n+    void\n+    any::_Manager_alloc<_Tp, _Alloc>::\n+    _S_manage(_Op __which, const any* __any, _Arg* __arg)\n+    {\n+      // The contained object is at _M_storage._M_ptr->_M_obj()\n+      auto __ptr = static_cast<const _Data*>(__any->_M_storage._M_ptr);\n+      switch (__which)\n+      {\n+      case _Op_access:\n+\t__arg->_M_obj = const_cast<_Tp*>(__ptr->_M_obj());\n+\tbreak;\n+      case _Op_get_type_info:\n+\t__arg->_M_typeinfo = &typeid(_Tp);\n+\tbreak;\n+      case _Op_clone:\n+\t__arg->_M_any->_M_storage\n+\t  = _S_alloc(__ptr->_M_alloc(), *__ptr->_M_obj());\n+\tbreak;\n+      case _Op_destroy:\n+\t{\n+\t  using _PtrTr = pointer_traits<typename _Traits::pointer>;\n+\t  typename _Traits::allocator_type __a(__ptr->_M_alloc());\n+\t  auto __alloc_ptr = _PtrTr::pointer_to(*const_cast<_Data*>(__ptr));\n+\t  __ptr->~_Data();\n+\t  _Traits::deallocate(__a, __alloc_ptr, 1);\n+\t}\n+\tbreak;\n+      }\n+    }\n+#endif\n+\n+  // @} group any\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace any_v1\n+} // namespace experimental\n+} // namespace std\n+\n+#endif // C++14\n+\n+#endif // _GLIBCXX_EXPERIMENTAL_ANY"}, {"sha": "783a8740269b9d31212d94824c04d796a1e47046", "filename": "libstdc++-v3/include/ext/aligned_buffer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2Fext%2Faligned_buffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Finclude%2Fext%2Faligned_buffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Faligned_buffer.h?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -47,6 +47,11 @@ namespace __gnu_cxx\n \tstd::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type\n \t_M_storage;\n \n+      __aligned_buffer() = default;\n+\n+      // Can be used to avoid value-initialization\n+      __aligned_buffer(std::nullptr_t) { }\n+\n       void*\n       _M_addr() noexcept\n       {"}, {"sha": "9845d5cc32a75aa67f4e57744cd08d21e8a5ea39", "filename": "libstdc++-v3/testsuite/experimental/any/assign/1.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F1.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+\n+void test01()\n+{\n+  any x;\n+  any y;\n+  y = x;\n+  VERIFY( x.empty() );\n+  VERIFY( y.empty() );\n+\n+  y = std::move(x);\n+  VERIFY( x.empty() );\n+  VERIFY( y.empty() );\n+}\n+\n+void test02()\n+{\n+  any x(1);\n+  any y;\n+  y = x;\n+  VERIFY( !x.empty() );\n+  VERIFY( !y.empty() );\n+\n+  x = std::move(y);\n+  VERIFY( !x.empty() );\n+  VERIFY( y.empty() );\n+\n+  x = y;\n+  VERIFY( x.empty() );\n+  VERIFY( y.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "1aa6f39a0109254519c376b23be321fcf7fd0faf", "filename": "libstdc++-v3/testsuite/experimental/any/assign/2.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fassign%2F2.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+using std::experimental::any_cast;\n+\n+struct X\n+{\n+  bool moved = false;\n+  bool moved_from = false;\n+  X() = default;\n+  X(const X&) = default;\n+  X(X&& x) : moved(true) { x.moved_from = true; }\n+};\n+\n+void test01()\n+{\n+  X x;\n+  any a1;\n+  a1 = x;\n+  VERIFY(x.moved_from == false);\n+  any a2;\n+  a2 = std::move(x);\n+  VERIFY(x.moved_from == true);\n+  VERIFY(any_cast<X&>(a2).moved == true );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "cc3698013dc52448b04d6e9293c27b5261900538", "filename": "libstdc++-v3/testsuite/experimental/any/cons/1.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F1.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+\n+void test01()\n+{\n+  any x;\n+  VERIFY( x.empty() );\n+\n+  any y(x);\n+  VERIFY( x.empty() );\n+  VERIFY( y.empty() );\n+\n+  any z(std::move(y));\n+  VERIFY( y.empty() );\n+  VERIFY( z.empty() );\n+}\n+\n+void test02()\n+{\n+  any x(1);\n+  VERIFY( !x.empty() );\n+\n+  any y(x);\n+  VERIFY( !x.empty() );\n+  VERIFY( !y.empty() );\n+\n+  any z(std::move(y));\n+  VERIFY( y.empty() );\n+  VERIFY( !z.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "c766edf89e518e8aa95195f7fb1eb9286335aae8", "filename": "libstdc++-v3/testsuite/experimental/any/cons/2.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F2.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+using std::experimental::any_cast;\n+\n+struct X\n+{\n+  bool moved = false;\n+  bool moved_from = false;\n+  X() = default;\n+  X(const X&) = default;\n+  X(X&& x) : moved(true) { x.moved_from = true; }\n+};\n+\n+void test01()\n+{\n+  X x;\n+  any a1(x);\n+  VERIFY(x.moved_from == false);\n+  any a2(std::move(x));\n+  VERIFY(x.moved_from == true);\n+  VERIFY(any_cast<X&>(a2).moved == true );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "671a178bca2a7c1108b1a7eceef0cf975629de3a", "filename": "libstdc++-v3/testsuite/experimental/any/cons/3.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fcons%2F3.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,83 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_allocator.h>\n+\n+using std::experimental::any;\n+using __gnu_test::CustomPointerAlloc;\n+using __gnu_test::tracker_allocator;\n+using __gnu_test::tracker_allocator_counter;\n+\n+struct NotSmall { char c[64]; };\n+\n+bool test [[gnu::unused]] = true;\n+\n+void test01()\n+{\n+  CustomPointerAlloc<int> alloc;\n+\n+  any x(std::allocator_arg, alloc, 1);\n+  VERIFY( !x.empty() );\n+\n+  any y(std::allocator_arg, alloc, std::move(x));\n+  VERIFY( x.empty() );\n+  VERIFY( !y.empty() );\n+}\n+\n+void test02()\n+{\n+  tracker_allocator<int> alloc;\n+\n+  any x(std::allocator_arg, alloc, 1);\n+  auto allocated = tracker_allocator_counter::get_allocation_count();\n+  VERIFY( allocated == 0 );  // no allocation for small object\n+\n+  any y(std::allocator_arg, alloc, std::move(x));\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == 0 );\n+\n+  y = {};\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == 0 );\n+}\n+\n+void test03()\n+{\n+  tracker_allocator<int> alloc;\n+\n+\n+  any x(std::allocator_arg, alloc, NotSmall{});\n+  auto allocated = tracker_allocator_counter::get_allocation_count();\n+  __builtin_printf(\"ALLOCATED %lu\\n\", (unsigned long)allocated);\n+  VERIFY( allocated >= sizeof(NotSmall) );\n+\n+  any y(std::allocator_arg, alloc, std::move(x));\n+  VERIFY( tracker_allocator_counter::get_allocation_count() == allocated );\n+\n+  y = {};\n+  VERIFY( tracker_allocator_counter::get_deallocation_count() == allocated );\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "98de1bc63df51938a23fedf7c7fb433d17fe3a04", "filename": "libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,108 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <string>\n+#include <cstring>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+using std::experimental::any_cast;\n+\n+void test01()\n+{\n+  using std::string;\n+  using std::strcmp;\n+\n+  // taken from example in N3804 proposal\n+\n+  any x(5);                                   // x holds int\n+  VERIFY(any_cast<int>(x) == 5);              // cast to value\n+  any_cast<int&>(x) = 10;                     // cast to reference\n+  VERIFY(any_cast<int>(x) == 10); \n+\n+  x = \"Meow\";                                 // x holds const char*\n+  VERIFY(strcmp(any_cast<const char*>(x), \"Meow\") == 0);\n+  any_cast<const char*&>(x) = \"Harry\";\n+  VERIFY(strcmp(any_cast<const char*>(x), \"Harry\") == 0);\n+\n+  x = string(\"Meow\");                         // x holds string\n+  string s, s2(\"Jane\");\n+  s = move(any_cast<string&>(x));             // move from any \n+  VERIFY(s == \"Meow\");\n+  any_cast<string&>(x) = move(s2);            // move to any\n+  VERIFY(any_cast<const string&>(x) == \"Jane\");\n+\n+  string cat(\"Meow\");\n+  const any y(cat);                           // const y holds string\n+  VERIFY(any_cast<const string&>(y) == cat);\n+}\n+\n+void test02()\n+{\n+  using std::experimental::bad_any_cast;\n+  any x(1);\n+  auto p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  x = 1.0;\n+  p = any_cast<double>(&x);\n+  VERIFY(p != nullptr);\n+\n+  x = any();\n+  p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  try {\n+    any_cast<double>(x);\n+    VERIFY(false);\n+  } catch (const bad_any_cast&) {\n+  }\n+}\n+\n+void test03()\n+{\n+  using std::experimental::bad_any_cast;\n+  any x(std::allocator_arg, std::allocator<double>{}, 1);\n+  auto p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  x = any(std::allocator_arg, std::allocator<int>{}, 1.0);\n+  p = any_cast<double>(&x);\n+  VERIFY(p != nullptr);\n+\n+  x = any(std::allocator_arg, std::allocator<char>{});\n+  p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  try {\n+    any_cast<double>(x);\n+    VERIFY(false);\n+  } catch (const bad_any_cast&) {\n+  }\n+}\n+\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}, {"sha": "b93b0396640adb4ea7035aa296f9134b5577ffb9", "filename": "libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_neg.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+\n+void test01()\n+{\n+  using std::experimental::any;\n+  using std::experimental::any_cast;\n+\n+  const any y(1);\n+  any_cast<int&>(y); // { dg-error \"qualifiers\" \"\" { target { *-*-* } } 381 }\n+}"}, {"sha": "4879e6368fc48ddf6c2a71a45b9f589c23552ca2", "filename": "libstdc++-v3/testsuite/experimental/any/misc/any_cast_no_rtti.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_no_rtti.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_no_rtti.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fany_cast_no_rtti.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,54 @@\n+// { dg-options \"-std=gnu++14 -fno-rtti\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <string>\n+#include <cstring>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+using std::experimental::any_cast;\n+\n+void test01()\n+{\n+  using std::experimental::bad_any_cast;\n+  any x(1);\n+  auto p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  x = 1.0;\n+  p = any_cast<double>(&x);\n+  VERIFY(p != nullptr);\n+\n+  x = any();\n+  p = any_cast<double>(&x);\n+  VERIFY(p == nullptr);\n+\n+  try {\n+    any_cast<double>(x);\n+    VERIFY(false);\n+  } catch (const bad_any_cast&) {\n+  }\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "1faaee82e1ca89518be0ffdb0cc59ea4408681dc", "filename": "libstdc++-v3/testsuite/experimental/any/misc/swap.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fswap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fswap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmisc%2Fswap.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+\n+void test01()\n+{\n+  any x(1);\n+  any y;\n+  swap(x, y);\n+  VERIFY( x.empty() );\n+  VERIFY( !y.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "9e6c3edb3d5eb957e05af2f07145750437a95f09", "filename": "libstdc++-v3/testsuite/experimental/any/modifiers/1.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmodifiers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmodifiers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fmodifiers%2F1.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,44 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+\n+void test01()\n+{\n+  any x(1);\n+  any y;\n+  x.swap(y);\n+  VERIFY( x.empty() );\n+  VERIFY( !y.empty() );\n+  x.swap(y);\n+  VERIFY( !x.empty() );\n+  VERIFY( y.empty() );\n+\n+  x.clear();\n+  VERIFY( x.empty() );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}, {"sha": "9784ca0c94b8554ef708197143e3701a2a65a293", "filename": "libstdc++-v3/testsuite/experimental/any/observers/type.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fobservers%2Ftype.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8043fa674add9511ee418536ad48161bd206372/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fobservers%2Ftype.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fany%2Fobservers%2Ftype.cc?ref=e8043fa674add9511ee418536ad48161bd206372", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++14\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/any>\n+#include <testsuite_hooks.h>\n+\n+using std::experimental::any;\n+\n+void test01()\n+{\n+  any x;\n+  VERIFY( x.type() == typeid(void) );\n+  x = 1;\n+  VERIFY( x.type() == typeid(int) );\n+  x = any();\n+  VERIFY( x.type() == typeid(void) );\n+}\n+\n+int main()\n+{\n+  test01();\n+}"}]}