{"sha": "c0220ea4c509e3c14cef20c864545340aa4b98b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzAyMjBlYTRjNTA5ZTNjMTRjZWYyMGM4NjQ1NDUzNDBhYTRiOThiNA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-03-04T23:05:24Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-03-04T23:05:24Z"}, "message": "builtins.c, [...]: Fix comment typos.\n\n\t* builtins.c, c-pragma.h, c-typeck.c, cgraph.c, cgraphunit.c,\n\tcombine.c, common.opt, config/dfp-bit.c, config/i386/i386.c,\n\tconfig/m68k/m68k.c, config/m68k/m68k.md, config/mt/mt.c,\n\tconfig/mt/mt.h, config/s390/s390.md, df-core.c, df-problems.c,\n\tdf-scan.c, df.h, diagnostic.c, expr.c, function.h, gimplify.c,\n\tloop-invariant.c, omp-low.c, opts.c, passes.c,\n\trtl-factoring.c, rtlanal.c, struct-equiv.c, tree-cfgcleanup.c,\n\ttree-ssa-loop-niter.c, tree-ssa-loop-prefetch.c,\n\ttree-ssa-structalias.c, tree-ssa-threadedge.c,\n\ttree-ssa-threadupdate.c, tree-vect-patterns.c,\n\ttree-vect-transform.c, tree-vectorizer.h, tree-vrp.c,\n\tunwind-dw2.c: Fix comment typos.  Follow spelling conventions.\n\nFrom-SVN: r111721", "tree": {"sha": "4350c209f16fe5635562cd7e6a9850c631419372", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4350c209f16fe5635562cd7e6a9850c631419372"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0220ea4c509e3c14cef20c864545340aa4b98b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0220ea4c509e3c14cef20c864545340aa4b98b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0220ea4c509e3c14cef20c864545340aa4b98b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0220ea4c509e3c14cef20c864545340aa4b98b4/comments", "author": null, "committer": null, "parents": [{"sha": "8156c8b0b9a1880ea8501385d035dbf9ae990306", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8156c8b0b9a1880ea8501385d035dbf9ae990306", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8156c8b0b9a1880ea8501385d035dbf9ae990306"}], "stats": {"total": 153, "additions": 84, "deletions": 69}, "files": [{"sha": "e6fa6830c32e3f247f5c26e8e83d5863381299dd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -1,3 +1,18 @@\n+2006-03-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* builtins.c, c-pragma.h, c-typeck.c, cgraph.c, cgraphunit.c,\n+\tcombine.c, common.opt, config/dfp-bit.c, config/i386/i386.c,\n+\tconfig/m68k/m68k.c, config/m68k/m68k.md, config/mt/mt.c,\n+\tconfig/mt/mt.h, config/s390/s390.md, df-core.c, df-problems.c,\n+\tdf-scan.c, df.h, diagnostic.c, expr.c, function.h, gimplify.c,\n+\tloop-invariant.c, omp-low.c, opts.c, passes.c,\n+\trtl-factoring.c, rtlanal.c, struct-equiv.c, tree-cfgcleanup.c,\n+\ttree-ssa-loop-niter.c, tree-ssa-loop-prefetch.c,\n+\ttree-ssa-structalias.c, tree-ssa-threadedge.c,\n+\ttree-ssa-threadupdate.c, tree-vect-patterns.c,\n+\ttree-vect-transform.c, tree-vectorizer.h, tree-vrp.c,\n+\tunwind-dw2.c: Fix comment typos.  Follow spelling conventions.\n+\n 2006-03-04  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* dwarf2out.c (dwarf2out_add_library_unit_info): Remove."}, {"sha": "f6095e84bed3db8cb8b2700aae47a4d5766d2e8a", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -498,7 +498,7 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n \n   /* For a zero count, we don't care what frame address we return, so frame\n      pointer elimination is OK, and using the soft frame pointer is OK.\n-     For a non-zero count, we require a stable offset from the current frame\n+     For a nonzero count, we require a stable offset from the current frame\n      pointer to the previous one, so we must use the hard frame pointer, and\n      we must disable frame pointer elimination.  */\n   if (count == 0)"}, {"sha": "5868f07251cce8ba4fcd881d83ca2a1725cf135e", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -25,7 +25,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include <cpplib.h> /* For enum cpp_ttype.  */\n \n /* Pragma identifiers built in to the front end parsers.  Identifiers\n-   for anciliary handlers will follow these.  */\n+   for ancillary handlers will follow these.  */\n typedef enum pragma_kind {\n   PRAGMA_NONE = 0,\n "}, {"sha": "98eeacd552a0380b1b8a9ebcca04c40cd6b20843", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -8456,7 +8456,7 @@ c_expr_to_decl (tree expr, bool *tc ATTRIBUTE_UNUSED,\n }\n \n \f\n-/* Like c_begin_compound_stmt, except force the retension of the BLOCK.  */\n+/* Like c_begin_compound_stmt, except force the retention of the BLOCK.  */\n \n tree\n c_begin_omp_parallel (void)"}, {"sha": "6a8ac08aeff4602cdb3b6bee11de74b77b4a8c6a", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -114,7 +114,7 @@ struct cgraph_node *cgraph_nodes;\n struct cgraph_node *cgraph_nodes_queue;\n \n /* Queue of cgraph nodes scheduled to be expanded.  This is a\n-   secondary queue used during optimization to accomodate passes that\n+   secondary queue used during optimization to accommodate passes that\n    may generate new functions that need to be optimized and expanded.  */\n struct cgraph_node *cgraph_expand_queue;\n "}, {"sha": "80f26fac52a1cfe9aacf0b40e68a44beaef5ec49", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -1692,7 +1692,7 @@ save_inline_function_body (struct cgraph_node *node)\n   cgraph_lower_function (node);\n \n   /* In non-unit-at-a-time we construct full fledged clone we never output to\n-     assembly file.  This clone is pointed out by inline_decl of orginal function\n+     assembly file.  This clone is pointed out by inline_decl of original function\n      and inlining infrastructure knows how to deal with this.  */\n   if (!flag_unit_at_a_time)\n     {"}, {"sha": "74b01cbc014413b59760889787fc93f62aeef125", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -11123,7 +11123,7 @@ record_truncated_value (rtx x)\n \n       x = SUBREG_REG (x);\n     }\n-  /* ??? For hard-regs we now record everthing.  We might be able to\n+  /* ??? For hard-regs we now record everything.  We might be able to\n      optimize this using last_set_mode.  */\n   else if (REG_P (x) && REGNO (x) < FIRST_PSEUDO_REGISTER)\n     truncated_mode = GET_MODE (x);"}, {"sha": "5b00a7bd0f9e578211c76bb6ae57d1c1843120ea", "filename": "gcc/common.opt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -557,7 +557,7 @@ Give external symbols a leading underscore\n \n floop-optimize\n Common\n-Does nothing.  Preserved for backward compatability.\n+Does nothing.  Preserved for backward compatibility.\n \n fmath-errno\n Common Report Var(flag_errno_math) Init(1)\n@@ -723,7 +723,7 @@ Add a common subexpression elimination pass after loop optimizations\n \n frerun-loop-opt\n Common\n-Does nothing.  Preserved for backward compatability.\n+Does nothing.  Preserved for backward compatibility.\n \n frounding-math\n Common Report Var(flag_rounding_math)\n@@ -842,7 +842,7 @@ Use a stack protection method for every function\n \n fstrength-reduce\n Common\n-Does nothing.  Preserved for backward compatability.\n+Does nothing.  Preserved for backward compatibility.\n \n ; Nonzero if we should do (language-dependent) alias analysis.\n ; Typically, this analysis will assume that expressions of certain"}, {"sha": "271bfb5627ac3ba17101e72e9caa4af2c6979369", "filename": "gcc/config/dfp-bit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fdfp-bit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fdfp-bit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdfp-bit.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -415,7 +415,7 @@ DFP_TO_INT (DFP_C_TYPE x)\n   decNumberFromString (&qval, (char *) \"1.0\", &context);\n   /* Force the exponent to zero.  */\n   decNumberQuantize (&n1, &n2, &qval, &context);\n-  /* This is based on text in N1107 secton 5.1; it might turn out to be\n+  /* This is based on text in N1107 section 5.1; it might turn out to be\n      undefined behavior instead.  */\n   if (context.status & DEC_Invalid_operation)\n     {\n@@ -510,7 +510,7 @@ BFP_TO_DFP (BFP_TYPE x)\n \n   /* Use a C library function to write the floating point value to a string.  */\n #ifdef BFP_VIA_TYPE\n-  /* FIXME: Is threre a better way to output an XFmode variable in C?  */\n+  /* FIXME: Is there a better way to output an XFmode variable in C?  */\n   sprintf (buf, BFP_FMT, (BFP_VIA_TYPE) x);\n #else\n   sprintf (buf, BFP_FMT, x);"}, {"sha": "7758f430a149b1bbc70794f0604b579d79b2d5d5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -742,7 +742,7 @@ const int x86_use_sahf = m_PPRO | m_K6 | m_PENT4 | m_NOCONA | m_GENERIC32; /*m_G\n /* We probably ought to watch for partial register stalls on Generic32\n    compilation setting as well.  However in current implementation the\n    partial register stalls are not eliminated very well - they can\n-   be introduced via subregs synthetized by combine and can happen\n+   be introduced via subregs synthesized by combine and can happen\n    in caller/callee saving sequences.\n    Because this option pays back little on PPro based chips and is in conflict\n    with partial reg. dependencies used by Athlon/P4 based chips, it is better\n@@ -777,7 +777,7 @@ const int x86_prologue_using_move = m_ATHLON_K8 | m_PPRO | m_GENERIC;\n const int x86_epilogue_using_move = m_ATHLON_K8 | m_PPRO | m_GENERIC;\n const int x86_shift1 = ~m_486;\n const int x86_arch_always_fancy_math_387 = m_PENT | m_PPRO | m_ATHLON_K8 | m_PENT4 | m_NOCONA | m_GENERIC;\n-/* In Generic model we have an confict here in between PPro/Pentium4 based chips\n+/* In Generic model we have an conflict here in between PPro/Pentium4 based chips\n    that thread 128bit SSE registers as single units versus K8 based chips that\n    divide SSE registers to two 64bit halves.\n    x86_sse_partial_reg_dependency promote all store destinations to be 128bit"}, {"sha": "7b3a8ed43b791825344f6262de8cbfbcf0ba8e79", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -2342,7 +2342,7 @@ fp_reg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n    normally.\n \n    Note SCRATCH_REG may not be in the proper mode depending on how it\n-   will be used.  This routine is resposible for creating a new copy\n+   will be used.  This routine is responsible for creating a new copy\n    of SCRATCH_REG in the proper mode.  */\n \n int\n@@ -3647,7 +3647,7 @@ m68k_regno_mode_ok (int regno, enum machine_mode mode)\n /* Return floating point values in a 68881 register.  This makes 68881 code\n    a little bit faster.  It also makes -msoft-float code incompatible with\n    hard-float code, so people have to be careful not to mix the two.\n-   For ColdFire it was decided the ABI incopmatibility is undesirable.\n+   For ColdFire it was decided the ABI incompatibility is undesirable.\n    If there is need for a hard-float ABI it is probably worth doing it\n    properly and also passing function arguments in FP registers.  */\n rtx"}, {"sha": "6bbeff293c1893380ab4f9f8ed5380b4f59fac54", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -138,7 +138,7 @@\n (define_mode_attr round [(SF \"%$\") (DF \"%&\") (XF \"\")])\n ;; Mnemonic infix to round result for mul or div instruction\n (define_mode_attr round_mul [(SF \"sgl\") (DF \"%&\") (XF \"\")])\n-;; Suffix specifiying source operand format\n+;; Suffix specifying source operand format\n (define_mode_attr prec [(SF \"s\") (DF \"d\") (XF \"x\")])\n ;; Allowable D registers\n (define_mode_attr dreg [(SF \"d\") (DF \"\") (XF \"\")])"}, {"sha": "44c494ee99e09edbba9889ed708985a20828eaab", "filename": "gcc/config/mt/mt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fmt%2Fmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fmt%2Fmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -683,7 +683,7 @@ mt_legitimate_simple_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n }\n \n \n-/* Helper function of GO_IF_LEGITIMATE_ADDRESS.  Return non-zero if\n+/* Helper function of GO_IF_LEGITIMATE_ADDRESS.  Return nonzero if\n    XINSN is a legitimate address on MT.  */\n int\n mt_legitimate_address_p (enum machine_mode mode, rtx xinsn, int strict)\n@@ -1648,9 +1648,9 @@ void mt_add_loop (void)\n }\n \n \n-/* Maxium loop nesting depth.  */\n+/* Maximum loop nesting depth.  */\n #define MAX_LOOP_DEPTH 4\n-/* Maxium size of a loop (allows some headroom for delayed branch slot\n+/* Maximum size of a loop (allows some headroom for delayed branch slot\n    filling.  */\n #define MAX_LOOP_LENGTH (200 * 4)\n \n@@ -1850,7 +1850,7 @@ mt_scan_loop (loop_info loop, rtx reg, rtx dbnz)\n    loop iterations.  It can be nested with an automatically maintained\n    stack of counter and end address registers.  It's an ideal\n    candidate for doloop.  Unfortunately, gcc presumes that loops\n-   always end with an explicit instriction, and the doloop_begin\n+   always end with an explicit instruction, and the doloop_begin\n    instruction is not a flow control instruction so it can be\n    scheduled earlier than just before the start of the loop.  To make\n    matters worse, the optimization pipeline can duplicate loop exit"}, {"sha": "90d98ac47dced4b9e3d5d48c70f97a798b5cf550", "filename": "gcc/config/mt/mt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fmt%2Fmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fmt%2Fmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmt%2Fmt.h?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -512,7 +512,7 @@ extern struct mt_frame_info current_frame_info;\n   {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}\t\t\t\t\\\n }\n \n-/* A C expression that returns non-zero if the compiler is allowed to try to\n+/* A C expression that returns nonzero if the compiler is allowed to try to\n    replace register number FROM with register number TO.  */\n #define CAN_ELIMINATE(FROM, TO)\t\t\t\t\t\t\\\n  ((FROM) == ARG_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM\t\t\\"}, {"sha": "c03f8808b5555057eb1a00f51c8f653b84037594", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -454,7 +454,7 @@\n ; Load-and-Test instructions\n ;\n \n-; tst(di|si) intruction pattern(s).\n+; tst(di|si) instruction pattern(s).\n \n (define_insn \"*tstdi_sign\"\n   [(set (reg CC_REGNUM)\n@@ -542,7 +542,7 @@\n   \"lt<g>r\\t%0,%0\"\n   [(set_attr \"op_type\" \"RR<E>\")])\n \n-; tst(hi|qi) intruction pattern(s).\n+; tst(hi|qi) instruction pattern(s).\n \n (define_insn \"*tst<mode>CCT\"\n   [(set (reg CC_REGNUM)"}, {"sha": "06b108549e8e3ab146a046d48ae88d53cfef0c10", "filename": "gcc/df-core.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -80,12 +80,12 @@ calls to add a problem for a given instance of df must occur before\n the first call to DF_RESCAN_BLOCKS or DF_ANALYZE.\n \n For all of the problems defined in df-problems.c, there are\n-convienence functions named DF_*_ADD_PROBLEM.\n+convenience functions named DF_*_ADD_PROBLEM.\n \n \n Problems can be dependent on other problems.  For instance, solving\n def-use or use-def chains is dependant on solving reaching\n-definitions. As long as these dependancies are listed in the problem\n+definitions. As long as these dependencies are listed in the problem\n definition, the order of adding the problems is not material.\n Otherwise, the problems will be solved in the order of calls to\n df_add_problem.  Note that it is not necessary to have a problem.  In\n@@ -100,7 +100,7 @@ to analyze the entire function and no call to df_set_blocks is made.\n When a subset is given, the analysis behaves as if the function only\n contains those blocks and any edges that occur directly between the\n blocks in the set.  Care should be taken to call df_set_blocks right\n-before the call to analyze in order to eliminate the possiblity that\n+before the call to analyze in order to eliminate the possibility that\n optimizations that reorder blocks invalidate the bitvector.\n \n \n@@ -220,7 +220,7 @@ There are 4 ways to obtain access to refs:\n      register and are put there to keep the code from forgetting about\n      them.\n \n-     Artifical defs occur at the end of the entry block.  These arise\n+     Artificial defs occur at the end of the entry block.  These arise\n      from registers that are live at entry to the function.\n \n 2) All of the uses and defs associated with each pseudo or hard"}, {"sha": "a0422f8307b9d303e19bbadfc5f6dfb0d666966d", "filename": "gcc/df-problems.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -184,7 +184,7 @@ df_get_live_out (struct df *df, basic_block bb)\n ----------------------------------------------------------------------------*/\n \n /* Generic versions to get the void* version of the block info.  Only\n-   used inside the problem instace vectors.  */\n+   used inside the problem instance vectors.  */\n \n /* Grow the bb_info array.  */\n \n@@ -2781,7 +2781,7 @@ df_chain_bb_reset (struct dataflow *dflow, unsigned int bb_index)\n \t}\n     }\n   \n-  /* Get rid of any chains in artifical uses or defs.  */\n+  /* Get rid of any chains in artificial uses or defs.  */\n   if (problem_data->flags & DF_DU_CHAIN)\n     {\n       struct df_ref *def;"}, {"sha": "1ed153d6396b15890bfdc18c90df625b1cc5e577", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -549,7 +549,7 @@ df_ref_create (struct df *df, rtx reg, rtx *loc, rtx insn,\n ----------------------------------------------------------------------------*/\n \n \n-/* Get the artifical uses for a basic block.  */\n+/* Get the artificial uses for a basic block.  */\n \n struct df_ref *\n df_get_artificial_defs (struct df *df, unsigned int bb_index)\n@@ -559,7 +559,7 @@ df_get_artificial_defs (struct df *df, unsigned int bb_index)\n }\n \n \n-/* Get the artifical uses for a basic block.  */\n+/* Get the artificial uses for a basic block.  */\n \n struct df_ref *\n df_get_artificial_uses (struct df *df, unsigned int bb_index)\n@@ -797,7 +797,7 @@ df_bb_refs_delete (struct dataflow *dflow, int bb_index)\n \t}\n     }\n   \n-  /* Get rid of any artifical uses or defs.  */\n+  /* Get rid of any artificial uses or defs.  */\n   if (bb_info)\n     {\n       def = bb_info->artificial_defs;"}, {"sha": "720bbfadece08c1bb508253805525a4fd0f9b00d", "filename": "gcc/df.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -271,7 +271,7 @@ struct df_ref_info\n   unsigned int bitmap_size;\t/* Number of refs seen.  */\n \n   /* True if refs table is organized so that every reference for a\n-     pseudo is contigious.  */\n+     pseudo is contiguous.  */\n   bool refs_organized;\n   /* True if the next refs should be added immediately or false to\n      defer to later to reorganize the table.  */"}, {"sha": "b671b1a38ca8909c8e6449773b2bb3cb5d006238", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -383,7 +383,7 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \t option.  */\n       if (context->classify_diagnostic[diagnostic->option_index] != DK_UNSPECIFIED)\n \tdiagnostic->kind = context->classify_diagnostic[diagnostic->option_index];\n-      /* This allows for future extenions, like temporarily disabling\n+      /* This allows for future extensions, like temporarily disabling\n \t warnings for ranges of source code.  */\n       if (diagnostic->kind == DK_IGNORED)\n \treturn;"}, {"sha": "e3cb784f187a72a3054b05054e9708be7ef8809c", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -6282,7 +6282,7 @@ expand_operands (tree exp0, tree exp1, rtx target, rtx *op0, rtx *op1,\n }\n \n \f\n-/* Return a MEM that constains constant EXP.  DEFER is as for\n+/* Return a MEM that contains constant EXP.  DEFER is as for\n    output_constant_def and MODIFIER is as for expand_expr.  */\n \n static rtx"}, {"sha": "a904e0f19f4346e81770dafe8085a753a99e4e80", "filename": "gcc/function.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -386,7 +386,7 @@ struct function GTY(())\n   unsigned int calls_alloca : 1;\n \n   /* Nonzero if function being compiled called builtin_return_addr or\n-     builtin_frame_address with non-zero count.  */\n+     builtin_frame_address with nonzero count.  */\n   unsigned int accesses_prior_frames : 1;\n \n   /* Nonzero if the function calls __builtin_eh_return.  */"}, {"sha": "4b58201004d2aaad1824c53e722d68bb1358b0e6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -404,8 +404,8 @@ find_single_pointer_decl (tree t)\n \n   if (walk_tree (&t, find_single_pointer_decl_1, &decl, NULL))\n     {\n-      /* find_single_pointer_decl_1 returns a non-zero value, causing\n-\t walk_tree to return a non-zero value, to indicate that it\n+      /* find_single_pointer_decl_1 returns a nonzero value, causing\n+\t walk_tree to return a nonzero value, to indicate that it\n \t found more than one pointer DECL.  */\n       return NULL_TREE;\n     }\n@@ -4884,7 +4884,7 @@ gimplify_omp_atomic_fetch_op (tree *expr_p, tree addr, tree rhs, int index)\n }\n \n /* A subroutine of gimplify_omp_atomic_pipeline.  Walk *EXPR_P and replace\n-   appearences of *LHS_ADDR with LHS_VAR.  If an expression does not involve\n+   appearances of *LHS_ADDR with LHS_VAR.  If an expression does not involve\n    the lhs, evaluate it into a temporary.  Return 1 if the lhs appeared as\n    a subexpression, 0 if it did not, or -1 if an error was encountered.  */\n "}, {"sha": "2185d189a26459064e0d04677b879a47ff687386", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -936,7 +936,7 @@ get_inv_cost (struct invariant *inv, int *comp_cost, unsigned *regs_needed)\n   {\n     /* Hoisting constant pool constants into stack regs may cost more than\n        just single register.  On x87, the balance is affected both by the\n-       small number of FP registers, and by its register stack organisation,\n+       small number of FP registers, and by its register stack organization,\n        that forces us to add compensation code in and around the loop to\n        shuffle the operands to the top of stack before use, and pop them\n        from the stack after the loop finishes."}, {"sha": "0a9c96fb0de4aeb74e0850e07a59f531cfd1f5f9", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -47,7 +47,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    phases.  The first phase scans the function looking for OMP statements\n    and then for variables that must be replaced to satisfy data sharing\n    clauses.  The second phase expands code for the constructs, as well as\n-   re-gimplifing things when variables have been replaced with complex\n+   re-gimplifying things when variables have been replaced with complex\n    expressions.\n \n    Final code generation is done by pass_expand_omp.  The flowgraph is\n@@ -2042,7 +2042,7 @@ expand_parallel_call (struct omp_region *region, basic_block bb, tree ws_args)\n   clauses = OMP_PARALLEL_CLAUSES (region->entry);\n   push_gimplify_context ();\n \n-  /* Determine what flavour of GOMP_parallel_start we will be\n+  /* Determine what flavor of GOMP_parallel_start we will be\n      emitting.  */\n   start_ix = BUILT_IN_GOMP_PARALLEL_START;\n   if (is_combined_parallel (region))"}, {"sha": "00b9716a607dc45029514154f76b380872c513b4", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -1085,7 +1085,7 @@ common_handle_option (size_t scode, const char *arg, int value,\n     case OPT_floop_optimize:\n     case OPT_frerun_loop_opt:\n     case OPT_fstrength_reduce:\n-      /* These are no-ops, preserved for backward compatability.  */\n+      /* These are no-ops, preserved for backward compatibility.  */\n       break;\n \n     default:"}, {"sha": "9732b2518e9b8c8fb0561580c44b4efda35506df", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -364,7 +364,7 @@ register_dump_files_1 (struct tree_opt_pass *pass, bool ipa, int properties)\n \n /* Register the dump files for the pipeline starting at PASS.  IPA is\n    true if the pass is inter-procedural, and PROPERTIES reflects the\n-   properties that are guarenteed to be available at the beginning of\n+   properties that are guaranteed to be available at the beginning of\n    the pipeline.  */\n \n static void "}, {"sha": "021a802a4d75d13000acf1005d21e58e55aa6a8d", "filename": "gcc/rtl-factoring.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Frtl-factoring.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Frtl-factoring.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-factoring.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -125,7 +125,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    TODO:\n    - Use REG_ALLOC_ORDER when choosing link register.\n    - Handle JUMP_INSNs. Also handle volatile function calls (handle them\n-     simmilar to unconditional jumps.)\n+     similar to unconditional jumps.)\n    - Test command line option -fpic.\n */\n \n@@ -227,7 +227,7 @@ typedef struct seq_block_def\n   struct seq_block_def *next_seq_block;\n } *seq_block;\n \n-/* Contains same sequence candidates for futher searching.  */\n+/* Contains same sequence candidates for further searching.  */\n typedef struct hash_bucket_def\n {\n   /* The hash value of the group.  */\n@@ -888,7 +888,7 @@ determine_seq_blocks (void)\n         }\n \n       /* Ensure that SB contains a seq_block with the appropriate length.\n-         Insert a new seq_block if neccessary.  */\n+         Insert a new seq_block if necessary.  */\n       if (!seq_blocks || ((*mseq)->abstracted_length < seq_blocks->length))\n         {\n           sb = (seq_block) xmalloc (sizeof (struct seq_block_def));\n@@ -979,7 +979,7 @@ split_blocks_after_seqs (void)\n     }\n }\n \n-/* Splits the best pattern sequence accoring to SEQ_BLOCKS. Emits pseudo-call\n+/* Splits the best pattern sequence according to SEQ_BLOCKS. Emits pseudo-call\n    and -return insns before and after the sequence.  */\n \n static void\n@@ -1373,7 +1373,7 @@ rtl_seqabstr (void)\n   /* Iterate until there are no sequences to abstract.  */\n   for (iter = 1;; iter++)\n     {\n-      /* Recompute gain for sequences if neccessary and select sequence with\n+      /* Recompute gain for sequences if necessary and select sequence with\n          biggest gain.  */\n       recompute_gain ();\n       if (!pattern_seqs)"}, {"sha": "d740ed5b1235ee2770d3f78f66b0a052c8004a44", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -2196,7 +2196,7 @@ may_trap_after_code_motion_p (rtx x)\n   return may_trap_p_1 (x, MTP_AFTER_MOVE);\n }\n \n-/* Same as above, but additionally return non-zero if evaluating rtx X might\n+/* Same as above, but additionally return nonzero if evaluating rtx X might\n    cause a fault.  We define a fault for the purpose of this function as a\n    erroneous execution condition that cannot be encountered during the normal\n    execution of a valid program; the typical example is an unaligned memory"}, {"sha": "265cfd0fce8a63a07ff24a0260a4c4fbdf87068b", "filename": "gcc/struct-equiv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fstruct-equiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Fstruct-equiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstruct-equiv.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -483,7 +483,7 @@ rtx_equiv_p (rtx *xp, rtx y, int rvalue, struct equiv_info *info)\n \t\t   pair, use the old one.  If the width is the same, use the\n \t\t   old one if the modes match, but the new if they don't.\n \t\t   We don't want to get too fancy with subreg_regno_offset\n-\t\t   here, so we just test two straightforwad cases each.  */\n+\t\t   here, so we just test two straightforward cases each.  */\n \t\tif (info->live_update\n \t\t    && (x_mode != GET_MODE (info->x_local[i])\n \t\t\t? size >= size_i : size > size_i))"}, {"sha": "fb1ea761d32683a3d17f0225e20bf535235ea471", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -782,7 +782,7 @@ merge_phi_nodes (void)\n \t\tbreak;\n \t    }\n \n-\t  /* If the loop above iterated thorugh all the PHI nodes\n+\t  /* If the loop above iterated through all the PHI nodes\n \t     in BB, then we can merge the PHIs from BB into DEST.  */\n \t  if (!phi)\n \t    *current++ = bb;"}, {"sha": "cda02dd778328300d9f76340e5671a839fffda82", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -623,7 +623,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n \treturn false;\n     }\n \n-  /* If the loop exits immediatelly, there is nothing to do.  */\n+  /* If the loop exits immediately, there is nothing to do.  */\n   if (zero_p (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n     {\n       niter->niter = build_int_cst_type (unsigned_type_for (type), 0);"}, {"sha": "c00aaea3093d3f5cf6205ef84f1467c75ba3d641", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -115,7 +115,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* Magic constants follow.  These should be replaced by machine specific\n    numbers.  */\n \n-/* A number that should rouhgly correspond to the number of instructions\n+/* A number that should roughly correspond to the number of instructions\n    executed before the prefetch is completed.  */\n \n #ifndef PREFETCH_LATENCY\n@@ -768,7 +768,7 @@ schedule_prefetches (struct mem_ref_group *groups, unsigned unroll_factor,\n   /* For now we just take memory references one by one and issue\n      prefetches for as many as possible.  The groups are sorted\n      starting with the largest step, since the references with\n-     large step are more likely to cause many cache mises.  */\n+     large step are more likely to cause many cache misses.  */\n \n   for (; groups; groups = groups->next)\n     for (ref = groups->refs; ref; ref = ref->next)"}, {"sha": "a9032a39492e9550c446c2c85a6305c9a351eee4", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -1040,7 +1040,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n \t\t       graph->zero_weight_succs[from]);\n     }\n \n-  /* Merge all the non-zero weighted predecessor edges.  */\n+  /* Merge all the nonzero weighted predecessor edges.  */\n   for (i = 0; VEC_iterate (constraint_edge_t, predvec, i, c); i++)\n     {\n       unsigned int d = c->dest;\n@@ -1064,7 +1064,7 @@ merge_graph_nodes (constraint_graph_t graph, unsigned int to,\n       \n     }\n   \n-  /* Merge all the non-zero weighted successor edges.  */\n+  /* Merge all the nonzero weighted successor edges.  */\n   for (i = 0; VEC_iterate (constraint_edge_t, succvec, i, c); i++)\n     {\n       unsigned int d = c->dest;\n@@ -4049,7 +4049,7 @@ intra_create_variable_infos (void)\n       lhs.type = SCALAR;\n       lhs.var  = create_variable_info_for (t, alias_get_name (t));\n \n-      /* With flag_argument_noalias greater than one means that the incomming\n+      /* With flag_argument_noalias greater than one means that the incoming\n          argument cannot alias anything except for itself so create a HEAP\n          variable.  */\n       if (POINTER_TYPE_P (TREE_TYPE (t))"}, {"sha": "511eb6a624b48309fa17fe4139ac76e5ef3bf0cf", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -120,7 +120,7 @@ remove_temporary_equivalences (VEC(tree, heap) **stack)\n \n       dest = VEC_pop (tree, *stack);\n \n-      /* A NULL value indicates we should stop unwinding, oherwise\n+      /* A NULL value indicates we should stop unwinding, otherwise\n \t pop off the next entry as they're recorded in pairs.  */\n       if (dest == NULL)\n \tbreak;"}, {"sha": "4a92effb5a47f925aff2bec9ab772b3b375547aa", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -811,7 +811,7 @@ thread_block (basic_block bb)\n }\n \n /* Walk through the registered jump threads and convert them into a\n-   form convienent for this pass.\n+   form convenient for this pass.\n \n    Any block which has incoming edges threaded to outgoing edges\n    will have its entry in THREADED_BLOCK set."}, {"sha": "558908e18b12c65a87846e2fd588c21aaa0dbdec", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -41,7 +41,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"recog.h\"\n #include \"toplev.h\"\n \n-/* Funcion prototypes */\n+/* Function prototypes */\n static void vect_pattern_recog_1 \n   (tree (* ) (tree, tree *, tree *), block_stmt_iterator);\n static bool widened_name_p (tree, tree, tree *, tree *);\n@@ -133,7 +133,7 @@ widened_name_p (tree name, tree use_stmt, tree *half_type, tree *def_stmt)\n      S7  sum_1 = prod + sum_0;\n \n    where 'TYPE1' is exactly double the size of type 'type', and 'TYPE2' is the \n-   same size of 'TYPE1' or bigger. This is a sepcial case of a reduction \n+   same size of 'TYPE1' or bigger. This is a special case of a reduction \n    computation.\n       \n    Input:\n@@ -455,7 +455,7 @@ vect_recog_widen_sum_pattern (tree last_stmt, tree *type_in, tree *type_out)\n    If 'TYPE_OUT' is also returned by PATTERN_RECOG_FUNC, we check that it fits\n    to the available target pattern.\n \n-   This function also does some bookeeping, as explained in the documentation \n+   This function also does some bookkeeping, as explained in the documentation \n    for vect_recog_pattern.  */\n \n static void\n@@ -578,7 +578,7 @@ vect_pattern_recog_1 (\n    remain irrelevant unless used by stmts other than S4.\n \n    If vectorization succeeds, vect_transform_stmt will skip over {S1,S2,S3}\n-   (because they are marked as irrelevent). It will vectorize S6, and record\n+   (because they are marked as irrelevant). It will vectorize S6, and record\n    a pointer to the new vector stmt VS6 both from S6 (as usual), and also \n    from S4. We do that so that when we get to vectorizing stmts that use the\n    def of S4 (like S5 that uses a_0), we'll know where to take the relevant"}, {"sha": "2d533e67a9af4a970e4d43e81cca5bad47fb9e75", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -857,7 +857,7 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt,\n   exit_bsi = bsi_start (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3 \n-         (i.e. when reduc_code is not available) and in the final adjusment code\n+         (i.e. when reduc_code is not available) and in the final adjustment code\n          (if needed).  Also get the original scalar reduction variable as\n          defined in the loop.  In case STMT is a \"pattern-stmt\" (i.e. - it \n          represents a reduction pattern), the tree-code and scalar-def are \n@@ -2945,7 +2945,7 @@ vect_create_cond_for_align_checks (loop_vec_info loop_vinfo,\n   append_to_statement_list_force (and_stmt, cond_expr_stmt_list);\n \n   /* Make and_tmp the left operand of the conditional test against zero.\n-     if and_tmp has a non-zero bit then some address is unaligned.  */\n+     if and_tmp has a nonzero bit then some address is unaligned.  */\n   ptrsize_zero = build_int_cst (int_ptrsize_type, 0);\n   return build2 (EQ_EXPR, boolean_type_node,\n                  and_tmp_name, ptrsize_zero);"}, {"sha": "405289cba9dc29ab51ab3ce351b7eca55c483a10", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -208,7 +208,7 @@ typedef struct _stmt_vec_info {\n   /* Stmt is part of some pattern (computation idiom)  */\n   bool in_pattern_p;\n \n-  /* Used for various bookeeping purposes, generally holding a pointer to \n+  /* Used for various bookkeeping purposes, generally holding a pointer to \n      some other stmt S that is in some way \"related\" to this stmt. \n      Current use of this field is:\n         If this stmt is part of a pattern (i.e. the field 'in_pattern_p' is "}, {"sha": "7342d2960f8fcf2196844730e8c7c592339259c1", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -1058,7 +1058,7 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t     there are three cases to consider.\n \n \n-\t     1. The VR_ANTI_RANGE range is competely within the \n+\t     1. The VR_ANTI_RANGE range is completely within the \n \t\tVR_RANGE and the endpoints of the ranges are\n \t\tdifferent.  In that case the resulting range\n \t\tshould be whichever range is more precise."}, {"sha": "55a6143d370e922a05c11d0be2035e27f84600bd", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0220ea4c509e3c14cef20c864545340aa4b98b4/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=c0220ea4c509e3c14cef20c864545340aa4b98b4", "patch": "@@ -228,7 +228,7 @@ _Unwind_SetGRValue (struct _Unwind_Context *context, int index,\n   context->reg[index] = (void *) (_Unwind_Internal_Ptr) val;\n }\n \n-/* Return non-zero if register INDEX is stored by value rather than\n+/* Return nonzero if register INDEX is stored by value rather than\n    by reference.  */\n \n static inline int"}]}