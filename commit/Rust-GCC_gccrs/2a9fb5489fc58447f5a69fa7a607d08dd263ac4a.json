{"sha": "2a9fb5489fc58447f5a69fa7a607d08dd263ac4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE5ZmI1NDg5ZmM1ODQ0N2Y1YTY5ZmE3YTYwN2QwOGRkMjYzYWM0YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-03-26T17:35:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "1997-03-26T17:35:01Z"}, "message": "Add a CSE pass over the hard registers after reload is complete\n\nFrom-SVN: r13805", "tree": {"sha": "66aecf7a8aceb38fe8392993ec0dbb071045c8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66aecf7a8aceb38fe8392993ec0dbb071045c8db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a/comments", "author": null, "committer": null, "parents": [{"sha": "9d661e569a79a794ff4ccdd83a9c599fd035b8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d661e569a79a794ff4ccdd83a9c599fd035b8d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d661e569a79a794ff4ccdd83a9c599fd035b8d7"}], "stats": {"total": 673, "additions": 673, "deletions": 0}, "files": [{"sha": "a7b4238d1b5c2f1ce3c2cf3b9b9fb7124d348b48", "filename": "gcc/reload1.c", "status": "modified", "additions": 673, "deletions": 0, "changes": 673, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a9fb5489fc58447f5a69fa7a607d08dd263ac4a/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2a9fb5489fc58447f5a69fa7a607d08dd263ac4a", "patch": "@@ -393,6 +393,17 @@ static void delete_output_reload\tPROTO((rtx, int, rtx));\n static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n static int count_occurrences\t\tPROTO((rtx, rtx));\n+static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n+static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx, enum machine_mode,\n+\t\t\t\t\t       rtx));\n+static void reload_cse_invalidate_mem\tPROTO((rtx));\n+static void reload_cse_invalidate_rtx\tPROTO((rtx, rtx));\n+static void reload_cse_regs\t\tPROTO((rtx));\n+static int reload_cse_regno_equal_p\tPROTO((int, rtx, enum machine_mode));\n+static int reload_cse_noop_set_p\tPROTO((rtx));\n+static void reload_cse_simplify_set\tPROTO((rtx, rtx));\n+static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n+static void reload_cse_record_set\tPROTO((rtx, rtx));\n \f\n /* Initialize the reload pass once per compilation.  */\n \n@@ -2106,6 +2117,10 @@ reload (first, global, dumpfile)\n \t}\n     }\n \n+  /* Do a very simple CSE pass over just the hard registers.  */\n+  if (optimize > 0)\n+    reload_cse_regs (first);\n+\n #ifdef PRESERVE_DEATH_INFO_REGNO_P\n   /* Make a pass over all the insns and remove death notes for things that\n      are no longer registers or no longer die in the insn (e.g., an input\n@@ -7511,3 +7526,661 @@ count_occurrences (x, find)\n     }\n   return count;\n }\n+\f\n+/* This array holds values which are equivalent to a hard register\n+   during reload_cse_regs.  Each array element is an EXPR_LIST of\n+   values.  Each time a hard register is set, we set the corresponding\n+   array element to the value.  Each time a hard register is copied\n+   into memory, we add the memory location to the corresponding array\n+   element.  We don't store values or memory addresses with side\n+   effects in this array.\n+\n+   If the value is a CONST_INT, then the mode of the containing\n+   EXPR_LIST is the mode in which that CONST_INT was referenced.\n+\n+   We sometimes clobber a specific entry in a list.  In that case, we\n+   just set XEXP (list-entry, 0) to 0.  */\n+\n+static rtx *reg_values;\n+\n+/* Invalidate any entries in reg_values which depend on REGNO,\n+   including those for REGNO itself.  This is called if REGNO is\n+   changing.  If CLOBBER is true, then always forget anything we\n+   currently know about REGNO.  MODE is the mode of the assignment to\n+   REGNO, which is used to determine how many hard registers are being\n+   changed.  If MODE is VOIDmode, then only REGNO is being changed;\n+   this is used when invalidating call clobbered registers across a\n+   call.  */\n+\n+static void\n+reload_cse_invalidate_regno (regno, mode, clobber)\n+     int regno;\n+     enum machine_mode mode;\n+     int clobber;\n+{\n+  int endregno;\n+  register int i;\n+\n+  /* Our callers don't always go through true_regnum; we may see a\n+     pseudo-register here from a CLOBBER or the like.  We probably\n+     won't ever see a pseudo-register that has a real register number,\n+     for we check anyhow for safety.  */\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    regno = reg_renumber[regno];\n+  if (regno < 0)\n+    return;\n+\n+  if (mode == VOIDmode)\n+    endregno = regno + 1;\n+  else\n+    endregno = regno + HARD_REGNO_NREGS (regno, mode);\n+\n+  if (clobber)\n+    for (i = regno; i < endregno; i++)\n+      reg_values[i] = 0;\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      rtx x;\n+\n+      for (x = reg_values[i]; x; x = XEXP (x, 1))\n+\t{\n+\t  if (XEXP (x, 0) != 0\n+\t      && refers_to_regno_p (regno, endregno, XEXP (x, 0), NULL_RTX))\n+\t    {\n+\t      /* If this is the only entry on the list, clear\n+                 reg_values[i].  Otherwise, just clear this entry on\n+                 the list.  */\n+\t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n+\t\t{\n+\t\t  reg_values[i] = 0;\n+\t\t  break;\n+\t\t}\n+\t      XEXP (x, 0) = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* The memory at address (plus MEM_BASE MEM_OFFSET), where MEM_OFFSET\n+   is a CONST_INT, is being changed.  MEM_MODE is the mode of the\n+   memory reference.  Return whether this change will invalidate VAL.  */\n+\n+static int\n+reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode, val)\n+     rtx mem_base;\n+     rtx mem_offset;\n+     enum machine_mode mem_mode;\n+     rtx val;\n+{\n+  enum rtx_code code;\n+  char *fmt;\n+  int i;\n+\n+  code = GET_CODE (val);\n+  switch (code)\n+    {\n+      /* Get rid of a few simple cases quickly. */\n+    case REG:\n+    case SUBREG:\n+    case PC:\n+    case CC0:\n+    case SCRATCH:\n+    case CONST:\n+    case CONST_INT:\n+    case CONST_DOUBLE:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return 0;\n+\n+    case MEM:\n+      {\n+\trtx val_base, val_offset;\n+\n+\tif (mem_mode == BLKmode || GET_MODE (val) == BLKmode)\n+\t  return 1;\n+\n+\tval_offset = const0_rtx;\n+\tval_base = eliminate_constant_term (XEXP (val, 0), &val_offset);\n+\n+\t/* If MEM_BASE and VAL_BASE are the same, but the offsets do\n+\t   not overlap, then we do not have a conflict on this MEM.\n+\t   For complete safety, we still need to check that VAL_BASE\n+\t   itself does not contain an overlapping MEM.\n+\n+\t   We can't simplify the check to just OFFSET + SIZE <=\n+\t   OTHER_OFFSET, because SIZE might cause OFFSET to wrap from\n+\t   positive to negative.  If we used unsigned arithmetic, we\n+\t   would have the same problem wrapping around zero.  */\n+\n+\tif (rtx_equal_p (mem_base, val_base)\n+\t    && ((INTVAL (mem_offset) < INTVAL (val_offset)\n+\t\t && (INTVAL (mem_offset) + GET_MODE_SIZE (mem_mode)\n+\t\t     <= INTVAL (val_offset)))\n+\t\t|| (INTVAL (val_offset) < INTVAL (mem_offset)\n+\t\t    && (INTVAL (val_offset) + GET_MODE_SIZE (GET_MODE (val))\n+\t\t\t<= INTVAL (mem_offset)))))\n+\t  return reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n+\t\t\t\t\t    val_base);\n+\n+\treturn 1;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  fmt = GET_RTX_FORMAT (code);\n+\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  if (reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n+\t\t\t\t\t XEXP (val, i)))\n+\t    return 1;\n+\t}\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  int j;\n+\n+\t  for (j = 0; j < XVECLEN (val, i); j++)\n+\t    if (reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n+\t\t\t\t\t   XVECEXP (val, i, j)))\n+\t      return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Invalidate any entries in reg_values which are changed because of a\n+   store to MEM_RTX.  If this is called because of a non-const call\n+   instruction, MEM_RTX is (mem:BLK const0_rtx).  */\n+\n+static void\n+reload_cse_invalidate_mem (mem_rtx)\n+     rtx mem_rtx;\n+{\n+  register int i;\n+  rtx mem_base, mem_offset;\n+  enum machine_mode mem_mode;\n+\n+  /* We detect certain cases where memory addresses can not conflict:\n+     if they use the same register, and the offsets do not overlap.  */\n+\n+  mem_offset = const0_rtx;\n+  mem_base = eliminate_constant_term (XEXP (mem_rtx, 0), &mem_offset);\n+  mem_mode = GET_MODE (mem_rtx);\n+\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      rtx x;\n+\n+      for (x = reg_values[i]; x; x = XEXP (x, 1))\n+\t{\n+\t  if (XEXP (x, 0) != 0\n+\t      && reload_cse_mem_conflict_p (mem_base, mem_offset, mem_mode,\n+\t\t\t\t\t    XEXP (x, 0)))\n+\t    {\n+\t      /* If this is the only entry on the list, clear\n+                 reg_values[i].  Otherwise, just clear this entry on\n+                 the list.  */\n+\t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n+\t\t{\n+\t\t  reg_values[i] = 0;\n+\t\t  break;\n+\t\t}\n+\t      XEXP (x, 0) = 0;\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Invalidate DEST, which is being assigned to or clobbered.  The\n+   second parameter exists so that this function can be passed to\n+   note_stores; it is ignored.  */\n+\n+static void\n+reload_cse_invalidate_rtx (dest, ignore)\n+     rtx dest;\n+     rtx ignore;\n+{\n+  while (GET_CODE (dest) == STRICT_LOW_PART\n+\t || GET_CODE (dest) == SIGN_EXTRACT\n+\t || GET_CODE (dest) == ZERO_EXTRACT\n+\t || GET_CODE (dest) == SUBREG)\n+    dest = XEXP (dest, 0);\n+\n+  if (GET_CODE (dest) == REG)\n+    reload_cse_invalidate_regno (REGNO (dest), GET_MODE (dest), 1);\n+  else if (GET_CODE (dest) == MEM)\n+    reload_cse_invalidate_mem (dest);\n+}\n+\n+/* Do a very simple CSE pass over the hard registers.\n+\n+   This function detects no-op moves where we happened to assign two\n+   different pseudo-registers to the same hard register, and then\n+   copied one to the other.  Reload will generate a useless\n+   instruction copying a register to itself.\n+\n+   This function also detects cases where we load a value from memory\n+   into two different registers, and (if memory is more expensive than\n+   registers) changes it to simply copy the first register into the\n+   second register.  */\n+\n+static void\n+reload_cse_regs (first)\n+     rtx first;\n+{\n+  char *firstobj;\n+  rtx callmem;\n+  register int i;\n+  rtx insn;\n+\n+  reg_values = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    reg_values[i] = 0;\n+\n+  /* Create our EXPR_LIST structures on reload_obstack, so that we can\n+     free them when we are done.  */\n+  push_obstacks (&reload_obstack, &reload_obstack);\n+  firstobj = (char *) obstack_alloc (&reload_obstack, 0);\n+\n+  /* We pass this to reload_cse_invalidate_mem to invalidate all of\n+     memory for a non-const call instruction.  */\n+  callmem = gen_rtx (MEM, BLKmode, const0_rtx);\n+\n+  for (insn = first; insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx body;\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  /* Forget all the register values at a code label.  We don't\n+             try to do anything clever around jumps.  */\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    reg_values[i] = 0;\n+\n+\t  continue;\n+\t}\n+\n+#ifdef NON_SAVING_SETJMP \n+      if (NON_SAVING_SETJMP && GET_CODE (insn) == NOTE\n+\t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n+\t{\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    reg_values[i] = 0;\n+\n+\t  continue;\n+\t}\n+#endif\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+\n+      /* If this is a call instruction, forget anything stored in a\n+\t call clobbered register, or, if this is not a const call, in\n+\t memory.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (call_used_regs[i])\n+\t      reload_cse_invalidate_regno (i, VOIDmode, 1);\n+\n+\t  if (! CONST_CALL_P (insn))\n+\t    reload_cse_invalidate_mem (callmem);\n+\t}\n+\n+      body = PATTERN (insn);\n+      if (GET_CODE (body) == SET)\n+\t{\n+\t  if (reload_cse_noop_set_p (body))\n+\t    {\n+\t      /* If we were preserving death notes, then we would want\n+\t\t to remove any existing death note for the register\n+\t\t being set.  */\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\n+\t      /* We're done with this insn.  */\n+\t      continue;\n+\t    }\n+\n+\t  reload_cse_simplify_set (body, insn);\n+\t  reload_cse_record_set (body, body);\n+\t}\n+      else if (GET_CODE (body) == PARALLEL)\n+\t{\n+\t  int delete;\n+\n+\t  /* If every action in a PARALLEL is a noop, we can delete\n+             the entire PARALLEL.  */\n+\t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t    if (GET_CODE (XVECEXP (body, 0, i)) != SET\n+\t\t|| ! reload_cse_noop_set_p (XVECEXP (body, 0, i)))\n+\t      break;\n+\t  if (i < 0)\n+\t    {\n+\t      /* If we were preserving death notes, then we would want\n+\t\t to remove any existing death notes for the registers\n+\t\t being set.  */\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\n+\t      /* We're done with this insn.  */\n+\t      continue;\n+\t    }\n+\n+\t  /* Look through the PARALLEL and record the values being\n+             set, if possible.  Also handle any CLOBBERs.  */\n+\t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t    {\n+\t      rtx x = XVECEXP (body, 0, i);\n+\n+\t      if (GET_CODE (x) == SET)\n+\t\treload_cse_record_set (x, body);\n+\t      else\n+\t\tnote_stores (x, reload_cse_invalidate_rtx);\n+\t    }\n+\t}\n+      else\n+\tnote_stores (body, reload_cse_invalidate_rtx);\n+\n+#ifdef AUTO_INC_DEC\n+      /* Clobber any registers which appear in REG_INC notes.  We\n+         could keep track of the changes to their values, but it is\n+         unlikely to help.  */\n+      {\n+\trtx x;\n+\n+\tfor (x = REG_NOTES (insn); x; x = XEXP (x, 1))\n+\t  if (REG_NOTE_KIND (x) == REG_INC)\n+\t    reload_cse_invalidate_rtx (XEXP (x, 0), NULL_RTX);\n+      }\n+#endif\n+\n+      /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n+         after we have processed the insn.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx x;\n+\n+\t  for (x = CALL_INSN_FUNCTION_USAGE (insn); x; x = XEXP (x, 1))\n+\t    if (GET_CODE (XEXP (x, 0)) == CLOBBER)\n+\t      reload_cse_invalidate_rtx (XEXP (XEXP (x, 0), 0), NULL_RTX);\n+\t}\n+    }\n+\n+  /* Free all the temporary structures we created, and go back to the\n+     regular obstacks.  */\n+  obstack_free (&reload_obstack, firstobj);\n+  pop_obstacks ();\n+}\n+\n+/* Return whether the values known for REGNO are equal to VAL.  MODE\n+   is the mode of the object that VAL is being copied to; this matters\n+   if VAL is a CONST_INT.  */\n+\n+static int\n+reload_cse_regno_equal_p (regno, val, mode)\n+     int regno;\n+     rtx val;\n+     enum machine_mode mode;\n+{\n+  rtx x;\n+\n+  if (val == 0)\n+    return 0;\n+\n+  for (x = reg_values[regno]; x; x = XEXP (x, 1))\n+    if (XEXP (x, 0) != 0\n+\t&& rtx_equal_p (XEXP (x, 0), val)\n+\t&& (GET_CODE (val) != CONST_INT\n+\t    || mode == GET_MODE (x)\n+\t    || (GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (x))\n+\t\t&& TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (mode),\n+\t\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (x))))))\n+      return 1;\n+\n+  return 0;\n+}\n+\n+/* See whether a single SET instruction is a nooop.  */\n+\n+static int\n+reload_cse_noop_set_p (set)\n+     rtx set;\n+{\n+  rtx src, dest;\n+  enum machine_mode dest_mode;\n+  int dreg, sreg;\n+\n+  src = SET_SRC (set);\n+  dest = SET_DEST (set);\n+  dest_mode = GET_MODE (dest);\n+\n+  if (side_effects_p (src))\n+    return 0;\n+\n+  dreg = true_regnum (dest);\n+  sreg = true_regnum (src);\n+\n+  if (dreg >= 0)\n+    {\n+      /* Check for setting a register to itself.  */\n+      if (dreg == sreg)\n+\treturn 1;\n+\n+      /* Check for setting a register to a value which we already know\n+         is in the register.  */\n+      if (reload_cse_regno_equal_p (dreg, src, dest_mode))\n+\treturn 1;\n+\n+      /* Check for setting a register DREG to another register SREG\n+         where SREG is equal to a value which is already in DREG.  */\n+      if (sreg >= 0)\n+\t{\n+\t  rtx x;\n+\n+\t  for (x = reg_values[sreg]; x; x = XEXP (x, 1))\n+\t    if (XEXP (x, 0) != 0\n+\t\t&& reload_cse_regno_equal_p (dreg, XEXP (x, 0), dest_mode))\n+\t      return 1;\n+\t}\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      /* Check for storing a register to memory when we know that the\n+         register is equivalent to the memory location. */\n+      if (sreg >= 0\n+\t  && reload_cse_regno_equal_p (sreg, dest, dest_mode)\n+\t  && ! side_effects_p (dest))\n+\treturn 1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Try to simplify a single SET instruction.  SET is the set pattern.\n+   INSN is the instruction it came from. */\n+\n+static void\n+reload_cse_simplify_set (set, insn)\n+     rtx set;\n+     rtx insn;\n+{\n+  int dreg;\n+  rtx src;\n+  enum machine_mode dest_mode;\n+  enum reg_class dclass;\n+  register int i;\n+\n+  /* We only handle one case: if we set a register to a value which is\n+     not a register, we try to find that value in some other register\n+     and change the set into a register copy.  */\n+\n+  dreg = true_regnum (SET_DEST (set));\n+  if (dreg < 0)\n+    return;\n+\n+  src = SET_SRC (set);\n+  if (side_effects_p (src) || true_regnum (src) >= 0)\n+    return;\n+\n+  /* If memory loads are cheaper than register copies, don't change\n+     them.  */\n+  if (GET_CODE (src) == MEM && MEMORY_MOVE_COST (GET_MODE (src)) < 2)\n+    return;\n+\n+  dest_mode = GET_MODE (SET_DEST (set));\n+  dclass = REGNO_REG_CLASS (dreg);\n+  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+    {\n+      if (i != dreg\n+\t  && REGISTER_MOVE_COST (REGNO_REG_CLASS (i), dclass) == 2\n+\t  && reload_cse_regno_equal_p (i, src, dest_mode))\n+\t{\n+\t  int validated;\n+\n+\t  /* Pop back to the real obstacks while changing the insn.  */\n+\t  pop_obstacks ();\n+\n+\t  validated = validate_change (insn, &SET_SRC (set),\n+\t\t\t\t       gen_rtx (REG, dest_mode, i), 0);\n+\n+\t  /* Go back to the obstack we are using for temporary\n+             storage.  */\n+\t  push_obstacks (&reload_obstack, &reload_obstack);\n+\n+\t  if (validated)\n+\t    return;\n+\t}\n+    }\n+}\n+\n+/* These two variables are used to pass information from\n+   reload_cse_record_set to reload_cse_check_clobber.  */\n+\n+static int reload_cse_check_clobbered;\n+static rtx reload_cse_check_src;\n+\n+/* See if DEST overlaps with RELOAD_CSE_CHECK_SRC. If it does, set\n+   RELOAD_CSE_CHECK_CLOBBERED.  This is called via note_stores.  The\n+   second argument, which is passed by note_stores, is ignored.  */\n+\n+static void\n+reload_cse_check_clobber (dest, ignore)\n+     rtx dest;\n+     rtx ignore;\n+{\n+  if (reg_overlap_mentioned_p (dest, reload_cse_check_src))\n+    reload_cse_check_clobbered = 1;\n+}\n+\n+/* Record the result of a SET instruction.  SET is the set pattern.\n+   BODY is the pattern of the insn that it came from.  */\n+\n+static void\n+reload_cse_record_set (set, body)\n+     rtx set;\n+     rtx body;\n+{\n+  rtx dest, src;\n+  int dreg, sreg;\n+  enum machine_mode dest_mode;\n+\n+  dest = SET_DEST (set);\n+  src = SET_SRC (set);\n+  dreg = true_regnum (dest);\n+  sreg = true_regnum (src);\n+  dest_mode = GET_MODE (dest);\n+\n+  /* We can only handle an assignment to a register, or a store of a\n+     register to a memory location.  For other cases, we just clobber\n+     the destination.  We also have to just clobber if there are side\n+     effects in SRC or DEST.  */\n+  if ((dreg < 0 && GET_CODE (dest) != MEM)\n+      || side_effects_p (src)\n+      || side_effects_p (dest))\n+    {\n+      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+      return;\n+    }\n+\n+#ifdef HAVE_cc0\n+  /* We don't try to handle values involving CC, because it's a pain\n+     to keep track of when they have to be invalidated.  */\n+  if (reg_mentioned_p (cc0_rtx, src)\n+      || reg_mentioned_p (cc0_rtx, dest))\n+    {\n+      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+      return;\n+    }\n+#endif\n+\n+  /* If BODY is a PARALLEL, then we need to see whether the source of\n+     SET is clobbered by some other instruction in the PARALLEL.  */\n+  if (GET_CODE (body) == PARALLEL)\n+    {\n+      int i;\n+\n+      for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n+\t{\n+\t  rtx x;\n+\n+\t  x = XVECEXP (body, 0, i);\n+\t  if (x == set)\n+\t    continue;\n+\n+\t  reload_cse_check_clobbered = 0;\n+\t  reload_cse_check_src = src;\n+\t  note_stores (x, reload_cse_check_clobber);\n+\t  if (reload_cse_check_clobbered)\n+\t    {\n+\t      reload_cse_invalidate_rtx (dest, NULL_RTX);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  if (dreg >= 0)\n+    {\n+      int i;\n+\n+      /* This is an assignment to a register.  Update the value we\n+         have stored for the register.  */\n+      if (sreg >= 0)\n+\treg_values[dreg] = reg_values[sreg];\n+      else\n+\treg_values[dreg] = gen_rtx (EXPR_LIST, dest_mode, src, NULL_RTX);\n+\n+      /* We've changed DREG, so invalidate any values held by other\n+         registers that depend upon it.  */\n+      reload_cse_invalidate_regno (dreg, dest_mode, 0);\n+\n+      /* If this assignment changes more than one hard register,\n+         forget anything we know about the others.  */\n+      for (i = 1; i < HARD_REGNO_NREGS (dreg, dest_mode); i++)\n+\treg_values[dreg + i] = 0;\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      /* Invalidate conflicting memory locations.  */\n+      reload_cse_invalidate_mem (dest);\n+\n+      /* If we're storing a register to memory, add DEST to the list\n+         in REG_VALUES.  */\n+      if (sreg >= 0 && ! side_effects_p (dest))\n+\treg_values[sreg] = gen_rtx (EXPR_LIST, dest_mode, dest,\n+\t\t\t\t    reg_values[sreg]);\n+    }\n+  else\n+    {\n+      /* We should have bailed out earlier.  */\n+      abort ();\n+    }\n+}"}]}