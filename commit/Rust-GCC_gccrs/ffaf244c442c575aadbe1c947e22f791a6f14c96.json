{"sha": "ffaf244c442c575aadbe1c947e22f791a6f14c96", "node_id": "C_kwDOANBUbNoAKGZmYWYyNDRjNDQyYzU3NWFhZGJlMWM5NDdlMjJmNzkxYTZmMTRjOTY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-07T07:57:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-10-07T10:06:10Z"}, "message": "Convert nonzero mask back to tree.\n\nHaving nonzero masks always set had a performance penalty of 10% in\nVRP, so mask==NULL is a shortcut to all bits set.\n\ngcc/ChangeLog:\n\n\t* value-range.cc (irange::irange_set): Convert nonzero mask to\n\ttree.\n\t(irange::irange_set_anti_range): Same.\n\t(irange::set): Same.\n\t(irange::verify_range): Same.\n\t(irange::contains_p): Same.\n\t(irange::invert): Same.\n\t(irange::set_range_from_nonzero_bits): Same.\n\t(irange::set_nonzero_bits): Same.\n\t(mask_to_wi): Same.\n\t(irange::intersect_nonzero_bits): Same.\n\t(irange::union_nonzero_bits): Same.\n\t* value-range.h (irange::varying_compatible_p): Same.\n\t(gt_ggc_mx): Same.\n\t(gt_pch_nx): Same.\n\t(irange::set_undefined): Same.\n\t(irange::set_varying): Same.", "tree": {"sha": "82391c260d1d2a0eca086a2a854d6383980daf43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82391c260d1d2a0eca086a2a854d6383980daf43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffaf244c442c575aadbe1c947e22f791a6f14c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaf244c442c575aadbe1c947e22f791a6f14c96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffaf244c442c575aadbe1c947e22f791a6f14c96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaf244c442c575aadbe1c947e22f791a6f14c96/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fce601fd07fd04f55c4e8260ec49012dea886b06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fce601fd07fd04f55c4e8260ec49012dea886b06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fce601fd07fd04f55c4e8260ec49012dea886b06"}], "stats": {"total": 104, "additions": 77, "deletions": 27}, "files": [{"sha": "16105f8767817eee2e9a49d41ee5ab50e0b797f1", "filename": "gcc/value-range.cc", "status": "modified", "additions": 66, "deletions": 19, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf244c442c575aadbe1c947e22f791a6f14c96/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf244c442c575aadbe1c947e22f791a6f14c96/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=ffaf244c442c575aadbe1c947e22f791a6f14c96", "patch": "@@ -935,7 +935,7 @@ irange::irange_set (tree min, tree max)\n   m_base[1] = max;\n   m_num_ranges = 1;\n   m_kind = VR_RANGE;\n-  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n+  m_nonzero_mask = NULL;\n   normalize_kind ();\n \n   if (flag_checking)\n@@ -1009,7 +1009,7 @@ irange::irange_set_anti_range (tree min, tree max)\n     }\n \n   m_kind = VR_RANGE;\n-  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n+  m_nonzero_mask = NULL;\n   normalize_kind ();\n \n   if (flag_checking)\n@@ -1066,7 +1066,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n       m_base[0] = min;\n       m_base[1] = max;\n       m_num_ranges = 1;\n-      m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n+      m_nonzero_mask = NULL;\n       return;\n     }\n \n@@ -1116,7 +1116,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n   m_base[0] = min;\n   m_base[1] = max;\n   m_num_ranges = 1;\n-  m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (TREE_TYPE (min)));\n+  m_nonzero_mask = NULL;\n   normalize_kind ();\n   if (flag_checking)\n     verify_range ();\n@@ -1135,7 +1135,8 @@ irange::verify_range ()\n     }\n   if (m_kind == VR_VARYING)\n     {\n-      gcc_checking_assert (m_nonzero_mask == -1);\n+      gcc_checking_assert (!m_nonzero_mask\n+\t\t\t   || wi::to_wide (m_nonzero_mask) == -1);\n       gcc_checking_assert (m_num_ranges == 1);\n       gcc_checking_assert (varying_compatible_p ());\n       return;\n@@ -1409,10 +1410,10 @@ irange::contains_p (tree cst) const\n   gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n \n   // See if we can exclude CST based on the nonzero bits.\n-  if (m_nonzero_mask != -1)\n+  if (m_nonzero_mask)\n     {\n       wide_int cstw = wi::to_wide (cst);\n-      if (cstw != 0 && wi::bit_and (m_nonzero_mask, cstw) == 0)\n+      if (cstw != 0 && wi::bit_and (wi::to_wide (m_nonzero_mask), cstw) == 0)\n \treturn false;\n     }\n \n@@ -2776,7 +2777,7 @@ irange::invert ()\n   signop sign = TYPE_SIGN (ttype);\n   wide_int type_min = wi::min_value (prec, sign);\n   wide_int type_max = wi::max_value (prec, sign);\n-  m_nonzero_mask = wi::shwi (-1, prec);\n+  m_nonzero_mask = NULL;\n   if (m_num_ranges == m_max_ranges\n       && lower_bound () != type_min\n       && upper_bound () != type_max)\n@@ -2878,20 +2879,22 @@ bool\n irange::set_range_from_nonzero_bits ()\n {\n   gcc_checking_assert (!undefined_p ());\n-  unsigned popcount = wi::popcount (m_nonzero_mask);\n+  if (!m_nonzero_mask)\n+    return false;\n+  unsigned popcount = wi::popcount (wi::to_wide (m_nonzero_mask));\n \n   // If we have only one bit set in the mask, we can figure out the\n   // range immediately.\n   if (popcount == 1)\n     {\n       // Make sure we don't pessimize the range.\n-      if (!contains_p (wide_int_to_tree (type (), m_nonzero_mask)))\n+      if (!contains_p (m_nonzero_mask))\n \treturn false;\n \n       bool has_zero = contains_p (build_zero_cst (type ()));\n-      wide_int bits = m_nonzero_mask;\n-      set (type (), bits, bits);\n-      m_nonzero_mask = bits;\n+      tree nz = m_nonzero_mask;\n+      set (nz, nz);\n+      m_nonzero_mask = nz;\n       if (has_zero)\n \t{\n \t  int_range<2> zero;\n@@ -2909,11 +2912,21 @@ irange::set_nonzero_bits (const wide_int_ref &bits)\n   gcc_checking_assert (!undefined_p ());\n   unsigned prec = TYPE_PRECISION (type ());\n \n+  if (bits == -1)\n+    {\n+      m_nonzero_mask = NULL;\n+      normalize_kind ();\n+      if (flag_checking)\n+\tverify_range ();\n+      return;\n+    }\n+\n   // Drop VARYINGs with a nonzero mask to a plain range.\n   if (m_kind == VR_VARYING && bits != -1)\n     m_kind = VR_RANGE;\n \n-  m_nonzero_mask = wide_int::from (bits, prec, TYPE_SIGN (type ()));\n+  wide_int nz = wide_int::from (bits, prec, TYPE_SIGN (type ()));\n+  m_nonzero_mask = wide_int_to_tree (type (), nz);\n   if (set_range_from_nonzero_bits ())\n     return;\n \n@@ -2937,7 +2950,21 @@ irange::get_nonzero_bits () const\n   // the mask precisely up to date at all times.  Instead, we default\n   // to -1 and set it when explicitly requested.  However, this\n   // function will always return the correct mask.\n-  return m_nonzero_mask & get_nonzero_bits_from_range ();\n+  if (m_nonzero_mask)\n+    return wi::to_wide (m_nonzero_mask) & get_nonzero_bits_from_range ();\n+  else\n+    return get_nonzero_bits_from_range ();\n+}\n+\n+// Convert tree mask to wide_int.  Returns -1 for NULL masks.\n+\n+inline wide_int\n+mask_to_wi (tree mask, tree type)\n+{\n+  if (mask)\n+    return wi::to_wide (mask);\n+  else\n+    return wi::shwi (-1, TYPE_PRECISION (type));\n }\n \n // Intersect the nonzero bits in R into THIS and normalize the range.\n@@ -2948,10 +2975,20 @@ irange::intersect_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n+  if (!m_nonzero_mask && !r.m_nonzero_mask)\n+    {\n+      normalize_kind ();\n+      if (flag_checking)\n+\tverify_range ();\n+      return false;\n+    }\n+\n   bool changed = false;\n-  if (m_nonzero_mask != r.m_nonzero_mask)\n+  tree t = type ();\n+  if (mask_to_wi (m_nonzero_mask, t) != mask_to_wi (r.m_nonzero_mask, t))\n     {\n-      m_nonzero_mask = get_nonzero_bits () & r.get_nonzero_bits ();\n+      wide_int nz = get_nonzero_bits () & r.get_nonzero_bits ();\n+      m_nonzero_mask = wide_int_to_tree (t, nz);\n       if (set_range_from_nonzero_bits ())\n \treturn true;\n       changed = true;\n@@ -2970,10 +3007,20 @@ irange::union_nonzero_bits (const irange &r)\n {\n   gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n \n+  if (!m_nonzero_mask && !r.m_nonzero_mask)\n+    {\n+      normalize_kind ();\n+      if (flag_checking)\n+\tverify_range ();\n+      return false;\n+    }\n+\n   bool changed = false;\n-  if (m_nonzero_mask != r.m_nonzero_mask)\n+  tree t = type ();\n+  if (mask_to_wi (m_nonzero_mask, t) != mask_to_wi (r.m_nonzero_mask, t))\n     {\n-      m_nonzero_mask = get_nonzero_bits () | r.get_nonzero_bits ();\n+      wide_int nz = get_nonzero_bits () | r.get_nonzero_bits ();\n+      m_nonzero_mask = wide_int_to_tree (t, nz);\n       // No need to call set_range_from_nonzero_bits, because we'll\n       // never narrow the range.  Besides, it would cause endless\n       // recursion because of the union_ in"}, {"sha": "484f911bd9051bfdafffa089b6c03895fc0ed5a4", "filename": "gcc/value-range.h", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf244c442c575aadbe1c947e22f791a6f14c96/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf244c442c575aadbe1c947e22f791a6f14c96/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=ffaf244c442c575aadbe1c947e22f791a6f14c96", "patch": "@@ -215,7 +215,7 @@ class GTY((user)) irange : public vrange\n   bool intersect (const wide_int& lb, const wide_int& ub);\n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n-  wide_int m_nonzero_mask;\n+  tree m_nonzero_mask;\n   tree *m_base;\n };\n \n@@ -683,11 +683,11 @@ irange::varying_compatible_p () const\n   if (INTEGRAL_TYPE_P (t))\n     return (wi::to_wide (l) == wi::min_value (prec, sign)\n \t    && wi::to_wide (u) == wi::max_value (prec, sign)\n-\t    && m_nonzero_mask == -1);\n+\t    && (!m_nonzero_mask || wi::to_wide (m_nonzero_mask) == -1));\n   if (POINTER_TYPE_P (t))\n     return (wi::to_wide (l) == 0\n \t    && wi::to_wide (u) == wi::max_value (prec, sign)\n-\t    && m_nonzero_mask == -1);\n+\t    && (!m_nonzero_mask || wi::to_wide (m_nonzero_mask) == -1));\n   return true;\n }\n \n@@ -754,6 +754,8 @@ gt_ggc_mx (irange *x)\n       gt_ggc_mx (x->m_base[i * 2]);\n       gt_ggc_mx (x->m_base[i * 2 + 1]);\n     }\n+  if (x->m_nonzero_mask)\n+    gt_ggc_mx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -764,6 +766,8 @@ gt_pch_nx (irange *x)\n       gt_pch_nx (x->m_base[i * 2]);\n       gt_pch_nx (x->m_base[i * 2 + 1]);\n     }\n+  if (x->m_nonzero_mask)\n+    gt_pch_nx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -774,6 +778,8 @@ gt_pch_nx (irange *x, gt_pointer_operator op, void *cookie)\n       op (&x->m_base[i * 2], NULL, cookie);\n       op (&x->m_base[i * 2 + 1], NULL, cookie);\n     }\n+  if (x->m_nonzero_mask)\n+    op (&x->m_nonzero_mask, NULL, cookie);\n }\n \n template<unsigned N>\n@@ -868,18 +874,15 @@ irange::set_undefined ()\n {\n   m_kind = VR_UNDEFINED;\n   m_num_ranges = 0;\n+  m_nonzero_mask = NULL;\n }\n \n inline void\n irange::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   m_num_ranges = 1;\n-\n-  if (type == error_mark_node)\n-    m_nonzero_mask = wi::shwi (-1, 1);\n-  else\n-    m_nonzero_mask = wi::shwi (-1, TYPE_PRECISION (type));\n+  m_nonzero_mask = NULL;\n \n   if (INTEGRAL_TYPE_P (type))\n     {"}]}