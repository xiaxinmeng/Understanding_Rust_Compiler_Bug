{"sha": "1b32e4e506aa3acd719c60d4287f30fc696a6d47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIzMmU0ZTUwNmFhM2FjZDcxOWM2MGQ0Mjg3ZjMwZmM2OTZhNmQ0Nw==", "commit": {"author": {"name": "Bob Walters", "email": "bob.s.walters@gmail.com", "date": "2008-11-11T12:16:57Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2008-11-11T12:16:57Z"}, "message": "forward_list.h: Support non-standard pointer types\n\n2008-11-11  Bob Walters  <bob.s.walters@gmail.com>\n\n\t* include/bits/forward_list.h: Support non-standard pointer types\n\t(_Fwd_list_node_base): Add _Alloc template parameter.\n\t(_Fwd_list_node<>): Likewise.\n\t(_Fwd_list_iterator<>): Likewise.\n\t(_Fwd_list_const_iterator<>): Likewise.\n\t(_Fwd_list_node_base::_M_next, _M_transfer_after, _M_reverse_after): \n\tUse _Alloc<_Tp>::pointer.\n\t(_Fwd_list_iterator<>::_M_node): Use _Node_base::_Pointer.\n\t(_Fwd_list_base<>::_M_get_node, _M_create_node, _M_create_node, \n\t_M_insert_after, _M_put_node, _M_erase_after): Likewise.\n\t(_Fwd_list_const_iterator<>::_M_node): use _Node_base::_Const_pointer.\n\t(forward_list<>): Use __static_pointer_cast in place of static_cast,\n\tand __const_pointer_cast in place of const_cast.\n\t* include/bits/forward_list.tcc\n\t(_Fwd_list_node<>::_M_sort_after): Using _Pointer typedefs in place \n\tof standard pointers, __static_pointer_cast in place of static_cast.\n\t(_Fwd_list_base<>::_Fwd_list_base, _M_insert_after, _M_erase_after):\n\tLikewise.\n\t(forward_list<>::_M_initialize_dispatch, _M_fill_initialize, \n\tsplice_after, remove, remove_if, merge): Likewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/1.cc: New.\n\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/2.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/3.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/4.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/5.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/1.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/2.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/3.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/4.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/5.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/6.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/operations/7.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/requirements/1.cc: \n\tLikewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/requirements/\n\texplicit_instantiation/1.cc: Likewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/requirements/\n\texplicit_instantiation/3.cc: Likewise.\n\t* testsuite/23_containers/forward_list/ext_pointer/1.cc: Likewise.\n\nFrom-SVN: r141765", "tree": {"sha": "02bdfc783a9f079e2157f3dd8ce4bc6aed8072b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02bdfc783a9f079e2157f3dd8ce4bc6aed8072b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b32e4e506aa3acd719c60d4287f30fc696a6d47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b32e4e506aa3acd719c60d4287f30fc696a6d47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b32e4e506aa3acd719c60d4287f30fc696a6d47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b32e4e506aa3acd719c60d4287f30fc696a6d47/comments", "author": {"login": "bob-walters", "id": 2716127, "node_id": "MDQ6VXNlcjI3MTYxMjc=", "avatar_url": "https://avatars.githubusercontent.com/u/2716127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bob-walters", "html_url": "https://github.com/bob-walters", "followers_url": "https://api.github.com/users/bob-walters/followers", "following_url": "https://api.github.com/users/bob-walters/following{/other_user}", "gists_url": "https://api.github.com/users/bob-walters/gists{/gist_id}", "starred_url": "https://api.github.com/users/bob-walters/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bob-walters/subscriptions", "organizations_url": "https://api.github.com/users/bob-walters/orgs", "repos_url": "https://api.github.com/users/bob-walters/repos", "events_url": "https://api.github.com/users/bob-walters/events{/privacy}", "received_events_url": "https://api.github.com/users/bob-walters/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8a4e9d3d650687dfa24d58e79fdc70d0f77173"}], "stats": {"total": 1965, "additions": 1620, "deletions": 345}, "files": [{"sha": "3b918456dbb3350f4ed3d6e417f4950287ddc620", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -1,3 +1,56 @@\n+2008-11-11  Bob Walters  <bob.s.walters@gmail.com>\n+\n+\t* include/bits/forward_list.h: Support non-standard pointer types\n+\t(_Fwd_list_node_base): Add _Alloc template parameter.\n+\t(_Fwd_list_node<>): Likewise.\n+\t(_Fwd_list_iterator<>): Likewise.\n+\t(_Fwd_list_const_iterator<>): Likewise.\n+\t(_Fwd_list_node_base::_M_next, _M_transfer_after, _M_reverse_after): \n+\tUse _Alloc<_Tp>::pointer.\n+\t(_Fwd_list_iterator<>::_M_node): Use _Node_base::_Pointer.\n+\t(_Fwd_list_base<>::_M_get_node, _M_create_node, _M_create_node, \n+\t_M_insert_after, _M_put_node, _M_erase_after): Likewise.\n+\t(_Fwd_list_const_iterator<>::_M_node): use _Node_base::_Const_pointer.\n+\t(forward_list<>): Use __static_pointer_cast in place of static_cast,\n+\tand __const_pointer_cast in place of const_cast.\n+\t* include/bits/forward_list.tcc\n+\t(_Fwd_list_node<>::_M_sort_after): Using _Pointer typedefs in place \n+\tof standard pointers, __static_pointer_cast in place of static_cast.\n+\t(_Fwd_list_base<>::_Fwd_list_base, _M_insert_after, _M_erase_after):\n+\tLikewise.\n+\t(forward_list<>::_M_initialize_dispatch, _M_fill_initialize, \n+\tsplice_after, remove, remove_if, merge): Likewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/1.cc: New.\n+\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/2.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/3.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/4.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/modifiers/5.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/1.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/2.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/3.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/4.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/5.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/6.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/operations/7.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/requirements/1.cc: \n+\tLikewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/requirements/\n+\texplicit_instantiation/1.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/requirements/\n+\texplicit_instantiation/3.cc: Likewise.\n+\t* testsuite/23_containers/forward_list/ext_pointer/1.cc: Likewise.\n+\n 2008-11-11  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* include/ext/extptr_allocator.h: Minor tweaks."}, {"sha": "cb7397800c009caba9ed7a7365de18e749376bfa", "filename": "libstdc++-v3/include/bits/forward_list.h", "status": "modified", "additions": 165, "deletions": 147, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.h?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -42,75 +42,89 @@\n \n #include <memory>\n #include <initializer_list>\n+#include <ext/cast.h>\n \n _GLIBCXX_BEGIN_NAMESPACE(std)\n \n+  using __gnu_cxx::__static_pointer_cast;\n+  using __gnu_cxx::__const_pointer_cast;\n+\n   /**\n    *  @brief  A helper basic node class for @forward_list.\n    *          This is just a linked list with nothing inside it.\n    *          There are purely list shuffling utility methods here.\n    */\n-  struct _Fwd_list_node_base\n-  {\n-    _Fwd_list_node_base() : _M_next(0) { }\n-\n-    _Fwd_list_node_base* _M_next;\n-\n-    static void\n-    swap(_Fwd_list_node_base& __x, _Fwd_list_node_base& __y)\n-    { std::swap(__x._M_next, __y._M_next); }\n-\n-    void\n-    _M_transfer_after(_Fwd_list_node_base* __bbegin,\n-                      _Fwd_list_node_base* __bend)\n-    {\n-      _Fwd_list_node_base* __keep = __bbegin->_M_next;\n-      if (__bend)\n-        {\n-          __bbegin->_M_next = __bend->_M_next;\n-          __bend->_M_next = this->_M_next;\n-        }\n-      else\n-        __bbegin->_M_next = 0;\n-      this->_M_next = __keep;\n-    }\n-\n-    void\n-    _M_transfer_after(_Fwd_list_node_base* __bbegin)\n+  template<typename _Alloc>\n+    struct _Fwd_list_node_base\n     {\n-      _Fwd_list_node_base* __bend = __bbegin;\n-      while (__bend && __bend->_M_next)\n-        __bend = __bend->_M_next;\n-      _M_transfer_after(__bbegin, __bend);\n-    }\n-\n-    void\n-    _M_reverse_after()\n-    {\n-      _Fwd_list_node_base* __tail = this->_M_next;\n-      if (!__tail)\n-        return;\n-      while (_Fwd_list_node_base* __temp = __tail->_M_next)\n-        {\n-          _Fwd_list_node_base* __keep = this->_M_next;\n-          this->_M_next = __temp;\n-          __tail->_M_next = __temp->_M_next;\n-          this->_M_next->_M_next = __keep;\n-        }\n-    }\n-  };\n+      // The type allocated by _Alloc cannot be this type, so we rebind\n+      typedef typename _Alloc::template rebind<_Fwd_list_node_base<_Alloc> >\n+        ::other::pointer        _Pointer;\n+      typedef typename _Alloc::template rebind<_Fwd_list_node_base<_Alloc> >\n+        ::other::const_pointer  _Const_pointer;\n+  \n+      _Pointer _M_next;\n+  \n+      _Fwd_list_node_base() : _M_next(0) { }\n+  \n+      static void\n+      swap(_Fwd_list_node_base& __x, _Fwd_list_node_base& __y)\n+      { std::swap(__x._M_next, __y._M_next); }\n+  \n+      void\n+      _M_transfer_after(_Pointer __bbegin, _Pointer __bend)\n+      { \n+        _Pointer __keep = __bbegin->_M_next;\n+        if (__bend)\n+          {\n+            __bbegin->_M_next = __bend->_M_next;\n+            __bend->_M_next = this->_M_next;\n+          }\n+        else\n+          __bbegin->_M_next = 0;\n+        this->_M_next = __keep;\n+      }\n+  \n+      void\n+      _M_transfer_after(_Pointer __bbegin)\n+      {\n+        _Pointer __bend = __bbegin;\n+        while (__bend && __bend->_M_next)\n+          __bend = __bend->_M_next;\n+        _M_transfer_after(__bbegin, __bend);\n+      }\n+  \n+      void\n+      _M_reverse_after()\n+      { \n+        _Pointer __tail = this->_M_next;\n+        if (!__tail)\n+          return;\n+        while (_Pointer __temp = __tail->_M_next)\n+          {\n+            _Pointer __keep = this->_M_next;\n+            this->_M_next = __temp;\n+            __tail->_M_next = __temp->_M_next;\n+            this->_M_next->_M_next = __keep;\n+          }\n+      }    \n+    };\n \n   /**\n    *  @brief  A helper node class for @forward_list.\n    *          This is just a linked list with a data value in each node.\n    *          There is a sorting utility method.\n    */\n-  template<typename _Tp>\n-    struct _Fwd_list_node : public _Fwd_list_node_base\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n+    struct _Fwd_list_node : public _Fwd_list_node_base<_Alloc>\n     {\n+      typedef typename _Alloc::template rebind<_Fwd_list_node<_Tp, _Alloc> >\n+        ::other::pointer        _Pointer;\n+\n       template<typename... _Args>\n         _Fwd_list_node(_Args&&... __args)\n-        : _Fwd_list_node_base(), _M_value(std::forward<_Args>(__args)...) { }\n+        : _Fwd_list_node_base<_Alloc>(), \n+          _M_value(std::forward<_Args>(__args)...) { }\n \n       template<typename _Comp>\n         void\n@@ -124,30 +138,32 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    * \n    *   All the functions are op overloads.\n    */\n-  template<typename _Tp>\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     struct _Fwd_list_iterator\n     {\n-      typedef _Fwd_list_iterator<_Tp>           _Self;\n-      typedef _Fwd_list_node<_Tp>               _Node;\n+      typedef _Fwd_list_iterator<_Tp, _Alloc>   _Self;\n+      typedef _Fwd_list_node<_Tp, _Alloc>       _Node;\n+      typedef _Fwd_list_node_base<_Alloc>       _Node_base;\n \n       typedef _Tp                               value_type;\n-      typedef _Tp*                              pointer;\n-      typedef _Tp&                              reference;\n-      typedef ptrdiff_t                         difference_type;\n+      typedef typename _Alloc::pointer          pointer;\n+      typedef typename _Alloc::reference        reference;\n+      typedef typename _Alloc::difference_type  difference_type;\n       typedef std::forward_iterator_tag         iterator_category;\n \n       _Fwd_list_iterator() : _M_node() { }\n \n       explicit\n-      _Fwd_list_iterator(_Fwd_list_node_base* __n) : _M_node(__n) { }\n+      _Fwd_list_iterator(typename _Node_base::_Pointer __n) \n+      : _M_node(__n) { }\n \n       reference\n       operator*() const\n-      { return static_cast<_Node*>(this->_M_node)->_M_value; }\n+      { return __static_pointer_cast<_Node*>(this->_M_node)->_M_value; }\n \n       pointer\n       operator->() const\n-      { return &static_cast<_Node*>(this->_M_node)->_M_value; }\n+      { return &__static_pointer_cast<_Node*>(this->_M_node)->_M_value; }\n \n       _Self&\n       operator++()\n@@ -181,43 +197,44 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n           return _Fwd_list_iterator(0);\n       }\n \n-      _Fwd_list_node_base* _M_node;\n+      typename _Node_base::_Pointer _M_node;\n     };\n \n   /**\n    *   @brief A forward_list::const_iterator.\n    * \n    *   All the functions are op overloads.\n    */\n-  template<typename _Tp>\n+  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >\n     struct _Fwd_list_const_iterator\n     {\n-      typedef _Fwd_list_const_iterator<_Tp>     _Self;\n-      typedef const _Fwd_list_node<_Tp>         _Node;\n-      typedef _Fwd_list_iterator<_Tp>           iterator;\n+      typedef _Fwd_list_const_iterator<_Tp, _Alloc>   _Self;\n+      typedef const _Fwd_list_node<_Tp, _Alloc>       _Node;\n+      typedef const _Fwd_list_node_base<_Alloc>       _Node_base;\n+      typedef _Fwd_list_iterator<_Tp, _Alloc>         iterator;\n \n-      typedef _Tp                               value_type;\n-      typedef const _Tp*                        pointer;\n-      typedef const _Tp&                        reference;\n-      typedef ptrdiff_t                         difference_type;\n-      typedef std::forward_iterator_tag         iterator_category;\n+      typedef _Tp                                     value_type;\n+      typedef typename _Alloc::const_pointer          pointer;\n+      typedef typename _Alloc::const_reference        reference;\n+      typedef typename _Alloc::difference_type        difference_type;\n+      typedef std::forward_iterator_tag               iterator_category;\n \n       _Fwd_list_const_iterator() : _M_node() { }\n \n       explicit\n-      _Fwd_list_const_iterator(const _Fwd_list_node_base* __n)\n+      _Fwd_list_const_iterator(typename _Node_base::_Const_pointer __n) \n       : _M_node(__n) { }\n \n       _Fwd_list_const_iterator(const iterator& __iter)\n       : _M_node(__iter._M_node) { }\n \n       reference\n       operator*() const\n-      { return static_cast<_Node*>(this->_M_node)->_M_value; }\n+      { return __static_pointer_cast<_Node*>(this->_M_node)->_M_value; }\n \n       pointer\n       operator->() const\n-      { return &static_cast<_Node*>(this->_M_node)->_M_value; }\n+      { return &__static_pointer_cast<_Node*>(this->_M_node)->_M_value; }\n \n       _Self&\n       operator++()\n@@ -251,60 +268,61 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n           return _Fwd_list_const_iterator(0);\n       }\n \n-      const _Fwd_list_node_base* _M_node;\n+      typename _Node_base::_Const_pointer _M_node;\n     };\n \n   /**\n    *  @brief  Forward list iterator equality comparison.\n    */\n-  template<typename _Tp>\n+  template<typename _Tp,class _Alloc>\n     inline bool\n-    operator==(const _Fwd_list_iterator<_Tp>& __x,\n-               const _Fwd_list_const_iterator<_Tp>& __y)\n+    operator==(const _Fwd_list_iterator<_Tp, _Alloc>& __x,\n+               const _Fwd_list_const_iterator<_Tp, _Alloc>& __y)\n     { return __x._M_node == __y._M_node; }\n \n   /**\n    *  @brief  Forward list iterator inequality comparison.\n    */\n-  template<typename _Tp>\n+  template<typename _Tp,class _Alloc>\n     inline bool\n-    operator!=(const _Fwd_list_iterator<_Tp>& __x,\n-               const _Fwd_list_const_iterator<_Tp>& __y)\n+    operator!=(const _Fwd_list_iterator<_Tp, _Alloc>& __x,\n+               const _Fwd_list_const_iterator<_Tp, _Alloc>& __y)\n     { return __x._M_node != __y._M_node; }\n \n   /**\n    *  @brief  Base class for @forward_list.\n    */\n-  template<typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     struct _Fwd_list_base\n     {\n     protected:\n-      typedef typename _Alloc::template rebind<_Fwd_list_node<_Tp>>::other\n-        _Node_alloc_type;\n-\n       typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;\n \n+      typedef typename _Alloc::template \n+        rebind<_Fwd_list_node<_Tp, _Tp_alloc_type>>::other _Node_alloc_type;\n+\n       struct _Fwd_list_impl \n       : public _Node_alloc_type\n       {\n-\t_Fwd_list_node_base _M_head;\n+        _Fwd_list_node_base<_Tp_alloc_type> _M_head;\n \n-\t_Fwd_list_impl()\n-\t: _Node_alloc_type(), _M_head()\n-\t{ }\n+        _Fwd_list_impl()\n+        : _Node_alloc_type(), _M_head()\n+        { }\n \n         _Fwd_list_impl(const _Node_alloc_type& __a)\n-\t: _Node_alloc_type(__a), _M_head()\n-\t{ }\n+        : _Node_alloc_type(__a), _M_head()\n+        { }\n       };\n \n       _Fwd_list_impl _M_impl;\n \n     public:\n-      typedef _Fwd_list_iterator<_Tp>         iterator;\n-      typedef _Fwd_list_const_iterator<_Tp>   const_iterator;\n+      typedef _Fwd_list_iterator<_Tp, _Tp_alloc_type>        iterator;\n+      typedef _Fwd_list_const_iterator<_Tp, _Tp_alloc_type>  const_iterator;\n \n-      typedef _Fwd_list_node<_Tp>             _Node;\n+      typedef _Fwd_list_node<_Tp, _Tp_alloc_type>            _Node;\n+      typedef _Fwd_list_node_base<_Tp_alloc_type>            _Node_base;\n \n       _Node_alloc_type&\n       _M_get_Node_allocator()\n@@ -326,56 +344,56 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       _Fwd_list_base(_Fwd_list_base&& __lst, const _Alloc& __a)\n       : _M_impl(__a)\n-      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n-                                  __lst._M_impl._M_head); }\n+      { _Node_base::swap(this->_M_impl._M_head, \n+                         __lst._M_impl._M_head); }\n \n       _Fwd_list_base(_Fwd_list_base&& __lst)\n       : _M_impl(__lst._M_get_Node_allocator())\n-      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n-                                  __lst._M_impl._M_head); }\n+      { _Node_base::swap(this->_M_impl._M_head, \n+                         __lst._M_impl._M_head); }\n \n       ~_Fwd_list_base()\n       { _M_erase_after(&_M_impl._M_head, 0); }\n \n     protected:\n \n-      _Node*\n+      typename _Node::_Pointer\n       _M_get_node()\n       { return _M_get_Node_allocator().allocate(1); }\n \n       template<typename... _Args>\n-        _Node*\n+        typename _Node::_Pointer\n         _M_create_node(_Args&&... __args)\n-\t{\n-\t  _Node* __node = this->_M_get_node();\n-\t  try\n-\t    {\n-\t      _M_get_Node_allocator().construct(__node,\n-\t\t\t\t\t      std::forward<_Args>(__args)...);\n-\t      __node->_M_next = 0;\n-\t    }\n-\t  catch(...)\n-\t    {\n-\t      this->_M_put_node(__node);\n-\t      __throw_exception_again;\n-\t    }\n-\t  return __node;\n-\t}\n+        {\n+          typename _Node::_Pointer __node = this->_M_get_node();\n+          try\n+            {\n+              _M_get_Node_allocator().construct(__node,\n+                                              std::forward<_Args>(__args)...);\n+              __node->_M_next = 0;\n+            }\n+          catch(...)\n+            {\n+              this->_M_put_node(__node);\n+              __throw_exception_again;\n+            }\n+          return __node;\n+        }\n \n       template<typename... _Args>\n-        _Fwd_list_node_base*\n+        typename _Node_base::_Pointer\n         _M_insert_after(const_iterator __pos, _Args&&... __args);\n \n       void\n-      _M_put_node(_Node* __p)\n+      _M_put_node(typename _Node::_Pointer __p)\n       { _M_get_Node_allocator().deallocate(__p, 1); }\n \n-      _Fwd_list_node_base*\n-      _M_erase_after(_Fwd_list_node_base* __pos);\n+      typename _Node_base::_Pointer\n+      _M_erase_after(typename _Node_base::_Pointer __pos);\n \n-      _Fwd_list_node_base*\n-      _M_erase_after(_Fwd_list_node_base* __pos,\n-                     _Fwd_list_node_base* __last);\n+      typename _Node_base::_Pointer\n+      _M_erase_after(typename _Node_base::_Pointer __pos, \n+                     typename _Node_base::_Pointer __last);\n     };\n \n   /**\n@@ -415,7 +433,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     {\n     private:\n       typedef _Fwd_list_base<_Tp, _Alloc>                  _Base;\n-      typedef _Fwd_list_node<_Tp>                          _Node;\n+      typedef typename _Base::_Node                        _Node;\n+      typedef typename _Base::_Node_base                   _Node_base;\n       typedef typename _Base::_Tp_alloc_type               _Tp_alloc_type;\n \n     public:\n@@ -425,8 +444,9 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       typedef typename _Tp_alloc_type::const_pointer       const_pointer;\n       typedef typename _Tp_alloc_type::reference           reference;\n       typedef typename _Tp_alloc_type::const_reference     const_reference;\n-      typedef _Fwd_list_iterator<_Tp>                      iterator;\n-      typedef _Fwd_list_const_iterator<_Tp>                const_iterator;\n+ \n+      typedef typename _Base::iterator                     iterator;\n+      typedef typename _Base::const_iterator               const_iterator;\n       typedef std::size_t                                  size_type;\n       typedef std::ptrdiff_t                               difference_type;\n       typedef _Alloc                                       allocator_type;\n@@ -758,7 +778,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       reference\n       front()\n       {\n-        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+        _Node* __front = __static_pointer_cast<_Node*>(this->_M_impl._M_head._M_next);\n         return __front->_M_value;\n       }\n \n@@ -769,7 +789,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       const_reference\n       front() const\n       {\n-        _Node* __front = static_cast<_Node*>(this->_M_impl._M_head._M_next);\n+        _Node* __front =\n+\t  __static_pointer_cast<_Node*>(this->_M_impl._M_head._M_next);\n         return __front->_M_value;\n       }\n \n@@ -790,7 +811,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n         void\n         emplace_front(_Args&&... __args)\n         { this->_M_insert_after(cbefore_begin(),\n-\t\t\t\tstd::forward<_Args>(__args)...); }\n+                                std::forward<_Args>(__args)...); }\n \n       /**\n        *  @brief  Add data to the front of the %forward_list.\n@@ -846,7 +867,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n         iterator\n         emplace_after(const_iterator __pos, _Args&&... __args)\n         { return iterator(this->_M_insert_after(__pos,\n-\t\t\t\t\t  std::forward<_Args>(__args)...)); }\n+                                          std::forward<_Args>(__args)...)); }\n \n       /**\n        *  @brief  Inserts given value into %forward_list after specified\n@@ -952,8 +973,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       iterator\n       erase_after(const_iterator __pos)\n       {\n-        _Fwd_list_node_base* __tmp\n-          = const_cast<_Fwd_list_node_base*>(__pos._M_node);\n+        _Node_base* __tmp = __const_pointer_cast<_Node_base*>(__pos._M_node);\n         if (__tmp)\n           return iterator(this->_M_erase_after(__tmp));\n         else\n@@ -982,9 +1002,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       iterator\n       erase_after(const_iterator __pos, iterator __last)\n       {\n-        _Fwd_list_node_base* __tmp\n-          = const_cast<_Fwd_list_node_base*>(__pos._M_node);\n-        return iterator(this->_M_erase_after(__tmp, __last._M_node));\n+        _Node_base* __tmp = __const_pointer_cast<_Node_base*>(__pos._M_node);\n+        return iterator(this->_M_erase_after(__tmp, &*__last._M_node));\n       }\n \n       /**\n@@ -999,8 +1018,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n        */\n       void\n       swap(forward_list&& __list)\n-      { _Fwd_list_node_base::swap(this->_M_impl._M_head,\n-                                  __list._M_impl._M_head); }\n+      { _Node_base::swap(this->_M_impl._M_head, __list._M_impl._M_head); }\n \n       /**\n        *  @brief Resizes the %forward_list to the specified number of\n@@ -1188,7 +1206,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       void\n       sort()\n       {\n-        _Node* __tmp = static_cast<_Node*>(&this->_M_impl._M_head);\n+        _Node* __tmp = __static_pointer_cast<_Node*>(&this->_M_impl._M_head);\n         __tmp->_M_sort_after(std::less<_Tp>());\n       }\n \n@@ -1201,10 +1219,10 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       template<typename _Comp>\n         void\n         sort(_Comp __comp)\n-\t{\n-\t  _Node* __tmp = static_cast<_Node*>(&this->_M_impl._M_head);\n-\t  __tmp->_M_sort_after(__comp);\n-\t}\n+        {\n+          _Node* __tmp = __static_pointer_cast<_Node*>(&this->_M_impl._M_head);\n+          __tmp->_M_sort_after(__comp);\n+        }\n \n       /**\n        *  @brief  Reverse the elements in list.\n@@ -1216,15 +1234,15 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n     private:\n       template<typename _Integer>\n-\tvoid\n-\t_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n-\t{ _M_fill_initialize(static_cast<size_type>(__n), __x); }\n+        void\n+        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)\n+        { _M_fill_initialize(static_cast<size_type>(__n), __x); }\n \n       // Called by the range constructor to implement [23.1.1]/9\n       template<typename _InputIterator>\n-\tvoid\n-\t_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n-\t\t\t       __false_type);\n+        void\n+        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n+                               __false_type);\n \n       // Called by forward_list(n,v,a), and the range constructor when it\n       // turns out to be the same thing.\n@@ -1263,7 +1281,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     operator<(const forward_list<_Tp, _Alloc>& __lx,\n               const forward_list<_Tp, _Alloc>& __ly)\n     { return std::lexicographical_compare(__lx.cbegin(), __lx.cend(),\n-  \t\t\t\t\t  __ly.cbegin(), __ly.cend()); }\n+\t\t\t\t\t  __ly.cbegin(), __ly.cend()); }\n \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>"}, {"sha": "bfc814df4a379836a3294a5f1e3dc7010b5560eb", "filename": "libstdc++-v3/include/bits/forward_list.tcc", "status": "modified", "additions": 221, "deletions": 198, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fforward_list.tcc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -41,104 +41,104 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   *          This node is assumed to be an empty head node (of type\n   *          _Fwd_list_node_base).\n   */\n-  template<typename _Tp>\n+  template<typename _Tp, class _Alloc>\n     template<typename _Comp>\n       void\n-      _Fwd_list_node<_Tp>::\n+      _Fwd_list_node<_Tp, _Alloc>::\n       _M_sort_after(_Comp __comp)\n       {\n-\t// If `next' is 0, return immediately.\n-\t_Fwd_list_node* __list = static_cast<_Fwd_list_node*>(this->_M_next);\n-\tif (!__list)\n-\t  return;\n-\n-\tunsigned long __insize = 1;\n-\n-\twhile (1)\n-\t  {\n-\t    _Fwd_list_node* __p = __list;\n-\t    __list = 0;\n-\t    _Fwd_list_node* __tail = 0;\n-\n-\t    // Count number of merges we do in this pass.\n-\t    unsigned long __nmerges = 0;\n-\n-\t    while (__p)\n-\t      {\n-\t\t++__nmerges;\n-\t\t// There exists a merge to be done.\n-\t\t// Step `insize' places along from p.\n-\t\t_Fwd_list_node* __q = __p;\n-\t\tunsigned long __psize = 0;\n-\t\tfor (unsigned long __i = 0; __i < __insize; ++__i)\n-\t\t  {\n-\t\t    ++__psize;\n-\t\t    __q = static_cast<_Fwd_list_node*>(__q->_M_next);\n-\t\t    if (!__q)\n-\t\t      break;\n-\t\t  }\n-\n-\t\t// If q hasn't fallen off end, we have two lists to merge.\n-\t\tunsigned long __qsize = __insize;\n-\n-\t\t// Now we have two lists; merge them.\n-\t\twhile (__psize > 0 || (__qsize > 0 && __q))\n-\t\t  {\n-\t\t    // Decide whether next node of merge comes from p or q.\n-\t\t    _Fwd_list_node<_Tp>* __e;\n-\t\t    if (__psize == 0)\n-\t\t      {\n-\t\t\t// p is empty; e must come from q.\n-\t\t\t__e = __q;\n-\t\t\t__q = static_cast<_Fwd_list_node*>(__q->_M_next);\n-\t\t\t--__qsize;\n-\t\t      }\n-\t\t    else if (__qsize == 0 || !__q)\n-\t\t      {\n-\t\t\t// q is empty; e must come from p.\n-\t\t\t__e = __p;\n-\t\t\t__p = static_cast<_Fwd_list_node*>(__p->_M_next);\n-\t\t\t--__psize;\n-\t\t      }\n-\t\t    else if (__comp(__p->_M_value, __q->_M_value))\n-\t\t      {\n-\t\t\t// First node of p is lower; e must come from p.\n-\t\t\t__e = __p;\n-\t\t\t__p = static_cast<_Fwd_list_node*>(__p->_M_next);\n-\t\t\t--__psize;\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\t// First node of q is lower; e must come from q.\n-\t\t\t__e = __q;\n-\t\t\t__q = static_cast<_Fwd_list_node*>(__q->_M_next);\n-\t\t\t--__qsize;\n-\t\t      }\n-\n-\t\t    // Add the next node to the merged list.\n-\t\t    if (__tail)\n-\t\t      __tail->_M_next = __e;\n-\t\t    else\n-\t\t      __list = __e;\n-\t\t    __tail = __e;\n-\t\t  }\n-\n-\t\t// Now p has stepped `insize' places along, and q has too.\n-\t\t__p = __q;\n-\t      }\n-\t    __tail->_M_next = 0;\n-\n-\t    // If we have done only one merge, we're finished.\n-\t    // Allow for nmerges == 0, the empty list case.\n-\t    if (__nmerges <= 1)\n-\t      {\n-\t\tthis->_M_next = __list;\n-\t\treturn;\n-\t      }\n-\n-\t    // Otherwise repeat, merging lists twice the size.\n-\t    __insize *= 2;\n-\t  }\n+        // If `next' is 0, return immediately.\n+        _Pointer __list = __static_pointer_cast<_Pointer>(this->_M_next);\n+        if (!__list)\n+          return;\n+\n+        unsigned long __insize = 1;\n+\n+        while (1)\n+          {\n+            _Pointer __p = __list;\n+            __list = 0;\n+            _Pointer __tail = 0;\n+\n+            // Count number of merges we do in this pass.\n+            unsigned long __nmerges = 0;\n+\n+            while (__p)\n+              {\n+                ++__nmerges;\n+                // There exists a merge to be done.\n+                // Step `insize' places along from p.\n+                _Pointer __q = __p;\n+                unsigned long __psize = 0;\n+                for (unsigned long __i = 0; __i < __insize; ++__i)\n+                  {\n+                    ++__psize;\n+                    __q = __static_pointer_cast<_Pointer>(__q->_M_next);\n+                    if (!__q)\n+                      break;\n+                  }\n+\n+                // If q hasn't fallen off end, we have two lists to merge.\n+                unsigned long __qsize = __insize;\n+\n+                // Now we have two lists; merge them.\n+                while (__psize > 0 || (__qsize > 0 && __q))\n+                  {\n+                    // Decide whether next node of merge comes from p or q.\n+                    _Pointer __e;\n+                    if (__psize == 0)\n+                      {\n+                        // p is empty; e must come from q.\n+                        __e = __q;\n+                        __q = __static_pointer_cast<_Pointer>(__q->_M_next);\n+                        --__qsize;\n+                      }\n+                    else if (__qsize == 0 || !__q)\n+                      {\n+                        // q is empty; e must come from p.\n+                        __e = __p;\n+                        __p = __static_pointer_cast<_Pointer>(__p->_M_next);\n+                        --__psize;\n+                      }\n+                    else if (__comp(__p->_M_value, __q->_M_value))\n+                      {\n+                        // First node of p is lower; e must come from p.\n+                        __e = __p;\n+                        __p = __static_pointer_cast<_Pointer>(__p->_M_next);\n+                        --__psize;\n+                      }\n+                    else\n+                      {\n+                        // First node of q is lower; e must come from q.\n+                        __e = __q;\n+                        __q = __static_pointer_cast<_Pointer>(__q->_M_next);\n+                        --__qsize;\n+                      }\n+\n+                    // Add the next node to the merged list.\n+                    if (__tail)\n+                      __tail->_M_next = __e;\n+                    else\n+                      __list = __e;\n+                    __tail = __e;\n+                  }\n+\n+                // Now p has stepped `insize' places along, and q has too.\n+                __p = __q;\n+              }\n+            __tail->_M_next = 0;\n+\n+            // If we have done only one merge, we're finished.\n+            // Allow for nmerges == 0, the empty list case.\n+            if (__nmerges <= 1)\n+              {\n+                this->_M_next = __list;\n+                return;\n+              }\n+\n+            // Otherwise repeat, merging lists twice the size.\n+            __insize *= 2;\n+          }\n       }\n  \n   template<typename _Tp, typename _Alloc>\n@@ -147,62 +147,73 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     : _M_impl(__a)\n     {\n       this->_M_impl._M_head._M_next = 0;\n-      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n-      _Node* __curr = static_cast<_Node*>(__lst._M_impl._M_head._M_next);\n+      typename _Node_base::_Pointer __to = &this->_M_impl._M_head;\n+      typename _Node::_Pointer __curr \n+        = __static_pointer_cast<typename _Node::_Pointer>\n+                               (__lst._M_impl._M_head._M_next);\n       while (__curr)\n-\t{\n-\t  __to->_M_next = _M_create_node(__curr->_M_value);\n-\t  __to = __to->_M_next;\n-\t  __curr = static_cast<_Node*>(__curr->_M_next);\n-\t}\n+        {\n+          __to->_M_next = _M_create_node(__curr->_M_value);\n+          __to = __to->_M_next;\n+          __curr = __static_pointer_cast<typename _Node::_Pointer>\n+                                        (__curr->_M_next);\n+        }\n     }\n \n   template<typename _Tp, typename _Alloc>\n     template<typename... _Args>\n-      _Fwd_list_node_base*\n+      typename _Fwd_list_base<_Tp, _Alloc>::_Node_base::_Pointer\n       _Fwd_list_base<_Tp, _Alloc>::\n       _M_insert_after(const_iterator __pos, _Args&&... __args)\n       {\n-\t_Fwd_list_node_base* __to\n-\t  = const_cast<_Fwd_list_node_base*>(__pos._M_node);\n-\t_Node* __thing = _M_create_node(std::forward<_Args>(__args)...);\n-\t__thing->_M_next = __to->_M_next;\n-\t__to->_M_next = __thing;\n-\treturn __to->_M_next;\n+        typename _Node_base::_Pointer __to \n+          = __const_pointer_cast<typename _Node_base::_Pointer>\n+                                (__pos._M_node);\n+        typename _Node::_Pointer __thing \n+          = __static_pointer_cast<typename _Node::_Pointer>( \n+                _M_create_node(std::forward<_Args>(__args)...) );\n+        __thing->_M_next = __to->_M_next;\n+        __to->_M_next = __thing;\n+        return __static_pointer_cast<typename _Node_base::_Pointer>\n+                                    (__to->_M_next);\n       }\n \n   template<typename _Tp, typename _Alloc>\n-    _Fwd_list_node_base*\n+    typename _Fwd_list_base<_Tp, _Alloc>::_Node_base::_Pointer\n     _Fwd_list_base<_Tp, _Alloc>::\n-    _M_erase_after(_Fwd_list_node_base* __pos)\n+    _M_erase_after(typename _Node_base::_Pointer __pos)\n     {\n-      _Node* __curr = static_cast<_Node*>(__pos->_M_next);\n+      typename _Node::_Pointer __curr \n+        = __static_pointer_cast<typename _Node::_Pointer>(__pos->_M_next);\n       if (__curr)\n-\t{\n-\t  _Fwd_list_node_base* __next = __curr->_M_next;\n-\t  __pos->_M_next = __next;\n-\t  _M_get_Node_allocator().destroy(__curr);\n-\t  _M_put_node(__curr);\n-\t}\n+        {\n+          typename _Node_base::_Pointer __next = __curr->_M_next;\n+          __pos->_M_next = __next;\n+          _M_get_Node_allocator().destroy(__curr);\n+          _M_put_node(__curr);\n+        }\n       return __pos;\n     }\n \n   template<typename _Tp, typename _Alloc>\n-    _Fwd_list_node_base*\n+    typename _Fwd_list_base<_Tp, _Alloc>::_Node_base::_Pointer\n     _Fwd_list_base<_Tp, _Alloc>::\n-    _M_erase_after(_Fwd_list_node_base* __pos, _Fwd_list_node_base* __last)\n+    _M_erase_after(typename _Node_base::_Pointer __pos, \n+                   typename _Node_base::_Pointer __last)\n     {\n-      _Node* __curr = static_cast<_Node*>(__pos->_M_next);\n+      typename _Node::_Pointer __curr \n+        = __static_pointer_cast<typename _Node::_Pointer>(__pos->_M_next);\n       while (__curr)\n-\t{\n-\t  _Node* __temp = __curr;\n-\t  __curr = static_cast<_Node*>(__curr->_M_next);\n-\t  _M_get_Node_allocator().destroy(__temp);\n-\t  _M_put_node(__temp);\n-\t  __pos->_M_next = __curr;\n-\t  if (__temp == __last)\n-\t    break;\n-\t}\n+        {\n+          typename _Node::_Pointer __temp = __curr;\n+          __curr = __static_pointer_cast<typename _Node::_Pointer>\n+                                        (__curr->_M_next);\n+          _M_get_Node_allocator().destroy(__temp);\n+          _M_put_node(__temp);\n+          __pos->_M_next = __curr;\n+          if (__temp == __last)\n+            break;\n+        }\n       return __pos;\n     }\n   \n@@ -214,7 +225,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,\n                              __false_type)\n       {\n-        _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+        typename _Node_base::_Pointer __to = &this->_M_impl._M_head;\n         for (; __first != __last; ++__first)\n           {\n             __to->_M_next = this->_M_create_node(*__first);\n@@ -229,7 +240,7 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     forward_list<_Tp, _Alloc>::\n     _M_fill_initialize(size_type __n, const value_type& __value)\n     {\n-      _Fwd_list_node_base* __to = &this->_M_impl._M_head;\n+      typename _Node_base::_Pointer __to = &this->_M_impl._M_head;\n       for (; __n > 0; --__n)\n         {\n           __to->_M_next = this->_M_create_node(__value);\n@@ -243,24 +254,24 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     operator=(const forward_list& __list)\n     {\n       if (&__list != this)\n-\t{\n-\t  iterator __prev1 = before_begin();\n-\t  iterator __curr1 = begin();\n-\t  iterator __last1 = end();\n-\t  const_iterator __first2 = __list.cbegin();\n-\t  const_iterator __last2 = __list.cend();\n-\t  while (__curr1 != __last1 && __first2 != __last2)\n-\t    {\n-\t      *__curr1 = *__first2;\n-\t      ++__prev1;\n-\t      ++__curr1;\n-\t      ++__first2;\n-\t    }\n-\t  if (__first2 == __last2)\n-\t    erase_after(__prev1, __last1);\n-\t  else\n-\t    insert_after(__prev1, __first2, __last2);\n-\t}\n+        {\n+          iterator __prev1 = before_begin();\n+          iterator __curr1 = begin();\n+          iterator __last1 = end();\n+          const_iterator __first2 = __list.cbegin();\n+          const_iterator __last2 = __list.cend();\n+          while (__curr1 != __last1 && __first2 != __last2)\n+            {\n+              *__curr1 = *__first2;\n+              ++__prev1;\n+              ++__curr1;\n+              ++__first2;\n+            }\n+          if (__first2 == __last2)\n+            erase_after(__prev1, __last1);\n+          else\n+            insert_after(__prev1, __first2, __last2);\n+        }\n       return *this;\n     }\n \n@@ -273,14 +284,14 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \n       size_type __len = 0;\n       while (__k._M_next() != end() && __len < __sz)\n-\t{\n-\t  ++__k;\n-\t  ++__len;\n-\t}\n+        {\n+          ++__k;\n+          ++__len;\n+        }\n       if (__len == __sz)\n-\terase_after(__k, end());\n+        erase_after(__k, end());\n       else\n-\tinsert_after(__k, __sz - __len, __val);\n+        insert_after(__k, __sz - __len, __val);\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -289,42 +300,50 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n     splice_after(const_iterator __pos, forward_list&& __list)\n     {\n       if (!__list.empty() && &__list != this)\n-\t{\n-\t  _Fwd_list_node_base* __tmp\n-\t    = const_cast<_Fwd_list_node_base*>(__pos._M_node);\n-\t  const_iterator __before = __list.cbefore_begin();\n-\t  __tmp->_M_transfer_after(const_cast<_Fwd_list_node_base*>\n-\t\t\t\t   (__before._M_node));\n-\t}\n+        {\n+          typename _Node_base::_Pointer __tmp \n+            = __const_pointer_cast<typename _Node_base::_Pointer>\n+                                  (__pos._M_node);\n+          const_iterator __before = __list.cbefore_begin();\n+          __tmp->_M_transfer_after(__const_pointer_cast\n+                                     <typename _Node_base::_Pointer>\n+                                     (__before._M_node));\n+        }\n     }\n \n   template<typename _Tp, typename _Alloc>\n     void\n     forward_list<_Tp, _Alloc>::\n     splice_after(const_iterator __pos, forward_list&& __list,\n-\t\t const_iterator __before, const_iterator __last)\n+                 const_iterator __before, const_iterator __last)\n     {\n-      _Fwd_list_node_base* __tmp\n-\t= const_cast<_Fwd_list_node_base*>(__pos._M_node);\n-      __tmp->_M_transfer_after(const_cast<_Fwd_list_node_base*>\n-\t\t\t       (__before._M_node),\n-\t\t\t       const_cast<_Fwd_list_node_base*>\n-\t\t\t       (__last._M_node));\n+      typename _Node_base::_Pointer __tmp \n+        = __const_pointer_cast<typename _Node_base::_Pointer>(__pos._M_node);\n+      __tmp->_M_transfer_after(__const_pointer_cast\n+                                 <typename _Node_base::_Pointer>\n+                                 (__before._M_node),\n+                               __const_pointer_cast\n+                                 <typename _Node_base::_Pointer>\n+                                 (__last._M_node));\n     }\n \n   template<typename _Tp, typename _Alloc>\n     void\n     forward_list<_Tp, _Alloc>::\n     remove(const _Tp& __val)\n     {\n-      _Node* __curr = static_cast<_Node*>(&this->_M_impl._M_head);\n-      while (_Node* __temp = static_cast<_Node*>(__curr->_M_next))\n-\t{\n-\t  if (__temp->_M_value == __val)\n-\t    this->_M_erase_after(__curr);\n-\t  else\n-\t    __curr = static_cast<_Node*>(__curr->_M_next);\n-\t}\n+      typename _Node::_Pointer __curr \n+        = __static_pointer_cast<typename _Node::_Pointer>\n+                               (&this->_M_impl._M_head);\n+      while (typename _Node::_Pointer __temp = \n+             __static_pointer_cast<typename _Node::_Pointer>(__curr->_M_next))\n+        {\n+          if (__temp->_M_value == __val)\n+            this->_M_erase_after(__curr);\n+          else\n+            __curr = __static_pointer_cast<typename _Node::_Pointer>\n+                                          (__curr->_M_next);\n+        }\n     }\n \n   template<typename _Tp, typename _Alloc>\n@@ -333,14 +352,18 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       forward_list<_Tp, _Alloc>::\n       remove_if(_Pred __pred)\n       {\n-\t_Node* __curr = static_cast<_Node*>(&this->_M_impl._M_head);\n-\twhile (_Node* __temp = static_cast<_Node*>(__curr->_M_next))\n-\t  {\n-\t    if (__pred(__temp->_M_value))\n-\t      this->_M_erase_after(__curr);\n-\t    else\n-\t      __curr = static_cast<_Node*>(__curr->_M_next);\n-\t  }\n+        typename _Node::_Pointer __curr \n+          = __static_pointer_cast<typename _Node::_Pointer>\n+                                 (&this->_M_impl._M_head);\n+        while (typename _Node::_Pointer __temp = \n+               __static_pointer_cast<typename _Node::_Pointer>(__curr->_M_next))\n+          {\n+            if (__pred(__temp->_M_value))\n+              this->_M_erase_after(__curr);\n+            else\n+              __curr = __static_pointer_cast<typename _Node::_Pointer>\n+                                            (__curr->_M_next);\n+          }\n       }\n \n   template<typename _Tp, typename _Alloc>\n@@ -352,16 +375,16 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n         iterator __first = begin();\n         iterator __last = end();\n         if (__first == __last)\n-\t  return;\n+          return;\n         iterator __next = __first;\n         while (++__next != __last)\n-\t{\n-\t  if (__binary_pred(*__first, *__next))\n-\t    erase_after(__first);\n-\t  else\n-\t    __first = __next;\n-\t  __next = __first;\n-\t}\n+        {\n+          if (__binary_pred(*__first, *__next))\n+            erase_after(__first);\n+          else\n+            __first = __next;\n+          __next = __first;\n+        }\n       }\n \n   template<typename _Tp, typename _Alloc>\n@@ -370,13 +393,13 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       forward_list<_Tp, _Alloc>::\n       merge(forward_list&& __list, _Comp __comp)\n       {\n-        _Fwd_list_node_base* __node = &this->_M_impl._M_head;\n+        typename _Node_base::_Pointer __node = &this->_M_impl._M_head;\n         while (__node->_M_next && __list._M_impl._M_head._M_next)\n           {\n-            if (__comp(static_cast<_Node*>\n-\t\t       (__list._M_impl._M_head._M_next)->_M_value,\n-                       static_cast<_Node*>\n-\t\t       (__node->_M_next)->_M_value))\n+            if (__comp(__static_pointer_cast<typename _Node::_Pointer>\n+                       (__list._M_impl._M_head._M_next)->_M_value,\n+                       __static_pointer_cast<typename _Node::_Pointer>\n+                       (__node->_M_next)->_M_value))\n               __node->_M_transfer_after(&__list._M_impl._M_head,\n                                         __list._M_impl._M_head._M_next);\n             __node = __node->_M_next;"}, {"sha": "c4b90b7aa7da00c11ef650c1dbe1e2ac78148d96", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/1.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2F1.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,99 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list capacity [lib.forward_list.capacity]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+// This test verifies the following.\n+//\n+void\n+test01()\n+{\n+  std::forward_list<double, _ExtPtr_allocator<double> > fld;\n+\n+  VERIFY(fld.empty() == true);\n+  fld.push_front(1.0);\n+  VERIFY(fld.empty() == false);\n+  fld.resize(0);\n+  VERIFY(fld.empty() == true);\n+}\n+\n+void\n+test02()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > a, b;\n+  a.push_front(1);\n+\n+  b = std::move(a);\n+  VERIFY(b.empty() == false);\n+  VERIFY(*b.begin() == 1);\n+  VERIFY(a.empty() == true);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > c(std::move(b));\n+  VERIFY(c.empty() == false);\n+  (*c.begin() == 1 );\n+  VERIFY( b.empty() == true );\n+}\n+\n+// Test various constrcutors \n+void\n+test03()\n+{\n+  const int ni = 10;\n+  int i[ni] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  _ExtPtr_allocator<int>  alloc;\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > flccin(i, i+ni);\n+  std::forward_list<int, _ExtPtr_allocator<int> > flc(flccin);\n+  std::forward_list<int, _ExtPtr_allocator<int> > flm(std::move(flccin));\n+  std::forward_list<int, _ExtPtr_allocator<int> > flcc(flccin, alloc );\n+  std::forward_list<int, _ExtPtr_allocator<int> > flmc(\n+\tstd::forward_list<int, _ExtPtr_allocator<int> >(i, i+ni), alloc);\n+  std::forward_list<double, _ExtPtr_allocator<double> > flil(\n+        {1.0, 2.0, 3.0, 4.0, 5.0});\n+}\n+\n+// Test constrcutors \n+//   Construction from given number of default item\n+//   Construction from given number of given item\n+void\n+test04()\n+{\n+  std::forward_list<double, _ExtPtr_allocator<double> > flvd(10);\n+  std::forward_list<float, _ExtPtr_allocator<float> > flv(10, 5.0F);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  return 0;\n+}"}, {"sha": "0df4d44423de3fe5066b45e3eb9cd88e19074e65", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/modifiers/1.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F1.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+#include <array>\n+\n+bool test __attribute__((unused)) = true;\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+class PathPoint\n+{\n+public:\n+  PathPoint(char t, std::array<double, 3> & c)\n+  : type(t), coord(c) { }\n+  char getType() const { return type; }\n+private:\n+  char type;\n+  std::array<double, 3> coord;\n+};\n+\n+// This test verifies the following.\n+//   emplace_front\n+//   pop_front\n+//   emplace_after\n+void\n+test01()\n+{\n+  std::forward_list<PathPoint, _ExtPtr_allocator<PathPoint> > path;\n+  std::array<double, 3> coord1 = { { 0.0, 1.0, 2.0 } };\n+  path.emplace_front('a', coord1);\n+\n+  std::forward_list<PathPoint, _ExtPtr_allocator<PathPoint> >::const_iterator pos = path.cbegin();\n+\n+  std::array<double, 3> coord2 = { { 3.0, 4.0, 5.0 } };\n+  path.emplace_after(pos, 'b', coord2);\n+\n+  VERIFY(path.front().getType() == 'a');\n+\n+  path.pop_front();\n+\n+  VERIFY(path.front().getType() == 'b');\n+\n+  path.pop_front();\n+\n+  VERIFY(path.empty() == true);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "27264b36e6dfecaed851d731efeb3ad1e37ede72", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/modifiers/2.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F2.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,151 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+#include <string>\n+\n+bool test __attribute__((unused)) = true;\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+// This test verifies the following:\n+//   insert_after single item\n+//   before_begin iterator\n+void\n+test01()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  fl.insert_after(fl.before_begin(), 42);\n+  VERIFY(fl.front() == 42);\n+}\n+\n+// This test verifies the following:\n+void\n+test02()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  // Note: Calling l.insert_after(pos, 5, 42); without the long five\n+  // gets resolved to the iterator range version and fails to compile!\n+  fl.insert_after(pos, 5, 42);\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  VERIFY(*pos == 42);\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == 42);\n+}\n+\n+// This test verifies the following:\n+void\n+test03()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  int i[3] = {666, 777, 888};\n+  fl.insert_after(pos, i, i+3);\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == 888);\n+  ++pos;\n+  VERIFY(*pos == 2);\n+}\n+\n+// This test verifies the following:\n+void\n+test04()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  fl.insert_after(pos, {-1, -2, -3, -4, -5});\n+  VERIFY(*pos == 1);\n+\n+  ++pos;\n+  ++pos;\n+  ++pos;\n+  VERIFY(*pos == -3);\n+}\n+\n+// This test verifies the following:\n+void\n+test05()\n+{\n+  std::forward_list<std::string, _ExtPtr_allocator<std::string> > fl(\n+    {\"AAA\", \"BBB\", \"CCC\"});\n+\n+  std::forward_list<std::string, _ExtPtr_allocator<std::string> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == \"BBB\");\n+\n+  std::string x( \"XXX\" );\n+  fl.insert_after(pos, std::move(x));\n+  VERIFY(*pos == \"BBB\");\n+  ++pos;\n+  VERIFY(*pos == \"XXX\");\n+  ++pos;\n+  VERIFY(*pos == \"CCC\");\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  return 0;\n+}"}, {"sha": "24ac7881570e3e4c912dfeec6e7673bced49f3c9", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/modifiers/3.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F3.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,98 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+// This test verifies the following:\n+//   cbegin\n+//   erase_after one iterator\n+//   pos is useable and points to current element\n+void\n+test01()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::iterator \n+    next = fl.erase_after(pos);\n+\n+  VERIFY(*next == 1);\n+\n+  VERIFY(*pos == 1);\n+  ++pos;\n+  VERIFY(*pos == 3);\n+}\n+\n+// This test verifies the following:\n+//   cbegin\n+//   erase_after iterator range\n+//   pos is useable and points to current element\n+void\n+test02()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+\n+  ++pos;\n+  VERIFY(*pos == 1);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::iterator \n+    stop = fl.begin();\n+\n+  ++stop;\n+  ++stop;\n+  ++stop;\n+  ++stop;\n+  VERIFY(*stop == 4);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::iterator \n+    next = fl.erase_after(pos, stop);\n+\n+  VERIFY(*next == 1);\n+\n+  VERIFY(*pos == 1);\n+  ++pos;\n+  VERIFY(*pos == 5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "6e947fdf247bc3af5ce257273ba486f2b9702814", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/modifiers/4.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F4.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+\n+// This test verifies the following:\n+//   swap\n+void\n+test01()\n+{\n+  std::forward_list<int> fl1({0, 1, 2, 3, 4, 5});\n+  std::forward_list<int> fl2({666, 777, 888});\n+\n+  fl1.swap(fl2);\n+\n+  VERIFY(fl1.front() == 666);\n+  VERIFY(fl2.front() == 0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "114b9bd03a66d4bed8c293f282aa67692b6bb533", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/modifiers/5.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Fmodifiers%2F5.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,49 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   clear\n+void\n+test01()\n+{\n+  std::forward_list<int, __gnu_cxx::_ExtPtr_allocator<int> > fl(\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9});\n+\n+  VERIFY(fl.empty() == false);\n+\n+  fl.clear();\n+\n+  VERIFY(fl.empty() == true);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "dcb75929fe0af16519fcf075d0aae04de6a7785c", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/1.cc", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F1.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,116 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  typedef std::forward_list<double, _ExtPtr_allocator<double> > fwd_list_type;\n+\n+  fwd_list_type a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  fwd_list_type::const_iterator posa = a.cbefore_begin();\n+\n+  fwd_list_type x = {666.0, 777.0, 888.0};\n+\n+  a.splice_after(posa, x);\n+\n+  ++posa;\n+  VERIFY(*posa == 666.0);\n+\n+  VERIFY(x.empty() == true);\n+}\n+\n+// This test verifies the following:\n+//   \n+void\n+test02()\n+{\n+  typedef std::forward_list<double, _ExtPtr_allocator<double> > fwd_list_type;\n+\n+  fwd_list_type a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  fwd_list_type::const_iterator posa = a.cbefore_begin();\n+  ++posa;\n+  VERIFY(*posa == 0.0);\n+\n+  fwd_list_type y = {10.0, 11.0, 12.0, 13.0, 14.0, 15.0};\n+  fwd_list_type::const_iterator befy = y.cbefore_begin();\n+  ++befy;\n+  VERIFY(*befy == 10.0);\n+  fwd_list_type::const_iterator endy = befy;\n+  ++endy;\n+  ++endy;\n+  ++endy;\n+  ++endy;\n+  VERIFY(*endy == 14.0);\n+\n+  a.splice_after(posa, y, befy, endy);\n+  VERIFY(*posa == 0.0);\n+\n+  VERIFY(*befy == 10.0);\n+  ++befy;\n+  VERIFY(*befy == 15.0);\n+}\n+\n+// This test verifies the following:\n+//   \n+void\n+test03()\n+{\n+  typedef std::forward_list<double, _ExtPtr_allocator<double> > fwd_list_type;\n+\n+  fwd_list_type a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  fwd_list_type::const_iterator posa = a.cbefore_begin();\n+  ++posa;\n+  ++posa;\n+  VERIFY(*posa == 1.0);\n+\n+  fwd_list_type z = {42.0, 43.0, 44.0};\n+  fwd_list_type::const_iterator posz = z.begin();\n+  VERIFY(*posz == 42.0);\n+\n+  a.splice_after(posa, z, posz);\n+  VERIFY(*posa == 1.0);\n+  ++posa;\n+  VERIFY(*posa == 43.0);\n+\n+  VERIFY(*posz == 42.0);\n+  ++posz;\n+  VERIFY(*posz == 44.0);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "245bc416911fedd3a60b69417bc8eb338fc18e62", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/2.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F2.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   remove\n+void\n+test01()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl =\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  fl.remove(7);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbefore_begin();\n+\n+  for (std::size_t i = 0; i < 7; ++i)\n+    ++pos;\n+  VERIFY(*pos == 6);\n+\n+  ++pos;\n+  VERIFY(*pos == 8);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4290f46ef8a43eebc0275ca7f45d17f24d865ffc", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/3.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F3.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+#include <algorithm>\n+\n+bool test __attribute__((unused)) = true;\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+// This test verifies the following:\n+//   remove_if\n+void\n+test01()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl =\n+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n+\n+  fl.remove_if(std::bind2nd(std::less<int>(),5));\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> >::const_iterator \n+    pos = fl.cbegin();\n+  VERIFY(*pos == 5);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "62a8bf4d4136b97d7771f8d9507235e54c593777", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/4.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F4.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,86 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   unique\n+void\n+test01()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl = \n+    {99, 5, 99, 6, -5, 666, 777, 888, 42, 42, 42, 42, 42, 7, 0, 0, 0, 9, 9, 9};\n+\n+  fl.unique();\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl2 = \n+    {99, 5, 99, 6, -5, 666, 777, 888, 42, 7, 0, 9};\n+\n+  VERIFY(fl == fl2);\n+}\n+\n+//  Test comparison predicate.\n+template<typename Num>\n+  class Mod\n+  {\n+  public:\n+    Mod(const Num & mod)\n+      {\n+        m = mod;\n+      }\n+    bool operator()(const Num i, const Num j)\n+      {\n+        return i%m == j%m;\n+      }\n+  private:\n+    Num m;\n+  };\n+\n+// This test verifies the following:\n+//   unique with predicate\n+void\n+test02()\n+{\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl = \n+    {99, 5, 99, 6, -5, 666, 777, 888, 42, 7, 0, 9};\n+\n+  fl.unique(Mod<int>(111));\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl2 = \n+    {99, 5, 99, 6, -5, 666, 42, 7, 0, 9};\n+\n+  VERIFY(fl == fl2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "1f43f21a93643849eca2ca5e57f337f6bebb1a7b", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/5.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F5.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  typedef std::forward_list<double, _ExtPtr_allocator<double> > fwd_list_type;\n+\n+  fwd_list_type a = {0.0, 1.0, 2.0, 3.0, 4.0};\n+  fwd_list_type b = {1.0, 2.0, 3.0, 4.0, 4.0, 5.0};\n+\n+  a.merge(b);\n+\n+  fwd_list_type r = {0.0, 1.0, 1.0, 2.0, 2.0, 3.0, 3.0, 4.0, 4.0, 4.0, 5.0};\n+\n+  VERIFY(a == r);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "a3580569febcd7ca0ba373d44bcff282530fef83", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/6.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F6.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+//  Comparison functor.\n+template<typename Num>\n+  class Comp\n+  {\n+  public:\n+    Comp(const Num & num)\n+      {\n+        n = num;\n+      }\n+    bool operator()(const Num i, const Num j)\n+      {\n+        return (n * i) < (n * j);\n+      }\n+  private:\n+    Num n;\n+  };\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  typedef std::forward_list<int, _ExtPtr_allocator<int> > fwd_list_type;\n+\n+  const unsigned int n = 13;\n+  int order[][n] = {\n+    { 0,1,2,3,4,5,6,7,8,9,10,11,12 },\n+    { 6,2,8,4,11,1,12,7,3,9,5,0,10 },\n+    { 12,11,10,9,8,7,6,5,4,3,2,1,0 },\n+  };\n+  fwd_list_type sorted(order[0], order[0] + n);\n+\n+  for (unsigned int i = 0; i < sizeof(order)/sizeof(*order); ++i)\n+    {\n+      fwd_list_type head(order[i], order[i] + n);\n+\n+      head.sort();\n+\n+      VERIFY(head == sorted);\n+    }\n+\n+  fwd_list_type reversed(order[2], order[2] + n);\n+  for (unsigned int i = 0; i < sizeof(order)/sizeof(*order); ++i)\n+    {\n+      fwd_list_type head(order[i], order[i] + n);\n+\n+      Comp<int> comp(-1);\n+      head.sort( comp );\n+\n+      VERIFY(head == reversed);\n+    }\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "e73504cabdb7380fa507999a471595e4f3b068e2", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/operations/7.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F7.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F7.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Foperations%2F7.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <testsuite_hooks.h>\n+#include <ext/extptr_allocator.h>\n+\n+#include <algorithm>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// This test verifies the following:\n+//   \n+void\n+test01()\n+{\n+  const unsigned int n = 13;\n+  int order[n] = {0,1,2,3,4,5,6,7,8,9,10,11,12};\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl(order, order + n);\n+\n+  std::forward_list<int, _ExtPtr_allocator<int> > fl2;\n+  for (std::size_t i = 0; i < n; ++i)\n+    fl2.push_front(order[i]);\n+\n+  fl.reverse();\n+\n+  VERIFY(std::lexicographical_compare(fl.begin(), fl.end(),\n+                                      fl2.begin(), fl2.end()) == false);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "484df00164fb8ee9774ba1b32530ff9e7fa542c2", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/requirements/1.cc", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2F1.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,73 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 23.2.3.n forward_list xxx [lib.forward_list.xxx]\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_cxx::_ExtPtr_allocator;\n+\n+bool test __attribute__((unused)) = true;\n+\n+// A nontrivial type.\n+template<typename T>\n+  struct A { };\n+\n+// Another nontrivial type\n+struct B { };\n+\n+// A nontrivial type convertible from an int\n+struct C\n+{\n+  C(int i) : i_(i) { }\n+  bool operator==(const C& rhs) { return i_ == rhs.i_; }\n+  int i_;\n+};\n+\n+// This test verifies the following.\n+//\n+void\n+test01()\n+{\n+  std::forward_list< A<B>, _ExtPtr_allocator<A<B> > > lst;\n+  VERIFY(lst.begin() == lst.end());\n+  VERIFY(std::distance(lst.begin(), lst.end()) == 0);\n+\n+  // check type definitions -- will fail compile if missing\n+  typedef std::forward_list< A<B> >::reference              reference;\n+  typedef std::forward_list< A<B> >::const_reference        const_reference;\n+  typedef std::forward_list< A<B> >::iterator               iterator;\n+  typedef std::forward_list< A<B> >::const_iterator         const_iterator;\n+  typedef std::forward_list< A<B> >::size_type              size_type;\n+  typedef std::forward_list< A<B> >::difference_type        difference_type;\n+  typedef std::forward_list< A<B> >::value_type             value_type;\n+  typedef std::forward_list< A<B> >::allocator_type         allocator_type;\n+  typedef std::forward_list< A<B> >::pointer                pointer;\n+  typedef std::forward_list< A<B> >::const_pointer          const_pointer;\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "900508edad64487d3443f08a400e0b79d77a0836", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/requirements/explicit_instantiation/1.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F1.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+\n+// { dg-do compile }\n+\n+template class std::forward_list<int, __gnu_cxx::_ExtPtr_allocator<int> >;"}, {"sha": "6d8e5c562a29bbe4ddc060b43559607cb1988d1c", "filename": "libstdc++-v3/testsuite/23_containers/forward_list/ext_pointer/requirements/explicit_instantiation/3.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b32e4e506aa3acd719c60d4287f30fc696a6d47/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fforward_list%2Fext_pointer%2Frequirements%2Fexplicit_instantiation%2F3.cc?ref=1b32e4e506aa3acd719c60d4287f30fc696a6d47", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2008 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// This file tests explicit instantiation of library containers\n+\n+#include <forward_list>\n+#include <ext/extptr_allocator.h>\n+\n+// { dg-do compile }\n+\n+// libstdc++/21770\n+template class std::forward_list<int, __gnu_cxx::_ExtPtr_allocator<char> >;"}]}