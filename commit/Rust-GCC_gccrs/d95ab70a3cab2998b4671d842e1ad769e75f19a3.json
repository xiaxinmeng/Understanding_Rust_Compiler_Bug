{"sha": "d95ab70a3cab2998b4671d842e1ad769e75f19a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDk1YWI3MGEzY2FiMjk5OGI0NjcxZDg0MmUxYWQ3NjllNzVmMTlhMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-12-02T09:08:49Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-12-02T09:08:49Z"}, "message": "PR 68432: Add a target hook to control size/speed optab choices\n\nThe problem in the PR is that some i386 optabs FAIL when\noptimising for size rather than speed.  The gimple level generally\nneeds access to this information before calling the generator,\nso this patch adds a new hook to say whether an optab should\nbe used when optimising for size or speed.  It also has a \"both\"\noption for cases where we want code that is optimised for both\nsize and speed.\n\nI've passed the optab to the target hook because I think in most\ncases that's more useful than the instruction code.  We could pass\nboth if there's a use for it though.\n\nAt the moment the match-and-simplify code doesn't have direct access\nto the target block, so for now I've used \"both\" there.\n\nTested on x86_64-linux-gnu and powerpc64-linux-gnu.\n\ngcc/\n\tPR tree-optimization/68432\n\t* coretypes.h (optimization_type): New enum.\n\t* doc/tm.texi.in (TARGET_OPTAB_SUPPORTED_P): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* target.def (optab_supported_p): New hook.\n\t* targhooks.h (default_optab_supported_p): Declare.\n\t* targhooks.c (default_optab_supported_p): New function.\n\t* predict.h (function_optimization_type): Declare.\n\t(bb_optimization_type): Likewise.\n\t* predict.c (function_optimization_type): New function.\n\t(bb_optimization_type): Likewise.\n\t* optabs-query.h (convert_optab_handler): Define an overload\n\tthat takes an optimization type.\n\t(direct_optab_handler): Likewise.\n\t* optabs-query.c (convert_optab_handler): Likewise.\n\t(direct_optab_handler): Likewise.\n\t* internal-fn.h (direct_internal_fn_supported_p): Take an\n\toptimization_type argument.\n\t* internal-fn.c (direct_optab_supported_p): Likewise.\n\t(multi_vector_optab_supported_p): Likewise.\n\t(direct_internal_fn_supported_p): Likewise.\n\t* builtins.c (replacement_internal_fn): Update call to\n\tdirect_internal_fn_supported_p.\n\t* gimple-match-head.c (build_call_internal): Likewise.\n\t* tree-vect-patterns.c (vect_recog_pow_pattern): Likewise.\n\t* tree-vect-stmts.c (vectorizable_internal_function): Likewise.\n\t* tree.c (maybe_build_call_expr_loc): Likewise.\n\t* config/i386/i386.c (ix86_optab_supported_p): New function.\n\t(TARGET_OPTAB_SUPPORTED_P): Define.\n\t* config/i386/i386.md (asinxf2): Remove optimize_insn_for_size_p check.\n\t(asin<mode>2, acosxf2, acos<mode>2, log1pxf2, log1p<mode>2)\n\t(expNcorexf3, expxf2, exp<mode>2, exp10xf2, exp10<mode>2, exp2xf2)\n\t(exp2<mode>2, expm1xf2, expm1<mode>2, ldexpxf3, ldexp<mode>3)\n\t(scalbxf3, scalb<mode>3, rint<mode>2, round<mode>2)\n\t(<rounding_insn>xf2, <rounding_insn><mode>2): Likewise.\n\ngcc/testsuite/\n\t* gcc.target/i386/pr68432-1.c: New test.\n\t* gcc.target/i386/pr68432-2.c: Likewise.\n\t* gcc.target/i386/pr68432-3.c: Likewise.\n\nFrom-SVN: r231161", "tree": {"sha": "72dd378628c948224552d17ec9c275577e55462a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72dd378628c948224552d17ec9c275577e55462a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d95ab70a3cab2998b4671d842e1ad769e75f19a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95ab70a3cab2998b4671d842e1ad769e75f19a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d95ab70a3cab2998b4671d842e1ad769e75f19a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d95ab70a3cab2998b4671d842e1ad769e75f19a3/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "886456e210ef12d77f625ace8f312ab23d208aff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886456e210ef12d77f625ace8f312ab23d208aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886456e210ef12d77f625ace8f312ab23d208aff"}], "stats": {"total": 388, "additions": 297, "deletions": 91}, "files": [{"sha": "b7e853d061df863e605349c5568f1d63f1c88933", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1,3 +1,41 @@\n+2015-12-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR tree-optimization/68432\n+\t* coretypes.h (optimization_type): New enum.\n+\t* doc/tm.texi.in (TARGET_OPTAB_SUPPORTED_P): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* target.def (optab_supported_p): New hook.\n+\t* targhooks.h (default_optab_supported_p): Declare.\n+\t* targhooks.c (default_optab_supported_p): New function.\n+\t* predict.h (function_optimization_type): Declare.\n+\t(bb_optimization_type): Likewise.\n+\t* predict.c (function_optimization_type): New function.\n+\t(bb_optimization_type): Likewise.\n+\t* optabs-query.h (convert_optab_handler): Define an overload\n+\tthat takes an optimization type.\n+\t(direct_optab_handler): Likewise.\n+\t* optabs-query.c (convert_optab_handler): Likewise.\n+\t(direct_optab_handler): Likewise.\n+\t* internal-fn.h (direct_internal_fn_supported_p): Take an\n+\toptimization_type argument.\n+\t* internal-fn.c (direct_optab_supported_p): Likewise.\n+\t(multi_vector_optab_supported_p): Likewise.\n+\t(direct_internal_fn_supported_p): Likewise.\n+\t* builtins.c (replacement_internal_fn): Update call to\n+\tdirect_internal_fn_supported_p.\n+\t* gimple-match-head.c (build_call_internal): Likewise.\n+\t* tree-vect-patterns.c (vect_recog_pow_pattern): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_internal_function): Likewise.\n+\t* tree.c (maybe_build_call_expr_loc): Likewise.\n+\t* config/i386/i386.c (ix86_optab_supported_p): New function.\n+\t(TARGET_OPTAB_SUPPORTED_P): Define.\n+\t* config/i386/i386.md (asinxf2): Remove optimize_insn_for_size_p check.\n+\t(asin<mode>2, acosxf2, acos<mode>2, log1pxf2, log1p<mode>2)\n+\t(expNcorexf3, expxf2, exp<mode>2, exp10xf2, exp10<mode>2, exp2xf2)\n+\t(exp2<mode>2, expm1xf2, expm1<mode>2, ldexpxf3, ldexp<mode>3)\n+\t(scalbxf3, scalb<mode>3, rint<mode>2, round<mode>2)\n+\t(<rounding_insn>xf2, <rounding_insn><mode>2): Likewise.\n+\n 2015-12-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* Makefile.in (GENSUPPORT_H): New macro."}, {"sha": "7c614e6336edf4c10646d26a94c21c66e5bf1b29", "filename": "gcc/builtins.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1962,7 +1962,8 @@ replacement_internal_fn (gcall *call)\n       if (ifn != IFN_LAST)\n \t{\n \t  tree_pair types = direct_internal_fn_types (ifn, call);\n-\t  if (direct_internal_fn_supported_p (ifn, types))\n+\t  optimization_type opt_type = bb_optimization_type (gimple_bb (call));\n+\t  if (direct_internal_fn_supported_p (ifn, types, opt_type))\n \t    return ifn;\n \t}\n     }"}, {"sha": "05e7fe6d39ae5077c0bbe498bf235e09e2a5189f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -54100,6 +54100,49 @@ ix86_operands_ok_for_move_multiple (rtx *operands, bool load,\n   return true;\n }\n \n+/* Implement the TARGET_OPTAB_SUPPORTED_P hook.  */\n+\n+static bool\n+ix86_optab_supported_p (int op, machine_mode mode1, machine_mode,\n+\t\t\toptimization_type opt_type)\n+{\n+  switch (op)\n+    {\n+    case asin_optab:\n+    case acos_optab:\n+    case log1p_optab:\n+    case exp_optab:\n+    case exp10_optab:\n+    case exp2_optab:\n+    case expm1_optab:\n+    case ldexp_optab:\n+    case scalb_optab:\n+    case round_optab:\n+      return opt_type == OPTIMIZE_FOR_SPEED;\n+\n+    case rint_optab:\n+      if (SSE_FLOAT_MODE_P (mode1)\n+\t  && TARGET_SSE_MATH\n+\t  && !flag_trapping_math\n+\t  && !TARGET_ROUND)\n+\treturn opt_type == OPTIMIZE_FOR_SPEED;\n+      return true;\n+\n+    case floor_optab:\n+    case ceil_optab:\n+    case btrunc_optab:\n+      if (SSE_FLOAT_MODE_P (mode1)\n+\t  && TARGET_SSE_MATH\n+\t  && !flag_trapping_math\n+\t  && TARGET_ROUND)\n+\treturn true;\n+      return opt_type == OPTIMIZE_FOR_SPEED;\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Address space support.\n \n    This is not \"far pointers\" in the 16-bit sense, but an easy way\n@@ -54645,6 +54688,9 @@ ix86_addr_space_zero_address_valid (addr_space_t as)\n #undef TARGET_ABSOLUTE_BIGGEST_ALIGNMENT\n #define TARGET_ABSOLUTE_BIGGEST_ALIGNMENT 512\n \n+#undef TARGET_OPTAB_SUPPORTED_P\n+#define TARGET_OPTAB_SUPPORTED_P ix86_optab_supported_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-i386.h\""}, {"sha": "e8c5f061331b9f63f86f026fa23d01dd3fc79880", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 68, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -14726,9 +14726,6 @@\n {\n   int i;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   for (i = 2; i < 6; i++)\n     operands[i] = gen_reg_rtx (XFmode);\n \n@@ -14746,9 +14743,6 @@\n   rtx op0 = gen_reg_rtx (XFmode);\n   rtx op1 = gen_reg_rtx (XFmode);\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   emit_insn (gen_extend<mode>xf2 (op1, operands[1]));\n   emit_insn (gen_asinxf2 (op0, op1));\n   emit_insn (gen_truncxf<mode>2_i387_noop (operands[0], op0));\n@@ -14770,9 +14764,6 @@\n {\n   int i;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   for (i = 2; i < 6; i++)\n     operands[i] = gen_reg_rtx (XFmode);\n \n@@ -14790,9 +14781,6 @@\n   rtx op0 = gen_reg_rtx (XFmode);\n   rtx op1 = gen_reg_rtx (XFmode);\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   emit_insn (gen_extend<mode>xf2 (op1, operands[1]));\n   emit_insn (gen_acosxf2 (op0, op1));\n   emit_insn (gen_truncxf<mode>2_i387_noop (operands[0], op0));\n@@ -14953,9 +14941,6 @@\n   \"TARGET_USE_FANCY_MATH_387\n    && flag_unsafe_math_optimizations\"\n {\n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   ix86_emit_i387_log1p (operands[0], operands[1]);\n   DONE;\n })\n@@ -14970,9 +14955,6 @@\n {\n   rtx op0;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n \n   operands[1] = gen_rtx_FLOAT_EXTEND (XFmode, operands[1]);\n@@ -15121,9 +15103,6 @@\n {\n   int i;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   for (i = 3; i < 10; i++)\n     operands[i] = gen_reg_rtx (XFmode);\n \n@@ -15138,9 +15117,6 @@\n {\n   rtx op2;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op2 = gen_reg_rtx (XFmode);\n   emit_move_insn (op2, standard_80387_constant_rtx (5)); /* fldl2e */\n \n@@ -15158,9 +15134,6 @@\n {\n   rtx op0, op1;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n \n@@ -15178,9 +15151,6 @@\n {\n   rtx op2;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op2 = gen_reg_rtx (XFmode);\n   emit_move_insn (op2, standard_80387_constant_rtx (6)); /* fldl2t */\n \n@@ -15198,9 +15168,6 @@\n {\n   rtx op0, op1;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n \n@@ -15218,9 +15185,6 @@\n {\n   rtx op2;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op2 = gen_reg_rtx (XFmode);\n   emit_move_insn (op2, CONST1_RTX (XFmode));  /* fld1 */\n \n@@ -15238,9 +15202,6 @@\n {\n   rtx op0, op1;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n \n@@ -15278,9 +15239,6 @@\n {\n   int i;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   for (i = 2; i < 13; i++)\n     operands[i] = gen_reg_rtx (XFmode);\n \n@@ -15300,9 +15258,6 @@\n {\n   rtx op0, op1;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n \n@@ -15320,8 +15275,6 @@\n    && flag_unsafe_math_optimizations\"\n {\n   rtx tmp1, tmp2;\n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n \n   tmp1 = gen_reg_rtx (XFmode);\n   tmp2 = gen_reg_rtx (XFmode);\n@@ -15343,9 +15296,6 @@\n {\n   rtx op0, op1;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n \n@@ -15366,9 +15316,6 @@\n   \"TARGET_USE_FANCY_MATH_387\n    && flag_unsafe_math_optimizations\"\n {\n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   operands[3] = gen_reg_rtx (XFmode);\n })\n \n@@ -15383,9 +15330,6 @@\n {\n   rtx op0, op1, op2;\n \n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   op0 = gen_reg_rtx (XFmode);\n   op1 = gen_reg_rtx (XFmode);\n   op2 = gen_reg_rtx (XFmode);\n@@ -15463,8 +15407,6 @@\n       if (TARGET_ROUND)\n \temit_insn (gen_sse4_1_round<mode>2\n \t\t   (operands[0], operands[1], GEN_INT (ROUND_MXCSR)));\n-      else if (optimize_insn_for_size_p ())\n-        FAIL;\n       else\n \tix86_expand_rint (operands[0], operands[1]);\n     }\n@@ -15491,9 +15433,6 @@\n    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n        && !flag_trapping_math && !flag_rounding_math)\"\n {\n-  if (optimize_insn_for_size_p ())\n-    FAIL;\n-\n   if (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\n       && !flag_trapping_math && !flag_rounding_math)\n     {\n@@ -15747,8 +15686,7 @@\n \t\t\t      FRNDINT_ROUNDING))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"TARGET_USE_FANCY_MATH_387\n-   && flag_unsafe_math_optimizations\n-   && !optimize_insn_for_size_p ()\")\n+   && flag_unsafe_math_optimizations\")\n \n (define_expand \"<rounding_insn><mode>2\"\n   [(parallel [(set (match_operand:MODEF 0 \"register_operand\")\n@@ -15768,8 +15706,6 @@\n       if (TARGET_ROUND)\n \temit_insn (gen_sse4_1_round<mode>2\n \t\t   (operands[0], operands[1], GEN_INT (ROUND_<ROUNDING>)));\n-      else if (optimize_insn_for_size_p ())\n-\tFAIL;\n       else if (TARGET_64BIT || (<MODE>mode != DFmode))\n \t{\n \t  if (ROUND_<ROUNDING> == ROUND_FLOOR)\n@@ -15797,9 +15733,6 @@\n     {\n       rtx op0, op1;\n \n-      if (optimize_insn_for_size_p ())\n-\tFAIL;\n-\n       op0 = gen_reg_rtx (XFmode);\n       op1 = gen_reg_rtx (XFmode);\n       emit_insn (gen_extend<mode>xf2 (op1, operands[1]));"}, {"sha": "5a9fb63052705f442ec73b483c2866850c45f4de", "filename": "gcc/coretypes.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -200,6 +200,18 @@ enum node_frequency {\n   NODE_FREQUENCY_HOT\n };\n \n+/* Ways of optimizing code.  */\n+enum optimization_type {\n+  /* Prioritize speed over size.  */\n+  OPTIMIZE_FOR_SPEED,\n+\n+  /* Only do things that are good for both size and speed.  */\n+  OPTIMIZE_FOR_BOTH,\n+\n+  /* Prioritize size over speed.  */\n+  OPTIMIZE_FOR_SIZE\n+};\n+\n /* Possible initialization status of a variable.   When requested\n    by the user, this information is tracked and recorded in the DWARF\n    debug information, along with the variable's location.  */"}, {"sha": "a84ad5723b6f9f9c72a97b93e971ffd0cac6e597", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -6425,6 +6425,20 @@ Define this macro if a non-short-circuit operation produced by\n @code{BRANCH_COST} is greater than or equal to the value 2.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_OPTAB_SUPPORTED_P (int @var{op}, machine_mode @var{mode1}, machine_mode @var{mode2}, optimization_type @var{opt_type})\n+Return true if the optimizers should use optab @var{op} with\n+modes @var{mode1} and @var{mode2} for optimization type @var{opt_type}.\n+The optab is known to have an associated @file{.md} instruction\n+whose C condition is true.  @var{mode2} is only meaningful for conversion\n+optabs; for direct optabs it is a copy of @var{mode1}.\n+\n+For example, when called with @var{op} equal to @code{rint_optab} and\n+@var{mode1} equal to @code{DFmode}, the hook should say whether the\n+optimizers should use optab @code{rintdf2}.\n+\n+The default hook returns true for all inputs.\n+@end deftypefn\n+\n @deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, machine_mode @var{mode}, int @var{outer_code}, int @var{opno}, int *@var{total}, bool @var{speed})\n This target hook describes the relative costs of RTL expressions.\n "}, {"sha": "a0a0a812fc1d459a103e033b28396057885f6bdf", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -4746,6 +4746,8 @@ Define this macro if a non-short-circuit operation produced by\n @code{BRANCH_COST} is greater than or equal to the value 2.\n @end defmac\n \n+@hook TARGET_OPTAB_SUPPORTED_P\n+\n @hook TARGET_RTX_COSTS\n \n @hook TARGET_ADDRESS_COST"}, {"sha": "049ebab3f4728f194899f4a8aa67c579bcef719d", "filename": "gcc/gimple-match-head.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fgimple-match-head.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fgimple-match-head.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-match-head.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -261,7 +261,7 @@ build_call_internal (internal_fn fn, tree type, unsigned int nargs, tree *ops)\n   if (direct_internal_fn_p (fn))\n     {\n       tree_pair types = direct_internal_fn_types (fn, type, ops);\n-      if (!direct_internal_fn_supported_p (fn, types))\n+      if (!direct_internal_fn_supported_p (fn, types, OPTIMIZE_FOR_BOTH))\n \treturn NULL;\n     }\n   return gimple_build_call_internal (fn, nargs, ops[0], ops[1], ops[2]);"}, {"sha": "2be2d8806f1c0e9edc65ed3b18a30bd7be0430fb", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -2214,23 +2214,30 @@ direct_internal_fn_types (internal_fn fn, gcall *call)\n }\n \n /* Return true if OPTAB is supported for TYPES (whose modes should be\n-   the same).  Used for simple direct optabs.  */\n+   the same) when the optimization type is OPT_TYPE.  Used for simple\n+   direct optabs.  */\n \n static bool\n-direct_optab_supported_p (direct_optab optab, tree_pair types)\n+direct_optab_supported_p (direct_optab optab, tree_pair types,\n+\t\t\t  optimization_type opt_type)\n {\n   machine_mode mode = TYPE_MODE (types.first);\n   gcc_checking_assert (mode == TYPE_MODE (types.second));\n-  return direct_optab_handler (optab, mode) != CODE_FOR_nothing;\n+  return direct_optab_handler (optab, mode, opt_type) != CODE_FOR_nothing;\n }\n \n /* Return true if load/store lanes optab OPTAB is supported for\n-   array type TYPES.first.  */\n+   array type TYPES.first when the optimization type is OPT_TYPE.  */\n \n static bool\n-multi_vector_optab_supported_p (convert_optab optab, tree_pair types)\n+multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n+\t\t\t\toptimization_type opt_type)\n {\n-  return get_multi_vector_move (types.first, optab) != CODE_FOR_nothing;\n+  gcc_assert (TREE_CODE (types.first) == ARRAY_TYPE);\n+  machine_mode imode = TYPE_MODE (types.first);\n+  machine_mode vmode = TYPE_MODE (TREE_TYPE (types.first));\n+  return (convert_optab_handler (optab, imode, vmode, opt_type)\n+\t  != CODE_FOR_nothing);\n }\n \n #define direct_unary_optab_supported_p direct_optab_supported_p\n@@ -2240,20 +2247,23 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types)\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n \n-/* Return true if FN is supported for the types in TYPES.  The types\n-   are those associated with the \"type0\" and \"type1\" fields of FN's\n-   direct_internal_fn_info structure.  */\n+/* Return true if FN is supported for the types in TYPES when the\n+   optimization type is OPT_TYPE.  The types are those associated with\n+   the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n+   structure.  */\n \n bool\n-direct_internal_fn_supported_p (internal_fn fn, tree_pair types)\n+direct_internal_fn_supported_p (internal_fn fn, tree_pair types,\n+\t\t\t\toptimization_type opt_type)\n {\n   switch (fn)\n     {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) \\\n     case IFN_##CODE: break;\n #define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n     case IFN_##CODE: \\\n-      return direct_##TYPE##_optab_supported_p (OPTAB##_optab, types);\n+      return direct_##TYPE##_optab_supported_p (OPTAB##_optab, types, \\\n+\t\t\t\t\t\topt_type);\n #include \"internal-fn.def\"\n \n     case IFN_LAST:\n@@ -2262,16 +2272,17 @@ direct_internal_fn_supported_p (internal_fn fn, tree_pair types)\n   gcc_unreachable ();\n }\n \n-/* Return true if FN is supported for type TYPE.  The caller knows that\n-   the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n-   structure are the same.  */\n+/* Return true if FN is supported for type TYPE when the optimization\n+   type is OPT_TYPE.  The caller knows that the \"type0\" and \"type1\"\n+   fields of FN's direct_internal_fn_info structure are the same.  */\n \n bool\n-direct_internal_fn_supported_p (internal_fn fn, tree type)\n+direct_internal_fn_supported_p (internal_fn fn, tree type,\n+\t\t\t\toptimization_type opt_type)\n {\n   const direct_internal_fn_info &info = direct_internal_fn (fn);\n   gcc_checking_assert (info.type0 == info.type1);\n-  return direct_internal_fn_supported_p (fn, tree_pair (type, type));\n+  return direct_internal_fn_supported_p (fn, tree_pair (type, type), opt_type);\n }\n \n /* Return true if IFN_SET_EDOM is supported.  */"}, {"sha": "ef27f09cdc9f97c21e3c34a64d73717c716d59be", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -166,8 +166,10 @@ direct_internal_fn (internal_fn fn)\n \n extern tree_pair direct_internal_fn_types (internal_fn, tree, tree *);\n extern tree_pair direct_internal_fn_types (internal_fn, gcall *);\n-extern bool direct_internal_fn_supported_p (internal_fn, tree_pair);\n-extern bool direct_internal_fn_supported_p (internal_fn, tree);\n+extern bool direct_internal_fn_supported_p (internal_fn, tree_pair,\n+\t\t\t\t\t    optimization_type);\n+extern bool direct_internal_fn_supported_p (internal_fn, tree,\n+\t\t\t\t\t    optimization_type);\n extern bool set_edom_supported_p (void);\n \n extern void expand_internal_call (gcall *);"}, {"sha": "2f9c7cde2782089cd8010e1f7294632f590276fb", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -35,6 +35,36 @@ struct target_optabs *this_fn_optabs = &default_target_optabs;\n struct target_optabs *this_target_optabs = &default_target_optabs;\n #endif\n \n+/* Return the insn used to perform conversion OP from mode FROM_MODE\n+   to mode TO_MODE; return CODE_FOR_nothing if the target does not have\n+   such an insn, or if it is unsuitable for optimization type OPT_TYPE.  */\n+\n+insn_code\n+convert_optab_handler (convert_optab optab, machine_mode to_mode,\n+\t\t       machine_mode from_mode, optimization_type opt_type)\n+{\n+  insn_code icode = convert_optab_handler (optab, to_mode, from_mode);\n+  if (icode == CODE_FOR_nothing\n+      || !targetm.optab_supported_p (optab, to_mode, from_mode, opt_type))\n+    return CODE_FOR_nothing;\n+  return icode;\n+}\n+\n+/* Return the insn used to implement mode MODE of OP; return\n+   CODE_FOR_nothing if the target does not have such an insn,\n+   or if it is unsuitable for optimization type OPT_TYPE.  */\n+\n+insn_code\n+direct_optab_handler (convert_optab optab, machine_mode mode,\n+\t\t      optimization_type opt_type)\n+{\n+  insn_code icode = direct_optab_handler (optab, mode);\n+  if (icode == CODE_FOR_nothing\n+      || !targetm.optab_supported_p (optab, mode, mode, opt_type))\n+    return CODE_FOR_nothing;\n+  return icode;\n+}\n+\n /* Enumerates the possible types of structure operand to an\n    extraction_insn.  */\n enum extraction_type { ET_unaligned_mem, ET_reg };"}, {"sha": "8a5f042b461b2cb3468b1a2184323a2a63f2e00a", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -46,6 +46,9 @@ convert_optab_handler (convert_optab op, machine_mode to_mode,\n   return raw_optab_handler (scode);\n }\n \n+enum insn_code convert_optab_handler (convert_optab, machine_mode,\n+\t\t\t\t      machine_mode, optimization_type);\n+\n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n \n@@ -55,6 +58,9 @@ direct_optab_handler (direct_optab op, machine_mode mode)\n   return optab_handler (op, mode);\n }\n \n+enum insn_code direct_optab_handler (convert_optab, machine_mode,\n+\t\t\t\t     optimization_type);\n+\n /* Return true if UNOPTAB is for a trapping-on-overflow operation.  */\n \n inline bool"}, {"sha": "d5c40def863f0c87b6ff4aa7e998a9985dc6045e", "filename": "gcc/predict.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -269,6 +269,16 @@ optimize_function_for_speed_p (struct function *fun)\n   return !optimize_function_for_size_p (fun);\n }\n \n+/* Return the optimization type that should be used for the function FUN.  */\n+\n+optimization_type\n+function_optimization_type (struct function *fun)\n+{\n+  return (optimize_function_for_speed_p (fun)\n+\t  ? OPTIMIZE_FOR_SPEED\n+\t  : OPTIMIZE_FOR_SIZE);\n+}\n+\n /* Return TRUE when BB should be optimized for size.  */\n \n bool\n@@ -286,6 +296,16 @@ optimize_bb_for_speed_p (const_basic_block bb)\n   return !optimize_bb_for_size_p (bb);\n }\n \n+/* Return the optimization type that should be used for block BB.  */\n+\n+optimization_type\n+bb_optimization_type (const_basic_block bb)\n+{\n+  return (optimize_bb_for_speed_p (bb)\n+\t  ? OPTIMIZE_FOR_SPEED\n+\t  : OPTIMIZE_FOR_SIZE);\n+}\n+\n /* Return TRUE when BB should be optimized for size.  */\n \n bool"}, {"sha": "486ce171f8797d775f144bacb0afc3176094e5d0", "filename": "gcc/predict.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -54,8 +54,10 @@ extern bool probably_never_executed_bb_p (struct function *, const_basic_block);\n extern bool probably_never_executed_edge_p (struct function *, edge);\n extern bool optimize_function_for_size_p (struct function *);\n extern bool optimize_function_for_speed_p (struct function *);\n+extern optimization_type function_optimization_type (struct function *);\n extern bool optimize_bb_for_size_p (const_basic_block);\n extern bool optimize_bb_for_speed_p (const_basic_block);\n+extern optimization_type bb_optimization_type (const_basic_block);\n extern bool optimize_edge_for_size_p (edge);\n extern bool optimize_edge_for_speed_p (edge);\n extern bool optimize_insn_for_size_p (void);"}, {"sha": "197189282b1cd224118786a8ff35da107bc45a92", "filename": "gcc/target.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -3434,6 +3434,23 @@ move would be greater than that of a library call.\",\n         enum by_pieces_operation op, bool speed_p),\n  default_use_by_pieces_infrastructure_p)\n \n+DEFHOOK\n+(optab_supported_p,\n+ \"Return true if the optimizers should use optab @var{op} with\\n\\\n+modes @var{mode1} and @var{mode2} for optimization type @var{opt_type}.\\n\\\n+The optab is known to have an associated @file{.md} instruction\\n\\\n+whose C condition is true.  @var{mode2} is only meaningful for conversion\\n\\\n+optabs; for direct optabs it is a copy of @var{mode1}.\\n\\\n+\\n\\\n+For example, when called with @var{op} equal to @code{rint_optab} and\\n\\\n+@var{mode1} equal to @code{DFmode}, the hook should say whether the\\n\\\n+optimizers should use optab @code{rintdf2}.\\n\\\n+\\n\\\n+The default hook returns true for all inputs.\",\n+ bool, (int op, machine_mode mode1, machine_mode mode2,\n+\toptimization_type opt_type),\n+ default_optab_supported_p)\n+\n /* True for MODE if the target expects that registers in this mode will\n    be allocated to registers in a small register class.  The compiler is\n    allowed to use registers explicitly used in the rtl as spill registers"}, {"sha": "704560965420f782663357096578513b06021079", "filename": "gcc/targhooks.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1953,4 +1953,12 @@ can_use_doloop_if_innermost (const widest_int &, const widest_int &,\n   return loop_depth == 1;\n }\n \n+/* Default implementation of TARGET_OPTAB_SUPPORTED_P.  */\n+\n+bool\n+default_optab_supported_p (int, machine_mode, machine_mode, optimization_type)\n+{\n+  return true;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "281b5fed1fbaeb846a9c830088219faebba12765", "filename": "gcc/targhooks.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -250,4 +250,7 @@ extern void default_setup_incoming_vararg_bounds (cumulative_args_t ca ATTRIBUTE\n \t\t\t\t\t\t  tree type ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  int *pretend_arg_size ATTRIBUTE_UNUSED,\n \t\t\t\t\t\t  int second_time ATTRIBUTE_UNUSED);\n+extern bool default_optab_supported_p (int, machine_mode, machine_mode,\n+\t\t\t\t       optimization_type);\n+\n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "0d686b2d5e8582ea1b56536861afc110a9a8151a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1,3 +1,9 @@\n+2015-12-02  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/i386/pr68432-1.c: New test.\n+\t* gcc.target/i386/pr68432-2.c: Likewise.\n+\t* gcc.target/i386/pr68432-3.c: Likewise.\n+\n 2015-12-02  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n \n \t* gcc.target/s390/zvector/vec-splat-2.c: New test."}, {"sha": "8493652369e307eb8c2fb97b325dc22a0e57e205", "filename": "gcc/testsuite/gcc.target/i386/pr68432-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-1.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-math-errno -fno-trapping-math -msse2 -mfpmath=sse\" } */\n+\n+float\n+f1 (float f)\n+{\n+  return __builtin_rintf (f);\n+}\n+\n+double\n+f2 (double f)\n+{\n+  return __builtin_rint (f);\n+}\n+\n+/* { dg-final { scan-assembler-times \"\\tucomiss\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tucomisd\\t\" 1 } } */"}, {"sha": "8a0c29558953bd4ecfd19aed2d7d9ff29e1823c2", "filename": "gcc/testsuite/gcc.target/i386/pr68432-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-2.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -fno-math-errno -fno-trapping-math -msse2 -mfpmath=sse\" } */\n+\n+float\n+f1 (float f)\n+{\n+  return __builtin_rintf (f);\n+}\n+\n+double\n+f2 (double f)\n+{\n+  return __builtin_rint (f);\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tucomiss\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tucomisd\\t\" } } */"}, {"sha": "5f22972338ee6015ea3927cdc8a49bed6b4424ae", "filename": "gcc/testsuite/gcc.target/i386/pr68432-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr68432-3.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-math-errno -fno-trapping-math -msse2 -mfpmath=sse\" } */\n+\n+float __attribute__ ((cold))\n+f1 (float f)\n+{\n+  return __builtin_rintf (f);\n+}\n+\n+double __attribute__ ((cold))\n+f2 (double f)\n+{\n+  return __builtin_rint (f);\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tucomiss\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\tucomisd\\t\" } } */"}, {"sha": "cd142e139036ac7960763bc4205c8bf4dc9cd3af", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1056,7 +1056,9 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n       && real_equal (&TREE_REAL_CST (exp), &dconsthalf))\n     {\n       *type_in = get_vectype_for_scalar_type (TREE_TYPE (base));\n-      if (*type_in && direct_internal_fn_supported_p (IFN_SQRT, *type_in))\n+      if (*type_in\n+\t  && direct_internal_fn_supported_p (IFN_SQRT, *type_in,\n+\t\t\t\t\t     OPTIMIZE_FOR_SPEED))\n \t{\n \t  gcall *stmt = gimple_build_call_internal (IFN_SQRT, 1, base);\n \t  var = vect_recog_temp_ssa_var (TREE_TYPE (base), stmt);"}, {"sha": "9f116528b47edccf4a4b676681eb797ba312e6e5", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -1681,7 +1681,8 @@ vectorizable_internal_function (combined_fn cfn, tree fndecl,\n \t{\n \t  tree type0 = (info.type0 < 0 ? vectype_out : vectype_in);\n \t  tree type1 = (info.type1 < 0 ? vectype_out : vectype_in);\n-\t  if (direct_internal_fn_supported_p (ifn, tree_pair (type0, type1)))\n+\t  if (direct_internal_fn_supported_p (ifn, tree_pair (type0, type1),\n+\t\t\t\t\t      OPTIMIZE_FOR_SPEED))\n \t    return ifn;\n \t}\n     }"}, {"sha": "4f7ce7e507024e7c9080c00930f9c1f2185373c6", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d95ab70a3cab2998b4671d842e1ad769e75f19a3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d95ab70a3cab2998b4671d842e1ad769e75f19a3", "patch": "@@ -11118,7 +11118,8 @@ maybe_build_call_expr_loc (location_t loc, combined_fn fn, tree type,\n       if (direct_internal_fn_p (ifn))\n \t{\n \t  tree_pair types = direct_internal_fn_types (ifn, type, argarray);\n-\t  if (!direct_internal_fn_supported_p (ifn, types))\n+\t  if (!direct_internal_fn_supported_p (ifn, types,\n+\t\t\t\t\t       OPTIMIZE_FOR_BOTH))\n \t    return NULL_TREE;\n \t}\n       return build_call_expr_internal_loc_array (loc, ifn, type, n, argarray);"}]}