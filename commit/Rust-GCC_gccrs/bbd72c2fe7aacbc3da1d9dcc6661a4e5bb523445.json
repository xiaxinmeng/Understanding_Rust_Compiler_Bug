{"sha": "bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJkNzJjMmZlN2FhY2JjM2RhMWQ5ZGNjNjY2MWE0ZTViYjUyMzQ0NQ==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gmail.com", "date": "2012-05-21T22:51:38Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2012-05-21T22:51:38Z"}, "message": "rs6000.c (save_reg_p): New function.\n\n\t* config/rs6000/rs6000.c (save_reg_p): New function.\n\t(first_reg_to_save, first_fp_reg_to_save): Use it here.\n\t(first_altivec_reg_to_save, restore_saved_cr): Likewise.\n\t(emit_frame_save): Use gen_frame_store.\n\t(gen_frame_mem_offset): Correct SPE condition requiring reg+reg.\n\t(rs6000_emit_prologue): Use save_reg_p.  Use gen_frame_store for\n\tvrsave and toc.\n\t(rs6000_emit_epilogue): Use save_reg_p.  Use gen_frame_load for\n\tvrsave, toc, gp and fp restores.\n\nFrom-SVN: r187749", "tree": {"sha": "3d8851f124e1a18771109b3cb75f2792ecfc930d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8851f124e1a18771109b3cb75f2792ecfc930d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445/comments", "author": {"login": "amodra", "id": 6006325, "node_id": "MDQ6VXNlcjYwMDYzMjU=", "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amodra", "html_url": "https://github.com/amodra", "followers_url": "https://api.github.com/users/amodra/followers", "following_url": "https://api.github.com/users/amodra/following{/other_user}", "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}", "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amodra/subscriptions", "organizations_url": "https://api.github.com/users/amodra/orgs", "repos_url": "https://api.github.com/users/amodra/repos", "events_url": "https://api.github.com/users/amodra/events{/privacy}", "received_events_url": "https://api.github.com/users/amodra/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e1968bbaad35369d758bf0dd0cdd5da96c9ea63d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1968bbaad35369d758bf0dd0cdd5da96c9ea63d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1968bbaad35369d758bf0dd0cdd5da96c9ea63d"}], "stats": {"total": 128, "additions": 61, "deletions": 67}, "files": [{"sha": "563912f67b3b54d15833711268162407712955b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "patch": "@@ -1,3 +1,15 @@\n+2012-05-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/rs6000/rs6000.c (save_reg_p): New function.\n+\t(first_reg_to_save, first_fp_reg_to_save): Use it here.\n+\t(first_altivec_reg_to_save, restore_saved_cr): Likewise.\n+\t(emit_frame_save): Use gen_frame_store.\n+\t(gen_frame_mem_offset): Correct SPE condition requiring reg+reg.\n+\t(rs6000_emit_prologue): Use save_reg_p.  Use gen_frame_store for\n+\tvrsave and toc.\n+\t(rs6000_emit_epilogue): Use save_reg_p.  Use gen_frame_load for\n+\tvrsave, toc, gp and fp restores.\n+\n 2012-05-22  Alan Modra  <amodra@gmail.com>\n \n \t* config/rs6000/rs6000.c: Delete unnecessary forward declarations."}, {"sha": "ff177862234b5b06d27eb81d9c5e94f3326d1412", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 49, "deletions": 67, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bbd72c2fe7aacbc3da1d9dcc6661a4e5bb523445", "patch": "@@ -17022,6 +17022,12 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n /* This page contains routines that are used to determine what the\n    function prologue and epilogue code will do and write them out.  */\n \n+static inline bool\n+save_reg_p (int r)\n+{\n+  return !call_used_regs[r] && df_regs_ever_live_p (r);\n+}\n+\n /* Return the first fixed-point register that is required to be\n    saved. 32 if none.  */\n \n@@ -17032,14 +17038,16 @@ first_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (first_reg = 13; first_reg <= 31; first_reg++)\n-    if (df_regs_ever_live_p (first_reg)\n-\t&& (! call_used_regs[first_reg]\n-\t    || (first_reg == RS6000_PIC_OFFSET_TABLE_REGNUM\n-\t\t&& ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n-\t\t    || (DEFAULT_ABI == ABI_DARWIN && flag_pic)\n-\t\t    || (TARGET_TOC && TARGET_MINIMAL_TOC)))))\n+    if (save_reg_p (first_reg))\n       break;\n \n+  if (first_reg > RS6000_PIC_OFFSET_TABLE_REGNUM\n+      && ((DEFAULT_ABI == ABI_V4 && flag_pic != 0)\n+\t  || (DEFAULT_ABI == ABI_DARWIN && flag_pic)\n+\t  || (TARGET_TOC && TARGET_MINIMAL_TOC))\n+      && df_regs_ever_live_p (RS6000_PIC_OFFSET_TABLE_REGNUM))\n+    first_reg = RS6000_PIC_OFFSET_TABLE_REGNUM;\n+\n #if TARGET_MACHO\n   if (flag_pic\n       && crtl->uses_pic_offset_table\n@@ -17059,7 +17067,7 @@ first_fp_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (first_reg = 14 + 32; first_reg <= 63; first_reg++)\n-    if (df_regs_ever_live_p (first_reg))\n+    if (save_reg_p (first_reg))\n       break;\n \n   return first_reg;\n@@ -17085,7 +17093,7 @@ first_altivec_reg_to_save (void)\n \n   /* Find lowest numbered live register.  */\n   for (i = FIRST_ALTIVEC_REGNO + 20; i <= LAST_ALTIVEC_REGNO; ++i)\n-    if (df_regs_ever_live_p (i))\n+    if (save_reg_p (i))\n       break;\n \n   return i;\n@@ -18781,7 +18789,7 @@ static rtx\n emit_frame_save (rtx frame_reg, enum machine_mode mode,\n \t\t unsigned int regno, int offset, HOST_WIDE_INT frame_reg_to_sp)\n {\n-  rtx reg, insn, mem, addr;\n+  rtx reg, insn;\n \n   /* Some cases that need register indexed addressing.  */\n   gcc_checking_assert (!((TARGET_ALTIVEC_ABI && ALTIVEC_VECTOR_MODE (mode))\n@@ -18792,9 +18800,7 @@ emit_frame_save (rtx frame_reg, enum machine_mode mode,\n \t\t\t     && !SPE_CONST_OFFSET_OK (offset))));\n \n   reg = gen_rtx_REG (mode, regno);\n-  addr = gen_rtx_PLUS (Pmode, frame_reg, GEN_INT (offset));\n-  mem = gen_frame_mem (mode, addr);\n-  insn = emit_move_insn (mem, reg);\n+  insn = emit_insn (gen_frame_store (reg, frame_reg, offset));\n   return rs6000_frame_related (insn, frame_reg, frame_reg_to_sp,\n \t\t\t       NULL_RTX, NULL_RTX);\n }\n@@ -18809,7 +18815,7 @@ gen_frame_mem_offset (enum machine_mode mode, rtx reg, int offset)\n \n   int_rtx = GEN_INT (offset);\n \n-  if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode))\n+  if ((TARGET_SPE_ABI && SPE_VECTOR_MODE (mode) && !SPE_CONST_OFFSET_OK (offset))\n       || (TARGET_E500_DOUBLE && mode == DFmode))\n     {\n       offset_rtx = gen_rtx_REG (Pmode, FIXED_SCRATCH);\n@@ -19438,8 +19444,7 @@ rs6000_emit_prologue (void)\n     {\n       int i;\n       for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-\tif (df_regs_ever_live_p (info->first_fp_reg_save + i)\n-\t    && ! call_used_regs[info->first_fp_reg_save + i])\n+\tif (save_reg_p (info->first_fp_reg_save + i))\n \t  emit_frame_save (frame_reg_rtx,\n \t\t\t   (TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n \t\t\t    ? DFmode : SFmode),\n@@ -19889,7 +19894,7 @@ rs6000_emit_prologue (void)\n       && TARGET_ALTIVEC_VRSAVE\n       && info->vrsave_mask != 0)\n     {\n-      rtx reg, mem, vrsave;\n+      rtx reg, vrsave;\n       int offset;\n       int save_regno;\n \n@@ -19916,10 +19921,7 @@ rs6000_emit_prologue (void)\n \n       /* Save VRSAVE.  */\n       offset = info->vrsave_save_offset + frame_off;\n-      mem = gen_frame_mem (SImode,\n-\t\t\t   gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t\t GEN_INT (offset)));\n-      insn = emit_move_insn (mem, reg);\n+      insn = emit_insn (gen_frame_store (reg, frame_reg_rtx, offset));\n \n       /* Include the registers in the mask.  */\n       emit_insn (gen_iorsi3 (reg, reg, GEN_INT ((int) info->vrsave_mask)));\n@@ -20000,9 +20002,8 @@ rs6000_emit_prologue (void)\n      linux-unwind.h frob_update_context.  */\n   if (rs6000_save_toc_in_prologue_p ())\n     {\n-      rtx addr = gen_rtx_PLUS (Pmode, sp_reg_rtx, GEN_INT (5 * reg_size));\n-      rtx mem = gen_frame_mem (reg_mode, addr);\n-      emit_move_insn (mem, gen_rtx_REG (reg_mode, TOC_REGNUM));\n+      rtx reg = gen_rtx_REG (reg_mode, TOC_REGNUM);\n+      emit_insn (gen_frame_store (reg, sp_reg_rtx, 5 * reg_size));\n     }\n }\n \n@@ -20100,7 +20101,7 @@ restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n   if (using_mfcr_multiple)\n     {\n       for (i = 0; i < 8; i++)\n-\tif (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n+\tif (save_reg_p (CR0_REGNO + i))\n \t  count++;\n       gcc_assert (count);\n     }\n@@ -20114,13 +20115,13 @@ restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n \n       ndx = 0;\n       for (i = 0; i < 8; i++)\n-\tif (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n+\tif (save_reg_p (CR0_REGNO + i))\n \t  {\n \t    rtvec r = rtvec_alloc (2);\n \t    RTVEC_ELT (r, 0) = reg;\n \t    RTVEC_ELT (r, 1) = GEN_INT (1 << (7-i));\n \t    RTVEC_ELT (p, ndx) =\n-\t      gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO+i),\n+\t      gen_rtx_SET (VOIDmode, gen_rtx_REG (CCmode, CR0_REGNO + i),\n \t\t\t   gen_rtx_UNSPEC (CCmode, r, UNSPEC_MOVESI_TO_CR));\n \t    ndx++;\n \t  }\n@@ -20129,8 +20130,8 @@ restore_saved_cr (rtx reg, int using_mfcr_multiple, bool exit_func)\n     }\n   else\n     for (i = 0; i < 8; i++)\n-      if (df_regs_ever_live_p (CR0_REGNO+i) && ! call_used_regs[CR0_REGNO+i])\n-\temit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode, CR0_REGNO+i),\n+      if (save_reg_p (CR0_REGNO + i))\n+\temit_insn (gen_movsi_to_cr_one (gen_rtx_REG (CCmode, CR0_REGNO + i),\n \t\t\t\t\treg));\n \n   if (!exit_func && (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap))\n@@ -20463,7 +20464,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  || (DEFAULT_ABI != ABI_V4\n \t      && offset_below_red_zone_p (info->vrsave_save_offset))))\n     {\n-      rtx addr, mem, reg;\n+      rtx reg;\n \n       if (frame_reg_rtx == sp_reg_rtx)\n \t{\n@@ -20478,11 +20479,9 @@ rs6000_emit_epilogue (int sibcall)\n \t    frame_reg_rtx = hard_frame_pointer_rtx;\n \t}\n \n-      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t   GEN_INT (info->vrsave_save_offset + frame_off));\n-      mem = gen_frame_mem (SImode, addr);\n       reg = gen_rtx_REG (SImode, 12);\n-      emit_move_insn (reg, mem);\n+      emit_insn (gen_frame_load (reg, frame_reg_rtx,\n+\t\t\t\t info->vrsave_save_offset + frame_off));\n \n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n@@ -20660,13 +20659,11 @@ rs6000_emit_epilogue (int sibcall)\n       && (DEFAULT_ABI == ABI_V4\n \t  || !offset_below_red_zone_p (info->vrsave_save_offset)))\n     {\n-      rtx addr, mem, reg;\n+      rtx reg;\n \n-      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t   GEN_INT (info->vrsave_save_offset + frame_off));\n-      mem = gen_frame_mem (SImode, addr);\n       reg = gen_rtx_REG (SImode, 12);\n-      emit_move_insn (reg, mem);\n+      emit_insn (gen_frame_load (reg, frame_reg_rtx,\n+\t\t\t\t info->vrsave_save_offset + frame_off));\n \n       emit_insn (generate_set_vrsave (reg, info, 1));\n     }\n@@ -20720,11 +20717,9 @@ rs6000_emit_epilogue (int sibcall)\n \n       if (TARGET_AIX)\n \t{\n-\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t   GEN_INT (frame_off + 5 * reg_size));\n-\t  rtx mem = gen_frame_mem (reg_mode, addr);\n-\n-\t  emit_move_insn (gen_rtx_REG (reg_mode, 2), mem);\n+\t  rtx reg = gen_rtx_REG (reg_mode, 2);\n+\t  emit_insn (gen_frame_load (reg, frame_reg_rtx,\n+\t\t\t\t     frame_off + 5 * reg_size));\n \t}\n \n       for (i = 0; ; ++i)\n@@ -20735,6 +20730,7 @@ rs6000_emit_epilogue (int sibcall)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \n+\t  /* Note: possible use of r0 here to address SPE regs.  */\n \t  mem = gen_frame_mem_offset (reg_mode, frame_reg_rtx,\n \t\t\t\t      info->ehrd_offset + frame_off\n \t\t\t\t      + reg_size * (int) i);\n@@ -20853,16 +20849,10 @@ rs6000_emit_epilogue (int sibcall)\n     {\n       for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n \tif (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-\t  {\n-\t    rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t\t     GEN_INT (info->gp_save_offset\n-\t\t\t\t\t      + frame_off\n-\t\t\t\t\t      + reg_size * i));\n-\t    rtx mem = gen_frame_mem (reg_mode, addr);\n-\t    rtx reg = gen_rtx_REG (reg_mode, info->first_gp_reg_save + i);\n-\n-\t    emit_move_insn (reg, mem);\n-\t  }\n+\t  emit_insn (gen_frame_load\n+\t\t     (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n+\t\t      frame_reg_rtx,\n+\t\t      info->gp_save_offset + frame_off + reg_size * i));\n     }\n \n   if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n@@ -20925,21 +20915,13 @@ rs6000_emit_epilogue (int sibcall)\n   /* Restore fpr's if we need to do it without calling a function.  */\n   if (restoring_FPRs_inline)\n     for (i = 0; i < 64 - info->first_fp_reg_save; i++)\n-      if ((df_regs_ever_live_p (info->first_fp_reg_save + i)\n-\t   && !call_used_regs[info->first_fp_reg_save + i]))\n+      if (save_reg_p (info->first_fp_reg_save + i))\n \t{\n-\t  rtx addr, mem, reg;\n-\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n-\t\t\t       GEN_INT (info->fp_save_offset\n-\t\t\t\t\t+ frame_off\n-\t\t\t\t\t+ 8 * i));\n-\t  mem = gen_frame_mem ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t\t? DFmode : SFmode), addr);\n-\t  reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n-\t\t\t      ? DFmode : SFmode),\n-\t\t\t     info->first_fp_reg_save + i);\n-\n-\t  emit_move_insn (reg, mem);\n+\t  rtx reg = gen_rtx_REG ((TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\n+\t\t\t\t  ? DFmode : SFmode),\n+\t\t\t\t info->first_fp_reg_save + i);\n+\t  emit_insn (gen_frame_load (reg, frame_reg_rtx,\n+\t\t\t\t     info->fp_save_offset + frame_off + 8 * i));\n \t  if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t}"}]}