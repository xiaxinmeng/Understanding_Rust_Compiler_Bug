{"sha": "7bead48f160d4faab372aeab8a5200c5c21d2523", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JlYWQ0OGYxNjBkNGZhYWIzNzJhZWFiOGE1MjAwYzVjMjFkMjUyMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-11-19T16:59:05Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-11-19T16:59:05Z"}, "message": "re PR c++/561 (std:unclear about Overloaded Function Pointer resolution)\n\n\tPR c++/561\n\t* decl.c (static_fn_type): Split out...\n\t(revert_static_member_fn): ...from here.\n\t* cp-tree.h: Declare it.\n\t* class.c (resolve_address_of_overloaded_function): Use it to compare\n\tpointers to member functions.\n\t* typeck.c (build_static_cast_1): Call instantiate_type.\n\nFrom-SVN: r154336", "tree": {"sha": "918b5da9a9ebc906d543b57fb0a5e50e3dd5076f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/918b5da9a9ebc906d543b57fb0a5e50e3dd5076f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bead48f160d4faab372aeab8a5200c5c21d2523", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bead48f160d4faab372aeab8a5200c5c21d2523", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bead48f160d4faab372aeab8a5200c5c21d2523", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bead48f160d4faab372aeab8a5200c5c21d2523/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4a85780b75143fa28bc26ce508eafa95c5f5b3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a85780b75143fa28bc26ce508eafa95c5f5b3e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a85780b75143fa28bc26ce508eafa95c5f5b3e8"}], "stats": {"total": 126, "additions": 88, "deletions": 38}, "files": [{"sha": "6a30b67bdfdfc7bda8a87ac8cc22fd760a94e762", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -1,3 +1,13 @@\n+2009-11-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/561\n+\t* decl.c (static_fn_type): Split out...\n+\t(revert_static_member_fn): ...from here.\n+\t* cp-tree.h: Declare it.\n+\t* class.c (resolve_address_of_overloaded_function): Use it to compare\n+\tpointers to member functions.\n+\t* typeck.c (build_static_cast_1): Call instantiate_type.\n+\n 2009-11-18  Shujing Zhao  <pearly.zhao@oracle.com>\n \n \tPR c++/40892"}, {"sha": "3cf15fb0fa6af2983dd898a489f93bf9a50bbdac", "filename": "gcc/cp/class.c", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -6065,6 +6065,7 @@ resolve_address_of_overloaded_function (tree target_type,\n      interoperability with most_specialized_instantiation.  */\n   tree matches = NULL_TREE;\n   tree fn;\n+  tree target_fn_type;\n \n   /* By the time we get here, we should be seeing only real\n      pointer-to-member types, not the internal POINTER_TYPE to\n@@ -6096,6 +6097,15 @@ resolve_address_of_overloaded_function (tree target_type,\n       return error_mark_node;\n     }\n \n+  /* Non-member functions and static member functions match targets of type\n+     \"pointer-to-function\" or \"reference-to-function.\"  Nonstatic member\n+     functions match targets of type \"pointer-to-member-function;\" the\n+     function type of the pointer to member is used to select the member\n+     function from the set of overloaded member functions.\n+\n+     So figure out the FUNCTION_TYPE that we want to match against.  */\n+  target_fn_type = static_fn_type (target_type);\n+\n   /* If we can find a non-template function that matches, we can just\n      use it.  There's no point in generating template instantiations\n      if we're just going to throw them out anyhow.  But, of course, we\n@@ -6107,7 +6117,6 @@ resolve_address_of_overloaded_function (tree target_type,\n       for (fns = overload; fns; fns = OVL_NEXT (fns))\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n-\t  tree fntype;\n \n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    /* We're not looking for templates just yet.  */\n@@ -6125,13 +6134,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t    continue;\n \n \t  /* See if there's a match.  */\n-\t  fntype = TREE_TYPE (fn);\n-\t  if (is_ptrmem)\n-\t    fntype = build_ptrmemfunc_type (build_pointer_type (fntype));\n-\t  else if (!is_reference)\n-\t    fntype = build_pointer_type (fntype);\n-\n-\t  if (can_convert_arg (target_type, fntype, fn, LOOKUP_NORMAL))\n+\t  if (same_type_p (target_fn_type, static_fn_type (fn)))\n \t    matches = tree_cons (fn, NULL_TREE, matches);\n \t}\n     }\n@@ -6141,26 +6144,16 @@ resolve_address_of_overloaded_function (tree target_type,\n      match we need to look at them, too.  */\n   if (!matches)\n     {\n-      tree target_fn_type;\n       tree target_arg_types;\n       tree target_ret_type;\n       tree fns;\n       tree *args;\n       unsigned int nargs, ia;\n       tree arg;\n \n-      if (is_ptrmem)\n-\ttarget_fn_type\n-\t  = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (target_type));\n-      else\n-\ttarget_fn_type = TREE_TYPE (target_type);\n       target_arg_types = TYPE_ARG_TYPES (target_fn_type);\n       target_ret_type = TREE_TYPE (target_fn_type);\n \n-      /* Never do unification on the 'this' parameter.  */\n-      if (TREE_CODE (target_fn_type) == METHOD_TYPE)\n-\ttarget_arg_types = TREE_CHAIN (target_arg_types);\n-\n       nargs = list_length (target_arg_types);\n       args = XALLOCAVEC (tree, nargs);\n       for (arg = target_arg_types, ia = 0;\n@@ -6173,7 +6166,6 @@ resolve_address_of_overloaded_function (tree target_type,\n \t{\n \t  tree fn = OVL_CURRENT (fns);\n \t  tree instantiation;\n-\t  tree instantiation_type;\n \t  tree targs;\n \n \t  if (TREE_CODE (fn) != TEMPLATE_DECL)\n@@ -6201,14 +6193,7 @@ resolve_address_of_overloaded_function (tree target_type,\n \t    continue;\n \n \t  /* See if there's a match.  */\n-\t  instantiation_type = TREE_TYPE (instantiation);\n-\t  if (is_ptrmem)\n-\t    instantiation_type =\n-\t      build_ptrmemfunc_type (build_pointer_type (instantiation_type));\n-\t  else if (!is_reference)\n-\t    instantiation_type = build_pointer_type (instantiation_type);\n-\t  if (can_convert_arg (target_type, instantiation_type, instantiation,\n-\t\t\t       LOOKUP_NORMAL))\n+\t  if (same_type_p (target_fn_type, static_fn_type (instantiation)))\n \t    matches = tree_cons (instantiation, fn, matches);\n \t}\n "}, {"sha": "cae259b6b36ff3944b4f6431b950448691547dfa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -4610,6 +4610,7 @@ extern void maybe_register_incomplete_var\t(tree);\n extern void maybe_commonize_var\t\t\t(tree);\n extern void complete_vars\t\t\t(tree);\n extern void finish_stmt\t\t\t\t(void);\n+extern tree static_fn_type\t\t\t(tree);\n extern void revert_static_member_fn\t\t(tree);\n extern void fixup_anonymous_aggr\t\t(tree);\n extern int check_static_variable_definition\t(tree, tree);"}, {"sha": "29e32c8062419ca3f345684885098beddf166f31", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -12812,26 +12812,47 @@ finish_stmt (void)\n {\n }\n \n+/* Return the FUNCTION_TYPE that corresponds to MEMFNTYPE, which can be a\n+   FUNCTION_DECL, METHOD_TYPE, FUNCTION_TYPE, pointer or reference to\n+   METHOD_TYPE or FUNCTION_TYPE, or pointer to member function.  */\n+\n+tree\n+static_fn_type (tree memfntype)\n+{\n+  tree fntype;\n+  tree args;\n+  int quals;\n+\n+  if (TYPE_PTRMEMFUNC_P (memfntype))\n+    memfntype = TYPE_PTRMEMFUNC_FN_TYPE (memfntype);\n+  if (POINTER_TYPE_P (memfntype)\n+      || TREE_CODE (memfntype) == FUNCTION_DECL)\n+    memfntype = TREE_TYPE (memfntype);\n+  if (TREE_CODE (memfntype) == FUNCTION_TYPE)\n+    return memfntype;\n+  gcc_assert (TREE_CODE (memfntype) == METHOD_TYPE);\n+  args = TYPE_ARG_TYPES (memfntype);\n+  fntype = build_function_type (TREE_TYPE (memfntype), TREE_CHAIN (args));\n+  quals = cp_type_quals (TREE_TYPE (TREE_VALUE (args)));\n+  fntype = build_qualified_type (fntype, quals);\n+  fntype = (cp_build_type_attribute_variant\n+\t    (fntype, TYPE_ATTRIBUTES (memfntype)));\n+  fntype = (build_exception_variant\n+\t    (fntype, TYPE_RAISES_EXCEPTIONS (memfntype)));\n+  return fntype;\n+}\n+\n /* DECL was originally constructed as a non-static member function,\n    but turned out to be static.  Update it accordingly.  */\n \n void\n revert_static_member_fn (tree decl)\n {\n-  tree tmp;\n-  tree function = TREE_TYPE (decl);\n-  tree args = TYPE_ARG_TYPES (function);\n+  TREE_TYPE (decl) = static_fn_type (decl);\n \n-  if (cp_type_quals (TREE_TYPE (TREE_VALUE (args)))\n-      != TYPE_UNQUALIFIED)\n+  if (cp_type_quals (TREE_TYPE (decl)) != TYPE_UNQUALIFIED)\n     error (\"static member function %q#D declared with type qualifiers\", decl);\n \n-  args = TREE_CHAIN (args);\n-  tmp = build_function_type (TREE_TYPE (function), args);\n-  tmp = build_qualified_type (tmp, cp_type_quals (function));\n-  tmp = build_exception_variant (tmp,\n-\t\t\t\t TYPE_RAISES_EXCEPTIONS (function));\n-  TREE_TYPE (decl) = tmp;\n   if (DECL_ARGUMENTS (decl))\n     DECL_ARGUMENTS (decl) = TREE_CHAIN (DECL_ARGUMENTS (decl));\n   DECL_STATIC_FUNCTION_P (decl) = 1;"}, {"sha": "4c02f78f2b175f12e207b0cd6ced1e270e2583c5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -5346,6 +5346,14 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n   orig = expr;\n \n+  /* Resolve overloaded address here rather than once in\n+     implicit_conversion and again in the inverse code below.  */\n+  if (TYPE_PTRMEMFUNC_P (type) && type_unknown_p (expr))\n+    {\n+      expr = instantiate_type (type, expr, complain);\n+      intype = TREE_TYPE (expr);\n+    }\n+\n   /* [expr.static.cast]\n \n      An expression e can be explicitly converted to a type T using a"}, {"sha": "bcf6d5571efea54af4fa1fec2a4e54ff22dc1a85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -1,3 +1,8 @@\n+2009-11-19  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/561\n+\t* g++.dg/overload/pmf2.C: New.\n+\n 2009-11-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/42090"}, {"sha": "e95e1f83a61f15e9b6dd6d7fac9f0f4fdd878951", "filename": "gcc/testsuite/g++.dg/overload/pmf2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bead48f160d4faab372aeab8a5200c5c21d2523/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf2.C?ref=7bead48f160d4faab372aeab8a5200c5c21d2523", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/561\n+\n+class A { };\n+\n+struct B : public A\n+{\n+  void foo ();\n+  void foo (int);\n+  template <class T>\n+  void bar (T);\n+  template <class T>\n+  void bar (T, T);\n+};\n+\n+int main ()\n+{\n+  void (A::*f1)() = (void (A::*)()) &B::foo;\n+  void (A::*f2)(int) = (void (A::*)(int)) &B::bar;\n+  void (A::*f3)(int) = (void (A::*)(int)) &B::bar<int>;\n+}"}]}