{"sha": "87c465f52c1f582a61283932963305aab86e2aa6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdjNDY1ZjUyYzFmNTgyYTYxMjgzOTMyOTYzMzA1YWFiODZlMmFhNg==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2004-11-25T17:05:38Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2004-11-25T17:05:38Z"}, "message": "Friend class name lookup 3/n, PR c++/3332\n\n\tFriend class name lookup 3/n, PR c++/3332\n\t* name-lookup.c (push_inner_scope, pop_inner_scope): New functions.\n\t(lookup_type_scope): Don't deal with name from user declaration\n\tspecially.\n\t* name-lookup.h (push_inner_scope, pop_inner_scope): Add declarations.\n\t* parser.c (cp_parser_class_specifier): Use push_inner_scope and\n\tpop_inner_scope.\n\n\t* g++.dg/lookup/friend3.C: New test.\n\t* g++.dg/lookup/friend4.C: Likewise.\n\t* g++.dg/lookup/friend5.C: Likewise.\n\nFrom-SVN: r91300", "tree": {"sha": "91d0a3afa8097085bb941b4f5983bfc30e4e40c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91d0a3afa8097085bb941b4f5983bfc30e4e40c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87c465f52c1f582a61283932963305aab86e2aa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c465f52c1f582a61283932963305aab86e2aa6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87c465f52c1f582a61283932963305aab86e2aa6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87c465f52c1f582a61283932963305aab86e2aa6/comments", "author": null, "committer": null, "parents": [{"sha": "29ef83dee9acfdee32507bff8c536ae26f922402", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ef83dee9acfdee32507bff8c536ae26f922402", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ef83dee9acfdee32507bff8c536ae26f922402"}], "stats": {"total": 234, "additions": 217, "deletions": 17}, "files": [{"sha": "e79b20e559267c2586c6ac700d5c18cf41bce0e2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -1,3 +1,13 @@\n+2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 3/n, PR c++/3332\n+\t* name-lookup.c (push_inner_scope, pop_inner_scope): New functions.\n+\t(lookup_type_scope): Don't deal with name from user declaration\n+\tspecially.\n+\t* name-lookup.h (push_inner_scope, pop_inner_scope): Add declarations.\n+\t* parser.c (cp_parser_class_specifier): Use push_inner_scope and\n+\tpop_inner_scope.\n+\n 2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tFriend class name lookup 2/n, PR c++/14513, c++/15410"}, {"sha": "aa5e5d24454ac57718b876225eb96c8d736ab718", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 119, "deletions": 13, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -2542,8 +2542,10 @@ is_ancestor (tree root, tree child)\n     }\n }\n \n-/* Enter the class or namespace scope indicated by T.  Returns TRUE iff\n-   pop_scope should be called later to exit this scope.  */\n+/* Enter the class or namespace scope indicated by T suitable for\n+   name lookup.  T can be arbitrary scope, not necessary nested inside\n+   the current scope.  Returns TRUE iff pop_scope should be called\n+   later to exit this scope.  */\n \n bool\n push_scope (tree t)\n@@ -2578,6 +2580,110 @@ pop_scope (tree t)\n   else if CLASS_TYPE_P (t)\n     pop_nested_class ();\n }\n+\n+/* Subroutine of push_inner_scope.  */\n+\n+static void\n+push_inner_scope_r (tree outer, tree inner)\n+{\n+  tree prev;\n+\n+  if (outer == inner\n+      || (TREE_CODE (inner) != NAMESPACE_DECL && !CLASS_TYPE_P (inner)))\n+    return;\n+\n+  prev = CP_DECL_CONTEXT (TREE_CODE (inner) == NAMESPACE_DECL ? inner : TYPE_NAME (inner));\n+  if (outer != prev)\n+    push_inner_scope_r (outer, prev);\n+  if (TREE_CODE (inner) == NAMESPACE_DECL)\n+    {\n+      struct cp_binding_level *save_template_parm = 0;\n+      /* Temporary take out template parameter scopes.  They are saved\n+\t in reversed order in save_template_parm.  */\n+      while (current_binding_level->kind == sk_template_parms)\n+\t{\n+\t  struct cp_binding_level *b = current_binding_level;\n+\t  current_binding_level = b->level_chain;\n+\t  b->level_chain = save_template_parm;\n+\t  save_template_parm = b;\n+\t}\n+\n+      resume_scope (NAMESPACE_LEVEL (inner));\n+      current_namespace = inner;\n+\n+      /* Restore template parameter scopes.  */\n+      while (save_template_parm)\n+\t{\n+\t  struct cp_binding_level *b = save_template_parm;\n+\t  save_template_parm = b->level_chain;\n+\t  b->level_chain = current_binding_level;\n+\t  current_binding_level = b;\n+\t}\n+    }\n+  else\n+    pushclass (inner);\n+}\n+\n+/* Enter the scope INNER from current scope.  INNER must be a scope\n+   nested inside current scope.  This works with both name lookup and\n+   pushing name into scope.  In case a template parameter scope is present,\n+   namespace is pushed under the template parameter scope according to\n+   name lookup rule in 14.6.1/6.\n+   \n+   Return the former current scope suitable for pop_inner_scope.  */\n+\n+tree\n+push_inner_scope (tree inner)\n+{\n+  tree outer = current_scope ();\n+  if (!outer)\n+    outer = current_namespace;\n+\n+  push_inner_scope_r (outer, inner);\n+  return outer;\n+}\n+\n+/* Exit the current scope INNER back to scope OUTER.  */\n+\n+void\n+pop_inner_scope (tree outer, tree inner)\n+{\n+  if (outer == inner\n+      || (TREE_CODE (inner) != NAMESPACE_DECL && !CLASS_TYPE_P (inner)))\n+    return;\n+\n+  while (outer != inner)\n+    {\n+      if (TREE_CODE (inner) == NAMESPACE_DECL)\n+\t{\n+\t  struct cp_binding_level *save_template_parm = 0;\n+\t  /* Temporary take out template parameter scopes.  They are saved\n+\t     in reversed order in save_template_parm.  */\n+\t  while (current_binding_level->kind == sk_template_parms)\n+\t    {\n+\t      struct cp_binding_level *b = current_binding_level;\n+\t      current_binding_level = b->level_chain;\n+\t      b->level_chain = save_template_parm;\n+\t      save_template_parm = b;\n+\t    }\n+\n+\t  pop_namespace ();\n+\n+\t  /* Restore template parameter scopes.  */\n+\t  while (save_template_parm)\n+\t    {\n+\t      struct cp_binding_level *b = save_template_parm;\n+\t      save_template_parm = b->level_chain;\n+\t      b->level_chain = current_binding_level;\n+\t      current_binding_level = b;\n+\t    }\n+\t}\n+      else\n+\tpopclass ();\n+\n+      inner = CP_DECL_CONTEXT (TREE_CODE (inner) == NAMESPACE_DECL ? inner : TYPE_NAME (inner));\n+    }\n+}\n \f\n /* Do a pushlevel for class declarations.  */\n \n@@ -4125,14 +4231,17 @@ lookup_name (tree name, int prefer_type)\n \n /* Look up NAME for type used in elaborated name specifier in\n    the scopes given by SCOPE.  SCOPE can be either TS_CURRENT or\n-   TS_WITHIN_ENCLOSING_NON_CLASS (possibly more scope is checked if \n-   cleanup or template parameter scope is encountered).\n+   TS_WITHIN_ENCLOSING_NON_CLASS.  Although not implied by the\n+   name, more scopes are checked if cleanup or template parameter\n+   scope is encountered.\n \n    Unlike lookup_name_real, we make sure that NAME is actually\n-   declared in the desired scope, not from inheritance, using \n-   declaration, nor using directive.  A TYPE_DECL best matching\n-   the NAME is returned.  Catching error and issuing diagnostics\n-   are caller's responsibility.  */\n+   declared in the desired scope, not from inheritance, nor using\n+   directive.  For using declaration, there is DR138 still waiting\n+   to be resolved.\n+\n+   A TYPE_DECL best matching the NAME is returned.  Catching error\n+   and issuing diagnostics are caller's responsibility.  */\n \n tree\n lookup_type_scope (tree name, tag_scope scope)\n@@ -4182,12 +4291,9 @@ lookup_type_scope (tree name, tag_scope scope)\n \t  /* If this is the kind of thing we're looking for, we're done.\n \t     Ignore names found via using declaration.  See DR138 for\n \t     current status.  */\n-\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES)\n-\t      && (CP_DECL_CONTEXT (iter->type) == iter->scope->this_entity))\n+\t  if (qualify_lookup (iter->type, LOOKUP_PREFER_TYPES))\n \t    val = iter->type;\n-\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES)\n-\t\t   && (CP_DECL_CONTEXT (iter->value)\n-\t\t       == iter->scope->this_entity))\n+\t  else if (qualify_lookup (iter->value, LOOKUP_PREFER_TYPES))\n \t    val = iter->value;\n \t}\n \t"}, {"sha": "011c62a6f136bd5dc4c27971a936b7f3458e046e", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -306,6 +306,8 @@ extern void keep_next_level (bool);\n extern bool is_ancestor (tree, tree);\n extern bool push_scope (tree);\n extern void pop_scope (tree);\n+extern tree push_inner_scope (tree);\n+extern void pop_inner_scope (tree, tree);\n extern void push_binding_level (struct cp_binding_level *);\n \f\n extern void push_namespace (tree);"}, {"sha": "b2164b77235f527ab884c6223d56742a16025bad", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -12240,7 +12240,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   int has_trailing_semicolon;\n   bool nested_name_specifier_p;\n   unsigned saved_num_template_parameter_lists;\n-  bool pop_p = false;\n+  tree old_scope = NULL_TREE;\n   tree scope = NULL_TREE;\n \n   push_deferring_access_checks (dk_no_deferred);\n@@ -12279,7 +12279,7 @@ cp_parser_class_specifier (cp_parser* parser)\n   if (nested_name_specifier_p)\n     {\n       scope = CP_DECL_CONTEXT (TYPE_MAIN_DECL (type));\n-      pop_p = push_scope (scope);\n+      old_scope = push_inner_scope (scope);\n     }\n   type = begin_class_definition (type);\n \n@@ -12304,8 +12304,8 @@ cp_parser_class_specifier (cp_parser* parser)\n     }\n   if (type != error_mark_node)\n     type = finish_struct (type, attributes);\n-  if (pop_p)\n-    pop_scope (scope);\n+  if (nested_name_specifier_p)\n+    pop_inner_scope (old_scope, scope);\n   /* If this class is not itself within the scope of another class,\n      then we need to parse the bodies of all of the queued function\n      definitions.  Note that the queued functions defined in a class"}, {"sha": "934cb9aa81e8579b0952df6ca6f9526943ea3d72", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -1,3 +1,10 @@\n+2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tFriend class name lookup 3/n, PR c++/3332\n+\t* g++.dg/lookup/friend3.C: New test.\n+\t* g++.dg/lookup/friend4.C: Likewise.\n+\t* g++.dg/lookup/friend5.C: Likewise.\n+\n 2004-11-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tFriend class name lookup 2/n, PR c++/14513, c++/15410"}, {"sha": "2a58dd8ca057cfd324ec808fbea524eb739b152d", "filename": "gcc/testsuite/g++.dg/lookup/friend3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend3.C?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -0,0 +1,19 @@\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+// { dg-do compile }\n+\n+// Friend name lookup in class defined outside its namespace\n+\n+namespace A {\n+  class B;\n+  class C;\n+}\n+\n+class A::B {\n+  friend class C;\n+  typedef int i;\n+};\n+\n+class A::C {\n+  A::B::i j;\n+};"}, {"sha": "86ac9156109b65b8a3b2929c8d89158d131ea76c", "filename": "gcc/testsuite/g++.dg/lookup/friend4.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend4.C?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -0,0 +1,22 @@\n+// Copyright (C) 2004 Free Software Foundation\n+// Contributed by Kriang Lerdsuwanakij <lerdsuwa@users.sourceforge.net>\n+// { dg-do compile }\n+\n+// Friend name lookup in class defined outside its namespace\n+// (Local class case)\n+\n+void f() {\n+  class A {\n+    class B;\n+    class C;\n+  };\n+\n+  class A::B {\n+    friend class C;\n+    typedef int i;\n+  };\n+\n+  class A::C {\n+    A::B::i j;\n+  };\n+}"}, {"sha": "5be37bbd5abc2dbe549a21a72be6ae1ac3846e63", "filename": "gcc/testsuite/g++.dg/lookup/friend5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87c465f52c1f582a61283932963305aab86e2aa6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend5.C?ref=87c465f52c1f582a61283932963305aab86e2aa6", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// Origin: aroach@stoic.electriceyeball.com\n+\n+// PR c++/3332: Friend function lookup in class defined outside its\n+// namespace\n+\n+namespace N\n+{\n+  class A;\n+}\n+\n+class N::A\n+{\n+  void x();\n+  friend void func(void);\n+};\n+\n+namespace N\n+{\n+  void func(void);\n+}\n+\n+void N::func(void)\n+{\n+  N::A a;\n+  a.x();\n+}\n+\n+int main()\n+{\n+  return 0;\n+}\n+"}]}