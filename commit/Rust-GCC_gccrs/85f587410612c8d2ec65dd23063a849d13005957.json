{"sha": "85f587410612c8d2ec65dd23063a849d13005957", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODVmNTg3NDEwNjEyYzhkMmVjNjVkZDIzMDYzYTg0OWQxMzAwNTk1Nw==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-10T14:31:29Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-04-12T21:39:45Z"}, "message": "Add Canonical paths to name resolution\n\nIn order to support name resolution and checks for duplicate definitions\nof names we need canonical paths for all DefId items such as inherent impl\nitems and normal items.\n\nConsider:\n\n  struct Foo<T>(T);\n\n  impl Foo<f32> {\n    fn name()...\n  }\n\n  impl Foo<i32> {\n    fn name()...\n  }\n\nEach of the impl blocks have a name function but these are seperate due to\nthe concrete impl of the Parameter type passed in.\n\nThe caveat here is that to call this Function name the programmer must be\nexplicit in which implentation they wish to call such as:\n\n  let a = Foo::<f32>::name();\n\nThis lets the Path probe lookup the apropriate impl block. The problem here\nis that rust also allows for the compiler to infer the impl you wish such\nas:\n\n  let a = Foo::name();\n\nThis should fail since there are multiple candidates possible for this\nPath. Unless there might have only been one name function in which case\nit would have worked.\n\nThis does not support looking for any inherent impl items overlapping such\nas: rustc_typeck/src/coherence/inherent_impls_overlap.rs - see #353\n\nFixes #355 #335 #325", "tree": {"sha": "becd4a2fe59042dc35cbaae862403105b5ead1df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/becd4a2fe59042dc35cbaae862403105b5ead1df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85f587410612c8d2ec65dd23063a849d13005957", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f587410612c8d2ec65dd23063a849d13005957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85f587410612c8d2ec65dd23063a849d13005957", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85f587410612c8d2ec65dd23063a849d13005957/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fe4984806be69154e2a48be58965eb67a4be300", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fe4984806be69154e2a48be58965eb67a4be300", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fe4984806be69154e2a48be58965eb67a4be300"}], "stats": {"total": 1003, "additions": 686, "deletions": 317}, "files": [{"sha": "fbf05f2ad7d6fd48a551e208db1a8a89580f3886", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -109,15 +109,16 @@ class ResolveExpr : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n+\t\t\t\t\t    &resolved_node))\n       {\n \tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n \t\t\t\t\t Definition{expr.get_node_id (),\n \t\t\t\t\t\t    parent});\n       }\n-    else if (resolver->get_type_scope ().lookup (expr.as_string (),\n-\t\t\t\t\t\t &resolved_node))\n+    else if (resolver->get_type_scope ().lookup (\n+\t       CanonicalPath (expr.as_string ()), &resolved_node))\n       {\n \tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (expr.get_node_id (),\n@@ -255,8 +256,9 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  label_name, label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (std::string, NodeId, Location locus) -> void {\n+\t  CanonicalPath (label_name), label_lifetime_node_id,\n+\t  label.get_locus (), false,\n+\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n \t    rust_error_at (locus, \"was defined here\");\n@@ -281,8 +283,8 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n-\t\t\t\t\t\t  &resolved_node))\n+\tif (!resolver->get_label_scope ().lookup (\n+\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");\n@@ -311,8 +313,9 @@ class ResolveExpr : public ResolverBase\n \tauto label_name = label.get_lifetime ().get_lifetime_name ();\n \tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n \tresolver->get_label_scope ().insert (\n-\t  label_name, label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (std::string, NodeId, Location locus) -> void {\n+\t  CanonicalPath (label_name), label_lifetime_node_id,\n+\t  label.get_locus (), false,\n+\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \t    rust_error_at (label.get_locus (),\n \t\t\t   \"label redefined multiple times\");\n \t    rust_error_at (locus, \"was defined here\");\n@@ -338,8 +341,8 @@ class ResolveExpr : public ResolverBase\n \t  }\n \n \tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (label.get_lifetime_name (),\n-\t\t\t\t\t\t  &resolved_node))\n+\tif (!resolver->get_label_scope ().lookup (\n+\t      CanonicalPath (label.get_lifetime_name ()), &resolved_node))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to resolve label\");"}, {"sha": "46343c2796eb29f55677a50a1ed95ced2cfbcf04", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 18, "deletions": 26, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -31,25 +31,19 @@ class ResolveToplevelImplItem : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::InherentImplItem *item, AST::Type *base)\n+  static void go (AST::InherentImplItem *item, const CanonicalPath &prefix)\n   {\n-    ResolveToplevelImplItem resolver (base);\n-    if (resolver.base_path.is_empty ())\n-      {\n-\trust_error_at (base->get_locus_slow (),\n-\t\t       \"failed to resolve simple path\");\n-\treturn;\n-      }\n+    ResolveToplevelImplItem resolver (prefix);\n     item->accept_vis (resolver);\n   }\n \n   void visit (AST::ConstantItem &constant) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + constant.get_identifier ();\n+    auto path\n+      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n     resolver->get_name_scope ().insert (\n-      identifier, constant.get_node_id (), constant.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (constant.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -60,11 +54,11 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + function.get_function_name ();\n+    auto path\n+      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n     resolver->get_name_scope ().insert (\n-      identifier, function.get_node_id (), function.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (function.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -75,11 +69,11 @@ class ResolveToplevelImplItem : public ResolverBase\n \n   void visit (AST::Method &method) override\n   {\n-    std::string identifier\n-      = base_path.as_string () + \"::\" + method.get_method_name ();\n+    auto path\n+      = prefix.append (ResolveMethodItemToCanonicalPath::resolve (method));\n     resolver->get_name_scope ().insert (\n-      identifier, method.get_node_id (), method.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, method.get_node_id (), method.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (method.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -89,15 +83,13 @@ class ResolveToplevelImplItem : public ResolverBase\n   }\n \n private:\n-  ResolveToplevelImplItem (AST::Type *base)\n-    : ResolverBase (UNKNOWN_NODEID), base (base),\n-      base_path (AST::SimplePath::create_empty ())\n+  ResolveToplevelImplItem (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n   {\n-    ResolveTypeToSimplePath::go (base, base_path, true);\n+    rust_assert (!prefix.is_error ());\n   }\n \n-  AST::Type *base;\n-  AST::SimplePath base_path;\n+  const CanonicalPath &prefix;\n };\n \n } // namespace Resolver"}, {"sha": "9c19ce6d26f4c27e37016aea8dc20b4154a0356b", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -179,18 +179,21 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    bool canonicalize_type_with_generics = false;\n     NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n-\t\t\t\t\t    impl_block.get_node_id ());\n+\t\t\t\t\t    impl_block.get_node_id (),\n+\t\t\t\t\t    canonicalize_type_with_generics);\n     if (resolved_node == UNKNOWN_NODEID)\n       return;\n \n+    auto Self = CanonicalPath::get_big_self ();\n     resolver->get_type_scope ().insert (\n-      \"Self\", resolved_node, impl_block.get_type ()->get_locus_slow ());\n+      Self, resolved_node, impl_block.get_type ()->get_locus_slow ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       impl_item->accept_vis (*this);\n \n-    resolver->get_type_scope ().peek ()->clear_name (\"Self\", resolved_node);\n+    resolver->get_type_scope ().peek ()->clear_name (Self, resolved_node);\n     resolver->get_type_scope ().pop ();\n   }\n "}, {"sha": "07349081fcf246b870f393b5c0ad1a617e0fce3f", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -33,7 +33,6 @@ class ResolvePattern : public ResolverBase\n   static void go (AST::Pattern *pattern, NodeId parent)\n   {\n     ResolvePattern resolver (parent);\n-\n     pattern->accept_vis (resolver);\n     if (resolver.resolved_node == UNKNOWN_NODEID)\n       {\n@@ -42,12 +41,10 @@ class ResolvePattern : public ResolverBase\n       }\n   };\n \n-  ~ResolvePattern () {}\n-\n   void visit (AST::IdentifierPattern &pattern) override\n   {\n-    if (resolver->get_name_scope ().lookup (pattern.get_ident (),\n-\t\t\t\t\t    &resolved_node))\n+    if (resolver->get_name_scope ().lookup (\n+\t  CanonicalPath (pattern.get_ident ()), &resolved_node))\n       {\n \tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n \tresolver->insert_new_definition (pattern.get_node_id (),\n@@ -68,23 +65,14 @@ class PatternDeclaration : public ResolverBase\n   static void go (AST::Pattern *pattern, NodeId parent)\n   {\n     PatternDeclaration resolver (parent);\n-\n     pattern->accept_vis (resolver);\n-    if (resolver.resolved_node != UNKNOWN_NODEID)\n-      {\n-\t// print both locations?!\n-\trust_error_at (resolver.locus, \"duplicate pattern %s\",\n-\t\t       pattern->as_string ().c_str ());\n-      }\n   };\n \n-  ~PatternDeclaration () {}\n-\n   void visit (AST::IdentifierPattern &pattern) override\n   {\n     // if we have a duplicate id this then allows for shadowing correctly\n     // as new refs to this decl will match back here so it is ok to overwrite\n-    resolver->get_name_scope ().insert (pattern.get_ident (),\n+    resolver->get_name_scope ().insert (CanonicalPath (pattern.get_ident ()),\n \t\t\t\t\tpattern.get_node_id (),\n \t\t\t\t\tpattern.get_locus ());\n     resolver->insert_new_definition (pattern.get_node_id (),"}, {"sha": "2550c3953622fdab1ec0c2521de4b3968388fc68", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -32,17 +32,19 @@ class ResolveTopLevel : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::Item *item)\n+  static void go (AST::Item *item,\n+\t\t  const CanonicalPath &prefix = CanonicalPath::create_empty ())\n   {\n-    ResolveTopLevel resolver;\n+    ResolveTopLevel resolver (prefix);\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TypeAlias &alias) override\n   {\n     resolver->get_type_scope ().insert (\n-      alias.get_new_type_name (), alias.get_node_id (), alias.get_locus (),\n-      false, [&] (std::string, NodeId, Location locus) -> void {\n+      CanonicalPath (alias.get_new_type_name ()), alias.get_node_id (),\n+      alias.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (alias.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -51,9 +53,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::TupleStruct &struct_decl) override\n   {\n     resolver->get_type_scope ().insert (\n-      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n       struct_decl.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -62,9 +64,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::StructStruct &struct_decl) override\n   {\n     resolver->get_type_scope ().insert (\n-      struct_decl.get_identifier (), struct_decl.get_node_id (),\n+      CanonicalPath (struct_decl.get_identifier ()), struct_decl.get_node_id (),\n       struct_decl.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (struct_decl.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -73,8 +75,9 @@ class ResolveTopLevel : public ResolverBase\n   void visit (AST::StaticItem &var) override\n   {\n     resolver->get_name_scope ().insert (\n-      var.get_identifier (), var.get_node_id (), var.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      CanonicalPath (var.get_identifier ()), var.get_node_id (),\n+      var.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (var.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -86,10 +89,11 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::ConstantItem &constant) override\n   {\n+    auto path\n+      = prefix.append (ResolveConstantItemToCanonicalPath::resolve (constant));\n     resolver->get_name_scope ().insert (\n-      constant.get_identifier (), constant.get_node_id (),\n-      constant.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, constant.get_node_id (), constant.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (constant.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -100,10 +104,11 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::Function &function) override\n   {\n+    auto path\n+      = prefix.append (ResolveFunctionItemToCanonicalPath::resolve (function));\n     resolver->get_name_scope ().insert (\n-      function.get_function_name (), function.get_node_id (),\n-      function.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      path, function.get_node_id (), function.get_locus (), false,\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (function.get_locus (), \"redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n@@ -122,13 +127,24 @@ class ResolveTopLevel : public ResolverBase\n \n   void visit (AST::InherentImpl &impl_block) override\n   {\n+    bool canonicalize_type_args = !impl_block.has_generics ();\n+    bool type_resolve_generic_args = false;\n+    CanonicalPath impl_type\n+      = ResolveTypeToCanonicalPath::resolve (*impl_block.get_type ().get (),\n+\t\t\t\t\t     canonicalize_type_args,\n+\t\t\t\t\t     type_resolve_generic_args);\n+    CanonicalPath impl_prefix = prefix.append (impl_type);\n+\n     for (auto &impl_item : impl_block.get_impl_items ())\n-      ResolveToplevelImplItem::go (impl_item.get (),\n-\t\t\t\t   impl_block.get_type ().get ());\n+      ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);\n   }\n \n private:\n-  ResolveTopLevel () : ResolverBase (UNKNOWN_NODEID) {}\n+  ResolveTopLevel (const CanonicalPath &prefix)\n+    : ResolverBase (UNKNOWN_NODEID), prefix (prefix)\n+  {}\n+\n+  const CanonicalPath &prefix;\n };\n \n } // namespace Resolver"}, {"sha": "35e04a87450a79a6adac433c2f469f652811b744", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 117, "deletions": 42, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -25,73 +25,136 @@\n namespace Rust {\n namespace Resolver {\n \n-class ResolveTypeToSimplePath : public ResolverBase\n+class ResolveConstantItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::ConstantItem &constant)\n+  {\n+    return CanonicalPath (constant.get_identifier ());\n+  }\n+};\n+\n+class ResolveFunctionItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::Function &function)\n+  {\n+    return CanonicalPath (function.get_function_name ());\n+  }\n+};\n+\n+class ResolveMethodItemToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::Method &method)\n+  {\n+    return CanonicalPath (method.get_method_name ());\n+  }\n+};\n+\n+class ResolveTypeToCanonicalPath : public ResolverBase\n {\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static bool go (AST::Type *type, AST::SimplePath &simple_path_result,\n-\t\t  bool path_only = false)\n+  static CanonicalPath resolve (AST::Type &type,\n+\t\t\t\tbool include_generic_args = true,\n+\t\t\t\tbool type_resolve_generic_args = true)\n   {\n-    ResolveTypeToSimplePath resolver (simple_path_result, path_only);\n-    type->accept_vis (resolver);\n-    return !resolver.type_seg_failed_flag;\n+    ResolveTypeToCanonicalPath resolver (include_generic_args,\n+\t\t\t\t\t type_resolve_generic_args);\n+    type.accept_vis (resolver);\n+    return resolver.result;\n   }\n \n   void visit (AST::TypePath &path) override\n   {\n-    segs.reserve (path.get_num_segments ());\n     for (auto &seg : path.get_segments ())\n       {\n \tseg->accept_vis (*this);\n-\tif (type_seg_failed_flag)\n+\tif (failure_flag)\n \t  return;\n       }\n-\n-    if (segs.empty ())\n-      {\n-\trust_error_at (path.get_locus (), \"failed to resolve path: %s\",\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    bool has_opening_scope_res = false;\n-    result = AST::SimplePath (std::move (segs), has_opening_scope_res,\n-\t\t\t      path.get_locus ());\n   }\n \n   void visit (AST::TypePathSegmentGeneric &seg) override;\n \n   void visit (AST::TypePathSegment &seg) override;\n \n+  static CanonicalPath canonicalize_generic_args (AST::GenericArgs &args);\n+\n+  static bool type_resolve_generic_args (AST::GenericArgs &args);\n+\n private:\n-  ResolveTypeToSimplePath (AST::SimplePath &simple_path_result, bool path_only)\n-    : ResolverBase (UNKNOWN_NODEID), type_seg_failed_flag (false),\n-      result (simple_path_result), path_only_flag (path_only)\n+  ResolveTypeToCanonicalPath (bool include_generic_args,\n+\t\t\t      bool type_resolve_generic_args)\n+    : ResolverBase (UNKNOWN_NODEID), result (CanonicalPath::create_empty ()),\n+      include_generic_args_flag (include_generic_args),\n+      type_resolve_generic_args_flag (type_resolve_generic_args),\n+      failure_flag (false)\n   {}\n \n-  bool type_seg_failed_flag;\n-  std::vector<AST::SimplePathSegment> segs;\n-  AST::SimplePath &result;\n-  bool path_only_flag;\n+  CanonicalPath result;\n+  bool include_generic_args_flag;\n+  bool type_resolve_generic_args_flag;\n+  bool failure_flag;\n+};\n+\n+class ResolvePathSegmentToCanonicalPath\n+{\n+public:\n+  static CanonicalPath resolve (AST::PathExprSegment &seg)\n+  {\n+    CanonicalPath path = CanonicalPath (seg.get_ident_segment ().as_string ());\n+    if (seg.has_generic_args ())\n+      {\n+\tbool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\t  seg.get_generic_args ());\n+\tif (!ok)\n+\t  {\n+\t    rust_error_at (seg.get_locus (),\n+\t\t\t   \"failed to resolve all generic args\");\n+\t    return CanonicalPath::create_empty ();\n+\t  }\n+\n+\tpath\n+\t  = path.append (ResolveTypeToCanonicalPath::canonicalize_generic_args (\n+\t    seg.get_generic_args ()));\n+      }\n+    return path;\n+  }\n };\n \n-class ResolveTypePath\n+// FIXME: as part of imports and visibility we need to be able to keep a context\n+// for handling PathInExpressions segments as they can be local to a particular\n+// lexical scope requiring a context to be maintained for resolution\n+class ResolveRelativeTypePath\n {\n public:\n-  static NodeId go (AST::TypePath &path, NodeId parent)\n+  static NodeId go (AST::TypePath &path, NodeId parent,\n+\t\t    const CanonicalPath &prefix,\n+\t\t    bool canonicalize_type_with_generics)\n   {\n-    AST::SimplePath path_buffer = AST::SimplePath::create_empty ();\n-    if (!ResolveTypeToSimplePath::go (&path, path_buffer))\n-      return UNKNOWN_NODEID;\n+    CanonicalPath canonical_path\n+      = ResolveTypeToCanonicalPath::resolve (path,\n+\t\t\t\t\t     canonicalize_type_with_generics,\n+\t\t\t\t\t     true);\n+    if (canonical_path.is_error ())\n+      {\n+\trust_error_at (path.get_locus (), \"Failed to resolve canonical path\");\n+\treturn UNKNOWN_NODEID;\n+      }\n+\n+    CanonicalPath lookup = canonical_path;\n+    if (!prefix.is_error ())\n+      lookup = prefix.append (canonical_path);\n \n     auto resolver = Resolver::get ();\n     NodeId resolved_node = UNKNOWN_NODEID;\n-    if (!resolver->get_type_scope ().lookup (path_buffer.as_string (),\n-\t\t\t\t\t     &resolved_node))\n+    if (!resolver->get_type_scope ().lookup (canonical_path, &resolved_node))\n       {\n \trust_error_at (path.get_locus_slow (), \"failed to resolve TypePath: %s\",\n-\t\t       path_buffer.as_string ().c_str ());\n+\t\t       canonical_path.get ().c_str ());\n \treturn UNKNOWN_NODEID;\n       }\n \n@@ -104,9 +167,10 @@ class ResolveType : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static NodeId go (AST::Type *type, NodeId parent)\n+  static NodeId go (AST::Type *type, NodeId parent,\n+\t\t    bool canonicalize_type_with_generics = false)\n   {\n-    ResolveType resolver (parent);\n+    ResolveType resolver (parent, canonicalize_type_with_generics);\n     type->accept_vis (resolver);\n     if (!resolver.ok)\n       rust_error_at (type->get_locus_slow (), \"unresolved type\");\n@@ -139,7 +203,10 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    resolved_node = ResolveTypePath::go (path, parent);\n+    resolved_node\n+      = ResolveRelativeTypePath::go (path, parent,\n+\t\t\t\t     CanonicalPath::create_empty (),\n+\t\t\t\t     canonicalize_type_with_generics);\n     ok = resolved_node != UNKNOWN_NODEID;\n     if (ok)\n       {\n@@ -160,12 +227,16 @@ class ResolveType : public ResolverBase\n     type.get_type_referenced ()->accept_vis (*this);\n   }\n \n-  // nothing to do for inferred types\n   void visit (AST::InferredType &type) override { ok = true; }\n \n private:\n-  ResolveType (NodeId parent) : ResolverBase (parent), ok (false) {}\n+  ResolveType (NodeId parent, bool canonicalize_type_with_generics)\n+    : ResolverBase (parent),\n+      canonicalize_type_with_generics (canonicalize_type_with_generics),\n+      ok (false)\n+  {}\n \n+  bool canonicalize_type_with_generics;\n   bool ok;\n };\n \n@@ -190,17 +261,21 @@ class ResolveGenericParam : public ResolverBase\n \n     // for now lets focus on handling the basics: like struct<T> { a:T, ....}\n     resolver->get_type_scope ().insert (\n-      param.get_type_representation (), param.get_node_id (),\n+      CanonicalPath (param.get_type_representation ()), param.get_node_id (),\n       param.get_locus (), false,\n-      [&] (std::string, NodeId, Location locus) -> void {\n+      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n \trust_error_at (param.get_locus (),\n \t\t       \"generic param redefined multiple times\");\n \trust_error_at (locus, \"was defined here\");\n       });\n   }\n \n private:\n-  ResolveGenericParam (NodeId parent) : ResolverBase (parent), ok (false) {}\n+  ResolveGenericParam (NodeId parent)\n+    : ResolverBase (parent),\n+\n+      ok (false)\n+  {}\n \n   bool ok;\n };"}, {"sha": "aac55e2a696947164e8b2bf9b872da4d0bdb967b", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 165, "deletions": 45, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -50,7 +50,8 @@ Resolver::Resolver ()\n   : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n     name_scope (Scope (mappings->get_current_crate ())),\n     type_scope (Scope (mappings->get_current_crate ())),\n-    label_scope (Scope (mappings->get_current_crate ()))\n+    label_scope (Scope (mappings->get_current_crate ())),\n+    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n {\n   generate_builtins ();\n }\n@@ -116,9 +117,12 @@ Resolver::insert_builtin_types (Rib *r)\n {\n   auto builtins = get_builtin_types ();\n   for (auto &builtin : builtins)\n-    r->insert_name (builtin->as_string (), builtin->get_node_id (),\n-\t\t    Linemap::predeclared_location (), false,\n-\t\t    [] (std::string, NodeId, Location) -> void {});\n+    {\n+      CanonicalPath builtin_path (builtin->as_string ());\n+      r->insert_name (builtin_path, builtin->get_node_id (),\n+\t\t      Linemap::predeclared_location (), false,\n+\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n+    }\n }\n \n std::vector<AST::Type *> &\n@@ -374,88 +378,170 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n \n // rust-ast-resolve-type.h\n \n-void\n-ResolveTypeToSimplePath::visit (AST::TypePathSegmentGeneric &seg)\n+CanonicalPath\n+ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n {\n-  if (!path_only_flag)\n+  std::string buf;\n+\n+  size_t i = 0;\n+  size_t total = args.get_type_args ().size ();\n+\n+  for (auto &ty_arg : args.get_type_args ())\n     {\n-      AST::GenericArgs &generics = seg.get_generic_args ();\n-      for (auto &gt : generics.get_type_args ())\n-\tResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      buf += ty_arg->as_string ();\n+      if ((i + 1) < total)\n+\tbuf += \",\";\n+\n+      i++;\n     }\n \n+  return CanonicalPath (\"<\" + buf + \">\");\n+}\n+\n+bool\n+ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n+{\n+  for (auto &gt : args.get_type_args ())\n+    {\n+      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      // FIXME error handling here for inference variable since they do not have\n+      // a node to resolve to\n+      // if (resolved == UNKNOWN_NODEID) return false;\n+    }\n+  return true;\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n   if (seg.is_error ())\n     {\n-      type_seg_failed_flag = true;\n-      rust_error_at (Location (), \"segment has error: %s\",\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n \t\t     seg.as_string ().c_str ());\n       return;\n     }\n \n-  segs.push_back (AST::SimplePathSegment (seg.get_ident_segment ().as_string (),\n-\t\t\t\t\t  seg.get_locus ()));\n+  // ident seg\n+  CanonicalPath ident_seg\n+    = CanonicalPath (seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n+\n+  // generic args\n+  if (seg.has_generic_args ())\n+    {\n+      if (include_generic_args_flag)\n+\tresult\n+\t  = result.append (canonicalize_generic_args (seg.get_generic_args ()));\n+\n+      if (type_resolve_generic_args_flag)\n+\t{\n+\t  bool ok = type_resolve_generic_args (seg.get_generic_args ());\n+\t  failure_flag = !ok;\n+\t}\n+    }\n }\n \n void\n-ResolveTypeToSimplePath::visit (AST::TypePathSegment &seg)\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n {\n   if (seg.is_error ())\n     {\n-      type_seg_failed_flag = true;\n-      rust_error_at (Location (), \"segment has error: %s\",\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n \t\t     seg.as_string ().c_str ());\n       return;\n     }\n \n-  segs.push_back (AST::SimplePathSegment (seg.get_ident_segment ().as_string (),\n-\t\t\t\t\t  seg.get_locus ()));\n+  CanonicalPath ident_seg\n+    = CanonicalPath (seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n }\n \n // rust-ast-resolve-expr.h\n \n void\n ResolvePath::resolve_path (AST::PathInExpression *expr)\n {\n-  // this needs extended similar to the TypePath to lookup each segment\n-  // in turn then look its rib for the next segment and so forth until we\n-  // resolve to a final NodeId generic args can be ignored\n-  std::string path_buf;\n-  for (auto &seg : expr->get_segments ())\n+  // resolve root segment first then apply segments in turn\n+  AST::PathExprSegment &root_segment = expr->get_segments ().at (0);\n+  AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n+\n+  bool segment_is_type = false;\n+  CanonicalPath root_seg_path (root_ident_seg.as_string ());\n+\n+  // name scope first\n+  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n     {\n-      auto s = seg.get_ident_segment ();\n-      if (s.is_error () && !seg.has_generic_args ())\n+      segment_is_type = false;\n+      resolver->insert_resolved_name (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  // check the type scope\n+  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n+    {\n+      segment_is_type = true;\n+      resolver->insert_resolved_type (root_segment.get_node_id (),\n+\t\t\t\t      resolved_node);\n+      resolver->insert_new_definition (root_segment.get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr->get_locus (),\n+\t\t     \"unknown root segment in path %s lookup %s\",\n+\t\t     expr->as_string ().c_str (),\n+\t\t     root_ident_seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (root_segment.has_generic_args ())\n+    {\n+      bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\troot_segment.get_generic_args ());\n+      if (!ok)\n \t{\n-\t  rust_error_at (expr->get_locus (), \"malformed path\");\n+\t  rust_error_at (root_segment.get_locus (),\n+\t\t\t \"failed to resolve generic args\");\n \t  return;\n \t}\n+    }\n \n-      if (seg.has_generic_args ())\n-\t{\n-\t  AST::GenericArgs &args = seg.get_generic_args ();\n-\t  for (auto &gt : args.get_type_args ())\n-\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n-\t}\n+  if (expr->is_single_segment ())\n+    {\n+      if (segment_is_type)\n+\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      else\n+\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n \n-      if (!s.is_error ())\n-\t{\n-\t  bool needs_sep = !path_buf.empty ();\n-\t  if (needs_sep)\n-\t    path_buf += \"::\";\n+      resolver->insert_new_definition (expr->get_node_id (),\n+\t\t\t\t       Definition{expr->get_node_id (),\n+\t\t\t\t\t\t  parent});\n+      return;\n+    }\n \n-\t  path_buf += s.as_string ();\n-\t}\n+  // we can attempt to resolve this path fully\n+  CanonicalPath path = root_seg_path;\n+  for (size_t i = 1; i < expr->get_segments ().size (); i++)\n+    {\n+      AST::PathExprSegment &seg = expr->get_segments ().at (i);\n+      auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n+      path = path.append (s);\n     }\n \n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (path_buf, &resolved_node))\n+  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n     {\n       resolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n       resolver->insert_new_definition (expr->get_node_id (),\n \t\t\t\t       Definition{expr->get_node_id (),\n \t\t\t\t\t\t  parent});\n     }\n   // check the type scope\n-  else if (resolver->get_type_scope ().lookup (path_buf, &resolved_node))\n+  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n     {\n       resolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n       resolver->insert_new_definition (expr->get_node_id (),\n@@ -464,8 +550,42 @@ ResolvePath::resolve_path (AST::PathInExpression *expr)\n     }\n   else\n     {\n-      rust_error_at (expr->get_locus (), \"unknown path %s lookup %s\",\n-\t\t     expr->as_string ().c_str (), path_buf.c_str ());\n+      // attempt to fully resolve the path which is allowed to fail given the\n+      // following scenario\n+      //\n+      // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n+      // resolved fully here, there are limitations though imagine:\n+      //\n+      // struct Foo<A> (A);\n+      //\n+      // impl Foo<isize> {\n+      //    fn test() -> ...\n+      //\n+      // impl Foo<f32> {\n+      //    fn test() -> ...\n+      //\n+      // fn main() {\n+      //    let a:i32 = Foo::test();\n+      //\n+      // there are multiple paths that test can resolve to Foo::<?>::test here\n+      // so we cannot resolve this case\n+      //\n+      // canonical names:\n+      //\n+      // struct Foo<A>            -> Foo\n+      // impl Foo<isize>::fn test -> Foo::isize::test\n+      // impl Foo<f32>::fn test   -> Foo::f32::test\n+      //\n+      // Since there is the case we have the following paths for test:\n+      //\n+      // Foo::isize::test\n+      // Foo::f32::test\n+      // vs\n+      // Foo::test\n+      //\n+      // but the lookup was simply Foo::test we must rely on type resolution to\n+      // figure this type out in a similar fashion to method resolution with a\n+      // probe phase\n     }\n }\n "}, {"sha": "13b6c91cda6d327359c79ac65db2f3ab1f0c3436", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -57,7 +57,8 @@ class VerifyAsignee : public ResolverBase\n \n   void visit (AST::IdentifierExpr &expr) override\n   {\n-    if (!resolver->get_name_scope ().lookup (expr.as_string (), &resolved_node))\n+    if (!resolver->get_name_scope ().lookup (CanonicalPath (expr.as_string ()),\n+\t\t\t\t\t     &resolved_node))\n       return;\n \n     ok = true;"}, {"sha": "205c877fe2bd3ed7530a8a3b5cabfd18a445a04b", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 74, "deletions": 14, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -26,6 +26,62 @@\n namespace Rust {\n namespace Resolver {\n \n+// https://doc.rust-lang.org/reference/paths.html#canonical-paths\n+//\n+// struct X - path X\n+// impl X { fn test - path X::test }\n+//\n+// struct X<T> - path X\n+//\n+// impl X<T>   { fn test - path X::test}\n+// impl X<i32> { fn test - path X<i32>::test }\n+// impl X<f32> { fn test - path X<f32>::test }\n+class CanonicalPath\n+{\n+public:\n+  explicit CanonicalPath (std::string path) : path (path) {}\n+\n+  CanonicalPath (const CanonicalPath &other) : path (other.path) {}\n+\n+  CanonicalPath &operator= (const CanonicalPath &other)\n+  {\n+    path = other.path;\n+    return *this;\n+  }\n+\n+  std::string get () const { return path; }\n+\n+  static CanonicalPath get_big_self () { return CanonicalPath (\"Self\"); }\n+\n+  static CanonicalPath get_wee_self () { return CanonicalPath (\"self\"); }\n+\n+  static CanonicalPath create_empty ()\n+  {\n+    return CanonicalPath (std::string ());\n+  }\n+\n+  bool is_error () const { return path.empty (); }\n+\n+  CanonicalPath append (const CanonicalPath &other) const\n+  {\n+    rust_assert (!other.is_error ());\n+    return is_error () ? CanonicalPath (other.get ())\n+\t\t       : CanonicalPath (append (other.get ()));\n+  }\n+\n+  bool operator== (const CanonicalPath &b) const\n+  {\n+    return get ().compare (b.get ()) == 0;\n+  }\n+\n+  bool operator< (const CanonicalPath &b) const { return get () < b.get (); }\n+\n+private:\n+  std::string append (std::string elem) const { return path + \"::\" + elem; }\n+\n+  std::string path;\n+};\n+\n class Rib\n {\n public:\n@@ -37,31 +93,32 @@ class Rib\n \n   ~Rib () {}\n \n-  void insert_name (std::string ident, NodeId id, Location locus, bool shadow,\n-\t\t    std::function<void (std::string, NodeId, Location)> dup_cb)\n+  void insert_name (\n+    const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+    std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n   {\n-    auto it = mappings.find (ident);\n+    auto it = mappings.find (path);\n     bool already_exists = it != mappings.end ();\n     if (already_exists && !shadow)\n       {\n \tfor (auto &decl : decls_within_rib)\n \t  {\n \t    if (decl.first == it->second)\n \t      {\n-\t\tdup_cb (ident, it->second, decl.second);\n+\t\tdup_cb (path, it->second, decl.second);\n \t\treturn;\n \t      }\n \t  }\n-\tdup_cb (ident, it->second, locus);\n+\tdup_cb (path, it->second, locus);\n \treturn;\n       }\n \n-    mappings[ident] = id;\n+    mappings[path] = id;\n     decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n     references[id] = {};\n   }\n \n-  bool lookup_name (std::string ident, NodeId *id)\n+  bool lookup_name (const CanonicalPath &ident, NodeId *id)\n   {\n     auto it = mappings.find (ident);\n     if (it == mappings.end ())\n@@ -71,7 +128,7 @@ class Rib\n     return true;\n   }\n \n-  void clear_name (std::string ident, NodeId id)\n+  void clear_name (const CanonicalPath &ident, NodeId id)\n   {\n     mappings.erase (ident);\n     for (auto &it : decls_within_rib)\n@@ -136,7 +193,7 @@ class Rib\n private:\n   CrateNum crate_num;\n   NodeId node_id;\n-  std::map<std::string, NodeId> mappings;\n+  std::map<CanonicalPath, NodeId> mappings;\n   std::set<std::pair<NodeId, Location> > decls_within_rib;\n   std::map<NodeId, std::set<NodeId> > references;\n };\n@@ -145,21 +202,24 @@ class Scope\n {\n public:\n   Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+\n   ~Scope () {}\n \n-  void insert (std::string ident, NodeId id, Location locus, bool shadow,\n-\t       std::function<void (std::string, NodeId, Location)> dup_cb)\n+  void\n+  insert (const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+\t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n   {\n     peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n   }\n \n-  void insert (std::string ident, NodeId id, Location locus)\n+  void insert (const CanonicalPath &ident, NodeId id, Location locus)\n   {\n     peek ()->insert_name (ident, id, locus, true,\n-\t\t\t  [] (std::string, NodeId, Location) -> void {});\n+\t\t\t  [] (const CanonicalPath &, NodeId, Location) -> void {\n+\t\t\t  });\n   }\n \n-  bool lookup (std::string ident, NodeId *id)\n+  bool lookup (const CanonicalPath &ident, NodeId *id)\n   {\n     NodeId lookup = UNKNOWN_NODEID;\n     iterate ([&] (Rib *r) mutable -> bool {"}, {"sha": "35a5502f4ca872d6e1c3069f8d6de3457d832ce2", "filename": "gcc/rust/typecheck/rust-hir-method-resolve.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-method-resolve.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -40,7 +40,8 @@ class MethodResolution : public TypeCheckBase\n     // lookup impl items for this crate and find all methods that can resolve to\n     // this receiver\n     probe.mappings->iterate_impl_items (\n-      [&] (HirId id, HIR::InherentImplItem *item) mutable -> bool {\n+      [&] (HirId id, HIR::InherentImplItem *item,\n+\t   HIR::InherentImpl *impl) mutable -> bool {\n \titem->accept_vis (probe);\n \treturn true;\n       });"}, {"sha": "b9468126f7547c7073414836d2ba7181aae6c552", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 142, "deletions": 61, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-tyty-call.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n #include \"rust-hir-method-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n #include \"rust-substitution-mapper.h\"\n \n namespace Rust {\n@@ -171,8 +172,6 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     TyTy::BaseType *function_tyty\n       = TypeCheckExpr::Resolve (expr.get_fnexpr (), false);\n-    if (function_tyty == nullptr)\n-      return;\n \n     bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n \t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n@@ -759,80 +758,93 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::PathInExpression &expr) override\n   {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n+    // resolve root_segment\n+    TyTy::BaseType *tyseg = resolve_root_path (expr);\n+    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+    else if (expr.get_num_segments () == 1)\n+      {\n+\tinfered = tyseg;\n+\treturn;\n+      }\n \n-    // then lookup the reference_node_id\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    NodeId resolved_node_id = UNKNOWN_NODEID;\n+    for (size_t i = 1; i < expr.get_num_segments (); i++)\n       {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\tHIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n+\t// probe the path\n+\tauto candidates = PathProbeType::Probe (tyseg, seg.get_segment ());\n+\tif (candidates.size () == 0)\n \t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n+\t    rust_error_at (seg.get_locus (), \"failed to resolve path segment\");\n+\t    return;\n+\t  }\n+\telse if (candidates.size () > 1)\n+\t  {\n+\t    ReportMultipleCandidateError::Report (candidates,\n+\t\t\t\t\t\t  seg.get_segment (),\n+\t\t\t\t\t\t  seg.get_locus ());\n \t    return;\n \t  }\n-\tref_node_id = def.parent;\n-      }\n-    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-      {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n \n-    if (ref_node_id == UNKNOWN_NODEID)\n-      {\n-\trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n-      }\n+\tauto candidate = candidates.at (0);\n+\ttyseg = candidate.ty;\n+\tresolved_node_id\n+\t  = candidate.impl_item->get_impl_mappings ().get_nodeid ();\n \n-    // node back to HIR\n-    HirId ref;\n-    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t       ref_node_id, &ref))\n-      {\n-\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-\treturn;\n+\tbool did_substitute = false;\n+\tif (seg.has_generic_args ())\n+\t  {\n+\t    if (!tyseg->can_substitute ())\n+\t      {\n+\t\trust_error_at (expr.get_locus (),\n+\t\t\t       \"substitutions not supported for %s\",\n+\t\t\t       tyseg->as_string ().c_str ());\n+\t\treturn;\n+\t      }\n+\n+\t    did_substitute = true;\n+\t    tyseg = SubstMapper::Resolve (tyseg, expr.get_locus (),\n+\t\t\t\t\t  &seg.get_generic_args ());\n+\n+\t    if (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t      return;\n+\t  }\n+\telse\n+\t  {\n+\t    if (tyseg->needs_generic_substitutions ())\n+\t      {\n+\t\tdid_substitute = true;\n+\t\ttyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n+\t\tif (tyseg->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t  return;\n+\t      }\n+\t  }\n       }\n \n-    if (!context->lookup_type (ref, &infered))\n+    rust_assert (resolved_node_id != UNKNOWN_NODEID);\n+\n+    // lookup if the name resolver was able to canonically resolve this or not\n+    NodeId path_resolved_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t&path_resolved_id))\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve PathInExpression type\");\n-\treturn;\n+\trust_assert (path_resolved_id == resolved_node_id);\n       }\n-\n-    HIR::PathExprSegment seg = expr.get_final_segment ();\n-    if (!infered->supports_substitutions () && seg.has_generic_args ())\n+    // check the type scope\n+    else if (resolver->lookup_resolved_type (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\t     &path_resolved_id))\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"path does not support substitutions\");\n-\treturn;\n+\trust_assert (path_resolved_id == resolved_node_id);\n       }\n-\n-    if (expr.is_self ())\n-      return;\n-\n-    if (infered->has_subsititions_defined ())\n+    else\n       {\n-\tif (!infered->can_substitute ())\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"substitutions not supported for %s\",\n-\t\t\t   infered->as_string ().c_str ());\n-\t    return;\n-\t  }\n-\n-\tinfered = SubstMapper::Resolve (infered, expr.get_locus (),\n-\t\t\t\t\tseg.has_generic_args ()\n-\t\t\t\t\t  ? &seg.get_generic_args ()\n-\t\t\t\t\t  : nullptr);\n+\tresolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t\tresolved_node_id);\n       }\n+\n+    infered = tyseg;\n   }\n \n   void visit (HIR::LoopExpr &expr) override\n@@ -951,6 +963,75 @@ class TypeCheckExpr : public TypeCheckBase\n       inside_loop (inside_loop)\n   {}\n \n+  TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr)\n+  {\n+    HIR::PathExprSegment &root = expr.get_root_seg ();\n+    NodeId ast_node_id = root.get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      {\n+\t// these ref_node_ids will resolve to a pattern declaration but we are\n+\t// interested in the definition that this refers to get the parent id\n+\tDefinition def;\n+\tif (!resolver->lookup_definition (ref_node_id, &def))\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"unknown reference for resolved name\");\n+\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  }\n+\tref_node_id = def.parent;\n+      }\n+    else\n+      {\n+\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n+      }\n+\n+    if (ref_node_id == UNKNOWN_NODEID)\n+      {\n+\trust_error_at (root.get_locus (),\n+\t\t       \"failed to type resolve root segment\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       ref_node_id, &ref))\n+      {\n+\trust_error_at (expr.get_locus (), \"reverse lookup failure\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    TyTy::BaseType *lookup = nullptr;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\trust_error_at (expr.get_locus (), \"failed to resolve root segment\");\n+\treturn new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+      }\n+\n+    // turbo-fish segment path::<ty>\n+    if (root.has_generic_args ())\n+      {\n+\tif (!lookup->can_substitute ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"substitutions not supported for %s\",\n+\t\t\t   lookup->as_string ().c_str ());\n+\t    return new TyTy::ErrorType (lookup->get_ref ());\n+\t  }\n+\tlookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n+\t\t\t\t       &root.get_generic_args ());\n+      }\n+    else if (lookup->needs_generic_substitutions ())\n+      {\n+\tlookup = SubstMapper::InferSubst (lookup, expr.get_locus ());\n+      }\n+\n+    return lookup;\n+  }\n+\n   bool\n   validate_arithmetic_type (TyTy::BaseType *type,\n \t\t\t    HIR::ArithmeticOrLogicalExpr::ExprType expr_type)"}, {"sha": "e52368a67657764bf6f5adeeeb9470e5b35d0c85", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -58,7 +58,7 @@ class TypeCheckStmt : public TypeCheckBase\n       {\n \tinit_expr_ty\n \t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), inside_loop);\n-\tif (init_expr_ty == nullptr)\n+\tif (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n \n \tinit_expr_ty = init_expr_ty->clone ();"}, {"sha": "8124f357e4b39779e9ec38a5435d1da8ef6ea6ea", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct-field.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct-field.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -41,8 +41,6 @@ class TypeCheckStructExpr : public TypeCheckBase\n \n   void visit (HIR::StructExprStructFields &struct_expr) override;\n \n-  void visit (HIR::PathInExpression &path) override;\n-\n   void visit (HIR::StructExprFieldIdentifierValue &field) override;\n \n   void visit (HIR::StructExprFieldIndexValue &field) override;"}, {"sha": "6f6ab9ca583c870ee1e7cb110ac6815c08b7de03", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 8, "deletions": 76, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -60,6 +60,7 @@ TypeResolution::Resolve (HIR::Crate &crate)\n     // nothing to do\n     if (ty->get_kind () != TyTy::TypeKind::INFER)\n       return true;\n+\n     TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n     TyTy::BaseType *default_type;\n     bool ok = infer_var->default_type (&default_type);\n@@ -72,6 +73,7 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \t\t\t\t UNKNOWN_LOCAL_DEFID),\n \t  result);\n       }\n+\n     return true;\n   });\n \n@@ -161,14 +163,16 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n void\n TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n {\n-  struct_expr.get_struct_name ().accept_vis (*this);\n-  if (struct_path_resolved == nullptr)\n+  TyTy::BaseType *struct_path_ty\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+  if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n     {\n-      rust_fatal_error (struct_expr.get_struct_name ().get_locus (),\n-\t\t\t\"Failed to resolve type\");\n+      rust_error_at (struct_expr.get_struct_name ().get_locus (),\n+\t\t     \"expected an ADT type for constructor\");\n       return;\n     }\n \n+  struct_path_resolved = static_cast<TyTy::ADTType *> (struct_path_ty);\n   TyTy::ADTType *struct_def = struct_path_resolved;\n   if (struct_expr.has_struct_base ())\n     {\n@@ -291,78 +295,6 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   resolved = struct_def;\n }\n \n-void\n-TypeCheckStructExpr::visit (HIR::PathInExpression &expr)\n-{\n-  NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-\n-  // then lookup the reference_node_id\n-  NodeId ref_node_id;\n-  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-    {\n-      if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-\t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"Failed to lookup reference for node: %s\",\n-\t\t\t expr.as_string ().c_str ());\n-\t  return;\n-\t}\n-    }\n-\n-  // node back to HIR\n-  HirId ref;\n-  if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t     ref_node_id, &ref))\n-    {\n-      rust_error_at (expr.get_locus (), \"reverse lookup failure\");\n-      return;\n-    }\n-\n-  // the base reference for this name _must_ have a type set\n-  TyTy::BaseType *lookup;\n-  if (!context->lookup_type (ref, &lookup))\n-    {\n-      rust_error_at (mappings->lookup_location (ref),\n-\t\t     \"consider giving this a type: %s\",\n-\t\t     expr.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (lookup->get_kind () != TyTy::TypeKind::ADT)\n-    {\n-      rust_fatal_error (mappings->lookup_location (ref),\n-\t\t\t\"expected an ADT type\");\n-      return;\n-    }\n-\n-  struct_path_resolved = static_cast<TyTy::ADTType *> (lookup);\n-  if (struct_path_resolved->has_substitutions ())\n-    {\n-      HIR::PathExprSegment seg = expr.get_final_segment ();\n-      if (!struct_path_resolved->needs_substitution ()\n-\t  && seg.has_generic_args ())\n-\t{\n-\t  rust_error_at (seg.get_generic_args ().get_locus (),\n-\t\t\t \"unexpected type arguments\");\n-\t}\n-      else if (struct_path_resolved->needs_substitution ())\n-\t{\n-\t  TyTy::BaseType *subst\n-\t    = SubstMapper::Resolve (struct_path_resolved, expr.get_locus (),\n-\t\t\t\t    seg.has_generic_args ()\n-\t\t\t\t      ? &seg.get_generic_args ()\n-\t\t\t\t      : nullptr);\n-\t  if (subst == nullptr || subst->get_kind () != TyTy::TypeKind::ADT)\n-\t    {\n-\t      rust_fatal_error (mappings->lookup_location (ref),\n-\t\t\t\t\"expected a substituted ADT type\");\n-\t      return;\n-\t    }\n-\t  struct_path_resolved = static_cast<TyTy::ADTType *> (subst);\n-\t}\n-    }\n-}\n-\n void\n TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n {"}, {"sha": "db43cbd3f351cd389d6e43eb182fd05289306965", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -37,6 +37,11 @@ class SubstMapper : public TyTy::TyVisitor\n     return mapper.resolved;\n   }\n \n+  static TyTy::BaseType *InferSubst (TyTy::BaseType *base, Location locus)\n+  {\n+    return SubstMapper::Resolve (base, locus, nullptr);\n+  }\n+\n   bool have_generic_args () const { return generics != nullptr; }\n \n   void visit (TyTy::FnType &type) override"}, {"sha": "03d6cee70071b4d15d077dfe68f09027741d4457", "filename": "gcc/testsuite/rust.test/compile/generics13.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics13.rs?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -0,0 +1,34 @@\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+struct GenericStruct<T> {\n+    a: T,\n+    b: usize,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 {\n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test();\n+\n+    let a2: GenericStruct<i8>;\n+    a2 = GenericStruct::<i8> { a: 1, b: 456 };\n+\n+    let b2: i8 = a2.a;\n+    let c2: usize = a2.b;\n+\n+    let a4;\n+    a4 = GenericStruct { a: 1.0, b: 456 };\n+\n+    let b4: f32 = a4.a;\n+    let c4: usize = a4.b;\n+}"}, {"sha": "bf00f72cec9c31f7940015896b29b02f18674928", "filename": "gcc/testsuite/rust.test/compile/generics14.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompile%2Fgenerics14.rs?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -0,0 +1,17 @@\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 {\n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test();\n+}"}, {"sha": "256d2aae22a0bdffc7c0e52b60f36db1e2b3d028", "filename": "gcc/testsuite/rust.test/xfail_compile/generics6.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fgenerics6.rs?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -0,0 +1,29 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<A> {\n+    a: A,\n+}\n+\n+impl Foo<isize> {\n+    fn test() -> i32 { // {dg-error \"possible candidate\" } \n+        123\n+    }\n+\n+    fn bar(self) -> isize {\n+        self.a\n+    }\n+}\n+\n+impl Foo<f32> {\n+    fn test() -> i32 { // {dg-error \"possible candidate\" }\n+        123\n+    }\n+\n+    fn bar(self) -> f32 {\n+        self.a\n+    }\n+}\n+\n+fn main() {\n+    let a: i32 = Foo::test(); // { dg-error \"multiple applicable items in scope for: test\" }\n+}\n+"}, {"sha": "3856b73310cfb598956958c3bb317853dd1e268a", "filename": "gcc/testsuite/rust.test/xfail_compile/redef_error6.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85f587410612c8d2ec65dd23063a849d13005957/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fxfail_compile%2Fredef_error6.rs?ref=85f587410612c8d2ec65dd23063a849d13005957", "patch": "@@ -0,0 +1,14 @@\n+// { dg-excess-errors \"Noisy error and debug\" }\n+struct Foo<T>(T, usize);\n+\n+impl Foo<i32> {\n+    fn test() -> i32 { // { dg-error \"was defined here\" }\n+        123\n+    }\n+\n+    fn test(self) -> i32 { // { dg-error \"redefined multiple times\" }\n+        self.0\n+    }\n+}\n+\n+fn main() {}"}]}