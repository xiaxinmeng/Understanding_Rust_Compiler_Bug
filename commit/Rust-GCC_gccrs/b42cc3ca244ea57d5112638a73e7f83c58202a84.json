{"sha": "b42cc3ca244ea57d5112638a73e7f83c58202a84", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQyY2MzY2EyNDRlYTU3ZDUxMTI2MzhhNzNlN2Y4M2M1ODIwMmE4NA==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2017-05-17T13:54:23Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2017-05-17T13:54:23Z"}, "message": "Implement new C++ intrinsics __is_assignable and __is_constructible.\n\nc-family/\n\nImplement new C++ intrinsics __is_assignable and __is_constructible.\n* c-common.c (__is_assignable, __is_constructible): New.\n* c-common.h (RID_IS_ASSIGNABLE, RID_IS_CONSTRUCTIBLE): Likewise.\n\ncp/\n\nPR c++/80654\nPR c++/80682\nImplement new C++ intrinsics __is_assignable and __is_constructible.\n* cp-tree.h (CPTK_IS_ASSIGNABLE, CPTK_IS_CONSTRUCTIBLE): New.\n(is_xible): New.\n* cxx-pretty-print.c (pp_cxx_trait_expression): Handle\nCPTK_IS_ASSIGNABLE and CPTK_IS_CONSTRUCTIBLE.\n* method.c (constructible_expr): Set cp_unevaluated.\n(is_xible_helper): New.\n(is_trivially_xible): Adjust.\n(is_xible): New.\n* parser.c (cp_parser_primary_expression): Handle\nRID_IS_ASSIGNABLE and RID_IS_CONSTRUCTIBLE.\n(cp_parser_trait_expr): Likewise.\n* semantics.c (trait_expr_value): Handle\nCPTK_IS_ASSIGNABLE and CPTK_IS_CONSTRUCTIBLE.\n\ntestsuite/\n\n* g++.dg/ext/80654.C: New.\n\nlibstdc++-v3/\n\nImplement new C++ intrinsics __is_assignable and __is_constructible.\n* include/std/type_traits (__do_is_static_castable_impl): Remove.\n(__is_static_castable_impl, __is_static_castable_safe): Likewise.\n(__is_static_castable, __do_is_direct_constructible_impl): Likewise.\n(__is_direct_constructible_impl): Likewise.\n(__is_direct_constructible_new_safe): Likewise.\n(__is_base_to_derived_ref, __is_lvalue_to_rvalue_ref): Likewise.\n(__is_direct_constructible_ref_cast): Likewise.\n(__is_direct_constructible_new, __is_direct_constructible): Likewise.\n(__do_is_nary_constructible_impl): Likewise.\n(__is_nary_constructible_impl, __is_nary_constructible): Likewise.\n(__is_constructible_impl): Likewise.\n(is_constructible): Call the intrinsic.\n(__is_assignable_helper): Remove.\n(is_assignable): Call the intrinsic.\n(is_trivially_constructible): Likewise.\n(__is_trivially_copy_constructible_impl): New.\n(is_trivially_copy_constructible): Use it.\n(__is_trivially_move_constructible_impl): New.\n(is_trivially_move_constructible): Use it.\n(is_trivially_assignable): Call the intrinsic.\n(__is_trivially_copy_assignable_impl): New.\n(is_trivially_copy_assignable): Use it.\n(__is_trivially_move_assignable_impl): New.\n(is_trivially_move_assignable): Use it.\n(testsuite/20_util/declval/requirements/1_neg.cc): Adjust.\n(testsuite/20_util/is_trivially_copy_assignable/value.cc):\nAdd test for void.\n(testsuite/20_util/is_trivially_copy_constructible/value.cc): Likewise.\n(testsuite/20_util/is_trivially_move_assignable/value.cc): Likewise.\n(testsuite/20_util/is_trivially_move_constructible/value.cc): Likewise.\n(testsuite/20_util/make_signed/requirements/typedefs_neg.cc): Adjust.\n(testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc):\nLikewise.\n\nFrom-SVN: r248153", "tree": {"sha": "5dba2cc1db7a08d1f9a5a4c2c53436d4d65bed2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dba2cc1db7a08d1f9a5a4c2c53436d4d65bed2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b42cc3ca244ea57d5112638a73e7f83c58202a84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b42cc3ca244ea57d5112638a73e7f83c58202a84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b42cc3ca244ea57d5112638a73e7f83c58202a84", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b42cc3ca244ea57d5112638a73e7f83c58202a84/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36f4bc9ce82363820ce3aac4bb3f7fbfdeef1663"}], "stats": {"total": 462, "additions": 220, "deletions": 242}, "files": [{"sha": "428d733da1a318d9b502f081d350df36512da2f6", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -1,3 +1,9 @@\n+2017-05-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement new C++ intrinsics __is_assignable and __is_constructible.\n+\t* c-common.c (__is_assignable, __is_constructible): New.\n+\t* c-common.h (RID_IS_ASSIGNABLE, RID_IS_CONSTRUCTIBLE): Likewise.\n+\n 2017-05-17  Martin Liska  <mliska@suse.cz>\n \n \t* c-common.h: Introduce dump_flags_t type and"}, {"sha": "a3c63d74d00f2cd219f74b10922c80f1c17f148d", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -514,6 +514,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"volatile\",\t\tRID_VOLATILE,\t0 },\n   { \"wchar_t\",\t\tRID_WCHAR,\tD_CXXONLY },\n   { \"while\",\t\tRID_WHILE,\t0 },\n+  { \"__is_assignable\", RID_IS_ASSIGNABLE, D_CXXONLY },\n+  { \"__is_constructible\", RID_IS_CONSTRUCTIBLE, D_CXXONLY },\n \n   /* C++ transactional memory.  */\n   { \"synchronized\",\tRID_SYNCHRONIZED, D_CXX_OBJC | D_TRANSMEM },"}, {"sha": "3023b07af67349d1e3e647c15d356d14df44f80c", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -172,6 +172,7 @@ enum rid\n   RID_IS_TRIVIALLY_ASSIGNABLE, RID_IS_TRIVIALLY_CONSTRUCTIBLE,\n   RID_IS_TRIVIALLY_COPYABLE,\n   RID_IS_UNION,                RID_UNDERLYING_TYPE,\n+  RID_IS_ASSIGNABLE,           RID_IS_CONSTRUCTIBLE,\n \n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,"}, {"sha": "f657194f419e637c4e3961f9ef853181c160e836", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -1,3 +1,22 @@\n+2017-05-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tPR c++/80654\n+\tPR c++/80682\n+\tImplement new C++ intrinsics __is_assignable and __is_constructible.\n+\t* cp-tree.h (CPTK_IS_ASSIGNABLE, CPTK_IS_CONSTRUCTIBLE): New.\n+\t(is_xible): New.\n+\t* cxx-pretty-print.c (pp_cxx_trait_expression): Handle\n+\tCPTK_IS_ASSIGNABLE and CPTK_IS_CONSTRUCTIBLE.\n+\t* method.c (constructible_expr): Set cp_unevaluated.\n+\t(is_xible_helper): New.\n+\t(is_trivially_xible): Adjust.\n+\t(is_xible): New.\n+\t* parser.c (cp_parser_primary_expression): Handle\n+\tRID_IS_ASSIGNABLE and RID_IS_CONSTRUCTIBLE.\n+\t(cp_parser_trait_expr): Likewise.\n+\t* semantics.c (trait_expr_value): Handle\n+\tCPTK_IS_ASSIGNABLE and CPTK_IS_CONSTRUCTIBLE.\n+\n 2017-05-17  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-tree.h (ovl_iterator::using_p): New predicate."}, {"sha": "921118635a68243009f069ef0297eb531c9b05f9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -1016,7 +1016,9 @@ enum cp_trait_kind\n   CPTK_IS_TRIVIALLY_CONSTRUCTIBLE,\n   CPTK_IS_TRIVIALLY_COPYABLE,\n   CPTK_IS_UNION,\n-  CPTK_UNDERLYING_TYPE\n+  CPTK_UNDERLYING_TYPE,\n+  CPTK_IS_ASSIGNABLE,\n+  CPTK_IS_CONSTRUCTIBLE\n };\n \n /* The types that we are processing.  */\n@@ -6227,6 +6229,7 @@ extern void use_thunk\t\t\t\t(tree, bool);\n extern bool trivial_fn_p\t\t\t(tree);\n extern tree forward_parm\t\t\t(tree);\n extern bool is_trivially_xible\t\t\t(enum tree_code, tree, tree);\n+extern bool is_xible\t\t\t\t(enum tree_code, tree, tree);\n extern tree get_defaulted_eh_spec\t\t(tree);\n extern tree unevaluated_noexcept_spec\t\t(void);\n extern void after_nsdmi_defaulted_late_checks   (tree);"}, {"sha": "b74a56f42000ef474d4c37b28718ba88c5ec44df", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -2634,6 +2634,12 @@ pp_cxx_trait_expression (cxx_pretty_printer *pp, tree t)\n     case CPTK_IS_LITERAL_TYPE:\n       pp_cxx_ws_string (pp, \"__is_literal_type\");\n       break;\n+    case CPTK_IS_ASSIGNABLE:\n+      pp_cxx_ws_string (pp, \"__is_assignable\");\n+      break;\n+    case CPTK_IS_CONSTRUCTIBLE:\n+      pp_cxx_ws_string (pp, \"__is_constructible\");\n+      break;\n \n     default:\n       gcc_unreachable ();"}, {"sha": "756b59dc354b0b7a044635fee6218903f7c713ee", "filename": "gcc/cp/method.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -1162,6 +1162,7 @@ constructible_expr (tree to, tree from)\n     {\n       tree ctype = to;\n       vec<tree, va_gc> *args = NULL;\n+      cp_unevaluated cp_uneval_guard;\n       if (TREE_CODE (to) != REFERENCE_TYPE)\n \tto = cp_build_reference_type (to, /*rval*/false);\n       tree ob = build_stub_object (to);\n@@ -1198,29 +1199,56 @@ constructible_expr (tree to, tree from)\n   return expr;\n }\n \n-/* Returns true iff TO is trivially assignable (if CODE is MODIFY_EXPR) or\n+/* Returns a tree iff TO is assignable (if CODE is MODIFY_EXPR) or\n    constructible (otherwise) from FROM, which is a single type for\n    assignment or a list of types for construction.  */\n \n-bool\n-is_trivially_xible (enum tree_code code, tree to, tree from)\n+static tree\n+is_xible_helper (enum tree_code code, tree to, tree from, bool trivial)\n {\n-  if (VOID_TYPE_P (to))\n-    return false;\n+  if (VOID_TYPE_P (to) || ABSTRACT_CLASS_TYPE_P (to)\n+      || (from && FUNC_OR_METHOD_TYPE_P (from)\n+\t  && (TYPE_READONLY (from) || FUNCTION_REF_QUALIFIED (from))))\n+    return error_mark_node;\n   tree expr;\n   if (code == MODIFY_EXPR)\n     expr = assignable_expr (to, from);\n-  else if (from && TREE_CHAIN (from))\n-    return false; // only 0- and 1-argument ctors can be trivial\n+  else if (trivial && from && TREE_CHAIN (from))\n+    return error_mark_node; // only 0- and 1-argument ctors can be trivial\n   else\n     expr = constructible_expr (to, from);\n+  return expr;\n+}\n+\n+/* Returns true iff TO is trivially assignable (if CODE is MODIFY_EXPR) or\n+   constructible (otherwise) from FROM, which is a single type for\n+   assignment or a list of types for construction.  */\n+\n+bool\n+is_trivially_xible (enum tree_code code, tree to, tree from)\n+{\n+  tree expr;\n+  expr = is_xible_helper (code, to, from, /*trivial*/true);\n \n   if (expr == error_mark_node)\n     return false;\n   tree nt = cp_walk_tree_without_duplicates (&expr, check_nontriv, NULL);\n   return !nt;\n }\n \n+/* Returns true iff TO is assignable (if CODE is MODIFY_EXPR) or\n+   constructible (otherwise) from FROM, which is a single type for\n+   assignment or a list of types for construction.  */\n+\n+bool\n+is_xible (enum tree_code code, tree to, tree from)\n+{\n+  tree expr = is_xible_helper (code, to, from, /*trivial*/false);\n+  if (expr == error_mark_node)\n+    return false;\n+  return !!expr;\n+}\n+\n /* Subroutine of synthesized_method_walk.  Update SPEC_P, TRIVIAL_P and\n    DELETED_P or give an error message MSG with argument ARG.  */\n "}, {"sha": "7a87a5e623d55eecbb7c371fdf0d8f0736945531", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -5135,6 +5135,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_TRIVIALLY_CONSTRUCTIBLE:\n \tcase RID_IS_TRIVIALLY_COPYABLE:\n \tcase RID_IS_UNION:\n+\tcase RID_IS_ASSIGNABLE:\n+\tcase RID_IS_CONSTRUCTIBLE:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n \t// C++ concepts\n@@ -9686,6 +9688,14 @@ cp_parser_trait_expr (cp_parser* parser, enum rid keyword)\n     case RID_DIRECT_BASES:\n       kind = CPTK_DIRECT_BASES;\n       break;\n+    case RID_IS_ASSIGNABLE:\n+      kind = CPTK_IS_ASSIGNABLE;\n+      binary = true;\n+      break;\n+    case RID_IS_CONSTRUCTIBLE:\n+      kind = CPTK_IS_CONSTRUCTIBLE;\n+      variadic = true;\n+      break;\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "fa02b27145ac14b2d6c17c807d42e972a7621f32", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -9211,6 +9211,12 @@ trait_expr_value (cp_trait_kind kind, tree type1, tree type2)\n     case CPTK_IS_UNION:\n       return type_code1 == UNION_TYPE;\n \n+    case CPTK_IS_ASSIGNABLE:\n+      return is_xible (MODIFY_EXPR, type1, type2);\n+\n+    case CPTK_IS_CONSTRUCTIBLE:\n+      return is_xible (INIT_EXPR, type1, type2);\n+\n     default:\n       gcc_unreachable ();\n       return false;\n@@ -9284,6 +9290,10 @@ finish_trait_expr (cp_trait_kind kind, tree type1, tree type2)\n \treturn error_mark_node;\n       break;\n \n+    case CPTK_IS_ASSIGNABLE:\n+    case CPTK_IS_CONSTRUCTIBLE:\n+      break;\n+\n     case CPTK_IS_TRIVIALLY_ASSIGNABLE:\n     case CPTK_IS_TRIVIALLY_CONSTRUCTIBLE:\n       if (!check_trait_type (type1)"}, {"sha": "8679613e966d14a150ff8aabc8debfcbc0234d95", "filename": "gcc/testsuite/g++.dg/ext/80654.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2F80654.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2F80654.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2F80654.C?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -0,0 +1,18 @@\n+// { dg-do compile { target c++11 } }\n+\n+template <class T> struct wrap \n+{\n+  T t;\n+  wrap(const wrap& other) : t(other.t) {}\n+};\n+\n+struct nocopy {\n+  nocopy (const nocopy&) = delete;\n+};\n+\n+int main ()\n+{\n+  static_assert(!__is_trivially_constructible(wrap<nocopy>,\n+\t\t\t\t\t      const wrap<nocopy>&), \"\");\n+  return 0;\n+}"}, {"sha": "98d363acc2e1202fe6d9fa8eb871ac72573c5d5c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -1,3 +1,40 @@\n+2017-05-17  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement new C++ intrinsics __is_assignable and __is_constructible.\n+\t* include/std/type_traits (__do_is_static_castable_impl): Remove.\n+\t(__is_static_castable_impl, __is_static_castable_safe): Likewise.\n+\t(__is_static_castable, __do_is_direct_constructible_impl): Likewise.\n+\t(__is_direct_constructible_impl): Likewise.\n+\t(__is_direct_constructible_new_safe): Likewise.\n+\t(__is_base_to_derived_ref, __is_lvalue_to_rvalue_ref): Likewise.\n+\t(__is_direct_constructible_ref_cast): Likewise.\n+\t(__is_direct_constructible_new, __is_direct_constructible): Likewise.\n+\t(__do_is_nary_constructible_impl): Likewise.\n+\t(__is_nary_constructible_impl, __is_nary_constructible): Likewise.\n+\t(__is_constructible_impl): Likewise.\n+\t(is_constructible): Call the intrinsic.\n+\t(__is_assignable_helper): Remove.\n+\t(is_assignable): Call the intrinsic.\n+\t(is_trivially_constructible): Likewise.\n+\t(__is_trivially_copy_constructible_impl): New.\n+\t(is_trivially_copy_constructible): Use it.\n+\t(__is_trivially_move_constructible_impl): New.\n+\t(is_trivially_move_constructible): Use it.\n+\t(is_trivially_assignable): Call the intrinsic.\n+\t(__is_trivially_copy_assignable_impl): New.\n+\t(is_trivially_copy_assignable): Use it.\n+\t(__is_trivially_move_assignable_impl): New.\n+\t(is_trivially_move_assignable): Use it.\n+\t(testsuite/20_util/declval/requirements/1_neg.cc): Adjust.\n+\t(testsuite/20_util/is_trivially_copy_assignable/value.cc):\n+\tAdd test for void.\n+\t(testsuite/20_util/is_trivially_copy_constructible/value.cc): Likewise.\n+\t(testsuite/20_util/is_trivially_move_assignable/value.cc): Likewise.\n+\t(testsuite/20_util/is_trivially_move_constructible/value.cc): Likewise.\n+\t(testsuite/20_util/make_signed/requirements/typedefs_neg.cc): Adjust.\n+\t(testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc):\n+\tLikewise.\n+\n 2017-05-16  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/experimental/source_location/1.cc: Change expected result"}, {"sha": "390b6f40af501add678168b64804806c97b28b39", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 60, "deletions": 230, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -924,213 +924,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __is_default_constructible_safe<_Tp>::type\n     { };\n \n-\n-  // Implementation of is_constructible.\n-\n-  // The hardest part of this trait is the binary direct-initialization\n-  // case, because we hit into a functional cast of the form T(arg).\n-  // This implementation uses different strategies depending on the\n-  // target type to reduce the test overhead as much as possible:\n-  //\n-  // a) For a reference target type, we use a static_cast expression\n-  //    modulo its extra cases.\n-  //\n-  // b) For a non-reference target type we use a ::new expression.\n-  struct __do_is_static_castable_impl\n-  {\n-    template<typename _From, typename _To, typename\n-             = decltype(static_cast<_To>(declval<_From>()))>\n-      static true_type __test(int);\n-\n-    template<typename, typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _From, typename _To>\n-    struct __is_static_castable_impl\n-    : public __do_is_static_castable_impl\n-    {\n-      typedef decltype(__test<_From, _To>(0)) type;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_static_castable_safe\n-    : public __is_static_castable_impl<_From, _To>::type\n-    { };\n-\n-  // __is_static_castable\n-  template<typename _From, typename _To>\n-    struct __is_static_castable\n-    : public integral_constant<bool, (__is_static_castable_safe<\n-\t\t\t\t      _From, _To>::value)>\n-    { };\n-\n-  // Implementation for non-reference types. To meet the proper\n-  // variable definition semantics, we also need to test for\n-  // is_destructible in this case.\n-  // This form should be simplified by a single expression:\n-  // ::delete ::new _Tp(declval<_Arg>()), see c++/51222.\n-  struct __do_is_direct_constructible_impl\n-  {\n-    template<typename _Tp, typename _Arg, typename\n-\t     = decltype(::new _Tp(declval<_Arg>()))>\n-      static true_type __test(int);\n-\n-    template<typename, typename>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_impl\n-    : public __do_is_direct_constructible_impl\n-    {\n-      typedef decltype(__test<_Tp, _Arg>(0)) type;\n-    };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_new_safe\n-    : public __and_<is_destructible<_Tp>,\n-                    __is_direct_constructible_impl<_Tp, _Arg>>\n-    { };\n-\n-  template<typename, typename>\n-    struct is_same;\n-\n-  template<typename, typename>\n-    struct is_base_of;\n-\n-  template<typename>\n-    struct remove_reference;\n-\n-  template<typename _From, typename _To, bool\n-           = __not_<__or_<is_void<_From>,\n-                          is_function<_From>>>::value>\n-    struct __is_base_to_derived_ref;\n-\n-  template<typename _Tp, typename... _Args>\n-    struct is_constructible;\n-\n-  // Detect whether we have a downcast situation during\n-  // reference binding.\n-  template<typename _From, typename _To>\n-    struct __is_base_to_derived_ref<_From, _To, true>\n-    {\n-      typedef typename remove_cv<typename remove_reference<_From\n-        >::type>::type __src_t;\n-      typedef typename remove_cv<typename remove_reference<_To\n-        >::type>::type __dst_t;\n-      typedef __and_<__not_<is_same<__src_t, __dst_t>>,\n-\t\t     is_base_of<__src_t, __dst_t>,\n-\t\t     __not_<is_constructible<__dst_t, _From>>> type;\n-      static constexpr bool value = type::value;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_base_to_derived_ref<_From, _To, false>\n-    : public false_type\n-    { };\n-\n-  template<typename _From, typename _To, bool\n-           = __and_<is_lvalue_reference<_From>,\n-                    is_rvalue_reference<_To>>::value>\n-    struct __is_lvalue_to_rvalue_ref;\n-\n-  // Detect whether we have an lvalue of non-function type\n-  // bound to a reference-compatible rvalue-reference.\n-  template<typename _From, typename _To>\n-    struct __is_lvalue_to_rvalue_ref<_From, _To, true>\n-    {\n-      typedef typename remove_cv<typename remove_reference<\n-        _From>::type>::type __src_t;\n-      typedef typename remove_cv<typename remove_reference<\n-        _To>::type>::type __dst_t;\n-      typedef __and_<__not_<is_function<__src_t>>,\n-        __or_<is_same<__src_t, __dst_t>,\n-\t\t    is_base_of<__dst_t, __src_t>>> type;\n-      static constexpr bool value = type::value;\n-    };\n-\n-  template<typename _From, typename _To>\n-    struct __is_lvalue_to_rvalue_ref<_From, _To, false>\n-    : public false_type\n-    { };\n-\n-  // Here we handle direct-initialization to a reference type as\n-  // equivalent to a static_cast modulo overshooting conversions.\n-  // These are restricted to the following conversions:\n-  //    a) A base class value to a derived class reference\n-  //    b) An lvalue to an rvalue-reference of reference-compatible\n-  //       types that are not functions\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_ref_cast\n-    : public __and_<__is_static_castable<_Arg, _Tp>,\n-                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,\n-                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>\n-                   >>>\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible_new\n-    : public conditional<is_reference<_Tp>::value,\n-\t\t\t __is_direct_constructible_ref_cast<_Tp, _Arg>,\n-\t\t\t __is_direct_constructible_new_safe<_Tp, _Arg>\n-\t\t\t >::type\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_direct_constructible\n-    : public __is_direct_constructible_new<_Tp, _Arg>::type\n-    { };\n-\n-  // Since default-construction and binary direct-initialization have\n-  // been handled separately, the implementation of the remaining\n-  // n-ary construction cases is rather straightforward. We can use\n-  // here a functional cast, because array types are excluded anyway\n-  // and this form is never interpreted as a C cast.\n-  struct __do_is_nary_constructible_impl\n-  {\n-    template<typename _Tp, typename... _Args, typename\n-             = decltype(_Tp(declval<_Args>()...))>\n-      static true_type __test(int);\n-\n-    template<typename, typename...>\n-      static false_type __test(...);\n-  };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_nary_constructible_impl\n-    : public __do_is_nary_constructible_impl\n-    {\n-      typedef decltype(__test<_Tp, _Args...>(0)) type;\n-    };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_nary_constructible\n-    : public __is_nary_constructible_impl<_Tp, _Args...>::type\n-    {\n-      static_assert(sizeof...(_Args) > 1,\n-                    \"Only useful for > 1 arguments\");\n-    };\n-\n-  template<typename _Tp, typename... _Args>\n-    struct __is_constructible_impl\n-    : public __is_nary_constructible<_Tp, _Args...>\n-    { };\n-\n-  template<typename _Tp, typename _Arg>\n-    struct __is_constructible_impl<_Tp, _Arg>\n-    : public __is_direct_constructible<_Tp, _Arg>\n-    { };\n-\n-  template<typename _Tp>\n-    struct __is_constructible_impl<_Tp>\n-    : public is_default_constructible<_Tp>\n-    { };\n-\n   /// is_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_constructible\n-    : public __is_constructible_impl<_Tp, _Args...>::type\n+      : public __bool_constant<__is_constructible(_Tp, _Args...)>\n     { };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n@@ -1255,26 +1052,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public __is_nothrow_move_constructible_impl<_Tp>\n     { };\n \n-  template<typename _Tp, typename _Up>\n-    class __is_assignable_helper\n-    {\n-      template<typename _Tp1, typename _Up1,\n-\t       typename = decltype(declval<_Tp1>() = declval<_Up1>())>\n-\tstatic true_type\n-\t__test(int);\n-\n-      template<typename, typename>\n-\tstatic false_type\n-\t__test(...);\n-\n-    public:\n-      typedef decltype(__test<_Tp, _Up>(0)) type;\n-    };\n-\n   /// is_assignable\n   template<typename _Tp, typename _Up>\n     struct is_assignable\n-      : public __is_assignable_helper<_Tp, _Up>::type\n+      : public __bool_constant<__is_assignable(_Tp, _Up)>\n     { };\n \n   template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n@@ -1364,8 +1145,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// is_trivially_constructible\n   template<typename _Tp, typename... _Args>\n     struct is_trivially_constructible\n-    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,\n-\t\t\t__is_trivially_constructible(_Tp, _Args...)>>\n+    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>\n     { };\n \n   /// is_trivially_default_constructible\n@@ -1405,45 +1185,95 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   { };\n \n   /// is_trivially_copy_constructible\n+\n+  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+    struct __is_trivially_copy_constructible_impl;\n+\n   template<typename _Tp>\n-    struct is_trivially_copy_constructible\n+    struct __is_trivially_copy_constructible_impl<_Tp, false>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_trivially_copy_constructible_impl<_Tp, true>\n     : public __and_<is_copy_constructible<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_constructible(_Tp, const _Tp&)>>\n     { };\n \n+  template<typename _Tp>\n+    struct is_trivially_copy_constructible\n+    : public __is_trivially_copy_constructible_impl<_Tp>\n+    { };\n+\n   /// is_trivially_move_constructible\n+\n+  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+    struct __is_trivially_move_constructible_impl;\n+\n   template<typename _Tp>\n-    struct is_trivially_move_constructible\n+    struct __is_trivially_move_constructible_impl<_Tp, false>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_trivially_move_constructible_impl<_Tp, true>\n     : public __and_<is_move_constructible<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_constructible(_Tp, _Tp&&)>>\n     { };\n \n+  template<typename _Tp>\n+    struct is_trivially_move_constructible\n+    : public __is_trivially_move_constructible_impl<_Tp>\n+    { };\n+\n   /// is_trivially_assignable\n   template<typename _Tp, typename _Up>\n     struct is_trivially_assignable\n-    : public __and_<is_assignable<_Tp, _Up>,\n-\t\t    integral_constant<bool,\n-\t\t\t__is_trivially_assignable(_Tp, _Up)>>\n+    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>\n     { };\n \n   /// is_trivially_copy_assignable\n+\n+  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+    struct __is_trivially_copy_assignable_impl;\n+\n   template<typename _Tp>\n-    struct is_trivially_copy_assignable\n+    struct __is_trivially_copy_assignable_impl<_Tp, false>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_trivially_copy_assignable_impl<_Tp, true>\n     : public __and_<is_copy_assignable<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_assignable(_Tp&, const _Tp&)>>\n     { };\n \n+  template<typename _Tp>\n+    struct is_trivially_copy_assignable\n+    : public __is_trivially_copy_assignable_impl<_Tp>\n+    { };\n+\n   /// is_trivially_move_assignable\n+\n+  template<typename _Tp, bool = __is_referenceable<_Tp>::value>\n+    struct __is_trivially_move_assignable_impl;\n+\n   template<typename _Tp>\n-    struct is_trivially_move_assignable\n+    struct __is_trivially_move_assignable_impl<_Tp, false>\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct __is_trivially_move_assignable_impl<_Tp, true>\n     : public __and_<is_move_assignable<_Tp>,\n \t\t    integral_constant<bool,\n \t\t\t__is_trivially_assignable(_Tp&, _Tp&&)>>\n     { };\n \n+  template<typename _Tp>\n+    struct is_trivially_move_assignable\n+    : public __is_trivially_move_assignable_impl<_Tp>\n+    { };\n+\n   /// is_trivially_destructible\n   template<typename _Tp>\n     struct is_trivially_destructible"}, {"sha": "4e254e8919158b84d41d1ef7fbfb42c82cafebf0", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -18,7 +18,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 2259 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 2089 }\n \n #include <utility>\n "}, {"sha": "902aa5e59322605b4e977e4d7cf13ee19928c73f", "filename": "libstdc++-v3/testsuite/20_util/is_trivially_copy_assignable/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_assignable%2Fvalue.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -88,4 +88,6 @@ void test01()\n \t\tMoveOnly>(false), \"\");\n   static_assert(test_property<is_trivially_copy_assignable, \n \t\tMoveOnly2>(false), \"\");\n+  static_assert(test_property<is_trivially_copy_assignable,\n+\t\tvoid>(false), \"\");\n }"}, {"sha": "627410bdc3093f3e8c973f48c7ed00ffcf33ee52", "filename": "libstdc++-v3/testsuite/20_util/is_trivially_copy_constructible/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_constructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_constructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_copy_constructible%2Fvalue.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -82,4 +82,6 @@ void test01()\n \t\tMoveOnly>(false), \"\");\n   static_assert(test_property<is_trivially_copy_constructible, \n \t\tMoveOnly2>(false), \"\");\n+  static_assert(test_property<is_trivially_copy_constructible,\n+\t\tvoid>(false), \"\");\n }"}, {"sha": "221048347a2218efb0708a7be8379f85a068c9f8", "filename": "libstdc++-v3/testsuite/20_util/is_trivially_move_assignable/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_assignable%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_assignable%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_assignable%2Fvalue.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -88,4 +88,6 @@ void test01()\n \t\tMoveOnly>(true), \"\");\n   static_assert(test_property<is_trivially_move_assignable, \n \t\tMoveOnly2>(false), \"\");\n+  static_assert(test_property<is_trivially_move_assignable, \n+\t\tvoid>(false), \"\");\n }"}, {"sha": "9a21b6e2133d7ac18b0e83390798a5d02d65e0e2", "filename": "libstdc++-v3/testsuite/20_util/is_trivially_move_constructible/value.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_constructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_constructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_trivially_move_constructible%2Fvalue.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -82,4 +82,6 @@ void test01()\n \t\tMoveOnly>(true), \"\");\n   static_assert(test_property<is_trivially_move_constructible, \n \t\tMoveOnly2>(false), \"\");\n+  static_assert(test_property<is_trivially_move_constructible,\n+\t\tvoid>(false), \"\");\n }"}, {"sha": "e3e80f919799e8ff106a8bb92561744b74f5b2d5", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -47,4 +47,4 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 39 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1924 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1754 }"}, {"sha": "86b0c2d6da717998c65516d6e39d906b6c05d581", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b42cc3ca244ea57d5112638a73e7f83c58202a84/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=b42cc3ca244ea57d5112638a73e7f83c58202a84", "patch": "@@ -47,5 +47,5 @@ void test01()\n // { dg-error \"required from here\" \"\" { target *-*-* } 39 }\n // { dg-error \"required from here\" \"\" { target *-*-* } 41 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1820 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1777 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1650 }\n+"}]}