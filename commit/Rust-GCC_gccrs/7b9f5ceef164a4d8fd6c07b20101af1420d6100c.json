{"sha": "7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2I5ZjVjZWVmMTY0YTRkOGZkNmMwN2IyMDEwMWFmMTQyMGQ2MTAwYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-14T23:16:04Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-11-14T23:16:04Z"}, "message": "runtime: don't crash if signal handler info argument is nil\n    \n    Apparently on Solaris 10 a SA_SIGINFO signal handler can be invoked with\n    a nil info argument.  I would not have believed it but I've now seen it\n    happen, and the sigaction man page actually says \"If the second argument\n    is not equal to NULL, it points to a siginfo_t structure....\"  So, if\n    that happens, don't crash.\n    \n    Also fix another case where we want to make sure that &T{} does not\n    allocate.\n    \n    Reviewed-on: https://go-review.googlesource.com/33150\n\nFrom-SVN: r242403", "tree": {"sha": "b5ec8e784225739b75eaacc89ac8e28611847abf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5ec8e784225739b75eaacc89ac8e28611847abf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/comments", "author": null, "committer": null, "parents": [{"sha": "6964bb3ed962554b18ca92633b5395f91f9bebac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6964bb3ed962554b18ca92633b5395f91f9bebac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6964bb3ed962554b18ca92633b5395f91f9bebac"}], "stats": {"total": 20, "additions": 16, "deletions": 4}, "files": [{"sha": "1fe9decbd3d881f50c55d0f849d3080444af58e7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "patch": "@@ -1,4 +1,4 @@\n-3c8d91cff0ad3d233ebd268f88a3749d38a0aac1\n+eb716b515356166d3177e6244619be5901f31162\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "321c6197889729054a6584dbb77d9b526fdcb852", "filename": "libgo/go/runtime/signal_gccgo.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_gccgo.go?ref=7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "patch": "@@ -47,7 +47,14 @@ type sigctxt struct {\n \tctxt unsafe.Pointer\n }\n \n-func (c *sigctxt) sigcode() uint64 { return uint64(c.info.si_code) }\n+func (c *sigctxt) sigcode() uint64 {\n+\tif c.info == nil {\n+\t\t// This can happen on Solaris 10.  We don't know the\n+\t\t// code, just avoid a misleading value.\n+\t\treturn _SI_USER + 1\n+\t}\n+\treturn uint64(c.info.si_code)\n+}\n \n //go:nosplit\n func sigblock() {"}, {"sha": "667d5feed983b163e18e16c6df6b7ba7a3361aa6", "filename": "libgo/go/runtime/signal_sigtramp.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fsignal_sigtramp.go?ref=7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "patch": "@@ -29,7 +29,8 @@ func sigtrampgo(sig uint32, info *_siginfo_t, ctx unsafe.Pointer) {\n \t\t\t// get here anyhow.\n \t\t\treturn\n \t\t}\n-\t\tbadsignal(uintptr(sig), &sigctxt{info, ctx})\n+\t\tc := sigctxt{info, ctx}\n+\t\tbadsignal(uintptr(sig), &c)\n \t\treturn\n \t}\n "}, {"sha": "b844dc59b7cd0085abd7eb87c8e040fd6a743ebb", "filename": "libgo/runtime/go-signal.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fruntime%2Fgo-signal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b9f5ceef164a4d8fd6c07b20101af1420d6100c/libgo%2Fruntime%2Fgo-signal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-signal.c?ref=7b9f5ceef164a4d8fd6c07b20101af1420d6100c", "patch": "@@ -187,7 +187,11 @@ getSiginfo(siginfo_t *info, void *context __attribute__((unused)))\n \tLocation loc[1];\n \tint32 n;\n \n-\tret.sigaddr = (uintptr)(info->si_addr);\n+\tif (info == nil) {\n+\t\tret.sigaddr = 0;\n+\t} else {\n+\t\tret.sigaddr = (uintptr)(info->si_addr);\n+\t}\n \tret.sigpc = 0;\n \n \t// There doesn't seem to be a portable way to get the PC."}]}