{"sha": "94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlZGM0YWJkYzFkZThkMGM3NzQyMTM1NGVhYmYzYmZjM2RlMGM5MQ==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-01-23T02:47:51Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-01-23T02:47:51Z"}, "message": "class.c, parser.c: ANSIfy function definitions and declarations.\n\n2003-01-22  Nathanael Nerode  <neroden@gcc.gnu.org>\n\n\t* class.c, parser.c: ANSIfy function definitions and declarations.\n\nFrom-SVN: r61641", "tree": {"sha": "1fbb9cd69d25af595c0878534a27012452ba2185", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fbb9cd69d25af595c0878534a27012452ba2185"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/comments", "author": null, "committer": null, "parents": [{"sha": "850ccfaeaacb41b54c5896b72ed696cd0094a1c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850ccfaeaacb41b54c5896b72ed696cd0094a1c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/850ccfaeaacb41b54c5896b72ed696cd0094a1c1"}], "stats": {"total": 1833, "additions": 704, "deletions": 1129}, "files": [{"sha": "367111942b4d200b51b60ed678bd14bf7f665573", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "patch": "@@ -1,3 +1,7 @@\n+2003-01-22  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* class.c, parser.c: ANSIfy function definitions and declarations.\n+\n 2003-01-22  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/9328"}, {"sha": "efc86e107088699176d0100ae8c3114a58efa03c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 283, "deletions": 491, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "patch": "@@ -94,7 +94,7 @@ typedef struct vtbl_init_data_s\n } vtbl_init_data;\n \n /* The type of a function passed to walk_subobject_offsets.  */\n-typedef int (*subobject_offset_fn) PARAMS ((tree, tree, splay_tree));\n+typedef int (*subobject_offset_fn) (tree, tree, splay_tree);\n \n /* The stack itself.  This is a dynamically resized array.  The\n    number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */\n@@ -105,112 +105,112 @@ static class_stack_node_t current_class_stack;\n    declaration order.  */\n varray_type local_classes;\n \n-static tree get_vfield_name PARAMS ((tree));\n-static void finish_struct_anon PARAMS ((tree));\n-static tree get_vtable_name PARAMS ((tree));\n-static tree get_basefndecls PARAMS ((tree, tree));\n-static int build_primary_vtable PARAMS ((tree, tree));\n-static int build_secondary_vtable PARAMS ((tree, tree));\n-static void finish_vtbls PARAMS ((tree));\n-static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n-static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n-static void delete_duplicate_fields PARAMS ((tree));\n-static void finish_struct_bits PARAMS ((tree));\n-static int alter_access PARAMS ((tree, tree, tree));\n-static void handle_using_decl PARAMS ((tree, tree));\n-static void check_for_override PARAMS ((tree, tree));\n-static tree dfs_modify_vtables PARAMS ((tree, void *));\n-static tree modify_all_vtables PARAMS ((tree, tree));\n-static void determine_primary_base PARAMS ((tree));\n-static void finish_struct_methods PARAMS ((tree));\n-static void maybe_warn_about_overly_private_class PARAMS ((tree));\n-static int field_decl_cmp PARAMS ((const void *, const void *));\n-static int resort_field_decl_cmp PARAMS ((const void *, const void *));\n-static int method_name_cmp PARAMS ((const void *, const void *));\n-static int resort_method_name_cmp PARAMS ((const void *, const void *));\n-static void add_implicitly_declared_members PARAMS ((tree, int, int, int));\n-static tree fixed_type_or_null PARAMS ((tree, int *, int *));\n-static tree resolve_address_of_overloaded_function PARAMS ((tree, tree, int,\n-\t\t\t\t\t\t\t  int, int, tree));\n-static tree build_vtable_entry_ref PARAMS ((tree, tree, tree));\n-static tree build_vtbl_ref_1 PARAMS ((tree, tree));\n-static tree build_vtbl_initializer PARAMS ((tree, tree, tree, tree, int *));\n-static int count_fields PARAMS ((tree));\n-static int add_fields_to_vec PARAMS ((tree, tree, int));\n-static void check_bitfield_decl PARAMS ((tree));\n+static tree get_vfield_name (tree);\n+static void finish_struct_anon (tree);\n+static tree get_vtable_name (tree);\n+static tree get_basefndecls (tree, tree);\n+static int build_primary_vtable (tree, tree);\n+static int build_secondary_vtable (tree, tree);\n+static void finish_vtbls (tree);\n+static void modify_vtable_entry (tree, tree, tree, tree, tree *);\n+static tree delete_duplicate_fields_1 (tree, tree);\n+static void delete_duplicate_fields (tree);\n+static void finish_struct_bits (tree);\n+static int alter_access (tree, tree, tree);\n+static void handle_using_decl (tree, tree);\n+static void check_for_override (tree, tree);\n+static tree dfs_modify_vtables (tree, void *);\n+static tree modify_all_vtables (tree, tree);\n+static void determine_primary_base (tree);\n+static void finish_struct_methods (tree);\n+static void maybe_warn_about_overly_private_class (tree);\n+static int field_decl_cmp (const void *, const void *);\n+static int resort_field_decl_cmp (const void *, const void *);\n+static int method_name_cmp (const void *, const void *);\n+static int resort_method_name_cmp (const void *, const void *);\n+static void add_implicitly_declared_members (tree, int, int, int);\n+static tree fixed_type_or_null (tree, int *, int *);\n+static tree resolve_address_of_overloaded_function (tree, tree, int,\n+\t\t\t\t\t\t\t  int, int, tree);\n+static tree build_vtable_entry_ref (tree, tree, tree);\n+static tree build_vtbl_ref_1 (tree, tree);\n+static tree build_vtbl_initializer (tree, tree, tree, tree, int *);\n+static int count_fields (tree);\n+static int add_fields_to_vec (tree, tree, int);\n+static void check_bitfield_decl (tree);\n static void check_field_decl (tree, tree, int *, int *, int *, int *);\n static void check_field_decls (tree, tree *, int *, int *, int *);\n static tree *build_base_field (record_layout_info, tree, splay_tree, tree *);\n static void build_base_fields (record_layout_info, splay_tree, tree *);\n-static void check_methods PARAMS ((tree));\n-static void remove_zero_width_bit_fields PARAMS ((tree));\n-static void check_bases PARAMS ((tree, int *, int *, int *));\n+static void check_methods (tree);\n+static void remove_zero_width_bit_fields (tree);\n+static void check_bases (tree, int *, int *, int *);\n static void check_bases_and_members (tree);\n static tree create_vtable_ptr (tree, tree *);\n static void include_empty_classes (record_layout_info);\n static void layout_class_type (tree, tree *);\n-static void fixup_pending_inline PARAMS ((tree));\n-static void fixup_inline_methods PARAMS ((tree));\n-static void set_primary_base PARAMS ((tree, tree));\n-static void propagate_binfo_offsets PARAMS ((tree, tree, tree));\n+static void fixup_pending_inline (tree);\n+static void fixup_inline_methods (tree);\n+static void set_primary_base (tree, tree);\n+static void propagate_binfo_offsets (tree, tree, tree);\n static void layout_virtual_bases (record_layout_info, splay_tree);\n-static tree dfs_set_offset_for_unshared_vbases PARAMS ((tree, void *));\n-static void build_vbase_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n-static void add_vcall_offset_vtbl_entries_r PARAMS ((tree, vtbl_init_data *));\n-static void add_vcall_offset_vtbl_entries_1 PARAMS ((tree, vtbl_init_data *));\n-static void build_vcall_offset_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n+static tree dfs_set_offset_for_unshared_vbases (tree, void *);\n+static void build_vbase_offset_vtbl_entries (tree, vtbl_init_data *);\n+static void add_vcall_offset_vtbl_entries_r (tree, vtbl_init_data *);\n+static void add_vcall_offset_vtbl_entries_1 (tree, vtbl_init_data *);\n+static void build_vcall_offset_vtbl_entries (tree, vtbl_init_data *);\n static void add_vcall_offset (tree, tree, vtbl_init_data *);\n-static void layout_vtable_decl PARAMS ((tree, int));\n-static tree dfs_find_final_overrider PARAMS ((tree, void *));\n-static tree find_final_overrider PARAMS ((tree, tree, tree));\n-static int make_new_vtable PARAMS ((tree, tree));\n-static int maybe_indent_hierarchy PARAMS ((FILE *, int, int));\n-static void dump_class_hierarchy_r PARAMS ((FILE *, int, tree, tree, int));\n-static void dump_class_hierarchy PARAMS ((tree));\n-static void dump_array PARAMS ((FILE *, tree));\n-static void dump_vtable PARAMS ((tree, tree, tree));\n-static void dump_vtt PARAMS ((tree, tree));\n-static tree build_vtable PARAMS ((tree, tree, tree));\n-static void initialize_vtable PARAMS ((tree, tree));\n-static void initialize_array PARAMS ((tree, tree));\n-static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n-\t\t\t\t\t\t   tree, tree, splay_tree));\n-static tree end_of_class PARAMS ((tree, int));\n-static bool layout_empty_base PARAMS ((tree, tree, splay_tree, tree));\n-static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n-static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n-\t\t\t\t\t       tree));\n-static void build_rtti_vtbl_entries PARAMS ((tree, vtbl_init_data *));\n-static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n-\t\t\t\t\t\t\tvtbl_init_data *));\n-static void force_canonical_binfo_r PARAMS ((tree, tree, tree, tree));\n-static void force_canonical_binfo PARAMS ((tree, tree, tree, tree));\n-static tree dfs_unshared_virtual_bases PARAMS ((tree, void *));\n-static void mark_primary_bases PARAMS ((tree));\n-static tree mark_primary_virtual_base PARAMS ((tree, tree));\n-static void clone_constructors_and_destructors PARAMS ((tree));\n-static tree build_clone PARAMS ((tree, tree));\n-static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n-static tree copy_virtuals PARAMS ((tree));\n-static void build_ctor_vtbl_group PARAMS ((tree, tree));\n-static void build_vtt PARAMS ((tree));\n-static tree binfo_ctor_vtable PARAMS ((tree));\n-static tree *build_vtt_inits PARAMS ((tree, tree, tree *, tree *));\n-static tree dfs_build_secondary_vptr_vtt_inits PARAMS ((tree, void *));\n-static tree dfs_ctor_vtable_bases_queue_p PARAMS ((tree, void *data));\n-static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n-static tree get_original_base PARAMS ((tree, tree));\n-static tree dfs_get_primary_binfo PARAMS ((tree, void*));\n-static int record_subobject_offset PARAMS ((tree, tree, splay_tree));\n-static int check_subobject_offset PARAMS ((tree, tree, splay_tree));\n-static int walk_subobject_offsets PARAMS ((tree, subobject_offset_fn,\n-\t\t\t\t\t   tree, splay_tree, tree, int));\n-static void record_subobject_offsets PARAMS ((tree, tree, splay_tree, int));\n-static int layout_conflict_p PARAMS ((tree, tree, splay_tree, int));\n-static int splay_tree_compare_integer_csts PARAMS ((splay_tree_key k1,\n-\t\t\t\t\t\t    splay_tree_key k2));\n-static void warn_about_ambiguous_bases PARAMS ((tree));\n-static bool type_requires_array_cookie PARAMS ((tree));\n+static void layout_vtable_decl (tree, int);\n+static tree dfs_find_final_overrider (tree, void *);\n+static tree find_final_overrider (tree, tree, tree);\n+static int make_new_vtable (tree, tree);\n+static int maybe_indent_hierarchy (FILE *, int, int);\n+static void dump_class_hierarchy_r (FILE *, int, tree, tree, int);\n+static void dump_class_hierarchy (tree);\n+static void dump_array (FILE *, tree);\n+static void dump_vtable (tree, tree, tree);\n+static void dump_vtt (tree, tree);\n+static tree build_vtable (tree, tree, tree);\n+static void initialize_vtable (tree, tree);\n+static void initialize_array (tree, tree);\n+static void layout_nonempty_base_or_field (record_layout_info,\n+\t\t\t\t\t\t   tree, tree, splay_tree);\n+static tree end_of_class (tree, int);\n+static bool layout_empty_base (tree, tree, splay_tree, tree);\n+static void accumulate_vtbl_inits (tree, tree, tree, tree, tree);\n+static tree dfs_accumulate_vtbl_inits (tree, tree, tree, tree,\n+\t\t\t\t\t       tree);\n+static void build_rtti_vtbl_entries (tree, vtbl_init_data *);\n+static void build_vcall_and_vbase_vtbl_entries (tree, \n+\t\t\t\t\t\t\tvtbl_init_data *);\n+static void force_canonical_binfo_r (tree, tree, tree, tree);\n+static void force_canonical_binfo (tree, tree, tree, tree);\n+static tree dfs_unshared_virtual_bases (tree, void *);\n+static void mark_primary_bases (tree);\n+static tree mark_primary_virtual_base (tree, tree);\n+static void clone_constructors_and_destructors (tree);\n+static tree build_clone (tree, tree);\n+static void update_vtable_entry_for_fn (tree, tree, tree, tree *);\n+static tree copy_virtuals (tree);\n+static void build_ctor_vtbl_group (tree, tree);\n+static void build_vtt (tree);\n+static tree binfo_ctor_vtable (tree);\n+static tree *build_vtt_inits (tree, tree, tree *, tree *);\n+static tree dfs_build_secondary_vptr_vtt_inits (tree, void *);\n+static tree dfs_ctor_vtable_bases_queue_p (tree, void *data);\n+static tree dfs_fixup_binfo_vtbls (tree, void *);\n+static tree get_original_base (tree, tree);\n+static tree dfs_get_primary_binfo (tree, void*);\n+static int record_subobject_offset (tree, tree, splay_tree);\n+static int check_subobject_offset (tree, tree, splay_tree);\n+static int walk_subobject_offsets (tree, subobject_offset_fn,\n+\t\t\t\t\t   tree, splay_tree, tree, int);\n+static void record_subobject_offsets (tree, tree, splay_tree, int);\n+static int layout_conflict_p (tree, tree, splay_tree, int);\n+static int splay_tree_compare_integer_csts (splay_tree_key k1,\n+\t\t\t\t\t\t    splay_tree_key k2);\n+static void warn_about_ambiguous_bases (tree);\n+static bool type_requires_array_cookie (tree);\n static bool contains_empty_class_p (tree);\n static tree dfs_base_derived_from (tree, void *);\n static bool base_derived_from (tree, tree);\n@@ -248,11 +248,10 @@ int n_inner_fields_searched = 0;\n    from EXPR.  */\n \n tree\n-build_base_path (code, expr, binfo, nonnull)\n-     enum tree_code code;\n-     tree expr;\n-     tree binfo;\n-     int nonnull;\n+build_base_path (enum tree_code code,\n+                 tree expr,\n+                 tree binfo,\n+                 int nonnull)\n {\n   tree v_binfo = NULL_TREE;\n   tree d_binfo = NULL_TREE;\n@@ -389,8 +388,7 @@ convert_to_base (tree object, tree type, bool check_access)\n /* Virtual function things.  */\n \n static tree\n-build_vtable_entry_ref (array_ref, instance, idx)\n-     tree array_ref, instance, idx;\n+build_vtable_entry_ref (tree array_ref, tree instance, tree idx)\n {\n   tree i, i2, vtable, first_fn, basetype;\n \n@@ -421,8 +419,7 @@ build_vtable_entry_ref (array_ref, instance, idx)\n    creating extra tree nodes when we don't have to.  */\n \n static tree\n-build_vtbl_ref_1 (instance, idx)\n-     tree instance, idx;\n+build_vtbl_ref_1 (tree instance, tree idx)\n {\n   tree aref;\n   tree vtbl = NULL_TREE;\n@@ -459,8 +456,7 @@ build_vtbl_ref_1 (instance, idx)\n }\n \n tree\n-build_vtbl_ref (instance, idx)\n-     tree instance, idx;\n+build_vtbl_ref (tree instance, tree idx)\n {\n   tree aref = build_vtbl_ref_1 (instance, idx);\n \n@@ -474,8 +470,7 @@ build_vtbl_ref (instance, idx)\n    function pointer corresponding to vtable element INDEX.  */\n \n tree\n-build_vfn_ref (instance, idx)\n-     tree instance, idx;\n+build_vfn_ref (tree instance, tree idx)\n {\n   tree aref = build_vtbl_ref_1 (instance, idx);\n \n@@ -495,8 +490,7 @@ build_vfn_ref (instance, idx)\n    for the given TYPE.  */\n \n static tree\n-get_vtable_name (type)\n-     tree type;\n+get_vtable_name (tree type)\n {\n   return mangle_vtbl_for_type (type);\n }\n@@ -505,8 +499,7 @@ get_vtable_name (type)\n    for TYPE.  */\n \n tree\n-get_vtt_name (type)\n-     tree type;\n+get_vtt_name (tree type)\n {\n   return mangle_vtt_for_type (type);\n }\n@@ -516,10 +509,7 @@ get_vtt_name (type)\n    Use NAME for the name of the vtable, and VTABLE_TYPE for its type.  */\n \n static tree\n-build_vtable (class_type, name, vtable_type)\n-     tree class_type;\n-     tree name;\n-     tree vtable_type;\n+build_vtable (tree class_type, tree name, tree vtable_type)\n {\n   tree decl;\n \n@@ -546,9 +536,7 @@ build_vtable (class_type, name, vtable_type)\n    which are known to exist in the runtime.  */\n \n tree \n-get_vtable_decl (type, complete)\n-     tree type;\n-     int complete;\n+get_vtable_decl (tree type, int complete)\n {\n   tree decl;\n \n@@ -576,8 +564,7 @@ get_vtable_decl (type, complete)\n    BV_VCALL_INDEX for each entry is cleared.  */\n \n static tree\n-copy_virtuals (binfo)\n-     tree binfo;\n+copy_virtuals (tree binfo)\n {\n   tree copies;\n   tree t;\n@@ -596,8 +583,7 @@ copy_virtuals (binfo)\n    created.  */\n \n static int\n-build_primary_vtable (binfo, type)\n-     tree binfo, type;\n+build_primary_vtable (tree binfo, tree type)\n {\n   tree decl;\n   tree virtuals;\n@@ -651,8 +637,7 @@ build_primary_vtable (binfo, type)\n    can result.  */\n \n static int\n-build_secondary_vtable (binfo, for_type)\n-     tree binfo, for_type;\n+build_secondary_vtable (tree binfo, tree for_type)\n {\n   my_friendly_assert (binfo == CANONICAL_BINFO (binfo, for_type), 20010605);\n \n@@ -678,9 +663,7 @@ build_secondary_vtable (binfo, for_type)\n    T. Return nonzero if we actually created a new vtable.  */\n \n static int\n-make_new_vtable (t, binfo)\n-     tree t;\n-     tree binfo;\n+make_new_vtable (tree t, tree binfo)\n {\n   if (binfo == TYPE_BINFO (t))\n     /* In this case, it is *type*'s vtable we are modifying.  We start\n@@ -705,12 +688,11 @@ make_new_vtable (t, binfo)\n    the function is actually called.  */\n \n static void\n-modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n-     tree t;\n-     tree binfo;\n-     tree fndecl;\n-     tree delta;\n-     tree *virtuals;\n+modify_vtable_entry (tree t,\n+                     tree binfo, \n+                     tree fndecl, \n+                     tree delta, \n+                     tree* virtuals)\n {\n   tree v;\n \n@@ -744,10 +726,7 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n    add the method for improved error recovery.)  */\n \n void\n-add_method (type, method, error_p)\n-     tree type;\n-     tree method;\n-     int error_p;\n+add_method (tree type, tree method, int error_p)\n {\n   int using = (DECL_CONTEXT (method) != type);\n   int len;\n@@ -984,8 +963,7 @@ add_method (type, method, error_p)\n    when we have unnamed bitfields, for example.  */\n \n static tree\n-delete_duplicate_fields_1 (field, fields)\n-     tree field, fields;\n+delete_duplicate_fields_1 (tree field, tree fields)\n {\n   tree x;\n   tree prev = 0;\n@@ -1063,8 +1041,7 @@ delete_duplicate_fields_1 (field, fields)\n }\n \n static void\n-delete_duplicate_fields (fields)\n-     tree fields;\n+delete_duplicate_fields (tree fields)\n {\n   tree x;\n   for (x = fields; x && TREE_CHAIN (x); x = TREE_CHAIN (x))\n@@ -1075,10 +1052,7 @@ delete_duplicate_fields (fields)\n    legit, otherwise return 0.  */\n \n static int\n-alter_access (t, fdecl, access)\n-     tree t;\n-     tree fdecl;\n-     tree access;\n+alter_access (tree t, tree fdecl, tree access)\n {\n   tree elem;\n \n@@ -1118,9 +1092,7 @@ alter_access (t, fdecl, access)\n /* Process the USING_DECL, which is a member of T.  */\n \n static void\n-handle_using_decl (using_decl, t)\n-     tree using_decl;\n-     tree t;\n+handle_using_decl (tree using_decl, tree t)\n {\n   tree ctype = DECL_INITIAL (using_decl);\n   tree name = DECL_NAME (using_decl);\n@@ -1216,12 +1188,10 @@ handle_using_decl (using_decl, t)\n    the bases.  */\n \n static void\n-check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n-\t     no_const_asn_ref_p)\n-     tree t;\n-     int *cant_have_default_ctor_p;\n-     int *cant_have_const_ctor_p;\n-     int *no_const_asn_ref_p;\n+check_bases (tree t,\n+             int* cant_have_default_ctor_p,\n+             int* cant_have_const_ctor_p,\n+             int* no_const_asn_ref_p)\n {\n   int n_baseclasses;\n   int i;\n@@ -1332,11 +1302,7 @@ check_bases (t, cant_have_default_ctor_p, cant_have_const_ctor_p,\n    assoc list of binfos that have already been reseated.  */\n \n static void\n-force_canonical_binfo_r (to, from, type, mappings)\n-     tree to;\n-     tree from;\n-     tree type;\n-     tree mappings;\n+force_canonical_binfo_r (tree to, tree from, tree type, tree mappings)\n {\n   int i, n_baseclasses = BINFO_N_BASETYPES (from);\n \n@@ -1404,11 +1370,7 @@ force_canonical_binfo_r (to, from, type, mappings)\n    primary.  */\n \n static void\n-force_canonical_binfo (to, from, type, mappings)\n-     tree to;\n-     tree from;\n-     tree type;\n-     tree mappings;\n+force_canonical_binfo (tree to, tree from, tree type, tree mappings)\n {\n   tree assoc = purpose_member (BINFO_TYPE (to),\n \t\t               CLASSTYPE_VBASECLASSES (type));\n@@ -1424,9 +1386,7 @@ force_canonical_binfo (to, from, type, mappings)\n    otherwise (because something else has already made it primary).  */\n \n static tree\n-mark_primary_virtual_base (base_binfo, type)\n-     tree base_binfo;\n-     tree type;\n+mark_primary_virtual_base (tree base_binfo, tree type)\n {\n   tree shared_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), type);\n \n@@ -1453,9 +1413,7 @@ mark_primary_virtual_base (base_binfo, type)\n    mark_primary_bases.  DATA is the most derived type.  */\n \n static tree\n-dfs_unshared_virtual_bases (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_unshared_virtual_bases (tree binfo, void* data)\n {\n   tree t = (tree) data;\n   \n@@ -1506,8 +1464,7 @@ dfs_unshared_virtual_bases (binfo, data)\n    dominated by TYPE that are primary bases.  */\n \n static void\n-mark_primary_bases (type)\n-     tree type;\n+mark_primary_bases (tree type)\n {\n   tree binfo;\n   \n@@ -1546,9 +1503,7 @@ mark_primary_bases (type)\n /* Make the BINFO the primary base of T.  */\n \n static void\n-set_primary_base (t, binfo)\n-     tree t;\n-     tree binfo;\n+set_primary_base (tree t, tree binfo)\n {\n   tree basetype;\n \n@@ -1562,8 +1517,7 @@ set_primary_base (t, binfo)\n /* Determine the primary class for T.  */\n \n static void\n-determine_primary_base (t)\n-     tree t;\n+determine_primary_base (tree t)\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n   tree vbases;\n@@ -1705,8 +1659,7 @@ determine_primary_base (t)\n    use.  */\n \n static void\n-finish_struct_bits (t)\n-     tree t;\n+finish_struct_bits (tree t)\n {\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n@@ -1785,8 +1738,7 @@ finish_struct_bits (t)\n    non-private static member functions.  */\n \n static void\n-maybe_warn_about_overly_private_class (t)\n-     tree t;\n+maybe_warn_about_overly_private_class (tree t)\n {\n   int has_member_fn = 0;\n   int has_nonprivate_method = 0;\n@@ -1927,8 +1879,7 @@ maybe_warn_about_overly_private_class (t)\n /* Function to help qsort sort FIELD_DECLs by name order.  */\n \n static int\n-field_decl_cmp (x_p, y_p)\n-     const void *x_p, *y_p;\n+field_decl_cmp (const void* x_p, const void* y_p)\n {\n   const tree *const x = x_p;\n   const tree *const y = y_p;\n@@ -1953,8 +1904,7 @@ static struct {\n    pointer operator in resort_data.  */\n \n static int\n-resort_field_decl_cmp (x_p, y_p)\n-     const void *x_p, *y_p;\n+resort_field_decl_cmp (const void* x_p, const void* y_p)\n {\n   const tree *const x = x_p;\n   const tree *const y = y_p;\n@@ -1980,11 +1930,10 @@ resort_field_decl_cmp (x_p, y_p)\n /* Resort DECL_SORTED_FIELDS because pointers have been reordered.  */\n \n void \n-resort_sorted_fields (obj, orig_obj, new_value, cookie)\n-     void *obj;\n-     void *orig_obj ATTRIBUTE_UNUSED;\n-     gt_pointer_operator new_value;\n-     void *cookie;\n+resort_sorted_fields (void* obj, \n+                      void* orig_obj ATTRIBUTE_UNUSED , \n+                      gt_pointer_operator new_value, \n+                      void* cookie)\n {\n   tree sf = obj;\n   resort_data.new_value = new_value;\n@@ -1996,8 +1945,7 @@ resort_sorted_fields (obj, orig_obj, new_value, cookie)\n /* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n \n static int\n-method_name_cmp (m1_p, m2_p)\n-     const void *m1_p, *m2_p;\n+method_name_cmp (const void* m1_p, const void* m2_p)\n {\n   const tree *const m1 = m1_p;\n   const tree *const m2 = m2_p;\n@@ -2017,8 +1965,7 @@ method_name_cmp (m1_p, m2_p)\n    pointer operator in resort_field_decl_data.  */\n \n static int\n-resort_method_name_cmp (m1_p, m2_p)\n-     const void *m1_p, *m2_p;\n+resort_method_name_cmp (const void* m1_p, const void* m2_p)\n {\n   const tree *const m1 = m1_p;\n   const tree *const m2 = m2_p;\n@@ -2042,11 +1989,10 @@ resort_method_name_cmp (m1_p, m2_p)\n /* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n \n void \n-resort_type_method_vec (obj, orig_obj, new_value, cookie)\n-     void *obj;\n-     void *orig_obj ATTRIBUTE_UNUSED;\n-     gt_pointer_operator new_value;\n-     void *cookie;\n+resort_type_method_vec (void* obj,\n+                        void* orig_obj ATTRIBUTE_UNUSED ,\n+                        gt_pointer_operator new_value,\n+                        void* cookie)\n {\n   tree method_vec = obj;\n   int len = TREE_VEC_LENGTH (method_vec);\n@@ -2087,8 +2033,7 @@ resort_type_method_vec (obj, orig_obj, new_value, cookie)\n    search.  */\n \n static void\n-finish_struct_methods (t)\n-     tree t;\n+finish_struct_methods (tree t)\n {\n   tree fn_fields;\n   tree method_vec;\n@@ -2146,8 +2091,7 @@ finish_struct_methods (t)\n /* Emit error when a duplicate definition of a type is seen.  Patch up.  */\n \n void\n-duplicate_tag_error (t)\n-     tree t;\n+duplicate_tag_error (tree t)\n {\n   error (\"redefinition of `%#T'\", t);\n   cp_error_at (\"previous definition of `%#T'\", t);\n@@ -2221,9 +2165,7 @@ duplicate_tag_error (t)\n    to lay it out.  */\n \n static void\n-layout_vtable_decl (binfo, n)\n-     tree binfo;\n-     int n;\n+layout_vtable_decl (tree binfo, int n)\n {\n   tree atype;\n   tree vtable;\n@@ -2251,8 +2193,7 @@ layout_vtable_decl (binfo, n)\n    have the same signature.  */\n \n int\n-same_signature_p (fndecl, base_fndecl)\n-     tree fndecl, base_fndecl;\n+same_signature_p (tree fndecl, tree base_fndecl)\n {\n   /* One destructor overrides another if they are the same kind of\n      destructor.  */\n@@ -2316,9 +2257,7 @@ typedef struct find_final_overrider_data_s {\n /* Called from find_final_overrider via dfs_walk.  */\n \n static tree\n-dfs_find_final_overrider (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_find_final_overrider (tree binfo, void* data)\n {\n   find_final_overrider_data *ffod = (find_final_overrider_data *) data;\n \n@@ -2386,10 +2325,7 @@ dfs_find_final_overrider (binfo, data)\n    DERIVED) is the base object in which FN is declared.  */\n \n static tree\n-find_final_overrider (derived, binfo, fn)\n-     tree derived;\n-     tree binfo;\n-     tree fn;\n+find_final_overrider (tree derived, tree binfo, tree fn)\n {\n   find_final_overrider_data ffod;\n \n@@ -2459,11 +2395,7 @@ get_vcall_index (tree fn, tree type)\n    corresponding position in the BINFO_VIRTUALS list.  */\n \n static void\n-update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n-     tree t;\n-     tree binfo;\n-     tree fn;\n-     tree *virtuals;\n+update_vtable_entry_for_fn (tree t, tree binfo, tree fn, tree* virtuals)\n {\n   tree b;\n   tree overrider;\n@@ -2622,9 +2554,7 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n /* Called from modify_all_vtables via dfs_walk.  */\n \n static tree\n-dfs_modify_vtables (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_modify_vtables (tree binfo, void* data)\n {\n   if (/* There's no need to modify the vtable for a non-virtual\n          primary base; we're not going to use that vtable anyhow.\n@@ -2671,9 +2601,7 @@ dfs_modify_vtables (binfo, data)\n    should therefore be appended to the end of the vtable for T.  */\n \n static tree\n-modify_all_vtables (t, virtuals)\n-     tree t;\n-     tree virtuals;\n+modify_all_vtables (tree t, tree virtuals)\n {\n   tree binfo = TYPE_BINFO (t);\n   tree *fnsp;\n@@ -2716,8 +2644,7 @@ modify_all_vtables (t, virtuals)\n    indicated NAME.  */\n \n static tree\n-get_basefndecls (name, t)\n-     tree name, t;\n+get_basefndecls (tree name, tree t)\n {\n   tree methods;\n   tree base_fndecls = NULL_TREE;\n@@ -2748,8 +2675,7 @@ get_basefndecls (name, t)\n    mark this field as being virtual as well.  */\n \n static void\n-check_for_override (decl, ctype)\n-     tree decl, ctype;\n+check_for_override (tree decl, tree ctype)\n {\n   if (TREE_CODE (decl) == TEMPLATE_DECL)\n     /* In [temp.mem] we have:\n@@ -2778,8 +2704,7 @@ check_for_override (decl, ctype)\n    We know that constructors and destructors don't apply.  */\n \n void\n-warn_hidden (t)\n-     tree t;\n+warn_hidden (tree t)\n {\n   tree method_vec = CLASSTYPE_METHOD_VEC (t);\n   int n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n@@ -2848,8 +2773,7 @@ warn_hidden (t)\n    things we should check for also.  */\n \n static void\n-finish_struct_anon (t)\n-     tree t;\n+finish_struct_anon (tree t)\n {\n   tree field;\n \n@@ -2914,10 +2838,7 @@ finish_struct_anon (t)\n    (FUNCTION_DECL, TEMPLATE_DECL).  */\n \n void\n-maybe_add_class_template_decl_list (type, t, friend_p)\n-     tree type;\n-     tree t;\n-     int friend_p;\n+maybe_add_class_template_decl_list (tree type, tree t, int friend_p)\n {\n   /* Save some memory by not creating TREE_LIST if TYPE is not template.  */\n   if (CLASSTYPE_TEMPLATE_INFO (type))\n@@ -2936,13 +2857,10 @@ maybe_add_class_template_decl_list (type, t, friend_p)\n    DECL is returned; otherwise the return value is NULL_TREE.  */\n \n static void\n-add_implicitly_declared_members (t, cant_have_default_ctor,\n-\t\t\t\t cant_have_const_cctor,\n-\t\t\t\t cant_have_const_assignment)\n-     tree t;\n-     int cant_have_default_ctor;\n-     int cant_have_const_cctor;\n-     int cant_have_const_assignment;\n+add_implicitly_declared_members (tree t, \n+                                 int cant_have_default_ctor,\n+\t\t\t\t int cant_have_const_cctor,\n+\t\t\t\t int cant_have_const_assignment)\n {\n   tree default_fn;\n   tree implicit_fns = NULL_TREE;\n@@ -3033,8 +2951,7 @@ add_implicitly_declared_members (t, cant_have_default_ctor,\n    in TYPE, including anonymous union members.  */\n \n static int\n-count_fields (fields)\n-     tree fields;\n+count_fields (tree fields)\n {\n   tree x;\n   int n_fields = 0;\n@@ -3052,9 +2969,7 @@ count_fields (fields)\n    TREE_LIST FIELDS to the TREE_VEC FIELD_VEC, starting at offset IDX.  */\n \n static int\n-add_fields_to_vec (fields, field_vec, idx)\n-     tree fields, field_vec;\n-     int idx;\n+add_fields_to_vec (tree fields, tree field_vec, int idx)\n {\n   tree x;\n   for (x = fields; x; x = TREE_CHAIN (x))\n@@ -3072,8 +2987,7 @@ add_fields_to_vec (fields, field_vec, idx)\n    flags.  */\n \n static void\n-check_bitfield_decl (field)\n-     tree field;\n+check_bitfield_decl (tree field)\n {\n   tree type = TREE_TYPE (field);\n   tree w = NULL_TREE;\n@@ -3173,15 +3087,12 @@ check_bitfield_decl (field)\n    flags.  */\n \n static void\n-check_field_decl (field, t, cant_have_const_ctor,\n-\t\t  cant_have_default_ctor, no_const_asn_ref,\n-\t\t  any_default_members)\n-     tree field;\n-     tree t;\n-     int *cant_have_const_ctor;\n-     int *cant_have_default_ctor;\n-     int *no_const_asn_ref;\n-     int *any_default_members;\n+check_field_decl (tree field,\n+                  tree t,\n+                  int* cant_have_const_ctor,\n+\t\t  int* cant_have_default_ctor,\n+                  int* no_const_asn_ref,\n+\t\t  int* any_default_members)\n {\n   tree type = strip_array_types (TREE_TYPE (field));\n \n@@ -3524,10 +3435,7 @@ check_field_decls (tree t, tree *access_decls,\n    OFFSETS.  */\n \n static int\n-record_subobject_offset (type, offset, offsets)\n-     tree type;\n-     tree offset;\n-     splay_tree offsets;\n+record_subobject_offset (tree type, tree offset, splay_tree offsets)\n {\n   splay_tree_node n;\n \n@@ -3552,10 +3460,7 @@ record_subobject_offset (type, offset, offsets)\n    already an entry in OFFSETS for the same TYPE as the same OFFSET.  */\n \n static int\n-check_subobject_offset (type, offset, offsets)\n-     tree type;\n-     tree offset;\n-     splay_tree offsets;\n+check_subobject_offset (tree type, tree offset, splay_tree offsets)\n {\n   splay_tree_node n;\n   tree t;\n@@ -3587,13 +3492,12 @@ check_subobject_offset (type, offset, offsets)\n    is returned.  Otherwise, returns zero.  */\n \n static int\n-walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n-     tree type;\n-     subobject_offset_fn f;\n-     tree offset;\n-     splay_tree offsets;\n-     tree max_offset;\n-     int vbases_p;\n+walk_subobject_offsets (tree type, \n+                        subobject_offset_fn f, \n+                        tree offset, \n+                        splay_tree offsets, \n+                        tree max_offset, \n+                        int vbases_p)\n {\n   int r = 0;\n   tree type_binfo = NULL_TREE;\n@@ -3791,11 +3695,10 @@ walk_subobject_offsets (type, f, offset, offsets, max_offset, vbases_p)\n    examined.  */\n \n static void\n-record_subobject_offsets (type, offset, offsets, vbases_p)\n-     tree type;\n-     tree offset;\n-     splay_tree offsets;\n-     int vbases_p;\n+record_subobject_offsets (tree type, \n+                          tree offset, \n+                          splay_tree offsets, \n+                          int vbases_p)\n {\n   walk_subobject_offsets (type, record_subobject_offset, offset,\n \t\t\t  offsets, /*max_offset=*/NULL_TREE, vbases_p);\n@@ -3806,11 +3709,10 @@ record_subobject_offsets (type, offset, offsets, vbases_p)\n    virtual bases of TYPE are examined.  */\n \n static int\n-layout_conflict_p (type, offset, offsets, vbases_p)\n-     tree type;\n-     tree offset;\n-     splay_tree offsets;\n-     int vbases_p;\n+layout_conflict_p (tree type,\n+                   tree offset, \n+                   splay_tree offsets, \n+                   int vbases_p)\n {\n   splay_tree_node max_node;\n \n@@ -3941,11 +3843,7 @@ empty_base_at_nonzero_offset_p (tree type,\n    type.  Return nonzero iff we added it at the end.  */\n \n static bool\n-layout_empty_base (binfo, eoc, offsets, t)\n-     tree binfo;\n-     tree eoc;\n-     splay_tree offsets;\n-     tree t;\n+layout_empty_base (tree binfo, tree eoc, splay_tree offsets, tree t)\n {\n   tree alignment;\n   tree basetype = BINFO_TYPE (binfo);\n@@ -4142,8 +4040,7 @@ build_base_fields (record_layout_info rli,\n    methods, and so forth.  */\n \n static void\n-check_methods (t)\n-     tree t;\n+check_methods (tree t)\n {\n   tree x;\n \n@@ -4175,9 +4072,7 @@ check_methods (t)\n    NAME.  */\n \n static tree\n-build_clone (fn, name)\n-     tree fn;\n-     tree name;\n+build_clone (tree fn, tree name)\n {\n   tree parms;\n   tree clone;\n@@ -4296,9 +4191,7 @@ build_clone (fn, name)\n    CLASTYPE_METHOD_VEC as well.  */\n \n void\n-clone_function_decl (fn, update_method_vec_p)\n-     tree fn;\n-     int update_method_vec_p;\n+clone_function_decl (tree fn, int update_method_vec_p)\n {\n   tree clone;\n \n@@ -4357,8 +4250,7 @@ clone_function_decl (fn, update_method_vec_p)\n    clones.  */\n \n void\n-adjust_clone_args (decl)\n-     tree decl;\n+adjust_clone_args (tree decl)\n {\n   tree clone;\n   \n@@ -4427,8 +4319,7 @@ adjust_clone_args (decl)\n    in-charge and not-in-charge variant.  */\n \n static void\n-clone_constructors_and_destructors (t)\n-     tree t;\n+clone_constructors_and_destructors (tree t)\n {\n   tree fns;\n \n@@ -4446,8 +4337,7 @@ clone_constructors_and_destructors (t)\n /* Remove all zero-width bit-fields from T.  */\n \n static void\n-remove_zero_width_bit_fields (t)\n-     tree t;\n+remove_zero_width_bit_fields (tree t)\n {\n   tree *fieldsp;\n \n@@ -4467,8 +4357,7 @@ remove_zero_width_bit_fields (t)\n    array whose elements have the indicated class TYPE.  */\n \n static bool\n-type_requires_array_cookie (type)\n-     tree type;\n+type_requires_array_cookie (tree type)\n {\n   tree fns;\n   bool has_two_argument_delete_p = false;\n@@ -4610,9 +4499,7 @@ check_bases_and_members (tree t)\n    on VIRTUALS_P.  */\n \n static tree\n-create_vtable_ptr (t, virtuals_p)\n-     tree t;\n-     tree *virtuals_p;\n+create_vtable_ptr (tree t, tree* virtuals_p)\n {\n   tree fn;\n \n@@ -4688,8 +4575,7 @@ create_vtable_ptr (t, virtuals_p)\n    complete.  */\n \n static void\n-fixup_pending_inline (fn)\n-     tree fn;\n+fixup_pending_inline (tree fn)\n {\n   if (DECL_PENDING_INLINE_INFO (fn))\n     {\n@@ -4706,8 +4592,7 @@ fixup_pending_inline (fn)\n    complete.  */\n \n static void\n-fixup_inline_methods (type)\n-     tree type;\n+fixup_inline_methods (tree type)\n {\n   tree method = TYPE_METHODS (type);\n \n@@ -4739,10 +4624,7 @@ fixup_inline_methods (type)\n    OFFSET, which is a type offset, is number of bytes.  */\n \n static void\n-propagate_binfo_offsets (binfo, offset, t)\n-     tree binfo;\n-     tree offset;\n-     tree t;\n+propagate_binfo_offsets (tree binfo, tree offset, tree t)\n {\n   int i;\n   tree primary_binfo;\n@@ -4794,9 +4676,7 @@ propagate_binfo_offsets (binfo, offset, t)\n /* Called via dfs_walk from layout_virtual bases.  */\n \n static tree\n-dfs_set_offset_for_unshared_vbases (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_set_offset_for_unshared_vbases (tree binfo, void* data)\n {\n   /* If this is a virtual base, make sure it has the same offset as\n      the shared copy.  If it's a primary base, then we know it's\n@@ -4931,9 +4811,7 @@ end_of_base (tree binfo)\n    only non-virtual bases are included.  */\n \n static tree\n-end_of_class (t, include_virtuals_p)\n-     tree t;\n-     int include_virtuals_p;\n+end_of_class (tree t, int include_virtuals_p)\n {\n   tree result = size_zero_node;\n   tree binfo;\n@@ -4979,8 +4857,7 @@ end_of_class (t, include_virtuals_p)\n    subobjects of U.  */\n \n static void\n-warn_about_ambiguous_bases (t)\n-     tree t;\n+warn_about_ambiguous_bases (tree t)\n {\n   int i;\n   tree vbases;\n@@ -5013,9 +4890,7 @@ warn_about_ambiguous_bases (t)\n /* Compare two INTEGER_CSTs K1 and K2.  */\n \n static int\n-splay_tree_compare_integer_csts (k1, k2)\n-     splay_tree_key k1;\n-     splay_tree_key k2;\n+splay_tree_compare_integer_csts (splay_tree_key k1, splay_tree_key k2)\n {\n   return tree_int_cst_compare ((tree) k1, (tree) k2);\n }\n@@ -5384,8 +5259,7 @@ key_method (tree type)\n    is complete.  */\n \n void\n-finish_struct_1 (t)\n-     tree t;\n+finish_struct_1 (tree t)\n {\n   tree x;\n   /* A TREE_LIST.  The TREE_VALUE of each node is a FUNCTION_DECL.  */\n@@ -5580,8 +5454,7 @@ finish_struct_1 (t)\n    order.  Rearrange them to declaration order.  */\n \n void\n-unreverse_member_declarations (t)\n-     tree t;\n+unreverse_member_declarations (tree t)\n {\n   tree next;\n   tree prev;\n@@ -5613,8 +5486,7 @@ unreverse_member_declarations (t)\n }\n \n tree\n-finish_struct (t, attributes)\n-     tree t, attributes;\n+finish_struct (tree t, tree attributes)\n {\n   const char *saved_filename = input_filename;\n   int saved_lineno = lineno;\n@@ -5663,10 +5535,7 @@ finish_struct (t, attributes)\n    before this function is called.  */\n \n static tree\n-fixed_type_or_null (instance, nonnull, cdtorp)\n-     tree instance;\n-     int *nonnull;\n-     int *cdtorp;\n+fixed_type_or_null (tree instance, int* nonnull, int* cdtorp)\n {\n   switch (TREE_CODE (instance))\n     {\n@@ -5788,9 +5657,7 @@ fixed_type_or_null (instance, nonnull, cdtorp)\n    before this function is called.  */\n \n int\n-resolves_to_fixed_type_p (instance, nonnull)\n-     tree instance;\n-     int *nonnull;\n+resolves_to_fixed_type_p (tree instance, int* nonnull)\n {\n   tree t = TREE_TYPE (instance);\n   int cdtorp = 0;\n@@ -5807,7 +5674,7 @@ resolves_to_fixed_type_p (instance, nonnull)\n \n \f\n void\n-init_class_processing ()\n+init_class_processing (void)\n {\n   current_class_depth = 0;\n   current_class_stack_size = 10;\n@@ -5858,9 +5725,7 @@ init_class_processing ()\n    that name becomes `error_mark_node'.  */\n \n void\n-pushclass (type, modify)\n-     tree type;\n-     int modify;\n+pushclass (tree type, int modify)\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n@@ -5945,7 +5810,7 @@ pushclass (type, modify)\n    must invalidate our cache.  */\n \n void\n-invalidate_class_lookup_cache ()\n+invalidate_class_lookup_cache (void)\n {\n   tree t;\n   \n@@ -5961,7 +5826,7 @@ invalidate_class_lookup_cache ()\n    previously, that is the one popped to.  */\n \n void\n-popclass ()\n+popclass (void)\n {\n   poplevel_class ();\n   pop_class_decls ();\n@@ -5979,8 +5844,7 @@ popclass ()\n    no type.  */\n \n int\n-currently_open_class (t)\n-     tree t;\n+currently_open_class (tree t)\n {\n   int i;\n   if (t == current_class_type)\n@@ -5996,8 +5860,7 @@ currently_open_class (t)\n    something via unqualified lookup.  */\n \n tree\n-currently_open_derived_class (t)\n-     tree t;\n+currently_open_derived_class (tree t)\n {\n   int i;\n \n@@ -6023,9 +5886,7 @@ currently_open_derived_class (t)\n    formal of the same name.  */\n \n void\n-push_nested_class (type, modify)\n-     tree type;\n-     int modify;\n+push_nested_class (tree type, int modify)\n {\n   tree context;\n \n@@ -6048,7 +5909,7 @@ push_nested_class (type, modify)\n /* Undoes a push_nested_class call.  */\n \n void\n-pop_nested_class ()\n+pop_nested_class (void)\n {\n   tree context = DECL_CONTEXT (TYPE_MAIN_DECL (current_class_type));\n \n@@ -6060,7 +5921,7 @@ pop_nested_class ()\n /* Returns the number of extern \"LANG\" blocks we are nested within.  */\n \n int\n-current_lang_depth ()\n+current_lang_depth (void)\n {\n   return VARRAY_ACTIVE_SIZE (current_lang_base);\n }\n@@ -6069,8 +5930,7 @@ current_lang_depth ()\n    so that behavior of name-mangling machinery is correct.  */\n \n void\n-push_lang_context (name)\n-     tree name;\n+push_lang_context (tree name)\n {\n   VARRAY_PUSH_TREE (current_lang_base, current_lang_name);\n \n@@ -6105,7 +5965,7 @@ push_lang_context (name)\n /* Get out of the current language scope.  */\n \n void\n-pop_lang_context ()\n+pop_lang_context (void)\n {\n   current_lang_name = VARRAY_TOP_TREE (current_lang_base);\n   VARRAY_POP (current_lang_base);\n@@ -6122,18 +5982,12 @@ pop_lang_context ()\n    template arguments.  */\n \n static tree\n-resolve_address_of_overloaded_function (target_type, \n-\t\t\t\t\toverload,\n-\t\t\t\t\tcomplain,\n-\t                                ptrmem,\n-\t\t\t\t\ttemplate_only,\n-\t\t\t\t\texplicit_targs)\n-     tree target_type;\n-     tree overload;\n-     int complain;\n-     int ptrmem;\n-     int template_only;\n-     tree explicit_targs;\n+resolve_address_of_overloaded_function (tree target_type, \n+\t\t\t\t\ttree overload,\n+\t\t\t\t\tint complain,\n+\t                                int ptrmem,\n+\t\t\t\t\tint template_only,\n+\t\t\t\t\ttree explicit_targs)\n {\n   /* Here's what the standard says:\n      \n@@ -6398,9 +6252,7 @@ cannot resolve overloaded function `%D' based on conversion to type `%T'\",\n    function, or a pointer to member function.  */\n \n tree\n-instantiate_type (lhstype, rhs, flags)\n-     tree lhstype, rhs;\n-     tsubst_flags_t flags;\n+instantiate_type (tree lhstype, tree rhs, tsubst_flags_t flags)\n {\n   int complain = (flags & tf_error);\n   int strict = (flags & tf_no_attributes)\n@@ -6651,8 +6503,7 @@ instantiate_type (lhstype, rhs, flags)\n    all be the same name.  Who knows for multiple inheritance).  */\n \n static tree\n-get_vfield_name (type)\n-     tree type;\n+get_vfield_name (tree type)\n {\n   tree binfo = TYPE_BINFO (type);\n   char *buf;\n@@ -6671,7 +6522,7 @@ get_vfield_name (type)\n }\n \n void\n-print_class_statistics ()\n+print_class_statistics (void)\n {\n #ifdef GATHER_STATISTICS\n   fprintf (stderr, \"convert_harshness = %d\\n\", n_convert_harshness);\n@@ -6695,7 +6546,7 @@ print_class_statistics ()\n    the inserted class name is treated as if it were a public member name.  */\n \n void\n-build_self_reference ()\n+build_self_reference (void)\n {\n   tree name = constructor_name (current_class_type);\n   tree value = build_lang_decl (TYPE_DECL, name, current_class_type);\n@@ -6717,8 +6568,7 @@ build_self_reference ()\n /* Returns 1 if TYPE contains only padding bytes.  */\n \n int\n-is_empty_class (type)\n-     tree type;\n+is_empty_class (tree type)\n {\n   if (type == error_mark_node)\n     return 0;\n@@ -6764,8 +6614,7 @@ contains_empty_class_p (tree type)\n    a *_TYPE node.  NODE can also be a local class.  */\n \n tree\n-get_enclosing_class (type)\n-     tree type;\n+get_enclosing_class (tree type)\n {\n   tree node = type;\n \n@@ -6793,8 +6642,7 @@ get_enclosing_class (type)\n /* Return 1 if TYPE or one of its enclosing classes is derived from BASE.  */\n \n int\n-is_base_of_enclosing_class (base, type)\n-     tree base, type;\n+is_base_of_enclosing_class (tree base, tree type)\n {\n   while (type)\n     {\n@@ -6810,9 +6658,7 @@ is_base_of_enclosing_class (base, type)\n    defined and that the result of that lookup was DECL.  */\n \n void\n-maybe_note_name_used_in_class (name, decl)\n-     tree name;\n-     tree decl;\n+maybe_note_name_used_in_class (tree name, tree decl)\n {\n   splay_tree names_used;\n \n@@ -6839,9 +6685,7 @@ maybe_note_name_used_in_class (name, decl)\n    to see that the declaration is valid.  */\n \n void\n-note_name_declared_in_class (name, decl)\n-     tree name;\n-     tree decl;\n+note_name_declared_in_class (tree name, tree decl)\n {\n   splay_tree names_used;\n   splay_tree_node n;\n@@ -6872,8 +6716,7 @@ note_name_declared_in_class (name, decl)\n    will return the VAR_DECL for the primary vtable.  */\n \n tree\n-get_vtbl_decl_for_binfo (binfo)\n-     tree binfo;\n+get_vtbl_decl_for_binfo (tree binfo)\n {\n   tree decl;\n \n@@ -6894,9 +6737,7 @@ get_vtbl_decl_for_binfo (binfo)\n    who's TREE_VALUE is a list of candidate binfos that we fill in.  */\n \n static tree\n-dfs_get_primary_binfo (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_get_primary_binfo (tree binfo, void* data)\n {\n   tree cons = (tree) data;\n   tree primary_base = TREE_PURPOSE (cons);\n@@ -6919,8 +6760,7 @@ dfs_get_primary_binfo (binfo, data)\n    object.  Check BINFO_PRIMARY_P to be sure.  */\n \n tree\n-get_primary_binfo (binfo)\n-     tree binfo;\n+get_primary_binfo (tree binfo)\n {\n   tree primary_base;\n   tree result = NULL_TREE;\n@@ -6994,10 +6834,7 @@ get_primary_binfo (binfo)\n /* If INDENTED_P is zero, indent to INDENT. Return nonzero.  */\n \n static int\n-maybe_indent_hierarchy (stream, indent, indented_p)\n-     FILE *stream;\n-     int indent;\n-     int indented_p;\n+maybe_indent_hierarchy (FILE * stream, int indent, int indented_p)\n {\n   if (!indented_p)\n     fprintf (stream, \"%*s\", indent, \"\");\n@@ -7009,12 +6846,11 @@ maybe_indent_hierarchy (stream, indent, indented_p)\n    the top level; it is incremented recursively.  */\n \n static void\n-dump_class_hierarchy_r (stream, flags, t, binfo, indent)\n-     FILE *stream;\n-     int flags;\n-     tree t;\n-     tree binfo;\n-     int indent;\n+dump_class_hierarchy_r (FILE * stream,\n+                        int flags,\n+                        tree t,\n+                        tree binfo,\n+                        int indent)\n {\n   int i;\n   int indented = 0;\n@@ -7105,8 +6941,7 @@ dump_class_hierarchy_r (stream, flags, t, binfo, indent)\n /* Dump the BINFO hierarchy for T.  */\n \n static void\n-dump_class_hierarchy (t)\n-     tree t;\n+dump_class_hierarchy (tree t)\n {\n   int flags;\n   FILE *stream = dump_begin (TDI_class, &flags);\n@@ -7124,9 +6959,7 @@ dump_class_hierarchy (t)\n }\n \n static void\n-dump_array (stream, decl)\n-     FILE *stream;\n-     tree decl;\n+dump_array (FILE * stream, tree decl)\n {\n   tree inits;\n   int ix;\n@@ -7148,10 +6981,7 @@ dump_array (stream, decl)\n }\n \n static void\n-dump_vtable (t, binfo, vtable)\n-     tree t;\n-     tree binfo;\n-     tree vtable;\n+dump_vtable (tree t, tree binfo, tree vtable)\n {\n   int flags;\n   FILE *stream = dump_begin (TDI_class, &flags);\n@@ -7181,9 +7011,7 @@ dump_vtable (t, binfo, vtable)\n }\n \n static void\n-dump_vtt (t, vtt)\n-     tree t;\n-     tree vtt;\n+dump_vtt (tree t, tree vtt)\n {\n   int flags;\n   FILE *stream = dump_begin (TDI_class, &flags);\n@@ -7207,8 +7035,7 @@ dump_vtt (t, vtt)\n /* Create all the necessary vtables for T and its base classes.  */\n \n static void\n-finish_vtbls (t)\n-     tree t;\n+finish_vtbls (tree t)\n {\n   tree list;\n   tree vbase;\n@@ -7256,9 +7083,7 @@ finish_vtbls (t)\n /* Initialize the vtable for BINFO with the INITS.  */\n \n static void\n-initialize_vtable (binfo, inits)\n-     tree binfo;\n-     tree inits;\n+initialize_vtable (tree binfo, tree inits)\n {\n   tree decl;\n \n@@ -7272,9 +7097,7 @@ initialize_vtable (binfo, inits)\n    the INITS.  */\n \n static void\n-initialize_array (decl, inits)\n-  tree decl;\n-  tree inits;\n+initialize_array (tree decl, tree inits)\n {\n   tree context;\n \n@@ -7300,8 +7123,7 @@ initialize_array (decl, inits)\n    Secondary VTTs look like complete object VTTs without part 4.  */\n \n static void\n-build_vtt (t)\n-     tree t;\n+build_vtt (tree t)\n {\n   tree inits;\n   tree type;\n@@ -7337,9 +7159,7 @@ build_vtt (t)\n    BINFO.  */\n \n static tree\n-get_original_base (base_binfo, binfo)\n-     tree base_binfo;\n-     tree binfo;\n+get_original_base (tree base_binfo, tree binfo)\n {\n   tree derived;\n   int ix;\n@@ -7364,8 +7184,7 @@ get_original_base (base_binfo, binfo)\n    complete.  VALUE can also be another BINFO, in which case we recurse.  */\n \n static tree\n-binfo_ctor_vtable (binfo)\n-     tree binfo;\n+binfo_ctor_vtable (tree binfo)\n {\n   tree vt;\n \n@@ -7392,11 +7211,7 @@ binfo_ctor_vtable (binfo)\n    vtables for the BINFO-in-T variant.  */\n \n static tree *\n-build_vtt_inits (binfo, t, inits, index)\n-     tree binfo;\n-     tree t;\n-     tree *inits;\n-     tree *index;\n+build_vtt_inits (tree binfo, tree t, tree* inits, tree* index)\n {\n   int i;\n   tree b;\n@@ -7503,9 +7318,7 @@ build_vtt_inits (binfo, t, inits, index)\n    TREE_TOP_LEVEL flag indicates that this is the primary VTT.  */\n \n static tree\n-dfs_build_secondary_vptr_vtt_inits (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_build_secondary_vptr_vtt_inits (tree binfo, void* data)\n {\n   tree l; \n   tree t;\n@@ -7568,9 +7381,7 @@ dfs_build_secondary_vptr_vtt_inits (binfo, data)\n    hierarchy.  */\n \n static tree\n-dfs_ctor_vtable_bases_queue_p (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_ctor_vtable_bases_queue_p (tree binfo, void* data)\n {\n   if (TREE_VIA_VIRTUAL (binfo))\n      /* Get the shared version.  */\n@@ -7587,9 +7398,7 @@ dfs_ctor_vtable_bases_queue_p (binfo, data)\n    TREE_VALUE is the TREE_TYPE of the base whose sub vtt was generated.  */\n \n static tree\n-dfs_fixup_binfo_vtbls (binfo, data)\n-     tree binfo;\n-     void *data;\n+dfs_fixup_binfo_vtbls (tree binfo, void* data)\n {\n   CLEAR_BINFO_MARKED (binfo);\n \n@@ -7612,9 +7421,7 @@ dfs_fixup_binfo_vtbls (binfo, data)\n    hierarchy dominated by T.  */\n \n static void\n-build_ctor_vtbl_group (binfo, t)\n-     tree binfo;\n-     tree t;\n+build_ctor_vtbl_group (tree binfo, tree t)\n {\n   tree list;\n   tree type;\n@@ -7677,12 +7484,11 @@ build_ctor_vtbl_group (binfo, t)\n    but are not necessarily the same in terms of layout.  */\n \n static void\n-accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n-     tree binfo;\n-     tree orig_binfo;\n-     tree rtti_binfo;\n-     tree t;\n-     tree inits;\n+accumulate_vtbl_inits (tree binfo,\n+                       tree orig_binfo,\n+                       tree rtti_binfo,\n+                       tree t,\n+                       tree inits)\n {\n   int i;\n   int ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n@@ -7731,12 +7537,11 @@ accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n    the BINFO vtable.  */\n \n static tree\n-dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n-     tree binfo;\n-     tree orig_binfo;\n-     tree rtti_binfo;\n-     tree t;\n-     tree l;\n+dfs_accumulate_vtbl_inits (tree binfo,\n+                           tree orig_binfo,\n+                           tree rtti_binfo,\n+                           tree t,\n+                           tree l)\n {\n   tree inits = NULL_TREE;\n   tree vtbl = NULL_TREE;\n@@ -7858,12 +7663,11 @@ dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n    constructed.  */\n \n static tree\n-build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n-     tree binfo;\n-     tree orig_binfo;\n-     tree t;\n-     tree rtti_binfo;\n-     int *non_fn_entries_p;\n+build_vtbl_initializer (tree binfo,\n+                        tree orig_binfo,\n+                        tree t,\n+                        tree rtti_binfo,\n+                        int* non_fn_entries_p)\n {\n   tree v, b;\n   tree vfun_inits;\n@@ -8028,9 +7832,7 @@ build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n    offsets in BINFO, which is in the hierarchy dominated by T.  */\n \n static void\n-build_vcall_and_vbase_vtbl_entries (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n+build_vcall_and_vbase_vtbl_entries (tree binfo, vtbl_init_data* vid)\n {\n   tree b;\n \n@@ -8052,9 +7854,7 @@ build_vcall_and_vbase_vtbl_entries (binfo, vid)\n    where the next vbase offset will go.  */\n \n static void\n-build_vbase_offset_vtbl_entries (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n+build_vbase_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n {\n   tree vbase;\n   tree t;\n@@ -8158,9 +7958,7 @@ build_vbase_offset_vtbl_entries (binfo, vid)\n    to VID->INITS.  */\n \n static void\n-build_vcall_offset_vtbl_entries (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n+build_vcall_offset_vtbl_entries (tree binfo, vtbl_init_data* vid)\n {\n   /* We only need these entries if this base is a virtual base.  We\n      compute the indices -- but do not add to the vtable -- when\n@@ -8198,9 +7996,7 @@ build_vcall_offset_vtbl_entries (binfo, vid)\n /* Build vcall offsets, starting with those for BINFO.  */\n \n static void\n-add_vcall_offset_vtbl_entries_r (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n+add_vcall_offset_vtbl_entries_r (tree binfo, vtbl_init_data* vid)\n {\n   int i;\n   tree primary_binfo;\n@@ -8234,9 +8030,7 @@ add_vcall_offset_vtbl_entries_r (binfo, vid)\n /* Called from build_vcall_offset_vtbl_entries_r.  */\n \n static void\n-add_vcall_offset_vtbl_entries_1 (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data* vid;\n+add_vcall_offset_vtbl_entries_1 (tree binfo, vtbl_init_data* vid)\n {\n   /* Make entries for the rest of the virtuals.  */\n   if (abi_version_at_least (2))\n@@ -8394,9 +8188,7 @@ add_vcall_offset (tree orig_fn, tree binfo, vtbl_init_data *vid)\n    by VID->rtti_binfo.  */\n \n static void\n-build_rtti_vtbl_entries (binfo, vid)\n-     tree binfo;\n-     vtbl_init_data *vid;\n+build_rtti_vtbl_entries (tree binfo, vtbl_init_data* vid)\n {\n   tree b;\n   tree t;"}, {"sha": "8e5dc333403ceeedcb28f2e328868454aa8aaf62", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 417, "deletions": 638, "changes": 1055, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94edc4abdc1de8d0c77421354eabf3bfc3de0c91/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=94edc4abdc1de8d0c77421354eabf3bfc3de0c91", "patch": "@@ -213,53 +213,53 @@ typedef struct cp_lexer GTY (())\n /* Prototypes.  */\n \n static cp_lexer *cp_lexer_new_main\n-  PARAMS ((void));\n+  (void);\n static cp_lexer *cp_lexer_new_from_tokens\n-  PARAMS ((struct cp_token_cache *));\n+  (struct cp_token_cache *);\n static int cp_lexer_saving_tokens\n-  PARAMS ((const cp_lexer *));\n+  (const cp_lexer *);\n static cp_token *cp_lexer_next_token\n-  PARAMS ((cp_lexer *, cp_token *));\n-static ptrdiff_t cp_lexer_token_difference\n-  PARAMS ((cp_lexer *, cp_token *, cp_token *));\n+  (cp_lexer *, cp_token *);\n+static ptrdiff_t cp_lexer_token_difference \n+  (cp_lexer *, cp_token *, cp_token *);\n static cp_token *cp_lexer_read_token\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static void cp_lexer_maybe_grow_buffer\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static void cp_lexer_get_preprocessor_token\n-  PARAMS ((cp_lexer *, cp_token *));\n+  (cp_lexer *, cp_token *);\n static cp_token *cp_lexer_peek_token\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static cp_token *cp_lexer_peek_nth_token\n-  PARAMS ((cp_lexer *, size_t));\n+  (cp_lexer *, size_t);\n static inline bool cp_lexer_next_token_is\n-  PARAMS ((cp_lexer *, enum cpp_ttype));\n+  (cp_lexer *, enum cpp_ttype);\n static bool cp_lexer_next_token_is_not\n-  PARAMS ((cp_lexer *, enum cpp_ttype));\n+  (cp_lexer *, enum cpp_ttype);\n static bool cp_lexer_next_token_is_keyword\n-  PARAMS ((cp_lexer *, enum rid));\n-static cp_token *cp_lexer_consume_token\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *, enum rid);\n+static cp_token *cp_lexer_consume_token \n+  (cp_lexer *);\n static void cp_lexer_purge_token\n   (cp_lexer *);\n static void cp_lexer_purge_tokens_after\n   (cp_lexer *, cp_token *);\n static void cp_lexer_save_tokens\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static void cp_lexer_commit_tokens\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static void cp_lexer_rollback_tokens\n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static inline void cp_lexer_set_source_position_from_token \n-  PARAMS ((cp_lexer *, const cp_token *));\n+  (cp_lexer *, const cp_token *);\n static void cp_lexer_print_token\n-  PARAMS ((FILE *, cp_token *));\n+  (FILE *, cp_token *);\n static inline bool cp_lexer_debugging_p \n-  PARAMS ((cp_lexer *));\n+  (cp_lexer *);\n static void cp_lexer_start_debugging\n-  PARAMS ((cp_lexer *)) ATTRIBUTE_UNUSED;\n+  (cp_lexer *) ATTRIBUTE_UNUSED;\n static void cp_lexer_stop_debugging\n-  PARAMS ((cp_lexer *)) ATTRIBUTE_UNUSED;\n+  (cp_lexer *) ATTRIBUTE_UNUSED;\n \n /* Manifest constants.  */\n \n@@ -398,9 +398,8 @@ cp_lexer_debugging_p (cp_lexer *lexer)\n    TOKEN.  */\n \n static inline void\n-cp_lexer_set_source_position_from_token (lexer, token)\n-     cp_lexer *lexer ATTRIBUTE_UNUSED;\n-     const cp_token *token;\n+cp_lexer_set_source_position_from_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n+                                         const cp_token *token)\n {\n   /* Ideally, the source position information would not be a global\n      variable, but it is.  */\n@@ -417,9 +416,7 @@ cp_lexer_set_source_position_from_token (lexer, token)\n    the next token in the buffer.  */\n \n static inline cp_token *\n-cp_lexer_next_token (lexer, token)\n-     cp_lexer *lexer;\n-     cp_token *token;\n+cp_lexer_next_token (cp_lexer* lexer, cp_token* token)\n {\n   token++;\n   if (token == lexer->buffer_end)\n@@ -430,8 +427,7 @@ cp_lexer_next_token (lexer, token)\n /* Non-zero if we are presently saving tokens.  */\n \n static int\n-cp_lexer_saving_tokens (lexer)\n-     const cp_lexer *lexer;\n+cp_lexer_saving_tokens (const cp_lexer* lexer)\n {\n   return VARRAY_ACTIVE_SIZE (lexer->saved_tokens) != 0;\n }\n@@ -452,10 +448,7 @@ cp_lexer_advance_token (cp_lexer *lexer, cp_token *token, ptrdiff_t n)\n    to reach FINISH.  If START and FINISH are the same, returns zero.  */\n \n static ptrdiff_t\n-cp_lexer_token_difference (lexer, start, finish)\n-     cp_lexer *lexer;\n-     cp_token *start;\n-     cp_token *finish;\n+cp_lexer_token_difference (cp_lexer* lexer, cp_token* start, cp_token* finish)\n {\n   if (finish >= start)\n     return finish - start;\n@@ -468,8 +461,7 @@ cp_lexer_token_difference (lexer, start, finish)\n    token buffer.  Returns the newly read token.  */\n \n static cp_token *\n-cp_lexer_read_token (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_read_token (cp_lexer* lexer)\n {\n   cp_token *token;\n \n@@ -560,8 +552,7 @@ cp_lexer_read_token (lexer)\n /* If the circular buffer is full, make it bigger.  */\n \n static void\n-cp_lexer_maybe_grow_buffer (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_maybe_grow_buffer (cp_lexer* lexer)\n {\n   /* If the buffer is full, enlarge it.  */\n   if (lexer->last_token == lexer->first_token)\n@@ -621,9 +612,8 @@ cp_lexer_maybe_grow_buffer (lexer)\n /* Store the next token from the preprocessor in *TOKEN.  */\n \n static void \n-cp_lexer_get_preprocessor_token (lexer, token)\n-     cp_lexer *lexer ATTRIBUTE_UNUSED;\n-     cp_token *token;\n+cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n+                                 cp_token *token)\n {\n   bool done;\n \n@@ -690,8 +680,7 @@ cp_lexer_get_preprocessor_token (lexer, token)\n    consume it.  */\n \n static cp_token *\n-cp_lexer_peek_token (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_peek_token (cp_lexer* lexer)\n {\n   cp_token *token;\n \n@@ -715,9 +704,7 @@ cp_lexer_peek_token (lexer)\n /* Return true if the next token has the indicated TYPE.  */\n \n static bool\n-cp_lexer_next_token_is (lexer, type)\n-     cp_lexer *lexer;\n-     enum cpp_ttype type;\n+cp_lexer_next_token_is (cp_lexer* lexer, enum cpp_ttype type)\n {\n   cp_token *token;\n \n@@ -730,19 +717,15 @@ cp_lexer_next_token_is (lexer, type)\n /* Return true if the next token does not have the indicated TYPE.  */\n \n static bool\n-cp_lexer_next_token_is_not (lexer, type)\n-     cp_lexer *lexer;\n-     enum cpp_ttype type;\n+cp_lexer_next_token_is_not (cp_lexer* lexer, enum cpp_ttype type)\n {\n   return !cp_lexer_next_token_is (lexer, type);\n }\n \n /* Return true if the next token is the indicated KEYWORD.  */\n \n static bool\n-cp_lexer_next_token_is_keyword (lexer, keyword)\n-     cp_lexer *lexer;\n-     enum rid keyword;\n+cp_lexer_next_token_is_keyword (cp_lexer* lexer, enum rid keyword)\n {\n   cp_token *token;\n \n@@ -756,9 +739,7 @@ cp_lexer_next_token_is_keyword (lexer, keyword)\n    then this is precisely equivalent to cp_lexer_peek_token.  */\n \n static cp_token *\n-cp_lexer_peek_nth_token (lexer, n)\n-     cp_lexer *lexer;\n-     size_t n;\n+cp_lexer_peek_nth_token (cp_lexer* lexer, size_t n)\n {\n   cp_token *token;\n \n@@ -793,8 +774,7 @@ cp_lexer_peek_nth_token (lexer, n)\n    time.  */\n \n static cp_token *\n-cp_lexer_consume_token (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_consume_token (cp_lexer* lexer)\n {\n   cp_token *token;\n \n@@ -901,8 +881,7 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *token)\n    preserved.  */\n \n static void\n-cp_lexer_save_tokens (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_save_tokens (cp_lexer* lexer)\n {\n   /* Provide debugging output.  */\n   if (cp_lexer_debugging_p (lexer))\n@@ -922,8 +901,7 @@ cp_lexer_save_tokens (lexer)\n /* Commit to the portion of the token stream most recently saved.  */\n \n static void\n-cp_lexer_commit_tokens (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_commit_tokens (cp_lexer* lexer)\n {\n   /* Provide debugging output.  */\n   if (cp_lexer_debugging_p (lexer))\n@@ -936,8 +914,7 @@ cp_lexer_commit_tokens (lexer)\n    to the token stream.  Stop saving tokens.  */\n \n static void\n-cp_lexer_rollback_tokens (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_rollback_tokens (cp_lexer* lexer)\n {\n   size_t delta;\n \n@@ -964,9 +941,7 @@ cp_lexer_rollback_tokens (lexer)\n /* Print a representation of the TOKEN on the STREAM.  */\n \n static void\n-cp_lexer_print_token (stream, token)\n-     FILE *stream;\n-     cp_token *token;\n+cp_lexer_print_token (FILE * stream, cp_token* token)\n {\n   const char *token_type = NULL;\n \n@@ -1036,17 +1011,15 @@ cp_lexer_print_token (stream, token)\n /* Start emitting debugging information.  */\n \n static void\n-cp_lexer_start_debugging (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_start_debugging (cp_lexer* lexer)\n {\n   ++lexer->debugging_p;\n }\n   \n /* Stop emitting debugging information.  */\n \n static void\n-cp_lexer_stop_debugging (lexer)\n-     cp_lexer *lexer;\n+cp_lexer_stop_debugging (cp_lexer* lexer)\n {\n   --lexer->debugging_p;\n }\n@@ -1203,7 +1176,7 @@ typedef struct cp_parser_context GTY (())\n /* Constructors and destructors.  */\n \n static cp_parser_context *cp_parser_context_new\n-  PARAMS ((cp_parser_context *));\n+  (cp_parser_context *);\n \n /* Class variables.  */\n \n@@ -1215,8 +1188,7 @@ static GTY((deletable (\"\"))) cp_parser_context* cp_parser_context_free_list;\n    is given by NEXT.  */\n \n static cp_parser_context *\n-cp_parser_context_new (next)\n-     cp_parser_context *next;\n+cp_parser_context_new (cp_parser_context* next)\n {\n   cp_parser_context *context;\n \n@@ -1346,14 +1318,14 @@ typedef struct cp_parser GTY(())\n } cp_parser;\n \n /* The type of a function that parses some kind of expression  */\n-typedef tree (*cp_parser_expression_fn) PARAMS ((cp_parser *));\n+typedef tree (*cp_parser_expression_fn) (cp_parser *);\n \n /* Prototypes.  */\n \n /* Constructors and destructors.  */\n \n static cp_parser *cp_parser_new\n-  PARAMS ((void));\n+  (void);\n \n /* Routines to parse various constructs.  \n \n@@ -1370,21 +1342,21 @@ static cp_parser *cp_parser_new\n /* Lexical conventions [gram.lex]  */\n \n static tree cp_parser_identifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Basic concepts [gram.basic]  */\n \n static bool cp_parser_translation_unit\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Expressions [gram.expr]  */\n \n static tree cp_parser_primary_expression\n   (cp_parser *, cp_parser_id_kind *, tree *);\n static tree cp_parser_id_expression\n-  PARAMS ((cp_parser *, bool, bool, bool *));\n+  (cp_parser *, bool, bool, bool *);\n static tree cp_parser_unqualified_id\n-  PARAMS ((cp_parser *, bool, bool));\n+  (cp_parser *, bool, bool);\n static tree cp_parser_nested_name_specifier_opt\n   (cp_parser *, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n@@ -1394,179 +1366,179 @@ static tree cp_parser_class_or_namespace_name\n static tree cp_parser_postfix_expression\n   (cp_parser *, bool);\n static tree cp_parser_expression_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_pseudo_destructor_name\n-  PARAMS ((cp_parser *, tree *, tree *));\n+  (cp_parser *, tree *, tree *);\n static tree cp_parser_unary_expression\n   (cp_parser *, bool);\n static enum tree_code cp_parser_unary_operator\n-  PARAMS ((cp_token *));\n+  (cp_token *);\n static tree cp_parser_new_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_new_placement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_new_type_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_new_declarator_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_direct_new_declarator\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_new_initializer\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_delete_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_cast_expression \n   (cp_parser *, bool);\n static tree cp_parser_pm_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_multiplicative_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_additive_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_shift_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_relational_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_equality_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_and_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_exclusive_or_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_inclusive_or_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_logical_and_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_logical_or_expression \n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_conditional_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_question_colon_clause\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static tree cp_parser_assignment_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static enum tree_code cp_parser_assignment_operator_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_constant_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Statements [gram.stmt.stmt]  */\n \n static void cp_parser_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_labeled_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_expression_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_compound_statement\n   (cp_parser *);\n static void cp_parser_statement_seq_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_selection_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_condition\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_iteration_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_for_init_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_jump_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_declaration_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n static tree cp_parser_implicitly_scoped_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_already_scoped_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Declarations [gram.dcl.dcl] */\n \n static void cp_parser_declaration_seq_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_declaration\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_block_declaration\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static void cp_parser_simple_declaration\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static tree cp_parser_decl_specifier_seq \n-  PARAMS ((cp_parser *, cp_parser_flags, tree *, bool *));\n+  (cp_parser *, cp_parser_flags, tree *, bool *);\n static tree cp_parser_storage_class_specifier_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_function_specifier_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_type_specifier\n- (cp_parser *, cp_parser_flags, bool, bool, bool *, bool *);\n+  (cp_parser *, cp_parser_flags, bool, bool, bool *, bool *);\n static tree cp_parser_simple_type_specifier\n-  PARAMS ((cp_parser *, cp_parser_flags));\n+  (cp_parser *, cp_parser_flags);\n static tree cp_parser_type_name\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_elaborated_type_specifier\n-  PARAMS ((cp_parser *, bool, bool));\n+  (cp_parser *, bool, bool);\n static tree cp_parser_enum_specifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_enumerator_list\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static void cp_parser_enumerator_definition \n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static tree cp_parser_namespace_name\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_namespace_definition\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_namespace_body\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_qualified_namespace_specifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_namespace_alias_definition\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_using_declaration\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_using_directive\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_asm_definition\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_linkage_specification\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Declarators [gram.dcl.decl] */\n \n static tree cp_parser_init_declarator\n-  PARAMS ((cp_parser *, tree, tree, bool, bool, bool *));\n+  (cp_parser *, tree, tree, bool, bool, bool *);\n static tree cp_parser_declarator\n-  PARAMS ((cp_parser *, cp_parser_declarator_kind, bool *));\n+  (cp_parser *, cp_parser_declarator_kind, bool *);\n static tree cp_parser_direct_declarator\n-  PARAMS ((cp_parser *, cp_parser_declarator_kind, bool *));\n+  (cp_parser *, cp_parser_declarator_kind, bool *);\n static enum tree_code cp_parser_ptr_operator\n-  PARAMS ((cp_parser *, tree *, tree *));\n+  (cp_parser *, tree *, tree *);\n static tree cp_parser_cv_qualifier_seq_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_cv_qualifier_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_declarator_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_type_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_type_specifier_seq\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_parameter_declaration_clause\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_parameter_declaration_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_parameter_declaration\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static tree cp_parser_function_definition\n-  PARAMS ((cp_parser *, bool *));\n+  (cp_parser *, bool *);\n static void cp_parser_function_body\n   (cp_parser *);\n static tree cp_parser_initializer\n-  PARAMS ((cp_parser *, bool *));\n+  (cp_parser *, bool *);\n static tree cp_parser_initializer_clause\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_initializer_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n static bool cp_parser_ctor_initializer_opt_and_function_body\n   (cp_parser *);\n@@ -1576,162 +1548,160 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n static tree cp_parser_class_name\n   (cp_parser *, bool, bool, bool, bool, bool, bool);\n static tree cp_parser_class_specifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_class_head\n-  PARAMS ((cp_parser *, bool *));\n+  (cp_parser *, bool *);\n static enum tag_types cp_parser_class_key\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_member_specification_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_member_declaration\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_pure_specifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_constant_initializer\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Derived classes [gram.class.derived] */\n \n static tree cp_parser_base_clause\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_base_specifier\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Special member functions [gram.special] */\n \n static tree cp_parser_conversion_function_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_conversion_type_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_conversion_declarator_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_ctor_initializer_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_mem_initializer_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_mem_initializer\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_mem_initializer_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Overloading [gram.over] */\n \n static tree cp_parser_operator_function_id\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_operator\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Templates [gram.temp] */\n \n static void cp_parser_template_declaration\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static tree cp_parser_template_parameter_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_template_parameter\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_type_parameter\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_template_id\n-  PARAMS ((cp_parser *, bool, bool));\n+  (cp_parser *, bool, bool);\n static tree cp_parser_template_name\n-  PARAMS ((cp_parser *, bool, bool));\n+  (cp_parser *, bool, bool);\n static tree cp_parser_template_argument_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_template_argument\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_explicit_instantiation\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_explicit_specialization\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Exception handling [gram.exception] */\n \n static tree cp_parser_try_block \n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_function_try_block\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_handler_seq\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_handler\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_exception_declaration\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_throw_expression\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_exception_specification_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_type_id_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* GNU Extensions */\n \n static tree cp_parser_asm_specification_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_asm_operand_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_asm_clobber_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_attributes_opt\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static tree cp_parser_attribute_list\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_extension_opt\n-  PARAMS ((cp_parser *, int *));\n+  (cp_parser *, int *);\n static void cp_parser_label_declaration\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n \n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  PARAMS ((cp_parser *, tree, bool, bool, bool, bool));\n+  (cp_parser *, tree, bool, bool, bool, bool);\n static tree cp_parser_lookup_name_simple\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static tree cp_parser_resolve_typename_type\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n   (tree, bool);\n static bool cp_parser_check_declarator_template_parameters\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static bool cp_parser_check_template_parameters\n-  PARAMS ((cp_parser *, unsigned));\n+  (cp_parser *, unsigned);\n static tree cp_parser_binary_expression\n-  PARAMS ((cp_parser *, \n-\t   const cp_parser_token_tree_map,\n-\t   cp_parser_expression_fn));\n+  (cp_parser *, const cp_parser_token_tree_map, cp_parser_expression_fn);\n static tree cp_parser_global_scope_opt\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static bool cp_parser_constructor_declarator_p\n   (cp_parser *, bool);\n static tree cp_parser_function_definition_from_specifiers_and_declarator\n-  PARAMS ((cp_parser *, tree, tree, tree));\n+  (cp_parser *, tree, tree, tree);\n static tree cp_parser_function_definition_after_declarator\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static void cp_parser_template_declaration_after_export\n-  PARAMS ((cp_parser *, bool));\n+  (cp_parser *, bool);\n static tree cp_parser_single_declaration\n-  PARAMS ((cp_parser *, bool, bool *));\n+  (cp_parser *, bool, bool *);\n static tree cp_parser_functional_cast\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static void cp_parser_late_parsing_for_member\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree);\n static void cp_parser_late_parsing_default_args\n   (cp_parser *, tree);\n static tree cp_parser_sizeof_operand\n-  PARAMS ((cp_parser *, enum rid));\n+  (cp_parser *, enum rid);\n static bool cp_parser_declares_only_class_p\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_friend_p\n-  PARAMS ((tree));\n+  (tree);\n static cp_token *cp_parser_require\n-  PARAMS ((cp_parser *, enum cpp_ttype, const char *));\n+  (cp_parser *, enum cpp_ttype, const char *);\n static cp_token *cp_parser_require_keyword\n-  PARAMS ((cp_parser *, enum rid, const char *));\n+  (cp_parser *, enum rid, const char *);\n static bool cp_parser_token_starts_function_definition_p \n-  PARAMS ((cp_token *));\n+  (cp_token *);\n static bool cp_parser_next_token_starts_class_definition_p\n   (cp_parser *);\n static enum tag_types cp_parser_token_is_class_key\n-  PARAMS ((cp_token *));\n+  (cp_token *);\n static void cp_parser_check_class_key\n   (enum tag_types, tree type);\n static bool cp_parser_optional_template_keyword\n@@ -1741,74 +1711,70 @@ static void cp_parser_pre_parsed_nested_name_specifier\n static void cp_parser_cache_group\n   (cp_parser *, cp_token_cache *, enum cpp_ttype, unsigned);\n static void cp_parser_parse_tentatively \n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_commit_to_tentative_parse\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_abort_tentative_parse\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_parse_definitely\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static inline bool cp_parser_parsing_tentatively\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_committed_to_tentative_parse\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_error\n-  PARAMS ((cp_parser *, const char *));\n+  (cp_parser *, const char *);\n static bool cp_parser_simulate_error\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_check_type_definition\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_diagnose_invalid_type_name\n   (cp_parser *);\n static bool cp_parser_skip_to_closing_parenthesis\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_skip_to_closing_parenthesis_or_comma\n   (cp_parser *);\n static void cp_parser_skip_to_end_of_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_consume_semicolon_at_end_of_statement\n   (cp_parser *);\n static void cp_parser_skip_to_end_of_block_or_statement\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static void cp_parser_skip_to_closing_brace\n   (cp_parser *);\n static void cp_parser_skip_until_found\n-  PARAMS ((cp_parser *, enum cpp_ttype, const char *));\n+  (cp_parser *, enum cpp_ttype, const char *);\n static bool cp_parser_error_occurred\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_allow_gnu_extensions_p\n-  PARAMS ((cp_parser *));\n+  (cp_parser *);\n static bool cp_parser_is_string_literal\n-  PARAMS ((cp_token *));\n+  (cp_token *);\n static bool cp_parser_is_keyword \n-  PARAMS ((cp_token *, enum rid));\n+  (cp_token *, enum rid);\n static tree cp_parser_scope_through_which_access_occurs\n   (tree, tree, tree);\n \n /* Returns non-zero if we are parsing tentatively.  */\n \n static inline bool\n-cp_parser_parsing_tentatively (parser)\n-     cp_parser *parser;\n+cp_parser_parsing_tentatively (cp_parser* parser)\n {\n   return parser->context->next != NULL;\n }\n \n /* Returns non-zero if TOKEN is a string literal.  */\n \n static bool\n-cp_parser_is_string_literal (token)\n-     cp_token *token;\n+cp_parser_is_string_literal (cp_token* token)\n {\n   return (token->type == CPP_STRING || token->type == CPP_WSTRING);\n }\n \n /* Returns non-zero if TOKEN is the indicated KEYWORD.  */\n \n static bool\n-cp_parser_is_keyword (token, keyword)\n-     cp_token *token;\n-     enum rid keyword;\n+cp_parser_is_keyword (cp_token* token, enum rid keyword)\n {\n   return token->keyword == keyword;\n }\n@@ -1820,12 +1786,9 @@ cp_parser_is_keyword (token, keyword)\n    NESTED_NAME_SPECIFIER is `A'.  */\n \n tree\n-cp_parser_scope_through_which_access_occurs (decl, \n-\t\t\t\t\t     object_type,\n-\t\t\t\t\t     nested_name_specifier)\n-     tree decl;\n-     tree object_type;\n-     tree nested_name_specifier;\n+cp_parser_scope_through_which_access_occurs (tree decl, \n+\t\t\t\t\t     tree object_type,\n+\t\t\t\t\t     tree nested_name_specifier)\n {\n   tree scope;\n   tree qualifying_type = NULL_TREE;\n@@ -1875,9 +1838,7 @@ cp_parser_scope_through_which_access_occurs (decl,\n /* Issue the indicated error MESSAGE.  */\n \n static void\n-cp_parser_error (parser, message)\n-     cp_parser *parser;\n-     const char *message;\n+cp_parser_error (cp_parser* parser, const char* message)\n {\n   /* Output the MESSAGE -- unless we're parsing tentatively.  */\n   if (!cp_parser_simulate_error (parser))\n@@ -1889,8 +1850,7 @@ cp_parser_error (parser, message)\n    simulated; false if a messgae should be issued by the caller.  */\n \n static bool\n-cp_parser_simulate_error (parser)\n-     cp_parser *parser;\n+cp_parser_simulate_error (cp_parser* parser)\n {\n   if (cp_parser_parsing_tentatively (parser)\n       && !cp_parser_committed_to_tentative_parse (parser))\n@@ -1906,8 +1866,7 @@ cp_parser_simulate_error (parser)\n    issued.  */\n \n static void\n-cp_parser_check_type_definition (parser)\n-     cp_parser *parser;\n+cp_parser_check_type_definition (cp_parser* parser)\n {\n   /* If types are forbidden here, issue a message.  */\n   if (parser->type_definition_forbidden_message)\n@@ -2053,8 +2012,7 @@ cp_parser_skip_to_closing_parenthesis_or_comma (cp_parser *parser)\n    non-nested `}' comes first, then we stop before consuming that.  */\n \n static void\n-cp_parser_skip_to_end_of_statement (parser)\n-     cp_parser *parser;\n+cp_parser_skip_to_end_of_statement (cp_parser* parser)\n {\n   unsigned nesting_depth = 0;\n \n@@ -2132,8 +2090,7 @@ cp_parser_consume_semicolon_at_end_of_statement (cp_parser *parser)\n    have consumed a non-nested `;'.  */\n \n static void\n-cp_parser_skip_to_end_of_block_or_statement (parser)\n-     cp_parser *parser;\n+cp_parser_skip_to_end_of_block_or_statement (cp_parser* parser)\n {\n   unsigned nesting_depth = 0;\n \n@@ -2201,7 +2158,7 @@ cp_parser_skip_to_closing_brace (cp_parser *parser)\n /* Create a new C++ parser.  */\n \n static cp_parser *\n-cp_parser_new ()\n+cp_parser_new (void)\n {\n   cp_parser *parser;\n   cp_lexer *lexer;\n@@ -2253,8 +2210,7 @@ cp_parser_new ()\n    identifier.  */\n \n static tree \n-cp_parser_identifier (parser)\n-     cp_parser *parser;\n+cp_parser_identifier (cp_parser* parser)\n {\n   cp_token *token;\n \n@@ -2274,8 +2230,7 @@ cp_parser_identifier (parser)\n    Returns TRUE if all went well.  */\n \n static bool\n-cp_parser_translation_unit (parser)\n-     cp_parser *parser;\n+cp_parser_translation_unit (cp_parser* parser)\n {\n   while (true)\n     {\n@@ -2943,11 +2898,9 @@ cp_parser_id_expression (cp_parser *parser,\n    names are looked up in uninstantiated templates.  */\n \n static tree\n-cp_parser_unqualified_id (parser, template_keyword_p,\n-\t\t\t  check_dependency_p)\n-     cp_parser *parser;\n-     bool template_keyword_p;\n-     bool check_dependency_p;\n+cp_parser_unqualified_id (cp_parser* parser, \n+                          bool template_keyword_p,\n+\t\t\t  bool check_dependency_p)\n {\n   cp_token *token;\n \n@@ -4121,8 +4074,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n    is returned even if there is only a single expression in the list.  */\n \n static tree\n-cp_parser_expression_list (parser)\n-     cp_parser *parser;\n+cp_parser_expression_list (cp_parser* parser)\n {\n   tree expression_list = NULL_TREE;\n \n@@ -4171,10 +4123,9 @@ cp_parser_expression_list (parser)\n    or ERROR_MARK_NODE if no type-name is present.  */\n \n static void\n-cp_parser_pseudo_destructor_name (parser, scope, type)\n-     cp_parser *parser;\n-     tree *scope;\n-     tree *type;\n+cp_parser_pseudo_destructor_name (cp_parser* parser, \n+                                  tree* scope, \n+                                  tree* type)\n {\n   bool nested_name_specifier_p;\n \n@@ -4419,8 +4370,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n    unary-operator, the corresponding tree code is returned.  */\n \n static enum tree_code\n-cp_parser_unary_operator (token)\n-     cp_token *token;\n+cp_parser_unary_operator (cp_token* token)\n {\n   switch (token->type)\n     {\n@@ -4455,8 +4405,7 @@ cp_parser_unary_operator (token)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_new_expression (parser)\n-     cp_parser *parser;\n+cp_parser_new_expression (cp_parser* parser)\n {\n   bool global_scope_p;\n   tree placement;\n@@ -4512,8 +4461,7 @@ cp_parser_new_expression (parser)\n    Returns the same representation as for an expression-list.  */\n \n static tree\n-cp_parser_new_placement (parser)\n-     cp_parser *parser;\n+cp_parser_new_placement (cp_parser* parser)\n {\n   tree expression_list;\n \n@@ -4537,8 +4485,7 @@ cp_parser_new_placement (parser)\n    and whose TREE_VALUE is the new-declarator.  */\n \n static tree\n-cp_parser_new_type_id (parser)\n-     cp_parser *parser;\n+cp_parser_new_type_id (cp_parser* parser)\n {\n   tree type_specifier_seq;\n   tree declarator;\n@@ -4571,8 +4518,7 @@ cp_parser_new_type_id (parser)\n    cp_parser_declarator for the representations used.  */\n \n static tree\n-cp_parser_new_declarator_opt (parser)\n-     cp_parser *parser;\n+cp_parser_new_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n   tree type;\n@@ -4622,8 +4568,7 @@ cp_parser_new_declarator_opt (parser)\n    documented for cp_parser_direct_declarator.  */\n \n static tree\n-cp_parser_direct_new_declarator (parser)\n-     cp_parser *parser;\n+cp_parser_direct_new_declarator (cp_parser* parser)\n {\n   tree declarator = NULL_TREE;\n \n@@ -4683,8 +4628,7 @@ cp_parser_direct_new_declarator (parser)\n    expression-list, VOID_ZERO_NODE is returned.  */\n \n static tree\n-cp_parser_new_initializer (parser)\n-     cp_parser *parser;\n+cp_parser_new_initializer (cp_parser* parser)\n {\n   tree expression_list;\n \n@@ -4711,8 +4655,7 @@ cp_parser_new_initializer (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_delete_expression (parser)\n-     cp_parser *parser;\n+cp_parser_delete_expression (cp_parser* parser)\n {\n   bool global_scope_p;\n   bool array_p;\n@@ -4848,8 +4791,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n      Returns a representation of the expression.  */\n \n static tree\n-cp_parser_pm_expression (parser)\n-     cp_parser *parser;\n+cp_parser_pm_expression (cp_parser* parser)\n {\n   tree cast_expr;\n   tree pm_expr;\n@@ -4900,8 +4842,7 @@ cp_parser_pm_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_multiplicative_expression (parser)\n-     cp_parser *parser;\n+cp_parser_multiplicative_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_MULT, MULT_EXPR },\n@@ -4925,8 +4866,7 @@ cp_parser_multiplicative_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_additive_expression (parser)\n-     cp_parser *parser;\n+cp_parser_additive_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_PLUS, PLUS_EXPR },\n@@ -4949,8 +4889,7 @@ cp_parser_additive_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_shift_expression (parser)\n-     cp_parser *parser;\n+cp_parser_shift_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_LSHIFT, LSHIFT_EXPR },\n@@ -4981,8 +4920,7 @@ cp_parser_shift_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_relational_expression (parser)\n-     cp_parser *parser;\n+cp_parser_relational_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_LESS, LT_EXPR },\n@@ -5009,8 +4947,7 @@ cp_parser_relational_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_equality_expression (parser)\n-     cp_parser *parser;\n+cp_parser_equality_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_EQ_EQ, EQ_EXPR },\n@@ -5032,8 +4969,7 @@ cp_parser_equality_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_and_expression (parser)\n-     cp_parser *parser;\n+cp_parser_and_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_AND, BIT_AND_EXPR },\n@@ -5054,8 +4990,7 @@ cp_parser_and_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_exclusive_or_expression (parser)\n-     cp_parser *parser;\n+cp_parser_exclusive_or_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_XOR, BIT_XOR_EXPR },\n@@ -5077,8 +5012,7 @@ cp_parser_exclusive_or_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_inclusive_or_expression (parser)\n-     cp_parser *parser;\n+cp_parser_inclusive_or_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_OR, BIT_IOR_EXPR },\n@@ -5099,8 +5033,7 @@ cp_parser_inclusive_or_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_logical_and_expression (parser)\n-     cp_parser *parser;\n+cp_parser_logical_and_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_AND_AND, TRUTH_ANDIF_EXPR },\n@@ -5121,8 +5054,7 @@ cp_parser_logical_and_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_logical_or_expression (parser)\n-     cp_parser *parser;\n+cp_parser_logical_or_expression (cp_parser* parser)\n {\n   static const cp_parser_token_tree_map map = {\n     { CPP_OR_OR, TRUTH_ORIF_EXPR },\n@@ -5148,8 +5080,7 @@ cp_parser_logical_or_expression (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_conditional_expression (parser)\n-     cp_parser *parser;\n+cp_parser_conditional_expression (cp_parser* parser)\n {\n   tree logical_or_expr;\n \n@@ -5180,9 +5111,7 @@ cp_parser_conditional_expression (parser)\n      ? : assignment-expression */\n \n static tree\n-cp_parser_question_colon_clause (parser, logical_or_expr)\n-     cp_parser *parser;\n-     tree logical_or_expr;\n+cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n {\n   tree expr;\n   tree assignment_expr;\n@@ -5218,8 +5147,7 @@ cp_parser_question_colon_clause (parser, logical_or_expr)\n    Returns a representation for the expression.  */\n \n static tree\n-cp_parser_assignment_expression (parser)\n-     cp_parser *parser;\n+cp_parser_assignment_expression (cp_parser* parser)\n {\n   tree expr;\n \n@@ -5280,8 +5208,7 @@ cp_parser_assignment_expression (parser)\n    operator, ERROR_MARK is returned.  */\n \n static enum tree_code\n-cp_parser_assignment_operator_opt (parser)\n-     cp_parser *parser;\n+cp_parser_assignment_operator_opt (cp_parser* parser)\n {\n   enum tree_code op;\n   cp_token *token;\n@@ -5364,8 +5291,7 @@ cp_parser_assignment_operator_opt (parser)\n    Returns a representation of the expression.  */\n \n static tree\n-cp_parser_expression (parser)\n-     cp_parser *parser;\n+cp_parser_expression (cp_parser* parser)\n {\n   tree expression = NULL_TREE;\n   bool saw_comma_p = false;\n@@ -5422,8 +5348,7 @@ cp_parser_expression (parser)\n      conditional-expression  */\n \n static tree\n-cp_parser_constant_expression (parser)\n-     cp_parser *parser;\n+cp_parser_constant_expression (cp_parser* parser)\n {\n   bool saved_constant_expression_p;\n   tree expression;\n@@ -5472,8 +5397,7 @@ cp_parser_constant_expression (parser)\n      try-block  */\n \n static void\n-cp_parser_statement (parser)\n-     cp_parser *parser;\n+cp_parser_statement (cp_parser* parser)\n {\n   tree statement;\n   cp_token *token;\n@@ -5573,8 +5497,7 @@ cp_parser_statement (parser)\n    an ordinary label, returns a LABEL_STMT.  */\n \n static tree\n-cp_parser_labeled_statement (parser)\n-     cp_parser *parser;\n+cp_parser_labeled_statement (cp_parser* parser)\n {\n   cp_token *token;\n   tree statement = NULL_TREE;\n@@ -5634,8 +5557,7 @@ cp_parser_labeled_statement (parser)\n    statement consists of nothing more than an `;'.  */\n \n static tree\n-cp_parser_expression_statement (parser)\n-     cp_parser *parser;\n+cp_parser_expression_statement (cp_parser* parser)\n {\n   tree statement;\n \n@@ -5688,8 +5610,7 @@ cp_parser_compound_statement (cp_parser *parser)\n      statement-seq [opt] statement  */\n \n static void\n-cp_parser_statement_seq_opt (parser)\n-     cp_parser *parser;\n+cp_parser_statement_seq_opt (cp_parser* parser)\n {\n   /* Scan statements until there aren't any more.  */\n   while (true)\n@@ -5714,8 +5635,7 @@ cp_parser_statement_seq_opt (parser)\n    Returns the new IF_STMT or SWITCH_STMT.  */\n \n static tree\n-cp_parser_selection_statement (parser)\n-     cp_parser *parser;\n+cp_parser_selection_statement (cp_parser* parser)\n {\n   cp_token *token;\n   enum rid keyword;\n@@ -5819,8 +5739,7 @@ cp_parser_selection_statement (parser)\n    Returns the expression that should be tested.  */\n \n static tree\n-cp_parser_condition (parser)\n-     cp_parser *parser;\n+cp_parser_condition (cp_parser* parser)\n {\n   tree type_specifiers;\n   const char *saved_message;\n@@ -5900,8 +5819,7 @@ cp_parser_condition (parser)\n    Returns the new WHILE_STMT, DO_STMT, or FOR_STMT.  */\n \n static tree\n-cp_parser_iteration_statement (parser)\n-     cp_parser *parser;\n+cp_parser_iteration_statement (cp_parser* parser)\n {\n   cp_token *token;\n   enum rid keyword;\n@@ -6011,8 +5929,7 @@ cp_parser_iteration_statement (parser)\n      simple-declaration  */\n \n static void\n-cp_parser_for_init_statement (parser)\n-     cp_parser *parser;\n+cp_parser_for_init_statement (cp_parser* parser)\n {\n   /* If the next token is a `;', then we have an empty\n      expression-statement.  Gramatically, this is also a\n@@ -6054,8 +5971,7 @@ cp_parser_for_init_statement (parser)\n    GOTO_STMT.  */\n \n static tree\n-cp_parser_jump_statement (parser)\n-     cp_parser *parser;\n+cp_parser_jump_statement (cp_parser* parser)\n {\n   tree statement = error_mark_node;\n   cp_token *token;\n@@ -6129,8 +6045,7 @@ cp_parser_jump_statement (parser)\n      block-declaration  */\n \n static void\n-cp_parser_declaration_statement (parser)\n-     cp_parser *parser;\n+cp_parser_declaration_statement (cp_parser* parser)\n {\n   /* Parse the block-declaration.  */\n   cp_parser_block_declaration (parser, /*statement_p=*/true);\n@@ -6151,8 +6066,7 @@ cp_parser_declaration_statement (parser)\n    Returns the new statement.  */\n \n static tree\n-cp_parser_implicitly_scoped_statement (parser)\n-     cp_parser *parser;\n+cp_parser_implicitly_scoped_statement (cp_parser* parser)\n {\n   tree statement;\n \n@@ -6180,8 +6094,7 @@ cp_parser_implicitly_scoped_statement (parser)\n    scope.  */\n \n static void\n-cp_parser_already_scoped_statement (parser)\n-     cp_parser *parser;\n+cp_parser_already_scoped_statement (cp_parser* parser)\n {\n   /* If the token is not a `{', then we must take special action.  */\n   if (cp_lexer_next_token_is_not(parser->lexer, CPP_OPEN_BRACE))\n@@ -6209,8 +6122,7 @@ cp_parser_already_scoped_statement (parser)\n      declaration-seq declaration  */\n \n static void\n-cp_parser_declaration_seq_opt (parser)\n-     cp_parser *parser;\n+cp_parser_declaration_seq_opt (cp_parser* parser)\n {\n   while (true)\n     {\n@@ -6267,8 +6179,7 @@ cp_parser_declaration_seq_opt (parser)\n       __extension__ declaration */\n \n static void\n-cp_parser_declaration (parser)\n-     cp_parser *parser;\n+cp_parser_declaration (cp_parser* parser)\n {\n   cp_token token1;\n   cp_token token2;\n@@ -6434,9 +6345,8 @@ cp_parser_block_declaration (cp_parser *parser,\n    function-definition as a simple-declaration.   */\n \n static void\n-cp_parser_simple_declaration (parser, function_definition_allowed_p)\n-     cp_parser *parser;\n-     bool function_definition_allowed_p;\n+cp_parser_simple_declaration (cp_parser* parser, \n+                              bool function_definition_allowed_p)\n {\n   tree decl_specifiers;\n   tree attributes;\n@@ -6604,12 +6514,10 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n    friendship is granted might not be a class.  */\n \n static tree\n-cp_parser_decl_specifier_seq (parser, flags, attributes,\n-\t\t\t      declares_class_or_enum)\n-     cp_parser *parser;\n-     cp_parser_flags flags;\n-     tree *attributes;\n-     bool *declares_class_or_enum;\n+cp_parser_decl_specifier_seq (cp_parser* parser, \n+                              cp_parser_flags flags, \n+                              tree* attributes,\n+\t\t\t      bool* declares_class_or_enum)\n {\n   tree decl_specs = NULL_TREE;\n   bool friend_p = false;\n@@ -6809,8 +6717,7 @@ cp_parser_decl_specifier_seq (parser, flags, attributes,\n    Returns an IDENTIFIER_NODE corresponding to the keyword used.  */\n    \n static tree\n-cp_parser_storage_class_specifier_opt (parser)\n-     cp_parser *parser;\n+cp_parser_storage_class_specifier_opt (cp_parser* parser)\n {\n   switch (cp_lexer_peek_token (parser->lexer)->keyword)\n     {\n@@ -6838,8 +6745,7 @@ cp_parser_storage_class_specifier_opt (parser)\n    Returns an IDENTIFIER_NODE corresponding to the keyword used.  */\n    \n static tree\n-cp_parser_function_specifier_opt (parser)\n-     cp_parser *parser;\n+cp_parser_function_specifier_opt (cp_parser* parser)\n {\n   switch (cp_lexer_peek_token (parser->lexer)->keyword)\n     {\n@@ -6861,8 +6767,7 @@ cp_parser_function_specifier_opt (parser)\n      extern string-literal declaration  */\n \n static void\n-cp_parser_linkage_specification (parser)\n-     cp_parser *parser;\n+cp_parser_linkage_specification (cp_parser* parser)\n {\n   cp_token *token;\n   tree linkage;\n@@ -6939,8 +6844,7 @@ cp_parser_linkage_specification (parser)\n    Returns an IDENTIFIER_NODE representing the operator.  */\n \n static tree \n-cp_parser_conversion_function_id (parser)\n-     cp_parser *parser;\n+cp_parser_conversion_function_id (cp_parser* parser)\n {\n   tree type;\n   tree saved_scope;\n@@ -6994,8 +6898,7 @@ cp_parser_conversion_function_id (parser)\n    Returns the TYPE specified.  */\n \n static tree\n-cp_parser_conversion_type_id (parser)\n-     cp_parser *parser;\n+cp_parser_conversion_type_id (cp_parser* parser)\n {\n   tree attributes;\n   tree type_specifiers;\n@@ -7024,8 +6927,7 @@ cp_parser_conversion_type_id (parser)\n    cp_parser_declarator for details.  */\n \n static tree\n-cp_parser_conversion_declarator_opt (parser)\n-     cp_parser *parser;\n+cp_parser_conversion_declarator_opt (cp_parser* parser)\n {\n   enum tree_code code;\n   tree class_type;\n@@ -7070,8 +6972,7 @@ cp_parser_conversion_declarator_opt (parser)\n    Returns TRUE iff the ctor-initializer was actually present.  */\n \n static bool\n-cp_parser_ctor_initializer_opt (parser)\n-     cp_parser *parser;\n+cp_parser_ctor_initializer_opt (cp_parser* parser)\n {\n   /* If the next token is not a `:', then there is no\n      ctor-initializer.  */\n@@ -7099,8 +7000,7 @@ cp_parser_ctor_initializer_opt (parser)\n      mem-initializer , mem-initializer-list  */\n \n static void\n-cp_parser_mem_initializer_list (parser)\n-     cp_parser *parser;\n+cp_parser_mem_initializer_list (cp_parser* parser)\n {\n   tree mem_initializer_list = NULL_TREE;\n \n@@ -7147,8 +7047,7 @@ cp_parser_mem_initializer_list (parser)\n    the TREE_VALUE is the expression-list.  */\n \n static tree\n-cp_parser_mem_initializer (parser)\n-     cp_parser *parser;\n+cp_parser_mem_initializer (cp_parser* parser)\n {\n   tree mem_initializer_id;\n   tree expression_list;\n@@ -7187,8 +7086,7 @@ cp_parser_mem_initializer (parser)\n    to be initialized for the second production.  */\n \n static tree\n-cp_parser_mem_initializer_id (parser)\n-     cp_parser *parser;\n+cp_parser_mem_initializer_id (cp_parser* parser)\n {\n   bool global_scope_p;\n   bool nested_name_specifier_p;\n@@ -7255,8 +7153,7 @@ cp_parser_mem_initializer_id (parser)\n    human-readable spelling of the identifier, e.g., `operator +'.  */\n \n static tree \n-cp_parser_operator_function_id (parser)\n-     cp_parser *parser;\n+cp_parser_operator_function_id (cp_parser* parser)\n {\n   /* Look for the `operator' keyword.  */\n   if (!cp_parser_require_keyword (parser, RID_OPERATOR, \"`operator'\"))\n@@ -7281,8 +7178,7 @@ cp_parser_operator_function_id (parser)\n    human-readable spelling of the identifier, e.g., `operator +'.  */\n    \n static tree\n-cp_parser_operator (parser)\n-     cp_parser *parser;\n+cp_parser_operator (cp_parser* parser)\n {\n   tree id = NULL_TREE;\n   cp_token *token;\n@@ -7543,9 +7439,7 @@ cp_parser_operator (parser)\n      template < template-parameter-list >  */\n \n static void\n-cp_parser_template_declaration (parser, member_p)\n-     cp_parser *parser;\n-     bool member_p;\n+cp_parser_template_declaration (cp_parser* parser, bool member_p)\n {\n   /* Check for `export'.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_EXPORT))\n@@ -7569,8 +7463,7 @@ cp_parser_template_declaration (parser, member_p)\n    The nodes are connected via their TREE_CHAINs.  */\n \n static tree\n-cp_parser_template_parameter_list (parser)\n-     cp_parser *parser;\n+cp_parser_template_parameter_list (cp_parser* parser)\n {\n   tree parameter_list = NULL_TREE;\n \n@@ -7607,8 +7500,7 @@ cp_parser_template_parameter_list (parser)\n    TREE_PURPOSE is the default value, if any.  */\n \n static tree\n-cp_parser_template_parameter (parser)\n-     cp_parser *parser;\n+cp_parser_template_parameter (cp_parser* parser)\n {\n   cp_token *token;\n \n@@ -7673,8 +7565,7 @@ cp_parser_template_parameter (parser)\n    the declaration of the parameter.  */\n \n static tree\n-cp_parser_type_parameter (parser)\n-     cp_parser *parser;\n+cp_parser_type_parameter (cp_parser* parser)\n {\n   cp_token *token;\n   tree parameter;\n@@ -7989,10 +7880,9 @@ cp_parser_template_id (cp_parser *parser,\n    names are looked up inside uninstantiated templates.  */\n \n static tree\n-cp_parser_template_name (parser, template_keyword_p, check_dependency_p)\n-     cp_parser *parser;\n-     bool template_keyword_p;\n-     bool check_dependency_p;\n+cp_parser_template_name (cp_parser* parser, \n+                         bool template_keyword_p, \n+                         bool check_dependency_p)\n {\n   tree identifier;\n   tree decl;\n@@ -8092,8 +7982,7 @@ cp_parser_template_name (parser, template_keyword_p, check_dependency_p)\n    argument.  */\n \n static tree\n-cp_parser_template_argument_list (parser)\n-     cp_parser *parser;\n+cp_parser_template_argument_list (cp_parser* parser)\n {\n   tree arguments = NULL_TREE;\n \n@@ -8129,8 +8018,7 @@ cp_parser_template_argument_list (parser)\n    OVERLOAD.  */\n \n static tree\n-cp_parser_template_argument (parser)\n-     cp_parser *parser;\n+cp_parser_template_argument (cp_parser* parser)\n {\n   tree argument;\n   bool template_p;\n@@ -8207,8 +8095,7 @@ cp_parser_template_argument (parser)\n        decl-specifier-seq [opt] declarator [opt] ;  */\n \n static void\n-cp_parser_explicit_instantiation (parser)\n-     cp_parser *parser;\n+cp_parser_explicit_instantiation (cp_parser* parser)\n {\n   bool declares_class_or_enum;\n   tree decl_specifiers;\n@@ -8286,8 +8173,7 @@ cp_parser_explicit_instantiation (parser)\n      template <> template-declaration  */\n \n static void\n-cp_parser_explicit_specialization (parser)\n-     cp_parser *parser;\n+cp_parser_explicit_specialization (cp_parser* parser)\n {\n   /* Look for the `template' keyword.  */\n   cp_parser_require_keyword (parser, RID_TEMPLATE, \"`template'\");\n@@ -8357,18 +8243,12 @@ cp_parser_explicit_specialization (parser)\n    is set to FALSE.  */\n \n static tree\n-cp_parser_type_specifier (parser, \n-\t\t\t  flags, \n-\t\t\t  is_friend,\n-\t\t\t  is_declaration,\n-\t\t\t  declares_class_or_enum,\n-\t\t\t  is_cv_qualifier)\n-     cp_parser *parser;\n-     cp_parser_flags flags;\n-     bool is_friend;\n-     bool is_declaration;\n-     bool *declares_class_or_enum;\n-     bool *is_cv_qualifier;\n+cp_parser_type_specifier (cp_parser* parser, \n+\t\t\t  cp_parser_flags flags, \n+\t\t\t  bool is_friend,\n+\t\t\t  bool is_declaration,\n+\t\t\t  bool* declares_class_or_enum,\n+\t\t\t  bool* is_cv_qualifier)\n {\n   tree type_spec = NULL_TREE;\n   cp_token *token;\n@@ -8488,9 +8368,7 @@ cp_parser_type_specifier (parser,\n    productions, the value returned is the indicated TYPE_DECL.  */\n \n static tree\n-cp_parser_simple_type_specifier (parser, flags)\n-     cp_parser *parser;\n-     cp_parser_flags flags;\n+cp_parser_simple_type_specifier (cp_parser* parser, cp_parser_flags flags)\n {\n   tree type = NULL_TREE;\n   cp_token *token;\n@@ -8607,8 +8485,7 @@ cp_parser_simple_type_specifier (parser, flags)\n    Returns a TYPE_DECL for the the type.  */\n \n static tree\n-cp_parser_type_name (parser)\n-     cp_parser *parser;\n+cp_parser_type_name (cp_parser* parser)\n {\n   tree type_decl;\n   tree identifier;\n@@ -8671,10 +8548,9 @@ cp_parser_type_name (parser)\n    Returns the TYPE specified.  */\n \n static tree\n-cp_parser_elaborated_type_specifier (parser, is_friend, is_declaration)\n-     cp_parser *parser;\n-     bool is_friend;\n-     bool is_declaration;\n+cp_parser_elaborated_type_specifier (cp_parser* parser, \n+                                     bool is_friend, \n+                                     bool is_declaration)\n {\n   enum tag_types tag_type;\n   tree identifier;\n@@ -8868,8 +8744,7 @@ cp_parser_elaborated_type_specifier (parser, is_friend, is_declaration)\n    Returns an ENUM_TYPE representing the enumeration.  */\n \n static tree\n-cp_parser_enum_specifier (parser)\n-     cp_parser *parser;\n+cp_parser_enum_specifier (cp_parser* parser)\n {\n   cp_token *token;\n   tree identifier = NULL_TREE;\n@@ -8921,9 +8796,7 @@ cp_parser_enum_specifier (parser)\n      enumerator-list , enumerator-definition  */\n \n static void\n-cp_parser_enumerator_list (parser, type)\n-     cp_parser *parser;\n-     tree type;\n+cp_parser_enumerator_list (cp_parser* parser, tree type)\n {\n   while (true)\n     {\n@@ -8960,9 +8833,7 @@ cp_parser_enumerator_list (parser, type)\n      identifier  */\n \n static void\n-cp_parser_enumerator_definition (parser, type)\n-     cp_parser *parser;\n-     tree type;\n+cp_parser_enumerator_definition (cp_parser* parser, tree type)\n {\n   cp_token *token;\n   tree identifier;\n@@ -8999,8 +8870,7 @@ cp_parser_enumerator_definition (parser, type)\n    Returns the NAMESPACE_DECL for the namespace.  */\n \n static tree\n-cp_parser_namespace_name (parser)\n-     cp_parser *parser;\n+cp_parser_namespace_name (cp_parser* parser)\n {\n   tree identifier;\n   tree namespace_decl;\n@@ -9064,8 +8934,7 @@ cp_parser_namespace_name (parser)\n      namespace { namespace-body } */\n \n static void\n-cp_parser_namespace_definition (parser)\n-     cp_parser *parser;\n+cp_parser_namespace_definition (cp_parser* parser)\n {\n   tree identifier;\n \n@@ -9099,8 +8968,7 @@ cp_parser_namespace_definition (parser)\n      declaration-seq [opt]  */\n \n static void\n-cp_parser_namespace_body (parser)\n-     cp_parser *parser;\n+cp_parser_namespace_body (cp_parser* parser)\n {\n   cp_parser_declaration_seq_opt (parser);\n }\n@@ -9111,8 +8979,7 @@ cp_parser_namespace_body (parser)\n      namespace identifier = qualified-namespace-specifier ;  */\n \n static void\n-cp_parser_namespace_alias_definition (parser)\n-     cp_parser *parser;\n+cp_parser_namespace_alias_definition (cp_parser* parser)\n {\n   tree identifier;\n   tree namespace_specifier;\n@@ -9144,8 +9011,7 @@ cp_parser_namespace_alias_definition (parser)\n    namespace.  */\n \n static tree\n-cp_parser_qualified_namespace_specifier (parser)\n-     cp_parser *parser;\n+cp_parser_qualified_namespace_specifier (cp_parser* parser)\n {\n   /* Look for the optional `::'.  */\n   cp_parser_global_scope_opt (parser, \n@@ -9167,8 +9033,7 @@ cp_parser_qualified_namespace_specifier (parser)\n      using :: unqualified-id ;  */\n \n static void\n-cp_parser_using_declaration (parser)\n-     cp_parser *parser;\n+cp_parser_using_declaration (cp_parser* parser)\n {\n   cp_token *token;\n   bool typename_p = false;\n@@ -9256,8 +9121,7 @@ cp_parser_using_declaration (parser)\n        namespace-name ;  */\n \n static void\n-cp_parser_using_directive (parser)\n-     cp_parser *parser;\n+cp_parser_using_directive (cp_parser* parser)\n {\n   tree namespace_decl;\n \n@@ -9297,8 +9161,7 @@ cp_parser_using_directive (parser)\n                           : asm-operand-list [opt] ) ;  */\n \n static void\n-cp_parser_asm_definition (parser)\n-     cp_parser *parser;\n+cp_parser_asm_definition (cp_parser* parser)\n {\n   cp_token *token;\n   tree string;\n@@ -9447,18 +9310,12 @@ cp_parser_asm_definition (parser)\n    is FALSE.  */\n \n static tree\n-cp_parser_init_declarator (parser, \n-\t\t\t   decl_specifiers, \n-\t\t\t   prefix_attributes,\n-\t\t\t   function_definition_allowed_p,\n-\t\t\t   member_p,\n-\t\t\t   function_definition_p)\n-     cp_parser *parser;\n-     tree decl_specifiers;\n-     tree prefix_attributes;\n-     bool function_definition_allowed_p;\n-     bool member_p;\n-     bool *function_definition_p;\n+cp_parser_init_declarator (cp_parser* parser, \n+\t\t\t   tree decl_specifiers, \n+\t\t\t   tree prefix_attributes,\n+\t\t\t   bool function_definition_allowed_p,\n+\t\t\t   bool member_p,\n+\t\t\t   bool* function_definition_p)\n {\n   cp_token *token;\n   tree declarator;\n@@ -9737,10 +9594,9 @@ cp_parser_init_declarator (parser,\n    expression, not a declaration.)  */\n \n static tree\n-cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n-     cp_parser *parser;\n-     cp_parser_declarator_kind dcl_kind;\n-     bool *ctor_dtor_or_conv_p;\n+cp_parser_declarator (cp_parser* parser, \n+                      cp_parser_declarator_kind dcl_kind, \n+                      bool* ctor_dtor_or_conv_p)\n {\n   cp_token *token;\n   tree declarator;\n@@ -9844,10 +9700,9 @@ cp_parser_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n    indicating the size of the array is the second operand.  */\n \n static tree\n-cp_parser_direct_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n-     cp_parser *parser;\n-     cp_parser_declarator_kind dcl_kind;\n-     bool *ctor_dtor_or_conv_p;\n+cp_parser_direct_declarator (cp_parser* parser,\n+                             cp_parser_declarator_kind dcl_kind,\n+                             bool* ctor_dtor_or_conv_p)\n {\n   cp_token *token;\n   tree declarator = NULL_TREE;\n@@ -10147,10 +10002,9 @@ cp_parser_direct_declarator (parser, dcl_kind, ctor_dtor_or_conv_p)\n    cv-qualifiers.  Returns ERROR_MARK if an error occurred.  */\n    \n static enum tree_code\n-cp_parser_ptr_operator (parser, type, cv_qualifier_seq)\n-     cp_parser *parser;\n-     tree *type;\n-     tree *cv_qualifier_seq;\n+cp_parser_ptr_operator (cp_parser* parser, \n+                        tree* type, \n+                        tree* cv_qualifier_seq)\n {\n   enum tree_code code = ERROR_MARK;\n   cp_token *token;\n@@ -10225,8 +10079,7 @@ cp_parser_ptr_operator (parser, type, cv_qualifier_seq)\n    representation of a cv-qualifier.  */\n \n static tree\n-cp_parser_cv_qualifier_seq_opt (parser)\n-     cp_parser *parser;\n+cp_parser_cv_qualifier_seq_opt (cp_parser* parser)\n {\n   tree cv_qualifiers = NULL_TREE;\n   \n@@ -10261,8 +10114,7 @@ cp_parser_cv_qualifier_seq_opt (parser)\n      __restrict__ */\n \n static tree\n-cp_parser_cv_qualifier_opt (parser)\n-     cp_parser *parser;\n+cp_parser_cv_qualifier_opt (cp_parser* parser)\n {\n   cp_token *token;\n   tree cv_qualifier = NULL_TREE;\n@@ -10302,8 +10154,7 @@ cp_parser_cv_qualifier_opt (parser)\n    unqualified-id.  */\n \n static tree\n-cp_parser_declarator_id (parser)\n-     cp_parser *parser;\n+cp_parser_declarator_id (cp_parser* parser)\n {\n   tree id_expression;\n \n@@ -10341,8 +10192,7 @@ cp_parser_declarator_id (parser)\n    Returns the TYPE specified.  */\n \n static tree\n-cp_parser_type_id (parser)\n-     cp_parser *parser;\n+cp_parser_type_id (cp_parser* parser)\n {\n   tree type_specifier_seq;\n   tree abstract_declarator;\n@@ -10380,8 +10230,7 @@ cp_parser_type_id (parser)\n    type-specifier, or the TREE_PURPOSE is a list of attributes.  */\n \n static tree\n-cp_parser_type_specifier_seq (parser)\n-     cp_parser *parser;\n+cp_parser_type_specifier_seq (cp_parser* parser)\n {\n   bool seen_type_specifier = false;\n   tree type_specifier_seq = NULL_TREE;\n@@ -10443,8 +10292,7 @@ cp_parser_type_specifier_seq (parser)\n    parameter-declaration-clause consisting only of an ellipsis.  */\n \n static tree\n-cp_parser_parameter_declaration_clause (parser)\n-     cp_parser *parser;\n+cp_parser_parameter_declaration_clause (cp_parser* parser)\n {\n   tree parameters;\n   cp_token *token;\n@@ -10527,8 +10375,7 @@ cp_parser_parameter_declaration_clause (parser)\n    `void_list_node' is never appended to the list.  */\n \n static tree\n-cp_parser_parameter_declaration_list (parser)\n-     cp_parser *parser;\n+cp_parser_parameter_declaration_list (cp_parser* parser)\n {\n   tree parameters = NULL_TREE;\n \n@@ -10827,9 +10674,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n    be a `friend'.  */\n \n static tree\n-cp_parser_function_definition (parser, friend_p)\n-     cp_parser *parser;\n-     bool *friend_p;\n+cp_parser_function_definition (cp_parser* parser, bool* friend_p)\n {\n   tree decl_specifiers;\n   tree attributes;\n@@ -11026,9 +10871,7 @@ cp_parser_ctor_initializer_opt_and_function_body (cp_parser *parser)\n    set to FALSE if there is no initializer present.  */\n \n static tree\n-cp_parser_initializer (parser, is_parenthesized_init)\n-     cp_parser *parser;\n-     bool *is_parenthesized_init;\n+cp_parser_initializer (cp_parser* parser, bool* is_parenthesized_init)\n {\n   cp_token *token;\n   tree init;\n@@ -11086,8 +10929,7 @@ cp_parser_initializer (parser, is_parenthesized_init)\n    trailing `,' was provided.  */\n \n static tree\n-cp_parser_initializer_clause (parser)\n-     cp_parser *parser;\n+cp_parser_initializer_clause (cp_parser* parser)\n {\n   tree initializer;\n \n@@ -11140,8 +10982,7 @@ cp_parser_initializer_clause (parser)\n    IDENTIFIER_NODE naming the field to initialize.   */\n \n static tree\n-cp_parser_initializer_list (parser)\n-     cp_parser *parser;\n+cp_parser_initializer_list (cp_parser* parser)\n {\n   tree initializers = NULL_TREE;\n \n@@ -11333,8 +11174,7 @@ cp_parser_class_name (cp_parser *parser,\n    Returns the TREE_TYPE representing the class.  */\n \n static tree\n-cp_parser_class_specifier (parser)\n-     cp_parser *parser;\n+cp_parser_class_specifier (cp_parser* parser)\n {\n   cp_token *token;\n   tree type;\n@@ -11504,10 +11344,8 @@ cp_parser_class_specifier (parser)\n    body of the class.  */\n \n static tree\n-cp_parser_class_head (parser, \n-\t\t      nested_name_specifier_p)\n-     cp_parser *parser;\n-     bool *nested_name_specifier_p;\n+cp_parser_class_head (cp_parser* parser, \n+\t\t      bool* nested_name_specifier_p)\n {\n   cp_token *token;\n   tree nested_name_specifier;\n@@ -11762,8 +11600,7 @@ cp_parser_class_head (parser,\n    error.  */\n \n static enum tag_types\n-cp_parser_class_key (parser)\n-     cp_parser *parser;\n+cp_parser_class_key (cp_parser* parser)\n {\n   cp_token *token;\n   enum tag_types tag_type;\n@@ -11787,8 +11624,7 @@ cp_parser_class_key (parser)\n      access-specifier : member-specification [opt]  */\n \n static void\n-cp_parser_member_specification_opt (parser)\n-     cp_parser *parser;\n+cp_parser_member_specification_opt (cp_parser* parser)\n {\n   while (true)\n     {\n@@ -11853,8 +11689,7 @@ cp_parser_member_specification_opt (parser)\n      identifier [opt] attributes [opt] : constant-expression  */\n \n static void\n-cp_parser_member_declaration (parser)\n-     cp_parser *parser;\n+cp_parser_member_declaration (cp_parser* parser)\n {\n   tree decl_specifiers;\n   tree prefix_attributes;\n@@ -12203,8 +12038,7 @@ cp_parser_member_declaration (parser)\n    Otherwiser, ERROR_MARK_NODE is returned.  */\n \n static tree\n-cp_parser_pure_specifier (parser)\n-     cp_parser *parser;\n+cp_parser_pure_specifier (cp_parser* parser)\n {\n   cp_token *token;\n \n@@ -12230,8 +12064,7 @@ cp_parser_pure_specifier (parser)\n    Returns a representation of the constant-expression.  */\n \n static tree\n-cp_parser_constant_initializer (parser)\n-     cp_parser *parser;\n+cp_parser_constant_initializer (cp_parser* parser)\n {\n   /* Look for the `=' token.  */\n   if (!cp_parser_require (parser, CPP_EQ, \"`='\"))\n@@ -12278,8 +12111,7 @@ cp_parser_constant_initializer (parser)\n    NULL_TREE, not ERROR_MARK_NODE.  */\n \n static tree\n-cp_parser_base_clause (parser)\n-     cp_parser *parser;\n+cp_parser_base_clause (cp_parser* parser)\n {\n   tree bases = NULL_TREE;\n \n@@ -12334,8 +12166,7 @@ cp_parser_base_clause (parser)\n    (or the ERROR_MARK_NODE) indicating the type that was specified.  */\n        \n static tree\n-cp_parser_base_specifier (parser)\n-     cp_parser *parser;\n+cp_parser_base_specifier (cp_parser* parser)\n {\n   cp_token *token;\n   bool done = false;\n@@ -12484,8 +12315,7 @@ cp_parser_base_specifier (parser)\n    TREE_VALUE of each node is a type.  */\n \n static tree\n-cp_parser_exception_specification_opt (parser)\n-     cp_parser *parser;\n+cp_parser_exception_specification_opt (cp_parser* parser)\n {\n   cp_token *token;\n   tree type_id_list;\n@@ -12537,8 +12367,7 @@ cp_parser_exception_specification_opt (parser)\n    in the order that the types were presented.  */\n \n static tree\n-cp_parser_type_id_list (parser)\n-     cp_parser *parser;\n+cp_parser_type_id_list (cp_parser* parser)\n {\n   tree types = NULL_TREE;\n \n@@ -12569,8 +12398,7 @@ cp_parser_type_id_list (parser)\n      try compound-statement handler-seq  */\n \n static tree\n-cp_parser_try_block (parser)\n-     cp_parser *parser;\n+cp_parser_try_block (cp_parser* parser)\n {\n   tree try_block;\n \n@@ -12590,8 +12418,7 @@ cp_parser_try_block (parser)\n      try ctor-initializer [opt] function-body handler-seq  */\n \n static bool\n-cp_parser_function_try_block (parser)\n-     cp_parser *parser;\n+cp_parser_function_try_block (cp_parser* parser)\n {\n   tree try_block;\n   bool ctor_initializer_p;\n@@ -12620,8 +12447,7 @@ cp_parser_function_try_block (parser)\n      handler handler-seq [opt]  */\n \n static void\n-cp_parser_handler_seq (parser)\n-     cp_parser *parser;\n+cp_parser_handler_seq (cp_parser* parser)\n {\n   while (true)\n     {\n@@ -12643,8 +12469,7 @@ cp_parser_handler_seq (parser)\n      catch ( exception-declaration ) compound-statement  */\n \n static void\n-cp_parser_handler (parser)\n-     cp_parser *parser;\n+cp_parser_handler (cp_parser* parser)\n {\n   tree handler;\n   tree declaration;\n@@ -12671,8 +12496,7 @@ cp_parser_handler (parser)\n    ellipsis variant is used.  */\n \n static tree\n-cp_parser_exception_declaration (parser)\n-     cp_parser *parser;\n+cp_parser_exception_declaration (cp_parser* parser)\n {\n   tree type_specifiers;\n   tree declarator;\n@@ -12714,8 +12538,7 @@ cp_parser_exception_declaration (parser)\n    Returns a THROW_EXPR representing the throw-expression.  */\n \n static tree\n-cp_parser_throw_expression (parser)\n-     cp_parser *parser;\n+cp_parser_throw_expression (cp_parser* parser)\n {\n   tree expression;\n \n@@ -12743,8 +12566,7 @@ cp_parser_throw_expression (parser)\n    NULL_TREE.  */\n \n static tree\n-cp_parser_asm_specification_opt (parser)\n-     cp_parser *parser;\n+cp_parser_asm_specification_opt (cp_parser* parser)\n {\n   cp_token *token;\n   tree asm_specification;\n@@ -12791,8 +12613,7 @@ cp_parser_asm_specification_opt (parser)\n    is a STRING_CST for the string literal before the parenthesis.  */\n \n static tree\n-cp_parser_asm_operand_list (parser)\n-     cp_parser *parser;\n+cp_parser_asm_operand_list (cp_parser* parser)\n {\n   tree asm_operands = NULL_TREE;\n \n@@ -12851,8 +12672,7 @@ cp_parser_asm_operand_list (parser)\n    appeared.  The TREE_VALUE of each node is a STRING_CST.  */\n \n static tree\n-cp_parser_asm_clobber_list (parser)\n-     cp_parser *parser;\n+cp_parser_asm_clobber_list (cp_parser* parser)\n {\n   tree clobbers = NULL_TREE;\n \n@@ -12888,8 +12708,7 @@ cp_parser_asm_clobber_list (parser)\n    The return value is as for cp_parser_attribute_list.  */\n      \n static tree\n-cp_parser_attributes_opt (parser)\n-     cp_parser *parser;\n+cp_parser_attributes_opt (cp_parser* parser)\n {\n   tree attributes = NULL_TREE;\n \n@@ -12949,8 +12768,7 @@ cp_parser_attributes_opt (parser)\n    any.  */\n \n static tree\n-cp_parser_attribute_list (parser)\n-     cp_parser *parser;\n+cp_parser_attribute_list (cp_parser* parser)\n {\n   tree attribute_list = NULL_TREE;\n \n@@ -13047,9 +12865,7 @@ cp_parser_attribute_list (parser)\n    for restoring the value of the PEDANTIC flag.  */\n \n static bool\n-cp_parser_extension_opt (parser, saved_pedantic)\n-     cp_parser *parser;\n-     int *saved_pedantic;\n+cp_parser_extension_opt (cp_parser* parser, int* saved_pedantic)\n {\n   /* Save the old value of the PEDANTIC flag.  */\n   *saved_pedantic = pedantic;\n@@ -13078,8 +12894,7 @@ cp_parser_extension_opt (parser, saved_pedantic)\n      identifier  */\n \n static void\n-cp_parser_label_declaration (parser)\n-     cp_parser *parser;\n+cp_parser_label_declaration (cp_parser* parser)\n {\n   /* Look for the `__label__' keyword.  */\n   cp_parser_require_keyword (parser, RID_LABEL, \"`__label__'\");\n@@ -13327,9 +13142,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name, bool check_access,\n    TRUE.  */\n \n static tree\n-cp_parser_lookup_name_simple (parser, name)\n-     cp_parser *parser;\n-     tree name;\n+cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n {\n   return cp_parser_lookup_name (parser, name, \n \t\t\t\t/*check_access=*/true,\n@@ -13344,9 +13157,7 @@ cp_parser_lookup_name_simple (parser, name)\n    extremely limited situations.  */\n \n static tree\n-cp_parser_resolve_typename_type (parser, type)\n-     cp_parser *parser;\n-     tree type;\n+cp_parser_resolve_typename_type (cp_parser* parser, tree type)\n {\n   tree scope;\n   tree name;\n@@ -13445,9 +13256,8 @@ cp_parser_maybe_treat_template_as_class (tree decl, bool tag_name_p)\n    and FALSE otherwise.  */\n \n static bool\n-cp_parser_check_declarator_template_parameters (parser, declarator)\n-     cp_parser *parser;\n-     tree declarator;\n+cp_parser_check_declarator_template_parameters (cp_parser* parser, \n+                                                tree declarator)\n {\n   unsigned num_templates;\n \n@@ -13522,9 +13332,8 @@ cp_parser_check_declarator_template_parameters (parser, declarator)\n    return TRUE.  */\n \n static bool\n-cp_parser_check_template_parameters (parser, num_templates)\n-     cp_parser *parser;\n-     unsigned num_templates;\n+cp_parser_check_template_parameters (cp_parser* parser,\n+                                     unsigned num_templates)\n {\n   /* If there are more template classes than parameter lists, we have\n      something like:\n@@ -13564,10 +13373,9 @@ cp_parser_check_template_parameters (parser, num_templates)\n    the two sub-expressions.  */\n \n static tree\n-cp_parser_binary_expression (parser, token_tree_map, fn)\n-     cp_parser *parser;\n-     const cp_parser_token_tree_map token_tree_map;\n-     cp_parser_expression_fn fn;\n+cp_parser_binary_expression (cp_parser* parser, \n+                             const cp_parser_token_tree_map token_tree_map, \n+                             cp_parser_expression_fn fn)\n {\n   tree lhs;\n \n@@ -13619,9 +13427,7 @@ cp_parser_binary_expression (parser, token_tree_map, fn)\n    present, and NULL_TREE otherwise.  */\n \n static tree\n-cp_parser_global_scope_opt (parser, current_scope_valid_p)\n-     cp_parser *parser;\n-     bool current_scope_valid_p;\n+cp_parser_global_scope_opt (cp_parser* parser, bool current_scope_valid_p)\n {\n   cp_token *token;\n \n@@ -13781,11 +13587,10 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n \n static tree\n cp_parser_function_definition_from_specifiers_and_declarator\n-  (parser, decl_specifiers, attributes, declarator)\n-     cp_parser *parser;\n-     tree decl_specifiers;\n-     tree attributes;\n-     tree declarator;\n+  (cp_parser* parser,\n+   tree decl_specifiers,\n+   tree attributes,\n+   tree declarator)\n {\n   tree fn;\n   bool success_p;\n@@ -13823,10 +13628,8 @@ cp_parser_function_definition_from_specifiers_and_declarator\n    Returns the function defined.  */\n \n static tree \n-cp_parser_function_definition_after_declarator (parser, \n-\t\t\t\t\t\tinline_p)\n-     cp_parser *parser;\n-     bool inline_p;\n+cp_parser_function_definition_after_declarator (cp_parser* parser, \n+\t\t\t\t\t\tbool inline_p)\n {\n   tree fn;\n   bool ctor_initializer_p = false;\n@@ -13888,9 +13691,7 @@ cp_parser_function_definition_after_declarator (parser,\n    is as for cp_parser_template_declaration.  */\n \n static void\n-cp_parser_template_declaration_after_export (parser, member_p)\n-     cp_parser *parser;\n-     bool member_p;\n+cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n {\n   tree decl = NULL_TREE;\n   tree parameter_list;\n@@ -13968,12 +13769,9 @@ cp_parser_template_declaration_after_export (parser, member_p)\n    *FRIEND_P is set to TRUE iff the declaration is a friend.  */\n \n static tree\n-cp_parser_single_declaration (parser, \n-\t\t\t      member_p,\n-\t\t\t      friend_p)\n-     cp_parser *parser;\n-     bool member_p;\n-     bool *friend_p;\n+cp_parser_single_declaration (cp_parser* parser, \n+\t\t\t      bool member_p,\n+\t\t\t      bool* friend_p)\n {\n   bool declares_class_or_enum;\n   tree decl = NULL_TREE;\n@@ -14054,9 +13852,7 @@ cp_parser_single_declaration (parser,\n    representing the cast.  */\n \n static tree\n-cp_parser_functional_cast (parser, type)\n-     cp_parser *parser;\n-     tree type;\n+cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n   tree expression_list;\n \n@@ -14080,9 +13876,7 @@ cp_parser_functional_cast (parser, type)\n    parse them now.  */\n \n static void\n-cp_parser_late_parsing_for_member (parser, member_function)\n-     cp_parser *parser;\n-     tree member_function;\n+cp_parser_late_parsing_for_member (cp_parser* parser, tree member_function)\n {\n   cp_lexer *saved_lexer;\n \n@@ -14208,9 +14002,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n    encountered.  */\n \n static tree\n-cp_parser_sizeof_operand (parser, keyword)\n-     cp_parser *parser;\n-     enum rid keyword;\n+cp_parser_sizeof_operand (cp_parser* parser, enum rid keyword)\n {\n   static const char *format;\n   tree expr = NULL_TREE;\n@@ -14303,8 +14095,7 @@ cp_parser_declares_only_class_p (cp_parser *parser)\n    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n \n static bool\n-cp_parser_friend_p (decl_specifiers)\n-     tree decl_specifiers;\n+cp_parser_friend_p (tree decl_specifiers)\n {\n   while (decl_specifiers)\n     {\n@@ -14327,10 +14118,9 @@ cp_parser_friend_p (decl_specifiers)\n    Otherwise, returns NULL.  */\n \n static cp_token *\n-cp_parser_require (parser, type, token_desc)\n-     cp_parser *parser;\n-     enum cpp_ttype type;\n-     const char *token_desc;\n+cp_parser_require (cp_parser* parser,\n+                   enum cpp_ttype type,\n+                   const char* token_desc)\n {\n   if (cp_lexer_next_token_is (parser->lexer, type))\n     return cp_lexer_consume_token (parser->lexer);\n@@ -14348,10 +14138,9 @@ cp_parser_require (parser, type, token_desc)\n    the next token is not as expected.  */\n \n static void\n-cp_parser_skip_until_found (parser, type, token_desc)\n-     cp_parser *parser;\n-     enum cpp_ttype type;\n-     const char *token_desc;\n+cp_parser_skip_until_found (cp_parser* parser, \n+                            enum cpp_ttype type, \n+                            const char* token_desc)\n {\n   cp_token *token;\n   unsigned nesting_depth = 0;\n@@ -14397,10 +14186,9 @@ cp_parser_skip_until_found (parser, type, token_desc)\n    Otherwise, returns NULL.  */\n \n static cp_token *\n-cp_parser_require_keyword (parser, keyword, token_desc)\n-     cp_parser *parser;\n-     enum rid keyword;\n-     const char *token_desc;\n+cp_parser_require_keyword (cp_parser* parser,\n+                           enum rid keyword,\n+                           const char* token_desc)\n {\n   cp_token *token = cp_parser_require (parser, CPP_KEYWORD, token_desc);\n \n@@ -14424,8 +14212,7 @@ cp_parser_require_keyword (parser, keyword, token_desc)\n    function-definition.  */\n \n static bool \n-cp_parser_token_starts_function_definition_p (token)\n-     cp_token *token;\n+cp_parser_token_starts_function_definition_p (cp_token* token)\n {\n   return (/* An ordinary function-body begins with an `{'.  */\n \t  token->type == CPP_OPEN_BRACE\n@@ -14453,8 +14240,7 @@ cp_parser_next_token_starts_class_definition_p (cp_parser *parser)\n    or none_type otherwise.  */\n \n static enum tag_types\n-cp_parser_token_is_class_key (token)\n-     cp_token *token;\n+cp_parser_token_is_class_key (cp_token* token)\n {\n   switch (token->keyword)\n     {\n@@ -14577,8 +14363,7 @@ cp_parser_cache_group (cp_parser *parser,\n    tokens.  */\n \n static void\n-cp_parser_parse_tentatively (parser)\n-     cp_parser *parser;\n+cp_parser_parse_tentatively (cp_parser* parser)\n {\n   /* Enter a new parsing context.  */\n   parser->context = cp_parser_context_new (parser->context);\n@@ -14593,8 +14378,7 @@ cp_parser_parse_tentatively (parser)\n /* Commit to the currently active tentative parse.  */\n \n static void\n-cp_parser_commit_to_tentative_parse (parser)\n-     cp_parser *parser;\n+cp_parser_commit_to_tentative_parse (cp_parser* parser)\n {\n   cp_parser_context *context;\n   cp_lexer *lexer;\n@@ -14616,8 +14400,7 @@ cp_parser_commit_to_tentative_parse (parser)\n    will be rolled back, and no diagnostics will be issued.  */\n \n static void\n-cp_parser_abort_tentative_parse (parser)\n-     cp_parser *parser;\n+cp_parser_abort_tentative_parse (cp_parser* parser)\n {\n   cp_parser_simulate_error (parser);\n   /* Now, pretend that we want to see if the construct was\n@@ -14630,8 +14413,7 @@ cp_parser_abort_tentative_parse (parser)\n    Returns true if no error occurred; false otherwise.  */\n \n static bool\n-cp_parser_parse_definitely (parser)\n-     cp_parser *parser;\n+cp_parser_parse_definitely (cp_parser* parser)\n {\n   bool error_occurred;\n   cp_parser_context *context;\n@@ -14670,8 +14452,7 @@ cp_parser_parse_definitely (parser)\n    we will stick with this tentative parse, even if errors occur.  */\n \n static bool\n-cp_parser_committed_to_tentative_parse (parser)\n-     cp_parser *parser;\n+cp_parser_committed_to_tentative_parse (cp_parser* parser)\n {\n   return (cp_parser_parsing_tentatively (parser)\n \t  && parser->context->status == CP_PARSER_STATUS_KIND_COMMITTED);\n@@ -14681,8 +14462,7 @@ cp_parser_committed_to_tentative_parse (parser)\n    tentative parse.  */\n    \n static bool\n-cp_parser_error_occurred (parser)\n-     cp_parser *parser;\n+cp_parser_error_occurred (cp_parser* parser)\n {\n   return (cp_parser_parsing_tentatively (parser)\n \t  && parser->context->status == CP_PARSER_STATUS_KIND_ERROR);\n@@ -14691,8 +14471,7 @@ cp_parser_error_occurred (parser)\n /* Returns non-zero if GNU extensions are allowed.  */\n \n static bool\n-cp_parser_allow_gnu_extensions_p (parser)\n-     cp_parser *parser;\n+cp_parser_allow_gnu_extensions_p (cp_parser* parser)\n {\n   return parser->allow_gnu_extensions_p;\n }\n@@ -14708,7 +14487,7 @@ static GTY (()) cp_parser *the_parser;\n /* Parse the entire translation unit.  */\n \n int\n-yyparse ()\n+yyparse (void)\n {\n   bool error_occurred;\n \n@@ -14725,7 +14504,7 @@ yyparse ()\n /* Clean up after parsing the entire translation unit.  */\n \n void\n-free_parser_stacks ()\n+free_parser_stacks (void)\n {\n   /* Nothing to do.  */\n }"}]}