{"sha": "95f2be29446f6d04e4b221b228eac190057d839b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVmMmJlMjk0NDZmNmQwNGU0YjIyMWIyMjhlYWMxOTAwNTdkODM5Yg==", "commit": {"author": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2018-09-26T09:17:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-09-26T09:17:46Z"}, "message": "[Ada] Front-end support for OpenACC pragmas\n\nThis patch introduces the upper part of the Ada front-end support for a first\nset of OpenACC directives (Acc_Kernels, Acc_Loop, Acc_Parallel, Acc_Data) and\ntheir clauses.\n\nThe pragmas syntax is documented, pragmas are recognized and checked for\nsyntactic correctness, keyed on -fopenacc. A couple of new flags are defined\non loop statements in the GNAT tree.\n\n2018-09-26  Olivier Hainque  <hainque@adacore.com>\n\ngcc/ada/\n\n\t* opt.ads (OpenAcc_Enabled): New flag. False by default. True\n\twhen OpenACC pragmas are requested to be honored, when -fopenacc\n\tis found on the command line.\n\t* back_end.adb (Scan_Compiler_Arguments): Set OpenACC_Enabled if\n\t-fopenacc is seen on the command line.\n\t* sinfo.adb, sinfo.ads (Is_OpenAcc_Environment): New\n\tflag/predicate on Loop statements which embed an Acc_Kernels,\n\tAcc_Parallel or Acc_Data pragma.\n\t(Is_OpenAcc_Loop): New flag/predicate on Loop statements which\n\tembed an Acc_Loop pragma.\n\t(Set_Is_OpenAcc_Environment, Set_Is_OpenAcc_Loop): Setters for\n\tthe new flags.\n\t* par-prag.adb (Prag): Handle Acc_Data, Acc_Loop, Acc_Parallel\n\tand Acc_Kernels pragmas.  Nothing to do here, all handled by\n\tsem_prag.\n\t* sem_prag.adb (Acc_First, Acc_Next,\n\tValidate_Acc_Condition_Clause, Validate_Acc_Data_Clause,\n\tValidate_Acc_Int_Expr_Clause, Validate_Acc_Int_Expr_List_Clause,\n\tValidate_Acc_Loop_Collapse, Validate_Acc_Loop_Gang,\n\tValidate_Acc_Loop_Vector, Validate_Acc_Loop_Worker,\n\tValidate_Acc_Name_Reduction, Validate_Acc_Size_Expressions): New\n\thelper for Analyze_Pragma, to handle OpenACC pragmas.\n\t(Analyze_Pragma): Handle Acc_Data, Acc_Loop, Acc_Parallel and\n\tAcc_Kernels pragmas.\n\t* sem_ch5.adb (Disable_Constant): Unset Is_True_Constant on\n\tvariable entity, action for ...\n\t(Disable_Constants): Helper for Analyze_Loop_Statement, to ...\n\t(Analyze_Loop_Statement): Disable True_Constant on variables\n\treferenced within an OpenACC environment.\n\t* snames.ads-tmpl: Declare Name_Ids for the OpenACC directives\n\tand clauses we can handle. Remove an exraneous whitespace before\n\tcolumns, preventing line length overflow in the generated spec\n\twith Ids now reaching beyond 999.\n\t* doc/gnat_rm/implementation_defined_pragmas.rst: Document\n\tpragma Acc_Parallel, Acc_Loop, Acc_Kernels and Acc_Data.\n\t* gnat_rm.texi: Regenerate.\n\nFrom-SVN: r264617", "tree": {"sha": "b4e19fae878516ff491fd5168facec2dabd723bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4e19fae878516ff491fd5168facec2dabd723bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95f2be29446f6d04e4b221b228eac190057d839b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f2be29446f6d04e4b221b228eac190057d839b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f2be29446f6d04e4b221b228eac190057d839b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f2be29446f6d04e4b221b228eac190057d839b/comments", "author": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8e53268102e205b1b10664b53ad41c31a9257b32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e53268102e205b1b10664b53ad41c31a9257b32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e53268102e205b1b10664b53ad41c31a9257b32"}], "stats": {"total": 3078, "additions": 2081, "deletions": 997}, "files": [{"sha": "825722a4e6b8a271086cd991c637901b2104d8db", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -1,3 +1,42 @@\n+2018-09-26  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* opt.ads (OpenAcc_Enabled): New flag. False by default. True\n+\twhen OpenACC pragmas are requested to be honored, when -fopenacc\n+\tis found on the command line.\n+\t* back_end.adb (Scan_Compiler_Arguments): Set OpenACC_Enabled if\n+\t-fopenacc is seen on the command line.\n+\t* sinfo.adb, sinfo.ads (Is_OpenAcc_Environment): New\n+\tflag/predicate on Loop statements which embed an Acc_Kernels,\n+\tAcc_Parallel or Acc_Data pragma.\n+\t(Is_OpenAcc_Loop): New flag/predicate on Loop statements which\n+\tembed an Acc_Loop pragma.\n+\t(Set_Is_OpenAcc_Environment, Set_Is_OpenAcc_Loop): Setters for\n+\tthe new flags.\n+\t* par-prag.adb (Prag): Handle Acc_Data, Acc_Loop, Acc_Parallel\n+\tand Acc_Kernels pragmas.  Nothing to do here, all handled by\n+\tsem_prag.\n+\t* sem_prag.adb (Acc_First, Acc_Next,\n+\tValidate_Acc_Condition_Clause, Validate_Acc_Data_Clause,\n+\tValidate_Acc_Int_Expr_Clause, Validate_Acc_Int_Expr_List_Clause,\n+\tValidate_Acc_Loop_Collapse, Validate_Acc_Loop_Gang,\n+\tValidate_Acc_Loop_Vector, Validate_Acc_Loop_Worker,\n+\tValidate_Acc_Name_Reduction, Validate_Acc_Size_Expressions): New\n+\thelper for Analyze_Pragma, to handle OpenACC pragmas.\n+\t(Analyze_Pragma): Handle Acc_Data, Acc_Loop, Acc_Parallel and\n+\tAcc_Kernels pragmas.\n+\t* sem_ch5.adb (Disable_Constant): Unset Is_True_Constant on\n+\tvariable entity, action for ...\n+\t(Disable_Constants): Helper for Analyze_Loop_Statement, to ...\n+\t(Analyze_Loop_Statement): Disable True_Constant on variables\n+\treferenced within an OpenACC environment.\n+\t* snames.ads-tmpl: Declare Name_Ids for the OpenACC directives\n+\tand clauses we can handle. Remove an exraneous whitespace before\n+\tcolumns, preventing line length overflow in the generated spec\n+\twith Ids now reaching beyond 999.\n+\t* doc/gnat_rm/implementation_defined_pragmas.rst: Document\n+\tpragma Acc_Parallel, Acc_Loop, Acc_Kernels and Acc_Data.\n+\t* gnat_rm.texi: Regenerate.\n+\n 2018-09-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Is_Onown_Limited): A derived type whose parent P"}, {"sha": "520a8b2deb83347b31d53ed2312cfc83c7ad1316", "filename": "gcc/ada/back_end.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fback_end.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fback_end.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fback_end.adb?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -375,6 +375,9 @@ package body Back_End is\n             elsif Is_Front_End_Switch (Argv) then\n                Scan_Front_End_Switches (Argv, Args, Next_Arg);\n \n+            elsif Argv (Argv'First + 1 .. Argv'Last) = \"fopenacc\" then\n+               Opt.OpenAcc_Enabled := True;\n+\n             --  All non-front-end switches are back-end switches\n \n             else"}, {"sha": "6074cd428196a648ce8dfbbc0fa37a6fd3c496f5", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_pragmas.rst", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_pragmas.rst?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -89,6 +89,158 @@ Syntax:\n For the semantics of this pragma, see the entry for aspect ``Abstract_State`` in\n the SPARK 2014 Reference Manual, section 7.1.4.\n \n+Pragma Acc_Parallel\n+===================\n+Syntax:\n+\n+.. code-block:: ada\n+\n+  pragma Acc_Parallel [( ACC_PARALLEL_CLAUSE [, ACC_PARALLEL_CLAUSE... ])];\n+\n+  ACC_PARALLEL_CLAUSE ::=\n+      Acc_If        => boolean_EXPRESSION\n+    | Acc_Private   => IDENTIFIERS\n+    | Async         => integer_EXPRESSION\n+    | Copy          => IDENTIFIERS\n+    | Copy_In       => IDENTIFIERS\n+    | Copy_Out      => IDENTIFIERS\n+    | Create        => IDENTIFIERS\n+    | Default       => None\n+    | Device_Ptr    => IDENTIFIERS\n+    | First_Private => IDENTIFIERS\n+    | Num_Gangs     => integer_EXPRESSION\n+    | Num_Workers   => integer_EXPRESSION\n+    | Present       => IDENTIFIERS\n+    | Reduction     => (REDUCTION_RECORD)\n+    | Vector_Length => integer_EXPRESSION\n+    | Wait          => INTEGERS\n+\n+  REDUCTION_RECORD ::=\n+      \"+\"   => IDENTIFIERS\n+    | \"*\"   => IDENTIFIERS\n+    | \"min\" => IDENTIFIERS\n+    | \"max\" => IDENTIFIERS\n+    | \"or\"  => IDENTIFIERS\n+    | \"and\" => IDENTIFIERS\n+\n+  IDENTIFIERS ::=\n+    | IDENTIFIER\n+    | (IDENTIFIER, IDENTIFIERS)\n+\n+  INTEGERS ::=\n+    | integer_EXPRESSION\n+    | (integer_EXPRESSION, INTEGERS)\n+\n+Requires the :switch:`-fopenacc` flag.\n+\n+Equivalent to the ``parallel`` directive of the OpenAcc standard. This pragma\n+should be placed in loops. It offloads the content of the loop to an\n+accelerator device.\n+\n+For more information about the effect of the clauses, see the OpenAcc\n+specification.\n+\n+Pragma Acc_Loop\n+===============\n+Syntax:\n+\n+.. code-block:: ada\n+\n+  pragma Acc_Loop [( ACC_LOOP_CLAUSE [, ACC_LOOP_CLAUSE... ])];\n+\n+  ACC_LOOP_CLAUSE ::=\n+      Auto\n+    | Collapse        => INTEGER_LITERAL\n+    | Gang            [=> GANG_ARG]\n+    | Independent\n+    | Private         => IDENTIFIERS\n+    | Reduction       => (REDUCTION_RECORD)\n+    | Seq\n+    | Tile            => SIZE_EXPRESSION\n+    | Vector          [=> integer_EXPRESSION]\n+    | Worker          [=> integer_EXPRESSION]\n+\n+  GANG_ARG ::=\n+      integer_EXPRESSION\n+    | Static => SIZE_EXPRESSION\n+\n+  SIZE_EXPRESSION ::=\n+      *\n+    | integer_EXPRESSION\n+\n+Requires the :switch:`-fopenacc` flag.\n+\n+Equivalent to the ``loop`` directive of the OpenAcc standard. This pragma\n+should be placed in for loops after the \"Acc_Parallel\" pragma. It tells the\n+compiler how to parallelize the loop.\n+\n+For more information about the effect of the clauses, see the OpenAcc\n+specification.\n+\n+Pragma Acc_Kernels\n+==================\n+Syntax:\n+\n+.. code-block:: ada\n+\n+  pragma Acc_Kernels [( ACC_KERNELS_CLAUSE [, ACC_KERNELS_CLAUSE...])];\n+\n+  ACC_KERNELS_CLAUSE ::=\n+      Acc_If        => boolean_EXPRESSION\n+    | Async         => integer_EXPRESSION\n+    | Copy          => IDENTIFIERS\n+    | Copy_In       => IDENTIFIERS\n+    | Copy_Out      => IDENTIFIERS\n+    | Create        => IDENTIFIERS\n+    | Default       => None\n+    | Device_Ptr    => IDENTIFIERS\n+    | Num_Gangs     => integer_EXPRESSION\n+    | Num_Workers   => integer_EXPRESSION\n+    | Present       => IDENTIFIERS\n+    | Vector_Length => integer_EXPRESSION\n+    | Wait          => INTEGERS\n+\n+  IDENTIFIERS ::=\n+    | IDENTIFIER\n+    | (IDENTIFIER, IDENTIFIERS)\n+\n+  INTEGERS ::=\n+    | integer_EXPRESSION\n+    | (integer_EXPRESSION, INTEGERS)\n+\n+Requires the :switch:`-fopenacc` flag.\n+\n+Equivalent to the kernels directive of the OpenAcc standard. This pragma should\n+be placed in loops.\n+\n+For more information about the effect of the clauses, see the OpenAcc\n+specification.\n+\n+Pragma Acc_Data\n+===============\n+Syntax:\n+\n+.. code-block:: ada\n+\n+  pragma Acc_Data ([ ACC_DATA_CLAUSE [, ACC_DATA_CLAUSE...]]);\n+\n+  ACC_DATA_CLAUSE ::=\n+      Copy          => IDENTIFIERS\n+    | Copy_In       => IDENTIFIERS\n+    | Copy_Out      => IDENTIFIERS\n+    | Create        => IDENTIFIERS\n+    | Device_Ptr    => IDENTIFIERS\n+    | Present       => IDENTIFIERS\n+\n+Requires the :switch:`-fopenacc` flag.\n+\n+Equivalent to the ``data`` directive of the OpenAcc standard. This pragma\n+should be placed in loops.\n+\n+For more information about the effect of the clauses, see the OpenAcc\n+specification.\n+\n+\n Pragma Ada_83\n =============\n "}, {"sha": "fbe92ade729bf215d3d811cb2ec2392b59812fcb", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 1002, "deletions": 831, "changes": 1833, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=95f2be29446f6d04e4b221b228eac190057d839b"}, {"sha": "ca5dc6162d02fac2658f2e08b95b22106bda5293", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -2335,6 +2335,15 @@ package Opt is\n \n    --    The only special comment sequence allowed is --!\n \n+   -------------\n+   -- OpenAcc --\n+   -------------\n+\n+   OpenAcc_Enabled : Boolean := False;\n+   --  GNAT\n+   --  Indicates whether OpenAcc pragmas should be taken into account.\n+   --  Set True by use of -fopenacc.\n+\n    --------------------------\n    -- Private Declarations --\n    --------------------------"}, {"sha": "f51a838728a83ed03f40575a27ec68795cc4fc63", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -1516,6 +1516,10 @@ begin\n          | Pragma_Warning_As_Error\n          | Pragma_Weak_External\n          | Pragma_Validity_Checks\n+         | Pragma_Acc_Data\n+         | Pragma_Acc_Kernels\n+         | Pragma_Acc_Loop\n+         | Pragma_Acc_Parallel\n       =>\n          null;\n "}, {"sha": "6f002f428247f9ebab73a65a1fa8d062f37dbe7b", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -3361,6 +3361,9 @@ package body Sem_Ch5 is\n \n    procedure Analyze_Loop_Statement (N : Node_Id) is\n \n+      function Disable_Constant (N : Node_Id) return Traverse_Result;\n+      --  If N represents an E_Variable entity, set Is_True_Constant To False\n+\n       function Is_Container_Iterator (Iter : Node_Id) return Boolean;\n       --  Given a loop iteration scheme, determine whether it is an Ada 2012\n       --  container iteration.\n@@ -3371,6 +3374,25 @@ package body Sem_Ch5 is\n       --  iterators. Prevents infinite recursion when block is analyzed.\n       --  Routine is a noop if loop is single statement within source block.\n \n+      ----------------------\n+      -- Disable_Constant --\n+      ----------------------\n+\n+      function Disable_Constant (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Entity_Name (N)\n+            and then Present (Entity (N))\n+            and then Ekind (Entity (N)) = E_Variable\n+         then\n+            Set_Is_True_Constant (Entity (N), False);\n+         end if;\n+         return OK;\n+      end Disable_Constant;\n+\n+      procedure Disable_Constants is new Traverse_Proc (Disable_Constant);\n+      --  Helper for Analyze_Loop_Statement, to unset Is_True_Constant on\n+      --  variables referenced within an OpenACC environment.\n+\n       ---------------------------\n       -- Is_Container_Iterator --\n       ---------------------------\n@@ -3812,6 +3834,15 @@ package body Sem_Ch5 is\n       if No (Iter) and then not Has_Exit (Ent) then\n          Check_Unreachable_Code (Stmt);\n       end if;\n+\n+      --  Variables referenced within a loop subject to possible OpenACC\n+      --  offloading may be implicitly written to as part of the OpenACC\n+      --  transaction.  Clear flags possibly conveying that they are constant,\n+      --  set for example when the code does not explicitly assign them.\n+\n+      if Is_OpenAcc_Environment (Stmt) then\n+         Disable_Constants (Stmt);\n+      end if;\n    end Analyze_Loop_Statement;\n \n    ----------------------------"}, {"sha": "c409b85ecb987f1f156262af9bab222eb07489e5", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 581, "deletions": 0, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -3685,6 +3685,12 @@ package body Sem_Prag is\n       -- Local Subprograms --\n       -----------------------\n \n+      function Acc_First (N : Node_Id) return Node_Id;\n+      --  Helper function to iterate over arguments given to OpenAcc pragmas.\n+\n+      function Acc_Next (N : Node_Id) return Node_Id;\n+      --  Helper function to iterate over arguments given to OpenAcc pragmas.\n+\n       procedure Acquire_Warning_Match_String (Arg : Node_Id);\n       --  Used by pragma Warnings (Off, string), and Warn_As_Error (string) to\n       --  get the given string argument, and place it in Name_Buffer, adding\n@@ -4234,6 +4240,85 @@ package body Sem_Prag is\n       --  which is used for error messages on any constructs violating the\n       --  profile.\n \n+      procedure Validate_Acc_Condition_Clause (Clause : Node_Id);\n+      --  Make sure the argument of a given Acc_If clause is a boolean.\n+\n+      procedure Validate_Acc_Data_Clause (Clause : Node_Id);\n+      --  Make sure the argument of an OpenAcc data clause (e.g. Copy, Copyin,\n+      --  Copyout...) is an identifier or an aggregate of identifiers.\n+\n+      procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id);\n+      --  Make sure the argument of an OpenAcc clause is an Integer expression.\n+\n+      procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id);\n+      --  Make sure the argument of an OpenAcc clause is an Integer expression\n+      --  or a list of Integer expressions.\n+\n+      procedure Validate_Acc_Loop_Collapse (Clause : Node_Id);\n+      --  Make sure that the parent loop of the Acc_Loop(Collapse => N) pragma\n+      --  contains at least N-1 nested loops.\n+\n+      procedure Validate_Acc_Loop_Gang (Clause : Node_Id);\n+      --  Make sure the argument of the Gang clause of a Loop directive is\n+      --  either an integer expression or a (Static => integer expressions)\n+      --  aggregate.\n+\n+      procedure Validate_Acc_Loop_Vector (Clause : Node_Id);\n+      --  When this procedure is called in a construct offloaded by an\n+      --  Acc_Kernels pragma, makes sure that a Vector_Length clause does\n+      --  not exist on said pragma.\n+      --  In all cases, make sure the argument is an integer expression.\n+\n+      procedure Validate_Acc_Loop_Worker (Clause : Node_Id);\n+      --  When this procedure is called in a construct offloaded by an\n+      --  Acc_Parallel pragma, makes sure that no argument has been given.\n+      --  When this procedure is called in a construct offloaded by an\n+      --  Acc_Kernels pragma and if Loop_Worker was given an argument,\n+      --  makes sure that the Num_Workers clause does not appear on the\n+      --  Acc_Kernels pragma and that the argument is an integer.\n+\n+      procedure Validate_Acc_Name_Reduction (Clause : Node_Id);\n+      --  Make sure the reduction clause is an aggregate made of a string\n+      --  representing a supported reduction operation (i.e. \"+\", \"*\", \"and\",\n+      --  \"or\", \"min\" or \"max\") and either an identifier or aggregate of\n+      --  identifiers.\n+\n+      procedure Validate_Acc_Size_Expressions (Clause : Node_Id);\n+      --  Makes sure that Clause is either an integer expression or an\n+      --  association with a Static as name and a list of integer expressions\n+      --  or \"*\" strings on the right hand side.\n+\n+      ---------------\n+      -- Acc_First --\n+      ---------------\n+\n+      function Acc_First (N : Node_Id) return Node_Id is\n+      begin\n+         if Nkind (N) = N_Aggregate then\n+            if Present (Expressions (N)) then\n+               return First (Expressions (N));\n+            elsif Present (Component_Associations (N)) then\n+               return Expression (First (Component_Associations (N)));\n+            end if;\n+         end if;\n+         return N;\n+      end Acc_First;\n+\n+      --------------\n+      -- Acc_Next --\n+      --------------\n+\n+      function Acc_Next (N : Node_Id) return Node_Id is\n+      begin\n+         if Nkind (Parent (N)) = N_Component_Association then\n+            return Expression (Next (Parent (N)));\n+         elsif Nkind (Parent (N)) = N_Aggregate then\n+            return Next (N);\n+         else\n+            return Empty;\n+         end if;\n+      end Acc_Next;\n+\n       ----------------------------------\n       -- Acquire_Warning_Match_String --\n       ----------------------------------\n@@ -11082,6 +11167,248 @@ package body Sem_Prag is\n          end if;\n       end Set_Ravenscar_Profile;\n \n+      -----------------------------------\n+      -- Validate_Acc_Condition_Clause --\n+      -----------------------------------\n+\n+      procedure Validate_Acc_Condition_Clause (Clause : Node_Id) is\n+      begin\n+         Analyze_And_Resolve (Clause);\n+         if not Is_Boolean_Type (Etype (Clause)) then\n+            Error_Pragma (\"Expected a boolean\");\n+         end if;\n+      end Validate_Acc_Condition_Clause;\n+\n+      ------------------------------\n+      -- Validate_Acc_Data_Clause --\n+      ------------------------------\n+\n+      procedure Validate_Acc_Data_Clause (Clause : Node_Id) is\n+         Expr : Node_Id;\n+      begin\n+         Expr := Acc_First (Clause);\n+         while Present (Expr) loop\n+            if Nkind (Expr) /= N_Identifier then\n+               Error_Pragma (\"Expected an Identifer\");\n+            end if;\n+            Analyze_And_Resolve (Expr);\n+            Expr := Acc_Next (Expr);\n+         end loop;\n+      end Validate_Acc_Data_Clause;\n+\n+      ----------------------------------\n+      -- Validate_Acc_Int_Expr_Clause --\n+      ----------------------------------\n+\n+      procedure Validate_Acc_Int_Expr_Clause (Clause : Node_Id) is\n+      begin\n+         Analyze_And_Resolve (Clause);\n+         if not Is_Integer_Type (Etype (Clause)) then\n+            Error_Pragma_Arg (\"Expected an integer\", Clause);\n+         end if;\n+      end Validate_Acc_Int_Expr_Clause;\n+\n+      ---------------------------------------\n+      -- Validate_Acc_Int_Expr_List_Clause --\n+      ---------------------------------------\n+\n+      procedure Validate_Acc_Int_Expr_List_Clause (Clause : Node_Id) is\n+         Expr : Node_Id;\n+      begin\n+         Expr := Acc_First (Clause);\n+         while Present (Expr) loop\n+            Analyze_And_Resolve (Expr);\n+            if not Is_Integer_Type (Etype (Expr)) then\n+               Error_Pragma (\"Expected an Integer\");\n+            end if;\n+            Expr := Acc_Next (Expr);\n+         end loop;\n+      end Validate_Acc_Int_Expr_List_Clause;\n+\n+      --------------------------------\n+      -- Validate_Acc_Loop_Collapse --\n+      --------------------------------\n+\n+      procedure Validate_Acc_Loop_Collapse (Clause : Node_Id) is\n+         Count : Uint;\n+         Parent_Loop : Node_Id;\n+         Current_Statement : Node_Id;\n+      begin\n+         --  Make sure the argument is a positive integer.\n+         Analyze_And_Resolve (Clause);\n+         Count := Static_Integer (Clause);\n+         if Count = No_Uint or else Count < 1 then\n+            Error_Pragma_Arg (\"Expected a positive integer\", Clause);\n+         end if;\n+\n+         --  Then, make sure we have at least Count-1 tightly-nested loops\n+         --  (i.e. loops with no statements in between).\n+\n+         Parent_Loop := Parent (Parent (Parent (Clause)));\n+         Current_Statement := First (Statements (Parent_Loop));\n+         --  Skip first pragmas in the parent loop\n+         while Present (Current_Statement)\n+            and then Nkind (Current_Statement) = N_Pragma loop\n+            Current_Statement := Next (Current_Statement);\n+         end loop;\n+\n+         if not Present (Next (Current_Statement)) then\n+            While_Loop :\n+            while Nkind (Current_Statement) = N_Loop_Statement\n+               and Count > 1 loop\n+               Current_Statement := First (Statements (Current_Statement));\n+               exit While_Loop when Present (Next (Current_Statement));\n+               Count := Count - 1;\n+            end loop While_Loop;\n+         end if;\n+\n+         if Count > 1 then\n+            Error_Pragma_Arg (\"Collapse argument too high or loops not \" &\n+            \"tightly nested.\", Clause);\n+         end if;\n+      end Validate_Acc_Loop_Collapse;\n+\n+      ----------------------------\n+      -- Validate_Acc_Loop_Gang --\n+      ----------------------------\n+\n+      procedure Validate_Acc_Loop_Gang (Clause : Node_Id) is\n+      begin\n+         Error_Pragma_Arg (\"Loop_Gang not implemented\", Clause);\n+      end Validate_Acc_Loop_Gang;\n+\n+      ------------------------------\n+      -- Validate_Acc_Loop_Vector --\n+      ------------------------------\n+\n+      procedure Validate_Acc_Loop_Vector (Clause : Node_Id) is\n+      begin\n+         Error_Pragma_Arg (\"Loop_Vector not implemented\", Clause);\n+      end Validate_Acc_Loop_Vector;\n+\n+      -------------------------------\n+      --  Validate_Acc_Loop_Worker --\n+      -------------------------------\n+\n+      procedure Validate_Acc_Loop_Worker (Clause : Node_Id) is\n+      begin\n+         Error_Pragma_Arg (\"Loop_Worker not implemented\", Clause);\n+      end Validate_Acc_Loop_Worker;\n+\n+      ---------------------------------\n+      -- Validate_Acc_Name_Reduction --\n+      ---------------------------------\n+\n+      procedure Validate_Acc_Name_Reduction (Clause : Node_Id) is\n+         --  ??? On top of the following operations, the OpenAcc spec adds the\n+         --  \"bitwise and\", \"bitwise or\" and modulo for C and \".eqv\" and\n+         --  \".neqv\" for Fortran. Can we, should we and how do we support them\n+         --  in Ada?\n+         type Reduction_Op is (Add_Op, Mul_Op, Max_Op,\n+            Min_Op, And_Op, Or_Op);\n+         function To_Reduction_Op (Op : String) return Reduction_Op;\n+         function To_Reduction_Op (Op : String) return Reduction_Op is\n+         begin\n+            if Op = \"+\" then\n+               return Add_Op;\n+            elsif Op = \"*\" then\n+               return Mul_Op;\n+            elsif Op = \"max\" then\n+               return Max_Op;\n+            elsif Op = \"min\" then\n+               return Min_Op;\n+            elsif Op = \"and\" then\n+               return And_Op;\n+            elsif Op = \"or\" then\n+               return Or_Op;\n+            else\n+               Error_Pragma (\"Unsuported reduction operation\");\n+            end if;\n+         end To_Reduction_Op;\n+         Expr : Node_Id;\n+         Reduc_Op : Node_Id;\n+         Reduc_Var : Node_Id;\n+         Seen_Entities : Elist_Id;\n+      begin\n+         --  Reduction operations look like this:\n+         --  (\"+\" => (a, b), \"*\" => c)\n+         Seen_Entities := New_Elmt_List;\n+         Expr := First (Component_Associations (Clause));\n+         while Present (Expr) loop\n+            Reduc_Op := First (Choices (Expr));\n+            String_To_Name_Buffer (Strval (Reduc_Op));\n+            case To_Reduction_Op (Name_Buffer (1 .. Name_Len)) is\n+\n+               when Add_Op | Mul_Op | Max_Op | Min_Op =>\n+                  Reduc_Var := Acc_First (Expression (Expr));\n+                  while Present (Reduc_Var) loop\n+                     Analyze_And_Resolve (Reduc_Var);\n+                     if Contains (Seen_Entities, Entity (Reduc_Var)) then\n+                        Error_Pragma (\"Variable used in multiple reductions\");\n+                     else\n+                        if (Nkind (Reduc_Var) /= N_Identifier)\n+                           or not Is_Numeric_Type (Etype (Reduc_Var))\n+                        then\n+                           Error_Pragma\n+                              (\"Expected an identifier for a Numeric\");\n+                        end if;\n+                        Append_Elmt (Entity (Reduc_Var), Seen_Entities);\n+                     end if;\n+                     Reduc_Var := Acc_Next (Reduc_Var);\n+                  end loop;\n+\n+               when And_Op | Or_Op =>\n+                  Reduc_Var := Acc_First (Expression (Expr));\n+                  while Present (Reduc_Var) loop\n+                     Analyze_And_Resolve (Reduc_Var);\n+                     if Contains (Seen_Entities, Entity (Reduc_Var)) then\n+                        Error_Pragma (\"Variable used in multiple \" &\n+                        \"reductions\");\n+                     else\n+                        if Nkind (Reduc_Var) /= N_Identifier or not\n+                           Is_Boolean_Type (Etype (Reduc_Var))\n+                        then\n+                           Error_Pragma (\"Expected a variable of type \" &\n+                           \"Boolean\");\n+                        end if;\n+                        Append_Elmt (Entity (Reduc_Var), Seen_Entities);\n+                     end if;\n+                     Reduc_Var := Acc_Next (Reduc_Var);\n+                  end loop;\n+            end case;\n+            Expr := Next (Expr);\n+         end loop;\n+      end Validate_Acc_Name_Reduction;\n+\n+      -----------------------------------\n+      -- Validate_Acc_Size_Expressions --\n+      -----------------------------------\n+\n+      procedure Validate_Acc_Size_Expressions (Clause : Node_Id) is\n+\n+         --  A size expr is either an integer expression or \"*\"\n+         function Validate_Size_Expr (Expr : Node_Id) return Boolean;\n+         function Validate_Size_Expr (Expr : Node_Id) return Boolean is\n+         begin\n+            if Nkind (Expr) = N_Operator_Symbol then\n+               return Get_String_Char (Strval (Expr), 1) = Get_Char_Code ('*');\n+            end if;\n+            Analyze_And_Resolve (Expr);\n+            return Is_Integer_Type (Etype (Expr));\n+         end Validate_Size_Expr;\n+\n+         Expr : Node_Id;\n+      begin\n+         Expr := Acc_First (Clause);\n+         while Present (Expr) loop\n+            if not Validate_Size_Expr (Expr) then\n+               Error_Pragma (\"Size expressions should be either integers \" &\n+               \"or '*'\");\n+            end if;\n+            Expr := Acc_Next (Expr);\n+         end loop;\n+      end Validate_Acc_Size_Expressions;\n+\n    --  Start of processing for Analyze_Pragma\n \n    begin\n@@ -12025,6 +12352,256 @@ package body Sem_Prag is\n             Analyze_If_Present (Pragma_Initial_Condition);\n          end Abstract_State;\n \n+         --------------\n+         -- Acc_Data --\n+         --------------\n+\n+         when Pragma_Acc_Data => Acc_Data : declare\n+            Clause_Names : constant Name_List := (\n+               Name_Attach,\n+               Name_Copy,\n+               Name_Copy_In,\n+               Name_Copy_Out,\n+               Name_Create,\n+               Name_Delete,\n+               Name_Detach,\n+               Name_Device_Ptr,\n+               Name_No_Create,\n+               Name_Present\n+               );\n+            Clauses : Args_List (Clause_Names'Range);\n+            Clause : Node_Id;\n+\n+         begin\n+            if not OpenAcc_Enabled then\n+               return;\n+            end if;\n+            GNAT_Pragma;\n+            if Nkind (Parent (N)) /= N_Loop_Statement\n+            then\n+               Error_Pragma (\"Acc_Data pragma should be placed in loop or \"\n+               & \"block statements.\");\n+            end if;\n+            Gather_Associations (Clause_Names, Clauses);\n+            for Id in Clause_Names'First .. Clause_Names'Last loop\n+               Clause := Clauses (Id);\n+               if Present (Clause) then\n+                  case Clause_Names (Id) is\n+                     when Name_Copy\n+                        | Name_Copy_In\n+                        | Name_Copy_Out\n+                        | Name_Create\n+                        | Name_Device_Ptr\n+                        | Name_Present =>\n+                        Validate_Acc_Data_Clause (Clause);\n+                     when Name_Attach\n+                        | Name_Detach\n+                        | Name_Delete\n+                        | Name_No_Create =>\n+                        Error_Pragma (\"Unsupported pragma clause.\");\n+                     when others => raise Program_Error;\n+                  end case;\n+               end if;\n+            end loop;\n+\n+            Set_Is_OpenAcc_Environment (Parent (N));\n+\n+         end Acc_Data;\n+\n+         --------------\n+         -- Acc_Loop --\n+         --------------\n+\n+         when Pragma_Acc_Loop => Acc_Loop : declare\n+\n+            Clause_Names : constant Name_List := (\n+               Name_Auto,\n+               Name_Collapse,\n+               Name_Gang,\n+               Name_Independent,\n+               Name_Acc_Private,\n+               Name_Reduction,\n+               Name_Seq,\n+               Name_Tile,\n+               Name_Vector,\n+               Name_Worker\n+            );\n+            Clauses : Args_List (Clause_Names'Range);\n+            Clause : Node_Id;\n+            Parent_Node : Node_Id;\n+\n+         begin\n+            if not OpenAcc_Enabled then\n+               return;\n+            end if;\n+            GNAT_Pragma;\n+\n+            --  Make sure the pragma is in an openacc construct\n+            Check_Loop_Pragma_Placement;\n+            Parent_Node := Parent (N);\n+            while Present (Parent_Node) and then\n+               (Nkind (Parent_Node) /= N_Loop_Statement or else\n+                not Is_OpenAcc_Environment (Parent_Node)) loop\n+               Parent_Node := Parent (Parent_Node);\n+            end loop;\n+            if not Is_OpenAcc_Environment (Parent_Node) then\n+               Error_Pragma (\"Acc_Loop directive must be associated with an \" &\n+               \"OpenAcc construct region\");\n+            end if;\n+\n+            Gather_Associations (Clause_Names, Clauses);\n+            for Id in Clause_Names'First .. Clause_Names'Last loop\n+               Clause := Clauses (Id);\n+               if Present (Clause) then\n+                  case Clause_Names (Id) is\n+                     when Name_Auto | Name_Independent | Name_Seq => null;\n+                     when Name_Collapse =>\n+                        Validate_Acc_Loop_Collapse (Clause);\n+                     when Name_Gang => Validate_Acc_Loop_Gang (Clause);\n+                     when Name_Acc_Private =>\n+                        Validate_Acc_Data_Clause (Clause);\n+                     when Name_Reduction =>\n+                        Validate_Acc_Name_Reduction (Clause);\n+                     when Name_Tile => Validate_Acc_Size_Expressions (Clause);\n+                     when Name_Vector => Validate_Acc_Loop_Vector (Clause);\n+                     when Name_Worker => Validate_Acc_Loop_Worker (Clause);\n+                     when others => raise Program_Error;\n+                  end case;\n+               end if;\n+            end loop;\n+            Set_Is_OpenAcc_Loop (Parent (N));\n+         end Acc_Loop;\n+\n+         ----------------------------------\n+         -- Acc_Parallel and Acc_Kernels --\n+         ----------------------------------\n+\n+         when Pragma_Acc_Parallel | Pragma_Acc_Kernels =>\n+            Acc_Kernels_Or_Parallel :\n+         declare\n+\n+            Clause_Names : constant Name_List := (\n+               Name_Acc_If,\n+               Name_Async,\n+               Name_Copy,\n+               Name_Copy_In,\n+               Name_Copy_Out,\n+               Name_Create,\n+               Name_Default,\n+               Name_Device_Ptr,\n+               Name_Device_Type,\n+               Name_Num_Gangs,\n+               Name_Num_Workers,\n+               Name_Present,\n+               Name_Vector_Length,\n+               Name_Wait,\n+               --  Parallel only\n+               Name_Acc_Private,\n+               Name_First_Private,\n+               Name_Reduction,\n+               --  Kernels only\n+               Name_Attach,\n+               Name_No_Create\n+               );\n+            Clauses : Args_List (Clause_Names'Range);\n+            Clause : Node_Id;\n+\n+         begin\n+            if not OpenAcc_Enabled then\n+               return;\n+            end if;\n+            GNAT_Pragma;\n+            Check_Loop_Pragma_Placement;\n+\n+            if Nkind (Parent (N)) /= N_Loop_Statement then\n+               Error_Pragma (\"Pragma should be placed in loop or block \"\n+               & \"statements.\");\n+            end if;\n+\n+            Gather_Associations (Clause_Names, Clauses);\n+            for Id in Clause_Names'First .. Clause_Names'Last loop\n+               Clause := Clauses (Id);\n+               if Present (Clause) then\n+                  if Chars (Parent (Clause)) = No_Name then\n+                     Error_Pragma (\"All arguments should be associations\");\n+                  else\n+                     case Clause_Names (Id) is\n+                           --  Note: According to the OpenAcc Standard v2.6,\n+                           --  Async's argument should be optional. Because\n+                           --  this complicates parsing the clause, the\n+                           --  argument is made mandatory. The standard defines\n+                           --  two negative values, acc_async_noval and\n+                           --  acc_async_sync. When given acc_async_noval as\n+                           --  value, the clause should behave as if no\n+                           --  argument was given. According to the standard,\n+                           --  acc_async_noval is defined in header files for C\n+                           --  and Fortran, thus this value should probably be\n+                           --  defined in the OpenAcc Ada library once it is\n+                           --  implemented.\n+                        when Name_Async\n+                           | Name_Num_Gangs\n+                           | Name_Num_Workers\n+                           | Name_Vector_Length =>\n+                           Validate_Acc_Int_Expr_Clause (Clause);\n+\n+                        when Name_Acc_If =>\n+                           Validate_Acc_Condition_Clause (Clause);\n+\n+                           --  Unsupported by GCC\n+                        when Name_Attach\n+                           | Name_No_Create =>\n+                           Error_Pragma (\"Unsupported clause.\");\n+\n+                        when Name_First_Private\n+                           | Name_Acc_Private =>\n+                           if Prag_Id /= Pragma_Acc_Parallel then\n+                              Error_Pragma (\"Argument is only available for\" &\n+                              \" 'Parallel' construct.\");\n+                           else\n+                              Validate_Acc_Data_Clause (Clause);\n+                           end if;\n+\n+                        when Name_Copy\n+                           | Name_Copy_In\n+                           | Name_Copy_Out\n+                           | Name_Present\n+                           | Name_Create\n+                           | Name_Device_Ptr =>\n+                           Validate_Acc_Data_Clause (Clause);\n+\n+                        when Name_Reduction =>\n+                           if Prag_Id /= Pragma_Acc_Parallel then\n+                              Error_Pragma (\"Argument is only available for\" &\n+                              \" 'Parallel' construct.\");\n+                           else\n+                              Validate_Acc_Name_Reduction (Clause);\n+                           end if;\n+\n+                        when Name_Default =>\n+                           if Chars (Clause) /= Name_None then\n+                              Error_Pragma (\"Expected None\");\n+                           end if;\n+\n+                        when Name_Device_Type =>\n+                           Error_Pragma (\"Unsupported pragma clause\");\n+\n+                           --  Same as for Name_Async, Name_Wait's arguments\n+                           --  should be optional. However, this can be\n+                           --  simulated using acc_async_noval, hence, we do\n+                           --  not bother making the argument optional for now.\n+                        when Name_Wait =>\n+                           Validate_Acc_Int_Expr_List_Clause (Clause);\n+\n+                        when others => raise Program_Error;\n+                     end case;\n+                  end if;\n+               end if;\n+            end loop;\n+\n+            Set_Is_OpenAcc_Environment (Parent (N));\n+\n+         end Acc_Kernels_Or_Parallel;\n+\n          ------------\n          -- Ada_83 --\n          ------------\n@@ -30117,6 +30694,10 @@ package body Sem_Prag is\n    Sig_Flags : constant array (Pragma_Id) of Int :=\n      (Pragma_Abort_Defer                    => -1,\n       Pragma_Abstract_State                 => -1,\n+      Pragma_Acc_Data                       =>  0,\n+      Pragma_Acc_Kernels                    =>  0,\n+      Pragma_Acc_Loop                       =>  0,\n+      Pragma_Acc_Parallel                   =>  0,\n       Pragma_Ada_83                         => -1,\n       Pragma_Ada_95                         => -1,\n       Pragma_Ada_05                         => -1,"}, {"sha": "544444188e8707b7e055eec808cce25b086f89d6", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -2069,6 +2069,22 @@ package body Sinfo is\n       return Flag16 (N);\n    end Is_Null_Loop;\n \n+   function Is_OpenAcc_Environment\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      return Flag13 (N);\n+   end Is_OpenAcc_Environment;\n+\n+   function Is_OpenAcc_Loop\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      return Flag14 (N);\n+   end Is_OpenAcc_Loop;\n+\n    function Is_Overloaded\n       (N : Node_Id) return Boolean is\n    begin\n@@ -5527,6 +5543,22 @@ package body Sinfo is\n       Set_Flag16 (N, Val);\n    end Set_Is_Null_Loop;\n \n+   procedure Set_Is_OpenAcc_Environment\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      Set_Flag13 (N, Val);\n+   end Set_Is_OpenAcc_Environment;\n+\n+   procedure Set_Is_OpenAcc_Loop\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      Set_Flag14 (N, Val);\n+   end Set_Is_OpenAcc_Loop;\n+\n    procedure Set_Is_Overloaded\n       (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "bed8b32455b28d654a64ecb7e5b7958b9fef9b9c", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -1896,6 +1896,14 @@ package Sinfo is\n    --    can be determined to be null at compile time. This is used to remove\n    --    the loop entirely at expansion time.\n \n+   --  Is_OpenAcc_Environment (Flag13-Sem)\n+   --    This flag is set in an N_Loop_Statement node if it contains an\n+   --    Acc_Data, Acc_Parallel or Add_Kernels pragma.\n+\n+   --  Is_OpenAcc_Loop (Flag14-Sem)\n+   --    This flag is set in an N_Loop_Statement node if it contains an\n+   --    OpenAcc_Loop pragma.\n+\n    --  Is_Overloaded (Flag5-Sem)\n    --    A flag present in all expression nodes. Used temporarily during\n    --    overloading determination. The setting of this flag is not relevant\n@@ -5129,6 +5137,8 @@ package Sinfo is\n       --  Has_Created_Identifier (Flag15)\n       --  Is_Null_Loop (Flag16)\n       --  Suppress_Loop_Warnings (Flag17)\n+      --  Is_OpenAcc_Environment (Flag13-Sem)\n+      --  Is_OpenAcc_Loop (Flag14-Sem)\n \n       --  Note: the parser fills in the Identifier field if there is an\n       --  explicit loop identifier. Otherwise the parser leaves this field\n@@ -9847,6 +9857,12 @@ package Sinfo is\n    function Is_Null_Loop\n      (N : Node_Id) return Boolean;    -- Flag16\n \n+   function Is_OpenAcc_Environment\n+     (N : Node_Id) return Boolean;    -- Flag13\n+\n+   function Is_OpenAcc_Loop\n+     (N : Node_Id) return Boolean;    -- Flag14\n+\n    function Is_Overloaded\n      (N : Node_Id) return Boolean;    -- Flag5\n \n@@ -10945,6 +10961,12 @@ package Sinfo is\n    procedure Set_Is_Null_Loop\n      (N : Node_Id; Val : Boolean := True);    -- Flag16\n \n+   procedure Set_Is_OpenAcc_Environment\n+     (N : Node_Id; Val : Boolean := True);    -- Flag13\n+\n+   procedure Set_Is_OpenAcc_Loop\n+     (N : Node_Id; Val : Boolean := True);    -- Flag14\n+\n    procedure Set_Is_Overloaded\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n@@ -13450,6 +13472,8 @@ package Sinfo is\n    pragma Inline (Is_Known_Guaranteed_ABE);\n    pragma Inline (Is_Machine_Number);\n    pragma Inline (Is_Null_Loop);\n+   pragma Inline (Is_OpenAcc_Environment);\n+   pragma Inline (Is_OpenAcc_Loop);\n    pragma Inline (Is_Overloaded);\n    pragma Inline (Is_Power_Of_2_For_Shift);\n    pragma Inline (Is_Prefixed_Call);\n@@ -13812,6 +13836,8 @@ package Sinfo is\n    pragma Inline (Set_Is_Known_Guaranteed_ABE);\n    pragma Inline (Set_Is_Machine_Number);\n    pragma Inline (Set_Is_Null_Loop);\n+   pragma Inline (Set_Is_OpenAcc_Environment);\n+   pragma Inline (Set_Is_OpenAcc_Loop);\n    pragma Inline (Set_Is_Overloaded);\n    pragma Inline (Set_Is_Power_Of_2_For_Shift);\n    pragma Inline (Set_Is_Prefixed_Call);"}, {"sha": "0b9e531b089851f50df54dc84e808ce5146b72c8", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 202, "deletions": 166, "changes": 368, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95f2be29446f6d04e4b221b228eac190057d839b/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=95f2be29446f6d04e4b221b228eac190057d839b", "patch": "@@ -480,6 +480,10 @@ package Snames is\n \n    Name_Abort_Defer                    : constant Name_Id := N + $; -- GNAT\n    Name_Abstract_State                 : constant Name_Id := N + $; -- GNAT\n+   Name_Acc_Data                       : constant Name_Id := N + $;\n+   Name_Acc_Kernels                    : constant Name_Id := N + $;\n+   Name_Acc_Loop                       : constant Name_Id := N + $;\n+   Name_Acc_Parallel                   : constant Name_Id := N + $;\n    Name_All_Calls_Remote               : constant Name_Id := N + $;\n    Name_Assert                         : constant Name_Id := N + $; -- Ada 05\n    Name_Assert_And_Cut                 : constant Name_Id := N + $; -- GNAT\n@@ -860,6 +864,34 @@ package Snames is\n    Name_Warn                           : constant Name_Id := N + $;\n    Name_Working_Storage                : constant Name_Id := N + $;\n \n+   --  OpenAcc-specific clause names\n+   --  Parallel, Kernels, Data\n+   Name_Acc_If                         : constant Name_Id := N + $;\n+   Name_Acc_Private                    : constant Name_Id := N + $;\n+   Name_Attach                         : constant Name_Id := N + $;\n+   Name_Copy_In                        : constant Name_Id := N + $;\n+   Name_Copy_Out                       : constant Name_Id := N + $;\n+   Name_Create                         : constant Name_Id := N + $;\n+   Name_Delete                         : constant Name_Id := N + $;\n+   Name_Detach                         : constant Name_Id := N + $;\n+   Name_Device_Ptr                     : constant Name_Id := N + $;\n+   Name_Device_Type                    : constant Name_Id := N + $;\n+   Name_First_Private                  : constant Name_Id := N + $;\n+   Name_No_Create                      : constant Name_Id := N + $;\n+   Name_Num_Gangs                      : constant Name_Id := N + $;\n+   Name_Num_Workers                    : constant Name_Id := N + $;\n+   Name_Present                        : constant Name_Id := N + $;\n+   Name_Reduction                      : constant Name_Id := N + $;\n+   Name_Vector_Length                  : constant Name_Id := N + $;\n+   Name_Wait                           : constant Name_Id := N + $;\n+   --  Loop\n+   Name_Collapse                       : constant Name_Id := N + $;\n+   Name_Gang                           : constant Name_Id := N + $;\n+   Name_Worker                         : constant Name_Id := N + $;\n+   Name_Seq                            : constant Name_Id := N + $;\n+   Name_Auto                           : constant Name_Id := N + $;\n+   Name_Tile                           : constant Name_Id := N + $;\n+\n    --  Names of recognized attributes. The entries with the comment \"Ada 83\"\n    --  are attributes that are defined in Ada 83, but not in Ada 95. These\n    --  attributes are implemented in all Ada modes in GNAT.\n@@ -1310,172 +1342,172 @@ package Snames is\n \n    --  Names with a -- GB annotation are only used in gprbuild or gprclean\n \n-   Name_Active                             : constant Name_Id := N + $;\n-   Name_Aggregate                          : constant Name_Id := N + $;\n-   Name_Archive_Builder                    : constant Name_Id := N + $;\n-   Name_Archive_Builder_Append_Option      : constant Name_Id := N + $;\n-   Name_Archive_Indexer                    : constant Name_Id := N + $;\n-   Name_Archive_Suffix                     : constant Name_Id := N + $;\n-   Name_Artifacts                          : constant Name_Id := N + $;\n-   Name_Artifacts_In_Exec_Dir              : constant Name_Id := N + $; -- GB\n-   Name_Artifacts_In_Object_Dir            : constant Name_Id := N + $; -- GB\n-   Name_Binder                             : constant Name_Id := N + $;\n-   Name_Body_Suffix                        : constant Name_Id := N + $;\n-   Name_Builder                            : constant Name_Id := N + $;\n-   Name_Clean                              : constant Name_Id := N + $;\n-   Name_Compiler                           : constant Name_Id := N + $;\n-   Name_Compiler_Command                   : constant Name_Id := N + $; -- GB\n-   Name_Config_Body_File_Name              : constant Name_Id := N + $;\n-   Name_Config_Body_File_Name_Index        : constant Name_Id := N + $;\n-   Name_Config_Body_File_Name_Pattern      : constant Name_Id := N + $;\n-   Name_Config_File_Switches               : constant Name_Id := N + $;\n-   Name_Config_File_Unique                 : constant Name_Id := N + $;\n-   Name_Config_Spec_File_Name              : constant Name_Id := N + $;\n-   Name_Config_Spec_File_Name_Index        : constant Name_Id := N + $;\n-   Name_Config_Spec_File_Name_Pattern      : constant Name_Id := N + $;\n-   Name_Configuration                      : constant Name_Id := N + $;\n-   Name_Cross_Reference                    : constant Name_Id := N + $;\n-   Name_Default_Language                   : constant Name_Id := N + $;\n-   Name_Default_Switches                   : constant Name_Id := N + $;\n-   Name_Dependency_Driver                  : constant Name_Id := N + $;\n-   Name_Dependency_Kind                    : constant Name_Id := N + $;\n-   Name_Dependency_Switches                : constant Name_Id := N + $;\n-   Name_Driver                             : constant Name_Id := N + $;\n-   Name_Excluded_Source_Dirs               : constant Name_Id := N + $;\n-   Name_Excluded_Source_Files              : constant Name_Id := N + $;\n-   Name_Excluded_Source_List_File          : constant Name_Id := N + $;\n-   Name_Exec_Dir                           : constant Name_Id := N + $;\n-   Name_Exec_Subdir                        : constant Name_Id := N + $;\n-   Name_Excluded_Patterns                  : constant Name_Id := N + $;\n-   Name_Executable                         : constant Name_Id := N + $;\n-   Name_Executable_Suffix                  : constant Name_Id := N + $;\n-   Name_Extends                            : constant Name_Id := N + $;\n-   Name_External_As_List                   : constant Name_Id := N + $;\n-   Name_Externally_Built                   : constant Name_Id := N + $;\n-   Name_Finder                             : constant Name_Id := N + $;\n-   Name_Global_Compilation_Switches        : constant Name_Id := N + $;\n-   Name_Global_Configuration_Pragmas       : constant Name_Id := N + $;\n-   Name_Global_Config_File                 : constant Name_Id := N + $; -- GB\n-   Name_Gnatls                             : constant Name_Id := N + $;\n-   Name_Gnatstub                           : constant Name_Id := N + $;\n-   Name_Gnu                                : constant Name_Id := N + $;\n-   Name_Ide                                : constant Name_Id := N + $;\n-   Name_Ignore_Source_Sub_Dirs             : constant Name_Id := N + $;\n-   Name_Implementation                     : constant Name_Id := N + $;\n-   Name_Implementation_Exceptions          : constant Name_Id := N + $;\n-   Name_Implementation_Suffix              : constant Name_Id := N + $;\n-   Name_Included_Artifact_Patterns         : constant Name_Id := N + $;\n-   Name_Included_Patterns                  : constant Name_Id := N + $;\n-   Name_Include_Switches                   : constant Name_Id := N + $;\n-   Name_Include_Path                       : constant Name_Id := N + $;\n-   Name_Include_Path_File                  : constant Name_Id := N + $;\n-   Name_Inherit_Source_Path                : constant Name_Id := N + $;\n-   Name_Install                            : constant Name_Id := N + $;\n-   Name_Install_Name                       : constant Name_Id := N + $;\n-   Name_Languages                          : constant Name_Id := N + $;\n-   Name_Language_Kind                      : constant Name_Id := N + $;\n-   Name_Leading_Library_Options            : constant Name_Id := N + $;\n-   Name_Leading_Required_Switches          : constant Name_Id := N + $;\n-   Name_Leading_Switches                   : constant Name_Id := N + $;\n-   Name_Lib_Subdir                         : constant Name_Id := N + $;\n-   Name_Link_Lib_Subdir                    : constant Name_Id := N + $;\n-   Name_Library                            : constant Name_Id := N + $;\n-   Name_Library_Ali_Dir                    : constant Name_Id := N + $;\n-   Name_Library_Auto_Init                  : constant Name_Id := N + $;\n-   Name_Library_Auto_Init_Supported        : constant Name_Id := N + $;\n-   Name_Library_Builder                    : constant Name_Id := N + $;\n-   Name_Library_Dir                        : constant Name_Id := N + $;\n-   Name_Library_GCC                        : constant Name_Id := N + $;\n-   Name_Library_Install_Name_Option        : constant Name_Id := N + $;\n-   Name_Library_Interface                  : constant Name_Id := N + $;\n-   Name_Library_Kind                       : constant Name_Id := N + $;\n-   Name_Library_Name                       : constant Name_Id := N + $;\n-   Name_Library_Major_Minor_Id_Supported   : constant Name_Id := N + $;\n-   Name_Library_Options                    : constant Name_Id := N + $;\n-   Name_Library_Partial_Linker             : constant Name_Id := N + $;\n-   Name_Library_Reference_Symbol_File      : constant Name_Id := N + $;\n-   Name_Library_Rpath_Options              : constant Name_Id := N + $; -- GB\n-   Name_Library_Standalone                 : constant Name_Id := N + $;\n-   Name_Library_Encapsulated_Options       : constant Name_Id := N + $; -- GB\n-   Name_Library_Encapsulated_Supported     : constant Name_Id := N + $; -- GB\n-   Name_Library_Src_Dir                    : constant Name_Id := N + $;\n-   Name_Library_Support                    : constant Name_Id := N + $;\n-   Name_Library_Symbol_File                : constant Name_Id := N + $;\n-   Name_Library_Symbol_Policy              : constant Name_Id := N + $;\n-   Name_Library_Version                    : constant Name_Id := N + $;\n-   Name_Library_Version_Switches           : constant Name_Id := N + $;\n-   Name_Linker                             : constant Name_Id := N + $;\n-   Name_Linker_Executable_Option           : constant Name_Id := N + $;\n-   Name_Linker_Lib_Dir_Option              : constant Name_Id := N + $;\n-   Name_Linker_Lib_Name_Option             : constant Name_Id := N + $;\n-   Name_Local_Config_File                  : constant Name_Id := N + $; -- GB\n-   Name_Local_Configuration_Pragmas        : constant Name_Id := N + $;\n-   Name_Locally_Removed_Files              : constant Name_Id := N + $;\n-   Name_Map_File_Option                    : constant Name_Id := N + $;\n-   Name_Mapping_File_Switches              : constant Name_Id := N + $;\n-   Name_Mapping_Spec_Suffix                : constant Name_Id := N + $;\n-   Name_Mapping_Body_Suffix                : constant Name_Id := N + $;\n-   Name_Max_Command_Line_Length            : constant Name_Id := N + $;\n-   Name_Metrics                            : constant Name_Id := N + $;\n-   Name_Multi_Unit_Object_Separator        : constant Name_Id := N + $;\n-   Name_Multi_Unit_Switches                : constant Name_Id := N + $;\n-   Name_Naming                             : constant Name_Id := N + $;\n-   Name_None                               : constant Name_Id := N + $;\n-   Name_Object_Artifact_Extensions         : constant Name_Id := N + $;\n-   Name_Object_File_Suffix                 : constant Name_Id := N + $;\n-   Name_Object_File_Switches               : constant Name_Id := N + $;\n-   Name_Object_Generated                   : constant Name_Id := N + $;\n-   Name_Object_List                        : constant Name_Id := N + $;\n-   Name_Object_Path_Switches               : constant Name_Id := N + $;\n-   Name_Objects_Linked                     : constant Name_Id := N + $;\n-   Name_Objects_Path                       : constant Name_Id := N + $;\n-   Name_Objects_Path_File                  : constant Name_Id := N + $;\n-   Name_Object_Dir                         : constant Name_Id := N + $;\n-   Name_Option_List                        : constant Name_Id := N + $;\n-   Name_Path_Syntax                        : constant Name_Id := N + $;\n-   Name_Pic_Option                         : constant Name_Id := N + $;\n-   Name_Pretty_Printer                     : constant Name_Id := N + $;\n-   Name_Prefix                             : constant Name_Id := N + $;\n-   Name_Project                            : constant Name_Id := N + $;\n-   Name_Project_Dir                        : constant Name_Id := N + $;\n-   Name_Project_Files                      : constant Name_Id := N + $;\n-   Name_Project_Path                       : constant Name_Id := N + $;\n-   Name_Project_Subdir                     : constant Name_Id := N + $;\n-   Name_Remote                             : constant Name_Id := N + $;\n-   Name_Required_Artifacts                 : constant Name_Id := N + $;\n-   Name_Response_File_Format               : constant Name_Id := N + $;\n-   Name_Response_File_Switches             : constant Name_Id := N + $;\n-   Name_Root_Dir                           : constant Name_Id := N + $;\n-   Name_Roots                              : constant Name_Id := N + $; -- GB\n-   Name_Required_Switches                  : constant Name_Id := N + $;\n-   Name_Run_Path_Option                    : constant Name_Id := N + $;\n-   Name_Run_Path_Origin                    : constant Name_Id := N + $;\n-   Name_Separate_Run_Path_Options          : constant Name_Id := N + $;\n-   Name_Shared_Library_Minimum_Switches    : constant Name_Id := N + $;\n-   Name_Shared_Library_Prefix              : constant Name_Id := N + $;\n-   Name_Shared_Library_Suffix              : constant Name_Id := N + $;\n-   Name_Separate_Suffix                    : constant Name_Id := N + $;\n-   Name_Source_Artifact_Extensions         : constant Name_Id := N + $;\n-   Name_Source_Dirs                        : constant Name_Id := N + $;\n-   Name_Source_File_Switches               : constant Name_Id := N + $;\n-   Name_Source_Files                       : constant Name_Id := N + $;\n-   Name_Source_List_File                   : constant Name_Id := N + $;\n-   Name_Sources_Subdir                     : constant Name_Id := N + $;\n-   Name_Spec                               : constant Name_Id := N + $;\n-   Name_Spec_Suffix                        : constant Name_Id := N + $;\n-   Name_Specification                      : constant Name_Id := N + $;\n-   Name_Specification_Exceptions           : constant Name_Id := N + $;\n-   Name_Specification_Suffix               : constant Name_Id := N + $;\n-   Name_Stack                              : constant Name_Id := N + $;\n-   Name_Switches                           : constant Name_Id := N + $;\n-   Name_Symbolic_Link_Supported            : constant Name_Id := N + $;\n-   Name_Synchronize                        : constant Name_Id := N + $;\n-   Name_Toolchain_Description              : constant Name_Id := N + $;\n-   Name_Toolchain_Version                  : constant Name_Id := N + $;\n-   Name_Trailing_Required_Switches         : constant Name_Id := N + $;\n-   Name_Trailing_Switches                  : constant Name_Id := N + $;\n-   Name_Runtime_Library_Dir                : constant Name_Id := N + $;\n-   Name_Runtime_Source_Dir                 : constant Name_Id := N + $;\n+   Name_Active                           : constant Name_Id := N + $;\n+   Name_Aggregate                        : constant Name_Id := N + $;\n+   Name_Archive_Builder                  : constant Name_Id := N + $;\n+   Name_Archive_Builder_Append_Option    : constant Name_Id := N + $;\n+   Name_Archive_Indexer                  : constant Name_Id := N + $;\n+   Name_Archive_Suffix                   : constant Name_Id := N + $;\n+   Name_Artifacts                        : constant Name_Id := N + $;\n+   Name_Artifacts_In_Exec_Dir            : constant Name_Id := N + $; -- GB\n+   Name_Artifacts_In_Object_Dir          : constant Name_Id := N + $; -- GB\n+   Name_Binder                           : constant Name_Id := N + $;\n+   Name_Body_Suffix                      : constant Name_Id := N + $;\n+   Name_Builder                          : constant Name_Id := N + $;\n+   Name_Clean                            : constant Name_Id := N + $;\n+   Name_Compiler                         : constant Name_Id := N + $;\n+   Name_Compiler_Command                 : constant Name_Id := N + $; -- GB\n+   Name_Config_Body_File_Name            : constant Name_Id := N + $;\n+   Name_Config_Body_File_Name_Index      : constant Name_Id := N + $;\n+   Name_Config_Body_File_Name_Pattern    : constant Name_Id := N + $;\n+   Name_Config_File_Switches             : constant Name_Id := N + $;\n+   Name_Config_File_Unique               : constant Name_Id := N + $;\n+   Name_Config_Spec_File_Name            : constant Name_Id := N + $;\n+   Name_Config_Spec_File_Name_Index      : constant Name_Id := N + $;\n+   Name_Config_Spec_File_Name_Pattern    : constant Name_Id := N + $;\n+   Name_Configuration                    : constant Name_Id := N + $;\n+   Name_Cross_Reference                  : constant Name_Id := N + $;\n+   Name_Default_Language                 : constant Name_Id := N + $;\n+   Name_Default_Switches                 : constant Name_Id := N + $;\n+   Name_Dependency_Driver                : constant Name_Id := N + $;\n+   Name_Dependency_Kind                  : constant Name_Id := N + $;\n+   Name_Dependency_Switches              : constant Name_Id := N + $;\n+   Name_Driver                           : constant Name_Id := N + $;\n+   Name_Excluded_Source_Dirs             : constant Name_Id := N + $;\n+   Name_Excluded_Source_Files            : constant Name_Id := N + $;\n+   Name_Excluded_Source_List_File        : constant Name_Id := N + $;\n+   Name_Exec_Dir                         : constant Name_Id := N + $;\n+   Name_Exec_Subdir                      : constant Name_Id := N + $;\n+   Name_Excluded_Patterns                : constant Name_Id := N + $;\n+   Name_Executable                       : constant Name_Id := N + $;\n+   Name_Executable_Suffix                : constant Name_Id := N + $;\n+   Name_Extends                          : constant Name_Id := N + $;\n+   Name_External_As_List                 : constant Name_Id := N + $;\n+   Name_Externally_Built                 : constant Name_Id := N + $;\n+   Name_Finder                           : constant Name_Id := N + $;\n+   Name_Global_Compilation_Switches      : constant Name_Id := N + $;\n+   Name_Global_Configuration_Pragmas     : constant Name_Id := N + $;\n+   Name_Global_Config_File               : constant Name_Id := N + $; -- GB\n+   Name_Gnatls                           : constant Name_Id := N + $;\n+   Name_Gnatstub                         : constant Name_Id := N + $;\n+   Name_Gnu                              : constant Name_Id := N + $;\n+   Name_Ide                              : constant Name_Id := N + $;\n+   Name_Ignore_Source_Sub_Dirs           : constant Name_Id := N + $;\n+   Name_Implementation                   : constant Name_Id := N + $;\n+   Name_Implementation_Exceptions        : constant Name_Id := N + $;\n+   Name_Implementation_Suffix            : constant Name_Id := N + $;\n+   Name_Included_Artifact_Patterns       : constant Name_Id := N + $;\n+   Name_Included_Patterns                : constant Name_Id := N + $;\n+   Name_Include_Switches                 : constant Name_Id := N + $;\n+   Name_Include_Path                     : constant Name_Id := N + $;\n+   Name_Include_Path_File                : constant Name_Id := N + $;\n+   Name_Inherit_Source_Path              : constant Name_Id := N + $;\n+   Name_Install                          : constant Name_Id := N + $;\n+   Name_Install_Name                     : constant Name_Id := N + $;\n+   Name_Languages                        : constant Name_Id := N + $;\n+   Name_Language_Kind                    : constant Name_Id := N + $;\n+   Name_Leading_Library_Options          : constant Name_Id := N + $;\n+   Name_Leading_Required_Switches        : constant Name_Id := N + $;\n+   Name_Leading_Switches                 : constant Name_Id := N + $;\n+   Name_Lib_Subdir                       : constant Name_Id := N + $;\n+   Name_Link_Lib_Subdir                  : constant Name_Id := N + $;\n+   Name_Library                          : constant Name_Id := N + $;\n+   Name_Library_Ali_Dir                  : constant Name_Id := N + $;\n+   Name_Library_Auto_Init                : constant Name_Id := N + $;\n+   Name_Library_Auto_Init_Supported      : constant Name_Id := N + $;\n+   Name_Library_Builder                  : constant Name_Id := N + $;\n+   Name_Library_Dir                      : constant Name_Id := N + $;\n+   Name_Library_GCC                      : constant Name_Id := N + $;\n+   Name_Library_Install_Name_Option      : constant Name_Id := N + $;\n+   Name_Library_Interface                : constant Name_Id := N + $;\n+   Name_Library_Kind                     : constant Name_Id := N + $;\n+   Name_Library_Name                     : constant Name_Id := N + $;\n+   Name_Library_Major_Minor_Id_Supported : constant Name_Id := N + $;\n+   Name_Library_Options                  : constant Name_Id := N + $;\n+   Name_Library_Partial_Linker           : constant Name_Id := N + $;\n+   Name_Library_Reference_Symbol_File    : constant Name_Id := N + $;\n+   Name_Library_Rpath_Options            : constant Name_Id := N + $; -- GB\n+   Name_Library_Standalone               : constant Name_Id := N + $;\n+   Name_Library_Encapsulated_Options     : constant Name_Id := N + $; -- GB\n+   Name_Library_Encapsulated_Supported   : constant Name_Id := N + $; -- GB\n+   Name_Library_Src_Dir                  : constant Name_Id := N + $;\n+   Name_Library_Support                  : constant Name_Id := N + $;\n+   Name_Library_Symbol_File              : constant Name_Id := N + $;\n+   Name_Library_Symbol_Policy            : constant Name_Id := N + $;\n+   Name_Library_Version                  : constant Name_Id := N + $;\n+   Name_Library_Version_Switches         : constant Name_Id := N + $;\n+   Name_Linker                           : constant Name_Id := N + $;\n+   Name_Linker_Executable_Option         : constant Name_Id := N + $;\n+   Name_Linker_Lib_Dir_Option            : constant Name_Id := N + $;\n+   Name_Linker_Lib_Name_Option           : constant Name_Id := N + $;\n+   Name_Local_Config_File                : constant Name_Id := N + $; -- GB\n+   Name_Local_Configuration_Pragmas      : constant Name_Id := N + $;\n+   Name_Locally_Removed_Files            : constant Name_Id := N + $;\n+   Name_Map_File_Option                  : constant Name_Id := N + $;\n+   Name_Mapping_File_Switches            : constant Name_Id := N + $;\n+   Name_Mapping_Spec_Suffix              : constant Name_Id := N + $;\n+   Name_Mapping_Body_Suffix              : constant Name_Id := N + $;\n+   Name_Max_Command_Line_Length          : constant Name_Id := N + $;\n+   Name_Metrics                          : constant Name_Id := N + $;\n+   Name_Multi_Unit_Object_Separator      : constant Name_Id := N + $;\n+   Name_Multi_Unit_Switches              : constant Name_Id := N + $;\n+   Name_Naming                           : constant Name_Id := N + $;\n+   Name_None                             : constant Name_Id := N + $;\n+   Name_Object_Artifact_Extensions       : constant Name_Id := N + $;\n+   Name_Object_File_Suffix               : constant Name_Id := N + $;\n+   Name_Object_File_Switches             : constant Name_Id := N + $;\n+   Name_Object_Generated                 : constant Name_Id := N + $;\n+   Name_Object_List                      : constant Name_Id := N + $;\n+   Name_Object_Path_Switches             : constant Name_Id := N + $;\n+   Name_Objects_Linked                   : constant Name_Id := N + $;\n+   Name_Objects_Path                     : constant Name_Id := N + $;\n+   Name_Objects_Path_File                : constant Name_Id := N + $;\n+   Name_Object_Dir                       : constant Name_Id := N + $;\n+   Name_Option_List                      : constant Name_Id := N + $;\n+   Name_Path_Syntax                      : constant Name_Id := N + $;\n+   Name_Pic_Option                       : constant Name_Id := N + $;\n+   Name_Pretty_Printer                   : constant Name_Id := N + $;\n+   Name_Prefix                           : constant Name_Id := N + $;\n+   Name_Project                          : constant Name_Id := N + $;\n+   Name_Project_Dir                      : constant Name_Id := N + $;\n+   Name_Project_Files                    : constant Name_Id := N + $;\n+   Name_Project_Path                     : constant Name_Id := N + $;\n+   Name_Project_Subdir                   : constant Name_Id := N + $;\n+   Name_Remote                           : constant Name_Id := N + $;\n+   Name_Required_Artifacts               : constant Name_Id := N + $;\n+   Name_Response_File_Format             : constant Name_Id := N + $;\n+   Name_Response_File_Switches           : constant Name_Id := N + $;\n+   Name_Root_Dir                         : constant Name_Id := N + $;\n+   Name_Roots                            : constant Name_Id := N + $; -- GB\n+   Name_Required_Switches                : constant Name_Id := N + $;\n+   Name_Run_Path_Option                  : constant Name_Id := N + $;\n+   Name_Run_Path_Origin                  : constant Name_Id := N + $;\n+   Name_Separate_Run_Path_Options        : constant Name_Id := N + $;\n+   Name_Shared_Library_Minimum_Switches  : constant Name_Id := N + $;\n+   Name_Shared_Library_Prefix            : constant Name_Id := N + $;\n+   Name_Shared_Library_Suffix            : constant Name_Id := N + $;\n+   Name_Separate_Suffix                  : constant Name_Id := N + $;\n+   Name_Source_Artifact_Extensions       : constant Name_Id := N + $;\n+   Name_Source_Dirs                      : constant Name_Id := N + $;\n+   Name_Source_File_Switches             : constant Name_Id := N + $;\n+   Name_Source_Files                     : constant Name_Id := N + $;\n+   Name_Source_List_File                 : constant Name_Id := N + $;\n+   Name_Sources_Subdir                   : constant Name_Id := N + $;\n+   Name_Spec                             : constant Name_Id := N + $;\n+   Name_Spec_Suffix                      : constant Name_Id := N + $;\n+   Name_Specification                    : constant Name_Id := N + $;\n+   Name_Specification_Exceptions         : constant Name_Id := N + $;\n+   Name_Specification_Suffix             : constant Name_Id := N + $;\n+   Name_Stack                            : constant Name_Id := N + $;\n+   Name_Switches                         : constant Name_Id := N + $;\n+   Name_Symbolic_Link_Supported          : constant Name_Id := N + $;\n+   Name_Synchronize                      : constant Name_Id := N + $;\n+   Name_Toolchain_Description            : constant Name_Id := N + $;\n+   Name_Toolchain_Version                : constant Name_Id := N + $;\n+   Name_Trailing_Required_Switches       : constant Name_Id := N + $;\n+   Name_Trailing_Switches                : constant Name_Id := N + $;\n+   Name_Runtime_Library_Dir              : constant Name_Id := N + $;\n+   Name_Runtime_Source_Dir               : constant Name_Id := N + $;\n \n    --  Other miscellaneous names used in front end\n \n@@ -1885,6 +1917,10 @@ package Snames is\n \n       Pragma_Abort_Defer,\n       Pragma_Abstract_State,\n+      Pragma_Acc_Data,\n+      Pragma_Acc_Kernels,\n+      Pragma_Acc_Loop,\n+      Pragma_Acc_Parallel,\n       Pragma_All_Calls_Remote,\n       Pragma_Assert,\n       Pragma_Assert_And_Cut,"}]}