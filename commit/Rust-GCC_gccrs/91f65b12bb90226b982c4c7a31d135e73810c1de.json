{"sha": "91f65b12bb90226b982c4c7a31d135e73810c1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmNjViMTJiYjkwMjI2Yjk4MmM0YzdhMzFkMTM1ZTczODEwYzFkZQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-26T11:48:16Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2013-11-26T11:48:16Z"}, "message": "re PR target/58314 (SH4 error: 'asm' operand requires impossible reload)\n\n\tPR target/58314\n\tPR target/50751\n\t* config/sh/sh.c (max_mov_insn_displacement, disp_addr_displacement):\n\tPrefix function names with 'sh_'.  Make them non-static.\n\t* config/sh/sh-protos.h (sh_disp_addr_displacement,\n\tsh_max_mov_insn_displacement): Add declarations.\n\t* config/sh/constraints.md (Q): Reject QImode.\n\t(Sdd): Use match_code \"mem\".\n\t(Snd): Fix erroneous matching of non-memory operands.\n\t* config/sh/predicates.md (short_displacement_mem_operand): New\n\tpredicate.\n\t(general_movsrc_operand): Disallow PC relative QImode loads.\n\t* config/sh/sh.md (*mov<mode>_reg_reg): Remove it.\n\t(*movqi, *movhi): Merge both insns into...\n\t(*mov<mode>): ... this new insn.  Replace generic 'm' constraints with\n\t'Snd' and 'Sdd' constraints.  Calculate insn length dynamically based\n\ton the operand types.\n\nFrom-SVN: r205390", "tree": {"sha": "f023627b216c6579d7de4bdf913bdc41513ce8a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f023627b216c6579d7de4bdf913bdc41513ce8a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91f65b12bb90226b982c4c7a31d135e73810c1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f65b12bb90226b982c4c7a31d135e73810c1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f65b12bb90226b982c4c7a31d135e73810c1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f65b12bb90226b982c4c7a31d135e73810c1de/comments", "author": null, "committer": null, "parents": [{"sha": "8d590b9cb389dc759d48974e61740e96d61a2605", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d590b9cb389dc759d48974e61740e96d61a2605", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d590b9cb389dc759d48974e61740e96d61a2605"}], "stats": {"total": 150, "additions": 83, "deletions": 67}, "files": [{"sha": "5e25b2534daaa0b66a083e49769c9abac31e86a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -1,3 +1,23 @@\n+2013-11-26  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/58314\n+\tPR target/50751\n+\t* config/sh/sh.c (max_mov_insn_displacement, disp_addr_displacement):\n+\tPrefix function names with 'sh_'.  Make them non-static.\n+\t* config/sh/sh-protos.h (sh_disp_addr_displacement,\n+\tsh_max_mov_insn_displacement): Add declarations.\n+\t* config/sh/constraints.md (Q): Reject QImode.\n+\t(Sdd): Use match_code \"mem\".\n+\t(Snd): Fix erroneous matching of non-memory operands.\n+\t* config/sh/predicates.md (short_displacement_mem_operand): New\n+\tpredicate.\n+\t(general_movsrc_operand): Disallow PC relative QImode loads.\n+\t* config/sh/sh.md (*mov<mode>_reg_reg): Remove it.\n+\t(*movqi, *movhi): Merge both insns into...\n+\t(*mov<mode>): ... this new insn.  Replace generic 'm' constraints with\n+\t'Snd' and 'Sdd' constraints.  Calculate insn length dynamically based\n+\ton the operand types.\n+\n 2013-11-26  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config/epiphany/epiphany.c (epiphany_expand_prologue):"}, {"sha": "df7823764e5e9105f4b1fd6720547cde1c4eb154", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -221,6 +221,7 @@\n (define_constraint \"Q\"\n   \"A pc relative load operand.\"\n   (and (match_code \"mem\")\n+       (match_test \"GET_MODE (op) != QImode\")\n        (match_test \"IS_PC_RELATIVE_LOAD_ADDR_P (XEXP (op, 0))\")))\n \n (define_constraint \"Bsc\"\n@@ -295,13 +296,15 @@\n \n (define_memory_constraint \"Sdd\"\n   \"A memory reference that uses displacement addressing.\"\n-  (and (match_test \"MEM_P (op) && GET_CODE (XEXP (op, 0)) == PLUS\")\n+  (and (match_code \"mem\")\n+       (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n        (match_test \"REG_P (XEXP (XEXP (op, 0), 0))\")\n        (match_test \"CONST_INT_P (XEXP (XEXP (op, 0), 1))\")))\n \n (define_memory_constraint \"Snd\"\n   \"A memory reference that excludes displacement addressing.\"\n-  (match_test \"! satisfies_constraint_Sdd (op)\"))\n+  (and (match_code \"mem\")\n+       (match_test \"! satisfies_constraint_Sdd (op)\")))\n \n (define_memory_constraint \"Sbv\"\n   \"A memory reference, as used in SH2A bclr.b, bset.b, etc.\""}, {"sha": "2aff6ad9e844b45155f84572e237faf79ade90e6", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -421,6 +421,12 @@\n \t\t\t\t\t   XEXP (XEXP (op, 0), 1),\n \t\t\t\t\t   TARGET_SH2A, true)\")))\n \n+;; Returns true if OP is a displacement address that can fit into a\n+;; 16 bit (non-SH2A) memory load / store insn.\n+(define_predicate \"short_displacement_mem_operand\"\n+  (match_test \"sh_disp_addr_displacement (op)\n+\t       <= sh_max_mov_insn_displacement (GET_MODE (op), false)\"))\n+\n ;; Returns 1 if the operand can be used in an SH2A movu.{b|w} insn.\n (define_predicate \"zero_extend_movu_operand\"\n   (and (match_operand 0 \"displacement_mem_operand\")\n@@ -445,6 +451,11 @@\n   if (t_reg_operand (op, mode))\n     return 0;\n \n+  /* Disallow PC relative QImode loads, since these is no insn to do that\n+     and an imm8 load should be used instead.  */\n+  if (IS_PC_RELATIVE_LOAD_ADDR_P (op) && GET_MODE (op) == QImode)\n+    return false;\n+\n   if (MEM_P (op))\n     {\n       rtx inside = XEXP (op, 0);"}, {"sha": "fade1b4c3871e1dd539c1f84c125b8b95a23fbbb", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -162,6 +162,8 @@ extern bool sh_vector_mode_supported_p (enum machine_mode);\n extern bool sh_cfun_trap_exit_p (void);\n extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);\n extern int sh_eval_treg_value (rtx op);\n+extern HOST_WIDE_INT sh_disp_addr_displacement (rtx mem_op);\n+extern int sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a);\n \n /* Result value of sh_find_set_of_reg.  */\n struct set_of_reg"}, {"sha": "3e907b24a9d15df80b6c437bfd569581bbdd3f72", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -316,9 +316,7 @@ static rtx sh_trampoline_adjust_address (rtx);\n static void sh_conditional_register_usage (void);\n static bool sh_legitimate_constant_p (enum machine_mode, rtx);\n static int mov_insn_size (enum machine_mode, bool);\n-static int max_mov_insn_displacement (enum machine_mode, bool);\n static int mov_insn_alignment_mask (enum machine_mode, bool);\n-static HOST_WIDE_INT disp_addr_displacement (rtx);\n static bool sequence_insn_p (rtx);\n static void sh_canonicalize_comparison (int *, rtx *, rtx *, bool);\n static void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n@@ -3582,8 +3580,8 @@ mov_insn_size (enum machine_mode mode, bool consider_sh2a)\n \n /* Determine the maximum possible displacement for a move insn for the\n    specified mode.  */\n-static int\n-max_mov_insn_displacement (enum machine_mode mode, bool consider_sh2a)\n+int\n+sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a)\n {\n   /* The 4 byte displacement move insns are the same as the 2 byte\n      versions but take a 12 bit displacement.  All we need to do is to\n@@ -3619,8 +3617,8 @@ mov_insn_alignment_mask (enum machine_mode mode, bool consider_sh2a)\n }\n \n /* Return the displacement value of a displacement address.  */\n-static inline HOST_WIDE_INT\n-disp_addr_displacement (rtx x)\n+HOST_WIDE_INT\n+sh_disp_addr_displacement (rtx x)\n {\n   gcc_assert (satisfies_constraint_Sdd (x));\n   return INTVAL (XEXP (XEXP (x, 0), 1));\n@@ -3657,12 +3655,12 @@ sh_address_cost (rtx x, enum machine_mode mode,\n \t HImode and QImode loads/stores with displacement put pressure on\n \t R0 which will most likely require another reg copy.  Thus account\n \t a higher cost for that.  */\n-      if (offset > 0 && offset <= max_mov_insn_displacement (mode, false))\n+      if (offset > 0 && offset <= sh_max_mov_insn_displacement (mode, false))\n \treturn (mode == HImode || mode == QImode) ? 2 : 1;\n \n       /* The displacement would fit into a 4 byte move insn (SH2A).  */\n       if (TARGET_SH2A\n-\t  && offset > 0 && offset <= max_mov_insn_displacement (mode, true))\n+\t  && offset > 0 && offset <= sh_max_mov_insn_displacement (mode, true))\n \treturn 2;\n \n       /* The displacement is probably out of range and will require extra\n@@ -10175,7 +10173,7 @@ sh_legitimate_index_p (enum machine_mode mode, rtx op, bool consider_sh2a,\n   else\n     {\n       const HOST_WIDE_INT offset = INTVAL (op);\n-      const int max_disp = max_mov_insn_displacement (mode, consider_sh2a);\n+      const int max_disp = sh_max_mov_insn_displacement (mode, consider_sh2a);\n       const int align_mask = mov_insn_alignment_mask (mode, consider_sh2a);\n \n       /* If the mode does not support any displacement always return false.\n@@ -10361,7 +10359,7 @@ sh_find_mov_disp_adjust (enum machine_mode mode, HOST_WIDE_INT offset)\n      effectively disable the small displacement insns.  */\n   const int mode_sz = GET_MODE_SIZE (mode);\n   const int mov_insn_sz = mov_insn_size (mode, false);\n-  const int max_disp = max_mov_insn_displacement (mode, false);\n+  const int max_disp = sh_max_mov_insn_displacement (mode, false);\n   const int max_disp_next = max_disp + mov_insn_sz;\n   HOST_WIDE_INT align_modifier = offset > 127 ? mov_insn_sz : 0;\n   HOST_WIDE_INT offset_adjust;\n@@ -13121,7 +13119,8 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n      the insns must have the appropriate alternatives.  */\n   if ((mode == QImode || mode == HImode) && rclass != R0_REGS\n       && satisfies_constraint_Sdd (x)\n-      && disp_addr_displacement (x) <= max_mov_insn_displacement (mode, false))\n+      && sh_disp_addr_displacement (x)\n+\t <= sh_max_mov_insn_displacement (mode, false))\n     return R0_REGS;\n \n   /* When reload is trying to address a QImode or HImode subreg on the stack, "}, {"sha": "f79157996d6a249e0fda2458f4deaf7ad84427b9", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 35, "deletions": 54, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f65b12bb90226b982c4c7a31d135e73810c1de/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=91f65b12bb90226b982c4c7a31d135e73810c1de", "patch": "@@ -6993,34 +6993,9 @@ label:\n   prepare_move_operands (operands, QImode);\n })\n \n-;; If movqi_reg_reg is specified as an alternative of movqi, movqi will be\n-;; selected to copy QImode regs.  If one of them happens to be allocated\n-;; on the stack, reload will stick to movqi insn and generate wrong\n-;; displacement addressing because of the generic m alternatives.\n-;; With the movqi_reg_reg being specified before movqi it will be initially\n-;; picked to load/store regs.  If the regs regs are on the stack reload\n-;; try other insns and not stick to movqi_reg_reg, unless there were spilled\n-;; pseudos in which case 'm' constraints pertain.\n-;; The same applies to the movhi variants.\n-;;\n-;; Notice, that T bit is not allowed as a mov src operand here.  This is to\n-;; avoid things like (set (reg:QI) (subreg:QI (reg:SI T_REG) 0)), which\n-;; introduces zero extensions after T bit stores and redundant reg copies.\n-;;\n-;; FIXME: We can't use 'arith_reg_operand' (which disallows T_REG) as a\n-;; predicate for the mov src operand because reload will have trouble\n-;; reloading MAC subregs otherwise.  For that probably special patterns\n-;; would be required.\n-(define_insn \"*mov<mode>_reg_reg\"\n-  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=r,m,*z\")\n-\t(match_operand:QIHI 1 \"register_operand\" \"r,*z,m\"))]\n-  \"TARGET_SH1 && !t_reg_operand (operands[1], VOIDmode)\"\n-  \"@\n-\tmov\t%1,%0\n-\tmov.<bw>\t%1,%0\n-\tmov.<bw>\t%1,%0\"\n-  [(set_attr \"type\" \"move,store,load\")])\n-\n+;; Specifying the displacement addressing load / store patterns separately\n+;; before the generic movqi / movhi pattern allows controlling the order\n+;; in which load / store insns are selected in a more fine grained way.\n ;; FIXME: The non-SH2A and SH2A variants should be combined by adding\n ;; \"enabled\" attribute as it is done in other targets.\n (define_insn \"*mov<mode>_store_mem_disp04\"\n@@ -7070,38 +7045,44 @@ label:\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"2,2,4\")])\n \n-;; The m constraints basically allow any kind of addresses to be used with any\n-;; source/target register as the other operand.  This is not true for \n-;; displacement addressing modes on anything but SH2A.  That's why the\n-;; specialized load/store insns are specified above.\n-(define_insn \"*movqi\"\n-  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,l\")\n-\t(match_operand:QI 1 \"general_movsrc_operand\"  \"i,m,r,l,r\"))]\n+;; The order of the constraint alternatives is important here.\n+;; Q/r has to come first, otherwise PC relative loads might wrongly get\n+;; placed into delay slots.  Since there is no QImode PC relative load, the\n+;; Q constraint and general_movsrc_operand will reject it for QImode.\n+;; The Snd alternatives should come before Sdd in order to avoid a preference\n+;; of using r0 als the register operand for addressing modes other than\n+;; displacement addressing.\n+;; The Sdd alternatives allow only r0 as register operand, even though on\n+;; SH2A any register could be allowed by switching to a 32 bit insn.\n+;; Generally sticking to the r0 is preferrable, since it generates smaller\n+;; code.  Obvious r0 reloads can then be eliminated with a peephole on SH2A.\n+(define_insn \"*mov<mode>\"\n+  [(set (match_operand:QIHI 0 \"general_movdst_operand\"\n+\t\t\t      \"=r,r,r,Snd,r,  Sdd,z,  r,l\")\n+\t(match_operand:QIHI 1 \"general_movsrc_operand\"\n+\t\t\t       \"Q,r,i,r,  Snd,z,  Sdd,l,r\"))]\n   \"TARGET_SH1\n-   && (arith_reg_operand (operands[0], QImode)\n-       || arith_reg_operand (operands[1], QImode))\"\n+   && (arith_reg_operand (operands[0], <MODE>mode)\n+       || arith_reg_operand (operands[1], <MODE>mode))\"\n   \"@\n+\tmov.<bw>\t%1,%0\n \tmov\t%1,%0\n-\tmov.b\t%1,%0\n-\tmov.b\t%1,%0\n-\tsts\t%1,%0\n-\tlds\t%1,%0\"\n- [(set_attr \"type\" \"movi8,load,store,prget,prset\")])\n-\n-(define_insn \"*movhi\"\n-  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,m,r,l\")\n-\t(match_operand:HI 1 \"general_movsrc_operand\"  \"Q,i,m,r,l,r\"))]\n-  \"TARGET_SH1\n-   && (arith_reg_operand (operands[0], HImode)\n-       || arith_reg_operand (operands[1], HImode))\"\n-  \"@\n-\tmov.w\t%1,%0\n \tmov\t%1,%0\n-\tmov.w\t%1,%0\n-\tmov.w\t%1,%0\n+\tmov.<bw>\t%1,%0\n+\tmov.<bw>\t%1,%0\n+\tmov.<bw>\t%1,%0\n+\tmov.<bw>\t%1,%0\n \tsts\t%1,%0\n \tlds\t%1,%0\"\n- [(set_attr \"type\" \"pcload,movi8,load,store,prget,prset\")])\n+  [(set_attr \"type\" \"pcload,move,movi8,store,load,store,load,prget,prset\")\n+   (set (attr \"length\")\n+\t(cond [(and (match_operand 0 \"displacement_mem_operand\")\n+\t\t    (not (match_operand 0 \"short_displacement_mem_operand\")))\n+\t       (const_int 4)\n+\t       (and (match_operand 1 \"displacement_mem_operand\")\n+\t\t    (not (match_operand 1 \"short_displacement_mem_operand\")))\n+\t       (const_int 4)]\n+\t      (const_int 2)))])\n \n (define_insn \"*movqi_media\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m\")"}]}