{"sha": "ef78c245331528fd804584ddde6151dbcd7bee2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY3OGMyNDUzMzE1MjhmZDgwNDU4NGRkZGU2MTUxZGJjZDdiZWUyYw==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-13T01:32:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-04-13T01:32:01Z"}, "message": "Initial revision\n\nFrom-SVN: r19176", "tree": {"sha": "fefc4ffe01dc7b98d2779b3bbcc5f290b55fd22b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fefc4ffe01dc7b98d2779b3bbcc5f290b55fd22b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef78c245331528fd804584ddde6151dbcd7bee2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef78c245331528fd804584ddde6151dbcd7bee2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef78c245331528fd804584ddde6151dbcd7bee2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef78c245331528fd804584ddde6151dbcd7bee2c/comments", "author": null, "committer": null, "parents": [{"sha": "8dd8e7643a92d99cdda3ea160236d74fef6895fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd8e7643a92d99cdda3ea160236d74fef6895fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd8e7643a92d99cdda3ea160236d74fef6895fa"}], "stats": {"total": 169, "additions": 169, "deletions": 0}, "files": [{"sha": "6486102abdc9a7510eef41243d861cc1cbe4ca13", "filename": "gcc/config/i386/rtemself.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef78c245331528fd804584ddde6151dbcd7bee2c/gcc%2Fconfig%2Fi386%2Frtemself.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef78c245331528fd804584ddde6151dbcd7bee2c/gcc%2Fconfig%2Fi386%2Frtemself.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Frtemself.h?ref=ef78c245331528fd804584ddde6151dbcd7bee2c", "patch": "@@ -0,0 +1,169 @@\n+/* Definitions for Intel 386 running Linux-based GNU systems with ELF format.\n+   Copyright (C) 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n+   Contributed by Eric Youngdale.\n+   Modified for stabs-in-ELF by H.J. Lu.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define LINUX_DEFAULT_ELF\n+\n+/* A lie, I guess, but the general idea behind linux/ELF is that we are\n+   supposed to be outputting something that will assemble under SVr4.\n+   This gets us pretty close.  */\n+#include <i386/i386.h>\t/* Base i386 target machine definitions */\n+#include <i386/att.h>\t/* Use the i386 AT&T assembler syntax */\n+#include <linux.h>\t/* some common stuff */\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i386 RTEMS with ELF)\");\n+\n+/* The svr4 ABI for the i386 says that records and unions are returned\n+   in memory.  */\n+#undef DEFAULT_PCC_STRUCT_RETURN\n+#define DEFAULT_PCC_STRUCT_RETURN 1\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   This is only used for PIC code.  See comments by the `casesi' insn in\n+   i386.md for an explanation of the expression this outputs. */\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.long _GLOBAL_OFFSET_TABLE_+[.-%s%d]\\n\", LPREFIX, VALUE)\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\n+\n+/* Copy this from the svr4 specifications... */\n+/* Define the register numbers to be used in Dwarf debugging information.\n+   The SVR4 reference port C compiler uses the following register numbers\n+   in its Dwarf output code:\n+\t0 for %eax (gnu regno = 0)\n+\t1 for %ecx (gnu regno = 2)\n+\t2 for %edx (gnu regno = 1)\n+\t3 for %ebx (gnu regno = 3)\n+\t4 for %esp (gnu regno = 7)\n+\t5 for %ebp (gnu regno = 6)\n+\t6 for %esi (gnu regno = 4)\n+\t7 for %edi (gnu regno = 5)\n+   The following three DWARF register numbers are never generated by\n+   the SVR4 C compiler or by the GNU compilers, but SDB on x86/svr4\n+   believes these numbers have these meanings.\n+\t8  for %eip    (no gnu equivalent)\n+\t9  for %eflags (no gnu equivalent)\n+\t10 for %trapno (no gnu equivalent)\n+   It is not at all clear how we should number the FP stack registers\n+   for the x86 architecture.  If the version of SDB on x86/svr4 were\n+   a bit less brain dead with respect to floating-point then we would\n+   have a precedent to follow with respect to DWARF register numbers\n+   for x86 FP registers, but the SDB on x86/svr4 is so completely\n+   broken with respect to FP registers that it is hardly worth thinking\n+   of it as something to strive for compatibility with.\n+   The version of x86/svr4 SDB I have at the moment does (partially)\n+   seem to believe that DWARF register number 11 is associated with\n+   the x86 register %st(0), but that's about all.  Higher DWARF\n+   register numbers don't seem to be associated with anything in\n+   particular, and even for DWARF regno 11, SDB only seems to under-\n+   stand that it should say that a variable lives in %st(0) (when\n+   asked via an `=' command) if we said it was in DWARF regno 11,\n+   but SDB still prints garbage when asked for the value of the\n+   variable in question (via a `/' command).\n+   (Also note that the labels SDB prints for various FP stack regs\n+   when doing an `x' command are all wrong.)\n+   Note that these problems generally don't affect the native SVR4\n+   C compiler because it doesn't allow the use of -O with -g and\n+   because when it is *not* optimizing, it allocates a memory\n+   location for each floating-point variable, and the memory\n+   location is what gets described in the DWARF AT_location\n+   attribute for the variable in question.\n+   Regardless of the severe mental illness of the x86/svr4 SDB, we\n+   do something sensible here and we use the following DWARF\n+   register numbers.  Note that these are all stack-top-relative\n+   numbers.\n+\t11 for %st(0) (gnu regno = 8)\n+\t12 for %st(1) (gnu regno = 9)\n+\t13 for %st(2) (gnu regno = 10)\n+\t14 for %st(3) (gnu regno = 11)\n+\t15 for %st(4) (gnu regno = 12)\n+\t16 for %st(5) (gnu regno = 13)\n+\t17 for %st(6) (gnu regno = 14)\n+\t18 for %st(7) (gnu regno = 15)\n+*/\n+#undef DBX_REGISTER_NUMBER\n+#define DBX_REGISTER_NUMBER(n) \\\n+((n) == 0 ? 0 \\\n+ : (n) == 1 ? 2 \\\n+ : (n) == 2 ? 1 \\\n+ : (n) == 3 ? 3 \\\n+ : (n) == 4 ? 6 \\\n+ : (n) == 5 ? 7 \\\n+ : (n) == 6 ? 5 \\\n+ : (n) == 7 ? 4 \\\n+ : ((n) >= FIRST_STACK_REG && (n) <= LAST_STACK_REG) ? (n)+3 \\\n+ : (-1))\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tleal %sP%d@GOTOFF(%%ebx),%%edx\\n\",\t\t\\\n+\t       LPREFIX, (LABELNO));\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tcall *mcount@GOT(%%ebx)\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmovl $%sP%d,%%edx\\n\", LPREFIX, (LABELNO));\t\\\n+      fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef SIZE_TYPE\n+#define SIZE_TYPE \"unsigned int\"\n+ \n+#undef PTRDIFF_TYPE\n+#define PTRDIFF_TYPE \"int\"\n+  \n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+   \n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE BITS_PER_WORD\n+    \n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES  \"-Di386 -Drtems -D__rtems__ \\\n+   -Asystem(rtems) -Acpu(i386) -Amachine(i386)\"\n+\n+/* Get perform_* macros to build libgcc.a.  */\n+#include \"i386/perform.h\"\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n+   FILE the assembler definition of uninitialized global DECL named\n+   NAME whose size is SIZE bytes and alignment is ALIGN bytes.\n+   Try to use asm_output_aligned_bss to implement this macro.  */\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+  asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC  \"crt0.o%s\"\n+\n+#undef ENDFILE_SPEC\n+     "}]}