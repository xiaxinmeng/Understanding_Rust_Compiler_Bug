{"sha": "87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdlOWMyYTJmMGZmM2Q0OGQ4ZjBmNGI0ZGMwMDBhZTQ3MTZhYTE2ZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2014-01-26T10:05:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-26T10:05:39Z"}, "message": "a-intnam-lynxos.ads, [...]: Removed, no longer maintained.\n\n2014-01-26  Arnaud Charlet  <charlet@adacore.com>     \n                                                      \n\t* a-intnam-lynxos.ads, mlib-tgt-specific-lynxos.adb,\n\ts-osinte-lynxos-3.adb, s-osinte-lynxos-3.ads, s-osinte-lynxos.adb,\n\ts-osinte-lynxos.ads, s-taprop-lynxos.adb, s-tpopsp-lynxos.adb,\n\tsystem-lynxos-ppc.ads, system-lynxos-x86.ads: Removed, no longer\n\tmaintained.\n\nFrom-SVN: r207114", "tree": {"sha": "773e968dcaf1c86cb25cfa90a968dcbcac7deac2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/773e968dcaf1c86cb25cfa90a968dcbcac7deac2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b4dfb6814dd39b6bee77e76b52164bd864387528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4dfb6814dd39b6bee77e76b52164bd864387528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4dfb6814dd39b6bee77e76b52164bd864387528"}], "stats": {"total": 3996, "additions": 8, "deletions": 3988}, "files": [{"sha": "363c4c91a7134e265de195ac59311e0fb8ffb30c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=87e9c2a2f0ff3d48d8f0f4b4dc000ae4716aa16d", "patch": "@@ -1,3 +1,11 @@\n+2014-01-26  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-intnam-lynxos.ads, mlib-tgt-specific-lynxos.adb,\n+\ts-osinte-lynxos-3.adb, s-osinte-lynxos-3.ads, s-osinte-lynxos.adb,\n+\ts-osinte-lynxos.ads, s-taprop-lynxos.adb, s-tpopsp-lynxos.adb,\n+\tsystem-lynxos-ppc.ads, system-lynxos-x86.ads: Removed, no longer\n+\tmaintained.\n+\n 2014-01-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/Makefile.in: Fix oversight."}, {"sha": "c4e714c8696b4415fa616475df7c72d6284985da", "filename": "gcc/ada/a-intnam-lynxos.ads", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fa-intnam-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fa-intnam-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-intnam-lynxos.ads?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,166 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   A D A . I N T E R R U P T S . N A M E S                --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS version of this package\n-\n---  The following signals are reserved by the run time:\n-\n---  SIGFPE, SIGILL, SIGSEGV, SIGBUS, SIGTRAP, SIGABRT, SIGINT,\n---  SIGWAITING, SIGLWP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF, SIGSTOP, SIGKILL\n-\n---  The pragma Unreserve_All_Interrupts affects the following signal(s):\n-\n---  SIGINT: made available for Ada handler\n-\n-with System.OS_Interface;\n-\n-package Ada.Interrupts.Names is\n-\n-   --  All identifiers in this unit are implementation defined\n-\n-   pragma Implementation_Defined;\n-\n-   --  Beware that the mapping of names to signals may be many-to-one. There\n-   --  may be aliases.\n-\n-   SIGHUP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGHUP;      --  hangup\n-\n-   SIGINT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGINT;      --  interrupt (rubout)\n-\n-   SIGQUIT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)\n-\n-   SIGILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)\n-\n-   SIGTRAP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)\n-\n-   SIGBRK : constant Interrupt_ID :=\n-     System.OS_Interface.SIGBRK;      --  break\n-\n-   SIGIOT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGIOT;      --  IOT instruction\n-\n-   SIGABRT : constant Interrupt_ID := --  used by abort,\n-     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future\n-\n-   SIGCORE : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCORE;     --  kill with core dump\n-\n-   SIGEMT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGEMT;      --  EMT instruction\n-\n-   SIGFPE : constant Interrupt_ID :=\n-     System.OS_Interface.SIGFPE;      --  floating point exception\n-\n-   SIGKILL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)\n-\n-   SIGBUS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGBUS;      --  bus error\n-\n-   SIGSEGV : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSEGV;     --  segmentation violation\n-\n-   SIGSYS : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSYS;      --  bad argument to system call\n-\n-   SIGPIPE : constant Interrupt_ID := --  write on a pipe with\n-     System.OS_Interface.SIGPIPE;     --  no one to read it\n-\n-   SIGALRM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGALRM;     --  alarm clock\n-\n-   SIGTERM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTERM;     --  software termination signal from kill\n-\n-   SIGURG : constant Interrupt_ID :=\n-     System.OS_Interface.SIGURG;      --  urgent condition on IO channel\n-\n-   SIGSTOP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)\n-\n-   SIGTSTP : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTSTP;     --  user stop requested from tty\n-\n-   SIGCONT : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCONT;     --  stopped process has been continued\n-\n-   SIGCLD : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCLD;      --  child status change\n-\n-   SIGCHLD : constant Interrupt_ID :=\n-     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD\n-\n-   SIGTTIN : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTTIN;     --  background tty read attempted\n-\n-   SIGTTOU : constant Interrupt_ID :=\n-     System.OS_Interface.SIGTTOU;     --  background tty write attempted\n-\n-   SIGPOLL : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPOLL;     --  pollable event occurred\n-\n-   SIGIO : constant Interrupt_ID :=   --  input/output possible,\n-     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)\n-\n-   SIGXCPU : constant Interrupt_ID :=\n-     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded\n-\n-   SIGXFSZ : constant Interrupt_ID :=\n-     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded\n-\n-   SIGVTALRM : constant Interrupt_ID :=\n-     System.OS_Interface.SIGVTALRM;   --  virtual timer expired\n-\n-   SIGPROF : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPROF;     --  profiling timer expired\n-\n-   SIGWINCH : constant Interrupt_ID :=\n-     System.OS_Interface.SIGWINCH;    --  window size change\n-\n-   SIGLOST : constant Interrupt_ID :=\n-     System.OS_Interface.SIGLOST;     --  SUN 4.1 compatibility\n-\n-   SIGUSR1 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR1;     --  user defined signal 1\n-\n-   SIGUSR2 : constant Interrupt_ID :=\n-     System.OS_Interface.SIGUSR2;     --  user defined signal 2\n-\n-   SIGPRIO : constant Interrupt_ID :=\n-     System.OS_Interface.SIGPRIO;\n-   --  sent to a process with its priority\n-   --  or group is changed\n-end Ada.Interrupts.Names;"}, {"sha": "cb1f8772e1de880b86a491e06ee46fc6fc76707a", "filename": "gcc/ada/mlib-tgt-specific-lynxos.adb", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fmlib-tgt-specific-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fmlib-tgt-specific-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt-specific-lynxos.adb?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,149 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT COMPILER COMPONENTS                         --\n---                                                                          --\n---                    M L I B . T G T . S P E C I F I C                     --\n---                             (LynxOS Version)                             --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2003-2008, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n--- for  more details.  You should have  received  a copy of the GNU General --\n--- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n--- http://www.gnu.org/licenses for a complete copy of the license.          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is the LynxOS version of the body\n-\n-package body MLib.Tgt.Specific is\n-\n-   --  Non default subprograms\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False);\n-\n-   function DLL_Ext return String;\n-\n-   function Dynamic_Option return String;\n-\n-   function PIC_Option return String;\n-\n-   function Library_Major_Minor_Id_Supported return Boolean;\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean;\n-\n-   function Support_For_Libraries return Library_Support;\n-\n-   ---------------------------\n-   -- Build_Dynamic_Library --\n-   ---------------------------\n-\n-   procedure Build_Dynamic_Library\n-     (Ofiles       : Argument_List;\n-      Options      : Argument_List;\n-      Interfaces   : Argument_List;\n-      Lib_Filename : String;\n-      Lib_Dir      : String;\n-      Symbol_Data  : Symbol_Record;\n-      Driver_Name  : Name_Id := No_Name;\n-      Lib_Version  : String  := \"\";\n-      Auto_Init    : Boolean := False)\n-   is\n-      pragma Unreferenced (Ofiles);\n-      pragma Unreferenced (Options);\n-      pragma Unreferenced (Interfaces);\n-      pragma Unreferenced (Lib_Filename);\n-      pragma Unreferenced (Lib_Dir);\n-      pragma Unreferenced (Symbol_Data);\n-      pragma Unreferenced (Driver_Name);\n-      pragma Unreferenced (Lib_Version);\n-      pragma Unreferenced (Auto_Init);\n-\n-   begin\n-      null;\n-   end Build_Dynamic_Library;\n-\n-   -------------\n-   -- DLL_Ext --\n-   -------------\n-\n-   function DLL_Ext return String is\n-   begin\n-      return \"\";\n-   end DLL_Ext;\n-\n-   --------------------\n-   -- Dynamic_Option --\n-   --------------------\n-\n-   function Dynamic_Option return String is\n-   begin\n-      return \"\";\n-   end Dynamic_Option;\n-\n-   --------------------------------------\n-   -- Library_Major_Minor_Id_Supported --\n-   --------------------------------------\n-\n-   function Library_Major_Minor_Id_Supported return Boolean is\n-   begin\n-      return False;\n-   end Library_Major_Minor_Id_Supported;\n-\n-   ----------------\n-   -- PIC_Option --\n-   ----------------\n-\n-   function PIC_Option return String is\n-   begin\n-      return \"\";\n-   end PIC_Option;\n-\n-   -----------------------------------------------\n-   -- Standalone_Library_Auto_Init_Is_Supported --\n-   -----------------------------------------------\n-\n-   function Standalone_Library_Auto_Init_Is_Supported return Boolean is\n-   begin\n-      return False;\n-   end Standalone_Library_Auto_Init_Is_Supported;\n-\n-   ---------------------------\n-   -- Support_For_Libraries --\n-   ---------------------------\n-\n-   function Support_For_Libraries return Library_Support is\n-   begin\n-      return Static_Only;\n-   end Support_For_Libraries;\n-\n-begin\n-   Build_Dynamic_Library_Ptr := Build_Dynamic_Library'Access;\n-   DLL_Ext_Ptr := DLL_Ext'Access;\n-   Dynamic_Option_Ptr := Dynamic_Option'Access;\n-   Library_Major_Minor_Id_Supported_Ptr :=\n-                                Library_Major_Minor_Id_Supported'Access;\n-   PIC_Option_Ptr := PIC_Option'Access;\n-   Standalone_Library_Auto_Init_Is_Supported_Ptr :=\n-     Standalone_Library_Auto_Init_Is_Supported'Access;\n-   Support_For_Libraries_Ptr := Support_For_Libraries'Access;\n-end MLib.Tgt.Specific;"}, {"sha": "0a4a3deb46398f07d2e50ee9ce7b5b95cc67a696", "filename": "gcc/ada/s-osinte-lynxos-3.adb", "status": "removed", "additions": 0, "deletions": 575, "changes": 575, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos-3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos-3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.adb?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,575 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1999-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS (Native) version of this package\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-package body System.OS_Interface is\n-\n-   use Interfaces.C;\n-\n-   -------------------\n-   -- clock_gettime --\n-   -------------------\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec)\n-      return     int\n-   is\n-      function clock_gettime_base\n-        (clock_id : clockid_t;\n-         tp       : access timespec)\n-         return     int;\n-      pragma Import (C, clock_gettime_base, \"clock_gettime\");\n-\n-   begin\n-      if clock_gettime_base (clock_id, tp) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end clock_gettime;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (TS : timespec) return Duration is\n-   begin\n-      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n-   end To_Duration;\n-\n-   ------------------------\n-   -- To_Target_Priority --\n-   ------------------------\n-\n-   function To_Target_Priority\n-     (Prio : System.Any_Priority) return Interfaces.C.int\n-   is\n-   begin\n-      return Interfaces.C.int (Prio);\n-   end To_Target_Priority;\n-\n-   -----------------\n-   -- To_Timespec --\n-   -----------------\n-\n-   function To_Timespec (D : Duration) return timespec is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return timespec'(tv_sec => S,\n-        tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n-   end To_Timespec;\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait\n-     (set :  access sigset_t;\n-      sig :  access Signal)\n-      return int\n-   is\n-      function sigwait_base\n-        (set   : access sigset_t;\n-         value : System.Address)\n-         return  Signal;\n-      pragma Import (C, sigwait_base, \"sigwait\");\n-\n-   begin\n-      sig.all := sigwait_base (set, Null_Address);\n-\n-      if sig.all = -1 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end sigwait;\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   --  For all the following functions, LynxOS threads has the POSIX Draft 4\n-   --  behavior; it sets errno but the standard Posix requires it to be\n-   --  returned.\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t)\n-      return int\n-   is\n-      function pthread_mutexattr_create\n-        (attr : access pthread_mutexattr_t)\n-         return int;\n-      pragma Import (C, pthread_mutexattr_create, \"pthread_mutexattr_create\");\n-\n-   begin\n-      if pthread_mutexattr_create (attr) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutexattr_init;\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t)\n-      return int\n-   is\n-      function pthread_mutexattr_delete\n-        (attr : access pthread_mutexattr_t)\n-         return int;\n-      pragma Import (C, pthread_mutexattr_delete, \"pthread_mutexattr_delete\");\n-\n-   begin\n-      if pthread_mutexattr_delete (attr) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutexattr_destroy;\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t)\n-      return  int\n-   is\n-      function pthread_mutex_init_base\n-        (mutex : access pthread_mutex_t;\n-         attr  : pthread_mutexattr_t)\n-         return  int;\n-      pragma Import (C, pthread_mutex_init_base, \"pthread_mutex_init\");\n-\n-   begin\n-      if pthread_mutex_init_base (mutex, attr.all) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_init;\n-\n-   function pthread_mutex_destroy\n-     (mutex : access pthread_mutex_t)\n-      return  int\n-   is\n-      function pthread_mutex_destroy_base\n-        (mutex : access pthread_mutex_t)\n-         return  int;\n-      pragma Import (C, pthread_mutex_destroy_base, \"pthread_mutex_destroy\");\n-\n-   begin\n-      if pthread_mutex_destroy_base (mutex) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_destroy;\n-\n-   function pthread_mutex_lock\n-     (mutex : access pthread_mutex_t)\n-      return  int\n-   is\n-      function pthread_mutex_lock_base\n-        (mutex : access pthread_mutex_t)\n-         return  int;\n-      pragma Import (C, pthread_mutex_lock_base, \"pthread_mutex_lock\");\n-\n-   begin\n-      if pthread_mutex_lock_base (mutex) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_lock;\n-\n-   function pthread_mutex_unlock\n-     (mutex : access pthread_mutex_t)\n-      return  int\n-   is\n-      function pthread_mutex_unlock_base\n-        (mutex : access pthread_mutex_t)\n-         return  int;\n-      pragma Import (C, pthread_mutex_unlock_base, \"pthread_mutex_unlock\");\n-\n-   begin\n-      if pthread_mutex_unlock_base (mutex) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_mutex_unlock;\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t)\n-      return int\n-   is\n-      function pthread_condattr_create\n-        (attr : access pthread_condattr_t)\n-         return int;\n-      pragma Import (C, pthread_condattr_create, \"pthread_condattr_create\");\n-\n-   begin\n-      if pthread_condattr_create (attr) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_condattr_init;\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t)\n-      return int\n-   is\n-      function pthread_condattr_delete\n-        (attr : access pthread_condattr_t)\n-         return int;\n-      pragma Import (C, pthread_condattr_delete, \"pthread_condattr_delete\");\n-\n-   begin\n-      if pthread_condattr_delete (attr) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_condattr_destroy;\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t)\n-      return int\n-   is\n-      function pthread_cond_init_base\n-        (cond : access pthread_cond_t;\n-         attr : pthread_condattr_t)\n-         return int;\n-      pragma Import (C, pthread_cond_init_base, \"pthread_cond_init\");\n-\n-   begin\n-      if pthread_cond_init_base (cond, attr.all) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_init;\n-\n-   function pthread_cond_destroy\n-     (cond : access pthread_cond_t)\n-      return int\n-   is\n-      function pthread_cond_destroy_base\n-        (cond : access pthread_cond_t)\n-         return int;\n-      pragma Import (C, pthread_cond_destroy_base, \"pthread_cond_destroy\");\n-\n-   begin\n-      if pthread_cond_destroy_base (cond) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_destroy;\n-\n-   function pthread_cond_signal\n-     (cond : access pthread_cond_t)\n-      return int\n-   is\n-      function pthread_cond_signal_base\n-        (cond : access pthread_cond_t)\n-         return int;\n-      pragma Import (C, pthread_cond_signal_base, \"pthread_cond_signal\");\n-\n-   begin\n-      if pthread_cond_signal_base (cond) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_signal;\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t)\n-      return  int\n-   is\n-      function pthread_cond_wait_base\n-        (cond  : access pthread_cond_t;\n-         mutex : access pthread_mutex_t)\n-         return  int;\n-      pragma Import (C, pthread_cond_wait_base, \"pthread_cond_wait\");\n-\n-   begin\n-      if pthread_cond_wait_base (cond, mutex) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_wait;\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      reltime : access timespec) return int\n-   is\n-      function pthread_cond_timedwait_base\n-        (cond    : access pthread_cond_t;\n-         mutex   : access pthread_mutex_t;\n-         reltime : access timespec) return int;\n-      pragma Import (C, pthread_cond_timedwait_base, \"pthread_cond_timedwait\");\n-\n-   begin\n-      if pthread_cond_timedwait_base (cond, mutex, reltime) /= 0 then\n-         if errno = EAGAIN then\n-            return ETIMEDOUT;\n-         end if;\n-\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_cond_timedwait;\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param)\n-      return   int\n-   is\n-      function pthread_setscheduler\n-        (thread : pthread_t;\n-         policy : int;\n-         prio   : int)\n-         return   int;\n-      pragma Import (C, pthread_setscheduler, \"pthread_setscheduler\");\n-\n-   begin\n-      if pthread_setscheduler (thread, policy, param.sched_priority) = -1 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_setschedparam;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int)\n-      return     int\n-   is\n-      pragma Unreferenced (attr, protocol);\n-   begin\n-      return 0;\n-   end pthread_mutexattr_setprotocol;\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int)\n-      return        int\n-   is\n-      pragma Unreferenced (attr, prioceiling);\n-   begin\n-      return 0;\n-   end pthread_mutexattr_setprioceiling;\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int)\n-      return            int\n-   is\n-      pragma Unreferenced (attr, contentionscope);\n-   begin\n-      return 0;\n-   end pthread_attr_setscope;\n-\n-   function sched_yield return int is\n-      procedure pthread_yield;\n-      pragma Import (C, pthread_yield, \"pthread_yield\");\n-\n-   begin\n-      pthread_yield;\n-      return 0;\n-   end sched_yield;\n-\n-   -----------------------------\n-   --  P1003.1c - Section 16  --\n-   -----------------------------\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int)\n-      return        int\n-   is\n-      pragma Unreferenced (attr, detachstate);\n-   begin\n-      return 0;\n-   end pthread_attr_setdetachstate;\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address)\n-      return          int\n-   is\n-      --  The LynxOS pthread_create doesn't seems to work.\n-      --  Workaround : We're using st_new instead.\n-      --\n-      --   function pthread_create_base\n-      --     (thread        : access pthread_t;\n-      --      attributes    : pthread_attr_t;\n-      --      start_routine : Thread_Body;\n-      --      arg           : System.Address)\n-      --      return          int;\n-      --   pragma Import (C, pthread_create_base, \"pthread_create\");\n-\n-      St : aliased st_t := attributes.st;\n-\n-      function st_new\n-        (start_routine : Thread_Body;\n-         arg           : System.Address;\n-         attributes    : access st_t;\n-         thread        : access pthread_t)\n-         return          int;\n-      pragma Import (C, st_new, \"st_new\");\n-\n-   begin\n-      --  Following code would be used if above commented function worked\n-\n-      --   if pthread_create_base\n-      --        (thread, attributes.all, start_routine, arg) /= 0 then\n-\n-      if st_new (start_routine, arg, St'Access, thread) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_create;\n-\n-   function pthread_detach (thread : pthread_t) return int is\n-      aliased_thread : aliased pthread_t := thread;\n-\n-      function pthread_detach_base (thread : access pthread_t) return int;\n-      pragma Import (C, pthread_detach_base, \"pthread_detach\");\n-\n-   begin\n-      if pthread_detach_base (aliased_thread'Access) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_detach;\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address)\n-      return  int\n-   is\n-      function pthread_setspecific_base\n-        (key   : pthread_key_t;\n-         value : System.Address)\n-         return  int;\n-      pragma Import (C, pthread_setspecific_base, \"pthread_setspecific\");\n-\n-   begin\n-      if pthread_setspecific_base (key, value) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_setspecific;\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address is\n-      procedure pthread_getspecific_base\n-        (key   : pthread_key_t;\n-         value : access System.Address);\n-      pragma Import (C, pthread_getspecific_base, \"pthread_getspecific\");\n-\n-      value : aliased System.Address := System.Null_Address;\n-\n-   begin\n-      pthread_getspecific_base (key, value'Unchecked_Access);\n-      return value;\n-   end pthread_getspecific;\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address is\n-      pragma Warnings (Off, thread);\n-\n-   begin\n-      return Null_Address;\n-   end Get_Stack_Base;\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer)\n-      return       int\n-   is\n-      function pthread_keycreate\n-        (key        : access pthread_key_t;\n-         destructor : destructor_pointer)\n-         return       int;\n-      pragma Import (C, pthread_keycreate, \"pthread_keycreate\");\n-\n-   begin\n-      if pthread_keycreate (key, destructor) /= 0 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end pthread_key_create;\n-\n-   procedure pthread_init is\n-   begin\n-      null;\n-   end pthread_init;\n-\n-end System.OS_Interface;"}, {"sha": "e8288d9f6dd1e77cb62de8e986b93d4e1d4fd822", "filename": "gcc/ada/s-osinte-lynxos-3.ads", "status": "removed", "additions": 0, "deletions": 552, "changes": 552, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos-3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos-3.ads?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,552 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                          GNAT RUN-TIME COMPONENTS                        --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS (Native) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by the tasking run-time (libgnarl).\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-mthreads\");\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype char           is Interfaces.C.char;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 60;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 63;\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for Signal'Size use int'Size;\n-\n-   SIGHUP      : constant := 1; --  hangup\n-   SIGINT      : constant := 2; --  interrupt (rubout)\n-   SIGQUIT     : constant := 3; --  quit (ASCD FS)\n-   SIGILL      : constant := 4; --  illegal instruction (not reset)\n-   SIGTRAP     : constant := 5; --  trace trap (not reset)\n-   SIGBRK      : constant := 6; --  break\n-   SIGIOT      : constant := 6; --  IOT instruction\n-   SIGABRT     : constant := 6; --  used by abort, replace SIGIOT in the future\n-   SIGCORE     : constant := 7; --  kill with core dump\n-   SIGEMT      : constant := 7; --  EMT instruction\n-   SIGFPE      : constant := 8; --  floating point exception\n-   SIGKILL     : constant := 9; --  kill (cannot be caught or ignored)\n-   SIGBUS      : constant := 10; --  bus error\n-   SIGSEGV     : constant := 11; --  segmentation violation\n-   SIGSYS      : constant := 12; --  bad argument to system call\n-   SIGPIPE     : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM     : constant := 14; --  alarm clock\n-   SIGTERM     : constant := 15; --  software termination signal from kill\n-   SIGURG      : constant := 16; --  urgent condition on IO channel\n-   SIGSTOP     : constant := 17; --  stop (cannot be caught or ignored)\n-   SIGTSTP     : constant := 18; --  user stop requested from tty\n-   SIGCONT     : constant := 19; --  stopped process has been continued\n-   SIGCLD      : constant := 20; --  alias for SIGCHLD\n-   SIGCHLD     : constant := 20; --  child status change\n-   SIGTTIN     : constant := 21; --  background tty read attempted\n-   SIGTTOU     : constant := 22; --  background tty write attempted\n-   SIGIO       : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGPOLL     : constant := 23; --  pollable event occurred\n-   SIGXCPU     : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ     : constant := 25; --  filesize limit exceeded\n-   SIGVTALRM   : constant := 26; --  virtual timer expired\n-   SIGPROF     : constant := 27; --  profiling timer expired\n-   SIGWINCH    : constant := 28; --  window size change\n-   SIGLOST     : constant := 29; --  SUN 4.1 compatibility\n-   SIGUSR1     : constant := 30; --  user defined signal 1\n-   SIGUSR2     : constant := 31; --  user defined signal 2\n-   SIGPRIO     : constant := 32; --  sent to a process with its priority or\n-                                 --  group is changed\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF);\n-   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP, SIGPRIO);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type struct_sigaction is record\n-      sa_handler : System.Address;\n-      sa_mask    : sigset_t;\n-      sa_flags   : int;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SA_SIGINFO  : constant := 16#80#;\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := True;\n-   --  Indicates whether time slicing is supported\n-\n-   type timespec is private;\n-\n-   type clockid_t is new int;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Inline (clock_gettime);\n-   --  LynxOS has non standard clock_gettime\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timezone is record\n-      tz_minuteswest : int;\n-      tz_dsttime     : int;\n-   end record;\n-   pragma Convention (C, struct_timezone);\n-   type struct_timezone_ptr is access all struct_timezone;\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 16#00200000#;\n-   SCHED_RR    : constant := 16#00100000#;\n-   SCHED_OTHER : constant := 16#00400000#;\n-\n-   function To_Target_Priority\n-     (Prio : System.Any_Priority) return Interfaces.C.int;\n-   --  Maps System.Any_Priority to a POSIX priority\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   --  lwp_self does not exist on this thread library, revert to pthread_self\n-   --  which is the closest approximation (with getpid). This function is\n-   --  needed to share 7staprop.adb across POSIX-like targets.\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-   pragma Convention (C, Thread_Body);\n-\n-   function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type st_t                is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 0;\n-\n-   PTHREAD_SCOPE_PROCESS : constant := 0;\n-   PTHREAD_SCOPE_SYSTEM  : constant := 1;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Alternate_Stack_Size : constant := 0;\n-   --  No alternate signal stack is used on this platform\n-\n-   Stack_Base_Available : constant Boolean := False;\n-   --  Indicates whether the stack base is available on this target\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 0;\n-   PROT_READ  : constant := 1;\n-   PROT_WRITE : constant := 2;\n-   PROT_EXEC  : constant := 4;\n-   PROT_USER  : constant := 8;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC + PROT_USER;\n-\n-   PROT_ON    : constant := PROT_READ;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait\n-     (set : access sigset_t;\n-      sig : access Signal) return int;\n-   pragma Inline (sigwait);\n-   --  LynxOS has non standard sigwait\n-\n-   function pthread_kill (thread : pthread_t; sig : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : access sigset_t;\n-      oset : access sigset_t) return int;\n-   pragma Import (C, pthread_sigmask, \"sigprocmask\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 11 --\n-   --------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutexattr_init);\n-   --  LynxOS has a nonstandard pthread_mutexattr_init\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutexattr_destroy);\n-   --  Lynxos has a nonstandard pthread_mutexattr_destroy\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Inline (pthread_mutex_init);\n-   --  LynxOS has a nonstandard pthread_mutex_init\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_destroy);\n-   --  LynxOS has a nonstandard pthread_mutex_destroy\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_lock);\n-   --  LynxOS has a nonstandard pthread_mutex_lock\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_mutex_unlock);\n-   --  LynxOS has a nonstandard pthread_mutex_unlock\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_condattr_init);\n-   --  LynxOS has a nonstandard pthread_condattr_init\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_condattr_destroy);\n-   --  LynxOS has a nonstandard pthread_condattr_destroy\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Inline (pthread_cond_init);\n-   --  LynxOS has a non standard pthread_cond_init\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Inline (pthread_cond_destroy);\n-   --  LynxOS has a nonstandard pthread_cond_destroy\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Inline (pthread_cond_signal);\n-   --  LynxOS has a nonstandard pthread_cond_signal\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Inline (pthread_cond_wait);\n-   --  LynxOS has a nonstandard pthread_cond_wait\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      reltime : access timespec) return int;\n-   pragma Inline (pthread_cond_timedwait);\n-   --  LynxOS has a nonstandard pthread_cond_timedwait\n-\n-   Relative_Timed_Wait : constant Boolean := True;\n-   --  pthread_cond_timedwait requires a relative delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_INHERIT : constant := 0;\n-   PTHREAD_PRIO_PROTECT : constant := 0;\n-\n-   type struct_sched_param is record\n-      sched_priority : int;  --  scheduling priority\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Inline (pthread_setschedparam);\n-   --  LynxOS doesn't have pthread_setschedparam.\n-   --  Instead, use pthread_setscheduler\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Inline (pthread_mutexattr_setprotocol);\n-   --  LynxOS doesn't have pthread_mutexattr_setprotocol\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr     : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Inline (pthread_mutexattr_setprioceiling);\n-   --  LynxOS doesn't have pthread_mutexattr_setprioceiling\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   --  LynxOS doesn't have pthread_attr_setscope: all threads have system scope\n-   pragma Inline (pthread_attr_setscope);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy, \"pthread_attr_setsched\");\n-\n-   function sched_yield return int;\n-   --   pragma Import (C, sched_yield, \"sched_yield\");\n-   pragma Inline (sched_yield);\n-\n-   ---------------------------\n-   -- P1003.1c - Section 16 --\n-   ---------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_create\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_delete\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Inline (pthread_attr_setdetachstate);\n-   --  LynxOS doesn't have pthread_attr_setdetachstate\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize, \"pthread_attr_setstacksize\");\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Inline (pthread_create);\n-   --  LynxOS has a non standard pthread_create\n-\n-   function pthread_detach (thread : pthread_t) return int;\n-   pragma Inline (pthread_detach);\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function pthread_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Inline (pthread_setspecific);\n-   --  LynxOS has a non standard pthread_setspecific\n-\n-   function pthread_getspecific (key : pthread_key_t) return System.Address;\n-   pragma Inline (pthread_getspecific);\n-   --  LynxOS has a non standard pthread_getspecific\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-   pragma Convention (C, destructor_pointer);\n-\n-   function pthread_key_create\n-     (key        : access pthread_key_t;\n-      destructor : destructor_pointer) return int;\n-   pragma Inline (pthread_key_create);\n-   --  LynxOS has a non standard pthread_keycreate\n-\n-   procedure pthread_init;\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-private\n-\n-   type sigbit_array is array (1 .. 2) of long;\n-   type sigset_t is record\n-      sa_sigbits : sigbit_array;\n-   end record;\n-   pragma Convention (C_Pass_By_Copy, sigset_t);\n-\n-   type pid_t is new long;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type st_t is record\n-      stksize      : int;\n-      prio         : int;\n-      inheritsched : int;\n-      state        : int;\n-      sched        : int;\n-   end record;\n-   pragma Convention (C, st_t);\n-\n-   type pthread_attr_t is record\n-      st                 : st_t;\n-      pthread_attr_scope : int;  --  ignored\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is new int;\n-\n-   type pthread_mutexattr_t is new int;\n-\n-   type tid_t is new short;\n-   type pthread_t is new tid_t;\n-\n-   type synch_ptr is access all pthread_mutex_t;\n-   type pthread_mutex_t is record\n-      w_count   : int;\n-      mut_owner : int;\n-      id        : unsigned;\n-      next      : synch_ptr;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-\n-   type pthread_cond_t is new pthread_mutex_t;\n-\n-   type pthread_key_t is new int;\n-\n-end System.OS_Interface;"}, {"sha": "4b9957d4a27610b35c05ea4e0734f97d22f44d89", "filename": "gcc/ada/s-osinte-lynxos.adb", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.adb?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,119 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---                     Copyright (C) 2001-2010, AdaCore                     --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS (POSIX Threads) version of this package\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during\n---  tasking operations. It causes infinite loops and other problems.\n-\n-package body System.OS_Interface is\n-\n-   use Interfaces.C;\n-\n-   -----------------\n-   -- To_Duration --\n-   -----------------\n-\n-   function To_Duration (TS : timespec) return Duration is\n-   begin\n-      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;\n-   end To_Duration;\n-\n-   -----------------\n-   -- To_Timespec --\n-   -----------------\n-\n-   function To_Timespec (D : Duration) return timespec is\n-      S : time_t;\n-      F : Duration;\n-\n-   begin\n-      S := time_t (Long_Long_Integer (D));\n-      F := D - Duration (S);\n-\n-      --  If F has negative value due to a round-up, adjust for positive F\n-      --  value.\n-\n-      if F < 0.0 then\n-         S := S - 1;\n-         F := F + 1.0;\n-      end if;\n-\n-      return timespec'(tv_sec => S,\n-                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));\n-   end To_Timespec;\n-\n-   -------------\n-   -- sigwait --\n-   -------------\n-\n-   function sigwait\n-     (set :  access sigset_t;\n-      sig :  access Signal)\n-      return int\n-   is\n-      function sigwaitinfo\n-        (set   : access sigset_t;\n-         info  : System.Address) return Signal;\n-      pragma Import (C, sigwaitinfo, \"sigwaitinfo\");\n-\n-   begin\n-      sig.all := sigwaitinfo (set, Null_Address);\n-\n-      if sig.all = -1 then\n-         return errno;\n-      end if;\n-\n-      return 0;\n-   end sigwait;\n-\n-   --------------------\n-   -- Get_Stack_Base --\n-   --------------------\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address is\n-      pragma Warnings (Off, thread);\n-\n-   begin\n-      return Null_Address;\n-   end Get_Stack_Base;\n-\n-   ------------------\n-   -- pthread_init --\n-   ------------------\n-\n-   procedure pthread_init is\n-   begin\n-      null;\n-   end pthread_init;\n-\n-end System.OS_Interface;"}, {"sha": "7bcbab6072eda97a9647d5861071edf603677876", "filename": "gcc/ada/s-osinte-lynxos.ads", "status": "removed", "additions": 0, "deletions": 578, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-osinte-lynxos.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-osinte-lynxos.ads?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,578 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                   S Y S T E M . O S _ I N T E R F A C E                  --\n---                                                                          --\n---                                  S p e c                                 --\n---                                                                          --\n---             Copyright (C) 1991-1994, Florida State University            --\n---          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS (POSIX Threads) version of this package\n-\n---  This package encapsulates all direct interfaces to OS services\n---  that are needed by the tasking run-time (libgnarl).\n-\n---  PLEASE DO NOT add any with-clauses to this package or remove the pragma\n---  Preelaborate. This package is designed to be a bottom-level (leaf) package.\n-\n-with Ada.Unchecked_Conversion;\n-\n-with Interfaces.C;\n-\n-package System.OS_Interface is\n-   pragma Preelaborate;\n-\n-   pragma Linker_Options (\"-mthreads\");\n-   --  Selects the POSIX 1.c runtime, rather than the non-threading runtime\n-   --  or the deprecated legacy threads library. The -mthreads flag is\n-   --  defined in patch.LynxOS and matches the definition for Lynx's gcc.\n-\n-   subtype int            is Interfaces.C.int;\n-   subtype short          is Interfaces.C.short;\n-   subtype long           is Interfaces.C.long;\n-   subtype unsigned       is Interfaces.C.unsigned;\n-   subtype unsigned_short is Interfaces.C.unsigned_short;\n-   subtype unsigned_long  is Interfaces.C.unsigned_long;\n-   subtype unsigned_char  is Interfaces.C.unsigned_char;\n-   subtype plain_char     is Interfaces.C.plain_char;\n-   subtype size_t         is Interfaces.C.size_t;\n-\n-   -----------\n-   -- Errno --\n-   -----------\n-\n-   function errno return int;\n-   pragma Import (C, errno, \"__get_errno\");\n-\n-   EAGAIN    : constant := 11;\n-   EINTR     : constant := 4;\n-   EINVAL    : constant := 22;\n-   ENOMEM    : constant := 12;\n-   ETIMEDOUT : constant := 60;\n-\n-   -------------\n-   -- Signals --\n-   -------------\n-\n-   Max_Interrupt : constant := 63;\n-\n-   --  Max_Interrupt is the number of OS signals, as defined in:\n-   --\n-   --   /usr/include/sys/signal.h\n-   --\n-   --\n-   --  The lowest numbered signal is 1, but 0 is a valid argument to some\n-   --  library functions, e.g. kill(2). However, 0 is not just another\n-   --  signal: For instance 'I in Signal' and similar should be used with\n-   --  caution.\n-\n-   type Signal is new int range 0 .. Max_Interrupt;\n-   for  Signal'Size use int'Size;\n-\n-   SIGHUP        : constant := 1;  --  hangup\n-   SIGINT        : constant := 2;  --  interrupt (rubout)\n-   SIGQUIT       : constant := 3;  --  quit (ASCD FS)\n-   SIGILL        : constant := 4;  --  illegal instruction (not reset)\n-   SIGTRAP       : constant := 5;  --  trace trap (not reset)\n-   SIGBRK        : constant := 6;  --  break\n-   SIGIOT        : constant := 6;  --  IOT instruction\n-   SIGABRT       : constant := 6;  --  used by abort, replace SIGIOT in future\n-   SIGCORE       : constant := 7;  --  kill with core dump\n-   SIGEMT        : constant := 7;  --  EMT instruction\n-   SIGFPE        : constant := 8;  --  floating point exception\n-   SIGKILL       : constant := 9;  --  kill (cannot be caught or ignored)\n-   SIGBUS        : constant := 10; --  bus error\n-   SIGSEGV       : constant := 11; --  segmentation violation\n-   SIGSYS        : constant := 12; --  bad argument to system call\n-   SIGPIPE       : constant := 13; --  write on a pipe with no one to read it\n-   SIGALRM       : constant := 14; --  alarm clock\n-   SIGTERM       : constant := 15; --  software termination signal from kill\n-   SIGURG        : constant := 16; --  urgent condition on IO channel\n-   SIGSTOP       : constant := 17; --  stop (cannot be caught or ignored)\n-   SIGTSTP       : constant := 18; --  user stop requested from tty\n-   SIGCONT       : constant := 19; --  stopped process has been continued\n-   SIGCLD        : constant := 20; --  alias for SIGCHLD\n-   SIGCHLD       : constant := 20; --  child status change\n-   SIGTTIN       : constant := 21; --  background tty read attempted\n-   SIGTTOU       : constant := 22; --  background tty write attempted\n-   SIGIO         : constant := 23; --  I/O possible (Solaris SIGPOLL alias)\n-   SIGPOLL       : constant := 23; --  pollable event occurred\n-   SIGTHREADKILL : constant := 24; --  Reserved by LynxOS runtime\n-   SIGXCPU       : constant := 24; --  CPU time limit exceeded\n-   SIGXFSZ       : constant := 25; --  filesize limit exceeded\n-   SIGVTALRM     : constant := 26; --  virtual timer expired\n-   SIGPROF       : constant := 27; --  profiling timer expired\n-   SIGWINCH      : constant := 28; --  window size change\n-   SIGLOST       : constant := 29; --  SUN 4.1 compatibility\n-   SIGUSR1       : constant := 30; --  user defined signal 1\n-   SIGUSR2       : constant := 31; --  user defined signal 2\n-\n-   SIGPRIO       : constant := 32;\n-   --  sent to a process with its priority or group is changed\n-\n-   SIGADAABORT : constant := SIGABRT;\n-   --  Change this if you want to use another signal for task abort.\n-   --  SIGTERM might be a good one.\n-\n-   type Signal_Set is array (Natural range <>) of Signal;\n-\n-   Unmasked    : constant Signal_Set :=\n-     (SIGTRAP, SIGTTIN, SIGTTOU, SIGTSTP, SIGPROF, SIGTHREADKILL);\n-   Reserved    : constant Signal_Set := (SIGABRT, SIGKILL, SIGSTOP, SIGPRIO);\n-\n-   type sigset_t is private;\n-\n-   function sigaddset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigaddset, \"sigaddset\");\n-\n-   function sigdelset (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigdelset, \"sigdelset\");\n-\n-   function sigfillset (set : access sigset_t) return int;\n-   pragma Import (C, sigfillset, \"sigfillset\");\n-\n-   function sigismember (set : access sigset_t; sig : Signal) return int;\n-   pragma Import (C, sigismember, \"sigismember\");\n-\n-   function sigemptyset (set : access sigset_t) return int;\n-   pragma Import (C, sigemptyset, \"sigemptyset\");\n-\n-   type struct_sigaction is record\n-      sa_handler   : System.Address;\n-      sa_mask      : sigset_t;\n-      sa_flags     : int;\n-   end record;\n-   pragma Convention (C, struct_sigaction);\n-   type struct_sigaction_ptr is access all struct_sigaction;\n-\n-   SA_SIGINFO : constant := 16#80#;\n-\n-   SA_ONSTACK : constant := 16#00#;\n-   --  SA_ONSTACK is not defined on LynxOS, but it is referred to in the POSIX\n-   --  implementation of System.Interrupt_Management. Therefore we define a\n-   --  dummy value of zero here so that setting this flag is a nop.\n-\n-   SIG_BLOCK   : constant := 0;\n-   SIG_UNBLOCK : constant := 1;\n-   SIG_SETMASK : constant := 2;\n-\n-   SIG_DFL : constant := 0;\n-   SIG_IGN : constant := 1;\n-\n-   function sigaction\n-     (sig  : Signal;\n-      act  : struct_sigaction_ptr;\n-      oact : struct_sigaction_ptr) return int;\n-   pragma Import (C, sigaction, \"sigaction\");\n-\n-   ----------\n-   -- Time --\n-   ----------\n-\n-   Time_Slice_Supported : constant Boolean := True;\n-   --  Indicates whether time slicing is supported\n-\n-   type timespec is private;\n-\n-   type clockid_t is new int;\n-\n-   function clock_gettime\n-     (clock_id : clockid_t;\n-      tp       : access timespec) return int;\n-   pragma Import (C, clock_gettime, \"clock_gettime\");\n-\n-   function clock_getres\n-     (clock_id : clockid_t;\n-      res      : access timespec) return int;\n-   pragma Import (C, clock_getres, \"clock_getres\");\n-\n-   function To_Duration (TS : timespec) return Duration;\n-   pragma Inline (To_Duration);\n-\n-   function To_Timespec (D : Duration) return timespec;\n-   pragma Inline (To_Timespec);\n-\n-   type struct_timezone is record\n-      tz_minuteswest : int;\n-      tz_dsttime     : int;\n-   end record;\n-   pragma Convention (C, struct_timezone);\n-   type struct_timezone_ptr is access all struct_timezone;\n-\n-   -------------------------\n-   -- Priority Scheduling --\n-   -------------------------\n-\n-   SCHED_FIFO  : constant := 16#200000#;\n-   SCHED_RR    : constant := 16#100000#;\n-   SCHED_OTHER : constant := 16#400000#;\n-\n-   -------------\n-   -- Process --\n-   -------------\n-\n-   type pid_t is private;\n-\n-   function kill (pid : pid_t; sig : Signal) return int;\n-   pragma Import (C, kill, \"kill\");\n-\n-   function getpid return pid_t;\n-   pragma Import (C, getpid, \"getpid\");\n-\n-   ---------\n-   -- LWP --\n-   ---------\n-\n-   function lwp_self return System.Address;\n-   pragma Import (C, lwp_self, \"pthread_self\");\n-\n-   -------------\n-   -- Threads --\n-   -------------\n-\n-   type Thread_Body is access\n-     function (arg : System.Address) return System.Address;\n-   pragma Convention (C, Thread_Body);\n-\n-   function Thread_Body_Access is new\n-     Ada.Unchecked_Conversion (System.Address, Thread_Body);\n-\n-   type pthread_t           is private;\n-   subtype Thread_Id        is pthread_t;\n-\n-   type pthread_mutex_t     is limited private;\n-   type pthread_cond_t      is limited private;\n-   type pthread_attr_t      is limited private;\n-   type pthread_mutexattr_t is limited private;\n-   type pthread_condattr_t  is limited private;\n-   type pthread_key_t       is private;\n-\n-   PTHREAD_CREATE_DETACHED : constant := 1;\n-   PTHREAD_CREATE_JOINABLE : constant := 0;\n-\n-   -----------\n-   -- Stack --\n-   -----------\n-\n-   Alternate_Stack_Size : constant := 0;\n-   --  No alternate signal stack is used on this platform\n-\n-   Stack_Base_Available : constant Boolean := False;\n-   --  Indicates whether the stack base is available on this target\n-\n-   function Get_Stack_Base (thread : pthread_t) return Address;\n-   pragma Inline (Get_Stack_Base);\n-   --  Returns the stack base of the specified thread.\n-   --  Only call this function when Stack_Base_Available is True.\n-\n-   function Get_Page_Size return size_t;\n-   function Get_Page_Size return Address;\n-   pragma Import (C, Get_Page_Size, \"getpagesize\");\n-   --  Returns the size of a page, or 0 if this is not relevant on this\n-   --  target\n-\n-   PROT_NONE  : constant := 1;\n-   PROT_READ  : constant := 2;\n-   PROT_WRITE : constant := 4;\n-   PROT_EXEC  : constant := 8;\n-   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;\n-\n-   PROT_ON    : constant := PROT_READ;\n-   PROT_OFF   : constant := PROT_ALL;\n-\n-   function mprotect (addr : Address; len : size_t; prot : int) return int;\n-   pragma Import (C, mprotect);\n-\n-   ---------------------------------------\n-   -- Nonstandard Thread Initialization --\n-   ---------------------------------------\n-\n-   procedure pthread_init;\n-   --  This is a dummy procedure to share some GNULLI files\n-\n-   -------------------------\n-   -- POSIX.1c  Section 3 --\n-   -------------------------\n-\n-   function sigwait\n-     (set : access sigset_t;\n-      sig : access Signal) return int;\n-   pragma Inline (sigwait);\n-   --  LynxOS has non standard sigwait\n-\n-   function pthread_kill\n-     (thread : pthread_t;\n-      sig    : Signal) return int;\n-   pragma Import (C, pthread_kill, \"pthread_kill\");\n-\n-   function pthread_sigmask\n-     (how  : int;\n-      set  : access sigset_t;\n-      oset : access sigset_t) return int;\n-   pragma Import (C, pthread_sigmask, \"pthread_sigmask\");\n-   --  The behavior of pthread_sigmask on LynxOS requires\n-   --  further investigation.\n-\n-   ----------------------------\n-   --  POSIX.1c  Section 11  --\n-   ----------------------------\n-\n-   function pthread_mutexattr_init\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_init, \"pthread_mutexattr_init\");\n-\n-   function pthread_mutexattr_destroy\n-     (attr : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutexattr_destroy, \"pthread_mutexattr_destroy\");\n-\n-   function pthread_mutex_init\n-     (mutex : access pthread_mutex_t;\n-      attr  : access pthread_mutexattr_t) return int;\n-   pragma Import (C, pthread_mutex_init, \"pthread_mutex_init\");\n-\n-   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_destroy, \"pthread_mutex_destroy\");\n-\n-   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_lock, \"pthread_mutex_lock\");\n-\n-   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_mutex_unlock, \"pthread_mutex_unlock\");\n-\n-   function pthread_condattr_init\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_init, \"pthread_condattr_init\");\n-\n-   function pthread_condattr_destroy\n-     (attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_condattr_destroy, \"pthread_condattr_destroy\");\n-\n-   function pthread_cond_init\n-     (cond : access pthread_cond_t;\n-      attr : access pthread_condattr_t) return int;\n-   pragma Import (C, pthread_cond_init, \"pthread_cond_init\");\n-\n-   function pthread_cond_destroy (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_destroy, \"pthread_cond_destroy\");\n-\n-   function pthread_cond_signal (cond : access pthread_cond_t) return int;\n-   pragma Import (C, pthread_cond_signal, \"pthread_cond_signal\");\n-\n-   function pthread_cond_wait\n-     (cond  : access pthread_cond_t;\n-      mutex : access pthread_mutex_t) return int;\n-   pragma Import (C, pthread_cond_wait, \"pthread_cond_wait\");\n-\n-   function pthread_cond_timedwait\n-     (cond    : access pthread_cond_t;\n-      mutex   : access pthread_mutex_t;\n-      abstime : access timespec) return int;\n-   pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n-\n-   Relative_Timed_Wait : constant Boolean := False;\n-   --  pthread_cond_timedwait requires an absolute delay time\n-\n-   --------------------------\n-   -- POSIX.1c  Section 13 --\n-   --------------------------\n-\n-   PTHREAD_PRIO_NONE    : constant := 0;\n-   PTHREAD_PRIO_INHERIT : constant := 1;\n-   PTHREAD_PRIO_PROTECT : constant := 2;\n-\n-   function pthread_mutexattr_setprotocol\n-     (attr     : access pthread_mutexattr_t;\n-      protocol : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprotocol);\n-\n-   function pthread_mutexattr_setprioceiling\n-     (attr        : access pthread_mutexattr_t;\n-      prioceiling : int) return int;\n-   pragma Import (C, pthread_mutexattr_setprioceiling);\n-\n-   type struct_sched_param is record\n-      sched_priority : int;\n-   end record;\n-\n-   function pthread_setschedparam\n-     (thread : pthread_t;\n-      policy : int;\n-      param  : access struct_sched_param) return int;\n-   pragma Import (C, pthread_setschedparam, \"pthread_setschedparam\");\n-\n-   function pthread_attr_setscope\n-     (attr            : access pthread_attr_t;\n-      contentionscope : int) return int;\n-   pragma Import (C, pthread_attr_setscope, \"pthread_attr_setscope\");\n-\n-   function pthread_attr_setinheritsched\n-     (attr         : access pthread_attr_t;\n-      inheritsched : int) return int;\n-   pragma Import (C, pthread_attr_setinheritsched);\n-\n-   function pthread_attr_setschedpolicy\n-     (attr   : access pthread_attr_t;\n-      policy : int) return int;\n-   pragma Import (C, pthread_attr_setschedpolicy);\n-\n-   function sched_yield return int;\n-   pragma Import (C, sched_yield, \"sched_yield\");\n-\n-   --------------------------\n-   -- P1003.1c  Section 16 --\n-   --------------------------\n-\n-   function pthread_attr_init (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_init, \"pthread_attr_init\");\n-\n-   function pthread_attr_destroy\n-     (attributes : access pthread_attr_t) return int;\n-   pragma Import (C, pthread_attr_destroy, \"pthread_attr_destroy\");\n-\n-   function pthread_attr_setdetachstate\n-     (attr        : access pthread_attr_t;\n-      detachstate : int) return int;\n-   pragma Import (C, pthread_attr_setdetachstate);\n-\n-   function pthread_attr_setstacksize\n-     (attr      : access pthread_attr_t;\n-      stacksize : size_t) return int;\n-   pragma Import (C, pthread_attr_setstacksize);\n-\n-   function pthread_create\n-     (thread        : access pthread_t;\n-      attributes    : access pthread_attr_t;\n-      start_routine : Thread_Body;\n-      arg           : System.Address) return int;\n-   pragma Import (C, pthread_create, \"pthread_create\");\n-\n-   procedure pthread_exit (status : System.Address);\n-   pragma Import (C, pthread_exit, \"pthread_exit\");\n-\n-   function pthread_self return pthread_t;\n-   pragma Import (C, pthread_self, \"pthread_self\");\n-\n-   --------------------------\n-   -- POSIX.1c  Section 17 --\n-   --------------------------\n-\n-   function st_setspecific\n-     (key   : pthread_key_t;\n-      value : System.Address) return int;\n-   pragma Import (C, st_setspecific, \"st_setspecific\");\n-\n-   function st_getspecific\n-     (key    : pthread_key_t;\n-      retval : System.Address) return int;\n-   pragma Import (C, st_getspecific, \"st_getspecific\");\n-\n-   type destructor_pointer is access procedure (arg : System.Address);\n-   pragma Convention (C, destructor_pointer);\n-\n-   function st_keycreate\n-     (destructor : destructor_pointer;\n-      key        : access pthread_key_t) return int;\n-   pragma Import (C, st_keycreate, \"st_keycreate\");\n-\n-private\n-\n-   type sigset_t is record\n-      X1, X2 : long;\n-   end record;\n-   pragma Convention (C, sigset_t);\n-\n-   type pid_t is new long;\n-\n-   type time_t is new long;\n-\n-   type timespec is record\n-      tv_sec  : time_t;\n-      tv_nsec : long;\n-   end record;\n-   pragma Convention (C, timespec);\n-\n-   type st_attr_t is record\n-      stksize      : int;\n-      prio         : int;\n-      inheritsched : int;\n-      state        : int;\n-      sched        : int;\n-      detachstate  : int;\n-      guardsize    : int;\n-   end record;\n-   pragma Convention (C, st_attr_t);\n-\n-   type pthread_attr_t is record\n-      pthread_attr_magic : unsigned;\n-      st                 : st_attr_t;\n-      pthread_attr_scope : int;\n-   end record;\n-   pragma Convention (C, pthread_attr_t);\n-\n-   type pthread_condattr_t is record\n-      cv_magic   : unsigned;\n-      cv_pshared : unsigned;\n-   end record;\n-   pragma Convention (C, pthread_condattr_t);\n-\n-   type pthread_mutexattr_t is record\n-      m_flags   : unsigned;\n-      m_prio_c  : int;\n-      m_pshared : int;\n-   end record;\n-   pragma Convention (C, pthread_mutexattr_t);\n-\n-   type tid_t is new short;\n-   type pthread_t is new tid_t;\n-\n-   type block_obj_t is new System.Address;\n-   --  typedef struct _block_obj_s {\n-   --     struct st_entry *b_head;\n-   --  } block_obj_t;\n-\n-   type pthread_mutex_t is record\n-      m_flags      : unsigned;\n-      m_owner      : tid_t;\n-      m_wait       : block_obj_t;\n-      m_prio_c     : int;\n-      m_oldprio    : int;\n-      m_count      : int;\n-      m_referenced : int;\n-   end record;\n-   pragma Convention (C, pthread_mutex_t);\n-   type pthread_mutex_t_ptr is access all pthread_mutex_t;\n-\n-   type pthread_cond_t is record\n-      cv_magic  : unsigned;\n-      cv_wait   : block_obj_t;\n-      cv_mutex  : pthread_mutex_t_ptr;\n-      cv_refcnt : int;\n-   end record;\n-   pragma Convention (C, pthread_cond_t);\n-\n-   type pthread_key_t is new int;\n-\n-end System.OS_Interface;"}, {"sha": "d553f1e69ab15997dbbd5366210be5bcc4cc4cb4", "filename": "gcc/ada/s-taprop-lynxos.adb", "status": "removed", "additions": 0, "deletions": 1423, "changes": 1423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-taprop-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-taprop-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-taprop-lynxos.adb?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,1423 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---     S Y S T E M . T A S K _ P R I M I T I V E S . O P E R A T I O N S    --\n---                                                                          --\n---                                  B o d y                                 --\n---                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS version of this file, adapted to make SCHED_FIFO and\n---  ceiling locking (Annex D compliance) work properly.\n-\n---  This package contains all the GNULL primitives that interface directly with\n---  the underlying OS.\n-\n-pragma Polling (Off);\n---  Turn off polling, we do not want ATC polling to take place during tasking\n---  operations. It causes infinite loops and other problems.\n-\n-with Ada.Unchecked_Deallocation;\n-\n-with Interfaces.C;\n-\n-with System.Tasking.Debug;\n-with System.Interrupt_Management;\n-with System.OS_Primitives;\n-with System.Task_Info;\n-\n-with System.Soft_Links;\n---  We use System.Soft_Links instead of System.Tasking.Initialization\n---  because the later is a higher level package that we shouldn't depend on.\n---  For example when using the restricted run time, it is replaced by\n---  System.Tasking.Restricted.Stages.\n-\n-package body System.Task_Primitives.Operations is\n-\n-   package SSL renames System.Soft_Links;\n-\n-   use System.Tasking.Debug;\n-   use System.Tasking;\n-   use Interfaces.C;\n-   use System.OS_Interface;\n-   use System.Parameters;\n-   use System.OS_Primitives;\n-\n-   ----------------\n-   -- Local Data --\n-   ----------------\n-\n-   --  The followings are logically constants, but need to be initialized\n-   --  at run time.\n-\n-   Single_RTS_Lock : aliased RTS_Lock;\n-   --  This is a lock to allow only one thread of control in the RTS at\n-   --  a time; it is used to execute in mutual exclusion from all other tasks.\n-   --  Used mainly in Single_Lock mode, but also to protect All_Tasks_List\n-\n-   ATCB_Key : aliased pthread_key_t;\n-   --  Key used to find the Ada Task_Id associated with a thread\n-\n-   Environment_Task_Id : Task_Id;\n-   --  A variable to hold Task_Id for the environment task\n-\n-   Locking_Policy : Character;\n-   pragma Import (C, Locking_Policy, \"__gl_locking_policy\");\n-   --  Value of the pragma Locking_Policy:\n-   --    'C' for Ceiling_Locking\n-   --    'I' for Inherit_Locking\n-   --    ' ' for none.\n-\n-   Unblocked_Signal_Mask : aliased sigset_t;\n-   --  The set of signals that should unblocked in all tasks\n-\n-   --  The followings are internal configuration constants needed\n-\n-   Next_Serial_Number : Task_Serial_Number := 100;\n-   --  We start at 100, to reserve some special values for\n-   --  using in error checking.\n-\n-   Time_Slice_Val : Integer;\n-   pragma Import (C, Time_Slice_Val, \"__gl_time_slice_val\");\n-\n-   Dispatching_Policy : Character;\n-   pragma Import (C, Dispatching_Policy, \"__gl_task_dispatching_policy\");\n-\n-   Foreign_Task_Elaborated : aliased Boolean := True;\n-   --  Used to identified fake tasks (i.e., non-Ada Threads)\n-\n-   --------------------\n-   -- Local Packages --\n-   --------------------\n-\n-   package Specific is\n-\n-      procedure Initialize (Environment_Task : Task_Id);\n-      pragma Inline (Initialize);\n-      --  Initialize various data needed by this package\n-\n-      function Is_Valid_Task return Boolean;\n-      pragma Inline (Is_Valid_Task);\n-      --  Does the current thread have an ATCB?\n-\n-      procedure Set (Self_Id : Task_Id);\n-      pragma Inline (Set);\n-      --  Set the self id for the current task\n-\n-      function Self return Task_Id;\n-      pragma Inline (Self);\n-      --  Return a pointer to the Ada Task Control Block of the calling task\n-\n-   end Specific;\n-\n-   package body Specific is separate;\n-   --  The body of this package is target specific\n-\n-   ---------------------------------\n-   -- Support for foreign threads --\n-   ---------------------------------\n-\n-   function Register_Foreign_Thread (Thread : Thread_Id) return Task_Id;\n-   --  Allocate and Initialize a new ATCB for the current Thread\n-\n-   function Register_Foreign_Thread\n-     (Thread : Thread_Id) return Task_Id is separate;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Abort_Handler (Sig : Signal);\n-   --  Signal handler used to implement asynchronous abort\n-\n-   procedure Set_OS_Priority (T : Task_Id; Prio : System.Any_Priority);\n-   --  This procedure calls the scheduler of the OS to set thread's priority\n-\n-   -------------------\n-   -- Abort_Handler --\n-   -------------------\n-\n-   procedure Abort_Handler (Sig : Signal) is\n-      pragma Unreferenced (Sig);\n-\n-      T       : constant Task_Id := Self;\n-      Result  : Interfaces.C.int;\n-      Old_Set : aliased sigset_t;\n-\n-   begin\n-      --  It is not safe to raise an exception when using ZCX and the GCC\n-      --  exception handling mechanism.\n-\n-      if ZCX_By_Default and then GCC_ZCX_Support then\n-         return;\n-      end if;\n-\n-      if T.Deferral_Level = 0\n-        and then T.Pending_ATC_Level < T.ATC_Nesting_Level\n-        and then not T.Aborting\n-      then\n-         T.Aborting := True;\n-\n-         --  Make sure signals used for RTS internal purpose are unmasked\n-\n-         Result :=\n-           pthread_sigmask\n-             (SIG_UNBLOCK,\n-              Unblocked_Signal_Mask'Access,\n-              Old_Set'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Standard'Abort_Signal;\n-      end if;\n-   end Abort_Handler;\n-\n-   -----------------\n-   -- Stack_Guard --\n-   -----------------\n-\n-   procedure Stack_Guard (T : ST.Task_Id; On : Boolean) is\n-      Stack_Base : constant Address := Get_Stack_Base (T.Common.LL.Thread);\n-      Guard_Page_Address : Address;\n-\n-      Res : Interfaces.C.int;\n-\n-   begin\n-      if Stack_Base_Available then\n-\n-         --  Compute the guard page address\n-\n-         Guard_Page_Address :=\n-           Stack_Base - (Stack_Base mod Get_Page_Size) + Get_Page_Size;\n-\n-         if On then\n-            Res := mprotect (Guard_Page_Address, Get_Page_Size, PROT_ON);\n-         else\n-            Res := mprotect (Guard_Page_Address, Get_Page_Size, PROT_OFF);\n-         end if;\n-\n-         pragma Assert (Res = 0);\n-      end if;\n-   end Stack_Guard;\n-\n-   --------------------\n-   -- Get_Thread_Id  --\n-   --------------------\n-\n-   function Get_Thread_Id (T : ST.Task_Id) return OSI.Thread_Id is\n-   begin\n-      return T.Common.LL.Thread;\n-   end Get_Thread_Id;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   function Self return Task_Id renames Specific.Self;\n-\n-   ---------------------\n-   -- Initialize_Lock --\n-   ---------------------\n-\n-   procedure Initialize_Lock\n-     (Prio : System.Any_Priority;\n-      L    : not null access Lock)\n-   is\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      if Locking_Policy = 'C' then\n-         L.Ceiling := Prio;\n-      end if;\n-\n-      Result := pthread_mutex_init (L.Mutex'Access, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   procedure Initialize_Lock\n-     (L     : not null access RTS_Lock;\n-      Level : Lock_Level)\n-   is\n-      pragma Unreferenced (Level);\n-\n-      Attributes : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Result := pthread_mutexattr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutex_init (L, Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Attributes'Access);\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_Lock;\n-\n-   -------------------\n-   -- Finalize_Lock --\n-   -------------------\n-\n-   procedure Finalize_Lock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L.Mutex'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   procedure Finalize_Lock (L : not null access RTS_Lock) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_mutex_destroy (L);\n-      pragma Assert (Result = 0);\n-   end Finalize_Lock;\n-\n-   ----------------\n-   -- Write_Lock --\n-   ----------------\n-\n-   procedure Write_Lock\n-     (L                 : not null access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n-      Result : Interfaces.C.int;\n-      T      : constant Task_Id := Self;\n-\n-   begin\n-      if Locking_Policy = 'C' then\n-         if T.Common.Current_Priority > L.Ceiling then\n-            Ceiling_Violation := True;\n-            return;\n-         end if;\n-\n-         L.Saved_Priority := T.Common.Current_Priority;\n-\n-         if T.Common.Current_Priority < L.Ceiling then\n-            Set_OS_Priority (T, L.Ceiling);\n-         end if;\n-      end if;\n-\n-      Result := pthread_mutex_lock (L.Mutex'Access);\n-\n-      --  Assume that the cause of EINVAL is a priority ceiling violation\n-\n-      Ceiling_Violation := (Result = EINVAL);\n-      pragma Assert (Result = 0 or else Result = EINVAL);\n-   end Write_Lock;\n-\n-   --  No tricks on RTS_Locks\n-\n-   procedure Write_Lock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_lock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   procedure Write_Lock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_lock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Write_Lock;\n-\n-   ---------------\n-   -- Read_Lock --\n-   ---------------\n-\n-   procedure Read_Lock\n-     (L                 : not null access Lock;\n-      Ceiling_Violation : out Boolean)\n-   is\n-   begin\n-      Write_Lock (L, Ceiling_Violation);\n-   end Read_Lock;\n-\n-   ------------\n-   -- Unlock --\n-   ------------\n-\n-   procedure Unlock (L : not null access Lock) is\n-      Result : Interfaces.C.int;\n-      T      : constant Task_Id := Self;\n-\n-   begin\n-      Result := pthread_mutex_unlock (L.Mutex'Access);\n-      pragma Assert (Result = 0);\n-\n-      if Locking_Policy = 'C' then\n-         if T.Common.Current_Priority > L.Saved_Priority then\n-            Set_OS_Priority (T, L.Saved_Priority);\n-         end if;\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock\n-     (L           : not null access RTS_Lock;\n-      Global_Lock : Boolean := False)\n-   is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock or else Global_Lock then\n-         Result := pthread_mutex_unlock (L);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   procedure Unlock (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_unlock (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Unlock;\n-\n-   -----------------\n-   -- Set_Ceiling --\n-   -----------------\n-\n-   --  Dynamic priority ceilings are not supported by the underlying system\n-\n-   procedure Set_Ceiling\n-     (L    : not null access Lock;\n-      Prio : System.Any_Priority)\n-   is\n-      pragma Unreferenced (L, Prio);\n-   begin\n-      null;\n-   end Set_Ceiling;\n-\n-   -----------\n-   -- Sleep --\n-   -----------\n-\n-   procedure Sleep\n-     (Self_ID : Task_Id;\n-      Reason  : System.Tasking.Task_States)\n-   is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      if Single_Lock then\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access);\n-      else\n-         Result :=\n-           pthread_cond_wait\n-             (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access);\n-      end if;\n-\n-      --  EINTR is not considered a failure\n-\n-      pragma Assert (Result = 0 or else Result = EINTR);\n-   end Sleep;\n-\n-   -----------------\n-   -- Timed_Sleep --\n-   -----------------\n-\n-   --  This is for use within the run-time system, so abort is\n-   --  assumed to be already deferred, and the caller should be\n-   --  holding its own ATCB lock.\n-\n-   procedure Timed_Sleep\n-     (Self_ID  : Task_Id;\n-      Time     : Duration;\n-      Mode     : ST.Delay_Modes;\n-      Reason   : Task_States;\n-      Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time;\n-      Rel_Time   : Duration;\n-      Abs_Time   : Duration;\n-      Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Timedout := True;\n-      Yielded := False;\n-\n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n-         end if;\n-\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n-         end if;\n-      end if;\n-\n-      if Abs_Time > Check_Time then\n-         if Relative_Timed_Wait then\n-            Request := To_Timespec (Rel_Time);\n-         else\n-            Request := To_Timespec (Abs_Time);\n-         end if;\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Single_RTS_Lock'Access,\n-                    Request'Access);\n-\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access, Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            if Result = 0 or Result = EINTR then\n-\n-               --  Somebody may have called Wakeup for us\n-\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            pragma Assert (Result = ETIMEDOUT);\n-         end loop;\n-      end if;\n-   end Timed_Sleep;\n-\n-   -----------------\n-   -- Timed_Delay --\n-   -----------------\n-\n-   --  This is for use in implementing delay statements, so we assume\n-   --  the caller is abort-deferred but is holding no locks.\n-\n-   procedure Timed_Delay\n-     (Self_ID : Task_Id;\n-      Time    : Duration;\n-      Mode    : ST.Delay_Modes)\n-   is\n-      Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time;\n-      Abs_Time   : Duration;\n-      Rel_Time   : Duration;\n-      Request    : aliased timespec;\n-\n-      Result : Interfaces.C.int;\n-      pragma Warnings (Off, Result);\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      --  Comments needed in code below ???\n-\n-      Write_Lock (Self_ID);\n-\n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n-         end if;\n-\n-      else\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n-         end if;\n-      end if;\n-\n-      if Abs_Time > Check_Time then\n-         if Relative_Timed_Wait then\n-            Request := To_Timespec (Rel_Time);\n-         else\n-            Request := To_Timespec (Abs_Time);\n-         end if;\n-\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            if Single_Lock then\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Single_RTS_Lock'Access,\n-                    Request'Access);\n-            else\n-               Result :=\n-                 pthread_cond_timedwait\n-                   (Self_ID.Common.LL.CV'Access,\n-                    Self_ID.Common.LL.L'Access,\n-                    Request'Access);\n-            end if;\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            pragma Assert (Result = 0         or else\n-                           Result = ETIMEDOUT or else\n-                           Result = EINTR);\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      Result := sched_yield;\n-   end Timed_Delay;\n-\n-   ---------------------\n-   -- Monotonic_Clock --\n-   ---------------------\n-\n-   function Monotonic_Clock return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result :=\n-        clock_gettime\n-          (clock_id => CLOCK_REALTIME, tp => TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-      return To_Duration (TS);\n-   end Monotonic_Clock;\n-\n-   -------------------\n-   -- RT_Resolution --\n-   -------------------\n-\n-   function RT_Resolution return Duration is\n-      Res    : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result :=\n-        clock_getres\n-          (clock_id => CLOCK_REALTIME, res => Res'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-      return To_Duration (Res);\n-   end RT_Resolution;\n-\n-   ------------\n-   -- Wakeup --\n-   ------------\n-\n-   procedure Wakeup (T : Task_Id; Reason : System.Tasking.Task_States) is\n-      pragma Unreferenced (Reason);\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := pthread_cond_signal (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Wakeup;\n-\n-   -----------\n-   -- Yield --\n-   -----------\n-\n-   procedure Yield (Do_Yield : Boolean := True) is\n-      Result : Interfaces.C.int;\n-      pragma Unreferenced (Result);\n-   begin\n-      if Do_Yield then\n-         Result := sched_yield;\n-      end if;\n-   end Yield;\n-\n-   ------------------\n-   -- Set_Priority --\n-   ------------------\n-\n-   procedure Set_OS_Priority (T : Task_Id; Prio : System.Any_Priority) is\n-      Result : Interfaces.C.int;\n-      Param  : aliased struct_sched_param;\n-\n-      function Get_Policy (Prio : System.Any_Priority) return Character;\n-      pragma Import (C, Get_Policy, \"__gnat_get_specific_dispatching\");\n-      --  Get priority specific dispatching policy\n-\n-      Priority_Specific_Policy : constant Character := Get_Policy (Prio);\n-      --  Upper case first character of the policy name corresponding to the\n-      --  task as set by a Priority_Specific_Dispatching pragma.\n-\n-   begin\n-      Param.sched_priority := Interfaces.C.int (Prio);\n-\n-      if Time_Slice_Supported\n-        and then (Dispatching_Policy = 'R'\n-                   or else Priority_Specific_Policy = 'R'\n-                   or else Time_Slice_Val > 0)\n-      then\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_RR, Param'Access);\n-\n-      elsif Dispatching_Policy = 'F'\n-        or else Priority_Specific_Policy = 'F'\n-        or else Time_Slice_Val = 0\n-      then\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_FIFO, Param'Access);\n-\n-      else\n-         Result :=\n-           pthread_setschedparam\n-             (T.Common.LL.Thread, SCHED_OTHER, Param'Access);\n-      end if;\n-\n-      pragma Assert (Result = 0);\n-   end Set_OS_Priority;\n-\n-   type Prio_Array_Type is array (System.Any_Priority) of Integer;\n-   pragma Atomic_Components (Prio_Array_Type);\n-   Prio_Array : Prio_Array_Type;\n-   --  Comments needed for these declarations ???\n-\n-   procedure Set_Priority\n-     (T                   : Task_Id;\n-      Prio                : System.Any_Priority;\n-      Loss_Of_Inheritance : Boolean := False)\n-   is\n-      Array_Item : Integer;\n-\n-   begin\n-      Set_OS_Priority (T, Prio);\n-\n-      if Locking_Policy = 'C' then\n-\n-         --  Annex D requirements: loss of inheritance puts task at the start\n-         --  of the queue for that prio; copied from 5ztaprop (VxWorks).\n-\n-         if Loss_Of_Inheritance\n-           and then Prio < T.Common.Current_Priority then\n-\n-            Array_Item := Prio_Array (T.Common.Base_Priority) + 1;\n-            Prio_Array (T.Common.Base_Priority) := Array_Item;\n-\n-            loop\n-               Yield;\n-               exit when Array_Item = Prio_Array (T.Common.Base_Priority)\n-                 or else Prio_Array (T.Common.Base_Priority) = 1;\n-            end loop;\n-\n-            Prio_Array (T.Common.Base_Priority) :=\n-              Prio_Array (T.Common.Base_Priority) - 1;\n-         end if;\n-      end if;\n-\n-      T.Common.Current_Priority := Prio;\n-   end Set_Priority;\n-\n-   ------------------\n-   -- Get_Priority --\n-   ------------------\n-\n-   function Get_Priority (T : Task_Id) return System.Any_Priority is\n-   begin\n-      return T.Common.Current_Priority;\n-   end Get_Priority;\n-\n-   ----------------\n-   -- Enter_Task --\n-   ----------------\n-\n-   procedure Enter_Task (Self_ID : Task_Id) is\n-   begin\n-      Self_ID.Common.LL.Thread := pthread_self;\n-      Self_ID.Common.LL.LWP := lwp_self;\n-\n-      Specific.Set (Self_ID);\n-\n-      Lock_RTS;\n-\n-      for J in Known_Tasks'Range loop\n-         if Known_Tasks (J) = null then\n-            Known_Tasks (J) := Self_ID;\n-            Self_ID.Known_Tasks_Index := J;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      Unlock_RTS;\n-   end Enter_Task;\n-\n-   --------------\n-   -- New_ATCB --\n-   --------------\n-\n-   function New_ATCB (Entry_Num : Task_Entry_Index) return Task_Id is\n-   begin\n-      return new Ada_Task_Control_Block (Entry_Num);\n-   end New_ATCB;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean renames Specific.Is_Valid_Task;\n-\n-   -----------------------------\n-   -- Register_Foreign_Thread --\n-   -----------------------------\n-\n-   function Register_Foreign_Thread return Task_Id is\n-   begin\n-      if Is_Valid_Task then\n-         return Self;\n-      else\n-         return Register_Foreign_Thread (pthread_self);\n-      end if;\n-   end Register_Foreign_Thread;\n-\n-   --------------------\n-   -- Initialize_TCB --\n-   --------------------\n-\n-   procedure Initialize_TCB (Self_ID : Task_Id; Succeeded : out Boolean) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Result     : Interfaces.C.int;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-\n-   begin\n-      --  Give the task a unique serial number\n-\n-      Self_ID.Serial_Number := Next_Serial_Number;\n-      Next_Serial_Number := Next_Serial_Number + 1;\n-      pragma Assert (Next_Serial_Number /= 0);\n-\n-      if not Single_Lock then\n-         Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-         if Result = 0 then\n-            Result :=\n-              pthread_mutex_init\n-                (Self_ID.Common.LL.L'Access, Mutex_Attr'Access);\n-            pragma Assert (Result = 0 or else Result = ENOMEM);\n-         end if;\n-\n-         if Result /= 0 then\n-            Succeeded := False;\n-            return;\n-         end if;\n-\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = 0 then\n-         Result :=\n-           pthread_cond_init (Self_ID.Common.LL.CV'Access, Cond_Attr'Access);\n-         pragma Assert (Result = 0 or else Result = ENOMEM);\n-      end if;\n-\n-      if Result = 0 then\n-         Succeeded := True;\n-      else\n-         if not Single_Lock then\n-            Result := pthread_mutex_destroy (Self_ID.Common.LL.L'Access);\n-            pragma Assert (Result = 0);\n-         end if;\n-\n-         Succeeded := False;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize_TCB;\n-\n-   -----------------\n-   -- Create_Task --\n-   -----------------\n-\n-   procedure Create_Task\n-     (T          : Task_Id;\n-      Wrapper    : System.Address;\n-      Stack_Size : System.Parameters.Size_Type;\n-      Priority   : System.Any_Priority;\n-      Succeeded  : out Boolean)\n-   is\n-      Attributes          : aliased pthread_attr_t;\n-      Adjusted_Stack_Size : Interfaces.C.size_t;\n-      Result              : Interfaces.C.int;\n-\n-      use System.Task_Info;\n-\n-   begin\n-      Adjusted_Stack_Size := Interfaces.C.size_t (Stack_Size);\n-\n-      if Stack_Base_Available then\n-\n-         --  If Stack Checking is supported then allocate 2 additional pages:\n-\n-         --  In the worst case, stack is allocated at something like\n-         --  N * Get_Page_Size - epsilon, we need to add the size for 2 pages\n-         --  to be sure the effective stack size is greater than what\n-         --  has been asked.\n-\n-         Adjusted_Stack_Size := Adjusted_Stack_Size + 2 * Get_Page_Size;\n-      end if;\n-\n-      Result := pthread_attr_init (Attributes'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Succeeded := False;\n-         return;\n-      end if;\n-\n-      Result :=\n-        pthread_attr_setdetachstate\n-          (Attributes'Access, PTHREAD_CREATE_DETACHED);\n-      pragma Assert (Result = 0);\n-\n-      Result :=\n-        pthread_attr_setstacksize\n-          (Attributes'Access, Adjusted_Stack_Size);\n-      pragma Assert (Result = 0);\n-\n-      if T.Common.Task_Info /= Default_Scope then\n-\n-         --  We are assuming that Scope_Type has the same values than the\n-         --  corresponding C macros\n-\n-         Result :=\n-           pthread_attr_setscope\n-             (Attributes'Access, Task_Info_Type'Pos (T.Common.Task_Info));\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      --  Since the initial signal mask of a thread is inherited from the\n-      --  creator, and the Environment task has all its signals masked, we\n-      --  do not need to manipulate caller's signal mask at this point.\n-      --  All tasks in RTS will have All_Tasks_Mask initially.\n-\n-      Result :=\n-        pthread_create\n-          (T.Common.LL.Thread'Access,\n-           Attributes'Access,\n-           Thread_Body_Access (Wrapper),\n-           To_Address (T));\n-      pragma Assert (Result = 0 or else Result = EAGAIN);\n-\n-      Succeeded := Result = 0;\n-\n-      Result := pthread_attr_destroy (Attributes'Access);\n-      pragma Assert (Result = 0);\n-\n-      if Succeeded then\n-         Set_Priority (T, Priority);\n-      end if;\n-   end Create_Task;\n-\n-   ------------------\n-   -- Finalize_TCB --\n-   ------------------\n-\n-   procedure Finalize_TCB (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-      Tmp    : Task_Id := T;\n-      Is_Self : constant Boolean := T = Self;\n-\n-      procedure Free is new\n-        Ada.Unchecked_Deallocation (Ada_Task_Control_Block, Task_Id);\n-\n-   begin\n-      if not Single_Lock then\n-         Result := pthread_mutex_destroy (T.Common.LL.L'Access);\n-         pragma Assert (Result = 0);\n-      end if;\n-\n-      Result := pthread_cond_destroy (T.Common.LL.CV'Access);\n-      pragma Assert (Result = 0);\n-\n-      if T.Known_Tasks_Index /= -1 then\n-         Known_Tasks (T.Known_Tasks_Index) := null;\n-      end if;\n-\n-      Free (Tmp);\n-\n-      if Is_Self then\n-         Result := st_setspecific (ATCB_Key, System.Null_Address);\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Finalize_TCB;\n-\n-   ---------------\n-   -- Exit_Task --\n-   ---------------\n-\n-   procedure Exit_Task is\n-   begin\n-      Specific.Set (null);\n-   end Exit_Task;\n-\n-   ----------------\n-   -- Abort_Task --\n-   ----------------\n-\n-   procedure Abort_Task (T : Task_Id) is\n-      Result : Interfaces.C.int;\n-   begin\n-      Result :=\n-        pthread_kill\n-          (T.Common.LL.Thread,\n-           Signal (System.Interrupt_Management.Abort_Task_Interrupt));\n-      pragma Assert (Result = 0);\n-   end Abort_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (S : in out Suspension_Object) is\n-      Mutex_Attr : aliased pthread_mutexattr_t;\n-      Cond_Attr  : aliased pthread_condattr_t;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      --  Initialize internal state (always to False (RM D.10(6)))\n-\n-      S.State := False;\n-      S.Waiting := False;\n-\n-      --  Initialize internal mutex\n-\n-      Result := pthread_mutexattr_init (Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutex_init (S.L'Access, Mutex_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result = ENOMEM then\n-         Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-         pragma Assert (Result = 0);\n-\n-         raise Storage_Error;\n-      end if;\n-\n-      Result := pthread_mutexattr_destroy (Mutex_Attr'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Initialize internal condition variable\n-\n-      Result := pthread_condattr_init (Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_cond_init (S.CV'Access, Cond_Attr'Access);\n-      pragma Assert (Result = 0 or else Result = ENOMEM);\n-\n-      if Result /= 0 then\n-         Result := pthread_mutex_destroy (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         if Result = ENOMEM then\n-            Result := pthread_condattr_destroy (Cond_Attr'Access);\n-            pragma Assert (Result = 0);\n-\n-            raise Storage_Error;\n-         end if;\n-      end if;\n-\n-      Result := pthread_condattr_destroy (Cond_Attr'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      --  Destroy internal mutex\n-\n-      Result := pthread_mutex_destroy (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  Destroy internal condition variable\n-\n-      Result := pthread_cond_destroy (S.CV'Access);\n-      pragma Assert (Result = 0);\n-   end Finalize;\n-\n-   -------------------\n-   -- Current_State --\n-   -------------------\n-\n-   function Current_State (S : Suspension_Object) return Boolean is\n-   begin\n-      --  We do not want to use lock on this read operation. State is marked\n-      --  as Atomic so that we ensure that the value retrieved is correct.\n-\n-      return S.State;\n-   end Current_State;\n-\n-   ---------------\n-   -- Set_False --\n-   ---------------\n-\n-   procedure Set_False (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      S.State := False;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_False;\n-\n-   --------------\n-   -- Set_True --\n-   --------------\n-\n-   procedure Set_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      --  If there is already a task waiting on this suspension object then\n-      --  we resume it, leaving the state of the suspension object to False,\n-      --  as specified in (RM D.10(9)). Otherwise, just leave state set True.\n-\n-      if S.Waiting then\n-         S.Waiting := False;\n-         S.State := False;\n-\n-         Result := pthread_cond_signal (S.CV'Access);\n-         pragma Assert (Result = 0);\n-\n-      else\n-         S.State := True;\n-      end if;\n-\n-      Result := pthread_mutex_unlock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      SSL.Abort_Undefer.all;\n-   end Set_True;\n-\n-   ------------------------\n-   -- Suspend_Until_True --\n-   ------------------------\n-\n-   procedure Suspend_Until_True (S : in out Suspension_Object) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      SSL.Abort_Defer.all;\n-\n-      Result := pthread_mutex_lock (S.L'Access);\n-      pragma Assert (Result = 0);\n-\n-      if S.Waiting then\n-\n-         --  Program_Error must be raised upon calling Suspend_Until_True\n-         --  if another task is already waiting on that suspension object\n-         --  (RM D.10 (10)).\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-\n-         raise Program_Error;\n-\n-      else\n-         --  Suspend the task if the state is False. Otherwise, the task\n-         --  continues its execution, and the state of the suspension object\n-         --  is set to False (RM D.10(9)).\n-\n-         if S.State then\n-            S.State := False;\n-         else\n-            S.Waiting := True;\n-            Result := pthread_cond_wait (S.CV'Access, S.L'Access);\n-         end if;\n-\n-         Result := pthread_mutex_unlock (S.L'Access);\n-         pragma Assert (Result = 0);\n-\n-         SSL.Abort_Undefer.all;\n-      end if;\n-   end Suspend_Until_True;\n-\n-   ----------------\n-   -- Check_Exit --\n-   ----------------\n-\n-   --  Dummy version\n-\n-   function Check_Exit (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_Exit;\n-\n-   --------------------\n-   -- Check_No_Locks --\n-   --------------------\n-\n-   function Check_No_Locks (Self_ID : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (Self_ID);\n-   begin\n-      return True;\n-   end Check_No_Locks;\n-\n-   ----------------------\n-   -- Environment_Task --\n-   ----------------------\n-\n-   function Environment_Task return Task_Id is\n-   begin\n-      return Environment_Task_Id;\n-   end Environment_Task;\n-\n-   --------------\n-   -- Lock_RTS --\n-   --------------\n-\n-   procedure Lock_RTS is\n-   begin\n-      Write_Lock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Lock_RTS;\n-\n-   ----------------\n-   -- Unlock_RTS --\n-   ----------------\n-\n-   procedure Unlock_RTS is\n-   begin\n-      Unlock (Single_RTS_Lock'Access, Global_Lock => True);\n-   end Unlock_RTS;\n-\n-   ------------------\n-   -- Suspend_Task --\n-   ------------------\n-\n-   function Suspend_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      return False;\n-   end Suspend_Task;\n-\n-   -----------------\n-   -- Resume_Task --\n-   -----------------\n-\n-   function Resume_Task\n-     (T           : ST.Task_Id;\n-      Thread_Self : Thread_Id) return Boolean\n-   is\n-      pragma Unreferenced (T);\n-      pragma Unreferenced (Thread_Self);\n-   begin\n-      return False;\n-   end Resume_Task;\n-\n-   --------------------\n-   -- Stop_All_Tasks --\n-   --------------------\n-\n-   procedure Stop_All_Tasks is\n-   begin\n-      null;\n-   end Stop_All_Tasks;\n-\n-   ---------------\n-   -- Stop_Task --\n-   ---------------\n-\n-   function Stop_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Stop_Task;\n-\n-   -------------------\n-   -- Continue_Task --\n-   -------------------\n-\n-   function Continue_Task (T : ST.Task_Id) return Boolean is\n-      pragma Unreferenced (T);\n-   begin\n-      return False;\n-   end Continue_Task;\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-      act     : aliased struct_sigaction;\n-      old_act : aliased struct_sigaction;\n-      Tmp_Set : aliased sigset_t;\n-      Result  : Interfaces.C.int;\n-\n-      function State\n-        (Int  : System.Interrupt_Management.Interrupt_ID) return Character;\n-      pragma Import (C, State, \"__gnat_get_interrupt_state\");\n-      --  Get interrupt state.  Defined in a-init.c\n-      --  The input argument is the interrupt number,\n-      --  and the result is one of the following:\n-\n-      Default : constant Character := 's';\n-      --    'n'   this interrupt not set by any Interrupt_State pragma\n-      --    'u'   Interrupt_State pragma set state to User\n-      --    'r'   Interrupt_State pragma set state to Runtime\n-      --    's'   Interrupt_State pragma set state to System (use \"default\"\n-      --           system handler)\n-\n-   begin\n-      Environment_Task_Id := Environment_Task;\n-\n-      Interrupt_Management.Initialize;\n-\n-      --  Prepare the set of signals that should unblocked in all tasks\n-\n-      Result := sigemptyset (Unblocked_Signal_Mask'Access);\n-      pragma Assert (Result = 0);\n-\n-      for J in Interrupt_Management.Interrupt_ID loop\n-         if System.Interrupt_Management.Keep_Unmasked (J) then\n-            Result := sigaddset (Unblocked_Signal_Mask'Access, Signal (J));\n-            pragma Assert (Result = 0);\n-         end if;\n-      end loop;\n-\n-      --  Initialize the lock used to synchronize chain of all ATCBs\n-\n-      Initialize_Lock (Single_RTS_Lock'Access, RTS_Lock_Level);\n-\n-      Specific.Initialize (Environment_Task);\n-\n-      Enter_Task (Environment_Task);\n-\n-      --  Install the abort-signal handler\n-\n-      if State\n-          (System.Interrupt_Management.Abort_Task_Interrupt) /= Default\n-      then\n-         act.sa_flags := 0;\n-         act.sa_handler := Abort_Handler'Address;\n-\n-         Result := sigemptyset (Tmp_Set'Access);\n-         pragma Assert (Result = 0);\n-         act.sa_mask := Tmp_Set;\n-\n-         Result :=\n-           sigaction\n-             (Signal (System.Interrupt_Management.Abort_Task_Interrupt),\n-              act'Unchecked_Access,\n-              old_act'Unchecked_Access);\n-\n-         pragma Assert (Result = 0);\n-      end if;\n-   end Initialize;\n-\n-end System.Task_Primitives.Operations;"}, {"sha": "bc98b11fabdadb88cbb1a244bd6971f10154f3c2", "filename": "gcc/ada/s-tpopsp-lynxos.adb", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-tpopsp-lynxos.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fs-tpopsp-lynxos.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tpopsp-lynxos.adb?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,111 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n---                                                                          --\n---                SYSTEM.TASK_PRIMITIVES.OPERATIONS.SPECIFIC                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---         Copyright (C) 1992-2009, Free Software Foundation, Inc.          --\n---                                                                          --\n--- GNARL is free software; you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNARL was developed by the GNARL team at Florida State University.       --\n--- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n---  This is a LynxOS version of this package.\n-\n-separate (System.Task_Primitives.Operations)\n-package body Specific is\n-\n-   ----------------\n-   -- Initialize --\n-   ----------------\n-\n-   procedure Initialize (Environment_Task : Task_Id) is\n-      pragma Warnings (Off, Environment_Task);\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := st_keycreate (null, ATCB_Key'Access);\n-      pragma Assert (Result = 0);\n-   end Initialize;\n-\n-   -------------------\n-   -- Is_Valid_Task --\n-   -------------------\n-\n-   function Is_Valid_Task return Boolean is\n-      Result : Interfaces.C.int;\n-      Value : aliased System.Address;\n-   begin\n-      Result := st_getspecific (ATCB_Key, Value'Address);\n-      pragma Assert (Result = 0);\n-      return (Value /= System.Null_Address);\n-   end Is_Valid_Task;\n-\n-   ---------\n-   -- Set --\n-   ---------\n-\n-   procedure Set (Self_Id : Task_Id) is\n-      Result : Interfaces.C.int;\n-\n-   begin\n-      Result := st_setspecific (ATCB_Key, To_Address (Self_Id));\n-      pragma Assert (Result = 0);\n-   end Set;\n-\n-   ----------\n-   -- Self --\n-   ----------\n-\n-   --  To make Ada tasks and C threads interoperate better, we have added some\n-   --  functionality to Self. Suppose a C main program (with threads) calls an\n-   --  Ada procedure and the Ada procedure calls the tasking runtime system.\n-   --  Eventually, a call will be made to self. Since the call is not coming\n-   --  from an Ada task, there will be no corresponding ATCB.\n-\n-   --  What we do in Self is to catch references that do not come from\n-   --  recognized Ada tasks, and create an ATCB for the calling thread.\n-\n-   --  The new ATCB will be \"detached\" from the normal Ada task master\n-   --  hierarchy, much like the existing implicitly created signal-server\n-   --  tasks.\n-\n-   function Self return Task_Id is\n-      Value : aliased System.Address;\n-\n-      Result : Interfaces.C.int;\n-      pragma Unreferenced (Result);\n-\n-   begin\n-      Result := st_getspecific (ATCB_Key, Value'Address);\n-      --  Is it OK not to check this result???\n-\n-      --  If the key value is Null, then it is a non-Ada task.\n-\n-      if Value /= System.Null_Address then\n-         return To_Task_Id (Value);\n-      else\n-         return Register_Foreign_Thread;\n-      end if;\n-   end Self;\n-\n-end Specific;"}, {"sha": "3f701b2dcf9776fea365557c2f266ff615a3fc28", "filename": "gcc/ada/system-lynxos-ppc.ads", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fsystem-lynxos-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fsystem-lynxos-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-lynxos-ppc.ads?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,157 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                           (LynxOS PPC Version)                           --\n---                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is private;\n-   pragma Preelaborable_Initialization (Address);\n-   Null_Address : constant Address;\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 32;\n-   Memory_Size  : constant := 2 ** 32;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := High_Order_First;\n-   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   --  17 is the system determined default priority for user applications\n-   --  running on LynxOS.\n-\n-   --  The standard (Rm 13.7) requires that Default_Priority has the value:\n-\n-   --  (Priority'First + Priority'Last) / 2\n-\n-   --  To allow an appropriate value for Default_Priority and expose a useful\n-   --  range of priorities to the user, we use a range of 0 .. 34 for subtype\n-   --  Priority.\n-\n-   --  The rest of the range allowed by the system from 35 to 255 is made\n-   --  available here in Interrupt_Priority.\n-\n-   Max_Priority           : constant Positive := 34;\n-   Max_Interrupt_Priority : constant Positive := 255;\n-\n-   subtype Any_Priority       is Integer      range   0 .. 255;\n-   subtype Priority           is Any_Priority range   0 .. 34;\n-   subtype Interrupt_Priority is Any_Priority range  35 .. 255;\n-\n-   Default_Priority : constant Priority := 17;\n-\n-private\n-\n-   type Address is mod Memory_Size;\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := False;\n-   Command_Line_Args         : constant Boolean := True;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := True;\n-   Stack_Check_Limits        : constant Boolean := False;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Always_Compatible_Rep     : constant Boolean := False;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-\n-end System;"}, {"sha": "70adfa98e191fbf69f9dd7e5df07204f4f424ffc", "filename": "gcc/ada/system-lynxos-x86.ads", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fsystem-lynxos-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4dfb6814dd39b6bee77e76b52164bd864387528/gcc%2Fada%2Fsystem-lynxos-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsystem-lynxos-x86.ads?ref=b4dfb6814dd39b6bee77e76b52164bd864387528", "patch": "@@ -1,158 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                        GNAT RUN-TIME COMPONENTS                          --\n---                                                                          --\n---                               S Y S T E M                                --\n---                                                                          --\n---                                 S p e c                                  --\n---                           (LynxOS x86 Version)                           --\n---                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n---                                                                          --\n--- GNAT was originally developed  by the GNAT team at  New York University. --\n--- Extensive contributions were provided by Ada Core Technologies Inc.      --\n---                                                                          --\n-------------------------------------------------------------------------------\n-\n-package System is\n-   pragma Pure;\n-   --  Note that we take advantage of the implementation permission to make\n-   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada\n-   --  2005, this is Pure in any case (AI-362).\n-\n-   type Name is (SYSTEM_NAME_GNAT);\n-   System_Name : constant Name := SYSTEM_NAME_GNAT;\n-\n-   --  System-Dependent Named Numbers\n-\n-   Min_Int               : constant := Long_Long_Integer'First;\n-   Max_Int               : constant := Long_Long_Integer'Last;\n-\n-   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;\n-   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;\n-\n-   Max_Base_Digits       : constant := Long_Long_Float'Digits;\n-   Max_Digits            : constant := Long_Long_Float'Digits;\n-\n-   Max_Mantissa          : constant := 63;\n-   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n-\n-   Tick                  : constant := 0.01;\n-\n-   --  Storage-related Declarations\n-\n-   type Address is private;\n-   pragma Preelaborable_Initialization (Address);\n-   Null_Address : constant Address;\n-\n-   Storage_Unit : constant := 8;\n-   Word_Size    : constant := 32;\n-   Memory_Size  : constant := 2 ** 32;\n-\n-   --  Address comparison\n-\n-   function \"<\"  (Left, Right : Address) return Boolean;\n-   function \"<=\" (Left, Right : Address) return Boolean;\n-   function \">\"  (Left, Right : Address) return Boolean;\n-   function \">=\" (Left, Right : Address) return Boolean;\n-   function \"=\"  (Left, Right : Address) return Boolean;\n-\n-   pragma Import (Intrinsic, \"<\");\n-   pragma Import (Intrinsic, \"<=\");\n-   pragma Import (Intrinsic, \">\");\n-   pragma Import (Intrinsic, \">=\");\n-   pragma Import (Intrinsic, \"=\");\n-\n-   --  Other System-Dependent Declarations\n-\n-   type Bit_Order is (High_Order_First, Low_Order_First);\n-   Default_Bit_Order : constant Bit_Order := Low_Order_First;\n-   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning\n-\n-   --  Priority-related Declarations (RM D.1)\n-\n-   --  17 is the system determined default priority for user applications\n-   --  running on LynxOS.\n-\n-   --  The standard (Rm 13.7) requires that Default_Priority has the value:\n-\n-   --  (Priority'First + Priority'Last) / 2\n-\n-   --  To allow an appropriate value for Default_Priority and expose a useful\n-   --  range of priorities to the user, we use a range of 0 .. 34 for subtype\n-   --  Priority.\n-\n-   --  The rest of the range allowed by the system from 35 to 255 is made\n-   --  available here in Interrupt_Priority.\n-\n-   Max_Priority           : constant Positive := 34;\n-   Max_Interrupt_Priority : constant Positive := 255;\n-\n-   subtype Any_Priority       is Integer      range   0 .. 255;\n-   subtype Priority           is Any_Priority range   0 .. 34;\n-   subtype Interrupt_Priority is Any_Priority range  35 .. 255;\n-\n-   Default_Priority : constant Priority := 17;\n-\n-private\n-\n-   type Address is mod Memory_Size;\n-   Null_Address : constant Address := 0;\n-\n-   --------------------------------------\n-   -- System Implementation Parameters --\n-   --------------------------------------\n-\n-   --  These parameters provide information about the target that is used\n-   --  by the compiler. They are in the private part of System, where they\n-   --  can be accessed using the special circuitry in the Targparm unit\n-   --  whose source should be consulted for more detailed descriptions\n-   --  of the individual switch values.\n-\n-   Backend_Divide_Checks     : constant Boolean := False;\n-   Backend_Overflow_Checks   : constant Boolean := False;\n-   Command_Line_Args         : constant Boolean := True;\n-   Configurable_Run_Time     : constant Boolean := False;\n-   Denorm                    : constant Boolean := True;\n-   Duration_32_Bits          : constant Boolean := False;\n-   Exit_Status_Supported     : constant Boolean := True;\n-   Fractional_Fixed_Ops      : constant Boolean := False;\n-   Frontend_Layout           : constant Boolean := False;\n-   Machine_Overflows         : constant Boolean := False;\n-   Machine_Rounds            : constant Boolean := True;\n-   Preallocated_Stacks       : constant Boolean := False;\n-   Signed_Zeros              : constant Boolean := True;\n-   Stack_Check_Default       : constant Boolean := False;\n-   Stack_Check_Probes        : constant Boolean := True;\n-   Stack_Check_Limits        : constant Boolean := False;\n-   Support_Aggregates        : constant Boolean := True;\n-   Support_Atomic_Primitives : constant Boolean := True;\n-   Support_Composite_Assign  : constant Boolean := True;\n-   Support_Composite_Compare : constant Boolean := True;\n-   Support_Long_Shifts       : constant Boolean := True;\n-   Always_Compatible_Rep     : constant Boolean := False;\n-   Suppress_Standard_Library : constant Boolean := False;\n-   Use_Ada_Main_Program_Name : constant Boolean := False;\n-   ZCX_By_Default            : constant Boolean := False;\n-\n-end System;"}]}