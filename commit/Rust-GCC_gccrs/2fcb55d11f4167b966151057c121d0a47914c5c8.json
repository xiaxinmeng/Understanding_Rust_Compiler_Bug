{"sha": "2fcb55d11f4167b966151057c121d0a47914c5c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZjYjU1ZDExZjQxNjdiOTY2MTUxMDU3YzEyMWQwYTQ3OTE0YzVjOA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-10-16T19:24:36Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-10-16T19:24:36Z"}, "message": "PR tree-optimization/83821 - local aggregate initialization defeats strlen optimization\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/83821\n\t* tree-ssa-strlen.c (maybe_invalidate): Add argument.  Consider\n\tthe length of a string when available.\n\t(handle_builtin_memset) Add argument.\n\t(handle_store, strlen_check_and_optimize_call): Same.\n\t(check_and_optimize_stmt): Same.  Pass it to callees.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/83821\n\t* c-c++-common/Warray-bounds-4.c: Remove XFAIL.\n\t* gcc.dg/strlenopt-82.c: New test.\n\t* gcc.dg/strlenopt-83.c: Same.\n\t* gcc.dg/strlenopt-84.c: Same.\n\t* gcc.dg/strlenopt-85.c: Same.\n\t* gcc.dg/strlenopt-86.c: Same.\n\t* gcc.dg/tree-ssa/calloc-4.c: Same.\n\t* gcc.dg/tree-ssa/calloc-5.c: Same.\n\nFrom-SVN: r277080", "tree": {"sha": "4a828418b3d87be6e4b4e53b6d73c3f3ed6e1de5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a828418b3d87be6e4b4e53b6d73c3f3ed6e1de5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fcb55d11f4167b966151057c121d0a47914c5c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcb55d11f4167b966151057c121d0a47914c5c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fcb55d11f4167b966151057c121d0a47914c5c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcb55d11f4167b966151057c121d0a47914c5c8/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c14dbc6b01d5b7238d9d6893bcddce19b7056c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c14dbc6b01d5b7238d9d6893bcddce19b7056c"}], "stats": {"total": 706, "additions": 694, "deletions": 12}, "files": [{"sha": "b81945b6eb2c86bed4ed303bc0babe4a04b303cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -1,3 +1,12 @@\n+2019-10-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83821\n+\t* tree-ssa-strlen.c (maybe_invalidate): Add argument.  Consider\n+\tthe length of a string when available.\n+\t(handle_builtin_memset) Add argument.\n+\t(handle_store, strlen_check_and_optimize_call): Same.\n+\t(check_and_optimize_stmt): Same.  Pass it to callees.\n+\n 2019-10-16  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/91996"}, {"sha": "0785e413e9187d63756712c82a1184d1e24f6ad7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -1,3 +1,15 @@\n+2019-10-16  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/83821\n+\t* c-c++-common/Warray-bounds-4.c: Remove XFAIL.\n+\t* gcc.dg/strlenopt-82.c: New test.\n+\t* gcc.dg/strlenopt-83.c: Same.\n+\t* gcc.dg/strlenopt-84.c: Same.\n+\t* gcc.dg/strlenopt-85.c: Same.\n+\t* gcc.dg/strlenopt-86.c: Same.\n+\t* gcc.dg/tree-ssa/calloc-4.c: Same.\n+\t* gcc.dg/tree-ssa/calloc-5.c: Same.\n+\n 2019-10-16  Martin Sebor  <msebor@redhat.com>\n \n \tPR tree-optimization/91996"}, {"sha": "a09a08d658df295e9509dab12192e8db1929a368", "filename": "gcc/testsuite/c-c++-common/Warray-bounds-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWarray-bounds-4.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -63,7 +63,7 @@ void test_strcpy_bounds_memarray_range (void)\n   TM (\"0\", \"\",     ma.a5 + i, ma.a5);\n   TM (\"01\", \"\",    ma.a5 + i, ma.a5);\n   TM (\"012\", \"\",   ma.a5 + i, ma.a5);\n-  TM (\"0123\", \"\",  ma.a5 + i, ma.a5);     /* { dg-warning \"offset 6 from the object at .ma. is out of the bounds of referenced subobject .a5. with type .char\\\\\\[5]. at offset 0\" \"strcpy\" { xfail *-*-* } } */\n+  TM (\"0123\", \"\",  ma.a5 + i, ma.a5);     /* { dg-warning \"offset 5 from the object at .ma. is out of the bounds of referenced subobject .\\(MA::\\)?a5. with type .char *\\\\\\[5]. at offset 0\" \"strcpy\" } */\n \n #if __i386__ || __x86_64__\n   /* Disabled for non-x86 targets due to bug 83462.  */"}, {"sha": "8070f6ccf30c8a1898ddcdc54748a4823c6215d6", "filename": "gcc/testsuite/gcc.dg/strlenopt-82.c", "status": "added", "additions": 224, "deletions": 0, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-82.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-82.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-82.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,224 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+\n+   Avoid exercising targets other than x86_64 in LP64 mode due to PR 83543\n+   - strlen of a local array member not optimized on some targets\n+   { dg-do compile { target { { i?86-*-* x86_64-*-* } && lp64 } } }\n+\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+\n+#define CAT(x, y) x ## y\n+#define CONCAT(x, y) CAT (x, y)\n+#define FAILNAME(name) CONCAT (call_ ## name ##_on_line_, __LINE__)\n+\n+#define FAIL(name) do {\t\t\t\t\\\n+    extern void FAILNAME (name) (void);\t\t\\\n+    FAILNAME (name)();\t\t\t\t\\\n+  } while (0)\n+\n+/* Macro to emit a call to function named\n+     call_in_true_branch_not_eliminated_on_line_NNN()\n+   for each call that's expected to be eliminated.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that no such call appears in output.  */\n+#define ELIM(expr) \\\n+  if (!(expr)) FAIL (in_true_branch_not_eliminated); else (void)0\n+\n+/* Macro to emit a call to a function named\n+     call_made_in_{true,false}_branch_on_line_NNN()\n+   for each call that's expected to be retained.  The dg-final\n+   scan-tree-dump-time directive at the bottom of the test verifies\n+   that the expected number of both kinds of calls appears in output\n+   (a pair for each line with the invocation of the KEEP() macro.  */\n+#define KEEP(expr)\t\t\t\t\\\n+  if (expr)\t\t\t\t\t\\\n+    FAIL (made_in_true_branch);\t\t\t\\\n+  else\t\t\t\t\t\t\\\n+    FAIL (made_in_false_branch)\n+\n+#define STR10 \"0123456789\"\n+#define STR20 STR10 STR10\n+#define STR30 STR20 STR10\n+#define STR40 STR20 STR20\n+\n+void elim_char_array_init_consecutive (void)\n+{\n+  char a[][10] = { \"1\", \"12\", \"123\", \"1234\", \"12345\", \"12345\" };\n+\n+  ELIM (strlen (a[0]) == 1);\n+  ELIM (strlen (a[1]) == 2);\n+  ELIM (strlen (a[2]) == 3);\n+  ELIM (strlen (a[3]) == 4);\n+  ELIM (strlen (a[4]) == 5);\n+}\n+\n+void elim_char_array_cpy_consecutive (void)\n+{\n+  char a[5][10];\n+\n+  strcpy (a[0], \"12345\");\n+  strcpy (a[1], \"1234\");\n+  strcpy (a[2], \"123\");\n+  strcpy (a[3], \"12\");\n+  strcpy (a[4], \"1\");\n+\n+  ELIM (strlen (a[0]) == 5);\n+  ELIM (strlen (a[1]) == 4);\n+  ELIM (strlen (a[2]) == 3);\n+  ELIM (strlen (a[3]) == 2);\n+  ELIM (strlen (a[4]) == 1);\n+}\n+\n+void elim_clear_char_array_cpy_consecutive (void)\n+{\n+  char a[5][10] = { };\n+\n+  strcpy (a[0], \"12345\");\n+  strcpy (a[1], \"1234\");\n+  strcpy (a[2], \"123\");\n+  strcpy (a[3], \"12\");\n+  strcpy (a[4], \"1\");\n+\n+  ELIM (strlen (a[0]) == 5);\n+  ELIM (strlen (a[1]) == 4);\n+  ELIM (strlen (a[2]) == 3);\n+  ELIM (strlen (a[3]) == 2);\n+  ELIM (strlen (a[4]) == 1);\n+}\n+\n+struct Consec\n+{\n+  char s1[sizeof STR40];\n+  char s2[sizeof STR40];\n+  const char *p1;\n+  const char *p2;\n+};\n+\n+void elim_struct_init_consecutive (void)\n+{\n+  struct Consec a = { STR10, STR10, STR10, STR10 };\n+\n+  ELIM (strlen (a.s1) == sizeof STR10 - 1);\n+  ELIM (strlen (a.s2) == sizeof STR10 - 1);\n+  ELIM (strlen (a.p1) == sizeof STR10 - 1);\n+  ELIM (strlen (a.p2) == sizeof STR10 - 1);\n+}\n+\n+void elim_struct_array_init_consecutive (void)\n+{\n+  struct Consec a[2] = {\n+    { STR10, STR20, STR30, STR40 },\n+    { STR40, STR30, STR20, STR10 }\n+  };\n+\n+  ELIM (strlen (a[0].s1) == sizeof STR10 - 1);\n+  ELIM (strlen (a[0].s2) == sizeof STR20 - 1);\n+  ELIM (strlen (a[0].p1) == sizeof STR30 - 1);\n+  ELIM (strlen (a[0].p2) == sizeof STR40 - 1);\n+\n+  ELIM (strlen (a[1].s1) == sizeof STR40 - 1);\n+  ELIM (strlen (a[1].s2) == sizeof STR30 - 1);\n+  ELIM (strlen (a[1].p1) == sizeof STR20 - 1);\n+  ELIM (strlen (a[1].p2) == sizeof STR10 - 1);\n+}\n+\n+struct NonConsec\n+{\n+  char s1[sizeof STR40];\n+  int i1;\n+  char s2[sizeof STR40];\n+  int i2;\n+  const char *p1;\n+  int i3;\n+  const char *p2;\n+  int i4;\n+};\n+\n+void elim_struct_init_nonconsecutive (void)\n+{\n+  struct NonConsec b = { STR10, 123, STR20, 456, b.s1, 789, b.s2, 123 };\n+\n+  ELIM (strlen (b.s1) == sizeof STR10 - 1);\n+  ELIM (strlen (b.s2) == sizeof STR20 - 1);\n+  ELIM (strlen (b.p1) == sizeof STR10 - 1);\n+  ELIM (strlen (b.p2) == sizeof STR20 - 1);\n+}\n+\n+void elim_struct_assign_tmp_nonconsecutive (void)\n+{\n+  struct NonConsec b = { \"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4 };\n+\n+  b = (struct NonConsec){ STR10, 123, STR20, 456, STR30, 789, STR40, 123 };\n+\n+  ELIM (strlen (b.s1) == sizeof STR10 - 1);\n+  ELIM (strlen (b.s2) == sizeof STR20 - 1);\n+  ELIM (strlen (b.p1) == sizeof STR30 - 1);\n+  ELIM (strlen (b.p2) == sizeof STR40 - 1);\n+}\n+\n+const struct NonConsec bcst = {\n+  STR40, -1, STR30, -2, STR20, -3, STR10, -4\n+};\n+\n+void elim_struct_assign_cst_nonconsecutive (void)\n+{\n+  struct NonConsec b = { \"a\", 1, \"b\", 2, \"c\", 3, \"d\" };\n+\n+  b = bcst;\n+\n+  ELIM (strlen (b.s1) == sizeof STR40 - 1);\n+  ELIM (strlen (b.s2) == sizeof STR30 - 1);\n+  ELIM (strlen (b.p1) == sizeof STR20 - 1);\n+  ELIM (strlen (b.p2) == sizeof STR10 - 1);\n+}\n+\n+void elim_struct_copy_cst_nonconsecutive (void)\n+{\n+  struct NonConsec b = { \"a\", 1, \"b\", 2, \"c\", 3, \"d\" };\n+  memcpy (&b, &bcst, sizeof b);\n+\n+  /* ELIM (strlen (b.s1) == sizeof STR40 - 1);\n+     ELIM (strlen (b.s2) == sizeof STR30 - 1); */\n+  ELIM (strlen (b.p1) == sizeof STR20 - 1);\n+  ELIM (strlen (b.p2) == sizeof STR10 - 1);\n+}\n+\n+\n+#line 1000\n+\n+int sink (void*);\n+\n+void keep_init_nonconsecutive (void)\n+{\n+  struct NonConsec b = {\n+    STR10, 123, STR20, 456, b.s1, 789, b.s2,\n+    sink (&b)\n+  };\n+\n+  KEEP (strlen (b.s1) == sizeof STR10 - 1);\n+  KEEP (strlen (b.s2) == sizeof STR10 - 1);\n+  KEEP (strlen (b.p1) == sizeof STR10 - 1);\n+  KEEP (strlen (b.p2) == sizeof STR10 - 1);\n+}\n+\n+void keep_assign_tmp_nonconsecutive (void)\n+{\n+  struct NonConsec b = { \"a\", 1, \"b\", 2, \"c\", 3, \"d\", 4 };\n+\n+  b = (struct NonConsec){\n+    STR10, 123, STR20, 456, STR30, 789, STR40,\n+    sink (&b)\n+  };\n+\n+  KEEP (strlen (b.s1) == sizeof STR10 - 1);\n+  KEEP (strlen (b.s2) == sizeof STR20 - 1);\n+  KEEP (strlen (b.p1) == sizeof STR30 - 1);\n+  KEEP (strlen (b.p2) == sizeof STR40 - 1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"call_in_true_branch_not_eliminated_\" 0 \"optimized\" } }\n+\n+   { dg-final { scan-tree-dump-times \"call_made_in_true_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"call_made_in_false_branch_on_line_1\\[0-9\\]\\[0-9\\]\\[0-9\\]\" 8 \"optimized\" } } */"}, {"sha": "5baafea5c320271c2942048d52c07decaad5e1d7", "filename": "gcc/testsuite/gcc.dg/strlenopt-83.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-83.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-83.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-83.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,83 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -fdump-tree-optimized\" } */\n+\n+#include \"strlenopt.h\"\n+char *p_p2, *p_p5, *p_p9, *p_p14;\n+\n+unsigned n0, n1, n2, n3, n4;\n+\n+\n+static inline __attribute__ ((always_inline)) void\n+elim_strlen_of_consecutive_strcpy (char *p)\n+{\n+  p_p2 = p + 2;\n+  __builtin_strcpy (p_p2, \"12\");\n+\n+  p_p5 = p_p2 + 3;\n+  __builtin_strcpy (p_p5, \"124\");\n+\n+  p_p9 = p_p5 + 4;\n+  __builtin_strcpy (p_p9, \"1245\");\n+\n+  p_p14 = p_p9 + 5;\n+\n+  n0 = __builtin_strlen (p);\n+  n1 = __builtin_strlen (p_p2);\n+  n2 = __builtin_strlen (p_p5);\n+  n3 = __builtin_strlen (p_p9);\n+\n+  /* The following isn't handled yet:\n+     n4 = __builtin_strlen (p_p14); */\n+\n+  if (n0 || n1 != 2 || n2 != 3 || n3 != 4)\n+    __builtin_abort ();\n+}\n+\n+\n+void elim_strlen_of_consecutive_strcpy_in_alloca (unsigned n)\n+{\n+  /* Only known sizes are handled so far.  */\n+  n = 14;\n+\n+  char *p = __builtin_alloca (n);\n+\n+  *p = '\\0';\n+\n+  elim_strlen_of_consecutive_strcpy (p);\n+}\n+\n+\n+void elim_strlen_of_consecutive_strcpy_in_vla (unsigned n)\n+{\n+  /* Only known sizes are handled so far.  */\n+  n = 14;\n+\n+  char vla[n];\n+\n+  *vla = '\\0';\n+\n+  elim_strlen_of_consecutive_strcpy (vla);\n+}\n+\n+void elim_strlen_of_consecutive_strcpy_in_malloc (unsigned n)\n+{\n+  char *p = __builtin_malloc (n);\n+\n+  *p = '\\0';\n+\n+  elim_strlen_of_consecutive_strcpy (p);\n+}\n+\n+\n+void elim_strlen_of_consecutive_strcpy_in_calloc (unsigned n)\n+{\n+  char *p = __builtin_calloc (n, 1);\n+\n+  /* Do not store into *P to verify that strlen knows it's zero.  */\n+\n+  elim_strlen_of_consecutive_strcpy (p);\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"optimized\" } } */"}, {"sha": "d6102b6e6f572c45965dfdf44ec2fdf80f8a1206", "filename": "gcc/testsuite/gcc.dg/strlenopt-84.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-84.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-84.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-84.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,135 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   Verify that stores that overwrite an interior nul are correctly\n+   reflected in strlen results.\n+   { dg-do run }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define false (0 == 1)\n+#define true (0 == 0)\n+#define assert(e)\t\t\t\t\t\t\t\\\n+  ((e) ? (void)0 : (__builtin_printf (\"assertion failed on line %i\\n\",\t\\\n+\t\t\t\t      __LINE__), __builtin_abort ()))\n+\n+#define ATTR(...) __attribute__ ((__VA_ARGS__))\n+\n+static inline int ATTR (always_inline)\n+assign_and_get_length (char *p, _Bool clear)\n+{\n+  p[0] = 'a';\n+\n+  if (clear)\n+    p[1] = 0;\n+\n+  p[2] = 'c';\n+\n+  if (clear)\n+    p[3] = 0;\n+\n+  p[1] = 'b';\n+\n+  return __builtin_strlen (p);\n+}\n+\n+ATTR (noipa) void array_get_length (void)\n+{\n+  char a[4];\n+  unsigned n = assign_and_get_length (a, true);\n+  assert (n == 3);\n+}\n+\n+ATTR (noipa) void clear_array_get_length (void)\n+{\n+  char a[4] = { };\n+  unsigned n = assign_and_get_length (a, false);\n+  assert (n == 3);\n+}\n+\n+ATTR (noipa) void calloc_get_length (void)\n+{\n+  char *p = __builtin_calloc (5, 1);\n+  unsigned n = assign_and_get_length (p, false);\n+  assert (n == 3);\n+}\n+\n+ATTR (noipa) void malloc_get_length (void)\n+{\n+  char *p = __builtin_malloc (5);\n+  unsigned n = assign_and_get_length (p, true);\n+  assert (n == 3);\n+}\n+\n+ATTR (noipa) void vla_get_length (int n)\n+{\n+  char a[n];\n+  unsigned len = assign_and_get_length (a, true);\n+  assert (len == 3);\n+}\n+\n+\n+static inline void ATTR (always_inline)\n+assign_and_test_length (char *p, _Bool clear)\n+{\n+  p[0] = 'a';\n+\n+  if (clear)\n+    p[1] = 0;\n+\n+  p[2] = 'c';\n+\n+  if (clear)\n+    p[3] = 0;\n+\n+  unsigned n0 =  __builtin_strlen (p);\n+\n+  p[1] = 'b';\n+\n+  unsigned n1 =  __builtin_strlen (p);\n+  assert (n0 != n1);\n+}\n+\n+ATTR (noipa) void array_test_length (void)\n+{\n+  char a[4];\n+  assign_and_test_length (a, true);\n+}\n+\n+ATTR (noipa) void clear_array_test_length (void)\n+{\n+  char a[4] = { };\n+  assign_and_test_length (a, false);\n+}\n+\n+ATTR (noipa) void calloc_test_length (void)\n+{\n+  char *p = __builtin_calloc (5, 1);\n+  assign_and_test_length (p, false);\n+}\n+\n+ATTR (noipa) void malloc_test_length (void)\n+{\n+  char *p = __builtin_malloc (5);\n+  assign_and_test_length (p, true);\n+}\n+\n+ATTR (noipa) void vla_test_length (int n)\n+{\n+  char a[n];\n+  assign_and_test_length (a, true);\n+}\n+\n+int main (void)\n+{\n+  array_get_length ();\n+  clear_array_get_length ();\n+  calloc_get_length ();\n+  malloc_get_length ();\n+  vla_get_length (4);\n+\n+  array_test_length ();\n+  clear_array_test_length ();\n+  calloc_test_length ();\n+  malloc_test_length ();\n+  vla_test_length (4);\n+}\n+"}, {"sha": "e049e0c30e0a8cc8cb84aefcae7d997a62a3ac28", "filename": "gcc/testsuite/gcc.dg/strlenopt-85.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-85.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-85.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-85.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,44 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   Verify that a strlen() call is eliminated for a pointer to a region\n+   of memory allocated by calloc() even if one or more nul bytes are\n+   written into it.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned n0, n1;\n+\n+void* elim_strlen_calloc_store_memset_1 (unsigned a, unsigned b)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[0] = '\\0';\n+  p[1] = '\\0';\n+  p[2] = '\\0';\n+  p[3] = '\\0';\n+\n+  __builtin_memset (p, 0, b);\n+\n+  n0 = __builtin_strlen (p);\n+\n+  return p;\n+}\n+\n+void* elim_strlen_calloc_store_memset_2 (unsigned a, unsigned b, unsigned c)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = '\\0';\n+  __builtin_memset (p, 0, b);\n+\n+  n0 = __builtin_strlen (p);\n+\n+  p[3] = 0;\n+  __builtin_memset (p, 0, c);\n+\n+  n1 = __builtin_strlen (p);\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"__builtin_strlen\" \"optimized\" } } */"}, {"sha": "3e86fa3c90aba9810809d88b23e38e172221cb8f", "filename": "gcc/testsuite/gcc.dg/strlenopt-86.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-86.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,57 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   Verify that a strlen() call is not eliminated for a pointer to a region\n+   of memory allocated by calloc() if a byte is written into the region\n+   that isn't known to be nul.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+unsigned n0, n1;\n+\n+void*\n+keep_strlen_calloc_store_cst_memset (unsigned a, unsigned b)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = 'x';\n+\n+  __builtin_memset (p, 0, b);\n+\n+  n0 = __builtin_strlen (p);\n+\n+  return p;\n+}\n+\n+void*\n+keep_strlen_calloc_store_var_memset (int x, unsigned a, unsigned b)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = x;\n+\n+  __builtin_memset (p, 0, b);\n+\n+  n0 = __builtin_strlen (p);\n+\n+  return p;\n+}\n+\n+void*\n+keep_strlen_calloc_store_memset_2 (int x, unsigned a, unsigned b, unsigned c)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = x;\n+  __builtin_memset (p, 0, b);\n+\n+  n0 = __builtin_strlen (p);\n+\n+  p[3] = x;\n+  __builtin_memset (p, 0, c);\n+\n+  n1 = __builtin_strlen (p);\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin_strlen\" 4 \"optimized\" } } */"}, {"sha": "b3a1d0c2c693756c35a8953ec3d019883df5a367", "filename": "gcc/testsuite/gcc.dg/tree-ssa/calloc-4.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-4.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,37 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   Verify that a memset() call to zero out a subregion of memory\n+   allocated by calloc() is eliminated even if a zero byte is written\n+   into it in between the two calls.  See the calloc-2.c test that\n+   verifies that the memset() calls isn't eliminated if the written\n+   value is non-zero.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+void* elim_calloc_store_memset_1 (unsigned a, unsigned b)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = '\\0';\n+\n+  __builtin_memset (p, 0, b);   // should be eliminated\n+\n+  return p;\n+}\n+\n+void* elim_calloc_store_memset_2 (unsigned a, unsigned b, unsigned c)\n+{\n+  char *p = __builtin_calloc (a, 1);\n+\n+  p[1] = '\\0';\n+  __builtin_memset (p, 0, b);   // should be eliminated\n+\n+  p[3] = '\\0';\n+  __builtin_memset (p, 0, c);   // should also be eliminated\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"malloc\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_calloc \\\\\\(\" 2 \"optimized\" } }\n+   { dg-final { scan-tree-dump-not \"_memset \\\\\\(\" \"optimized\" } } */"}, {"sha": "3d3e5a1454237e1c534849605109a0317a581bce", "filename": "gcc/testsuite/gcc.dg/tree-ssa/calloc-5.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcalloc-5.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -0,0 +1,22 @@\n+/* PR tree-optimization/83821 - local aggregate initialization defeats\n+   strlen optimization\n+   Verify that with DSE disabled, a memset() call to zero out a subregion\n+   of memory allocated by calloc() is not eliminated after a non-zero byte\n+   is written into it using memset() in between the two calls.\n+   { dg-do compile }\n+   { dg-options \"-O2 -fno-tree-dse -fdump-tree-optimized\" } */\n+\n+char* keep_memset_calls (void)\n+{\n+  char *p = __builtin_calloc (12, 1);\n+\n+  __builtin_memset (p + 5, 1, 2);   /* dead store (not eliminated) */\n+\n+  __builtin_memset (p, 0, 12);      /* must not be eliminated */\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"malloc\" \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_calloc \\\\\\(\" 1 \"optimized\" } }\n+   { dg-final { scan-tree-dump-times \"_memset \\\\\\(\" 2 \"optimized\" } } */"}, {"sha": "ff9b92b5b75f9a6c903294c42610686933865128", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 70, "deletions": 11, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fcb55d11f4167b966151057c121d0a47914c5c8/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=2fcb55d11f4167b966151057c121d0a47914c5c8", "patch": "@@ -1094,11 +1094,16 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n }\n \n /* Invalidate string length information for strings whose length\n-   might change due to stores in stmt.  */\n+   might change due to stores in stmt, except those marked DON'T\n+   INVALIDATE.  For string-modifying statements, ZERO_WRITE is\n+   set when the statement wrote only zeros.  */\n \n static bool\n-maybe_invalidate (gimple *stmt)\n+maybe_invalidate (gimple *stmt, bool zero_write = false)\n {\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  %s()\\n\", __func__);\n+\n   strinfo *si;\n   unsigned int i;\n   bool nonempty = false;\n@@ -1109,18 +1114,59 @@ maybe_invalidate (gimple *stmt)\n \tif (!si->dont_invalidate)\n \t  {\n \t    ao_ref r;\n-\t    /* Do not use si->nonzero_chars.  */\n-\t    ao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n+\t    tree size = NULL_TREE;\n+\t    if (si->nonzero_chars)\n+\t      {\n+\t\t/* Include the terminating nul in the size of the string\n+\t\t   to consider when determining possible clobber.  */\n+\t\ttree type = TREE_TYPE (si->nonzero_chars);\n+\t\tsize = fold_build2 (PLUS_EXPR, type, si->nonzero_chars,\n+\t\t\t\t    build_int_cst (type, 1));\n+\t      }\n+\t    ao_ref_init_from_ptr_and_size (&r, si->ptr, size);\n \t    if (stmt_may_clobber_ref_p_1 (stmt, &r))\n \t      {\n+\t\tif (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  {\n+\t\t    if (size && tree_fits_uhwi_p (size))\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"  statement may clobber string %zu long\\n\",\n+\t\t\t       tree_to_uhwi (size));\n+\t\t    else\n+\t\t      fprintf (dump_file,\n+\t\t\t       \"  statement may clobber string\\n\");\n+\t\t  }\n+\n \t\tset_strinfo (i, NULL);\n \t\tfree_strinfo (si);\n \t\tcontinue;\n \t      }\n+\n+\t    if (size\n+\t\t&& !zero_write\n+\t\t&& si->stmt\n+\t\t&& is_gimple_call (si->stmt)\n+\t\t&& (DECL_FUNCTION_CODE (gimple_call_fndecl (si->stmt))\n+\t\t    == BUILT_IN_CALLOC))\n+\t      {\n+\t\t/* If the clobber test above considered the length of\n+\t\t   the string (including the nul), then for (potentially)\n+\t\t   non-zero writes that might modify storage allocated by\n+\t\t   calloc consider the whole object and if it might be\n+\t\t   clobbered by the statement reset the allocation\n+\t\t   statement.  */\n+\t\tao_ref_init_from_ptr_and_size (&r, si->ptr, NULL_TREE);\n+\t\tif (stmt_may_clobber_ref_p_1 (stmt, &r))\n+\t\t  si->stmt = NULL;\n+\t      }\n \t  }\n \tsi->dont_invalidate = false;\n \tnonempty = true;\n       }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"  %s() ==> %i\\n\", __func__, nonempty);\n+\n   return nonempty;\n }\n \n@@ -3213,11 +3259,15 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n    return true when the call is transfomred, false otherwise.  */\n \n static bool\n-handle_builtin_memset (gimple_stmt_iterator *gsi)\n+handle_builtin_memset (gimple_stmt_iterator *gsi, bool *zero_write)\n {\n   gimple *stmt2 = gsi_stmt (*gsi);\n   if (!integer_zerop (gimple_call_arg (stmt2, 1)))\n     return false;\n+\n+  /* Let the caller know the memset call cleared the destination.  */\n+  *zero_write = true;\n+\n   tree ptr = gimple_call_arg (stmt2, 0);\n   int idx1 = get_stridx (ptr);\n   if (idx1 <= 0)\n@@ -4223,7 +4273,7 @@ count_nonzero_bytes (tree exp, unsigned lenrange[3], bool *nulterm,\n    '*(int*)a = 12345').  Return true when handled.  */\n \n static bool\n-handle_store (gimple_stmt_iterator *gsi, const vr_values *rvals)\n+handle_store (gimple_stmt_iterator *gsi, bool *zero_write, const vr_values *rvals)\n {\n   int idx = -1;\n   strinfo *si = NULL;\n@@ -4250,7 +4300,10 @@ handle_store (gimple_stmt_iterator *gsi, const vr_values *rvals)\n \t  if (offset == 0)\n \t    ssaname = TREE_OPERAND (lhs, 0);\n \t  else if (si == NULL || compare_nonzero_chars (si, offset, rvals) < 0)\n-\t    return true;\n+\t    {\n+\t      *zero_write = initializer_zerop (rhs);\n+\t      return true;\n+\t    }\n \t}\n     }\n   else\n@@ -4285,6 +4338,7 @@ handle_store (gimple_stmt_iterator *gsi, const vr_values *rvals)\n     {\n       rhs_minlen = lenrange[0];\n       storing_nonzero_p = lenrange[1] > 0;\n+      *zero_write = storing_all_zeros_p;\n \n       /* Avoid issuing multiple warnings for the same LHS or statement.\n \t For example, -Warray-bounds may have already been issued for\n@@ -4649,6 +4703,7 @@ is_char_type (tree type)\n \n static bool\n strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n+\t\t\t\tbool *zero_write,\n \t\t\t\tconst vr_values *rvals)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n@@ -4708,7 +4763,7 @@ strlen_check_and_optimize_call (gimple_stmt_iterator *gsi,\n       handle_builtin_malloc (DECL_FUNCTION_CODE (callee), gsi);\n       break;\n     case BUILT_IN_MEMSET:\n-      if (handle_builtin_memset (gsi))\n+      if (handle_builtin_memset (gsi, zero_write))\n \treturn false;\n       break;\n     case BUILT_IN_MEMCMP:\n@@ -4855,9 +4910,13 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n+  /* For statements that modify a string, set to true if the write\n+     is only zeros.  */\n+  bool zero_write = false;\n+\n   if (is_gimple_call (stmt))\n     {\n-      if (!strlen_check_and_optimize_call (gsi, rvals))\n+      if (!strlen_check_and_optimize_call (gsi, &zero_write, rvals))\n \treturn false;\n     }\n   else if (!flag_optimize_strlen || !strlen_optimize)\n@@ -4907,7 +4966,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t  }\n \n \t/* Handle a single or multibyte assignment.  */\n-\tif (is_char_store && !handle_store (gsi, rvals))\n+\tif (is_char_store && !handle_store (gsi, &zero_write, rvals))\n \t  return false;\n       }\n     }\n@@ -4920,7 +4979,7 @@ check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n     }\n \n   if (gimple_vdef (stmt))\n-    maybe_invalidate (stmt);\n+    maybe_invalidate (stmt, zero_write);\n   return true;\n }\n "}]}