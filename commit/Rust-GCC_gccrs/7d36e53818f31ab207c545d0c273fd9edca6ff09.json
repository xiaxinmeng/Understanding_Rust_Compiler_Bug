{"sha": "7d36e53818f31ab207c545d0c273fd9edca6ff09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2QzNmU1MzgxOGYzMWFiMjA3YzU0NWQwYzI3M2ZkOWVkY2E2ZmYwOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-10-14T15:51:15Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-10-14T15:51:15Z"}, "message": "re PR tree-optimization/44913 (-ftree-vectorize causes FAIL: gcc.dg/pr44838.c execution test)\n\n2010-10-14  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/44913\n\t* tree-data-ref.c (disjoint_objects_p): Remove.\n\t(dr_may_alias_p): Simplify.  Only hand the base object to\n\tthe alias-oracle.\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n\tsome more trees, bail out instead of asserting.\n\t(ptr_derefs_may_alias_p): Likewise.  Export.\n\t(refs_may_alias_p_1): Handle STRING_CSTs.\n\t* tree-ssa-alias.h (ptr_derefs_may_alias_p): Declare.\n\n\t* gcc.dg/torture/pr44913.c: New testcase.\n\nFrom-SVN: r165473", "tree": {"sha": "136f40349648fdc45c3adcb47ada09856e717076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/136f40349648fdc45c3adcb47ada09856e717076"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d36e53818f31ab207c545d0c273fd9edca6ff09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d36e53818f31ab207c545d0c273fd9edca6ff09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d36e53818f31ab207c545d0c273fd9edca6ff09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d36e53818f31ab207c545d0c273fd9edca6ff09/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "180f8dbbb3361ce1728425ba7537e401f595f866", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/180f8dbbb3361ce1728425ba7537e401f595f866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/180f8dbbb3361ce1728425ba7537e401f595f866"}], "stats": {"total": 278, "additions": 113, "deletions": 165}, "files": [{"sha": "bab69584717383682f30af2459a3fbf5c08adf5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -1,3 +1,15 @@\n+2010-10-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/44913\n+\t* tree-data-ref.c (disjoint_objects_p): Remove.\n+\t(dr_may_alias_p): Simplify.  Only hand the base object to\n+\tthe alias-oracle.\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n+\tsome more trees, bail out instead of asserting.\n+\t(ptr_derefs_may_alias_p): Likewise.  Export.\n+\t(refs_may_alias_p_1): Handle STRING_CSTs.\n+\t* tree-ssa-alias.h (ptr_derefs_may_alias_p): Declare.\n+\n 2010-10-14  Joseph Myers  <joseph@codesourcery.com>\n \n \tPR c/45969"}, {"sha": "22dc14b591fddd49ace8b9fb744c4fa3f5c8d106", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -3,6 +3,11 @@\n \tPR c/45969\n \t* gcc.c-torture/compile/pr45969-1.c: New test.\n \n+2010-10-14  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/44913\n+\t* gcc.dg/torture/pr44913.c: New testcase.\n+\n 2010-10-14  Richard Guenther  <rguenther@suse.de>\n \n \tPR lto/45382"}, {"sha": "eef61fbfb154e41744a6d4598652ee935a235039", "filename": "gcc/testsuite/gcc.dg/torture/pr44913.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr44913.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr44913.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr44913.c?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run } */\n+\n+void __attribute__((noinline,noclone))\n+foo (int *a, int n)\n+{\n+  int *lasta = a + n;\n+  for (; a != lasta; a++)\n+    {\n+      *a *= 2;\n+      a[1] = a[-1] + a[-2];\n+    }\n+}\n+extern void abort (void);\n+int main()\n+{\n+  int a[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };\n+  int r[16] = { 1, 2, 6, 6, 16, 24, 44, 80, 136, 248, 432, 768, 1360, 2400, 4256, 3760 };\n+  unsigned i;\n+  foo (&a[2], 13);\n+  for (i = 0; i < 8; ++i)\n+    if (a[i] != r[i])\n+      abort ();\n+  return 0;\n+}"}, {"sha": "3cee320846bad1bb791d21423e2c3e69c5e4105d", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 5, "deletions": 139, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -1233,154 +1233,20 @@ object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n \t\t\t\t\t\t  loop->num);\n }\n \n-/* Returns true if A and B are accesses to different objects, or to different\n-   fields of the same object.  */\n-\n-static bool\n-disjoint_objects_p (tree a, tree b)\n-{\n-  tree base_a, base_b;\n-  VEC (tree, heap) *comp_a = NULL, *comp_b = NULL;\n-  bool ret;\n-\n-  base_a = get_base_address (a);\n-  base_b = get_base_address (b);\n-\n-  if (DECL_P (base_a)\n-      && DECL_P (base_b)\n-      && base_a != base_b)\n-    return true;\n-\n-  if (!operand_equal_p (base_a, base_b, 0))\n-    return false;\n-\n-  /* Compare the component references of A and B.  We must start from the inner\n-     ones, so record them to the vector first.  */\n-  while (handled_component_p (a))\n-    {\n-      VEC_safe_push (tree, heap, comp_a, a);\n-      a = TREE_OPERAND (a, 0);\n-    }\n-  while (handled_component_p (b))\n-    {\n-      VEC_safe_push (tree, heap, comp_b, b);\n-      b = TREE_OPERAND (b, 0);\n-    }\n-\n-  ret = false;\n-  while (1)\n-    {\n-      if (VEC_length (tree, comp_a) == 0\n-\t  || VEC_length (tree, comp_b) == 0)\n-\tbreak;\n-\n-      a = VEC_pop (tree, comp_a);\n-      b = VEC_pop (tree, comp_b);\n-\n-      /* Real and imaginary part of a variable do not alias.  */\n-      if ((TREE_CODE (a) == REALPART_EXPR\n-\t   && TREE_CODE (b) == IMAGPART_EXPR)\n-\t  || (TREE_CODE (a) == IMAGPART_EXPR\n-\t      && TREE_CODE (b) == REALPART_EXPR))\n-\t{\n-\t  ret = true;\n-\t  break;\n-\t}\n-\n-      if (TREE_CODE (a) != TREE_CODE (b))\n-\tbreak;\n-\n-      /* Nothing to do for ARRAY_REFs, as the indices of array_refs in\n-\t DR_BASE_OBJECT are always zero.  */\n-      if (TREE_CODE (a) == ARRAY_REF)\n-\tcontinue;\n-      else if (TREE_CODE (a) == COMPONENT_REF)\n-\t{\n-\t  if (operand_equal_p (TREE_OPERAND (a, 1), TREE_OPERAND (b, 1), 0))\n-\t    continue;\n-\n-\t  /* Different fields of unions may overlap.  */\n-\t  base_a = TREE_OPERAND (a, 0);\n-\t  if (TREE_CODE (TREE_TYPE (base_a)) == UNION_TYPE)\n-\t    break;\n-\n-\t  /* Different fields of structures cannot.  */\n-\t  ret = true;\n-\t  break;\n-\t}\n-      else\n-\tbreak;\n-    }\n-\n-  VEC_free (tree, heap, comp_a);\n-  VEC_free (tree, heap, comp_b);\n-\n-  return ret;\n-}\n-\n /* Returns false if we can prove that data references A and B do not alias,\n    true otherwise.  */\n \n bool\n dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n {\n-  const_tree addr_a = DR_BASE_ADDRESS (a);\n-  const_tree addr_b = DR_BASE_ADDRESS (b);\n-  const_tree type_a, type_b;\n-  const_tree decl_a = NULL_TREE, decl_b = NULL_TREE;\n-\n-  /* If the accessed objects are disjoint, the memory references do not\n-     alias.  */\n-  if (disjoint_objects_p (DR_BASE_OBJECT (a), DR_BASE_OBJECT (b)))\n-    return false;\n+  tree addr_a = DR_BASE_OBJECT (a);\n+  tree addr_b = DR_BASE_OBJECT (b);\n \n-  /* Query the alias oracle.  */\n   if (DR_IS_WRITE (a) && DR_IS_WRITE (b))\n-    {\n-      if (!refs_output_dependent_p (DR_REF (a), DR_REF (b)))\n-\treturn false;\n-    }\n+    return refs_output_dependent_p (addr_a, addr_b);\n   else if (DR_IS_READ (a) && DR_IS_WRITE (b))\n-    {\n-      if (!refs_anti_dependent_p (DR_REF (a), DR_REF (b)))\n-\treturn false;\n-    }\n-  else if (!refs_may_alias_p (DR_REF (a), DR_REF (b)))\n-    return false;\n-\n-  if (!addr_a || !addr_b)\n-    return true;\n-\n-  /* If the references are based on different static objects, they cannot\n-     alias (PTA should be able to disambiguate such accesses, but often\n-     it fails to).  */\n-  if (TREE_CODE (addr_a) == ADDR_EXPR\n-      && TREE_CODE (addr_b) == ADDR_EXPR)\n-    return TREE_OPERAND (addr_a, 0) == TREE_OPERAND (addr_b, 0);\n-\n-  /* An instruction writing through a restricted pointer is \"independent\" of any\n-     instruction reading or writing through a different restricted pointer,\n-     in the same block/scope.  */\n-\n-  type_a = TREE_TYPE (addr_a);\n-  type_b = TREE_TYPE (addr_b);\n-  gcc_assert (POINTER_TYPE_P (type_a) && POINTER_TYPE_P (type_b));\n-\n-  if (TREE_CODE (addr_a) == SSA_NAME)\n-    decl_a = SSA_NAME_VAR (addr_a);\n-  if (TREE_CODE (addr_b) == SSA_NAME)\n-    decl_b = SSA_NAME_VAR (addr_b);\n-\n-  if (TYPE_RESTRICT (type_a) && TYPE_RESTRICT (type_b)\n-      && (DR_IS_WRITE (a) || DR_IS_WRITE (b))\n-      && decl_a && DECL_P (decl_a)\n-      && decl_b && DECL_P (decl_b)\n-      && decl_a != decl_b\n-      && TREE_CODE (DECL_CONTEXT (decl_a)) == FUNCTION_DECL\n-      && DECL_CONTEXT (decl_a) == DECL_CONTEXT (decl_b))\n-    return false;\n-\n-  return true;\n+    return refs_anti_dependent_p (addr_a, addr_b);\n+  return refs_may_alias_p (addr_a, addr_b);\n }\n \n static void compute_self_dependence (struct data_dependence_relation *);"}, {"sha": "42335b577a52089115f3df7558b0baef3ef7d115", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 66, "deletions": 26, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -166,17 +166,31 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n {\n   struct ptr_info_def *pi;\n \n-  gcc_assert ((TREE_CODE (ptr) == SSA_NAME\n-\t       || TREE_CODE (ptr) == ADDR_EXPR\n-\t       || TREE_CODE (ptr) == INTEGER_CST)\n-\t      && (TREE_CODE (decl) == VAR_DECL\n-\t\t  || TREE_CODE (decl) == PARM_DECL\n-\t\t  || TREE_CODE (decl) == RESULT_DECL));\n-\n-  /* Non-aliased variables can not be pointed to.  */\n-  if (!may_be_aliased (decl))\n+  /* Conversions are irrelevant for points-to information and\n+     data-dependence analysis can feed us those.  */\n+  STRIP_NOPS (ptr);\n+\n+  /* Anything we do not explicilty handle aliases.  */\n+  if ((TREE_CODE (ptr) != SSA_NAME\n+       && TREE_CODE (ptr) != ADDR_EXPR\n+       && TREE_CODE (ptr) != POINTER_PLUS_EXPR)\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr))\n+      || (TREE_CODE (decl) != VAR_DECL\n+\t  && TREE_CODE (decl) != PARM_DECL\n+\t  && TREE_CODE (decl) != RESULT_DECL))\n     return false;\n \n+  /* Disregard pointer offsetting.  */\n+  if (TREE_CODE (ptr) == POINTER_PLUS_EXPR)\n+    {\n+      do\n+\t{\n+\t  ptr = TREE_OPERAND (ptr, 0);\n+\t}\n+      while (TREE_CODE (ptr) == POINTER_PLUS_EXPR);\n+      return ptr_deref_may_alias_decl_p (ptr, decl);\n+    }\n+\n   /* ADDR_EXPR pointers either just offset another pointer or directly\n      specify the pointed-to set.  */\n   if (TREE_CODE (ptr) == ADDR_EXPR)\n@@ -196,10 +210,9 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing constant pointers.\n-     Just bail out in this case.  */\n-  if (TREE_CODE (ptr) == INTEGER_CST)\n-    return true;\n+  /* Non-aliased variables can not be pointed to.  */\n+  if (!may_be_aliased (decl))\n+    return false;\n \n   /* If we do not have useful points-to information for this pointer\n      we cannot disambiguate anything else.  */\n@@ -222,17 +235,46 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n    The caller is responsible for applying TBAA to see if accesses\n    through PTR1 and PTR2 may conflict at all.  */\n \n-static bool\n+bool\n ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n {\n   struct ptr_info_def *pi1, *pi2;\n \n-  gcc_assert ((TREE_CODE (ptr1) == SSA_NAME\n-\t       || TREE_CODE (ptr1) == ADDR_EXPR\n-\t       || TREE_CODE (ptr1) == INTEGER_CST)\n-\t      && (TREE_CODE (ptr2) == SSA_NAME\n-\t\t  || TREE_CODE (ptr2) == ADDR_EXPR\n-\t\t  || TREE_CODE (ptr2) == INTEGER_CST));\n+  /* Conversions are irrelevant for points-to information and\n+     data-dependence analysis can feed us those.  */\n+  STRIP_NOPS (ptr1);\n+  STRIP_NOPS (ptr2);\n+\n+  /* Anything we do not explicilty handle aliases.  */\n+  if ((TREE_CODE (ptr1) != SSA_NAME\n+       && TREE_CODE (ptr1) != ADDR_EXPR\n+       && TREE_CODE (ptr1) != POINTER_PLUS_EXPR)\n+      || (TREE_CODE (ptr2) != SSA_NAME\n+\t  && TREE_CODE (ptr2) != ADDR_EXPR\n+\t  && TREE_CODE (ptr2) != POINTER_PLUS_EXPR)\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr1))\n+      || !POINTER_TYPE_P (TREE_TYPE (ptr2)))\n+    return true;\n+\n+  /* Disregard pointer offsetting.  */\n+  if (TREE_CODE (ptr1) == POINTER_PLUS_EXPR)\n+    {\n+      do\n+\t{\n+\t  ptr1 = TREE_OPERAND (ptr1, 0);\n+\t}\n+      while (TREE_CODE (ptr1) == POINTER_PLUS_EXPR);\n+      return ptr_derefs_may_alias_p (ptr1, ptr2);\n+    }\n+  if (TREE_CODE (ptr2) == POINTER_PLUS_EXPR)\n+    {\n+      do\n+\t{\n+\t  ptr2 = TREE_OPERAND (ptr2, 0);\n+\t}\n+      while (TREE_CODE (ptr2) == POINTER_PLUS_EXPR);\n+      return ptr_derefs_may_alias_p (ptr1, ptr2);\n+    }\n \n   /* ADDR_EXPR pointers either just offset another pointer or directly\n      specify the pointed-to set.  */\n@@ -263,12 +305,6 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n \treturn true;\n     }\n \n-  /* We can end up with dereferencing constant pointers.\n-     Just bail out in this case.  */\n-  if (TREE_CODE (ptr1) == INTEGER_CST\n-      || TREE_CODE (ptr2) == INTEGER_CST)\n-    return true;\n-\n   /* We may end up with two empty points-to solutions for two same pointers.\n      In this case we still want to say both pointers alias, so shortcut\n      that here.  */\n@@ -938,13 +974,15 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n   gcc_checking_assert ((!ref1->ref\n \t\t\t|| TREE_CODE (ref1->ref) == SSA_NAME\n \t\t\t|| DECL_P (ref1->ref)\n+\t\t\t|| TREE_CODE (ref1->ref) == STRING_CST\n \t\t\t|| handled_component_p (ref1->ref)\n \t\t\t|| INDIRECT_REF_P (ref1->ref)\n \t\t\t|| TREE_CODE (ref1->ref) == MEM_REF\n \t\t\t|| TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n \t\t       && (!ref2->ref\n \t\t\t   || TREE_CODE (ref2->ref) == SSA_NAME\n \t\t\t   || DECL_P (ref2->ref)\n+\t\t\t   || TREE_CODE (ref2->ref) == STRING_CST\n \t\t\t   || handled_component_p (ref2->ref)\n \t\t\t   || INDIRECT_REF_P (ref2->ref)\n \t\t\t   || TREE_CODE (ref2->ref) == MEM_REF\n@@ -965,6 +1003,8 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n       || TREE_CODE (base2) == SSA_NAME\n       || TREE_CODE (base1) == CONST_DECL\n       || TREE_CODE (base2) == CONST_DECL\n+      || TREE_CODE (base1) == STRING_CST\n+      || TREE_CODE (base2) == STRING_CST\n       || is_gimple_min_invariant (base1)\n       || is_gimple_min_invariant (base2))\n     return false;"}, {"sha": "a97ba69822ada5eb6279352896fe3060693eca70", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d36e53818f31ab207c545d0c273fd9edca6ff09/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=7d36e53818f31ab207c545d0c273fd9edca6ff09", "patch": "@@ -97,6 +97,7 @@ extern void ao_ref_init_from_ptr_and_size (ao_ref *, tree, tree);\n extern tree ao_ref_base (ao_ref *);\n extern alias_set_type ao_ref_alias_set (ao_ref *);\n extern bool ptr_deref_may_alias_global_p (tree);\n+extern bool ptr_derefs_may_alias_p (tree, tree);\n extern bool refs_may_alias_p (tree, tree);\n extern bool refs_may_alias_p_1 (ao_ref *, ao_ref *, bool);\n extern bool refs_anti_dependent_p (tree, tree);"}]}