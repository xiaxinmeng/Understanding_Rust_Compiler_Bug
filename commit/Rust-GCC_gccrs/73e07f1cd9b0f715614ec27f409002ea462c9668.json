{"sha": "73e07f1cd9b0f715614ec27f409002ea462c9668", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNlMDdmMWNkOWIwZjcxNTYxNGVjMjdmNDA5MDAyZWE0NjJjOTY2OA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-10-31T11:41:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-27T09:15:38Z"}, "message": "[Ada] Optimize magnitude of integer operations for fixed point\n\ngcc/ada/\n\n\t* exp_fixd.adb (Build_Double_Divide): Use the RM size of types and\n\ta more precise estimate for the size of the denominator.\n\t(Build_Double_Divide_Code): Likewise.\n\t(Build_Multiply): Use a more precise estimate for the size of the\n\tresult.\n\t(Build_Scaled_Divide):  Use the RM size of types and a more precise\n\testimate for the size of the numerator.\n\t(Build_Scaled_Divide_Code): Likewise.", "tree": {"sha": "ba62153078e9b8f243ece510c6b8f58fb15554c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba62153078e9b8f243ece510c6b8f58fb15554c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73e07f1cd9b0f715614ec27f409002ea462c9668", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e07f1cd9b0f715614ec27f409002ea462c9668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73e07f1cd9b0f715614ec27f409002ea462c9668", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73e07f1cd9b0f715614ec27f409002ea462c9668/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e9f814d754be790aec5b69a95699a8af2654058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9f814d754be790aec5b69a95699a8af2654058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e9f814d754be790aec5b69a95699a8af2654058"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "a3705694f559a7f87598b69a547769d3600cbc1b", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73e07f1cd9b0f715614ec27f409002ea462c9668/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73e07f1cd9b0f715614ec27f409002ea462c9668/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=73e07f1cd9b0f715614ec27f409002ea462c9668", "patch": "@@ -448,15 +448,15 @@ package body Exp_Fixd is\n      (N       : Node_Id;\n       X, Y, Z : Node_Id) return Node_Id\n    is\n-      Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n-      Z_Size : constant Nat := UI_To_Int (Esize (Etype (Z)));\n+      Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n+      Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n       Expr   : Node_Id;\n \n    begin\n       --  If the denominator fits in Max_Integer_Size bits, we can build the\n       --  operations directly without causing any intermediate overflow.\n \n-      if 2 * Nat'Max (Y_Size, Z_Size) <= System_Max_Integer_Size then\n+      if Y_Size + Z_Size <= System_Max_Integer_Size then\n          return Build_Divide (N, X, Build_Multiply (N, Y, Z));\n \n       --  Otherwise we use the runtime routine\n@@ -516,9 +516,9 @@ package body Exp_Fixd is\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n \n-      X_Size : constant Nat := UI_To_Int (Esize (Etype (X)));\n-      Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n-      Z_Size : constant Nat := UI_To_Int (Esize (Etype (Z)));\n+      X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n+      Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n+      Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n \n       QR_Id  : RE_Id;\n       QR_Siz : Nat;\n@@ -533,7 +533,7 @@ package body Exp_Fixd is\n    begin\n       --  Find type that will allow computation of denominator\n \n-      QR_Siz := Nat'Max (X_Size, 2 * Nat'Max (Y_Size, Z_Size));\n+      QR_Siz := Nat'Max (X_Size, Y_Size + Z_Size);\n \n       if QR_Siz <= 16 then\n          QR_Typ := Standard_Integer_16;\n@@ -724,10 +724,10 @@ package body Exp_Fixd is\n             end;\n          end if;\n \n-         --  Now the result size must be at least twice the longer of\n-         --  the two sizes, to accommodate all possible results.\n+         --  Now the result size must be at least the sum of the two sizes,\n+         --  to accommodate all possible results.\n \n-         Rsize := 2 * Int'Max (Left_Size, Right_Size);\n+         Rsize := Left_Size + Right_Size;\n \n          if Rsize <= 8 then\n             Result_Type := Standard_Integer_8;\n@@ -828,15 +828,15 @@ package body Exp_Fixd is\n      (N       : Node_Id;\n       X, Y, Z : Node_Id) return Node_Id\n    is\n-      X_Size : constant Nat := UI_To_Int (Esize (Etype (X)));\n-      Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n+      X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n+      Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n       Expr   : Node_Id;\n \n    begin\n       --  If the numerator fits in Max_Integer_Size bits, we can build the\n       --  operations directly without causing any intermediate overflow.\n \n-      if 2 * Nat'Max (X_Size, Y_Size) <= System_Max_Integer_Size then\n+      if X_Size + Y_Size <= System_Max_Integer_Size then\n          return Build_Divide (N, Build_Multiply (N, X, Y), Z);\n \n       --  Otherwise we use the runtime routine\n@@ -893,9 +893,9 @@ package body Exp_Fixd is\n    is\n       Loc    : constant Source_Ptr := Sloc (N);\n \n-      X_Size : constant Nat := UI_To_Int (Esize (Etype (X)));\n-      Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n-      Z_Size : constant Nat := UI_To_Int (Esize (Etype (Z)));\n+      X_Size : constant Nat := UI_To_Int (RM_Size (Etype (X)));\n+      Y_Size : constant Nat := UI_To_Int (RM_Size (Etype (Y)));\n+      Z_Size : constant Nat := UI_To_Int (RM_Size (Etype (Z)));\n \n       QR_Id  : RE_Id;\n       QR_Siz : Nat;\n@@ -910,7 +910,7 @@ package body Exp_Fixd is\n    begin\n       --  Find type that will allow computation of numerator\n \n-      QR_Siz := Nat'Max (2 * Nat'Max (X_Size, Y_Size), Z_Size);\n+      QR_Siz := Nat'Max (X_Size + Y_Size, Z_Size);\n \n       if QR_Siz <= 16 then\n          QR_Typ := Standard_Integer_16;"}]}