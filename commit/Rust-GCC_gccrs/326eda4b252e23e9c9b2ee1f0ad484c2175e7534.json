{"sha": "326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI2ZWRhNGIyNTJlMjNlOWM5YjJlZTFmMGFkNDg0YzIxNzVlNzUzNA==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2005-12-06T04:22:11Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-12-06T04:22:11Z"}, "message": "In gcc/ 2005-12-05 Daniel Berlin <dberlin@dberlin.org>\n\nIn gcc/\n2005-12-05  Daniel Berlin  <dberlin@dberlin.org>\n\t\n\t* print-tree.c (print_node): Ditto.\n\t* tree-dfa.c (add_referenced_var): Tag's don't have DECL_INITIAL.\n\t* tree-dump.c (dequeue_and_dump): Check for decl_common structure\n\tbefore accessing DECL_ARTIFICIAL. \n\tHandle new tag tree codes.\n\t* tree-flow-inline.h (clear_call_clobbered): Update for tag\n\tchanges.\n\t(unmodifiable_var_p): Ditto.\n\t* tree-flow.h (mem_tag_kind): Remove.\n\t(struct var_ann_d): Remove mem_tag_kind member.\n\t* tree-gimple.c (is_gimple_reg): Tags are not gimple registers.\n\t* tree-pretty-print.c (dump_generic_node): Handle memory tags.\n\t* tree-ssa-alias.c (init_alias_info): Update for memory tag changes.\n\t(group_aliases): Ditto.\n\t(setup_pointers_and_addressables): Ditto.\n\t(is_escape_site): Ditto.\t\t\t\t\t  \n\t(may_alias_p): Ditto.\n\t(create_tag_raw): New function.\n\t(create_memory_tag): Use it.\n\t(dump_alias_info): Update for tags.\n\t(may_be_aliased): Ditto.\n\t(add_type_alias): Ditto.\n\t(new_type_alias): Ditto.\n\t(create_sft): Ditto.\n\t(create_structure_vars): Ditto.\n\t* tree-ssa-ccp.c (get_default_value): Ditto.\n\t* tree-ssa-operands.c (get_expr_operands): Ditto.\n\t(add_stmt_operand): Ditto.\n\t(add_call_clobber_ops): Remove duplicated condition.\n\t* tree-ssa.c (verify_flow_insensitive_alias_info): Update for\n\ttags.\n\t* tree-tailcall.c (suitable_for_tail_opt_p): Ditto.\n\t* tree-vect-transform.c (vect_create_data_ref_ptr): Ditto.\n\t* tree.c (init_ttree): Update structures for new tree codes.\n\t(tree_code_size): Update sizes for new tree codes.\n\t(make_node_stat): Don't try to set common things on minimal\n\tstructures.\n\t(tree_node_structure): Update for tags.\n\t(is_global_var): Ditto.\n\t* tree.def: Add new tree codes.\n\t* tree.h (MTAG_P): New macro.\n\t(TREE_MEMORY_TAG_CHECK): Ditto.\n\t(SSA_VAR_P): Update for tags.\n\t(struct tree_memory_tag): New structure.\n\t(MTAG_GLOBAL): New macro.\n\t(union tree_node): Add memory tag member.\n\t* treestruct.def (TS_MEMORY_TAG): New.\n\nIn gcc/cp\n\n2005-12-05  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* ptree.c (cxx_print_decl): Update to check for decl_common\n\tstructure.\n\nFrom-SVN: r108102", "tree": {"sha": "88dba83e793d94c96e1d4866470453d1f88073c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88dba83e793d94c96e1d4866470453d1f88073c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "html_url": "https://github.com/Rust-GCC/gccrs/commit/326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "45c76dbb43ff77f9d8fd89271033784a9bfbd4c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45c76dbb43ff77f9d8fd89271033784a9bfbd4c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45c76dbb43ff77f9d8fd89271033784a9bfbd4c5"}], "stats": {"total": 443, "additions": 289, "deletions": 154}, "files": [{"sha": "0bc88d3cca6fe3bbc78d5d75aa1c56ebb44f581b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -1,3 +1,53 @@\n+2005-12-05  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* print-tree.c (print_node): Ditto.\n+\t* tree-dfa.c (add_referenced_var): Tag's don't have DECL_INITIAL.\n+\t* tree-dump.c (dequeue_and_dump): Check for decl_common structure\n+\tbefore accessing DECL_ARTIFICIAL. \n+\tHandle new tag tree codes.\n+\t* tree-flow-inline.h (clear_call_clobbered): Update for tag\n+\tchanges.\n+\t(unmodifiable_var_p): Ditto.\n+\t* tree-flow.h (mem_tag_kind): Remove.\n+\t(struct var_ann_d): Remove mem_tag_kind member.\n+\t* tree-gimple.c (is_gimple_reg): Tags are not gimple registers.\n+\t* tree-pretty-print.c (dump_generic_node): Handle memory tags.\n+\t* tree-ssa-alias.c (init_alias_info): Update for memory tag changes.\n+\t(group_aliases): Ditto.\n+\t(setup_pointers_and_addressables): Ditto.\n+\t(is_escape_site): Ditto.\t\t\t\t\t  \n+\t(may_alias_p): Ditto.\n+\t(create_tag_raw): New function.\n+\t(create_memory_tag): Use it.\n+\t(dump_alias_info): Update for tags.\n+\t(may_be_aliased): Ditto.\n+\t(add_type_alias): Ditto.\n+\t(new_type_alias): Ditto.\n+\t(create_sft): Ditto.\n+\t(create_structure_vars): Ditto.\n+\t* tree-ssa-ccp.c (get_default_value): Ditto.\n+\t* tree-ssa-operands.c (get_expr_operands): Ditto.\n+\t(add_stmt_operand): Ditto.\n+\t(add_call_clobber_ops): Remove duplicated condition.\n+\t* tree-ssa.c (verify_flow_insensitive_alias_info): Update for\n+\ttags.\n+\t* tree-tailcall.c (suitable_for_tail_opt_p): Ditto.\n+\t* tree-vect-transform.c (vect_create_data_ref_ptr): Ditto.\n+\t* tree.c (init_ttree): Update structures for new tree codes.\n+\t(tree_code_size): Update sizes for new tree codes.\n+\t(make_node_stat): Don't try to set common things on minimal\n+\tstructures.\n+\t(tree_node_structure): Update for tags.\n+\t(is_global_var): Ditto.\n+\t* tree.def: Add new tree codes.\n+\t* tree.h (MTAG_P): New macro.\n+\t(TREE_MEMORY_TAG_CHECK): Ditto.\n+\t(SSA_VAR_P): Update for tags.\n+\t(struct tree_memory_tag): New structure.\n+\t(MTAG_GLOBAL): New macro.\n+\t(union tree_node): Add memory tag member.\n+\t* treestruct.def (TS_MEMORY_TAG): New.\n+\t\n 2005-12-05  Dale Johannesen  <dalej@apple.com>\n \n \t* config/i386/xmmintrin.h (_MM_TRANSPOSE4_PS):  Fix to match"}, {"sha": "36642eb82809d8f56b7bc541e21e0dd2438b0b84", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -1,3 +1,8 @@\n+2005-12-05  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* ptree.c (cxx_print_decl): Update to check for decl_common\n+\tstructure.\n+\n 2005-12-02  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/24173"}, {"sha": "5d6651c53d81a2ba8fc0c1e644fc3b3a19e97704", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -41,7 +41,8 @@ cxx_print_decl (FILE *file, tree node, int indent)\n       return;\n     }\n \n-  if (!DECL_LANG_SPECIFIC (node))\n+  if (!CODE_CONTAINS_STRUCT (TREE_CODE (node), TS_DECL_COMMON)\n+      || !DECL_LANG_SPECIFIC (node))\n     return;\n   indent_to (file, indent + 3);\n   if (TREE_CODE (node) == FUNCTION_DECL"}, {"sha": "d247835ea6d96e1c5d956df962bde30213e5abdb", "filename": "gcc/print-tree.c", "status": "modified", "additions": 78, "deletions": 68, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -314,18 +314,19 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n   switch (TREE_CODE_CLASS (TREE_CODE (node)))\n     {\n     case tcc_declaration:\n-      mode = DECL_MODE (node);\n-\n-      if (DECL_UNSIGNED (node))\n-\tfputs (\" unsigned\", file);\n-      if (DECL_IGNORED_P (node))\n-\tfputs (\" ignored\", file);\n-      if (DECL_ABSTRACT (node))\n-\tfputs (\" abstract\", file);      \n-      if (DECL_EXTERNAL (node))\n-\tfputs (\" external\", file);\n-      if (DECL_NONLOCAL (node))\n-\tfputs (\" nonlocal\", file);\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+\t{\n+\t  if (DECL_UNSIGNED (node))\n+\t    fputs (\" unsigned\", file);\n+\t  if (DECL_IGNORED_P (node))\n+\t    fputs (\" ignored\", file);\n+\t  if (DECL_ABSTRACT (node))\n+\t    fputs (\" abstract\", file);      \n+\t  if (DECL_EXTERNAL (node))\n+\t    fputs (\" external\", file);\n+\t  if (DECL_NONLOCAL (node))\n+\t    fputs (\" nonlocal\", file);\n+\t}\n       if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n \t{\n \t  if (DECL_WEAK (node))\n@@ -385,66 +386,73 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t    }\n \t}\n \n-      if (DECL_VIRTUAL_P (node))\n-\tfputs (\" virtual\", file);\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+\t{\t  \n+\t  if (DECL_VIRTUAL_P (node))\n+\t    fputs (\" virtual\", file);\n+\t  if (DECL_PRESERVE_P (node))\n+\t    fputs (\" preserve\", file);\t  \n+\t  if (DECL_LANG_FLAG_0 (node))\n+\t    fputs (\" decl_0\", file);\n+\t  if (DECL_LANG_FLAG_1 (node))\n+\t    fputs (\" decl_1\", file);\n+\t  if (DECL_LANG_FLAG_2 (node))\n+\t    fputs (\" decl_2\", file);\n+\t  if (DECL_LANG_FLAG_3 (node))\n+\t    fputs (\" decl_3\", file);\n+\t  if (DECL_LANG_FLAG_4 (node))\n+\t    fputs (\" decl_4\", file);\n+\t  if (DECL_LANG_FLAG_5 (node))\n+\t    fputs (\" decl_5\", file);\n+\t  if (DECL_LANG_FLAG_6 (node))\n+\t    fputs (\" decl_6\", file);\n+\t  if (DECL_LANG_FLAG_7 (node))\n+\t    fputs (\" decl_7\", file);\n+\t  \n+\t  mode = DECL_MODE (node);\n+\t  fprintf (file, \" %s\", GET_MODE_NAME (mode));\n+\t}\n+\n       if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS)  && DECL_DEFER_OUTPUT (node))\n \tfputs (\" defer-output\", file);\n \n-      if (DECL_PRESERVE_P (node))\n-\tfputs (\" preserve\", file);\n-\n-      if (DECL_LANG_FLAG_0 (node))\n-\tfputs (\" decl_0\", file);\n-      if (DECL_LANG_FLAG_1 (node))\n-\tfputs (\" decl_1\", file);\n-      if (DECL_LANG_FLAG_2 (node))\n-\tfputs (\" decl_2\", file);\n-      if (DECL_LANG_FLAG_3 (node))\n-\tfputs (\" decl_3\", file);\n-      if (DECL_LANG_FLAG_4 (node))\n-\tfputs (\" decl_4\", file);\n-      if (DECL_LANG_FLAG_5 (node))\n-\tfputs (\" decl_5\", file);\n-      if (DECL_LANG_FLAG_6 (node))\n-\tfputs (\" decl_6\", file);\n-      if (DECL_LANG_FLAG_7 (node))\n-\tfputs (\" decl_7\", file);\n \n-      fprintf (file, \" %s\", GET_MODE_NAME (mode));\n       xloc = expand_location (DECL_SOURCE_LOCATION (node));\n       fprintf (file, \" file %s line %d\", xloc.file, xloc.line);\n \n-      print_node (file, \"size\", DECL_SIZE (node), indent + 4);\n-      print_node (file, \"unit size\", DECL_SIZE_UNIT (node), indent + 4);\n-\n-      if (TREE_CODE (node) != FUNCTION_DECL\n-\t  || DECL_INLINE (node) || DECL_BUILT_IN (node))\n-\tindent_to (file, indent + 3);\n-\n-      if (TREE_CODE (node) != FUNCTION_DECL)\n-\t{\n-\t  if (DECL_USER_ALIGN (node))\n-\t    fprintf (file, \" user\");\n-\n-\t  fprintf (file, \" align %d\", DECL_ALIGN (node));\n-\t  if (TREE_CODE (node) == FIELD_DECL)\n-\t    fprintf (file, \" offset_align \" HOST_WIDE_INT_PRINT_UNSIGNED,\n-\t\t     DECL_OFFSET_ALIGN (node));\n-\t}\n-      else if (DECL_BUILT_IN (node))\n-\t{\n-\t  if (DECL_BUILT_IN_CLASS (node) == BUILT_IN_MD)\n-\t    fprintf (file, \" built-in BUILT_IN_MD %d\", DECL_FUNCTION_CODE (node));\n-\t  else\n-\t    fprintf (file, \" built-in %s:%s\",\n-\t\t     built_in_class_names[(int) DECL_BUILT_IN_CLASS (node)],\n-\t\t     built_in_names[(int) DECL_FUNCTION_CODE (node)]);\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+\t{\t  \n+\t  print_node (file, \"size\", DECL_SIZE (node), indent + 4);\n+\t  print_node (file, \"unit size\", DECL_SIZE_UNIT (node), indent + 4);\n+\t  \n+\t  if (TREE_CODE (node) != FUNCTION_DECL\n+\t      || DECL_INLINE (node) || DECL_BUILT_IN (node))\n+\t    indent_to (file, indent + 3);\n+\t  \n+\t  if (TREE_CODE (node) != FUNCTION_DECL)\n+\t    {\n+\t      if (DECL_USER_ALIGN (node))\n+\t\tfprintf (file, \" user\");\n+\t      \n+\t      fprintf (file, \" align %d\", DECL_ALIGN (node));\n+\t      if (TREE_CODE (node) == FIELD_DECL)\n+\t\tfprintf (file, \" offset_align \" HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t\t\t DECL_OFFSET_ALIGN (node));\n+\t    }\n+\t  else if (DECL_BUILT_IN (node))\n+\t    {\n+\t      if (DECL_BUILT_IN_CLASS (node) == BUILT_IN_MD)\n+\t\tfprintf (file, \" built-in BUILT_IN_MD %d\", DECL_FUNCTION_CODE (node));\n+\t      else\n+\t\tfprintf (file, \" built-in %s:%s\",\n+\t\t\t built_in_class_names[(int) DECL_BUILT_IN_CLASS (node)],\n+\t\t\t built_in_names[(int) DECL_FUNCTION_CODE (node)]);\n+\t    }\n+\t  \n+\t  if (DECL_POINTER_ALIAS_SET_KNOWN_P (node))\n+\t    fprintf (file, \" alias set \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t     DECL_POINTER_ALIAS_SET (node));\n \t}\n-\n-      if (DECL_POINTER_ALIAS_SET_KNOWN_P (node))\n-\tfprintf (file, \" alias set \" HOST_WIDE_INT_PRINT_DEC,\n-\t\t DECL_POINTER_ALIAS_SET (node));\n-\n       if (TREE_CODE (node) == FIELD_DECL)\n \t{\n \t  print_node (file, \"offset\", DECL_FIELD_OFFSET (node), indent + 4);\n@@ -454,9 +462,12 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n       print_node_brief (file, \"context\", DECL_CONTEXT (node), indent + 4);\n \n-      print_node_brief (file, \"attributes\",\n-\t\t\tDECL_ATTRIBUTES (node), indent + 4);\n-      \n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\t\n+\t{\n+\t  print_node_brief (file, \"attributes\",\n+\t\t\t    DECL_ATTRIBUTES (node), indent + 4);\n+\t  print_node_brief (file, \"initial\", DECL_INITIAL (node), indent + 4);\n+\t}\n       if (CODE_CONTAINS_STRUCT (code, TS_DECL_WRTL))\n \t{\n \t  print_node_brief (file, \"abstract_origin\",\n@@ -467,7 +478,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  print_node (file, \"arguments\", DECL_ARGUMENT_FLD (node), indent + 4);\n \t  print_node (file, \"result\", DECL_RESULT_FLD (node), indent + 4);\n \t}\n-      print_node_brief (file, \"initial\", DECL_INITIAL (node), indent + 4);\n \n       lang_hooks.print_decl (file, node, indent);\n "}, {"sha": "3f89047714b2f79465709e8ebedac268fe4d6182", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -643,6 +643,10 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n       if (is_global_var (var))\n \tmark_call_clobbered (var);\n \n+      /* Tag's don't have DECL_INITIAL.  */\n+      if (MTAG_P (var))\n+\treturn;\n+      \n       /* Scan DECL_INITIAL for pointer variables as they may contain\n \t address arithmetic referencing the address of other\n \t variables.  */"}, {"sha": "ea36129cdb687046a0c817be8f740bfaaf7ee637", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -343,7 +343,8 @@ dequeue_and_dump (dump_info_p di)\n \t  di->column += 6 + strlen (filename) + 8;\n \t}\n       /* And any declaration can be compiler-generated.  */\n-      if (DECL_ARTIFICIAL (t))\n+      if (CODE_CONTAINS_STRUCT (TREE_CODE (t), TS_DECL_COMMON)\n+\t  && DECL_ARTIFICIAL (t))\n \tdump_string_field (di, \"note\", \"artificial\");\n       if (TREE_CHAIN (t) && !dump_flag (di, TDF_SLIM, NULL))\n \tdump_child (\"chan\", TREE_CHAIN (t));\n@@ -476,6 +477,11 @@ dequeue_and_dump (dump_info_p di)\n     case CONST_DECL:\n       dump_child (\"cnst\", DECL_INITIAL (t));\n       break;\n+      \n+    case TYPE_MEMORY_TAG:\n+    case NAME_MEMORY_TAG:\n+    case STRUCT_FIELD_TAG:\n+      break;\n \n     case VAR_DECL:\n     case PARM_DECL:"}, {"sha": "ddfa77a7c0c8631794ed80d1f3f41e4efa6bd84e", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -845,13 +845,12 @@ is_call_clobbered (tree var)\n static inline void\n mark_call_clobbered (tree var)\n {\n-  var_ann_t ann = var_ann (var);\n   /* If VAR is a memory tag, then we need to consider it a global\n      variable.  This is because the pointer that VAR represents has\n      been found to point to either an arbitrary location or to a known\n      location in global memory.  */\n-  if (ann->mem_tag_kind != NOT_A_TAG && ann->mem_tag_kind != STRUCT_FIELD)\n-    DECL_EXTERNAL (var) = 1;\n+  if (MTAG_P (var) && TREE_CODE (var) != STRUCT_FIELD_TAG)\n+    MTAG_GLOBAL (var) = 1;\n   bitmap_set_bit (call_clobbered_vars, DECL_UID (var));\n   ssa_call_clobbered_cache_valid = false;\n   ssa_ro_call_cache_valid = false;\n@@ -861,9 +860,8 @@ mark_call_clobbered (tree var)\n static inline void\n clear_call_clobbered (tree var)\n {\n-  var_ann_t ann = var_ann (var);\n-  if (ann->mem_tag_kind != NOT_A_TAG && ann->mem_tag_kind != STRUCT_FIELD)\n-    DECL_EXTERNAL (var) = 0;\n+  if (MTAG_P (var) && TREE_CODE (var) != STRUCT_FIELD_TAG)\n+    MTAG_GLOBAL (var) = 0;\n   bitmap_clear_bit (call_clobbered_vars, DECL_UID (var));\n   ssa_call_clobbered_cache_valid = false;\n   ssa_ro_call_cache_valid = false;\n@@ -1404,6 +1402,10 @@ unmodifiable_var_p (tree var)\n {\n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n+\n+  if (MTAG_P (var))\n+    return TREE_READONLY (var) && (TREE_STATIC (var) || MTAG_GLOBAL (var));\n+\n   return TREE_READONLY (var) && (TREE_STATIC (var) || DECL_EXTERNAL (var));\n }\n "}, {"sha": "6345d1ee3df858750d668061ed61e08562aa3c5e", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -137,28 +137,6 @@ enum need_phi_state {\n   NEED_PHI_STATE_MAYBE\n };\n \n-\n-/* When computing aliasing information, we represent the memory pointed-to\n-   by pointers with artificial variables called \"memory tags\" (MT).  There\n-   are two kinds of tags: type and name.  Type tags (TMT) are used in\n-   type-based alias analysis, they represent all the pointed-to locations\n-   and variables of the same alias set class.  Name tags (NMT) are used in\n-   flow-sensitive points-to alias analysis, they represent the variables\n-   and memory locations pointed-to by a specific SSA_NAME pointer.  */\n-enum mem_tag_kind {\n-  /* This variable is not a memory tag.  */\n-  NOT_A_TAG,\n-\n-  /* This variable is a type memory tag (TMT).  */\n-  TYPE_TAG,\n-\n-  /* This variable is a name memory tag (NMT).  */\n-  NAME_TAG,\n-\n-  /* This variable represents a structure field.  */\n-  STRUCT_FIELD\n-};\n-\n struct subvar;\n typedef struct subvar *subvar_t;\n \n@@ -189,9 +167,6 @@ struct var_ann_d GTY(())\n   /* Used when building root_var structures in tree_ssa_live.[ch].  */\n   unsigned root_var_processed : 1;\n \n-  /* If nonzero, this variable is a memory tag.  */\n-  ENUM_BITFIELD (mem_tag_kind) mem_tag_kind : 2;\n-\n   /* Nonzero if this variable is an alias tag that represents references to\n      other variables (i.e., this variable appears in the MAY_ALIASES array\n      of other variables).  */"}, {"sha": "3b70905cf84e90690a3bc16340d855505c78fb2b", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -266,11 +266,12 @@ is_gimple_reg_type (tree type)\n bool\n is_gimple_reg (tree t)\n {\n-  var_ann_t ann;\n-\n   if (TREE_CODE (t) == SSA_NAME)\n     t = SSA_NAME_VAR (t);\n \n+  if (MTAG_P (t))\n+    return false;\n+\n   if (!is_gimple_variable (t))\n     return false;\n \n@@ -305,12 +306,6 @@ is_gimple_reg (tree t)\n   if (TREE_CODE (TREE_TYPE (t)) == COMPLEX_TYPE)\n     return DECL_COMPLEX_GIMPLE_REG_P (t);\n \n-  /* Some compiler temporaries are created to be used exclusively in\n-     virtual operands (currently memory tags and sub-variables).\n-     These variables should never be considered GIMPLE registers.  */\n-  if (DECL_ARTIFICIAL (t) && (ann = var_ann (t)) != NULL)\n-    return ann->mem_tag_kind == NOT_A_TAG;\n-\n   return true;\n }\n "}, {"sha": "313e461dc8517e7816eed8303090d8c41181fe24", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -698,6 +698,9 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t}\n       break;\n \n+    case TYPE_MEMORY_TAG:\n+    case NAME_MEMORY_TAG:\n+    case STRUCT_FIELD_TAG:\n     case VAR_DECL:\n     case PARM_DECL:\n     case FIELD_DECL:"}, {"sha": "1a9c0060533821fa2cb09701c3487429b8b2bded", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -492,8 +492,8 @@ init_alias_info (void)\n \t     a global variable, so we *don't* clear their call clobberedness\n \t     just because they are tags, though we will clear it if they\n \t     aren't for global variables.  */\n-\t  if (ann->mem_tag_kind == NAME_TAG \n-\t      || ann->mem_tag_kind == TYPE_TAG \n+\t  if (TREE_CODE (var) == NAME_MEMORY_TAG\n+\t      || TREE_CODE (var) == TYPE_MEMORY_TAG\n \t      || !is_global_var (var))\n \t    clear_call_clobbered (var);\n \t}\n@@ -1119,8 +1119,8 @@ group_aliases (struct alias_info *ai)\n \t  tree alias = VARRAY_TREE (aliases, j);\n \t  var_ann_t ann = var_ann (alias);\n \n-\t  if ((ann->mem_tag_kind == NOT_A_TAG \n-\t       || ann->mem_tag_kind == STRUCT_FIELD)\n+\t  if ((!MTAG_P (alias)\n+\t       || TREE_CODE (alias) == STRUCT_FIELD_TAG)\n \t      && ann->may_aliases)\n \t    {\n \t      tree new_alias;\n@@ -1219,8 +1219,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n          Structure fields, on the other hand, have to have some of this\n          information processed for them, but it's pointless to mark them\n          non-addressable (since they are fake variables anyway).  */\n-      if (v_ann->mem_tag_kind != NOT_A_TAG\n-\t  && v_ann->mem_tag_kind != STRUCT_FIELD) \n+      if (MTAG_P (var) && TREE_CODE (var) != STRUCT_FIELD_TAG)\n \tcontinue;\n \n       /* Remove the ADDRESSABLE flag from every addressable variable whose\n@@ -1464,7 +1463,6 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n \t     bool alias_set_only)\n {\n   tree mem;\n-  var_ann_t m_ann;\n \n   alias_stats.alias_queries++;\n   alias_stats.simple_queries++;\n@@ -1498,9 +1496,7 @@ may_alias_p (tree ptr, HOST_WIDE_INT mem_alias_set,\n       return false;\n     }\n \n-  m_ann = var_ann (mem);\n-\n-  gcc_assert (m_ann->mem_tag_kind == TYPE_TAG);\n+  gcc_assert (TREE_CODE (mem) == TYPE_MEMORY_TAG);\n \n   alias_stats.tbaa_queries++;\n \n@@ -1729,6 +1725,31 @@ is_escape_site (tree stmt, struct alias_info *ai)\n   return false;\n }\n \n+/* Create a new memory tag of type TYPE.\n+   Does NOT push it into the current binding.  */\n+\n+static tree\n+create_tag_raw (enum tree_code code, tree type, const char *prefix)\n+{\n+  tree tmp_var;\n+  tree new_type;\n+\n+  /* Make the type of the variable writable.  */\n+  new_type = build_type_variant (type, 0, 0);\n+  TYPE_ATTRIBUTES (new_type) = TYPE_ATTRIBUTES (type);\n+\n+  tmp_var = build_decl (code, create_tmp_var_name (prefix),\n+\t\t\ttype);\n+  /* Make the variable writable.  */\n+  TREE_READONLY (tmp_var) = 0;\n+\n+  /* It doesn't start out global.  */\n+  MTAG_GLOBAL (tmp_var) = 0;\n+  TREE_STATIC (tmp_var) = 0;\n+  TREE_USED (tmp_var) = 1;\n+\n+  return tmp_var;\n+}\n \n /* Create a new memory tag of type TYPE.  If IS_TYPE_TAG is true, the tag\n    is considered to represent all the pointers whose pointed-to types are\n@@ -1739,7 +1760,8 @@ static tree\n create_memory_tag (tree type, bool is_type_tag)\n {\n   var_ann_t ann;\n-  tree tag = create_tmp_var_raw (type, (is_type_tag) ? \"TMT\" : \"NMT\");\n+  tree tag = create_tag_raw (is_type_tag ? TYPE_MEMORY_TAG : NAME_MEMORY_TAG,\n+\t\t\t     type, (is_type_tag) ? \"TMT\" : \"NMT\");\n \n   /* By default, memory tags are local variables.  Alias analysis will\n      determine whether they should be considered globals.  */\n@@ -1749,7 +1771,6 @@ create_memory_tag (tree type, bool is_type_tag)\n   TREE_ADDRESSABLE (tag) = 1;\n \n   ann = get_var_ann (tag);\n-  ann->mem_tag_kind = (is_type_tag) ? TYPE_TAG : NAME_TAG;\n   ann->type_mem_tag = NULL_TREE;\n \n   /* Add the tag to the symbol table.  */\n@@ -1942,8 +1963,7 @@ dump_alias_info (FILE *file)\n   \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      var_ann_t ann = var_ann (var);\n-      if (ann->mem_tag_kind == TYPE_TAG)\n+      if (TREE_CODE (var) == TYPE_MEMORY_TAG)\n \tdump_variable (file, var);\n     }\n \n@@ -1969,8 +1989,7 @@ dump_alias_info (FILE *file)\n   \n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n-      var_ann_t ann = var_ann (var);\n-      if (ann->mem_tag_kind == NAME_TAG)\n+      if (TREE_CODE (var) == NAME_MEMORY_TAG)\n \tdump_variable (file, var);\n     }\n \n@@ -2173,7 +2192,12 @@ may_be_aliased (tree var)\n \n   /* Globally visible variables can have their addresses taken by other\n      translation units.  */\n-  if (DECL_EXTERNAL (var) || TREE_PUBLIC (var))\n+\n+  if (MTAG_P (var)\n+      && (MTAG_GLOBAL (var) || TREE_PUBLIC (var)))\n+    return true;\n+  else if (!MTAG_P (var)\n+      && (DECL_EXTERNAL (var) || TREE_PUBLIC (var)))\n     return true;\n \n   /* Automatic variables can't have their addresses escape any other way.\n@@ -2280,7 +2304,7 @@ add_type_alias (tree ptr, tree var)\n found_tag:\n   /* If VAR is not already PTR's type tag, add it to the may-alias set\n      for PTR's type tag.  */\n-  gcc_assert (var_ann (var)->type_mem_tag == NOT_A_TAG);\n+  gcc_assert (!MTAG_P (var_ann (var)->type_mem_tag));\n   tag = ann->type_mem_tag;\n \n   /* If VAR has subvars, add the subvars to the tag instead of the\n@@ -2333,7 +2357,7 @@ new_type_alias (tree ptr, tree var)\n   subvar_t svars;\n \n   gcc_assert (p_ann->type_mem_tag == NULL_TREE);\n-  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG);\n+  gcc_assert (!MTAG_P (var));\n \n   /* Add VAR to the may-alias set of PTR's new type tag.  If VAR has\n      subvars, add the subvars to the tag instead of the actual var.  */\n@@ -2361,7 +2385,7 @@ new_type_alias (tree ptr, tree var)\n \t{\n \t  tree ali = VARRAY_TREE (aliases, 0);\n \n-\t  if (get_var_ann (ali)->mem_tag_kind == TYPE_TAG)\n+\t  if (TREE_CODE (ali) == TYPE_MEMORY_TAG)\n \t    {\n \t      p_ann->type_mem_tag = ali;\n \t      return;\n@@ -2495,19 +2519,18 @@ static tree\n create_sft (tree var, tree field)\n {\n   var_ann_t ann;\n-  tree subvar = create_tmp_var_raw (TREE_TYPE (field), \"SFT\");\n+  tree subvar = create_tag_raw (STRUCT_FIELD_TAG, TREE_TYPE (field), \"SFT\");\n \n   /* We need to copy the various flags from VAR to SUBVAR, so that\n      they are is_global_var iff the original variable was.  */\n   DECL_CONTEXT (subvar) = DECL_CONTEXT (var);\n-  DECL_EXTERNAL (subvar) = DECL_EXTERNAL (var);\n+  MTAG_GLOBAL (subvar) = DECL_EXTERNAL (var);\n   TREE_PUBLIC  (subvar) = TREE_PUBLIC (var);\n   TREE_STATIC (subvar) = TREE_STATIC (var);\n   TREE_READONLY (subvar) = TREE_READONLY (var);\n \n   /* Add the new variable to REFERENCED_VARS.  */\n   ann = get_var_ann (subvar);\n-  ann->mem_tag_kind = STRUCT_FIELD; \n   ann->type_mem_tag = NULL;  \t\n   add_referenced_tmp_var (subvar);\n \n@@ -2812,7 +2835,7 @@ create_structure_vars (void)\n       if (var \t  \n \t  && DECL_SIZE (var)\n \t  && var_can_have_subvars (var)\n-\t  && var_ann (var)->mem_tag_kind == NOT_A_TAG\n+\t  && !MTAG_P (var)\n \t  && TREE_CODE (DECL_SIZE (var)) == INTEGER_CST)\n \tcreate_overlap_variables_for (var);\n     }"}, {"sha": "08200ff0c580505e9299a102f2288eecdecb880f", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -342,6 +342,7 @@ get_default_value (tree var)\n     }\n   else if (TREE_STATIC (sym)\n \t   && TREE_READONLY (sym)\n+\t   && !MTAG_P (sym)\n \t   && DECL_INITIAL (sym)\n \t   && ccp_decl_initial_min_invariant (DECL_INITIAL (sym)))\n     {"}, {"sha": "b9873314079fc87ae27295cc95d367bc90ed699d", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -1091,6 +1091,9 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       return;\n \n     case SSA_NAME:\n+    case STRUCT_FIELD_TAG:\n+    case TYPE_MEMORY_TAG:\n+    case NAME_MEMORY_TAG:\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n@@ -1679,8 +1682,8 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \t\t{\n \t\t  /* Only regular variables or struct fields may get a\n \t\t     V_MUST_DEF operand.  */\n-\t\t  gcc_assert (v_ann->mem_tag_kind == NOT_A_TAG \n-\t\t\t      || v_ann->mem_tag_kind == STRUCT_FIELD);\n+\t\t  gcc_assert (!MTAG_P (var)\n+\t\t\t      || TREE_CODE (var) == STRUCT_FIELD_TAG);\n \t\t  /* V_MUST_DEF for non-aliased, non-GIMPLE register \n \t\t    variable definitions.  */\n \t\t  append_v_must_def (var);"}, {"sha": "4c683f1b0f6416eace42506649b1dedb77b07c76", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -406,7 +406,7 @@ verify_flow_insensitive_alias_info (void)\n       var_ann_t ann;\n       ann = var_ann (var);\n \n-      if (ann->mem_tag_kind == NOT_A_TAG\n+      if (!MTAG_P (var)\n \t  && ann->is_alias_tag\n \t  && !bitmap_bit_p (visited, DECL_UID (var)))\n \t{"}, {"sha": "c5a25270829581975c42803547174eb1ee69baff", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -144,9 +144,8 @@ suitable_for_tail_opt_p (void)\n   FOR_EACH_REFERENCED_VAR (var, rvi)\n     {\n \n-      if (!(TREE_STATIC (var) || DECL_EXTERNAL (var))\n-\t  && (var_ann (var)->mem_tag_kind == NOT_A_TAG\n-\t      || var_ann (var)->mem_tag_kind == STRUCT_FIELD)\n+      if (!is_global_var (var)\n+\t  && (!MTAG_P (var) || TREE_CODE (var) == STRUCT_FIELD_TAG)\n \t  && is_call_clobbered (var))\n \treturn false;\n     }"}, {"sha": "0d56efb50f5be5a03868243cb7c5bd1713167d33", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -301,7 +301,7 @@ vect_create_data_ref_ptr (tree stmt,\n \n   /* If tag is a variable (and NOT_A_TAG) than a new type alias\n      tag must be created with tag added to its may alias list.  */\n-  if (var_ann (tag)->mem_tag_kind == NOT_A_TAG)\n+  if (!MTAG_P (tag))\n     new_type_alias (vect_ptr, tag);\n   else\n     var_ann (vect_ptr)->type_mem_tag = tag;"}, {"sha": "324e83301f5fc81adc359d541c7ea63e2eb98b58", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -230,6 +230,13 @@ init_ttree (void)\n   tree_contains_struct[TRANSLATION_UNIT_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[LABEL_DECL][TS_DECL_MINIMAL] = 1;\n   tree_contains_struct[FIELD_DECL][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[STRUCT_FIELD_TAG][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[NAME_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n+  tree_contains_struct[TYPE_MEMORY_TAG][TS_DECL_MINIMAL] = 1;\n+\n+  tree_contains_struct[STRUCT_FIELD_TAG][TS_MEMORY_TAG] = 1;\n+  tree_contains_struct[NAME_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n+  tree_contains_struct[TYPE_MEMORY_TAG][TS_MEMORY_TAG] = 1;\n \n   tree_contains_struct[VAR_DECL][TS_DECL_WITH_VIS] = 1;\n   tree_contains_struct[FUNCTION_DECL][TS_DECL_WITH_VIS] = 1;\n@@ -288,6 +295,10 @@ tree_code_size (enum tree_code code)\n \t    return sizeof (struct tree_type_decl);\n \t  case FUNCTION_DECL:\n \t    return sizeof (struct tree_function_decl);\n+\t  case NAME_MEMORY_TAG:\n+\t  case TYPE_MEMORY_TAG:\n+\t  case STRUCT_FIELD_TAG:\n+\t    return sizeof (struct tree_memory_tag);\n \t  default:\n \t    return sizeof (struct tree_decl_non_common);\n \t  }\n@@ -479,13 +490,16 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n       break;\n \n     case tcc_declaration:\n-      if (code != FUNCTION_DECL)\n-\tDECL_ALIGN (t) = 1;\n-      DECL_USER_ALIGN (t) = 0;\n       if (CODE_CONTAINS_STRUCT (code, TS_DECL_WITH_VIS))\n \tDECL_IN_SYSTEM_HEADER (t) = in_system_header;\n-      /* We have not yet computed the alias set for this declaration.  */\n-      DECL_POINTER_ALIAS_SET (t) = -1;\n+      if (CODE_CONTAINS_STRUCT (code, TS_DECL_COMMON))\n+\t{\n+\t  if (code != FUNCTION_DECL)\n+\t    DECL_ALIGN (t) = 1;\n+\t  DECL_USER_ALIGN (t) = 0;\t  \n+\t  /* We have not yet computed the alias set for this declaration.  */\n+\t  DECL_POINTER_ALIAS_SET (t) = -1;\n+\t}\n       DECL_SOURCE_LOCATION (t) = input_location;\n       DECL_UID (t) = next_decl_uid++;\n \n@@ -1979,6 +1993,10 @@ tree_node_structure (tree t)\n \t    return TS_TYPE_DECL;\n \t  case FUNCTION_DECL:\n \t    return TS_FUNCTION_DECL;\n+\t  case TYPE_MEMORY_TAG:\n+\t  case NAME_MEMORY_TAG:\n+\t  case STRUCT_FIELD_TAG:\n+\t    return TS_MEMORY_TAG;\n \t  default:\n \t    return TS_DECL_NON_COMMON;\n \t  }\n@@ -6630,7 +6648,10 @@ in_array_bounds_p (tree ref)\n bool\n is_global_var (tree t)\n {\n-  return (TREE_STATIC (t) || DECL_EXTERNAL (t));\n+  if (MTAG_P (t))\n+    return (TREE_STATIC (t) || MTAG_GLOBAL (t));\n+  else\n+    return (TREE_STATIC (t) || DECL_EXTERNAL (t));\n }\n \n /* Return true if T (assumed to be a DECL) must be assigned a memory"}, {"sha": "66692b4016867f2df137e9e2e3c7d909a8a91d4f", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -358,6 +358,12 @@ DEFTREECODE (PARM_DECL, \"parm_decl\", tcc_declaration, 0)\n DEFTREECODE (TYPE_DECL, \"type_decl\", tcc_declaration, 0)\n DEFTREECODE (RESULT_DECL, \"result_decl\", tcc_declaration, 0)\n \n+/* Memory tags used in tree-ssa to represent memory locations in\n+   virtual SSA.  */\n+DEFTREECODE (STRUCT_FIELD_TAG, \"struct_field_tag\", tcc_declaration, 0)\n+DEFTREECODE (NAME_MEMORY_TAG, \"name_memory_tag\", tcc_declaration, 0)\n+DEFTREECODE (TYPE_MEMORY_TAG, \"type_memory_tag\", tcc_declaration, 0)\n+\n /* A namespace declaration.  Namespaces appear in DECL_CONTEXT of other\n    _DECLs, providing a hierarchy of names.  */\n DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)"}, {"sha": "99c18f4e1a685f6b401cc2f901c6fc78e33d611d", "filename": "gcc/tree.h", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -100,6 +100,14 @@ extern const enum tree_code_class tree_code_type[];\n #define DECL_P(CODE)\\\n         (TREE_CODE_CLASS (TREE_CODE (CODE)) == tcc_declaration)\n \n+/* Nonzero if CODE represents a memory tag.  */\n+\n+#define MTAG_P(CODE) \\\n+  (TREE_CODE (CODE) == STRUCT_FIELD_TAG\t\t\\\n+   || TREE_CODE (CODE) == NAME_MEMORY_TAG\t\\\n+   || TREE_CODE (CODE) == TYPE_MEMORY_TAG)\n+        \n+\n /* Nonzero if DECL represents a VAR_DECL or FUNCTION_DECL.  */\n \n #define VAR_OR_FUNCTION_DECL_P(DECL)\\\n@@ -692,6 +700,7 @@ extern void tree_operand_check_failed (int, enum tree_code,\n \n #define TYPE_CHECK(T)\t\tTREE_CLASS_CHECK (T, tcc_type)\n #define DECL_MINIMAL_CHECK(T)   CONTAINS_STRUCT_CHECK (T, TS_DECL_MINIMAL)\n+#define TREE_MEMORY_TAG_CHECK(T)       CONTAINS_STRUCT_CHECK (T, TS_MEMORY_TAG)\n #define DECL_COMMON_CHECK(T)    CONTAINS_STRUCT_CHECK (T, TS_DECL_COMMON)\n #define DECL_WRTL_CHECK(T)      CONTAINS_STRUCT_CHECK (T, TS_DECL_WRTL)\n #define DECL_WITH_VIS_CHECK(T)  CONTAINS_STRUCT_CHECK (T, TS_DECL_WITH_VIS)\n@@ -1972,14 +1981,16 @@ struct tree_binfo GTY (())\n /* Define fields and accessors for nodes representing declared names.  */\n \n /* Nonzero if DECL represents a variable for the SSA passes.  */\n-#define SSA_VAR_P(DECL) \\\n-\t(TREE_CODE (DECL) == VAR_DECL\t\\\n-\t || TREE_CODE (DECL) == PARM_DECL \\\n-\t || TREE_CODE (DECL) == RESULT_DECL \\\n-\t || (TREE_CODE (DECL) == SSA_NAME \\\n-\t     && (TREE_CODE (SSA_NAME_VAR (DECL)) == VAR_DECL \\\n-\t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == PARM_DECL \\\n-\t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == RESULT_DECL)))\n+#define SSA_VAR_P(DECL)\t\t\t\t\t\t\t\\\n+\t(TREE_CODE (DECL) == VAR_DECL\t\t\t\t\t\\\n+\t || TREE_CODE (DECL) == PARM_DECL\t\t\t\t\\\n+\t || TREE_CODE (DECL) == RESULT_DECL\t\t\t\t\\\n+\t || MTAG_P (DECL)\t\t\t\t\t\t\\\n+\t || (TREE_CODE (DECL) == SSA_NAME\t\t\t\t\\\n+\t     && (TREE_CODE (SSA_NAME_VAR (DECL)) == VAR_DECL\t\t\\\n+\t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == PARM_DECL\t\\\n+\t\t || TREE_CODE (SSA_NAME_VAR (DECL)) == RESULT_DECL\t\\\n+\t\t || MTAG_P (SSA_NAME_VAR (DECL)))))\n \n \n \n@@ -2038,6 +2049,24 @@ struct tree_decl_minimal GTY(())\n   tree context;\n };\n \n+/* When computing aliasing information, we represent the memory pointed-to\n+   by pointers with artificial variables called \"memory tags\" (MT).  There\n+   are two kinds of tags: type and name.  Type tags (TMT) are used in\n+   type-based alias analysis, they represent all the pointed-to locations\n+   and variables of the same alias set class.  Name tags (NMT) are used in\n+   flow-sensitive points-to alias analysis, they represent the variables\n+   and memory locations pointed-to by a specific SSA_NAME pointer.  */\n+\n+struct tree_memory_tag GTY(())\n+{\n+  struct tree_decl_minimal common;\n+  tree parent_var;\n+  unsigned int is_global:1;\n+};\n+\n+#define MTAG_GLOBAL(NODE) (TREE_MEMORY_TAG_CHECK (NODE)->mtag.is_global)\n+#define SFT_PARENT_VAR(NODE) (STRUCT_FIELD_TAG_CHECK (NODE)->mtag.parent_var)\n+\n /* For any sort of a ..._DECL node, this points to the original (abstract)\n    decl node which this decl is an instance of, or else it is NULL indicating\n    that this decl is not an instance of some other decl.  For example,\n@@ -2834,6 +2863,7 @@ union tree_node GTY ((ptr_alias (union lang_tree_node),\n   struct tree_statement_list GTY ((tag (\"TS_STATEMENT_LIST\"))) stmt_list;\n   struct tree_value_handle GTY ((tag (\"TS_VALUE_HANDLE\"))) value_handle;\n   struct tree_constructor GTY ((tag (\"TS_CONSTRUCTOR\"))) constructor;\n+  struct tree_memory_tag GTY ((tag (\"TS_MEMORY_TAG\"))) mtag;\n };\n \f\n /* Standard named or nameless data types of the C compiler.  */"}, {"sha": "e8d016a1866f889077b856c82d567b3ec2d9ca66", "filename": "gcc/treestruct.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftreestruct.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/326eda4b252e23e9c9b2ee1f0ad484c2175e7534/gcc%2Ftreestruct.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreestruct.def?ref=326eda4b252e23e9c9b2ee1f0ad484c2175e7534", "patch": "@@ -59,3 +59,4 @@ DEFTREESTRUCT(TS_BINFO, \"binfo\")\n DEFTREESTRUCT(TS_STATEMENT_LIST, \"statement list\")\n DEFTREESTRUCT(TS_VALUE_HANDLE, \"value handle\")\n DEFTREESTRUCT(TS_CONSTRUCTOR, \"constructor\")\n+DEFTREESTRUCT(TS_MEMORY_TAG, \"memory tag\")"}]}