{"sha": "604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0YjJiZmNjNDNmYTA1ZDUwNjUxY2NhM2EzNmIyOWI4ZmIwOGIxOA==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2013-06-23T02:27:03Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2013-06-23T02:27:03Z"}, "message": "c-common.c (c_common_nodes_and_builtins): Use cxx11 in lieu of cxx0x.\n\n2013-06-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\t* c-common.c (c_common_nodes_and_builtins): Use cxx11 in lieu of cxx0x.\n\t* c-cppbuiltin.c (c_cpp_builtins): Likewise.\n\t* c-opts.c (c_common_post_options): Likewise.\n\ncp/\n2013-06-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n\n\t* call.c (null_ptr_cst_p): Use cxx11 in lieu of cxx0x.\n\t* class.c (add_implicitly_declared_members): Likewise.\n\t(check_field_decl): Likewise.\n\t(finalize_literal_type_property): Likewise.\n\t(check_bases_and_members): Likewise.\n\t* decl.c (poplevel): Likewise.\n\t(case_conversion): Likewise.\n\t(check_initializer): Likewise.\n\t(grokfndecl): Likewise.\n\t(check_static_variable_definition): Likewise.\n\t(compute_array_index_type): Likewise.\n\t(grokdeclarator): Likewise.\n\t(build_enumerator): Likewise.\n\t* friend.c (make_friend_class): Likewise.\n\t* lex.c (init_reswords): Likewise.\n\t* method.c (synthesized_method_walk): Likewise.\n\t(implicitly_declare_fn): Likewise.\n\t* parser.c (cp_parser_diagnose_invalid_type_name): Likewise.\n\t(cp_parser_constant_expression): Likewise.\n\t(cp_parser_for_init_statement): Likewise.\n\t(cp_parser_block_declaration): Likewise.\n\t(cp_parser_type_name): Likewise.\n\t(cp_parser_enum_specifier): Likewise.\n\t(cp_parser_enumerator_list): Likewise.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_nth_tokens_can_be_std_attribute_p): Likewise.\n\t(cp_parser_template_declaration_after_export): Likewise.\n\t* pt.c (convert_nontype_argument_function): Likewise.\n\t(convert_nontype_argument): Likewise.\n\t(convert_template_argument): Likewise.\n\t(tsubst_copy_and_build): Likewise.\n\t(build_non_dependent_expr): Likewise.\n\t* semantics.c (non_const_var_error): Likewise.\n\t(potential_constant_expression_1): Likewise.\n\t* tree.c (lvalue_kind): Likewise.\n\t(build_vec_init_expr): Likewise.\n\t(cast_valid_in_integral_constant_expression_p): Likewise.\n\t* typeck.c (build_x_conditional_expr): Likewise.\n\t* typeck2.c (check_narrowing): Likewise.\n\nFrom-SVN: r200348", "tree": {"sha": "49846e26413c30cb73bb0e857aa263127f5437a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49846e26413c30cb73bb0e857aa263127f5437a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "495e687951f8eb80fac14b6aba3e66dc5d641b50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/495e687951f8eb80fac14b6aba3e66dc5d641b50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/495e687951f8eb80fac14b6aba3e66dc5d641b50"}], "stats": {"total": 172, "additions": 110, "deletions": 62}, "files": [{"sha": "03269e906c3ef88b2d2166921b5f6bed79e1bd27", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -1,3 +1,9 @@\n+2013-06-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* c-common.c (c_common_nodes_and_builtins): Use cxx11 in lieu of cxx0x.\n+\t* c-cppbuiltin.c (c_cpp_builtins): Likewise.\n+\t* c-opts.c (c_common_post_options): Likewise.\n+\n 2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-common.h (struct cilkplus_an_parts): New structure.\n@@ -6,7 +12,7 @@\n \t(fix_sec_implicit_args): Likewise.\n \t* array-notation-common.c (cilkplus_extract_an_triplets): New function.\n \t(fix_sec_implicit_args): Likewise.\n-\t\n+\n 2013-06-20  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* array-notation-common.c (find_inv_trees): Removed an unwanted"}, {"sha": "8b780c20845363253bc10ef8966a56bcb6be58c1", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -5454,7 +5454,7 @@ c_common_nodes_and_builtins (void)\n     {\n       char16_type_node = make_unsigned_type (char16_type_size);\n \n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n \trecord_builtin_type (RID_CHAR16, \"char16_t\", char16_type_node);\n     }\n \n@@ -5470,7 +5470,7 @@ c_common_nodes_and_builtins (void)\n     {\n       char32_type_node = make_unsigned_type (char32_type_size);\n \n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n \trecord_builtin_type (RID_CHAR32, \"char32_t\", char32_type_node);\n     }\n "}, {"sha": "94078c0046053008c0bd4ed6b28dd59f6e98569f", "filename": "gcc/c-family/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -713,7 +713,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \tcpp_define (pfile, \"__DEPRECATED\");\n       if (flag_rtti)\n \tcpp_define (pfile, \"__GXX_RTTI\");\n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n         cpp_define (pfile, \"__GXX_EXPERIMENTAL_CXX0X__\");\n     }\n   /* Note that we define this for C as well, so that we know if"}, {"sha": "702fe1a8bdf50e086b03d5f6f2099a2822a166ed", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -889,7 +889,7 @@ c_common_post_options (const char **pfilename)\n   if (warn_implicit_function_declaration == -1)\n     warn_implicit_function_declaration = flag_isoc99;\n \n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     {\n       /* If we're allowing C++0x constructs, don't warn about C++98\n \t identifiers which are keywords in C++0x.  */"}, {"sha": "55ed6a5659fc424ada9652d4c9d0607ff829ee33", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -1,3 +1,45 @@\n+2013-06-22  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* call.c (null_ptr_cst_p): Use cxx11 in lieu of cxx0x.\n+\t* class.c (add_implicitly_declared_members): Likewise.\n+\t(check_field_decl): Likewise.\n+\t(finalize_literal_type_property): Likewise.\n+\t(check_bases_and_members): Likewise.\n+\t* decl.c (poplevel): Likewise.\n+\t(case_conversion): Likewise.\n+\t(check_initializer): Likewise.\n+\t(grokfndecl): Likewise.\n+\t(check_static_variable_definition): Likewise.\n+\t(compute_array_index_type): Likewise.\n+\t(grokdeclarator): Likewise.\n+\t(build_enumerator): Likewise.\n+\t* friend.c (make_friend_class): Likewise.\n+\t* lex.c (init_reswords): Likewise.\n+\t* method.c (synthesized_method_walk): Likewise.\n+\t(implicitly_declare_fn): Likewise.\n+\t* parser.c (cp_parser_diagnose_invalid_type_name): Likewise.\n+\t(cp_parser_constant_expression): Likewise.\n+\t(cp_parser_for_init_statement): Likewise.\n+\t(cp_parser_block_declaration): Likewise.\n+\t(cp_parser_type_name): Likewise.\n+\t(cp_parser_enum_specifier): Likewise.\n+\t(cp_parser_enumerator_list): Likewise.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_nth_tokens_can_be_std_attribute_p): Likewise.\n+\t(cp_parser_template_declaration_after_export): Likewise.\n+\t* pt.c (convert_nontype_argument_function): Likewise.\n+\t(convert_nontype_argument): Likewise.\n+\t(convert_template_argument): Likewise.\n+\t(tsubst_copy_and_build): Likewise.\n+\t(build_non_dependent_expr): Likewise.\n+\t* semantics.c (non_const_var_error): Likewise.\n+\t(potential_constant_expression_1): Likewise.\n+\t* tree.c (lvalue_kind): Likewise.\n+\t(build_vec_init_expr): Likewise.\n+\t(cast_valid_in_integral_constant_expression_p): Likewise.\n+\t* typeck.c (build_x_conditional_expr): Likewise.\n+\t* typeck2.c (check_narrowing): Likewise.\n+\n 2013-06-21  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* call.c (convert_like_real): Added a check if array notation is present"}, {"sha": "6817bfc25a03a33b8e5a796cb8b276143a344136", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -554,7 +554,7 @@ null_ptr_cst_p (tree t)\n   if (CP_INTEGRAL_TYPE_P (TREE_TYPE (t)))\n     {\n       /* Core issue 903 says only literal 0 is a null pointer constant.  */\n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n \tt = maybe_constant_value (fold_non_dependent_expr_sfinae (t, tf_none));\n       STRIP_NOPS (t);\n       if (integer_zerop (t) && !TREE_OVERFLOW (t))"}, {"sha": "0067605969a92030f7d7d0f1c4bc91b29773f0e4", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -2971,7 +2971,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n {\n   bool move_ok = false;\n \n-  if (cxx_dialect >= cxx0x && !CLASSTYPE_DESTRUCTORS (t)\n+  if (cxx_dialect >= cxx11 && !CLASSTYPE_DESTRUCTORS (t)\n       && !TYPE_HAS_COPY_CTOR (t) && !TYPE_HAS_COPY_ASSIGN (t)\n       && !type_has_move_constructor (t) && !type_has_move_assign (t))\n     move_ok = true;\n@@ -2998,7 +2998,7 @@ add_implicitly_declared_members (tree t, tree* access_decls,\n     {\n       TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 1;\n       CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n \tTYPE_HAS_CONSTEXPR_CTOR (t)\n \t  /* This might force the declaration.  */\n \t  = type_has_constexpr_default_constructor (t);\n@@ -3199,7 +3199,7 @@ check_field_decl (tree field,\n \n   /* In C++98 an anonymous union cannot contain any fields which would change\n      the settings of CANT_HAVE_CONST_CTOR and friends.  */\n-  if (ANON_UNION_TYPE_P (type) && cxx_dialect < cxx0x)\n+  if (ANON_UNION_TYPE_P (type) && cxx_dialect < cxx11)\n     ;\n   /* And, we don't set TYPE_HAS_CONST_COPY_CTOR, etc., for anonymous\n      structs.  So, we recurse through their fields here.  */\n@@ -3220,7 +3220,7 @@ check_field_decl (tree field,\n \t make it through without complaint.  */\n       abstract_virtuals_error (field, type);\n \n-      if (TREE_CODE (t) == UNION_TYPE && cxx_dialect < cxx0x)\n+      if (TREE_CODE (t) == UNION_TYPE && cxx_dialect < cxx11)\n \t{\n \t  static bool warned;\n \t  int oldcount = errorcount;\n@@ -5181,7 +5181,7 @@ finalize_literal_type_property (tree t)\n {\n   tree fn;\n \n-  if (cxx_dialect < cxx0x\n+  if (cxx_dialect < cxx11\n       || TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t))\n     CLASSTYPE_LITERAL_P (t) = false;\n   else if (CLASSTYPE_LITERAL_P (t) && !TYPE_HAS_TRIVIAL_DFLT (t)\n@@ -5321,7 +5321,7 @@ check_bases_and_members (tree t)\n \n   /* Deduce noexcept on destructors.  This needs to happen after we've set\n      triviality flags appropriately for our bases.  */\n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     deduce_noexcept_on_destructors (t);\n \n   /* Check all the method declarations.  */"}, {"sha": "f562546db0c8df2805303da248f68aba07321532", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -652,7 +652,7 @@ poplevel (int keep, int reverse, int functionbody)\n       if (leaving_for_scope && VAR_P (link)\n \t  /* It's hard to make this ARM compatibility hack play nicely with\n \t     lambdas, and it really isn't necessary in C++11 mode.  */\n-\t  && cxx_dialect < cxx0x\n+\t  && cxx_dialect < cxx11\n \t  && DECL_NAME (link))\n \t{\n \t  tree name = DECL_NAME (link);\n@@ -3090,7 +3090,7 @@ case_conversion (tree type, tree value)\n   if (value == NULL_TREE)\n     return value;\n \n-  if (cxx_dialect >= cxx0x\n+  if (cxx_dialect >= cxx11\n       && (SCOPED_ENUM_P (type)\n \t  || !INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (value))))\n     {\n@@ -5757,7 +5757,7 @@ check_initializer (tree decl, tree init, int flags, vec<tree, va_gc> **cleanups)\n     {\n       static int explained = 0;\n \n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n \terror (\"initializer invalid for static member with constructor\");\n       else\n \terror (\"non-constant in-class initialization invalid for static \"\n@@ -7653,7 +7653,7 @@ grokfndecl (tree ctype,\n     grokclassfn (ctype, decl, flags);\n \n   /* 12.4/3  */\n-  if (cxx_dialect >= cxx0x\n+  if (cxx_dialect >= cxx11\n       && DECL_DESTRUCTOR_P (decl)\n       && !TYPE_BEING_DEFINED (DECL_CONTEXT (decl))\n       && !processing_template_decl)\n@@ -8053,7 +8053,7 @@ check_static_variable_definition (tree decl, tree type)\n      in check_initializer.  */\n   if (DECL_P (decl) && DECL_DECLARED_CONSTEXPR_P (decl))\n     return 0;\n-  else if (cxx_dialect >= cxx0x && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n+  else if (cxx_dialect >= cxx11 && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n     {\n       if (!COMPLETE_TYPE_P (type))\n \terror (\"in-class initialization of static data member %q#D of \"\n@@ -8175,7 +8175,7 @@ compute_array_index_type (tree name, tree size, tsubst_flags_t complain)\n \n       mark_rvalue_use (size);\n \n-      if (cxx_dialect < cxx0x && TREE_CODE (size) == NOP_EXPR\n+      if (cxx_dialect < cxx11 && TREE_CODE (size) == NOP_EXPR\n \t  && TREE_SIDE_EFFECTS (size))\n \t/* In C++98, we mark a non-constant array bound with a magic\n \t   NOP_EXPR with TREE_SIDE_EFFECTS; don't fold in that case.  */;\n@@ -9534,7 +9534,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t  }\n \t\telse if (declarator->u.function.late_return_type)\n \t\t  {\n-\t\t    if (cxx_dialect < cxx0x)\n+\t\t    if (cxx_dialect < cxx11)\n \t\t      /* Not using maybe_warn_cpp0x because this should\n \t\t\t always be an error.  */\n \t\t      error (\"trailing return type only available with \"\n@@ -12842,7 +12842,7 @@ build_enumerator (tree name, tree value, tree enumtype, location_t loc)\n \t\t\t\t  && double_int_fits_to_tree_p (type, di))\n \t\t\t\tbreak;\n \t\t\t    }\n-\t\t\t  if (type && cxx_dialect < cxx0x\n+\t\t\t  if (type && cxx_dialect < cxx11\n \t\t\t      && itk > itk_unsigned_long)\n \t\t\t    pedwarn (input_location, OPT_Wlong_long, pos ? \"\\\n incremented enumerator value is too large for %<unsigned long%>\" :  \"\\"}, {"sha": "3e018e8e84c138a044ffd9831efc6ec6eec292d4", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -230,8 +230,8 @@ make_friend_class (tree type, tree friend_type, bool complain)\n \t (possibly cv-qualified) class type, that class is declared as a\n \t friend; otherwise, the friend declaration is ignored.\n \n-         So don't complain in C++0x mode.  */\n-      if (cxx_dialect < cxx0x)\n+         So don't complain in C++11 mode.  */\n+      if (cxx_dialect < cxx11)\n \tpedwarn (input_location, complain ? 0 : OPT_Wpedantic,\n \t\t \"invalid type %qT declared %<friend%>\", friend_type);\n       return;"}, {"sha": "d6ed809d61d04d03d644e4cecf791085b22ad11b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -171,7 +171,7 @@ init_reswords (void)\n   tree id;\n   int mask = 0;\n \n-  if (cxx_dialect < cxx0x)\n+  if (cxx_dialect < cxx11)\n     mask |= D_CXX0X;\n   if (flag_no_asm)\n     mask |= D_ASM | D_EXT;"}, {"sha": "4ac533eacf7237fae7b912884d579fc6c65219d6", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -1179,7 +1179,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n   bool ctor_p;\n \n   if (spec_p)\n-    *spec_p = (cxx_dialect >= cxx0x ? noexcept_true_spec : empty_except_spec);\n+    *spec_p = (cxx_dialect >= cxx11 ? noexcept_true_spec : empty_except_spec);\n \n   if (deleted_p)\n     {\n@@ -1271,7 +1271,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n      resolution, so a constructor can be trivial even if it would otherwise\n      call a non-trivial constructor.  */\n   if (expected_trivial\n-      && (!copy_arg_p || cxx_dialect < cxx0x))\n+      && (!copy_arg_p || cxx_dialect < cxx11))\n     {\n       if (constexpr_p && sfk == sfk_constructor)\n \t{\n@@ -1632,7 +1632,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   if (deleted_p)\n     constexpr_p = false;\n   /* A trivial copy/move constructor is also a constexpr constructor.  */\n-  else if (trivial_p && cxx_dialect >= cxx0x\n+  else if (trivial_p && cxx_dialect >= cxx11\n \t   && (kind == sfk_copy_constructor\n \t       || kind == sfk_move_constructor))\n     gcc_assert (constexpr_p);\n@@ -1713,7 +1713,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n   DECL_IN_AGGR_P (fn) = 1;\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_DEFAULTED_FN (fn) = 1;\n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     {\n       DECL_DELETED_FN (fn) = deleted_p;\n       DECL_DECLARED_CONSTEXPR_P (fn) = constexpr_p;"}, {"sha": "f3bc27a698a60ca69e597c4bcaec966b25ce93c4", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -2829,7 +2829,7 @@ cp_parser_diagnose_invalid_type_name (cp_parser *parser,\n \t   template <typename T> struct B : public A<T> { X x; };\n \n \t The user should have said \"typename A<T>::X\".  */\n-      if (cxx_dialect < cxx0x && id == ridpointers[(int)RID_CONSTEXPR])\n+      if (cxx_dialect < cxx11 && id == ridpointers[(int)RID_CONSTEXPR])\n \tinform (location, \"C++11 %<constexpr%> only available with \"\n \t\t\"-std=c++11 or -std=gnu++11\");\n       else if (processing_template_decl && current_class_type\n@@ -8259,7 +8259,7 @@ cp_parser_constant_expression (cp_parser* parser,\n   /* We are now parsing a constant-expression.  */\n   parser->integral_constant_expression_p = true;\n   parser->allow_non_integral_constant_expression_p\n-    = (allow_non_constant_p || cxx_dialect >= cxx0x);\n+    = (allow_non_constant_p || cxx_dialect >= cxx11);\n   parser->non_integral_constant_expression_p = false;\n   /* Although the grammar says \"conditional-expression\", we parse an\n      \"assignment-expression\", which also permits \"throw-expression\"\n@@ -8276,7 +8276,7 @@ cp_parser_constant_expression (cp_parser* parser,\n     = saved_integral_constant_expression_p;\n   parser->allow_non_integral_constant_expression_p\n     = saved_allow_non_integral_constant_expression_p;\n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     {\n       /* Require an rvalue constant expression here; that's what our\n \t callers expect.  Reference constant expressions are handled\n@@ -10428,7 +10428,7 @@ cp_parser_for_init_statement (cp_parser* parser, tree *decl)\n \t  /* It is a range-for, consume the ':' */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  is_range_for = true;\n-\t  if (cxx_dialect < cxx0x)\n+\t  if (cxx_dialect < cxx11)\n \t    {\n \t      error_at (cp_lexer_peek_token (parser->lexer)->location,\n \t\t\t\"range-based %<for%> loops are not allowed \"\n@@ -10916,7 +10916,7 @@ cp_parser_block_declaration (cp_parser *parser,\n \tcp_parser_using_directive (parser);\n       /* If the second token after 'using' is '=', then we have an\n \t alias-declaration.  */\n-      else if (cxx_dialect >= cxx0x\n+      else if (cxx_dialect >= cxx11\n \t       && token2->type == CPP_NAME\n \t       && ((cp_lexer_peek_nth_token (parser->lexer, 3)->type == CPP_EQ)\n \t\t   || (cp_nth_tokens_can_be_attribute_p (parser, 3))))\n@@ -14533,7 +14533,7 @@ cp_parser_type_name (cp_parser* parser)\n   /* If it's not a class-name, keep looking.  */\n   if (!cp_parser_parse_definitely (parser))\n     {\n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n \t/* It must be a typedef-name or an enum-name.  */\n \treturn cp_parser_nonclass_name (parser);\n \n@@ -15069,7 +15069,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_CLASS)\n       || cp_lexer_next_token_is_keyword (parser->lexer, RID_STRUCT))\n     {\n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);\n \n       /* Consume the `struct' or `class' token.  */\n@@ -15163,7 +15163,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n       if (!cp_parser_parse_definitely (parser))\n \treturn NULL_TREE;\n \n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n         maybe_warn_cpp0x (CPP0X_SCOPED_ENUMS);\n \n       has_underlying_type = true;\n@@ -15181,7 +15181,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n   /* Look for the `{' but don't consume it yet.  */\n   if (!cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n     {\n-      if (cxx_dialect < cxx0x || (!scoped_enum_p && !underlying_type))\n+      if (cxx_dialect < cxx11 || (!scoped_enum_p && !underlying_type))\n \t{\n \t  cp_parser_error (parser, \"expected %<{%>\");\n \t  if (has_underlying_type)\n@@ -15381,7 +15381,7 @@ cp_parser_enumerator_list (cp_parser* parser, tree type)\n       /* If the next token is a `}', there is a trailing comma.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n \t{\n-\t  if (cxx_dialect < cxx0x && !in_system_header)\n+\t  if (cxx_dialect < cxx11 && !in_system_header)\n \t    pedwarn (input_location, OPT_Wpedantic,\n                      \"comma at end of enumerator list\");\n \t  break;\n@@ -19730,7 +19730,7 @@ cp_parser_member_declaration (cp_parser* parser)\n   /* Check for a using-declaration.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     {\n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n \t{\n \t  /* Parse the using-declaration.  */\n \t  cp_parser_using_declaration (parser,\n@@ -19834,7 +19834,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t    {\n \t      /* If the `friend' keyword was present, the friend must\n \t\t be introduced with a class-key.  */\n-\t       if (!declares_class_or_enum && cxx_dialect < cxx0x)\n+\t       if (!declares_class_or_enum && cxx_dialect < cxx11)\n \t\t pedwarn (decl_spec_token_start->location, OPT_Wpedantic,\n \t\t\t  \"in C++03 a class-key must be used \"\n \t\t\t  \"when declaring a friend\");\n@@ -20034,7 +20034,7 @@ cp_parser_member_declaration (cp_parser* parser)\n \t\t    initializer = cp_parser_pure_specifier (parser);\n \t\t  else if (decl_specifiers.storage_class != sc_static)\n \t\t    initializer = cp_parser_save_nsdmi (parser);\n-\t\t  else if (cxx_dialect >= cxx0x)\n+\t\t  else if (cxx_dialect >= cxx11)\n \t\t    {\n \t\t      bool nonconst;\n \t\t      /* Don't require a constant rvalue in C++11, since we\n@@ -20573,7 +20573,7 @@ cp_parser_exception_specification_opt (cp_parser* parser)\n \n #if 0\n   /* Enable this once a lot of code has transitioned to noexcept?  */\n-  if (cxx_dialect >= cxx0x && !in_system_header)\n+  if (cxx_dialect >= cxx11 && !in_system_header)\n     warning (OPT_Wdeprecated, \"dynamic exception specifications are \"\n \t     \"deprecated in C++0x; use %<noexcept%> instead\");\n #endif\n@@ -21041,7 +21041,7 @@ cp_nth_tokens_can_be_std_attribute_p (cp_parser *parser, size_t n)\n {\n   cp_token *token = cp_lexer_peek_nth_token (parser->lexer, n);\n \n-  return (cxx_dialect >= cxx0x\n+  return (cxx_dialect >= cxx11\n \t  && ((token->type == CPP_KEYWORD && token->keyword == RID_ALIGNAS)\n \t      || (token->type == CPP_OPEN_SQUARE\n \t\t  && (token = cp_lexer_peek_nth_token (parser->lexer, n + 1))\n@@ -22457,7 +22457,7 @@ cp_parser_template_declaration_after_export (cp_parser* parser, bool member_p)\n   if (cp_lexer_next_token_is_keyword (parser->lexer,\n \t\t\t\t      RID_TEMPLATE))\n     cp_parser_template_declaration_after_export (parser, member_p);\n-  else if (cxx_dialect >= cxx0x\n+  else if (cxx_dialect >= cxx11\n \t   && cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n     decl = cp_parser_alias_declaration (parser);\n   else"}, {"sha": "667e37f2ec9b169d6ea10db75c81bf135d352416", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -5151,9 +5151,9 @@ convert_nontype_argument_function (tree type, tree expr)\n     }\n \n   linkage = decl_linkage (fn_no_ptr);\n-  if (cxx_dialect >= cxx0x ? linkage == lk_none : linkage != lk_external)\n+  if (cxx_dialect >= cxx11 ? linkage == lk_none : linkage != lk_external)\n     {\n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n \terror (\"%qE is not a valid template argument for type %qT \"\n \t       \"because %qD has no linkage\",\n \t       expr, type, fn_no_ptr);\n@@ -5178,7 +5178,7 @@ check_valid_ptrmem_cst_expr (tree type, tree expr,\n   STRIP_NOPS (expr);\n   if (expr && (null_ptr_cst_p (expr) || TREE_CODE (expr) == PTRMEM_CST))\n     return true;\n-  if (cxx_dialect >= cxx0x && null_member_pointer_value_p (expr))\n+  if (cxx_dialect >= cxx11 && null_member_pointer_value_p (expr))\n     return true;\n   if (complain & tf_error)\n     {\n@@ -5510,7 +5510,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n      arbitrary constant expressions.  Pointer and pointer to\n      member arguments can be general constant expressions that evaluate\n      to a null value, but otherwise still need to be of a specific form.  */\n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     {\n       if (TREE_CODE (expr) == PTRMEM_CST)\n \t/* A PTRMEM_CST is already constant, and a valid template\n@@ -5644,7 +5644,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n       if (DECL_P (expr) && DECL_TEMPLATE_PARM_P (expr))\n \t/* Non-type template parameters are OK.  */\n \t;\n-      else if (cxx_dialect >= cxx0x && integer_zerop (expr))\n+      else if (cxx_dialect >= cxx11 && integer_zerop (expr))\n \t/* Null pointer values are OK in C++11.  */;\n       else if (TREE_CODE (expr) != ADDR_EXPR\n \t       && TREE_CODE (expr_type) != ARRAY_TYPE)\n@@ -5681,14 +5681,14 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t\t     expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n-\t  else if (cxx_dialect < cxx0x && !DECL_EXTERNAL_LINKAGE_P (decl))\n+\t  else if (cxx_dialect < cxx11 && !DECL_EXTERNAL_LINKAGE_P (decl))\n \t    {\n \t      error (\"%qE is not a valid template argument of type %qT \"\n \t\t     \"because %qD does not have external linkage\",\n \t\t     expr, type, decl);\n \t      return NULL_TREE;\n \t    }\n-\t  else if (cxx_dialect >= cxx0x && decl_linkage (decl) == lk_none)\n+\t  else if (cxx_dialect >= cxx11 && decl_linkage (decl) == lk_none)\n \t    {\n \t      error (\"%qE is not a valid template argument of type %qT \"\n \t\t     \"because %qD has no linkage\",\n@@ -5787,7 +5787,7 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n \t    return error_mark_node;\n \t}\n \n-      if (cxx_dialect >= cxx0x && integer_zerop (expr))\n+      if (cxx_dialect >= cxx11 && integer_zerop (expr))\n \t/* Null pointer values are OK in C++11.  */\n \treturn perform_qualification_conversions (type, expr);\n \n@@ -6216,7 +6216,7 @@ convert_template_argument (tree parm,\n       tree t = maybe_get_template_decl_from_type_decl (TYPE_NAME (arg));\n       if (TREE_CODE (t) == TEMPLATE_DECL)\n \t{\n-\t  if (cxx_dialect >= cxx0x)\n+\t  if (cxx_dialect >= cxx11)\n \t    /* OK under DR 1004.  */;\n \t  else if (complain & tf_warning_or_error)\n \t    pedwarn (input_location, OPT_Wpedantic, \"injected-class-name %qD\"\n@@ -13518,7 +13518,7 @@ tsubst_copy_and_build (tree t,\n \tdecl = finish_id_expression (t, decl, NULL_TREE,\n \t\t\t\t     &idk,\n \t\t\t\t     integral_constant_expression_p,\n-          /*allow_non_integral_constant_expression_p=*/(cxx_dialect >= cxx0x),\n+          /*allow_non_integral_constant_expression_p=*/(cxx_dialect >= cxx11),\n \t\t\t\t     &non_integral_constant_expression_p,\n \t\t\t\t     /*template_p=*/false,\n \t\t\t\t     /*done=*/true,\n@@ -19834,7 +19834,7 @@ value_dependent_expression_p (tree expression)\n \t    /* If there are no operands, it must be an expression such\n \t       as \"int()\". This should not happen for aggregate types\n \t       because it would form non-constant expressions.  */\n-\t    gcc_assert (cxx_dialect >= cxx0x\n+\t    gcc_assert (cxx_dialect >= cxx11\n \t\t\t|| INTEGRAL_OR_ENUMERATION_TYPE_P (type));\n \n \t    return false;\n@@ -20701,7 +20701,7 @@ build_non_dependent_expr (tree expr)\n #ifdef ENABLE_CHECKING\n   /* Try to get a constant value for all non-dependent expressions in\n       order to expose bugs in *_dependent_expression_p and constexpr.  */\n-  if (cxx_dialect >= cxx0x)\n+  if (cxx_dialect >= cxx11)\n     maybe_constant_value (fold_non_dependent_expr_sfinae (expr, tf_none));\n #endif\n "}, {"sha": "0a460a42544c47e78b3c202b5ed80175c3b28d14", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -7790,7 +7790,7 @@ non_const_var_error (tree r)\n     }\n   else\n     {\n-      if (cxx_dialect >= cxx0x && !DECL_DECLARED_CONSTEXPR_P (r))\n+      if (cxx_dialect >= cxx11 && !DECL_DECLARED_CONSTEXPR_P (r))\n \tinform (DECL_SOURCE_LOCATION (r),\n \t\t\"%qD was not declared %<constexpr%>\", r);\n       else\n@@ -8741,7 +8741,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case STATIC_CAST_EXPR:\n     case REINTERPRET_CAST_EXPR:\n     case IMPLICIT_CONV_EXPR:\n-      if (cxx_dialect < cxx0x\n+      if (cxx_dialect < cxx11\n \t  && !dependent_type_p (TREE_TYPE (t))\n \t  && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (t)))\n \t/* In C++98, a conversion to non-integral type can't be part of a"}, {"sha": "f8b4bbce822144cb3399078346d3096178171332", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -211,7 +211,7 @@ lvalue_kind (const_tree ref)\n       /* We just return clk_ordinary for NON_DEPENDENT_EXPR in C++98, but\n \t in C++11 lvalues don't bind to rvalue references, so we need to\n \t work harder to avoid bogus errors (c++/44870).  */\n-      if (cxx_dialect < cxx0x)\n+      if (cxx_dialect < cxx11)\n \treturn clk_ordinary;\n       else\n \treturn lvalue_kind (TREE_OPERAND (ref, 0));\n@@ -566,7 +566,7 @@ build_vec_init_expr (tree type, tree init, tsubst_flags_t complain)\n   TREE_SIDE_EFFECTS (init) = true;\n   SET_EXPR_LOCATION (init, input_location);\n \n-  if (cxx_dialect >= cxx0x\n+  if (cxx_dialect >= cxx11\n       && potential_constant_expression (elt_init))\n     VEC_INIT_EXPR_IS_CONSTEXPR (init) = true;\n   VEC_INIT_EXPR_VALUE_INIT (init) = value_init;\n@@ -3956,7 +3956,7 @@ bool\n cast_valid_in_integral_constant_expression_p (tree type)\n {\n   return (INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n-\t  || cxx_dialect >= cxx0x\n+\t  || cxx_dialect >= cxx11\n \t  || dependent_type_p (type)\n \t  || type == error_mark_node);\n }"}, {"sha": "5b321ce5a7f9df7001d4e29608d9e41f22b828cd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -5945,7 +5945,7 @@ build_x_conditional_expr (location_t loc, tree ifexp, tree op1, tree op2,\n \t\t\t\t    orig_ifexp, orig_op1, orig_op2);\n       /* In C++11, remember that the result is an lvalue or xvalue.\n          In C++98, lvalue_kind can just assume lvalue in a template.  */\n-      if (cxx_dialect >= cxx0x\n+      if (cxx_dialect >= cxx11\n \t  && lvalue_or_rvalue_with_address_p (expr)\n \t  && !lvalue_or_rvalue_with_address_p (min))\n \tTREE_TYPE (min) = cp_build_reference_type (TREE_TYPE (min),"}, {"sha": "a44789362e33f5d6dcdc119b302b1f17aadc9c04", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/604b2bfcc43fa05d50651cca3a36b29b8fb08b18/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=604b2bfcc43fa05d50651cca3a36b29b8fb08b18", "patch": "@@ -890,7 +890,7 @@ check_narrowing (tree type, tree init)\n \n   if (!ok)\n     {\n-      if (cxx_dialect >= cxx0x)\n+      if (cxx_dialect >= cxx11)\n \tpedwarn (EXPR_LOC_OR_HERE (init), OPT_Wnarrowing,\n \t\t \"narrowing conversion of %qE from %qT to %qT inside { }\",\n \t\t init, ftype, type);"}]}