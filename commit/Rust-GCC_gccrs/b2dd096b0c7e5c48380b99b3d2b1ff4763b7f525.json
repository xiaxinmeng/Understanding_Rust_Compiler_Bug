{"sha": "b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJkZDA5NmIwYzdlNWM0ODM4MGI5OWIzZDJiMWZmNDc2M2I3ZjUyNQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-04-22T05:44:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-04-22T05:44:12Z"}, "message": "Makefile.in (calls.o): Depend on except.h.\n\n\t* Makefile.in (calls.o): Depend on except.h.\n\t* calls.c: Include except.h.\n\t(emit_call_1): Call note_eh_region_may_contain_throw if\n\tappropriate.\n\t* except.c (eh_region): Add may_contain_throw.\n\t(expand_eh_region_end_cleanup): Do not include handler code when\n\tit cannot be reached.\n\t(note_eh_region_may_contain_throw): New function.\n\t* except.h (note_eh_region_may_contain_throw): New function.\n\n\t* call.c (build_over_call): Use build_cxx_call.\n\t(build_cxx_call): New method, split out of build_over_call.\n\t* cp-tree.h (language_function): Add can_throw.\n\t(build_cxx_call): Declare it.\n\t* decl.c (finish_function): If a function does not contain any\n\tcalls to functions that can throw an exception, indicate that\n\tfact.\n\t* decl2.c (mark_used): Do not defer the instantiation of\n\tfunctions, if the current function does not throw.\n\t* optimize.c (maybe_clone_body): Copy TREE_NOTHROW to the clones.\n\t* pt.c (instantiate_decl): Make sure import_export_decl is called\n\tbefore emitting things.\n\t* rtti.c (throw_bad_cast): Use build_cxx_call.\n\t(build_dynamic_cast_1): Likewise.\n\t* typeck.c (build_function_call): Likewise.\n\n\t* g++.dg/template/recurse.C: Adjust location of error messages.\n\nFrom-SVN: r65929", "tree": {"sha": "0b42d76e5fdf7dbe6a765ae20af65b5a2ed24e6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b42d76e5fdf7dbe6a765ae20af65b5a2ed24e6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/comments", "author": null, "committer": null, "parents": [{"sha": "f71c12554b607c5980b932a4dff5cba4c7decb89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f71c12554b607c5980b932a4dff5cba4c7decb89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f71c12554b607c5980b932a4dff5cba4c7decb89"}], "stats": {"total": 212, "additions": 162, "deletions": 50}, "files": [{"sha": "d6ffa22f2f685715c3f801e40b78418e5283fcaf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -1,3 +1,15 @@\n+2003-04-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* Makefile.in (calls.o): Depend on except.h.\n+\t* calls.c: Include except.h.\n+\t(emit_call_1): Call note_eh_region_may_contain_throw if\n+\tappropriate.\n+\t* except.c (eh_region): Add may_contain_throw.\n+\t(expand_eh_region_end_cleanup): Do not include handler code when\n+\tit cannot be reached.\n+\t(note_eh_region_may_contain_throw): New function.\n+\t* except.h (note_eh_region_may_contain_throw): New function.\n+\n 2003-04-21  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/i386/winnt.c (i386_pe_mark_dllimport): Revert previous"}, {"sha": "2858145d81c2339ef5fcaa5cb8d4d06e1c98fc4f", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -1532,7 +1532,7 @@ builtins.o : builtins.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(T\n    except.h $(TM_P_H) $(PREDICT_H) libfuncs.h real.h langhooks.h\n calls.o : calls.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    $(EXPR_H) langhooks.h $(TARGET_H) \\\n-   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h\n+   libfuncs.h $(REGS_H) toplev.h output.h function.h $(TIMEVAR_H) $(TM_P_H) cgraph.h except.h\n expmed.o : expmed.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(EXPR_H) $(OPTABS_H) $(RECOG_H) real.h \\\n    toplev.h $(TM_P_H) langhooks.h"}, {"sha": "bd889e1ae71537f4b07377202598ac21c506f70c", "filename": "gcc/calls.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"langhooks.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n+#include \"except.h\"\n \n /* Decide whether a function's arguments should be processed\n    from first to last or from last to first.\n@@ -588,6 +589,8 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n   if (ecf_flags & ECF_NOTHROW)\n     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, const0_rtx,\n \t\t\t\t\t       REG_NOTES (call_insn));\n+  else\n+    note_eh_region_may_contain_throw ();\n \n   if (ecf_flags & ECF_NORETURN)\n     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_NORETURN, const0_rtx,"}, {"sha": "28dde85070f3e8745042b1e57725e31f5b8ca1d4", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -1,3 +1,21 @@\n+2003-04-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (build_over_call): Use build_cxx_call.\n+\t(build_cxx_call): New method, split out of build_over_call.\n+\t* cp-tree.h (language_function): Add can_throw.\n+\t(build_cxx_call): Declare it.\n+\t* decl.c (finish_function): If a function does not contain any\n+\tcalls to functions that can throw an exception, indicate that\n+\tfact.\n+\t* decl2.c (mark_used): Do not defer the instantiation of\n+\tfunctions, if the current function does not throw.\n+\t* optimize.c (maybe_clone_body): Copy TREE_NOTHROW to the clones.\n+\t* pt.c (instantiate_decl): Make sure import_export_decl is called\n+\tbefore emitting things.\n+\t* rtti.c (throw_bad_cast): Use build_cxx_call.\n+\t(build_dynamic_cast_1): Likewise.\n+\t* typeck.c (build_function_call): Likewise.\n+\n 2003-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9881"}, {"sha": "f7253d500034ba262014c5814f54816ea6aa14d0", "filename": "gcc/cp/call.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -4707,10 +4707,22 @@ build_over_call (struct z_candidate *cand, int flags)\n   else\n     fn = build_addr_func (fn);\n \n+  return build_cxx_call (fn, args, converted_args);\n+}\n+\n+/* Build and return a call to FN, using the the CONVERTED_ARGS.  ARGS\n+   gives the original form of the arguments.  This function performs\n+   no overload resolution, conversion, or other high-level\n+   operations.  */\n+\n+tree\n+build_cxx_call(tree fn, tree args, tree converted_args)\n+{\n+  tree fndecl;\n+\n   /* Recognize certain built-in functions so we can make tree-codes\n      other than CALL_EXPR.  We do this when it enables fold-const.c\n      to do something useful.  */\n-\n   if (TREE_CODE (fn) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n       && DECL_BUILT_IN (TREE_OPERAND (fn, 0)))\n@@ -4721,14 +4733,24 @@ build_over_call (struct z_candidate *cand, int flags)\n \treturn exp;\n     }\n \n-  /* Some built-in function calls will be evaluated at\n-     compile-time in fold ().  */\n-  fn = fold (build_call (fn, converted_args));\n+  fn = build_call (fn, converted_args);\n+\n+  /* If this call might throw an exception, note that fact.  */\n+  fndecl = get_callee_fndecl (fn);\n+  if ((!fndecl || !TREE_NOTHROW (fndecl)) && at_function_scope_p ())\n+    cp_function_chain->can_throw = 1;\n+\n+  /* Some built-in function calls will be evaluated at compile-time in\n+     fold ().  */\n+  fn = fold (fn);\n+\n   if (VOID_TYPE_P (TREE_TYPE (fn)))\n     return fn;\n+\n   fn = require_complete_type (fn);\n   if (fn == error_mark_node)\n     return error_mark_node;\n+\n   if (IS_AGGR_TYPE (TREE_TYPE (fn)))\n     fn = build_cplus_new (TREE_TYPE (fn), fn);\n   return convert_from_reference (fn);"}, {"sha": "cbee534b4da882660d19b8e5a63cf71512e57672", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -794,6 +794,9 @@ struct language_function GTY(())\n   int in_base_initializer;\n   int x_expanding_p;\n \n+  /* True if this function can throw an exception.  */\n+  bool can_throw : 1;\n+\n   struct named_label_use_list *x_named_label_uses;\n   struct named_label_list *x_named_labels;\n   struct cp_binding_level *bindings;\n@@ -3522,6 +3525,7 @@ extern tree make_temporary_var_for_ref_to_temp (tree, tree);\n extern tree strip_top_quals (tree);\n extern tree perform_implicit_conversion (tree, tree);\n extern tree in_charge_arg_for_name (tree);\n+extern tree build_cxx_call (tree, tree, tree);\n \n /* in class.c */\n extern tree build_base_path\t\t\t(enum tree_code, tree, tree, int);"}, {"sha": "a14389f12565443f875894d4f8651a3566aae1d6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -13961,6 +13961,12 @@ finish_function (int flags)\n   /* If we're saving up tree structure, tie off the function now.  */\n   finish_stmt_tree (&DECL_SAVED_TREE (fndecl));\n \n+  /* If this function can't throw any exceptions, remember that.  */\n+  if (!processing_template_decl\n+      && !cp_function_chain->can_throw\n+      && !flag_non_call_exceptions)\n+    TREE_NOTHROW (fndecl) = 1;\n+\n   /* This must come after expand_function_end because cleanups might\n      have declarations (from inline functions) that need to go into\n      this function's blocks.  */"}, {"sha": "3f9c66fd4d4abaa8bd0531f669e5efdfd5037aef", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -4581,7 +4581,33 @@ mark_used (tree decl)\n       && DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl)\n       && (!DECL_EXPLICIT_INSTANTIATION (decl)\n \t  || (TREE_CODE (decl) == FUNCTION_DECL && DECL_INLINE (decl))))\n-    instantiate_decl (decl, /*defer_ok=*/1);\n+    {\n+      bool defer;\n+\n+      /* Normally, we put off instantiating functions in order to\n+\t improve compile times.  Maintaining a stack of active\n+\t functions is expensive, and the inliner knows to\n+\t instantiate any functions it might need.\n+\n+\t However, if instantiating this function might help us mark\n+\t the current function TREE_NOTHROW, we go ahead and\n+\t instantiate it now.  */\n+      defer = (!flag_exceptions\n+\t       || TREE_CODE (decl) != FUNCTION_DECL\n+\t       /* If the called function can't throw, we don't need to\n+\t\t  generate its body to find that out.  */\n+\t       || TREE_NOTHROW (decl)\n+\t       || !cfun\n+\t       /* If we already know the current function can't throw,\n+\t\t  then we don't need to work hard to prove it.  */\n+\t       || TREE_NOTHROW (current_function_decl)\n+\t       /* If we already know that the current function *can*\n+\t\t  throw, there's no point in gathering more\n+\t\t  information.  */\n+\t       || cp_function_chain->can_throw);\n+\n+      instantiate_decl (decl, defer);\n+    }\n }\n \n /* Called when a class-head is encountered.  TAG_KIND is the class-key"}, {"sha": "2c1c15d003eb727b6476b67f3770b130a0e13357", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -259,6 +259,9 @@ maybe_clone_body (tree fn)\n       /* Clean up.  */\n       splay_tree_delete (decl_map);\n \n+      /* The clone can throw iff the original function can throw.  */\n+      cp_function_chain->can_throw = !TREE_NOTHROW (fn);\n+\n       /* Now, expand this function into RTL, if appropriate.  */\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);"}, {"sha": "74f497e1cf699a443b201bbe15a6594719a5bfe8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -10948,13 +10948,8 @@ instantiate_decl (d, defer_ok)\n       SET_DECL_RTL (d, NULL_RTX);\n \n       DECL_IN_AGGR_P (d) = 0;\n-      if (DECL_INTERFACE_KNOWN (d))\n-\tDECL_EXTERNAL (d) = ! DECL_NOT_REALLY_EXTERN (d);\n-      else\n-\t{\n-\t  DECL_EXTERNAL (d) = 1;\n-\t  DECL_NOT_REALLY_EXTERN (d) = 1;\n-\t}\n+      import_export_decl (d);\n+      DECL_EXTERNAL (d) = ! DECL_NOT_REALLY_EXTERN (d);\n       cp_finish_decl (d, \n \t\t      (!DECL_INITIALIZED_IN_CLASS_P (d) \n \t\t       ? DECL_INITIAL (d) : NULL_TREE),\n@@ -11007,7 +11002,9 @@ instantiate_decl (d, defer_ok)\n       local_specializations = saved_local_specializations;\n \n       /* Finish the function.  */\n-      expand_body (finish_function (0));\n+      d = finish_function (0);\n+      import_export_decl (d);\n+      expand_body (d);\n     }\n \n   /* We're not deferring instantiation any more.  */"}, {"sha": "e02e69359b1d2fbf3128be7f83df024cf8634557", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -177,7 +177,7 @@ throw_bad_cast (void)\n     fn = push_throw_library_fn (fn, build_function_type (ptr_type_node,\n \t\t\t\t\t\t\t void_list_node));\n   \n-  return build_call (fn, NULL_TREE);\n+  return build_cxx_call (fn, NULL_TREE, NULL_TREE);\n }\n \n /* Return an expression for \"__cxa_bad_typeid()\".  The expression\n@@ -660,7 +660,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n               pop_nested_namespace (ns);\n               dynamic_cast_node = dcast_fn;\n \t    }\n-          result = build_call (dcast_fn, elems);\n+          result = build_cxx_call (dcast_fn, elems, elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {"}, {"sha": "3afb13c384d657207487e0083e26759e95701e29", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -2660,7 +2660,6 @@ build_function_call (function, params)\n      tree function, params;\n {\n   register tree fntype, fndecl;\n-  register tree value_type;\n   register tree coerced_params;\n   tree result;\n   tree name = NULL_TREE, assembler_name = NULL_TREE;\n@@ -2755,17 +2754,7 @@ build_function_call (function, params)\n \treturn result;\n     }\n \n-  /* Some built-in function calls will be evaluated at\n-     compile-time in fold ().  */\n-  result = fold (build_call (function, coerced_params));\n-  value_type = TREE_TYPE (result);\n-\n-  if (TREE_CODE (value_type) == VOID_TYPE)\n-    return result;\n-  result = require_complete_type (result);\n-  if (IS_AGGR_TYPE (value_type))\n-    result = build_cplus_new (value_type, result);\n-  return convert_from_reference (result);\n+  return build_cxx_call (function, params, coerced_params);\n }\n \f\n /* Convert the actual parameter expressions in the list VALUES"}, {"sha": "afc6a01f3dafe712a39e8a20de4a9ac83f0df9a4", "filename": "gcc/except.c", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -209,6 +209,9 @@ struct eh_region GTY(())\n   /* The RESX insn for handing off control to the next outermost handler,\n      if appropriate.  */\n   rtx resume;\n+\n+  /* True if something in this region may throw.  */\n+  unsigned may_contain_throw : 1;\n };\n \n struct call_site_record GTY(())\n@@ -561,33 +564,38 @@ expand_eh_region_end_cleanup (handler)\n \n   emit_label (region->label);\n \n-  /* Give the language a chance to specify an action to be taken if an\n-     exception is thrown that would propagate out of the HANDLER.  */\n-  protect_cleanup_actions\n-    = (lang_protect_cleanup_actions\n-       ? (*lang_protect_cleanup_actions) ()\n-       : NULL_TREE);\n+  if (flag_non_call_exceptions \n+      || flag_forced_unwind_exceptions\n+      || region->may_contain_throw)\n+    {\n+      /* Give the language a chance to specify an action to be taken if an\n+\t exception is thrown that would propagate out of the HANDLER.  */\n+      protect_cleanup_actions\n+\t= (lang_protect_cleanup_actions\n+\t   ? (*lang_protect_cleanup_actions) ()\n+\t   : NULL_TREE);\n \n-  if (protect_cleanup_actions)\n-    expand_eh_region_start ();\n+      if (protect_cleanup_actions)\n+\texpand_eh_region_start ();\n \n-  /* In case this cleanup involves an inline destructor with a try block in\n-     it, we need to save the EH return data registers around it.  */\n-  data_save[0] = gen_reg_rtx (ptr_mode);\n-  emit_move_insn (data_save[0], get_exception_pointer (cfun));\n-  data_save[1] = gen_reg_rtx (word_mode);\n-  emit_move_insn (data_save[1], get_exception_filter (cfun));\n+      /* In case this cleanup involves an inline destructor with a try block in\n+\t it, we need to save the EH return data registers around it.  */\n+      data_save[0] = gen_reg_rtx (ptr_mode);\n+      emit_move_insn (data_save[0], get_exception_pointer (cfun));\n+      data_save[1] = gen_reg_rtx (word_mode);\n+      emit_move_insn (data_save[1], get_exception_filter (cfun));\n \n-  expand_expr (handler, const0_rtx, VOIDmode, 0);\n+      expand_expr (handler, const0_rtx, VOIDmode, 0);\n \n-  emit_move_insn (cfun->eh->exc_ptr, data_save[0]);\n-  emit_move_insn (cfun->eh->filter, data_save[1]);\n+      emit_move_insn (cfun->eh->exc_ptr, data_save[0]);\n+      emit_move_insn (cfun->eh->filter, data_save[1]);\n \n-  if (protect_cleanup_actions)\n-    expand_eh_region_end_must_not_throw (protect_cleanup_actions);\n+      if (protect_cleanup_actions)\n+\texpand_eh_region_end_must_not_throw (protect_cleanup_actions);\n \n-  /* We need any stack adjustment complete before the around_label.  */\n-  do_pending_stack_adjust ();\n+      /* We need any stack adjustment complete before the around_label.  */\n+      do_pending_stack_adjust ();\n+    }\n \n   /* We delay the generation of the _Unwind_Resume until we generate\n      landing pads.  We emit a marker here so as to get good control\n@@ -823,6 +831,22 @@ expand_eh_region_end_fixup (handler)\n   fixup->u.fixup.cleanup_exp = handler;\n }\n \n+/* Note that the current EH region (if any) may contain a throw, or a\n+   call to a function which itself may contain a throw.  */\n+\n+void\n+note_eh_region_may_contain_throw ()\n+{\n+  struct eh_region *region;\n+\n+  region = cfun->eh->cur_region;\n+  while (region && !region->may_contain_throw)\n+    {\n+      region->may_contain_throw = 1;\n+      region = region->outer;\n+    }\n+}\n+\n /* Return an rtl expression for a pointer to the exception object\n    within a handler.  */\n "}, {"sha": "40d1676794396cc16818d3457cb709c2327b26ba", "filename": "gcc/except.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -78,6 +78,10 @@ extern void expand_eh_region_end_throw\t\tPARAMS ((tree));\n    destroying an object twice.  */\n extern void expand_eh_region_end_fixup\t\tPARAMS ((tree));\n \n+/* Note that the current EH region (if any) may contain a throw, or a\n+   call to a function which itself may contain a throw.  */\n+extern void note_eh_region_may_contain_throw    PARAMS ((void));\n+\n /* Invokes CALLBACK for every exception handler label.  Only used by old\n    loop hackery; should not be used by new code.  */\n extern void for_each_eh_label\t\t\tPARAMS ((void (*) (rtx)));"}, {"sha": "577a6090432b0e8df41f2525ba575e9d87e0f375", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -1,3 +1,7 @@\n+2003-04-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/template/recurse.C: Adjust location of error messages.\n+\n 2003-04-21  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9881"}, {"sha": "ce4c9268cfe0523787de01180362e8cbdded7e6d", "filename": "gcc/testsuite/g++.dg/template/recurse.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frecurse.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frecurse.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Frecurse.C?ref=b2dd096b0c7e5c48380b99b3d2b1ff4763b7f525", "patch": "@@ -6,7 +6,7 @@ template <int I> struct F\n   int operator()()\n     {\n       F<I+1> f;\t\t\t// { dg-error \"\" \"\" }\n-      return f()*I;\n+      return f()*I;             // { dg-error \"\" \"\" }\n     }\n };\n "}]}