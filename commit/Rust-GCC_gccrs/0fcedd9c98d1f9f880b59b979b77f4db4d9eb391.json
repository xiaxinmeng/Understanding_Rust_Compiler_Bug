{"sha": "0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjZWRkOWM5OGQxZjlmODgwYjU5Yjk3OWI3N2Y0ZGI0ZDllYjM5MQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-02-04T03:28:53Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-02-04T03:28:53Z"}, "message": "re PR c++/33916 (Default constructor fails to initialize array members)\n\n        PR c++/33916\n        * cp/init.c (build_value_init_1): New function.\n        (build_value_init): New function.\n        * cp/typeck2.c (build_functional_cast): Call it.\n        * cp/cp-gimplify.c (cp_gimplify_init_expr): Handle its output.\n\n        * cp/cp-tree.h (TYPE_HAS_USER_CONSTRUCTOR): Rename from\n        TYPE_HAS_CONSTRUCTOR.\n        * cp/class.c (finish_struct_bits, maybe_warn_about_overly_private_class,\n        add_implicitly_declared_members): Adjust.\n        (check_field_decls): Adjust. Remove warnings about reference/const\n        in class without constructor.\n        (check_bases_and_members): Adjust.  Give those warnings here instead.\n        * cp/decl.c (fixup_anonymous_aggr): Adjust.\n        (check_initializer): Adjust, clarify logic slightly.\n        (grok_special_member_properties): Adjust, only set if user-provided.\n        * cp/rtti.c (create_tinfo_types): Don't set.\n        * cp/cvt.c (ocp_convert): Remove exception for vtable_entry_type et al.\n        Use same_type_ignoring_top_level_qualifiers_p.\n        * cp/pt.c (check_explicit_specialization): Adjust.\n        (instantiate_class_template): Adjust.\n\n        * print-tree.c (print_node) [CONSTRUCTOR]: Print elements.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r132088", "tree": {"sha": "985387257ec096f981de1673a4abb0deacefe8d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/985387257ec096f981de1673a4abb0deacefe8d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a31cfd58cff0429868f5c11a761a0d013652ad94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a31cfd58cff0429868f5c11a761a0d013652ad94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a31cfd58cff0429868f5c11a761a0d013652ad94"}], "stats": {"total": 456, "additions": 383, "deletions": 73}, "files": [{"sha": "089f82f239dd0ea6765274a056c5ef87d266a2ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -1,3 +1,7 @@\n+2008-02-03  Jason Merrill  <jason@redhat.com>\n+\n+\t* print-tree.c (print_node) [CONSTRUCTOR]: Print elements.\n+\n 2008-02-04  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR other/29972"}, {"sha": "3504769f1bbdc9dfd9e7051d36e4c060cec5add5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -1,3 +1,28 @@\n+2008-02-02  Jason Merrill  <jason@redhat.com>\n+\t    Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/33916\n+\t* init.c (build_value_init_1): New function.\n+\t(build_value_init): New function.\n+\t* typeck2.c (build_functional_cast): Call it.\n+\t* cp-gimplify.c (cp_gimplify_init_expr): Handle its output.\n+\n+\t* cp-tree.h (TYPE_HAS_USER_CONSTRUCTOR): Rename from \n+\tTYPE_HAS_CONSTRUCTOR.\n+\t* class.c (finish_struct_bits, maybe_warn_about_overly_private_class,\n+\tadd_implicitly_declared_members): Adjust.\n+\t(check_field_decls): Adjust. Remove warnings about reference/const\n+\tin class without constructor.\n+\t(check_bases_and_members): Adjust.  Give those warnings here instead.\n+\t* decl.c (fixup_anonymous_aggr): Adjust.\n+\t(check_initializer): Adjust, clarify logic slightly.\n+\t(grok_special_member_properties): Adjust, only set if user-provided.\n+\t* rtti.c (create_tinfo_types): Don't set.\n+\t* cvt.c (ocp_convert): Remove exception for vtable_entry_type et al.\n+\tUse same_type_ignoring_top_level_qualifiers_p.\n+\t* pt.c (check_explicit_specialization): Adjust.\n+\t(instantiate_class_template): Adjust.\n+\n 2008-01-31  Douglas Gregor  <doug.gregor@gmail.com>\n            Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "a5456c23324c67a2d744e176ac99fc680d78cd7c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -955,7 +955,7 @@ add_method (tree type, tree method, tree using_decl)\n       CLASSTYPE_METHOD_VEC (type) = method_vec;\n     }\n \n-  /* Maintain TYPE_HAS_CONSTRUCTOR, etc.  */\n+  /* Maintain TYPE_HAS_USER_CONSTRUCTOR, etc.  */\n   grok_special_member_properties (method);\n \n   /* Constructors and destructors go in special slots.  */\n@@ -1451,7 +1451,7 @@ finish_struct_bits (tree t)\n     {\n       /* These fields are in the _TYPE part of the node, not in\n \t the TYPE_LANG_SPECIFIC component, so they are not shared.  */\n-      TYPE_HAS_CONSTRUCTOR (variants) = TYPE_HAS_CONSTRUCTOR (t);\n+      TYPE_HAS_USER_CONSTRUCTOR (variants) = TYPE_HAS_USER_CONSTRUCTOR (t);\n       TYPE_NEEDS_CONSTRUCTING (variants) = TYPE_NEEDS_CONSTRUCTING (t);\n       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (variants)\n \t= TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t);\n@@ -1596,7 +1596,8 @@ maybe_warn_about_overly_private_class (tree t)\n       return;\n     }\n \n-  if (TYPE_HAS_CONSTRUCTOR (t)\n+  /* Warn about classes that have private constructors and no friends.  */\n+  if (TYPE_HAS_USER_CONSTRUCTOR (t)\n       /* Implicitly generated constructors are always public.  */\n       && (!CLASSTYPE_LAZY_DEFAULT_CTOR (t)\n \t  || !CLASSTYPE_LAZY_COPY_CTOR (t)))\n@@ -2602,20 +2603,25 @@ add_implicitly_declared_members (tree t,\n \t}\n     }\n \n-  /* Default constructor.  */\n-  if (! TYPE_HAS_CONSTRUCTOR (t))\n+  /* [class.ctor]\n+\n+     If there is no user-declared constructor for a class, a default\n+     constructor is implicitly declared.  */\n+  if (! TYPE_HAS_USER_CONSTRUCTOR (t))\n     {\n       TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 1;\n       CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n     }\n \n-  /* Copy constructor.  */\n+  /* [class.ctor]\n+\n+     If a class definition does not explicitly declare a copy\n+     constructor, one is declared implicitly.  */\n   if (! TYPE_HAS_INIT_REF (t) && ! TYPE_FOR_JAVA (t))\n     {\n       TYPE_HAS_INIT_REF (t) = 1;\n       TYPE_HAS_CONST_INIT_REF (t) = !cant_have_const_cctor;\n       CLASSTYPE_LAZY_COPY_CTOR (t) = 1;\n-      TYPE_HAS_CONSTRUCTOR (t) = 1;\n     }\n \n   /* If there is no assignment operator, one will be created if and\n@@ -2937,8 +2943,7 @@ check_field_decls (tree t, tree *access_decls,\n       if (TREE_PRIVATE (x) || TREE_PROTECTED (x))\n \tCLASSTYPE_NON_AGGREGATE (t) = 1;\n \n-      /* If this is of reference type, check if it needs an init.\n-\t Also do a little ANSI jig if necessary.  */\n+      /* If this is of reference type, check if it needs an init.  */\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \t{\n \t  CLASSTYPE_NON_POD_P (t) = 1;\n@@ -2950,10 +2955,6 @@ check_field_decls (tree t, tree *access_decls,\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n-\n-\t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n-\t      && extra_warnings)\n-\t    warning (OPT_Wextra, \"non-static reference %q+#D in class without a constructor\", x);\n \t}\n \n       type = strip_array_types (type);\n@@ -3028,10 +3029,6 @@ check_field_decls (tree t, tree *access_decls,\n \t     only way to initialize nonstatic const and reference\n \t     members.  */\n \t  TYPE_HAS_COMPLEX_ASSIGN_REF (t) = 1;\n-\n-\t  if (! TYPE_HAS_CONSTRUCTOR (t) && CLASSTYPE_NON_AGGREGATE (t)\n-\t      && extra_warnings)\n-\t    warning (OPT_Wextra, \"non-static const member %q+#D in class without a constructor\", x);\n \t}\n       /* A field that is pseudo-const makes the structure likewise.  */\n       else if (CLASS_TYPE_P (type))\n@@ -3045,7 +3042,8 @@ check_field_decls (tree t, tree *access_decls,\n       /* Core issue 80: A nonstatic data member is required to have a\n \t different name from the class iff the class has a\n \t user-defined constructor.  */\n-      if (constructor_name_p (DECL_NAME (x), t) && TYPE_HAS_CONSTRUCTOR (t))\n+      if (constructor_name_p (DECL_NAME (x), t)\n+\t  && TYPE_HAS_USER_CONSTRUCTOR (t))\n \tpedwarn (\"field %q+#D with same name as class\", x);\n \n       /* We set DECL_C_BIT_FIELD in grokbitfield.\n@@ -3073,7 +3071,7 @@ check_field_decls (tree t, tree *access_decls,\n      This seems enough for practical purposes.  */\n   if (warn_ecpp\n       && has_pointers\n-      && TYPE_HAS_CONSTRUCTOR (t)\n+      && TYPE_HAS_USER_CONSTRUCTOR (t)\n       && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n       && !(TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n     {\n@@ -4158,10 +4156,22 @@ check_bases_and_members (tree t)\n      declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_CONTAINS_VPTR_P (t));\n+  /* We need to call a constructor for this class if it has a\n+     user-declared constructor, or if the default constructor is going\n+     to initialize the vptr.  (This is not an if-and-only-if;\n+     TYPE_NEEDS_CONSTRUCTING is set elsewhere if bases or members\n+     themselves need constructing.)  */\n   TYPE_NEEDS_CONSTRUCTING (t)\n-    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n+    |= (TYPE_HAS_USER_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n+  /* [dcl.init.aggr]\n+\n+     An aggregate is an arry or a class with no user-declared\n+     constructors ... and no virtual functions.  \n+\n+     Again, other conditions for being an aggregate are checked\n+     elsewhere.  */\n   CLASSTYPE_NON_AGGREGATE (t)\n-    |= (TYPE_HAS_CONSTRUCTOR (t) || TYPE_POLYMORPHIC_P (t));\n+    |= (TYPE_HAS_USER_CONSTRUCTOR (t) || TYPE_POLYMORPHIC_P (t));\n   CLASSTYPE_NON_POD_P (t)\n     |= (CLASSTYPE_NON_AGGREGATE (t)\n \t|| TYPE_HAS_NONTRIVIAL_DESTRUCTOR (t)\n@@ -4171,6 +4181,38 @@ check_bases_and_members (tree t)\n   TYPE_HAS_COMPLEX_DFLT (t)\n     |= (TYPE_HAS_DEFAULT_CONSTRUCTOR (t) || TYPE_CONTAINS_VPTR_P (t));\n \n+  /* If the class has no user-declared constructor, but does have\n+     non-static const or reference data members that can never be\n+     initialized, issue a warning.  */\n+  if (extra_warnings\n+      /* Classes with user-declared constructors are presumed to\n+\t initialize these members.  */\n+      && !TYPE_HAS_USER_CONSTRUCTOR (t)\n+      /* Aggregates can be initialized with brace-enclosed\n+\t initializers.  */\n+      && CLASSTYPE_NON_AGGREGATE (t))\n+    {\n+      tree field;\n+\n+      for (field = TYPE_FIELDS (t); field; field = TREE_CHAIN (field))\n+\t{\n+\t  tree type;\n+\n+\t  if (TREE_CODE (field) != FIELD_DECL)\n+\t    continue;\n+\n+\t  type = TREE_TYPE (field);\n+\t  if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t    warning (OPT_Wextra, \"non-static reference %q+#D in class \"\n+\t\t     \"without a constructor\", field);\n+\t  else if (CP_TYPE_CONST_P (type)\n+\t\t   && (!CLASS_TYPE_P (type)\n+\t\t       || !TYPE_HAS_DEFAULT_CONSTRUCTOR (type)))\n+\t    warning (OPT_Wextra, \"non-static const member %q+#D in class \"\n+\t\t     \"without a constructor\", field);\n+\t}\n+    }\n+\n   /* Synthesize any needed methods.  */\n   add_implicitly_declared_members (t,\n \t\t\t\t   cant_have_const_ctor,"}, {"sha": "50b40484413d6f574487ff701f6ee3ea0e10b407", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 38, "deletions": 17, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -387,35 +387,56 @@ cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n {\n   tree from = TREE_OPERAND (*expr_p, 1);\n   tree to = TREE_OPERAND (*expr_p, 0);\n-  tree sub;\n+  tree t;\n+  tree slot = NULL_TREE;\n \n   /* What about code that pulls out the temp and uses it elsewhere?  I\n      think that such code never uses the TARGET_EXPR as an initializer.  If\n      I'm wrong, we'll abort because the temp won't have any RTL.  In that\n      case, I guess we'll need to replace references somehow.  */\n   if (TREE_CODE (from) == TARGET_EXPR)\n-    from = TARGET_EXPR_INITIAL (from);\n+    {\n+      slot = TARGET_EXPR_SLOT (from);\n+      from = TARGET_EXPR_INITIAL (from);\n+    }\n \n   /* Look through any COMPOUND_EXPRs, since build_compound_expr pushes them\n      inside the TARGET_EXPR.  */\n-  sub = expr_last (from);\n+  for (t = from; t; )\n+    {\n+      tree sub = TREE_CODE (t) == COMPOUND_EXPR ? TREE_OPERAND (t, 0) : t;\n \n-  /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and\n-     replace the slot operand with our target.\n+      /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and\n+\t replace the slot operand with our target.\n \n-     Should we add a target parm to gimplify_expr instead?  No, as in this\n-     case we want to replace the INIT_EXPR.  */\n-  if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n-    {\n-      gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n-      AGGR_INIT_EXPR_SLOT (sub) = to;\n-      *expr_p = from;\n-\n-      /* The initialization is now a side-effect, so the container can\n-\t become void.  */\n-      if (from != sub)\n-\tTREE_TYPE (from) = void_type_node;\n+\t Should we add a target parm to gimplify_expr instead?  No, as in this\n+\t case we want to replace the INIT_EXPR.  */\n+      if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n+\t{\n+\t  gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n+\t  AGGR_INIT_EXPR_SLOT (sub) = to;\n+\t  *expr_p = from;\n+\n+\t  /* The initialization is now a side-effect, so the container can\n+\t     become void.  */\n+\t  if (from != sub)\n+\t    TREE_TYPE (from) = void_type_node;\n+\t}\n+      else if (TREE_CODE (sub) == INIT_EXPR\n+\t       && TREE_OPERAND (sub, 0) == slot)\n+\t{\n+\t  /* An INIT_EXPR under TARGET_EXPR created by build_value_init,\n+\t     will be followed by an AGGR_INIT_EXPR.  */\n+\t  gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n+\t  TREE_OPERAND (sub, 0) = to;\n+\t}\n+\n+      if (t == sub)\n+\tbreak;\n+      else\n+\tt = TREE_OPERAND (t, 1);\n     }\n+\n }\n \n /* Gimplify a MUST_NOT_THROW_EXPR.  */"}, {"sha": "549625c513885926f40cf9d16787965ef4aea1a3", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -91,7 +91,7 @@ struct diagnostic_info;\n \n    Usage of TYPE_LANG_FLAG_?:\n    0: TYPE_DEPENDENT_P\n-   1: TYPE_HAS_CONSTRUCTOR.\n+   1: TYPE_HAS_USER_CONSTRUCTOR.\n    2: Unused\n    3: TYPE_FOR_JAVA.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n@@ -2709,7 +2709,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n \n /* Nonzero for a class type means that the class type has a\n    user-declared constructor.  */\n-#define TYPE_HAS_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n+#define TYPE_HAS_USER_CONSTRUCTOR(NODE) (TYPE_LANG_FLAG_1 (NODE))\n \n /* When appearing in an INDIRECT_REF, it means that the tree structure\n    underneath is actually a call to a constructor.  This is needed\n@@ -4346,6 +4346,7 @@ extern tree build_aggr_init\t\t\t(tree, tree, int);\n extern int is_aggr_type\t\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n+extern tree build_value_init\t\t\t(tree);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n extern tree build_new\t\t\t\t(tree, tree, tree, tree, int);\n extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int);"}, {"sha": "5f48cc525e8870eeeaec732c01f6eeeb7ef150ae", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -596,13 +596,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   e = integral_constant_value (e);\n \n-  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP)\n-      /* Some internal structures (vtable_entry_type, sigtbl_ptr_type)\n-\t don't go through finish_struct, so they don't have the synthesized\n-\t constructors.  So don't force a temporary.  */\n-      && TYPE_HAS_CONSTRUCTOR (type))\n+  if (IS_AGGR_TYPE (type) && (convtype & CONV_FORCE_TEMP))\n     /* We need a new temporary; don't take this shortcut.  */;\n-  else if (TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (TREE_TYPE (e)))\n+  else if (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (e)))\n     {\n       if (same_type_p (type, TREE_TYPE (e)))\n \t/* The call to fold will not always remove the NOP_EXPR as\n@@ -619,10 +615,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       else if (TREE_CODE (e) == TARGET_EXPR)\n \t{\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n-\t     type of the temporary.  Only allow this for cv-qual changes,\n-\t     though.  */\n-\t  gcc_assert (same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (e)),\n-\t\t\t\t   TYPE_MAIN_VARIANT (type)));\n+\t     type of the temporary.  */\n \t  TREE_TYPE (e) = TREE_TYPE (TARGET_EXPR_SLOT (e)) = type;\n \t  return e;\n \t}"}, {"sha": "93baa7db83adb625f011116664598fe628ef7111", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -3689,7 +3689,7 @@ fixup_anonymous_aggr (tree t)\n   tree *q;\n \n   /* Wipe out memory of synthesized methods.  */\n-  TYPE_HAS_CONSTRUCTOR (t) = 0;\n+  TYPE_HAS_USER_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n   TYPE_HAS_INIT_REF (t) = 0;\n   TYPE_HAS_CONST_INIT_REF (t) = 0;\n@@ -4993,11 +4993,11 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       if (type == error_mark_node)\n \treturn NULL_TREE;\n \n-      if (TYPE_HAS_CONSTRUCTOR (type) || TYPE_NEEDS_CONSTRUCTING (type))\n+      if (TREE_CODE (type) == ARRAY_TYPE && TYPE_NEEDS_CONSTRUCTING (type))\n+\tgoto initialize_aggr;\n+      else if (CLASS_TYPE_P (type))\n \t{\n-\t  if (TREE_CODE (type) == ARRAY_TYPE)\n-\t    goto initialize_aggr;\n-\t  else if (TREE_CODE (init) == CONSTRUCTOR)\n+\t  if (TREE_CODE (init) == CONSTRUCTOR)\n \t    {\n \t      if (TYPE_NON_AGGREGATE_CLASS (type))\n \t\t{\n@@ -9582,7 +9582,8 @@ move_fn_p (const_tree d)\n \n /* Remember any special properties of member function DECL.  */\n \n-void grok_special_member_properties (tree decl)\n+void\n+grok_special_member_properties (tree decl)\n {\n   tree class_type;\n \n@@ -9594,7 +9595,8 @@ void grok_special_member_properties (tree decl)\n     {\n       int ctor = copy_fn_p (decl);\n \n-      TYPE_HAS_CONSTRUCTOR (class_type) = 1;\n+      if (!DECL_ARTIFICIAL (decl))\n+\tTYPE_HAS_USER_CONSTRUCTOR (class_type) = 1;\n \n       if (ctor > 0)\n \t{"}, {"sha": "ec59207716da42025f636c8ca2e490707bd8d763", "filename": "gcc/cp/init.c", "status": "modified", "additions": 150, "deletions": 3, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -152,7 +152,7 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \n   /* [dcl.init]\n \n-     To zero-initialization storage for an object of type T means:\n+     To zero-initialize an object of type T means:\n \n      -- if T is a scalar type, the storage is set to the value of zero\n \tconverted to T.\n@@ -209,8 +209,8 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \t    break;\n \t}\n \n-\t/* Build a constructor to contain the initializations.  */\n-\tinit = build_constructor (type, v);\n+      /* Build a constructor to contain the initializations.  */\n+      init = build_constructor (type, v);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n@@ -315,6 +315,153 @@ build_default_init (tree type, tree nelts)\n   return build_zero_init (type, nelts, /*static_storage_p=*/false);\n }\n \n+/* Return a suitable initializer for value-initializing an object of type\n+   TYPE, as described in [dcl.init].  If HAVE_CTOR is true, the initializer\n+   for an enclosing object is already calling the constructor for this\n+   object.  */\n+\n+static tree\n+build_value_init_1 (tree type, bool have_ctor)\n+{\n+  /* [dcl.init]\n+\n+     To value-initialize an object of type T means:\n+\n+     - if T is a class type (clause 9) with a user-provided constructor\n+       (12.1), then the default constructor for T is called (and the\n+       initialization is ill-formed if T has no accessible default\n+       constructor);\n+\n+     - if T is a non-union class type without a user-provided constructor,\n+       then every non-static data member and base-class component of T is\n+       value-initialized;92)\n+\n+     - if T is an array type, then each element is value-initialized;\n+\n+     - otherwise, the object is zero-initialized.\n+\n+     A program that calls for default-initialization or\n+     value-initialization of an entity of reference type is ill-formed.\n+\n+     92) Value-initialization for such a class object may be implemented by\n+     zero-initializing the object and then calling the default\n+     constructor.  */\n+\n+  if (CLASS_TYPE_P (type))\n+    {\n+      if (TYPE_HAS_USER_CONSTRUCTOR (type) && !have_ctor)\n+\treturn build_cplus_new\n+\t  (type,\n+\t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t      NULL_TREE, type, LOOKUP_NORMAL));\n+      else if (TREE_CODE (type) != UNION_TYPE)\n+\t{\n+\t  tree field, init;\n+\t  VEC(constructor_elt,gc) *v = NULL;\n+\t  bool call_ctor = !have_ctor && TYPE_NEEDS_CONSTRUCTING (type);\n+\n+\t  /* Iterate over the fields, building initializations.  */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      tree ftype, value;\n+\n+\t      if (TREE_CODE (field) != FIELD_DECL)\n+\t\tcontinue;\n+\n+\t      ftype = TREE_TYPE (field);\n+\n+\t      if (TREE_CODE (ftype) == REFERENCE_TYPE)\n+\t\terror (\"value-initialization of reference\");\n+\n+\t      /* We could skip vfields and fields of types with\n+\t\t user-defined constructors, but I think that won't improve\n+\t\t performance at all; it should be simpler in general just\n+\t\t to zero out the entire object than try to only zero the\n+\t\t bits that actually need it.  */\n+\n+\t      /* Note that for class types there will be FIELD_DECLs\n+\t\t corresponding to base classes as well.  Thus, iterating\n+\t\t over TYPE_FIELDs will result in correct initialization of\n+\t\t all of the subobjects.  */\n+\t      value = build_value_init_1 (ftype, have_ctor || call_ctor);\n+\n+\t      if (value)\n+\t\tCONSTRUCTOR_APPEND_ELT(v, field, value);\n+\t    }\n+\n+\t  /* Build a constructor to contain the zero- initializations.  */\n+\t  init = build_constructor (type, v);\n+\t  if (call_ctor)\n+\t    {\n+\t      /* This is a class that needs constructing, but doesn't have\n+\t\t a user-defined constructor.  So we need to zero-initialize\n+\t\t the object and then call the implicitly defined ctor.\n+\t\t Implement this by sticking the zero-initialization inside\n+\t\t the TARGET_EXPR for the constructor call;\n+\t\t cp_gimplify_init_expr will know how to handle it.  */\n+\t      tree ctor = build_special_member_call\n+\t\t(NULL_TREE, complete_ctor_identifier,\n+\t\t NULL_TREE, type, LOOKUP_NORMAL);\n+\n+\t      ctor = build_cplus_new (type, ctor);\n+\t      init = build2 (INIT_EXPR, void_type_node,\n+\t\t\t     TARGET_EXPR_SLOT (ctor), init);\n+\t      init = build2 (COMPOUND_EXPR, void_type_node, init,\n+\t\t\t     TARGET_EXPR_INITIAL (ctor));\n+\t      TARGET_EXPR_INITIAL (ctor) = init;\n+\t      return ctor;\n+\t    }\n+\t  return init;\n+\t}\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      VEC(constructor_elt,gc) *v = NULL;\n+\n+      /* Iterate over the array elements, building initializations.  */\n+      tree max_index = array_type_nelts (type);\n+\n+      /* If we have an error_mark here, we should just return error mark\n+\t as we don't know the size of the array yet.  */\n+      if (max_index == error_mark_node)\n+\treturn error_mark_node;\n+      gcc_assert (TREE_CODE (max_index) == INTEGER_CST);\n+\n+      /* A zero-sized array, which is accepted as an extension, will\n+\t have an upper bound of -1.  */\n+      if (!tree_int_cst_equal (max_index, integer_minus_one_node))\n+\t{\n+\t  constructor_elt *ce;\n+\n+\t  v = VEC_alloc (constructor_elt, gc, 1);\n+\t  ce = VEC_quick_push (constructor_elt, v, NULL);\n+\n+\t  /* If this is a one element array, we just use a regular init.  */\n+\t  if (tree_int_cst_equal (size_zero_node, max_index))\n+\t    ce->index = size_zero_node;\n+\t  else\n+\t    ce->index = build2 (RANGE_EXPR, sizetype, size_zero_node,\n+\t\t\t\tmax_index);\n+\n+\t  ce->value = build_value_init_1 (TREE_TYPE (type), have_ctor);\n+\t}\n+\n+      /* Build a constructor to contain the initializations.  */\n+      return build_constructor (type, v);\n+    }\n+\n+  return build_zero_init (type, NULL_TREE, /*static_storage_p=*/false);\n+}\n+\n+/* Return a suitable initializer for value-initializing an object of type\n+   TYPE, as described in [dcl.init].  */\n+\n+tree\n+build_value_init (tree type)\n+{\n+  return build_value_init_1 (type, false);\n+}\n+\n /* Initialize MEMBER, a FIELD_DECL, with INIT, a TREE_LIST of\n    arguments.  If TREE_LIST is void_type_node, an empty initializer\n    list was given; if NULL_TREE no initializer was given.  */"}, {"sha": "2b996d41ae1b4b4621ab86f27779ecae04e0b1b0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -2091,7 +2091,7 @@ check_explicit_specialization (tree declarator,\n \t    {\n \t      int is_constructor = DECL_CONSTRUCTOR_P (decl);\n \n-\t      if (is_constructor ? !TYPE_HAS_CONSTRUCTOR (ctype)\n+\t      if (is_constructor ? !TYPE_HAS_USER_CONSTRUCTOR (ctype)\n \t\t  : !CLASSTYPE_DESTRUCTORS (ctype))\n \t\t{\n \t\t  /* From [temp.expl.spec]:\n@@ -6818,7 +6818,7 @@ instantiate_class_template (tree type)\n   input_location = DECL_SOURCE_LOCATION (typedecl);\n   in_system_header = DECL_IN_SYSTEM_HEADER (typedecl);\n \n-  TYPE_HAS_CONSTRUCTOR (type) = TYPE_HAS_CONSTRUCTOR (pattern);\n+  TYPE_HAS_USER_CONSTRUCTOR (type) = TYPE_HAS_USER_CONSTRUCTOR (pattern);\n   TYPE_HAS_NEW_OPERATOR (type) = TYPE_HAS_NEW_OPERATOR (pattern);\n   TYPE_HAS_ARRAY_NEW_OPERATOR (type) = TYPE_HAS_ARRAY_NEW_OPERATOR (pattern);\n   TYPE_GETS_DELETE (type) = TYPE_GETS_DELETE (pattern);"}, {"sha": "1925d04fbc5fa5e268032edbde6fddc14d299759", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -1318,7 +1318,6 @@ create_tinfo_types (void)\n     ti->name = NULL_TREE;\n     finish_builtin_struct (ti->type, \"__type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n-    TYPE_HAS_CONSTRUCTOR (ti->type) = 1;\n   }\n \n   /* Fundamental type_info */\n@@ -1357,7 +1356,6 @@ create_tinfo_types (void)\n     ti->name = NULL_TREE;\n     finish_builtin_struct (ti->type, \"__base_class_type_info_pseudo\",\n \t\t\t   fields, NULL_TREE);\n-    TYPE_HAS_CONSTRUCTOR (ti->type) = 1;\n   }\n \n   /* Pointer type_info. Adds two fields, qualification mask"}, {"sha": "66c35d44e43e28fb312b0f3c2a85d9bb296f437f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -1310,6 +1310,8 @@ build_functional_cast (tree exp, tree parms)\n {\n   /* This is either a call to a constructor,\n      or a C cast in C++'s `functional' notation.  */\n+\n+  /* The type to which we are casting.  */\n   tree type;\n \n   if (exp == error_mark_node || parms == error_mark_node)\n@@ -1350,20 +1352,31 @@ build_functional_cast (tree exp, tree parms)\n   if (abstract_virtuals_error (NULL_TREE, type))\n     return error_mark_node;\n \n+  /* [expr.type.conv]\n+\n+     If the expression list is a single-expression, the type\n+     conversion is equivalent (in definedness, and if defined in\n+     meaning) to the corresponding cast expression.  */\n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n     return build_c_cast (type, TREE_VALUE (parms));\n \n-  /* We need to zero-initialize POD types.  */\n-  if (parms == NULL_TREE \n-      && !CLASSTYPE_NON_POD_P (type)\n-      && TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n+  /* [expr.type.conv]\n+\n+     The expression T(), where T is a simple-type-specifier for a\n+     non-array complete object type or the (possibly cv-qualified)\n+     void type, creates an rvalue of the specified type, which is\n+     value-initialized.  */\n+\n+  if (parms == NULL_TREE\n+      /* If there's a user-defined constructor, value-initialization is\n+\t just calling the constructor, so fall through.  */\n+      && !TYPE_HAS_USER_CONSTRUCTOR (type))\n     {\n-      exp = build_zero_init (type, \n-\t\t\t     /*nelts=*/NULL_TREE,\n-\t\t\t     /*static_storage_p=*/false);\n+      exp = build_value_init (type);\n       return get_target_expr (exp);\n     }\n \n+  /* Call the constructor.  */\n   exp = build_special_member_call (NULL_TREE, complete_ctor_identifier, parms,\n \t\t\t\t   type, LOOKUP_NORMAL);\n "}, {"sha": "8f2ca7555c866a1619b472f6db5611863df65365", "filename": "gcc/print-tree.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -851,6 +851,21 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t      }\n \t  break;\n \n+\tcase CONSTRUCTOR:\n+\t  {\n+\t    unsigned HOST_WIDE_INT cnt;\n+\t    tree index, value;\n+\t    len = VEC_length (constructor_elt, CONSTRUCTOR_ELTS (node));\n+\t    fprintf (file, \" lngt %d\", len);\n+\t    FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (node),\n+\t\t\t\t      cnt, index, value)\n+\t      {\n+\t\tprint_node (file, \"idx\", index, indent + 4);\n+\t\tprint_node (file, \"val\", value, indent + 4);\n+\t      }\n+\t  }\n+\t  break;\n+\n     \tcase STATEMENT_LIST:\n \t  dump_addr (file, \" head \", node->stmt_list.head);\n \t  dump_addr (file, \" tail \", node->stmt_list.tail);"}, {"sha": "3491f6a1d2cf07ab92ae25843e332b6388f92ec7", "filename": "gcc/testsuite/g++.dg/init/ctor8.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fctor8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fctor8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fctor8.C?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -1,9 +1,9 @@\n // PR c++/29039\n \n-typedef struct S { // { dg-error \"reference\" }\n+typedef struct S {\n   int &r; \n }; // { dg-warning \"'typedef' was ignored\" }\n \n S f () {\n-  return S (); // { dg-error \"synthesized\" }\n+  return S (); // { dg-error \"reference\" }\n }"}, {"sha": "9dbc2e067750ab056ce114eb17c5f7308b41ed6e", "filename": "gcc/testsuite/g++.dg/init/value1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fvalue1.C?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -0,0 +1,22 @@\n+// Test that with value-initialization, i is initialized to 0\n+// and the vtable pointer is properly initialized.\n+\n+// { dg-do run }\n+\n+struct A\n+{\n+  int i;\n+  virtual void f() {}\n+};\n+\n+void f (A& a)\n+{\n+  a.f();\n+}\n+\n+int main()\n+{\n+  A a = A();\n+  f (a);\n+  return a.i;\n+}"}, {"sha": "c75a6b087675a4c3e9932acf441ecada954b275b", "filename": "gcc/testsuite/g++.dg/warn/Wextra-1.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-1.C?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options \"-Wextra\" }\n+\n+struct T {\n+  // If the implicitly-declared default constructor for \"T\" is\n+  // required, an error will be issued because \"i\" cannot be\n+  // initialized.  And, this class is not an aggregate, so it cannot\n+  // be brace-initialized.  Thus, there is no way to create an object\n+  // of this class.  We issue a warning with -Wextra.\n+  const int i;\t\t\t// { dg-warning \"const\" }\n+private:\n+  int j;\n+};"}, {"sha": "5ca41c39d938414414550522256864926f3af2df", "filename": "gcc/testsuite/g++.dg/warn/Wextra-2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fcedd9c98d1f9f880b59b979b77f4db4d9eb391/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWextra-2.C?ref=0fcedd9c98d1f9f880b59b979b77f4db4d9eb391", "patch": "@@ -0,0 +1,15 @@\n+// { dg-options \"-Wextra\" } \n+\n+struct S {\n+  S();\n+};\n+\n+struct T {\n+private:\n+  int i;\n+public:\n+  // There should be no warning about this data member because the\n+  // default constructor for \"T\" will invoke the default constructor\n+  // for \"S\", even though \"S\" is \"const\".\n+  const S s; // { dg-bogus \"const\" }\n+};"}]}