{"sha": "9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk4MzI3MGJlYzBhMThmNjIzMGE1YmRhZjlhMTVmNjlkYThlOGJhYQ==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2005-06-15T11:33:13Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2005-06-15T11:33:13Z"}, "message": "re PR tree-optimization/22018 (VRP miscompiles multiply)\n\n\n\tPR 22018\n\t* tree-vrp.c (vrp_int_const_binop): New.\n\t(extract_range_from_binary_expr): Call it.\n\tUnify handling division and multiplication.\n\ntestsuite/ChangeLog:\n\n\tPR 22018\n\t* gcc.dg/tree-ssa/vrp13.c: Add multiplication tests.\n\t* gcc.dg/tree-ssa/pr22018.c: New test.\n\nFrom-SVN: r100978", "tree": {"sha": "12ee61e204a3b7f25a7b0e4c27a970e51d76b0b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12ee61e204a3b7f25a7b0e4c27a970e51d76b0b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/comments", "author": null, "committer": null, "parents": [{"sha": "f6d7e7d8c0a2d025da90575eb488603ca0d22ec7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d7e7d8c0a2d025da90575eb488603ca0d22ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d7e7d8c0a2d025da90575eb488603ca0d22ec7"}], "stats": {"total": 391, "additions": 282, "deletions": 109}, "files": [{"sha": "49139aaf9069dc0c263bb7eb2d2cfdb6879ba60f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "patch": "@@ -1,3 +1,10 @@\n+2005-06-15  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 22018\n+\t* tree-vrp.c (vrp_int_const_binop): New.\n+\t(extract_range_from_binary_expr): Call it.\n+\tUnify handling division and multiplication.\n+\n 2005-06-15  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* c-common.h (same_scalar_type_ignoring_signedness): Protoize."}, {"sha": "53abe65212f40586dc666796270fbbfbee0c2be4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "patch": "@@ -1,3 +1,9 @@\n+2005-06-15  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR 22018\n+\t* gcc.dg/tree-ssa/vrp13.c: Add multiplication tests.\n+\t* gcc.dg/tree-ssa/pr22018.c: New test.\n+\n 2005-06-15  Aldy Hernandez  <aldyh@redhat.com>\n \n \t* gcc.dg/simd-1.c: Update error messages."}, {"sha": "d4d332c2fc96ccd0dd970cd4cdbbf5f885806d91", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr22018.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22018.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22018.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr22018.c?ref=9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run }  */\n+/* { dg-options -O2 }  */\n+\n+void abort (void);\n+void g(int);\n+void f(int l)\n+{\n+  unsigned i;\n+  for (i = 0; i < l; i++)\n+    {\n+      int y = i;\n+      /* VRP was wrongfully computing z's range to be [0, 0] instead\n+\t of [-INF, 0].  */\n+      int z = y*-32;\n+      g(z);\n+    }\n+}\n+\n+void g(int i)\n+{\n+  static int x = 0;\n+  if (i == 0)\n+    x ++;\n+  if (x > 1)\n+    abort ();\n+}\n+\n+int main(void)\n+{\n+  f(3);\n+  return 0;\n+}"}, {"sha": "4b3afdbc8c61d44e300a195bbd6ed9bd47f10c47", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp13.c", "status": "modified", "additions": 127, "deletions": 8, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp13.c?ref=9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "patch": "@@ -3,7 +3,7 @@\n \n extern void abort (void);\n \n-foo (int i, int j)\n+foo_div (int i, int j)\n {\n   int k;\n \n@@ -112,27 +112,146 @@ foo (int i, int j)\n }\n \n \n+foo_mult (int i, int j)\n+{\n+  int k;\n+\n+  /* [-20, -10] * [2, 10] should give [-200, -20].  */\n+  if (i >= -20)\n+    if (i <= -10)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < -200)\n+\t      link_error ();\n+\t    if (k > -20)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, -10] * [-10, -2] should give [20, 200].  */\n+  if (i >= -20)\n+    if (i <= -10)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < 20)\n+\t      link_error ();\n+\t    if (k > 200)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, 10] * [2, 10] should give [-200, 100].  */\n+  if (i >= -20)\n+    if (i <= 10)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < -200)\n+\t      link_error ();\n+\t    if (k > 100)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [-20, 10] * [-10, -2] should give [-100, 200].  */\n+  if (i >= -20)\n+    if (i <= 10)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < -100)\n+\t      link_error ();\n+\t    if (k > 200)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [10, 20] * [2, 10] should give [20, 200].  */\n+  if (i >= 10)\n+    if (i <= 20)\n+      if (j >= 2)\n+\tif (j <= 10)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < 20)\n+\t      link_error ();\n+\t    if (k > 200)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  /* [10, 20] * [-10, -2] should give [-200, -20].  */\n+  if (i >= 10)\n+    if (i <= 20)\n+      if (j >= -10)\n+\tif (j <= -2)\n+\t  {\n+\t    k = i * j;\n+\t    if (k < -200)\n+\t      link_error ();\n+\t    if (k > -20)\n+\t      link_error ();\n+\n+\t    return k;\n+\t  }\n+\n+  abort ();\n+}\n+\n+\n main()\n {\n-  if (foo (-10, 5) != -2)\n+  if (foo_div (-10, 5) != -2)\n+    abort ();\n+\n+  if (foo_div (-16, 4) != -4)\n+    abort ();\n+\n+  if (foo_div (-15, -5) != 3)\n+    abort ();\n+\n+  if (foo_div (8, 2) != 4)\n+    abort ();\n+\n+  if (foo_div (10, -2) != -5)\n+    abort ();\n+\n+  if (foo_div (20, 5) != 4)\n+    abort ();\n+\n+  if (foo_div (15, -3) != -5)\n+    abort ();\n+\n+  if (foo_mult (-10, 5) != -50)\n     abort ();\n \n-  if (foo (-16, 4) != -4)\n+  if (foo_mult (-16, 4) != -64)\n     abort ();\n \n-  if (foo (-15, -5) != 3)\n+  if (foo_mult (-15, -5) != 75)\n     abort ();\n \n-  if (foo (8, 2) != 4)\n+  if (foo_mult (8, 2) != 16)\n     abort ();\n \n-  if (foo (10, -2) != -5)\n+  if (foo_mult (10, -2) != -20)\n     abort ();\n \n-  if (foo (20, 5) != 4)\n+  if (foo_mult (20, 5) != 100)\n     abort ();\n \n-  if (foo (15, -3) != -5)\n+  if (foo_mult (15, -3) != -45)\n     abort ();\n \n   return 0;"}, {"sha": "2569267ccf8884e23bb99b882b1c1e8367c5aade", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 110, "deletions": 101, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9983270bec0a18f6230a5bdaf9a15f69da8e8baa/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9983270bec0a18f6230a5bdaf9a15f69da8e8baa", "patch": "@@ -969,6 +969,50 @@ extract_range_from_ssa_name (value_range_t *vr, tree var)\n }\n \n \n+/* Wrapper around int_const_binop.  If the operation overflows and we\n+   are not using wrapping arithmetic, then adjust the result to be\n+   -INF or +INF depending on CODE, VAL1 and VAL2.  */\n+\n+static inline tree\n+vrp_int_const_binop (enum tree_code code, tree val1, tree val2)\n+{\n+  tree res;\n+\n+  if (flag_wrapv)\n+    return int_const_binop (code, val1, val2, 0);\n+\n+  /* If we are not using wrapping arithmetic, operate symbolically\n+     on -INF and +INF.  */\n+  res = int_const_binop (code, val1, val2, 0);\n+\n+  /* If the operation overflowed but neither VAL1 nor VAL2 are\n+     overflown, return -INF or +INF depending on whether VAL1 CODE\n+     VAL2 is a growing function or not.  */\n+  if (TREE_OVERFLOW (res)\n+      && !TREE_OVERFLOW (val1)\n+      && !TREE_OVERFLOW (val2))\n+    {\n+      bool grows = false;\n+      int sgn1 = tree_int_cst_sgn (val1);\n+      int sgn2 = tree_int_cst_sgn (val2);\n+\n+      /* Notice that we only need to handle the restricted set of\n+\t operations handled by extract_range_from_binary_expr.  */\n+      if (((code == PLUS_EXPR || code == MAX_EXPR) && sgn2 >= 0)\n+\t  || (code == MULT_EXPR && sgn1 == sgn2)\n+\t  || (code == MINUS_EXPR && sgn2 < 0))\n+\tgrows = true;\n+\n+      if (grows)\n+\treturn TYPE_MAX_VALUE (TREE_TYPE (res));\n+      else\n+\treturn TYPE_MIN_VALUE (TREE_TYPE (res));\n+    }\n+\n+  return res;\n+}\n+\n+\n /* Extract range information from a binary expression EXPR based on\n    the ranges of each of its operands and the expression code.  */\n \n@@ -1076,139 +1120,104 @@ extract_range_from_binary_expr (value_range_t *vr, tree expr)\n       max = fold_binary (code, TREE_TYPE (expr), vr0.max, vr1.max);\n     }\n   else if (code == PLUS_EXPR\n-\t   || code == MULT_EXPR\n \t   || code == MIN_EXPR\n \t   || code == MAX_EXPR)\n     {\n       /* For operations that make the resulting range directly\n \t proportional to the original ranges, apply the operation to\n \t the same end of each range.  */\n-      min = int_const_binop (code, vr0.min, vr1.min, 0);\n-      max = int_const_binop (code, vr0.max, vr1.max, 0);\n+      min = vrp_int_const_binop (code, vr0.min, vr1.min);\n+      max = vrp_int_const_binop (code, vr0.max, vr1.max);\n     }\n-  else if (code == TRUNC_DIV_EXPR\n+  else if (code == MULT_EXPR\n+\t   || code == TRUNC_DIV_EXPR\n \t   || code == FLOOR_DIV_EXPR\n \t   || code == CEIL_DIV_EXPR\n \t   || code == EXACT_DIV_EXPR\n \t   || code == ROUND_DIV_EXPR)\n     {\n-      tree zero;\n+      tree val[4];\n+      size_t i;\n+\n+      /* Multiplications and divisions are a bit tricky to handle,\n+\t depending on the mix of signs we have in the two ranges, we\n+\t need to operate on different values to get the minimum and\n+\t maximum values for the new range.  One approach is to figure\n+\t out all the variations of range combinations and do the\n+\t operations.\n \n-      /* Divisions are a bit tricky to handle, depending on the mix of\n-\t signs we have in the two range, we will need to divide\n-\t different values to get the minimum and maximum values for\n-\t the new range.  If VR1 includes zero, the result is VARYING.  */\n-      if (range_includes_zero_p (&vr1))\n+\t However, this involves several calls to compare_values and it\n+\t is pretty convoluted.  It's simpler to do the 4 operations\n+\t (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n+\t MAX1) and then figure the smallest and largest values to form\n+\t the new range.  */\n+\n+      /* Divisions by zero result in a VARYING value.  */\n+      if (code != MULT_EXPR && range_includes_zero_p (&vr1))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n \n-      /* We have three main variations to handle for VR0: all negative\n-\t values, all positive values and a mix of negative and\n-\t positive.  For each of these, we need to consider if VR1 is\n-\t all negative or all positive.  In total, there are 6\n-\t combinations to handle.  */\n-      zero = build_int_cst (TREE_TYPE (expr), 0);\n-      if (compare_values (vr0.max, zero) == -1)\n-\t{\n-\t  /* VR0 is all negative.  */\n-\t  if (compare_values (vr1.min, zero) == 1)\n-\t    {\n-\t      /* If VR1 is all positive, the new range is obtained\n-\t\t with [VR0.MIN / VR1.MIN, VR0.MAX / VR1.MAX].  */\n-\t      min = int_const_binop (code, vr0.min, vr1.min, 0);\n-\t      max = int_const_binop (code, vr0.max, vr1.max, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If VR1 is all negative, the new range is obtained\n-\t\t with [VR0.MAX / VR1.MIN, VR0.MIN / VR1.MAX].  */\n-\t      gcc_assert (compare_values (vr1.max, zero) == -1);\n-\t      min = int_const_binop (code, vr0.max, vr1.min, 0);\n-\t      max = int_const_binop (code, vr0.min, vr1.max, 0);\n-\t    }\n-\t}\n-      else if (range_includes_zero_p (&vr0))\n-\t{\n-\t  /* VR0 is a mix of negative and positive values.  */\n-\t  if (compare_values (vr1.min, zero) == 1)\n-\t    {\n-\t      /* If VR1 is all positive, the new range is obtained\n-\t\t with [VR0.MIN / VR1.MIN, VR0.MAX / VR1.MIN].  */\n-\t      min = int_const_binop (code, vr0.min, vr1.min, 0);\n-\t      max = int_const_binop (code, vr0.max, vr1.min, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* If VR1 is all negative, the new range is obtained\n-\t\t with [VR0.MAX / VR1.MAX, VR0.MIN / VR1.MAX].  */\n-\t      gcc_assert (compare_values (vr1.max, zero) == -1);\n-\t      min = int_const_binop (code, vr0.max, vr1.max, 0);\n-\t      max = int_const_binop (code, vr0.min, vr1.max, 0);\n-\t    }\n-\t}\n-      else\n+      /* Compute the 4 cross operations.  */\n+      val[0] = vrp_int_const_binop (code, vr0.min, vr1.min);\n+\n+      val[1] = (vr1.max != vr1.min)\n+\t       ? vrp_int_const_binop (code, vr0.min, vr1.max)\n+\t       : NULL_TREE;\n+\n+      val[2] = (vr0.max != vr0.min)\n+\t       ? vrp_int_const_binop (code, vr0.max, vr1.min)\n+\t       : NULL_TREE;\n+\n+      val[3] = (vr0.min != vr1.min && vr0.max != vr1.max)\n+\t       ? vrp_int_const_binop (code, vr0.max, vr1.max)\n+\t       : NULL_TREE;\n+\n+      /* Set MIN to the minimum of VAL[i] and MAX to the maximum\n+\t of VAL[i].  */\n+      min = val[0];\n+      max = val[0];\n+      for (i = 1; i < 4; i++)\n \t{\n-\t  /* VR0 is all positive.  */\n-\t  gcc_assert (compare_values (vr0.min, zero) == 1);\n-\t  if (compare_values (vr1.min, zero) == 1)\n-\t    {\n-\t      /* If VR1 is all positive, the new range is obtained\n-\t\t with [VR0.MIN / VR1.MAX, VR0.MAX / VR1.MIN].  */\n-\t      min = int_const_binop (code, vr0.min, vr1.max, 0);\n-\t      max = int_const_binop (code, vr0.max, vr1.min, 0);\n-\t    }\n-\t  else\n+\t  if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))\n+\t    break;\n+\n+\t  if (val[i])\n \t    {\n-\t      /* If VR1 is all negative, the new range is obtained\n-\t\t with [VR0.MAX / VR1.MAX, VR0.MIN / VR1.MIN].  */\n-\t      gcc_assert (compare_values (vr1.max, zero) == -1);\n-\t      min = int_const_binop (code, vr0.max, vr1.max, 0);\n-\t      max = int_const_binop (code, vr0.min, vr1.min, 0);\n+\t      if (TREE_OVERFLOW (val[i]))\n+\t\t{\n+\t\t  /* If we found an overflowed value, set MIN and MAX\n+\t\t     to it so that we set the resulting range to\n+\t\t     VARYING.  */\n+\t\t  min = max = val[i];\n+\t\t  break;\n+\t\t}\n+\n+\t      if (compare_values (val[i], min) == -1)\n+\t\tmin = val[i];\n+\n+\t      if (compare_values (val[i], max) == 1)\n+\t\tmax = val[i];\n \t    }\n \t}\n     }\n   else if (code == MINUS_EXPR)\n     {\n       /* For MINUS_EXPR, apply the operation to the opposite ends of\n \t each range.  */\n-      min = int_const_binop (code, vr0.min, vr1.max, 0);\n-      max = int_const_binop (code, vr0.max, vr1.min, 0);\n+      min = vrp_int_const_binop (code, vr0.min, vr1.max);\n+      max = vrp_int_const_binop (code, vr0.max, vr1.min);\n     }\n   else\n     gcc_unreachable ();\n \n-  /* If MAX overflowed, then the result depends on whether we are\n-     using wrapping arithmetic or not.  */\n-  if (TREE_OVERFLOW (max))\n+  /* If either MIN or MAX overflowed, then set the resulting range to\n+     VARYING.  */\n+  if (TREE_OVERFLOW (min) || TREE_OVERFLOW (max))\n     {\n-      /* If we are using wrapping arithmetic, set the result to\n-\t VARYING.  */\n-      if (flag_wrapv)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* Otherwise, set MAX to +INF.  */\n-      max = TYPE_MAX_VALUE (TREE_TYPE (expr));\n-    }\n-\n-  /* If MIN overflowed, then the result depends on whether we are\n-     using wrapping arithmetic or not.  */\n-  if (TREE_OVERFLOW (min))\n-    {\n-      /* If we are using wrapping arithmetic, set the result to\n-\t VARYING.  */\n-      if (flag_wrapv)\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n-      /* Otherwise, set MIN to -INF.  */\n-      min = TYPE_MIN_VALUE (TREE_TYPE (expr));\n+      set_value_range_to_varying (vr);\n+      return;\n     }\n \n   cmp = compare_values (min, max);"}]}