{"sha": "1f26ac87486d92b964b0c56823beabe28e7dcef7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWYyNmFjODc0ODZkOTJiOTY0YjBjNTY4MjNiZWFiZTI4ZTdkY2VmNw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-12-23T17:49:47Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-12-23T17:49:47Z"}, "message": "re PR c++/41090 (Using static label reference in c++ class constructor produces wrong code)\n\n\tPR c++/41090\n\tAdd -fdeclone-ctor-dtor.\ngcc/cp/\n\t* optimize.c (can_alias_cdtor, populate_clone_array): Split out\n\tfrom maybe_clone_body.\n\t(maybe_thunk_body): New function.\n\t(maybe_clone_body): Call it.\n\t* mangle.c (write_mangled_name): Remove code to suppress\n\twriting of mangled name for cloned constructor or destructor.\n\t(write_special_name_constructor): Handle decloned constructor.\n\t(write_special_name_destructor): Handle decloned destructor.\n\t* method.c (trivial_fn_p): Handle decloning.\n\t* semantics.c (expand_or_defer_fn_1): Clone after setting linkage.\ngcc/c-family/\n\t* c.opt: Add -fdeclone-ctor-dtor.\n\t* c-opts.c (c_common_post_options): Default to on iff -Os.\ngcc/\n\t* cgraph.h (struct cgraph_node): Add calls_comdat_local.\n\t(symtab_comdat_local_p, symtab_in_same_comdat_p): New.\n\t* cif-code.def: Add USES_COMDAT_LOCAL.\n\t* symtab.c (verify_symtab_base): Make sure we don't refer to a\n\tcomdat-local symbol from outside its comdat.\n\t* cgraph.c (verify_cgraph_node): Likewise.\n\t* cgraphunit.c (mark_functions_to_output): Don't mark comdat-locals.\n\t* ipa.c (symtab_remove_unreachable_nodes): Likewise.\n\t(function_and_variable_visibility): Handle comdat-local fns.\n\t* ipa-cp.c (determine_versionability): Don't clone comdat-locals.\n\t* ipa-inline-analysis.c (compute_inline_parameters): Update\n\tcalls_comdat_local.\n\t* ipa-inline-transform.c (inline_call): Likewise.\n\t(save_inline_function_body): Don't clear DECL_COMDAT_GROUP.\n\t* ipa-inline.c (can_inline_edge_p): Check calls_comdat_local.\n\t* lto-cgraph.c (input_overwrite_node): Read calls_comdat_local.\n\t(lto_output_node): Write it.\n\t* symtab.c (symtab_dissolve_same_comdat_group_list): Clear\n\tDECL_COMDAT_GROUP for comdat-locals.\ninclude/\n\t* demangle.h (enum gnu_v3_ctor_kinds):\n\tAdded literal gnu_v3_unified_ctor.\n\t(enum gnu_v3_ctor_kinds):\n\tAdded literal gnu_v3_unified_dtor.\nlibiberty/\n\t* cp-demangle.c (cplus_demangle_fill_ctor,cplus_demangle_fill_dtor):\n\tHandle unified ctor/dtor.\n\t(d_ctor_dtor_name): Handle unified ctor/dtor.\n\nFrom-SVN: r206182", "tree": {"sha": "deb79005e2132e0ee5c203e13985a93f5dd4714e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deb79005e2132e0ee5c203e13985a93f5dd4714e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f26ac87486d92b964b0c56823beabe28e7dcef7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f26ac87486d92b964b0c56823beabe28e7dcef7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f26ac87486d92b964b0c56823beabe28e7dcef7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f26ac87486d92b964b0c56823beabe28e7dcef7/comments", "author": null, "committer": null, "parents": [{"sha": "266d276c4eb2c06d3593ddf1d828776be91f0eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/266d276c4eb2c06d3593ddf1d828776be91f0eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/266d276c4eb2c06d3593ddf1d828776be91f0eea"}], "stats": {"total": 610, "additions": 524, "deletions": 86}, "files": [{"sha": "ab6875e977f4de823b794d63e2039cf298409886", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1,3 +1,25 @@\n+2013-12-23  Jason Merrill  <jason@redhat.com>\n+\n+\t* cgraph.h (struct cgraph_node): Add calls_comdat_local.\n+\t(symtab_comdat_local_p, symtab_in_same_comdat_p): New.\n+\t* cif-code.def: Add USES_COMDAT_LOCAL.\n+\t* symtab.c (verify_symtab_base): Make sure we don't refer to a\n+\tcomdat-local symbol from outside its comdat.\n+\t* cgraph.c (verify_cgraph_node): Likewise.\n+\t* cgraphunit.c (mark_functions_to_output): Don't mark comdat-locals.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Likewise.\n+\t(function_and_variable_visibility): Handle comdat-local fns.\n+\t* ipa-cp.c (determine_versionability): Don't clone comdat-locals.\n+\t* ipa-inline-analysis.c (compute_inline_parameters): Update\n+\tcalls_comdat_local.\n+\t* ipa-inline-transform.c (inline_call): Likewise.\n+\t(save_inline_function_body): Don't clear DECL_COMDAT_GROUP.\n+\t* ipa-inline.c (can_inline_edge_p): Check calls_comdat_local.\n+\t* lto-cgraph.c (input_overwrite_node): Read calls_comdat_local.\n+\t(lto_output_node): Write it.\n+\t* symtab.c (symtab_dissolve_same_comdat_group_list): Clear\n+\tDECL_COMDAT_GROUP for comdat-locals.\n+\n 2013-12-23   H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/i386.c (processor_target_table): Move Bonnell and"}, {"sha": "1e0da89b347df69ecb5fd6dd82e0263467c9a3d8", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1,3 +1,10 @@\n+2013-12-23  Stuart Hastings <stuart@apple.com>\n+\t    Bill Maddox  <maddox@google.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\t* c.opt: Add -fdeclone-ctor-dtor.\n+\t* c-opts.c (c_common_post_options): Default to on iff -Os.\n+\n 2013-12-18  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* c-common.c (c_common_attribute_table): Added \"cilk simd function\""}, {"sha": "3576f7d57c1439379c57f0d38c2b225fbc75efa0", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -899,6 +899,10 @@ c_common_post_options (const char **pfilename)\n   if (warn_implicit_function_declaration == -1)\n     warn_implicit_function_declaration = flag_isoc99;\n \n+  /* Declone C++ 'structors if -Os.  */\n+  if (flag_declone_ctor_dtor == -1)\n+    flag_declone_ctor_dtor = optimize_size;\n+\n   if (cxx_dialect >= cxx11)\n     {\n       /* If we're allowing C++0x constructs, don't warn about C++98"}, {"sha": "d270f77ae6ba8ab9260a8ea8e5820defb83f9f23", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -890,6 +890,10 @@ fdeduce-init-list\n C++ ObjC++ Var(flag_deduce_init_list) Init(0)\n -fdeduce-init-list\tenable deduction of std::initializer_list for a template type parameter from a brace-enclosed initializer-list\n \n+fdeclone-ctor-dtor\n+C++ ObjC++ Var(flag_declone_ctor_dtor) Init(-1)\n+Factor complex constructors and destructors to favor space over speed\n+\n fdefault-inline\n C++ ObjC++ Ignore\n Does nothing.  Preserved for backward compatibility."}, {"sha": "ccd150c81450fba860e565f58aab38fa9b168607", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -2666,10 +2666,18 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error_found = true;\n \t}\n     }\n+  bool check_comdat = symtab_comdat_local_p (node);\n   for (e = node->callers; e; e = e->next_caller)\n     {\n       if (verify_edge_count_and_frequency (e))\n \terror_found = true;\n+      if (check_comdat\n+\t  && !symtab_in_same_comdat_p (e->caller, node))\n+\t{\n+\t  error (\"comdat-local function called by %s outside its comdat\",\n+\t\t identifier_to_locale (e->caller->name ()));\n+\t  error_found = true;\n+\t}\n       if (!e->inline_failed)\n \t{\n \t  if (node->global.inlined_to"}, {"sha": "69b97a7e703df44f072204a76e93d2c76b9871f8", "filename": "gcc/cgraph.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -428,6 +428,9 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n   unsigned tm_clone : 1;\n   /* True if this decl is a dispatcher for function versions.  */\n   unsigned dispatcher_function : 1;\n+  /* True if this decl calls a COMDAT-local function.  This is set up in\n+     compute_inline_parameters and inline_call.  */\n+  unsigned calls_comdat_local : 1;\n };\n \n \n@@ -1490,4 +1493,22 @@ symtab_can_be_discarded (symtab_node *node)\n \t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY\n \t      && node->resolution != LDPR_PREVAILING_DEF_IRONLY_EXP));\n }\n+\n+/* Return true if NODE is local to a particular COMDAT group, and must not\n+   be named from outside the COMDAT.  This is used for C++ decloned\n+   constructors.  */\n+\n+static inline bool\n+symtab_comdat_local_p (symtab_node *node)\n+{\n+  return (node->same_comdat_group && !TREE_PUBLIC (node->decl));\n+}\n+\n+/* Return true if ONE and TWO are part of the same COMDAT group.  */\n+\n+static inline bool\n+symtab_in_same_comdat_p (symtab_node *one, symtab_node *two)\n+{\n+  return DECL_COMDAT_GROUP (one->decl) == DECL_COMDAT_GROUP (two->decl);\n+}\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "679c9eca8184878238cb17d97e09e9c556a61573", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1244,7 +1244,8 @@ mark_functions_to_output (void)\n \t      for (next = cgraph (node->same_comdat_group);\n \t\t   next != node;\n \t\t   next = cgraph (next->same_comdat_group))\n-\t\tif (!next->thunk.thunk_p && !next->alias)\n+\t\tif (!next->thunk.thunk_p && !next->alias\n+\t\t    && !symtab_comdat_local_p (next))\n \t\t  next->process = 1;\n \t    }\n \t}"}, {"sha": "be4af6a0a5d6a892a972723c0cb3fef2cc2f55cc", "filename": "gcc/cif-code.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcif-code.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcif-code.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcif-code.def?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -106,3 +106,6 @@ DEFCIFCODE(TARGET_OPTION_MISMATCH, N_(\"target specific option mismatch\"))\n \n /* We can't inline because of mismatched optimization levels.  */\n DEFCIFCODE(OPTIMIZATION_MISMATCH, N_(\"optimization level attribute mismatch\"))\n+\n+/* We can't inline because the callee refers to comdat-local symbols.  */\n+DEFCIFCODE(USES_COMDAT_LOCAL, N_(\"callee refers to comdat-local symbols\"))"}, {"sha": "52400421d6419df7d1d982da0b2b0571f2866a53", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1,3 +1,19 @@\n+2013-12-23  Stuart Hastings <stuart@apple.com>\n+\t    Bill Maddox  <maddox@google.com>\n+\t    Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/41090\n+\t* optimize.c (can_alias_cdtor, populate_clone_array): Split out\n+\tfrom maybe_clone_body.\n+\t(maybe_thunk_body): New function.\n+\t(maybe_clone_body): Call it.\n+\t* mangle.c (write_mangled_name): Remove code to suppress\n+\twriting of mangled name for cloned constructor or destructor.\n+\t(write_special_name_constructor): Handle decloned constructor.\n+\t(write_special_name_destructor): Handle decloned destructor.\n+\t* method.c (trivial_fn_p): Handle decloning.\n+\t* semantics.c (expand_or_defer_fn_1): Clone after setting linkage.\n+\n 2013-12-23  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/59111"}, {"sha": "a184dcc0c1bcb6b9588f3cc939132f1f75e08ee5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -10185,7 +10185,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t    /* The TYPE_DECL is \"abstract\" because there will be\n \t       clones of this constructor/destructor, and there will\n \t       be copies of this TYPE_DECL generated in those\n-\t       clones.  */\n+\t       clones.  The decloning optimization (for space) may\n+               revert this subsequently if it determines that\n+               the clones should share a common implementation.  */\n \t    DECL_ABSTRACT (decl) = 1;\n \t}\n       else if (current_class_type"}, {"sha": "d99062dcb5ec4e3244c61aaa2bd0dc49e17582d0", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 14, "deletions": 29, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -689,13 +689,6 @@ write_mangled_name (const tree decl, bool top_level)\n     mangled_name:;\n       write_string (\"_Z\");\n       write_encoding (decl);\n-      if (DECL_LANG_SPECIFIC (decl)\n-\t  && (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl)\n-\t      || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl)))\n-\t/* We need a distinct mangled name for these entities, but\n-\t   we should never actually output it.  So, we append some\n-\t   characters the assembler won't like.  */\n-\twrite_string (\" *INTERNAL* \");\n     }\n }\n \n@@ -1653,25 +1646,21 @@ write_identifier (const char *identifier)\n \t\t    ::= C2   # base object constructor\n \t\t    ::= C3   # complete object allocating constructor\n \n-   Currently, allocating constructors are never used.\n-\n-   We also need to provide mangled names for the maybe-in-charge\n-   constructor, so we treat it here too.  mangle_decl_string will\n-   append *INTERNAL* to that, to make sure we never emit it.  */\n+   Currently, allocating constructors are never used.  */\n \n static void\n write_special_name_constructor (const tree ctor)\n {\n   if (DECL_BASE_CONSTRUCTOR_P (ctor))\n     write_string (\"C2\");\n+  /* This is the old-style \"[unified]\" constructor.\n+     In some cases, we may emit this function and call\n+     it from the clones in order to share code and save space.  */\n+  else if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (ctor))\n+    write_string (\"C4\");\n   else\n     {\n-      gcc_assert (DECL_COMPLETE_CONSTRUCTOR_P (ctor)\n-\t\t  /* Even though we don't ever emit a definition of\n-\t\t     the old-style destructor, we still have to\n-\t\t     consider entities (like static variables) nested\n-\t\t     inside it.  */\n-\t\t  || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (ctor));\n+      gcc_assert (DECL_COMPLETE_CONSTRUCTOR_P (ctor));\n       write_string (\"C1\");\n     }\n }\n@@ -1681,11 +1670,7 @@ write_special_name_constructor (const tree ctor)\n \n      <special-name> ::= D0 # deleting (in-charge) destructor\n \t\t    ::= D1 # complete object (in-charge) destructor\n-\t\t    ::= D2 # base object (not-in-charge) destructor\n-\n-   We also need to provide mangled names for the maybe-incharge\n-   destructor, so we treat it here too.  mangle_decl_string will\n-   append *INTERNAL* to that, to make sure we never emit it.  */\n+\t\t    ::= D2 # base object (not-in-charge) destructor  */\n \n static void\n write_special_name_destructor (const tree dtor)\n@@ -1694,14 +1679,14 @@ write_special_name_destructor (const tree dtor)\n     write_string (\"D0\");\n   else if (DECL_BASE_DESTRUCTOR_P (dtor))\n     write_string (\"D2\");\n+  else if (DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (dtor))\n+    /* This is the old-style \"[unified]\" destructor.\n+       In some cases, we may emit this function and call\n+       it from the clones in order to share code and save space.  */\n+    write_string (\"D4\");\n   else\n     {\n-      gcc_assert (DECL_COMPLETE_DESTRUCTOR_P (dtor)\n-\t\t  /* Even though we don't ever emit a definition of\n-\t\t     the old-style destructor, we still have to\n-\t\t     consider entities (like static variables) nested\n-\t\t     inside it.  */\n-\t\t  || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (dtor));\n+      gcc_assert (DECL_COMPLETE_DESTRUCTOR_P (dtor));\n       write_string (\"D1\");\n     }\n }"}, {"sha": "e79a9221a99e7eafff33b384462c7b77784b5287", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -477,7 +477,8 @@ trivial_fn_p (tree fn)\n     return false;\n \n   /* If fn is a clone, get the primary variant.  */\n-  fn = DECL_ORIGIN (fn);\n+  if (tree prim = DECL_CLONED_FUNCTION (fn))\n+    fn = prim;\n   return type_has_trivial_fn (DECL_CONTEXT (fn), special_function_p (fn));\n }\n "}, {"sha": "40494f27a5598eab51fb7a84cfec2a613061a955", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 259, "deletions": 34, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -193,30 +193,40 @@ cdtor_comdat_group (tree complete, tree base)\n   return get_identifier (grp_name);\n }\n \n-/* FN is a function that has a complete body.  Clone the body as\n-   necessary.  Returns nonzero if there's no longer any need to\n-   process the main body.  */\n+/* Returns true iff we can make the base and complete [cd]tor aliases of\n+   the same symbol rather than separate functions.  */\n \n-bool\n-maybe_clone_body (tree fn)\n+static bool\n+can_alias_cdtor (tree fn)\n {\n-  tree comdat_group = NULL_TREE;\n-  tree clone;\n-  tree fns[3];\n-  bool first = true;\n-  bool in_charge_parm_used;\n-  int idx;\n-  bool need_alias = false;\n+#ifndef ASM_OUTPUT_DEF\n+  /* If aliases aren't supported by the assembler, fail.  */\n+  return false;\n+#endif\n+  /* We can't use an alias if there are virtual bases.  */\n+  if (CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)))\n+    return false;\n+  /* ??? Why not use aliases with -frepo?  */\n+  if (flag_use_repository)\n+    return false;\n+  gcc_assert (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n+\t      || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn));\n+  /* Don't use aliases for weak/linkonce definitions unless we can put both\n+     symbols in the same COMDAT group.  */\n+  return (DECL_INTERFACE_KNOWN (fn)\n+\t  && (SUPPORTS_ONE_ONLY || !DECL_WEAK (fn))\n+\t  && (!DECL_ONE_ONLY (fn)\n+\t      || (HAVE_COMDAT_GROUP && DECL_WEAK (fn))));\n+}\n \n-  /* We only clone constructors and destructors.  */\n-  if (!DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n-      && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n-    return 0;\n+/* FN is a [cd]tor, fns is a pointer to an array of length 3.  Fill fns\n+   with pointers to the base, complete, and deleting variants.  */\n \n-  /* Emit the DWARF1 abstract instance.  */\n-  (*debug_hooks->deferred_inline_function) (fn);\n+static void\n+populate_clone_array (tree fn, tree *fns)\n+{\n+  tree clone;\n \n-  in_charge_parm_used = CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)) != NULL;\n   fns[0] = NULL_TREE;\n   fns[1] = NULL_TREE;\n   fns[2] = NULL_TREE;\n@@ -234,6 +244,206 @@ maybe_clone_body (tree fn)\n       fns[2] = clone;\n     else\n       gcc_unreachable ();\n+}\n+\n+/* FN is a constructor or destructor, and there are FUNCTION_DECLs\n+   cloned from it nearby.  Instead of cloning this body, leave it\n+   alone and create tiny one-call bodies for the cloned\n+   FUNCTION_DECLs.  These clones are sibcall candidates, and their\n+   resulting code will be very thunk-esque.  */\n+\n+static bool\n+maybe_thunk_body (tree fn, bool force)\n+{\n+  tree bind, block, call, clone, clone_result, fn_parm, fn_parm_typelist;\n+  tree last_arg, modify, *args;\n+  int parmno, vtt_parmno, max_parms;\n+  tree fns[3];\n+\n+  if (!force && !flag_declone_ctor_dtor)\n+    return 0;\n+\n+  /* If function accepts variable arguments, give up.  */\n+  last_arg = tree_last (TYPE_ARG_TYPES (TREE_TYPE (fn)));\n+  if (last_arg != void_list_node)\n+    return 0;\n+\n+  /* If we got this far, we've decided to turn the clones into thunks.  */\n+\n+  /* We're going to generate code for fn, so it is no longer \"abstract.\"\n+     Also make the unified ctor/dtor private to either the translation unit\n+     (for non-vague linkage ctors) or the COMDAT group (otherwise).  */\n+\n+  populate_clone_array (fn, fns);\n+  DECL_ABSTRACT (fn) = false;\n+  if (!DECL_WEAK (fn))\n+    {\n+      TREE_PUBLIC (fn) = false;\n+      DECL_EXTERNAL (fn) = false;\n+      DECL_INTERFACE_KNOWN (fn) = true;\n+    }\n+  else if (HAVE_COMDAT_GROUP)\n+    {\n+      tree comdat_group = cdtor_comdat_group (fns[1], fns[0]);\n+      DECL_COMDAT_GROUP (fns[0]) = comdat_group;\n+      symtab_add_to_same_comdat_group (cgraph_get_create_node (fns[1]),\n+\t\t\t\t       cgraph_get_create_node (fns[0]));\n+      symtab_add_to_same_comdat_group (symtab_get_node (fn),\n+\t\t\t\t       symtab_get_node (fns[0]));\n+      if (fns[2])\n+\t/* If *[CD][12]* dtors go into the *[CD]5* comdat group and dtor is\n+\t   virtual, it goes into the same comdat group as well.  */\n+\tsymtab_add_to_same_comdat_group (cgraph_get_create_node (fns[2]),\n+\t\t\t\t\t symtab_get_node (fns[0]));\n+      TREE_PUBLIC (fn) = false;\n+      DECL_EXTERNAL (fn) = false;\n+      DECL_INTERFACE_KNOWN (fn) = true;\n+      /* function_and_variable_visibility doesn't want !PUBLIC decls to\n+\t have these flags set.  */\n+      DECL_WEAK (fn) = false;\n+      DECL_COMDAT (fn) = false;\n+    }\n+\n+  /* Find the vtt_parm, if present.  */\n+  for (vtt_parmno = -1, parmno = 0, fn_parm = DECL_ARGUMENTS (fn);\n+       fn_parm;\n+       ++parmno, fn_parm = TREE_CHAIN (fn_parm))\n+    {\n+      if (DECL_ARTIFICIAL (fn_parm)\n+\t  && DECL_NAME (fn_parm) == vtt_parm_identifier)\n+\t{\n+\t  /* Compensate for removed in_charge parameter.  */\n+\t  vtt_parmno = parmno;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Allocate an argument buffer for build_cxx_call().\n+     Make sure it is large enough for any of the clones.  */\n+  max_parms = 0;\n+  FOR_EACH_CLONE (clone, fn)\n+    {\n+      int length = list_length (DECL_ARGUMENTS (fn));\n+      if (length > max_parms)\n+        max_parms = length;\n+    }\n+  args = (tree *) alloca (max_parms * sizeof (tree));\n+\n+  /* We know that any clones immediately follow FN in TYPE_METHODS.  */\n+  FOR_EACH_CLONE (clone, fn)\n+    {\n+      tree clone_parm;\n+\n+      /* If we've already generated a body for this clone, avoid\n+\t duplicating it.  (Is it possible for a clone-list to grow after we\n+\t first see it?)  */\n+      if (DECL_SAVED_TREE (clone) || TREE_ASM_WRITTEN (clone))\n+\tcontinue;\n+\n+      /* Start processing the function.  */\n+      start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n+\n+      if (clone == fns[2])\n+\t{\n+\t  for (clone_parm = DECL_ARGUMENTS (clone); clone_parm;\n+\t       clone_parm = TREE_CHAIN (clone_parm))\n+\t    DECL_ABSTRACT_ORIGIN (clone_parm) = NULL_TREE;\n+\t  /* Build the delete destructor by calling complete destructor and\n+\t     delete function.  */\n+\t  build_delete_destructor_body (clone, fns[1]);\n+\t}\n+      else\n+\t{\n+\t  /* Walk parameter lists together, creating parameter list for\n+\t     call to original function.  */\n+\t  for (parmno = 0,\n+\t\t fn_parm = DECL_ARGUMENTS (fn),\n+\t\t fn_parm_typelist = TYPE_ARG_TYPES (TREE_TYPE (fn)),\n+\t\t clone_parm = DECL_ARGUMENTS (clone);\n+\t       fn_parm;\n+\t       ++parmno,\n+\t\t fn_parm = TREE_CHAIN (fn_parm))\n+\t    {\n+\t      if (parmno == vtt_parmno && ! DECL_HAS_VTT_PARM_P (clone))\n+\t\t{\n+\t\t  gcc_assert (fn_parm_typelist);\n+\t\t  /* Clobber argument with formal parameter type.  */\n+\t\t  args[parmno]\n+\t\t    = convert (TREE_VALUE (fn_parm_typelist),\n+\t\t\t       null_pointer_node);\n+\t\t}\n+\t      else if (parmno == 1 && DECL_HAS_IN_CHARGE_PARM_P (fn))\n+\t\t{\n+\t\t  tree in_charge\n+\t\t    = copy_node (in_charge_arg_for_name (DECL_NAME (clone)));\n+\t\t  args[parmno] = in_charge;\n+\t\t}\n+\t      /* Map other parameters to their equivalents in the cloned\n+\t\t function.  */\n+\t      else\n+\t\t{\n+\t\t  gcc_assert (clone_parm);\n+\t\t  DECL_ABSTRACT_ORIGIN (clone_parm) = NULL;\n+\t\t  args[parmno] = clone_parm;\n+\t\t  clone_parm = TREE_CHAIN (clone_parm);\n+\t\t}\n+\t      if (fn_parm_typelist)\n+\t\tfn_parm_typelist = TREE_CHAIN (fn_parm_typelist);\n+\t    }\n+\n+\t  /* We built this list backwards; fix now.  */\n+\t  mark_used (fn);\n+\t  call = build_cxx_call (fn, parmno, args, tf_warning_or_error);\n+\t  /* Arguments passed to the thunk by invisible reference should\n+\t     be transmitted to the callee unchanged.  Do not create a\n+\t     temporary and invoke the copy constructor.  The thunking\n+\t     transformation must not introduce any constructor calls.  */\n+\t  CALL_FROM_THUNK_P (call) = 1;\n+\t  block = make_node (BLOCK);\n+\t  if (targetm.cxx.cdtor_returns_this ())\n+\t    {\n+\t      clone_result = DECL_RESULT (clone);\n+\t      modify = build2 (MODIFY_EXPR, TREE_TYPE (clone_result),\n+\t\t\t       clone_result, call);\n+\t      add_stmt (modify);\n+\t      BLOCK_VARS (block) = clone_result;\n+\t    }\n+\t  else\n+\t    {\n+\t      add_stmt (call);\n+\t    }\n+\t  bind = c_build_bind_expr (DECL_SOURCE_LOCATION (clone),\n+\t\t\t\t    block, cur_stmt_list);\n+\t  DECL_SAVED_TREE (clone) = push_stmt_list ();\n+\t  add_stmt (bind);\n+\t}\n+\n+      DECL_ABSTRACT_ORIGIN (clone) = NULL;\n+      expand_or_defer_fn (finish_function (0));\n+    }\n+  return 1;\n+}\n+\n+/* FN is a function that has a complete body.  Clone the body as\n+   necessary.  Returns nonzero if there's no longer any need to\n+   process the main body.  */\n+\n+bool\n+maybe_clone_body (tree fn)\n+{\n+  tree comdat_group = NULL_TREE;\n+  tree clone;\n+  tree fns[3];\n+  bool first = true;\n+  int idx;\n+  bool need_alias = false;\n+\n+  /* We only clone constructors and destructors.  */\n+  if (!DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (fn)\n+      && !DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (fn))\n+    return 0;\n+\n+  populate_clone_array (fn, fns);\n \n   /* Remember if we can't have multiple clones for some reason.  We need to\n      check this before we remap local static initializers in clone_body.  */\n@@ -247,9 +457,6 @@ maybe_clone_body (tree fn)\n     {\n       tree parm;\n       tree clone_parm;\n-      int parmno;\n-      bool alias = false;\n-      struct pointer_map_t *decl_map;\n \n       clone = fns[idx];\n       if (!clone)\n@@ -296,26 +503,44 @@ maybe_clone_body (tree fn)\n \t   parm = DECL_CHAIN (parm), clone_parm = DECL_CHAIN (clone_parm))\n \t/* Update this parameter.  */\n \tupdate_cloned_parm (parm, clone_parm, first);\n+    }\n+\n+  bool can_alias = can_alias_cdtor (fn);\n+\n+  /* If we decide to turn clones into thunks, they will branch to fn.\n+     Must have original function available to call.  */\n+  if (!can_alias && maybe_thunk_body (fn, need_alias))\n+    {\n+      pop_from_top_level ();\n+      /* We still need to emit the original function.  */\n+      return 0;\n+    }\n+\n+  /* Emit the DWARF1 abstract instance.  */\n+  (*debug_hooks->deferred_inline_function) (fn);\n+\n+  /* We know that any clones immediately follow FN in the TYPE_METHODS list. */\n+  for (idx = 0; idx < 3; idx++)\n+    {\n+      tree parm;\n+      tree clone_parm;\n+      int parmno;\n+      struct pointer_map_t *decl_map;\n+      bool alias = false;\n+\n+      clone = fns[idx];\n+      if (!clone)\n+\tcontinue;\n \n       /* Start processing the function.  */\n       start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n       /* Tell cgraph if both ctors or both dtors are known to have\n \t the same body.  */\n-      if (!in_charge_parm_used\n+      if (can_alias\n \t  && fns[0]\n \t  && idx == 1\n-\t  && !flag_use_repository\n-\t  && DECL_INTERFACE_KNOWN (fns[0])\n-\t  && (SUPPORTS_ONE_ONLY || !DECL_WEAK (fns[0]))\n-\t  && (!DECL_ONE_ONLY (fns[0])\n-\t      || (HAVE_COMDAT_GROUP\n-\t\t  && DECL_WEAK (fns[0])))\n-\t  && !flag_syntax_only\n-\t  /* Set linkage flags appropriately before\n-\t     cgraph_create_function_alias looks at them.  */\n-\t  && expand_or_defer_fn_1 (clone)\n-\t  && cgraph_same_body_alias (cgraph_get_node (fns[0]),\n+\t  && cgraph_same_body_alias (cgraph_get_create_node (fns[0]),\n \t\t\t\t     clone, fns[0]))\n \t{\n \t  alias = true;"}, {"sha": "1a5948478b4968ab9533c636a1aef69df93fee96", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -3901,20 +3901,6 @@ expand_or_defer_fn_1 (tree fn)\n \n   gcc_assert (DECL_SAVED_TREE (fn));\n \n-  /* If this is a constructor or destructor body, we have to clone\n-     it.  */\n-  if (maybe_clone_body (fn))\n-    {\n-      /* We don't want to process FN again, so pretend we've written\n-\t it out, even though we haven't.  */\n-      TREE_ASM_WRITTEN (fn) = 1;\n-      /* If this is an instantiation of a constexpr function, keep\n-\t DECL_SAVED_TREE for explain_invalid_constexpr_fn.  */\n-      if (!is_instantiation_of_constexpr (fn))\n-\tDECL_SAVED_TREE (fn) = NULL_TREE;\n-      return false;\n-    }\n-\n   /* We make a decision about linkage for these functions at the end\n      of the compilation.  Until that point, we do not want the back\n      end to output them -- but we do want it to see the bodies of\n@@ -3962,6 +3948,20 @@ expand_or_defer_fn_1 (tree fn)\n \t}\n     }\n \n+  /* If this is a constructor or destructor body, we have to clone\n+     it.  */\n+  if (maybe_clone_body (fn))\n+    {\n+      /* We don't want to process FN again, so pretend we've written\n+\t it out, even though we haven't.  */\n+      TREE_ASM_WRITTEN (fn) = 1;\n+      /* If this is an instantiation of a constexpr function, keep\n+\t DECL_SAVED_TREE for explain_invalid_constexpr_fn.  */\n+      if (!is_instantiation_of_constexpr (fn))\n+\tDECL_SAVED_TREE (fn) = NULL_TREE;\n+      return false;\n+    }\n+\n   /* There's no reason to do any of the work here if we're only doing\n      semantic analysis; this code just generates RTL.  */\n   if (flag_syntax_only)"}, {"sha": "60675c585e010e6c5b3d5e50fbf494322e0971a2", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -7339,6 +7339,18 @@ branch-less equivalents.\n \n Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -fdeclone-ctor-dtor\n+@opindex fdeclone-ctor-dtor\n+The C++ ABI requires multiple entry points for constructors and\n+destructors: one for a base subobject, one for a complete object, and\n+one for a virtual destructor that calls operator delete afterwards.\n+For a hierarchy with virtual bases, the base and complete variants are\n+clones, which means two copies of the function.  With this option, the\n+base and complete variants are changed to be thunks that call a common\n+implementation.\n+\n+Enabled by @option{-Os}.\n+\n @item -fdelete-null-pointer-checks\n @opindex fdelete-null-pointer-checks\n Assume that programs cannot safely dereference null pointers, and that"}, {"sha": "b484d053f163d9b42e0e339b53ccbbd7dc2d1672", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -437,6 +437,10 @@ determine_versionability (struct cgraph_node *node)\n \t coexist, but that may not be worth the effort.  */\n       reason = \"function has SIMD clones\";\n     }\n+  /* Don't clone decls local to a comdat group; it breaks and for C++\n+     decloned constructors, inlining is always better anyway.  */\n+  else if (symtab_comdat_local_p (node))\n+    reason = \"comdat-local function\";\n \n   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)\n     fprintf (dump_file, \"Function %s/%i is not versionable, reason: %s.\\n\","}, {"sha": "21e52a193ffaa43b3cbd54012905a1ec0d3365fd", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -2796,6 +2796,11 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n     }\n   estimate_function_body_sizes (node, early);\n \n+  for (e = node->callees; e; e = e->next_callee)\n+    if (symtab_comdat_local_p (e->callee))\n+      break;\n+  node->calls_comdat_local = (e != NULL);\n+\n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   info->time = info->self_time;\n   info->size = info->self_size;"}, {"sha": "71d7800cea1245ad9eedf59d592f3306c99cb1e6", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -272,6 +272,18 @@ inline_call (struct cgraph_edge *e, bool update_original,\n    inline_update_overall_summary (to);\n   new_size = inline_summary (to)->size;\n \n+  if (callee->calls_comdat_local)\n+    to->calls_comdat_local = true;\n+  else if (to->calls_comdat_local && symtab_comdat_local_p (callee))\n+    {\n+      struct cgraph_edge *se = to->callees;\n+      for (; se; se = se->next_callee)\n+\tif (se->inline_failed && symtab_comdat_local_p (se->callee))\n+\t  break;\n+      if (se == NULL)\n+\tto->calls_comdat_local = false;\n+    }\n+\n #ifdef ENABLE_CHECKING\n   /* Verify that estimated growth match real growth.  Allow off-by-one\n      error due to INLINE_SIZE_SCALE roudoff errors.  */\n@@ -369,7 +381,6 @@ save_inline_function_body (struct cgraph_node *node)\n   /* The function will be short lived and removed after we inline all the clones,\n      but make it internal so we won't confuse ourself.  */\n   DECL_EXTERNAL (first_clone->decl) = 0;\n-  DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n   TREE_PUBLIC (first_clone->decl) = 0;\n   DECL_COMDAT (first_clone->decl) = 0;\n   first_clone->ipa_transforms_to_apply.release ();"}, {"sha": "f6a26a882e694410111c597e569e4ced405f4d66", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -241,7 +241,7 @@ report_inline_failed_reason (struct cgraph_edge *e)\n \n    if REPORT is true, output reason to the dump file.  \n \n-   if DISREGARD_LIMITES is true, ignore size limits.*/\n+   if DISREGARD_LIMITS is true, ignore size limits.*/\n \n static bool\n can_inline_edge_p (struct cgraph_edge *e, bool report,\n@@ -271,6 +271,11 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n     }\n+  else if (callee->calls_comdat_local)\n+    {\n+      e->inline_failed = CIF_USES_COMDAT_LOCAL;\n+      inlinable = false;\n+    }\n   else if (!inline_summary (callee)->inlinable \n \t   || (caller_cfun && fn_contains_cilk_spawn_p (caller_cfun)))\n     {"}, {"sha": "3c19288f26cd7a2a55f4aaae145d24ab36326859", "filename": "gcc/ipa.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -362,14 +362,17 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t      enqueue_node (origin_node, &first, reachable);\n \t    }\n \t  /* If any symbol in a comdat group is reachable, force\n-\t     all other in the same comdat group to be also reachable.  */\n+\t     all externally visible symbols in the same comdat\n+\t     group to be reachable as well.  Comdat-local symbols\n+\t     can be discarded if all uses were inlined.  */\n \t  if (node->same_comdat_group)\n \t    {\n \t      symtab_node *next;\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n-\t\tif (!pointer_set_insert (reachable, next))\n+\t\tif (!symtab_comdat_local_p (next)\n+\t\t    && !pointer_set_insert (reachable, next))\n \t\t  enqueue_node (next, &first, reachable);\n \t    }\n \t  /* Mark references as reachable.  */\n@@ -969,14 +972,14 @@ function_and_variable_visibility (bool whole_program)\n \t  node->unique_name = ((node->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t      || node->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n \t\t\t\t      && TREE_PUBLIC (node->decl));\n-\t  symtab_make_decl_local (node->decl);\n \t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  if (node->same_comdat_group)\n+\t  if (node->same_comdat_group && TREE_PUBLIC (node->decl))\n \t    /* cgraph_externally_visible_p has already checked all other nodes\n \t       in the group and they will all be made local.  We need to\n \t       dissolve the group at once so that the predicate does not\n \t       segfault though. */\n \t    symtab_dissolve_same_comdat_group_list (node);\n+\t  symtab_make_decl_local (node->decl);\n \t}\n \n       if (node->thunk.thunk_p"}, {"sha": "7834ed04160b97311bfc5b1721c41f3c21895812", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -518,6 +518,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n   bp_pack_value (&bp, node->tm_clone, 1);\n+  bp_pack_value (&bp, node->calls_comdat_local, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n \t        LDPR_NUM_KNOWN, node->resolution);\n@@ -993,6 +994,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n   node->tm_clone = bp_unpack_value (bp, 1);\n+  node->calls_comdat_local = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);"}, {"sha": "8d36cae7b2712caae13214a2210e9f414b629e27", "filename": "gcc/symtab.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -538,6 +538,10 @@ symtab_dissolve_same_comdat_group_list (symtab_node *node)\n     {\n       next = n->same_comdat_group;\n       n->same_comdat_group = NULL;\n+      /* Clear DECL_COMDAT_GROUP for comdat locals, since\n+         make_decl_local doesn't.  */\n+      if (!TREE_PUBLIC (n->decl))\n+\tDECL_COMDAT_GROUP (n->decl) = NULL_TREE;\n       n = next;\n     }\n   while (n != node);\n@@ -844,6 +848,21 @@ verify_symtab_base (symtab_node *node)\n \t  n = n->same_comdat_group;\n \t}\n       while (n != node);\n+      if (symtab_comdat_local_p (node))\n+\t{\n+\t  struct ipa_ref_list *refs = &node->ref_list;\n+\t  struct ipa_ref *ref;\n+\t  for (int i = 0; ipa_ref_list_referring_iterate (refs, i, ref); ++i)\n+\t    {\n+\t      if (!symtab_in_same_comdat_p (ref->referring, node))\n+\t\t{\n+\t\t  error (\"comdat-local symbol referred to by %s outside its \"\n+\t\t\t \"comdat\",\n+\t\t\t identifier_to_locale (ref->referring->name()));\n+\t\t  error_found = true;\n+\t\t}\n+\t    }\n+\t}\n     }\n   return error_found;\n }\n@@ -911,6 +930,10 @@ symtab_make_decl_local (tree decl)\n {\n   rtx rtl, symbol;\n \n+  /* Avoid clearing DECL_COMDAT_GROUP on comdat-local decls.  */\n+  if (TREE_PUBLIC (decl) == 0)\n+    return;\n+\n   if (TREE_CODE (decl) == VAR_DECL)\n     DECL_COMMON (decl) = 0;\n   else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);"}, {"sha": "3be8e3114873ad4eeba1e7ac2333cf6df5869b79", "filename": "gcc/testsuite/g++.dg/ext/label13a.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel13a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel13a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel13a.C?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -0,0 +1,25 @@\n+// PR c++/41090\n+// { dg-do run }\n+// { dg-options \"-save-temps\" }\n+// { dg-final { scan-assembler \"_ZN1CC4Ev\" } }\n+// { dg-final cleanup-saved-temps }\n+\n+int i;\n+struct A { A() {} };\n+struct C: virtual A\n+{\n+  C();\n+};\n+\n+C::C()\n+{\n+  static void *labelref = &&label;\n+  goto *labelref;\n+ label: i = 1;\n+}\n+\n+int main()\n+{\n+  C c;\n+  return (i != 1);\n+}"}, {"sha": "1f935b7e399a3991bc0b8b4bf6fb0afd75fe7a38", "filename": "gcc/testsuite/g++.dg/opt/declone1.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdeclone1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdeclone1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fdeclone1.C?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -0,0 +1,21 @@\n+// { dg-options \"-fdeclone-ctor-dtor -O3\" }\n+\n+struct V {};\n+\n+template <class T>\n+struct A: virtual V {\n+  static A* p;\n+  A();\n+};\n+\n+template <class T>\n+A<T>::A()\n+{\n+  if (!p)\n+    p = new A();\n+}\n+\n+int main()\n+{\n+  A<int> a;\n+}"}, {"sha": "a06aec0e47834ae4a35d24838dab88e9483b5212", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1,3 +1,10 @@\n+2013-12-23  Bill Maddox  <maddox@google.com>\n+\n+\t* demangle.h (enum gnu_v3_ctor_kinds):\n+\tAdded literal gnu_v3_unified_ctor.\n+\t(enum gnu_v3_ctor_kinds):\n+\tAdded literal gnu_v3_unified_dtor.\n+\n 2013-12-04  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* longlong.h: New file."}, {"sha": "bbad71bd8c742519283ebeaf17e9686b71c2b140", "filename": "include/demangle.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/include%2Fdemangle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/include%2Fdemangle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fdemangle.h?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -173,6 +173,10 @@ enum gnu_v3_ctor_kinds {\n   gnu_v3_complete_object_ctor = 1,\n   gnu_v3_base_object_ctor,\n   gnu_v3_complete_object_allocating_ctor,\n+  /* These are not part of the V3 ABI.  Unified constructors are generated\n+     as a speed-for-space optimization when the -fdeclone-ctor-dtor option\n+     is used, and are always internal symbols.  */\n+  gnu_v3_unified_ctor,\n   gnu_v3_object_ctor_group\n };\n \n@@ -188,6 +192,10 @@ enum gnu_v3_dtor_kinds {\n   gnu_v3_deleting_dtor = 1,\n   gnu_v3_complete_object_dtor,\n   gnu_v3_base_object_dtor,\n+  /* These are not part of the V3 ABI.  Unified destructors are generated\n+     as a speed-for-space optimization when the -fdeclone-ctor-dtor option\n+     is used, and are always internal symbols.  */\n+  gnu_v3_unified_dtor,\n   gnu_v3_object_dtor_group\n };\n "}, {"sha": "1e8d0fe66385de61011ef9006fc7a020fdce9417", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -1,3 +1,9 @@\n+2013-12-23  Bill Maddox  <maddox@google.com>\n+\n+\t* cp-demangle.c (cplus_demangle_fill_ctor,cplus_demangle_fill_dtor):\n+\tHandle unified ctor/dtor.\n+\t(d_ctor_dtor_name): Handle unified ctor/dtor.\n+\n 2013-11-22  Cary Coutant  <ccoutant@google.com>\n     \n \tPR other/59195"}, {"sha": "7f51268e1151d262c55fb6735efeae73b60b7f32", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f26ac87486d92b964b0c56823beabe28e7dcef7/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f26ac87486d92b964b0c56823beabe28e7dcef7/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=1f26ac87486d92b964b0c56823beabe28e7dcef7", "patch": "@@ -2107,6 +2107,9 @@ d_ctor_dtor_name (struct d_info *di)\n \t  case '3':\n \t    kind = gnu_v3_complete_object_allocating_ctor;\n \t    break;\n+          case '4':\n+\t    kind = gnu_v3_unified_ctor;\n+\t    break;\n \t  case '5':\n \t    kind = gnu_v3_object_ctor_group;\n \t    break;\n@@ -2132,6 +2135,10 @@ d_ctor_dtor_name (struct d_info *di)\n \t  case '2':\n \t    kind = gnu_v3_base_object_dtor;\n \t    break;\n+          /*  digit '3' is not used */\n+\t  case '4':\n+\t    kind = gnu_v3_unified_dtor;\n+\t    break;\n \t  case '5':\n \t    kind = gnu_v3_object_dtor_group;\n \t    break;"}]}