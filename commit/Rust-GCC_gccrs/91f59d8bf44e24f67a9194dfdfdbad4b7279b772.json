{"sha": "91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFmNTlkOGJmNDRlMjRmNjdhOTE5NGRmZGZkYmFkNGI3Mjc5Yjc3Mg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2011-11-29T19:42:44Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2011-11-29T19:42:44Z"}, "message": "re PR target/50123 (cmpxchg generated for atomic and with zero/or with -1)\n\n2011-11-29  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR target/50123\n\t* optabs.c (maybe_optimize_fetch_op): New.  Look for more optimal\n\tinstructions for a FECTH_OP or OP_FECTH sequence.\n\t(expand_atomic_fetch_op): Call maybe_optimize_fetch_op.\n\t* testsuite/gcc.dg/atomic-op-optimize.c: New.  Test for optimizations.\n\nFrom-SVN: r181815", "tree": {"sha": "0941a5f3f350e92aa547e0c78f48f37d4ee5250d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0941a5f3f350e92aa547e0c78f48f37d4ee5250d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/comments", "author": null, "committer": null, "parents": [{"sha": "421ecf992e5c8971c4b47b39e71bc622527b859d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/421ecf992e5c8971c4b47b39e71bc622527b859d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/421ecf992e5c8971c4b47b39e71bc622527b859d"}], "stats": {"total": 72, "additions": 72, "deletions": 0}, "files": [{"sha": "921b4f930498bcd62719231d813ed38d5177bcec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "patch": "@@ -1,3 +1,10 @@\n+2011-11-29  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR target/50123\n+\t* optabs.c (maybe_optimize_fetch_op): New.  Look for more optimal\n+\tinstructions for a FECTH_OP or OP_FECTH sequence.\n+\t(expand_atomic_fetch_op): Call maybe_optimize_fetch_op.\n+\n 2011-11-29  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sync.md (UNSPEC_LDA, UNSPEC_STA): New unspecs."}, {"sha": "c3f81dfe2d22f5613caf9b62af052db3b9447b7b", "filename": "gcc/optabs.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "patch": "@@ -7943,6 +7943,41 @@ get_atomic_op_for_code (struct atomic_op_functions *op, enum rtx_code code)\n     }\n }\n \n+/* See if there is a more optimal way to implement the operation \"*MEM CODE VAL\"\n+   using memory order MODEL.  If AFTER is true the operation needs to return\n+   the value of *MEM after the operation, otherwise the previous value.  \n+   TARGET is an optional place to place the result.  The result is unused if\n+   it is const0_rtx.\n+   Return the result if there is a better sequence, otherwise NULL_RTX.  */\n+\n+static rtx\n+maybe_optimize_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n+\t\t\t enum memmodel model, bool after)\n+{\n+  /* If the value is prefetched, or not used, it may be possible to replace\n+     the sequence with a native exchange operation.  */\n+  if (!after || target == const0_rtx)\n+    {\n+      /* fetch_and (&x, 0, m) can be replaced with exchange (&x, 0, m).  */\n+      if (code == AND && val == const0_rtx)\n+        {\n+\t  if (target == const0_rtx)\n+\t    target = gen_reg_rtx (GET_MODE (mem));\n+\t  return maybe_emit_atomic_exchange (target, mem, val, model);\n+\t}\n+\n+      /* fetch_or (&x, -1, m) can be replaced with exchange (&x, -1, m).  */\n+      if (code == IOR && val == constm1_rtx)\n+        {\n+\t  if (target == const0_rtx)\n+\t    target = gen_reg_rtx (GET_MODE (mem));\n+\t  return maybe_emit_atomic_exchange (target, mem, val, model);\n+\t}\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n /* Try to emit an instruction for a specific operation varaition. \n    OPTAB contains the OP functions.\n    TARGET is an optional place to return the result. const0_rtx means unused.\n@@ -8028,6 +8063,11 @@ expand_atomic_fetch_op (rtx target, rtx mem, rtx val, enum rtx_code code,\n \n   get_atomic_op_for_code (&optab, code);\n \n+  /* Check to see if there are any better instructions.  */\n+  result = maybe_optimize_fetch_op (target, mem, val, code, model, after);\n+  if (result)\n+    return result;\n+\n   /* Check for the case where the result isn't used and try those patterns.  */\n   if (unused_result)\n     {"}, {"sha": "a5a39e3c4d13db15cea153fd441e58c4ff7fb83d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "patch": "@@ -1,3 +1,8 @@\n+2011-11-29  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR target/50123\n+\t* gcc.dg/atomic-op-optimize.c: New.  Test for optimizations.\n+\n 2011-11-29  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/ppc-target-4.c: New file to test target"}, {"sha": "d2e960a0ceee044e240d95b65146edc8d3dbefc6", "filename": "gcc/testsuite/gcc.dg/atomic-op-optimize.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91f59d8bf44e24f67a9194dfdfdbad4b7279b772/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic-op-optimize.c?ref=91f59d8bf44e24f67a9194dfdfdbad4b7279b772", "patch": "@@ -0,0 +1,20 @@\n+/* Both these atomic operations should be optimized to an exchange operation.\n+   Test that it at happens on x86 by making sure there are 2 xchg's and no\n+   compare_exchange loop.  */\n+\n+/* { dg-require-effective-target sync_int_long } */\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-assembler-times \"cmpxchg\" 0 } } */\n+/* { dg-final { scan-assembler-times \"xchg\" 2 } } */\n+\n+int x;\n+\n+int f()\n+{\n+  return __atomic_fetch_and (&x, 0, __ATOMIC_RELAXED);\n+}\n+\n+int g()\n+{\n+  return __atomic_fetch_or (&x, -1, __ATOMIC_RELAXED);\n+}"}]}