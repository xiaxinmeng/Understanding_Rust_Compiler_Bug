{"sha": "0db1c3863d5167dd47e5a0ab4a714ace875a9202", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRiMWMzODYzZDUxNjdkZDQ3ZTVhMGFiNGE3MTRhY2U4NzVhOTIwMg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2018-08-21T14:49:34Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-08-21T14:49:34Z"}, "message": "[Ada] Spurious crash on expression function as completion with contracts\n\nThis patch fixes a compiler abort on an expression function that is a\ncompletion of a subprogram with preconditions. The problem is caused by\nthe presence of types in the precondition that are not frozen when the\nsubprogram body constructed for the expression function receives the\ncode that enforces the precondition. These types must be frozen before\nthe contract is expanded, so the freeze nodes for these types appear in\nthe proper scope. This is analogous to what is done with type references\nthat appear in the original expression of the expression function.\n\n2018-08-21  Ed Schonberg  <schonberg@adacore.com>\n\ngcc/ada/\n\n\t* sem_ch6.adb: Remove Freeze_Expr_Types.\n\t* freeze.ads, freeze.adb (Freeze_Expr_Types): Moved from\n\tsem_ch6.adb, and extended to handle other expressions that may\n\tcontain unfrozen types that must be frozen in their proper\n\tscopes.\n\t* contracts.adb (Analyze_Entry_Or_Subprogram_Contract): If the\n\tcontract is for the generated body of an expression function\n\tthat is a completion, traverse the expressions for pre- and\n\tpostconditions to freeze all types before adding the contract\n\tcode within the subprogram body.\n\ngcc/testsuite/\n\n\t* gnat.dg/expr_func6.adb, gnat.dg/expr_func6.ads: New testcase.\n\nFrom-SVN: r263734", "tree": {"sha": "c4a0ebe971f279ef50bb7d01b5146d9d0b097b64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4a0ebe971f279ef50bb7d01b5146d9d0b097b64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0db1c3863d5167dd47e5a0ab4a714ace875a9202", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db1c3863d5167dd47e5a0ab4a714ace875a9202", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0db1c3863d5167dd47e5a0ab4a714ace875a9202", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0db1c3863d5167dd47e5a0ab4a714ace875a9202/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b1c45479aa2fd573063e370005f0c377e8b888e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b1c45479aa2fd573063e370005f0c377e8b888e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b1c45479aa2fd573063e370005f0c377e8b888e"}], "stats": {"total": 500, "additions": 291, "deletions": 209}, "files": [{"sha": "ca38083e42c774f7313522803e60ddd07f731723", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -1,3 +1,16 @@\n+2018-08-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Remove Freeze_Expr_Types.\n+\t* freeze.ads, freeze.adb (Freeze_Expr_Types): Moved from\n+\tsem_ch6.adb, and extended to handle other expressions that may\n+\tcontain unfrozen types that must be frozen in their proper\n+\tscopes.\n+\t* contracts.adb (Analyze_Entry_Or_Subprogram_Contract): If the\n+\tcontract is for the generated body of an expression function\n+\tthat is a completion, traverse the expressions for pre- and\n+\tpostconditions to freeze all types before adding the contract\n+\tcode within the subprogram body.\n+\n 2018-08-21  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch10.adb: Remove the with and use clause for unit Ghost."}, {"sha": "e70765a06e8136df7e8e66829fad78effd83bfd3", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -32,6 +32,7 @@ with Errout;   use Errout;\n with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n+with Freeze;   use Freeze;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -47,6 +48,7 @@ with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n+with Stand;    use Stand;\n with Stringt;  use Stringt;\n with SCIL_LL;  use SCIL_LL;\n with Tbuild;   use Tbuild;\n@@ -589,14 +591,40 @@ package body Contracts is\n          if Skip_Assert_Exprs then\n             null;\n \n-         --  Otherwise analyze the pre/postconditions\n+         --  Otherwise analyze the pre/postconditions. Their expressions\n+         --  might include references to types that are not frozen yet,\n+         --  in the case where the body is a rewritten expression function\n+         --  that is a completion, so freeze all types within before\n+         --  constructing the contract code.\n \n          else\n-            Prag := Pre_Post_Conditions (Items);\n-            while Present (Prag) loop\n-               Analyze_Pre_Post_Condition_In_Decl_Part (Prag, Freeze_Id);\n-               Prag := Next_Pragma (Prag);\n-            end loop;\n+            declare\n+               Bod : Node_Id;\n+               Freeze_Types : Boolean := False;\n+            begin\n+               if Present (Freeze_Id) then\n+                  Bod := Unit_Declaration_Node (Freeze_Id);\n+                  if Nkind (Bod) = N_Subprogram_Body\n+                    and then Was_Expression_Function (Bod)\n+                    and then Ekind (Subp_Id) = E_Function\n+                    and then Chars (Subp_Id) = Chars (Freeze_Id)\n+                    and then Subp_Id /= Freeze_Id\n+                  then\n+                     Freeze_Types := True;\n+                  end if;\n+               end if;\n+\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Freeze_Types then\n+                     Freeze_Expr_Types (Subp_Id, Standard_Boolean,\n+                       Expression (Corresponding_Aspect (Prag)), Bod);\n+                  end if;\n+\n+                  Analyze_Pre_Post_Condition_In_Decl_Part (Prag, Freeze_Id);\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end;\n          end if;\n \n          --  Analyze contract-cases and test-cases"}, {"sha": "d7f3f58e33cfcbd0d3d25a9f9f7697fe98b2e58a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -49,6 +49,7 @@ with Rtsfind;   use Rtsfind;\n with Sem;       use Sem;\n with Sem_Aux;   use Sem_Aux;\n with Sem_Cat;   use Sem_Cat;\n+with Sem_Ch3;   use Sem_Ch3;\n with Sem_Ch6;   use Sem_Ch6;\n with Sem_Ch7;   use Sem_Ch7;\n with Sem_Ch8;   use Sem_Ch8;\n@@ -7643,6 +7644,209 @@ package body Freeze is\n       In_Spec_Expression := In_Spec_Exp;\n    end Freeze_Expression;\n \n+   -----------------------\n+   -- Freeze_Expr_Types --\n+   -----------------------\n+\n+   procedure Freeze_Expr_Types\n+     (Def_Id : Entity_Id;\n+      Typ    : Entity_Id;\n+      Expr   : Node_Id;\n+      N      : Node_Id)\n+   is\n+\n+      function Cloned_Expression return Node_Id;\n+      --  Build a duplicate of the expression of the return statement that\n+      --  has no defining entities shared with the original expression.\n+\n+      function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result;\n+      --  Freeze all types referenced in the subtree rooted at Node\n+\n+      -----------------------\n+      -- Cloned_Expression --\n+      -----------------------\n+\n+      function Cloned_Expression return Node_Id is\n+         function Clone_Id (Node : Node_Id) return Traverse_Result;\n+         --  Tree traversal routine that clones the defining identifier of\n+         --  iterator and loop parameter specification nodes.\n+\n+         --------------\n+         -- Clone_Id --\n+         --------------\n+\n+         function Clone_Id (Node : Node_Id) return Traverse_Result is\n+         begin\n+            if Nkind_In (Node, N_Iterator_Specification,\n+                               N_Loop_Parameter_Specification)\n+            then\n+               Set_Defining_Identifier (Node,\n+                 New_Copy (Defining_Identifier (Node)));\n+            end if;\n+\n+            return OK;\n+         end Clone_Id;\n+\n+         procedure Clone_Def_Ids is new Traverse_Proc (Clone_Id);\n+\n+         --  Local variable\n+\n+         Dup_Expr : constant Node_Id := New_Copy_Tree (Expr);\n+\n+      --  Start of processing for Cloned_Expression\n+\n+      begin\n+         --  We must duplicate the expression with semantic information to\n+         --  inherit the decoration of global entities in generic instances.\n+         --  Set the parent of the new node to be the parent of the original\n+         --  to get the proper context, which is needed for complete error\n+         --  reporting and for semantic analysis.\n+\n+         Set_Parent (Dup_Expr, Parent (Expr));\n+\n+         --  Replace the defining identifier of iterators and loop param\n+         --  specifications by a clone to ensure that the cloned expression\n+         --  and the original expression don't have shared identifiers;\n+         --  otherwise, as part of the preanalysis of the expression, these\n+         --  shared identifiers may be left decorated with itypes which\n+         --  will not be available in the tree passed to the backend.\n+\n+         Clone_Def_Ids (Dup_Expr);\n+\n+         return Dup_Expr;\n+      end Cloned_Expression;\n+\n+      ----------------------\n+      -- Freeze_Type_Refs --\n+      ----------------------\n+\n+      function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result is\n+         procedure Check_And_Freeze_Type (Typ : Entity_Id);\n+         --  Check that Typ is fully declared and freeze it if so\n+\n+         ---------------------------\n+         -- Check_And_Freeze_Type --\n+         ---------------------------\n+\n+         procedure Check_And_Freeze_Type (Typ : Entity_Id) is\n+         begin\n+            --  Skip Itypes created by the preanalysis, and itypes whose\n+            --  scope is another type (i.e. component subtypes that depend\n+            --  on a discriminant),\n+\n+            if Is_Itype (Typ)\n+              and then (Scope_Within_Or_Same (Scope (Typ), Def_Id)\n+                         or else Is_Type (Scope (Typ)))\n+            then\n+               return;\n+            end if;\n+\n+            --  This provides a better error message than generating\n+            --  primitives whose compilation fails much later. Refine\n+            --  the error message if possible.\n+\n+            Check_Fully_Declared (Typ, Node);\n+\n+            if Error_Posted (Node) then\n+               if Has_Private_Component (Typ)\n+                 and then not Is_Private_Type (Typ)\n+               then\n+                  Error_Msg_NE (\"\\type& has private component\", Node, Typ);\n+               end if;\n+\n+            else\n+               Freeze_Before (N, Typ);\n+            end if;\n+         end Check_And_Freeze_Type;\n+\n+      --  Start of processing for Freeze_Type_Refs\n+\n+      begin\n+         --  Check that a type referenced by an entity can be frozen\n+\n+         if Is_Entity_Name (Node) and then Present (Entity (Node)) then\n+            Check_And_Freeze_Type (Etype (Entity (Node)));\n+\n+            --  Check that the enclosing record type can be frozen\n+\n+            if Ekind_In (Entity (Node), E_Component, E_Discriminant) then\n+               Check_And_Freeze_Type (Scope (Entity (Node)));\n+            end if;\n+\n+         --  Freezing an access type does not freeze the designated type,\n+         --  but freezing conversions between access to interfaces requires\n+         --  that the interface types themselves be frozen, so that dispatch\n+         --  table entities are properly created.\n+\n+         --  Unclear whether a more general rule is needed ???\n+\n+         elsif Nkind (Node) = N_Type_Conversion\n+           and then Is_Access_Type (Etype (Node))\n+           and then Is_Interface (Designated_Type (Etype (Node)))\n+         then\n+            Check_And_Freeze_Type (Designated_Type (Etype (Node)));\n+         end if;\n+\n+         --  An implicit dereference freezes the designated type. In the\n+         --  case of a dispatching call whose controlling argument is an\n+         --  access type, the dereference is not made explicit, so we must\n+         --  check for such a call and freeze the designated type.\n+\n+         if Nkind (Node) in N_Has_Etype\n+           and then Present (Etype (Node))\n+           and then Is_Access_Type (Etype (Node))\n+           and then Nkind (Parent (Node)) = N_Function_Call\n+           and then Node = Controlling_Argument (Parent (Node))\n+         then\n+            Check_And_Freeze_Type (Designated_Type (Etype (Node)));\n+         end if;\n+\n+         --  No point in posting several errors on the same expression\n+\n+         if Serious_Errors_Detected > 0 then\n+            return Abandon;\n+         else\n+            return OK;\n+         end if;\n+      end Freeze_Type_Refs;\n+\n+      procedure Freeze_References is new Traverse_Proc (Freeze_Type_Refs);\n+\n+      --  Local variables\n+\n+      Saved_First_Entity : constant Entity_Id := First_Entity (Def_Id);\n+      Saved_Last_Entity  : constant Entity_Id := Last_Entity  (Def_Id);\n+      Dup_Expr           : constant Node_Id   := Cloned_Expression;\n+\n+   --  Start of processing for Freeze_Expr_Types\n+\n+   begin\n+      --  Preanalyze a duplicate of the expression to have available the\n+      --  minimum decoration needed to locate referenced unfrozen types\n+      --  without adding any decoration to the function expression.\n+\n+      Push_Scope (Def_Id);\n+      Install_Formals (Def_Id);\n+\n+      Preanalyze_Spec_Expression (Dup_Expr, Typ);\n+      End_Scope;\n+\n+      --  Restore certain attributes of Def_Id since the preanalysis may\n+      --  have introduced itypes to this scope, thus modifying attributes\n+      --  First_Entity and Last_Entity.\n+\n+      Set_First_Entity (Def_Id, Saved_First_Entity);\n+      Set_Last_Entity  (Def_Id, Saved_Last_Entity);\n+\n+      if Present (Last_Entity (Def_Id)) then\n+         Set_Next_Entity (Last_Entity (Def_Id), Empty);\n+      end if;\n+\n+      --  Freeze all types referenced in the expression\n+\n+      Freeze_References (Dup_Expr);\n+   end Freeze_Expr_Types;\n+\n    -----------------------------\n    -- Freeze_Fixed_Point_Type --\n    -----------------------------"}, {"sha": "96b3c90b59a425004d0cb4ac17789ba8a3142698", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -230,6 +230,17 @@ package Freeze is\n    --  so need to be similarly treated. Freeze_Expression takes care of\n    --  determining the proper insertion point for generated freeze actions.\n \n+   procedure Freeze_Expr_Types\n+     (Def_Id : Entity_Id;\n+      Typ    : Entity_Id;\n+      Expr   : Node_Id;\n+      N      : Node_Id);\n+   --  N is the body constructed for an expression function that is a\n+   --  completion, and Def_Id is the function being completed.\n+   --  This procedure freezes before N all the types referenced in Expr,\n+   --  which is either the expression of the expression function, or\n+   --  the expression in a pre/post aspect that applies to Def_Id;\n+\n    procedure Freeze_Fixed_Point_Type (Typ : Entity_Id);\n    --  Freeze fixed point type. For fixed-point types, we have to defer\n    --  setting the size and bounds till the freeze point, since they are"}, {"sha": "5548c81c5574cf08613541903eb65522f3ed2700", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 203, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -285,208 +285,6 @@ package body Sem_Ch6 is\n       LocX : constant Source_Ptr := Sloc (Expr);\n       Spec : constant Node_Id    := Specification (N);\n \n-      procedure Freeze_Expr_Types (Def_Id : Entity_Id);\n-      --  N is an expression function that is a completion and Def_Id its\n-      --  defining entity. Freeze before N all the types referenced by the\n-      --  expression of the function.\n-\n-      -----------------------\n-      -- Freeze_Expr_Types --\n-      -----------------------\n-\n-      procedure Freeze_Expr_Types (Def_Id : Entity_Id) is\n-         function Cloned_Expression return Node_Id;\n-         --  Build a duplicate of the expression of the return statement that\n-         --  has no defining entities shared with the original expression.\n-\n-         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result;\n-         --  Freeze all types referenced in the subtree rooted at Node\n-\n-         -----------------------\n-         -- Cloned_Expression --\n-         -----------------------\n-\n-         function Cloned_Expression return Node_Id is\n-            function Clone_Id (Node : Node_Id) return Traverse_Result;\n-            --  Tree traversal routine that clones the defining identifier of\n-            --  iterator and loop parameter specification nodes.\n-\n-            --------------\n-            -- Clone_Id --\n-            --------------\n-\n-            function Clone_Id (Node : Node_Id) return Traverse_Result is\n-            begin\n-               if Nkind_In (Node, N_Iterator_Specification,\n-                                  N_Loop_Parameter_Specification)\n-               then\n-                  Set_Defining_Identifier (Node,\n-                    New_Copy (Defining_Identifier (Node)));\n-               end if;\n-\n-               return OK;\n-            end Clone_Id;\n-\n-            procedure Clone_Def_Ids is new Traverse_Proc (Clone_Id);\n-\n-            --  Local variable\n-\n-            Dup_Expr : constant Node_Id := New_Copy_Tree (Expr);\n-\n-         --  Start of processing for Cloned_Expression\n-\n-         begin\n-            --  We must duplicate the expression with semantic information to\n-            --  inherit the decoration of global entities in generic instances.\n-            --  Set the parent of the new node to be the parent of the original\n-            --  to get the proper context, which is needed for complete error\n-            --  reporting and for semantic analysis.\n-\n-            Set_Parent (Dup_Expr, Parent (Expr));\n-\n-            --  Replace the defining identifier of iterators and loop param\n-            --  specifications by a clone to ensure that the cloned expression\n-            --  and the original expression don't have shared identifiers;\n-            --  otherwise, as part of the preanalysis of the expression, these\n-            --  shared identifiers may be left decorated with itypes which\n-            --  will not be available in the tree passed to the backend.\n-\n-            Clone_Def_Ids (Dup_Expr);\n-\n-            return Dup_Expr;\n-         end Cloned_Expression;\n-\n-         ----------------------\n-         -- Freeze_Type_Refs --\n-         ----------------------\n-\n-         function Freeze_Type_Refs (Node : Node_Id) return Traverse_Result is\n-            procedure Check_And_Freeze_Type (Typ : Entity_Id);\n-            --  Check that Typ is fully declared and freeze it if so\n-\n-            ---------------------------\n-            -- Check_And_Freeze_Type --\n-            ---------------------------\n-\n-            procedure Check_And_Freeze_Type (Typ : Entity_Id) is\n-            begin\n-               --  Skip Itypes created by the preanalysis, and itypes whose\n-               --  scope is another type (i.e. component subtypes that depend\n-               --  on a discriminant),\n-\n-               if Is_Itype (Typ)\n-                 and then (Scope_Within_Or_Same (Scope (Typ), Def_Id)\n-                            or else Is_Type (Scope (Typ)))\n-               then\n-                  return;\n-               end if;\n-\n-               --  This provides a better error message than generating\n-               --  primitives whose compilation fails much later. Refine\n-               --  the error message if possible.\n-\n-               Check_Fully_Declared (Typ, Node);\n-\n-               if Error_Posted (Node) then\n-                  if Has_Private_Component (Typ)\n-                    and then not Is_Private_Type (Typ)\n-                  then\n-                     Error_Msg_NE (\"\\type& has private component\", Node, Typ);\n-                  end if;\n-\n-               else\n-                  Freeze_Before (N, Typ);\n-               end if;\n-            end Check_And_Freeze_Type;\n-\n-         --  Start of processing for Freeze_Type_Refs\n-\n-         begin\n-            --  Check that a type referenced by an entity can be frozen\n-\n-            if Is_Entity_Name (Node) and then Present (Entity (Node)) then\n-               Check_And_Freeze_Type (Etype (Entity (Node)));\n-\n-               --  Check that the enclosing record type can be frozen\n-\n-               if Ekind_In (Entity (Node), E_Component, E_Discriminant) then\n-                  Check_And_Freeze_Type (Scope (Entity (Node)));\n-               end if;\n-\n-            --  Freezing an access type does not freeze the designated type,\n-            --  but freezing conversions between access to interfaces requires\n-            --  that the interface types themselves be frozen, so that dispatch\n-            --  table entities are properly created.\n-\n-            --  Unclear whether a more general rule is needed ???\n-\n-            elsif Nkind (Node) = N_Type_Conversion\n-              and then Is_Access_Type (Etype (Node))\n-              and then Is_Interface (Designated_Type (Etype (Node)))\n-            then\n-               Check_And_Freeze_Type (Designated_Type (Etype (Node)));\n-            end if;\n-\n-            --  An implicit dereference freezes the designated type. In the\n-            --  case of a dispatching call whose controlling argument is an\n-            --  access type, the dereference is not made explicit, so we must\n-            --  check for such a call and freeze the designated type.\n-\n-            if Nkind (Node) in N_Has_Etype\n-              and then Present (Etype (Node))\n-              and then Is_Access_Type (Etype (Node))\n-              and then Nkind (Parent (Node)) = N_Function_Call\n-              and then Node = Controlling_Argument (Parent (Node))\n-            then\n-               Check_And_Freeze_Type (Designated_Type (Etype (Node)));\n-            end if;\n-\n-            --  No point in posting several errors on the same expression\n-\n-            if Serious_Errors_Detected > 0 then\n-               return Abandon;\n-            else\n-               return OK;\n-            end if;\n-         end Freeze_Type_Refs;\n-\n-         procedure Freeze_References is new Traverse_Proc (Freeze_Type_Refs);\n-\n-         --  Local variables\n-\n-         Saved_First_Entity : constant Entity_Id := First_Entity (Def_Id);\n-         Saved_Last_Entity  : constant Entity_Id := Last_Entity  (Def_Id);\n-         Dup_Expr           : constant Node_Id   := Cloned_Expression;\n-\n-      --  Start of processing for Freeze_Expr_Types\n-\n-      begin\n-         --  Preanalyze a duplicate of the expression to have available the\n-         --  minimum decoration needed to locate referenced unfrozen types\n-         --  without adding any decoration to the function expression.\n-\n-         Push_Scope (Def_Id);\n-         Install_Formals (Def_Id);\n-\n-         Preanalyze_Spec_Expression (Dup_Expr, Etype (Def_Id));\n-         End_Scope;\n-\n-         --  Restore certain attributes of Def_Id since the preanalysis may\n-         --  have introduced itypes to this scope, thus modifying attributes\n-         --  First_Entity and Last_Entity.\n-\n-         Set_First_Entity (Def_Id, Saved_First_Entity);\n-         Set_Last_Entity  (Def_Id, Saved_Last_Entity);\n-\n-         if Present (Last_Entity (Def_Id)) then\n-            Set_Next_Entity (Last_Entity (Def_Id), Empty);\n-         end if;\n-\n-         --  Freeze all types referenced in the expression\n-\n-         Freeze_References (Dup_Expr);\n-      end Freeze_Expr_Types;\n-\n       --  Local variables\n \n       Asp      : Node_Id;\n@@ -600,7 +398,7 @@ package body Sem_Ch6 is\n          --  As elsewhere, we do not emit freeze nodes within a generic unit.\n \n          if not Inside_A_Generic then\n-            Freeze_Expr_Types (Def_Id);\n+            Freeze_Expr_Types (Def_Id, Etype (Def_Id), Expr, N);\n          end if;\n \n          --  For navigation purposes, indicate that the function is a body"}, {"sha": "444f3e852ca8a11978887e7f0148f60b7a560e04", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -1,3 +1,7 @@\n+2018-08-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/expr_func6.adb, gnat.dg/expr_func6.ads: New testcase.\n+\n 2018-08-21  Javier Miranda  <miranda@adacore.com>\n \n \t* gnat.dg/spark2.adb, gnat.dg/spark2.ads: New testcase."}, {"sha": "7223fa0e6aa83f6ee320c6bc40079565734c70ed", "filename": "gcc/testsuite/gnat.dg/expr_func6.adb", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.adb?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -0,0 +1,7 @@\n+--  { dg-do compile }\n+\n+package body Expr_Func6 is\n+\n+   procedure Dummy is null;\n+\n+end Expr_Func6;"}, {"sha": "462bde106c034bd4921f89dfda4d7b2aa90aa699", "filename": "gcc/testsuite/gnat.dg/expr_func6.ads", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0db1c3863d5167dd47e5a0ab4a714ace875a9202/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fexpr_func6.ads?ref=0db1c3863d5167dd47e5a0ab4a714ace875a9202", "patch": "@@ -0,0 +1,17 @@\n+pragma Assertion_Policy (Check);\n+\n+package Expr_Func6 is\n+\n+   type Monolean is (Nottrue);\n+\n+   function Basic_Function return Monolean;\n+   function Fancy_Function_With_Contract return Boolean\n+     with Pre => Basic_Function = Nottrue;\n+\n+   function Fancy_Function_With_Contract return Boolean is (False);\n+\n+   function Basic_Function return Monolean is (Nottrue);\n+\n+   procedure Dummy;\n+\n+end Expr_Func6;"}]}