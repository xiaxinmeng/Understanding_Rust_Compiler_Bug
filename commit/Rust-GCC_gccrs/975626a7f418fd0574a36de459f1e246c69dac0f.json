{"sha": "975626a7f418fd0574a36de459f1e246c69dac0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTc1NjI2YTdmNDE4ZmQwNTc0YTM2ZGU0NTlmMWUyNDZjNjlkYWMwZg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-10-06T19:32:04Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-10-06T19:32:04Z"}, "message": "re PR target/29256 (loop performance regression)\n\n\tPR middle-end/29256\n\t* tree-ssa-loop-ivopts.c (determine_base_object): Handle pointers\n\tcasted to integer type.\n\t(get_address_cost): Decrease cost of [symbol + index] addressing modes\n\tif they are significantly more expensive than [reg + index] ones.\n\n\t* gcc.dg/tree-ssa/loop-19.c: New test.\n\nFrom-SVN: r117513", "tree": {"sha": "8db53ae568c90ff0d6e7b963b4f8f907540d3826", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8db53ae568c90ff0d6e7b963b4f8f907540d3826"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/975626a7f418fd0574a36de459f1e246c69dac0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975626a7f418fd0574a36de459f1e246c69dac0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/975626a7f418fd0574a36de459f1e246c69dac0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/975626a7f418fd0574a36de459f1e246c69dac0f/comments", "author": null, "committer": null, "parents": [{"sha": "3ac571201309b925c13eebe0a140b20f93dbf4b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac571201309b925c13eebe0a140b20f93dbf4b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac571201309b925c13eebe0a140b20f93dbf4b1"}], "stats": {"total": 214, "additions": 160, "deletions": 54}, "files": [{"sha": "e52ef56255301b36591c503e4ef143eb910ca379", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=975626a7f418fd0574a36de459f1e246c69dac0f", "patch": "@@ -1,3 +1,11 @@\n+2006-10-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR middle-end/29256\n+\t* tree-ssa-loop-ivopts.c (determine_base_object): Handle pointers\n+\tcasted to integer type.\n+\t(get_address_cost): Decrease cost of [symbol + index] addressing modes\n+\tif they are significantly more expensive than [reg + index] ones.\n+\n 2006-10-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/29330"}, {"sha": "9beac3fc86d8b6c02aeae90c9c3554c2efe955ba", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=975626a7f418fd0574a36de459f1e246c69dac0f", "patch": "@@ -1,3 +1,8 @@\n+2006-10-06  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\tPR middle-end/29256\n+\t* gcc.dg/tree-ssa/loop-19.c: New test.\n+\n 2006-10-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/29330"}, {"sha": "276913a2c82f85f5bd564c85670bfd19c3017242", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-19.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-19.c?ref=975626a7f418fd0574a36de459f1e246c69dac0f", "patch": "@@ -0,0 +1,27 @@\n+/* This tests strength reduction and choice of induction variables.  The targets\n+   for this testcase are quite limited, as with different set of available\n+   addressing modes, the results may be quite different.\n+ \n+   The testcase comes from PR 29256 (and originally, the stream benchmark).  */\n+\n+/* { dg-do compile { target i?86-*-* x86_64-*-* powerpc*-*-*} } */\n+/* { dg-options \"-O3 -fdump-tree-final_cleanup\" } */\n+\n+# define N      2000000\n+static double   a[N],c[N];\n+void tuned_STREAM_Copy()\n+{\n+  int j;\n+  for (j=0; j<N; j++)\n+    c[j] = a[j];\n+}\n+\n+/* Check that the memory references are based on &a and &c, with appropriate\n+   offsets.  Ideally, we would want each of them to appear once in the output.\n+   However, due to a bug in jump threading, we end up peeling one iteration from\n+   the loop, which creates an additional occurence.  */\n+\n+/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )a,\" 2 \"final_cleanup\" } } */\n+/* { dg-final { scan-tree-dump-times \"MEM.(base: &|symbol: )c,\" 2 \"final_cleanup\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "08746200f9e45ca38e8aa4bc4e5f92768e2a6403", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 120, "deletions": 54, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/975626a7f418fd0574a36de459f1e246c69dac0f/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=975626a7f418fd0574a36de459f1e246c69dac0f", "patch": "@@ -835,6 +835,13 @@ determine_base_object (tree expr)\n   enum tree_code code = TREE_CODE (expr);\n   tree base, obj, op0, op1;\n \n+  /* If this is a pointer casted to any type, we need to determine\n+     the base object for the pointer; so handle conversions before\n+     throwing away non-pointer expressions.  */\n+  if (TREE_CODE (expr) == NOP_EXPR\n+      || TREE_CODE (expr) == CONVERT_EXPR)\n+    return determine_base_object (TREE_OPERAND (expr, 0));\n+\n   if (!POINTER_TYPE_P (TREE_TYPE (expr)))\n     return NULL_TREE;\n \n@@ -871,10 +878,6 @@ determine_base_object (tree expr)\n \n       return fold_build2 (code, ptr_type_node, op0, op1);\n \n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n-      return determine_base_object (TREE_OPERAND (expr, 0));\n-\n     default:\n       return fold_convert (ptr_type_node, expr);\n     }\n@@ -3371,16 +3374,19 @@ get_address_cost (bool symbol_present, bool var_present,\n   static HOST_WIDE_INT min_offset, max_offset;\n   static unsigned costs[2][2][2][2];\n   unsigned cost, acost;\n-  rtx seq, addr, base;\n   bool offset_p, ratio_p;\n-  rtx reg1;\n   HOST_WIDE_INT s_offset;\n   unsigned HOST_WIDE_INT mask;\n   unsigned bits;\n \n   if (!initialized)\n     {\n       HOST_WIDE_INT i;\n+      int old_cse_not_expected;\n+      unsigned sym_p, var_p, off_p, rat_p, add_c;\n+      rtx seq, addr, base;\n+      rtx reg0, reg1;\n+\n       initialized = true;\n \n       reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n@@ -3417,6 +3423,114 @@ get_address_cost (bool symbol_present, bool var_present,\n \t    rat = i;\n \t    break;\n \t  }\n+\n+      /* Compute the cost of various addressing modes.  */\n+      acost = 0;\n+      reg0 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n+      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);\n+\n+      for (i = 0; i < 16; i++)\n+\t{\n+\t  sym_p = i & 1;\n+\t  var_p = (i >> 1) & 1;\n+\t  off_p = (i >> 2) & 1;\n+\t  rat_p = (i >> 3) & 1;\n+\n+\t  addr = reg0;\n+\t  if (rat_p)\n+\t    addr = gen_rtx_fmt_ee (MULT, Pmode, addr, gen_int_mode (rat, Pmode));\n+\n+\t  if (var_p)\n+\t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n+\n+\t  if (sym_p)\n+\t    {\n+\t      base = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"\"));\n+\t      if (off_p)\n+\t\tbase = gen_rtx_fmt_e (CONST, Pmode,\n+\t\t\t\t      gen_rtx_fmt_ee (PLUS, Pmode,\n+\t\t\t\t\t\t      base,\n+\t\t\t\t\t\t      gen_int_mode (off, Pmode)));\n+\t    }\n+\t  else if (off_p)\n+\t    base = gen_int_mode (off, Pmode);\n+\t  else\n+\t    base = NULL_RTX;\n+    \n+\t  if (base)\n+\t    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);\n+  \n+\t  start_sequence ();\n+\t  /* To avoid splitting addressing modes, pretend that no cse will\n+\t     follow.  */\n+\t  old_cse_not_expected = cse_not_expected;\n+\t  cse_not_expected = true;\n+\t  addr = memory_address (Pmode, addr);\n+\t  cse_not_expected = old_cse_not_expected;\n+\t  seq = get_insns ();\n+\t  end_sequence ();\n+\n+\t  acost = seq_cost (seq);\n+\t  acost += address_cost (addr, Pmode);\n+\n+\t  if (!acost)\n+\t    acost = 1;\n+\t  costs[sym_p][var_p][off_p][rat_p] = acost;\n+\t}\n+\n+      /* On some targets, it is quite expensive to load symbol to a register,\n+\t which makes addresses that contain symbols look much more expensive.\n+\t However, the symbol will have to be loaded in any case before the\n+\t loop (and quite likely we have it in register already), so it does not\n+\t make much sense to penalize them too heavily.  So make some final\n+         tweaks for the SYMBOL_PRESENT modes:\n+\n+         If VAR_PRESENT is false, and the mode obtained by changing symbol to\n+\t var is cheaper, use this mode with small penalty.\n+\t If VAR_PRESENT is true, try whether the mode with\n+\t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n+\t if this is the case, use it.  */\n+      add_c = add_cost (Pmode);\n+      for (i = 0; i < 8; i++)\n+\t{\n+\t  var_p = i & 1;\n+\t  off_p = (i >> 1) & 1;\n+\t  rat_p = (i >> 2) & 1;\n+\n+\t  acost = costs[0][1][off_p][rat_p] + 1;\n+\t  if (var_p)\n+\t    acost += add_c;\n+\n+\t  if (acost < costs[1][var_p][off_p][rat_p])\n+\t    costs[1][var_p][off_p][rat_p] = acost;\n+\t}\n+  \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Address costs:\\n\");\n+      \n+\t  for (i = 0; i < 16; i++)\n+\t    {\n+\t      sym_p = i & 1;\n+\t      var_p = (i >> 1) & 1;\n+\t      off_p = (i >> 2) & 1;\n+\t      rat_p = (i >> 3) & 1;\n+\n+\t      fprintf (dump_file, \"  \");\n+\t      if (sym_p)\n+\t\tfprintf (dump_file, \"sym + \");\n+\t      if (var_p)\n+\t\tfprintf (dump_file, \"var + \");\n+\t      if (off_p)\n+\t\tfprintf (dump_file, \"cst + \");\n+\t      if (rat_p)\n+\t\tfprintf (dump_file, \"rat * \");\n+\n+\t      acost = costs[sym_p][var_p][off_p][rat_p];\n+\t      fprintf (dump_file, \"index costs %d\\n\", acost);\n+\t    }\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n \n   bits = GET_MODE_BITSIZE (Pmode);\n@@ -3442,54 +3556,6 @@ get_address_cost (bool symbol_present, bool var_present,\n     }\n \n   acost = costs[symbol_present][var_present][offset_p][ratio_p];\n-  if (!acost)\n-    {\n-      int old_cse_not_expected;\n-      acost = 0;\n-      \n-      addr = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);\n-      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);\n-      if (ratio_p)\n-\taddr = gen_rtx_fmt_ee (MULT, Pmode, addr, gen_int_mode (rat, Pmode));\n-\n-      if (var_present)\n-\taddr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);\n-\n-      if (symbol_present)\n-\t{\n-\t  base = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (\"\"));\n-\t  if (offset_p)\n-\t    base = gen_rtx_fmt_e (CONST, Pmode,\n-\t\t\t\t  gen_rtx_fmt_ee (PLUS, Pmode,\n-\t\t\t\t\t\t  base,\n-\t\t\t\t\t\t  gen_int_mode (off, Pmode)));\n-\t}\n-      else if (offset_p)\n-\tbase = gen_int_mode (off, Pmode);\n-      else\n-\tbase = NULL_RTX;\n-    \n-      if (base)\n-\taddr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);\n-  \n-      start_sequence ();\n-      /* To avoid splitting addressing modes, pretend that no cse will\n- \t follow.  */\n-      old_cse_not_expected = cse_not_expected;\n-      cse_not_expected = true;\n-      addr = memory_address (Pmode, addr);\n-      cse_not_expected = old_cse_not_expected;\n-      seq = get_insns ();\n-      end_sequence ();\n-  \n-      acost = seq_cost (seq);\n-      acost += address_cost (addr, Pmode);\n-\n-      if (!acost)\n-\tacost = 1;\n-      costs[symbol_present][var_present][offset_p][ratio_p] = acost;\n-    }\n-\n   return cost + acost;\n }\n "}]}