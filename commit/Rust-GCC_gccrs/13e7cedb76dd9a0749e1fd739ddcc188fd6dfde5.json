{"sha": "13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNlN2NlZGI3NmRkOWEwNzQ5ZTFmZDczOWRkY2MxODhmZDZkZmRlNQ==", "commit": {"author": {"name": "Dan Hipschman", "email": "dsh@google.com", "date": "2007-07-31T21:16:26Z"}, "committer": {"name": "Dan Hipschman", "email": "dsh@gcc.gnu.org", "date": "2007-07-31T21:16:26Z"}, "message": "This factors the code in xgcc that is used to terminate an accumulated\nargument.\n\nFrom-SVN: r127107", "tree": {"sha": "98733f90e31f6d11e2772431d21926a10d198281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98733f90e31f6d11e2772431d21926a10d198281"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5/comments", "author": null, "committer": null, "parents": [{"sha": "7d520b9b1220582ebd84badc309b6cbe0d074797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d520b9b1220582ebd84badc309b6cbe0d074797", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d520b9b1220582ebd84badc309b6cbe0d074797"}], "stats": {"total": 107, "additions": 34, "deletions": 73}, "files": [{"sha": "ede25840c2924809e71c2dbd30289d260eb13ed7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "patch": "@@ -1,3 +1,9 @@\n+2007-07-31  Dan Hipschman  <dsh@google.com>\n+\n+\t* gcc.c (end_going_arg): New function.\n+\t(do_spec_2): Use it.\n+\t(do_spec_1): Use it.\n+\n 2007-07-31  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* ddg.c (add_cross_iteration_register_deps): Declare bb_info"}, {"sha": "3d4467791f1f548a49a1da223e3b7d17469b7274", "filename": "gcc/gcc.c", "status": "modified", "additions": 28, "deletions": 73, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=13e7cedb76dd9a0749e1fd739ddcc188fd6dfde5", "patch": "@@ -4373,6 +4373,26 @@ static int input_from_pipe;\n    arguments.  */\n static const char *suffix_subst;\n \n+/* If there is an argument being accumulated, terminate it and store it.  */\n+\n+static void\n+end_going_arg (void)\n+{\n+  if (arg_going)\n+    {\n+      const char *string;\n+\n+      obstack_1grow (&obstack, 0);\n+      string = XOBFINISH (&obstack, const char *);\n+      if (this_is_library_file)\n+\tstring = find_file (string);\n+      store_arg (string, delete_this_arg, this_is_output_file);\n+      if (this_is_output_file)\n+\toutfiles[input_file_number] = string;\n+      arg_going = 0;\n+    }\n+}\n+\n /* Process the spec SPEC and run the commands specified therein.\n    Returns 0 if the spec is successfully processed; -1 if failed.  */\n \n@@ -4402,7 +4422,6 @@ do_spec (const char *spec)\n static int\n do_spec_2 (const char *spec)\n {\n-  const char *string;\n   int result;\n \n   clear_args ();\n@@ -4415,18 +4434,7 @@ do_spec_2 (const char *spec)\n \n   result = do_spec_1 (spec, 0, NULL);\n \n-  /* End any pending argument.  */\n-  if (arg_going)\n-    {\n-      obstack_1grow (&obstack, 0);\n-      string = XOBFINISH (&obstack, const char *);\n-      if (this_is_library_file)\n-\tstring = find_file (string);\n-      store_arg (string, delete_this_arg, this_is_output_file);\n-      if (this_is_output_file)\n-\toutfiles[input_file_number] = string;\n-      arg_going = 0;\n-    }\n+  end_going_arg ();\n \n   return result;\n }\n@@ -4587,7 +4595,6 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n   const char *p = spec;\n   int c;\n   int i;\n-  const char *string;\n   int value;\n \n   while ((c = *p++))\n@@ -4596,19 +4603,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n     switch (inswitch ? 'a' : c)\n       {\n       case '\\n':\n-\t/* End of line: finish any pending argument,\n-\t   then run the pending command if one has been started.  */\n-\tif (arg_going)\n-\t  {\n-\t    obstack_1grow (&obstack, 0);\n-\t    string = XOBFINISH (&obstack, const char *);\n-\t    if (this_is_library_file)\n-\t      string = find_file (string);\n-\t    store_arg (string, delete_this_arg, this_is_output_file);\n-\t    if (this_is_output_file)\n-\t      outfiles[input_file_number] = string;\n-\t  }\n-\targ_going = 0;\n+\tend_going_arg ();\n \n \tif (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], \"|\"))\n \t  {\n@@ -4642,17 +4637,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \tbreak;\n \n       case '|':\n-\t/* End any pending argument.  */\n-\tif (arg_going)\n-\t  {\n-\t    obstack_1grow (&obstack, 0);\n-\t    string = XOBFINISH (&obstack, const char *);\n-\t    if (this_is_library_file)\n-\t      string = find_file (string);\n-\t    store_arg (string, delete_this_arg, this_is_output_file);\n-\t    if (this_is_output_file)\n-\t      outfiles[input_file_number] = string;\n-\t  }\n+\tend_going_arg ();\n \n \t/* Use pipe */\n \tobstack_1grow (&obstack, c);\n@@ -4661,19 +4646,9 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n       case '\\t':\n       case ' ':\n-\t/* Space or tab ends an argument if one is pending.  */\n-\tif (arg_going)\n-\t  {\n-\t    obstack_1grow (&obstack, 0);\n-\t    string = XOBFINISH (&obstack, const char *);\n-\t    if (this_is_library_file)\n-\t      string = find_file (string);\n-\t    store_arg (string, delete_this_arg, this_is_output_file);\n-\t    if (this_is_output_file)\n-\t      outfiles[input_file_number] = string;\n-\t  }\n+\tend_going_arg ();\n+\n \t/* Reinitialize for a new argument.  */\n-\targ_going = 0;\n \tdelete_this_arg = 0;\n \tthis_is_output_file = 0;\n \tthis_is_library_file = 0;\n@@ -5101,18 +5076,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      p = handle_braces (p + 1);\n \t      if (p == 0)\n \t\treturn -1;\n-\t      /* End any pending argument.  */\n-\t      if (arg_going)\n-\t\t{\n-\t\t  obstack_1grow (&obstack, 0);\n-\t\t  string = XOBFINISH (&obstack, const char *);\n-\t\t  if (this_is_library_file)\n-\t\t    string = find_file (string);\n-\t\t  store_arg (string, delete_this_arg, this_is_output_file);\n-\t\t  if (this_is_output_file)\n-\t\t    outfiles[input_file_number] = string;\n-\t\t  arg_going = 0;\n-\t\t}\n+\t      end_going_arg ();\n \t      /* If any args were output, mark the last one for deletion\n \t\t on failure.  */\n \t      if (argbuf_index != cur_index)\n@@ -5431,17 +5395,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n   /* End of string.  If we are processing a spec function, we need to\n      end any pending argument.  */\n-  if (processing_spec_function && arg_going)\n-    {\n-      obstack_1grow (&obstack, 0);\n-      string = XOBFINISH (&obstack, const char *);\n-      if (this_is_library_file)\n-        string = find_file (string);\n-      store_arg (string, delete_this_arg, this_is_output_file);\n-      if (this_is_output_file)\n-        outfiles[input_file_number] = string;\n-      arg_going = 0;\n-    }\n+  if (processing_spec_function)\n+    end_going_arg ();\n \n   return 0;\n }"}]}