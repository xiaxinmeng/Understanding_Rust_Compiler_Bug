{"sha": "577ad216dc16802d1eeed14a3948ed3bacac30e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc3YWQyMTZkYzE2ODAyZDFlZWVkMTRhMzk0OGVkM2JhY2FjMzBlNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2018-05-28T08:54:27Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-05-28T08:54:27Z"}, "message": "[Ada] Improve unnesting of indexed references\n\n2018-05-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\ngcc/ada/\n\n\t* exp_unst.adb (Check_Static_Type): Add argument to indicate node to be\n\treplaced, if any; all callers changed.\n\t(Note_Uplevel_Ref): Likewise.  Also replace reference to deferred\n\tconstant with private view so we take the address of that entity.\n\t(Note_Uplevel_Bound): Add argument to indicate node to be replaced, if\n\tany; all callers changed.  Handle N_Indexed_Component like\n\tN_Attribute_Reference.  Add N_Type_Conversion case.\n\t(Visit_Node): Indexed references can be uplevel if the type isn't\n\tstatic.\n\t(Unnest_Subprograms): Don't rewrite if no reference given.  If call has\n\tbeen relocated, set first_named pointer in original node as well.\n\nFrom-SVN: r260830", "tree": {"sha": "6d5a40cffe1e6ce5376eb610a9ca8b861e9f2ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d5a40cffe1e6ce5376eb610a9ca8b861e9f2ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/577ad216dc16802d1eeed14a3948ed3bacac30e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577ad216dc16802d1eeed14a3948ed3bacac30e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/577ad216dc16802d1eeed14a3948ed3bacac30e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/577ad216dc16802d1eeed14a3948ed3bacac30e6/comments", "author": null, "committer": null, "parents": [{"sha": "1541ede1e18b72f77b84fdef0478e97684d14cf1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1541ede1e18b72f77b84fdef0478e97684d14cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1541ede1e18b72f77b84fdef0478e97684d14cf1"}], "stats": {"total": 124, "additions": 93, "deletions": 31}, "files": [{"sha": "d724ee9f93385d97289efe771b6ba332a22a56c6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577ad216dc16802d1eeed14a3948ed3bacac30e6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577ad216dc16802d1eeed14a3948ed3bacac30e6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=577ad216dc16802d1eeed14a3948ed3bacac30e6", "patch": "@@ -1,3 +1,17 @@\n+2018-05-28  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* exp_unst.adb (Check_Static_Type): Add argument to indicate node to be\n+\treplaced, if any; all callers changed.\n+\t(Note_Uplevel_Ref): Likewise.  Also replace reference to deferred\n+\tconstant with private view so we take the address of that entity.\n+\t(Note_Uplevel_Bound): Add argument to indicate node to be replaced, if\n+\tany; all callers changed.  Handle N_Indexed_Component like\n+\tN_Attribute_Reference.  Add N_Type_Conversion case.\n+\t(Visit_Node): Indexed references can be uplevel if the type isn't\n+\tstatic.\n+\t(Unnest_Subprograms): Don't rewrite if no reference given.  If call has\n+\tbeen relocated, set first_named pointer in original node as well.\n+\n 2018-05-28  Ed Schonberg  <schonberg@adacore.com>\n \n \t* exp_aggr.adb (Flatten): Copy tree of expression in a component"}, {"sha": "fbc52b79f4ac3ed290de5de5a739ac5b9a0c4749", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 79, "deletions": 31, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/577ad216dc16802d1eeed14a3948ed3bacac30e6/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/577ad216dc16802d1eeed14a3948ed3bacac30e6/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=577ad216dc16802d1eeed14a3948ed3bacac30e6", "patch": "@@ -366,16 +366,20 @@ package body Exp_Unst is\n             Caller : Entity_Id;\n             Callee : Entity_Id;\n \n-            procedure Check_Static_Type (T : Entity_Id; DT : in out Boolean);\n+            procedure Check_Static_Type\n+              (T : Entity_Id; N : Node_Id; DT : in out Boolean);\n             --  Given a type T, checks if it is a static type defined as a type\n             --  with no dynamic bounds in sight. If so, the only action is to\n             --  set Is_Static_Type True for T. If T is not a static type, then\n             --  all types with dynamic bounds associated with T are detected,\n             --  and their bounds are marked as uplevel referenced if not at the\n-            --  library level, and DT is set True.\n+            --  library level, and DT is set True. If N is specified, it's the\n+            --  node that will need to be replaced. If not specified, it means\n+            --  we can't do a replacement because the bound is implicit.\n \n             procedure Note_Uplevel_Ref\n               (E      : Entity_Id;\n+               N      : Node_Id;\n                Caller : Entity_Id;\n                Callee : Entity_Id);\n             --  Called when we detect an explicit or implicit uplevel reference\n@@ -386,19 +390,23 @@ package body Exp_Unst is\n             -- Check_Static_Type --\n             -----------------------\n \n-            procedure Check_Static_Type (T : Entity_Id; DT : in out Boolean) is\n-               procedure Note_Uplevel_Bound (N : Node_Id);\n+            procedure Check_Static_Type\n+              (T : Entity_Id; N : Node_Id; DT : in out Boolean)\n+            is\n+               procedure Note_Uplevel_Bound (N : Node_Id; Ref : Node_Id);\n                --  N is the bound of a dynamic type. This procedure notes that\n                --  this bound is uplevel referenced, it can handle references\n                --  to entities (typically _FIRST and _LAST entities), and also\n                --  attribute references of the form T'name (name is typically\n                --  FIRST or LAST) where T is the uplevel referenced bound.\n+               --  Ref, if Present, is the location of the reference to\n+               --  replace.\n \n                ------------------------\n                -- Note_Uplevel_Bound --\n                ------------------------\n \n-               procedure Note_Uplevel_Bound (N : Node_Id) is\n+               procedure Note_Uplevel_Bound (N : Node_Id; Ref : Node_Id) is\n                begin\n                   --  Entity name case. Make sure that the entity is declared\n                   --  in a subprogram. This may not be the case for for a type\n@@ -410,14 +418,22 @@ package body Exp_Unst is\n                      then\n                         Note_Uplevel_Ref\n                           (E      => Entity (N),\n+                           N      => Ref,\n                            Caller => Current_Subprogram,\n                            Callee => Enclosing_Subprogram (Entity (N)));\n                      end if;\n \n-                  --  Attribute case\n+                  --  Attribute or indexed component case\n+\n+                  elsif Nkind_In (N, N_Attribute_Reference,\n+                                     N_Indexed_Component)\n+                  then\n+                     Note_Uplevel_Bound (Prefix (N), Ref);\n+\n+                  --  Conversion case\n \n-                  elsif Nkind (N) = N_Attribute_Reference then\n-                     Note_Uplevel_Bound (Prefix (N));\n+                  elsif Nkind (N) = N_Type_Conversion then\n+                     Note_Uplevel_Bound (Expression (N), Ref);\n                   end if;\n                end Note_Uplevel_Bound;\n \n@@ -452,12 +468,12 @@ package body Exp_Unst is\n \n                   begin\n                      if not Is_Static_Expression (LB) then\n-                        Note_Uplevel_Bound (LB);\n+                        Note_Uplevel_Bound (LB, N);\n                         DT := True;\n                      end if;\n \n                      if not Is_Static_Expression (UB) then\n-                        Note_Uplevel_Bound (UB);\n+                        Note_Uplevel_Bound (UB, N);\n                         DT := True;\n                      end if;\n                   end;\n@@ -470,7 +486,7 @@ package body Exp_Unst is\n                   begin\n                      C := First_Component_Or_Discriminant (T);\n                      while Present (C) loop\n-                        Check_Static_Type (Etype (C), DT);\n+                        Check_Static_Type (Etype (C), N, DT);\n                         Next_Component_Or_Discriminant (C);\n                      end loop;\n                   end;\n@@ -481,19 +497,19 @@ package body Exp_Unst is\n                   declare\n                      IX : Node_Id;\n                   begin\n-                     Check_Static_Type (Component_Type (T), DT);\n+                     Check_Static_Type (Component_Type (T), N, DT);\n \n                      IX := First_Index (T);\n                      while Present (IX) loop\n-                        Check_Static_Type (Etype (IX), DT);\n+                        Check_Static_Type (Etype (IX), N, DT);\n                         Next_Index (IX);\n                      end loop;\n                   end;\n \n                --  For private type, examine whether full view is static\n \n                elsif Is_Private_Type (T) and then Present (Full_View (T)) then\n-                  Check_Static_Type (Full_View (T), DT);\n+                  Check_Static_Type (Full_View (T), N, DT);\n \n                   if Is_Static_Type (Full_View (T)) then\n                      Set_Is_Static_Type (T);\n@@ -516,9 +532,11 @@ package body Exp_Unst is\n \n             procedure Note_Uplevel_Ref\n               (E      : Entity_Id;\n+               N      : Node_Id;\n                Caller : Entity_Id;\n                Callee : Entity_Id)\n             is\n+               Full_E : Entity_Id := E;\n             begin\n                --  Nothing to do for static type\n \n@@ -544,12 +562,16 @@ package body Exp_Unst is\n \n                --  We have a new uplevel referenced entity\n \n+               if Ekind (E) = E_Constant and then Present (Full_View (E)) then\n+                  Full_E := Full_View (E);\n+               end if;\n+\n                --  All we do at this stage is to add the uplevel reference to\n                --  the table. It's too early to do anything else, since this\n                --  uplevel reference may come from an unreachable subprogram\n                --  in which case the entry will be deleted.\n \n-               Urefs.Append ((N, E, Caller, Callee));\n+               Urefs.Append ((N, Full_E, Caller, Callee));\n             end Note_Uplevel_Ref;\n \n          --  Start of processing for Visit_Node\n@@ -617,25 +639,26 @@ package body Exp_Unst is\n                            end if;\n                         end if;\n \n+                     --  References to bounds can be uplevel references if\n+                     --  the type isn't static.\n+\n                      when Attribute_First\n                         | Attribute_Last\n                         | Attribute_Length\n                      =>\n-                        --  Special-case attributes of array objects whose\n-                        --  bounds may be uplevel references. More complex\n-                        --  prefixes are handled during full traversal. Note\n-                        --  that if the nominal subtype of the prefix is\n-                        --  unconstrained, the bound must be obtained from\n-                        --  the object, not from the (possibly) uplevel\n-                        --  reference.\n-\n-                        if Is_Entity_Name (Prefix (N))\n-                          and then Is_Constrained (Etype (Prefix (N)))\n-                        then\n+                        --  Special-case attributes of objects whose bounds\n+                        --  may be uplevel references. More complex prefixes\n+                        --  handled during full traversal. Note that if the\n+                        --  nominal subtype of the prefix is unconstrained,\n+                        --  the bound must be obtained from the object, not\n+                        --  from the (possibly) uplevel reference.\n+\n+                        if Is_Constrained (Etype (Prefix (N))) then\n                            declare\n                               DT : Boolean := False;\n                            begin\n-                              Check_Static_Type (Etype (Prefix (N)), DT);\n+                              Check_Static_Type (Etype (Prefix (N)),\n+                                                 Empty, DT);\n                            end;\n \n                            return OK;\n@@ -646,6 +669,19 @@ package body Exp_Unst is\n                   end case;\n                end;\n \n+            --  Indexed references can be uplevel if the type isn't static and\n+            --  if the lower bound (or an inner bound for a multidimensional\n+            --  array) is uplevel.\n+\n+            elsif Nkind_In (N, N_Indexed_Component, N_Slice)\n+              and then Is_Constrained (Etype (Prefix (N)))\n+            then\n+               declare\n+                  DT : Boolean := False;\n+               begin\n+                  Check_Static_Type (Etype (Prefix (N)), Empty, DT);\n+               end;\n+\n             --  Record a subprogram. We record a subprogram body that acts as\n             --  a spec. Otherwise we record a subprogram declaration, providing\n             --  that it has a corresponding body we can get hold of. The case\n@@ -755,7 +791,7 @@ package body Exp_Unst is\n                         DT : Boolean := False;\n \n                      begin\n-                        Check_Static_Type (Ent, DT);\n+                        Check_Static_Type (Ent, N, DT);\n \n                         if Is_Static_Type (Ent) then\n                            return OK;\n@@ -767,7 +803,7 @@ package body Exp_Unst is\n                   Callee := Enclosing_Subprogram (Ent);\n \n                   if Callee /= Caller and then not Is_Static_Type (Ent) then\n-                     Note_Uplevel_Ref (Ent, Caller, Callee);\n+                     Note_Uplevel_Ref (Ent, N, Caller, Callee);\n                   end if;\n                end if;\n \n@@ -925,8 +961,12 @@ package body Exp_Unst is\n                   --  to objects that will be referenced uplevel, and we use\n                   --  the flag Is_Uplevel_Referenced_Entity to avoid making\n                   --  duplicate entries in the list.\n+                  --  Discriminants are also excluded, only the enclosing\n+                  --  object can appear in the list.\n \n-                  if not Is_Uplevel_Referenced_Entity (URJ.Ent) then\n+                  if not Is_Uplevel_Referenced_Entity (URJ.Ent)\n+                    and then Ekind (URJ.Ent) /= E_Discriminant\n+                  then\n                      Set_Is_Uplevel_Referenced_Entity (URJ.Ent);\n \n                      if not Is_Type (URJ.Ent) then\n@@ -1520,8 +1560,9 @@ package body Exp_Unst is\n          begin\n             --  Ignore type references, these are implicit references that do\n             --  not need rewriting (e.g. the appearence in a conversion).\n+            --  Also ignore if no reference was specified.\n \n-            if Is_Type (UPJ.Ent) then\n+            if Is_Type (UPJ.Ent) or else No (UPJ.Ref) then\n                goto Continue;\n             end if;\n \n@@ -1765,6 +1806,13 @@ package body Exp_Unst is\n                if No (Act) then\n                   Set_First_Named_Actual (CTJ.N, Extra);\n \n+                  --  If call has been relocated (as with an expression in\n+                  --  an aggregate), set First_Named pointer in original node\n+                  --  as well, because that's the parent of the parameter list.\n+\n+                  Set_First_Named_Actual\n+                    (Parent (List_Containing (ExtraP)), Extra);\n+\n                --  Here we must follow the chain and append the new entry\n \n                else"}]}