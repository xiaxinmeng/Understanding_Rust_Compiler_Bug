{"sha": "908a1a166dccefa24ae8b3606f4ce1da944eecb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA4YTFhMTY2ZGNjZWZhMjRhZThiMzYwNmY0Y2UxZGE5NDRlZWNiMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-14T16:04:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-14T16:04:32Z"}, "message": "Use vec<> for constant permute masks\n\nThis patch makes can_vec_perm_p & co. take a vec<>, wrapped in new\ntypedefs vec_perm_indices and auto_vec_perm_indices.  There are two\nreasons for doing this for SVE:\n\n(1) it means that the number of elements is bundled with the elements\n    themselves, and is obviously constant.\n\n(2) it makes it easier to change the \"unsigned char\" element type to\n    something wider.\n\nChanging the target hook is left as follow-on work.\n\n2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.h (vec_perm_indices): New typedef.\n\t(auto_vec_perm_indices): Likewise.\n\t* optabs-query.h: Include target.h\n\t(can_vec_perm_p): Take a vec_perm_indices *.\n\t* optabs-query.c (can_vec_perm_p): Likewise.\n\t(can_mult_highpart_p): Update accordingly.  Use auto_vec_perm_indices.\n\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t(vect_permute_store_chain): Use auto_vec_perm_indices.\n\t(vect_permute_load_chain): Likewise.\n\t* fold-const.c (fold_vec_perm): Take vec_perm_indices.\n\t(fold_ternary_loc): Update accordingly.  Use auto_vec_perm_indices.\n\tUpdate uses of can_vec_perm_p.\n\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Replace the\n\tmode with a number of elements.  Take a vec_perm_indices *.\n\t(vect_create_epilog_for_reduction): Update accordingly.\n\tUse auto_vec_perm_indices.\n\t(have_whole_vector_shift): Likewise.  Update call to can_vec_perm_p.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vect_schedule_slp_instance): Use auto_vec_perm_indices.\n\t* tree-vectorizer.h (vect_gen_perm_mask_any): Take a vec_perm_indices.\n\t(vect_gen_perm_mask_checked): Likewise.\n\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Take a vec_perm_indices.\n\t(vect_gen_perm_mask_checked): Likewise.\n\t(vectorizable_mask_load_store): Use auto_vec_perm_indices.\n\t(vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\t(perm_mask_for_reverse): Likewise.  Update call to can_vec_perm_p.\n\t(vectorizable_bswap): Likewise.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252761", "tree": {"sha": "15660ec76cab5cc22a0052c6cf11bdbe96bc2fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/15660ec76cab5cc22a0052c6cf11bdbe96bc2fd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/908a1a166dccefa24ae8b3606f4ce1da944eecb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908a1a166dccefa24ae8b3606f4ce1da944eecb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/908a1a166dccefa24ae8b3606f4ce1da944eecb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908a1a166dccefa24ae8b3606f4ce1da944eecb0/comments", "author": null, "committer": null, "parents": [{"sha": "794e31808f1554d51f0f0357c3a74a6365f0a274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/794e31808f1554d51f0f0357c3a74a6365f0a274", "html_url": "https://github.com/Rust-GCC/gccrs/commit/794e31808f1554d51f0f0357c3a74a6365f0a274"}], "stats": {"total": 287, "additions": 176, "deletions": 111}, "files": [{"sha": "a6c6fcc5cef65970de95706b6f541e9f3e081dbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -1,3 +1,41 @@\n+2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.h (vec_perm_indices): New typedef.\n+\t(auto_vec_perm_indices): Likewise.\n+\t* optabs-query.h: Include target.h\n+\t(can_vec_perm_p): Take a vec_perm_indices *.\n+\t* optabs-query.c (can_vec_perm_p): Likewise.\n+\t(can_mult_highpart_p): Update accordingly.  Use auto_vec_perm_indices.\n+\t* tree-ssa-forwprop.c (simplify_vector_constructor): Likewise.\n+\t* tree-vect-generic.c (lower_vec_perm): Likewise.\n+\t* tree-vect-data-refs.c (vect_grouped_store_supported): Likewise.\n+\t(vect_grouped_load_supported): Likewise.\n+\t(vect_shift_permute_load_chain): Likewise.\n+\t(vect_permute_store_chain): Use auto_vec_perm_indices.\n+\t(vect_permute_load_chain): Likewise.\n+\t* fold-const.c (fold_vec_perm): Take vec_perm_indices.\n+\t(fold_ternary_loc): Update accordingly.  Use auto_vec_perm_indices.\n+\tUpdate uses of can_vec_perm_p.\n+\t* tree-vect-loop.c (calc_vec_perm_mask_for_shift): Replace the\n+\tmode with a number of elements.  Take a vec_perm_indices *.\n+\t(vect_create_epilog_for_reduction): Update accordingly.\n+\tUse auto_vec_perm_indices.\n+\t(have_whole_vector_shift): Likewise.  Update call to can_vec_perm_p.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Likewise.\n+\t(vect_transform_slp_perm_load): Likewise.\n+\t(vect_schedule_slp_instance): Use auto_vec_perm_indices.\n+\t* tree-vectorizer.h (vect_gen_perm_mask_any): Take a vec_perm_indices.\n+\t(vect_gen_perm_mask_checked): Likewise.\n+\t* tree-vect-stmts.c (vect_gen_perm_mask_any): Take a vec_perm_indices.\n+\t(vect_gen_perm_mask_checked): Likewise.\n+\t(vectorizable_mask_load_store): Use auto_vec_perm_indices.\n+\t(vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\t(perm_mask_for_reverse): Likewise.  Update call to can_vec_perm_p.\n+\t(vectorizable_bswap): Likewise.\n+\n 2017-09-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "fa9d1bb20ff503231f77eb85ccbd548594d14c3f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -8786,12 +8786,14 @@ vec_cst_ctor_to_array (tree arg, unsigned int nelts, tree *elts)\n    NULL_TREE otherwise.  */\n \n static tree\n-fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n+fold_vec_perm (tree type, tree arg0, tree arg1, vec_perm_indices sel)\n {\n-  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+  unsigned int i;\n   bool need_ctor = false;\n \n-  gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n+  unsigned int nelts = sel.length ();\n+  gcc_assert (TYPE_VECTOR_SUBPARTS (type) == nelts\n+\t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n \t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts);\n   if (TREE_TYPE (TREE_TYPE (arg0)) != TREE_TYPE (type)\n       || TREE_TYPE (TREE_TYPE (arg1)) != TREE_TYPE (type))\n@@ -11312,15 +11314,15 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t\t  || TREE_CODE (arg2) == CONSTRUCTOR))\n \t    {\n \t      unsigned int nelts = VECTOR_CST_NELTS (arg0), i;\n-\t      unsigned char *sel = XALLOCAVEC (unsigned char, nelts);\n \t      gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n+\t      auto_vec_perm_indices sel (nelts);\n \t      for (i = 0; i < nelts; i++)\n \t\t{\n \t\t  tree val = VECTOR_CST_ELT (arg0, i);\n \t\t  if (integer_all_onesp (val))\n-\t\t    sel[i] = i;\n+\t\t    sel.quick_push (i);\n \t\t  else if (integer_zerop (val))\n-\t\t    sel[i] = nelts + i;\n+\t\t    sel.quick_push (nelts + i);\n \t\t  else /* Currently unreachable.  */\n \t\t    return NULL_TREE;\n \t\t}\n@@ -11643,8 +11645,6 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       if (TREE_CODE (arg2) == VECTOR_CST)\n \t{\n \t  unsigned int nelts = VECTOR_CST_NELTS (arg2), i, mask, mask2;\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, 2 * nelts);\n-\t  unsigned char *sel2 = sel + nelts;\n \t  bool need_mask_canon = false;\n \t  bool need_mask_canon2 = false;\n \t  bool all_in_vec0 = true;\n@@ -11656,6 +11656,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t  mask2 = 2 * nelts - 1;\n \t  mask = single_arg ? (nelts - 1) : mask2;\n \t  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (type));\n+\t  auto_vec_perm_indices sel (nelts);\n+\t  auto_vec_perm_indices sel2 (nelts);\n \t  for (i = 0; i < nelts; i++)\n \t    {\n \t      tree val = VECTOR_CST_ELT (arg2, i);\n@@ -11667,16 +11669,19 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t      wide_int t = val;\n \t      need_mask_canon |= wi::gtu_p (t, mask);\n \t      need_mask_canon2 |= wi::gtu_p (t, mask2);\n-\t      sel[i] = t.to_uhwi () & mask;\n-\t      sel2[i] = t.to_uhwi () & mask2;\n+\t      unsigned int elt = t.to_uhwi () & mask;\n+\t      unsigned int elt2 = t.to_uhwi () & mask2;\n \n-\t      if (sel[i] < nelts)\n+\t      if (elt < nelts)\n \t\tall_in_vec1 = false;\n \t      else\n \t\tall_in_vec0 = false;\n \n-\t      if ((sel[i] & (nelts-1)) != i)\n+\t      if ((elt & (nelts - 1)) != i)\n \t\tmaybe_identity = false;\n+\n+\t      sel.quick_push (elt);\n+\t      sel2.quick_push (elt2);\n \t    }\n \n \t  if (maybe_identity)\n@@ -11714,8 +11719,8 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \t     argument permutation while still allowing an equivalent\n \t     2-argument version.  */\n \t  if (need_mask_canon && arg2 == op2\n-\t      && !can_vec_perm_p (TYPE_MODE (type), false, sel)\n-\t      && can_vec_perm_p (TYPE_MODE (type), false, sel2))\n+\t      && !can_vec_perm_p (TYPE_MODE (type), false, &sel)\n+\t      && can_vec_perm_p (TYPE_MODE (type), false, &sel2))\n \t    {\n \t      need_mask_canon = need_mask_canon2;\n \t      sel = sel2;"}, {"sha": "ced6f57f4c26161b4e77bf7311b2a775b18176a4", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -353,8 +353,7 @@ can_conditionally_move_p (machine_mode mode)\n    zeroes; this case is not dealt with here.  */\n \n bool\n-can_vec_perm_p (machine_mode mode, bool variable,\n-\t\tconst unsigned char *sel)\n+can_vec_perm_p (machine_mode mode, bool variable, vec_perm_indices *sel)\n {\n   machine_mode qimode;\n \n@@ -368,7 +367,7 @@ can_vec_perm_p (machine_mode mode, bool variable,\n       if (direct_optab_handler (vec_perm_const_optab, mode) != CODE_FOR_nothing\n \t  && (sel == NULL\n \t      || targetm.vectorize.vec_perm_const_ok == NULL\n-\t      || targetm.vectorize.vec_perm_const_ok (mode, sel)))\n+\t      || targetm.vectorize.vec_perm_const_ok (mode, &(*sel)[0])))\n \treturn true;\n     }\n \n@@ -460,7 +459,6 @@ int\n can_mult_highpart_p (machine_mode mode, bool uns_p)\n {\n   optab op;\n-  unsigned char *sel;\n   unsigned i, nunits;\n \n   op = uns_p ? umul_highpart_optab : smul_highpart_optab;\n@@ -472,17 +470,19 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n     return 0;\n \n   nunits = GET_MODE_NUNITS (mode);\n-  sel = XALLOCAVEC (unsigned char, nunits);\n \n   op = uns_p ? vec_widen_umult_even_optab : vec_widen_smult_even_optab;\n   if (optab_handler (op, mode) != CODE_FOR_nothing)\n     {\n       op = uns_p ? vec_widen_umult_odd_optab : vec_widen_smult_odd_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n+\t  auto_vec_perm_indices sel (nunits);\n \t  for (i = 0; i < nunits; ++i)\n-\t    sel[i] = !BYTES_BIG_ENDIAN + (i & ~1) + ((i & 1) ? nunits : 0);\n-\t  if (can_vec_perm_p (mode, false, sel))\n+\t    sel.quick_push (!BYTES_BIG_ENDIAN\n+\t\t\t    + (i & ~1)\n+\t\t\t    + ((i & 1) ? nunits : 0));\n+\t  if (can_vec_perm_p (mode, false, &sel))\n \t    return 2;\n \t}\n     }\n@@ -493,9 +493,10 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n       op = uns_p ? vec_widen_umult_lo_optab : vec_widen_smult_lo_optab;\n       if (optab_handler (op, mode) != CODE_FOR_nothing)\n \t{\n+\t  auto_vec_perm_indices sel (nunits);\n \t  for (i = 0; i < nunits; ++i)\n-\t    sel[i] = 2 * i + (BYTES_BIG_ENDIAN ? 0 : 1);\n-\t  if (can_vec_perm_p (mode, false, sel))\n+\t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n+\t  if (can_vec_perm_p (mode, false, &sel))\n \t    return 3;\n \t}\n     }"}, {"sha": "9c2d57404f0e59482ada89789cd53d4d15ebb3ee", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_OPTABS_QUERY_H\n \n #include \"insn-opinit.h\"\n+#include \"target.h\"\n \n /* Return the insn used to implement mode MODE of OP, or CODE_FOR_nothing\n    if the target does not have such an insn.  */\n@@ -165,7 +166,7 @@ enum insn_code can_extend_p (machine_mode, machine_mode, int);\n enum insn_code can_float_p (machine_mode, machine_mode, int);\n enum insn_code can_fix_p (machine_mode, machine_mode, int, bool *);\n bool can_conditionally_move_p (machine_mode mode);\n-bool can_vec_perm_p (machine_mode, bool, const unsigned char *);\n+bool can_vec_perm_p (machine_mode, bool, vec_perm_indices *);\n enum insn_code widening_optab_handler (optab, machine_mode, machine_mode);\n /* Find a widening optab even if it doesn't widen as much as we want.  */\n #define find_widening_optab_handler(A,B,C,D) \\"}, {"sha": "64e1d68f0e01a7620df16b427957d3e9ab650915", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -191,6 +191,14 @@ enum vect_cost_model_location {\n   vect_epilogue = 2\n };\n \n+/* The type to use for vector permutes with a constant permute vector.\n+   Each entry is an index into the concatenated input vectors.  */\n+typedef vec<unsigned char> vec_perm_indices;\n+\n+/* Same, but can be used to construct local permute vectors that are\n+   automatically freed.  */\n+typedef auto_vec<unsigned char, 32> auto_vec_perm_indices;\n+\n /* The target structure.  This holds all the backend hooks.  */\n #define DEFHOOKPOD(NAME, DOC, TYPE, INIT) TYPE NAME;\n #define DEFHOOK(NAME, DOC, TYPE, PARAMS, INIT) TYPE (* NAME) PARAMS;"}, {"sha": "11511b4284c636a057e685b2bfd61d9cfefa779d", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -1952,7 +1952,6 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   unsigned elem_size, nelts, i;\n   enum tree_code code, conv_code;\n   constructor_elt *elt;\n-  unsigned char *sel;\n   bool maybe_ident;\n \n   gcc_checking_assert (gimple_assign_rhs_code (stmt) == CONSTRUCTOR);\n@@ -1965,7 +1964,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n   elem_type = TREE_TYPE (type);\n   elem_size = TREE_INT_CST_LOW (TYPE_SIZE (elem_type));\n \n-  sel = XALLOCAVEC (unsigned char, nelts);\n+  auto_vec_perm_indices sel (nelts);\n   orig = NULL;\n   conv_code = ERROR_MARK;\n   maybe_ident = true;\n@@ -2023,8 +2022,10 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t}\n       if (TREE_INT_CST_LOW (TREE_OPERAND (op1, 1)) != elem_size)\n \treturn false;\n-      sel[i] = TREE_INT_CST_LOW (TREE_OPERAND (op1, 2)) / elem_size;\n-      if (sel[i] != i) maybe_ident = false;\n+      unsigned int elt = TREE_INT_CST_LOW (TREE_OPERAND (op1, 2)) / elem_size;\n+      if (elt != i)\n+\tmaybe_ident = false;\n+      sel.quick_push (elt);\n     }\n   if (i < nelts)\n     return false;\n@@ -2053,7 +2054,7 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n     {\n       tree mask_type;\n \n-      if (!can_vec_perm_p (TYPE_MODE (type), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (type), false, &sel))\n \treturn false;\n       mask_type\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),"}, {"sha": "0b3b968c172b3f52005e3f343c9227305219de09", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -4547,7 +4547,8 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-      unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+      auto_vec_perm_indices sel (nelt);\n+      sel.quick_grow (nelt);\n \n       if (count == 3)\n \t{\n@@ -4568,7 +4569,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = 0;\n \t\t}\n-\t      if (!can_vec_perm_p (mode, false, sel))\n+\t      if (!can_vec_perm_p (mode, false, &sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -4585,7 +4586,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t  if (3 * i + nelt2 < nelt)\n \t\t    sel[3 * i + nelt2] = nelt + j2++;\n \t\t}\n-\t      if (!can_vec_perm_p (mode, false, sel))\n+\t      if (!can_vec_perm_p (mode, false, &sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -4605,13 +4606,13 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t      sel[i * 2] = i;\n \t      sel[i * 2 + 1] = i + nelt;\n \t    }\n-\t    if (can_vec_perm_p (mode, false, sel))\n-\t      {\n-\t\tfor (i = 0; i < nelt; i++)\n-\t\t  sel[i] += nelt / 2;\n-\t\tif (can_vec_perm_p (mode, false, sel))\n-\t\t  return true;\n-\t      }\n+\t  if (can_vec_perm_p (mode, false, &sel))\n+\t    {\n+\t      for (i = 0; i < nelt; i++)\n+\t\tsel[i] += nelt / 2;\n+\t      if (can_vec_perm_p (mode, false, &sel))\n+\t\treturn true;\n+\t    }\n \t}\n     }\n \n@@ -4710,7 +4711,9 @@ vect_permute_store_chain (vec<tree> dr_chain,\n   tree perm3_mask_low, perm3_mask_high;\n   unsigned int i, n, log_length = exact_log2 (length);\n   unsigned int j, nelt = TYPE_VECTOR_SUBPARTS (vectype);\n-  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+\n+  auto_vec_perm_indices sel (nelt);\n+  sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n@@ -5132,7 +5135,8 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n   if (VECTOR_MODE_P (mode))\n     {\n       unsigned int i, j, nelt = GET_MODE_NUNITS (mode);\n-      unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+      auto_vec_perm_indices sel (nelt);\n+      sel.quick_grow (nelt);\n \n       if (count == 3)\n \t{\n@@ -5144,7 +5148,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = 3 * i + k;\n \t\telse\n \t\t  sel[i] = 0;\n-\t      if (!can_vec_perm_p (mode, false, sel))\n+\t      if (!can_vec_perm_p (mode, false, &sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5157,7 +5161,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\t  sel[i] = i;\n \t\telse\n \t\t  sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n-\t      if (!can_vec_perm_p (mode, false, sel))\n+\t      if (!can_vec_perm_p (mode, false, &sel))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5174,11 +5178,11 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t  gcc_assert (pow2p_hwi (count));\n \t  for (i = 0; i < nelt; i++)\n \t    sel[i] = i * 2;\n-\t  if (can_vec_perm_p (mode, false, sel))\n+\t  if (can_vec_perm_p (mode, false, &sel))\n \t    {\n \t      for (i = 0; i < nelt; i++)\n \t\tsel[i] = i * 2 + 1;\n-\t      if (can_vec_perm_p (mode, false, sel))\n+\t      if (can_vec_perm_p (mode, false, &sel))\n \t\treturn true;\n \t    }\n         }\n@@ -5292,7 +5296,9 @@ vect_permute_load_chain (vec<tree> dr_chain,\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   unsigned int i, j, log_length = exact_log2 (length);\n   unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n-  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+\n+  auto_vec_perm_indices sel (nelt);\n+  sel.quick_grow (nelt);\n \n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n@@ -5486,10 +5492,12 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n   unsigned int i;\n   unsigned nelt = TYPE_VECTOR_SUBPARTS (vectype);\n-  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n \n+  auto_vec_perm_indices sel (nelt);\n+  sel.quick_grow (nelt);\n+\n   result_chain->quick_grow (length);\n   memcpy (result_chain->address (), dr_chain.address (),\n \t  length * sizeof (tree));\n@@ -5501,7 +5509,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i * 2;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2 + 1;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5515,7 +5523,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i * 2 + 1;\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5529,7 +5537,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {4 5 6 7 8 9 10 11}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = nelt / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5544,7 +5552,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \tsel[i] = i;\n       for (i = nelt / 2; i < nelt; i++)\n \tsel[i] = nelt + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5607,7 +5615,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t  sel[i] = 3 * k + (l % 3);\n \t  k++;\n \t}\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5621,7 +5629,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {6 7 8 9 10 11 12 13}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5634,7 +5642,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + 1 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5647,7 +5655,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {3 4 5 6 7 8 9 10}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5660,7 +5668,7 @@ vect_shift_permute_load_chain (vec<tree> dr_chain,\n \t For vector length 8 it is {5 6 7 8 9 10 11 12}.  */\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) / 2 + i;\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "b114ff09006d824cc684f5046570c7f82cbc55ab", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -1300,13 +1300,13 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n \n   if (TREE_CODE (mask) == VECTOR_CST)\n     {\n-      unsigned char *sel_int = XALLOCAVEC (unsigned char, elements);\n+      auto_vec_perm_indices sel_int (elements);\n \n       for (i = 0; i < elements; ++i)\n-\tsel_int[i] = (TREE_INT_CST_LOW (VECTOR_CST_ELT (mask, i))\n-\t\t      & (2 * elements - 1));\n+\tsel_int.quick_push (TREE_INT_CST_LOW (VECTOR_CST_ELT (mask, i))\n+\t\t\t    & (2 * elements - 1));\n \n-      if (can_vec_perm_p (TYPE_MODE (vect_type), false, sel_int))\n+      if (can_vec_perm_p (TYPE_MODE (vect_type), false, &sel_int))\n \t{\n \t  gimple_assign_set_rhs3 (stmt, mask);\n \t  update_stmt (stmt);"}, {"sha": "8135219ea248412df11b03835157fad0df17e238", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -3698,15 +3698,15 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n }\n \n /* Writes into SEL a mask for a vec_perm, equivalent to a vec_shr by OFFSET\n-   vector elements (not bits) for a vector of mode MODE.  */\n+   vector elements (not bits) for a vector with NELT elements.  */\n static void\n-calc_vec_perm_mask_for_shift (machine_mode mode, unsigned int offset,\n-\t\t\t      unsigned char *sel)\n+calc_vec_perm_mask_for_shift (unsigned int offset, unsigned int nelt,\n+\t\t\t      vec_perm_indices *sel)\n {\n-  unsigned int i, nelt = GET_MODE_NUNITS (mode);\n+  unsigned int i;\n \n   for (i = 0; i < nelt; i++)\n-    sel[i] = (i + offset) & (2*nelt - 1);\n+    sel->quick_push ((i + offset) & (2 * nelt - 1));\n }\n \n /* Checks whether the target supports whole-vector shifts for vectors of mode\n@@ -3722,12 +3722,13 @@ have_whole_vector_shift (machine_mode mode)\n     return false;\n \n   unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+  auto_vec_perm_indices sel (nelt);\n \n   for (i = nelt/2; i >= 1; i/=2)\n     {\n-      calc_vec_perm_mask_for_shift (mode, i, sel);\n-      if (!can_vec_perm_p (mode, false, sel))\n+      sel.truncate (0);\n+      calc_vec_perm_mask_for_shift (i, nelt, &sel);\n+      if (!can_vec_perm_p (mode, false, &sel))\n \treturn false;\n     }\n   return true;\n@@ -5059,7 +5060,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       if (reduce_with_shift && !slp_reduc)\n         {\n           int nelements = vec_size_in_bits / element_bitsize;\n-          unsigned char *sel = XALLOCAVEC (unsigned char, nelements);\n+          auto_vec_perm_indices sel (nelements);\n \n           int elt_offset;\n \n@@ -5083,8 +5084,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                elt_offset >= 1;\n                elt_offset /= 2)\n             {\n-              calc_vec_perm_mask_for_shift (mode, elt_offset, sel);\n-              tree mask = vect_gen_perm_mask_any (vectype, sel);\n+\t      sel.truncate (0);\n+\t      calc_vec_perm_mask_for_shift (elt_offset, nelements, &sel);\n+\t      tree mask = vect_gen_perm_mask_any (vectype, sel);\n \t      epilog_stmt = gimple_build_assign (vec_dest, VEC_PERM_EXPR,\n \t\t\t\t\t\t new_temp, zero_vec, mask);\n               new_name = make_ssa_name (vec_dest, epilog_stmt);"}, {"sha": "32174fe6bb02f187897553ecde73b4a07c4432b3", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -873,15 +873,16 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   if (alt_stmt_code != ERROR_MARK\n       && TREE_CODE_CLASS (alt_stmt_code) != tcc_reference)\n     {\n-      unsigned char *sel\n-\t= XALLOCAVEC (unsigned char, TYPE_VECTOR_SUBPARTS (vectype));\n-      for (i = 0; i < TYPE_VECTOR_SUBPARTS (vectype); ++i)\n+      unsigned int count = TYPE_VECTOR_SUBPARTS (vectype);\n+      auto_vec_perm_indices sel (count);\n+      for (i = 0; i < count; ++i)\n \t{\n-\t  sel[i] = i;\n+\t  unsigned int elt = i;\n \t  if (gimple_assign_rhs_code (stmts[i % group_size]) == alt_stmt_code)\n-\t    sel[i] += TYPE_VECTOR_SUBPARTS (vectype);\n+\t    elt += count;\n+\t  sel.quick_push (elt);\n \t}\n-      if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+      if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n \t{\n \t  for (i = 0; i < group_size; ++i)\n \t    if (gimple_assign_rhs_code (stmts[i]) == alt_stmt_code)\n@@ -3486,7 +3487,6 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   int group_size = SLP_INSTANCE_GROUP_SIZE (slp_node_instance);\n   int mask_element;\n-  unsigned char *mask;\n   machine_mode mode;\n \n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n@@ -3502,7 +3502,8 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_element_type);\n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  mask = XALLOCAVEC (unsigned char, nunits);\n+  auto_vec_perm_indices mask (nunits);\n+  mask.quick_grow (nunits);\n \n   /* Initialize the vect stmts of NODE to properly insert the generated\n      stmts later.  */\n@@ -3577,7 +3578,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t  if (index == nunits)\n \t    {\n \t      if (! noop_p\n-\t\t  && ! can_vec_perm_p (mode, false, mask))\n+\t\t  && ! can_vec_perm_p (mode, false, &mask))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    {\n@@ -3730,15 +3731,15 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       enum tree_code code0 = gimple_assign_rhs_code (stmt);\n       enum tree_code ocode = ERROR_MARK;\n       gimple *ostmt;\n-      unsigned char *mask = XALLOCAVEC (unsigned char, group_size);\n+      auto_vec_perm_indices mask (group_size);\n       FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, ostmt)\n \tif (gimple_assign_rhs_code (ostmt) != code0)\n \t  {\n-\t    mask[i] = 1;\n+\t    mask.quick_push (1);\n \t    ocode = gimple_assign_rhs_code (ostmt);\n \t  }\n \telse\n-\t  mask[i] = 0;\n+\t  mask.quick_push (0);\n       if (ocode != ERROR_MARK)\n \t{\n \t  vec<gimple *> v0;"}, {"sha": "0cee0d4879266b3bc8cc77736bfa5ab032708248", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -1706,15 +1706,14 @@ static tree\n perm_mask_for_reverse (tree vectype)\n {\n   int i, nunits;\n-  unsigned char *sel;\n \n   nunits = TYPE_VECTOR_SUBPARTS (vectype);\n-  sel = XALLOCAVEC (unsigned char, nunits);\n \n+  auto_vec_perm_indices sel (nunits);\n   for (i = 0; i < nunits; ++i)\n-    sel[i] = nunits - 1 - i;\n+    sel.quick_push (nunits - 1 - i);\n \n-  if (!can_vec_perm_p (TYPE_MODE (vectype), false, sel))\n+  if (!can_vec_perm_p (TYPE_MODE (vectype), false, &sel))\n     return NULL_TREE;\n   return vect_gen_perm_mask_checked (vectype, sel);\n }\n@@ -2171,19 +2170,20 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \tmodifier = NONE;\n       else if (nunits == gather_off_nunits / 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, gather_off_nunits);\n \t  modifier = WIDEN;\n \n+\t  auto_vec_perm_indices sel (gather_off_nunits);\n \t  for (i = 0; i < gather_off_nunits; ++i)\n-\t    sel[i] = i | nunits;\n+\t    sel.quick_push (i | nunits);\n \n \t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, nunits);\n \t  modifier = NARROW;\n \n+\t  auto_vec_perm_indices sel (nunits);\n+\t  sel.quick_grow (nunits);\n \t  for (i = 0; i < nunits; ++i)\n \t    sel[i] = i < gather_off_nunits\n \t\t     ? i : i + nunits - gather_off_nunits;\n@@ -2481,14 +2481,14 @@ vectorizable_bswap (gimple *stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   unsigned int num_bytes = TYPE_VECTOR_SUBPARTS (char_vectype);\n-  unsigned char *elts = XALLOCAVEC (unsigned char, num_bytes);\n-  unsigned char *elt = elts;\n   unsigned word_bytes = num_bytes / nunits;\n+\n+  auto_vec_perm_indices elts (num_bytes);\n   for (unsigned i = 0; i < nunits; ++i)\n     for (unsigned j = 0; j < word_bytes; ++j)\n-      *elt++ = (i + 1) * word_bytes - j - 1;\n+      elts.quick_push ((i + 1) * word_bytes - j - 1);\n \n-  if (! can_vec_perm_p (TYPE_MODE (char_vectype), false, elts))\n+  if (! can_vec_perm_p (TYPE_MODE (char_vectype), false, &elts))\n     return false;\n \n   if (! vec_stmt)\n@@ -5803,22 +5803,22 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \tmodifier = NONE;\n       else if (nunits == (unsigned int) scatter_off_nunits / 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, scatter_off_nunits);\n \t  modifier = WIDEN;\n \n+\t  auto_vec_perm_indices sel (scatter_off_nunits);\n \t  for (i = 0; i < (unsigned int) scatter_off_nunits; ++i)\n-\t    sel[i] = i | nunits;\n+\t    sel.quick_push (i | nunits);\n \n \t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t}\n       else if (nunits == (unsigned int) scatter_off_nunits * 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, nunits);\n \t  modifier = NARROW;\n \n+\t  auto_vec_perm_indices sel (nunits);\n \t  for (i = 0; i < (unsigned int) nunits; ++i)\n-\t    sel[i] = i | scatter_off_nunits;\n+\t    sel.quick_push (i | scatter_off_nunits);\n \n \t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n \t  gcc_assert (perm_mask != NULL_TREE);\n@@ -6503,19 +6503,19 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n    vect_gen_perm_mask_checked.  */\n \n tree\n-vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n+vect_gen_perm_mask_any (tree vectype, vec_perm_indices sel)\n {\n   tree mask_elt_type, mask_type, mask_vec;\n-  int i, nunits;\n \n-  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  unsigned int nunits = sel.length ();\n+  gcc_checking_assert (nunits == TYPE_VECTOR_SUBPARTS (vectype));\n \n   mask_elt_type = lang_hooks.types.type_for_mode\n     (int_mode_for_mode (TYPE_MODE (TREE_TYPE (vectype))).require (), 1);\n   mask_type = get_vectype_for_scalar_type (mask_elt_type);\n \n   auto_vec<tree, 32> mask_elts (nunits);\n-  for (i = 0; i < nunits; ++i)\n+  for (unsigned int i = 0; i < nunits; ++i)\n     mask_elts.quick_push (build_int_cst (mask_elt_type, sel[i]));\n   mask_vec = build_vector (mask_type, mask_elts);\n \n@@ -6526,9 +6526,9 @@ vect_gen_perm_mask_any (tree vectype, const unsigned char *sel)\n    i.e. that the target supports the pattern _for arbitrary input vectors_.  */\n \n tree\n-vect_gen_perm_mask_checked (tree vectype, const unsigned char *sel)\n+vect_gen_perm_mask_checked (tree vectype, vec_perm_indices sel)\n {\n-  gcc_assert (can_vec_perm_p (TYPE_MODE (vectype), false, sel));\n+  gcc_assert (can_vec_perm_p (TYPE_MODE (vectype), false, &sel));\n   return vect_gen_perm_mask_any (vectype, sel);\n }\n \n@@ -6841,22 +6841,22 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n \tmodifier = NONE;\n       else if (nunits == gather_off_nunits / 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, gather_off_nunits);\n \t  modifier = WIDEN;\n \n+\t  auto_vec_perm_indices sel (gather_off_nunits);\n \t  for (i = 0; i < gather_off_nunits; ++i)\n-\t    sel[i] = i | nunits;\n+\t    sel.quick_push (i | nunits);\n \n \t  perm_mask = vect_gen_perm_mask_checked (gs_info.offset_vectype, sel);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n \t{\n-\t  unsigned char *sel = XALLOCAVEC (unsigned char, nunits);\n \t  modifier = NARROW;\n \n+\t  auto_vec_perm_indices sel (nunits);\n \t  for (i = 0; i < nunits; ++i)\n-\t    sel[i] = i < gather_off_nunits\n-\t\t     ? i : i + nunits - gather_off_nunits;\n+\t    sel.quick_push (i < gather_off_nunits\n+\t\t\t    ? i : i + nunits - gather_off_nunits);\n \n \t  perm_mask = vect_gen_perm_mask_checked (vectype, sel);\n \t  ncopies *= 2;"}, {"sha": "7ed00782148ae94e665f45d07fcb677a166578a9", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/908a1a166dccefa24ae8b3606f4ce1da944eecb0/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=908a1a166dccefa24ae8b3606f4ce1da944eecb0", "patch": "@@ -1151,8 +1151,8 @@ extern void vect_get_load_cost (struct data_reference *, int, bool,\n extern void vect_get_store_cost (struct data_reference *, int,\n \t\t\t\t unsigned int *, stmt_vector_for_cost *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n-extern tree vect_gen_perm_mask_any (tree, const unsigned char *);\n-extern tree vect_gen_perm_mask_checked (tree, const unsigned char *);\n+extern tree vect_gen_perm_mask_any (tree, vec_perm_indices);\n+extern tree vect_gen_perm_mask_checked (tree, vec_perm_indices);\n extern void optimize_mask_stores (struct loop*);\n \n /* In tree-vect-data-refs.c.  */"}]}