{"sha": "72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJkMWM4ZGQ4MzAxY2Q2OGJmOGI1ZjllODk3MTMzNmEyMTFhZGRhNA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-09-21T22:11:42Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2016-09-21T22:11:42Z"}, "message": "re PR target/77670 (PowerPC64 Spec 2006 fails on 453.povray using -mcpu=power9 -mpower9-minmax)\n\n2016-09-21  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/77670\n\t* config/rs6000/predicates.md (invert_fpmask_comparison_operator):\n\tNew predicate that matches the ISA 3.0 XSCMP{EQ,GT,GE}DP\n\tinstructions when you want to invert the test.\n\t* config/rs6000/rs6000.md (fpmask<mode>): Use the arguments in the\n\tcorrect order for XXSEL.\n\t(mov<SFDF:mode><SFDF2:mode>cc_invert_p9): Define the inverted test\n\tfor using XSCMP{EQ,GT,GE}DP.\n\nFrom-SVN: r240335", "tree": {"sha": "684907a78493a19e56352445b2e65b1494d73154", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/684907a78493a19e56352445b2e65b1494d73154"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d1c8dd8301cd68bf8b5f9e8971336a211adda4/comments", "author": null, "committer": null, "parents": [{"sha": "4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a"}], "stats": {"total": 45, "additions": 44, "deletions": 1}, "files": [{"sha": "be61b2b5aeae3d2dd0d2e5fa5b1feb00f842e7c7", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1c8dd8301cd68bf8b5f9e8971336a211adda4/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1c8dd8301cd68bf8b5f9e8971336a211adda4/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "patch": "@@ -1172,6 +1172,12 @@\n (define_predicate \"fpmask_comparison_operator\"\n   (match_code \"eq,gt,ge\"))\n \n+;; Return 1 if OP is a comparison operator suitable for vector/scalar\n+;; comparisons that generate a 0/-1 mask (i.e. the inverse of\n+;; fpmask_comparison_operator).\n+(define_predicate \"invert_fpmask_comparison_operator\"\n+  (match_code \"ne,unlt,unle\"))\n+\n ;; Return 1 if OP is a comparison operation that is valid for a branch\n ;; insn, which is true if the corresponding bit in the CC register is set.\n (define_predicate \"branch_positive_comparison_operator\""}, {"sha": "007d3e66ec99ac0d0367ee4397c839d8285f4977", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72d1c8dd8301cd68bf8b5f9e8971336a211adda4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72d1c8dd8301cd68bf8b5f9e8971336a211adda4/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=72d1c8dd8301cd68bf8b5f9e8971336a211adda4", "patch": "@@ -4882,6 +4882,43 @@\n  [(set_attr \"length\" \"8\")\n   (set_attr \"type\" \"vecperm\")])\n \n+;; Handle inverting the fpmask comparisons.\n+(define_insn_and_split \"*mov<SFDF:mode><SFDF2:mode>cc_invert_p9\"\n+  [(set (match_operand:SFDF 0 \"vsx_register_operand\" \"=&<SFDF:Fv>,<SFDF:Fv>\")\n+\t(if_then_else:SFDF\n+\t (match_operator:CCFP 1 \"invert_fpmask_comparison_operator\"\n+\t\t[(match_operand:SFDF2 2 \"vsx_register_operand\" \"<SFDF2:Fv>,<SFDF2:Fv>\")\n+\t\t (match_operand:SFDF2 3 \"vsx_register_operand\" \"<SFDF2:Fv>,<SFDF2:Fv>\")])\n+\t (match_operand:SFDF 4 \"vsx_register_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")\n+\t (match_operand:SFDF 5 \"vsx_register_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n+   (clobber (match_scratch:V2DI 6 \"=0,&wa\"))]\n+  \"TARGET_P9_MINMAX\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 6)\n+\t(if_then_else:V2DI (match_dup 9)\n+\t\t\t   (match_dup 7)\n+\t\t\t   (match_dup 8)))\n+   (set (match_dup 0)\n+\t(if_then_else:SFDF (ne (match_dup 6)\n+\t\t\t       (match_dup 8))\n+\t\t\t   (match_dup 5)\n+\t\t\t   (match_dup 4)))]\n+{\n+  rtx op1 = operands[1];\n+  enum rtx_code cond = reverse_condition_maybe_unordered (GET_CODE (op1));\n+\n+  if (GET_CODE (operands[6]) == SCRATCH)\n+    operands[6] = gen_reg_rtx (V2DImode);\n+\n+  operands[7] = CONSTM1_RTX (V2DImode);\n+  operands[8] = CONST0_RTX (V2DImode);\n+\n+  operands[9] = gen_rtx_fmt_ee (cond, CCFPmode, operands[2], operands[3]);\n+}\n+ [(set_attr \"length\" \"8\")\n+  (set_attr \"type\" \"vecperm\")])\n+\n (define_insn \"*fpmask<mode>\"\n   [(set (match_operand:V2DI 0 \"vsx_register_operand\" \"=wa\")\n \t(if_then_else:V2DI\n@@ -4901,7 +4938,7 @@\n \t\t\t   (match_operand:SFDF 3 \"vsx_register_operand\" \"<Fv>\")\n \t\t\t   (match_operand:SFDF 4 \"vsx_register_operand\" \"<Fv>\")))]\n   \"TARGET_P9_MINMAX\"\n-  \"xxsel %x0,%x1,%x3,%x4\"\n+  \"xxsel %x0,%x4,%x3,%x1\"\n   [(set_attr \"type\" \"vecmove\")])\n \n \f"}]}