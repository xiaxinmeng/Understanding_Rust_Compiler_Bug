{"sha": "e5c95afe1e18581b060601f70b1a6888835028ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTVjOTVhZmUxZTE4NTgxYjA2MDYwMWY3MGIxYTY4ODg4MzUwMjhjZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2007-08-01T11:50:39Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-08-01T11:50:39Z"}, "message": "tree-pretty-print.c (dump_generic_node): Dump OMP_SECTIONS_SWITCH.\n\n\t* tree-pretty-print.c (dump_generic_node): Dump OMP_SECTIONS_SWITCH.\n\tDisplay new operands of OMP_SECTIONS and OMP_CONTINUE.\n\t* tree.h (OMP_SECTIONS_CONTROL): New macro.\n\t(OMP_DIRECTIVE_P): Add OMP_SECTIONS_SWITCH.\n\t* omp-low.c (get_ws_args_for, determine_parallel_type,\n\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk, expand_omp_for, expand_omp_sections):\n\tWork with more precise CFG.\n\t(build_omp_regions_1): Handle OMP_SECTIONS_SWITCH.\n\t(lower_omp_sections): Emit OMP_SECTIONS_SWITCH.  Add arguments to\n\tOMP_CONTINUE.\n\t* tree-gimple.c (is_gimple_stmt): Handle OMP_SECTIONS_SWITCH.\n\t* gimple-low.c (lower_stmt): Ditto.\n\t* tree-inline.c (estimate_num_insns_1): Ditto.\n\t* tree.def (OMP_SECTIONS, OMP_CONTINUE): Added new operands.\n\t(OMP_SECTIONS_SWITCH): New.\n\t* tree-cfgcleanup.c (cleanup_omp_return): New.\n\t(cleanup_tree_cfg_bb): Call cleanup_omp_return.\n\t* tree-cfg.c (make_edges): Create back edges for OMP_CONTINUE\n\tand exit edge for OMP_FOR.  Handle OMP_SECTIONS_SWITCH.\n\t(tree_redirect_edge_and_branch): Handle omp constructs.\n\n\t* fortran/trans-openmp.c (gfc_trans_omp_sections): Build OMP_SECTIONS\n\twith three arguments.\n\nFrom-SVN: r127121", "tree": {"sha": "ff781d81e1c759d85b9e39299b57bf35bf7747a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff781d81e1c759d85b9e39299b57bf35bf7747a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5c95afe1e18581b060601f70b1a6888835028ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c95afe1e18581b060601f70b1a6888835028ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5c95afe1e18581b060601f70b1a6888835028ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5c95afe1e18581b060601f70b1a6888835028ce/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "203bb67ec4596d07169474c03d36f7726e796120", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/203bb67ec4596d07169474c03d36f7726e796120", "html_url": "https://github.com/Rust-GCC/gccrs/commit/203bb67ec4596d07169474c03d36f7726e796120"}], "stats": {"total": 442, "additions": 277, "deletions": 165}, "files": [{"sha": "d7afe17fd9cdc9d04492f6f18740f44d4f4758d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -1,3 +1,30 @@\n+2007-08-01  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* tree-pretty-print.c (dump_generic_node): Dump OMP_SECTIONS_SWITCH.\n+\tDisplay new operands of OMP_SECTIONS and OMP_CONTINUE.\n+\t* tree.h (OMP_SECTIONS_CONTROL): New macro.\n+\t(OMP_DIRECTIVE_P): Add OMP_SECTIONS_SWITCH.\n+\t* omp-low.c (get_ws_args_for, determine_parallel_type,\n+\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n+\texpand_omp_for_static_chunk, expand_omp_for, expand_omp_sections):\n+\tWork with more precise CFG.\n+\t(build_omp_regions_1): Handle OMP_SECTIONS_SWITCH.\n+\t(lower_omp_sections): Emit OMP_SECTIONS_SWITCH.  Add arguments to\n+\tOMP_CONTINUE.\n+\t* tree-gimple.c (is_gimple_stmt): Handle OMP_SECTIONS_SWITCH.\n+\t* gimple-low.c (lower_stmt): Ditto.\n+\t* tree-inline.c (estimate_num_insns_1): Ditto.\n+\t* tree.def (OMP_SECTIONS, OMP_CONTINUE): Added new operands.\n+\t(OMP_SECTIONS_SWITCH): New.\n+\t* tree-cfgcleanup.c (cleanup_omp_return): New.\n+\t(cleanup_tree_cfg_bb): Call cleanup_omp_return.\n+\t* tree-cfg.c (make_edges): Create back edges for OMP_CONTINUE\n+\tand exit edge for OMP_FOR.  Handle OMP_SECTIONS_SWITCH.\n+\t(tree_redirect_edge_and_branch): Handle omp constructs.\n+\n+\t* fortran/trans-openmp.c (gfc_trans_omp_sections): Build OMP_SECTIONS\n+\twith three arguments.\n+\n 2007-08-01  Zdenek Dvorak  <ook@ucw.cz>\n \n \t* tree-cfg.c (tree_merge_blocks): Preserve loop exit phi nodes only"}, {"sha": "99fd1d04ba6f6e8f5713c419d071ff1d0306a154", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -1205,7 +1205,7 @@ gfc_trans_omp_sections (gfc_code *code, gfc_omp_clauses *clauses)\n     }\n   stmt = gfc_finish_block (&body);\n \n-  stmt = build2_v (OMP_SECTIONS, stmt, omp_clauses);\n+  stmt = build3_v (OMP_SECTIONS, stmt, omp_clauses, NULL_TREE);\n   gfc_add_expr_to_block (&block, stmt);\n \n   return gfc_finish_block (&block);"}, {"sha": "93532b95626985ed7a60d505ce4abba859aeb4a9", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -244,6 +244,7 @@ lower_stmt (tree_stmt_iterator *tsi, struct lower_data *data)\n     case CHANGE_DYNAMIC_TYPE_EXPR:\n     case OMP_FOR:\n     case OMP_SECTIONS:\n+    case OMP_SECTIONS_SWITCH:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:"}, {"sha": "bc1c82193cbe16dfffb400a757d5aaef6ffc974d", "filename": "gcc/omp-low.c", "status": "modified", "additions": 152, "deletions": 150, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -347,8 +347,11 @@ get_ws_args_for (tree ws_stmt)\n     }\n   else if (TREE_CODE (ws_stmt) == OMP_SECTIONS)\n     {\n-      basic_block bb = bb_for_stmt (ws_stmt);\n-      t = build_int_cst (unsigned_type_node, EDGE_COUNT (bb->succs));\n+      /* Number of sections is equal to the number of edges from the\n+\t OMP_SECTIONS_SWITCH statement, except for the one to the exit\n+\t of the sections region.  */\n+      basic_block bb = single_succ (bb_for_stmt (ws_stmt));\n+      t = build_int_cst (unsigned_type_node, EDGE_COUNT (bb->succs) - 1);\n       t = tree_cons (NULL, t, NULL);\n       return t;\n     }\n@@ -366,7 +369,8 @@ determine_parallel_type (struct omp_region *region)\n   basic_block ws_entry_bb, ws_exit_bb;\n \n   if (region == NULL || region->inner == NULL\n-      || region->exit == NULL || region->inner->exit == NULL)\n+      || region->exit == NULL || region->inner->exit == NULL\n+      || region->inner->cont == NULL)\n     return;\n \n   /* We only support parallel+for and parallel+sections.  */\n@@ -2566,7 +2570,7 @@ expand_omp_parallel (struct omp_region *region)\n     L3:\n \n     If this is a combined omp parallel loop, instead of the call to\n-    GOMP_loop_foo_start, we emit 'goto L3'.  */\n+    GOMP_loop_foo_start, we emit 'goto L2'.  */\n \n static void\n expand_omp_for_generic (struct omp_region *region,\n@@ -2580,6 +2584,9 @@ expand_omp_for_generic (struct omp_region *region,\n   basic_block l2_bb = NULL, l3_bb = NULL;\n   block_stmt_iterator si;\n   bool in_combined_parallel = is_combined_parallel (region);\n+  bool broken_loop = region->cont == NULL;\n+\n+  gcc_assert (!broken_loop || !in_combined_parallel);\n \n   type = TREE_TYPE (fd->v);\n \n@@ -2589,19 +2596,23 @@ expand_omp_for_generic (struct omp_region *region,\n   TREE_ADDRESSABLE (istart0) = 1;\n   TREE_ADDRESSABLE (iend0) = 1;\n \n-  gcc_assert ((region->cont != NULL) ^ (region->exit == NULL));\n-\n   entry_bb = region->entry;\n-  l0_bb = create_empty_bb (entry_bb);\n-  l1_bb = single_succ (entry_bb);\n-\n   cont_bb = region->cont;\n-  exit_bb = region->exit;\n-  if (cont_bb)\n+  gcc_assert (EDGE_COUNT (entry_bb->succs) == 2);\n+  gcc_assert (broken_loop\n+\t      || BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n+  l0_bb = split_edge (FALLTHRU_EDGE (entry_bb));\n+  l1_bb = single_succ (l0_bb);\n+  if (!broken_loop)\n     {\n       l2_bb = create_empty_bb (cont_bb);\n-      l3_bb = single_succ (cont_bb);\n+      gcc_assert (BRANCH_EDGE (cont_bb)->dest == l1_bb);\n+      gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n     }\n+  else\n+    l2_bb = NULL;\n+  l3_bb = BRANCH_EDGE (entry_bb)->dest;\n+  exit_bb = region->exit;\n \n   si = bsi_last (entry_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n@@ -2626,11 +2637,8 @@ expand_omp_for_generic (struct omp_region *region,\n \tt = build_call_expr (built_in_decls[start_fn], 5,\n \t\t\t     t0, t1, t2, t3, t4);\n       t = get_formal_tmp_var (t, &list);\n-      if (cont_bb)\n-\t{\n-\t  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-\t  append_to_statement_list (t, &list);\n-\t}\n+      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n+      append_to_statement_list (t, &list);\n       bsi_insert_after (&si, list, BSI_SAME_STMT);\n     }\n   bsi_remove (&si, true);\n@@ -2648,47 +2656,39 @@ expand_omp_for_generic (struct omp_region *region,\n   si = bsi_start (l0_bb);\n   bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n \n-  /* Handle the rare case where BODY doesn't ever return.  */\n-  if (cont_bb == NULL)\n+  if (!broken_loop)\n     {\n-      remove_edge (single_succ_edge (entry_bb));\n-      make_edge (entry_bb, l0_bb, EDGE_FALLTHRU);\n-      make_edge (l0_bb, l1_bb, EDGE_FALLTHRU);\n-      return;\n-    }\n-\n-  /* Code to control the increment and predicate for the sequential\n-     loop goes in the first half of EXIT_BB (we split EXIT_BB so\n-     that we can inherit all the edges going out of the loop\n-     body).  */\n-  list = alloc_stmt_list ();\n+      /* Code to control the increment and predicate for the sequential\n+\t loop goes in the CONT_BB.  */\n+      list = alloc_stmt_list ();\n \n-  t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n+      t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n+      t = build_gimple_modify_stmt (fd->v, t);\n+      gimplify_and_add (t, &list);\n   \n-  t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n-  t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n+      t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n+      t = get_formal_tmp_var (t, &list);\n+      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n+      append_to_statement_list (t, &list);\n \n-  si = bsi_last (cont_bb);\n-  bsi_insert_after (&si, list, BSI_SAME_STMT);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n-  bsi_remove (&si, true);\n+      si = bsi_last (cont_bb);\n+      bsi_insert_after (&si, list, BSI_SAME_STMT);\n+      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n+      bsi_remove (&si, true);\n \n-  /* Emit code to get the next parallel iteration in L2_BB.  */\n-  list = alloc_stmt_list ();\n+      /* Emit code to get the next parallel iteration in L2_BB.  */\n+      list = alloc_stmt_list ();\n \n-  t = build_call_expr (built_in_decls[next_fn], 2,\n-\t\t       build_fold_addr_expr (istart0),\n-\t\t       build_fold_addr_expr (iend0));\n-  t = get_formal_tmp_var (t, &list);\n-  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n+      t = build_call_expr (built_in_decls[next_fn], 2,\n+\t\t\t   build_fold_addr_expr (istart0),\n+\t\t\t   build_fold_addr_expr (iend0));\n+      t = get_formal_tmp_var (t, &list);\n+      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n+      append_to_statement_list (t, &list);\n   \n-  si = bsi_start (l2_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+      si = bsi_start (l2_bb);\n+      bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+    }\n \n   /* Add the loop cleanup function.  */\n   si = bsi_last (exit_bb);\n@@ -2701,23 +2701,26 @@ expand_omp_for_generic (struct omp_region *region,\n   bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n-  remove_edge (single_succ_edge (entry_bb));\n   if (in_combined_parallel)\n-    make_edge (entry_bb, l2_bb, EDGE_FALLTHRU);\n+    {\n+      remove_edge (BRANCH_EDGE (entry_bb));\n+      redirect_edge_and_branch (single_succ_edge (entry_bb), l2_bb);\n+    }\n   else\n     {\n-      make_edge (entry_bb, l0_bb, EDGE_TRUE_VALUE);\n-      make_edge (entry_bb, l3_bb, EDGE_FALSE_VALUE);\n+      find_edge (entry_bb, l0_bb)->flags = EDGE_TRUE_VALUE;\n+      find_edge (entry_bb, l3_bb)->flags = EDGE_FALSE_VALUE;\n     }\n \n-  make_edge (l0_bb, l1_bb, EDGE_FALLTHRU);\n-\n-  remove_edge (single_succ_edge (cont_bb));\n-  make_edge (cont_bb, l1_bb, EDGE_TRUE_VALUE);\n-  make_edge (cont_bb, l2_bb, EDGE_FALSE_VALUE);\n+  if (!broken_loop)\n+    {\n+      find_edge (cont_bb, l1_bb)->flags = EDGE_TRUE_VALUE;\n+      remove_edge (find_edge (cont_bb, l3_bb));\n+      make_edge (cont_bb, l2_bb, EDGE_FALSE_VALUE);\n \n-  make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n-  make_edge (l2_bb, l3_bb, EDGE_FALSE_VALUE);\n+      make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n+      make_edge (l2_bb, l3_bb, EDGE_FALSE_VALUE);\n+    }\n }\n \n \n@@ -2762,10 +2765,14 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   type = TREE_TYPE (fd->v);\n \n   entry_bb = region->entry;\n-  seq_start_bb = create_empty_bb (entry_bb);\n-  body_bb = single_succ (entry_bb);\n   cont_bb = region->cont;\n-  fin_bb = single_succ (cont_bb);\n+  gcc_assert (EDGE_COUNT (entry_bb->succs) == 2);\n+  gcc_assert (BRANCH_EDGE (entry_bb)->dest == FALLTHRU_EDGE (cont_bb)->dest);\n+  seq_start_bb = split_edge (FALLTHRU_EDGE (entry_bb));\n+  body_bb = single_succ (seq_start_bb);\n+  gcc_assert (BRANCH_EDGE (cont_bb)->dest == body_bb);\n+  gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n+  fin_bb = FALLTHRU_EDGE (cont_bb)->dest;\n   exit_bb = region->exit;\n \n   /* Iteration space partitioning goes in ENTRY_BB.  */\n@@ -2871,13 +2878,10 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   bsi_remove (&si, true);\n \n   /* Connect all the blocks.  */\n-  make_edge (seq_start_bb, body_bb, EDGE_FALLTHRU);\n-\n-  remove_edge (single_succ_edge (entry_bb));\n-  make_edge (entry_bb, fin_bb, EDGE_TRUE_VALUE);\n-  make_edge (entry_bb, seq_start_bb, EDGE_FALSE_VALUE);\n-\n-  make_edge (cont_bb, body_bb, EDGE_TRUE_VALUE);\n+  find_edge (entry_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n+  find_edge (entry_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n+  \n+  find_edge (cont_bb, body_bb)->flags = EDGE_TRUE_VALUE;\n   find_edge (cont_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n }\n \n@@ -2923,16 +2927,24 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   basic_block trip_update_bb, cont_bb, fin_bb;\n   tree list;\n   block_stmt_iterator si;\n+  edge se;\n \n   type = TREE_TYPE (fd->v);\n \n   entry_bb = region->entry;\n-  iter_part_bb = create_empty_bb (entry_bb);\n-  seq_start_bb = create_empty_bb (iter_part_bb);\n-  body_bb = single_succ (entry_bb);\n+  se = split_block (entry_bb, last_stmt (entry_bb));\n+  entry_bb = se->src;\n+  iter_part_bb = se->dest;\n   cont_bb = region->cont;\n-  trip_update_bb = create_empty_bb (cont_bb);\n-  fin_bb = single_succ (cont_bb);\n+  gcc_assert (EDGE_COUNT (iter_part_bb->succs) == 2);\n+  gcc_assert (BRANCH_EDGE (iter_part_bb)->dest\n+\t      == FALLTHRU_EDGE (cont_bb)->dest);\n+  seq_start_bb = split_edge (FALLTHRU_EDGE (iter_part_bb));\n+  body_bb = single_succ (seq_start_bb);\n+  gcc_assert (BRANCH_EDGE (cont_bb)->dest == body_bb);\n+  gcc_assert (EDGE_COUNT (cont_bb->succs) == 2);\n+  fin_bb = FALLTHRU_EDGE (cont_bb)->dest;\n+  trip_update_bb = split_edge (FALLTHRU_EDGE (cont_bb));\n   exit_bb = region->exit;\n \n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n@@ -3057,19 +3069,13 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n-  remove_edge (single_succ_edge (entry_bb));\n-  make_edge (entry_bb, iter_part_bb, EDGE_FALLTHRU);\n-\n-  make_edge (iter_part_bb, seq_start_bb, EDGE_TRUE_VALUE);\n-  make_edge (iter_part_bb, fin_bb, EDGE_FALSE_VALUE);\n-\n-  make_edge (seq_start_bb, body_bb, EDGE_FALLTHRU);\n-\n-  remove_edge (single_succ_edge (cont_bb));\n-  make_edge (cont_bb, body_bb, EDGE_TRUE_VALUE);\n-  make_edge (cont_bb, trip_update_bb, EDGE_FALSE_VALUE);\n-\n-  make_edge (trip_update_bb, iter_part_bb, EDGE_FALLTHRU);\n+  find_edge (iter_part_bb, seq_start_bb)->flags = EDGE_TRUE_VALUE;\n+  find_edge (iter_part_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n+  \n+  find_edge (cont_bb, body_bb)->flags = EDGE_TRUE_VALUE;\n+  find_edge (cont_bb, trip_update_bb)->flags = EDGE_FALSE_VALUE;\n+  \n+  redirect_edge_and_branch (single_succ_edge (trip_update_bb), iter_part_bb);\n }\n \n \n@@ -3087,8 +3093,7 @@ expand_omp_for (struct omp_region *region)\n \n   if (fd.sched_kind == OMP_CLAUSE_SCHEDULE_STATIC\n       && !fd.have_ordered\n-      && region->cont\n-      && region->exit)\n+      && region->cont != NULL)\n     {\n       if (fd.chunk_size == NULL)\n \texpand_omp_for_static_nochunk (region, &fd);\n@@ -3137,95 +3142,93 @@ expand_omp_for (struct omp_region *region)\n static void\n expand_omp_sections (struct omp_region *region)\n {\n-  tree label_vec, l0, l1, l2, t, u, v, sections_stmt;\n-  unsigned i, len;\n-  basic_block entry_bb, exit_bb, l0_bb, l1_bb, l2_bb, default_bb;\n+  tree label_vec, l1, l2, t, u, v, sections_stmt;\n+  unsigned i, casei, len;\n+  basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   block_stmt_iterator si;\n   struct omp_region *inner;\n-  edge e;\n+  bool exit_reachable = region->cont != NULL;\n \n+  gcc_assert (exit_reachable == (region->exit != NULL));\n   entry_bb = region->entry;\n-  l0_bb = create_empty_bb (entry_bb);\n-  l0 = tree_block_label (l0_bb);\n-\n-  gcc_assert ((region->cont != NULL) ^ (region->exit == NULL));\n+  l0_bb = single_succ (entry_bb);\n   l1_bb = region->cont;\n-  if (l1_bb)\n+  l2_bb = region->exit;\n+  if (exit_reachable)\n     {\n-      l2_bb = single_succ (l1_bb);\n+      gcc_assert (single_pred (l2_bb) == l0_bb);\n       default_bb = create_empty_bb (l1_bb->prev_bb);\n-\n       l1 = tree_block_label (l1_bb);\n+      l2 = tree_block_label (l2_bb);\n     }\n   else\n     {\n-      l2_bb = create_empty_bb (l0_bb);\n-      default_bb = l2_bb;\n-\n-      l1 = NULL;\n+      default_bb = create_empty_bb (l0_bb);\n+      l1 = NULL_TREE;\n+      l2 = tree_block_label (default_bb);\n     }\n-  l2 = tree_block_label (l2_bb);\n-\n-  exit_bb = region->exit;\n-\n-  v = create_tmp_var (unsigned_type_node, \".section\");\n \n   /* We will build a switch() with enough cases for all the\n      OMP_SECTION regions, a '0' case to handle the end of more work\n      and a default case to abort if something goes wrong.  */\n-  len = EDGE_COUNT (entry_bb->succs);\n-  label_vec = make_tree_vec (len + 2);\n+  len = EDGE_COUNT (l0_bb->succs);\n+  label_vec = make_tree_vec (len + 1);\n \n   /* The call to GOMP_sections_start goes in ENTRY_BB, replacing the\n      OMP_SECTIONS statement.  */\n   si = bsi_last (entry_bb);\n   sections_stmt = bsi_stmt (si);\n   gcc_assert (TREE_CODE (sections_stmt) == OMP_SECTIONS);\n+  v = OMP_SECTIONS_CONTROL (sections_stmt);\n   if (!is_combined_parallel (region))\n     {\n       /* If we are not inside a combined parallel+sections region,\n \t call GOMP_sections_start.  */\n-      t = build_int_cst (unsigned_type_node, len);\n+      t = build_int_cst (unsigned_type_node,\n+\t\t\t exit_reachable ? len - 1 : len);\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n       t = build_call_expr (u, 1, t);\n       t = build_gimple_modify_stmt (v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n   bsi_remove (&si, true);\n \n-  /* The switch() statement replacing OMP_SECTIONS goes in L0_BB.  */\n-  si = bsi_start (l0_bb);\n+  /* The switch() statement replacing OMP_SECTIONS_SWITCH goes in L0_BB.  */\n+  si = bsi_last (l0_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SECTIONS_SWITCH);\n \n   t = build3 (SWITCH_EXPR, void_type_node, v, NULL, label_vec);\n-  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+  bsi_remove (&si, true);\n \n-  t = build3 (CASE_LABEL_EXPR, void_type_node,\n-\t      build_int_cst (unsigned_type_node, 0), NULL, l2);\n-  TREE_VEC_ELT (label_vec, 0) = t;\n-  make_edge (l0_bb, l2_bb, 0);\n+  i = 0;\n+  if (exit_reachable)\n+    {\n+      t = build3 (CASE_LABEL_EXPR, void_type_node,\n+\t\t  build_int_cst (unsigned_type_node, 0), NULL, l2);\n+      TREE_VEC_ELT (label_vec, 0) = t;\n+      i++;\n+    }\n \n   /* Convert each OMP_SECTION into a CASE_LABEL_EXPR.  */\n-  for (inner = region->inner, i = 1; inner; inner = inner->next, ++i)\n+  for (inner = region->inner, casei = 1;\n+       inner;\n+       inner = inner->next, i++, casei++)\n     {\n       basic_block s_entry_bb, s_exit_bb;\n \n       s_entry_bb = inner->entry;\n       s_exit_bb = inner->exit;\n \n       t = tree_block_label (s_entry_bb);\n-      u = build_int_cst (unsigned_type_node, i);\n+      u = build_int_cst (unsigned_type_node, casei);\n       u = build3 (CASE_LABEL_EXPR, void_type_node, u, NULL, t);\n       TREE_VEC_ELT (label_vec, i) = u;\n \n       si = bsi_last (s_entry_bb);\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SECTION);\n       gcc_assert (i < len || OMP_SECTION_LAST (bsi_stmt (si)));\n       bsi_remove (&si, true);\n-\n-      e = single_pred_edge (s_entry_bb);\n-      e->flags = 0;\n-      redirect_edge_pred (e, l0_bb);\n-\n       single_succ_edge (s_entry_bb)->flags = EDGE_FALLTHRU;\n \n       if (s_exit_bb == NULL)\n@@ -3241,29 +3244,28 @@ expand_omp_sections (struct omp_region *region)\n   /* Error handling code goes in DEFAULT_BB.  */\n   t = tree_block_label (default_bb);\n   u = build3 (CASE_LABEL_EXPR, void_type_node, NULL, NULL, t);\n-  TREE_VEC_ELT (label_vec, len + 1) = u;\n+  TREE_VEC_ELT (label_vec, len) = u;\n   make_edge (l0_bb, default_bb, 0);\n \n   si = bsi_start (default_bb);\n   t = build_call_expr (built_in_decls[BUILT_IN_TRAP], 0);\n   bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n-  /* Code to get the next section goes in L1_BB.  */\n-  if (l1_bb)\n+  if (exit_reachable)\n     {\n+      /* Code to get the next section goes in L1_BB.  */\n       si = bsi_last (l1_bb);\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n       t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT], 0);\n       t = build_gimple_modify_stmt (v, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n       bsi_remove (&si, true);\n-    }\n \n-  /* Cleanup function replaces OMP_RETURN in EXIT_BB.  */\n-  if (exit_bb)\n-    {\n-      si = bsi_last (exit_bb);\n+      single_succ_edge (l1_bb)->flags = EDGE_FALLTHRU;\n+\n+      /* Cleanup function replaces OMP_RETURN in EXIT_BB.  */\n+      si = bsi_last (l2_bb);\n       if (OMP_RETURN_NOWAIT (bsi_stmt (si)))\n \tt = built_in_decls[BUILT_IN_GOMP_SECTIONS_END_NOWAIT];\n       else\n@@ -3279,16 +3281,8 @@ expand_omp_sections (struct omp_region *region)\n       /* If this was a combined parallel+sections region, we did not\n \t emit a GOMP_sections_start in the entry block, so we just\n \t need to jump to L1_BB to get the next section.  */\n-      make_edge (entry_bb, l1_bb, EDGE_FALLTHRU);\n-    }\n-  else\n-    make_edge (entry_bb, l0_bb, EDGE_FALLTHRU);\n-\n-  if (l1_bb)\n-    {\n-      e = single_succ_edge (l1_bb);\n-      redirect_edge_succ (e, l0_bb);\n-      e->flags = EDGE_FALLTHRU;\n+      gcc_assert (exit_reachable);\n+      redirect_edge_and_branch (single_succ_edge (entry_bb), l1_bb);\n     }\n }\n \n@@ -3451,6 +3445,11 @@ build_omp_regions_1 (basic_block bb, struct omp_region *parent)\n \t  gcc_assert (parent);\n \t  parent->cont = bb;\n \t}\n+      else if (code == OMP_SECTIONS_SWITCH)\n+\t{\n+\t  /* OMP_SECTIONS_SWITCH is part of OMP_SECTIONS, and we do nothing for\n+\t     it.  */\n+\t}\n       else\n \t{\n \t  /* Otherwise, this directive becomes the parent for a new\n@@ -3539,7 +3538,7 @@ struct tree_opt_pass pass_expand_omp =\n static void\n lower_omp_sections (tree *stmt_p, omp_context *ctx)\n {\n-  tree new_stmt, stmt, body, bind, block, ilist, olist, new_body;\n+  tree new_stmt, stmt, body, bind, block, ilist, olist, new_body, control;\n   tree t, dlist;\n   tree_stmt_iterator tsi;\n   unsigned i, len;\n@@ -3601,9 +3600,12 @@ lower_omp_sections (tree *stmt_p, omp_context *ctx)\n   new_body = alloc_stmt_list ();\n   append_to_statement_list (ilist, &new_body);\n   append_to_statement_list (stmt, &new_body);\n+  append_to_statement_list (make_node (OMP_SECTIONS_SWITCH), &new_body);\n   append_to_statement_list (bind, &new_body);\n \n-  t = make_node (OMP_CONTINUE);\n+  control = create_tmp_var (unsigned_type_node, \".section\");\n+  t = build2 (OMP_CONTINUE, void_type_node, control, control);\n+  OMP_SECTIONS_CONTROL (stmt) = control;\n   append_to_statement_list (t, &new_body);\n \n   append_to_statement_list (olist, &new_body);\n@@ -4040,7 +4042,7 @@ lower_omp_for (tree *stmt_p, omp_context *ctx)\n \n   append_to_statement_list (OMP_FOR_BODY (stmt), body_p);\n \n-  t = make_node (OMP_CONTINUE);\n+  t = build2 (OMP_CONTINUE, void_type_node, fd.v, fd.v);\n   append_to_statement_list (t, body_p);\n \n   /* After the loop, add exit clauses.  */"}, {"sha": "f124c9a436fd05e7acf27bfd615b2c69a847f608", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -517,6 +517,10 @@ make_edges (void)\n \n \t    case OMP_SECTIONS:\n \t      cur_region = new_omp_region (bb, code, cur_region);\n+\t      fallthru = true;\n+\t      break;\n+\n+\t    case OMP_SECTIONS_SWITCH:\n \t      fallthru = false;\n \t      break;\n \n@@ -533,31 +537,42 @@ make_edges (void)\n \t      switch (cur_region->type)\n \t\t{\n \t\tcase OMP_FOR:\n-\t\t  /* ??? Technically there should be a some sort of loopback\n-\t\t     edge here, but it goes to a block that doesn't exist yet,\n-\t\t     and without it, updating the ssa form would be a real\n-\t\t     bear.  Fortunately, we don't yet do ssa before expanding\n-\t\t     these nodes.  */\n+\t\t  /* Make the loopback edge.  */\n+\t\t  make_edge (bb, single_succ (cur_region->entry), 0);\n+\t      \n+\t\t  /* Create an edge from OMP_FOR to exit, which corresponds to\n+\t\t     the case that the body of the loop is not executed at\n+\t\t     all.  */\n+\t\t  make_edge (cur_region->entry, bb->next_bb, 0);\n+\t\t  fallthru = true;\n \t\t  break;\n \n \t\tcase OMP_SECTIONS:\n \t\t  /* Wire up the edges into and out of the nested sections.  */\n-\t\t  /* ??? Similarly wrt loopback.  */\n \t\t  {\n+\t\t    basic_block switch_bb = single_succ (cur_region->entry);\n+\n \t\t    struct omp_region *i;\n \t\t    for (i = cur_region->inner; i ; i = i->next)\n \t\t      {\n \t\t\tgcc_assert (i->type == OMP_SECTION);\n-\t\t\tmake_edge (cur_region->entry, i->entry, 0);\n+\t\t\tmake_edge (switch_bb, i->entry, 0);\n \t\t\tmake_edge (i->exit, bb, EDGE_FALLTHRU);\n \t\t      }\n+\n+\t\t    /* Make the loopback edge to the block with\n+\t\t       OMP_SECTIONS_SWITCH.  */\n+\t\t    make_edge (bb, switch_bb, 0);\n+\n+\t\t    /* Make the edge from the switch to exit.  */\n+\t\t    make_edge (switch_bb, bb->next_bb, 0);\n+\t\t    fallthru = false;\n \t\t  }\n \t\t  break;\n \n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      fallthru = true;\n \t      break;\n \n \t    default:\n@@ -4807,6 +4822,13 @@ tree_redirect_edge_and_branch (edge e, basic_block dest)\n       e->flags |= EDGE_FALLTHRU;\n       break;\n \n+    case OMP_RETURN:\n+    case OMP_CONTINUE:\n+    case OMP_SECTIONS_SWITCH:\n+    case OMP_FOR:\n+      /* The edges from OMP constructs can be simply redirected.  */\n+      break;\n+\n     default:\n       /* Otherwise it must be a fallthru edge, and we don't need to\n \t do anything besides redirecting it.  */"}, {"sha": "bd2523bf7e6b72e069cce225d358bd1dd73088f6", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -507,6 +507,36 @@ split_bbs_on_noreturn_calls (void)\n   return changed;\n }\n \n+/* If OMP_RETURN in basic block BB is unreachable, remove it.  */\n+\n+static bool\n+cleanup_omp_return (basic_block bb)\n+{\n+  tree stmt = last_stmt (bb);\n+  basic_block control_bb;\n+\n+  if (stmt == NULL_TREE\n+      || TREE_CODE (stmt) != OMP_RETURN\n+      || !single_pred_p (bb))\n+    return false;\n+\n+  control_bb = single_pred (bb);\n+  stmt = last_stmt (control_bb);\n+\n+  if (TREE_CODE (stmt) != OMP_SECTIONS_SWITCH)\n+    return false;\n+\n+  /* The block with the control statement normally has two entry edges -- one\n+     from entry, one from continue.  If continue is removed, return is\n+     unreachable, so we remove it here as well.  */\n+  if (EDGE_COUNT (control_bb->preds) == 2)\n+    return false;\n+\n+  gcc_assert (EDGE_COUNT (control_bb->preds) == 1);\n+  remove_edge_and_dominated_blocks (single_pred_edge (bb));\n+  return true;\n+}\n+\n /* Tries to cleanup cfg in basic block BB.  Returns true if anything\n    changes.  */\n \n@@ -515,8 +545,11 @@ cleanup_tree_cfg_bb (basic_block bb)\n {\n   bool retval = false;\n \n-  retval = cleanup_control_flow_bb (bb);\n+  if (cleanup_omp_return (bb))\n+    return true;\n \n+  retval = cleanup_control_flow_bb (bb);\n+  \n   /* Forwarder blocks can carry line number information which is\n      useful when debugging, so we only clean them up when\n      optimizing.  */"}, {"sha": "e9753ebeecbd58685c10c35ce87fb5c8a0f040d5", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -230,6 +230,7 @@ is_gimple_stmt (tree t)\n     case OMP_PARALLEL:\n     case OMP_FOR:\n     case OMP_SECTIONS:\n+    case OMP_SECTIONS_SWITCH:\n     case OMP_SECTION:\n     case OMP_SINGLE:\n     case OMP_MASTER:"}, {"sha": "af0c7d40667366364ee9c313691c959fdf836b30", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -2010,6 +2010,7 @@ estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case OMP_CLAUSE:\n     case OMP_RETURN:\n     case OMP_CONTINUE:\n+    case OMP_SECTIONS_SWITCH:\n       break;\n \n     /* We don't account constants for now.  Assume that the cost is amortized"}, {"sha": "bd71a7df0e9b33b5d9b3beabafbc4a4947f9ef8b", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -1851,9 +1851,21 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \n     case OMP_SECTIONS:\n       pp_string (buffer, \"#pragma omp sections\");\n+      if (OMP_SECTIONS_CONTROL (node))\n+\t{\n+\t  pp_string (buffer, \" <\");\n+\t  dump_generic_node (buffer, OMP_SECTIONS_CONTROL (node), spc,\n+\t\t\t     flags, false);\n+\t  pp_string (buffer, \">\");\n+\t}\n       dump_omp_clauses (buffer, OMP_SECTIONS_CLAUSES (node), spc, flags);\n       goto dump_omp_body;\n \n+    case OMP_SECTIONS_SWITCH:\n+      pp_string (buffer, \"OMP_SECTIONS_SWITCH\");\n+      is_expr = false;\n+      break;\n+ \n     case OMP_SECTION:\n       pp_string (buffer, \"#pragma omp section\");\n       goto dump_omp_body;\n@@ -1901,7 +1913,11 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       break;\n \n     case OMP_CONTINUE:\n-      pp_string (buffer, \"OMP_CONTINUE\");\n+      pp_string (buffer, \"OMP_CONTINUE <\");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \" <- \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \">\");\n       is_expr = false;\n       break;\n "}, {"sha": "72c6d246b4f3959d228f60a2ac862ddf19626b8e", "filename": "gcc/tree.def", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -999,8 +999,14 @@ DEFTREECODE (OMP_FOR, \"omp_for\", tcc_statement, 6)\n \n /* OpenMP - #pragma omp sections [clause1 ... clauseN]\n    Operand 0: OMP_SECTIONS_BODY: Sections body.\n-   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.  */\n-DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 2)\n+   Operand 1: OMP_SECTIONS_CLAUSES: List of clauses.\n+   Operand 2: OMP_SECTIONS_CONTROL: The control variable used for deciding\n+\t      which of the sections to execute.  */\n+DEFTREECODE (OMP_SECTIONS, \"omp_sections\", tcc_statement, 3)\n+\n+/* This tree immediatelly follows OMP_SECTIONS, and represents the switch\n+   used to decide which branch is taken.  */\n+DEFTREECODE (OMP_SECTIONS_SWITCH, \"omp_sections_switch\", tcc_statement, 0)\n \n /* OpenMP - #pragma omp single\n    Operand 0: OMP_SINGLE_BODY: Single section body.\n@@ -1028,8 +1034,9 @@ DEFTREECODE (OMP_CRITICAL, \"omp_critical\", tcc_statement, 2)\n DEFTREECODE (OMP_RETURN, \"omp_return\", tcc_statement, 0)\n \n /* OpenMP - An intermediate tree code to mark the location of the\n-   loop or sections iteration in the partially lowered code.  */\n-DEFTREECODE (OMP_CONTINUE, \"omp_continue\", tcc_statement, 0)\n+   loop or sections iteration in the partially lowered code.\n+   The arguments are definition and use of the control variable.  */\n+DEFTREECODE (OMP_CONTINUE, \"omp_continue\", tcc_statement, 2)\n \n /* OpenMP - #pragma omp atomic\n    Operand 0: The address at which the atomic operation is to be performed."}, {"sha": "f955b87629bbe7359e85ab26f5f271e74f6a8dae", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5c95afe1e18581b060601f70b1a6888835028ce/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e5c95afe1e18581b060601f70b1a6888835028ce", "patch": "@@ -187,6 +187,7 @@ extern const enum tree_code_class tree_code_type[];\n     (TREE_CODE (NODE) == OMP_PARALLEL\t\t\t\\\n      || TREE_CODE (NODE) == OMP_FOR\t\t\t\\\n      || TREE_CODE (NODE) == OMP_SECTIONS\t\t\\\n+     || TREE_CODE (NODE) == OMP_SECTIONS_SWITCH\t\t\\\n      || TREE_CODE (NODE) == OMP_SINGLE\t\t\t\\\n      || TREE_CODE (NODE) == OMP_SECTION\t\t\t\\\n      || TREE_CODE (NODE) == OMP_MASTER\t\t\t\\\n@@ -1695,6 +1696,7 @@ struct tree_constructor GTY(())\n \n #define OMP_SECTIONS_BODY(NODE)    TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 0)\n #define OMP_SECTIONS_CLAUSES(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 1)\n+#define OMP_SECTIONS_CONTROL(NODE) TREE_OPERAND (OMP_SECTIONS_CHECK (NODE), 2)\n \n #define OMP_SECTION_BODY(NODE)\t   TREE_OPERAND (OMP_SECTION_CHECK (NODE), 0)\n "}]}