{"sha": "00b960c7ada70affc18fe7f4ad170a40c684c208", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBiOTYwYzdhZGE3MGFmZmMxOGZlN2Y0YWQxNzBhNDBjNjg0YzIwOA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2001-11-21T01:04:44Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2001-11-21T01:04:44Z"}, "message": "rs6000.c (direct_return): Check if we are saving altivec registers.\n\n\t* rs6000.c (direct_return): Check if we are saving altivec\n\tregisters.\n\t(first_altivec_reg_to_save): New.\n\tUpdated stack frame layout comments.\n\t(rs6000_stack_info): Calculate altivec register save size.\n\tSave link register if we saved some altivec registers.\n\t(rs6000_stack_info): Align save size to 16 if altivec abi or\n\tabi_darwin.\n\t(rs6000_stack_info): Calculate altivec register offsets.\n\t(rs6000_stack_info): Add altivec info to save_size.\n\t(debug_stack_info): Add altivec debug info.\n\t(rs6000_emit_prologue): Save altivec registers and vrsave.\n\t(compute_vrsave_mask): New.\n\t(altivec_expand_builtin): Remove unused variables.\n\t(rs6000_parse_abi_options): Add static qualifier.\n\t(rs6000_expand_builtin): Remove unused parameters.\n\t(altivec_expand_builtin): Cast bdesc_2arg to get rid of warning.\n\t(altivec_init_builtins): Same.\n\t(is_altivec_return_reg): New.\n\t(vrsave_operation): New.\n\t(ALTIVEC_REG_BIT): New.\n\t(generate_set_vrsave): New.\n\n\t* rs6000.md (get_vrsave): New.\n\t(set_vrsave): New.\n\t(*set_vrsave_internal): New.\n\n\t* rs6000.h (rs6000_stack): Add first_altivec_reg_save,\n\taltivec_save_offset, vrsave_save_offset, altive_size, vrsave_size,\n\taltivec_padding_size, vrsave_mask.\n\t(TOTAL_ALTIVEC_REGS): New.\n\t(EPILOGUE_USES): Add VRSAVE_REGNO.\n\nFrom-SVN: r47228", "tree": {"sha": "b5b8cc76657317a11d2de8f055d3e60e9ca71759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b8cc76657317a11d2de8f055d3e60e9ca71759"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00b960c7ada70affc18fe7f4ad170a40c684c208", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b960c7ada70affc18fe7f4ad170a40c684c208", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00b960c7ada70affc18fe7f4ad170a40c684c208", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00b960c7ada70affc18fe7f4ad170a40c684c208/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b735a5700b2b490eccc2dc62dd0179d5c79d211", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b735a5700b2b490eccc2dc62dd0179d5c79d211", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b735a5700b2b490eccc2dc62dd0179d5c79d211"}], "stats": {"total": 501, "additions": 471, "deletions": 30}, "files": [{"sha": "417b2f9d6b2cc5a75628eb15bb70d090dbe0c57d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00b960c7ada70affc18fe7f4ad170a40c684c208", "patch": "@@ -1,3 +1,38 @@\n+2001-11-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* rs6000.c (direct_return): Check if we are saving altivec\n+\tregisters.\n+\t(first_altivec_reg_to_save): New.\n+\tUpdated stack frame layout comments.\n+\t(rs6000_stack_info): Calculate altivec register save size.\n+\tSave link register if we saved some altivec registers.\n+\t(rs6000_stack_info): Align save size to 16 if altivec abi or\n+\tabi_darwin.\n+\t(rs6000_stack_info): Calculate altivec register offsets.\n+\t(rs6000_stack_info): Add altivec info to save_size.\n+\t(debug_stack_info): Add altivec debug info.\n+\t(rs6000_emit_prologue): Save altivec registers and vrsave.\n+\t(compute_vrsave_mask): New.\n+\t(altivec_expand_builtin): Remove unused variables.\n+\t(rs6000_parse_abi_options): Add static qualifier.\n+\t(rs6000_expand_builtin): Remove unused parameters.\n+\t(altivec_expand_builtin): Cast bdesc_2arg to get rid of warning.\n+\t(altivec_init_builtins): Same.\n+\t(is_altivec_return_reg): New.\n+\t(vrsave_operation): New.\n+\t(ALTIVEC_REG_BIT): New.\n+\t(generate_set_vrsave): New.\n+\n+\t* rs6000.md (get_vrsave): New.\n+\t(set_vrsave): New.\n+\t(*set_vrsave_internal): New.\n+\n+\t* rs6000.h (rs6000_stack): Add first_altivec_reg_save,\n+\taltivec_save_offset, vrsave_save_offset, altive_size, vrsave_size,\n+\taltivec_padding_size, vrsave_mask.\n+\t(TOTAL_ALTIVEC_REGS): New.\n+\t(EPILOGUE_USES): Add VRSAVE_REGNO.\n+\n 2001-11-20  Jeff Law <law@redhat.com>\n \n \t* unroll.c (copy_loop_body): Update LABEL_NUSES for the"}, {"sha": "6ed9a49dfa2dc62d2d66acec185f11c2a114b8f7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 400, "deletions": 30, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=00b960c7ada70affc18fe7f4ad170a40c684c208", "patch": "@@ -153,10 +153,15 @@ static int rs6000_issue_rate PARAMS ((void));\n static void rs6000_init_builtins PARAMS ((tree));\n static void altivec_init_builtins PARAMS ((void));\n static rtx rs6000_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n-static rtx altivec_expand_builtin PARAMS ((tree, rtx, rtx, enum machine_mode, int));\n+static rtx altivec_expand_builtin PARAMS ((tree, rtx));\n static rtx altivec_expand_binop_builtin PARAMS ((enum insn_code, tree, rtx));\n \n static void rs6000_parse_abi_options PARAMS ((void));\n+static int first_altivec_reg_to_save PARAMS ((void));\n+static unsigned int compute_vrsave_mask PARAMS ((void));\n+static void is_altivec_return_reg PARAMS ((rtx, void *));\n+int vrsave_operation PARAMS ((rtx, enum machine_mode));\n+static rtx generate_set_vrsave PARAMS ((rtx, rs6000_stack_t *));\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n@@ -234,6 +239,9 @@ static const char alt_reg_names[][8] =\n #undef TARGET_EXPAND_BUILTIN\n #define TARGET_EXPAND_BUILTIN rs6000_expand_builtin\n \n+/* The VRSAVE bitmask puts bit %v0 as the most significant bit.  */\n+#define ALTIVEC_REG_BIT(REGNO) (0x80000000 >> ((REGNO) - FIRST_ALTIVEC_REGNO))\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Override command line options.  Mostly we process the processor\n@@ -496,7 +504,8 @@ rs6000_override_options (default_cpu)\n }\n \n /* Handle -mabi= options.  */\n-void rs6000_parse_abi_options ()\n+static void\n+rs6000_parse_abi_options ()\n {\n   if (rs6000_abi_string == 0)\n     return;\n@@ -585,8 +594,10 @@ direct_return ()\n \n       if (info->first_gp_reg_save == 32\n \t  && info->first_fp_reg_save == 64\n+\t  && info->first_altivec_reg_save == LAST_ALTIVEC_REGNO + 1\n \t  && ! info->lr_save_p\n \t  && ! info->cr_save_p\n+\t  && info->vrsave_mask == 0\n \t  && ! info->push_p)\n \treturn 1;\n     }\n@@ -3108,21 +3119,18 @@ altivec_expand_binop_builtin (icode, arglist, target)\n }\n \n static rtx\n-altivec_expand_builtin (exp, target, subtarget, mode, ignore)\n+altivec_expand_builtin (exp, target)\n      tree exp;\n      rtx target;\n-     rtx subtarget;\n-     enum machine_mode mode;\n-     int ignore;\n {\n   struct builtin_description *d;\n   size_t i;\n   enum insn_code icode;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0, arg1, arg2, arg3;\n-  rtx op0, op1, op2, pat;\n-  enum machine_mode tmode, mode0, mode1, mode2;\n+  tree arg0, arg1;\n+  rtx op0, op1, pat;\n+  enum machine_mode tmode, mode0, mode1;\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n   \n   switch (fcode)\n@@ -3170,7 +3178,8 @@ altivec_expand_builtin (exp, target, subtarget, mode, ignore)\n     }\n \n   /* Handle simple binary operations.  */\n-  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+  d = (struct builtin_description *) bdesc_2arg;\n+  for (i = 0; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n     if (d->code == fcode)\n       return altivec_expand_binop_builtin (d->icode, arglist, target);\n \n@@ -3188,12 +3197,12 @@ static rtx\n rs6000_expand_builtin (exp, target, subtarget, mode, ignore)\n      tree exp;\n      rtx target;\n-     rtx subtarget;\n-     enum machine_mode mode;\n-     int ignore;\n+     rtx subtarget ATTRIBUTE_UNUSED;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     int ignore ATTRIBUTE_UNUSED;\n {\n   if (TARGET_ALTIVEC)\n-    return altivec_expand_builtin (exp, target, subtarget, mode, ignore);\n+    return altivec_expand_builtin (exp, target);\n \n   abort ();\n }\n@@ -3322,7 +3331,8 @@ altivec_init_builtins (void)\n   def_builtin (MASK_ALTIVEC, \"__builtin_altivec_st_internal\", void_ftype_pint_v4si, ALTIVEC_BUILTIN_ST_INTERNAL);\n \n   /* Add the simple binary operators.  */\n-  for (i = 0, d = bdesc_2arg; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n+  d = (struct builtin_description *) bdesc_2arg;\n+  for (i = 0; i < sizeof (bdesc_2arg) / sizeof *d; i++, d++)\n     {\n       enum machine_mode mode0, mode1, mode2;\n       tree type;\n@@ -3831,6 +3841,41 @@ store_multiple_operation (op, mode)\n   return 1;\n }\n \n+/* Return 1 for a parallel vrsave operation.  */\n+\n+int\n+vrsave_operation (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno, src_regno;\n+  int i;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, 0))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC)\n+    return 0;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, 0)));\n+  src_regno  = REGNO (SET_SRC (XVECEXP (op, 0, 0)));\n+\n+  if (dest_regno != VRSAVE_REGNO\n+      && src_regno != VRSAVE_REGNO)\n+    return 0;\n+\n+  for (i = 1; i < count; i++)\n+    {\n+      rtx elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != CLOBBER)\n+\treturn 0;\n+    }\n+\n+  return 1;\n+}\n+\n /* Return 1 for an PARALLEL suitable for mtcrf.  */\n \n int\n@@ -5926,6 +5971,85 @@ first_fp_reg_to_save ()\n \n   return first_reg;\n }\n+\n+/* Similar, for AltiVec regs.  */\n+\n+static int\n+first_altivec_reg_to_save ()\n+{\n+  int i;\n+\n+  /* Stack frame remains as is unless we are in AltiVec ABI.  */\n+  if (! TARGET_ALTIVEC_ABI)\n+    return LAST_ALTIVEC_REGNO + 1;\n+\n+  /* Find lowest numbered live register.  */\n+  for (i = FIRST_ALTIVEC_REGNO + 20; i <= LAST_ALTIVEC_REGNO; ++i)\n+    if (regs_ever_live[i])\n+      break;\n+\n+  return i;\n+}\n+\n+/* Return a 32-bit mask of the AltiVec registers we need to set in\n+   VRSAVE.  Bit n of the return value is 1 if Vn is live.  The MSB in\n+   the 32-bit word is 0.  */\n+\n+static unsigned int\n+compute_vrsave_mask ()\n+{\n+  unsigned int i, mask = 0;\n+\n+  /* First, find out if we use _any_ altivec registers.  */\n+  for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n+    if (regs_ever_live[i])\n+      mask |= ALTIVEC_REG_BIT (i);\n+\n+  if (mask == 0)\n+    return mask;\n+\n+  /* Next, add all registers that are call-clobbered.  We do this\n+     because post-reload register optimizers such as regrename_optimize\n+     may choose to use them.  They never change the register class\n+     chosen by reload, so cannot create new uses of altivec registers\n+     if there were none before, so the early exit above is safe.  */\n+  /* ??? Alternately, we could define HARD_REGNO_RENAME_OK to disallow\n+     altivec registers not saved in the mask, which might well make the\n+     adjustments below more effective in eliding the save/restore of\n+     VRSAVE in small functions.  */\n+  for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n+    if (call_used_regs[i])\n+      mask |= ALTIVEC_REG_BIT (i);\n+\n+  /* Next, remove the argument registers from the set.  These must\n+     be in the VRSAVE mask set by the caller, so we don't need to add\n+     them in again.  More importantly, the mask we compute here is\n+     used to generate CLOBBERs in the set_vrsave insn, and we do not\n+     wish the argument registers to die.  */\n+  for (i = cfun->args_info.vregno; i >= ALTIVEC_ARG_MIN_REG; --i)\n+    mask &= ~ALTIVEC_REG_BIT (i);\n+\n+  /* Similarly, remove the return value from the set.  */\n+  {\n+    bool yes = false;\n+    diddle_return_value (is_altivec_return_reg, &yes);\n+    if (yes)\n+      mask &= ~ALTIVEC_REG_BIT (ALTIVEC_ARG_RETURN);\n+  }\n+\n+  return mask;\n+}\n+\n+static void\n+is_altivec_return_reg (reg, xyes)\n+     rtx reg;\n+     void *xyes;\n+{\n+  bool *yes = (bool *) xyes;\n+  if (REGNO (reg) == ALTIVEC_ARG_RETURN)\n+    *yes = true;\n+}\n+\n \f\n /* Calculate the stack information for the current function.  This is\n    complicated by having two separate calling sequences, the AIX calling\n@@ -5954,9 +6078,15 @@ first_fp_reg_to_save ()\n \t\t+---------------------------------------+\n \t\t| Float/int conversion temporary (X)\t| 24+P+A+L\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 24+P+A+X+L\n+\t\t| Save area for AltiVec registers (W)\t| 24+P+A+L+X\n+\t\t+---------------------------------------+\n+\t\t| AltiVec alignment padding (Y)\t\t| 24+P+A+L+X+W\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 24+P+A+X+L+G\n+\t\t| Save area for VRSAVE register (Z)\t| 24+P+A+L+X+W+Y\n+\t\t+---------------------------------------+\n+\t\t| Save area for GP registers (G)\t| 24+P+A+X+L+X+W+Y+Z\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t| 24+P+A+X+L+X+W+Y+Z+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -5982,11 +6112,17 @@ first_fp_reg_to_save ()\n \t\t+---------------------------------------+    \n \t\t| Float/int conversion temporary (X)\t| 8+P+A+V+L\n \t\t+---------------------------------------+\n-\t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X\n+\t\t| Save area for AltiVec registers (W)\t| 8+P+A+V+L+X\n+\t\t+---------------------------------------+\n+\t\t| AltiVec alignment padding (Y)\t\t| 8+P+A+V+L+X+W\n+\t\t+---------------------------------------+\n+\t\t| Save area for VRSAVE register (Z)\t| 8+P+A+V+L+X+W+Y\n+\t\t+---------------------------------------+\n+\t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L+X+W+Y+Z\n \t\t+---------------------------------------+    \n-\t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+C\n+\t\t| Save area for GP registers (G)\t| 8+P+A+V+L+X+W+Y+Z+C\n \t\t+---------------------------------------+    \n-\t\t| Save area for FP registers (F)\t| 8+P+A+V+L+X+C+G\n+\t\t| Save area for FP registers (F)\t| 8+P+A+V+L+X+W+Y+Z+C+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -6042,6 +6178,10 @@ rs6000_stack_info ()\n   info_ptr->first_fp_reg_save = first_fp_reg_to_save ();\n   info_ptr->fp_size = 8 * (64 - info_ptr->first_fp_reg_save);\n \n+  info_ptr->first_altivec_reg_save = first_altivec_reg_to_save ();\n+  info_ptr->altivec_size = 16 * (LAST_ALTIVEC_REGNO + 1\n+\t\t\t\t - info_ptr->first_altivec_reg_save);\n+\n   /* Does this function call anything?  */\n   info_ptr->calls_p = (! current_function_is_leaf\n \t\t       || cfun->machine->ra_needs_full_frame);\n@@ -6054,6 +6194,7 @@ rs6000_stack_info ()\n #endif\n       || (info_ptr->first_fp_reg_save != 64\n \t  && !FP_SAVE_INLINE (info_ptr->first_fp_reg_save))\n+      || info_ptr->first_altivec_reg_save <= LAST_ALTIVEC_REGNO\n       || (abi == ABI_V4 && current_function_calls_alloca)\n       || (abi == ABI_SOLARIS && current_function_calls_alloca)\n       || (DEFAULT_ABI == ABI_DARWIN\n@@ -6095,14 +6236,17 @@ rs6000_stack_info ()\n   info_ptr->vars_size    = RS6000_ALIGN (get_frame_size (), 8);\n   info_ptr->parm_size    = RS6000_ALIGN (current_function_outgoing_args_size,\n \t\t\t\t\t 8);\n-  info_ptr->save_size    = RS6000_ALIGN (info_ptr->fp_size\n-\t\t\t\t\t + info_ptr->gp_size\n-\t\t\t\t\t + ehrd_size\n-\t\t\t\t\t + info_ptr->cr_size\n-\t\t\t\t\t + info_ptr->lr_size\n-\t\t\t\t\t + info_ptr->toc_size, 8);\n-  if (DEFAULT_ABI == ABI_DARWIN)\n-    info_ptr->save_size = RS6000_ALIGN (info_ptr->save_size, 16);\n+\n+  if (TARGET_ALTIVEC_ABI)\n+    {\n+      info_ptr->vrsave_mask = compute_vrsave_mask ();\n+      info_ptr->vrsave_size  = info_ptr->vrsave_mask ? 4 : 0;\n+    }\n+  else\n+    {\n+      info_ptr->vrsave_mask = 0;\n+      info_ptr->vrsave_size = 0;\n+    }\n \n   /* Calculate the offsets.  */\n   switch (abi)\n@@ -6116,7 +6260,29 @@ rs6000_stack_info ()\n     case ABI_DARWIN:\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n-      info_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n+\n+      if (TARGET_ALTIVEC_ABI)\n+\t{\n+\t  info_ptr->vrsave_save_offset\n+\t    = info_ptr->gp_save_offset - info_ptr->vrsave_size;\n+\n+\t  /* Align stack so vector save area is on a quadword boundary.  */\n+\t  if (info_ptr->altivec_size != 0)\n+\t    info_ptr->altivec_padding_size\n+\t      = 16 - (-info_ptr->vrsave_save_offset % 16);\n+\t  else\n+\t    info_ptr->altivec_padding_size = 0;\n+\n+\t  info_ptr->altivec_save_offset\n+\t    = info_ptr->vrsave_save_offset\n+\t    - info_ptr->altivec_padding_size\n+\t    - info_ptr->altivec_size;\n+\n+\t  /* Adjust for AltiVec case.  */\n+\t  info_ptr->ehrd_offset = info_ptr->altivec_save_offset - ehrd_size;\n+\t}\n+      else\n+\tinfo_ptr->ehrd_offset      = info_ptr->gp_save_offset - ehrd_size;\n       info_ptr->cr_save_offset   = reg_size; /* first word when 64-bit.  */\n       info_ptr->lr_save_offset   = 2*reg_size;\n       break;\n@@ -6126,12 +6292,48 @@ rs6000_stack_info ()\n       info_ptr->fp_save_offset   = - info_ptr->fp_size;\n       info_ptr->gp_save_offset   = info_ptr->fp_save_offset - info_ptr->gp_size;\n       info_ptr->cr_save_offset   = info_ptr->gp_save_offset - info_ptr->cr_size;\n-      info_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->toc_size;\n+\n+      if (TARGET_ALTIVEC_ABI)\n+\t{\n+\t  info_ptr->vrsave_save_offset\n+\t    = info_ptr->cr_save_offset - info_ptr->vrsave_size;\n+\n+\t  /* Align stack so vector save area is on a quadword boundary.  */\n+\t  if (info_ptr->altivec_size != 0)\n+\t    info_ptr->altivec_padding_size\n+\t      = 16 - (-info_ptr->vrsave_save_offset % 16);\n+\t  else\n+\t    info_ptr->altivec_padding_size = 0;\n+\n+\t  info_ptr->altivec_save_offset\n+\t    = info_ptr->vrsave_save_offset\n+\t    - info_ptr->altivec_padding_size\n+\t    - info_ptr->altivec_size;\n+\n+\t  /* Adjust for AltiVec case.  */\n+\t  info_ptr->toc_save_offset\n+\t    = info_ptr->altivec_save_offset - info_ptr->toc_size;\n+\t}\n+      else\n+\tinfo_ptr->toc_save_offset  = info_ptr->cr_save_offset - info_ptr->toc_size;\n       info_ptr->ehrd_offset      = info_ptr->toc_save_offset - ehrd_size;\n       info_ptr->lr_save_offset   = reg_size;\n       break;\n     }\n \n+  info_ptr->save_size    = RS6000_ALIGN (info_ptr->fp_size\n+\t\t\t\t\t + info_ptr->gp_size\n+\t\t\t\t\t + info_ptr->altivec_size\n+\t\t\t\t\t + info_ptr->altivec_padding_size\n+\t\t\t\t\t + info_ptr->vrsave_size\n+\t\t\t\t\t + ehrd_size\n+\t\t\t\t\t + info_ptr->cr_size\n+\t\t\t\t\t + info_ptr->lr_size\n+\t\t\t\t\t + info_ptr->vrsave_size\n+\t\t\t\t\t + info_ptr->toc_size,\n+\t\t\t\t\t (TARGET_ALTIVEC_ABI || ABI_DARWIN)\n+\t\t\t\t\t ? 16 : 8);\n+\n   total_raw_size\t = (info_ptr->vars_size\n \t\t\t    + info_ptr->parm_size\n \t\t\t    + info_ptr->save_size\n@@ -6173,6 +6375,12 @@ rs6000_stack_info ()\n   if (info_ptr->gp_size == 0)\n     info_ptr->gp_save_offset = 0;\n \n+  if (! TARGET_ALTIVEC_ABI || info_ptr->altivec_size == 0)\n+    info_ptr->altivec_save_offset = 0;\n+\n+  if (! TARGET_ALTIVEC_ABI || info_ptr->vrsave_mask == 0)\n+    info_ptr->vrsave_save_offset = 0;\n+\n   if (! info_ptr->lr_save_p)\n     info_ptr->lr_save_offset = 0;\n \n@@ -6212,12 +6420,19 @@ debug_stack_info (info)\n \n   fprintf (stderr, \"\\tABI                 = %5s\\n\", abi_string);\n \n+  if (TARGET_ALTIVEC_ABI)\n+    fprintf (stderr, \"\\tALTIVEC ABI extensions enabled.\\n\");\n+\n   if (info->first_gp_reg_save != 32)\n     fprintf (stderr, \"\\tfirst_gp_reg_save   = %5d\\n\", info->first_gp_reg_save);\n \n   if (info->first_fp_reg_save != 64)\n     fprintf (stderr, \"\\tfirst_fp_reg_save   = %5d\\n\", info->first_fp_reg_save);\n \n+  if (info->first_altivec_reg_save <= LAST_ALTIVEC_REGNO)\n+    fprintf (stderr, \"\\tfirst_altivec_reg_save = %5d\\n\",\n+\t     info->first_altivec_reg_save);\n+\n   if (info->lr_save_p)\n     fprintf (stderr, \"\\tlr_save_p           = %5d\\n\", info->lr_save_p);\n \n@@ -6227,6 +6442,9 @@ debug_stack_info (info)\n   if (info->toc_save_p)\n     fprintf (stderr, \"\\ttoc_save_p          = %5d\\n\", info->toc_save_p);\n \n+  if (info->vrsave_mask)\n+    fprintf (stderr, \"\\tvrsave_mask         = 0x%x\\n\", info->vrsave_mask);\n+\n   if (info->push_p)\n     fprintf (stderr, \"\\tpush_p              = %5d\\n\", info->push_p);\n \n@@ -6239,6 +6457,14 @@ debug_stack_info (info)\n   if (info->fp_save_offset)\n     fprintf (stderr, \"\\tfp_save_offset      = %5d\\n\", info->fp_save_offset);\n \n+  if (info->altivec_save_offset)\n+    fprintf (stderr, \"\\taltivec_save_offset = %5d\\n\",\n+\t     info->altivec_save_offset);\n+\n+  if (info->vrsave_save_offset)\n+    fprintf (stderr, \"\\tvrsave_save_offset  = %5d\\n\",\n+\t     info->vrsave_save_offset);\n+\n   if (info->lr_save_offset)\n     fprintf (stderr, \"\\tlr_save_offset      = %5d\\n\", info->lr_save_offset);\n \n@@ -6272,6 +6498,16 @@ debug_stack_info (info)\n   if (info->fp_size)\n     fprintf (stderr, \"\\tfp_size             = %5d\\n\", info->fp_size);\n \n+  if (info->altivec_size)\n+    fprintf (stderr, \"\\taltivec_size        = %5d\\n\", info->altivec_size);\n+\n+  if (info->vrsave_size)\n+    fprintf (stderr, \"\\tvrsave_size         = %5d\\n\", info->vrsave_size);\n+\n+  if (info->altivec_padding_size)\n+    fprintf (stderr, \"\\taltivec_padding_size= %5d\\n\",\n+\t     info->altivec_padding_size);\n+\n   if (info->lr_size)\n     fprintf (stderr, \"\\tlr_size             = %5d\\n\", info->lr_size);\n \n@@ -6806,6 +7042,36 @@ rs6000_frame_related (insn, reg, val, reg2, rreg)\n \t\t\t\t\tREG_NOTES (insn));\n }\n \n+/* Returns an insn that has a vrsave set operation with the\n+   appropriate CLOBBERs.  */\n+\n+static rtx\n+generate_set_vrsave (reg, info)\n+     rtx reg;\n+     rs6000_stack_t *info;\n+{\n+  int nclobs, i;\n+  rtx insn, clobs[TOTAL_ALTIVEC_REGS + 1];\n+\n+  clobs[0] = gen_set_vrsave (reg);\n+\n+  nclobs = 1;\n+\n+  /* CLOBBER the registers in the mask.  */\n+\n+  for (i = FIRST_ALTIVEC_REGNO; i <= LAST_ALTIVEC_REGNO; ++i)\n+    if (info->vrsave_mask != 0 && ALTIVEC_REG_BIT (i) != 0)\n+      clobs[nclobs++] = gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t\t gen_rtx_REG (V4SImode, i));\n+\n+  insn = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (nclobs));\n+\n+  for (i = 0; i < nclobs; ++i)\n+    XVECEXP (insn, 0, i) = clobs[i];\n+\n+  return insn;\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -7042,6 +7308,70 @@ rs6000_emit_prologue ()\n   if (info->push_p && DEFAULT_ABI != ABI_V4 && DEFAULT_ABI != ABI_SOLARIS)\n     rs6000_emit_allocate_stack (info->total_size, FALSE);\n \n+  /* Save AltiVec registers if needed.  */\n+  if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+    {\n+      int i;\n+\n+      /* There should be a non inline version of this, for when we\n+\t are saving lots of vector registers.  */\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    rtx addr, areg, savereg, mem;\n+\n+\t    savereg = gen_rtx_REG (V4SImode, i);\n+\n+\t    areg = gen_rtx_REG (Pmode, 0);\n+\t    emit_move_insn\n+\t      (areg, GEN_INT (info->altivec_save_offset\n+\t\t\t      + sp_offset\n+\t\t\t      + 16 * (i - info->first_altivec_reg_save)));\n+\n+\t    /* AltiVec addressing mode is [reg+reg].  */\n+\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t    mem = gen_rtx_MEM (V4SImode, addr);\n+\t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t    insn = emit_move_insn (mem, savereg);\n+\t    rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+\t\t\t\t  NULL_RTX, NULL_RTX);\n+\t  }\n+    }\n+\n+  /* VRSAVE is a bit vector representing which AltiVec registers\n+     are used.  The OS uses this to determine which vector\n+     registers to save on a context switch.  We need to save\n+     VRSAVE on the stack frame, add whatever AltiVec registers we\n+     used in this function, and do the corresponding magic in the\n+     epilogue.  */\n+\n+  if (TARGET_ALTIVEC && info->vrsave_mask != 0)\n+    {\n+      rtx reg, addr, mem;\n+\n+      /* Get VRSAVE onto a GPR.  */\n+      reg = gen_rtx_REG (SImode, 12);\n+      emit_insn (gen_get_vrsave (reg));\n+\n+      /* Save VRSAVE.  */\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t   GEN_INT (info->vrsave_save_offset + sp_offset));\n+      mem = gen_rtx_MEM (SImode, addr);\n+      set_mem_alias_set (mem, rs6000_sr_alias_set);\n+      insn = emit_move_insn (mem, reg);\n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t    NULL_RTX, NULL_RTX);\n+\n+      /* Include the registers in the mask.  */\n+      emit_insn (gen_iorsi3 (reg, reg, GEN_INT ((int) info->vrsave_mask)));\n+\n+      insn = emit_insn (generate_set_vrsave (reg, info));\n+\n+      rs6000_frame_related (insn, frame_ptr_rtx, info->total_size,\n+\t\t\t    NULL_RTX, NULL_RTX);\n+    }\n+\n   /* Set frame pointer, if needed.  */\n   if (frame_pointer_needed)\n     {\n@@ -7321,6 +7651,46 @@ rs6000_emit_epilogue (sibcall)\n \t\t\t  mem);\n \t}\n \n+  /* Restore AltiVec registers if needed.  */\n+  if (TARGET_ALTIVEC_ABI && info->altivec_size != 0)\n+    {\n+      int i;\n+\n+      for (i = info->first_altivec_reg_save; i <= LAST_ALTIVEC_REGNO; ++i)\n+\tif (regs_ever_live[i] && ! call_used_regs[i])\n+\t  {\n+\t    rtx addr, areg, mem;\n+\n+\t    areg = gen_rtx_REG (Pmode, 0);\n+\t    emit_move_insn\n+\t      (areg, GEN_INT (info->altivec_save_offset\n+\t\t\t      + sp_offset\n+\t\t\t      + 16 * (i - info->first_altivec_reg_save)));\n+\n+\t    /* AltiVec addressing mode is [reg+reg].  */\n+\t    addr = gen_rtx_PLUS (Pmode, frame_reg_rtx, areg);\n+\t    mem = gen_rtx_MEM (V4SImode, addr);\n+\t    set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t    emit_move_insn (gen_rtx_REG (V4SImode, i), mem);\n+\t  }\n+    }\n+\n+  /* Restore VRSAVE if needed.  */\n+  if (TARGET_ALTIVEC_ABI && info->vrsave_mask != 0)\n+    {\n+      rtx addr, mem, reg;\n+\n+      addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t   GEN_INT (info->vrsave_save_offset + sp_offset));\n+      mem = gen_rtx_MEM (SImode, addr);\n+      set_mem_alias_set (mem, rs6000_sr_alias_set);\n+      reg = gen_rtx_REG (SImode, 12);\n+      emit_move_insn (reg, mem);\n+\n+      emit_insn (generate_set_vrsave (reg, info));\n+    }\n+\n   /* If we saved cr, restore it here.  Just those that were used.  */\n   if (info->cr_save_p)\n     {"}, {"sha": "71e41d2e307335f4c407b760cba4bccce717c9c5", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=00b960c7ada70affc18fe7f4ad170a40c684c208", "patch": "@@ -736,6 +736,7 @@ extern int rs6000_debug_arg;\t\t/* debug argument handling */\n #define XER_REGNO    76\n #define FIRST_ALTIVEC_REGNO\t77\n #define LAST_ALTIVEC_REGNO\t108\n+#define TOTAL_ALTIVEC_REGS\t(LAST_ALTIVEC_REGNO - FIRST_ALTIVEC_REGNO)\n #define VRSAVE_REGNO\t\t109\n \n /* List the order in which to allocate registers.  Each register must be\n@@ -1265,16 +1266,20 @@ extern enum rs6000_abi rs6000_current_abi;\t/* available for use by subtarget */\n typedef struct rs6000_stack {\n   int first_gp_reg_save;\t/* first callee saved GP register used */\n   int first_fp_reg_save;\t/* first callee saved FP register used */\n+  int first_altivec_reg_save;\t/* first callee saved AltiVec register used */\n   int lr_save_p;\t\t/* true if the link reg needs to be saved */\n   int cr_save_p;\t\t/* true if the CR reg needs to be saved */\n+  unsigned int vrsave_mask;\t/* mask of vec registers to save */\n   int toc_save_p;\t\t/* true if the TOC needs to be saved */\n   int push_p;\t\t\t/* true if we need to allocate stack space */\n   int calls_p;\t\t\t/* true if the function makes any calls */\n   enum rs6000_abi abi;\t\t/* which ABI to use */\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n   int fp_save_offset;\t\t/* offset to save FP regs from initial SP */\n+  int altivec_save_offset;\t/* offset to save AltiVec regs from inital SP */\n   int lr_save_offset;\t\t/* offset to save LR from initial SP */\n   int cr_save_offset;\t\t/* offset to save CR from initial SP */\n+  int vrsave_save_offset;\t/* offset to save VRSAVE from initial SP */\n   int toc_save_offset;\t\t/* offset to save the TOC pointer */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n   int ehrd_offset;\t\t/* offset to EH return data */\n@@ -1286,8 +1291,12 @@ typedef struct rs6000_stack {\n   int fixed_size;\t\t/* fixed size of stack frame */\n   int gp_size;\t\t\t/* size of saved GP registers */\n   int fp_size;\t\t\t/* size of saved FP registers */\n+  int altivec_size;\t\t/* size of saved AltiVec registers */\n   int cr_size;\t\t\t/* size to hold CR if not in save_size */\n   int lr_size;\t\t\t/* size to hold LR if not in save_size */\n+  int vrsave_size;\t\t/* size to hold VRSAVE if not in save_size */\n+  int altivec_padding_size;\t/* size of altivec alignment padding if\n+\t\t\t\t   not in save_size */\n   int toc_size;\t\t\t/* size to hold TOC if not in save_size */\n   int total_size;\t\t/* total bytes allocated for stack */\n } rs6000_stack_t;\n@@ -1685,6 +1694,7 @@ typedef struct rs6000_args\n \n #define\tEPILOGUE_USES(REGNO)\t\t\t\t\t\\\n   ((reload_completed && (REGNO) == LINK_REGISTER_REGNUM)\t\\\n+   || (REGNO) == VRSAVE_REGNO\t\t\t\t\t\\\n    || (current_function_calls_eh_return\t\t\t\t\\\n        && TARGET_AIX\t\t\t\t\t\t\\\n        && (REGNO) == TOC_REGISTER))\n@@ -2792,6 +2802,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t\t     CONST_DOUBLE, SYMBOL_REF}},\t\t\t   \\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n+  {\"vrsave_operation\", {PARALLEL}},\t\t\t\t\t   \\\n   {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n \t\t\t\t  GT, LEU, LTU, GEU, GTU,\t\t   \\\n \t\t\t\t  UNORDERED, ORDERED,\t\t\t   \\"}, {"sha": "174d3e6c17072e02bc166f0c50fec2e594525db7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00b960c7ada70affc18fe7f4ad170a40c684c208/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=00b960c7ada70affc18fe7f4ad170a40c684c208", "patch": "@@ -13622,6 +13622,31 @@\n    vor %0,%1,%1\"\n   [(set_attr \"type\" \"altivec\")])\n \n+;; Copy VRSAVE into a GPR.\n+(define_insn \"get_vrsave\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(reg:SI 109)] 28))]\n+  \"TARGET_ALTIVEC\"\n+  \"mfvrsave %0\"\n+  [(set_attr \"type\" \"altivec\")])\n+\n+(define_insn \"*set_vrsave_internal\"\n+  [(match_parallel 0 \"vrsave_operation\"\n+     [(set (reg:SI 109)\n+\t   (unspec:SI [(match_operand:SI 1 \"register_operand\" \"r\")\n+\t\t       (reg:SI 109)] 30))])]\n+  \"TARGET_ALTIVEC\"\n+  \"mtvrsave %1\"\n+  [(set_attr \"type\" \"altivec\")])\n+\n+(define_insn \"set_vrsave\"\n+  [(set (reg:SI 109)\n+\t(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t\t    (reg:SI 109)] 30))]\n+  \"TARGET_ALTIVEC\"\n+  \"mtvrsave %0\"\n+  [(set_attr \"type\" \"altivec\")])\n+\n ;; Simple binary operations.\n \n (define_insn \"altivec_vaddubm\""}]}