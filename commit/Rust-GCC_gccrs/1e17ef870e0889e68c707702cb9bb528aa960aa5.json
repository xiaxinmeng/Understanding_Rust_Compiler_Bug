{"sha": "1e17ef870e0889e68c707702cb9bb528aa960aa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWUxN2VmODcwZTA4ODllNjhjNzA3NzAyY2I5YmI1MjhhYTk2MGFhNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-07T08:26:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-07T08:26:08Z"}, "message": "decl.c (gnat_to_gnu_entity): Reorder local variables.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Reorder local variables.\n\t* gcc-interface/trans.c: Fix formatting throughout.  Fix comments.\n\t* gcc-interface/utils.c: Fix comments.\n\nFrom-SVN: r145658", "tree": {"sha": "6e514b0c5e1d40e92cbb39613ae6208c6c76f118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6e514b0c5e1d40e92cbb39613ae6208c6c76f118"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e17ef870e0889e68c707702cb9bb528aa960aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e17ef870e0889e68c707702cb9bb528aa960aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e17ef870e0889e68c707702cb9bb528aa960aa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e17ef870e0889e68c707702cb9bb528aa960aa5/comments", "author": null, "committer": null, "parents": [{"sha": "229077b0b4db794783c20b1a80aa9dd3930f2dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/229077b0b4db794783c20b1a80aa9dd3930f2dfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/229077b0b4db794783c20b1a80aa9dd3930f2dfc"}], "stats": {"total": 542, "additions": 266, "deletions": 276}, "files": [{"sha": "a957d37b38656f353b859335c6fa3496528402ef", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1e17ef870e0889e68c707702cb9bb528aa960aa5", "patch": "@@ -1,9 +1,17 @@\n 2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n-\t* decl.c (compile_time_known_address_p): Rewrite and move around.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Reorder local variables.\n+\t* gcc-interface/trans.c: Fix formatting throughout.  Fix comments.\n+\t* gcc-interface/utils.c: Fix comments.\n+\n+2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (compile_time_known_address_p): Rewrite and\n+\tmove around.\n \t(gnat_to_gnu_type): Move around.\n \t(get_unpadded_type): Likewise.\n-\t* utils.c (update_pointer_to): Use synthetic macro.  Tidy comments.\n+\t* gcc-interface/utils.c (update_pointer_to): Use synthetic macro.\n+\tTidy comments.\n \n 2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n "}, {"sha": "9947777bc92c1134c4beecef36ff72b136dae305", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 57, "deletions": 60, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=1e17ef870e0889e68c707702cb9bb528aa960aa5", "patch": "@@ -155,17 +155,16 @@ static int compatible_signatures_p (tree ftype1, tree ftype2);\n static void rest_of_type_decl_compilation_no_defer (tree);\n \f\n /* Given GNAT_ENTITY, a GNAT defining identifier node, which denotes some Ada\n-   entity, this routine returns the equivalent GCC tree for that entity\n-   (an ..._DECL node) and associates the ..._DECL node with the input GNAT\n-   defining identifier.\n+   entity, return the equivalent GCC tree for that entity (a ..._DECL node)\n+   and associate the ..._DECL node with the input GNAT defining identifier.\n \n    If GNAT_ENTITY is a variable or a constant declaration, GNU_EXPR gives its\n-   initial value (in GCC tree form).  This is optional for variables.\n-   For renamed entities, GNU_EXPR gives the object being renamed.\n+   initial value (in GCC tree form).  This is optional for a variable.  For\n+   a renamed entity, GNU_EXPR gives the object being renamed.\n \n    DEFINITION is nonzero if this call is intended for a definition.  This is\n-   used for separate compilation where it necessary to know whether an\n-   external declaration or a definition should be created if the GCC equivalent\n+   used for separate compilation where it is necessary to know whether an\n+   external declaration or a definition must be created if the GCC equivalent\n    was not created previously.  The value of 1 is normally used for a nonzero\n    DEFINITION, but a value of 2 is used in special circumstances, defined in\n    the code.  */\n@@ -174,27 +173,34 @@ tree\n gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n {\n   Entity_Id gnat_equiv_type = Gigi_Equivalent_Type (gnat_entity);\n-  tree gnu_entity_id;\n-  tree gnu_type = NULL_TREE;\n-  /* Contains the gnu XXXX_DECL tree node which is equivalent to the input\n-     GNAT tree.  This node will be associated with the GNAT node by calling\n-     the save_gnu_tree routine at the end of the `switch' statement.  */\n+  Entity_Id gnat_temp;\n+  Entity_Kind kind = Ekind (gnat_entity);\n+  /* Contains the GCC DECL node which is equivalent to the input GNAT node.\n+     This node will be associated with the GNAT node by calling at the end\n+     of the `switch' statement.  */\n   tree gnu_decl = NULL_TREE;\n-  /* true if we have already saved gnu_decl as a gnat association.  */\n+  /* Contains the GCC type to be used for the GCC node.  */\n+  tree gnu_type = NULL_TREE;\n+  /* Contains the GCC size tree to be used for the GCC node.  */\n+  tree gnu_size = NULL_TREE;\n+  /* Contains the GCC name to be used for the GCC node.  */\n+  tree gnu_entity_id;\n+  /* True if we have already saved gnu_decl as a GNAT association.  */\n   bool saved = false;\n-  /* Nonzero if we incremented defer_incomplete_level.  */\n+  /* True if we incremented defer_incomplete_level.  */\n   bool this_deferred = false;\n-  /* Nonzero if we incremented force_global.  */\n+  /* True if we incremented force_global.  */\n   bool this_global = false;\n-  /* Nonzero if we should check to see if elaborated during processing.  */\n+  /* True if we should check to see if elaborated during processing.  */\n   bool maybe_present = false;\n-  /* Nonzero if we made GNU_DECL and its type here.  */\n+  /* True if we made GNU_DECL and its type here.  */\n   bool this_made_decl = false;\n-  struct attrib *attr_list = NULL;\n+  /* True if debug info is requested for this entity.  */\n   bool debug_info_p = (Needs_Debug_Info (gnat_entity)\n \t\t       || debug_info_level == DINFO_LEVEL_VERBOSE);\n-  Entity_Kind kind = Ekind (gnat_entity);\n-  Entity_Id gnat_temp;\n+  /* True if this entity is to be considered as imported.  */\n+  bool imported_p = (Is_Imported (gnat_entity)\n+\t\t     && No (Address_Clause (gnat_entity)));\n   unsigned int esize\n     = ((Known_Esize (gnat_entity)\n \t&& UI_Is_In_Int_Range (Esize (gnat_entity)))\n@@ -204,22 +210,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      : IN (kind, Access_Kind) ? POINTER_SIZE * 2\n \t      : LONG_LONG_TYPE_SIZE)\n        : LONG_LONG_TYPE_SIZE);\n-  tree gnu_size = 0;\n-  bool imported_p\n-    = (Is_Imported (gnat_entity) && No (Address_Clause (gnat_entity)));\n   unsigned int align = 0;\n+  struct attrib *attr_list = NULL;\n \n   /* Since a use of an Itype is a definition, process it as such if it\n      is not in a with'ed unit.  */\n-\n-  if (!definition && Is_Itype (gnat_entity)\n+  if (!definition\n+      && Is_Itype (gnat_entity)\n       && !present_gnu_tree (gnat_entity)\n       && In_Extended_Main_Code_Unit (gnat_entity))\n     {\n-      /* Ensure that we are in a subprogram mentioned in the Scope\n-\t chain of this entity, our current scope is global,\n-\t or that we encountered a task or entry (where we can't currently\n-\t accurately check scoping).  */\n+      /* Ensure that we are in a subprogram mentioned in the Scope chain of\n+\t this entity, our current scope is global, or we encountered a task\n+\t or entry (where we can't currently accurately check scoping).  */\n       if (!current_function_decl\n \t  || DECL_ELABORATION_PROC_P (current_function_decl))\n \t{\n@@ -228,7 +231,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t}\n \n       for (gnat_temp = Scope (gnat_entity);\n-\t   Present (gnat_temp); gnat_temp = Scope (gnat_temp))\n+\t   Present (gnat_temp);\n+\t   gnat_temp = Scope (gnat_temp))\n \t{\n \t  if (Is_Type (gnat_temp))\n \t    gnat_temp = Underlying_Type (gnat_temp);\n@@ -254,21 +258,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \t}\n \n-      /* This abort means the entity \"gnat_entity\" has an incorrect scope,\n-\t i.e. that its scope does not correspond to the subprogram in which\n-\t it is declared */\n+      /* This abort means the entity has an incorrect scope, i.e. that its\n+\t scope does not correspond to the subprogram it is declared in.  */\n       gcc_unreachable ();\n     }\n \n-  /* If this is entity 0, something went badly wrong.  */\n+  /* If the entiy is not present, something went badly wrong.  */\n   gcc_assert (Present (gnat_entity));\n \n   /* If we've already processed this entity, return what we got last time.\n      If we are defining the node, we should not have already processed it.\n-     In that case, we will abort below when we try to save a new GCC tree for\n-     this object.   We also need to handle the case of getting a dummy type\n-     when a Full_View exists.  */\n-\n+     In that case, we will abort below when we try to save a new GCC tree\n+     for this object.  We also need to handle the case of getting a dummy\n+     type when a Full_View exists.  */\n   if (present_gnu_tree (gnat_entity)\n       && (!definition || (Is_Type (gnat_entity) && imported_p)))\n     {\n@@ -279,9 +281,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && IN (kind, Incomplete_Or_Private_Kind)\n \t  && Present (Full_View (gnat_entity)))\n \t{\n-\t  gnu_decl = gnat_to_gnu_entity (Full_View (gnat_entity),\n-\t\t\t\t\t NULL_TREE, 0);\n-\n+\t  gnu_decl\n+\t    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, 0);\n \t  save_gnu_tree (gnat_entity, NULL_TREE, false);\n \t  save_gnu_tree (gnat_entity, gnu_decl, false);\n \t}\n@@ -293,14 +294,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n      Esize must be specified unless it was specified by the programmer.  */\n   gcc_assert (!Unknown_Esize (gnat_entity)\n \t      || Has_Size_Clause (gnat_entity)\n-\t      || (!IN (kind, Numeric_Kind) && !IN (kind, Enumeration_Kind)\n+\t      || (!IN (kind, Numeric_Kind)\n+\t\t  && !IN (kind, Enumeration_Kind)\n \t\t  && (!IN (kind, Access_Kind)\n \t\t      || kind == E_Access_Protected_Subprogram_Type\n \t\t      || kind == E_Anonymous_Access_Protected_Subprogram_Type\n \t\t      || kind == E_Access_Subtype)));\n \n-  /* Likewise, RM_Size must be specified for all discrete and fixed-point\n-     types.  */\n+  /* RM_Size must be specified for all discrete and fixed-point types.  */\n   gcc_assert (!IN (kind, Discrete_Or_Fixed_Point_Kind)\n \t      || !Unknown_RM_Size (gnat_entity));\n \n@@ -319,7 +320,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      || IN (kind, Type_Kind));\n \n   /* For cases when we are not defining (i.e., we are referencing from\n-     another compilation unit) Public entities, show we are at global level\n+     another compilation unit) public entities, show we are at global level\n      for the purpose of computing scopes.  Don't do this for components or\n      discriminants since the relevant test is whether or not the record is\n      being defined.  But do this for Imported functions or procedures in\n@@ -410,7 +411,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t the regular processing take place, which leaves us with a regular\n \t exception data object for VMS exceptions too.  The condition code\n \t mapping is taken care of by the front end and the bitmasking by the\n-\t runtime library.   */\n+\t runtime library.  */\n       goto object;\n \n     case E_Discriminant:\n@@ -426,7 +427,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   stored discriminants, return the entity for the corresponding\n \t   stored discriminant.  Also use Original_Record_Component\n \t   if the record has a private extension.  */\n-\n \tif (Present (Original_Record_Component (gnat_entity))\n \t    && Original_Record_Component (gnat_entity) != gnat_entity)\n \t  {\n@@ -441,14 +441,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   then it is an untagged record.  If the Corresponding_Discriminant\n \t   is not empty then this must be a renamed discriminant and its\n \t   Original_Record_Component must point to the corresponding explicit\n-\t   stored discriminant (i.e., we should have taken the previous\n+\t   stored discriminant (i.e. we should have taken the previous\n \t   branch).  */\n-\n \telse if (Present (Corresponding_Discriminant (gnat_entity))\n \t\t && Is_Tagged_Type (gnat_record))\n \t  {\n \t    /* A tagged record has no explicit stored discriminants.  */\n-\n \t    gcc_assert (First_Discriminant (gnat_record)\n \t\t       == First_Stored_Discriminant (gnat_record));\n \t    gnu_decl\n@@ -471,9 +469,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   it is an untagged record.  If the Corresponding_Discriminant\n \t   is not empty then this must be a renamed discriminant and its\n \t   Original_Record_Component must point to the corresponding explicit\n-\t   stored discriminant (i.e., we should have taken the first\n+\t   stored discriminant (i.e. we should have taken the first\n \t   branch).  */\n-\n \telse if (Present (Corresponding_Discriminant (gnat_entity))\n \t\t && (First_Discriminant (gnat_record)\n \t\t     != First_Stored_Discriminant (gnat_record)))\n@@ -3281,7 +3278,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   either gnat_desig_full or gnat_desig_equiv.  */\n \tEntity_Id gnat_desig_rep;\n \n-\t/* Nonzero if this is a pointer to an unconstrained array.  */\n+\t/* True if this is a pointer to an unconstrained array.  */\n \tbool is_unconstrained_array;\n \n \t/* We want to know if we'll be seeing the freeze node for any\n@@ -3291,9 +3288,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     ? In_Extended_Main_Code_Unit (gnat_desig_full)\n \t     : In_Extended_Main_Code_Unit (gnat_desig_type));\n \n-\t/* Nonzero if we make a dummy type here.  */\n+\t/* True if we make a dummy type here.  */\n \tbool got_fat_p = false;\n-\t/* Nonzero if the dummy is a fat pointer.  */\n+\t/* True if the dummy is a fat pointer.  */\n \tbool made_dummy = false;\n \ttree gnu_desig_type = NULL_TREE;\n \tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n@@ -5483,10 +5480,10 @@ maybe_variable (tree gnu_operand)\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n    return the GCC tree to use for that expression.  GNU_NAME is the\n    qualification to use if an external name is appropriate and DEFINITION is\n-   nonzero if this is a definition of GNAT_ENTITY.  If NEED_VALUE is nonzero,\n-   we need a result.  Otherwise, we are just elaborating this for\n-   side-effects.  If NEED_DEBUG is nonzero we need the symbol for debugging\n-   purposes even if it isn't needed for code generation.  */\n+   true if this is a definition of GNAT_ENTITY.  If NEED_VALUE is true, we\n+   need a result.  Otherwise, we are just elaborating this for side-effects.\n+   If NEED_DEBUG is true we need the symbol for debugging purposes even if it\n+   isn't needed for code generation.  */\n \n static tree\n elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity,\n@@ -7285,7 +7282,7 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n \f\n /* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n    If TYPE is the best type, return it.  Otherwise, make a new type.  We\n-   only support new integral and pointer types.  FOR_BIASED is nonzero if\n+   only support new integral and pointer types.  FOR_BIASED is true if\n    we are making a biased type.  */\n \n static tree"}, {"sha": "44d335221189c61a4b0dda6b05e559e6acac37d2", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 192, "deletions": 205, "changes": 397, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=1e17ef870e0889e68c707702cb9bb528aa960aa5", "patch": "@@ -58,7 +58,6 @@\n #include \"ada-tree.h\"\n #include \"gigi.h\"\n #include \"adadecode.h\"\n-\n #include \"dwarf2.h\"\n #include \"dwarf2out.h\"\n \n@@ -74,10 +73,9 @@\n #endif\n \n /* For efficient float-to-int rounding, it is necessary to know whether\n-   floating-point arithmetic may use wider intermediate results.\n-   When FP_ARITH_MAY_WIDEN is not defined, be conservative and only assume\n-   floating-point arithmetic does not widen if double precision is emulated. */\n-\n+   floating-point arithmetic may use wider intermediate results.  When\n+   FP_ARITH_MAY_WIDEN is not defined, be conservative and only assume\n+   that arithmetic does not widen if double precision is emulated.  */\n #ifndef FP_ARITH_MAY_WIDEN\n #if defined(HAVE_extendsfdf2)\n #define FP_ARITH_MAY_WIDEN HAVE_extendsfdf2\n@@ -100,12 +98,12 @@ struct String_Entry *Strings_Ptr;\n Char_Code *String_Chars_Ptr;\n struct List_Header *List_Headers_Ptr;\n \n-/* Current filename without path. */\n+/* Current filename without path.  */\n const char *ref_filename;\n \n-/* If true, then gigi is being called on an analyzed but unexpanded\n+/* True when gigi is being called on an analyzed but unexpanded\n    tree, and the only purpose of the call is to properly annotate\n-   types with representation information. */\n+   types with representation information.  */\n bool type_annotate_only;\n \n /* When not optimizing, we cache the 'First, 'Last and 'Length attributes\n@@ -140,8 +138,8 @@ struct language_function GTY(())\n \n struct stmt_group GTY((chain_next (\"%h.previous\"))) {\n   struct stmt_group *previous;\t/* Previous code group.  */\n-  tree stmt_list;\t\t/* List of statements for this code group. */\n-  tree block;\t\t\t/* BLOCK for this code group, if any. */\n+  tree stmt_list;\t\t/* List of statements for this code group.  */\n+  tree block;\t\t\t/* BLOCK for this code group, if any.  */\n   tree cleanups;\t\t/* Cleanups for this code group, if any.  */\n };\n \n@@ -156,7 +154,7 @@ static GTY((deletable)) struct stmt_group *stmt_group_free_list;\n    ??? gnat_node should be Node_Id, but gengtype gets confused.  */\n \n struct elab_info GTY((chain_next (\"%h.next\"))) {\n-  struct elab_info *next;\t/* Pointer to next in chain. */\n+  struct elab_info *next;\t/* Pointer to next in chain.  */\n   tree elab_proc;\t\t/* Elaboration procedure.  */\n   int gnat_node;\t\t/* The N_Compilation_Unit.  */\n };\n@@ -275,7 +273,7 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \t the name table gets reallocated after Gigi returns but before all the\n \t debugging information is output.  The __gnat_to_canonical_file_spec\n \t call translates filenames from pragmas Source_Reference that contain\n-\t host style syntax not understood by gdb. */\n+\t host style syntax not understood by gdb.  */\n       const char *filename\n \t= IDENTIFIER_POINTER\n \t   (get_identifier\n@@ -601,8 +599,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n      required if this is a static expression because it might be used\n      in a context where a dereference is inappropriate, such as a case\n      statement alternative or a record discriminant.  There is no possible\n-     volatile-ness short-circuit here since Volatile constants must be imported\n-     per C.6. */\n+     volatile-ness short-circuit here since Volatile constants must bei\n+     imported per C.6.  */\n   if (Ekind (gnat_temp) == E_Constant && Is_Scalar_Type (gnat_temp_type)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n@@ -1061,7 +1059,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       gnu_expr = gnu_prefix;\n \n       /* Remove NOPS from gnu_expr and conversions from gnu_prefix.\n-\t We only use GNU_EXPR to see if a COMPONENT_REF was involved. */\n+\t We only use GNU_EXPR to see if a COMPONENT_REF was involved.  */\n       while (TREE_CODE (gnu_expr) == NOP_EXPR)\n \tgnu_expr = TREE_OPERAND (gnu_expr, 0);\n \n@@ -1112,15 +1110,21 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t  else if (Nkind (Prefix (gnat_node)) == N_Explicit_Dereference)\n \t    {\n \t      Node_Id gnat_deref = Prefix (gnat_node);\n-\t      Node_Id gnat_actual_subtype = Actual_Designated_Subtype (gnat_deref);\n-\t      tree gnu_ptr_type = TREE_TYPE (gnat_to_gnu (Prefix (gnat_deref)));\n+\t      Node_Id gnat_actual_subtype\n+\t\t= Actual_Designated_Subtype (gnat_deref);\n+\t      tree gnu_ptr_type\n+\t\t= TREE_TYPE (gnat_to_gnu (Prefix (gnat_deref)));\n+\n \t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type)\n-\t  \t&& Present (gnat_actual_subtype))\n-\t        {\n-\t\t  tree gnu_actual_obj_type = gnat_to_gnu_type (gnat_actual_subtype);\n-\t\t  gnu_type = build_unc_object_type_from_ptr (gnu_ptr_type,\n-\t\t\t       gnu_actual_obj_type, get_identifier (\"SIZE\"));\n-\t        }\n+\t\t  && Present (gnat_actual_subtype))\n+\t\t{\n+\t\t  tree gnu_actual_obj_type\n+\t\t    = gnat_to_gnu_type (gnat_actual_subtype);\n+\t\t  gnu_type\n+\t\t    = build_unc_object_type_from_ptr (gnu_ptr_type,\n+\t\t\t\t\t\t      gnu_actual_obj_type,\n+\t\t\t\t\t\t      get_identifier (\"SIZE\"));\n+\t\t}\n \n \t      gnu_result = TYPE_SIZE (gnu_type);\n \t    }\n@@ -1381,7 +1385,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tprefix_unused = true;\n \n \t/* We can have 'Bit on any object, but if it isn't a COMPONENT_REF,\n-\t   the result is 0.  Don't allow 'Bit on a bare component, though. */\n+\t   the result is 0.  Don't allow 'Bit on a bare component, though.  */\n \tif (attribute == Attr_Bit\n \t    && TREE_CODE (gnu_prefix) != COMPONENT_REF\n \t    && TREE_CODE (gnu_prefix) != FIELD_DECL)\n@@ -1452,7 +1456,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t}\n \n \t/* If this has a PLACEHOLDER_EXPR, qualify it by the object\n-\t   we are handling. */\n+\t   we are handling.  */\n \tgnu_result = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_result, gnu_prefix);\n \tbreak;\n       }\n@@ -1554,7 +1558,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n   /* If this is an attribute where the prefix was unused, force a use of it if\n      it has a side-effect.  But don't do it if the prefix is just an entity\n      name.  However, if an access check is needed, we must do it.  See second\n-     example in AARM 11.6(5.e). */\n+     example in AARM 11.6(5.e).  */\n   if (prefix_unused && TREE_SIDE_EFFECTS (gnu_prefix)\n       && !Is_Entity_Name (Prefix (gnat_node)))\n     gnu_result = fold_build2 (COMPOUND_EXPR, TREE_TYPE (gnu_result),\n@@ -1680,7 +1684,7 @@ Case_Statement_to_gnu (Node_Id gnat_node)\n \t}\n     }\n \n-  /* Now emit a definition of the label all the cases branched to. */\n+  /* Now emit a definition of the label all the cases branched to.  */\n   add_stmt (build1 (LABEL_EXPR, void_type_node,\n \t\t    TREE_VALUE (gnu_switch_label_stack)));\n   gnu_result = build3 (SWITCH_EXPR, TREE_TYPE (gnu_expr), gnu_expr,\n@@ -2373,7 +2377,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n       /* If we have not saved a GCC object for the formal, it means it is an\n \t Out parameter not passed by reference and that does not need to be\n \t copied in. Otherwise, look at the PARM_DECL to see if it is passed by\n-\t reference. */\n+\t reference.  */\n       if (gnu_formal\n \t  && TREE_CODE (gnu_formal) == PARM_DECL\n \t  && DECL_BY_REF_P (gnu_formal))\n@@ -2408,7 +2412,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    }\n \n \t  /* The symmetry of the paths to the type of an entity is broken here\n-\t     since arguments don't know that they will be passed by ref. */\n+\t     since arguments don't know that they will be passed by ref.  */\n \t  gnu_formal_type = TREE_TYPE (get_gnu_tree (gnat_formal));\n \t  gnu_actual = build_unary_op (ADDR_EXPR, gnu_formal_type, gnu_actual);\n \t}\n@@ -3087,7 +3091,7 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n   Sloc_to_locus (Sloc (gnat_unit_entity), &cfun->function_end_locus);\n   set_cfun (NULL);\n \n-  /* For a body, first process the spec if there is one. */\n+  /* For a body, first process the spec if there is one.  */\n   if (Nkind (Unit (gnat_node)) == N_Package_Body\n       || (Nkind (Unit (gnat_node)) == N_Subprogram_Body\n \t      && !Acts_As_Spec (gnat_node)))\n@@ -3151,7 +3155,7 @@ tree\n gnat_to_gnu (Node_Id gnat_node)\n {\n   bool went_into_elab_proc = false;\n-  tree gnu_result = error_mark_node; /* Default to no value. */\n+  tree gnu_result = error_mark_node; /* Default to no value.  */\n   tree gnu_result_type = void_type_node;\n   tree gnu_expr;\n   tree gnu_lhs, gnu_rhs;\n@@ -3214,7 +3218,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   switch (Nkind (gnat_node))\n     {\n       /********************************/\n-      /* Chapter 2: Lexical Elements: */\n+      /* Chapter 2: Lexical Elements  */\n       /********************************/\n \n     case N_Identifier:\n@@ -3274,12 +3278,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t}\n \n       /* We should never see a Vax_Float type literal, since the front end\n-         is supposed to transform these using appropriate conversions */\n+\t is supposed to transform these using appropriate conversions.  */\n       else if (Vax_Float (Underlying_Type (Etype (gnat_node))))\n \tgcc_unreachable ();\n \n       else\n-        {\n+\t{\n \t  Ureal ur_realval = Realval (gnat_node);\n \n \t  gnu_result_type = get_unpadded_type (Etype (gnat_node));\n@@ -3340,9 +3344,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  int i;\n \t  char *string;\n \t  if (length >= ALLOCA_THRESHOLD)\n-             string = XNEWVEC (char, length + 1); /* in case of large strings */\n-          else\n-             string = (char *) alloca (length + 1);\n+\t    string = XNEWVEC (char, length + 1);\n+\t  else\n+\t    string = (char *) alloca (length + 1);\n \n \t  /* Build the string with the characters in the literal.  Note\n \t     that Ada strings are 1-origin.  */\n@@ -3359,8 +3363,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t     this to not be converted to the array type.  */\n \t  TREE_TYPE (gnu_result) = gnu_result_type;\n \n-\t  if (length >= ALLOCA_THRESHOLD) /* free if heap-allocated */\n-             free (string);\n+\t  if (length >= ALLOCA_THRESHOLD)\n+\t    free (string);\n \t}\n       else\n \t{\n@@ -3395,7 +3399,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     /**************************************/\n-    /* Chapter 3: Declarations and Types: */\n+    /* Chapter 3: Declarations and Types  */\n     /**************************************/\n \n     case N_Subtype_Declaration:\n@@ -3502,7 +3506,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     /*************************************/\n-    /* Chapter 4: Names and Expressions: */\n+    /* Chapter 4: Names and Expressions  */\n     /*************************************/\n \n     case N_Explicit_Dereference:\n@@ -3625,7 +3629,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t\t   gnu_base_max_expr));\n \n \t    /* Build a slice index check that returns the low bound,\n-               assuming the slice is not empty.  */\n+\t       assuming the slice is not empty.  */\n \t    gnu_expr = emit_check\n \t      (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t\t\tgnu_expr_l, gnu_expr_h),\n@@ -3675,21 +3679,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \tgnu_prefix = maybe_implicit_deref (gnu_prefix);\n \n \t/* For discriminant references in tagged types always substitute the\n-\t   corresponding discriminant as the actual selected component. */\n-\n+\t   corresponding discriminant as the actual selected component.  */\n \tif (Is_Tagged_Type (gnat_pref_type))\n \t  while (Present (Corresponding_Discriminant (gnat_field)))\n \t    gnat_field = Corresponding_Discriminant (gnat_field);\n \n \t/* For discriminant references of untagged types always substitute the\n-\t   corresponding stored discriminant. */\n-\n+\t   corresponding stored discriminant.  */\n \telse if (Present (Corresponding_Discriminant (gnat_field)))\n \t  gnat_field = Original_Record_Component (gnat_field);\n \n \t/* Handle extracting the real or imaginary part of a complex.\n \t   The real part is the first field and the imaginary the last.  */\n-\n \tif (TREE_CODE (TREE_TYPE (gnu_prefix)) == COMPLEX_TYPE)\n \t  gnu_result = build_unary_op (Present (Next_Entity (gnat_field))\n \t\t\t\t       ? REALPART_EXPR : IMAGPART_EXPR,\n@@ -3698,9 +3699,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  {\n \t    gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \n-\t    /* If there are discriminants, the prefix might be\n-               evaluated more than once, which is a problem if it has\n-               side-effects. */\n+\t    /* If there are discriminants, the prefix might be evaluated more\n+\t       than once, which is a problem if it has side-effects.  */\n \t    if (Has_Discriminants (Is_Access_Type (Etype (Prefix (gnat_node)))\n \t\t\t\t   ? Designated_Type (Etype\n \t\t\t\t\t\t      (Prefix (gnat_node)))\n@@ -3720,8 +3720,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Attribute_Reference:\n       {\n-        /* The attribute designator (like an enumeration value). */\n-        int attribute = Get_Attribute_Id (Attribute_Name (gnat_node));\n+\t/* The attribute designator (like an enumeration value).  */\n+\tint attribute = Get_Attribute_Id (Attribute_Name (gnat_node));\n \n \t/* The Elab_Spec and Elab_Body attributes are special in that\n \t   Prefix is a unit, not an object with a GCC equivalent.  Similarly\n@@ -3863,7 +3863,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_high = gnat_to_gnu (High_Bound (gnat_range));\n \t  }\n \telse if (Nkind (gnat_range) == N_Identifier\n-              || Nkind (gnat_range) == N_Expanded_Name)\n+\t\t || Nkind (gnat_range) == N_Expanded_Name)\n \t  {\n \t    tree gnu_range_type = get_unpadded_type (Entity (gnat_range));\n \n@@ -3961,7 +3961,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* If the result type is a private type, its full view may be a\n \t   numeric subtype. The representation we need is that of its base\n \t   type, given that it is the result of an arithmetic operation.  */\n-        else if (Is_Private_Type (Etype (gnat_node)))\n+\telse if (Is_Private_Type (Etype (gnat_node)))\n \t  gnu_type = gnu_result_type\n \t    = get_unpadded_type (Base_Type (Full_View (Etype (gnat_node))));\n \n@@ -4023,12 +4023,12 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   do overflow checking, do it here.  The goal is to push\n \t   the expansions further into the back end over time.  */\n \tif (Do_Overflow_Check (gnat_node) && Backend_Overflow_Checks_On_Target\n-            && (Nkind (gnat_node) == N_Op_Add\n+\t    && (Nkind (gnat_node) == N_Op_Add\n \t\t|| Nkind (gnat_node) == N_Op_Subtract\n \t\t|| Nkind (gnat_node) == N_Op_Multiply)\n \t    && !TYPE_UNSIGNED (gnu_type)\n \t    && !FLOAT_TYPE_P (gnu_type))\n-          gnu_result\n+\t  gnu_result\n \t    = build_binary_op_trapv (code, gnu_type, gnu_lhs, gnu_rhs);\n \telse\n \t  gnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n@@ -4053,10 +4053,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Conditional_Expression:\n       {\n-        tree gnu_cond = gnat_to_gnu (First (Expressions (gnat_node)));\n-        tree gnu_true = gnat_to_gnu (Next (First (Expressions (gnat_node))));\n-        tree gnu_false\n-          = gnat_to_gnu (Next (Next (First (Expressions (gnat_node)))));\n+\ttree gnu_cond = gnat_to_gnu (First (Expressions (gnat_node)));\n+\ttree gnu_true = gnat_to_gnu (Next (First (Expressions (gnat_node))));\n+\ttree gnu_false\n+\t  = gnat_to_gnu (Next (Next (First (Expressions (gnat_node)))));\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \tgnu_result = build_cond_expr (gnu_result_type,\n@@ -4091,10 +4091,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_expr = gnat_to_gnu (Right_Opnd (gnat_node));\n \n       if (Ekind (Etype (gnat_node)) != E_Private_Type)\n-         gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n       else\n-         gnu_result_type = get_unpadded_type (Base_Type\n-\t\t\t\t\t      (Full_View (Etype (gnat_node))));\n+\tgnu_result_type = get_unpadded_type (Base_Type\n+\t\t\t\t\t     (Full_View (Etype (gnat_node))));\n \n       if (Do_Overflow_Check (gnat_node)\n \t  && !TYPE_UNSIGNED (gnu_result_type)\n@@ -4130,8 +4130,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_init = gnat_to_gnu (Expression (gnat_temp));\n \n \t    gnu_init = maybe_unconstrained_array (gnu_init);\n-            if (Do_Range_Check (Expression (gnat_temp)))\n-              gnu_init = emit_range_check (gnu_init, gnat_desig_type);\n+\t    if (Do_Range_Check (Expression (gnat_temp)))\n+\t      gnu_init = emit_range_check (gnu_init, gnat_desig_type);\n \n \t    if (Is_Elementary_Type (gnat_desig_type)\n \t\t|| Is_Constrained (gnat_desig_type))\n@@ -4159,9 +4159,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       }\n       break;\n \n-    /***************************/\n-    /* Chapter 5: Statements:  */\n-    /***************************/\n+    /**************************/\n+    /* Chapter 5: Statements  */\n+    /**************************/\n \n     case N_Label:\n       gnu_result = build1 (LABEL_EXPR, void_type_node,\n@@ -4226,7 +4226,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_If_Statement:\n       {\n-\ttree *gnu_else_ptr;\t/* Point to put next \"else if\" or \"else\". */\n+\ttree *gnu_else_ptr; /* Point to put next \"else if\" or \"else\".  */\n \n \t/* Make the outer COND_EXPR.  Avoid non-determinism.  */\n \tgnu_result = build3 (COND_EXPR, void_type_node,\n@@ -4340,7 +4340,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n \t\t&& Nkind (Expression (gnat_node)) == N_Function_Call)\n \t      {\n-\t        gnu_lhs\n+\t\tgnu_lhs\n \t\t  = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t    DECL_ARGUMENTS (current_function_decl));\n \t\tgnu_result = call_to_gnu (Expression (gnat_node),\n@@ -4352,7 +4352,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t\tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n \t\t  /* The original return type was unconstrained so dereference\n-\t\t     the TARGET pointer in the actual return value's type. */\n+\t\t     the TARGET pointer in the actual return value's type.  */\n \t\t  gnu_lhs\n \t\t    = build_unary_op (INDIRECT_REF, TREE_TYPE (gnu_ret_val),\n \t\t\t\t      DECL_ARGUMENTS (current_function_decl));\n@@ -4411,15 +4411,15 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t   gnat_to_gnu (Name (gnat_node)));\n       break;\n \n-    /****************************/\n-    /* Chapter 6: Subprograms:  */\n-    /****************************/\n+    /***************************/\n+    /* Chapter 6: Subprograms  */\n+    /***************************/\n \n     case N_Subprogram_Declaration:\n       /* Unless there is a freeze node, declare the subprogram.  We consider\n \t this a \"definition\" even though we're not generating code for\n \t the subprogram because we will be making the corresponding GCC\n-\t node here. */\n+\t node here.  */\n \n       if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n \tgnat_to_gnu_entity (Defining_Entity (Specification (gnat_node)),\n@@ -4458,9 +4458,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     case N_Defining_Program_Unit_Name:\n-      /* For a child unit identifier go up a level to get the\n-         specification.  We get this when we try to find the spec of\n-\t a child unit package that is the compilation unit being compiled. */\n+      /* For a child unit identifier go up a level to get the specification.\n+\t We get this when we try to find the spec of a child unit package\n+\t that is the compilation unit being compiled.  */\n       gnu_result = gnat_to_gnu (Parent (gnat_node));\n       break;\n \n@@ -4474,9 +4474,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = call_to_gnu (gnat_node, &gnu_result_type, NULL_TREE);\n       break;\n \n-    /*************************/\n-    /* Chapter 7: Packages:  */\n-    /*************************/\n+    /************************/\n+    /* Chapter 7: Packages  */\n+    /************************/\n \n     case N_Package_Declaration:\n       gnu_result = gnat_to_gnu (Specification (gnat_node));\n@@ -4492,7 +4492,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Package_Body:\n \n-      /* If this is the body of a generic package - do nothing */\n+      /* If this is the body of a generic package - do nothing.  */\n       if (Ekind (Corresponding_Spec (gnat_node)) == E_Generic_Package)\n \t{\n \t  gnu_result = alloc_stmt_list ();\n@@ -4508,19 +4508,19 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = end_stmt_group ();\n       break;\n \n-    /*********************************/\n-    /* Chapter 8: Visibility Rules:  */\n-    /*********************************/\n+    /********************************/\n+    /* Chapter 8: Visibility Rules  */\n+    /********************************/\n \n     case N_Use_Package_Clause:\n     case N_Use_Type_Clause:\n-      /* Nothing to do here - but these may appear in list of declarations */\n+      /* Nothing to do here - but these may appear in list of declarations.  */\n       gnu_result = alloc_stmt_list ();\n       break;\n \n-    /***********************/\n-    /* Chapter 9: Tasks:   */\n-    /***********************/\n+    /*********************/\n+    /* Chapter 9: Tasks  */\n+    /*********************/\n \n     case N_Protected_Type_Declaration:\n       gnu_result = alloc_stmt_list ();\n@@ -4531,9 +4531,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = alloc_stmt_list ();\n       break;\n \n-    /***********************************************************/\n-    /* Chapter 10: Program Structure and Compilation Issues:   */\n-    /***********************************************************/\n+    /*********************************************************/\n+    /* Chapter 10: Program Structure and Compilation Issues  */\n+    /*********************************************************/\n \n     case N_Compilation_Unit:\n \n@@ -4559,7 +4559,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       break;\n \n     /***************************/\n-    /* Chapter 11: Exceptions: */\n+    /* Chapter 11: Exceptions  */\n     /***************************/\n \n     case N_Handled_Sequence_Of_Statements:\n@@ -4615,9 +4615,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t= TREE_CHAIN (gnu_program_error_label_stack);\n       break;\n \n-    /*******************************/\n-    /* Chapter 12: Generic Units:  */\n-    /*******************************/\n+    /******************************/\n+    /* Chapter 12: Generic Units  */\n+    /******************************/\n \n     case N_Generic_Function_Renaming_Declaration:\n     case N_Generic_Package_Renaming_Declaration:\n@@ -4632,10 +4632,10 @@ gnat_to_gnu (Node_Id gnat_node)\n       gnu_result = alloc_stmt_list ();\n       break;\n \n-    /***************************************************/\n-    /* Chapter 13: Representation Clauses and\t       */\n-    /*             Implementation-Dependent Features:  */\n-    /***************************************************/\n+    /**************************************************/\n+    /* Chapter 13: Representation Clauses and         */\n+    /*             Implementation-Dependent Features  */\n+    /**************************************************/\n \n     case N_Attribute_Definition_Clause:\n       gnu_result = alloc_stmt_list ();\n@@ -4705,7 +4705,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t   build_string (strlen (clobber) + 1, clobber),\n \t\t\t   gnu_clobbers);\n \n-          /* Then perform some standard checking and processing on the\n+\t  /* Then perform some standard checking and processing on the\n \t     operands.  In particular, mark them addressable if needed.  */\n \t  gnu_outputs = nreverse (gnu_outputs);\n \t  noutputs = list_length (gnu_outputs);\n@@ -4770,9 +4770,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       break;\n \n-    /***************************************************/\n-    /* Added Nodes\t                               */\n-    /***************************************************/\n+    /****************/\n+    /* Added Nodes  */\n+    /****************/\n \n     case N_Freeze_Entity:\n       start_stmt_group ();\n@@ -4825,13 +4825,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  if (Present (Actual_Designated_Subtype (gnat_node)))\n \t    {\n \t      gnu_actual_obj_type\n-\t        = gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n+\t\t= gnat_to_gnu_type (Actual_Designated_Subtype (gnat_node));\n \n \t      if (TYPE_FAT_OR_THIN_POINTER_P (gnu_ptr_type))\n-\t        gnu_actual_obj_type\n-\t          = build_unc_object_type_from_ptr (gnu_ptr_type,\n-\t\t      gnu_actual_obj_type,\n-\t\t      get_identifier (\"DEALLOC\"));\n+\t\tgnu_actual_obj_type\n+\t\t  = build_unc_object_type_from_ptr (gnu_ptr_type,\n+\t\t\t\t\t\t    gnu_actual_obj_type,\n+\t\t\t\t\t\t    get_identifier (\"DEALLOC\"));\n \t    }\n \t  else\n \t    gnu_actual_obj_type = gnu_obj_type;\n@@ -4949,7 +4949,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t    if ((TYPE_DUMMY_P (gnu_target_desig_type)\n \t\t || get_alias_set (gnu_target_desig_type) != 0)\n-\t        && (!POINTER_TYPE_P (gnu_source_type)\n+\t\t&& (!POINTER_TYPE_P (gnu_source_type)\n \t\t    || (TYPE_DUMMY_P (gnu_source_desig_type)\n \t\t\t!= TYPE_DUMMY_P (gnu_target_desig_type))\n \t\t    || (TYPE_DUMMY_P (gnu_source_desig_type)\n@@ -5695,7 +5695,7 @@ elaborate_all_entities (Node_Id gnat_node)\n \t\t  && !IN (Ekind (gnat_entity), Named_Kind)\n \t\t  && !IN (Ekind (gnat_entity), Generic_Unit_Kind))\n \t\tgnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n-          }\n+\t  }\n \telse if (Ekind (Entity (Name (gnat_with_clause))) == E_Generic_Package)\n \t  {\n \t    Node_Id gnat_body\n@@ -5744,7 +5744,7 @@ process_freeze_entity (Node_Id gnat_node)\n     = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : 0;\n \n   /* If this entity has an Address representation clause, GNU_OLD is the\n-     address, so discard it here. */\n+     address, so discard it here.  */\n   if (Present (Address_Clause (gnat_entity)))\n     gnu_old = 0;\n \n@@ -5758,7 +5758,7 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example because of an inner call\n      in an instance body, or a previous compilation of a spec for inlining\n-     purposes. */\n+     purposes.  */\n   if (gnu_old\n       && ((TREE_CODE (gnu_old) == FUNCTION_DECL\n \t   && (Ekind (gnat_entity) == E_Function\n@@ -5790,7 +5790,7 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Reset the saved tree, if any, and elaborate the object or type for real.\n      If there is a full declaration, elaborate it and copy the type to\n      GNAT_ENTITY.  Likewise if this is the record subtype corresponding to\n-     a class wide type or subtype. */\n+     a class wide type or subtype.  */\n   if (gnu_old)\n     {\n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n@@ -5888,7 +5888,7 @@ process_inlined_subprograms (Node_Id gnat_node)\n \n static void\n process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n-               Node_Id gnat_end_list, bool pass1p, bool pass2p)\n+\t       Node_Id gnat_end_list, bool pass1p, bool pass2p)\n {\n   List_Id gnat_decl_array[2];\n   Node_Id gnat_decl;\n@@ -5926,7 +5926,7 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t     && Present (Freeze_Node (Corresponding_Spec (gnat_decl))))\n \t      record_code_position (gnat_decl);\n \n-            else if (Nkind (gnat_decl) == N_Package_Body_Stub\n+\t    else if (Nkind (gnat_decl) == N_Package_Body_Stub\n \t\t     && Present (Library_Unit (gnat_decl))\n \t\t     && Present (Freeze_Node\n \t\t\t\t (Corresponding_Spec\n@@ -5947,25 +5947,27 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, 1);\n \t\t  }\n \t      }\n-            /* For bodies and stubs that act as their own specs, the entity\n-               itself must be elaborated in the first pass, because it may\n-               be used in other declarations. */\n+\n+\t    /* For bodies and stubs that act as their own specs, the entity\n+\t       itself must be elaborated in the first pass, because it may\n+\t       be used in other declarations.  */\n \t    else if (Nkind (gnat_decl) == N_Subprogram_Body_Stub)\n \t      {\n-                  Node_Id gnat_subprog_id =\n-                     Defining_Entity (Specification (gnat_decl));\n+\t\tNode_Id gnat_subprog_id\n+\t\t  = Defining_Entity (Specification (gnat_decl));\n \n \t\t    if (Ekind (gnat_subprog_id) != E_Subprogram_Body\n-                        && Ekind (gnat_subprog_id) != E_Generic_Procedure\n+\t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Procedure\n \t\t\t&& Ekind (gnat_subprog_id) != E_Generic_Function)\n \t\t      gnat_to_gnu_entity (gnat_subprog_id, NULL_TREE, 1);\n-               }\n+\t      }\n \n \t    /* Concurrent stubs stand for the corresponding subprogram bodies,\n \t       which are deferred like other bodies.  */\n \t    else if (Nkind (gnat_decl) == N_Task_Body_Stub\n \t\t     || Nkind (gnat_decl) == N_Protected_Body_Stub)\n \t      ;\n+\n \t    else\n \t      add_stmt (gnat_to_gnu (gnat_decl));\n \t  }\n@@ -6149,8 +6151,8 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \n     case MULT_EXPR:\n       /* The check here is designed to be efficient if the rhs is constant,\n-         but it will work for any rhs by using integer division.\n-         Four different check expressions determine wether X * C overflows,\n+\t but it will work for any rhs by using integer division.\n+\t Four different check expressions determine wether X * C overflows,\n \t depending on C.\n \t   C ==  0  =>  false\n \t   C  >  0  =>  X > type_max / C || X < type_min / C\n@@ -6217,14 +6219,14 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n \t  < TYPE_PRECISION (get_base_type (gnu_range_type))))\n     return gnu_expr;\n \n-  /* Checked expressions must be evaluated only once. */\n+  /* Checked expressions must be evaluated only once.  */\n   gnu_expr = protect_multiple_eval (gnu_expr);\n \n   /* There's no good type to use here, so we might as well use\n      integer_type_node. Note that the form of the check is\n-        (not (expr >= lo)) or (not (expr <= hi))\n-      the reason for this slightly convoluted form is that NaNs\n-      are not considered to be in range in the float case. */\n+\t(not (expr >= lo)) or (not (expr <= hi))\n+     the reason for this slightly convoluted form is that NaNs\n+     are not considered to be in range in the float case.  */\n   return emit_check\n     (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t      invert_truthvalue\n@@ -6239,35 +6241,32 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n      gnu_expr, CE_Range_Check_Failed);\n }\n \f\n-/* Emit code for an index check. GNU_ARRAY_OBJECT is the array object\n-   which we are about to index, GNU_EXPR is the index expression to be\n-   checked, GNU_LOW and GNU_HIGH are the lower and upper bounds\n-   against which GNU_EXPR has to be checked. Note that for index\n-   checking we cannot use the emit_range_check function (although very\n-   similar code needs to be generated in both cases) since for index\n-   checking the array type against which we are checking the indices\n-   may be unconstrained and consequently we need to retrieve the\n-   actual index bounds from the array object itself\n-   (GNU_ARRAY_OBJECT). The place where we need to do that is in\n-   subprograms having unconstrained array formal parameters */\n+/* Emit code for an index check.  GNU_ARRAY_OBJECT is the array object which\n+   we are about to index, GNU_EXPR is the index expression to be checked,\n+   GNU_LOW and GNU_HIGH are the lower and upper bounds against which GNU_EXPR\n+   has to be checked.  Note that for index checking we cannot simply use the\n+   emit_range_check function (although very similar code needs to be generated\n+   in both cases) since for index checking the array type against which we are\n+   checking the indices may be unconstrained and consequently we need to get\n+   the actual index bounds from the array object itself (GNU_ARRAY_OBJECT).\n+   The place where we need to do that is in subprograms having unconstrained\n+   array formal parameters.  */\n \n static tree\n-emit_index_check (tree gnu_array_object,\n-                  tree gnu_expr,\n-                  tree gnu_low,\n-                  tree gnu_high)\n+emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n+\t\t  tree gnu_high)\n {\n   tree gnu_expr_check;\n \n-  /* Checked expressions must be evaluated only once. */\n+  /* Checked expressions must be evaluated only once.  */\n   gnu_expr = protect_multiple_eval (gnu_expr);\n \n   /* Must do this computation in the base type in case the expression's\n      type is an unsigned subtypes.  */\n   gnu_expr_check = convert (get_base_type (TREE_TYPE (gnu_expr)), gnu_expr);\n \n   /* If GNU_LOW or GNU_HIGH are a PLACEHOLDER_EXPR, qualify them by\n-     the object we are handling. */\n+     the object we are handling.  */\n   gnu_low = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_low, gnu_array_object);\n   gnu_high = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_high, gnu_array_object);\n \n@@ -6311,11 +6310,10 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n   return save_expr (gnu_result);\n }\n \f\n-/* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing\n-   overflow checks if OVERFLOW_P is nonzero and range checks if\n-   RANGE_P is nonzero.  GNAT_TYPE is known to be an integral type.\n-   If TRUNCATE_P is nonzero, do a float to integer conversion with\n-   truncation; otherwise round.  */\n+/* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing overflow\n+   checks if OVERFLOW_P is true and range checks if RANGE_P is true.\n+   GNAT_TYPE is known to be an integral type.  If TRUNCATE_P true, do a\n+   float to integer conversion with truncation; otherwise round.  */\n \n static tree\n convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n@@ -6410,8 +6408,8 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t\t\t\t\t\t\tgnu_out_ub))));\n \n       if (!integer_zerop (gnu_cond))\n-\tgnu_result = emit_check (gnu_cond, gnu_input,\n-\t                         CE_Overflow_Check_Failed);\n+\tgnu_result\n+\t  = emit_check (gnu_cond, gnu_input, CE_Overflow_Check_Failed);\n     }\n \n   /* Now convert to the result base type.  If this is a non-truncating\n@@ -6425,51 +6423,49 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       const struct real_format *fmt;\n \n       /* The following calculations depend on proper rounding to even\n-         of each arithmetic operation. In order to prevent excess\n-         precision from spoiling this property, use the widest hardware\n-         floating-point type if FP_ARITH_MAY_WIDEN is true.  */\n+\t of each arithmetic operation. In order to prevent excess\n+\t precision from spoiling this property, use the widest hardware\n+\t floating-point type if FP_ARITH_MAY_WIDEN is true.  */\n+      calc_type\n+\t= FP_ARITH_MAY_WIDEN ? longest_float_type_node : gnu_in_basetype;\n \n-      calc_type = (FP_ARITH_MAY_WIDEN ? longest_float_type_node\n-                                      : gnu_in_basetype);\n-\n-      /* FIXME: Should not have padding in the first place */\n+      /* FIXME: Should not have padding in the first place.  */\n       if (TREE_CODE (calc_type) == RECORD_TYPE\n-              && TYPE_IS_PADDING_P (calc_type))\n-        calc_type = TREE_TYPE (TYPE_FIELDS (calc_type));\n+\t  && TYPE_IS_PADDING_P (calc_type))\n+\tcalc_type = TREE_TYPE (TYPE_FIELDS (calc_type));\n \n-      /* Compute the exact value calc_type'Pred (0.5) at compile time. */\n+      /* Compute the exact value calc_type'Pred (0.5) at compile time.  */\n       fmt = REAL_MODE_FORMAT (TYPE_MODE (calc_type));\n       real_2expN (&half_minus_pred_half, -(fmt->p) - 1, TYPE_MODE (calc_type));\n       REAL_ARITHMETIC (pred_half, MINUS_EXPR, dconsthalf,\n-                       half_minus_pred_half);\n+\t\t       half_minus_pred_half);\n       gnu_pred_half = build_real (calc_type, pred_half);\n \n       /* If the input is strictly negative, subtract this value\n-         and otherwise add it from the input. For 0.5, the result\n-         is exactly between 1.0 and the machine number preceding 1.0\n-         (for calc_type). Since the last bit of 1.0 is even, this 0.5\n-         will round to 1.0, while all other number with an absolute\n-         value less than 0.5 round to 0.0. For larger numbers exactly\n-         halfway between integers, rounding will always be correct as\n-         the true mathematical result will be closer to the higher\n-         integer compared to the lower one. So, this constant works\n-         for all floating-point numbers.\n-\n-         The reason to use the same constant with subtract/add instead\n-         of a positive and negative constant is to allow the comparison\n-         to be scheduled in parallel with retrieval of the constant and\n-         conversion of the input to the calc_type (if necessary).\n-      */\n+\t and otherwise add it from the input. For 0.5, the result\n+\t is exactly between 1.0 and the machine number preceding 1.0\n+\t (for calc_type). Since the last bit of 1.0 is even, this 0.5\n+\t will round to 1.0, while all other number with an absolute\n+\t value less than 0.5 round to 0.0. For larger numbers exactly\n+\t halfway between integers, rounding will always be correct as\n+\t the true mathematical result will be closer to the higher\n+\t integer compared to the lower one. So, this constant works\n+\t for all floating-point numbers.\n+\n+\t The reason to use the same constant with subtract/add instead\n+\t of a positive and negative constant is to allow the comparison\n+\t to be scheduled in parallel with retrieval of the constant and\n+\t conversion of the input to the calc_type (if necessary).  */\n \n       gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n       gnu_saved_result = save_expr (gnu_result);\n       gnu_conv = convert (calc_type, gnu_saved_result);\n       gnu_comp = build2 (GE_EXPR, integer_type_node,\n-\t                gnu_saved_result, gnu_zero);\n+\t\t\t gnu_saved_result, gnu_zero);\n       gnu_add_pred_half\n-        = build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+\t= build2 (PLUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n       gnu_subtract_pred_half\n-        = build2 (MINUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n+\t= build2 (MINUS_EXPR, calc_type, gnu_conv, gnu_pred_half);\n       gnu_result = build3 (COND_EXPR, calc_type, gnu_comp,\n \t\t\t   gnu_add_pred_half, gnu_subtract_pred_half);\n     }\n@@ -6622,7 +6618,7 @@ addressable_p (tree gnu_expr, tree gnu_type)\n \t\t   check the alignment of the containing record, as it is\n \t\t   guaranteed to be not smaller than that of its most\n \t\t   aligned field that is not a bit-field.  */\n-\t        && (!STRICT_ALIGNMENT\n+\t\t&& (!STRICT_ALIGNMENT\n \t\t    || DECL_ALIGN (TREE_OPERAND (gnu_expr, 1))\n \t\t       >= TYPE_ALIGN (TREE_TYPE (gnu_expr))))\n \t       /* The field of a padding record is always addressable.  */\n@@ -6688,7 +6684,7 @@ process_type (Entity_Id gnat_entity)\n       elaborate_entity (gnat_entity);\n \n       if (!gnu_old)\n-        {\n+\t{\n \t  tree gnu_decl = create_type_decl (get_entity_name (gnat_entity),\n \t\t\t\t\t    make_dummy_type (gnat_entity),\n \t\t\t\t\t    NULL, false, false, gnat_entity);\n@@ -6726,9 +6722,7 @@ process_type (Entity_Id gnat_entity)\n \n   /* If this is a record type corresponding to a task or protected type\n      that is a completion of an incomplete type, perform a similar update\n-     on the type.  */\n-  /* ??? Including protected types here is a guess. */\n-\n+     on the type.  ??? Including protected types here is a guess.  */\n   if (IN (Ekind (gnat_entity), Record_Kind)\n       && Is_Concurrent_Record_Type (gnat_entity)\n       && present_gnu_tree (Corresponding_Concurrent_Type (gnat_entity)))\n@@ -6770,7 +6764,7 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n       tree gnu_expr = gnat_to_gnu (Expression (gnat_assoc));\n \n       /* The expander is supposed to put a single component selector name\n-\t in every record component association */\n+\t in every record component association.  */\n       gcc_assert (No (Next (gnat_field)));\n \n       /* Ignore fields that have Corresponding_Discriminants since we'll\n@@ -6810,15 +6804,15 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n   return gnu_result;\n }\n \n-/* Builds a possibly nested constructor for array aggregates. GNAT_EXPR\n-   is the first element of an array aggregate. It may itself be an\n-   aggregate (an array or record aggregate). GNU_ARRAY_TYPE is the gnu type\n-   corresponding to the array aggregate. GNAT_COMPONENT_TYPE is the type\n-   of the array component. It is needed for range checking. */\n+/* Build a possibly nested constructor for array aggregates.  GNAT_EXPR is\n+   the first element of an array aggregate.  It may itself be an aggregate.\n+   GNU_ARRAY_TYPE is the GCC type corresponding to the array aggregate.\n+   GNAT_COMPONENT_TYPE is the type of the array component; it is needed\n+   for range checking.  */\n \n static tree\n pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n-                    Entity_Id gnat_component_type)\n+\t\t    Entity_Id gnat_component_type)\n {\n   tree gnu_expr_list = NULL_TREE;\n   tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n@@ -6841,7 +6835,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t  gnu_expr = gnat_to_gnu (gnat_expr);\n \n \t  /* before assigning the element to the array make sure it is\n-\t     in range */\n+\t     in range.  */\n \t  if (Do_Range_Check (gnat_expr))\n \t    gnu_expr = emit_range_check (gnu_expr, gnat_component_type);\n \t}\n@@ -7066,7 +7060,7 @@ maybe_stabilize_reference (tree ref, bool force, bool *success)\n     case ERROR_MARK:\n       ref = error_mark_node;\n \n-      /* ...  Fallthru to failure ... */\n+      /* ...  fall through to failure ... */\n \n       /* If arg isn't a kind of lvalue we recognize, make no change.\n \t Caller should recognize the error for an invalid lvalue.  */\n@@ -7235,9 +7229,7 @@ static const char *\n extract_encoding (const char *name)\n {\n   char *encoding = GGC_NEWVEC (char, strlen (name));\n-  \n   get_encoding (name, encoding);\n-  \n   return encoding;\n }\n \n@@ -7247,9 +7239,7 @@ static const char *\n decode_name (const char *name)\n {\n   char *decoded = GGC_NEWVEC (char, strlen (name) * 2 + 60);\n-  \n   __gnat_decode (name, decoded, 0);\n-  \n   return decoded;\n }\n \f\n@@ -7356,11 +7346,8 @@ post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent, tree t)\n    integer to write in the message.  */\n \n void\n-post_error_ne_tree_2 (const char *msg,\n-                      Node_Id node,\n-                      Entity_Id ent,\n-                      tree t,\n-                      int num)\n+post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent, tree t,\n+\t\t      int num)\n {\n   Error_Msg_Uint_2 = UI_From_Int (num);\n   post_error_ne_tree (msg, node, ent, t);"}, {"sha": "bbf51969e844cc5a3e6160ccff2f6954dcefdbd5", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e17ef870e0889e68c707702cb9bb528aa960aa5/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=1e17ef870e0889e68c707702cb9bb528aa960aa5", "patch": "@@ -210,7 +210,7 @@ init_gnat_to_gnu (void)\n \n /* GNAT_ENTITY is a GNAT tree node for an entity.   GNU_DECL is the GCC tree\n    which is to be associated with GNAT_ENTITY. Such GCC tree node is always\n-   a ..._DECL node.  If NO_CHECK is nonzero, the latter check is suppressed.\n+   a ..._DECL node.  If NO_CHECK is true, the latter check is suppressed.\n \n    If GNU_DECL is zero, a previous association is to be reset.  */\n \n@@ -1252,13 +1252,11 @@ get_parallel_type (tree type)\n }\n \n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n-   with FIRST_BIT and SIZE that describe a field.  SPECIAL is nonzero\n-   if this represents a QUAL_UNION_TYPE in which case we must look for\n-   COND_EXPRs and replace a value of zero with the old size.  If HAS_REP\n-   is nonzero, we must take the MAX of the end position of this field\n-   with LAST_SIZE.  In all other cases, we use FIRST_BIT plus SIZE.\n-\n-   We return an expression for the size.  */\n+   with FIRST_BIT and SIZE that describe a field.  SPECIAL is true if this\n+   represents a QUAL_UNION_TYPE in which case we must look for COND_EXPRs and\n+   replace a value of zero with the old size.  If HAS_REP is true, we take the\n+   MAX of the end position of this field with LAST_SIZE.  In all other cases,\n+   we use FIRST_BIT plus SIZE.  Return an expression for the size.  */\n \n static tree\n merge_sizes (tree last_size, tree first_bit, tree size, bool special,\n@@ -1499,7 +1497,7 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n    definition to be made visible outside of the current compilation unit, for\n    instance variable definitions in a package specification.\n \n-   EXTERN_FLAG is nonzero when processing an external variable declaration (as\n+   EXTERN_FLAG is true when processing an external variable declaration (as\n    opposed to a definition: no storage is to be allocated for the variable).\n \n    STATIC_FLAG is only relevant when not at top level.  In that case"}]}