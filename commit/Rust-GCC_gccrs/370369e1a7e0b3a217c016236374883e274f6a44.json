{"sha": "370369e1a7e0b3a217c016236374883e274f6a44", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwMzY5ZTFhN2UwYjNhMjE3YzAxNjIzNjM3NDg4M2UyNzRmNmE0NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-06-27T23:06:33Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-06-27T23:06:33Z"}, "message": "basic-block.h (basic_block_def): Kill rbi.\n\n\n\t* basic-block.h (basic_block_def): Kill rbi.\n\t(reorder_block_def): Kill; Remove next field (replaced by aux);\n\tmove other fields to ...\n\t(rtl_bb_info): ... here.\n\t* bb-reorder.c (find_traces, rotate_loop, find_traces_1_round,\n\tcopy_bb, connect_traces, add_labels_and_missing_jumps\n\tfix_up_fall_thru_edges, fix_crossing_conditional_branches,\n\tduplicate_computed_gotos, partition_hot_cold_basic-blocks):\n\tUpdate to new fields.\n\t* cfg.c (initialize_bb_rbi): Kill.\n\t* cfglayout.c (record_effective_endpoints, fixup_reorder_chain,\n\tfixup_fallthru_exit_predecessor, cfg_layout_duplicate_bb): Update.\n\t* cfgrtl.c (cfg_layout_create_basic_block): Do not initialize rbi.\n\t(try_redirect_by_replacing_jump): Update rbi references.\n\t(cfg_layout_split_block): Likewise.\n\t(cfg_layout_delete_block): Likewise.\n\t(cfg_layout_merge_blocks): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\t* passes.c (rest_of_handle_sms): Likewise.\n\t* tracer.c (seen, tail_duplicate, layout_superblocks): Likewise.\n\nFrom-SVN: r101359", "tree": {"sha": "8971e4e755934027002c5bc8895d3ab1088c2e5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8971e4e755934027002c5bc8895d3ab1088c2e5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/370369e1a7e0b3a217c016236374883e274f6a44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370369e1a7e0b3a217c016236374883e274f6a44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/370369e1a7e0b3a217c016236374883e274f6a44", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370369e1a7e0b3a217c016236374883e274f6a44/comments", "author": null, "committer": null, "parents": [{"sha": "4ebe7d9317b79fcd68fcec3e5cbdb502abe8152d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ebe7d9317b79fcd68fcec3e5cbdb502abe8152d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ebe7d9317b79fcd68fcec3e5cbdb502abe8152d"}], "stats": {"total": 321, "additions": 157, "deletions": 164}, "files": [{"sha": "748d3e925ce54f96241a328cf2902fcfdd6f1841", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -1,3 +1,26 @@\n+2005-06-28  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (basic_block_def): Kill rbi.\n+\t(reorder_block_def): Kill; Remove next field (replaced by aux);\n+\tmove other fields to ...\n+\t(rtl_bb_info): ... here.\n+\t* bb-reorder.c (find_traces, rotate_loop, find_traces_1_round,\n+\tcopy_bb, connect_traces, add_labels_and_missing_jumps\n+\tfix_up_fall_thru_edges, fix_crossing_conditional_branches,\n+\tduplicate_computed_gotos, partition_hot_cold_basic-blocks):\n+\tUpdate to new fields.\n+\t* cfg.c (initialize_bb_rbi): Kill.\n+\t* cfglayout.c (record_effective_endpoints, fixup_reorder_chain,\n+\tfixup_fallthru_exit_predecessor, cfg_layout_duplicate_bb): Update.\n+\t* cfgrtl.c (cfg_layout_create_basic_block): Do not initialize rbi.\n+\t(try_redirect_by_replacing_jump): Update rbi references.\n+\t(cfg_layout_split_block): Likewise.\n+\t(cfg_layout_delete_block): Likewise.\n+\t(cfg_layout_merge_blocks): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\t* passes.c (rest_of_handle_sms): Likewise.\n+\t* tracer.c (seen, tail_duplicate, layout_superblocks): Likewise.\n+\n 2005-06-27  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_file_start): Note PPC405 erratum"}, {"sha": "46bd83d4307e861edc29b19ecb887456eb841390", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -233,9 +233,6 @@ struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")\n   struct basic_block_def *prev_bb;\n   struct basic_block_def *next_bb;\n \n-  /* The data used by basic block copying and reordering functions.  */\n-  struct reorder_block_def * rbi;\n-\n   union basic_block_il_dependent {\n       struct rtl_bb_info * GTY ((tag (\"1\"))) rtl;\n     } GTY ((desc (\"((%1.flags & BB_RTL) != 0)\"))) il;\n@@ -273,25 +270,17 @@ struct rtl_bb_info GTY(())\n \n   /* The registers that are live on exit from this block.  */\n   bitmap GTY ((skip (\"\"))) global_live_at_end;\n-};\n-\n-typedef struct basic_block_def *basic_block;\n-\n-/* Structure to hold information about the blocks during reordering and\n-   copying.  Needs to be put on a diet.  */\n \n-struct reorder_block_def GTY(())\n-{\n+  /* In CFGlayout mode points to insn notes/jumptables to be placed just before\n+     and after the block.   */\n   rtx header;\n   rtx footer;\n \n-  basic_block next;\n-\n   /* This field is used by the bb-reorder and tracer passes.  */\n   int visited;\n };\n \n-typedef struct reorder_block_def *reorder_block_def;\n+typedef struct basic_block_def *basic_block;\n \n #define BB_FREQ_MAX 10000\n \n@@ -940,9 +929,6 @@ extern void reorder_basic_blocks (unsigned int);\n extern void duplicate_computed_gotos (void);\n extern void partition_hot_cold_basic_blocks (void);\n \n-/* In cfg.c */\n-extern void initialize_bb_rbi (basic_block bb);\n-\n /* In dominance.c */\n \n enum cdi_direction"}, {"sha": "e0865ac61dcb4ed7cd6aa652fc2ae77ec8949935", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -272,7 +272,7 @@ find_traces (int *n_traces, struct trace *traces)\n \t  basic_block bb;\n \t  fprintf (dump_file, \"Trace %d (round %d):  \", i + 1,\n \t\t   traces[i].round + 1);\n-\t  for (bb = traces[i].first; bb != traces[i].last; bb = bb->rbi->next)\n+\t  for (bb = traces[i].first; bb != traces[i].last; bb = bb->aux)\n \t    fprintf (dump_file, \"%d [%d] \", bb->index, bb->frequency);\n \t  fprintf (dump_file, \"%d [%d]\\n\", bb->index, bb->frequency);\n \t}\n@@ -306,14 +306,14 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n-\t    && e->dest->rbi->visited != trace_n\n+\t    && e->dest->il.rtl->visited != trace_n\n \t    && (e->flags & EDGE_CAN_FALLTHRU)\n \t    && !(e->flags & EDGE_COMPLEX))\n \t{\n \t  if (is_preferred)\n \t    {\n \t      /* The best edge is preferred.  */\n-\t      if (!e->dest->rbi->visited\n+\t      if (!e->dest->il.rtl->visited\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is also preferred.  */\n@@ -329,7 +329,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t    }\n \t  else\n \t    {\n-\t      if (!e->dest->rbi->visited\n+\t      if (!e->dest->il.rtl->visited\n \t\t  || bbd[e->dest->index].start_of_trace >= 0)\n \t\t{\n \t\t  /* The current edge E is preferred.  */\n@@ -352,7 +352,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t\t}\n \t    }\n \t}\n-      bb = bb->rbi->next;\n+      bb = bb->aux;\n     }\n   while (bb != back_edge->dest);\n \n@@ -362,17 +362,17 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t the trace.  */\n       if (back_edge->dest == trace->first)\n \t{\n-\t  trace->first = best_bb->rbi->next;\n+\t  trace->first = best_bb->aux;\n \t}\n       else\n \t{\n \t  basic_block prev_bb;\n \n \t  for (prev_bb = trace->first;\n-\t       prev_bb->rbi->next != back_edge->dest;\n-\t       prev_bb = prev_bb->rbi->next)\n+\t       prev_bb->aux != back_edge->dest;\n+\t       prev_bb = prev_bb->aux)\n \t    ;\n-\t  prev_bb->rbi->next = best_bb->rbi->next;\n+\t  prev_bb->aux = best_bb->aux;\n \n \t  /* Try to get rid of uncond jump to cond jump.  */\n \t  if (single_succ_p (prev_bb))\n@@ -393,7 +393,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n       /* We have not found suitable loop tail so do no rotation.  */\n       best_bb = back_edge->src;\n     }\n-  best_bb->rbi->next = NULL;\n+  best_bb->aux = NULL;\n   return best_bb;\n }\n \n@@ -402,7 +402,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n static void\n mark_bb_visited (basic_block bb, int trace)\n {\n-  bb->rbi->visited = trace;\n+  bb->il.rtl->visited = trace;\n   if (bbd[bb->index].heap)\n     {\n       fibheap_delete_node (bbd[bb->index].heap, bbd[bb->index].node);\n@@ -496,8 +496,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t      if (e->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n-\t      if (e->dest->rbi->visited\n-\t\t  && e->dest->rbi->visited != *n_traces)\n+\t      if (e->dest->il.rtl->visited\n+\t\t  && e->dest->il.rtl->visited != *n_traces)\n \t\tcontinue;\n \n \t      if (BB_PARTITION (e->dest) != BB_PARTITION (bb))\n@@ -550,7 +550,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t    {\n \t      if (e == best_edge\n \t\t  || e->dest == EXIT_BLOCK_PTR\n-\t\t  || e->dest->rbi->visited)\n+\t\t  || e->dest->il.rtl->visited)\n \t\tcontinue;\n \n \t      key = bb_to_key (e->dest);\n@@ -611,7 +611,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \n \t  if (best_edge) /* Suitable successor was found.  */\n \t    {\n-\t      if (best_edge->dest->rbi->visited == *n_traces)\n+\t      if (best_edge->dest->il.rtl->visited == *n_traces)\n \t\t{\n \t\t  /* We do nothing with one basic block loops.  */\n \t\t  if (best_edge->dest != bb)\n@@ -631,7 +631,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t\t\t   \"Rotating loop %d - %d\\n\",\n \t\t\t\t\t   best_edge->dest->index, bb->index);\n \t\t\t\t}\n-\t\t\t      bb->rbi->next = best_edge->dest;\n+\t\t\t      bb->aux = best_edge->dest;\n \t\t\t      bbd[best_edge->dest->index].in_trace = \n \t\t\t\t                             (*n_traces) - 1;\n \t\t\t      bb = rotate_loop (best_edge, trace, *n_traces);\n@@ -681,7 +681,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t    if (e != best_edge\n \t\t\t&& (e->flags & EDGE_CAN_FALLTHRU)\n \t\t\t&& !(e->flags & EDGE_COMPLEX)\n-\t\t\t&& !e->dest->rbi->visited\n+\t\t\t&& !e->dest->il.rtl->visited\n \t\t\t&& single_pred_p (e->dest)\n \t\t\t&& !(e->flags & EDGE_CROSSING)\n \t\t\t&& single_succ_p (e->dest)\n@@ -698,7 +698,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\tbreak;\n \t\t      }\n \n-\t\t  bb->rbi->next = best_edge->dest;\n+\t\t  bb->aux = best_edge->dest;\n \t\t  bbd[best_edge->dest->index].in_trace = (*n_traces) - 1;\n \t\t  bb = best_edge->dest;\n \t\t}\n@@ -715,7 +715,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n \t  if (e->dest == EXIT_BLOCK_PTR\n-\t      || e->dest->rbi->visited)\n+\t      || e->dest->il.rtl->visited)\n \t    continue;\n \n \t  if (bbd[e->dest->index].heap)\n@@ -757,15 +757,15 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n   BB_COPY_PARTITION (new_bb, old_bb);\n \n   gcc_assert (e->dest == new_bb);\n-  gcc_assert (!e->dest->rbi->visited);\n+  gcc_assert (!e->dest->il.rtl->visited);\n \n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Duplicated bb %d (created bb %d)\\n\",\n \t     old_bb->index, new_bb->index);\n-  new_bb->rbi->visited = trace;\n-  new_bb->rbi->next = bb->rbi->next;\n-  bb->rbi->next = new_bb;\n+  new_bb->il.rtl->visited = trace;\n+  new_bb->aux = bb->aux;\n+  bb->aux = new_bb;\n \n   if (new_bb->index >= array_size || last_basic_block > array_size)\n     {\n@@ -973,7 +973,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t    }\n \t  if (best)\n \t    {\n-\t      best->src->rbi->next = best->dest;\n+\t      best->src->aux = best->dest;\n \t      t2 = bbd[best->src->index].end_of_trace;\n \t      connected[t2] = true;\n \n@@ -988,7 +988,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t}\n \n       if (last_trace >= 0)\n-\ttraces[last_trace].last->rbi->next = traces[t2].first;\n+\ttraces[last_trace].last->aux = traces[t2].first;\n       last_trace = t;\n \n       /* Find the successor traces.  */\n@@ -1026,7 +1026,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t\t   best->src->index, best->dest->index);\n \t\t}\n \t      t = bbd[best->dest->index].start_of_trace;\n-\t      traces[last_trace].last->rbi->next = traces[t].first;\n+\t      traces[last_trace].last->aux = traces[t].first;\n \t      connected[t] = true;\n \t      last_trace = t;\n \t    }\n@@ -1119,7 +1119,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t  if (next_bb && next_bb != EXIT_BLOCK_PTR)\n \t\t    {\n \t\t      t = bbd[next_bb->index].start_of_trace;\n-\t\t      traces[last_trace].last->rbi->next = traces[t].first;\n+\t\t      traces[last_trace].last->aux = traces[t].first;\n \t\t      connected[t] = true;\n \t\t      last_trace = t;\n \t\t    }\n@@ -1137,7 +1137,7 @@ connect_traces (int n_traces, struct trace *traces)\n       basic_block bb;\n \n       fprintf (dump_file, \"Final order:\\n\");\n-      for (bb = traces[0].first; bb; bb = bb->rbi->next)\n+      for (bb = traces[0].first; bb; bb = bb->aux)\n \tfprintf (dump_file, \"%d \", bb->index);\n       fprintf (dump_file, \"\\n\");\n       fflush (dump_file);\n@@ -1305,7 +1305,7 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n \t\t      barrier = emit_barrier_after (new_jump);\n \t\t      JUMP_LABEL (new_jump) = label;\n \t\t      LABEL_NUSES (label) += 1;\n-\t\t      src->rbi->footer = unlink_insn_chain (barrier, barrier);\n+\t\t      src->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n \t\t      /* Mark edge as non-fallthru.  */\n \t\t      crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n  \t\t    } /* end: 'if (GET_CODE ... '  */\n@@ -1395,7 +1395,7 @@ fix_up_fall_thru_edges (void)\n  \t\t     the cond jump does).  */\n  \t\t  \n \t\t  if (!cond_jump_crosses\n-\t\t      && cur_bb->rbi->next == cond_jump->dest)\n+\t\t      && cur_bb->aux == cond_jump->dest)\n  \t\t    {\n  \t\t      /* Find label in fall_thru block. We've already added\n  \t\t         any missing labels, so there must be one.  */\n@@ -1430,8 +1430,8 @@ fix_up_fall_thru_edges (void)\n \t\t  \n  \t\t  if (new_bb)\n  \t\t    {\n- \t\t      new_bb->rbi->next = cur_bb->rbi->next;\n- \t\t      cur_bb->rbi->next = new_bb;\n+ \t\t      new_bb->aux = cur_bb->aux;\n+ \t\t      cur_bb->aux = new_bb;\n \t\t      \n  \t\t      /* Make sure new fall-through bb is in same \n \t\t\t partition as bb it's falling through from.  */\n@@ -1445,13 +1445,13 @@ fix_up_fall_thru_edges (void)\n  \t\t  if (new_bb)\n  \t\t    {\n  \t\t      barrier = emit_barrier_after (BB_END (new_bb));\n- \t\t      new_bb->rbi->footer = unlink_insn_chain (barrier, \n+ \t\t      new_bb->il.rtl->footer = unlink_insn_chain (barrier, \n  \t\t\t\t\t\t\t       barrier);\n  \t\t    }\n  \t\t  else\n  \t\t    {\n  \t\t      barrier = emit_barrier_after (BB_END (cur_bb));\n- \t\t      cur_bb->rbi->footer = unlink_insn_chain (barrier,\n+ \t\t      cur_bb->il.rtl->footer = unlink_insn_chain (barrier,\n  \t\t\t\t\t\t\t       barrier);\n  \t\t    }\n  \t\t}\n@@ -1597,8 +1597,8 @@ fix_crossing_conditional_branches (void)\n \t\t     conditional jump.  */\n \t\t  \n \t\t  new_bb = create_basic_block (NULL, NULL, last_bb);\n-\t\t  new_bb->rbi->next = last_bb->rbi->next;\n-\t\t  last_bb->rbi->next = new_bb;\n+\t\t  new_bb->aux = last_bb->aux;\n+\t\t  last_bb->aux = new_bb;\n \t\t  prev_bb = last_bb;\n \t\t  last_bb = new_bb;\n \t\t  \n@@ -1634,7 +1634,7 @@ fix_crossing_conditional_branches (void)\n \t\t  \n \t\t  barrier = emit_barrier_after (new_jump);\n \t\t  JUMP_LABEL (new_jump) = old_label;\n-\t\t  new_bb->rbi->footer = unlink_insn_chain (barrier, \n+\t\t  new_bb->il.rtl->footer = unlink_insn_chain (barrier, \n \t\t\t\t\t\t\t   barrier);\n \t\t  \n \t\t  /* Make sure new bb is in same partition as source\n@@ -2008,7 +2008,7 @@ duplicate_computed_gotos (void)\n \n       /* Build the reorder chain for the original order of blocks.  */\n       if (bb->next_bb != EXIT_BLOCK_PTR)\n-\tbb->rbi->next = bb->next_bb;\n+\tbb->aux = bb->next_bb;\n \n       /* Obviously the block has to end in a computed jump.  */\n       if (!computed_jump_p (BB_END (bb)))\n@@ -2048,10 +2048,10 @@ duplicate_computed_gotos (void)\n   /* Duplicate computed gotos.  */\n   FOR_EACH_BB (bb)\n     {\n-      if (bb->rbi->visited)\n+      if (bb->il.rtl->visited)\n \tcontinue;\n \n-      bb->rbi->visited = 1;\n+      bb->il.rtl->visited = 1;\n \n       /* BB must have one outgoing edge.  That edge must not lead to\n          the exit block or the next block.\n@@ -2067,9 +2067,9 @@ duplicate_computed_gotos (void)\n \tcontinue;\n \n       new_bb = duplicate_block (single_succ (bb), single_succ_edge (bb));\n-      new_bb->rbi->next = bb->rbi->next;\n-      bb->rbi->next = new_bb;\n-      new_bb->rbi->visited = 1;\n+      new_bb->aux = bb->aux;\n+      bb->aux = new_bb;\n+      new_bb->il.rtl->visited = 1;\n     }\n \n done:\n@@ -2156,7 +2156,7 @@ partition_hot_cold_basic_blocks (void)\n   FOR_EACH_BB (cur_bb)\n     if (cur_bb->index >= 0\n  \t&& cur_bb->next_bb->index >= 0)\n-      cur_bb->rbi->next = cur_bb->next_bb;\n+      cur_bb->aux = cur_bb->next_bb;\n   \n   find_rarely_executed_basic_blocks_and_crossing_edges (crossing_edges, \n \t\t\t\t\t\t\t&n_crossing_edges, "}, {"sha": "2d6a3ca5c33647e212ddb82fdcdda0bcf5b5cdd6", "filename": "gcc/cfg.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -136,16 +136,6 @@ alloc_block (void)\n   return bb;\n }\n \n-/* Initialize rbi (the structure containing data used by basic block\n-   duplication and reordering) for the given basic block.  */\n-\n-void\n-initialize_bb_rbi (basic_block bb)\n-{\n-  gcc_assert (!bb->rbi);\n-  bb->rbi = ggc_alloc_cleared (sizeof (struct reorder_block_def));\n-}\n-\n /* Link block B to chain after AFTER.  */\n void\n link_block (basic_block b, basic_block after)"}, {"sha": "16438cce7349630489c90050834991703265fedf", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 47, "deletions": 50, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -209,11 +209,11 @@ record_effective_endpoints (void)\n       rtx end;\n \n       if (PREV_INSN (BB_HEAD (bb)) && next_insn != BB_HEAD (bb))\n-\tbb->rbi->header = unlink_insn_chain (next_insn,\n+\tbb->il.rtl->header = unlink_insn_chain (next_insn,\n \t\t\t\t\t      PREV_INSN (BB_HEAD (bb)));\n       end = skip_insns_after_block (bb);\n       if (NEXT_INSN (BB_END (bb)) && BB_END (bb) != end)\n-\tbb->rbi->footer = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n+\tbb->il.rtl->footer = unlink_insn_chain (NEXT_INSN (BB_END (bb)), end);\n       next_insn = NEXT_INSN (BB_END (bb));\n     }\n \n@@ -584,16 +584,16 @@ fixup_reorder_chain (void)\n \n   for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n        bb != 0;\n-       bb = bb->rbi->next, index++)\n+       bb = bb->aux, index++)\n     {\n-      if (bb->rbi->header)\n+      if (bb->il.rtl->header)\n \t{\n \t  if (insn)\n-\t    NEXT_INSN (insn) = bb->rbi->header;\n+\t    NEXT_INSN (insn) = bb->il.rtl->header;\n \t  else\n-\t    set_first_insn (bb->rbi->header);\n-\t  PREV_INSN (bb->rbi->header) = insn;\n-\t  insn = bb->rbi->header;\n+\t    set_first_insn (bb->il.rtl->header);\n+\t  PREV_INSN (bb->il.rtl->header) = insn;\n+\t  insn = bb->il.rtl->header;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -603,10 +603,10 @@ fixup_reorder_chain (void)\n \tset_first_insn (BB_HEAD (bb));\n       PREV_INSN (BB_HEAD (bb)) = insn;\n       insn = BB_END (bb);\n-      if (bb->rbi->footer)\n+      if (bb->il.rtl->footer)\n \t{\n-\t  NEXT_INSN (insn) = bb->rbi->footer;\n-\t  PREV_INSN (bb->rbi->footer) = insn;\n+\t  NEXT_INSN (insn) = bb->il.rtl->footer;\n+\t  PREV_INSN (bb->il.rtl->footer) = insn;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t}\n@@ -630,7 +630,7 @@ fixup_reorder_chain (void)\n   /* Now add jumps and labels as needed to match the blocks new\n      outgoing edges.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = bb->rbi->next)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb ; bb = bb->aux)\n     {\n       edge e_fall, e_taken, e;\n       rtx bb_end_insn;\n@@ -656,7 +656,7 @@ fixup_reorder_chain (void)\n \t  if (any_condjump_p (bb_end_insn))\n \t    {\n \t      /* If the old fallthru is still next, nothing to do.  */\n-\t      if (bb->rbi->next == e_fall->dest\n+\t      if (bb->aux == e_fall->dest\n \t          || e_fall->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n@@ -699,7 +699,7 @@ fixup_reorder_chain (void)\n \t\t such as happens at the very end of a function, then we'll\n \t\t need to add a new unconditional jump.  Choose the taken\n \t\t edge based on known or assumed probability.  */\n-\t      else if (bb->rbi->next != e_taken->dest)\n+\t      else if (bb->aux != e_taken->dest)\n \t\t{\n \t\t  rtx note = find_reg_note (bb_end_insn, REG_BR_PROB, 0);\n \n@@ -762,7 +762,7 @@ fixup_reorder_chain (void)\n \t    continue;\n \n \t  /* If the fallthru block is still next, nothing to do.  */\n-\t  if (bb->rbi->next == e_fall->dest)\n+\t  if (bb->aux == e_fall->dest)\n \t    continue;\n \n \t  /* A fallthru to exit block.  */\n@@ -774,10 +774,9 @@ fixup_reorder_chain (void)\n       nb = force_nonfallthru (e_fall);\n       if (nb)\n \t{\n-\t  initialize_bb_rbi (nb);\n-\t  nb->rbi->visited = 1;\n-\t  nb->rbi->next = bb->rbi->next;\n-\t  bb->rbi->next = nb;\n+\t  nb->il.rtl->visited = 1;\n+\t  nb->aux = bb->aux;\n+\t  bb->aux = nb;\n \t  /* Don't process this new block.  */\n \t  bb = nb;\n \t  \n@@ -802,7 +801,7 @@ fixup_reorder_chain (void)\n       fprintf (dump_file, \"Reordered sequence:\\n\");\n       for (bb = ENTRY_BLOCK_PTR->next_bb, index = 0;\n \t   bb;\n-\t   bb = bb->rbi->next, index++)\n+\t   bb = bb->aux, index++)\n \t{\n \t  fprintf (dump_file, \" %i \", index);\n \t  if (get_bb_original (bb))\n@@ -821,7 +820,7 @@ fixup_reorder_chain (void)\n   bb = ENTRY_BLOCK_PTR->next_bb;\n   index = 0;\n \n-  for (; bb; prev_bb = bb, bb = bb->rbi->next, index ++)\n+  for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n     {\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n@@ -893,7 +892,7 @@ fixup_fallthru_exit_predecessor (void)\n     if (e->flags & EDGE_FALLTHRU)\n       bb = e->src;\n \n-  if (bb && bb->rbi->next)\n+  if (bb && bb->aux)\n     {\n       basic_block c = ENTRY_BLOCK_PTR->next_bb;\n \n@@ -902,22 +901,21 @@ fixup_fallthru_exit_predecessor (void)\n       if (c == bb)\n \t{\n \t  bb = split_block (bb, NULL)->dest;\n-\t  initialize_bb_rbi (bb);\n-\t  bb->rbi->next = c->rbi->next;\n-\t  c->rbi->next = bb;\n-\t  bb->rbi->footer = c->rbi->footer;\n-\t  c->rbi->footer = NULL;\n+\t  bb->aux = c->aux;\n+\t  c->aux = bb;\n+\t  bb->il.rtl->footer = c->il.rtl->footer;\n+\t  c->il.rtl->footer = NULL;\n \t}\n \n-      while (c->rbi->next != bb)\n-\tc = c->rbi->next;\n+      while (c->aux != bb)\n+\tc = c->aux;\n \n-      c->rbi->next = bb->rbi->next;\n-      while (c->rbi->next)\n-\tc = c->rbi->next;\n+      c->aux = bb->aux;\n+      while (c->aux)\n+\tc = c->aux;\n \n-      c->rbi->next = bb;\n-      bb->rbi->next = NULL;\n+      c->aux = bb;\n+      bb->aux = NULL;\n     }\n }\n \f\n@@ -1057,24 +1055,24 @@ cfg_layout_duplicate_bb (basic_block bb)\n \t\t\t       EXIT_BLOCK_PTR->prev_bb);\n \n   BB_COPY_PARTITION (new_bb, bb);\n-  if (bb->rbi->header)\n+  if (bb->il.rtl->header)\n     {\n-      insn = bb->rbi->header;\n+      insn = bb->il.rtl->header;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (bb->rbi->header, insn);\n+      insn = duplicate_insn_chain (bb->il.rtl->header, insn);\n       if (insn)\n-\tnew_bb->rbi->header = unlink_insn_chain (insn, get_last_insn ());\n+\tnew_bb->il.rtl->header = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n-  if (bb->rbi->footer)\n+  if (bb->il.rtl->footer)\n     {\n-      insn = bb->rbi->footer;\n+      insn = bb->il.rtl->footer;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n-      insn = duplicate_insn_chain (bb->rbi->footer, insn);\n+      insn = duplicate_insn_chain (bb->il.rtl->footer, insn);\n       if (insn)\n-\tnew_bb->rbi->footer = unlink_insn_chain (insn, get_last_insn ());\n+\tnew_bb->il.rtl->footer = unlink_insn_chain (insn, get_last_insn ());\n     }\n \n   if (bb->il.rtl->global_live_at_start)\n@@ -1100,11 +1098,6 @@ cfg_layout_duplicate_bb (basic_block bb)\n void\n cfg_layout_initialize (unsigned int flags)\n {\n-  basic_block bb;\n-\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    initialize_bb_rbi (bb);\n-\n   initialize_original_copy_tables ();\n \n   cfg_layout_rtl_register_cfg_hooks ();\n@@ -1142,8 +1135,8 @@ break_superblocks (void)\n   free (superblocks);\n }\n \n-/* Finalize the changes: reorder insn list according to the sequence, enter\n-   compensation code, rebuild scope forest.  */\n+/* Finalize the changes: reorder insn list according to the sequence specified\n+   by aux pointers, enter compensation code, rebuild scope forest.  */\n \n void\n cfg_layout_finalize (void)\n@@ -1166,7 +1159,11 @@ cfg_layout_finalize (void)\n   verify_insn_chain ();\n #endif\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    bb->rbi = NULL;\n+  {\n+    bb->il.rtl->header = bb->il.rtl->footer = NULL;\n+    bb->aux = NULL;\n+    bb->il.rtl->visited = 0;\n+  }\n \n   break_superblocks ();\n "}, {"sha": "b269ba44b23fffa95467bb8b983aae2a5530987a", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -345,7 +345,6 @@ cfg_layout_create_basic_block (void *head, void *end, basic_block after)\n {\n   basic_block newbb = rtl_create_basic_block (head, end, after);\n \n-  initialize_bb_rbi (newbb);\n   return newbb;\n }\n \f\n@@ -713,7 +712,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       /* Selectively unlink whole insn chain.  */\n       if (in_cfglayout)\n \t{\n-\t  rtx insn = src->rbi->footer;\n+\t  rtx insn = src->il.rtl->footer;\n \n           delete_insn_chain (kill_from, BB_END (src));\n \n@@ -725,7 +724,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t\t  if (PREV_INSN (insn))\n \t\t    NEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n \t\t  else\n-\t\t    src->rbi->footer = NEXT_INSN (insn);\n+\t\t    src->il.rtl->footer = NEXT_INSN (insn);\n \t\t  if (NEXT_INSN (insn))\n \t\t    PREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t\t}\n@@ -2490,8 +2489,8 @@ cfg_layout_split_block (basic_block bb, void *insnp)\n   rtx insn = insnp;\n   basic_block new_bb = rtl_split_block (bb, insn);\n \n-  new_bb->rbi->footer = bb->rbi->footer;\n-  bb->rbi->footer = NULL;\n+  new_bb->il.rtl->footer = bb->il.rtl->footer;\n+  bb->il.rtl->footer = NULL;\n \n   return new_bb;\n }\n@@ -2597,44 +2596,44 @@ cfg_layout_delete_block (basic_block bb)\n {\n   rtx insn, next, prev = PREV_INSN (BB_HEAD (bb)), *to, remaints;\n \n-  if (bb->rbi->header)\n+  if (bb->il.rtl->header)\n     {\n       next = BB_HEAD (bb);\n       if (prev)\n-\tNEXT_INSN (prev) = bb->rbi->header;\n+\tNEXT_INSN (prev) = bb->il.rtl->header;\n       else\n-\tset_first_insn (bb->rbi->header);\n-      PREV_INSN (bb->rbi->header) = prev;\n-      insn = bb->rbi->header;\n+\tset_first_insn (bb->il.rtl->header);\n+      PREV_INSN (bb->il.rtl->header) = prev;\n+      insn = bb->il.rtl->header;\n       while (NEXT_INSN (insn))\n \tinsn = NEXT_INSN (insn);\n       NEXT_INSN (insn) = next;\n       PREV_INSN (next) = insn;\n     }\n   next = NEXT_INSN (BB_END (bb));\n-  if (bb->rbi->footer)\n+  if (bb->il.rtl->footer)\n     {\n-      insn = bb->rbi->footer;\n+      insn = bb->il.rtl->footer;\n       while (insn)\n \t{\n \t  if (BARRIER_P (insn))\n \t    {\n \t      if (PREV_INSN (insn))\n \t\tNEXT_INSN (PREV_INSN (insn)) = NEXT_INSN (insn);\n \t      else\n-\t\tbb->rbi->footer = NEXT_INSN (insn);\n+\t\tbb->il.rtl->footer = NEXT_INSN (insn);\n \t      if (NEXT_INSN (insn))\n \t\tPREV_INSN (NEXT_INSN (insn)) = PREV_INSN (insn);\n \t    }\n \t  if (LABEL_P (insn))\n \t    break;\n \t  insn = NEXT_INSN (insn);\n \t}\n-      if (bb->rbi->footer)\n+      if (bb->il.rtl->footer)\n \t{\n \t  insn = BB_END (bb);\n-\t  NEXT_INSN (insn) = bb->rbi->footer;\n-\t  PREV_INSN (bb->rbi->footer) = insn;\n+\t  NEXT_INSN (insn) = bb->il.rtl->footer;\n+\t  PREV_INSN (bb->il.rtl->footer) = insn;\n \t  while (NEXT_INSN (insn))\n \t    insn = NEXT_INSN (insn);\n \t  NEXT_INSN (insn) = next;\n@@ -2645,12 +2644,10 @@ cfg_layout_delete_block (basic_block bb)\n \t}\n     }\n   if (bb->next_bb != EXIT_BLOCK_PTR)\n-    to = &bb->next_bb->rbi->header;\n+    to = &bb->next_bb->il.rtl->header;\n   else\n     to = &cfg_layout_function_footer;\n \n-  bb->rbi = NULL;\n-\n   rtl_delete_block (bb);\n \n   if (prev)\n@@ -2727,13 +2724,13 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n   gcc_assert (!JUMP_P (BB_END (a)));\n \n   /* Possible line number notes should appear in between.  */\n-  if (b->rbi->header)\n+  if (b->il.rtl->header)\n     {\n       rtx first = BB_END (a), last;\n \n-      last = emit_insn_after_noloc (b->rbi->header, BB_END (a));\n+      last = emit_insn_after_noloc (b->il.rtl->header, BB_END (a));\n       delete_insn_chain (NEXT_INSN (first), last);\n-      b->rbi->header = NULL;\n+      b->il.rtl->header = NULL;\n     }\n \n   /* In the case basic blocks are not adjacent, move them around.  */\n@@ -2769,20 +2766,20 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n     }\n \n   /* Possible tablejumps and barriers should appear after the block.  */\n-  if (b->rbi->footer)\n+  if (b->il.rtl->footer)\n     {\n-      if (!a->rbi->footer)\n-\ta->rbi->footer = b->rbi->footer;\n+      if (!a->il.rtl->footer)\n+\ta->il.rtl->footer = b->il.rtl->footer;\n       else\n \t{\n-\t  rtx last = a->rbi->footer;\n+\t  rtx last = a->il.rtl->footer;\n \n \t  while (NEXT_INSN (last))\n \t    last = NEXT_INSN (last);\n-\t  NEXT_INSN (last) = b->rbi->footer;\n-\t  PREV_INSN (b->rbi->footer) = last;\n+\t  NEXT_INSN (last) = b->il.rtl->footer;\n+\t  PREV_INSN (b->il.rtl->footer) = last;\n \t}\n-      b->rbi->footer = NULL;\n+      b->il.rtl->footer = NULL;\n     }\n   a->il.rtl->global_live_at_end = b->il.rtl->global_live_at_end;\n "}, {"sha": "d5145606ce18909c8d79d3823626eddc2d8879af", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -5233,7 +5233,7 @@ thread_prologue_and_epilogue_insns (rtx f ATTRIBUTE_UNUSED)\n       cfg_layout_initialize (0);\n       FOR_EACH_BB (cur_bb)\n \tif (cur_bb->index >= 0 && cur_bb->next_bb->index >= 0)\n-\t  cur_bb->rbi->next = cur_bb->next_bb;\n+\t  cur_bb->aux = cur_bb->next_bb;\n       cfg_layout_finalize ();\n     }\n epilogue_done:"}, {"sha": "6910f333ea3adb0aa231d200e1a6ede83b752c9a", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -600,7 +600,7 @@ rest_of_handle_sms (void)\n   /* Finalize layout changes.  */\n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->rbi->next = bb->next_bb;\n+      bb->aux = bb->next_bb;\n   cfg_layout_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n   ggc_collect ();\n@@ -1187,7 +1187,7 @@ rest_of_handle_loop2 (void)\n   /* Finalize layout changes.  */\n   FOR_EACH_BB (bb)\n     if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->rbi->next = bb->next_bb;\n+      bb->aux = bb->next_bb;\n   cfg_layout_finalize ();\n \n   cleanup_cfg (CLEANUP_EXPENSIVE);"}, {"sha": "5d3aaf4bbbe558806ea44a5fa6960b3bc5dc436d", "filename": "gcc/tracer.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370369e1a7e0b3a217c016236374883e274f6a44/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=370369e1a7e0b3a217c016236374883e274f6a44", "patch": "@@ -65,7 +65,7 @@ static int branch_ratio_cutoff;\n /* Return true if BB has been seen - it is connected to some trace\n    already.  */\n \n-#define seen(bb) (bb->rbi->visited || bb->rbi->next)\n+#define seen(bb) (bb->il.rtl->visited || bb->aux)\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n static bool\n@@ -292,8 +292,8 @@ tail_duplicate (void)\n \t\tfprintf (dump_file, \"Duplicated %i as %i [%i]\\n\",\n \t\t\t old->index, bb2->index, bb2->frequency);\n \t    }\n-\t  bb->rbi->next = bb2;\n-\t  bb2->rbi->visited = 1;\n+\t  bb->aux = bb2;\n+\t  bb2->il.rtl->visited = 1;\n \t  bb = bb2;\n \t  /* In case the trace became infrequent, stop duplicating.  */\n \t  if (ignore_bb_p (bb))\n@@ -328,28 +328,28 @@ layout_superblocks (void)\n     {\n       edge_iterator ei;\n       edge e, best = NULL;\n-      while (end->rbi->next)\n-\tend = end->rbi->next;\n+      while (end->aux)\n+\tend = end->aux;\n \n       FOR_EACH_EDGE (e, ei, end->succs)\n \tif (e->dest != EXIT_BLOCK_PTR\n \t    && e->dest != single_succ (ENTRY_BLOCK_PTR)\n-\t    && !e->dest->rbi->visited\n+\t    && !e->dest->il.rtl->visited\n \t    && (!best || EDGE_FREQUENCY (e) > EDGE_FREQUENCY (best)))\n \t  best = e;\n \n       if (best)\n \t{\n-\t  end->rbi->next = best->dest;\n-\t  best->dest->rbi->visited = 1;\n+\t  end->aux = best->dest;\n+\t  best->dest->il.rtl->visited = 1;\n \t}\n       else\n \tfor (; bb != EXIT_BLOCK_PTR; bb = bb->next_bb)\n \t  {\n-\t    if (!bb->rbi->visited)\n+\t    if (!bb->il.rtl->visited)\n \t      {\n-\t\tend->rbi->next = bb;\n-\t\tbb->rbi->visited = 1;\n+\t\tend->aux = bb;\n+\t\tbb->il.rtl->visited = 1;\n \t\tbreak;\n \t      }\n \t  }"}]}