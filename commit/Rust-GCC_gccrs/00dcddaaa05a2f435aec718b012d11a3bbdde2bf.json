{"sha": "00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBkY2RkYWFhMDVhMmY0MzVhZWM3MThiMDEyZDExYTNiYmRkZTJiZg==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-07-08T19:11:44Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-07-08T19:11:44Z"}, "message": "ANSI C conversion, libmudflap specialization, recursion limiting.\n\n2004-07-08  Frank Ch. Eigler  <fche@redhat.com>\n\n\tANSI C conversion, libmudflap specialization, recursion limiting.\n\t* splay-tree.h (splay_tree_{de,}allocate_fn): Remove allocation_data\n\targument and indirection function pointers, update callers.\n\t(splay_tree_s): Add statistics and recursion control fields\n\tnum_keys, max_depth, depth, rebalance_p.\n\t* splay-tree.c (splay_tree_splay_helper): Track recursion depth.\n\tBack out of search if it exceeds limit.\n\t(splay_tree_splay): Manage recursion limiting with rebalancing as\n\tneeded.\n\t(splay_tree_new): More initialization.\n\t(splay_tree_rebalance): New function.\n\t(splay_tree_foreach): Rewrite using nonrecursive logic.\n\t(splay_tree_xmalloc_allocate, splay_tree_xmalloc_deallocate):\n\tRemove.  Point indirect calls to mf-runtime.c's routines.\n\t(splay_tree_compare_ints, splay_tree_compare_pointers): Remove unused\n\tfunctions.\n\t(splay_tree_delete, splay_tree_delete_helper): Ditto.\n\t* testsuite/heap-scalestress.c: New test based on one from\n\tEyal Lebedinsky <eyal@eyal.emu.id.au>:\n\nFrom-SVN: r84303", "tree": {"sha": "97a0c5a50926d315a28447a12a9d2521421236a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97a0c5a50926d315a28447a12a9d2521421236a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a32e70c34d6a6e1f413406c432d499fb468c708e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a32e70c34d6a6e1f413406c432d499fb468c708e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a32e70c34d6a6e1f413406c432d499fb468c708e"}], "stats": {"total": 675, "additions": 388, "deletions": 287}, "files": [{"sha": "04ce4727ecdfa5f80566c32f9a298c2246af92f6", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "patch": "@@ -1,3 +1,25 @@\n+2004-07-08  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tANSI C conversion, libmudflap specialization, recursion limiting.\n+\t* splay-tree.h (splay_tree_{de,}allocate_fn): Remove allocation_data\n+\targument and indirection function pointers, update callers.\n+\t(splay_tree_s): Add statistics and recursion control fields\n+\tnum_keys, max_depth, depth, rebalance_p.\n+\t* splay-tree.c (splay_tree_splay_helper): Track recursion depth.\n+\tBack out of search if it exceeds limit.\n+\t(splay_tree_splay): Manage recursion limiting with rebalancing as\n+\tneeded.\n+\t(splay_tree_new): More initialization.\n+\t(splay_tree_rebalance): New function.\n+\t(splay_tree_foreach): Rewrite using nonrecursive logic.\n+\t(splay_tree_xmalloc_allocate, splay_tree_xmalloc_deallocate):\n+\tRemove.  Point indirect calls to mf-runtime.c's routines.\n+\t(splay_tree_compare_ints, splay_tree_compare_pointers): Remove unused\n+\tfunctions.\n+\t(splay_tree_delete, splay_tree_delete_helper): Ditto.\n+\t* testsuite/heap-scalestress.c: New test based on one from\n+\tEyal Lebedinsky <eyal@eyal.emu.id.au>:\n+\n 2004-07-05  Matthias Klose  <doko@debian.org>\n \n \t* libtool-version: New."}, {"sha": "229ef94355392defca4132d53dd530280e34a700", "filename": "libmudflap/splay-tree.c", "status": "modified", "additions": 250, "deletions": 210, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Fsplay-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Fsplay-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.c?ref=00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "patch": "@@ -38,20 +38,16 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include \"splay-tree.h\"\n \n-static void splay_tree_delete_helper    PARAMS((splay_tree, \n-\t\t\t\t\t\tsplay_tree_node));\n-static void splay_tree_splay            PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-static splay_tree_node splay_tree_splay_helper     \n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key,\n-\t\t\t\t\t\tsplay_tree_node*,\n-\t\t\t\t\t\tsplay_tree_node*,\n-\t\t\t\t\t\tsplay_tree_node*));\n-static int splay_tree_foreach_helper    PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_node,\n-\t\t\t\t\t\tsplay_tree_foreach_fn,\n-\t\t\t\t\t\tvoid*));\n+\n+static void splay_tree_delete_helper (splay_tree, splay_tree_node);\n+static void splay_tree_splay (splay_tree, splay_tree_key);\n+static splay_tree_node splay_tree_splay_helper (splay_tree,\n+                                                splay_tree_key,\n+                                                splay_tree_node *,\n+                                                splay_tree_node *,\n+                                                splay_tree_node *);\n+static void *splay_tree_xmalloc (size_t size);\n+static void splay_tree_free (void *object);\n \n \n \n@@ -63,42 +59,25 @@ compare_uintptr_t (splay_tree_key k1, splay_tree_key k2)\n     return -1;\n   else if ((uintptr_t) k1 > (uintptr_t) k2)\n     return 1;\n-  else \n+  else\n     return 0;\n }\n \n \n-\n-/* Deallocate NODE (a member of SP), and all its sub-trees.  */\n-\n-static void \n-splay_tree_delete_helper (sp, node)\n-     splay_tree sp;\n-     splay_tree_node node;\n-{\n-  if (!node)\n-    return;\n-\n-  splay_tree_delete_helper (sp, node->left);\n-  splay_tree_delete_helper (sp, node->right);\n-  (*sp->deallocate) ((char*) node, sp->allocate_data);\n-}\n-\n /* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n    and grandparent, respectively, of NODE.  */\n \n static splay_tree_node\n-splay_tree_splay_helper (sp, key, node, parent, grandparent)\n-     splay_tree sp;\n-     splay_tree_key key;\n-     splay_tree_node *node;\n-     splay_tree_node *parent;\n-     splay_tree_node *grandparent;\n+splay_tree_splay_helper (splay_tree sp,\n+                         splay_tree_key key,\n+                         splay_tree_node * node,\n+                         splay_tree_node * parent,\n+                         splay_tree_node * grandparent)\n {\n   splay_tree_node *next;\n   splay_tree_node n;\n   int comparison;\n-  \n+\n   n = *node;\n \n   if (!n)\n@@ -112,39 +91,49 @@ splay_tree_splay_helper (sp, key, node, parent, grandparent)\n   else if (comparison < 0)\n     /* The target is to the left.  */\n     next = &n->left;\n-  else \n+  else\n     /* The target is to the right.  */\n     next = &n->right;\n \n   if (next)\n     {\n+      /* Check whether our recursion depth is too high.  Abort this search,\n+         and signal that a rebalance is required to continue.  */\n+      if (sp->depth > sp->max_depth)\n+        {\n+          sp->rebalance_p = 1;\n+          return n;\n+         }\n+\n       /* Continue down the tree.  */\n+      sp->depth ++;\n       n = splay_tree_splay_helper (sp, key, next, node, parent);\n+      sp->depth --;\n \n       /* The recursive call will change the place to which NODE\n-\t points.  */\n-      if (*node != n)\n-\treturn n;\n+         points.  */\n+      if (*node != n || sp->rebalance_p)\n+        return n;\n     }\n \n   if (!parent)\n     /* NODE is the root.  We are done.  */\n     return n;\n \n   /* First, handle the case where there is no grandparent (i.e.,\n-     *PARENT is the root of the tree.)  */\n-  if (!grandparent) \n+   *PARENT is the root of the tree.)  */\n+  if (!grandparent)\n     {\n       if (n == (*parent)->left)\n-\t{\n-\t  *node = n->right;\n-\t  n->right = *parent;\n-\t}\n+        {\n+          *node = n->right;\n+          n->right = *parent;\n+        }\n       else\n-\t{\n-\t  *node = n->left;\n-\t  n->left = *parent;\n-\t}\n+        {\n+          *node = n->left;\n+          n->left = *parent;\n+        }\n       *parent = n;\n       return n;\n     }\n@@ -160,9 +149,9 @@ splay_tree_splay_helper (sp, key, node, parent, grandparent)\n       p->left = n->right;\n       n->right = p;\n       *grandparent = n;\n-      return n; \n+      return n;\n     }\n-  else if  (n == (*parent)->right && *parent == (*grandparent)->right)\n+  else if (n == (*parent)->right && *parent == (*grandparent)->right)\n     {\n       splay_tree_node p = *parent;\n \n@@ -176,15 +165,15 @@ splay_tree_splay_helper (sp, key, node, parent, grandparent)\n \n   /* Finally, deal with the case where N is a left child, but *PARENT\n      is a right child, or vice versa.  */\n-  if (n == (*parent)->left) \n+  if (n == (*parent)->left)\n     {\n       (*parent)->left = n->right;\n       n->right = *parent;\n       (*grandparent)->right = n->left;\n       n->left = *grandparent;\n       *grandparent = n;\n       return n;\n-    } \n+    }\n   else\n     {\n       (*parent)->right = n->left;\n@@ -196,117 +185,128 @@ splay_tree_splay_helper (sp, key, node, parent, grandparent)\n     }\n }\n \n-/* Splay SP around KEY.  */\n \n-static void\n-splay_tree_splay (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+\n+static int\n+splay_tree_rebalance_helper1 (splay_tree_node n, void *array_ptr)\n {\n-  if (sp->root == 0)\n-    return;\n+  splay_tree_node **p = array_ptr;\n+  *(*p) = n;\n+  (*p)++;\n+  return 0;\n+}\n \n-  /* If we just splayed the tree with the same key, do nothing.  */\n-  if (sp->last_splayed_key_p &&\n-      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n-    return;\n \n-  splay_tree_splay_helper (sp, key, &sp->root, \n-\t\t\t   /*grandparent=*/0, /*parent=*/0); \n+static splay_tree_node\n+splay_tree_rebalance_helper2 (splay_tree_node * array, unsigned low,\n+                              unsigned high)\n+{\n+  unsigned middle = low + (high - low) / 2;\n+  splay_tree_node n = array[middle];\n \n-  /* Cache this splay key. */\n-  sp->last_splayed_key = key;\n-  sp->last_splayed_key_p = 1;\n+  /* Note that since we're producing a balanced binary tree, it is not a problem\n+     that this function is recursive.  */\n+  if (low + 1 <= middle)\n+    n->left = splay_tree_rebalance_helper2 (array, low, middle - 1);\n+  else\n+    n->left = NULL;\n+\n+  if (middle + 1 <= high)\n+    n->right = splay_tree_rebalance_helper2 (array, middle + 1, high);\n+  else\n+    n->right = NULL;\n+\n+  return n;\n }\n \n-/* Call FN, passing it the DATA, for every node below NODE, all of\n-   which are from SP, following an in-order traversal.  If FN every\n-   returns a non-zero value, the iteration ceases immediately, and the\n-   value is returned.  Otherwise, this function returns 0.  */\n \n-static int\n-splay_tree_foreach_helper (sp, node, fn, data)\n-     splay_tree sp;\n-     splay_tree_node node;\n-     splay_tree_foreach_fn fn;\n-     void* data;\n+/* Rebalance the entire tree.  Do this by copying all the node\n+   pointers into an array, then cleverly re-linking them.  */\n+void\n+splay_tree_rebalance (splay_tree sp)\n {\n-  int val;\n-\n-  if (!node)\n-    return 0;\n+  splay_tree_node *all_nodes, *all_nodes_1;\n \n-  val = splay_tree_foreach_helper (sp, node->left, fn, data);\n-  if (val)\n-    return val;\n+  if (sp->num_keys <= 2)\n+    return;\n \n-  val = (*fn)(node, data);\n-  if (val)\n-    return val;\n+  all_nodes = splay_tree_xmalloc (sizeof (splay_tree_node) * sp->num_keys);\n \n-  return splay_tree_foreach_helper (sp, node->right, fn, data);\n-}\n+  /* Traverse all nodes to copy their addresses into this array.  */\n+  all_nodes_1 = all_nodes;\n+  splay_tree_foreach (sp, splay_tree_rebalance_helper1,\n+                      (void *) &all_nodes_1);\n \n+  /* Relink all the nodes.  */\n+  sp->root = splay_tree_rebalance_helper2 (all_nodes, 0, sp->num_keys - 1);\n \n-/* An allocator and deallocator based on xmalloc.  */\n-static void *\n-splay_tree_xmalloc_allocate (size, data)\n-     int size;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  return (void *) xmalloc (size);\n+  splay_tree_free (all_nodes);\n }\n \n+\n+/* Splay SP around KEY.  */\n static void\n-splay_tree_xmalloc_deallocate (object, data)\n-     void *object;\n-     void *data ATTRIBUTE_UNUSED;\n+splay_tree_splay (splay_tree sp, splay_tree_key key)\n {\n-  free (object);\n+  if (sp->root == 0)\n+    return;\n+\n+  /* If we just splayed the tree with the same key, do nothing.  */\n+  if (sp->last_splayed_key_p &&\n+      compare_uintptr_t (sp->last_splayed_key, key) == 0)\n+    return;\n+\n+  /* Compute a maximum recursion depth for a splay tree with NUM nodes.\n+     The idea is to limit excessive stack usage if we're facing\n+     degenerate access patterns.  Unfortunately such patterns can occur\n+     e.g. during static initialization, where many static objects might\n+     be registered in increasing address sequence, or during a case where\n+     large tree-like heap data structures are allocated quickly. \n+\n+     On x86, this corresponds to roughly 200K of stack usage. \n+     XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */\n+  sp->max_depth = 2500;\n+  sp->rebalance_p = sp->depth = 0;\n+\n+  splay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n+  if (sp->rebalance_p)\n+    {\n+      splay_tree_rebalance (sp);\n+\n+      sp->rebalance_p = sp->depth = 0;\n+      splay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n+\n+      if (sp->rebalance_p)\n+        abort ();\n+    }\n+\n+\n+  /* Cache this splay key. */\n+  sp->last_splayed_key = key;\n+  sp->last_splayed_key_p = 1;\n }\n \n \n-/* Allocate a new splay tree, using COMPARE_FN to compare nodes,\n-   DELETE_KEY_FN to deallocate keys, and DELETE_VALUE_FN to deallocate\n-   values.  Use xmalloc to allocate the splay tree structure, and any\n-   nodes added.  */\n \n-splay_tree \n+/* Allocate a new splay tree.  */\n+splay_tree\n splay_tree_new ()\n {\n-  splay_tree_allocate_fn allocate_fn = splay_tree_xmalloc_allocate;\n-  splay_tree_deallocate_fn deallocate_fn = splay_tree_xmalloc_deallocate;\n-  void *allocate_data = NULL;\n-  splay_tree sp = (splay_tree) (*allocate_fn) (sizeof (struct splay_tree_s),\n-                                               allocate_data);\n-  sp->root = 0;\n-  sp->allocate = allocate_fn;\n-  sp->deallocate = deallocate_fn;\n-  sp->allocate_data = allocate_data;\n+  splay_tree sp = splay_tree_xmalloc (sizeof (struct splay_tree_s));\n+  sp->root = NULL;\n   sp->last_splayed_key_p = 0;\n+  sp->num_keys = 0;\n \n   return sp;\n }\n \n-/* Deallocate SP.  */\n \n-void \n-splay_tree_delete (sp)\n-     splay_tree sp;\n-{\n-  splay_tree_delete_helper (sp, sp->root);\n-  (*sp->deallocate) ((char*) sp, sp->allocate_data);\n-}\n \n /* Insert a new node (associating KEY with DATA) into SP.  If a\n    previous node with the indicated KEY exists, its data is replaced\n    with the new value.  Returns the new node.  */\n-\n splay_tree_node\n-splay_tree_insert (sp, key, value)\n-     splay_tree sp;\n-     splay_tree_key key;\n-     splay_tree_value value;\n+splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)\n {\n   int comparison = 0;\n \n@@ -318,34 +318,32 @@ splay_tree_insert (sp, key, value)\n   if (sp->root && comparison == 0)\n     {\n       /* If the root of the tree already has the indicated KEY, just\n-\t replace the value with VALUE.  */\n+         replace the value with VALUE.  */\n       sp->root->value = value;\n-    } \n-  else \n+    }\n+  else\n     {\n       /* Create a new node, and insert it at the root.  */\n       splay_tree_node node;\n-      \n-      node = ((splay_tree_node)\n-              (*sp->allocate) (sizeof (struct splay_tree_node_s),\n-                               sp->allocate_data));\n+\n+      node = splay_tree_xmalloc (sizeof (struct splay_tree_node_s));\n       node->key = key;\n       node->value = value;\n-      \n+      sp->num_keys++;\n       if (!sp->root)\n-\tnode->left = node->right = 0;\n+        node->left = node->right = 0;\n       else if (comparison < 0)\n-\t{\n-\t  node->left = sp->root;\n-\t  node->right = node->left->right;\n-\t  node->left->right = 0;\n-\t}\n+        {\n+          node->left = sp->root;\n+          node->right = node->left->right;\n+          node->left->right = 0;\n+        }\n       else\n-\t{\n-\t  node->right = sp->root;\n-\t  node->left = node->right->left;\n-\t  node->right->left = 0;\n-\t}\n+        {\n+          node->right = sp->root;\n+          node->left = node->right->left;\n+          node->right->left = 0;\n+        }\n \n       sp->root = node;\n       sp->last_splayed_key_p = 0;\n@@ -357,53 +355,44 @@ splay_tree_insert (sp, key, value)\n /* Remove KEY from SP.  It is not an error if it did not exist.  */\n \n void\n-splay_tree_remove (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_remove (splay_tree sp, splay_tree_key key)\n {\n   splay_tree_splay (sp, key);\n   sp->last_splayed_key_p = 0;\n-\n   if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n     {\n       splay_tree_node left, right;\n-\n       left = sp->root->left;\n       right = sp->root->right;\n-\n       /* Delete the root node itself.  */\n-      (*sp->deallocate) (sp->root, sp->allocate_data);\n-\n+      splay_tree_free (sp->root);\n+      sp->num_keys--;\n       /* One of the children is now the root.  Doesn't matter much\n-\t which, so long as we preserve the properties of the tree.  */\n+         which, so long as we preserve the properties of the tree.  */\n       if (left)\n-\t{\n-\t  sp->root = left;\n-\n-\t  /* If there was a right child as well, hang it off the \n-\t     right-most leaf of the left child.  */\n-\t  if (right)\n-\t    {\n-\t      while (left->right)\n-\t\tleft = left->right;\n-\t      left->right = right;\n-\t    }\n-\t}\n+        {\n+          sp->root = left;\n+          /* If there was a right child as well, hang it off the \n+             right-most leaf of the left child.  */\n+          if (right)\n+            {\n+              while (left->right)\n+                left = left->right;\n+              left->right = right;\n+            }\n+        }\n       else\n-\tsp->root = right;\n+        sp->root = right;\n     }\n }\n \n /* Lookup KEY in SP, returning VALUE if present, and NULL \n    otherwise.  */\n \n splay_tree_node\n-splay_tree_lookup (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_lookup (splay_tree sp, splay_tree_key key)\n {\n   splay_tree_splay (sp, key);\n-\n   if (sp->root && compare_uintptr_t (sp->root->key, key) == 0)\n     return sp->root;\n   else\n@@ -413,113 +402,164 @@ splay_tree_lookup (sp, key)\n /* Return the node in SP with the greatest key.  */\n \n splay_tree_node\n-splay_tree_max (sp)\n-     splay_tree sp;\n+splay_tree_max (splay_tree sp)\n {\n   splay_tree_node n = sp->root;\n-\n   if (!n)\n     return NULL;\n-\n   while (n->right)\n     n = n->right;\n-\n   return n;\n }\n \n /* Return the node in SP with the smallest key.  */\n \n splay_tree_node\n-splay_tree_min (sp)\n-     splay_tree sp;\n+splay_tree_min (splay_tree sp)\n {\n   splay_tree_node n = sp->root;\n-\n   if (!n)\n     return NULL;\n-\n   while (n->left)\n     n = n->left;\n-\n   return n;\n }\n \n /* Return the immediate predecessor KEY, or NULL if there is no\n    predecessor.  KEY need not be present in the tree.  */\n \n splay_tree_node\n-splay_tree_predecessor (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_predecessor (splay_tree sp, splay_tree_key key)\n {\n   int comparison;\n   splay_tree_node node;\n-\n   /* If the tree is empty, there is certainly no predecessor.  */\n   if (!sp->root)\n     return NULL;\n-\n   /* Splay the tree around KEY.  That will leave either the KEY\n      itself, its predecessor, or its successor at the root.  */\n   splay_tree_splay (sp, key);\n   comparison = compare_uintptr_t (sp->root->key, key);\n-\n   /* If the predecessor is at the root, just return it.  */\n   if (comparison < 0)\n     return sp->root;\n-\n   /* Otherwise, find the rightmost element of the left subtree.  */\n   node = sp->root->left;\n   if (node)\n     while (node->right)\n       node = node->right;\n-\n   return node;\n }\n \n /* Return the immediate successor KEY, or NULL if there is no\n    successor.  KEY need not be present in the tree.  */\n \n splay_tree_node\n-splay_tree_successor (sp, key)\n-     splay_tree sp;\n-     splay_tree_key key;\n+splay_tree_successor (splay_tree sp, splay_tree_key key)\n {\n   int comparison;\n   splay_tree_node node;\n-\n   /* If the tree is empty, there is certainly no successor.  */\n   if (!sp->root)\n     return NULL;\n-\n   /* Splay the tree around KEY.  That will leave either the KEY\n      itself, its predecessor, or its successor at the root.  */\n   splay_tree_splay (sp, key);\n   comparison = compare_uintptr_t (sp->root->key, key);\n-\n   /* If the successor is at the root, just return it.  */\n   if (comparison > 0)\n     return sp->root;\n-\n   /* Otherwise, find the leftmost element of the right subtree.  */\n   node = sp->root->right;\n   if (node)\n     while (node->left)\n       node = node->left;\n-\n   return node;\n }\n \n /* Call FN, passing it the DATA, for every node in SP, following an\n    in-order traversal.  If FN every returns a non-zero value, the\n    iteration ceases immediately, and the value is returned.\n-   Otherwise, this function returns 0.  */\n-\n+   Otherwise, this function returns 0.\n+   \n+   This function simulates recursion using dynamically allocated\n+   arrays, since it may be called from splay_tree_rebalance(), which\n+   in turn means that the tree is already uncomfortably deep for stack\n+   space limits.  */\n int\n-splay_tree_foreach (sp, fn, data)\n-     splay_tree sp;\n-     splay_tree_foreach_fn fn;\n-     void *data;\n+splay_tree_foreach (splay_tree st, splay_tree_foreach_fn fn, void *data)\n {\n-  return splay_tree_foreach_helper (sp, sp->root, fn, data);\n+  splay_tree_node *stack1;\n+  char *stack2;\n+  unsigned sp;\n+  int val = 0;\n+  enum s { s_left, s_here, s_right, s_up };\n+\n+  if (st->root == NULL) /* => num_keys == 0 */\n+    return 0;\n+\n+  stack1 = splay_tree_xmalloc (sizeof (splay_tree_node) * st->num_keys);\n+  stack2 = splay_tree_xmalloc (sizeof (char) * st->num_keys);\n+\n+  sp = 0;\n+  stack1 [sp] = st->root;\n+  stack2 [sp] = s_left;\n+\n+  while (1)\n+    {\n+      splay_tree_node n;\n+      enum s s;\n+\n+      n = stack1 [sp];\n+      s = stack2 [sp];\n+\n+      /* Handle each of the four possible states separately.  */\n+\n+      /* 1: We're here to traverse the left subtree (if any).  */\n+      if (s == s_left)\n+        {\n+          stack2 [sp] = s_here;\n+          if (n->left != NULL)\n+            {\n+              sp ++;\n+              stack1 [sp] = n->left;\n+              stack2 [sp] = s_left;\n+            }\n+        }\n+\n+      /* 2: We're here to traverse this node.  */\n+      else if (s == s_here)\n+        {\n+          stack2 [sp] = s_right;\n+          val = (*fn) (n, data);\n+          if (val) break;\n+        }\n+\n+      /* 3: We're here to traverse the right subtree (if any).  */\n+      else if (s == s_right)\n+        {\n+          stack2 [sp] = s_up;\n+          if (n->right != NULL)\n+            {\n+              sp ++;\n+              stack1 [sp] = n->right;\n+              stack2 [sp] = s_left;\n+            }\n+        }\n+\n+      /* 4: We're here after both subtrees (if any) have been traversed.  */\n+      else if (s == s_up)\n+        {\n+          /* Pop the stack.  */\n+          if (sp == 0) break; /* Popping off the root note: we're finished!  */\n+          sp --;\n+        }\n+\n+      else\n+        abort ();\n+    }\n+\n+  splay_tree_free (stack1);\n+  splay_tree_free (stack2);\n+  return val;\n }"}, {"sha": "742eb4bb888f27962eb776580bf5006e47aa9faa", "filename": "libmudflap/splay-tree.h", "status": "modified", "additions": 37, "deletions": 77, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Fsplay-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Fsplay-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fsplay-tree.h?ref=00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "patch": "@@ -1,7 +1,7 @@\n /* A splay-tree datatype.  \n    Copyright 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.\n    Contributed by Mark Mitchell (mark@markmitchell.com).\n-   Adapted for libmudflap from libiberty.\n+   Adapted for libmudflap from libiberty by Frank Ch. Eigler <fche@redhat.com>.\n \n This file is part of GCC.\n    \n@@ -26,23 +26,16 @@ Boston, MA 02111-1307, USA.  */\n      Algorithms.  Harper-Collins, Inc.  1991.  \n \n    The major feature of splay trees is that all basic tree operations\n-   are amortized O(log n) time for a tree with n nodes.  */\n+   are amortized O(log n) time for a tree with n nodes.  \n+\n+   This version has been further modified to periodically rebalance\n+   the entire tree, should degenerate access patterns result in a very\n+   lopsided tree.\n+*/\n \n #ifndef _SPLAY_TREE_H\n #define _SPLAY_TREE_H\n \n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif /* __cplusplus */\n-\n-#define PARAMS(X) X\n-#define PTR  void *\n-#define ATTRIBUTE_UNUSED __attribute__((__unused__))\n-\n-#ifndef GTY\n-#define GTY(X)\n-#endif\n-\n /* Use typedefs for the key and data types to facilitate changing\n    these types, if necessary.  These types should be sufficiently wide\n    that any pointer or scalar can be cast to these types, and then\n@@ -54,83 +47,50 @@ typedef void *splay_tree_value;\n typedef struct splay_tree_node_s *splay_tree_node;\n \n /* The type of a function used to iterate over the tree.  */\n-typedef int (*splay_tree_foreach_fn) PARAMS((splay_tree_node, void*));\n-\n-/* The type of a function used to allocate memory for tree root and\n-   node structures.  The first argument is the number of bytes needed;\n-   the second is a data pointer the splay tree functions pass through\n-   to the allocator.  This function must never return zero.  */\n-typedef PTR (*splay_tree_allocate_fn) PARAMS((int, void *));\n-\n-/* The type of a function used to free memory allocated using the\n-   corresponding splay_tree_allocate_fn.  The first argument is the\n-   memory to be freed; the latter is a data pointer the splay tree\n-   functions pass through to the freer.  */\n-typedef void (*splay_tree_deallocate_fn) PARAMS((void *, void *));\n+typedef int (*splay_tree_foreach_fn) (splay_tree_node, void *);\n \n /* The nodes in the splay tree.  */\n-struct splay_tree_node_s GTY(())\n+struct splay_tree_node_s\n {\n-  /* The key.  */\n-  splay_tree_key GTY ((use_param1)) key;\n-\n-  /* The value.  */\n-  splay_tree_value GTY ((use_param2)) value;\n-\n-  /* The left and right children, respectively.  */\n-  splay_tree_node GTY ((use_params)) left;\n-  splay_tree_node GTY ((use_params)) right;\n+  /* Data.  */\n+  splay_tree_key key;\n+  splay_tree_value value;\n+  /* Children.  */\n+  splay_tree_node left;\n+  splay_tree_node right;\n };\n \n /* The splay tree itself.  */\n-struct splay_tree_s GTY(())\n+struct splay_tree_s\n {\n   /* The root of the tree.  */\n-  splay_tree_node GTY ((use_params)) root;\n-\n-  /* Allocate/free functions, and a data pointer to pass to them.  */\n-  splay_tree_allocate_fn allocate;\n-  splay_tree_deallocate_fn deallocate;\n-  PTR GTY((skip)) allocate_data;\n+  splay_tree_node root;\n \n   /* The last key value for which the tree has been splayed, but not\n      since modified.  */\n-  splay_tree_key GTY ((use_param1)) last_splayed_key;\n+  splay_tree_key last_splayed_key;\n   int last_splayed_key_p;\n+\n+  /* Statistics.  */\n+  unsigned num_keys;\n+\n+  /* Traversal recursion control flags.  */\n+  unsigned max_depth;\n+  unsigned depth;\n+  unsigned rebalance_p;\n };\n typedef struct splay_tree_s *splay_tree;\n \n-extern splay_tree splay_tree_new        PARAMS((void));\n-extern void splay_tree_delete           PARAMS((splay_tree));\n-extern splay_tree_node splay_tree_insert          \n-\t\t                        PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_key,\n-\t\t\t\t\t        splay_tree_value));\n-extern void splay_tree_remove\t\tPARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_lookup   \n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_key));\n-extern splay_tree_node splay_tree_predecessor\n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_successor\n-                                        PARAMS((splay_tree,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern splay_tree_node splay_tree_max\n-                                        PARAMS((splay_tree));\n-extern splay_tree_node splay_tree_min\n-                                        PARAMS((splay_tree));\n-extern int splay_tree_foreach           PARAMS((splay_tree,\n-\t\t\t\t\t        splay_tree_foreach_fn,\n-\t\t\t\t\t        void*));\n-extern int splay_tree_compare_ints      PARAMS((splay_tree_key,\n-\t\t\t\t\t\tsplay_tree_key));\n-extern int splay_tree_compare_pointers  PARAMS((splay_tree_key,\n-\t\t\t\t\t\tsplay_tree_key));\n-\t\t\t\t\t       \n-#ifdef __cplusplus\n-}\n-#endif /* __cplusplus */\n+extern splay_tree splay_tree_new (void);\n+extern splay_tree_node splay_tree_insert (splay_tree, splay_tree_key, splay_tree_value);\n+extern void splay_tree_remove (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_lookup (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_predecessor (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_successor (splay_tree, splay_tree_key);\n+extern splay_tree_node splay_tree_max (splay_tree);\n+extern splay_tree_node splay_tree_min (splay_tree);\n+extern int splay_tree_foreach (splay_tree, splay_tree_foreach_fn, void *);\n+extern void splay_tree_rebalance (splay_tree sp);\n+\n \n #endif /* _SPLAY_TREE_H */"}, {"sha": "2d51731d611ec2b9059be22a1e21f6282bcf6afb", "filename": "libmudflap/testsuite/libmudflap.c/heap-scalestress.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00dcddaaa05a2f435aec718b012d11a3bbdde2bf/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c?ref=00dcddaaa05a2f435aec718b012d11a3bbdde2bf", "patch": "@@ -0,0 +1,79 @@\n+/* zz30\n+ *\n+ * demonstrate a splay-tree depth problem\n+*/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+\n+#ifndef SCALE\n+#define SCALE 100000\n+#endif\n+\n+\n+struct list\n+{\n+  struct list *next;\n+};\n+\n+\n+int\n+main ()\n+{\n+  struct list *head = NULL;\n+  struct list *tail = NULL;\n+  struct list *p;\n+  long n;\n+  int direction;\n+\n+  for (direction = 0; direction < 2; direction++)\n+    {\n+      fprintf (stdout, \"allocating\\n\");\n+      fflush (stdout);\n+\n+      for (n = 0; n < SCALE; ++n)\n+\t{\n+\t  p = malloc (sizeof *p);\n+\t  if (NULL == p)\n+\t    {\n+\t      fprintf (stdout, \"malloc failed\\n\");\n+\t      break;\n+\t    }\n+\t  if (direction == 0)\n+\t    {\t\t\t/* add at tail */\n+\t      p->next = NULL;\n+\t      if (NULL != tail)\n+\t\ttail->next = p;\n+\t      else\n+\t\thead = p;\n+\t      tail = p;\n+\t    }\n+\t  else\n+\t    {\t\t\t/* add at head */\n+\t      p->next = head;\n+\t      if (NULL == tail)\n+\t\ttail = p;\n+\t      head = p;\n+\t    }\n+\t}\n+\n+      fprintf (stdout, \"freeing\\n\");\n+      fflush (stdout);\n+\n+      while (NULL != head)\n+\t{\n+\t  p = head;\n+\t  head = head->next;\n+\t  free (p);\n+\t}\n+\n+    }\n+\n+  fprintf (stdout, \"done\\n\");\n+  fflush (stdout);\n+\n+  return (0);\n+}\n+\n+/* { dg-output \"allocating.*freeing.*allocating.*freeing.*done\" } */"}]}