{"sha": "5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE2OGE5YjNkMDllM2RhMDNjYzUxYTA5ZmQyODgxM2ZmNmI0OWI5Ng==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T15:17:16Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-09T15:17:16Z"}, "message": "exp_ch6.adb (Expand_N_Extended_Return_Statement): Add self-checking code so if BIPAlloc is not passed in...\n\ngcc/ada/\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Add self-checking\n\tcode so if BIPAlloc is not passed in, it will likely raise\n\tProgram_Error instead of cause miscellaneous chaos.\n\t(Is_Build_In_Place_Result_Type): Return False if not Expander_Active,\n\tas for the other Is_B-I-P... functions.\n\t* sem_aggr.adb (Resolve_Extension_Aggregate): For an extension\n\taggregate whose ancestor part is a build-in-place call returning a\n\tnonlimited type, transform the assignment to the ancestor part to use a\n\ttemp.\n\t* sem_ch3.adb (Build_Itype_Reference): Handle the case where we're\n\tcreating an Itype for a library unit entity.\n\t(Check_Initialization): Avoid spurious error message on\n\tinternally-generated call.\n\t* sem_ch5.adb (Analyze_Assignment): Handle the case where the\n\tright-hand side is a build-in-place call. This didn't happen when b-i-p\n\twas only for limited types.\n\t* sem_ch6.adb (Create_Extra_Formals): Remove assumption that b-i-p\n\timplies >= Ada 2005.\n\t* sem_ch7.adb (Scan_Subprogram_Refs): Avoid traversing the same nodes\n\trepeatedly.\n\t* sem_util.adb (Next_Actual): Handle case of build-in-place call.\n\n2017-10-09  Arnaud Charlet  <charlet@adacore.com>\n\n\t* doc/gnat_ugn/gnat_and_program_execution.rst: Minor edit.\n\n2017-10-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* libgnarl/s-taprob.adb: Minor whitespace fix.\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* namet.ads: Minor comment fix.\n\n2017-10-09  Piotr Trojanek  <trojanek@adacore.com>\n\n\t* sem_aux.adb (Unit_Declaration_Node): Detect protected declarations,\n\tjust like other program units listed in Ada RM 10.1(1).\n\n2017-10-09  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch8.adb (Update_Chain_In_Scope): Modify warning messages.\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Associations, Check_Generic_Parent): If an\n\tactual for a formal package is an instantiation of a child unit, create\n\ta freeze node for the instance of the parent if it appears in the same\n\tscope and is not frozen yet.\n\n2017-10-09  Pierre-Marie de Rodat  <derodat@adacore.com>\n\n\t* exp_atag.ads, libgnat/a-tags.adb, libgnat/a-tags.ads: Enhance\n\tin-source documentation for tagged types's Offset_To_Top.\n\n2017-10-09  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch3.adb (Build_Assignment): Parameter name N was somewhat\n\tconfusing.  Same for N_Loc.  Remove assumption that b-i-p implies\n\tlimited.  This is for the case of a function call that occurs as the\n\tdefault for a record component.\n\t(Expand_N_Object_Declaration): Deal with the case where expansion has\n\tcreated an object declaration initialized with something like\n\tF(...)'Reference.\n\t* exp_ch3.adb: Minor reformatting.\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_attr.adb (Expand_Attribute_Reference, case 'Valid): The prefix of\n\tthe attribute is an object, but it may appear within a conversion. The\n\tobject itself must be retrieved when generating the range test that\n\timplements the validity check on a scalar type.\n\ngcc/testsuite/\n\n2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat.dg/validity_check2.adb, gnat.dg/validity_check2_pkg.ads:\n\tNew testcase.\n\nFrom-SVN: r253548", "tree": {"sha": "8ff8cd31df95b0fe86d1fba7f00ccbd8fb78cffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ff8cd31df95b0fe86d1fba7f00ccbd8fb78cffa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/comments", "author": null, "committer": null, "parents": [{"sha": "18b4306c0a150f144cddaf85ed814893b3b44b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b4306c0a150f144cddaf85ed814893b3b44b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18b4306c0a150f144cddaf85ed814893b3b44b81"}], "stats": {"total": 578, "additions": 495, "deletions": 83}, "files": [{"sha": "2ba6e707def8d8f692d137dbe3e9088a79f31d7b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -1,3 +1,78 @@\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_N_Extended_Return_Statement): Add self-checking\n+\tcode so if BIPAlloc is not passed in, it will likely raise\n+\tProgram_Error instead of cause miscellaneous chaos.\n+\t(Is_Build_In_Place_Result_Type): Return False if not Expander_Active,\n+\tas for the other Is_B-I-P... functions.\n+\t* sem_aggr.adb (Resolve_Extension_Aggregate): For an extension\n+\taggregate whose ancestor part is a build-in-place call returning a\n+\tnonlimited type, transform the assignment to the ancestor part to use a\n+\ttemp.\n+\t* sem_ch3.adb (Build_Itype_Reference): Handle the case where we're\n+\tcreating an Itype for a library unit entity.\n+\t(Check_Initialization): Avoid spurious error message on\n+\tinternally-generated call.\n+\t* sem_ch5.adb (Analyze_Assignment): Handle the case where the\n+\tright-hand side is a build-in-place call. This didn't happen when b-i-p\n+\twas only for limited types.\n+\t* sem_ch6.adb (Create_Extra_Formals): Remove assumption that b-i-p\n+\timplies >= Ada 2005.\n+\t* sem_ch7.adb (Scan_Subprogram_Refs): Avoid traversing the same nodes\n+\trepeatedly.\n+\t* sem_util.adb (Next_Actual): Handle case of build-in-place call.\n+\n+2017-10-09  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* doc/gnat_ugn/gnat_and_program_execution.rst: Minor edit.\n+\n+2017-10-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* libgnarl/s-taprob.adb: Minor whitespace fix.\n+\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* namet.ads: Minor comment fix.\n+\n+2017-10-09  Piotr Trojanek  <trojanek@adacore.com>\n+\n+\t* sem_aux.adb (Unit_Declaration_Node): Detect protected declarations,\n+\tjust like other program units listed in Ada RM 10.1(1).\n+\n+2017-10-09  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch8.adb (Update_Chain_In_Scope): Modify warning messages.\n+\n+2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Associations, Check_Generic_Parent): If an\n+\tactual for a formal package is an instantiation of a child unit, create\n+\ta freeze node for the instance of the parent if it appears in the same\n+\tscope and is not frozen yet.\n+\n+2017-10-09  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* exp_atag.ads, libgnat/a-tags.adb, libgnat/a-tags.ads: Enhance\n+\tin-source documentation for tagged types's Offset_To_Top.\n+\n+2017-10-09  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch3.adb (Build_Assignment): Parameter name N was somewhat\n+\tconfusing.  Same for N_Loc.  Remove assumption that b-i-p implies\n+\tlimited.  This is for the case of a function call that occurs as the\n+\tdefault for a record component.\n+\t(Expand_N_Object_Declaration): Deal with the case where expansion has\n+\tcreated an object declaration initialized with something like\n+\tF(...)'Reference.\n+\t* exp_ch3.adb: Minor reformatting.\n+\n+2017-10-09  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_attr.adb (Expand_Attribute_Reference, case 'Valid): The prefix of\n+\tthe attribute is an object, but it may appear within a conversion. The\n+\tobject itself must be retrieved when generating the range test that\n+\timplements the validity check on a scalar type.\n+\n 2017-10-05  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR ada/82393"}, {"sha": "ac45cee3305612c0b0bf93bd08064840da5edc02", "filename": "gcc/ada/doc/gnat_ugn/gnat_and_program_execution.rst", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fgnat_and_program_execution.rst?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -4093,9 +4093,8 @@ execution of this erroneous program:\n   ``gnatmem`` makes use of the output created by the special version of\n   allocation and deallocation routines that record call information. This allows\n   it to obtain accurate dynamic memory usage history at a minimal cost to the\n-  execution speed. Note however, that ``gnatmem`` is not supported on all\n-  platforms (currently, it is supported on AIX, HP-UX, GNU/Linux, Solaris and\n-  Windows).\n+  execution speed. Note however, that ``gnatmem`` is only supported on\n+  GNU/Linux and Windows.\n \n   The ``gnatmem`` command has the form\n "}, {"sha": "73af9a0505984a3a74e65ed45dd51c2592d8c534", "filename": "gcc/ada/exp_atag.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_atag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_atag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_atag.ads?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2006-2016, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2006-2017, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -147,7 +147,7 @@ package Exp_Atag is\n    --\n    --  Generates:\n    --    Offset_To_Top_Ptr\n-   --      (Address!(Tag_Ptr!(This).all) - Offset_To_Top_Offset)\n+   --      (Address!(Tag_Ptr!(This).all) - Offset_To_Top_Offset).all\n \n    function Build_Set_Predefined_Prim_Op_Address\n      (Loc          : Source_Ptr;"}, {"sha": "719699566e4ceb57c766a5cae01ce2f8d542b6f3", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -6512,7 +6512,9 @@ package body Exp_Attr is\n          begin\n             --  The prefix of attribute 'Valid should always denote an object\n             --  reference. The reference is either coming directly from source\n-            --  or is produced by validity check expansion.\n+            --  or is produced by validity check expansion. The object may be\n+            --  wrapped in a conversion in which case the call to Unqual_Conv\n+            --  will yield it.\n \n             --  If the prefix denotes a variable which captures the value of\n             --  an object for validation purposes, use the variable in the\n@@ -6523,7 +6525,7 @@ package body Exp_Attr is\n             --    if not Temp in ... then\n \n             if Is_Validation_Variable_Reference (Pref) then\n-               Temp := New_Occurrence_Of (Entity (Pref), Loc);\n+               Temp := New_Occurrence_Of (Entity (Unqual_Conv (Pref)), Loc);\n \n             --  Otherwise the prefix is either a source object or a constant\n             --  produced by validity check expansion. Generate:"}, {"sha": "514e4d2ebafa10d39f8e3ebb383747e24459b339", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -1711,10 +1711,11 @@ package body Exp_Ch3 is\n       Rec_Type  : Entity_Id;\n       Set_Tag   : Entity_Id := Empty;\n \n-      function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id;\n-      --  Build an assignment statement which assigns the default expression\n-      --  to its corresponding record component if defined. The left hand side\n-      --  of the assignment is marked Assignment_OK so that initialization of\n+      function Build_Assignment\n+        (Id : Entity_Id; Default : Node_Id) return List_Id;\n+      --  Build an assignment statement that assigns the default expression to\n+      --  its corresponding record component if defined. The left-hand side of\n+      --  the assignment is marked Assignment_OK so that initialization of\n       --  limited private records works correctly. This routine may also build\n       --  an adjustment call if the component is controlled.\n \n@@ -1783,13 +1784,15 @@ package body Exp_Ch3 is\n       -- Build_Assignment --\n       ----------------------\n \n-      function Build_Assignment (Id : Entity_Id; N : Node_Id) return List_Id is\n-         N_Loc : constant Source_Ptr := Sloc (N);\n+      function Build_Assignment\n+        (Id : Entity_Id; Default : Node_Id) return List_Id\n+      is\n+         Default_Loc : constant Source_Ptr := Sloc (Default);\n          Typ   : constant Entity_Id := Underlying_Type (Etype (Id));\n \n          Adj_Call : Node_Id;\n-         Exp      : Node_Id   := N;\n-         Kind     : Node_Kind := Nkind (N);\n+         Exp      : Node_Id   := Default;\n+         Kind     : Node_Kind := Nkind (Default);\n          Lhs      : Node_Id;\n          Res      : List_Id;\n \n@@ -1815,10 +1818,11 @@ package body Exp_Ch3 is\n               and then Present (Discriminal_Link (Entity (N)))\n             then\n                Val :=\n-                 Make_Selected_Component (N_Loc,\n+                 Make_Selected_Component (Default_Loc,\n                    Prefix        => New_Copy_Tree (Lhs),\n                    Selector_Name =>\n-                     New_Occurrence_Of (Discriminal_Link (Entity (N)), N_Loc));\n+                     New_Occurrence_Of\n+                       (Discriminal_Link (Entity (N)), Default_Loc));\n \n                if Present (Val) then\n                   Rewrite (N, New_Copy_Tree (Val));\n@@ -1835,9 +1839,9 @@ package body Exp_Ch3 is\n \n       begin\n          Lhs :=\n-           Make_Selected_Component (N_Loc,\n+           Make_Selected_Component (Default_Loc,\n              Prefix        => Make_Identifier (Loc, Name_uInit),\n-             Selector_Name => New_Occurrence_Of (Id, N_Loc));\n+             Selector_Name => New_Occurrence_Of (Id, Default_Loc));\n          Set_Assignment_OK (Lhs);\n \n          if Nkind (Exp) = N_Aggregate\n@@ -1866,16 +1870,16 @@ package body Exp_Ch3 is\n          --  traversing the expression. ???\n \n          if Kind = N_Attribute_Reference\n-           and then Nam_In (Attribute_Name (N), Name_Unchecked_Access,\n+           and then Nam_In (Attribute_Name (Default), Name_Unchecked_Access,\n                                                 Name_Unrestricted_Access)\n-           and then Is_Entity_Name (Prefix (N))\n-           and then Is_Type (Entity (Prefix (N)))\n-           and then Entity (Prefix (N)) = Rec_Type\n+           and then Is_Entity_Name (Prefix (Default))\n+           and then Is_Type (Entity (Prefix (Default)))\n+           and then Entity (Prefix (Default)) = Rec_Type\n          then\n             Exp :=\n-              Make_Attribute_Reference (N_Loc,\n+              Make_Attribute_Reference (Default_Loc,\n                 Prefix         =>\n-                  Make_Identifier (N_Loc, Name_uInit),\n+                  Make_Identifier (Default_Loc, Name_uInit),\n                 Attribute_Name => Name_Unrestricted_Access);\n          end if;\n \n@@ -1899,33 +1903,34 @@ package body Exp_Ch3 is\n \n          if Is_Tagged_Type (Typ) and then Tagged_Type_Expansion then\n             Append_To (Res,\n-              Make_Assignment_Statement (N_Loc,\n+              Make_Assignment_Statement (Default_Loc,\n                 Name       =>\n-                  Make_Selected_Component (N_Loc,\n+                  Make_Selected_Component (Default_Loc,\n                     Prefix        =>\n                       New_Copy_Tree (Lhs, New_Scope => Proc_Id),\n                     Selector_Name =>\n-                      New_Occurrence_Of (First_Tag_Component (Typ), N_Loc)),\n+                      New_Occurrence_Of\n+                        (First_Tag_Component (Typ), Default_Loc)),\n \n                 Expression =>\n                   Unchecked_Convert_To (RTE (RE_Tag),\n                     New_Occurrence_Of\n                       (Node\n                         (First_Elmt\n                           (Access_Disp_Table (Underlying_Type (Typ)))),\n-                       N_Loc))));\n+                       Default_Loc))));\n          end if;\n \n          --  Adjust the component if controlled except if it is an aggregate\n          --  that will be expanded inline.\n \n          if Kind = N_Qualified_Expression then\n-            Kind := Nkind (Expression (N));\n+            Kind := Nkind (Expression (Default));\n          end if;\n \n          if Needs_Finalization (Typ)\n            and then not (Nkind_In (Kind, N_Aggregate, N_Extension_Aggregate))\n-           and then not Is_Limited_View (Typ)\n+           and then not Is_Build_In_Place_Function_Call (Exp)\n          then\n             Adj_Call :=\n               Make_Adjust_Call\n@@ -6308,6 +6313,23 @@ package body Exp_Ch3 is\n \n             return;\n \n+         --  This is the same as the previous 'elsif', except that the call has\n+         --  been transformed by other expansion activities into something like\n+         --  F(...)'Reference.\n+\n+         elsif Nkind (Expr_Q) = N_Reference\n+           and then Is_Build_In_Place_Function_Call (Prefix (Expr_Q))\n+           and then not Is_Expanded_Build_In_Place_Call\n+             (Unqual_Conv (Prefix (Expr_Q)))\n+         then\n+            Make_Build_In_Place_Call_In_Anonymous_Context (Prefix (Expr_Q));\n+\n+            --  The previous call expands the expression initializing the\n+            --  built-in-place object into further code that will be analyzed\n+            --  later. No further expansion needed here.\n+\n+            return;\n+\n          --  Ada 2005 (AI-318-02): Specialization of the previous case for\n          --  expressions containing a build-in-place function call whose\n          --  returned object covers interface types, and Expr_Q has calls to"}, {"sha": "9204179fee7b431b6cf74942e58cf0fd1164e27a", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 35, "deletions": 8, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -5298,16 +5298,39 @@ package body Exp_Ch6 is\n                                   Temp_Typ   => Ref_Type,\n                                   Func_Id    => Func_Id,\n                                   Ret_Typ    => Ret_Obj_Typ,\n-                                  Alloc_Expr => Heap_Allocator)))),\n+                                  Alloc_Expr => Heap_Allocator))),\n+\n+                           --  ???If all is well, we can put the following\n+                           --  'elsif' in the 'else', but this is a useful\n+                           --  self-check in case caller and callee don't agree\n+                           --  on whether BIPAlloc and so on should be passed.\n+\n+                           Make_Elsif_Part (Loc,\n+                             Condition =>\n+                               Make_Op_Eq (Loc,\n+                                 Left_Opnd  =>\n+                                   New_Occurrence_Of (Obj_Alloc_Formal, Loc),\n+                                 Right_Opnd =>\n+                                   Make_Integer_Literal (Loc,\n+                                     UI_From_Int (BIP_Allocation_Form'Pos\n+                                                    (User_Storage_Pool)))),\n+\n+                             Then_Statements => New_List (\n+                               Pool_Decl,\n+                               Build_Heap_Allocator\n+                                 (Temp_Id    => Alloc_Obj_Id,\n+                                  Temp_Typ   => Ref_Type,\n+                                  Func_Id    => Func_Id,\n+                                  Ret_Typ    => Ret_Obj_Typ,\n+                                  Alloc_Expr => Pool_Allocator)))),\n+\n+                         --  Raise Program_Error if it's none of the above;\n+                         --  this is a compiler bug. ???PE_All_Guards_Closed\n+                         --  is bogus; we should have a new code.\n \n                          Else_Statements => New_List (\n-                           Pool_Decl,\n-                           Build_Heap_Allocator\n-                             (Temp_Id    => Alloc_Obj_Id,\n-                              Temp_Typ   => Ref_Type,\n-                              Func_Id    => Func_Id,\n-                              Ret_Typ    => Ret_Obj_Typ,\n-                              Alloc_Expr => Pool_Allocator)));\n+                           Make_Raise_Program_Error (Loc,\n+                              Reason => PE_All_Guards_Closed)));\n \n                      --  If a separate initialization assignment was created\n                      --  earlier, append that following the assignment of the\n@@ -7205,6 +7228,10 @@ package body Exp_Ch6 is\n \n    function Is_Build_In_Place_Result_Type (Typ : Entity_Id) return Boolean is\n    begin\n+      if not Expander_Active then\n+         return False;\n+      end if;\n+\n       --  In Ada 2005 all functions with an inherently limited return type\n       --  must be handled using a build-in-place profile, including the case\n       --  of a function with a limited interface result, where the function"}, {"sha": "c4d33c533655474c0fdb6cd6c9bbd053bf97688b", "filename": "gcc/ada/libgnarl/s-taprob.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnarl%2Fs-taprob.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnarl%2Fs-taprob.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprob.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -75,7 +75,7 @@ package body System.Tasking.Protected_Objects is\n \n    begin\n       if Init_Priority = Unspecified_Priority then\n-         Init_Priority  := System.Priority'Last;\n+         Init_Priority := System.Priority'Last;\n       end if;\n \n       Initialize_Lock (Init_Priority, Object.L'Access);"}, {"sha": "f3c2c0e969c5ed2693ac4fbe4c0ecfa701870c92", "filename": "gcc/ada/libgnat/a-tags.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnat%2Fa-tags.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnat%2Fa-tags.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tags.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -842,9 +842,21 @@ package body Ada.Tags is\n    begin\n       Curr_DT := DT (To_Tag_Ptr (This).all);\n \n+      --  See the documentation of Dispatch_Table_Wrapper.Offset_To_Top\n+\n       if Curr_DT.Offset_To_Top = SSE.Storage_Offset'Last then\n+\n+         --  The parent record type has variable-size components, so the\n+         --  instance-specific offset is stored in the tagged record, right\n+         --  after the reference to Curr_DT (which is a secondary dispatch\n+         --  table).\n+\n          return To_Storage_Offset_Ptr (This + Tag_Size).all;\n+\n       else\n+         --  The offset is compile-time known, so it is simply stored in the\n+         --  Offset_To_Top field.\n+\n          return Curr_DT.Offset_To_Top;\n       end if;\n    end Offset_To_Top;"}, {"sha": "a11cdd4a44dad71d9a09a63c13bda5f6822ac646", "filename": "gcc/ada/libgnat/a-tags.ads", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnat%2Fa-tags.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Flibgnat%2Fa-tags.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tags.ads?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -380,12 +380,21 @@ private\n       --  Prims_Ptr table.\n \n       Offset_To_Top : SSE.Storage_Offset;\n-      TSD           : System.Address;\n+      --  Offset between the _Tag field and the field that contains the\n+      --  reference to this dispatch table. For primary dispatch tables it is\n+      --  zero. For secondary dispatch tables: if the parent record type (if\n+      --  any) has a compile-time-known size, then Offset_To_Top contains the\n+      --  expected value, otherwise it contains SSE.Storage_Offset'Last and the\n+      --  actual offset is to be found in the tagged record, right after the\n+      --  field that contains the reference to this dispatch table. See the\n+      --  implementation of Ada.Tags.Offset_To_Top for the corresponding logic.\n+\n+      TSD : System.Address;\n \n       Prims_Ptr : aliased Address_Array (1 .. Num_Prims);\n       --  The size of the Prims_Ptr array actually depends on the tagged type\n       --  to which it applies. For each tagged type, the expander computes the\n-      --  actual array size, allocates the Dispatch_Table record accordingly.\n+      --  actual array size, allocating the Dispatch_Table record accordingly.\n    end record;\n \n    type Dispatch_Table_Ptr is access all Dispatch_Table_Wrapper;"}, {"sha": "72ac8fabf30d2146948d24966702ad2ad0c4df3f", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -477,7 +477,7 @@ package Namet is\n    --  Sets the Int value associated with the given name\n \n    function Is_Internal_Name (Id : Name_Id) return Boolean;\n-   --  Returns True if the name is an internal name (i.e. contains a character\n+   --  Returns True if the name is an internal name, i.e. contains a character\n    --  for which Is_OK_Internal_Letter is true, or if the name starts or ends\n    --  with an underscore.\n    --"}, {"sha": "e361bacaa1474ff5715908b4f178fb2ced6ffbc1", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -30,6 +30,7 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Expander; use Expander;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n@@ -2932,6 +2933,11 @@ package body Sem_Aggr is\n       --  Verify that the type of the ancestor part is a non-private ancestor\n       --  of the expected type, which must be a type extension.\n \n+      procedure Transform_BIP_Assignment (Typ : Entity_Id);\n+      --  For an extension aggregate whose ancestor part is a build-in-place\n+      --  call returning a nonlimited type, this is used to transform the\n+      --  assignment to the ancestor part to use a temp.\n+\n       ----------------------------\n       -- Valid_Limited_Ancestor --\n       ----------------------------\n@@ -3013,6 +3019,23 @@ package body Sem_Aggr is\n          return False;\n       end Valid_Ancestor_Type;\n \n+      procedure Transform_BIP_Assignment (Typ : Entity_Id) is\n+         Loc : constant Source_Ptr := Sloc (N);\n+         Def_Id : constant Entity_Id := Make_Temporary (Loc, 'Y', A);\n+         Obj_Decl : constant Node_Id :=\n+           Make_Object_Declaration\n+             (Loc,\n+              Defining_Identifier => Def_Id,\n+              Constant_Present => True,\n+              Object_Definition => New_Occurrence_Of (Typ, Loc),\n+              Expression => A,\n+              Has_Init_Expression => True);\n+      begin\n+         Set_Etype (Def_Id, Typ);\n+         Set_Ancestor_Part (N, New_Occurrence_Of (Def_Id, Loc));\n+         Insert_Action (N, Obj_Decl);\n+      end Transform_BIP_Assignment;\n+\n    --  Start of processing for Resolve_Extension_Aggregate\n \n    begin\n@@ -3081,7 +3104,7 @@ package body Sem_Aggr is\n             Get_First_Interp (A, I, It);\n             while Present (It.Typ) loop\n \n-               --  Only consider limited interpretations in the Ada 2005 case\n+               --  Consider limited interpretations if Ada 2005 or higher\n \n                if Is_Tagged_Type (It.Typ)\n                  and then (Ada_Version >= Ada_2005\n@@ -3177,6 +3200,18 @@ package body Sem_Aggr is\n \n                Error_Msg_N (\"ancestor part must be statically tagged\", A);\n             else\n+               --  We are using the build-in-place protocol, but we can't build\n+               --  in place, because we need to call the function before\n+               --  allocating the aggregate. Could do better for null\n+               --  extensions, and maybe for nondiscriminated types.\n+               --  This is wrong for limited, but those were wrong already.\n+\n+               if not Is_Limited_View (A_Type)\n+                 and then Is_Build_In_Place_Function_Call (A)\n+               then\n+                  Transform_BIP_Assignment (A_Type);\n+               end if;\n+\n                Resolve_Record_Aggregate (N, Typ);\n             end if;\n          end if;"}, {"sha": "d34ed078be7387c5fd4e3a654efb55102756bae8", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -1693,6 +1693,7 @@ package body Sem_Aux is\n         and then Nkind (N) /= N_Package_Renaming_Declaration\n         and then Nkind (N) /= N_Procedure_Instantiation\n         and then Nkind (N) /= N_Protected_Body\n+        and then Nkind (N) /= N_Protected_Type_Declaration\n         and then Nkind (N) /= N_Subprogram_Declaration\n         and then Nkind (N) /= N_Subprogram_Body\n         and then Nkind (N) /= N_Subprogram_Body_Stub"}, {"sha": "aeec421b5a362bf7df30e6caafc7c7d165cca908", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -1903,7 +1903,8 @@ package body Sem_Ch12 is\n                      --  body.\n \n                      Explicit_Freeze_Check : declare\n-                        Actual : constant Entity_Id := Entity (Match);\n+                        Actual  : constant Entity_Id := Entity (Match);\n+                        Gen_Par : Entity_Id;\n \n                         Needs_Freezing : Boolean;\n                         S              : Entity_Id;\n@@ -1912,38 +1913,83 @@ package body Sem_Ch12 is\n                         --  The actual may be an instantiation of a unit\n                         --  declared in a previous instantiation. If that\n                         --  one is also in the current compilation, it must\n-                        --  itself be frozen before the actual.\n+                        --  itself be frozen before the actual. The actual\n+                        --  may be an instantiation of a generic child unit,\n+                        --  in which case the same applies to the instance\n+                        --  of the parent which must be frozen before the\n+                        --  actual.\n                         --  Should this itself be recursive ???\n \n                         --------------------------\n                         -- Check_Generic_Parent --\n                         --------------------------\n \n                         procedure Check_Generic_Parent is\n-                           Par : Entity_Id;\n+                           Inst : constant Node_Id :=\n+                              Next (Unit_Declaration_Node (Actual));\n+                           Par  : Entity_Id;\n \n                         begin\n-                           if Nkind (Parent (Actual)) =\n-                                N_Package_Specification\n+                           Par := Empty;\n+\n+                           if Nkind (Parent (Actual)) = N_Package_Specification\n                            then\n                               Par := Scope (Generic_Parent (Parent (Actual)));\n-\n-                              if Is_Generic_Instance (Par)\n-                                and then Scope (Par) = Current_Scope\n-                                and then\n-                                  (No (Freeze_Node (Par))\n-                                    or else\n-                                      not Is_List_Member (Freeze_Node (Par)))\n+                              if Is_Generic_Instance (Par) then\n+                                 null;\n+\n+                              --  If the actual is a child generic unit, check\n+                              --  whether the instantiation of the parent is\n+                              --  also local and must also be frozen now.\n+                              --  We must retrieve the instance node to locate\n+                              --  the parent instance if any.\n+\n+                              elsif Ekind (Par) = E_Generic_Package\n+                                  and then Is_Child_Unit (Gen_Par)\n+                                  and then Ekind (Scope (Gen_Par))\n+                                     = E_Generic_Package\n                               then\n-                                 Set_Has_Delayed_Freeze (Par);\n-                                 Append_Elmt (Par, Actuals_To_Freeze);\n+                                 if Nkind (Inst) = N_Package_Instantiation\n+                                   and then\n+                                     Nkind (Name (Inst)) = N_Expanded_Name\n+                                 then\n+\n+                                    --  Retrieve entity of psarent instance.\n+\n+                                    Par := Entity (Prefix (Name (Inst)));\n+                                 end if;\n+\n+                              else\n+                                 Par := Empty;\n                               end if;\n                            end if;\n+\n+                           if Present (Par)\n+                             and then Is_Generic_Instance (Par)\n+                             and then Scope (Par) = Current_Scope\n+                             and then\n+                               (No (Freeze_Node (Par))\n+                                 or else\n+                                   not Is_List_Member (Freeze_Node (Par)))\n+                           then\n+                              Set_Has_Delayed_Freeze (Par);\n+                              Append_Elmt (Par, Actuals_To_Freeze);\n+                           end if;\n                         end Check_Generic_Parent;\n \n                      --  Start of processing for Explicit_Freeze_Check\n \n                      begin\n+                        if Present (Renamed_Entity (Actual)) then\n+                           Gen_Par :=\n+                             Generic_Parent (Specification (\n+                               Unit_Declaration_Node (\n+                                 Renamed_Entity (Actual))));\n+                        else\n+                           Gen_Par := Generic_Parent\n+                             (Specification (Unit_Declaration_Node (Actual)));\n+                        end if;\n+\n                         if not Expander_Active\n                           or else not Has_Completion (Actual)\n                           or else not In_Same_Source_Unit (I_Node, Actual)"}, {"sha": "eea0778c1a2a0b0f5968072d5d70f64f7a3a761c", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -10257,7 +10257,22 @@ package body Sem_Ch3 is\n          return;\n       else\n          Set_Itype (IR, Ityp);\n-         Insert_After (Nod, IR);\n+\n+         --  If Nod is a library unit entity, then Insert_After won't work,\n+         --  because Nod is not a member of any list. Therefore, we use\n+         --  Add_Global_Declaration in this case. This can happen if we have a\n+         --  build-in-place library function.\n+\n+         if (Nkind (Nod) in N_Entity\n+               and then Is_Compilation_Unit (Nod))\n+           or else\n+             (Nkind (Nod) = N_Defining_Program_Unit_Name\n+                and then Is_Compilation_Unit (Defining_Identifier (Nod)))\n+         then\n+            Add_Global_Declaration (IR);\n+         else\n+            Insert_After (Nod, IR);\n+         end if;\n       end if;\n    end Build_Itype_Reference;\n \n@@ -11777,9 +11792,20 @@ package body Sem_Ch3 is\n                if Nkind (Exp) = N_Type_Conversion\n                  and then Nkind (Expression (Exp)) = N_Function_Call\n                then\n-                  Error_Msg_N\n-                    (\"illegal context for call\"\n-                      & \" to function with limited result\", Exp);\n+                  --  No error for internally-generated object declarations,\n+                  --  which can come from build-in-place assignment statements.\n+\n+                  if Nkind (Parent (Exp)) = N_Object_Declaration\n+                    and then not Comes_From_Source\n+                                   (Defining_Identifier (Parent (Exp)))\n+                  then\n+                     null;\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"illegal context for call\"\n+                          & \" to function with limited result\", Exp);\n+                  end if;\n \n                else\n                   Error_Msg_N"}, {"sha": "54d0a8600d20e02e4edd43266715df48e4bb9629", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 108, "deletions": 11, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -101,13 +101,7 @@ package body Sem_Ch5 is\n \n    procedure Analyze_Assignment (N : Node_Id) is\n       Lhs : constant Node_Id := Name (N);\n-      Rhs : constant Node_Id := Expression (N);\n-\n-      Decl : Node_Id;\n-      T1   : Entity_Id;\n-      T2   : Entity_Id;\n-\n-      Save_Full_Analysis : Boolean := False;  -- initialize to prevent warning\n+      Rhs : Node_Id          := Expression (N);\n \n       procedure Diagnose_Non_Variable_Lhs (N : Node_Id);\n       --  N is the node for the left hand side of an assignment, and it is not\n@@ -126,6 +120,93 @@ package body Sem_Ch5 is\n       --  nominal subtype. This procedure is used to deal with cases where the\n       --  nominal subtype must be replaced by the actual subtype.\n \n+      procedure Transform_BIP_Assignment (Typ : Entity_Id);\n+      function Should_Transform_BIP_Assignment\n+        (Typ : Entity_Id) return Boolean;\n+      --  If the right-hand side of an assignment statement is a build-in-place\n+      --  call we cannot build in place, so we insert a temp initialized with\n+      --  the call, and transform the assignment statement to copy the temp.\n+      --  Transform_BIP_Assignment does the tranformation, and\n+      --  Should_Transform_BIP_Assignment determines whether we should.\n+      --  The same goes for qualified expressions and conversions whose\n+      --  operand is such a call.\n+      --\n+      --  This is only for nonlimited types; assignment statements are illegal\n+      --  for limited types, but are generated internally for aggregates and\n+      --  init procs. These limited-type are not really assignment statements\n+      --  -- conceptually, they are initializations, so should not be\n+      --  transformed.\n+      --\n+      --  Similarly, for nonlimited types, aggregates and init procs generate\n+      --  assignment statements that are really initializations. These are\n+      --  marked No_Ctrl_Actions.\n+\n+      function Should_Transform_BIP_Assignment\n+        (Typ : Entity_Id) return Boolean\n+      is\n+         Result : Boolean;\n+      begin\n+         if Expander_Active\n+           and then not Is_Limited_View (Typ)\n+           and then Is_Build_In_Place_Result_Type (Typ)\n+           and then not No_Ctrl_Actions (N)\n+         then\n+            --  This function is called early, before name resolution is\n+            --  complete, so we have to deal with things that might turn into\n+            --  function calls later. N_Function_Call and N_Op nodes are the\n+            --  obvious case. An N_Identifier or N_Expanded_Name is a\n+            --  parameterless function call if it denotes a function.\n+            --  Finally, an attribute reference can be a function call.\n+\n+            case Nkind (Unqual_Conv (Rhs)) is\n+               when N_Function_Call | N_Op =>\n+                  Result := True;\n+               when N_Identifier | N_Expanded_Name =>\n+                  case Ekind (Entity (Unqual_Conv (Rhs))) is\n+                     when E_Function | E_Operator =>\n+                        Result := True;\n+                     when others =>\n+                        Result := False;\n+                  end case;\n+               when N_Attribute_Reference =>\n+                  Result := Attribute_Name (Unqual_Conv (Rhs)) = Name_Input;\n+                  --  T'Input will turn into a call whose result type is T\n+               when others =>\n+                  Result := False;\n+            end case;\n+         else\n+            Result := False;\n+         end if;\n+         return Result;\n+      end Should_Transform_BIP_Assignment;\n+\n+      procedure Transform_BIP_Assignment (Typ : Entity_Id) is\n+         --  Tranform \"X : [constant] T := F (...);\" into:\n+         --\n+         --     Temp : constant T := F (...);\n+         --     X := Temp;\n+\n+         Loc : constant Source_Ptr := Sloc (N);\n+         Def_Id : constant Entity_Id := Make_Temporary (Loc, 'Y', Rhs);\n+         Obj_Decl : constant Node_Id :=\n+           Make_Object_Declaration\n+             (Loc,\n+              Defining_Identifier => Def_Id,\n+              Constant_Present => True,\n+              Object_Definition => New_Occurrence_Of (Typ, Loc),\n+              Expression => Rhs,\n+              Has_Init_Expression => True);\n+      begin\n+         Set_Etype (Def_Id, Typ);\n+         Set_Expression (N, New_Occurrence_Of (Def_Id, Loc));\n+\n+         --  At this point, Rhs is no longer equal to Expression (N), so:\n+\n+         Rhs := Expression (N);\n+\n+         Insert_Action (N, Obj_Decl);\n+      end Transform_BIP_Assignment;\n+\n       -------------------------------\n       -- Diagnose_Non_Variable_Lhs --\n       -------------------------------\n@@ -232,6 +313,7 @@ package body Sem_Ch5 is\n         (Opnd      : Node_Id;\n          Opnd_Type : in out Entity_Id)\n       is\n+         Decl : Node_Id;\n       begin\n          Require_Entity (Opnd);\n \n@@ -284,6 +366,11 @@ package body Sem_Ch5 is\n \n       --  Local variables\n \n+      T1 : Entity_Id;\n+      T2 : Entity_Id;\n+\n+      Save_Full_Analysis : Boolean;\n+\n       Saved_GM : constant Ghost_Mode_Type := Ghost_Mode;\n       --  Save the Ghost mode to restore on exit\n \n@@ -360,8 +447,9 @@ package body Sem_Ch5 is\n                   null;\n \n                elsif Has_Compatible_Type (Rhs, It.Typ) then\n-                  if T1 /= Any_Type then\n-\n+                  if T1 = Any_Type then\n+                     T1 := It.Typ;\n+                  else\n                      --  An explicit dereference is overloaded if the prefix\n                      --  is. Try to remove the ambiguity on the prefix, the\n                      --  error will be posted there if the ambiguity is real.\n@@ -412,8 +500,6 @@ package body Sem_Ch5 is\n                           (\"ambiguous left-hand side in assignment\", Lhs);\n                         exit;\n                      end if;\n-                  else\n-                     T1 := It.Typ;\n                   end if;\n                end if;\n \n@@ -429,6 +515,15 @@ package body Sem_Ch5 is\n          end if;\n       end if;\n \n+      --  Deal with build-in-place calls for nonlimited types.\n+      --  We don't do this later, because resolving the rhs\n+      --  tranforms it incorrectly for build-in-place.\n+\n+      if Should_Transform_BIP_Assignment (Typ => T1) then\n+         Transform_BIP_Assignment (Typ => T1);\n+      end if;\n+      pragma Assert (not Should_Transform_BIP_Assignment (Typ => T1));\n+\n       --  The resulting assignment type is T1, so now we will resolve the left\n       --  hand side of the assignment using this determined type.\n \n@@ -971,6 +1066,8 @@ package body Sem_Ch5 is\n          Expander_Mode_Restore;\n          Full_Analysis := Save_Full_Analysis;\n       end if;\n+\n+      pragma Assert (not Should_Transform_BIP_Assignment (Typ => T1));\n    end Analyze_Assignment;\n \n    -----------------------------"}, {"sha": "3e892f836add21686b7c6218905e200d74841d2e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -8002,7 +8002,7 @@ package body Sem_Ch6 is\n       --  Ada 2005 (AI-318-02): In the case of build-in-place functions, add\n       --  appropriate extra formals. See type Exp_Ch6.BIP_Formal_Kind.\n \n-      if Ada_Version >= Ada_2005 and then Is_Build_In_Place_Function (E) then\n+      if Is_Build_In_Place_Function (E) then\n          declare\n             Result_Subt : constant Entity_Id := Etype (E);\n             Full_Subt   : constant Entity_Id := Available_View (Result_Subt);"}, {"sha": "1565662ca1263c5616ffa5d8dbebde803f20f029", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -199,27 +199,37 @@ package body Sem_Ch7 is\n    subtype Entity_Header_Num is Integer range 0 .. Entity_Table_Size - 1;\n    --  Range of headers in hash table\n \n-   function Entity_Hash (Id : Entity_Id) return Entity_Header_Num;\n+   function Node_Hash (Id : Entity_Id) return Entity_Header_Num;\n    --  Simple hash function for Entity_Ids\n \n    package Subprogram_Table is new GNAT.Htable.Simple_HTable\n      (Header_Num => Entity_Header_Num,\n       Element    => Boolean,\n       No_Element => False,\n       Key        => Entity_Id,\n-      Hash       => Entity_Hash,\n+      Hash       => Node_Hash,\n       Equal      => \"=\");\n    --  Hash table to record which subprograms are referenced. It is declared\n    --  at library level to avoid elaborating it for every call to Analyze.\n \n+   package Traversed_Table is new GNAT.Htable.Simple_HTable\n+     (Header_Num => Entity_Header_Num,\n+      Element    => Boolean,\n+      No_Element => False,\n+      Key        => Node_Id,\n+      Hash       => Node_Hash,\n+      Equal      => \"=\");\n+   --  Hash table to record which nodes we have traversed, so we can avoid\n+   --  traversing the same nodes repeatedly.\n+\n    -----------------\n-   -- Entity_Hash --\n+   -- Node_Hash --\n    -----------------\n \n-   function Entity_Hash (Id : Entity_Id) return Entity_Header_Num is\n+   function Node_Hash (Id : Entity_Id) return Entity_Header_Num is\n    begin\n       return Entity_Header_Num (Id mod Entity_Table_Size);\n-   end Entity_Hash;\n+   end Node_Hash;\n \n    ---------------------------------\n    -- Analyze_Package_Body_Helper --\n@@ -260,13 +270,25 @@ package body Sem_Ch7 is\n          function Scan_Subprogram_Ref (N : Node_Id) return Traverse_Result;\n          --  Determine whether a node denotes a reference to a subprogram\n \n-         procedure Scan_Subprogram_Refs is\n+         procedure Traverse_And_Scan_Subprogram_Refs is\n            new Traverse_Proc (Scan_Subprogram_Ref);\n          --  Subsidiary to routine Has_Referencer. Determine whether a node\n          --  contains references to a subprogram and record them.\n          --  WARNING: this is a very expensive routine as it performs a full\n          --  tree traversal.\n \n+         procedure Scan_Subprogram_Refs (Node : Node_Id);\n+         --  If we haven't already traversed Node, then mark it and traverse\n+         --  it.\n+\n+         procedure Scan_Subprogram_Refs (Node : Node_Id) is\n+         begin\n+            if not Traversed_Table.Get (Node) then\n+               Traversed_Table.Set (Node, True);\n+               Traverse_And_Scan_Subprogram_Refs (Node);\n+            end if;\n+         end Scan_Subprogram_Refs;\n+\n          --------------------\n          -- Has_Referencer --\n          --------------------\n@@ -581,6 +603,7 @@ package body Sem_Ch7 is\n          --  actual parameters of the instantiations matter here, and they are\n          --  present in the declarations list of the instantiated packages.\n \n+         Traversed_Table.Reset;\n          Subprogram_Table.Reset;\n          Discard := Has_Referencer (Decls, Top_Level => True);\n       end Hide_Public_Entities;"}, {"sha": "95bb0fe4a973a107cfe000cc3eb307784ec16c13", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -9069,15 +9069,15 @@ package body Sem_Ch8 is\n                              (Current_Use_Clause (Associated_Node (N))))\n                   then\n                      Error_Msg_Node_1 := Entity (N);\n-                     Error_Msg_NE (\"ineffective use clause for package &?\",\n+                     Error_Msg_NE (\"use clause for package &? has no effect\",\n                                    Curr, Entity (N));\n                   end if;\n \n                --  We are dealing with an unused use_type_clause\n \n                else\n                   Error_Msg_Node_1 := Etype (N);\n-                  Error_Msg_NE (\"ineffective use clause for }?\",\n+                  Error_Msg_NE (\"use clause for }? has no effect\",\n                                  Curr, Etype (N));\n                end if;\n             end if;"}, {"sha": "60df83840f79c5cf2d6732967255814feddbc5f7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -19059,7 +19059,18 @@ package body Sem_Util is\n          N := Next (Actual_Id);\n \n          if Nkind (N) = N_Parameter_Association then\n-            return First_Named_Actual (Parent (Actual_Id));\n+            --  In case of a build-in-place call, the call will no longer be a\n+            --  call; it will have been rewritten.\n+\n+            if Nkind_In (Parent (Actual_Id),\n+                         N_Entry_Call_Statement,\n+                         N_Function_Call,\n+                         N_Procedure_Call_Statement)\n+            then\n+               return First_Named_Actual (Parent (Actual_Id));\n+            else\n+               return Empty;\n+            end if;\n          else\n             return N;\n          end if;"}, {"sha": "f349cf1603630234c67434c5b921346e3abc443b", "filename": "gcc/testsuite/gnat.dg/validity_check2.adb", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2.adb?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -0,0 +1,11 @@\n+--  { dg-do compile }\n+--  { dg-options \"-gnatVi -gnatws\" }\n+\n+with Validity_Check2_Pkg; use Validity_Check2_Pkg;\n+\n+procedure Validity_Check2 (R : access Rec) is\n+begin\n+  if Op_Code_To_Msg (R.Code) in Valid_Msg then\n+    raise Program_Error;\n+  end if;\n+end;"}, {"sha": "c9b6a01e191c73c711d04e09286b758ac0e8a885", "filename": "gcc/testsuite/gnat.dg/validity_check2_pkg.ads", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5168a9b3d09e3da03cc51a09fd28813ff6b49b96/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fvalidity_check2_pkg.ads?ref=5168a9b3d09e3da03cc51a09fd28813ff6b49b96", "patch": "@@ -0,0 +1,16 @@\n+with Ada.unchecked_conversion;\n+\n+package Validity_Check2_Pkg is\n+\n+  type Op_Code is (One, Two, Three, Four);\n+\n+  subtype Valid_Msg is Integer range 0 .. 15;\n+\n+  function Op_Code_To_Msg is\n+    new Ada.Unchecked_Conversion (Source => Op_code, Target => Valid_Msg);\n+\n+  type Rec is record\n+    Code : Op_Code;\n+  end record;\n+\n+end Validity_Check2_Pkg;"}]}