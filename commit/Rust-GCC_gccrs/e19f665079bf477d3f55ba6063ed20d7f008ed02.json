{"sha": "e19f665079bf477d3f55ba6063ed20d7f008ed02", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE5ZjY2NTA3OWJmNDc3ZDNmNTViYTYwNjNlZDIwZDdmMDA4ZWQwMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-21T13:06:47Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-04-21T13:06:47Z"}, "message": "tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle MEM_REF and TARGET_MEM_REF, do not care about INDIRECT_REFs.\n\n2011-04-21  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n\tMEM_REF and TARGET_MEM_REF, do not care about INDIRECT_REFs.\n\tUse DECL_P, not SSA_VAR_P.\n\t(ptr_derefs_may_alias_p): Likewise.\n\t(ptr_deref_may_alias_ref_p_1): Likewise.\n\t(decl_refs_may_alias_p): Likewise.\n\t(refs_may_alias_p_1): Likewise.\n\t(ref_maybe_used_by_call_p_1): Likewise.\n\t(call_may_clobber_ref_p_1): Likewise.\n\t(indirect_ref_may_alias_decl_p): Assume indirect refrences\n\tare either MEM_REF or TARGET_MEM_REF.\n\t(indirect_refs_may_alias_p): Likewise.\n\t* calls.c (emit_call_1): Build a MEM_REF instead of an INDIRECT_REF\n\tfor MEM_EXPR of indirect calls.\n\nFrom-SVN: r172825", "tree": {"sha": "8d66d21b19fad0cdd55951c0f3e46d754b92860e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d66d21b19fad0cdd55951c0f3e46d754b92860e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e19f665079bf477d3f55ba6063ed20d7f008ed02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19f665079bf477d3f55ba6063ed20d7f008ed02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e19f665079bf477d3f55ba6063ed20d7f008ed02", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e19f665079bf477d3f55ba6063ed20d7f008ed02/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d1831bb3e2b1f32005209b199b800d7ff182ac7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d1831bb3e2b1f32005209b199b800d7ff182ac7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d1831bb3e2b1f32005209b199b800d7ff182ac7"}], "stats": {"total": 167, "additions": 82, "deletions": 85}, "files": [{"sha": "a505c25093405dc0de4aaa4a9720ff9b1e35cdaf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e19f665079bf477d3f55ba6063ed20d7f008ed02", "patch": "@@ -1,3 +1,20 @@\n+2011-04-21  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-alias.c (ptr_deref_may_alias_decl_p): Handle\n+\tMEM_REF and TARGET_MEM_REF, do not care about INDIRECT_REFs.\n+\tUse DECL_P, not SSA_VAR_P.\n+\t(ptr_derefs_may_alias_p): Likewise.\n+\t(ptr_deref_may_alias_ref_p_1): Likewise.\n+\t(decl_refs_may_alias_p): Likewise.\n+\t(refs_may_alias_p_1): Likewise.\n+\t(ref_maybe_used_by_call_p_1): Likewise.\n+\t(call_may_clobber_ref_p_1): Likewise.\n+\t(indirect_ref_may_alias_decl_p): Assume indirect refrences\n+\tare either MEM_REF or TARGET_MEM_REF.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\t* calls.c (emit_call_1): Build a MEM_REF instead of an INDIRECT_REF\n+\tfor MEM_EXPR of indirect calls.\n+\n 2011-04-21  Tristan Gingold  <gingold@adacore.com>\n \n \t* vmsdbgout.c (write_srccorr): Compute file length from the string."}, {"sha": "bd7c3a67dd52ab8c7c1ca9db6c8b5817f37be7cc", "filename": "gcc/calls.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=e19f665079bf477d3f55ba6063ed20d7f008ed02", "patch": "@@ -274,7 +274,7 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU\n   if (fndecl && TREE_CODE (fndecl) == FUNCTION_DECL)\n     set_mem_expr (funmem, fndecl);\n   else if (fntree)\n-    set_mem_expr (funmem, build_fold_indirect_ref (CALL_EXPR_FN (fntree)));\n+    set_mem_expr (funmem, build_simple_mem_ref (CALL_EXPR_FN (fntree)));\n \n #if defined (HAVE_sibcall_pop) && defined (HAVE_sibcall_value_pop)\n   if ((ecf_flags & ECF_SIBCALL)"}, {"sha": "f324099b2360d4e82f9490477d6a57837d599399", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 64, "deletions": 84, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e19f665079bf477d3f55ba6063ed20d7f008ed02/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=e19f665079bf477d3f55ba6063ed20d7f008ed02", "patch": "@@ -196,11 +196,11 @@ ptr_deref_may_alias_decl_p (tree ptr, tree decl)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr, 0));\n       if (base\n-\t  && (INDIRECT_REF_P (base)\n-\t      || TREE_CODE (base) == MEM_REF))\n+\t  && (TREE_CODE (base) == MEM_REF\n+\t      || TREE_CODE (base) == TARGET_MEM_REF))\n \tptr = TREE_OPERAND (base, 0);\n       else if (base\n-\t       && SSA_VAR_P (base))\n+\t       && DECL_P (base))\n \treturn base == decl;\n       else if (base\n \t       && CONSTANT_CLASS_P (base))\n@@ -281,11 +281,11 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr1, 0));\n       if (base\n-\t  && (INDIRECT_REF_P (base)\n-\t      || TREE_CODE (base) == MEM_REF))\n+\t  && (TREE_CODE (base) == MEM_REF\n+\t      || TREE_CODE (base) == TARGET_MEM_REF))\n \tptr1 = TREE_OPERAND (base, 0);\n       else if (base\n-\t       && SSA_VAR_P (base))\n+\t       && DECL_P (base))\n \treturn ptr_deref_may_alias_decl_p (ptr2, base);\n       else\n \treturn true;\n@@ -294,11 +294,11 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n     {\n       tree base = get_base_address (TREE_OPERAND (ptr2, 0));\n       if (base\n-\t  && (INDIRECT_REF_P (base)\n-\t      || TREE_CODE (base) == MEM_REF))\n+\t  && (TREE_CODE (base) == MEM_REF\n+\t      || TREE_CODE (base) == TARGET_MEM_REF))\n \tptr2 = TREE_OPERAND (base, 0);\n       else if (base\n-\t       && SSA_VAR_P (base))\n+\t       && DECL_P (base))\n \treturn ptr_deref_may_alias_decl_p (ptr1, base);\n       else\n \treturn true;\n@@ -338,10 +338,10 @@ ptr_deref_may_alias_ref_p_1 (tree ptr, ao_ref *ref)\n {\n   tree base = ao_ref_base (ref);\n \n-  if (INDIRECT_REF_P (base)\n-      || TREE_CODE (base) == MEM_REF)\n+  if (TREE_CODE (base) == MEM_REF\n+      || TREE_CODE (base) == TARGET_MEM_REF)\n     return ptr_derefs_may_alias_p (ptr, TREE_OPERAND (base, 0));\n-  else if (SSA_VAR_P (base))\n+  else if (DECL_P (base))\n     return ptr_deref_may_alias_decl_p (ptr, base);\n \n   return true;\n@@ -688,7 +688,7 @@ decl_refs_may_alias_p (tree base1,\n \t\t       tree base2,\n \t\t       HOST_WIDE_INT offset2, HOST_WIDE_INT max_size2)\n {\n-  gcc_assert (SSA_VAR_P (base1) && SSA_VAR_P (base2));\n+  gcc_checking_assert (DECL_P (base1) && DECL_P (base2));\n \n   /* If both references are based on different variables, they cannot alias.  */\n   if (base1 != base2)\n@@ -720,24 +720,25 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   tree ptr1;\n   tree ptrtype1;\n   HOST_WIDE_INT offset1p = offset1, offset2p = offset2;\n+  double_int moff;\n+\n+  gcc_checking_assert ((TREE_CODE (base1) == MEM_REF\n+\t\t\t|| TREE_CODE (base1) == TARGET_MEM_REF)\n+\t\t       && DECL_P (base2));\n \n   ptr1 = TREE_OPERAND (base1, 0);\n \n   /* The offset embedded in MEM_REFs can be negative.  Bias them\n      so that the resulting offset adjustment is positive.  */\n-  if (TREE_CODE (base1) == MEM_REF\n-      || TREE_CODE (base1) == TARGET_MEM_REF)\n-    {\n-      double_int moff = mem_ref_offset (base1);\n-      moff = double_int_lshift (moff,\n-\t\t\t\tBITS_PER_UNIT == 8\n-\t\t\t\t? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\tHOST_BITS_PER_DOUBLE_INT, true);\n-      if (double_int_negative_p (moff))\n-\toffset2p += double_int_neg (moff).low;\n-      else\n-\toffset1p += moff.low;\n-    }\n+  moff = mem_ref_offset (base1);\n+  moff = double_int_lshift (moff,\n+\t\t\t    BITS_PER_UNIT == 8\n+\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t    HOST_BITS_PER_DOUBLE_INT, true);\n+  if (double_int_negative_p (moff))\n+    offset2p += double_int_neg (moff).low;\n+  else\n+    offset1p += moff.low;\n \n   /* If only one reference is based on a variable, they cannot alias if\n      the pointer access is beyond the extent of the variable access.\n@@ -755,12 +756,7 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (!flag_strict_aliasing || !tbaa_p)\n     return true;\n \n-  if (TREE_CODE (base1) == MEM_REF)\n-    ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n-  else if (TREE_CODE (base1) == TARGET_MEM_REF)\n-    ptrtype1 = TREE_TYPE (TMR_OFFSET (base1));\n-  else\n-    ptrtype1 = TREE_TYPE (ptr1);\n+  ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n \n   /* If the alias set for a pointer access is zero all bets are off.  */\n   if (base1_alias_set == -1)\n@@ -851,6 +847,11 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   tree ptr2;\n   tree ptrtype1, ptrtype2;\n \n+  gcc_checking_assert ((TREE_CODE (base1) == MEM_REF\n+\t\t\t|| TREE_CODE (base1) == TARGET_MEM_REF)\n+\t\t       && (TREE_CODE (base2) == MEM_REF\n+\t\t\t   || TREE_CODE (base2) == TARGET_MEM_REF));\n+\n   ptr1 = TREE_OPERAND (base1, 0);\n   ptr2 = TREE_OPERAND (base2, 0);\n \n@@ -878,34 +879,27 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t\t      && operand_equal_p (TMR_INDEX2 (base1),\n \t\t\t\t\t  TMR_INDEX2 (base2), 0))))))\n     {\n+      double_int moff;\n       /* The offset embedded in MEM_REFs can be negative.  Bias them\n \t so that the resulting offset adjustment is positive.  */\n-      if (TREE_CODE (base1) == MEM_REF\n-\t  || TREE_CODE (base1) == TARGET_MEM_REF)\n-\t{\n-\t  double_int moff = mem_ref_offset (base1);\n-\t  moff = double_int_lshift (moff,\n-\t\t\t\t    BITS_PER_UNIT == 8\n-\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t    HOST_BITS_PER_DOUBLE_INT, true);\n-\t  if (double_int_negative_p (moff))\n-\t    offset2 += double_int_neg (moff).low;\n-\t  else\n-\t    offset1 += moff.low;\n-\t}\n-      if (TREE_CODE (base2) == MEM_REF\n-\t  || TREE_CODE (base2) == TARGET_MEM_REF)\n-\t{\n-\t  double_int moff = mem_ref_offset (base2);\n-\t  moff = double_int_lshift (moff,\n-\t\t\t\t    BITS_PER_UNIT == 8\n-\t\t\t\t    ? 3 : exact_log2 (BITS_PER_UNIT),\n-\t\t\t\t    HOST_BITS_PER_DOUBLE_INT, true);\n-\t  if (double_int_negative_p (moff))\n-\t    offset1 += double_int_neg (moff).low;\n-\t  else\n-\t    offset2 += moff.low;\n-\t}\n+      moff = mem_ref_offset (base1);\n+      moff = double_int_lshift (moff,\n+\t\t\t\tBITS_PER_UNIT == 8\n+\t\t\t\t? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\tHOST_BITS_PER_DOUBLE_INT, true);\n+      if (double_int_negative_p (moff))\n+\toffset2 += double_int_neg (moff).low;\n+      else\n+\toffset1 += moff.low;\n+      moff = mem_ref_offset (base2);\n+      moff = double_int_lshift (moff,\n+\t\t\t\tBITS_PER_UNIT == 8\n+\t\t\t\t? 3 : exact_log2 (BITS_PER_UNIT),\n+\t\t\t\tHOST_BITS_PER_DOUBLE_INT, true);\n+      if (double_int_negative_p (moff))\n+\toffset1 += double_int_neg (moff).low;\n+      else\n+\toffset2 += moff.low;\n       return ranges_overlap_p (offset1, max_size1, offset2, max_size2);\n     }\n   if (!ptr_derefs_may_alias_p (ptr1, ptr2))\n@@ -915,18 +909,8 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n   if (!flag_strict_aliasing || !tbaa_p)\n     return true;\n \n-  if (TREE_CODE (base1) == MEM_REF)\n-    ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n-  else if (TREE_CODE (base1) == TARGET_MEM_REF)\n-    ptrtype1 = TREE_TYPE (TMR_OFFSET (base1));\n-  else\n-    ptrtype1 = TREE_TYPE (ptr1);\n-  if (TREE_CODE (base2) == MEM_REF)\n-    ptrtype2 = TREE_TYPE (TREE_OPERAND (base2, 1));\n-  else if (TREE_CODE (base2) == TARGET_MEM_REF)\n-    ptrtype2 = TREE_TYPE (TMR_OFFSET (base2));\n-  else\n-    ptrtype2 = TREE_TYPE (ptr2);\n+  ptrtype1 = TREE_TYPE (TREE_OPERAND (base1, 1));\n+  ptrtype2 = TREE_TYPE (TREE_OPERAND (base2, 1));\n \n   /* If the alias set for a pointer access is zero all bets are off.  */\n   if (base1_alias_set == -1)\n@@ -991,15 +975,13 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n \t\t\t|| DECL_P (ref1->ref)\n \t\t\t|| TREE_CODE (ref1->ref) == STRING_CST\n \t\t\t|| handled_component_p (ref1->ref)\n-\t\t\t|| INDIRECT_REF_P (ref1->ref)\n \t\t\t|| TREE_CODE (ref1->ref) == MEM_REF\n \t\t\t|| TREE_CODE (ref1->ref) == TARGET_MEM_REF)\n \t\t       && (!ref2->ref\n \t\t\t   || TREE_CODE (ref2->ref) == SSA_NAME\n \t\t\t   || DECL_P (ref2->ref)\n \t\t\t   || TREE_CODE (ref2->ref) == STRING_CST\n \t\t\t   || handled_component_p (ref2->ref)\n-\t\t\t   || INDIRECT_REF_P (ref2->ref)\n \t\t\t   || TREE_CODE (ref2->ref) == MEM_REF\n \t\t\t   || TREE_CODE (ref2->ref) == TARGET_MEM_REF));\n \n@@ -1039,18 +1021,16 @@ refs_may_alias_p_1 (ao_ref *ref1, ao_ref *ref2, bool tbaa_p)\n      references based on two decls.  Do this before defering to\n      TBAA to handle must-alias cases in conformance with the\n      GCC extension of allowing type-punning through unions.  */\n-  var1_p = SSA_VAR_P (base1);\n-  var2_p = SSA_VAR_P (base2);\n+  var1_p = DECL_P (base1);\n+  var2_p = DECL_P (base2);\n   if (var1_p && var2_p)\n     return decl_refs_may_alias_p (base1, offset1, max_size1,\n \t\t\t\t  base2, offset2, max_size2);\n \n-  ind1_p = (INDIRECT_REF_P (base1)\n-\t    || (TREE_CODE (base1) == MEM_REF)\n-\t    || (TREE_CODE (base1) == TARGET_MEM_REF));\n-  ind2_p = (INDIRECT_REF_P (base2)\n-\t    || (TREE_CODE (base2) == MEM_REF)\n-\t    || (TREE_CODE (base2) == TARGET_MEM_REF));\n+  ind1_p = (TREE_CODE (base1) == MEM_REF\n+\t    || TREE_CODE (base1) == TARGET_MEM_REF);\n+  ind2_p = (TREE_CODE (base2) == MEM_REF\n+\t    || TREE_CODE (base2) == TARGET_MEM_REF);\n \n   /* Canonicalize the pointer-vs-decl case.  */\n   if (ind1_p && var2_p)\n@@ -1285,8 +1265,8 @@ ref_maybe_used_by_call_p_1 (gimple call, ao_ref *ref)\n       if (pt_solution_includes (gimple_call_use_set (call), base))\n \treturn true;\n     }\n-  else if ((INDIRECT_REF_P (base)\n-\t    || TREE_CODE (base) == MEM_REF)\n+  else if ((TREE_CODE (base) == MEM_REF\n+\t    || TREE_CODE (base) == TARGET_MEM_REF)\n \t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));\n@@ -1569,8 +1549,8 @@ call_may_clobber_ref_p_1 (gimple call, ao_ref *ref)\n   /* Check if the base variable is call-clobbered.  */\n   if (DECL_P (base))\n     return pt_solution_includes (gimple_call_clobber_set (call), base);\n-  else if ((INDIRECT_REF_P (base)\n-\t    || TREE_CODE (base) == MEM_REF)\n+  else if ((TREE_CODE (base) == MEM_REF\n+\t    || TREE_CODE (base) == TARGET_MEM_REF)\n \t   && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n     {\n       struct ptr_info_def *pi = SSA_NAME_PTR_INFO (TREE_OPERAND (base, 0));"}]}