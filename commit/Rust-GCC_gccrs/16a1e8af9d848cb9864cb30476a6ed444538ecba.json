{"sha": "16a1e8af9d848cb9864cb30476a6ed444538ecba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhMWU4YWY5ZDg0OGNiOTg2NGNiMzA0NzZhNmVkNDQ0NTM4ZWNiYQ==", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2020-04-20T17:47:22Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-28T19:09:39Z"}, "message": "This setups an initial frame work for our resolution step for the pipeline\n\nMore work is required but it takes advantage of the vistior pattern\nfrom the AST so we can do this without RTTI and dynamic_casts.\n\nMore passes on the AST AKA our HIR should follow this pattern.\n\nAddresses: #12", "tree": {"sha": "a496ca4325daa7624e27efbe94e0bf4201e10792", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a496ca4325daa7624e27efbe94e0bf4201e10792"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16a1e8af9d848cb9864cb30476a6ed444538ecba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a1e8af9d848cb9864cb30476a6ed444538ecba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a1e8af9d848cb9864cb30476a6ed444538ecba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a1e8af9d848cb9864cb30476a6ed444538ecba/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7c6f785c8e893ec7bcacd1a2319ce309d2450f2"}], "stats": {"total": 2891, "additions": 1923, "deletions": 968}, "files": [{"sha": "e35aa69650eeea83bdf522dd451e54ff441d38bb", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -69,6 +69,7 @@ GRS_OBJS = \\\n     rust/rust-parse.o \\\n     rust/rust-ast-full-test.o \\\n     rust/rust-session-manager.o \\\n+    rust/rust-resolution.o \\\n     $(END)\n # removed object files from here \n \n@@ -208,7 +209,7 @@ CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n # cross-folder includes - add new folders later\n-RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast\n+RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast -I $(srcdir)/rust/analysis\n \n # add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n@@ -232,3 +233,8 @@ rust/%.o: rust/parse/%.cc\n rust/%.o: rust/ast/%.cc\n \t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n+\n+# build rust/analysis files in rust folder\n+rust/%.o: rust/analysis/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n+\t$(POSTCOMPILE)"}, {"sha": "65fed90ca8ba2a6a5cf43126770d31a8303b5c2b", "filename": "gcc/rust/analysis/rust-resolution.cc", "status": "added", "additions": 605, "deletions": 0, "changes": 605, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Frust-resolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.cc?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -0,0 +1,605 @@\n+#include \"rust-resolution.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+TypeResolution::TypeResolution (AST::Crate &crate) : scope (), crate (crate) {}\n+\n+TypeResolution::~TypeResolution () {}\n+\n+bool\n+TypeResolution::ResolveNamesAndTypes (AST::Crate &crate)\n+{\n+  TypeResolution resolver (crate);\n+  return resolver.go ();\n+}\n+\n+bool\n+TypeResolution::go ()\n+{\n+  scope.Push ();\n+  for (auto &item : crate.items)\n+    {\n+      item->accept_vis (*this);\n+    }\n+  scope.Pop ();\n+  return true;\n+}\n+\n+void\n+TypeResolution::visit (AST::Token &tok)\n+{}\n+\n+void\n+TypeResolution::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+TypeResolution::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+TypeResolution::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+TypeResolution::visit (AST::Lifetime &lifetime)\n+{}\n+\n+void\n+TypeResolution::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+TypeResolution::visit (AST::MacroInvocationSemi &macro)\n+{}\n+\n+// rust-path.h\n+void\n+TypeResolution::visit (AST::PathInExpression &path)\n+{}\n+void\n+TypeResolution::visit (AST::TypePathSegment &segment)\n+{}\n+void\n+TypeResolution::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+void\n+TypeResolution::visit (AST::TypePathSegmentFunction &segment)\n+{}\n+void\n+TypeResolution::visit (AST::TypePath &path)\n+{}\n+void\n+TypeResolution::visit (AST::QualifiedPathInExpression &path)\n+{}\n+void\n+TypeResolution::visit (AST::QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+TypeResolution::visit (AST::LiteralExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+void\n+TypeResolution::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::BorrowExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::DereferenceExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ErrorPropagationExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::NegationExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ComparisonExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::LazyBooleanExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::TypeCastExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::AssignmentExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::CompoundAssignmentExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::GroupedExpr &expr)\n+{}\n+// void TypeResolution::visit(ArrayElems& elems) {}\n+void\n+TypeResolution::visit (AST::ArrayElemsValues &elems)\n+{}\n+void\n+TypeResolution::visit (AST::ArrayElemsCopied &elems)\n+{}\n+void\n+TypeResolution::visit (AST::ArrayExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ArrayIndexExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::TupleExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::TupleIndexExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprStruct &expr)\n+{}\n+// void TypeResolution::visit(StructExprField& field) {}\n+void\n+TypeResolution::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprFieldIdentifierValue &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprFieldIndexValue &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprStructFields &expr)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprStructBase &expr)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprTuple &expr)\n+{}\n+void\n+TypeResolution::visit (AST::StructExprUnit &expr)\n+{}\n+// void TypeResolution::visit(EnumExprField& field) {}\n+void\n+TypeResolution::visit (AST::EnumExprFieldIdentifier &field)\n+{}\n+void\n+TypeResolution::visit (AST::EnumExprFieldIdentifierValue &field)\n+{}\n+void\n+TypeResolution::visit (AST::EnumExprFieldIndexValue &field)\n+{}\n+void\n+TypeResolution::visit (AST::EnumExprStruct &expr)\n+{}\n+void\n+TypeResolution::visit (AST::EnumExprTuple &expr)\n+{}\n+void\n+TypeResolution::visit (AST::EnumExprFieldless &expr)\n+{}\n+void\n+TypeResolution::visit (AST::CallExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::MethodCallExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::FieldAccessExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ClosureExprInner &expr)\n+{}\n+void\n+TypeResolution::visit (AST::BlockExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ClosureExprInnerTyped &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ContinueExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::BreakExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeFromToExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeFromExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeToExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeFullExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeFromToInclExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::RangeToInclExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ReturnExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::UnsafeBlockExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::LoopExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::WhileLoopExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::WhileLetLoopExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::ForLoopExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfExprConseqElse &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfExprConseqIf &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfExprConseqIfLet &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfLetExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfLetExprConseqElse &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfLetExprConseqIf &expr)\n+{}\n+void\n+TypeResolution::visit (AST::IfLetExprConseqIfLet &expr)\n+{}\n+// void TypeResolution::visit(MatchCase& match_case) {}\n+void\n+TypeResolution::visit (AST::MatchCaseBlockExpr &match_case)\n+{}\n+void\n+TypeResolution::visit (AST::MatchCaseExpr &match_case)\n+{}\n+void\n+TypeResolution::visit (AST::MatchExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::AwaitExpr &expr)\n+{}\n+void\n+TypeResolution::visit (AST::AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+TypeResolution::visit (AST::TypeParam &param)\n+{}\n+// void TypeResolution::visit(WhereClauseItem& item) {}\n+void\n+TypeResolution::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+void\n+TypeResolution::visit (AST::TypeBoundWhereClauseItem &item)\n+{}\n+void\n+TypeResolution::visit (AST::Method &method)\n+{}\n+void\n+TypeResolution::visit (AST::ModuleBodied &module)\n+{}\n+void\n+TypeResolution::visit (AST::ModuleNoBody &module)\n+{}\n+void\n+TypeResolution::visit (AST::ExternCrate &crate)\n+{}\n+// void TypeResolution::visit(UseTree& use_tree) {}\n+void\n+TypeResolution::visit (AST::UseTreeGlob &use_tree)\n+{}\n+void\n+TypeResolution::visit (AST::UseTreeList &use_tree)\n+{}\n+void\n+TypeResolution::visit (AST::UseTreeRebind &use_tree)\n+{}\n+void\n+TypeResolution::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+TypeResolution::visit (AST::Function &function)\n+{\n+  scope.Insert (function.function_name, function.return_type.get ());\n+\n+  scope.Push ();\n+  printf (\"INSIDE FUNCTION: %s\\n\", function.function_name.c_str ());\n+\n+  for (auto &param : function.function_params)\n+    {\n+      printf (\"FUNC PARAM: %s\\n\", param.as_string ().c_str ());\n+    }\n+\n+  // ensure return types\n+  // TODO\n+\n+  // walk the expression body\n+  for (auto &stmt : function.function_body->statements)\n+    {\n+      stmt->accept_vis (*this);\n+    }\n+\n+  scope.Pop ();\n+}\n+\n+void\n+TypeResolution::visit (AST::TypeAlias &type_alias)\n+{}\n+void\n+TypeResolution::visit (AST::StructStruct &struct_item)\n+{}\n+void\n+TypeResolution::visit (AST::TupleStruct &tuple_struct)\n+{}\n+void\n+TypeResolution::visit (AST::EnumItem &item)\n+{}\n+void\n+TypeResolution::visit (AST::EnumItemTuple &item)\n+{}\n+void\n+TypeResolution::visit (AST::EnumItemStruct &item)\n+{}\n+void\n+TypeResolution::visit (AST::EnumItemDiscriminant &item)\n+{}\n+void\n+TypeResolution::visit (AST::Enum &enum_item)\n+{}\n+void\n+TypeResolution::visit (AST::Union &union_item)\n+{}\n+void\n+TypeResolution::visit (AST::ConstantItem &const_item)\n+{}\n+void\n+TypeResolution::visit (AST::StaticItem &static_item)\n+{}\n+void\n+TypeResolution::visit (AST::TraitItemFunc &item)\n+{}\n+void\n+TypeResolution::visit (AST::TraitItemMethod &item)\n+{}\n+void\n+TypeResolution::visit (AST::TraitItemConst &item)\n+{}\n+void\n+TypeResolution::visit (AST::TraitItemType &item)\n+{}\n+void\n+TypeResolution::visit (AST::Trait &trait)\n+{}\n+void\n+TypeResolution::visit (AST::InherentImpl &impl)\n+{}\n+void\n+TypeResolution::visit (AST::TraitImpl &impl)\n+{}\n+// void TypeResolution::visit(ExternalItem& item) {}\n+void\n+TypeResolution::visit (AST::ExternalStaticItem &item)\n+{}\n+void\n+TypeResolution::visit (AST::ExternalFunctionItem &item)\n+{}\n+void\n+TypeResolution::visit (AST::ExternBlock &block)\n+{}\n+\n+// rust-macro.h\n+void\n+TypeResolution::visit (AST::MacroMatchFragment &match)\n+{}\n+void\n+TypeResolution::visit (AST::MacroMatchRepetition &match)\n+{}\n+void\n+TypeResolution::visit (AST::MacroMatcher &matcher)\n+{}\n+void\n+TypeResolution::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+void\n+TypeResolution::visit (AST::MacroInvocation &macro_invoc)\n+{}\n+void\n+TypeResolution::visit (AST::MetaItemPath &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaItemSeq &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaWord &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaListPaths &meta_item)\n+{}\n+void\n+TypeResolution::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+TypeResolution::visit (AST::LiteralPattern &pattern)\n+{\n+  printf (\"LiteralPattern: %s\\n\", pattern.as_string ().c_str ());\n+}\n+\n+void\n+TypeResolution::visit (AST::IdentifierPattern &pattern)\n+{\n+  printf (\"IdentifierPattern: %s\\n\", pattern.as_string ().c_str ());\n+  letPatternBuffer.push_back (pattern);\n+}\n+\n+void\n+TypeResolution::visit (AST::WildcardPattern &pattern)\n+{}\n+// void TypeResolution::visit(RangePatternBound& bound) {}\n+void\n+TypeResolution::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+void\n+TypeResolution::visit (AST::RangePatternBoundPath &bound)\n+{}\n+void\n+TypeResolution::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+void\n+TypeResolution::visit (AST::RangePattern &pattern)\n+{}\n+void\n+TypeResolution::visit (AST::ReferencePattern &pattern)\n+{}\n+// void TypeResolution::visit(StructPatternField& field) {}\n+void\n+TypeResolution::visit (AST::StructPatternFieldTuplePat &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructPatternFieldIdentPat &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructPatternFieldIdent &field)\n+{}\n+void\n+TypeResolution::visit (AST::StructPattern &pattern)\n+{}\n+// void TypeResolution::visit(TupleStructItems& tuple_items) {}\n+void\n+TypeResolution::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{}\n+void\n+TypeResolution::visit (AST::TupleStructItemsRange &tuple_items)\n+{}\n+void\n+TypeResolution::visit (AST::TupleStructPattern &pattern)\n+{}\n+// void TypeResolution::visit(TuplePatternItems& tuple_items) {}\n+void\n+TypeResolution::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{}\n+void\n+TypeResolution::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{}\n+void\n+TypeResolution::visit (AST::TuplePattern &pattern)\n+{}\n+void\n+TypeResolution::visit (AST::GroupedPattern &pattern)\n+{}\n+void\n+TypeResolution::visit (AST::SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+TypeResolution::visit (AST::EmptyStmt &stmt)\n+{}\n+void\n+\n+TypeResolution::visit (AST::LetStmt &stmt)\n+{\n+  printf (\"Within LetStmt: %s\\n\", stmt.as_string ().c_str ());\n+\n+  if (!stmt.has_type ())\n+    {\n+      // infer the type\n+      printf (\"XXX UNKNOWN TYPE PLEASE INFER ME\\n\");\n+    }\n+\n+  // TODO check we know what the type is\n+\n+  stmt.variables_pattern->accept_vis (*this);\n+\n+  for (auto it = letPatternBuffer.begin (); it != letPatternBuffer.end (); it++)\n+    {\n+      scope.Insert (it->variable_ident, stmt.type.get ());\n+    }\n+\n+  letPatternBuffer.clear ();\n+}\n+\n+void\n+TypeResolution::visit (AST::ExprStmtWithoutBlock &stmt)\n+{}\n+void\n+TypeResolution::visit (AST::ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+TypeResolution::visit (AST::TraitBound &bound)\n+{}\n+void\n+TypeResolution::visit (AST::ImplTraitType &type)\n+{}\n+void\n+TypeResolution::visit (AST::TraitObjectType &type)\n+{}\n+void\n+TypeResolution::visit (AST::ParenthesisedType &type)\n+{}\n+void\n+TypeResolution::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+void\n+TypeResolution::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+void\n+TypeResolution::visit (AST::TupleType &type)\n+{}\n+void\n+TypeResolution::visit (AST::NeverType &type)\n+{}\n+void\n+TypeResolution::visit (AST::RawPointerType &type)\n+{}\n+void\n+TypeResolution::visit (AST::ReferenceType &type)\n+{}\n+void\n+TypeResolution::visit (AST::ArrayType &type)\n+{}\n+void\n+TypeResolution::visit (AST::SliceType &type)\n+{}\n+void\n+TypeResolution::visit (AST::InferredType &type)\n+{}\n+void\n+TypeResolution::visit (AST::BareFunctionType &type)\n+{}\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "940557ed74bb293f1550255cd043b3acb1691eb4", "filename": "gcc/rust/analysis/rust-resolution.h", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Frust-resolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Frust-resolution.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -0,0 +1,235 @@\n+#pragma once\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"scope.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class TypeResolution : public AST::ASTVisitor\n+{\n+public:\n+  static bool ResolveNamesAndTypes (AST::Crate &crate);\n+\n+  ~TypeResolution ();\n+\n+  // visitor impl\n+  // rust-ast.h\n+  // virtual void visit(AttrInput& attr_input);\n+  // virtual void visit(TokenTree& token_tree);\n+  // virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok);\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n+  virtual void visit (AST::AttrInputMetaItemContainer &input);\n+  // virtual void visit(MetaItem& meta_item);\n+  // virtual void vsit(Stmt& stmt);\n+  // virtual void visit(Expr& expr);\n+  virtual void visit (AST::IdentifierExpr &ident_expr);\n+  // virtual void visit(Pattern& pattern);\n+  // virtual void visit(Type& type);\n+  // virtual void visit(TypeParamBound& type_param_bound);\n+  virtual void visit (AST::Lifetime &lifetime);\n+  // virtual void visit(GenericParam& generic_param);\n+  virtual void visit (AST::LifetimeParam &lifetime_param);\n+  // virtual void visit(TraitItem& trait_item);\n+  // virtual void visit(InherentImplItem& inherent_impl_item);\n+  // virtual void visit(TraitImplItem& trait_impl_item);\n+  virtual void visit (AST::MacroInvocationSemi &macro);\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path);\n+  virtual void visit (AST::TypePathSegment &segment);\n+  virtual void visit (AST::TypePathSegmentGeneric &segment);\n+  virtual void visit (AST::TypePathSegmentFunction &segment);\n+  virtual void visit (AST::TypePath &path);\n+  virtual void visit (AST::QualifiedPathInExpression &path);\n+  virtual void visit (AST::QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr);\n+  virtual void visit (AST::AttrInputLiteral &attr_input);\n+  virtual void visit (AST::MetaItemLitExpr &meta_item);\n+  virtual void visit (AST::MetaItemPathLit &meta_item);\n+  virtual void visit (AST::BorrowExpr &expr);\n+  virtual void visit (AST::DereferenceExpr &expr);\n+  virtual void visit (AST::ErrorPropagationExpr &expr);\n+  virtual void visit (AST::NegationExpr &expr);\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (AST::ComparisonExpr &expr);\n+  virtual void visit (AST::LazyBooleanExpr &expr);\n+  virtual void visit (AST::TypeCastExpr &expr);\n+  virtual void visit (AST::AssignmentExpr &expr);\n+  virtual void visit (AST::CompoundAssignmentExpr &expr);\n+  virtual void visit (AST::GroupedExpr &expr);\n+  // virtual void visit(ArrayElems& elems);\n+  virtual void visit (AST::ArrayElemsValues &elems);\n+  virtual void visit (AST::ArrayElemsCopied &elems);\n+  virtual void visit (AST::ArrayExpr &expr);\n+  virtual void visit (AST::ArrayIndexExpr &expr);\n+  virtual void visit (AST::TupleExpr &expr);\n+  virtual void visit (AST::TupleIndexExpr &expr);\n+  virtual void visit (AST::StructExprStruct &expr);\n+  // virtual void visit(StructExprField& field);\n+  virtual void visit (AST::StructExprFieldIdentifier &field);\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n+  virtual void visit (AST::StructExprFieldIndexValue &field);\n+  virtual void visit (AST::StructExprStructFields &expr);\n+  virtual void visit (AST::StructExprStructBase &expr);\n+  virtual void visit (AST::StructExprTuple &expr);\n+  virtual void visit (AST::StructExprUnit &expr);\n+  // virtual void visit(EnumExprField& field);\n+  virtual void visit (AST::EnumExprFieldIdentifier &field);\n+  virtual void visit (AST::EnumExprFieldIdentifierValue &field);\n+  virtual void visit (AST::EnumExprFieldIndexValue &field);\n+  virtual void visit (AST::EnumExprStruct &expr);\n+  virtual void visit (AST::EnumExprTuple &expr);\n+  virtual void visit (AST::EnumExprFieldless &expr);\n+  virtual void visit (AST::CallExpr &expr);\n+  virtual void visit (AST::MethodCallExpr &expr);\n+  virtual void visit (AST::FieldAccessExpr &expr);\n+  virtual void visit (AST::ClosureExprInner &expr);\n+  virtual void visit (AST::BlockExpr &expr);\n+  virtual void visit (AST::ClosureExprInnerTyped &expr);\n+  virtual void visit (AST::ContinueExpr &expr);\n+  virtual void visit (AST::BreakExpr &expr);\n+  virtual void visit (AST::RangeFromToExpr &expr);\n+  virtual void visit (AST::RangeFromExpr &expr);\n+  virtual void visit (AST::RangeToExpr &expr);\n+  virtual void visit (AST::RangeFullExpr &expr);\n+  virtual void visit (AST::RangeFromToInclExpr &expr);\n+  virtual void visit (AST::RangeToInclExpr &expr);\n+  virtual void visit (AST::ReturnExpr &expr);\n+  virtual void visit (AST::UnsafeBlockExpr &expr);\n+  virtual void visit (AST::LoopExpr &expr);\n+  virtual void visit (AST::WhileLoopExpr &expr);\n+  virtual void visit (AST::WhileLetLoopExpr &expr);\n+  virtual void visit (AST::ForLoopExpr &expr);\n+  virtual void visit (AST::IfExpr &expr);\n+  virtual void visit (AST::IfExprConseqElse &expr);\n+  virtual void visit (AST::IfExprConseqIf &expr);\n+  virtual void visit (AST::IfExprConseqIfLet &expr);\n+  virtual void visit (AST::IfLetExpr &expr);\n+  virtual void visit (AST::IfLetExprConseqElse &expr);\n+  virtual void visit (AST::IfLetExprConseqIf &expr);\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n+  // virtual void visit(MatchCase& match_case);\n+  virtual void visit (AST::MatchCaseBlockExpr &match_case);\n+  virtual void visit (AST::MatchCaseExpr &match_case);\n+  virtual void visit (AST::MatchExpr &expr);\n+  virtual void visit (AST::AwaitExpr &expr);\n+  virtual void visit (AST::AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param);\n+  // virtual void visit(WhereClauseItem& item);\n+  virtual void visit (AST::LifetimeWhereClauseItem &item);\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n+  virtual void visit (AST::Method &method);\n+  virtual void visit (AST::ModuleBodied &module);\n+  virtual void visit (AST::ModuleNoBody &module);\n+  virtual void visit (AST::ExternCrate &crate);\n+  // virtual void visit(UseTree& use_tree);\n+  virtual void visit (AST::UseTreeGlob &use_tree);\n+  virtual void visit (AST::UseTreeList &use_tree);\n+  virtual void visit (AST::UseTreeRebind &use_tree);\n+  virtual void visit (AST::UseDeclaration &use_decl);\n+  virtual void visit (AST::Function &function);\n+  virtual void visit (AST::TypeAlias &type_alias);\n+  virtual void visit (AST::StructStruct &struct_item);\n+  virtual void visit (AST::TupleStruct &tuple_struct);\n+  virtual void visit (AST::EnumItem &item);\n+  virtual void visit (AST::EnumItemTuple &item);\n+  virtual void visit (AST::EnumItemStruct &item);\n+  virtual void visit (AST::EnumItemDiscriminant &item);\n+  virtual void visit (AST::Enum &enum_item);\n+  virtual void visit (AST::Union &union_item);\n+  virtual void visit (AST::ConstantItem &const_item);\n+  virtual void visit (AST::StaticItem &static_item);\n+  virtual void visit (AST::TraitItemFunc &item);\n+  virtual void visit (AST::TraitItemMethod &item);\n+  virtual void visit (AST::TraitItemConst &item);\n+  virtual void visit (AST::TraitItemType &item);\n+  virtual void visit (AST::Trait &trait);\n+  virtual void visit (AST::InherentImpl &impl);\n+  virtual void visit (AST::TraitImpl &impl);\n+  // virtual void visit(ExternalItem& item);\n+  virtual void visit (AST::ExternalStaticItem &item);\n+  virtual void visit (AST::ExternalFunctionItem &item);\n+  virtual void visit (AST::ExternBlock &block);\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match);\n+  virtual void visit (AST::MacroMatchRepetition &match);\n+  virtual void visit (AST::MacroMatcher &matcher);\n+  virtual void visit (AST::MacroRulesDefinition &rules_def);\n+  virtual void visit (AST::MacroInvocation &macro_invoc);\n+  virtual void visit (AST::MetaItemPath &meta_item);\n+  virtual void visit (AST::MetaItemSeq &meta_item);\n+  virtual void visit (AST::MetaWord &meta_item);\n+  virtual void visit (AST::MetaNameValueStr &meta_item);\n+  virtual void visit (AST::MetaListPaths &meta_item);\n+  virtual void visit (AST::MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern);\n+  virtual void visit (AST::IdentifierPattern &pattern);\n+  virtual void visit (AST::WildcardPattern &pattern);\n+  // virtual void visit(RangePatternBound& bound);\n+  virtual void visit (AST::RangePatternBoundLiteral &bound);\n+  virtual void visit (AST::RangePatternBoundPath &bound);\n+  virtual void visit (AST::RangePatternBoundQualPath &bound);\n+  virtual void visit (AST::RangePattern &pattern);\n+  virtual void visit (AST::ReferencePattern &pattern);\n+  // virtual void visit(StructPatternField& field);\n+  virtual void visit (AST::StructPatternFieldTuplePat &field);\n+  virtual void visit (AST::StructPatternFieldIdentPat &field);\n+  virtual void visit (AST::StructPatternFieldIdent &field);\n+  virtual void visit (AST::StructPattern &pattern);\n+  // virtual void visit(TupleStructItems& tuple_items);\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n+  virtual void visit (AST::TupleStructPattern &pattern);\n+  // virtual void visit(TuplePatternItems& tuple_items);\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  virtual void visit (AST::TuplePattern &pattern);\n+  virtual void visit (AST::GroupedPattern &pattern);\n+  virtual void visit (AST::SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt);\n+  virtual void visit (AST::LetStmt &stmt);\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (AST::ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound);\n+  virtual void visit (AST::ImplTraitType &type);\n+  virtual void visit (AST::TraitObjectType &type);\n+  virtual void visit (AST::ParenthesisedType &type);\n+  virtual void visit (AST::ImplTraitTypeOneBound &type);\n+  virtual void visit (AST::TraitObjectTypeOneBound &type);\n+  virtual void visit (AST::TupleType &type);\n+  virtual void visit (AST::NeverType &type);\n+  virtual void visit (AST::RawPointerType &type);\n+  virtual void visit (AST::ReferenceType &type);\n+  virtual void visit (AST::ArrayType &type);\n+  virtual void visit (AST::SliceType &type);\n+  virtual void visit (AST::InferredType &type);\n+  virtual void visit (AST::BareFunctionType &type);\n+\n+private:\n+  TypeResolution (AST::Crate &crate);\n+\n+  bool go ();\n+\n+  Scope scope;\n+  AST::Crate &crate;\n+\n+  std::vector<AST::IdentifierPattern> letPatternBuffer;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "0374251c068dc00b092193c00f7a0b352164cbd2", "filename": "gcc/rust/analysis/scope.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Fscope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fanalysis%2Fscope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fanalysis%2Fscope.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -0,0 +1,55 @@\n+#pragma once\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+\n+namespace Rust {\n+namespace Analysis {\n+\n+class Scope\n+{\n+public:\n+  Scope () : scopeStack () {}\n+\n+  ~Scope () {}\n+\n+  bool Insert (std::string key, AST::Type *val)\n+  {\n+    if (scopeStack.back ().find (key) != scopeStack.back ().end ())\n+      {\n+\treturn false;\n+      }\n+\n+    scopeStack.back ().insert (std::make_pair (key, std::move (val)));\n+    return true;\n+  }\n+\n+  bool Lookup (std::string key, AST::Type **result)\n+  {\n+    for (auto it = scopeStack.rbegin (); it != scopeStack.rend (); ++it)\n+      {\n+\tauto lookup = it->find (key);\n+\tif (lookup != it->end ())\n+\t  {\n+\t    *result = lookup->second;\n+\t    return true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n+  void Push () { scopeStack.push_back ({}); }\n+\n+  std ::map<std::string, AST::Type *> Pop ()\n+  {\n+    auto toplevel = scopeStack.back ();\n+    scopeStack.pop_back ();\n+    return toplevel;\n+  }\n+\n+private:\n+  std::vector<std::map<std::string, AST::Type *> > scopeStack;\n+};\n+\n+} // namespace Analysis\n+} // namespace Rust"}, {"sha": "ac5cad763a532f8754d38e6198268d019ef1d671", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -783,8 +783,7 @@ UseTreeGlob::as_string () const\n       return \"*\";\n     case GLOBAL:\n       return \"::*\";\n-    case PATH_PREFIXED:\n-      {\n+      case PATH_PREFIXED: {\n \t::std::string path_str = path.as_string ();\n \treturn path_str + \"::*\";\n       }\n@@ -807,8 +806,7 @@ UseTreeList::as_string () const\n     case GLOBAL:\n       path_str = \"::{\";\n       break;\n-    case PATH_PREFIXED:\n-      {\n+      case PATH_PREFIXED: {\n \tpath_str = path.as_string () + \"::{\";\n \tbreak;\n       }\n@@ -4688,8 +4686,7 @@ MacroParser::parse_meta_item_inner ()\n \tcase SELF:\n \tcase CRATE:\n \tcase DOLLAR_SIGN:\n-\tcase SCOPE_RESOLUTION:\n-\t  {\n+\t  case SCOPE_RESOLUTION: {\n \t    return parse_path_meta_item ();\n \t  }\n \tdefault:\n@@ -4830,16 +4827,14 @@ MacroParser::parse_path_meta_item ()\n \n   switch (peek_token ()->get_id ())\n     {\n-    case LEFT_PAREN:\n-      {\n+      case LEFT_PAREN: {\n \t::std::vector< ::std::unique_ptr<MetaItemInner> > meta_items\n \t  = parse_meta_item_seq ();\n \n \treturn ::std::unique_ptr<MetaItemSeq> (\n \t  new MetaItemSeq (::std::move (path), ::std::move (meta_items)));\n       }\n-    case EQUAL:\n-      {\n+      case EQUAL: {\n \tskip_token ();\n \n \tLocation locus = peek_token ()->get_locus ();"}, {"sha": "5378378908b58136aeb2cf123f06c33fc74d10a2", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -303,7 +303,7 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   // tok) const;\n   //::std::vector< ::std::unique_ptr<MetaItemInner> > parse_meta_item_seq(const\n   //::std::vector< ::std::unique_ptr<Token> >& token_stream, int& i) const;\n-  //Literal\n+  // Literal\n   // parse_literal(const ::std::unique_ptr<Token>& tok) const;\n   //::std::unique_ptr<MetaItem> parse_path_meta_item(const ::std::vector<\n   //::std::unique_ptr<Token> >& token_stream, int& i) const; bool\n@@ -819,6 +819,8 @@ class Item : public Stmt\n   add_crate_name (::std::vector< ::std::string> &names ATTRIBUTE_UNUSED) const\n   {}\n \n+  virtual void accept_vis (ASTVisitor &vis ATTRIBUTE_UNUSED) {}\n+\n protected:\n   // Constructor\n   Item (::std::vector<Attribute> outer_attribs = ::std::vector<Attribute> ())"}, {"sha": "ce78bd76276cc5de25036675bae72826c8716c00", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -556,15 +556,15 @@ class ArithmeticOrLogicalExpr : public OperatorExpr\n   enum ExprType\n   {\n     ADD,\t // std::ops::Add\n-    SUBTRACT,    // std::ops::Sub\n-    MULTIPLY,    // std::ops::Mul\n-    DIVIDE,      // std::ops::Div\n-    MODULUS,     // std::ops::Rem\n+    SUBTRACT,\t // std::ops::Sub\n+    MULTIPLY,\t // std::ops::Mul\n+    DIVIDE,\t // std::ops::Div\n+    MODULUS,\t // std::ops::Rem\n     BITWISE_AND, // std::ops::BitAnd\n-    BITWISE_OR,  // std::ops::BitOr\n+    BITWISE_OR,\t // std::ops::BitOr\n     BITWISE_XOR, // std::ops::BitXor\n-    LEFT_SHIFT,  // std::ops::Shl\n-    RIGHT_SHIFT  // std::ops::Shr\n+    LEFT_SHIFT,\t // std::ops::Shl\n+    RIGHT_SHIFT\t // std::ops::Shr\n   };\n \n private:\n@@ -647,10 +647,10 @@ class ComparisonExpr : public OperatorExpr\n public:\n   enum ExprType\n   {\n-    EQUAL,\t    // std::cmp::PartialEq::eq\n-    NOT_EQUAL,\t// std::cmp::PartialEq::ne\n+    EQUAL,\t      // std::cmp::PartialEq::eq\n+    NOT_EQUAL,\t      // std::cmp::PartialEq::ne\n     GREATER_THAN,     // std::cmp::PartialEq::gt\n-    LESS_THAN,\t// std::cmp::PartialEq::lt\n+    LESS_THAN,\t      // std::cmp::PartialEq::lt\n     GREATER_OR_EQUAL, // std::cmp::PartialEq::ge\n     LESS_OR_EQUAL     // std::cmp::PartialEq::le\n   };\n@@ -964,15 +964,15 @@ class CompoundAssignmentExpr : public OperatorExpr\n   enum ExprType\n   {\n     ADD,\t // std::ops::AddAssign\n-    SUBTRACT,    // std::ops::SubAssign\n-    MULTIPLY,    // std::ops::MulAssign\n-    DIVIDE,      // std::ops::DivAssign\n-    MODULUS,     // std::ops::RemAssign\n+    SUBTRACT,\t // std::ops::SubAssign\n+    MULTIPLY,\t // std::ops::MulAssign\n+    DIVIDE,\t // std::ops::DivAssign\n+    MODULUS,\t // std::ops::RemAssign\n     BITWISE_AND, // std::ops::BitAndAssign\n-    BITWISE_OR,  // std::ops::BitOrAssign\n+    BITWISE_OR,\t // std::ops::BitOrAssign\n     BITWISE_XOR, // std::ops::BitXorAssign\n-    LEFT_SHIFT,  // std::ops::ShlAssign\n-    RIGHT_SHIFT  // std::ops::ShrAssign\n+    LEFT_SHIFT,\t // std::ops::ShlAssign\n+    RIGHT_SHIFT\t // std::ops::ShrAssign\n   };\n \n private:\n@@ -2936,6 +2936,7 @@ class ClosureExprInner : public ClosureExpr\n // A block AST node\n class BlockExpr : public ExprWithBlock\n {\n+public:\n   ::std::vector<Attribute> inner_attrs;\n \n   /*bool has_statements;\n@@ -2948,7 +2949,6 @@ class BlockExpr : public ExprWithBlock\n \n   Location locus;\n \n-public:\n   ::std::string as_string () const;\n \n   // Returns whether the block contains statements.\n@@ -4763,7 +4763,7 @@ struct MatchArm\n   // Copy constructor with clone\n   MatchArm (MatchArm const &other)\n     : /*match_arm_patterns(other.match_arm_patterns),*/ outer_attrs (\n-\tother.outer_attrs)\n+      other.outer_attrs)\n   {\n     // guard to protect from null pointer dereference\n     if (other.guard_expr != NULL)"}, {"sha": "45f58427db259f5ebcf2f2b3da9e5623ba0de68e", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -1310,6 +1310,7 @@ class UseDeclaration : public VisItem\n // Rust function declaration AST node\n class Function : public VisItem, public InherentImplItem, public TraitImplItem\n {\n+public:\n   FunctionQualifiers qualifiers;\n \n   Identifier function_name;\n@@ -1334,7 +1335,6 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n \n   Location locus;\n \n-public:\n   /*~Function() {\n       delete function_body;\n   }*/"}, {"sha": "e61d4738e321b190ec2d0174c7d101b1a78e9dbd", "filename": "gcc/rust/ast/rust-pattern.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -49,6 +49,7 @@ class LiteralPattern : public Pattern\n // Identifier pattern AST node (bind value matched to a variable)\n class IdentifierPattern : public Pattern\n {\n+public:\n   Identifier variable_ident;\n   bool is_ref;\n   bool is_mut;\n@@ -59,7 +60,6 @@ class IdentifierPattern : public Pattern\n \n   Location locus;\n \n-public:\n   /*~IdentifierPattern() {\n       delete to_bind;\n   }*/"}, {"sha": "49c94fdca16c83cd1ae7ccb82f7f67d3bee15a69", "filename": "gcc/rust/ast/rust-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -46,6 +46,7 @@ class EmptyStmt : public Stmt\n  * introduces new name into scope */\n class LetStmt : public Stmt\n {\n+public:\n   // bool has_outer_attrs;\n   ::std::vector<Attribute> outer_attrs;\n \n@@ -62,7 +63,6 @@ class LetStmt : public Stmt\n \n   Location locus;\n \n-public:\n   // Returns whether let statement has outer attributes.\n   inline bool has_outer_attrs () const { return !outer_attrs.empty (); }\n "}, {"sha": "5e9443f85f26afec2855022039585e5081c15104", "filename": "gcc/rust/parse/rust-parse.cc", "status": "modified", "additions": 135, "deletions": 231, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -192,17 +192,15 @@ Parser::skip_generics_right_angle ()\n       // this is good - skip token\n       lexer.skip_token ();\n       return true;\n-    case RIGHT_SHIFT:\n-      {\n+      case RIGHT_SHIFT: {\n \t/* shit. preferred HACK would be to replace this token in stream with\n \t * '>', but may not be possible at this point. */\n \t// FIXME: ensure locations aren't messed up\n \tTokenPtr right_angle = Token::make (RIGHT_ANGLE, tok->get_locus () + 1);\n \tlexer.replace_current_token (right_angle);\n \treturn true;\n       }\n-    case GREATER_OR_EQUAL:\n-      {\n+      case GREATER_OR_EQUAL: {\n \t// another HACK - replace with equal (as assignment intended, probably)\n \t/* FIXME: is this even required? how many people wouldn't leave a space?\n \t * - apparently rustc has this feature */\n@@ -211,8 +209,7 @@ Parser::skip_generics_right_angle ()\n \tlexer.replace_current_token (equal);\n \treturn true;\n       }\n-    case RIGHT_SHIFT_EQ:\n-      {\n+      case RIGHT_SHIFT_EQ: {\n \t// another HACK - replace with greater or equal\n \t// FIXME: again, is this really required? rustc has the feature, though\n \t// FIXME: ensure locations aren't messed up\n@@ -677,8 +674,7 @@ Parser::parse_attr_input ()\n     {\n     case LEFT_PAREN:\n     case LEFT_SQUARE:\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t// must be a delimited token tree, so parse that\n \t::std::unique_ptr<AST::DelimTokenTree> input_tree (\n \t  new AST::DelimTokenTree (parse_delim_token_tree ()));\n@@ -687,8 +683,7 @@ Parser::parse_attr_input ()\n \n \treturn input_tree;\n       }\n-    case EQUAL:\n-      {\n+      case EQUAL: {\n \t// = LiteralExpr\n \tlexer.skip_token ();\n \n@@ -1713,8 +1708,7 @@ Parser::parse_macro_match ()\n     {\n     case LEFT_PAREN:\n     case LEFT_SQUARE:\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t// must be macro matcher as delimited\n \tAST::MacroMatcher matcher = parse_macro_matcher ();\n \tif (matcher.is_error ())\n@@ -1726,8 +1720,7 @@ Parser::parse_macro_match ()\n \treturn ::std::unique_ptr<AST::MacroMatcher> (\n \t  new AST::MacroMatcher (::std::move (matcher)));\n       }\n-    case DOLLAR_SIGN:\n-      {\n+      case DOLLAR_SIGN: {\n \t// have to do more lookahead to determine if fragment or repetition\n \tconst_TokenPtr t2 = lexer.peek_token (1);\n \tswitch (t2->get_id ())\n@@ -1949,8 +1942,7 @@ Parser::parse_visibility ()\n       skip_token (RIGHT_PAREN);\n \n       return AST::Visibility::create_super ();\n-    case IN:\n-      {\n+      case IN: {\n \tlexer.skip_token ();\n \n \t// parse the \"in\" path as well\n@@ -2001,8 +1993,7 @@ Parser::parse_module (AST::Visibility vis,\n \tnew AST::ModuleNoBody (::std::move (name), ::std::move (vis),\n \t\t\t       ::std::move (outer_attrs),\n \t\t\t       locus)); // module name?\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \tlexer.skip_token ();\n \n \t// parse inner attributes\n@@ -2234,8 +2225,7 @@ Parser::parse_use_tree ()\n \t  return ::std::unique_ptr<AST::UseTreeGlob> (\n \t    new AST::UseTreeGlob (AST::UseTreeGlob::NO_PATH,\n \t\t\t\t  AST::SimplePath::create_empty (), locus));\n-\tcase LEFT_CURLY:\n-\t  {\n+\t  case LEFT_CURLY: {\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n@@ -2307,8 +2297,7 @@ Parser::parse_use_tree ()\n \t  return ::std::unique_ptr<AST::UseTreeGlob> (\n \t    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n \t\t\t\t  ::std::move (path), locus));\n-\tcase LEFT_CURLY:\n-\t  {\n+\t  case LEFT_CURLY: {\n \t    // nested tree UseTree type\n \t    lexer.skip_token ();\n \n@@ -2347,8 +2336,7 @@ Parser::parse_use_tree ()\n \t\t\t\t    ::std::move (path), std::move (use_trees),\n \t\t\t\t    locus));\n \t  }\n-\tcase AS:\n-\t  {\n+\t  case AS: {\n \t    // rebind UseTree type\n \t    lexer.skip_token ();\n \n@@ -3490,8 +3478,7 @@ Parser::parse_struct (AST::Visibility vis,\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t// struct with body\n \n \t// skip curly bracket\n@@ -3808,8 +3795,7 @@ Parser::parse_enum_item ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case LEFT_PAREN:\n-      {\n+      case LEFT_PAREN: {\n \t// tuple enum item\n \tlexer.skip_token ();\n \n@@ -3825,8 +3811,7 @@ Parser::parse_enum_item ()\n \t  ::std::move (item_name), ::std::move (tuple_fields),\n \t  ::std::move (outer_attrs), item_name_tok->get_locus ()));\n       }\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t// struct enum item\n \tlexer.skip_token ();\n \n@@ -3842,8 +3827,7 @@ Parser::parse_enum_item ()\n \t  ::std::move (item_name), ::std::move (struct_fields),\n \t  ::std::move (outer_attrs), item_name_tok->get_locus ()));\n       }\n-    case EQUAL:\n-      {\n+      case EQUAL: {\n \t// discriminant enum item\n \tlexer.skip_token ();\n \n@@ -4127,8 +4111,7 @@ Parser::parse_trait_item ()\n       gcc_fallthrough ();\n     case UNSAFE:\n     case EXTERN_TOK:\n-    case FN_TOK:\n-      {\n+      case FN_TOK: {\n \t/* function and method can't be disambiguated by lookahead alone\n \t * (without a lot of work and waste), so either make a\n \t * \"parse_trait_function_or_method\" or parse here mostly and pass in\n@@ -4248,8 +4231,7 @@ Parser::parse_trait_item ()\n \t\t\t\t      tok->get_locus ()));\n \t  }\n       }\n-    default:\n-      {\n+      default: {\n \t// TODO: try and parse macro invocation semi - if fails, maybe error.\n \t::std::unique_ptr<AST::MacroInvocationSemi> macro_invoc\n \t  = parse_macro_invocation_semi (outer_attrs);\n@@ -4560,8 +4542,7 @@ Parser::parse_inherent_impl_item ()\n     case DOLLAR_SIGN:\n       // these seem to be SimplePath tokens, so this is a macro invocation semi\n       return parse_macro_invocation_semi (::std::move (outer_attrs));\n-    case PUB:\n-      {\n+      case PUB: {\n \t// visibility, so not a macro invocation semi - must be constant,\n \t// function, or method\n \tAST::Visibility vis = parse_visibility ();\n@@ -4777,8 +4758,7 @@ Parser::parse_trait_impl_item ()\n     case TYPE:\n       return parse_type_alias (AST::Visibility::create_error (),\n \t\t\t       ::std::move (outer_attrs));\n-    case PUB:\n-      {\n+      case PUB: {\n \t// visibility, so not a macro invocation semi - must be constant,\n \t// function, or method\n \tAST::Visibility vis = parse_visibility ();\n@@ -5099,8 +5079,7 @@ Parser::parse_external_item ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case STATIC_TOK:\n-      {\n+      case STATIC_TOK: {\n \t// parse extern static item\n \tlexer.skip_token ();\n \n@@ -5148,8 +5127,7 @@ Parser::parse_external_item ()\n \t\t\t\t       has_mut, ::std::move (vis),\n \t\t\t\t       ::std::move (outer_attrs), locus));\n       }\n-    case FN_TOK:\n-      {\n+      case FN_TOK: {\n \t// parse extern function declaration item\n \t// skip function token\n \tlexer.skip_token ();\n@@ -5687,8 +5665,7 @@ Parser::parse_type_path_segment ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case LEFT_ANGLE:\n-      {\n+      case LEFT_ANGLE: {\n \t// parse generic args\n \tAST::GenericArgs generic_args = parse_path_generic_args ();\n \n@@ -5697,8 +5674,7 @@ Parser::parse_type_path_segment ()\n \t\t\t\t\t   has_separating_scope_resolution,\n \t\t\t\t\t   ::std::move (generic_args), locus));\n       }\n-    case LEFT_PAREN:\n-      {\n+      case LEFT_PAREN: {\n \t// parse type path function\n \tAST::TypePathFunction type_path_function = parse_type_path_function ();\n \n@@ -6272,8 +6248,7 @@ Parser::parse_expr_stmt (::std::vector<AST::Attribute> outer_attrs)\n     case ASYNC:\n       // expression with block\n       return parse_expr_stmt_with_block (::std::move (outer_attrs));\n-    case LIFETIME:\n-      {\n+      case LIFETIME: {\n \t/* FIXME: are there any expressions without blocks that can have\n \t * lifetime as their first token? Or is loop expr the only one? */\n \t// safe side for now:\n@@ -6287,8 +6262,7 @@ Parser::parse_expr_stmt (::std::vector<AST::Attribute> outer_attrs)\n \t    return parse_expr_stmt_without_block (::std::move (outer_attrs));\n \t  }\n       }\n-    case UNSAFE:\n-      {\n+      case UNSAFE: {\n \t/* FIXME: are there any expressions without blocks that can have unsafe\n \t * as their first token? Or is unsafe the only one? */\n \t// safe side for now\n@@ -6342,8 +6316,7 @@ Parser::parse_expr_stmt_with_block (::std::vector<AST::Attribute> outer_attrs)\n       // \"for\" iterator loop\n       expr_parsed = parse_for_loop_expr (::std::move (outer_attrs));\n       break;\n-    case WHILE:\n-      {\n+      case WHILE: {\n \t// while or while let, so more lookahead to find out\n \tif (lexer.peek_token ()->get_id () == LET)\n \t  {\n@@ -6510,8 +6483,7 @@ Parser::parse_expr_without_block (::std::vector<AST::Attribute> outer_attrs)\n       /* either grouped expr or tuple expr - depends on whether there is a comma\n        * inside the parentheses - if so, tuple expr, otherwise, grouped expr. */\n       return parse_grouped_or_tuple_expr (::std::move (outer_attrs));\n-    default:\n-      {\n+      default: {\n \t// HACK: piggyback on pratt parsed expr and abuse polymorphism to\n \t// essentially downcast\n \n@@ -7038,8 +7010,7 @@ Parser::parse_if_expr (\n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n \t{\n-\tcase LEFT_CURLY:\n-\t  {\n+\t  case LEFT_CURLY: {\n \t    // double selection - else\n \t    // parse else block expr (required)\n \t    ::std::unique_ptr<AST::BlockExpr> else_body = parse_block_expr ();\n@@ -7057,8 +7028,7 @@ Parser::parse_if_expr (\n \t\t\t\t\t ::std::move (if_body),\n \t\t\t\t\t ::std::move (else_body), locus));\n \t  }\n-\tcase IF:\n-\t  {\n+\t  case IF: {\n \t    // multiple selection - else if or else if let\n \t    // branch on whether next token is 'let' or not\n \t    if (lexer.peek_token (1)->get_id () == LET)\n@@ -7200,8 +7170,7 @@ Parser::parse_if_let_expr (\n       const_TokenPtr t = lexer.peek_token ();\n       switch (t->get_id ())\n \t{\n-\tcase LEFT_CURLY:\n-\t  {\n+\t  case LEFT_CURLY: {\n \t    // double selection - else\n \t    // parse else block expr (required)\n \t    ::std::unique_ptr<AST::BlockExpr> else_body = parse_block_expr ();\n@@ -7220,8 +7189,7 @@ Parser::parse_if_let_expr (\n \t\t\t\t\t    ::std::move (if_let_body),\n \t\t\t\t\t    ::std::move (else_body), locus));\n \t  }\n-\tcase IF:\n-\t  {\n+\t  case IF: {\n \t    // multiple selection - else if or else if let\n \t    // branch on whether next token is 'let' or not\n \t    if (lexer.peek_token (1)->get_id () == LET)\n@@ -8207,8 +8175,7 @@ Parser::parse_type ()\n     case LEFT_SQUARE:\n       // slice type or array type - requires further disambiguation\n       return parse_slice_or_array_type ();\n-    case LEFT_ANGLE:\n-      {\n+      case LEFT_ANGLE: {\n \t// qualified path in type\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n \tif (path.is_error ())\n@@ -8231,8 +8198,7 @@ Parser::parse_type ()\n     case AMP: // does this also include AMP_AMP?\n       // reference type\n       return parse_reference_type ();\n-    case LIFETIME:\n-      {\n+      case LIFETIME: {\n \t// probably a lifetime bound, so probably type param bounds in\n \t// TraitObjectType\n \t::std::vector< ::std::unique_ptr<AST::TypeParamBound> > bounds\n@@ -8247,8 +8213,7 @@ Parser::parse_type ()\n     case SELF_ALIAS:\n     case CRATE:\n     case DOLLAR_SIGN:\n-    case SCOPE_RESOLUTION:\n-      {\n+      case SCOPE_RESOLUTION: {\n \t// macro invocation or type path - requires further disambiguation.\n \t/* for parsing path component of each rule, perhaps parse it as a\n \t * typepath and attempt conversion to simplepath if a trailing '!' is\n@@ -8273,8 +8238,7 @@ Parser::parse_type ()\n \tt = lexer.peek_token ();\n \tswitch (t->get_id ())\n \t  {\n-\t  case EXCLAM:\n-\t    {\n+\t    case EXCLAM: {\n \t      // macro invocation\n \t      // convert to simple path\n \t      AST::SimplePath macro_path = path.as_simple_path ();\n@@ -8296,8 +8260,7 @@ Parser::parse_type ()\n \t\t\t\t\t  ::std::vector<AST::Attribute> (),\n \t\t\t\t\t  locus));\n \t    }\n-\t  case PLUS:\n-\t    {\n+\t    case PLUS: {\n \t      // type param bounds\n \t      ::std::vector< ::std::unique_ptr<AST::TypeParamBound> > bounds;\n \n@@ -8413,8 +8376,7 @@ Parser::parse_type ()\n \t    new AST::ImplTraitType (::std::move (bounds), locus));\n \t}\n     case DYN:\n-    case QUESTION_MARK:\n-      {\n+      case QUESTION_MARK: {\n \t// either TraitObjectType or TraitObjectTypeOneBound\n \tbool has_dyn = false;\n \tif (t->get_id () == DYN)\n@@ -8664,8 +8626,7 @@ Parser::parse_for_prefixed_type ()\n     case SELF:\n     case SELF_ALIAS:\n     case CRATE:\n-    case DOLLAR_SIGN:\n-      {\n+      case DOLLAR_SIGN: {\n \t// path, so trait type\n \n \t// parse type path to finish parsing trait bound\n@@ -8966,8 +8927,7 @@ Parser::parse_slice_or_array_type ()\n \n       return ::std::unique_ptr<AST::SliceType> (\n \tnew AST::SliceType (::std::move (inner_type), locus));\n-    case SEMICOLON:\n-      {\n+      case SEMICOLON: {\n \t// array type\n \tlexer.skip_token ();\n \n@@ -9014,8 +8974,7 @@ Parser::parse_type_no_bounds ()\n     case LEFT_SQUARE:\n       // slice type or array type - requires further disambiguation\n       return parse_slice_or_array_type ();\n-    case LEFT_ANGLE:\n-      {\n+      case LEFT_ANGLE: {\n \t// qualified path in type\n \tAST::QualifiedPathInType path = parse_qualified_path_in_type ();\n \tif (path.is_error ())\n@@ -9038,8 +8997,7 @@ Parser::parse_type_no_bounds ()\n     case AMP: // does this also include AMP_AMP?\n       // reference type\n       return parse_reference_type ();\n-    case LIFETIME:\n-      {\n+      case LIFETIME: {\n \t// probably a lifetime bound, so probably type param bounds in\n \t// TraitObjectType this is not allowed, but detection here for error\n \t// message\n@@ -9054,8 +9012,7 @@ Parser::parse_type_no_bounds ()\n     case SELF_ALIAS:\n     case CRATE:\n     case DOLLAR_SIGN:\n-    case SCOPE_RESOLUTION:\n-      {\n+      case SCOPE_RESOLUTION: {\n \t// macro invocation or type path - requires further disambiguation.\n \t/* for parsing path component of each rule, perhaps parse it as a\n \t * typepath and attempt conversion to simplepath if a trailing '!' is\n@@ -9081,8 +9038,7 @@ Parser::parse_type_no_bounds ()\n \tt = lexer.peek_token ();\n \tswitch (t->get_id ())\n \t  {\n-\t  case EXCLAM:\n-\t    {\n+\t    case EXCLAM: {\n \t      // macro invocation\n \t      // convert to simple path\n \t      AST::SimplePath macro_path = path.as_simple_path ();\n@@ -9104,8 +9060,7 @@ Parser::parse_type_no_bounds ()\n \t\t\t\t\t  ::std::vector<AST::Attribute> (),\n \t\t\t\t\t  locus));\n \t    }\n-\t  case PLUS:\n-\t    {\n+\t    case PLUS: {\n \t      // type param bounds - not allowed, here for error message\n \t      rust_error_at (t->get_locus (),\n \t\t\t     \"type param bounds (in TraitObjectType) are not \"\n@@ -9178,8 +9133,7 @@ Parser::parse_type_no_bounds ()\n \t    new AST::ImplTraitTypeOneBound (::std::move (value_bound), locus));\n \t}\n     case DYN:\n-    case QUESTION_MARK:\n-      {\n+      case QUESTION_MARK: {\n \t// either TraitObjectTypeOneBound\n \tbool has_dyn = false;\n \tif (t->get_id () == DYN)\n@@ -9506,8 +9460,7 @@ Parser::parse_range_pattern_bound ()\n     case SELF_ALIAS:\n     case CRATE:\n     case SCOPE_RESOLUTION:\n-    case DOLLAR_SIGN:\n-      {\n+      case DOLLAR_SIGN: {\n \t// path in expression\n \tAST::PathInExpression path = parse_path_in_expression ();\n \tif (path.is_error ())\n@@ -9520,8 +9473,7 @@ Parser::parse_range_pattern_bound ()\n \treturn ::std::unique_ptr<AST::RangePatternBoundPath> (\n \t  new AST::RangePatternBoundPath (::std::move (path)));\n       }\n-    case LEFT_ANGLE:\n-      {\n+      case LEFT_ANGLE: {\n \t// qualified path in expression\n \tAST::QualifiedPathInExpression path\n \t  = parse_qualified_path_in_expression ();\n@@ -9611,8 +9563,7 @@ Parser::parse_pattern ()\n     case LEFT_SQUARE:\n       // slice pattern\n       return parse_slice_pattern ();\n-    case LEFT_ANGLE:\n-      {\n+      case LEFT_ANGLE: {\n \t// qualified path in expression or qualified range pattern bound\n \tAST::QualifiedPathInExpression path\n \t  = parse_qualified_path_in_expression ();\n@@ -9647,17 +9598,15 @@ Parser::parse_pattern ()\n     case SELF_ALIAS:\n     case CRATE:\n     case SCOPE_RESOLUTION:\n-    case DOLLAR_SIGN:\n-      {\n+      case DOLLAR_SIGN: {\n \t// path in expression or range pattern bound\n \tAST::PathInExpression path = parse_path_in_expression ();\n \n \tconst_TokenPtr next = lexer.peek_token ();\n \tswitch (next->get_id ())\n \t  {\n \t  case DOT_DOT_EQ:\n-\t  case ELLIPSIS:\n-\t    {\n+\t    case ELLIPSIS: {\n \t      // qualified range pattern bound, so parse rest of range pattern\n \t      bool has_ellipsis_syntax\n \t\t= lexer.peek_token ()->get_id () == ELLIPSIS;\n@@ -9677,8 +9626,7 @@ Parser::parse_pattern ()\n \t  case EXCLAM:\n \t    return parse_macro_invocation_partial (\n \t      ::std::move (path), ::std::vector<AST::Attribute> ());\n-\t  case LEFT_PAREN:\n-\t    {\n+\t    case LEFT_PAREN: {\n \t      // tuple struct\n \t      lexer.skip_token ();\n \n@@ -9701,8 +9649,7 @@ Parser::parse_pattern ()\n \t\tnew AST::TupleStructPattern (::std::move (path),\n \t\t\t\t\t     ::std::move (items)));\n \t    }\n-\t  case LEFT_CURLY:\n-\t    {\n+\t    case LEFT_CURLY: {\n \t      // struct\n \t      lexer.skip_token ();\n \n@@ -9854,8 +9801,7 @@ Parser::parse_grouped_or_tuple_pattern ()\n \n       return ::std::unique_ptr<AST::GroupedPattern> (\n \tnew AST::GroupedPattern (::std::move (initial_pattern), paren_locus));\n-    case COMMA:\n-      {\n+      case COMMA: {\n \t// tuple pattern\n \tlexer.skip_token ();\n \n@@ -10097,8 +10043,7 @@ Parser::parse_ident_leading_pattern ()\n     case EXCLAM:\n       return parse_macro_invocation_partial (::std::move (path),\n \t\t\t\t\t     ::std::vector<AST::Attribute> ());\n-    case LEFT_PAREN:\n-      {\n+      case LEFT_PAREN: {\n \t// tuple struct\n \tlexer.skip_token ();\n \n@@ -10130,8 +10075,7 @@ Parser::parse_ident_leading_pattern ()\n \t  new AST::TupleStructPattern (::std::move (path),\n \t\t\t\t       ::std::move (items)));\n       }\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t// struct\n \tlexer.skip_token ();\n \n@@ -10150,8 +10094,7 @@ Parser::parse_ident_leading_pattern ()\n \t  new AST::StructPattern (::std::move (path), ::std::move (elems)));\n       }\n     case DOT_DOT_EQ:\n-    case ELLIPSIS:\n-      {\n+      case ELLIPSIS: {\n \t// range\n \tbool has_ellipsis_syntax = lexer.peek_token ()->get_id () == ELLIPSIS;\n \n@@ -10166,8 +10109,7 @@ Parser::parse_ident_leading_pattern ()\n \t  ::std::move (lower_bound), ::std::move (upper_bound),\n \t  Linemap::unknown_location (), has_ellipsis_syntax));\n       }\n-    case PATTERN_BIND:\n-      {\n+      case PATTERN_BIND: {\n \t// only allow on single-segment paths\n \tif (path.is_single_segment ())\n \t  {\n@@ -10300,8 +10242,7 @@ Parser::parse_tuple_struct_items ()\n     case RIGHT_PAREN:\n       return ::std::unique_ptr<AST::TupleStructItemsNoRange> (\n \tnew AST::TupleStructItemsNoRange (::std::move (lower_patterns)));\n-    case DOT_DOT:\n-      {\n+      case DOT_DOT: {\n \t// has an upper range that must be parsed separately\n \tlexer.skip_token ();\n \n@@ -10412,8 +10353,7 @@ Parser::parse_struct_pattern_field ()\n   const_TokenPtr t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case INT_LITERAL:\n-      {\n+      case INT_LITERAL: {\n \t// tuple index\n \t::std::string index_str = t->get_str ();\n \tint index = atoi (index_str.c_str ());\n@@ -10443,8 +10383,7 @@ Parser::parse_struct_pattern_field ()\n       // branch on next token\n       switch (lexer.peek_token (1)->get_id ())\n \t{\n-\tcase COLON:\n-\t  {\n+\t  case COLON: {\n \t    // identifier-pattern\n \t    Identifier ident = t->get_str ();\n \t    lexer.skip_token ();\n@@ -10468,8 +10407,7 @@ Parser::parse_struct_pattern_field ()\n \t\t\t\t\t\t   t->get_locus ()));\n \t  }\n \tcase COMMA:\n-\tcase RIGHT_CURLY:\n-\t  {\n+\t  case RIGHT_CURLY: {\n \t    // identifier only\n \t    Identifier ident = t->get_str ();\n \t    lexer.skip_token ();\n@@ -10488,8 +10426,7 @@ Parser::parse_struct_pattern_field ()\n \t  return NULL;\n \t}\n     case REF:\n-    case MUT:\n-      {\n+      case MUT: {\n \t// only identifier\n \tbool has_ref = false;\n \tif (t->get_id () == REF)\n@@ -10557,8 +10494,7 @@ Parser::parse_stmt_or_expr_without_block ()\n   t = lexer.peek_token ();\n   switch (t->get_id ())\n     {\n-    case LET:\n-      {\n+      case LET: {\n \t// let statement\n \t::std::unique_ptr<AST::LetStmt> stmt (\n \t  parse_let_stmt (::std::move (outer_attrs)));\n@@ -10575,48 +10511,42 @@ Parser::parse_stmt_or_expr_without_block ()\n     case CONST:\n     case STATIC_TOK:\n     case TRAIT:\n-    case IMPL:\n-      {\n+      case IMPL: {\n \t::std::unique_ptr<AST::VisItem> item (\n \t  parse_vis_item (::std::move (outer_attrs)));\n \treturn ExprOrStmt (::std::move (item));\n       }\n-    /* TODO: implement union keyword but not really because of\n-     * context-dependence crappy hack way to parse a union written below to\n-     * separate it from the good code. */\n-    // case UNION:\n-    case UNSAFE:\n-      { // maybe - unsafe traits are a thing\n+      /* TODO: implement union keyword but not really because of\n+       * context-dependence crappy hack way to parse a union written below to\n+       * separate it from the good code. */\n+      // case UNION:\n+      case UNSAFE: { // maybe - unsafe traits are a thing\n \t// if any of these (should be all possible VisItem prefixes), parse a\n \t// VisItem can't parse item because would require reparsing outer\n \t// attributes\n \tconst_TokenPtr t2 = lexer.peek_token (1);\n \tswitch (t2->get_id ())\n \t  {\n-\t  case LEFT_CURLY:\n-\t    {\n+\t    case LEFT_CURLY: {\n \t      // unsafe block\n \t      ::std::unique_ptr<AST::ExprStmtWithBlock> stmt (\n \t\tparse_expr_stmt_with_block (::std::move (outer_attrs)));\n \t      return ExprOrStmt (::std::move (stmt));\n \t    }\n-\t  case TRAIT:\n-\t    {\n+\t    case TRAIT: {\n \t      // unsafe trait\n \t      ::std::unique_ptr<AST::VisItem> item (\n \t\tparse_vis_item (::std::move (outer_attrs)));\n \t      return ExprOrStmt (::std::move (item));\n \t    }\n \t  case EXTERN_TOK:\n-\t  case FN_TOK:\n-\t    {\n+\t    case FN_TOK: {\n \t      // unsafe function\n \t      ::std::unique_ptr<AST::VisItem> item (\n \t\tparse_vis_item (::std::move (outer_attrs)));\n \t      return ExprOrStmt (::std::move (item));\n \t    }\n-\t  case IMPL:\n-\t    {\n+\t    case IMPL: {\n \t      // unsafe trait impl\n \t      ::std::unique_ptr<AST::VisItem> item (\n \t\tparse_vis_item (::std::move (outer_attrs)));\n@@ -10635,8 +10565,7 @@ Parser::parse_stmt_or_expr_without_block ()\n     case SUPER:\n     case SELF:\n     case CRATE:\n-    case DOLLAR_SIGN:\n-      {\n+      case DOLLAR_SIGN: {\n \t/* path-based thing so struct/enum or path or macro invocation of a\n \t * kind. however, the expressions are composable (i think) */\n \n@@ -10668,16 +10597,14 @@ Parser::parse_stmt_or_expr_without_block ()\n     case IF:\n     case MATCH_TOK:\n     case LEFT_CURLY:\n-    case ASYNC:\n-      {\n+      case ASYNC: {\n \t// all expressions with block, so cannot be final expr without block in\n \t// function\n \t::std::unique_ptr<AST::ExprStmtWithBlock> stmt (\n \t  parse_expr_stmt_with_block (::std::move (outer_attrs)));\n \treturn ExprOrStmt (::std::move (stmt));\n       }\n-    case LIFETIME:\n-      {\n+      case LIFETIME: {\n \t/* FIXME: are there any expressions without blocks that can have\n \t * lifetime as their first token? Or is loop expr the only one? */\n \t// safe side for now:\n@@ -10757,8 +10684,7 @@ Parser::parse_stmt_or_expr_without_block ()\n \t}\n       gcc_fallthrough ();\n       // TODO: find out how to disable gcc \"implicit fallthrough\" warning\n-    default:\n-      {\n+      default: {\n \t// expression statement (without block) or expression itself - parse\n \t// expression then make it statement if semi afterwards\n \n@@ -10796,8 +10722,7 @@ Parser::parse_path_based_stmt_or_expr (\n   const_TokenPtr t2 = lexer.peek_token ();\n   switch (t2->get_id ())\n     {\n-    case EXCLAM:\n-      {\n+      case EXCLAM: {\n \t// macro invocation or macro invocation semi - depends on whether there\n \t// is a final ';' convert path in expr to simple path (as that is used\n \t// in macros)\n@@ -10912,8 +10837,7 @@ Parser::parse_path_based_stmt_or_expr (\n \t    return ExprOrStmt::create_error ();\n \t  }\n       }\n-    case LEFT_CURLY:\n-      {\n+      case LEFT_CURLY: {\n \t/* definitely not a block:\n \t *  path '{' ident ','\n \t *  path '{' ident ':' [anything] ','\n@@ -10924,7 +10848,7 @@ Parser::parse_path_based_stmt_or_expr (\n \t\t\t       || (lexer.peek_token (2)->get_id () == COLON\n \t\t\t\t   && (lexer.peek_token (4)->get_id () == COMMA\n \t\t\t\t       || !can_tok_start_type (\n-\t\t\t\t\t    lexer.peek_token (3)->get_id ()))));\n+\t\t\t\t\t lexer.peek_token (3)->get_id ()))));\n \t::std::unique_ptr<AST::ExprWithoutBlock> expr = NULL;\n \n \tif (not_a_block)\n@@ -10965,8 +10889,7 @@ Parser::parse_path_based_stmt_or_expr (\n \t// otherwise, expression\n \treturn ExprOrStmt (::std::move (expr));\n       }\n-    case LEFT_PAREN:\n-      {\n+      case LEFT_PAREN: {\n \t// assume struct expr tuple (as struct-enum disambiguation requires name\n \t// lookup) again, make statement if final ';'\n \t::std::unique_ptr<AST::StructExprTuple> struct_expr\n@@ -10993,8 +10916,7 @@ Parser::parse_path_based_stmt_or_expr (\n \t// otherwise, expression\n \treturn ExprOrStmt (::std::move (struct_expr));\n       }\n-    default:\n-      {\n+      default: {\n \t// assume path - make statement if final ';'\n \t// lexer.skip_token();\n \n@@ -11067,8 +10989,7 @@ Parser::parse_struct_expr_field ()\n \t  return ::std::unique_ptr<AST::StructExprFieldIdentifier> (\n \t    new AST::StructExprFieldIdentifier (::std::move (ident)));\n \t}\n-    case INT_LITERAL:\n-      {\n+      case INT_LITERAL: {\n \t// parse tuple index field\n \tint index = atoi (t->get_str ().c_str ());\n \tlexer.skip_token ();\n@@ -11478,21 +11399,21 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \n   switch (tok->get_id ())\n     {\n-    /*case IDENTIFIER: {\n-\t// when encountering identifier, lookup in scope\n-\tSymbolPtr s = scope.lookup(tok->get_str());\n-\tif (s == NULL) {\n-\t    rust_error_at(tok->get_locus(), \"variable '%s' not declared in the\n-    current scope\", tok->get_str().c_str());\n+      /*case IDENTIFIER: {\n+\t  // when encountering identifier, lookup in scope\n+\t  SymbolPtr s = scope.lookup(tok->get_str());\n+\t  if (s == NULL) {\n+\t      rust_error_at(tok->get_locus(), \"variable '%s' not declared in the\n+      current scope\", tok->get_str().c_str());\n \n-\t    return Tree::error();\n-\t}\n-\t// expression is just its VAR_DECL that was stored in the Symbol at\n-    declaration return Tree(s->get_tree_decl(), tok->get_locus());\n-    }*/\n-    // symbol table must be created in semantic analysis pass, so can't use this\n-    case IDENTIFIER:\n-      {\n+\t      return Tree::error();\n+\t  }\n+\t  // expression is just its VAR_DECL that was stored in the Symbol at\n+      declaration return Tree(s->get_tree_decl(), tok->get_locus());\n+      }*/\n+      // symbol table must be created in semantic analysis pass, so can't use\n+      // this\n+      case IDENTIFIER: {\n \t// DEBUG\n \tfprintf (stderr, \"beginning null denotation identifier handling\\n\");\n \n@@ -11512,15 +11433,14 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t    // macro\n \t    return parse_macro_invocation_partial (::std::move (path),\n \t\t\t\t\t\t   ::std::move (outer_attrs));\n-\t  case LEFT_CURLY:\n-\t    {\n+\t    case LEFT_CURLY: {\n \t      bool not_a_block\n \t\t= lexer.peek_token (1)->get_id () == IDENTIFIER\n \t\t  && (lexer.peek_token (2)->get_id () == COMMA\n \t\t      || (lexer.peek_token (2)->get_id () == COLON\n \t\t\t  && (lexer.peek_token (4)->get_id () == COMMA\n \t\t\t      || !can_tok_start_type (\n-\t\t\t\t   lexer.peek_token (3)->get_id ()))));\n+\t\t\t\tlexer.peek_token (3)->get_id ()))));\n \n \t      /* definitely not a block:\n \t       *  path '{' ident ','\n@@ -11598,12 +11518,11 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t  }\n \tgcc_unreachable ();\n       }\n-    // FIXME: delegate to parse_literal_expr instead? would have to rejig tokens\n-    // and whatever.\n-    // FIXME: could also be path expression (and hence macro expression,\n-    // struct/enum expr)\n-    case LEFT_ANGLE:\n-      {\n+      // FIXME: delegate to parse_literal_expr instead? would have to rejig\n+      // tokens and whatever.\n+      // FIXME: could also be path expression (and hence macro expression,\n+      // struct/enum expr)\n+      case LEFT_ANGLE: {\n \t// qualified path\n \t// HACK: add outer attrs to path\n \tAST::QualifiedPathInExpression path\n@@ -11633,8 +11552,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n     case FALSE_LITERAL:\n       return ::std::unique_ptr<AST::LiteralExpr> (\n \tnew AST::LiteralExpr (\"false\", AST::Literal::BOOL, tok->get_locus ()));\n-    case LEFT_PAREN:\n-      { // have to parse whole expression if inside brackets\n+      case LEFT_PAREN: { // have to parse whole expression if inside brackets\n \t/* recursively invoke parse_expression with lowest priority possible as\n \t * it it were a top-level expression. */\n \t/*AST::Expr* expr = parse_expr();\n@@ -11652,24 +11570,23 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \n \treturn parse_grouped_or_tuple_expr (::std::move (outer_attrs), true);\n       }\n-    /*case PLUS: { // unary plus operator\n-\t// invoke parse_expr recursively with appropriate priority, etc. for\n-    below AST::Expr* expr = parse_expr(LBP_UNARY_PLUS);\n+      /*case PLUS: { // unary plus operator\n+\t  // invoke parse_expr recursively with appropriate priority, etc. for\n+      below AST::Expr* expr = parse_expr(LBP_UNARY_PLUS);\n \n-\tif (expr == NULL)\n-\t    return NULL;\n-\t// can only apply to integer and float expressions\n-\tif (expr->get_type() != integer_type_node || expr->get_type() !=\n-    float_type_node) { rust_error_at(tok->get_locus(), \"operand of unary plus\n-    must be int or float but it is %s\", print_type(expr->get_type())); return\n-    NULL;\n-\t}\n+\t  if (expr == NULL)\n+\t      return NULL;\n+\t  // can only apply to integer and float expressions\n+\t  if (expr->get_type() != integer_type_node || expr->get_type() !=\n+      float_type_node) { rust_error_at(tok->get_locus(), \"operand of unary plus\n+      must be int or float but it is %s\", print_type(expr->get_type())); return\n+      NULL;\n+\t  }\n \n-\treturn Tree(expr, tok->get_locus());\n-    }*/\n-    // Rust has no unary plus operator\n-    case MINUS:\n-      { // unary minus\n+\t  return Tree(expr, tok->get_locus());\n+      }*/\n+      // Rust has no unary plus operator\n+      case MINUS: { // unary minus\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \t::std::unique_ptr<AST::Expr> expr\n@@ -11694,8 +11611,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t  new AST::NegationExpr (::std::move (expr), AST::NegationExpr::NEGATE,\n \t\t\t\t ::std::move (outer_attrs), tok->get_locus ()));\n       }\n-    case EXCLAM:\n-      { // logical or bitwise not\n+      case EXCLAM: { // logical or bitwise not\n \tParseRestrictions entered_from_unary;\n \tentered_from_unary.entered_from_unary = true;\n \t::std::unique_ptr<AST::Expr> expr\n@@ -11719,8 +11635,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t  new AST::NegationExpr (::std::move (expr), AST::NegationExpr::NOT,\n \t\t\t\t ::std::move (outer_attrs), tok->get_locus ()));\n       }\n-    case ASTERISK:\n-      {\n+      case ASTERISK: {\n \t// pointer dereference only - HACK: as struct expressions should always\n \t// be value expressions, cannot be dereferenced\n \tParseRestrictions entered_from_unary;\n@@ -11735,8 +11650,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t\t\t\t    ::std::move (outer_attrs),\n \t\t\t\t    tok->get_locus ()));\n       }\n-    case AMP:\n-      {\n+      case AMP: {\n \t// (single) \"borrow\" expression - shared (mutable) or immutable\n \t::std::unique_ptr<AST::Expr> expr = NULL;\n \tbool is_mut_borrow = false;\n@@ -11766,8 +11680,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t  new AST::BorrowExpr (::std::move (expr), is_mut_borrow, false,\n \t\t\t       ::std::move (outer_attrs), tok->get_locus ()));\n       }\n-    case LOGICAL_AND:\n-      {\n+      case LOGICAL_AND: {\n \t// (double) \"borrow\" expression - shared (mutable) or immutable\n \t::std::unique_ptr<AST::Expr> expr = NULL;\n \tbool is_mut_borrow = false;\n@@ -11794,8 +11707,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t  new AST::BorrowExpr (::std::move (expr), is_mut_borrow, true,\n \t\t\t       ::std::move (outer_attrs), tok->get_locus ()));\n       }\n-    case SCOPE_RESOLUTION:\n-      {\n+      case SCOPE_RESOLUTION: {\n \t// TODO: fix: this is for global paths, i.e. ::std::string::whatever\n \trust_error_at (tok->get_locus (),\n \t\t       \"found null denotation scope resolution operator, and \"\n@@ -11806,8 +11718,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n     case SELF_ALIAS:\n     case DOLLAR_SIGN:\n     case CRATE:\n-    case SUPER:\n-      {\n+      case SUPER: {\n \t// DEBUG\n \tfprintf (stderr, \"beginning null denotation \"\n \t\t\t \"self/self-alias/dollar/crate/super handling\\n\");\n@@ -11839,8 +11750,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t    // macro\n \t    return parse_macro_invocation_partial (::std::move (path),\n \t\t\t\t\t\t   ::std::move (outer_attrs));\n-\t  case LEFT_CURLY:\n-\t    {\n+\t    case LEFT_CURLY: {\n \t      // struct/enum expr struct\n \t      fprintf (stderr, \"can_be_struct_expr: %s\\n\",\n \t\t       restrictions.can_be_struct_expr ? \"true\" : \"false\");\n@@ -11851,7 +11761,7 @@ Parser::null_denotation_NEW (const_TokenPtr tok,\n \t\t      || (lexer.peek_token (2)->get_id () == COLON\n \t\t\t  && (lexer.peek_token (4)->get_id () == COMMA\n \t\t\t      || !can_tok_start_type (\n-\t\t\t\t   lexer.peek_token (3)->get_id ()))));\n+\t\t\t\tlexer.peek_token (3)->get_id ()))));\n \n \t      if (!restrictions.can_be_struct_expr && !not_a_block)\n \t\t{\n@@ -11942,9 +11852,8 @@ Parser::left_denotation (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n \n   switch (tok->get_id ())\n     {\n-    // FIXME: allow for outer attributes to be applied\n-    case QUESTION_MARK:\n-      {\n+      // FIXME: allow for outer attributes to be applied\n+      case QUESTION_MARK: {\n \tLocation left_locus = left->get_locus_slow ();\n \t// error propagation expression - unary postfix\n \treturn ::std::unique_ptr<AST::ErrorPropagationExpr> (\n@@ -12108,8 +12017,7 @@ Parser::left_denotation (const_TokenPtr tok, ::std::unique_ptr<AST::Expr> left,\n \t\t     \"found scope resolution operator in left denotation \"\n \t\t     \"function - this should probably be handled elsewhere.\");\n       return NULL;\n-    case DOT:\n-      {\n+      case DOT: {\n \t// field expression or method call - relies on parentheses after next\n \t// identifier or await if token after is \"await\" (unary postfix) or\n \t// tuple index if token after is a decimal int literal\n@@ -13222,8 +13130,7 @@ Parser::parse_struct_expr_struct_partial (\n       /* technically this would give a struct base-only struct, but this\n        * algorithm should work too. As such, AST type not happening. */\n     case IDENTIFIER:\n-    case INT_LITERAL:\n-      {\n+      case INT_LITERAL: {\n \t// struct with struct expr fields\n \n \t// parse struct expr fields\n@@ -13504,8 +13411,7 @@ Parser::parse_closure_expr_pratt (const_TokenPtr tok,\n     case OR:\n       // no parameters, don't skip token\n       break;\n-    case PIPE:\n-      {\n+      case PIPE: {\n \t// actually may have parameters\n \t// don't skip token\n \tconst_TokenPtr t = lexer.peek_token ();\n@@ -13687,10 +13593,8 @@ Parser::debug_dump_lex_output ()\n \n // Parses crate and dumps AST to stderr, recursively.\n void\n-Parser::debug_dump_ast_output ()\n+Parser::debug_dump_ast_output (AST::Crate &crate)\n {\n-  AST::Crate crate = parse_crate ();\n-\n   // print crate \"as string\", which then calls each item as string, etc.\n   fprintf (stderr, \"%s\", crate.as_string ().c_str ());\n }"}, {"sha": "5abfba686b1c324c7832985b9e2d60a38ac5a690", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -556,7 +556,7 @@ class Parser\n \n   // Dumps all lexer output.\n   void debug_dump_lex_output ();\n-  void debug_dump_ast_output ();\n+  void debug_dump_ast_output (AST::Crate &crate);\n \n private:\n   // The lexer associated with the parser."}, {"sha": "b0cfca202b6e950c105221cf5dc2632b6f6d6413", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 855, "deletions": 702, "changes": 1557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a1e8af9d848cb9864cb30476a6ed444538ecba/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=16a1e8af9d848cb9864cb30476a6ed444538ecba", "patch": "@@ -9,769 +9,922 @@\n \n #include \"rust-lex.h\"\n #include \"rust-parse.h\"\n+#include \"rust-resolution.h\"\n \n #include \"rust-target.h\"\n \n #include <algorithm>\n \n-extern Linemap* rust_get_linemap();\n+extern Linemap *\n+rust_get_linemap ();\n \n namespace Rust {\n-    // Simple wrapper for FILE* that simplifies destruction.\n-    struct RAIIFile {\n-        FILE* file;\n-\n-        RAIIFile(const char* filename) : file(fopen(filename, \"r\")) {}\n-\n-        ~RAIIFile() {\n-            fclose(file);\n-        }\n-    };\n-\n-    // Implicitly enable a target_feature (and recursively enable dependencies).\n-    void Session::implicitly_enable_feature(::std::string feature_name) {\n-        // TODO: is this really required since features added would be complete via target spec?\n-\n-        if (!options.target_data.has_key_value_pair(\"target_data\", feature_name)) {\n-            // if feature has dependencies, enable them\n-            if (feature_name == \"aes\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"avx\") {\n-                implicitly_enable_feature(\"sse4.2\");\n-            } else if (feature_name == \"avx2\") {\n-                implicitly_enable_feature(\"avx\");\n-            } else if (feature_name == \"fma\") {\n-                implicitly_enable_feature(\"avx\");\n-            } else if (feature_name == \"pclmulqdq\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sha\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sse2\") {\n-                implicitly_enable_feature(\"sse\");\n-            } else if (feature_name == \"sse3\") {\n-                implicitly_enable_feature(\"sse2\");\n-            } else if (feature_name == \"sse4.1\") {\n-                implicitly_enable_feature(\"sse3\");\n-            } else if (feature_name == \"sse4.2\") {\n-                implicitly_enable_feature(\"sse4.1\");\n-            } else if (feature_name == \"ssse3\") {\n-                implicitly_enable_feature(\"sse3\");\n-            }\n-\n-            options.target_data.insert_key_value_pair(\"target_feature\", ::std::move(feature_name));\n-        }\n+// Simple wrapper for FILE* that simplifies destruction.\n+struct RAIIFile\n+{\n+  FILE *file;\n+\n+  RAIIFile (const char *filename) : file (fopen (filename, \"r\")) {}\n+\n+  ~RAIIFile () { fclose (file); }\n+};\n+\n+// Implicitly enable a target_feature (and recursively enable dependencies).\n+void\n+Session::implicitly_enable_feature (::std::string feature_name)\n+{\n+  // TODO: is this really required since features added would be complete via\n+  // target spec?\n+\n+  if (!options.target_data.has_key_value_pair (\"target_data\", feature_name))\n+    {\n+      // if feature has dependencies, enable them\n+      if (feature_name == \"aes\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"avx\")\n+\t{\n+\t  implicitly_enable_feature (\"sse4.2\");\n+\t}\n+      else if (feature_name == \"avx2\")\n+\t{\n+\t  implicitly_enable_feature (\"avx\");\n+\t}\n+      else if (feature_name == \"fma\")\n+\t{\n+\t  implicitly_enable_feature (\"avx\");\n+\t}\n+      else if (feature_name == \"pclmulqdq\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sha\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sse2\")\n+\t{\n+\t  implicitly_enable_feature (\"sse\");\n+\t}\n+      else if (feature_name == \"sse3\")\n+\t{\n+\t  implicitly_enable_feature (\"sse2\");\n+\t}\n+      else if (feature_name == \"sse4.1\")\n+\t{\n+\t  implicitly_enable_feature (\"sse3\");\n+\t}\n+      else if (feature_name == \"sse4.2\")\n+\t{\n+\t  implicitly_enable_feature (\"sse4.1\");\n+\t}\n+      else if (feature_name == \"ssse3\")\n+\t{\n+\t  implicitly_enable_feature (\"sse3\");\n+\t}\n+\n+      options.target_data.insert_key_value_pair (\"target_feature\",\n+\t\t\t\t\t\t ::std::move (feature_name));\n     }\n+}\n \n-    // Meant to enable all target features. As this will be done by target hook, this method's\n-    // deprecated.\n-    void Session::enable_features() {\n-        bool has_target_crt_static = false;\n-        const char* target = \"PLACEHOLDER\";\n-\n-        fprintf(stderr, \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n-\n-        if (has_target_crt_static) {\n-            // enable \"crt-static\" attribute\n-        }\n-\n-        /* TODO: do this via target hook. have one for each target that implicitly enables the\n-         * features for that platform. Would probably have to make custom target hook. */\n-\n-        /*\n-        if (target == \"x86\" || target == \"x86_64\") {\n-            if (TARGET_ISA_AES) {\n-                // enable aes, implicitly enable sse2\n-                implicitly_enable_feature(\"aes\");\n-            }\n-\n-            if (TARGET_ISA_AVX) {\n-                // enable avx, implicitly enable sse4.2\n-                implicitly_enable_feature(\"sse4.2\");\n-            }\n-\n-            if (TARGET_ISA_AVX2) {\n-                // enable avx2, implicitly enable avx\n-                implicitly_enable_feature(\"avx\");\n-            }\n-\n-            if (TARGET_ISA_BMI) {\n-                // enable bmi1\n-                implicitly_enable_feature(\"bmi1\");\n-            }\n-\n-            if (TARGET_ISA_BMI2) {\n-                // enable bmi2\n-                implicitly_enable_feature(\"bmi2\");\n-            }\n-\n-            if (TARGET_ISA_FMA) {\n-                // enable fma, implicitly enable avx\n-                implicitly_enable_feature(\"fma\");\n-            }\n-\n-            if (TARGET_ISA_FXSR) {\n-                // enable fxsr\n-                implicitly_enable_feature(\"fxsr\");\n-            }\n-\n-            if (TARGET_ISA_LZCNT) {\n-                // enable lzcnt\n-                implicitly_enable_feature(\"lzcnt\");\n-            }\n-\n-            if (TARGET_ISA_VPCLMULQDQ) {\n-                // enable pclmulqdq, implicitly enable sse2\n-                implicitly_enable_feature(\"pclmulqdq\");\n-            }\n-\n-            if (TARGET_ISA_POPCNT) {\n-                // enable popcnt\n-                implicitly_enable_feature(\"popcnt\");\n-            }\n-\n-            if (TARGET_ISA_RDRND) {\n-                // enable rdrand\n-                implicitly_enable_feature(\"rdrand\");\n-            }\n-\n-            if (TARGET_ISA_RDSEED) {\n-                // enable rdseed\n-                implicitly_enable_feature(\"rdseed\");\n-            }\n-\n-            if (TARGET_ISA_SHA) {\n-                // enable sha, implicitly enable sse2\n-                implicitly_enable_feature(\"sha\");\n-            }\n-\n-            if (TARGET_ISA_SSE) {\n-                // enable sse\n-                implicitly_enable_feature(\"sse\");\n-            }\n-\n-            if (TARGET_ISA_SSE2) {\n-                // enable sse2, implicitly enable sse\n-                implicitly_enable_feature(\"sse2\");\n-            }\n-\n-            if (TARGET_ISA_SSE3) {\n-                // enable sse3, implicitly enable sse2\n-                implicitly_enable_feature(\"sse3\");\n-            }\n-\n-            if (TARGET_ISA_SSE4_1) {\n-                // enable sse4.1, implicitly enable sse3\n-                implicitly_enable_feature(\"sse4.1\");\n-            }\n-\n-            if (TARGET_ISA_SSE4_2) {\n-                // enable sse4.2, implicitly enable sse4.1\n-                implicitly_enable_feature(\"sse4.2\");\n-            }\n-\n-            if (TARGET_ISA_SSSE3) {\n-                // enable ssse3, implicitly enable sse3\n-                implicitly_enable_feature(\"ssse3\");\n-            }\n-\n-            if (TARGET_ISA_XSAVE) {\n-                // enable xsave\n-                implicitly_enable_feature(\"xsave\");\n-            }\n-\n-            if (TARGET_ISA_XSAVEC) {\n-                // enable xsavec\n-                implicitly_enable_feature(\"xsavec\");\n-            }\n-\n-            if (TARGET_ISA_XSAVEOPT) {\n-                // enable xsaveopt\n-                implicitly_enable_feature(\"xsaveopt\");\n-            }\n-\n-            if (TARGET_ISA_XSAVES) {\n-                // enable xsaves\n-                implicitly_enable_feature(\"xsaves\");\n-            }\n-        }\n-        options.target_data.features.shrink_to_fit();\n-        ::std::sort(options.target_data.features.begin(), options.target_data.features.end());*/\n+// Meant to enable all target features. As this will be done by target hook,\n+// this method's deprecated.\n+void\n+Session::enable_features ()\n+{\n+  bool has_target_crt_static = false;\n+  const char *target = \"PLACEHOLDER\";\n+\n+  fprintf (\n+    stderr,\n+    \"ERROR: Somewhere in call chain Session::enable_features is called.\\n\");\n+\n+  if (has_target_crt_static)\n+    {\n+      // enable \"crt-static\" attribute\n     }\n \n-    void Session::init() {\n+  /* TODO: do this via target hook. have one for each target that implicitly\n+   * enables the\n+   * features for that platform. Would probably have to make custom target hook.\n+   */\n+\n+  /*\n+  if (target == \"x86\" || target == \"x86_64\") {\n+      if (TARGET_ISA_AES) {\n+\t  // enable aes, implicitly enable sse2\n+\t  implicitly_enable_feature(\"aes\");\n+      }\n+\n+      if (TARGET_ISA_AVX) {\n+\t  // enable avx, implicitly enable sse4.2\n+\t  implicitly_enable_feature(\"sse4.2\");\n+      }\n+\n+      if (TARGET_ISA_AVX2) {\n+\t  // enable avx2, implicitly enable avx\n+\t  implicitly_enable_feature(\"avx\");\n+      }\n+\n+      if (TARGET_ISA_BMI) {\n+\t  // enable bmi1\n+\t  implicitly_enable_feature(\"bmi1\");\n+      }\n+\n+      if (TARGET_ISA_BMI2) {\n+\t  // enable bmi2\n+\t  implicitly_enable_feature(\"bmi2\");\n+      }\n+\n+      if (TARGET_ISA_FMA) {\n+\t  // enable fma, implicitly enable avx\n+\t  implicitly_enable_feature(\"fma\");\n+      }\n+\n+      if (TARGET_ISA_FXSR) {\n+\t  // enable fxsr\n+\t  implicitly_enable_feature(\"fxsr\");\n+      }\n+\n+      if (TARGET_ISA_LZCNT) {\n+\t  // enable lzcnt\n+\t  implicitly_enable_feature(\"lzcnt\");\n+      }\n+\n+      if (TARGET_ISA_VPCLMULQDQ) {\n+\t  // enable pclmulqdq, implicitly enable sse2\n+\t  implicitly_enable_feature(\"pclmulqdq\");\n+      }\n+\n+      if (TARGET_ISA_POPCNT) {\n+\t  // enable popcnt\n+\t  implicitly_enable_feature(\"popcnt\");\n+      }\n+\n+      if (TARGET_ISA_RDRND) {\n+\t  // enable rdrand\n+\t  implicitly_enable_feature(\"rdrand\");\n+      }\n+\n+      if (TARGET_ISA_RDSEED) {\n+\t  // enable rdseed\n+\t  implicitly_enable_feature(\"rdseed\");\n+      }\n+\n+      if (TARGET_ISA_SHA) {\n+\t  // enable sha, implicitly enable sse2\n+\t  implicitly_enable_feature(\"sha\");\n+      }\n+\n+      if (TARGET_ISA_SSE) {\n+\t  // enable sse\n+\t  implicitly_enable_feature(\"sse\");\n+      }\n+\n+      if (TARGET_ISA_SSE2) {\n+\t  // enable sse2, implicitly enable sse\n+\t  implicitly_enable_feature(\"sse2\");\n+      }\n+\n+      if (TARGET_ISA_SSE3) {\n+\t  // enable sse3, implicitly enable sse2\n+\t  implicitly_enable_feature(\"sse3\");\n+      }\n+\n+      if (TARGET_ISA_SSE4_1) {\n+\t  // enable sse4.1, implicitly enable sse3\n+\t  implicitly_enable_feature(\"sse4.1\");\n+      }\n+\n+      if (TARGET_ISA_SSE4_2) {\n+\t  // enable sse4.2, implicitly enable sse4.1\n+\t  implicitly_enable_feature(\"sse4.2\");\n+      }\n+\n+      if (TARGET_ISA_SSSE3) {\n+\t  // enable ssse3, implicitly enable sse3\n+\t  implicitly_enable_feature(\"ssse3\");\n+      }\n+\n+      if (TARGET_ISA_XSAVE) {\n+\t  // enable xsave\n+\t  implicitly_enable_feature(\"xsave\");\n+      }\n+\n+      if (TARGET_ISA_XSAVEC) {\n+\t  // enable xsavec\n+\t  implicitly_enable_feature(\"xsavec\");\n+      }\n+\n+      if (TARGET_ISA_XSAVEOPT) {\n+\t  // enable xsaveopt\n+\t  implicitly_enable_feature(\"xsaveopt\");\n+      }\n+\n+      if (TARGET_ISA_XSAVES) {\n+\t  // enable xsaves\n+\t  implicitly_enable_feature(\"xsaves\");\n+      }\n+  }\n+  options.target_data.features.shrink_to_fit();\n+  ::std::sort(options.target_data.features.begin(),\n+  options.target_data.features.end());*/\n+}\n+\n+void\n+Session::init ()\n+{\n #ifndef TARGET_RUST_OS_INFO\n-# define TARGET_RUST_OS_INFO()\n+#define TARGET_RUST_OS_INFO()\n #endif\n //#define builtin_rust_info(KEY, VALUE) rust_add_target_info (KEY, VALUE)\n // might as well use c++ stuff\n-#define builtin_rust_info(KEY, VALUE) options.target_data.insert_key_value_pair(KEY, VALUE)\n-\n-        // initialise target hooks\n-        //targetrustm.rust_cpu_info();\n-        //targetrustm.rust_os_info();\n-        // ok, that's not working too well TODO - see if can salvage old implementation \n-        TARGET_RUST_CPU_INFO();\n-        TARGET_RUST_OS_INFO();\n-        \n+#define builtin_rust_info(KEY, VALUE)                                          \\\n+  options.target_data.insert_key_value_pair (KEY, VALUE)\n+\n+  // initialise target hooks\n+  // targetrustm.rust_cpu_info();\n+  // targetrustm.rust_os_info();\n+  // ok, that's not working too well TODO - see if can salvage old\n+  // implementation\n+  TARGET_RUST_CPU_INFO ();\n+  TARGET_RUST_OS_INFO ();\n+\n #undef builtin_rust_info\n \n-        // target-independent values that should exist in all targets\n-        options.target_data.insert_key_value_pair(\"target_pointer_width\", std::to_string(POINTER_SIZE));\n-        options.target_data.insert_key_value_pair(\"target_endian\", BYTES_BIG_ENDIAN ? \"big\" : \"little\");\n+  // target-independent values that should exist in all targets\n+  options.target_data.insert_key_value_pair (\"target_pointer_width\",\n+\t\t\t\t\t     std::to_string (POINTER_SIZE));\n+  options.target_data.insert_key_value_pair (\"target_endian\", BYTES_BIG_ENDIAN\n+\t\t\t\t\t\t\t\t? \"big\"\n+\t\t\t\t\t\t\t\t: \"little\");\n+\n+  // TODO: find min atomic width and max atomic width\n+  // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if\n+  // inside bounds) in rustc, min atomic width is a known quantity (or 8 if not\n+  // known), and max is also a known quantity (or is pointer size if not known)\n+  // TODO: add atomic pointer if some criteria is satisfied\n+\n+  // TODO: find whether target has \"atomic cas\"\n \n-        // TODO: find min atomic width and max atomic width\n-        // from it, add atomic-related stuff for sizes 8, 16, 32, 64, and 128 (if inside bounds)\n-        // in rustc, min atomic width is a known quantity (or 8 if not known), and max is also a known quantity (or is pointer size if not known)\n-        // TODO: add atomic pointer if some criteria is satisfied\n+  // add debug_assertions if enabled and proc_macro if crate type has it or\n+  // whatever\n \n-        // TODO: find whether target has \"atomic cas\"\n+  // derived values from hook\n+  options.target_data.init_derived_values ();\n+}\n \n-        // add debug_assertions if enabled and proc_macro if crate type has it or whatever\n+// Initialise default options. Actually called before handle_option, unlike init\n+// itself.\n+void\n+Session::init_options ()\n+{\n+  options.dump_option = CompileOptions::NO_DUMP;\n+}\n \n-        // derived values from hook\n-        options.target_data.init_derived_values();\n+// Handle option selection.\n+bool\n+Session::handle_option (\n+  enum opt_code code, const char *arg, HOST_WIDE_INT value ATTRIBUTE_UNUSED,\n+  int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED,\n+  const struct cl_option_handlers *handlers ATTRIBUTE_UNUSED)\n+{\n+  // used to store whether results of various stuff are successful\n+  bool ret = true;\n+\n+  // Handles options as listed in lang.opt.\n+  switch (code)\n+    {\n+    case OPT_I:\n+      // TODO: add search path\n+      break;\n+    case OPT_L:\n+      // TODO: add library link path or something\n+      break;\n+    case OPT_frust_dump_:\n+      // enable dump and return whether this was successful\n+      if (arg != NULL)\n+\t{\n+\t  ret = enable_dump (::std::string (arg));\n+\t}\n+      else\n+\t{\n+\t  ret = false;\n+\t}\n+      break;\n+    // no option handling for -o\n+    default:\n+      // return 1 to indicate option is valid\n+      break;\n     }\n \n-    // Initialise default options. Actually called before handle_option, unlike init itself.\n-    void Session::init_options() {\n-        options.dump_option = CompileOptions::NO_DUMP;\n+  return ret;\n+}\n+\n+/* Enables a certain dump depending on the name passed in. Returns true if name\n+ * is valid, false otherwise. */\n+bool\n+Session::enable_dump (::std::string arg)\n+{\n+  // FIXME: change dumping algorithm when new non-inhibiting dump system is\n+  // created\n+  if (arg == \"all\")\n+    {\n+      error_at (\n+\tUNKNOWN_LOCATION,\n+\t\"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n+      return false;\n+    }\n+  else if (arg == \"lex\")\n+    {\n+      options.dump_option = CompileOptions::LEXER_DUMP;\n+    }\n+  else if (arg == \"parse\")\n+    {\n+      options.dump_option = CompileOptions::PARSER_AST_DUMP;\n+    }\n+  else if (arg == \"register_plugins\")\n+    {\n+      options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n     }\n+  else if (arg == \"injection\")\n+    {\n+      options.dump_option = CompileOptions::INJECTION_DUMP;\n+    }\n+  else if (arg == \"expansion\")\n+    {\n+      options.dump_option = CompileOptions::EXPANSION_DUMP;\n+    }\n+  else if (arg == \"name_resolution\")\n+    {\n+      options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n+    }\n+  else if (arg == \"target_options\")\n+    {\n+      // special case - dump all target options, and then quit compilation\n+      // nope, option handling called before init, so have to make this an\n+      // actual compile option\n+      // options.target_data.dump_target_options();\n+      // return false;\n+      options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n+    }\n+  else if (arg == \"\")\n+    {\n+      error_at (UNKNOWN_LOCATION,\n+\t\t\"dump option was not given a name. choose 'lex' or 'parse'\");\n+      return false;\n+    }\n+  else\n+    {\n+      error_at (UNKNOWN_LOCATION,\n+\t\t\"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n+\t\targ.c_str ());\n+      return false;\n+    }\n+  return true;\n+}\n \n-    // Handle option selection.\n-    bool Session::handle_option(enum opt_code code, const char* arg,\n-      HOST_WIDE_INT value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED,\n-      location_t loc ATTRIBUTE_UNUSED, const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n-        // used to store whether results of various stuff are successful\n-        bool ret = true;\n-\n-        // Handles options as listed in lang.opt.\n-        switch (code) {\n-            case OPT_I:\n-                // TODO: add search path\n-                break;\n-            case OPT_L:\n-                // TODO: add library link path or something\n-                break;\n-            case OPT_frust_dump_:\n-                // enable dump and return whether this was successful\n-                if (arg != NULL) {\n-                    ret = enable_dump(::std::string(arg));\n-                } else {\n-                    ret = false;\n-                }\n-                break;\n-            // no option handling for -o\n-            default:\n-                // return 1 to indicate option is valid\n-                break;\n-        }\n-\n-        return ret;\n+/* Actual main entry point for front-end. Called from langhook to parse files.\n+ */\n+void\n+Session::parse_files (int num_files, const char **files)\n+{\n+  for (int i = 0; i < num_files; i++)\n+    {\n+      parse_file (files[i]);\n     }\n+  // TODO: should semantic analysis be dealed with here? or per file? for now,\n+  // per-file.\n+}\n+\n+// Parses a single file with filename filename.\n+void\n+Session::parse_file (const char *filename)\n+{\n+  RAIIFile file_wrap (filename);\n \n-    /* Enables a certain dump depending on the name passed in. Returns true if name is valid, false\n-     * otherwise. */\n-    bool Session::enable_dump(::std::string arg) {\n-        // FIXME: change dumping algorithm when new non-inhibiting dump system is created\n-        if (arg == \"all\") {\n-            error_at(\n-              UNKNOWN_LOCATION, \"dumping all is not supported as of now. choose 'lex' or 'parse'\");\n-            return false;\n-        } else if (arg == \"lex\") {\n-            options.dump_option = CompileOptions::LEXER_DUMP;\n-        } else if (arg == \"parse\") {\n-            options.dump_option = CompileOptions::PARSER_AST_DUMP;\n-        } else if (arg == \"register_plugins\") {\n-            options.dump_option = CompileOptions::REGISTER_PLUGINS_DUMP;\n-        } else if (arg == \"injection\") {\n-            options.dump_option = CompileOptions::INJECTION_DUMP;\n-        } else if (arg == \"expansion\") {\n-            options.dump_option = CompileOptions::EXPANSION_DUMP;\n-        } else if (arg == \"name_resolution\") {\n-            options.dump_option = CompileOptions::NAME_RESOLUTION_DUMP;\n-        } else if (arg == \"target_options\") {\n-            // special case - dump all target options, and then quit compilation\n-            // nope, option handling called before init, so have to make this an actual compile option\n-            //options.target_data.dump_target_options();\n-            //return false;\n-            options.dump_option = CompileOptions::TARGET_OPTION_DUMP;\n-        } else if (arg == \"\") {\n-            error_at(UNKNOWN_LOCATION, \"dump option was not given a name. choose 'lex' or 'parse'\");\n-            return false;\n-        } else {\n-            error_at(UNKNOWN_LOCATION, \"dump option '%s' was unrecognised. choose 'lex' or 'parse'\",\n-              arg.c_str());\n-            return false;\n-        }\n-        return true;\n+  if (file_wrap.file == NULL)\n+    {\n+      fatal_error (UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n     }\n \n-    /* Actual main entry point for front-end. Called from langhook to parse files. */\n-    void Session::parse_files(int num_files, const char** files) {\n-        for (int i = 0; i < num_files; i++) {\n-            parse_file(files[i]);\n-        }\n-        // TODO: should semantic analysis be dealed with here? or per file? for now, per-file.\n+  // parse file here\n+  // create lexer and parser - these are file-specific and so aren't instance\n+  // variables\n+  Rust::Lexer lex (filename, file_wrap.file, rust_get_linemap ());\n+  Rust::Parser parser (lex);\n+\n+  // generate crate from parser\n+  auto parsed_crate = parser.parse_crate ();\n+\n+  // give a chance to give some debug\n+  switch (options.dump_option)\n+    {\n+    case CompileOptions::LEXER_DUMP:\n+      parser.debug_dump_lex_output ();\n+      break;\n+    case CompileOptions::PARSER_AST_DUMP:\n+      parser.debug_dump_ast_output (parsed_crate);\n+      break;\n+    default:\n+      break;\n     }\n \n-    // Parses a single file with filename filename.\n-    void Session::parse_file(const char* filename) {\n-        RAIIFile file_wrap(filename);\n-\n-        if (file_wrap.file == NULL) {\n-            fatal_error(UNKNOWN_LOCATION, \"cannot open filename %s: %m\", filename);\n-        }\n-\n-        // parse file here\n-        // create lexer and parser - these are file-specific and so aren't instance variables\n-        Rust::Lexer lex(filename, file_wrap.file, rust_get_linemap());\n-        Rust::Parser parser(lex);\n-\n-        // determine parsing method from options\n-        /* FIXME: currently, the dump means that full compilation will not occur as of present. In\n-         * future, dumps should not inhibit full compilation. */\n-        switch (options.dump_option) {\n-            case CompileOptions::NO_DUMP:\n-                fatal_error(UNKNOWN_LOCATION, \"no-dump parsing has not been enabled yet\");\n-                return;\n-            case CompileOptions::LEXER_DUMP:\n-                parser.debug_dump_lex_output();\n-                return;\n-            case CompileOptions::PARSER_AST_DUMP:\n-                parser.debug_dump_ast_output();\n-                return;\n-            case CompileOptions::REGISTER_PLUGINS_DUMP:\n-            case CompileOptions::INJECTION_DUMP:\n-            case CompileOptions::EXPANSION_DUMP:\n-            case CompileOptions::NAME_RESOLUTION_DUMP:\n-                // will break later after more stages\n-                break;\n-            // semantic analysis when completed\n-            case CompileOptions::TARGET_OPTION_DUMP:\n-                options.target_data.dump_target_options();\n-                return;\n-            default:\n-                fatal_error(UNKNOWN_LOCATION, \"unrecognised dump option: '%u'\", options.dump_option);\n-                return;\n-        }\n-\n-        /* basic pipeline:\n-         *  - lex\n-         *  - parse\n-         *  - register plugins (dummy stage for now) - attribute injection? what is this?\n-         *    (attribute injection is injecting attributes specified in command line into crate root)\n-         *  - injection (some lint checks or dummy, register builtin macros, crate injection)\n-         *  - expansion (expands all macros, maybe build test harness, AST validation, maybe macro\n-         * crate)\n-         *  - name resolution (name resolution, maybe feature checking, maybe buffered lints)\n-         *  TODO not done */\n-\n-        // generate crate from parser\n-        AST::Crate parsed_crate = parser.parse_crate();\n-\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n-\n-        // register plugins pipeline stage\n-        register_plugins(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP) {\n-            // TODO: what do I dump here?\n-            return;\n-        }\n-\n-        // injection pipeline stage\n-        injection(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::INJECTION_DUMP) {\n-            // TODO: what do I dump here? injected crate names?\n-            return;\n-        }\n-\n-        // expansion pipeline stage\n-        expansion(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::EXPANSION_DUMP) {\n-            // TODO: what do I dump here? expanded macros? AST with expanded macros?\n-            return;\n-        }\n-\n-        // name resolution pipeline stage\n-        name_resolution(parsed_crate);\n-        fprintf(stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n-\n-        if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP) {\n-            // TODO: what do I dump here? resolved names? AST with resolved names?\n-            return;\n-        }\n+  /* basic pipeline:\n+   *  - lex\n+   *  - parse\n+   *  - register plugins (dummy stage for now) - attribute injection? what is\n+   * this? (attribute injection is injecting attributes specified in command\n+   * line into crate root)\n+   *  - injection (some lint checks or dummy, register builtin macros, crate\n+   * injection)\n+   *  - expansion (expands all macros, maybe build test harness, AST validation,\n+   * maybe macro crate)\n+   *  - name resolution (name resolution, maybe feature checking, maybe buffered\n+   * lints)\n+   *  TODO not done */\n+\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY PARSED CRATE \\n\\033[0m\");\n+\n+  // register plugins pipeline stage\n+  register_plugins (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY REGISTERED PLUGINS \\n\\033[0m\");\n+\n+  if (options.dump_option == CompileOptions::REGISTER_PLUGINS_DUMP)\n+    {\n+      // TODO: what do I dump here?\n+      return;\n     }\n \n-    // Checks whether 'cfg' attribute prevents compilation.\n-    bool check_cfg(const AST::Attribute& attr ATTRIBUTE_UNUSED) {\n-        // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+  // injection pipeline stage\n+  injection (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED INJECTION \\n\\033[0m\");\n+\n+  if (options.dump_option == CompileOptions::INJECTION_DUMP)\n+    {\n+      // TODO: what do I dump here? injected crate names?\n+      return;\n+    }\n \n-        // TODO: actually implement. assume true for now\n+  // expansion pipeline stage\n+  expansion (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\n\\033[0m\");\n \n-        return true;\n+  if (options.dump_option == CompileOptions::EXPANSION_DUMP)\n+    {\n+      // TODO: what do I dump here? expanded macros? AST with expanded macros?\n+      return;\n     }\n-    // TODO: deprecated - don't use\n \n-    // Checks whether any 'cfg' attribute on the item prevents compilation of that item.\n-    bool check_item_cfg(::std::vector<AST::Attribute> attrs) {\n-        for (const auto& attr : attrs) {\n-            if (attr.get_path() == \"cfg\" && !check_cfg(attr)) {\n-                return false;\n-            }\n-        }\n+  // name resolution pipeline stage\n+  name_resolution (parsed_crate);\n+  fprintf (stderr, \"\\033[0;31mSUCCESSFULLY FINISHED NAME RESOLUTION \\n\\033[0m\");\n \n-        return true;\n+  if (options.dump_option == CompileOptions::NAME_RESOLUTION_DUMP)\n+    {\n+      // TODO: what do I dump here? resolved names? AST with resolved names?\n+      return;\n     }\n-    // TODO: deprecated - don't use\n-\n-    // TODO: actually implement method\n-    void load_extern_crate(::std::string crate_name ATTRIBUTE_UNUSED) {}\n-    // TODO: deprecated - don't use\n-\n-    // Parses up to the \"load (external) crates\" part of the frontend.\n-    // TODO: lots of this code is probably actually useful outside of dumping, so maybe split off\n-    // function\n-    void Session::debug_dump_load_crates(Parser& parser) {\n-        // parse crate as AST\n-        AST::Crate crate = parser.parse_crate();\n-\n-        /* TODO: search through inner attrs and see whether any of those attr paths contain \"no_core\",\n-         * \"no_std\", \"compiler_builtins\". If so/not, save certain crate names. In these names, insert\n-         * items at beginning of crate items. This is crate injection. Also, inject prelude use decl\n-         * at beginning (first name is assumed to be prelude - prelude is a use decl automatically\n-         * generated to enable using Option and Copy without qualifying it or importing it via 'use'\n-         * manually) */\n-\n-        ::std::vector< ::std::string> crate_names;\n-        for (const auto& item : crate.items) {\n-            // if item is extern crate, add name? to list of stuff ONLY IF config is checked\n-            // if item is module, iterate this loop inside it as well (recursive?) ONLY IF config is\n-            // checked\n-\n-            // TODO: actually do the checks somewhere - probably in the items\n-\n-            item->add_crate_name(crate_names);\n-        }\n-\n-        /* loop through list of crate names/paths/whatever, attempting to load each one. save loaded\n-         * crates to a Session variable? Or save to current AST::Crate? */\n-        for (const auto& name : crate_names) {\n-            load_extern_crate(name /*, basename = \"\"?*/);\n-        }\n-        //  for each loaded crate, load dependencies of it as well\n+}\n+\n+// Checks whether 'cfg' attribute prevents compilation.\n+bool\n+check_cfg (const AST::Attribute &attr ATTRIBUTE_UNUSED)\n+{\n+  // if \"has sub items\", and if 'cfg' attr, recursively call this on sub items?\n+\n+  // TODO: actually implement. assume true for now\n+\n+  return true;\n+}\n+// TODO: deprecated - don't use\n+\n+// Checks whether any 'cfg' attribute on the item prevents compilation of that\n+// item.\n+bool\n+check_item_cfg (::std::vector<AST::Attribute> attrs)\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == \"cfg\" && !check_cfg (attr))\n+\t{\n+\t  return false;\n+\t}\n     }\n-    // TODO: deprecated - don't use\n \n-    void Session::register_plugins(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"ran register_plugins (with no body)\\n\");\n+  return true;\n+}\n+// TODO: deprecated - don't use\n+\n+// TODO: actually implement method\n+void\n+load_extern_crate (::std::string crate_name ATTRIBUTE_UNUSED)\n+{}\n+// TODO: deprecated - don't use\n+\n+// Parses up to the \"load (external) crates\" part of the frontend.\n+// TODO: lots of this code is probably actually useful outside of dumping, so\n+// maybe split off function\n+void\n+Session::debug_dump_load_crates (Parser &parser)\n+{\n+  // parse crate as AST\n+  AST::Crate crate = parser.parse_crate ();\n+\n+  /* TODO: search through inner attrs and see whether any of those attr paths\n+   * contain \"no_core\", \"no_std\", \"compiler_builtins\". If so/not, save certain\n+   * crate names. In these names, insert items at beginning of crate items. This\n+   * is crate injection. Also, inject prelude use decl at beginning (first name\n+   * is assumed to be prelude - prelude is a use decl automatically generated to\n+   * enable using Option and Copy without qualifying it or importing it via\n+   * 'use' manually) */\n+\n+  ::std::vector< ::std::string> crate_names;\n+  for (const auto &item : crate.items)\n+    {\n+      // if item is extern crate, add name? to list of stuff ONLY IF config is\n+      // checked if item is module, iterate this loop inside it as well\n+      // (recursive?) ONLY IF config is checked\n+\n+      // TODO: actually do the checks somewhere - probably in the items\n+\n+      item->add_crate_name (crate_names);\n     }\n \n-    // TODO: move somewhere else\n-    bool contains_name(const std::vector<AST::Attribute>& attrs, std::string name) {\n-        for (const auto& attr : attrs) {\n-            if (attr.get_path() == name) {\n-                return true;\n-            }\n-        }\n+  /* loop through list of crate names/paths/whatever, attempting to load each\n+   * one. save loaded crates to a Session variable? Or save to current\n+   * AST::Crate? */\n+  for (const auto &name : crate_names)\n+    {\n+      load_extern_crate (name /*, basename = \"\"?*/);\n+    }\n+  //  for each loaded crate, load dependencies of it as well\n+}\n+// TODO: deprecated - don't use\n+\n+void\n+Session::register_plugins (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  fprintf (stderr, \"ran register_plugins (with no body)\\n\");\n+}\n \n-        return false;\n+// TODO: move somewhere else\n+bool\n+contains_name (const std::vector<AST::Attribute> &attrs, std::string name)\n+{\n+  for (const auto &attr : attrs)\n+    {\n+      if (attr.get_path () == name)\n+\t{\n+\t  return true;\n+\t}\n     }\n \n-    void Session::injection(AST::Crate& crate) {\n-        fprintf(stderr, \"started injection\\n\");\n-\n-        // lint checks in future maybe?\n-\n-        // register builtin macros\n-        /* In rustc, builtin macros are divided into 3 categories depending on use - \"bang\" macros,\n-         * \"attr\" macros, and \"derive\" macros. I think the meanings of these categories should be\n-         * fairly obvious to anyone who has used rust. Builtin macro list by category: Bang\n-         *      - asm\n-         *      - assert\n-         *      - cfg\n-         *      - column\n-         *      - compile_error\n-         *      - concat_idents\n-         *      - concat\n-         *      - env\n-         *      - file\n-         *      - format_args_nl\n-         *      - format_args\n-         *      - global_asm\n-         *      - include_bytes\n-         *      - include_str\n-         *      - include\n-         *      - line\n-         *      - log_syntax\n-         *      - module_path\n-         *      - option_env\n-         *      - stringify\n-         *      - trace_macros\n-         *  Attr\n-         *      - bench\n-         *      - global_allocator\n-         *      - test\n-         *      - test_case\n-         *  Derive\n-         *      - Clone\n-         *      - Copy\n-         *      - Debug\n-         *      - Default\n-         *      - Eq\n-         *      - Hash\n-         *      - Ord\n-         *      - PartialEq\n-         *      - PartialOrd\n-         *      - RustcDecodable\n-         *      - RustcEncodable\n-         * rustc also has a \"quote\" macro that is defined differently and is supposedly not stable so\n-         * eh. */\n-        /* TODO: actually implement injection of these macros. In particular, derive macros, cfg, and\n-         * test should be prioritised since they seem to be used the most. */\n-\n-        // crate injection\n-        ::std::vector< ::std::string> names;\n-        if (contains_name(crate.inner_attrs, \"no_core\")) {\n-            // no prelude\n-            injected_crate_name = \"\";\n-        } else if (contains_name(crate.inner_attrs, \"no_std\")) {\n-            names.push_back(\"core\");\n-\n-            if (!contains_name(crate.inner_attrs, \"compiler_builtins\")) {\n-                names.push_back(\"compiler_builtins\");\n-            }\n-\n-            injected_crate_name = \"core\";\n-        } else {\n-            names.push_back(\"std\");\n-\n-            injected_crate_name = \"std\";\n-        }\n-\n-        // reverse iterate through names to insert crate items in \"forward\" order at beginning of\n-        // crate\n-        for (auto it = names.rbegin(); it != names.rend(); ++it) {\n-            // create \"macro use\" attribute for use on extern crate item to enable loading macros from\n-            // it\n-            AST::Attribute attr(AST::SimplePath::from_str(\"macro_use\"), NULL);\n-\n-            // create \"extern crate\" item with the name\n-            ::std::unique_ptr<AST::ExternCrate> extern_crate(\n-              new AST::ExternCrate(*it, AST::Visibility::create_error(), { ::std::move(attr) },\n-              Linemap::unknown_location()));\n-\n-            // insert at beginning\n-            crate.items.insert(crate.items.begin(), ::std::move(extern_crate));\n-        }\n-\n-        // create use tree path\n-        // prelude is injected_crate_name\n-        ::std::vector<AST::SimplePathSegment> segments\n-          = { AST::SimplePathSegment(injected_crate_name), AST::SimplePathSegment(\"prelude\"),\n-                AST::SimplePathSegment(\"v1\") };\n-        // create use tree and decl\n-        ::std::unique_ptr<AST::UseTreeGlob> use_tree(new AST::UseTreeGlob(\n-          AST::UseTreeGlob::PATH_PREFIXED, AST::SimplePath(::std::move(segments)), Location()));\n-        AST::Attribute prelude_attr(AST::SimplePath::from_str(\"prelude_import\"), NULL);\n-        ::std::unique_ptr<AST::UseDeclaration> use_decl(new AST::UseDeclaration(::std::move(use_tree),\n-          AST::Visibility::create_error(), { ::std::move(prelude_attr) }, Location()));\n-\n-        crate.items.insert(crate.items.begin(), ::std::move(use_decl));\n-\n-        /* TODO: potentially add checking attribute crate type? I can't figure out what this does\n-         * currently comment says \"Unconditionally collect crate types from attributes to make them\n-         * used\", which presumably refers to checking the linkage info by \"crate_type\". It also seems\n-         * to ensure that an invalid crate type is not specified, so maybe just do that. Valid crate\n-         * types: bin lib dylib staticlib cdylib rlib proc-macro */\n-\n-        fprintf(stderr, \"finished injection\\n\");\n+  return false;\n+}\n+\n+void\n+Session::injection (AST::Crate &crate)\n+{\n+  fprintf (stderr, \"started injection\\n\");\n+\n+  // lint checks in future maybe?\n+\n+  // register builtin macros\n+  /* In rustc, builtin macros are divided into 3 categories depending on use -\n+   * \"bang\" macros, \"attr\" macros, and \"derive\" macros. I think the meanings of\n+   * these categories should be fairly obvious to anyone who has used rust.\n+   * Builtin macro list by category: Bang\n+   *      - asm\n+   *      - assert\n+   *      - cfg\n+   *      - column\n+   *      - compile_error\n+   *      - concat_idents\n+   *      - concat\n+   *      - env\n+   *      - file\n+   *      - format_args_nl\n+   *      - format_args\n+   *      - global_asm\n+   *      - include_bytes\n+   *      - include_str\n+   *      - include\n+   *      - line\n+   *      - log_syntax\n+   *      - module_path\n+   *      - option_env\n+   *      - stringify\n+   *      - trace_macros\n+   *  Attr\n+   *      - bench\n+   *      - global_allocator\n+   *      - test\n+   *      - test_case\n+   *  Derive\n+   *      - Clone\n+   *      - Copy\n+   *      - Debug\n+   *      - Default\n+   *      - Eq\n+   *      - Hash\n+   *      - Ord\n+   *      - PartialEq\n+   *      - PartialOrd\n+   *      - RustcDecodable\n+   *      - RustcEncodable\n+   * rustc also has a \"quote\" macro that is defined differently and is\n+   * supposedly not stable so eh. */\n+  /* TODO: actually implement injection of these macros. In particular, derive\n+   * macros, cfg, and\n+   * test should be prioritised since they seem to be used the most. */\n+\n+  // crate injection\n+  ::std::vector< ::std::string> names;\n+  if (contains_name (crate.inner_attrs, \"no_core\"))\n+    {\n+      // no prelude\n+      injected_crate_name = \"\";\n     }\n+  else if (contains_name (crate.inner_attrs, \"no_std\"))\n+    {\n+      names.push_back (\"core\");\n \n-    void Session::expansion(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"started expansion\\n\");\n+      if (!contains_name (crate.inner_attrs, \"compiler_builtins\"))\n+\t{\n+\t  names.push_back (\"compiler_builtins\");\n+\t}\n \n-        // rustc has a modification to windows PATH temporarily here, which may end up being required\n+      injected_crate_name = \"core\";\n+    }\n+  else\n+    {\n+      names.push_back (\"std\");\n \n-        // create macro expansion config?\n-        // if not, would at least have to configure recursion_limit\n+      injected_crate_name = \"std\";\n+    }\n \n-        // create extctxt? from parse session, cfg, and resolver?\n-        // expand by calling cxtctxt object's monotonic_expander's expand_crate method.\n+  // reverse iterate through names to insert crate items in \"forward\" order at\n+  // beginning of crate\n+  for (auto it = names.rbegin (); it != names.rend (); ++it)\n+    {\n+      // create \"macro use\" attribute for use on extern crate item to enable\n+      // loading macros from it\n+      AST::Attribute attr (AST::SimplePath::from_str (\"macro_use\"), NULL);\n+\n+      // create \"extern crate\" item with the name\n+      ::std::unique_ptr<AST::ExternCrate> extern_crate (\n+\tnew AST::ExternCrate (*it, AST::Visibility::create_error (),\n+\t\t\t      {::std::move (attr)},\n+\t\t\t      Linemap::unknown_location ()));\n+\n+      // insert at beginning\n+      crate.items.insert (crate.items.begin (), ::std::move (extern_crate));\n+    }\n \n-        // error reporting - check unused macros, get missing fragment specifiers\n+  // create use tree path\n+  // prelude is injected_crate_name\n+  ::std::vector<AST::SimplePathSegment> segments\n+    = {AST::SimplePathSegment (injected_crate_name),\n+       AST::SimplePathSegment (\"prelude\"), AST::SimplePathSegment (\"v1\")};\n+  // create use tree and decl\n+  ::std::unique_ptr<AST::UseTreeGlob> use_tree (\n+    new AST::UseTreeGlob (AST::UseTreeGlob::PATH_PREFIXED,\n+\t\t\t  AST::SimplePath (::std::move (segments)),\n+\t\t\t  Location ()));\n+  AST::Attribute prelude_attr (AST::SimplePath::from_str (\"prelude_import\"),\n+\t\t\t       NULL);\n+  ::std::unique_ptr<AST::UseDeclaration> use_decl (\n+    new AST::UseDeclaration (::std::move (use_tree),\n+\t\t\t     AST::Visibility::create_error (),\n+\t\t\t     {::std::move (prelude_attr)}, Location ()));\n+\n+  crate.items.insert (crate.items.begin (), ::std::move (use_decl));\n+\n+  /* TODO: potentially add checking attribute crate type? I can't figure out\n+   * what this does currently comment says \"Unconditionally collect crate types\n+   * from attributes to make them used\", which presumably refers to checking the\n+   * linkage info by \"crate_type\". It also seems to ensure that an invalid crate\n+   * type is not specified, so maybe just do that. Valid crate types: bin lib\n+   * dylib staticlib cdylib rlib proc-macro */\n+\n+  fprintf (stderr, \"finished injection\\n\");\n+}\n \n-        // build test harness\n+void\n+Session::expansion (AST::Crate &crate ATTRIBUTE_UNUSED)\n+{\n+  fprintf (stderr, \"started expansion\\n\");\n \n-        // ast validation (also with proc macro decls)\n+  // rustc has a modification to windows PATH temporarily here, which may end up\n+  // being required\n \n-        // maybe create macro crate if not rustdoc\n+  // create macro expansion config?\n+  // if not, would at least have to configure recursion_limit\n \n-        fprintf(stderr, \"finished expansion\\n\");\n-    }\n+  // create extctxt? from parse session, cfg, and resolver?\n+  // expand by calling cxtctxt object's monotonic_expander's expand_crate\n+  // method.\n \n-    void Session::name_resolution(AST::Crate& crate ATTRIBUTE_UNUSED) {\n-        fprintf(stderr, \"started name resolution\\n\");\n+  // error reporting - check unused macros, get missing fragment specifiers\n \n-        fprintf(stderr, \"finished name resolution\\n\");\n-    }\n+  // build test harness\n \n-    void TargetOptions::dump_target_options() const {\n-        fprintf(stderr, \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n-        for (const auto& pairs : features) {\n-            for (const auto& value : pairs.second) {\n-                fprintf(stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str(), value.c_str());\n-            }\n-            if (pairs.second.empty()) {\n-                fprintf(stderr, \"%s\\n\", pairs.first.c_str());\n-            }\n-        }\n-        if (features.empty()) {\n-            fprintf(stderr, \"No target options available!\\n\");\n-        }\n-\n-        fprintf(stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n-    }\n+  // ast validation (also with proc macro decls)\n \n-    void TargetOptions::init_derived_values() {\n-        // enable derived values based on target families\n-        if (has_key_value_pair(\"target_family\", \"unix\"))\n-            insert_key(\"unix\");\n-        if (has_key_value_pair(\"target_family\", \"windows\"))\n-            insert_key(\"windows\");\n-        \n-        // implicitly enable features\n-        if (has_key_value_pair(\"target_feature\", \"aes\"))\n-            enable_implicit_feature_reqs(\"aes\");\n-        if (has_key_value_pair(\"target_feature\", \"avx\"))\n-            enable_implicit_feature_reqs(\"sse4.2\");\n-        if (has_key_value_pair(\"target_feature\", \"avx2\"))\n-            enable_implicit_feature_reqs(\"avx\");\n-        if (has_key_value_pair(\"target_feature\", \"pclmulqdq\"))\n-            enable_implicit_feature_reqs(\"sse2\");\n-        if (has_key_value_pair(\"target_feature\", \"sha\"))\n-            enable_implicit_feature_reqs(\"sse2\");\n-        if (has_key_value_pair(\"target_feature\", \"sse2\"))\n-            enable_implicit_feature_reqs(\"sse\");\n-        if (has_key_value_pair(\"target_feature\", \"sse3\"))\n-            enable_implicit_feature_reqs(\"sse2\");\n-        if (has_key_value_pair(\"target_feature\", \"sse4.1\"))\n-            enable_implicit_feature_reqs(\"sse3\");\n-        if (has_key_value_pair(\"target_feature\", \"sse4.2\"))\n-            enable_implicit_feature_reqs(\"sse4.1\");\n-        if (has_key_value_pair(\"target_feature\", \"ssse3\"))\n-            enable_implicit_feature_reqs(\"sse3\");\n-    }\n+  // maybe create macro crate if not rustdoc\n+\n+  fprintf (stderr, \"finished expansion\\n\");\n+}\n+\n+void\n+Session::name_resolution (AST::Crate &crate)\n+{\n+  fprintf (stderr, \"started name resolution\\n\");\n+  Analysis::TypeResolution::ResolveNamesAndTypes (crate);\n+  fprintf (stderr, \"finished name resolution\\n\");\n+}\n \n-    void TargetOptions::enable_implicit_feature_reqs(std::string feature) {\n-        if (feature == \"aes\") \n-            enable_implicit_feature_reqs(\"sse2\");\n-        else if (feature == \"avx\")\n-            enable_implicit_feature_reqs(\"sse4.2\");\n-        else if (feature == \"avx2\")\n-            enable_implicit_feature_reqs(\"avx\");\n-        else if (feature == \"fma\")\n-            enable_implicit_feature_reqs(\"avx\");\n-        else if (feature == \"pclmulqdq\") \n-            enable_implicit_feature_reqs(\"sse2\");\n-        else if (feature == \"sha\")\n-            enable_implicit_feature_reqs(\"sse2\");\n-        else if (feature == \"sse2\")\n-            enable_implicit_feature_reqs(\"sse\");\n-        else if (feature == \"sse3\")\n-            enable_implicit_feature_reqs(\"sse2\");\n-        else if (feature == \"sse4.1\")\n-            enable_implicit_feature_reqs(\"sse3\");\n-        else if (feature == \"sse4.2\")\n-            enable_implicit_feature_reqs(\"sse4.1\");\n-        else if (feature == \"ssse3\")\n-            enable_implicit_feature_reqs(\"sse3\");\n-\n-        if (!has_key_value_pair(\"target_feature\", feature))\n-            insert_key_value_pair(\"target_feature\", feature);\n+void\n+TargetOptions::dump_target_options () const\n+{\n+  fprintf (stderr,\n+\t   \"\\033[0;31m--PREPARING TO DUMP ALL TARGET OPTIONS--\\n\\033[0m\");\n+  for (const auto &pairs : features)\n+    {\n+      for (const auto &value : pairs.second)\n+\t{\n+\t  fprintf (stderr, \"%s: \\\"%s\\\"\\n\", pairs.first.c_str (),\n+\t\t   value.c_str ());\n+\t}\n+      if (pairs.second.empty ())\n+\t{\n+\t  fprintf (stderr, \"%s\\n\", pairs.first.c_str ());\n+\t}\n     }\n+  if (features.empty ())\n+    {\n+      fprintf (stderr, \"No target options available!\\n\");\n+    }\n+\n+  fprintf (stderr, \"\\033[0;31m--END OF TARGET OPTION DUMP--\\n\\033[0m\");\n+}\n \n-    // NOTEs:\n-    /* mrustc compile pipeline:\n-     *  - target load (pass target spec to parser?)\n-     *  - parse (convert source to AST)\n-     *  - load crates (load any explicitly mentioned extern crates [not all of them])\n-     *  - expand (AST transformations from attributes and macros, loads remaining extern crates\n-     * [std/core and any triggered by macro expansion])\n-     *  - implicit crates (test harness, allocator crate, panic crate)\n-     *  - resolve use (annotate every 'use' item with source [supposedly handles nasty recursion])\n-     *  - resolve index (generate index of visible items for every module [avoids recursion in next\n-     * pass])\n-     *  - resolve absolute (resolve all paths into either variable names [types/values] or absolute\n-     * paths)\n-     *  - HIR lower (convert modified AST to simpler HIR [both expressions and module tree])\n-     *  - resolve type aliases (replace any usages of type aliases with actual type [except associated\n-     *    types])\n-     *  - resolve bind (iterate HIR tree and set binding annotations on all concrete types [avoids\n-     * path lookups later])\n-     *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...] for all types\n-     *  - sort impls (small pass - sort impls into groups)\n-     *  - resolve UFCS outer (determine source trait for all top-level <T>::Type [qualified] paths)\n-     *  - resolve UFCS paths (do the same, but include for exprs this time. also normalises results of\n-     *    previous pass [expanding known associated types])\n-     *  - constant evaluate (evaluate all constants)\n-     *  - typecheck outer (checks impls are sane)\n-     *  - typecheck expressions (resolve and check types for all exprs)\n-     *  - expand HIR annotate (annotate how exprs are used - used for closure extractions and\n-     * reborrows)\n-     *  - expand HIR closures (extract closures into structs implementing Fn* traits)\n-     *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n-     *  - expand HIR calls (converts method and callable calls into explicit function calls)\n-     *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of 'v'])\n-     *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true type)\n-     *  - typecheck expressions (validate - double check that previous passes haven't broke type\n-     * system rules)\n-     *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n-     *  - MIR validate (check that the generated MIR is consistent)\n-     *  - MIR cleanup (perform various transformations on MIR - replace reads of const items with the\n-     * item itself; convert casts to unsized types into 'MakeDst' operations)\n-     *  - MIR optimise (perform various simple optimisations on the MIR - constant propagation, dead\n-     * code elimination, borrow elimination, some inlining)\n-     *  - MIR validate PO (re-validate the MIR)\n-     *  - MIR validate full (optionally: perform expensive state-tracking validation on MIR)\n-     *  - trans enumerate (enumerate all items needed for code generation, primarily types used for\n-     * generics)\n-     *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n-     *  - trans monomorph (generate monomorphised copies of all functions [with generics replaced with\n-     * real types])\n-     *  - MIR optimise inline (run optimisation again, this time with full type info [primarily for\n-     * inlining])\n-     *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n-     *  - trans codegen (generate final output file: emit C source file and call C compiler) */\n-\n-    /* rustc compile pipeline (basic, in way less detail):\n-     *  - parse input (parse .rs to AST)\n-     *  - name resolution, macro expansion, and configuration (process AST recursively, resolving\n-     * paths, expanding macros, processing #[cfg] nodes [i.e. maybe stripping stuff from AST])\n-     *  - lower to HIR\n-     *  - type check and other analyses (e.g. privacy checking)\n-     *  - lower to MIR and post-processing (and do stuff like borrow checking)\n-     *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n-     *  - linking (link together .o files) */\n-\n-    /* Pierced-together rustc compile pipeline (from source):\n-     *  - parse input (parse file to crate)\n-     *  - register plugins (attributes injection, set various options, register lints, load plugins)\n-     *  - expansion/configure and expand (initial 'cfg' processing, 'loading compiler plugins',\n-     *    syntax expansion, secondary 'cfg' expansion, synthesis of a test harness if required,\n-     * injection of any std lib dependency and prelude, and name resolution) - actually documented\n-     * inline\n-     *      - seeming pierced-together order: pre-AST expansion lint checks, registering builtin\n-     * macros, crate injection, then expand all macros, then maybe build test harness, AST validation,\n-     *        maybe create a macro crate (if not rustdoc), name resolution, complete gated feature\n-     * checking, add all buffered lints\n-     *  - create global context (lower to HIR)\n-     *  - analysis on global context (HIR optimisations? create MIR?)\n-     *  - code generation\n-     *  - link */\n+void\n+TargetOptions::init_derived_values ()\n+{\n+  // enable derived values based on target families\n+  if (has_key_value_pair (\"target_family\", \"unix\"))\n+    insert_key (\"unix\");\n+  if (has_key_value_pair (\"target_family\", \"windows\"))\n+    insert_key (\"windows\");\n+\n+  // implicitly enable features\n+  if (has_key_value_pair (\"target_feature\", \"aes\"))\n+    enable_implicit_feature_reqs (\"aes\");\n+  if (has_key_value_pair (\"target_feature\", \"avx\"))\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  if (has_key_value_pair (\"target_feature\", \"avx2\"))\n+    enable_implicit_feature_reqs (\"avx\");\n+  if (has_key_value_pair (\"target_feature\", \"pclmulqdq\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sha\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse2\"))\n+    enable_implicit_feature_reqs (\"sse\");\n+  if (has_key_value_pair (\"target_feature\", \"sse3\"))\n+    enable_implicit_feature_reqs (\"sse2\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.1\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n+  if (has_key_value_pair (\"target_feature\", \"sse4.2\"))\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  if (has_key_value_pair (\"target_feature\", \"ssse3\"))\n+    enable_implicit_feature_reqs (\"sse3\");\n }\n+\n+void\n+TargetOptions::enable_implicit_feature_reqs (std::string feature)\n+{\n+  if (feature == \"aes\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"avx\")\n+    enable_implicit_feature_reqs (\"sse4.2\");\n+  else if (feature == \"avx2\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"fma\")\n+    enable_implicit_feature_reqs (\"avx\");\n+  else if (feature == \"pclmulqdq\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sha\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse2\")\n+    enable_implicit_feature_reqs (\"sse\");\n+  else if (feature == \"sse3\")\n+    enable_implicit_feature_reqs (\"sse2\");\n+  else if (feature == \"sse4.1\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+  else if (feature == \"sse4.2\")\n+    enable_implicit_feature_reqs (\"sse4.1\");\n+  else if (feature == \"ssse3\")\n+    enable_implicit_feature_reqs (\"sse3\");\n+\n+  if (!has_key_value_pair (\"target_feature\", feature))\n+    insert_key_value_pair (\"target_feature\", feature);\n+}\n+\n+// NOTEs:\n+/* mrustc compile pipeline:\n+ *  - target load (pass target spec to parser?)\n+ *  - parse (convert source to AST)\n+ *  - load crates (load any explicitly mentioned extern crates [not all of\n+ * them])\n+ *  - expand (AST transformations from attributes and macros, loads remaining\n+ * extern crates [std/core and any triggered by macro expansion])\n+ *  - implicit crates (test harness, allocator crate, panic crate)\n+ *  - resolve use (annotate every 'use' item with source [supposedly handles\n+ * nasty recursion])\n+ *  - resolve index (generate index of visible items for every module [avoids\n+ * recursion in next pass])\n+ *  - resolve absolute (resolve all paths into either variable names\n+ * [types/values] or absolute paths)\n+ *  - HIR lower (convert modified AST to simpler HIR [both expressions and\n+ * module tree])\n+ *  - resolve type aliases (replace any usages of type aliases with actual type\n+ * [except associated types])\n+ *  - resolve bind (iterate HIR tree and set binding annotations on all concrete\n+ * types [avoids path lookups later])\n+ *  - resolve HIR markings (generate \"markings\" [e.g. for Copy/Send/Sync/...]\n+ * for all types\n+ *  - sort impls (small pass - sort impls into groups)\n+ *  - resolve UFCS outer (determine source trait for all top-level <T>::Type\n+ * [qualified] paths)\n+ *  - resolve UFCS paths (do the same, but include for exprs this time. also\n+ * normalises results of previous pass [expanding known associated types])\n+ *  - constant evaluate (evaluate all constants)\n+ *  - typecheck outer (checks impls are sane)\n+ *  - typecheck expressions (resolve and check types for all exprs)\n+ *  - expand HIR annotate (annotate how exprs are used - used for closure\n+ * extractions and reborrows)\n+ *  - expand HIR closures (extract closures into structs implementing Fn*\n+ * traits)\n+ *  - expand HIR vtables (generate vtables for types with dyn dispatch)\n+ *  - expand HIR calls (converts method and callable calls into explicit\n+ * function calls)\n+ *  - expand HIR reborrows (apply reborrow rules [taking '&mut *v' instead of\n+ * 'v'])\n+ *  - expand HIR erasedtype (replace all erased types 'impl Trait' with the true\n+ * type)\n+ *  - typecheck expressions (validate - double check that previous passes\n+ * haven't broke type system rules)\n+ *  - lower MIR (convert HIR exprs into a control-flow graph [MIR])\n+ *  - MIR validate (check that the generated MIR is consistent)\n+ *  - MIR cleanup (perform various transformations on MIR - replace reads of\n+ * const items with the item itself; convert casts to unsized types into\n+ * 'MakeDst' operations)\n+ *  - MIR optimise (perform various simple optimisations on the MIR - constant\n+ * propagation, dead code elimination, borrow elimination, some inlining)\n+ *  - MIR validate PO (re-validate the MIR)\n+ *  - MIR validate full (optionally: perform expensive state-tracking validation\n+ * on MIR)\n+ *  - trans enumerate (enumerate all items needed for code generation, primarily\n+ * types used for generics)\n+ *  - trans auto impls (create magic trait impls as enumerated in previous pass)\n+ *  - trans monomorph (generate monomorphised copies of all functions [with\n+ * generics replaced with real types])\n+ *  - MIR optimise inline (run optimisation again, this time with full type info\n+ * [primarily for inlining])\n+ *  - HIR serialise (write out HIR dump [module tree and generic/inline MIR])\n+ *  - trans codegen (generate final output file: emit C source file and call C\n+ * compiler) */\n+\n+/* rustc compile pipeline (basic, in way less detail):\n+ *  - parse input (parse .rs to AST)\n+ *  - name resolution, macro expansion, and configuration (process AST\n+ * recursively, resolving paths, expanding macros, processing #[cfg] nodes [i.e.\n+ * maybe stripping stuff from AST])\n+ *  - lower to HIR\n+ *  - type check and other analyses (e.g. privacy checking)\n+ *  - lower to MIR and post-processing (and do stuff like borrow checking)\n+ *  - translation to LLVM IR and LLVM optimisations (produce the .o files)\n+ *  - linking (link together .o files) */\n+\n+/* Pierced-together rustc compile pipeline (from source):\n+ *  - parse input (parse file to crate)\n+ *  - register plugins (attributes injection, set various options, register\n+ * lints, load plugins)\n+ *  - expansion/configure and expand (initial 'cfg' processing, 'loading\n+ * compiler plugins', syntax expansion, secondary 'cfg' expansion, synthesis of\n+ * a test harness if required, injection of any std lib dependency and prelude,\n+ * and name resolution) - actually documented inline\n+ *      - seeming pierced-together order: pre-AST expansion lint checks,\n+ * registering builtin macros, crate injection, then expand all macros, then\n+ * maybe build test harness, AST validation, maybe create a macro crate (if not\n+ * rustdoc), name resolution, complete gated feature checking, add all buffered\n+ * lints\n+ *  - create global context (lower to HIR)\n+ *  - analysis on global context (HIR optimisations? create MIR?)\n+ *  - code generation\n+ *  - link */\n+} // namespace Rust"}]}