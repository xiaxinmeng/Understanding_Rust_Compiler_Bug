{"sha": "e0e85e0617394f491e74fd1d8c5f121fa5527487", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTBlODVlMDYxNzM5NGY0OTFlNzRmZDFkOGM1ZjEyMWZhNTUyNzQ4Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-12-22T07:05:22Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2005-12-22T07:05:22Z"}, "message": "re PR fortran/20889 (type in a structure-constructor differs from type in derived-type-def)\n\n2005-12-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20889\n\t*resolve.c(resolve_structure_cons): Do not attempt to convert\n\tthe type of mismatched pointer type components, except when\n\tthe constructor component is BT_UNKNOWN; emit error instead.\n\n\tPR fortran/25029\n\tPR fortran/21256\n\t*resolve.c(check_assumed_size_reference): New function to check for upper\n\tbound in assumed size array references.\n\t(resolve_assumed_size_actual): New function to do a very restricted scan\n\tof actual argument expressions of those procedures for which incomplete\n\tassumed size array references are not allowed.\n\t(resolve_function, resolve_call): Switch off assumed size checking of\n\tactual arguments, except for elemental procedures and array valued\n\tintrinsics; excepting LBOUND.\n\t(resolve_variable): Call check_assumed_size_reference.\n\n\tPR fortran/19362\n\tPR fortran/20244\n\tPR fortran/20864\n\tPR fortran/25391\n\t*interface.c(gfc_compare_types): Broken into two.\n\t(gfc_compare_derived_types): Second half of gfc_compare_types with\n\tcorrections for a missing check that module name is non-NULL and\n\ta check for private components.\n\t*symbol.c(gfc_free_dt_list): New function.\n\t(gfc_free_namespace): Call gfc_free_dt_list.\n\t*resolve.c(resolve_symbol): Build the list of derived types in the\n\tsymbols namespace.\n\t*gfortran.h: Define the structure type gfc_dt_list.  Add a new field,\n\tderived_types to gfc_namespace.  Provide a prototye for the new\n\tfunction gfc_compare_derived_types.\n\t*trans_types.c(gfc_get_derived_type): Test for the derived type being\n\tavailable in the host namespace. In this case, the host backend\n\tdeclaration is used for the structure and its components.  If an\n\tunbuilt, equal structure that is not use associated is found in the\n\thost namespace, build it there and then.  On exit,traverse the\n\tnamespace of the derived type to see if there are equal but unbuilt.\n\tIf so, copy the structure and its component declarations.\n\t(copy_dt_decls_ifequal): New functions to copy declarations to other\n\tequal structure types.\n\n\tPR fortran/20862\n\t* io.c (gfc_match_format): Make the appearance of a format statement\n\tin a module specification block an error.\n\n\tPR fortran/23152\n\t* match.c (gfc_match_namelist): Set assumed shape arrays in\n\tnamelists as std=GFC_STD_GNU and assumed size arrays as an\n\tunconditional error.\n\n\tPR fortran/25069\n\t* match.c (gfc_match_namelist): Set the respecification of a USE\n\tassociated namelist group as std=GFC_STD_GNU.  Permit the concatenation\n\ton no error.\n\n\tPR fortran/25053\n\tPR fortran/25063\n\tPR fortran/25064\n\tPR fortran/25066\n\tPR fortran/25067\n\tPR fortran/25068\n\tPR fortran/25307\n\t* io.c (resolve_tag): Change std on IOSTAT != default integer to\n\tGFC_STD_GNU and change message accordingly.  Add same error for\n\tSIZE.\n\t(match_dt_element, gfortran.h): Add field err_where to gfc_dt and\n\tset it when tags are being matched.\n\t(gfc_resolve_dt): Remove tests that can be done before resolution\n\tand add some of the new ones here.\n\t(check_io_constraints): New function that checks for most of the\n\tdata transfer constraints. Some of these were previously done in\n\tmatch_io, from where this function is called, and some were done\n\tin gfc_resolve_dt.\n\t(match_io): Remove most of the tests of constraints and add the\n\tcall to check_io_constraints.\n\n2005-12-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/20889\n\t*gfortran.dg/pointer_component_type_1.f90: New test.\n\n\tPR fortran/25029\n\tPR fortran/21256\n\t*gfortran.dg/assumed_size_refs.f90: New test for the conditions that\n\tshould give an error with assumed size array refernces and checks those\n\tthat should not.\n\t*gfortran.dg/gfortran.dg/pr15140.f90: Give the assumed size array\n\treference an upper bound so that it does not generate an error.\n\n\tPR fortran/19362\n\tPR fortran/20244\n\tPR fortran/20864\n\tPR fortran/25391\n\t*gfortran.dg/used_dummy_types_1.f90: New test.\n\t*gfortran.dg/used_dummy_types_2.f90: New test.\n\t*gfortran.dg/used_dummy_types_3.f90: New test.\n\t*gfortran.dg/used_dummy_types_4.f90: New test.\n\t*gfortran.dg/used_dummy_types_5.f90: New test.\n\n\tPR fortran/23152\n\t*gfortran.dg/namelist_use.f90: Add trap for warning on NAMELIST\n\tgroup already being USE associated.\n\t*gfortran.dg/assumed_shape_nml.f90: New test.\n\t*gfortran.dg/assumed_size_nml.f90: New test.\n\n\tPR fortran/20862\n\tPR fortran/25053\n\tPR fortran/25063\n\tPR fortran/25064\n\tPR fortran/25066\n\tPR fortran/25067\n\tPR fortran/25068\n\tPR fortran/25307\n\t* gfortran.dg/io_constraints_1.f90: New test.\n\t* gfortran.dg/io_constraints_1.f90: New test.\n\t* gfortran.dg/iostat_3.f90: Change wording of warning.\n\t * gfortran.dg/g77/19981216-0.f:  the same.\n\nFrom-SVN: r108943", "tree": {"sha": "4a8bd33402e66bf0c181387712a9a394ea287d68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a8bd33402e66bf0c181387712a9a394ea287d68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e0e85e0617394f491e74fd1d8c5f121fa5527487", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e85e0617394f491e74fd1d8c5f121fa5527487", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0e85e0617394f491e74fd1d8c5f121fa5527487", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0e85e0617394f491e74fd1d8c5f121fa5527487/comments", "author": null, "committer": null, "parents": [{"sha": "c078a43735c62e3f90ac80ba1ae01e6d0b83baba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c078a43735c62e3f90ac80ba1ae01e6d0b83baba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c078a43735c62e3f90ac80ba1ae01e6d0b83baba"}], "stats": {"total": 1269, "additions": 1138, "deletions": 131}, "files": [{"sha": "31f1f826008b9b889c01430c5229d86f442019cb", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -1,3 +1,82 @@\n+2005-12-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20889\n+\t*resolve.c(resolve_structure_cons): Do not attempt to convert\n+\tthe type of mismatched pointer type components, except when\n+\tthe constructor component is BT_UNKNOWN; emit error instead.\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\t*resolve.c(check_assumed_size_reference): New function to check for upper\n+\tbound in assumed size array references.\n+\t(resolve_assumed_size_actual): New function to do a very restricted scan\n+\tof actual argument expressions of those procedures for which incomplete\n+\tassumed size array references are not allowed.\n+\t(resolve_function, resolve_call): Switch off assumed size checking of\n+\tactual arguments, except for elemental procedures and array valued\n+\tintrinsics; excepting LBOUND.\n+\t(resolve_variable): Call check_assumed_size_reference.\n+\n+\tPR fortran/19362\n+\tPR fortran/20244\n+\tPR fortran/20864\n+\tPR fortran/25391\n+\t*interface.c(gfc_compare_types): Broken into two.\n+\t(gfc_compare_derived_types): Second half of gfc_compare_types with\n+\tcorrections for a missing check that module name is non-NULL and\n+\ta check for private components.\n+\t*symbol.c(gfc_free_dt_list): New function.\n+\t(gfc_free_namespace): Call gfc_free_dt_list.\n+\t*resolve.c(resolve_symbol): Build the list of derived types in the\n+\tsymbols namespace.\n+\t*gfortran.h: Define the structure type gfc_dt_list.  Add a new field,\n+\tderived_types to gfc_namespace.  Provide a prototye for the new\n+\tfunction gfc_compare_derived_types.\n+\t*trans_types.c(gfc_get_derived_type): Test for the derived type being\n+\tavailable in the host namespace. In this case, the host backend\n+\tdeclaration is used for the structure and its components.  If an\n+\tunbuilt, equal structure that is not use associated is found in the\n+\thost namespace, build it there and then.  On exit,traverse the\n+\tnamespace of the derived type to see if there are equal but unbuilt.\n+\tIf so, copy the structure and its component declarations.\n+\t(copy_dt_decls_ifequal): New functions to copy declarations to other\n+\tequal structure types.\n+\n+\tPR fortran/20862\n+\t* io.c (gfc_match_format): Make the appearance of a format statement\n+\tin a module specification block an error.\n+\n+\tPR fortran/23152\n+\t* match.c (gfc_match_namelist): Set assumed shape arrays in\n+\tnamelists as std=GFC_STD_GNU and assumed size arrays as an\n+\tunconditional error.\n+\n+\tPR fortran/25069\n+\t* match.c (gfc_match_namelist): Set the respecification of a USE\n+\tassociated namelist group as std=GFC_STD_GNU.  Permit the concatenation\n+\ton no error.\n+\n+\tPR fortran/25053\n+\tPR fortran/25063\n+\tPR fortran/25064\n+\tPR fortran/25066\n+\tPR fortran/25067\n+\tPR fortran/25068\n+\tPR fortran/25307\n+\t* io.c (resolve_tag): Change std on IOSTAT != default integer to\n+\tGFC_STD_GNU and change message accordingly.  Add same error for\n+\tSIZE.\n+\t(match_dt_element, gfortran.h): Add field err_where to gfc_dt and\n+\tset it when tags are being matched.\n+\t(gfc_resolve_dt): Remove tests that can be done before resolution\n+\tand add some of the new ones here.\n+\t(check_io_constraints): New function that checks for most of the\n+\tdata transfer constraints. Some of these were previously done in\n+\tmatch_io, from where this function is called, and some were done\n+\tin gfc_resolve_dt.\n+\t(match_io): Remove most of the tests of constraints and add the\n+\tcall to check_io_constraints.\n+\n 2005-12-21  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25423"}, {"sha": "475b0ca5461d355e043e6532f0c157ba8462b16a", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -833,6 +833,16 @@ typedef struct gfc_symtree\n }\n gfc_symtree;\n \n+/* A linked list of derived types in the namespace.  */\n+typedef struct gfc_dt_list\n+{\n+  struct gfc_symbol *derived;\n+  struct gfc_dt_list *next;\n+}\n+gfc_dt_list;\n+\n+#define gfc_get_dt_list() gfc_getmem(sizeof(gfc_dt_list))\n+\n \n /* A namespace describes the contents of procedure, module or\n    interface block.  */\n@@ -892,6 +902,9 @@ typedef struct gfc_namespace\n   /* A list of all alternate entry points to this procedure (or NULL).  */\n   gfc_entry_list *entries;\n \n+  /* A list of all derived types in this procedure (or NULL).  */\n+  gfc_dt_list *derived_types;\n+\n   /* Set to 1 if namespace is a BLOCK DATA program unit.  */\n   int is_block_data;\n }\n@@ -1356,7 +1369,7 @@ typedef struct\n   gfc_st_label *format_label;\n   gfc_st_label *err, *end, *eor;\n \n-  locus eor_where, end_where;\n+  locus eor_where, end_where, err_where;\n }\n gfc_dt;\n \n@@ -1895,6 +1908,7 @@ int gfc_is_compile_time_shape (gfc_array_spec *);\n \n /* interface.c -- FIXME: some of these should be in symbol.c */\n void gfc_free_interface (gfc_interface *);\n+int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n void gfc_check_interfaces (gfc_namespace *);\n void gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);"}, {"sha": "b58fb835a479f5f78f0399609f7107c49a966f3a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -320,43 +320,39 @@ gfc_match_end_interface (void)\n }\n \n \n-/* Compare two typespecs, recursively if necessary.  */\n+/* Compare two derived types using the criteria in 4.4.2 of the standard,\n+   recursing through gfc_compare_types for the components.  */\n \n int\n-gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n+gfc_compare_derived_types (gfc_symbol * derived1, gfc_symbol * derived2)\n {\n   gfc_component *dt1, *dt2;\n \n-  if (ts1->type != ts2->type)\n-    return 0;\n-  if (ts1->type != BT_DERIVED)\n-    return (ts1->kind == ts2->kind);\n-\n-  /* Compare derived types.  */\n-  if (ts1->derived == ts2->derived)\n-    return 1;\n-\n   /* Special case for comparing derived types across namespaces.  If the\n      true names and module names are the same and the module name is\n      nonnull, then they are equal.  */\n-  if (strcmp (ts1->derived->name, ts2->derived->name) == 0\n-      && ((ts1->derived->module == NULL && ts2->derived->module == NULL)\n-\t  || (ts1->derived != NULL && ts2->derived != NULL\n-\t      && strcmp (ts1->derived->module, ts2->derived->module) == 0)))\n+  if (strcmp (derived1->name, derived2->name) == 0\n+\t&& derived1 != NULL && derived2 != NULL\n+\t&& derived1->module != NULL && derived2->module != NULL\n+\t&& strcmp (derived1->module, derived2->module) == 0)\n     return 1;\n \n   /* Compare type via the rules of the standard.  Both types must have\n      the SEQUENCE attribute to be equal.  */\n \n-  if (strcmp (ts1->derived->name, ts2->derived->name))\n+  if (strcmp (derived1->name, derived2->name))\n     return 0;\n \n-  dt1 = ts1->derived->components;\n-  dt2 = ts2->derived->components;\n+  if (derived1->component_access == ACCESS_PRIVATE\n+\t|| derived2->component_access == ACCESS_PRIVATE)\n+    return 0;\n \n-  if (ts1->derived->attr.sequence == 0 || ts2->derived->attr.sequence == 0)\n+  if (derived1->attr.sequence == 0 || derived2->attr.sequence == 0)\n     return 0;\n \n+  dt1 = derived1->components;\n+  dt2 = derived2->components;\n+\n   /* Since subtypes of SEQUENCE types must be SEQUENCE types as well, a\n      simple test can speed things up.  Otherwise, lots of things have to\n      match.  */\n@@ -389,6 +385,24 @@ gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n   return 1;\n }\n \n+/* Compare two typespecs, recursively if necessary.  */\n+\n+int\n+gfc_compare_types (gfc_typespec * ts1, gfc_typespec * ts2)\n+{\n+\n+  if (ts1->type != ts2->type)\n+    return 0;\n+  if (ts1->type != BT_DERIVED)\n+    return (ts1->kind == ts2->kind);\n+\n+  /* Compare derived types.  */\n+  if (ts1->derived == ts2->derived)\n+    return 1;\n+\n+  return gfc_compare_derived_types (ts1->derived ,ts2->derived);\n+}\n+\n \n /* Given two symbols that are formal arguments, compare their ranks\n    and types.  Returns nonzero if they have the same rank and type,"}, {"sha": "7ca000ae1389984bd98b7e5159eb5973a25aabe0", "filename": "gcc/fortran/io.c", "status": "modified", "additions": 216, "deletions": 98, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -816,6 +816,13 @@ gfc_match_format (void)\n   gfc_expr *e;\n   locus start;\n \n+  if (gfc_current_ns->proc_name\n+\t&& gfc_current_ns->proc_name->attr.flavor == FL_MODULE)\n+    {\n+      gfc_error (\"Format statement in module main block at %C.\");\n+      return MATCH_ERROR;\n+    }\n+\n   if (gfc_statement_label == NULL)\n     {\n       gfc_error (\"Missing format label at %C\");\n@@ -1056,8 +1063,16 @@ resolve_tag (const io_tag * tag, gfc_expr * e)\n \n       if (tag == &tag_iostat && e->ts.kind != gfc_default_integer_kind)\n \t{\n-\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003: Non-default \"\n-\t\t\t      \"integer kind in IOSTAT tag at %L\",\n+\t  if (gfc_notify_std (GFC_STD_GNU, \"Fortran 95 requires default \"\n+\t\t\t      \"INTEGER in IOSTAT tag at %L\",\n+\t\t\t      &e->where) == FAILURE)\n+\t    return FAILURE;\n+\t}\n+\n+      if (tag == &tag_size && e->ts.kind != gfc_default_integer_kind)\n+\t{\n+\t  if (gfc_notify_std (GFC_STD_GNU, \"Fortran 95 requires default \"\n+\t\t\t      \"INTEGER in SIZE tag at %L\",\n \t\t\t      &e->where) == FAILURE)\n \t    return FAILURE;\n \t}\n@@ -1728,6 +1743,8 @@ match_dt_element (io_kind k, gfc_dt * dt)\n   if (m != MATCH_NO)\n     return m;\n   m = match_ltag (&tag_err, &dt->err);\n+  if (m == MATCH_YES)\n+    dt->err_where = gfc_current_locus;\n   if (m != MATCH_NO)\n     return m;\n   m = match_etag (&tag_advance, &dt->advance);\n@@ -1807,7 +1824,6 @@ gfc_resolve_dt (gfc_dt * dt)\n       return FAILURE;\n     }\n \n-  /* Sanity checks on data transfer statements.  */\n   if (e->ts.type == BT_CHARACTER)\n     {\n       if (gfc_has_vector_index (e))\n@@ -1816,85 +1832,50 @@ gfc_resolve_dt (gfc_dt * dt)\n \t\t     &e->where);\n \t  return FAILURE;\n \t}\n+    }\n \n-      if (dt->rec != NULL)\n-\t{\n-\t  gfc_error (\"REC tag at %L is incompatible with internal file\",\n-\t\t     &dt->rec->where);\n-\t  return FAILURE;\n-\t}\n-\n-      if (dt->namelist != NULL)\n-\t{\n-\t  gfc_error (\"Internal file at %L is incompatible with namelist\",\n-\t\t     &dt->io_unit->where);\n-\t  return FAILURE;\n-\t}\n-\n-      if (dt->advance != NULL)\n-\t{\n-\t  gfc_error (\"ADVANCE tag at %L is incompatible with internal file\",\n-\t\t     &dt->advance->where);\n-\t  return FAILURE;\n-\t}\n+  if (e->rank && e->ts.type != BT_CHARACTER)\n+    {\n+      gfc_error (\"External IO UNIT cannot be an array at %L\", &e->where);\n+      return FAILURE;\n     }\n \n-  if (dt->rec != NULL)\n+  if (dt->err)\n     {\n-      if (dt->end != NULL)\n+      if (gfc_reference_st_label (dt->err, ST_LABEL_TARGET) == FAILURE)\n+\treturn FAILURE;\n+      if (dt->err->defined == ST_LABEL_UNKNOWN)\n \t{\n-\t  gfc_error (\"REC tag at %L is incompatible with END tag\",\n-\t\t     &dt->rec->where);\n+\t  gfc_error (\"ERR tag label %d at %L not defined\",\n+\t\t      dt->err->value, &dt->err_where);\n \t  return FAILURE;\n \t}\n+    }\n \n-      if (dt->format_label == &format_asterisk)\n+  if (dt->end)\n+    {\n+      if (gfc_reference_st_label (dt->end, ST_LABEL_TARGET) == FAILURE)\n+\treturn FAILURE;\n+      if (dt->end->defined == ST_LABEL_UNKNOWN)\n \t{\n-\t  gfc_error\n-\t    (\"END tag at %L is incompatible with list directed format (*)\",\n-\t     &dt->end_where);\n+\t  gfc_error (\"END tag label %d at %L not defined\",\n+\t\t      dt->end->value, &dt->end_where);\n \t  return FAILURE;\n \t}\n+    }\n \n-      if (dt->namelist != NULL)\n+  if (dt->eor)\n+    {\n+      if (gfc_reference_st_label (dt->eor, ST_LABEL_TARGET) == FAILURE)\n+\treturn FAILURE;\n+      if (dt->eor->defined == ST_LABEL_UNKNOWN)\n \t{\n-\t  gfc_error (\"REC tag at %L is incompatible with namelist\",\n-\t\t     &dt->rec->where);\n+\t  gfc_error (\"EOR tag label %d at %L not defined\",\n+\t\t      dt->eor->value, &dt->eor_where);\n \t  return FAILURE;\n \t}\n     }\n \n-  if (dt->advance != NULL && dt->format_label == &format_asterisk)\n-    {\n-      gfc_error (\"ADVANCE tag at %L is incompatible with list directed \"\n-\t\t \"format (*)\", &dt->advance->where);\n-      return FAILURE;\n-    }\n-\n-  if (dt->eor != 0 && dt->advance == NULL)\n-    {\n-      gfc_error (\"EOR tag at %L requires an ADVANCE tag\", &dt->eor_where);\n-      return FAILURE;\n-    }\n-\n-  if (dt->size != NULL && dt->advance == NULL)\n-    {\n-      gfc_error (\"SIZE tag at %L requires an ADVANCE tag\", &dt->size->where);\n-      return FAILURE;\n-    }\n-\n-  /* TODO: Make sure the ADVANCE tag is 'yes' or 'no' if it is a string\n-     constant.  */\n-\n-  if (gfc_reference_st_label (dt->err, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n-\n-  if (gfc_reference_st_label (dt->end, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n-\n-  if (gfc_reference_st_label (dt->eor, ST_LABEL_TARGET) == FAILURE)\n-    return FAILURE;\n-\n   /* Check the format label actually exists.  */\n   if (dt->format_label && dt->format_label != &format_asterisk\n       && dt->format_label->defined == ST_LABEL_UNKNOWN)\n@@ -2181,6 +2162,165 @@ terminate_io (gfc_code * io_code)\n }\n \n \n+/* Check the constraints for a data transfer statement.  The majority of the\n+   constraints appearing in 9.4 of the standard appear here.  Some are handled\n+   in resolve_tag and others in gfc_resolve_dt.  */\n+\n+static match\n+check_io_constraints (io_kind k, gfc_dt *dt, gfc_code * io_code, locus * spec_end)\n+{\n+#define io_constraint(condition,msg,arg)\\\n+if (condition) \\\n+  {\\\n+    gfc_error(msg,arg);\\\n+    m = MATCH_ERROR;\\\n+  }\n+\n+  match m;\n+  gfc_expr * expr;\n+  gfc_symbol * sym = NULL;\n+\n+  m = MATCH_YES;\n+\n+  expr = dt->io_unit;\n+  if (expr && expr->expr_type == EXPR_VARIABLE\n+\t&& expr->ts.type == BT_CHARACTER)\n+    {\n+      sym = expr->symtree->n.sym;\n+\n+      io_constraint (k == M_WRITE && sym->attr.intent == INTENT_IN,\n+\t\t     \"Internal file at %L must not be INTENT(IN)\",\n+\t\t     &expr->where);\n+\n+      io_constraint (gfc_has_vector_index (dt->io_unit),\n+\t\t     \"Internal file incompatible with vector subscript at %L\",\n+\t\t     &expr->where);\n+\n+      io_constraint (dt->rec != NULL,\n+\t\t     \"REC tag at %L is incompatible with internal file\",\n+\t\t     &dt->rec->where);\n+\n+      io_constraint (dt->namelist != NULL,\n+\t\t     \"Internal file at %L is incompatible with namelist\",\n+\t\t     &expr->where);\n+\n+      io_constraint (dt->advance != NULL,\n+\t\t     \"ADVANCE tag at %L is incompatible with internal file\",\n+\t\t     &dt->advance->where);\n+    }\n+\n+  if (expr && expr->ts.type != BT_CHARACTER)\n+    {\n+\n+      io_constraint (gfc_pure (NULL)\n+\t\t       && (k == M_READ || k == M_WRITE),\n+\t\t     \"IO UNIT in %s statement at %C must be \"\n+\t\t     \"an internal file in a PURE procedure\",\n+\t\t     io_kind_name (k));\n+    }\n+\n+\n+  if (k != M_READ)\n+    {\n+      io_constraint (dt->end,\n+\t\t     \"END tag not allowed with output at %L\",\n+\t\t     &dt->end_where);\n+\n+      io_constraint (dt->eor,\n+\t\t     \"EOR tag not allowed with output at %L\",\n+\t\t     &dt->eor_where);\n+\n+      io_constraint (k != M_READ && dt->size,\n+\t\t     \"SIZE=specifier not allowed with output at %L\",\n+\t\t     &dt->size->where);\n+    }\n+  else\n+    {\n+      io_constraint (dt->size && dt->advance == NULL,\n+\t\t     \"SIZE tag at %L requires an ADVANCE tag\",\n+\t\t     &dt->size->where);\n+\n+      io_constraint (dt->eor && dt->advance == NULL,\n+\t\t     \"EOR tag at %L requires an ADVANCE tag\",\n+\t\t     &dt->eor_where);\n+    }\n+\n+\n+\n+  if (dt->namelist)\n+    {\n+      io_constraint (io_code && dt->namelist,\n+\t\t     \"NAMELIST cannot be followed by IO-list at %L\",\n+\t\t     &io_code->loc);\n+\n+      io_constraint (dt->format_expr,\n+\t\t     \"IO spec-list cannot contain both NAMELIST group name \"\n+\t\t     \"and format specification at %L.\",\n+\t\t     &dt->format_expr->where);\n+\n+      io_constraint (dt->format_label,\n+\t\t     \"IO spec-list cannot contain both NAMELIST group name \"\n+\t\t     \"and format label at %L\", spec_end);\n+\n+      io_constraint (dt->rec,\n+\t\t     \"NAMELIST IO is not allowed with a REC=specifier \"\n+\t\t     \"at %L.\", &dt->rec->where);\n+\n+      io_constraint (dt->advance,\n+\t\t     \"NAMELIST IO is not allowed with a ADVANCE=specifier \"\n+\t\t     \"at %L.\", &dt->advance->where);\n+    }\n+\n+  if (dt->rec)\n+    {\n+      io_constraint (dt->end,\n+\t\t     \"An END tag is not allowed with a \"\n+\t\t     \"REC=specifier at %L.\", &dt->end_where);\n+\n+\n+      io_constraint (dt->format_label == &format_asterisk,\n+\t\t     \"FMT=* is not allowed with a REC=specifier \"\n+\t\t     \"at %L.\", spec_end);\n+    }\n+\n+  if (dt->advance)\n+    {\n+      const char * advance;\n+      int not_yes, not_no;\n+      expr = dt->advance;\n+      advance = expr->value.character.string;\n+\n+      io_constraint (dt->format_label == &format_asterisk,\n+\t\t     \"List directed format(*) is not allowed with a \"\n+\t\t     \"ADVANCE=specifier at %L.\", &expr->where);\n+\n+      not_no = strncasecmp (advance, \"no\", 2) != 0;\n+      not_yes = strncasecmp (advance, \"yes\", 2) != 0;\n+\n+      io_constraint (expr->expr_type == EXPR_CONSTANT\n+\t\t       && not_no && not_yes,\n+\t\t     \"ADVANCE=specifier at %L must have value = \"\n+\t\t     \"YES or NO.\", &expr->where);\n+\n+      io_constraint (dt->size && expr->expr_type == EXPR_CONSTANT\n+\t\t       && not_no && k == M_READ,\n+\t\t     \"SIZE tag at %L requires an ADVANCE = 'NO'\",\n+\t\t     &dt->size->where);\n+\n+      io_constraint (dt->eor && expr->expr_type == EXPR_CONSTANT \n+\t\t       && not_no && k == M_READ,\n+\t\t     \"EOR tag at %L requires an ADVANCE = 'NO'\",\n+\t\t     &dt->eor_where);      \n+    }\n+\n+  expr = dt->format_expr;\n+  if (expr != NULL && expr->expr_type == EXPR_CONSTANT)\n+    check_format_string (expr);\n+\n+  return m;\n+}\n+#undef io_constraint\n+\n /* Match a READ, WRITE or PRINT statement.  */\n \n static match\n@@ -2189,12 +2329,13 @@ match_io (io_kind k)\n   char name[GFC_MAX_SYMBOL_LEN + 1];\n   gfc_code *io_code;\n   gfc_symbol *sym;\n-  gfc_expr *expr;\n   int comma_flag, c;\n   locus where;\n+  locus spec_end;\n   gfc_dt *dt;\n   match m;\n \n+  where = gfc_current_locus;\n   comma_flag = 0;\n   current_dt = dt = gfc_getmem (sizeof (gfc_dt));\n   if (gfc_match_char ('(') == MATCH_NO)\n@@ -2217,12 +2358,6 @@ match_io (io_kind k)\n \t\t      m = MATCH_ERROR;\n \t\t      goto cleanup;\n \t\t    }\n-\t\t  if (gfc_match_eos () == MATCH_NO)\n-\t\t    {\n-\t\t      gfc_error (\"Namelist followed by I/O list at %C\");\n-\t\t      m = MATCH_ERROR;\n-\t\t      goto cleanup;\n-\t\t    }\n \n \t\t  dt->io_unit = default_unit (k);\n \t\t  dt->namelist = sym;\n@@ -2321,6 +2456,10 @@ match_io (io_kind k)\n     }\n \n get_io_list:\n+\n+  /* Used in check_io_constraints, where no locus is available.  */\n+  spec_end = gfc_current_locus;\n+\n   /* Optional leading comma (non-standard).  */\n   if (!comma_flag\n       && gfc_match_char (',') == MATCH_YES\n@@ -2346,33 +2485,12 @@ match_io (io_kind k)\n \tgoto syntax;\n     }\n \n-  /* A full IO statement has been matched.  */\n-  if (dt->io_unit->expr_type == EXPR_VARIABLE\n-      && k == M_WRITE\n-      && dt->io_unit->ts.type == BT_CHARACTER\n-      && dt->io_unit->symtree->n.sym->attr.intent == INTENT_IN)\n-    {\n-      gfc_error (\"Internal file '%s' at %L is INTENT(IN)\",\n-\t\t dt->io_unit->symtree->n.sym->name, &dt->io_unit->where);\n-      m = MATCH_ERROR;\n-      goto cleanup;\n-    }\n-\n-  expr = dt->format_expr;\n+  /* A full IO statement has been matched.  Check the constraints.  spec_end is\n+     supplied for cases where no locus is supplied.  */\n+  m = check_io_constraints (k, dt, io_code, &spec_end);\n \n-  if (expr != NULL && expr->expr_type == EXPR_CONSTANT)\n-    check_format_string (expr);\n-\n-  if (gfc_pure (NULL)\n-      && (k == M_READ || k == M_WRITE)\n-      && dt->io_unit->ts.type != BT_CHARACTER)\n-    {\n-      gfc_error\n-\t(\"io-unit in %s statement at %C must be an internal file in a \"\n-\t \"PURE procedure\", io_kind_name (k));\n-      m = MATCH_ERROR;\n-      goto cleanup;\n-    }\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n \n   new_st.op = (k == M_READ) ? EXEC_READ : EXEC_WRITE;\n   new_st.ext.dt = dt;"}, {"sha": "e28127b00b4a68bb183191121e24fb77628a401e", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -2503,6 +2503,14 @@ gfc_match_namelist (void)\n \t  return MATCH_ERROR;\n \t}\n \n+      if (group_name->attr.flavor == FL_NAMELIST\n+\t    && group_name->attr.use_assoc\n+\t    && gfc_notify_std (GFC_STD_GNU, \"Namelist group name '%s' \"\n+\t\t\t       \"at %C already is USE associated and can\"\n+\t\t\t       \"not be respecified.\", group_name->name)\n+\t\t == FAILURE)\n+\treturn MATCH_ERROR;\n+\n       if (group_name->attr.flavor != FL_NAMELIST\n \t  && gfc_add_flavor (&group_name->attr, FL_NAMELIST,\n \t\t\t     group_name->name, NULL) == FAILURE)\n@@ -2520,6 +2528,21 @@ gfc_match_namelist (void)\n \t      && gfc_add_in_namelist (&sym->attr, sym->name, NULL) == FAILURE)\n \t    goto error;\n \n+\t  /* Use gfc_error_check here, rather than goto error, so that this\n+\t     these are the only errors for the next two lines.  */\n+\t  if (sym->as && sym->as->type == AS_ASSUMED_SIZE)\n+\t    {\n+\t      gfc_error (\"Assumed size array '%s' in namelist '%s'at \"\n+\t\t         \"%C is not allowed.\", sym->name, group_name->name);\n+\t      gfc_error_check ();\n+\t    }\n+\n+\t  if (sym->as && sym->as->type == AS_ASSUMED_SHAPE\n+\t\t&& gfc_notify_std (GFC_STD_GNU, \"Assumed shape array '%s' in \"\n+\t\t\t\t   \"namelist '%s' at %C is an extension.\",\n+\t\t\t\t   sym->name, group_name->name) == FAILURE)\n+\t    gfc_error_check ();\n+\n \t  nl = gfc_get_namelist ();\n \t  nl->sym = sym;\n "}, {"sha": "5ba4c8e66e832d4e4a0107e7472c6d8e268c0620", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 143, "deletions": 4, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -588,9 +588,18 @@ resolve_structure_cons (gfc_expr * expr)\n \n       /* If we don't have the right type, try to convert it.  */\n \n-      if (!gfc_compare_types (&cons->expr->ts, &comp->ts)\n-\t  && gfc_convert_type (cons->expr, &comp->ts, 1) == FAILURE)\n-\tt = FAILURE;\n+      if (!gfc_compare_types (&cons->expr->ts, &comp->ts))\n+\t{\n+\t  t = FAILURE;\n+\t  if (comp->pointer && cons->expr->ts.type != BT_UNKNOWN)\n+\t    gfc_error (\"The element in the derived type constructor at %L, \"\n+\t\t       \"for pointer component '%s', is %s but should be %s\",\n+\t\t       &cons->expr->where, comp->name,\n+\t\t       gfc_basic_typename (cons->expr->ts.type),\n+\t\t       gfc_basic_typename (comp->ts.type));\n+\t  else\n+\t    t = gfc_convert_type (cons->expr, &comp->ts, 1);\n+\t}\n     }\n \n   return t;\n@@ -686,6 +695,68 @@ procedure_kind (gfc_symbol * sym)\n   return PTYPE_UNKNOWN;\n }\n \n+/* Check references to assumed size arrays.  The flag need_full_assumed_size\n+   is zero when matching actual arguments.  */\n+\n+static int need_full_assumed_size = 1;\n+\n+static int\n+check_assumed_size_reference (gfc_symbol * sym, gfc_expr * e)\n+{\n+  gfc_ref * ref;\n+  int dim;\n+  int last = 1;\n+\n+  if (!need_full_assumed_size\n+\t|| !(sym->as && sym->as->type == AS_ASSUMED_SIZE))\n+      return 0;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY)\n+      for (dim = 0; dim < ref->u.ar.as->rank; dim++)\n+\tlast = (ref->u.ar.end[dim] == NULL) && (ref->u.ar.type == DIMEN_ELEMENT);\n+\n+  if (last)\n+    {\n+      gfc_error (\"The upper bound in the last dimension must \"\n+\t\t \"appear in the reference to the assumed size \"\n+\t\t \"array '%s' at %L.\", sym->name, &e->where);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+\n+/* Look for bad assumed size array references in argument expressions\n+  of elemental and array valued intrinsic procedures.  Since this is\n+  called from procedure resolution functions, it only recurses at\n+  operators.  */\n+static bool\n+resolve_assumed_size_actual (gfc_expr *e)\n+{\n+  if (e == NULL)\n+   return false;\n+\n+  switch (e->expr_type)\n+    {\n+    case EXPR_VARIABLE:\n+      if (e->symtree\n+\t    && check_assumed_size_reference (e->symtree->n.sym, e))\n+\treturn true;\n+      break;\n+\n+    case EXPR_OP:\n+      if (resolve_assumed_size_actual (e->value.op.op1)\n+\t    || resolve_assumed_size_actual (e->value.op.op2))\n+\treturn true;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n \n /* Resolve an actual argument list.  Most of the time, this is just\n    resolving the expressions in the list.\n@@ -1083,9 +1154,16 @@ resolve_function (gfc_expr * expr)\n   const char *name;\n   try t;\n \n+  /* Switch off assumed size checking and do this again for certain kinds\n+     of procedure, once the procedure itself is resolved.  */\n+  need_full_assumed_size = 0;\n+\n   if (resolve_actual_arglist (expr->value.function.actual) == FAILURE)\n     return FAILURE;\n \n+  /* Resume assumed_size checking. */\n+  need_full_assumed_size = 1;\n+\n /* See if function is already resolved.  */\n \n   if (expr->value.function.name != NULL)\n@@ -1129,7 +1207,6 @@ resolve_function (gfc_expr * expr)\n \t  || (expr->value.function.isym != NULL\n \t      && expr->value.function.isym->elemental)))\n     {\n-\n       /* The rank of an elemental is the rank of its array argument(s).  */\n \n       for (arg = expr->value.function.actual; arg; arg = arg->next)\n@@ -1140,6 +1217,31 @@ resolve_function (gfc_expr * expr)\n \t      break;\n \t    }\n \t}\n+\n+      /* Being elemental, the last upper bound of an assumed size array\n+\t argument must be present.  */\n+      for (arg = expr->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if (arg->expr != NULL\n+\t\t&& arg->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (arg->expr))\n+\t    return FAILURE;\n+\t}\n+    }\n+\n+  else if (expr->value.function.actual != NULL\n+      && expr->value.function.isym != NULL\n+      && strcmp (expr->value.function.isym->name, \"lbound\"))\n+    {\n+      /* Array instrinsics must also have the last upper bound of an\n+\t asumed size array argument.  */\n+      for (arg = expr->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  if (arg->expr != NULL\n+\t\t&& arg->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (arg->expr))\n+\t    return FAILURE;\n+\t}\n     }\n \n   if (!pure_function (expr, &name))\n@@ -1381,9 +1483,17 @@ resolve_call (gfc_code * c)\n {\n   try t;\n \n+  /* Switch off assumed size checking and do this again for certain kinds\n+     of procedure, once the procedure itself is resolved.  */\n+  need_full_assumed_size = 0;\n+\n   if (resolve_actual_arglist (c->ext.actual) == FAILURE)\n     return FAILURE;\n \n+  /* Resume assumed_size checking. */\n+  need_full_assumed_size = 1;\n+\n+\n   t = SUCCESS;\n   if (c->resolved_sym == NULL)\n     switch (procedure_kind (c->symtree->n.sym))\n@@ -1404,6 +1514,21 @@ resolve_call (gfc_code * c)\n \tgfc_internal_error (\"resolve_subroutine(): bad function type\");\n       }\n \n+  if (c->ext.actual != NULL\n+      && c->symtree->n.sym->attr.elemental)\n+    {\n+      gfc_actual_arglist * a;\n+      /* Being elemental, the last upper bound of an assumed size array\n+\t argument must be present.  */\n+      for (a = c->ext.actual; a; a = a->next)\n+\t{\n+\t  if (a->expr != NULL\n+\t\t&& a->expr->rank > 0\n+\t\t&& resolve_assumed_size_actual (a->expr))\n+\t    return FAILURE;\n+\t}\n+    }\n+\n   if (t == SUCCESS)\n     find_noncopying_intrinsics (c->resolved_sym, c->ext.actual);\n   return t;\n@@ -2330,6 +2455,9 @@ resolve_variable (gfc_expr * e)\n       e->ts = sym->ts;\n     }\n \n+  if (check_assumed_size_reference (sym, e))\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n \n@@ -4580,6 +4708,17 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n       break;\n \n+    case FL_DERIVED:\n+      /* Add derived type to the derived type list.  */\n+      {\n+\tgfc_dt_list * dt_list;\n+\tdt_list = gfc_get_dt_list ();\n+\tdt_list->next = sym->ns->derived_types;\n+\tdt_list->derived = sym;\n+\tsym->ns->derived_types = dt_list;\n+      }\n+      break;\n+\n     default:\n \n       /* An external symbol falls through to here if it is not referenced.  */"}, {"sha": "bda1c1d4f7af78631b7cd1f53a81d05b6a42d6b1", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -2307,6 +2307,21 @@ free_sym_tree (gfc_symtree * sym_tree)\n }\n \n \n+/* Free a derived type list.  */\n+\n+static void\n+gfc_free_dt_list (gfc_dt_list * dt)\n+{\n+  gfc_dt_list *n;\n+\n+  for (; dt; dt = n)\n+    {\n+      n = dt->next;\n+      gfc_free (dt);\n+    }\n+}\n+\n+\n /* Free a namespace structure and everything below it.  Interface\n    lists associated with intrinsic operators are not freed.  These are\n    taken care of when a specific name is freed.  */\n@@ -2343,6 +2358,8 @@ gfc_free_namespace (gfc_namespace * ns)\n \n   gfc_free_equiv (ns->equiv);\n \n+  gfc_free_dt_list (ns->derived_types);\n+\n   for (i = GFC_INTRINSIC_BEGIN; i != GFC_INTRINSIC_END; i++)\n     gfc_free_interface (ns->operator[i]);\n "}, {"sha": "4e6b74e912c726366536c33f1463e16f386f0f63", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -1395,13 +1395,44 @@ gfc_add_field_to_struct (tree *fieldlist, tree context,\n }\n \n \n-/* Build a tree node for a derived type.  */\n+/* Copy the backend_decl and component backend_decls if\n+   the two derived type symbols are \"equal\", as described\n+   in 4.4.2 and resolved by gfc_compare_derived_types.  */\n+\n+static int\n+copy_dt_decls_ifequal (gfc_symbol *from, gfc_symbol *to)\n+{\n+  gfc_component *to_cm;\n+  gfc_component *from_cm;\n+\n+  if (from->backend_decl == NULL\n+\t|| !gfc_compare_derived_types (from, to))\n+    return 0;\n+\n+  to->backend_decl = from->backend_decl;\n+\n+  to_cm = to->components;\n+  from_cm = from->components;\n+\n+  for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)\n+    to_cm->backend_decl = from_cm->backend_decl;\n+\n+  return 1;\n+}\n+\n+\n+/* Build a tree node for a derived type.  If there are equal\n+   derived types, with different local names, these are built\n+   at the same time.  If an equal derived type has been built\n+   in a parent namespace, this is used.  */\n \n static tree\n gfc_get_derived_type (gfc_symbol * derived)\n {\n   tree typenode, field, field_type, fieldlist;\n   gfc_component *c;\n+  gfc_dt_list *dt;\n+  gfc_namespace * ns;\n \n   gcc_assert (derived && derived->attr.flavor == FL_DERIVED);\n \n@@ -1417,6 +1448,29 @@ gfc_get_derived_type (gfc_symbol * derived)\n     }\n   else\n     {\n+      /* In a module, if an equal derived type is already available in the\n+\t specification block, use its backend declaration and those of its\n+\t components, rather than building anew so that potential dummy and\n+\t actual arguments use the same TREE_TYPE.  Non-module structures,\n+\t need to be built, if found, because the order of visits to the \n+\t namespaces is different.  */\n+\n+      for (ns = derived->ns->parent; ns; ns = ns->parent)\n+\t{\n+\t  for (dt = ns->derived_types; dt; dt = dt->next)\n+\t    {\n+\t      if (derived->module == NULL\n+\t\t    && dt->derived->backend_decl == NULL\n+\t\t    && gfc_compare_derived_types (dt->derived, derived))\n+\t\tgfc_get_derived_type (dt->derived);\n+\n+\t      if (copy_dt_decls_ifequal (dt->derived, derived))\n+\t\tbreak;\n+\t    }\n+\t  if (derived->backend_decl)\n+\t    goto other_equal_dts;\n+\t}\n+\n       /* We see this derived type first time, so build the type node.  */\n       typenode = make_node (RECORD_TYPE);\n       TYPE_NAME (typenode) = get_identifier (derived->name);\n@@ -1495,9 +1549,16 @@ gfc_get_derived_type (gfc_symbol * derived)\n \n   derived->backend_decl = typenode;\n \n-  return typenode;\n+other_equal_dts:\n+  /* Add this backend_decl to all the other, equal derived types and\n+     their components in this namespace.  */\n+  for (dt = derived->ns->derived_types; dt; dt = dt->next)\n+    copy_dt_decls_ifequal (derived, dt->derived);\n+\n+  return derived->backend_decl;\n }\n-\f\n+\n+\n int\n gfc_return_by_reference (gfc_symbol * sym)\n {"}, {"sha": "d7eb3eb61facc5a42228847e4f3c05e86a253208", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -1,3 +1,45 @@\n+2005-12-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/20889\n+\t*gfortran.dg/pointer_component_type_1.f90: New test.\n+\n+\tPR fortran/25029\n+\tPR fortran/21256\n+\t*gfortran.dg/assumed_size_refs.f90: New test for the conditions that\n+\tshould give an error with assumed size array refernces and checks those\n+\tthat should not.\n+\t*gfortran.dg/gfortran.dg/pr15140.f90: Give the assumed size array\n+\treference an upper bound so that it does not generate an error.\n+\n+\tPR fortran/19362\n+\tPR fortran/20244\n+\tPR fortran/20864\n+\tPR fortran/25391\n+\t*gfortran.dg/used_dummy_types_1.f90: New test.\n+\t*gfortran.dg/used_dummy_types_2.f90: New test.\n+\t*gfortran.dg/used_dummy_types_3.f90: New test.\n+\t*gfortran.dg/used_dummy_types_4.f90: New test.\n+\t*gfortran.dg/used_dummy_types_5.f90: New test.\n+\n+\tPR fortran/23152\n+\t*gfortran.dg/namelist_use.f90: Add trap for warning on NAMELIST\n+\tgroup already being USE associated.\n+\t*gfortran.dg/assumed_shape_nml.f90: New test.\n+\t*gfortran.dg/assumed_size_nml.f90: New test.\n+\n+\tPR fortran/20862\n+\tPR fortran/25053\n+\tPR fortran/25063\n+\tPR fortran/25064\n+\tPR fortran/25066\n+\tPR fortran/25067\n+\tPR fortran/25068\n+\tPR fortran/25307\n+\t* gfortran.dg/io_constraints_1.f90: New test.\n+\t* gfortran.dg/io_constraints_1.f90: New test.\n+\t* gfortran.dg/iostat_3.f90: Change wording of warning.\n+\t * gfortran.dg/g77/19981216-0.f:  the same.\n+\n 2005-12-22  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR tree-optimization/23518"}, {"sha": "c2a8808ee8efaf6fc7e847dcf56f72a2fbc1dec4", "filename": "gcc/testsuite/gfortran.dg/assumed_shape_nml.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_nml.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_nml.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_shape_nml.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! One of two tests for the fix of PR23152 - There used to be\n+! no warning for assumed shape arrays in namelists.\n+!\n+! Conributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program assumed_shape_nml\n+  real, dimension (10) :: z\n+  z = 42.0\n+  call foo (z)\n+contains\n+  subroutine foo (y)\n+    real, DIMENSION (1:) :: y\n+    namelist /mynml/ y     ! { dg-warning \"is an extension\" }\n+    write (*, mynml)\n+  end subroutine foo\n+end program assumed_shape_nml"}, {"sha": "76d51483394bef15369025b2c3f5fd101078b9b1", "filename": "gcc/testsuite/gfortran.dg/assumed_size_nml.f90", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_nml.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_nml.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_size_nml.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,17 @@\n+! { dg-do compile }\n+! One of two tests for the fix of PR23152 - An ICE would\n+! ensue from assumed shape arrays in namelists.\n+!\n+! Conributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+program assumed_size_nml\n+  real, dimension (10) :: z\n+  z = 42.0\n+  call foo (z)\n+contains\n+  subroutine foo (y)\n+    real, DIMENSION (*) :: y\n+    namelist /mynml/ y     ! { dg-error \"is not allowed\" }\n+    write (6, mynml)\n+  end subroutine foo\n+end program assumed_size_nml\n\\ No newline at end of file"}, {"sha": "5920ddf64347973511a550974c6ecb3bab752e94", "filename": "gcc/testsuite/gfortran.dg/g77/19981216-0.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19981216-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19981216-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19981216-0.f?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -29,7 +29,7 @@ PROGRAM WAP\n \n         name = 'blah'\n         open(unit=8,status='unknown',file=name,form='formatted',\n-     F       iostat=ios) ! { dg-warning \"integer kind in IOSTAT\" }\n+     F       iostat=ios) ! { dg-warning \"INTEGER in IOSTAT\" }\n \n       END\n * -------------------------------------------"}, {"sha": "3ce6b1013392349e3d5d3d5e7cd9656f828a1aa1", "filename": "gcc/testsuite/gfortran.dg/initialization_1.f90", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Finitialization_1.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -29,7 +29,6 @@ subroutine foo(ch1, x, y)\n     integer :: m2(2) = shape (x)  ! { dg-error \"assumed size array\" }\n \n ! These are warnings because they are gfortran extensions.\n-    integer :: m3 = size (x, 1)   ! { dg-warning \"Evaluation of nonstandard initialization\" }\n     integer :: m4(2) = shape (z)  ! { dg-warning \"Evaluation of nonstandard initialization\" }\n \n ! This does not depend on non-constant properties."}, {"sha": "fa4c973dd349de98d24e9be77145375800a334af", "filename": "gcc/testsuite/gfortran.dg/io_constraints_1.f90", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_1.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,78 @@\n+! { dg-do compile }\n+! Part I of the test  of the IO constraints patch, which fixes PRs:\n+! PRs 25053, 25063, 25064, 25066, 25067, 25068, 25069, 25307 and 20862.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module fails\n+\n+ 2000 format (1h , 2i6)                        ! { dg-error \"Format statement in module\" }\n+\n+end module fails\n+\n+module global\n+\n+  integer :: modvar\n+  namelist /NL/ modvar\n+\n+contains\n+\n+  subroutine foo (i)\n+    integer :: i\n+    write (*, 100) i\n+ 100 format (1h , \"i=\", i6)                     ! This is OK.\n+  end subroutine foo\n+\n+end module global\n+\n+ use global\n+ integer :: a,b, c(20)\n+ integer(8) :: ierr\n+ character*80 :: buffer(3)\n+\n+! Appending to a USE associated namelist is an extension.\n+\n+ NAMELIST /NL/ a,b                              ! { dg-warning \"already is USE associated\" }\n+\n+ a=1 ; b=2\n+\n+!9.2.2.1:\n+ write(c, *) a, b                               !  { dg-error \"array\" }\n+!Was correctly picked up before patch.\n+ write(buffer((/3,1,2/)), *) a, b               !  { dg-error \"vector subscript\" }\n+\n+!9.2.2.2 and one of 9.4.1\n+!________________________\n+\n+ write(6, NML=NL, FMT = '(i6)')                 !  { dg-error \"group name and format\" }\n+ write(6, NML=NL, FMT = 200)                    !  { dg-error \"group name and format\" }\n+\n+!9.4.1\n+!_____\n+!\n+\n+! R912\n+!Was correctly picked up before patch.\n+ write(6, NML=NL, iostat = ierr)                ! { dg-warning \"requires default INTEGER\" }\n+ READ(1, fmt='(i6)', advance='NO', size = ierr) ! { dg-warning \"requires default INTEGER\" }\n+\n+! Constraints\n+!Was correctly picked up before patch.\n+ write(1, fmt='(i6)', end = 100) a              ! { dg-error \"END tag\" }\n+!Was correctly picked up before patch.\n+ write(1, fmt='(i6)', eor = 100) a              ! { dg-error \"EOR tag\" }\n+!Was correctly picked up before patch.\n+ write(1, fmt='(i6)', size = b) a               ! { dg-error \"SIZE=specifier not allowed\" }\n+\n+\n+ READ(1, fmt='(i6)', end = 900) a               ! { dg-error \"not defined\" }\n+ READ(1, fmt='(i6)', eor = 900, advance='NO') a ! { dg-error \"not defined\" }\n+ READ(1, fmt='(i6)', ERR = 900) a               ! { dg-error \"not defined\" }\n+\n+!Was correctly picked up before patch.\n+ READ(1, fmt=800) a                             ! { dg-error \"not defined\" }\n+\n+\n+100 continue\n+200 format (2i6)\n+ END"}, {"sha": "8100a4d3690116abd86089ac5583f4b99e1f1faf", "filename": "gcc/testsuite/gfortran.dg/io_constraints_2.f90", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fio_constraints_2.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,69 @@\n+! { dg-do compile }\n+! Part II of the test  of the IO constraints patch, which fixes PRs:\n+! PRs 25053, 25063, 25064, 25066, 25067, 25068, 25069, 25307 and 20862.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+\n+module global\n+\n+  integer :: modvar\n+  namelist /NL/ modvar\n+\n+contains\n+\n+  subroutine foo (i)\n+    integer :: i\n+    write (*, 100) i\n+ 100 format (1h , \"i=\", i6)                     ! This is OK.\n+  end subroutine foo\n+\n+end module global\n+\n+ use global\n+ integer :: a,b, c(20)\n+ integer(8) :: ierr\n+ character*80 :: buffer(3)\n+\n+\n+! Appending to a USE associated namelist is an extension.\n+\n+ NAMELIST /NL/ a,b                              ! { dg-warning \"already is USE associated\" }\n+\n+ a=1 ; b=2\n+\n+ write(*, NML=NL) z                             !  { dg-error \"followed by IO-list\" }\n+!Was correctly picked up before patch.\n+ print NL, z                                    !  { dg-error \"followed by IO-list\" }\n+!\n+! Not allowed with internal unit\n+!Was correctly picked up before patch.\n+ write(buffer, NML=NL)                          !  { dg-error \"incompatible with namelist\" }\n+!Was correctly picked up before patch.\n+ write(buffer, fmt='(i6)', REC=10) a            !  { dg-error \"REC tag\" }\n+ write(buffer, fmt='(i6)', END=10) a            !  { dg-error \"END tag\" }\n+\n+! Not allowed with REC= specifier\n+!Was correctly picked up before patch.\n+ read(10, REC=10, END=100)                      !  { dg-error \"END tag is not allowed\" }\n+ write(*, *, REC=10)                            !  { dg-error \"FMT=\" }\n+\n+! Not allowed with an ADVANCE=specifier\n+ READ(buffer, fmt='(i6)', advance='YES') a      ! { dg-error \"internal file\" }\n+ READ(1, NML=NL, advance='YES')                 ! { dg-error \"NAMELIST IO is not allowed\" }\n+\n+ write(1, fmt='(i6)', advance='YES', size = c(1)) a ! { dg-error \"output\" }\n+ write(1, fmt='(i6)', advance='YES', eor = 100) a   ! { dg-error \"output\" }\n+\n+ read(1, fmt='(i6)', advance='YES', size = c(1)) a  ! { dg-error \"ADVANCE = 'NO'\" }\n+ read(1, fmt='(i6)', advance='YES', eor = 100) a    ! { dg-error \"ADVANCE = 'NO'\" }\n+\n+ READ(1, fmt='(i6)', advance='NO', size = buffer) a ! { dg-error \"INTEGER\" }\n+!Was correctly picked up before patch. -correct syntax error\n+ READ(1, fmt='(i6)', advance='YES', size = 10) a    ! { dg-error \"Syntax error\" }\n+\n+ READ(1, fmt='(i6)', advance='MAYBE')               !  { dg-error \"YES or NO\" }\n+\n+100 continue\n+200 format (2i6)\n+ END"}, {"sha": "1dc72d149c4fb35ffe8848a4fa0afde3df34b908", "filename": "gcc/testsuite/gfortran.dg/iostat_3.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fiostat_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fiostat_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fiostat_3.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -3,6 +3,6 @@\n   real :: u\n   integer(kind=8) :: i\n   open (10,status=\"scratch\")\n-  read (10,*,iostat=i) u ! { dg-warning \"Fortran 2003: Non-default integer kind in IOSTAT tag\" }\n-  close (10,iostat=i) ! { dg-warning \"Fortran 2003: Non-default integer kind in IOSTAT tag\" }\n+  read (10,*,iostat=i) u ! { dg-warning \"Fortran 95 requires default INTEGER in IOSTAT tag\" }\n+  close (10,iostat=i) ! { dg-warning \"Fortran 95 requires default INTEGER in IOSTAT tag\" }\n   end"}, {"sha": "6d5cf8065f760c0424d5413fdb0125b37703c997", "filename": "gcc/testsuite/gfortran.dg/namelist_use.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_use.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_use.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fnamelist_use.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -15,7 +15,8 @@ end module global\n program namelist_use\n   use global\n   real    :: rrr\n-  namelist /nml2/ ii, rrr    ! Concatenate use and host associated variables.\n+! Concatenate use and host associated variables - an extension.\n+  namelist /nml2/ ii, rrr    ! { dg-warning \"already is USE associated\" }\n   open (10, status=\"scratch\")\n   write (10,*) \"&NML1 aa='lmno' ii=1 rr=2.5 /\"\n   write (10,*) \"&NML2 aa='pqrs' ii=2 rrr=3.5 /\""}, {"sha": "b3a4086aff662eb41ec2c207e8211c286dd819a3", "filename": "gcc/testsuite/gfortran.dg/pointer_component_type_1.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_component_type_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_component_type_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpointer_component_type_1.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! This checks the fix for PR20889 in wrong pointer types in derived\n+! type constructors would either give no message or would segfault.\n+!\n+! Contributed by Joost VandVondele  <jv244@cam.ac.uk>\n+!==============\n+  TYPE TEST\n+    REAL, POINTER :: A\n+  END TYPE\n+\n+  TYPE TEST1\n+    REAL :: A\n+  END TYPE\n+\n+  INTEGER, POINTER :: IP\n+  real, POINTER :: RP\n+  TYPE(TEST) :: DD\n+  TYPE(TEST1) :: EE\n+! Next line is the original => gave no warning/error.\n+  DD=TEST(NULL(IP))    ! { dg-error \"INTEGER but should be REAL\" }\n+! Would segfault here.\n+  DD=TEST(IP)          ! { dg-error \"INTEGER but should be REAL\" }\n+! Check right target type is OK.\n+  DD=TEST(NULL(RP))\n+! Check non-pointer is OK.\n+  EE= TEST1(1)\n+! Test attempted conversion from character to real.\n+  EE= TEST1(\"e\")       ! { dg-error \"convert CHARACTER\" }\n+END\n\\ No newline at end of file"}, {"sha": "0f566dcd1d4160d7b0367be574e993420c1b9716", "filename": "gcc/testsuite/gfortran.dg/pr15140.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15140.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15140.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr15140.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -3,7 +3,7 @@\n ! argument of the subroutine directly, but instead use a copy of it.\n function M(NAMES)\n   CHARACTER*(*) NAMES(*)\n-  if (any(names.ne.\"asdfg\")) call abort\n+  if (any(names(1:2).ne.\"asdfg\")) call abort\n   m = LEN(NAMES(1))\n END function M\n "}, {"sha": "9d034a680da4c5d5af8372c537f85dd4fc033703", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_1.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_1.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! This checks the fix for PR20244 in which USE association\n+! of derived types would cause an ICE, if the derived type\n+! was also available by host association. This occurred \n+! because the backend declarations were different. \n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!==============\n+module mtyp\n+  type t1\n+     integer::a\n+  end type t1\n+end module mtyp\n+!==============\n+module atest\n+  use mtyp\n+  type(t1)::ze\n+contains\n+  subroutine test(ze_in )\n+    use mtyp\n+    implicit none\n+    type(t1)::ze_in\n+    ze_in = ze\n+  end subroutine test\n+  subroutine init( )\n+    implicit none\n+    ze = t1 (42)\n+  end subroutine init\n+end module atest\n+!==============\n+  use atest\n+  type(t1) :: res = t1 (0)\n+  call init ()\n+  call test (res)\n+  if (res%a.ne.42) call abort\n+end  \n\\ No newline at end of file"}, {"sha": "f12d2864d0b560953ed49f14d4418f6c67e582bc", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_2.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_2.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,32 @@\n+! { dg-do compile }\n+! This tests that the fix for PR25391 also fixes PR20244. If\n+! the USE mod1 in subroutine foo were deleted, the code would\n+! compile fine.  With the USE statement, the compiler would\n+! make new TYPEs for T1 and T2 and bomb out in fold-convert.\n+! This is a slightly more elaborate test than\n+! used_dummy_types_1.f90 and came from the PR.\n+!\n+! Contributed by Jakub Jelinek  <jakubcc.gnu.org>\n+module mod1\n+  type t1\n+    real :: f1\n+  end type t1\n+  type t2\n+    type(t1), pointer :: f2(:)\n+    real, pointer :: f3(:,:)\n+  end type t2\n+end module mod1\n+\n+module mod2\n+  use mod1\n+  type(t1), pointer, save :: v(:)\n+contains\n+  subroutine foo (x)\n+    use mod1\n+    implicit none\n+    type(t2) :: x\n+    integer :: d\n+    d = size (x%f3, 2)\n+    v = x%f2(:)\n+  end subroutine foo\n+end module mod2"}, {"sha": "b252e45471f69731d6ff1b5b590327f6fa5114e9", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_3.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_3.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! This checks the fix for PR20864 in which same name, USE associated\n+! derived types from different modules, with private components were\n+! not recognised to be different.\n+!\n+! Contributed by Joost VandVondele  <jv244@cam.ac.uk>\n+!==============\n+  MODULE T1\n+    TYPE data_type\n+      SEQUENCE\n+  ! private causes the types in T1 and T2 to be different 4.4.2\n+      PRIVATE\n+      INTEGER :: I\n+    END TYPE\n+  END MODULE\n+\n+  MODULE T2\n+    TYPE data_type\n+      SEQUENCE\n+      PRIVATE\n+      INTEGER :: I\n+    END TYPE\n+\n+  CONTAINS\n+\n+    SUBROUTINE TEST(x)\n+      TYPE(data_type) :: x\n+    END SUBROUTINE TEST\n+  END MODULE\n+\n+    USE T1\n+    USE T2 , ONLY : TEST\n+    TYPE(data_type) :: x\n+    CALL TEST(x)         ! { dg-error \"Type/rank mismatch in argument\" }\n+  END\n+"}, {"sha": "98b5905d478422d9aa1b948d073ab892af14ed66", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_4.f90", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_4.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,101 @@\n+! { dg-do compile }\n+! This checks the fix for PR19362 in which types from different scopes\n+! that are the same, according to 4.4.2, would generate an ICE if one\n+! were assigned to the other.  As well as the test itself, various\n+! other requirements of 4.4.2 are tested here.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!==============\n+module global\n+\n+  TYPE :: seq_type1\n+    sequence\n+    integer :: i\n+  end type seq_type1\n+\n+  TYPE :: nonseq_type1\n+    integer :: i\n+  end type nonseq_type1\n+  type (nonseq_type1) :: ns1\n+\n+end module global\n+\n+! Host types with local name != true name\n+  use global, only: seq_type2=>seq_type1, nonseq_type2=>nonseq_type1, ns1\n+  type (nonseq_type2) :: ns2\n+\n+! Host non-sequence types\n+  type :: different_type\n+    integer :: i\n+  end type different_type\n+  type (different_type)  :: dt1\n+\n+  type :: same_type\n+    integer :: i\n+  end type same_type\n+  type (same_type)  :: st1\n+\n+  real :: seq_type1\n+\n+! Provide a reference to dt1.\n+  dt1 = different_type (42)\n+! These share a type declaration.\n+  ns2 = ns1\n+! USE associated seq_type1 is renamed.\n+  seq_type1 = 1.0\n+\n+! These are different.\n+  st1 = dt                ! { dg-error \"convert REAL\" }\n+\n+  call foo (st1)          ! { dg-error \"Type/rank mismatch in argument\" }\n+\n+contains\n+\n+  subroutine foo (st2)\n+\n+! Contained type with local name != true name.\n+! This is the same as seq_type2 in the host.\n+    use global, only: seq_type3=>seq_type1\n+\n+! This local declaration is the same as seq_type3 and seq_type2.\n+    TYPE :: seq_type1\n+      sequence\n+      integer :: i\n+    end type seq_type1\n+\n+! Host association of renamed type.\n+    type (seq_type2) :: x\n+! Locally declared version of the same thing.\n+    type (seq_type1) :: y\n+! USE associated renamed type.\n+    type (seq_type3) :: z\n+\n+! Contained type that is different to that in the host.\n+    type :: different_type\n+      complex :: z\n+    end type different_type\n+\n+    type :: same_type\n+      integer :: i\n+    end type same_type\n+\n+    type (different_type)  :: b\n+    type (same_type)  :: st2\n+\n+! Error because these are not the same.\n+    b = dt1               ! { dg-error \"convert TYPE\" }\n+\n+! Error in spite of the name - these are non-sequence types and are NOT\n+! the same.\n+    st1 = st2             ! { dg-error \"convert TYPE\" }\n+\n+    b%z = (2.0,-1.0)\n+\n+! Check that the references that are correct actually work. These test the\n+! fix for PR19362.\n+    x = seq_type1 (1)\n+    y = x\n+    y = seq_type3 (99)\n+  end subroutine foo\n+END\n+"}, {"sha": "b8b15e009502ec4b9a34d8bde490488f7c01b330", "filename": "gcc/testsuite/gfortran.dg/used_dummy_types_5.f90", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e0e85e0617394f491e74fd1d8c5f121fa5527487/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fused_dummy_types_5.f90?ref=e0e85e0617394f491e74fd1d8c5f121fa5527487", "patch": "@@ -0,0 +1,85 @@\n+! { dg-do compile }\n+! This checks that the fix for PR19362 has not broken gfortran\n+! in respect of.references allowed by 4.4.2.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!==============\n+module global\n+\n+  TYPE :: seq_type1\n+    sequence\n+    integer :: i\n+  end type seq_type1\n+\n+  TYPE :: nonseq_type1\n+    integer :: i = 44\n+  end type nonseq_type1\n+  type (nonseq_type1), save :: ns1\n+\n+end module global\n+\n+  use global, only: seq_type2=>seq_type1, nonseq_type1, ns1\n+\n+! Host non-sequence types\n+  type :: different_type\n+    integer :: i\n+  end type different_type\n+\n+  type :: same_type\n+    sequence\n+    integer :: i\n+  end type same_type\n+\n+  type (seq_type2)  :: t1\n+  type (different_type)  :: dt1\n+\n+  type (nonseq_type1) :: ns2\n+  type (same_type)  :: st1\n+  real seq_type1\n+\n+  t1 = seq_type2 (42)\n+  dt1 = different_type (43)\n+  ns2 = ns1\n+  seq_type1 =1.0e32\n+  st1%i = 45\n+\n+  call foo (t1)\n+\n+contains\n+\n+  subroutine foo (x)\n+\n+    use global, only: seq_type3=>seq_type1\n+\n+    TYPE :: seq_type1\n+      sequence\n+      integer :: i\n+    end type seq_type1\n+\n+    type :: different_type\n+      complex :: z\n+    end type different_type\n+\n+    type :: same_type\n+      sequence\n+      integer :: i\n+    end type same_type\n+! Host association of renamed type.\n+    type (seq_type2) :: x\n+! Locally declared version of the same thing.\n+    type (seq_type1) :: y\n+! USE associated renamed type.\n+    type (seq_type3) :: z\n+\n+\n+    type (different_type)  :: dt2\n+    type (same_type)  :: st2\n+\n+    dt2%z = (2.0,-1.0)\n+    y = seq_type2 (46)\n+    z = seq_type3 (47)\n+    st2 = st1\n+    print *, x, y, z, dt2, st2, ns2, ns1\n+  end subroutine foo\n+END\n+"}]}