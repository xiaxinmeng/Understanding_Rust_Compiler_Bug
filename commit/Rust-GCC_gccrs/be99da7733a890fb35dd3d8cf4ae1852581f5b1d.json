{"sha": "be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU5OWRhNzczM2E4OTBmYjM1ZGQzZDhjZjRhZTE4NTI1ODFmNWIxZA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-01-17T18:57:55Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-01-17T18:57:55Z"}, "message": "78th Cygnus<->FSF merge\n\nFrom-SVN: r11039", "tree": {"sha": "35917201c2e79bcd4b979c022dbc9be8b0628be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35917201c2e79bcd4b979c022dbc9be8b0628be0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/comments", "author": null, "committer": null, "parents": [{"sha": "3a265431763860a5381416371d38e2d602cfdaaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a265431763860a5381416371d38e2d602cfdaaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a265431763860a5381416371d38e2d602cfdaaf"}], "stats": {"total": 1337, "additions": 741, "deletions": 596}, "files": [{"sha": "22cb2b3c743eacd9d27d394874ff271876243212", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1,3 +1,137 @@\n+Wed Jan 17 10:18:01 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl2.c (warn_pointer_arith): Default to on.\n+\n+Tue Jan 16 12:45:38 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (is_rid): New function.\n+\t* decl.c (grokdeclarator): Diagnose reserved words used as\n+\tdeclarator-ids.\n+\n+Tue Jan 16 11:39:40 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* tree.c (get_decl_list): Don't lose cv-quals.\n+\n+\t* decl.c (grokdeclarator): Fix SCOPE_REF handling and diagnose\n+\ttypespecs used as declarator-ids.\n+\n+Tue Jan 16 11:09:42 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (poplevel): When poping a level, don't give a warning for\n+\tany subblocks that already exist.\n+\n+Tue Jan 16 00:25:33 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_object_ref): Finish what I started.\n+\n+\t* parse.y (qualified_type_name): Don't check TYPE_BUILT_IN.\n+\n+\t* decl2.c (constructor_name_full): Handle TEMPLATE_TYPE_PARMs.\n+\n+\t* decl.c (grokdeclarator): Also accept TEMPLATE_TYPE_PARM as a\n+ \tscope.\n+\n+Mon Jan 15 16:19:32 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl.c (xref_tag): Handle passing a type in directly.\n+\n+\t* parse.y (qualified_type_name): Pull out the type.\n+\t(nested_type): Ditto.\n+\tTake types directly instead of as identifiers.\n+\t* call.c (build_scoped_method_call): Take types directly instead of\n+ \tas identifiers.\n+  \t* decl.c (xref_basetypes): Ditto.\n+\t* init.c (expand_member_init): Ditto.\n+\t(build_member_call): Ditto.\n+\t(build_offset_ref): Ditto.\n+\t* typeck2.c (build_scoped_ref): Ditto, remove bogus code.\n+\t* method.c (do_build_assign_ref): Ditto.\n+\t* decl.c (grokdeclarator): Handle a type appearing as the\n+\tdeclarator-id for constructors.\n+\t* method.c (do_build_copy_constructor): current_base_init_list now\n+\tuses the types directly, not their names.\n+\t* init.c (sort_base_init): Ditto.\n+\t(expand_member_init): Ditto.\n+\t* init.c (is_aggr_type): New function, like is_aggr_typedef.\n+\t* class.c (pushclass): If !modify and\n+ \tCLASSTYPE_LOCAL_TYPEDECLS (type)), do set up IDENTIFIER_TYPE_VALUE\n+\tfor inherited types.\n+\n+Mon Jan 15 08:45:01 1996  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* tree.c (layout_basetypes): Call build_lang_field_decl instead\n+\tof build_lang_decl if first arg is a FIELD_DECL.\n+\t(tree_copy_lang_decl_for_deferred_output): Reverse test for when\n+\tto copy DECL_MAIN_VARIANT and DECL_CHAIN.\n+\n+Thu Jan 11 14:55:07 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\t* decl.c (cp_finish_decl): Only clear TREE_USED if DECL_NAME is\n+\tnon-empty.\n+\t* except.c (expand_start_catch_block): Set TREE_USED to avoid\n+\twarnings about the catch handler.\n+\n+Mon Jan  8 17:35:12 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Use a COMPOUND_EXPR instead of\n+ \texpand_target_expr.\n+\n+Thu Jan  4 12:30:32 1996  Brendan Kehoe  <brendan@lisa.cygnus.com>\n+\n+\tFix access control to use trees rather than integers.\n+\t* class.c (access_{default, public, protected, private,\n+\tdefault_virtual, public_virtual, private_virtual}_node): Add\n+\tdefinitions.\n+\t(init_class_processing): Do creation of those nodes.\n+\t* cp-tree.h (access_type): Delete enum decl.\n+\t(access_{default, public, protected, private, default_virtual,\n+\tpublic_virtual, private_virtual}_node): Add decls.\n+\t(compute_access): Change return type.\n+\t* search.c (compute_access): Have tree return type, instead of enum.\n+\t(lookup_field): Declare THIS_V and NEW_V to be tree nodes.\n+\t* lex.c (real_yylex): Use yylval.ttype for giving the value of the\n+\taccess_* node for each of RID_{PUBLIC, PRIVATE, PROTECTED}.\n+\t* parse.y (VISSPEC): Make ttype rather than itype.\n+\t(base_class_access_list): Likewise.\n+\t* *.[cy]: Change all refs of `access_public' to `access_public_node',\n+\tetc.\n+\t* call.c (build_method_call): Make ACCESS be a tree.\n+\t* class.c (alter_access, finish_struct_1, filter_struct): Likewise.\n+\t* cvt.c (convert_to_aggr): Likewise.\n+\t* init.c (build_offset_ref, resolve_offset_ref, build_delete):\n+\tLikewise.\n+\t* method.c (hack_identifier): Likewise.\n+\t* typeck.c (build_component_ref_1, build_component_ref): ): Likewise.\n+\n+Thu Jan  4 11:02:20 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (pointer_int_sum, pointer_diff): Make code agree with C\n+\tfrontend, and make it more consistent with respect to\n+\twarn_pointer_arith.\n+\n+Tue Jan  2 00:13:38 1996  Rusty Russell  <rusty@adelaide.maptek.com.au>\n+\n+\t* decl.c (pushdecl): Check for duplicate parameter names.\n+\n+Wed Jan  3 09:25:48 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (expand_static_init): Call assemble_external for atexit.\n+\n+Wed Jan  3 07:55:19 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (do_unwind): Remove some generated dead code.\n+\t(eh_outer_context): New routine, factor out some common code from\n+\texpand_builtin_throw and end_eh_unwinder.  Add code to do return\n+\taddress masking for the PA.\n+\t(expand_builtin_throw): Use eh_outer_context instead of open coding\n+\tit here.\n+\t(end_eh_unwinder): Ditto.\n+\n+Tue Jan  2 17:00:56 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (expand_throw): Call assemble_external for __empty, if we\n+\tuse it.\n+\n Thu Dec 28 11:13:15 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* except.c (expand_builtin_throw): Use RETURN_ADDR_OFFSET instead of\n@@ -3977,7 +4111,7 @@ Fri Dec  9 18:17:37 1994  Doug Evans  <dje@cygnus.com>\n \t(PARSE_H): Depend on $(PARSE_C), for parallel makes.\n \t(PARSE_C): Undo last patch.\n \n-Fri Dec  2 10:44:36 1994  Mike Stump  (mrs@wombat.gnu.ai.mit.edu)\n+Fri Dec  2 10:44:36 1994  Mike Stump  <mrs@cygnus.com>\n \n \t* Makefile.in (BISONFLAGS): Add --yacc so that output winds up in\n \ty.tab.c."}, {"sha": "cbe5588a3933116b6e8ff9729c89ba34fe3af02f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1461,32 +1461,29 @@ resolve_scope_to_name (outer_type, inner_stuff)\n /* Build a method call of the form `EXP->SCOPES::NAME (PARMS)'.\n    This is how virtual function calls are avoided.  */\n tree\n-build_scoped_method_call (exp, scopes, name, parms)\n-     tree exp, scopes, name, parms;\n+build_scoped_method_call (exp, basetype, name, parms)\n+     tree exp, basetype, name, parms;\n {\n   /* Because this syntactic form does not allow\n      a pointer to a base class to be `stolen',\n      we need not protect the derived->base conversion\n      that happens here.\n      \n      @@ But we do have to check access privileges later.  */\n-  tree basename = resolve_scope_to_name (NULL_TREE, scopes);\n-  tree basetype, binfo, decl;\n+  tree binfo, decl;\n   tree type = TREE_TYPE (exp);\n \n   if (type == error_mark_node\n-      || basename == NULL_TREE)\n+      || basetype == error_mark_node)\n     return error_mark_node;\n \n-  basetype = IDENTIFIER_TYPE_VALUE (basename);\n-\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     type = TREE_TYPE (type);\n \n   /* Destructors can be \"called\" for simple types; see 5.2.4 and 12.4 Note\n      that explicit ~int is caught in the parser; this deals with typedefs\n      and template parms.  */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR && ! is_aggr_typedef (basename, 0))\n+  if (TREE_CODE (name) == BIT_NOT_EXPR && ! IS_AGGR_TYPE (basetype))\n     {\n       if (type != basetype)\n \tcp_error (\"type of `%E' does not match destructor type `%T' (type was `%T')\",\n@@ -1498,7 +1495,7 @@ build_scoped_method_call (exp, scopes, name, parms)\n       return convert (void_type_node, exp);\n     }\n \n-  if (! is_aggr_typedef (basename, 1))\n+  if (! is_aggr_type (basetype, 1))\n     return error_mark_node;\n \n   if (! IS_AGGR_TYPE (type))\n@@ -1516,7 +1513,7 @@ build_scoped_method_call (exp, scopes, name, parms)\n \tdecl = build_indirect_ref (convert_pointer_to (binfo,\n \t\t\t\t\t\t       build_unary_op (ADDR_EXPR, exp, 0)), NULL_PTR);\n       else\n-\tdecl = build_scoped_ref (exp, scopes);\n+\tdecl = build_scoped_ref (exp, basetype);\n \n       /* Call to a destructor.  */\n       if (TREE_CODE (name) == BIT_NOT_EXPR)\n@@ -1613,7 +1610,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   register tree baselink, result, method_name, parmtypes, parm;\n   tree last;\n   int pass;\n-  enum access_type access = access_public;\n+  tree access = access_public_node;\n \n   /* Range of cases for vtable optimization.  */\n   enum vtable_needs { not_needed, maybe_needed, unneeded, needed };\n@@ -2422,7 +2419,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   if (flags & LOOKUP_PROTECT)\n     access = compute_access (basetype_path, function);\n \n-  if (access == access_private)\n+  if (access == access_private_node)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{\n@@ -2433,7 +2430,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t}\n       return error_mark_node;\n     }\n-  else if (access == access_protected)\n+  else if (access == access_protected_node)\n     {\n       if (flags & LOOKUP_COMPLAIN)\n \t{"}, {"sha": "cca35da334d4fb26059c16a65f413508cdb64e05", "filename": "gcc/cp/class.c", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -98,6 +98,15 @@ char *dont_allow_type_definitions;\n    via this node.  */\n static tree base_layout_decl;\n \n+/* Constants used for access control.  */\n+tree access_default_node; /* 0 */\n+tree access_public_node; /* 1 */\n+tree access_protected_node; /* 2 */\n+tree access_private_node; /* 3 */\n+tree access_default_virtual_node; /* 4 */\n+tree access_public_virtual_node; /* 5 */\n+tree access_private_virtual_node; /* 6 */\n+\n /* Variables shared between class.c and call.c.  */\n \n int n_vtables = 0;\n@@ -1108,10 +1117,10 @@ static int\n alter_access (t, fdecl, access)\n      tree t;\n      tree fdecl;\n-     enum access_type access;\n+     tree access;\n {\n   tree elem = purpose_member (t, DECL_ACCESS (fdecl));\n-  if (elem && TREE_VALUE (elem) != (tree)access)\n+  if (elem && TREE_VALUE (elem) != access)\n     {\n       if (TREE_CODE (TREE_TYPE (fdecl)) == FUNCTION_DECL)\n \t{\n@@ -1123,25 +1132,24 @@ alter_access (t, fdecl, access)\n     }\n   else if (TREE_PRIVATE (fdecl))\n     {\n-      if (access != access_private)\n+      if (access != access_private_node)\n \tcp_error_at (\"cannot make private `%D' non-private\", fdecl);\n       goto alter;\n     }\n   else if (TREE_PROTECTED (fdecl))\n     {\n-      if (access != access_protected)\n+      if (access != access_protected_node)\n \tcp_error_at (\"cannot make protected `%D' non-protected\", fdecl);\n       goto alter;\n     }\n   /* ARM 11.3: an access declaration may not be used to restrict access\n      to a member that is accessible in the base class.  */\n-  else if (access != access_public)\n+  else if (access != access_public_node)\n     cp_error_at (\"cannot reduce access of public member `%D'\", fdecl);\n   else if (elem == NULL_TREE)\n     {\n     alter:\n-      DECL_ACCESS (fdecl) = tree_cons (t, (tree)access,\n-\t\t\t\t\t   DECL_ACCESS (fdecl));\n+      DECL_ACCESS (fdecl) = tree_cons (t, access, DECL_ACCESS (fdecl));\n       return 1;\n     }\n   return 0;\n@@ -2957,16 +2965,16 @@ finish_struct_1 (t, warn_anon)\n       if (DECL_NAME (x) && TREE_CODE (DECL_NAME (x)) == SCOPE_REF)\n \t{\n \t  tree fdecl = TREE_OPERAND (DECL_NAME (x), 1);\n-\t  enum access_type access\n-\t    = TREE_PRIVATE (x) ? access_private :\n-\t      TREE_PROTECTED (x) ? access_protected : access_public;\n+\t  tree access\n+\t    = TREE_PRIVATE (x) ? access_private_node :\n+\t      TREE_PROTECTED (x) ? access_protected_node : access_public_node;\n \n \t  if (last_x)\n \t    TREE_CHAIN (last_x) = TREE_CHAIN (x);\n \t  else\n \t    fields = TREE_CHAIN (x);\n \n-\t  access_decls = tree_cons ((tree) access, fdecl, access_decls);\n+\t  access_decls = tree_cons (access, fdecl, access_decls);\n \t  continue;\n \t}\n \n@@ -3411,7 +3419,7 @@ finish_struct_1 (t, warn_anon)\n \ttree fdecl = TREE_VALUE (access_decls);\n \ttree flist = NULL_TREE;\n \ttree name;\n-\tenum access_type access = (enum access_type)TREE_PURPOSE(access_decls);\n+\ttree access = TREE_PURPOSE(access_decls);\n \tint i = TREE_VEC_ELT (method_vec, 0) ? 0 : 1;\n \ttree tmp;\n \n@@ -4053,7 +4061,7 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   tree *tail = &TYPE_METHODS (t);\n   tree name = TYPE_NAME (t);\n   tree x, last_x = NULL_TREE;\n-  enum access_type access;\n+  tree access;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n@@ -4083,21 +4091,21 @@ finish_struct (t, list_of_fieldlists, warn_anon)\n   if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n     {\n       if (list_of_fieldlists\n-\t  && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n-\tTREE_PURPOSE (list_of_fieldlists) = (tree)access_public;\n+\t  && TREE_PURPOSE (list_of_fieldlists) == access_default_node)\n+\tTREE_PURPOSE (list_of_fieldlists) = access_public_node;\n     }\n   else if (list_of_fieldlists\n-\t   && TREE_PURPOSE (list_of_fieldlists) == (tree)access_default)\n-    TREE_PURPOSE (list_of_fieldlists) = (tree)access_private;\n+\t   && TREE_PURPOSE (list_of_fieldlists) == access_default_node)\n+    TREE_PURPOSE (list_of_fieldlists) = access_private_node;\n \n   while (list_of_fieldlists)\n     {\n-      access = (enum access_type)TREE_PURPOSE (list_of_fieldlists);\n+      access = TREE_PURPOSE (list_of_fieldlists);\n \n       for (x = TREE_VALUE (list_of_fieldlists); x; x = TREE_CHAIN (x))\n \t{\n-\t  TREE_PRIVATE (x) = access == access_private;\n-\t  TREE_PROTECTED (x) = access == access_protected;\n+\t  TREE_PRIVATE (x) = access == access_private_node;\n+\t  TREE_PROTECTED (x) = access == access_protected_node;\n \n \t  /* Check for inconsistent use of this name in the class body.\n              Enums, types and static vars have already been checked.  */\n@@ -4306,6 +4314,14 @@ init_class_processing ()\n   current_lang_base = (tree *)xmalloc(current_lang_stacksize * sizeof (tree));\n   current_lang_stack = current_lang_base;\n \n+  access_default_node = build_int_2 (0, 0);\n+  access_public_node = build_int_2 (1, 0);\n+  access_protected_node = build_int_2 (2, 0);\n+  access_private_node = build_int_2 (3, 0);\n+  access_default_virtual_node = build_int_2 (4, 0);\n+  access_public_virtual_node = build_int_2 (5, 0);\n+  access_private_virtual_node = build_int_2 (6, 0);\n+\n   /* Keep these values lying around.  */\n   the_null_vtable_entry = build_vtable_entry (integer_zero_node, integer_zero_node);\n   base_layout_decl = build_lang_field_decl (FIELD_DECL, NULL_TREE, error_mark_node);\n@@ -4400,7 +4416,7 @@ pushclass (type, modify)\n       else if (type != previous_class_type || current_class_depth > 1)\n \t{\n \t  build_mi_matrix (type);\n-\t  push_class_decls (type);\n+\t  push_class_decls (type, !modify);\n \t  free_mi_matrix ();\n \t  if (current_class_depth == 1)\n \t    previous_class_type = type;\n@@ -4437,6 +4453,12 @@ pushclass (type, modify)\n \n       current_function_decl = this_fndecl;\n     }\n+  else if (CLASSTYPE_LOCAL_TYPEDECLS (type))\n+    {\n+      build_mi_matrix (type);\n+      push_class_decls (type, !modify);\n+      free_mi_matrix ();\n+    }\n \n   if (flag_cadillac)\n     cadillac_push_class (type);"}, {"sha": "6ad5ea097daf5e3fac8bbb9ff83713a1b066466d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1727,15 +1727,14 @@ extern int current_function_parms_stored;\n    can have.  These are sensible combinations of {public,private,protected}\n    cross {virtual,non-virtual}.  */\n \n-enum access_type {\n-  access_default,\n-  access_public,\n-  access_protected,\n-  access_private,\n-  access_default_virtual,\n-  access_public_virtual,\n-  access_private_virtual\n-};\n+/* in class.c. */\n+extern tree access_default_node; /* 0 */\n+extern tree access_public_node; /* 1 */\n+extern tree access_protected_node; /* 2 */\n+extern tree access_private_node; /* 3 */\n+extern tree access_default_virtual_node; /* 4 */\n+extern tree access_public_virtual_node; /* 5 */\n+extern tree access_private_virtual_node; /* 6 */\n \n /* in lex.c  */\n extern tree current_unit_name, current_unit_language;\n@@ -2311,7 +2310,7 @@ extern void push_memoized_context\t\tPROTO((tree, int));\n extern void pop_memoized_context\t\tPROTO((int));\n extern tree get_binfo\t\t\t\tPROTO((tree, tree, int));\n extern int get_base_distance\t\t\tPROTO((tree, tree, int, tree *));\n-extern enum access_type compute_access\t\tPROTO((tree, tree));\n+extern tree compute_access\t\t\tPROTO((tree, tree));\n extern tree lookup_field\t\t\tPROTO((tree, tree, int, int));\n extern tree lookup_nested_field\t\t\tPROTO((tree, int));\n extern tree lookup_fnfields\t\t\tPROTO((tree, tree, int));\n@@ -2333,7 +2332,7 @@ extern void build_mi_virtuals\t\t\tPROTO((int, int));\n extern void add_mi_virtuals\t\t\tPROTO((int, tree));\n extern void report_ambiguous_mi_virtuals\tPROTO((int, tree));\n extern void note_debug_info_needed\t\tPROTO((tree));\n-extern void push_class_decls\t\t\tPROTO((tree));\n+extern void push_class_decls\t\t\tPROTO((tree, int));\n extern void pop_class_decls\t\t\tPROTO((tree));\n extern void unuse_fields\t\t\tPROTO((tree));\n extern void unmark_finished_struct\t\tPROTO((tree));"}, {"sha": "c135bbaa27ba2d04aac48936a5c61158ccce610f", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -896,8 +896,7 @@ convert_to_aggr (type, expr, msgp, protect)\n   tree basetype = type;\n   tree name = TYPE_IDENTIFIER (basetype);\n   tree function, fndecl, fntype, parmtypes, parmlist, result;\n-  tree method_name;\n-  enum access_type access;\n+  tree method_name, access;\n   int can_be_private, can_be_protected;\n \n   if (! TYPE_HAS_CONSTRUCTOR (basetype))\n@@ -907,7 +906,7 @@ convert_to_aggr (type, expr, msgp, protect)\n       return error_mark_node;\n     }\n \n-  access = access_public;\n+  access = access_public_node;\n   can_be_private = 0;\n   can_be_protected = IDENTIFIER_CLASS_VALUE (name) || name == current_class_name;\n \n@@ -987,20 +986,20 @@ convert_to_aggr (type, expr, msgp, protect)\n \t    if (protect)\n \t      {\n \t\tif (TREE_PRIVATE (fndecl))\n-\t\t  access = access_private;\n+\t\t  access = access_private_node;\n \t\telse if (TREE_PROTECTED (fndecl))\n-\t\t  access = access_protected;\n+\t\t  access = access_protected_node;\n \t\telse\n-\t\t  access = access_public;\n+\t\t  access = access_public_node;\n \t      }\n \t    else\n-\t      access = access_public;\n+\t      access = access_public_node;\n \n-\t    if (access == access_private\n+\t    if (access == access_private_node\n \t\t? (basetype == current_class_type\n \t\t   || is_friend (basetype, cp->function)\n \t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n-\t\t: access == access_protected\n+\t\t: access == access_protected_node\n \t\t? (can_be_protected\n \t\t   || purpose_member (basetype, DECL_ACCESS (fndecl)))\n \t\t: 1)\n@@ -1011,7 +1010,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \t      }\n \t    else\n \t      {\n-\t\tif (access == access_private)\n+\t\tif (access == access_private_node)\n \t\t  saw_private = 1;\n \t\telse\n \t\t  saw_protected = 1;\n@@ -1061,7 +1060,7 @@ convert_to_aggr (type, expr, msgp, protect)\n   /* NOTREACHED */\n \n  found:\n-  if (access == access_private)\n+  if (access == access_private_node)\n     if (! can_be_private)\n       {\n \tif (msgp)\n@@ -1070,7 +1069,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \t    : \"conversion to type `%s' is from private base class\";\n \treturn error_mark_node;\n       }\n-  if (access == access_protected)\n+  if (access == access_protected_node)\n     if (! can_be_protected)\n       {\n \tif (msgp)"}, {"sha": "49eb67ea4be7ebec74ef3a654b09492d9446a813", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 212, "deletions": 205, "changes": 417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1104,17 +1104,22 @@ poplevel (keep, reverse, functionbody)\n \t{\n \t  if (decls || tags || subblocks)\n \t    {\n-\t      if (BLOCK_VARS (block) || BLOCK_TYPE_TAGS (block) || BLOCK_SUBBLOCKS (block))\n+\t      if (BLOCK_VARS (block) || BLOCK_TYPE_TAGS (block))\n \t\t{\n \t\t  warning (\"internal compiler error: debugging info corrupted\");\n \t\t}\n \t      BLOCK_VARS (block) = decls;\n \t      BLOCK_TYPE_TAGS (block) = tags;\n-\t      /* Recover from too many blocks by chaining them together. */\n-\t      BLOCK_SUBBLOCKS (block) = chainon (BLOCK_SUBBLOCKS (block), subblocks);\n+\n+\t      /* We can have previous subblocks and new subblocks when\n+\t\t doing fixup_gotos with complex cleanups.  We chain the new\n+\t\t subblocks onto the end of any pre-existing subblocks.  */\n+\t      BLOCK_SUBBLOCKS (block) = chainon (BLOCK_SUBBLOCKS (block),\n+\t\t\t\t\t\t subblocks);\n \t    }\n-\t  /* If we created the block earlier on, and we are just diddling it now, then\n-\t     it already should have a proper BLOCK_END_NOTE value associated with it.  */\n+\t  /* If we created the block earlier on, and we are just\n+\t     diddling it now, then it already should have a proper\n+\t     BLOCK_END_NOTE value associated with it.  */\n \t}\n       else\n \t{\n@@ -3140,6 +3145,10 @@ pushdecl (x)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n \t\tfatal (\"parse errors have confused me too much\");\n+\n+\t      /* Check for duplicate params. */\n+\t      if (duplicate_decls (x, t))\n+\t\treturn t;\n \t    }\n \t  else if (((TREE_CODE (x) == FUNCTION_DECL && DECL_LANGUAGE (x) == lang_c)\n \t       || (TREE_CODE (x) == TEMPLATE_DECL\n@@ -6909,7 +6918,9 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n \t\t was initialized was ever used.  Don't do this if it has a\n \t\t destructor, so we don't complain about the 'resource\n \t\t allocation is initialization' idiom.  */\n-\t      if (TYPE_NEEDS_CONSTRUCTING (type) && cleanup == NULL_TREE)\n+\t      if (TYPE_NEEDS_CONSTRUCTING (type)\n+\t\t  && cleanup == NULL_TREE\n+\t\t  && DECL_NAME (decl))\n \t\tTREE_USED (decl) = 0;\n \n \t      /* Store the cleanup, if there was one.  */\n@@ -7069,6 +7080,7 @@ expand_static_init (decl, init)\n \t\t\t\t  build_function_type (void_type_node,\n \t\t\t\t\t\t       pfvlist),\n \t\t\t\t  NOT_BUILT_IN, NULL_PTR);\n+\t      assemble_external (atexit_fndecl);\n \t      Atexit = default_conversion (atexit_fndecl);\n \t      pop_lang_context ();\n \t      pop_obstacks ();\n@@ -7690,222 +7702,211 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises, attrli\n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   {\n-    tree last = NULL_TREE;\n-    register tree decl = declarator;\n+    tree *next = &declarator;\n+    register tree decl;\n     name = NULL;\n \n-    while (decl)\n-      switch (TREE_CODE (decl))\n-        {\n-\tcase COND_EXPR:\n-\t  ctype = NULL_TREE;\n-\t  decl = TREE_OPERAND (decl, 0);\n-\t  break;\n-\n-\tcase BIT_NOT_EXPR:      /* for C++ destructors!  */\n+    while (next && *next)\n+      {\n+\tdecl = *next;\n+\tswitch (TREE_CODE (decl))\n \t  {\n-\t    tree name = TREE_OPERAND (decl, 0);\n-\t    tree rename = NULL_TREE;\n-\n-\t    my_friendly_assert (flags == NO_SPECIAL, 152);\n-\t    flags = DTOR_FLAG;\n-\t    return_type = return_dtor;\n-\t    my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 153);\n-\t    if (ctype == NULL_TREE)\n-\t      {\n-\t\tif (current_class_type == NULL_TREE)\n-\t\t  {\n-\t\t    error (\"destructors must be member functions\");\n-\t\t    flags = NO_SPECIAL;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    tree t = constructor_name (current_class_name);\n-\t\t    if (t != name)\n-\t\t      rename = t;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\ttree t = constructor_name (ctype);\n-\t\tif (t != name)\n-\t\t  rename = t;\n-\t      }\n-\n-\t    if (rename)\n-\t      {\n-\t\terror (\"destructor `%s' must match class name `%s'\",\n-\t\t       IDENTIFIER_POINTER (name),\n-\t\t       IDENTIFIER_POINTER (rename));\n-\t\tTREE_OPERAND (decl, 0) = rename;\n-\t      }\n-\t    decl = name;\n-\t  }\n-\t  break;\n-\n-\tcase ADDR_EXPR:         /* C++ reference declaration */\n-\t  /* fall through */\n-\tcase ARRAY_REF:\n-\tcase INDIRECT_REF:\n-\t  ctype = NULL_TREE;\n-\t  innermost_code = TREE_CODE (decl);\n-\t  last = decl;\n-\t  decl = TREE_OPERAND (decl, 0);\n-\t  break;\n+\t  case COND_EXPR:\n+\t    ctype = NULL_TREE;\n+\t    next = &TREE_OPERAND (decl, 0);\n+\t    break;\n \n-\tcase CALL_EXPR:\n-\t  if (parmlist_is_exprlist (TREE_OPERAND (decl, 1)))\n+\t  case BIT_NOT_EXPR:\t/* for C++ destructors!  */\n \t    {\n-\t      /* This is actually a variable declaration using constructor\n-\t\t syntax.  We need to call start_decl and cp_finish_decl so we\n-\t\t can get the variable initialized...  */\n-\n-\t      if (last)\n-\t\t/* We need to insinuate ourselves into the declarator in place\n-\t\t   of the CALL_EXPR.  */\n-\t\tTREE_OPERAND (last, 0) = TREE_OPERAND (decl, 0);\n+\t      tree name = TREE_OPERAND (decl, 0);\n+\t      tree rename = NULL_TREE;\n+\n+\t      my_friendly_assert (flags == NO_SPECIAL, 152);\n+\t      flags = DTOR_FLAG;\n+\t      return_type = return_dtor;\n+\t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 153);\n+\t      if (ctype == NULL_TREE)\n+\t\t{\n+\t\t  if (current_class_type == NULL_TREE)\n+\t\t    {\n+\t\t      error (\"destructors must be member functions\");\n+\t\t      flags = NO_SPECIAL;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tree t = constructor_name (current_class_name);\n+\t\t      if (t != name)\n+\t\t\trename = t;\n+\t\t    }\n+\t\t}\n \t      else\n-\t\tdeclarator = TREE_OPERAND (decl, 0);\n-\n-\t      init = TREE_OPERAND (decl, 1);\n-\n-\t      decl = start_decl (declarator, declspecs, 1, NULL_TREE);\n-\t      finish_decl (decl, init, NULL_TREE);\n-\t      return 0;\n-\t    }\n-\t  innermost_code = TREE_CODE (decl);\n-\t  if (decl_context == FIELD && ctype == NULL_TREE)\n-\t    ctype = current_class_type;\n-\t  if (ctype\n-\t      && TREE_OPERAND (decl, 0) == constructor_name_full (ctype))\n-\t    TREE_OPERAND (decl, 0) = constructor_name (ctype);\n-\t  decl = TREE_OPERAND (decl, 0);\n-\t  if (ctype != NULL_TREE\n-\t      && decl != NULL_TREE && flags != DTOR_FLAG\n-\t      && decl == constructor_name (ctype))\n-\t    {\n-\t      return_type = return_ctor;\n-\t      ctor_return_type = ctype;\n-\t    }\n-\t  ctype = NULL_TREE;\n-\t  break;\n-\n-\tcase IDENTIFIER_NODE:\n-\t  dname = decl;\n-\t  decl = NULL_TREE;\n+\t\t{\n+\t\t  tree t = constructor_name (ctype);\n+\t\t  if (t != name)\n+\t\t    rename = t;\n+\t\t}\n \n-\t  if (! IDENTIFIER_OPNAME_P (dname)\n-\t      /* Linux headers use '__op'.  Arrgh.  */\n-\t      || IDENTIFIER_TYPENAME_P (dname) && ! TREE_TYPE (dname))\n-\t    name = IDENTIFIER_POINTER (dname);\n-\t  else\n-\t    {\n-\t      if (IDENTIFIER_TYPENAME_P (dname))\n+\t      if (rename)\n \t\t{\n-\t\t  my_friendly_assert (flags == NO_SPECIAL, 154);\n-\t\t  flags = TYPENAME_FLAG;\n-\t\t  ctor_return_type = TREE_TYPE (dname);\n-\t\t  return_type = return_conversion;\n+\t\t  error (\"destructor `%s' must match class name `%s'\",\n+\t\t\t IDENTIFIER_POINTER (name),\n+\t\t\t IDENTIFIER_POINTER (rename));\n+\t\t  TREE_OPERAND (decl, 0) = rename;\n \t\t}\n-\t      name = operator_name_string (dname);\n+\t      next = &name;\n \t    }\n-\t  break;\n+\t    break;\n \n-\tcase RECORD_TYPE:\n-\tcase UNION_TYPE:\n-\tcase ENUMERAL_TYPE:\n-\t  /* Parse error puts this typespec where\n-\t     a declarator should go.  */\n-\t  error (\"declarator name missing\");\n-\t  dname = TYPE_NAME (decl);\n-\t  if (dname && TREE_CODE (dname) == TYPE_DECL)\n-\t    dname = DECL_NAME (dname);\n-\t  name = dname ? IDENTIFIER_POINTER (dname) : \"<nameless>\";\n-\t  declspecs = temp_tree_cons (NULL_TREE, decl, declspecs);\n-\t  decl = NULL_TREE;\n-\t  break;\n+\t  case ADDR_EXPR:\t/* C++ reference declaration */\n+\t    /* fall through */\n+\t  case ARRAY_REF:\n+\t  case INDIRECT_REF:\n+\t    ctype = NULL_TREE;\n+\t    innermost_code = TREE_CODE (decl);\n+\t    next = &TREE_OPERAND (decl, 0);\n+\t    break;\n \n-\t  /* C++ extension */\n-\tcase SCOPE_REF:\n-\t  {\n-\t    /* Perform error checking, and convert class names to types.\n-\t       We may call grokdeclarator multiple times for the same\n-\t       tree structure, so only do the conversion once.  In this\n-\t       case, we have exactly what we want for `ctype'.  */\n-\t    tree cname = TREE_OPERAND (decl, 0);\n-\t    if (cname == NULL_TREE)\n-\t      ctype = NULL_TREE;\n-\t    /* Can't use IS_AGGR_TYPE because CNAME might not be a type.  */\n-\t    else if (IS_AGGR_TYPE_CODE (TREE_CODE (cname))\n-\t\t     || TREE_CODE (cname) == UNINSTANTIATED_P_TYPE)\n-\t      ctype = cname;\n-\t    else if (! is_aggr_typedef (cname, 1))\n+\t  case CALL_EXPR:\n+\t    if (parmlist_is_exprlist (TREE_OPERAND (decl, 1)))\n \t      {\n-\t\tTREE_OPERAND (decl, 0) = NULL_TREE;\n+\t\t/* This is actually a variable declaration using constructor\n+\t\t   syntax.  We need to call start_decl and cp_finish_decl so we\n+\t\t   can get the variable initialized...  */\n+\n+\t\t*next = TREE_OPERAND (decl, 0);\n+\t\tinit = TREE_OPERAND (decl, 1);\n+\n+\t\tdecl = start_decl (declarator, declspecs, 1, NULL_TREE);\n+\t\tfinish_decl (decl, init, NULL_TREE);\n+\t\treturn 0;\n \t      }\n-\t    /* Must test TREE_OPERAND (decl, 1), in case user gives\n-\t       us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */\n-\t    else if (TREE_OPERAND (decl, 1)\n-\t\t     && TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)\n+\t    innermost_code = TREE_CODE (decl);\n+\t    if (decl_context == FIELD && ctype == NULL_TREE)\n+\t      ctype = current_class_type;\n+\t    if (ctype && TREE_OPERAND (decl, 0) == ctype)\n+\t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n+\t    next = &TREE_OPERAND (decl, 0);\n+\t    decl = *next;\n+\t    if (ctype != NULL_TREE\n+\t\t&& decl != NULL_TREE && flags != DTOR_FLAG\n+\t\t&& decl == constructor_name (ctype))\n \t      {\n-\t\tTREE_OPERAND (decl, 0) = IDENTIFIER_TYPE_VALUE (cname);\n+\t\treturn_type = return_ctor;\n+\t\tctor_return_type = ctype;\n \t      }\n-\t    else if (ctype == NULL_TREE)\n+\t    ctype = NULL_TREE;\n+\t    break;\n+\n+\t  case IDENTIFIER_NODE:\n+\t    dname = decl;\n+\t    next = 0;\n+\n+\t    if (is_rid (dname))\n \t      {\n-\t\tctype = IDENTIFIER_TYPE_VALUE (cname);\n-\t\tTREE_OPERAND (decl, 0) = ctype;\n+\t\tcp_error (\"declarator-id missing; using reserved word `%D'\",\n+\t\t\t  dname);\n+\t\tname = IDENTIFIER_POINTER (dname);\n \t      }\n-\t    else if (TREE_COMPLEXITY (decl) == current_class_depth)\n-\t      TREE_OPERAND (decl, 0) = ctype;\n+\t    if (! IDENTIFIER_OPNAME_P (dname)\n+\t\t/* Linux headers use '__op'.  Arrgh.  */\n+\t\t|| IDENTIFIER_TYPENAME_P (dname) && ! TREE_TYPE (dname))\n+\t      name = IDENTIFIER_POINTER (dname);\n \t    else\n \t      {\n-\t\tif (! UNIQUELY_DERIVED_FROM_P (IDENTIFIER_TYPE_VALUE (cname),\n-\t\t\t\t\t       ctype))\n+\t\tif (IDENTIFIER_TYPENAME_P (dname))\n \t\t  {\n-\t\t    cp_error (\"type `%T' is not derived from type `%T'\",\n-\t\t\t      IDENTIFIER_TYPE_VALUE (cname), ctype);\n-\t\t    TREE_OPERAND (decl, 0) = NULL_TREE;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    ctype = IDENTIFIER_TYPE_VALUE (cname);\n-\t\t    TREE_OPERAND (decl, 0) = ctype;\n+\t\t    my_friendly_assert (flags == NO_SPECIAL, 154);\n+\t\t    flags = TYPENAME_FLAG;\n+\t\t    ctor_return_type = TREE_TYPE (dname);\n+\t\t    return_type = return_conversion;\n \t\t  }\n+\t\tname = operator_name_string (dname);\n \t      }\n+\t    break;\n \n-\t    if (ctype\n-\t\t&& TREE_OPERAND (decl, 1) == constructor_name_full (ctype))\n-\t      TREE_OPERAND (decl, 1) = constructor_name (ctype);\n-\t    decl = TREE_OPERAND (decl, 1);\n-\t    if (ctype)\n+\t    /* C++ extension */\n+\t  case SCOPE_REF:\n+\t    {\n+\t      /* Perform error checking, and decide on a ctype.  */\n+\t      tree cname = TREE_OPERAND (decl, 0);\n+\t      if (cname == NULL_TREE)\n+\t\tctype = NULL_TREE;\n+\t      else if (! is_aggr_type (cname, 1))\n+\t\tTREE_OPERAND (decl, 0) = NULL_TREE;\n+\t      /* Must test TREE_OPERAND (decl, 1), in case user gives\n+\t\t us `typedef (class::memfunc)(int); memfunc *memfuncptr;'  */\n+\t      else if (TREE_OPERAND (decl, 1)\n+\t\t       && TREE_CODE (TREE_OPERAND (decl, 1)) == INDIRECT_REF)\n+\t\tctype = cname;\n+\t      else if (ctype == NULL_TREE)\n+\t\tctype = cname;\n+\t      else if (TREE_COMPLEXITY (decl) == current_class_depth)\n+\t\tTREE_OPERAND (decl, 0) = ctype;\n+\t      else\n+\t\t{\n+\t\t  if (! UNIQUELY_DERIVED_FROM_P (cname, ctype))\n+\t\t    {\n+\t\t      cp_error (\"type `%T' is not derived from type `%T'\",\n+\t\t\t\tcname, ctype);\n+\t\t      TREE_OPERAND (decl, 0) = NULL_TREE;\n+\t\t    }\n+\t\t  else\n+\t\t    ctype = cname;\n+\t\t}\n+\n+\t      if (ctype\n+\t\t  && TREE_OPERAND (decl, 1) == constructor_name_full (ctype))\n+\t\tTREE_OPERAND (decl, 1) = constructor_name (ctype);\n+\t      next = &TREE_OPERAND (decl, 1);\n+\t      decl = *next;\n+\t      if (ctype)\n+\t\t{\n+\t\t  if (TREE_CODE (decl) == IDENTIFIER_NODE\n+\t\t      && constructor_name (ctype) == decl)\n+\t\t    {\n+\t\t      return_type = return_ctor;\n+\t\t      ctor_return_type = ctype;\n+\t\t    }\n+\t\t  else if (TREE_CODE (decl) == BIT_NOT_EXPR\n+\t\t\t   && TREE_CODE (TREE_OPERAND (decl, 0)) == IDENTIFIER_NODE\n+\t\t\t   && (constructor_name (ctype) == TREE_OPERAND (decl, 0)\n+\t\t\t       || constructor_name_full (ctype) == TREE_OPERAND (decl, 0)))\n+\t\t    {\n+\t\t      return_type = return_dtor;\n+\t\t      ctor_return_type = ctype;\n+\t\t      flags = DTOR_FLAG;\n+\t\t      TREE_OPERAND (decl, 0) = constructor_name (ctype);\n+\t\t      next = &TREE_OPERAND (decl, 0);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t    break;\n+\n+\t  case ERROR_MARK:\n+\t    next = 0;\n+\t    break;\n+\n+\t  default:\n+\t    if (TREE_CODE_CLASS (TREE_CODE (decl)) == 't')\n \t      {\n-\t\tif (TREE_CODE (decl) == IDENTIFIER_NODE\n-\t\t    && constructor_name (ctype) == decl)\n-\t\t  {\n-\t\t    return_type = return_ctor;\n-\t\t    ctor_return_type = ctype;\n-\t\t  }\n-\t\telse if (TREE_CODE (decl) == BIT_NOT_EXPR\n-\t\t\t && TREE_CODE (TREE_OPERAND (decl, 0)) == IDENTIFIER_NODE\n-\t\t\t && (constructor_name (ctype) == TREE_OPERAND (decl, 0)\n-\t\t\t     || constructor_name_full (ctype) == TREE_OPERAND (decl, 0)))\n-\t\t  {\n-\t\t    return_type = return_dtor;\n-\t\t    ctor_return_type = ctype;\n-\t\t    flags = DTOR_FLAG;\n-\t\t    decl = TREE_OPERAND (decl, 0) = constructor_name (ctype);\n-\t\t  }\n+\t\t/* Parse error puts this typespec where\n+\t\t   a declarator should go.  */\n+\t\terror (\"typename specified as declarator-id\");\n+\t\tif (current_class_type)\n+\t\t  cp_error (\"  perhaps you want `%T' for a constructor\",\n+\t\t\t    current_class_name);\n+\t\tdname = TYPE_IDENTIFIER (decl);\n+\t\tname = dname ? IDENTIFIER_POINTER (dname) : \"<nameless>\";\n+\t\tdeclspecs = temp_tree_cons (NULL_TREE, integer_type_node,\n+\t\t\t\t\t    declspecs);\n+\t\t*next = dname;\n+\t\tnext = 0;\n+\t\tbreak;\n \t      }\n+\t    cp_compiler_error (\"`%D' as declarator\", decl);\n+\t    return 0; /* We used to do a 155 abort here.  */\n \t  }\n-\t  break;\n-\n-\tcase ERROR_MARK:\n-\t  decl = NULL_TREE;\n-\t  break;\n-\n-\tdefault:\n-\t  return 0; /* We used to do a 155 abort here.  */\n-\t}\n+      }\n     if (name == NULL)\n       name = \"type name\";\n   }\n@@ -10587,7 +10588,13 @@ xref_tag (code_type_node, name, binfo, globalize)\n \n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n-  t = IDENTIFIER_TYPE_VALUE (name);\n+  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+    {\n+      t = name;\n+      name = TYPE_NESTED_NAME (t);\n+    }\n+  else\n+    t = IDENTIFIER_TYPE_VALUE (name);\n   if (t && TREE_CODE (t) != code)\n     t = NULL_TREE;\n \n@@ -10770,17 +10777,17 @@ xref_basetypes (code_type_node, name, ref, binfo)\n     {\n       /* The base of a derived struct is public by default.  */\n       int via_public\n-\t= (TREE_PURPOSE (binfo) == (tree)access_public\n-\t   || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n+\t= (TREE_PURPOSE (binfo) == access_public_node\n+\t   || TREE_PURPOSE (binfo) == access_public_virtual_node\n \t   || (tag_code != class_type\n-\t       && (TREE_PURPOSE (binfo) == (tree)access_default\n-\t\t   || TREE_PURPOSE (binfo) == (tree)access_default_virtual)));\n-      int via_protected = TREE_PURPOSE (binfo) == (tree)access_protected;\n+\t       && (TREE_PURPOSE (binfo) == access_default_node\n+\t\t   || TREE_PURPOSE (binfo) == access_default_virtual_node)));\n+      int via_protected = TREE_PURPOSE (binfo) == access_protected_node;\n       int via_virtual\n-\t= (TREE_PURPOSE (binfo) == (tree)access_private_virtual\n-\t   || TREE_PURPOSE (binfo) == (tree)access_public_virtual\n-\t   || TREE_PURPOSE (binfo) == (tree)access_default_virtual);\n-      tree basetype = TREE_TYPE (TREE_VALUE (binfo));\n+\t= (TREE_PURPOSE (binfo) == access_private_virtual_node\n+\t   || TREE_PURPOSE (binfo) == access_public_virtual_node\n+\t   || TREE_PURPOSE (binfo) == access_default_virtual_node);\n+      tree basetype = TREE_VALUE (binfo);\n       tree base_binfo;\n \n       GNU_xref_hier (IDENTIFIER_POINTER (name),"}, {"sha": "03b8ff9662164a38134fd07c358191d1abd2ad90", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -176,7 +176,7 @@ int warn_traditional;\n /* Nonzero means warn about sizeof(function) or addition/subtraction\n    of function pointers.  */\n \n-int warn_pointer_arith;\n+int warn_pointer_arith = 1;\n \n /* Nonzero means warn for non-prototype function decls\n    or non-prototyped defs without previous prototype.  */\n@@ -2026,7 +2026,9 @@ constructor_name_full (thing)\n {\n   if (TREE_CODE (thing) == UNINSTANTIATED_P_TYPE)\n     return DECL_NAME (UPT_TEMPLATE (thing));\n-  if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n+  else if (TREE_CODE (thing) == TEMPLATE_TYPE_PARM)\n+    thing = TYPE_NAME (thing);\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (thing)))\n     {\n       if (TYPE_WAS_ANONYMOUS (thing) && TYPE_HAS_CONSTRUCTOR (thing))\n \tthing = DECL_NAME (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (thing), 0));"}, {"sha": "09aebdb1af777b0d31d03be1b28594b71f32db96", "filename": "gcc/cp/except.c", "status": "modified", "additions": 67, "deletions": 35, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -155,7 +155,7 @@ exception_section ()\n   if (flag_pic)\n     data_section ();\n   else\n-#if defined(TARGET_POWERPC) /* are we on a __rs6000? */\n+#if defined (TARGET_POWERPC) /* are we on a __rs6000? */\n     data_section ();\n #else\n     readonly_data_section ();\n@@ -1012,6 +1012,10 @@ expand_start_catch_block (declspecs, declarator)\n \t  return;\n \t}\n \n+      /* Make sure we mark the catch param as used, otherwise we'll get\n+\t a warning about an unused ((anonymous)).  */\n+      TREE_USED (decl) = 1;\n+\n       /* Figure out the type that the initializer is. */\n       init_type = TREE_TYPE (decl);\n       if (TREE_CODE (init_type) != REFERENCE_TYPE\n@@ -1167,7 +1171,8 @@ static void\n do_unwind (inner_throw_label)\n      rtx inner_throw_label;\n {\n-#if defined(SPARC_STACK_ALIGN) /* was sparc */\n+#if defined (SPARC_STACK_ALIGN) /* was sparc */\n+  /* This doesn't work for the flat model sparc, I bet.  */\n   tree fcall;\n   tree params;\n   rtx return_val_rtx;\n@@ -1186,7 +1191,7 @@ do_unwind (inner_throw_label)\n   easy_expand_asm (\"restore\");\n   emit_barrier ();\n #endif\n-#if defined(ARM_FRAME_RTX)  /* was __arm */\n+#if defined (ARM_FRAME_RTX)  /* was __arm */\n   if (flag_omit_frame_pointer)\n     sorry (\"this implementation of exception handling requires a frame pointer\");\n \n@@ -1195,7 +1200,7 @@ do_unwind (inner_throw_label)\n   emit_move_insn (hard_frame_pointer_rtx,\n \t\t  gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -12)));\n #endif\n-#if defined(TARGET_88000) /* was m88k */\n+#if defined (TARGET_88000) /* was m88k */\n   rtx temp_frame = frame_pointer_rtx;\n \n   temp_frame = memory_address (Pmode, temp_frame);\n@@ -1218,17 +1223,18 @@ do_unwind (inner_throw_label)\n \t\t\t\t\t\t     (HOST_WIDE_INT)m88k_debugger_offset (arg_pointer_rtx, 0))));\n #endif\n #endif\n-#if !defined(TARGET_88000) && !defined(ARM_FRAME_RTX) && !defined(SPARC_STACK_ALIGN)\n+#if ! defined (TARGET_88000) && ! defined (ARM_FRAME_RTX) && ! defined (SPARC_STACK_ALIGN)\n   tree fcall;\n   tree params;\n   rtx return_val_rtx;\n \n+#if 0\n+  /* I would like to do this here, but the move below doesn't seem to work. */\n   /* call to  __builtin_return_address () */\n   params = tree_cons (NULL_TREE, integer_zero_node, NULL_TREE);\n   fcall = build_function_call (BuiltinReturnAddress, params);\n   return_val_rtx = expand_expr (fcall, NULL_RTX, Pmode, 0);\n-#if 0\n-  /* I would like to do this here, but doesn't seem to work. */\n+\n   emit_move_insn (return_val_rtx, inner_throw_label);\n   /* So, for now, just pass throw label to stack unwinder. */\n #endif\n@@ -1242,6 +1248,48 @@ do_unwind (inner_throw_label)\n }\n \n \n+/* Given the return address, compute the new pc to throw.  This has to\n+   work for the current frame of the current function, and the one\n+   above it in the case of throw.  */\n+rtx\n+eh_outer_context (addr)\n+     rtx addr;\n+{\n+#if defined (ARM_FRAME_RTX)  /* was __arm */\n+  /* On the ARM, '__builtin_return_address',  must have 4\n+     subtracted from it. */\n+  emit_insn (gen_add2_insn (addr, GEN_INT (-4)));\n+\n+  /* If we are generating code for an ARM2/ARM3 machine or for an ARM6\n+     in 26 bit mode, the condition codes must be masked out of the\n+     return value, or else they will confuse BuiltinReturnAddress.\n+     This does not apply to ARM6 and later processors when running in\n+     32 bit mode. */\n+  if (!TARGET_6)\n+    emit_insn (gen_rtx (SET, Pmode,\n+\t\t\taddr,\n+\t\t\tgen_rtx (AND, Pmode,\n+\t\t\t\t addr, GEN_INT (0x03fffffc))));\n+#else\n+#if ! defined (SPARC_STACK_ALIGN) /* was sparc */\n+#if defined (TARGET_SNAKE)\n+  /* On HPPA, the low order two bits hold the priviledge level, so we\n+     must get rid of them.  */\n+  emit_insn (gen_rtx (SET, Pmode,\n+\t\t      addr,\n+\t\t      gen_rtx (AND, Pmode,\n+\t\t\t       addr, GEN_INT (0xfffffffc))));\n+#endif\n+\n+  /* On the SPARC, __builtin_return_address is already -8 or -12, no\n+     need to subtract any more from it. */\n+  addr = plus_constant (addr, -1);\n+#endif\n+#endif\n+\n+  return addr;\n+}\n+\n /* is called from expand_exception_blocks () to generate the code in a function\n    to \"throw\" if anything in the function needs to perform a throw.\n \n@@ -1320,8 +1368,9 @@ expand_builtin_throw ()\n   emit_label (gotta_rethrow_it);\n \n   /* call to  __builtin_return_address () */\n-#if defined(ARM_FRAME_RTX)  /* was __arm */\n-/* This replaces a 'call' to __builtin_return_address */\n+#if defined (ARM_FRAME_RTX)  /* was __arm */\n+  /* This should be moved into arm.h:RETURN_ADDR_RTX */\n+  /* This replaces a 'call' to __builtin_return_address */\n   return_val_rtx = gen_reg_rtx (Pmode);\n   emit_move_insn (return_val_rtx, gen_rtx (MEM, Pmode, plus_constant (hard_frame_pointer_rtx, -4)));\n #else\n@@ -1336,28 +1385,10 @@ expand_builtin_throw ()\n \n   emit_jump_insn (gen_beq (gotta_call_terminate));\n \n-#if defined(ARM_FRAME_RTX)  /* was __arm */\n-  /* On the ARM, '__builtin_return_address',  must have 4\n-     subtracted from it. */\n-  emit_insn (gen_add2_insn (return_val_rtx, GEN_INT (-4)));\n+  return_val_rtx = eh_outer_context (return_val_rtx);\n \n-  /* If we are generating code for an ARM2/ARM3 machine or for an ARM6 in 26 bit\n-     mode, the condition codes must be masked out of the return value, or else\n-     they will confuse BuiltinReturnAddress.  This does not apply to ARM6 and\n-     later processors when running in 32 bit mode. */\n-  if (!TARGET_6)\n-    emit_insn (gen_rtx (SET, Pmode, return_val_rtx, gen_rtx (AND, Pmode, return_val_rtx, GEN_INT (0x03fffffc))));\n-#else\n-#if !defined(SPARC_STACK_ALIGN) /* was sparc */\n-  /* On the SPARC, __builtin_return_address is already -8, no need to\n-     subtract any more from it. */\n-  return_val_rtx = plus_constant (return_val_rtx, -1);\n-#endif\n-#endif\n-\n-  /* yes it did */\n-  t = build_modify_expr (saved_pc, NOP_EXPR, make_tree (ptr_type_node, return_val_rtx));\n-  expand_expr (t, const0_rtx, VOIDmode, 0);\n+  /* Yes it did.  */\n+  emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);\n \n   do_unwind (gen_rtx (LABEL_REF, Pmode, top_of_loop));\n   emit_jump (top_of_loop);\n@@ -1700,6 +1731,9 @@ expand_throw (exp)\n \t    }\n \t}\n \n+      if (cleanup == empty_fndecl)\n+\tassemble_external (empty_fndecl);\n+\t\n       e = build_modify_expr (saved_throw_type, NOP_EXPR, throw_type);\n       expand_expr (e, const0_rtx, VOIDmode, 0);\n \n@@ -1823,11 +1857,9 @@ end_eh_unwinder (end)\n   ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n \t\t\t\t\t0, hard_frame_pointer_rtx);\n   return_val_rtx = copy_to_reg (ret_val);\n-#ifdef RETURN_ADDR_OFFSET\n-  return_val_rtx = plus_constant (return_val_rtx, RETURN_ADDR_OFFSET-1);\n-#else\n-  return_val_rtx = plus_constant (return_val_rtx, -1);\n-#endif\n+\n+  return_val_rtx = eh_outer_context (return_val_rtx);\n+\n   emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);\n   \n #ifdef JUMP_TO_THROW"}, {"sha": "36c25205669480b2cbf8676a6c962f3e18df9a53", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1217,24 +1217,25 @@ The below points out some things that work in g++'s exception handling.\n All completely constructed temps and local variables are cleaned up in\n all unwinded scopes.  Completely constructed parts of partially\n constructed objects are cleaned up.  This includes partially built\n-arrays.  Exception specifications are now handled.\n+arrays.  Exception specifications are now handled.  Thrown objects are\n+now cleaned up all the time.\n \n The below points out some flaws in g++'s exception handling, as it now\n stands.\n \n Only exact type matching or reference matching of throw types works when\n--fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm and\n-rs6000 machines.  Partial support is in for all other machines, but a\n-stack unwinder called __unwind_function has to be written, and added to\n-libgcc2 for them.  See below for details on __unwind_function.  Don't\n-expect exception handling to work right if you optimize, in fact the\n-compiler will probably core dump.  RTL_EXPRs for EH cond variables for\n-&& and || exprs should probably be wrapped in UNSAVE_EXPRs, and\n-RTL_EXPRs tweaked so that they can be unsaved, and the UNSAVE_EXPR code\n-should be in the backend, or alternatively, UNSAVE_EXPR should be ripped\n-out and exactly one finalization allowed to be expanded by the backend.\n-I talked with kenner about this, and we have to allow multiple\n-expansions.\n+-fno-rtti is used.  Only works on a SPARC (like Suns), i386, arm,\n+rs6000, Alpha and mips machines.  Partial support is in for all other\n+machines, but a stack unwinder called __unwind_function has to be\n+written, and added to libgcc2 for them.  See below for details on\n+__unwind_function.  Don't expect exception handling to work right if you\n+optimize, in fact the compiler will probably core dump.  RTL_EXPRs for\n+EH cond variables for && and || exprs should probably be wrapped in\n+UNSAVE_EXPRs, and RTL_EXPRs tweaked so that they can be unsaved, and the\n+UNSAVE_EXPR code should be in the backend, or alternatively, UNSAVE_EXPR\n+should be ripped out and exactly one finalization allowed to be expanded\n+by the backend.  I talked with kenner about this, and we have to allow\n+multiple expansions.\n \n We only do pointer conversions on exception matching a la 15.3 p2 case\n 3: `A handler with type T, const T, T&, or const T& is a match for a\n@@ -1266,12 +1267,13 @@ build_exception_variant should sort the incoming list, so that it\n implements set compares, not exact list equality.  Type smashing should\n smash exception specifications using set union.\n \n-Thrown objects are usually allocated on the heap, in the usual way, but\n-they are never deleted.  They should be deleted by the catch clauses.\n-If one runs out of heap space, throwing an object will probably never\n-work.  This could be relaxed some by passing an __in_chrg parameter to\n-track who has control over the exception object.  Thrown objects are not\n-allocated on the heap when they are pointer to object types.\n+Thrown objects are usually allocated on the heap, in the usual way.  If\n+one runs out of heap space, throwing an object will probably never work.\n+This could be relaxed some by passing an __in_chrg parameter to track\n+who has control over the exception object.  Thrown objects are not\n+allocated on the heap when they are pointer to object types.  We should\n+extend it so that all small (<4*sizeof(void*)) objects are stored\n+directly, instead of allocated on the heap.\n \n When the backend returns a value, it can create new exception regions\n that need protecting.  The new region should rethrow the object in"}, {"sha": "e114414b55e9e02e9704db7c0dc2abe403d73301", "filename": "gcc/cp/init.c", "status": "modified", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -371,10 +371,10 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n   last = tree_cons (NULL_TREE, NULL_TREE, current_base_init_list);\n   for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n     {\n-      tree basename = TREE_PURPOSE (x);\n+      tree basetype = TREE_PURPOSE (x);\n       tree binfo;\n \n-      if (basename == NULL_TREE)\n+      if (basetype == NULL_TREE)\n \t{\n \t  /* Initializer for single base class.  Must not\n \t     use multiple inheritance or this is ambiguous.  */\n@@ -393,9 +393,9 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t    }\n \t  binfo = TREE_VEC_ELT (binfos, 0);\n \t}\n-      else if (is_aggr_typedef (basename, 1))\n+      else if (is_aggr_type (basetype, 1))\n \t{\n-\t  binfo = binfo_or_else (IDENTIFIER_TYPE_VALUE (basename), t);\n+\t  binfo = binfo_or_else (basetype, t);\n \t  if (binfo == NULL_TREE)\n \t    continue;\n \n@@ -420,8 +420,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t      if (i < 0)\n \t\t{\n \t\t  cp_error (\"`%T' is not an immediate base class of `%T'\",\n-\t\t\t    IDENTIFIER_TYPE_VALUE (basename),\n-\t\t\t    current_class_type);\n+\t\t\t    basetype, current_class_type);\n \t\t  continue;\n \t\t}\n \t    }\n@@ -931,6 +930,12 @@ expand_member_init (exp, name, init)\n \n   type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n \n+  if (TREE_CODE_CLASS (TREE_CODE (name)) == 't')\n+    {\n+      basetype = name;\n+      name = TYPE_IDENTIFIER (name);\n+    }\n+\n   if (name == NULL_TREE && IS_AGGR_TYPE (type))\n     switch (CLASSTYPE_N_BASECLASSES (type))\n       {\n@@ -958,7 +963,7 @@ expand_member_init (exp, name, init)\n       if (init == void_type_node)\n \tinit = NULL_TREE;\n \n-      if (name == NULL_TREE || IDENTIFIER_HAS_TYPE_VALUE (name))\n+      if (name == NULL_TREE || basetype)\n \t{\n \t  tree base_init;\n \n@@ -976,40 +981,35 @@ expand_member_init (exp, name, init)\n \t    }\n \t  else\n \t    {\n-\t      basetype = IDENTIFIER_TYPE_VALUE (name);\n \t      if (basetype != type\n \t\t  && ! binfo_member (basetype, TYPE_BINFO (type))\n \t\t  && ! binfo_member (basetype, CLASSTYPE_VBASECLASSES (type)))\n \t\t{\n \t\t  if (IDENTIFIER_CLASS_VALUE (name))\n \t\t    goto try_member;\n \t\t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t\t    error (\"type `%s' is not an immediate or virtual basetype for `%s'\",\n-\t\t\t   IDENTIFIER_POINTER (name),\n-\t\t\t   TYPE_NAME_STRING (type));\n+\t\t    cp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n+\t\t\t      basetype, type);\n \t\t  else\n-\t\t    error (\"type `%s' is not an immediate basetype for `%s'\",\n-\t\t\t   IDENTIFIER_POINTER (name),\n-\t\t\t   TYPE_NAME_STRING (type));\n+\t\t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n+\t\t\t      basetype, type);\n \t\t  return;\n \t\t}\n \t    }\n \n-\t  if (purpose_member (name, current_base_init_list))\n+\t  if (purpose_member (basetype, current_base_init_list))\n \t    {\n-\t      error (\"base class `%s' already initialized\",\n-\t\t     IDENTIFIER_POINTER (name));\n+\t      cp_error (\"base class `%T' already initialized\", basetype);\n \t      return;\n \t    }\n \n \t  if (warn_reorder && current_member_init_list)\n \t    {\n-\t      warning (\"base initializer for `%s'\", IDENTIFIER_POINTER (name));\n+\t      cp_warning (\"base initializer for `%T'\", basetype);\n \t      warning (\"   will be re-ordered to precede member initializations\");\n \t    }\n \n-\t  base_init = build_tree_list (name, init);\n-\t  TREE_TYPE (base_init) = basetype;\n+\t  base_init = build_tree_list (basetype, init);\n \t  current_base_init_list = chainon (current_base_init_list, base_init);\n \t}\n       else\n@@ -1024,12 +1024,11 @@ expand_member_init (exp, name, init)\n \n \t  if (purpose_member (name, current_member_init_list))\n \t    {\n-\t      error (\"field `%s' already initialized\", IDENTIFIER_POINTER (name));\n+\t      cp_error (\"field `%D' already initialized\", field);\n \t      return;\n \t    }\n \n \t  member_init = build_tree_list (name, init);\n-\t  TREE_TYPE (member_init) = TREE_TYPE (field);\n \t  current_member_init_list = chainon (current_member_init_list, member_init);\n \t}\n       return;\n@@ -1741,6 +1740,26 @@ is_aggr_typedef (name, or_else)\n   return 1;\n }\n \n+/* Report an error if TYPE is not a user-defined, aggregate type.  If\n+   OR_ELSE is nonzero, give an error message.  */\n+int\n+is_aggr_type (type, or_else)\n+     tree type;\n+     int or_else;\n+{\n+  if (type == error_mark_node)\n+    return 0;\n+\n+  if (! IS_AGGR_TYPE (type)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n+    {\n+      if (or_else)\n+\tcp_error (\"`%T' is not an aggregate type\", type);\n+      return 0;\n+    }\n+  return 1;\n+}\n+\n /* Like is_aggr_typedef, but returns typedef if successful.  */\n tree\n get_aggr_from_typedef (name, or_else)\n@@ -1788,13 +1807,13 @@ get_type_value (name)\n /* This code could just as well go in `class.c', but is placed here for\n    modularity.  */\n \n-/* For an expression of the form CNAME :: NAME (PARMLIST), build\n+/* For an expression of the form TYPE :: NAME (PARMLIST), build\n    the appropriate function call.  */\n tree\n-build_member_call (cname, name, parmlist)\n-     tree cname, name, parmlist;\n+build_member_call (type, name, parmlist)\n+     tree type, name, parmlist;\n {\n-  tree type, t;\n+  tree t;\n   tree method_name = name;\n   int dtor = 0;\n   int dont_use_this = 0;\n@@ -1806,22 +1825,19 @@ build_member_call (cname, name, parmlist)\n       dtor = 1;\n     }\n \n-  if (TREE_CODE (cname) == SCOPE_REF)\n-    cname = resolve_scope_to_name (NULL_TREE, cname);\n-\n   /* This shouldn't be here, and build_member_call shouldn't appear in\n      parse.y!  (mrs)  */\n-  if (cname && get_aggr_from_typedef (cname, 0) == 0\n-      && TREE_CODE (cname) == IDENTIFIER_NODE)\n+  if (type && TREE_CODE (type) == IDENTIFIER_NODE\n+      && get_aggr_from_typedef (type, 0) == 0)\n     {\n-      tree ns = lookup_name (cname, 0);\n+      tree ns = lookup_name (type, 0);\n       if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n \t{\n-\t  return build_x_function_call (build_offset_ref (cname, name), parmlist, current_class_decl);\n+\t  return build_x_function_call (build_offset_ref (type, name), parmlist, current_class_decl);\n \t}\n     }\n \n-  if (cname == NULL_TREE || ! (type = get_aggr_from_typedef (cname, 1)))\n+  if (type == NULL_TREE || ! is_aggr_type (type, 1))\n     return error_mark_node;\n \n   /* An operator we did not like.  */\n@@ -1914,29 +1930,26 @@ build_member_call (cname, name, parmlist)\n \n /* Build a reference to a member of an aggregate.  This is not a\n    C++ `&', but really something which can have its address taken,\n-   and then act as a pointer to member, for example CNAME :: FIELD\n-   can have its address taken by saying & CNAME :: FIELD.\n+   and then act as a pointer to member, for example TYPE :: FIELD\n+   can have its address taken by saying & TYPE :: FIELD.\n \n    @@ Prints out lousy diagnostics for operator <typename>\n    @@ fields.\n \n    @@ This function should be rewritten and placed in search.c.  */\n tree\n-build_offset_ref (cname, name)\n-     tree cname, name;\n+build_offset_ref (type, name)\n+     tree type, name;\n {\n-  tree decl, type, fnfields, fields, t = error_mark_node;\n+  tree decl, fnfields, fields, t = error_mark_node;\n   tree basetypes = NULL_TREE;\n   int dtor = 0;\n \n-  if (TREE_CODE (cname) == SCOPE_REF)\n-    cname = resolve_scope_to_name (NULL_TREE, cname);\n-\n   /* Handle namespace names fully here.  */\n-  if (TREE_CODE (cname) == IDENTIFIER_NODE\n-      && get_aggr_from_typedef (cname, 0) == 0)\n+  if (TREE_CODE (type) == IDENTIFIER_NODE\n+      && get_aggr_from_typedef (type, 0) == 0)\n     {\n-      tree ns = lookup_name (cname, 0);\n+      tree ns = lookup_name (type, 0);\n       tree val;\n       if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n \t{\n@@ -1948,17 +1961,18 @@ build_offset_ref (cname, name)\n \t}\n     }\n \n-  if (cname == NULL_TREE || ! is_aggr_typedef (cname, 1))\n+  if (type == NULL_TREE || ! is_aggr_type (type, 1))\n     return error_mark_node;\n \n-  type = IDENTIFIER_TYPE_VALUE (cname);\n-\n   if (TREE_CODE (name) == BIT_NOT_EXPR)\n     {\n       dtor = 1;\n       name = TREE_OPERAND (name, 0);\n     }\n \n+  if (name == constructor_name_full (type))\n+    name = constructor_name (type);\n+\n   if (TYPE_SIZE (type) == 0)\n     {\n       t = IDENTIFIER_CLASS_VALUE (name);\n@@ -1983,24 +1997,14 @@ build_offset_ref (cname, name)\n       return error_mark_node;\n     }\n \n-#if 0\n-  if (TREE_CODE (name) == TYPE_EXPR)\n-    /* Pass a TYPE_DECL to build_component_type_expr.  */\n-    return build_component_type_expr (TYPE_NAME (TREE_TYPE (cname)),\n-\t\t\t\t      name, NULL_TREE, 1);\n-#endif\n-\n   if (current_class_type == 0\n       || get_base_distance (type, current_class_type, 0, &basetypes) == -1)\n     {\n       basetypes = TYPE_BINFO (type);\n-      decl = build1 (NOP_EXPR,\n-\t\t     IDENTIFIER_TYPE_VALUE (cname),\n-\t\t     error_mark_node);\n+      decl = build1 (NOP_EXPR, type, error_mark_node);\n     }\n   else if (current_class_decl == 0)\n-    decl = build1 (NOP_EXPR, IDENTIFIER_TYPE_VALUE (cname),\n-\t\t   error_mark_node);\n+    decl = build1 (NOP_EXPR, type, error_mark_node);\n   else\n     decl = C_C_D;\n \n@@ -2044,18 +2048,18 @@ build_offset_ref (cname, name)\n \n \t  if (DECL_CHAIN (t) == NULL_TREE || dtor)\n \t    {\n-\t      enum access_type access;\n+\t      tree access;\n \n \t      /* unique functions are handled easily.  */\n \t    unique:\n \t      access = compute_access (basetypes, t);\n-\t      if (access == access_protected)\n+\t      if (access == access_protected_node)\n \t\t{\n \t\t  cp_error_at (\"member function `%#D' is protected\", t);\n \t\t  error (\"in this context\");\n \t\t  return error_mark_node;\n \t\t}\n-\t      if (access == access_private)\n+\t      if (access == access_private_node)\n \t\t{\n \t\t  cp_error_at (\"member function `%#D' is private\", t);\n \t\t  error (\"in this context\");\n@@ -2066,7 +2070,7 @@ build_offset_ref (cname, name)\n \t    }\n \n \t  /* overloaded functions may need more work.  */\n-\t  if (cname == name)\n+\t  if (name == constructor_name (type))\n \t    {\n \t      if (TYPE_HAS_DESTRUCTOR (type)\n \t\t  && DECL_CHAIN (DECL_CHAIN (t)) == NULL_TREE)\n@@ -2134,11 +2138,13 @@ build_offset_ref (cname, name)\n     }\n \n   /* static class functions too.  */\n-  if (TREE_CODE (t) == FUNCTION_DECL && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+  if (TREE_CODE (t) == FUNCTION_DECL\n+      && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n     my_friendly_abort (53);\n \n-  /* In member functions, the form `cname::name' is no longer\n-     equivalent to `this->cname::name'.  */\n+  /* In member functions, the form `type::name' is no longer\n+     equivalent to `this->type::name', at least not until\n+     resolve_offset_ref.  */\n   return build (OFFSET_REF, build_offset_type (type, TREE_TYPE (t)), decl, t);\n }\n \n@@ -2271,8 +2277,7 @@ resolve_offset_ref (exp)\n \t  || (TREE_CODE (base) == NOP_EXPR\n \t      && TREE_OPERAND (base, 0) == error_mark_node)))\n     {\n-      tree basetype_path;\n-      enum access_type access;\n+      tree basetype_path, access;\n \n       if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n \tbasetype = TYPE_OFFSET_BASETYPE (type);\n@@ -2288,16 +2293,16 @@ resolve_offset_ref (exp)\n \t}\n       addr = convert_pointer_to (basetype, base);\n       access = compute_access (basetype_path, member);\n-      if (access == access_public)\n+      if (access == access_public_node)\n \treturn build (COMPONENT_REF, TREE_TYPE (member),\n \t\t      build_indirect_ref (addr, NULL_PTR), member);\n-      if (access == access_protected)\n+      if (access == access_protected_node)\n \t{\n \t  cp_error_at (\"member `%D' is protected\", member);\n \t  error (\"in this context\");\n \t  return error_mark_node;\n \t}\n-      if (access == access_private)\n+      if (access == access_private_node)\n \t{\n \t  cp_error_at (\"member `%D' is private\", member);\n \t  error (\"in this context\");\n@@ -3928,15 +3933,15 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \n       if (flags & LOOKUP_PROTECT)\n \t{\n-\t  enum access_type access = compute_access (basetypes, dtor);\n+\t  tree access = compute_access (basetypes, dtor);\n \n-\t  if (access == access_private)\n+\t  if (access == access_private_node)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n \t\tcp_error (\"destructor for type `%T' is private in this scope\", type);\n \t      return error_mark_node;\n \t    }\n-\t  else if (access == access_protected)\n+\t  else if (access == access_protected_node)\n \t    {\n \t      if (flags & LOOKUP_COMPLAIN)\n \t\tcp_error (\"destructor for type `%T' is protected in this scope\", type);"}, {"sha": "abab8fba7c150914532cfb667c48ba16b6254dd1", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -3018,9 +3018,8 @@ do_identifier (token)\n       if (IDENTIFIER_CLASS_VALUE (token) == id)\n \t{\n \t  /* Check access.  */\n-\t  enum access_type access\n-\t    = compute_access (TYPE_BINFO (current_class_type), id);\n-\t  if (access == access_private)\n+\t  tree access = compute_access (TYPE_BINFO (current_class_type), id);\n+\t  if (access == access_private_node)\n \t    cp_error (\"enum `%D' is private\", id);\n \t  /* protected is OK, since it's an enum of `this'.  */\n \t}\n@@ -3279,13 +3278,13 @@ real_yylex ()\n \t\t      switch (ptr->rid)\n \t\t\t{\n \t\t\tcase RID_PUBLIC:\n-\t\t\t  yylval.itype = access_public;\n+\t\t\t  yylval.ttype = access_public_node;\n \t\t\t  break;\n \t\t\tcase RID_PRIVATE:\n-\t\t\t  yylval.itype = access_private;\n+\t\t\t  yylval.ttype = access_private_node;\n \t\t\t  break;\n \t\t\tcase RID_PROTECTED:\n-\t\t\t  yylval.itype = access_protected;\n+\t\t\t  yylval.ttype = access_protected_node;\n \t\t\t  break;\n \t\t\tdefault:\n \t\t\t  my_friendly_abort (63);\n@@ -4394,6 +4393,13 @@ real_yylex ()\n   return value;\n }\n \n+int\n+is_rid (t)\n+     tree t;\n+{\n+  return !!is_reserved_word (IDENTIFIER_POINTER (t), IDENTIFIER_LENGTH (t));\n+}\n+\n typedef enum\n {\n   d_kind, t_kind, s_kind, r_kind, e_kind, c_kind,"}, {"sha": "7e415364fb948b9590f6ca821d69bf5fa1a7088e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1582,8 +1582,7 @@ hack_identifier (value, name, yychar)\n       if (DECL_LANG_SPECIFIC (value)\n \t  && DECL_CLASS_CONTEXT (value) != current_class_type)\n \t{\n-\t  tree path;\n-\t  enum access_type access;\n+\t  tree path, access;\n \t  register tree context\n \t    = (TREE_CODE (value) == FUNCTION_DECL && DECL_VIRTUAL_P (value))\n \t      ? DECL_CLASS_CONTEXT (value)\n@@ -1593,7 +1592,7 @@ hack_identifier (value, name, yychar)\n \t  if (path)\n \t    {\n \t      access = compute_access (path, value);\n-\t      if (access != access_public)\n+\t      if (access != access_public_node)\n \t\t{\n \t\t  if (TREE_CODE (value) == VAR_DECL)\n \t\t    error (\"static member `%s' is %s\",\n@@ -2101,7 +2100,7 @@ do_build_copy_constructor (fndecl)\n \t    (build_reference_type (basetype), parm,\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n-\t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n+\t  current_base_init_list = tree_cons (basetype,\n \t\t\t\t\t      p, current_base_init_list);\n \t}\n \t\n@@ -2116,7 +2115,7 @@ do_build_copy_constructor (fndecl)\n \t    (build_reference_type (basetype), parm,\n \t     CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t  p = convert_from_reference (p);\n-\t  current_base_init_list = tree_cons (TYPE_NESTED_NAME (basetype),\n+\t  current_base_init_list = tree_cons (basetype,\n \t\t\t\t\t      p, current_base_init_list);\n \t}\n       for (; fields; fields = TREE_CHAIN (fields))\n@@ -2192,8 +2191,7 @@ do_build_assign_ref (fndecl)\n \t\t(build_reference_type (basetype), parm,\n \t\t CONV_IMPLICIT|CONV_CONST, LOOKUP_COMPLAIN, NULL_TREE);\n \t      p = convert_from_reference (p);\n-\t      p = build_member_call (TYPE_NESTED_NAME (basetype),\n-\t\t\t\t     ansi_opname [MODIFY_EXPR],\n+\t      p = build_member_call (basetype, ansi_opname [MODIFY_EXPR],\n \t\t\t\t     build_tree_list (NULL_TREE, p));\n \t      expand_expr_stmt (p);\n \t    }"}, {"sha": "e3c2607ef11c018dfdab12c36df007bde0da1f1b", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 46, "deletions": 53, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -140,7 +140,7 @@ empty_parms ()\n \n /* the reserved words... C++ extensions */\n %token <ttype> AGGR\n-%token <itype> VISSPEC\n+%token <ttype> VISSPEC\n %token DELETE NEW OVERLOAD THIS OPERATOR CXX_TRUE CXX_FALSE\n %token NAMESPACE TYPENAME_KEYWORD USING\n %token LEFT_RIGHT TEMPLATE\n@@ -236,7 +236,7 @@ empty_parms ()\n %type <ttype> named_complex_class_head_sans_basetype\n %type <ttype> unnamed_class_head\n %type <ttype> class_head base_class_list\n-%type <itype> base_class_access_list\n+%type <ttype> base_class_access_list\n %type <ttype> base_class maybe_base_class_list base_class.1\n %type <ttype> exception_specification_opt ansi_raise_identifier ansi_raise_identifiers\n %type <ttype> operator_name\n@@ -779,13 +779,13 @@ member_init: '(' nonnull_exprlist ')'\n \t\t  expand_member_init (C_C_D, NULL_TREE, void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (C_C_D, $<ttype>$, $3); }\n+\t\t{ expand_member_init (C_C_D, $1, $3); }\n \t| notype_identifier LEFT_RIGHT\n-\t\t{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }\n+\t\t{ expand_member_init (C_C_D, $1, void_type_node); }\n \t| complete_type_name '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (C_C_D, $<ttype>$, $3); }\n+\t\t{ expand_member_init (C_C_D, $1, $3); }\n \t| complete_type_name LEFT_RIGHT\n-\t\t{ expand_member_init (C_C_D, $<ttype>$, void_type_node); }\n+\t\t{ expand_member_init (C_C_D, $1, void_type_node); }\n \t/* GNU extension */\n \t| notype_qualified_id '(' nonnull_exprlist ')'\n \t\t{\n@@ -1589,7 +1589,7 @@ primary:\n \t| object overqualified_id '(' nonnull_exprlist ')'\n \t\t{\n \t\t  got_object = NULL_TREE;\n-\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n+\t\t  if (IS_SIGNATURE (OP0 ($2)))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n \t\t      $$ = build_method_call ($$, OP1 ($2), $4, NULL_TREE,\n@@ -1601,7 +1601,7 @@ primary:\n \t| object overqualified_id LEFT_RIGHT\n \t\t{\n \t\t  got_object = NULL_TREE;\n-\t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n+\t\t  if (IS_SIGNATURE (OP0 ($2)))\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n \t\t      $$ = build_method_call ($$, OP1 ($2), NULL_TREE, NULL_TREE,\n@@ -2349,9 +2349,8 @@ base_class_list:\n base_class:\n \t  base_class.1\n \t\t{\n-\t\t  tree type;\n-\t\t  type = IDENTIFIER_TYPE_VALUE ($$);\n-\t\t  if (! is_aggr_typedef ($$, 1))\n+\t\t  tree type = $1;\n+\t\t  if (! is_aggr_type (type, 1))\n \t\t    $$ = NULL_TREE;\n \t\t  else if (current_aggr == signature_type_node\n \t\t\t   && (! type) && (! IS_SIGNATURE (type)))\n@@ -2363,23 +2362,22 @@ base_class:\n \t\t    {\n \t\t      sorry (\"signature inheritance, base type `%s' ignored\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t      $$ = build_tree_list ((tree)access_public, $$);\n+\t\t      $$ = build_tree_list (access_public_node, $$);\n \t\t    }\n \t\t  else if (type && IS_SIGNATURE (type))\n \t\t    {\n \t\t      error (\"signature name not allowed as base class\");\n \t\t      $$ = NULL_TREE;\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_tree_list ((tree)access_default, $$);\n+\t\t    $$ = build_tree_list (access_default_node, $$);\n \t\t}\n \t| base_class_access_list see_typename base_class.1\n \t\t{\n-\t\t  tree type;\n-\t\t  type = IDENTIFIER_TYPE_VALUE ($3);\n+\t\t  tree type = $3;\n \t\t  if (current_aggr == signature_type_node)\n \t\t    error (\"access and source specifiers not allowed in signature\");\n-\t\t  if (! is_aggr_typedef ($3, 1))\n+\t\t  if (! IS_AGGR_TYPE (type))\n \t\t    $$ = NULL_TREE;\n \t\t  else if (current_aggr == signature_type_node\n \t\t\t   && (! type) && (! IS_SIGNATURE (type)))\n@@ -2391,15 +2389,15 @@ base_class:\n \t\t    {\n \t\t      sorry (\"signature inheritance, base type `%s' ignored\",\n \t\t\t     IDENTIFIER_POINTER ($$));\n-\t\t      $$ = build_tree_list ((tree)access_public, $3);\n+\t\t      $$ = build_tree_list (access_public_node, $3);\n \t\t    }\n \t\t  else if (type && IS_SIGNATURE (type))\n \t\t    {\n \t\t      error (\"signature name not allowed as base class\");\n \t\t      $$ = NULL_TREE;\n \t\t    }\n \t\t  else\n-\t\t    $$ = build_tree_list ((tree) $$, $3);\n+\t\t    $$ = build_tree_list ($$, $3);\n \t\t}\n \t;\n \n@@ -2412,8 +2410,7 @@ base_class.1:\n \t\t      if (IS_AGGR_TYPE (TREE_TYPE ($3)))\n \t\t\t{\n \t\t\t  sorry (\"`sigof' as base signature specifier\");\n-\t\t\t  /* need to return some dummy signature identifier */\n-\t\t\t  $$ = $3;\n+\t\t\t  $$ = TREE_TYPE ($3);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -2434,8 +2431,7 @@ base_class.1:\n \t\t      if (IS_AGGR_TYPE (groktypename ($3)))\n \t\t\t{\n \t\t\t  sorry (\"`sigof' as base signature specifier\");\n-\t\t\t  /* need to return some dummy signature identifier */\n-\t\t\t  $$ = $3;\n+\t\t\t  $$ = groktypename ($3);\n \t\t\t}\n \t\t      else\n \t\t\t{\n@@ -2456,40 +2452,40 @@ base_class_access_list:\n \t| SCSPEC see_typename\n \t\t{ if ($<ttype>$ != ridpointers[(int)RID_VIRTUAL])\n \t\t    sorry (\"non-virtual access\");\n-\t\t  $$ = access_default_virtual; }\n+\t\t  $$ = access_default_virtual_node; }\n \t| base_class_access_list VISSPEC see_typename\n \t\t{ int err = 0;\n-\t\t  if ($2 == access_protected)\n+\t\t  if ($2 == access_protected_node)\n \t\t    {\n \t\t      warning (\"`protected' access not implemented\");\n-\t\t      $2 = access_public;\n+\t\t      $2 = access_public_node;\n \t\t      err++;\n \t\t    }\n-\t\t  else if ($2 == access_public)\n+\t\t  else if ($2 == access_public_node)\n \t\t    {\n-\t\t      if ($1 == access_private)\n+\t\t      if ($1 == access_private_node)\n \t\t\t{\n \t\t\tmixed:\n \t\t\t  error (\"base class cannot be public and private\");\n \t\t\t}\n-\t\t      else if ($1 == access_default_virtual)\n-\t\t\t$$ = access_public_virtual;\n+\t\t      else if ($1 == access_default_virtual_node)\n+\t\t\t$$ = access_public_virtual_node;\n \t\t    }\n-\t\t  else /* $2 == access_private */\n+\t\t  else /* $2 == access_private_node */\n \t\t    {\n-\t\t      if ($1 == access_public)\n+\t\t      if ($1 == access_public_node)\n \t\t\tgoto mixed;\n-\t\t      else if ($1 == access_default_virtual)\n-\t\t\t$$ = access_private_virtual;\n+\t\t      else if ($1 == access_default_virtual_node)\n+\t\t\t$$ = access_private_virtual_node;\n \t\t    }\n \t\t}\n \t| base_class_access_list SCSPEC see_typename\n \t\t{ if ($2 != ridpointers[(int)RID_VIRTUAL])\n \t\t    sorry (\"non-virtual access\");\n-\t\t  if ($$ == access_public)\n-\t\t    $$ = access_public_virtual;\n-\t\t  else if ($$ == access_private)\n-\t\t    $$ = access_private_virtual; }\n+\t\t  if ($$ == access_public_node)\n+\t\t    $$ = access_public_virtual_node;\n+\t\t  else if ($$ == access_private_node)\n+\t\t    $$ = access_private_virtual_node; }\n \t;\n \n left_curly: '{'\n@@ -2564,18 +2560,18 @@ opt.component_decl_list:\n \t| component_decl_list\n \t\t{\n \t\t  if (current_aggr == signature_type_node)\n-\t\t    $$ = build_tree_list ((tree) access_public, $$);\n+\t\t    $$ = build_tree_list (access_public_node, $$);\n \t\t  else\n-\t\t    $$ = build_tree_list ((tree) access_default, $$);\n+\t\t    $$ = build_tree_list (access_default_node, $$);\n \t\t}\n \t| opt.component_decl_list VISSPEC ':' component_decl_list\n \t\t{\n-\t\t  tree visspec = (tree) $2;\n+\t\t  tree visspec = $2;\n \n \t\t  if (current_aggr == signature_type_node)\n \t\t    {\n \t\t      error (\"access specifier not allowed in signature\");\n-\t\t      visspec = (tree) access_public;\n+\t\t      visspec = access_public_node;\n \t\t    }\n \t\t  $$ = chainon ($$, build_tree_list (visspec, $4));\n \t\t}\n@@ -2861,23 +2857,20 @@ after_type_declarator:\n qualified_type_name:\n \t  type_name %prec EMPTY\n \t\t{\n+\t\t  $$ = TREE_TYPE ($1);\n \t\t  /* Remember that this name has been used in the class\n \t\t     definition, as per [class.scope0] */\n \t\t  if (current_class_type\n \t\t      && TYPE_BEING_DEFINED (current_class_type)\n-\t\t      && ! IDENTIFIER_CLASS_VALUE ($$))\n-\t\t    {\n-\t\t      tree t = lookup_name ($$, -2);\n-\t\t      if (t)\n-\t\t\tpushdecl_class_level (t);\n-\t\t    }\n+\t\t      && ! IDENTIFIER_CLASS_VALUE ($1))\n+\t\t    pushdecl_class_level (lookup_name ($1, -2));\n \t\t}\n \t| nested_type\n \t;\n \n nested_type:\n \tnested_name_specifier type_name %prec EMPTY\n-\t\t{ $$ = $2; }\n+\t\t{ $$ = TREE_TYPE ($2); }\n \t;\n \n direct_after_type_declarator:\n@@ -2941,9 +2934,9 @@ complex_direct_notype_declarator:\n \t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n \t| notype_qualified_id\n-\t\t{ if (TREE_TYPE (OP0 ($$)) != current_class_type)\n+\t\t{ if (OP0 ($$) != current_class_type)\n \t\t    {\n-\t\t      push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n+\t\t      push_nested_class (OP0 ($$), 3);\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n@@ -2991,11 +2984,11 @@ nested_name_specifier:\n    inline here?!?  (jason) */\n nested_name_specifier_1:\n \t  TYPENAME SCOPE\n-\t\t{ got_scope = TREE_TYPE ($$); }\n+\t\t{ got_scope = $$ = TREE_TYPE ($1); }\n \t| NSNAME SCOPE\n-\t\t{ got_scope = $$; }\n+\t\t{ got_scope = $$ = $1; }\n \t| template_type SCOPE\n-\t\t{ got_scope = TREE_TYPE ($$); }\n+\t\t{ got_scope = $$ = TREE_TYPE ($1); }\n /* \tThese break 'const i;'\n \t| IDENTIFIER SCOPE\n \t\t{"}, {"sha": "ffc7f33f1ba1444437d72b7c478856040f5a5b8e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -127,13 +127,6 @@ process_template_parm (list, next)\n       decl = build_decl (TYPE_DECL, TREE_VALUE (parm), t);\n       TYPE_MAIN_DECL (t) = decl;\n       parm = decl;\n-      if (defval)\n-\t{\n-\t  if (IDENTIFIER_HAS_TYPE_VALUE (defval))\n-\t    defval = IDENTIFIER_TYPE_VALUE (defval);\n-\t  else\n-\t    defval = TREE_TYPE (IDENTIFIER_GLOBAL_VALUE (defval));\n-\t}\n     }\n   SET_DECL_ARTIFICIAL (decl);\n   pushdecl (decl);"}, {"sha": "110eaed978591a2d69fc590aadd25f2214e190c4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 58, "deletions": 49, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -794,35 +794,35 @@ current_scope ()\n \n    This will be static when lookup_fnfield comes into this file.\n \n-   access_public means that the field can be accessed by the current lexical\n+   access_public_node means that the field can be accessed by the current lexical\n    scope.\n \n-   access_protected means that the field cannot be accessed by the current\n+   access_protected_node means that the field cannot be accessed by the current\n    lexical scope because it is protected.\n \n-   access_private means that the field cannot be accessed by the current\n+   access_private_node means that the field cannot be accessed by the current\n    lexical scope because it is private. */\n \n #if 0\n-#define PUBLIC_RETURN return (DECL_PUBLIC (field) = 1), access_public\n-#define PROTECTED_RETURN return (DECL_PROTECTED (field) = 1), access_protected\n-#define PRIVATE_RETURN return (DECL_PRIVATE (field) = 1), access_private\n+#define PUBLIC_RETURN return (DECL_PUBLIC (field) = 1), access_public_node\n+#define PROTECTED_RETURN return (DECL_PROTECTED (field) = 1), access_protected_node\n+#define PRIVATE_RETURN return (DECL_PRIVATE (field) = 1), access_private_node\n #else\n-#define PUBLIC_RETURN return access_public\n-#define PROTECTED_RETURN return access_protected\n-#define PRIVATE_RETURN return access_private\n+#define PUBLIC_RETURN return access_public_node\n+#define PROTECTED_RETURN return access_protected_node\n+#define PRIVATE_RETURN return access_private_node\n #endif\n \n #if 0\n /* Disabled with DECL_PUBLIC &c.  */\n static tree previous_scope = NULL_TREE;\n #endif\n \n-enum access_type\n+tree\n compute_access (basetype_path, field)\n      tree basetype_path, field;\n {\n-  enum access_type access;\n+  tree access;\n   tree types;\n   tree context;\n   int protected_ok, via_protected;\n@@ -836,29 +836,29 @@ compute_access (basetype_path, field)\n      || (TREE_CODE (field) != FUNCTION_DECL && TREE_STATIC (field)));\n \n   if (! flag_access_control)\n-    return access_public;\n+    return access_public_node;\n \n   /* The field lives in the current class.  */\n   if (BINFO_TYPE (basetype_path) == current_class_type)\n-    return access_public;\n+    return access_public_node;\n \n #if 0\n   /* Disabled until pushing function scope clears these out.  If ever.  */\n   /* Make these special cases fast.  */\n   if (current_scope () == previous_scope)\n     {\n       if (DECL_PUBLIC (field))\n-\treturn access_public;\n+\treturn access_public_node;\n       if (DECL_PROTECTED (field))\n-\treturn access_protected;\n+\treturn access_protected_node;\n       if (DECL_PRIVATE (field))\n-\treturn access_private;\n+\treturn access_private_node;\n     }\n #endif\n \n   /* We don't currently support access control on nested types.  */\n   if (TREE_CODE (field) == TYPE_DECL)\n-    return access_public;\n+    return access_public_node;\n \n   previous_scope = current_scope ();\n   \n@@ -912,7 +912,7 @@ compute_access (basetype_path, field)\n   basetype_path = reverse_path (basetype_path);\n   types = basetype_path;\n   via_protected = 0;\n-  access = access_default;\n+  access = access_default_node;\n   protected_ok = static_mem && current_class_type\n     && ACCESSIBLY_DERIVED_FROM_P (BINFO_TYPE (types), current_class_type);\n \n@@ -934,7 +934,7 @@ compute_access (basetype_path, field)\n       member = purpose_member (type, DECL_ACCESS (field));\n       if (member)\n \t{\n-\t  access = (enum access_type) TREE_VALUE (member);\n+\t  access = TREE_VALUE (member);\n \t  break;\n \t}\n \n@@ -948,7 +948,7 @@ compute_access (basetype_path, field)\n \t    via_protected = 1;\n \t  else if (! TREE_VIA_PUBLIC (types) && ! private_ok)\n \t    {\n-\t      access = access_private;\n+\t      access = access_private_node;\n \t      break;\n \t    }\n \t}\n@@ -959,30 +959,30 @@ compute_access (basetype_path, field)\n \n   /* No special visibilities apply.  Use normal rules.  */\n \n-  if (access == access_default)\n+  if (access == access_default_node)\n     {\n       if (is_friend (context, previous_scope))\n-\taccess = access_public;\n+\taccess = access_public_node;\n       else if (TREE_PRIVATE (field))\n-\taccess = access_private;\n+\taccess = access_private_node;\n       else if (TREE_PROTECTED (field))\n-\taccess = access_protected;\n+\taccess = access_protected_node;\n       else\n-\taccess = access_public;\n+\taccess = access_public_node;\n     }\n \n-  if (access == access_public && via_protected)\n-    access = access_protected;\n+  if (access == access_public_node && via_protected)\n+    access = access_protected_node;\n \n-  if (access == access_protected && protected_ok)\n-    access = access_public;\n+  if (access == access_protected_node && protected_ok)\n+    access = access_public_node;\n \n #if 0\n-  if (access == access_public)\n+  if (access == access_public_node)\n     DECL_PUBLIC (field) = 1;\n-  else if (access == access_protected)\n+  else if (access == access_protected_node)\n     DECL_PROTECTED (field) = 1;\n-  else if (access == access_private)\n+  else if (access == access_private_node)\n     DECL_PRIVATE (field) = 1;\n   else my_friendly_abort (96);\n #endif\n@@ -1072,9 +1072,9 @@ lookup_field (xbasetype, name, protect, want_type)\n   int head = 0, tail = 0;\n   tree rval, rval_binfo = NULL_TREE, rval_binfo_h;\n   tree type, basetype_chain, basetype_path;\n-  enum access_type this_v = access_default;\n+  tree this_v = access_default_node;\n   tree entry, binfo, binfo_h;\n-  enum access_type own_access = access_default;\n+  tree own_access = access_default_node;\n   int vbase_name_p = VBASE_NAME_P (name);\n \n   /* rval_binfo is the binfo associated with the found member, note,\n@@ -1179,16 +1179,16 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    this_v = compute_access (basetype_path, rval);\n \t  if (TREE_CODE (rval) == CONST_DECL)\n \t    {\n-\t      if (this_v == access_private)\n+\t      if (this_v == access_private_node)\n \t\terrstr = \"enum `%D' is a private value of class `%T'\";\n-\t      else if (this_v == access_protected)\n+\t      else if (this_v == access_protected_node)\n \t\terrstr = \"enum `%D' is a protected value of class `%T'\";\n \t    }\n \t  else\n \t    {\n-\t      if (this_v == access_private)\n+\t      if (this_v == access_private_node)\n \t\terrstr = \"member `%D' is a private member of class `%T'\";\n-\t      else if (this_v == access_protected)\n+\t      else if (this_v == access_protected_node)\n \t\terrstr = \"member `%D' is a protected member of class `%T'\";\n \t    }\n \t}\n@@ -1370,14 +1370,14 @@ lookup_field (xbasetype, name, protect, want_type)\n \t    /* If is possible for one of the derived types on the path to\n \t       have defined special access for this field.  Look for such\n \t       declarations and report an error if a conflict is found.  */\n-\t    enum access_type new_v;\n+\t    tree new_v;\n \n-\t    if (this_v != access_default)\n+\t    if (this_v != access_default_node)\n \t      new_v = compute_access (TREE_VALUE (TREE_CHAIN (*tp)), rval);\n-\t    if (this_v != access_default && new_v != this_v)\n+\t    if (this_v != access_default_node && new_v != this_v)\n \t      {\n \t\terrstr = \"conflicting access to member `%D'\";\n-\t\tthis_v = access_default;\n+\t\tthis_v = access_default_node;\n \t      }\n \t    own_access = new_v;\n \t    CLEAR_BINFO_FIELDS_MARKED (TREE_VALUE (TREE_CHAIN (*tp)));\n@@ -1397,15 +1397,15 @@ lookup_field (xbasetype, name, protect, want_type)\n \n   if (errstr == 0)\n     {\n-      if (own_access == access_private)\n+      if (own_access == access_private_node)\n \terrstr = \"member `%D' declared private\";\n-      else if (own_access == access_protected)\n+      else if (own_access == access_protected_node)\n \terrstr = \"member `%D' declared protected\";\n-      else if (this_v == access_private)\n+      else if (this_v == access_private_node)\n \terrstr = TREE_PRIVATE (rval)\n \t  ? \"member `%D' is private\"\n \t    : \"member `%D' is from private base class\";\n-      else if (this_v == access_protected)\n+      else if (this_v == access_protected_node)\n \terrstr = TREE_PROTECTED (rval)\n \t  ? \"member `%D' is protected\"\n \t    : \"member `%D' is from protected base class\";\n@@ -3334,10 +3334,14 @@ dfs_compress_decls (binfo)\n    lattice.  Where ambiguities result, we mark them\n    with `error_mark_node' so that if they are encountered\n    without explicit qualification, we can emit an error\n-   message.  */\n+   message.\n+\n+   ONLY_TYPES is set when defining TYPE so that inherited types are visible\n+   in the derived class.  */\n void\n-push_class_decls (type)\n+push_class_decls (type, only_types)\n      tree type;\n+     int only_types;\n {\n   tree id;\n   struct obstack *ambient_obstack = current_obstack;\n@@ -3392,7 +3396,12 @@ push_class_decls (type)\n       /* Install the original class value in order to make\n \t pushdecl_class_level work correctly.  */\n       IDENTIFIER_CLASS_VALUE (id) = TREE_VALUE (closed_envelopes);\n-      if (TREE_CODE (new) == TREE_LIST)\n+      if (only_types)\n+\t{\n+\t  if (TREE_CODE (new) == TYPE_DECL)\n+\t    set_identifier_type_value (id, TREE_TYPE (new));\n+\t} \n+      else if (TREE_CODE (new) == TREE_LIST)\n \tpush_class_level_binding (id, new);\n       else\n \tpushdecl_class_level (new);"}, {"sha": "27d4e2ec71a00677aee4e90f4b0cc7758343b231", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -530,7 +530,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \n \t  if (rhs_method == NULL_TREE\n \t      || (compute_access (basetypes, rhs_method)\n-\t\t  != access_public))\n+\t\t  != access_public_node))\n \t    {\n \t      error (\"class `%s' does not contain a method conforming to `%s'\",\n \t\t     TYPE_NAME_STRING (rhstype),"}, {"sha": "be0fc99195b78eed5ce47252d61506bd9b2bbc3c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -820,8 +820,8 @@ layout_basetypes (rec, binfos)\n \t\tgoto got_it;\n \t    }\n \t  sprintf (name, VBASE_NAME_FORMAT, TYPE_NAME_STRING (basetype));\n-\t  decl = build_lang_decl (FIELD_DECL, get_identifier (name),\n-\t\t\t\t  build_pointer_type (basetype));\n+\t  decl = build_lang_field_decl (FIELD_DECL, get_identifier (name),\n+\t\t\t\t\tbuild_pointer_type (basetype));\n \t  /* If you change any of the below, take a look at all the\n \t     other VFIELD_BASEs and VTABLE_BASEs in the code, and change\n \t     them too. */\n@@ -1137,7 +1137,8 @@ get_decl_list (value)\n   if (TREE_CODE (value) == IDENTIFIER_NODE)\n     list = get_identifier_list (value);\n   else if (TREE_CODE (value) == RECORD_TYPE\n-\t   && TYPE_LANG_SPECIFIC (value))\n+\t   && TYPE_LANG_SPECIFIC (value)\n+\t   && value == TYPE_MAIN_VARIANT (value))\n     list = CLASSTYPE_AS_LIST (value);\n \n   if (list != NULL_TREE)"}, {"sha": "9901080192a3a19af1c7219c89662214d360357e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1532,15 +1532,14 @@ build_object_ref (datum, basetype, field)\n \t\tbasetype, field, dtype);\n       return error_mark_node;\n     }\n-  else if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (basetype)))\n+  else if (IS_SIGNATURE (basetype))\n     {\n       warning (\"signature name in scope resolution ignored\");\n       return build_component_ref (datum, field, NULL_TREE, 1);\n     }\n-  else if (is_aggr_typedef (basetype, 1))\n+  else if (is_aggr_type (basetype, 1))\n     {\n-      tree real_basetype = IDENTIFIER_TYPE_VALUE (basetype);\n-      tree binfo = binfo_or_else (real_basetype, TREE_TYPE (datum));\n+      tree binfo = binfo_or_else (basetype, TREE_TYPE (datum));\n       if (binfo)\n \treturn build_component_ref (build_scoped_ref (datum, basetype),\n \t\t\t\t    field, binfo, 1);\n@@ -1590,15 +1589,14 @@ build_component_ref_1 (datum, field, protect)\n \n   if (datum == C_C_D)\n     {\n-      enum access_type access\n-\t= compute_access (TYPE_BINFO (current_class_type), field);\n+      tree access = compute_access (TYPE_BINFO (current_class_type), field);\n \n-      if (access == access_private)\n+      if (access == access_private_node)\n \t{\n \t  cp_error (\"field `%D' is private\", field);\n \t  return error_mark_node;\n \t}\n-      else if (access == access_protected)\n+      else if (access == access_protected_node)\n \t{\n \t  cp_error (\"field `%D' is protected\", field);\n \t  return error_mark_node;\n@@ -1748,14 +1746,13 @@ build_component_ref (datum, component, basetype_path, protect)\n \t      if (TREE_CHAIN (fndecls) == NULL_TREE\n \t\t  && DECL_CHAIN (TREE_VALUE (fndecls)) == NULL_TREE)\n \t\t{\n-\t\t  enum access_type access;\n-\t\t  tree fndecl;\n+\t\t  tree access, fndecl;\n \n \t\t  /* Unique, so use this one now.  */\n \t\t  basetype = TREE_PURPOSE (fndecls);\n \t\t  fndecl = TREE_VALUE (fndecls);\n \t\t  access = compute_access (TREE_PURPOSE (fndecls), fndecl);\n-\t\t  if (access == access_public)\n+\t\t  if (access == access_public_node)\n \t\t    {\n \t\t      if (DECL_VINDEX (fndecl)\n \t\t\t  && ! resolves_to_fixed_type_p (datum, 0))\n@@ -1769,7 +1766,7 @@ build_component_ref (datum, component, basetype_path, protect)\n \t\t      mark_used (fndecl);\n \t\t      return fndecl;\n \t\t    }\n-\t\t  if (access == access_protected)\n+\t\t  if (access == access_protected_node)\n \t\t    cp_error (\"member function `%D' is protected\", fndecl);\n \t\t  else\n \t\t    cp_error (\"member function `%D' is private\", fndecl);\n@@ -3727,7 +3724,7 @@ pointer_int_sum (resultcode, ptrop, intop)\n     }\n   else if (TREE_CODE (TREE_TYPE (result_type)) == OFFSET_TYPE)\n     {\n-      if (pedantic)\n+      if (pedantic || warn_pointer_arith)\n \tpedwarn (\"ANSI C++ forbids using pointer to a member in arithmetic\");\n       size_exp = integer_one_node;\n     }\n@@ -3793,7 +3790,7 @@ pointer_diff (op0, op1)\n   tree restype = ptrdiff_type_node;\n   tree target_type = TREE_TYPE (TREE_TYPE (op0));\n \n-  if (pedantic)\n+  if (pedantic || warn_pointer_arith)\n     {\n       if (TREE_CODE (target_type) == VOID_TYPE)\n \tpedwarn (\"ANSI C++ forbids using pointer of type `void *' in subtraction\");\n@@ -6169,9 +6166,10 @@ build_modify_expr (lhs, modifycode, rhs)\n       /* Can't initialize directly from a TARGET_EXPR, since that would\n \t cause the lhs to be constructed twice, and possibly result in\n \t accidental self-initialization.  So we force the TARGET_EXPR to be\n-\t expanded.  expand_expr should really do this by itself.  */\n+\t expanded without a target.  */\n       if (TREE_CODE (newrhs) == TARGET_EXPR)\n-\tnewrhs = expand_target_expr (newrhs);\n+\tnewrhs = build (COMPOUND_EXPR, TREE_TYPE (newrhs), newrhs,\n+\t\t\tTREE_VALUE (newrhs));\n     }\n \n   if (TREE_CODE (newrhs) == ERROR_MARK)"}, {"sha": "a2f81729cadc547771fcf0e80fe8e496fb8023b0", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 8, "deletions": 60, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be99da7733a890fb35dd3d8cf4ae1852581f5b1d/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=be99da7733a890fb35dd3d8cf4ae1852581f5b1d", "patch": "@@ -1199,7 +1199,7 @@ process_init_constructor (type, init, elts)\n \f\n /* Given a structure or union value DATUM, construct and return\n    the structure or union component which results from narrowing\n-   that value by the types specified in TYPES.  For example, given the\n+   that value by the type specified in BASETYPE.  For example, given the\n    hierarchy\n \n    class L { int ii; };\n@@ -1213,23 +1213,16 @@ process_init_constructor (type, init, elts)\n \n    then the expression\n \n-   x::C::A::L::ii refers to the ii member of the L part of\n+   x.A::ii refers to the ii member of the L part of\n    of A part of the C object named by X.  In this case,\n-   DATUM would be x, and TYPES would be a SCOPE_REF consisting of\n-\n-\tSCOPE_REF\n-\t\tSCOPE_REF\n-\t\t\tC\tA\n-\t\tL\n-\n-   The last entry in the SCOPE_REF is always an IDENTIFIER_NODE.\n+   DATUM would be x, and BASETYPE would be A.\n \n */\n \n tree\n-build_scoped_ref (datum, types)\n+build_scoped_ref (datum, basetype)\n      tree datum;\n-     tree types;\n+     tree basetype;\n {\n   tree ref;\n   tree type = TREE_TYPE (datum);\n@@ -1242,62 +1235,17 @@ build_scoped_ref (datum, types)\n \n   type = TYPE_MAIN_VARIANT (type);\n \n-  if (TREE_CODE (types) == SCOPE_REF)\n-    {\n-      /* We have some work to do.  */\n-      struct type_chain\n-\t{ tree type; struct type_chain *next; }\n-      *chain = NULL, *head = NULL, scratch;\n-      ref = build_unary_op (ADDR_EXPR, datum, 0);\n-      while (TREE_CODE (types) == SCOPE_REF)\n-\t{\n-\t  tree t = TREE_OPERAND (types, 1);\n-\t  if (is_aggr_typedef (t, 1))\n-\t    {\n-\t      head = (struct type_chain *)alloca (sizeof (struct type_chain));\n-\t      head->type = IDENTIFIER_TYPE_VALUE (t);\n-\t      head->next = chain;\n-\t      chain = head;\n-\t      types = TREE_OPERAND (types, 0);\n-\t    }\n-\t  else return error_mark_node;\n-\t}\n-      if (! is_aggr_typedef (types, 1))\n-\treturn error_mark_node;\n-\n-      head = &scratch;\n-      head->type = IDENTIFIER_TYPE_VALUE (types);\n-      head->next = chain;\n-      chain = head;\n-      while (chain)\n-\t{\n-\t  tree binfo = chain->type;\n-\t  type = TREE_TYPE (TREE_TYPE (ref));\n-\t  if (binfo != TYPE_BINFO (type))\n-\t    {\n-\t      binfo = get_binfo (binfo, type, 1);\n-\t      if (binfo == error_mark_node)\n-\t\treturn error_mark_node;\n-\t      if (binfo == 0)\n-\t\treturn error_not_base_type (chain->type, type);\n-\t      ref = convert_pointer_to (binfo, ref);\n-\t    }\n-\t  chain = chain->next;\n-\t}\n-      return build_indirect_ref (ref, \"(compiler error in build_scoped_ref)\");\n-    }\n-\n   /* This is an easy conversion.  */\n-  if (is_aggr_typedef (types, 1))\n+  if (is_aggr_type (basetype, 1))\n     {\n-      tree binfo = TYPE_BINFO (IDENTIFIER_TYPE_VALUE (types));\n+      tree binfo = TYPE_BINFO (basetype);\n       if (binfo != TYPE_BINFO (type))\n \t{\n \t  binfo = get_binfo (binfo, type, 1);\n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n \t  if (binfo == 0)\n-\t    return error_not_base_type (IDENTIFIER_TYPE_VALUE (types), type);\n+\t    return error_not_base_type (basetype, type);\n \t}\n \n       switch (TREE_CODE (datum))"}]}