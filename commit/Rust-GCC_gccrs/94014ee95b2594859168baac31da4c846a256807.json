{"sha": "94014ee95b2594859168baac31da4c846a256807", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwMTRlZTk1YjI1OTQ4NTkxNjhiYWFjMzFkYTRjODQ2YTI1NjgwNw==", "commit": {"author": {"name": "Edward Smith-Rowland", "email": "3dw4rd@verizon.net", "date": "2019-03-04T20:11:14Z"}, "committer": {"name": "Edward Smith-Rowland", "email": "emsr@gcc.gnu.org", "date": "2019-03-04T20:11:14Z"}, "message": "PR libstdc++/88996 Implement P0439R0\n\n2019-03-04  Edward Smith-Rowland  <3dw4rd@verizon.net>\n\n\tPR libstdc++/88996 Implement P0439R0\n\tMake std::memory_order a scoped enumeration.\n\t* include/bits/atomic_base.h: For C++20 make memory_order a scoped enum,\n\tadd variables for the old enumerators.  Adjust calls.\n\t* testsuite/29_atomics/headers/atomic/types_std_c++2a.cc: New test.\n\t* testsuite/29_atomics/headers/atomic/types_std_c++2a_neg.cc: New test.\n\nFrom-SVN: r269372", "tree": {"sha": "b79096f9660e10e7d5a6b520823cbbc9313e6894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b79096f9660e10e7d5a6b520823cbbc9313e6894"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94014ee95b2594859168baac31da4c846a256807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94014ee95b2594859168baac31da4c846a256807", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94014ee95b2594859168baac31da4c846a256807", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94014ee95b2594859168baac31da4c846a256807/comments", "author": {"login": "emsr", "id": 1936479, "node_id": "MDQ6VXNlcjE5MzY0Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1936479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emsr", "html_url": "https://github.com/emsr", "followers_url": "https://api.github.com/users/emsr/followers", "following_url": "https://api.github.com/users/emsr/following{/other_user}", "gists_url": "https://api.github.com/users/emsr/gists{/gist_id}", "starred_url": "https://api.github.com/users/emsr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emsr/subscriptions", "organizations_url": "https://api.github.com/users/emsr/orgs", "repos_url": "https://api.github.com/users/emsr/repos", "events_url": "https://api.github.com/users/emsr/events{/privacy}", "received_events_url": "https://api.github.com/users/emsr/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f0103f7bb010405798fe14afc5972f327835ae57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0103f7bb010405798fe14afc5972f327835ae57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0103f7bb010405798fe14afc5972f327835ae57"}], "stats": {"total": 181, "additions": 140, "deletions": 41}, "files": [{"sha": "1d3c7774fd9c142950bac8f910216a29d0e7f54b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=94014ee95b2594859168baac31da4c846a256807", "patch": "@@ -1,3 +1,12 @@\n+2019-03-04  Edward Smith-Rowland  <3dw4rd@verizon.net>\n+\n+\tPR libstdc++/88996 Implement P0439R0\n+\tMake std::memory_order a scoped enumeration.\n+\t* include/bits/atomic_base.h: For C++20 make memory_order a scoped enum,\n+\tadd variables for the old enumerators.  Adjust calls.\n+\t* testsuite/29_atomics/headers/atomic/types_std_c++2a.cc: New test.\n+\t* testsuite/29_atomics/headers/atomic/types_std_c++2a_neg.cc: New test.\n+\n 2019-03-04  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/26_numerics/bit/bitops.rot/rotl.cc: Remove bogus dg-do"}, {"sha": "6c1703aa11aadf87623168be1bb1ced3830ef244", "filename": "libstdc++-v3/include/bits/atomic_base.h", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_base.h?ref=94014ee95b2594859168baac31da4c846a256807", "patch": "@@ -52,6 +52,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n \n   /// Enumeration for memory_order\n+#if __cplusplus > 201703L\n+  enum class memory_order : int\n+    {\n+      relaxed,\n+      consume,\n+      acquire,\n+      release,\n+      acq_rel,\n+      seq_cst\n+    };\n+\n+  inline constexpr memory_order memory_order_relaxed = memory_order::relaxed;\n+  inline constexpr memory_order memory_order_consume = memory_order::consume;\n+  inline constexpr memory_order memory_order_acquire = memory_order::acquire;\n+  inline constexpr memory_order memory_order_release = memory_order::release;\n+  inline constexpr memory_order memory_order_acq_rel = memory_order::acq_rel;\n+  inline constexpr memory_order memory_order_seq_cst = memory_order::seq_cst;\n+#else\n   typedef enum memory_order\n     {\n       memory_order_relaxed,\n@@ -61,6 +79,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       memory_order_acq_rel,\n       memory_order_seq_cst\n     } memory_order;\n+#endif\n \n   enum __memory_order_modifier\n     {\n@@ -73,13 +92,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   constexpr memory_order\n   operator|(memory_order __m, __memory_order_modifier __mod)\n   {\n-    return memory_order(__m | int(__mod));\n+    return memory_order(int(__m) | int(__mod));\n   }\n \n   constexpr memory_order\n   operator&(memory_order __m, __memory_order_modifier __mod)\n   {\n-    return memory_order(__m & int(__mod));\n+    return memory_order(int(__m) & int(__mod));\n   }\n \n   // Drop release ordering as per [atomics.types.operations.req]/21\n@@ -94,16 +113,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   __cmpexch_failure_order(memory_order __m) noexcept\n   {\n     return memory_order(__cmpexch_failure_order2(__m & __memory_order_mask)\n-      | (__m & __memory_order_modifier_mask));\n+      | __memory_order_modifier(__m & __memory_order_modifier_mask));\n   }\n \n   _GLIBCXX_ALWAYS_INLINE void\n   atomic_thread_fence(memory_order __m) noexcept\n-  { __atomic_thread_fence(__m); }\n+  { __atomic_thread_fence(int(__m)); }\n \n   _GLIBCXX_ALWAYS_INLINE void\n   atomic_signal_fence(memory_order __m) noexcept\n-  { __atomic_signal_fence(__m); }\n+  { __atomic_signal_fence(int(__m)); }\n \n   /// kill_dependency\n   template<typename _Tp>\n@@ -173,13 +192,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     _GLIBCXX_ALWAYS_INLINE bool\n     test_and_set(memory_order __m = memory_order_seq_cst) noexcept\n     {\n-      return __atomic_test_and_set (&_M_i, __m);\n+      return __atomic_test_and_set (&_M_i, int(__m));\n     }\n \n     _GLIBCXX_ALWAYS_INLINE bool\n     test_and_set(memory_order __m = memory_order_seq_cst) volatile noexcept\n     {\n-      return __atomic_test_and_set (&_M_i, __m);\n+      return __atomic_test_and_set (&_M_i, int(__m));\n     }\n \n     _GLIBCXX_ALWAYS_INLINE void\n@@ -190,7 +209,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __glibcxx_assert(__b != memory_order_acquire);\n       __glibcxx_assert(__b != memory_order_acq_rel);\n \n-      __atomic_clear (&_M_i, __m);\n+      __atomic_clear (&_M_i, int(__m));\n     }\n \n     _GLIBCXX_ALWAYS_INLINE void\n@@ -201,7 +220,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __glibcxx_assert(__b != memory_order_acquire);\n       __glibcxx_assert(__b != memory_order_acq_rel);\n \n-      __atomic_clear (&_M_i, __m);\n+      __atomic_clear (&_M_i, int(__m));\n     }\n \n   private:\n@@ -375,7 +394,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \t__glibcxx_assert(__b != memory_order_consume);\n \n-\t__atomic_store_n(&_M_i, __i, __m);\n+\t__atomic_store_n(&_M_i, __i, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE void\n@@ -387,7 +406,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \t__glibcxx_assert(__b != memory_order_consume);\n \n-\t__atomic_store_n(&_M_i, __i, __m);\n+\t__atomic_store_n(&_M_i, __i, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n@@ -397,7 +416,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_release);\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \n-\treturn __atomic_load_n(&_M_i, __m);\n+\treturn __atomic_load_n(&_M_i, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n@@ -407,22 +426,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_release);\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \n-\treturn __atomic_load_n(&_M_i, __m);\n+\treturn __atomic_load_n(&_M_i, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       exchange(__int_type __i,\n \t       memory_order __m = memory_order_seq_cst) noexcept\n       {\n-\treturn __atomic_exchange_n(&_M_i, __i, __m);\n+\treturn __atomic_exchange_n(&_M_i, __i, int(__m));\n       }\n \n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       exchange(__int_type __i,\n \t       memory_order __m = memory_order_seq_cst) volatile noexcept\n       {\n-\treturn __atomic_exchange_n(&_M_i, __i, __m);\n+\treturn __atomic_exchange_n(&_M_i, __i, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -435,7 +454,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -449,7 +469,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 1,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -478,7 +499,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -493,7 +515,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_i, &__i1, __i2, 0,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -515,52 +538,52 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_add(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_add(&_M_i, __i, __m); }\n+      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_add(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_add(&_M_i, __i, __m); }\n+      { return __atomic_fetch_add(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_sub(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n+      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_sub(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_sub(&_M_i, __i, __m); }\n+      { return __atomic_fetch_sub(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_and(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_and(&_M_i, __i, __m); }\n+      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_and(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_and(&_M_i, __i, __m); }\n+      { return __atomic_fetch_and(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_or(__int_type __i,\n \t       memory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_or(&_M_i, __i, __m); }\n+      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_or(__int_type __i,\n \t       memory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_or(&_M_i, __i, __m); }\n+      { return __atomic_fetch_or(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_xor(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n+      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __int_type\n       fetch_xor(__int_type __i,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_xor(&_M_i, __i, __m); }\n+      { return __atomic_fetch_xor(&_M_i, __i, int(__m)); }\n     };\n \n \n@@ -692,7 +715,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \t__glibcxx_assert(__b != memory_order_consume);\n \n-\t__atomic_store_n(&_M_p, __p, __m);\n+\t__atomic_store_n(&_M_p, __p, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE void\n@@ -704,7 +727,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \t__glibcxx_assert(__b != memory_order_consume);\n \n-\t__atomic_store_n(&_M_p, __p, __m);\n+\t__atomic_store_n(&_M_p, __p, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n@@ -714,7 +737,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_release);\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \n-\treturn __atomic_load_n(&_M_p, __m);\n+\treturn __atomic_load_n(&_M_p, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n@@ -724,22 +747,22 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b != memory_order_release);\n \t__glibcxx_assert(__b != memory_order_acq_rel);\n \n-\treturn __atomic_load_n(&_M_p, __m);\n+\treturn __atomic_load_n(&_M_p, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       exchange(__pointer_type __p,\n \t       memory_order __m = memory_order_seq_cst) noexcept\n       {\n-\treturn __atomic_exchange_n(&_M_p, __p, __m);\n+\treturn __atomic_exchange_n(&_M_p, __p, int(__m));\n       }\n \n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       exchange(__pointer_type __p,\n \t       memory_order __m = memory_order_seq_cst) volatile noexcept\n       {\n-\treturn __atomic_exchange_n(&_M_p, __p, __m);\n+\treturn __atomic_exchange_n(&_M_p, __p, int(__m));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -753,7 +776,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE bool\n@@ -768,28 +792,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__glibcxx_assert(__b2 != memory_order_acq_rel);\n \t__glibcxx_assert(__b2 <= __b1);\n \n-\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0, __m1, __m2);\n+\treturn __atomic_compare_exchange_n(&_M_p, &__p1, __p2, 0,\n+\t\t\t\t\t   int(__m1), int(__m2));\n       }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }\n+      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       fetch_add(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), __m); }\n+      { return __atomic_fetch_add(&_M_p, _M_type_size(__d), int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       fetch_sub(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) noexcept\n-      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }\n+      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }\n \n       _GLIBCXX_ALWAYS_INLINE __pointer_type\n       fetch_sub(ptrdiff_t __d,\n \t\tmemory_order __m = memory_order_seq_cst) volatile noexcept\n-      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), __m); }\n+      { return __atomic_fetch_sub(&_M_p, _M_type_size(__d), int(__m)); }\n     };\n \n   // @} group atomics"}, {"sha": "60fb6faba8968fc9330c29ab55b636c0d82ff1d7", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/types_std_c++2a.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a.cc?ref=94014ee95b2594859168baac31da4c846a256807", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+\n+void test01()\n+{\n+  using std::memory_order;\n+  constexpr auto relaxed = memory_order::relaxed;\n+  constexpr auto consume = memory_order::consume;\n+  constexpr auto acquire = memory_order::acquire;\n+  constexpr auto release = memory_order::release;\n+  constexpr auto acq_rel = memory_order::acq_rel;\n+  constexpr auto seq_cst = memory_order::seq_cst;\n+}"}, {"sha": "03f56320074c4e4072c5083ade848b2c08d439dd", "filename": "libstdc++-v3/testsuite/29_atomics/headers/atomic/types_std_c++2a_neg.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94014ee95b2594859168baac31da4c846a256807/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F29_atomics%2Fheaders%2Fatomic%2Ftypes_std_c%2B%2B2a_neg.cc?ref=94014ee95b2594859168baac31da4c846a256807", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <atomic>\n+\n+void test01()\n+{\n+  // Not global scoped, only namespace std.\n+  using memory_order; // { dg-error \"expected nested-name-specifier\" }\n+  constexpr auto relaxed = memory_order::relaxed; // { dg-error \"has not been declared\" }\n+  constexpr auto consume = memory_order::consume; // { dg-error \"has not been declared\" }\n+  constexpr auto acquire = memory_order::acquire; // { dg-error \"has not been declared\" }\n+  constexpr auto release = memory_order::release; // { dg-error \"has not been declared\" }\n+  constexpr auto acq_rel = memory_order::acq_rel; // { dg-error \"has not been declared\" }\n+  constexpr auto seq_cst = memory_order::seq_cst; // { dg-error \"has not been declared\" }\n+}"}]}