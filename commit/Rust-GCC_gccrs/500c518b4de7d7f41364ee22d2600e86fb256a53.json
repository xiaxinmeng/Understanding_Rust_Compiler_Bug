{"sha": "500c518b4de7d7f41364ee22d2600e86fb256a53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAwYzUxOGI0ZGU3ZDdmNDEzNjRlZTIyZDI2MDBlODZmYjI1NmE1Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-01T12:32:27Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-03-01T12:32:27Z"}, "message": "(subst, case NOT): If STORE_FLAG_VALUE==-1, treat an ASHIFTRT of just the sign bit as if it were an LT.\n\n(subst, case NOT): If STORE_FLAG_VALUE==-1, treat an ASHIFTRT of just the\nsign bit as if it were an LT.\n(subst, case XOR): Likewise for STORE_FLAG_VALUE==1 and an LSHIFTRT.\n(simplify_and_const_int, case LSHIFTRT): If shifting a sign bit copy,\nstart shift at the sign bit.\n(simplify_shift_const): Likewise for ASHIFTRT.\n\n(BYTE_LOADS_EXTEND): Fix typo when defining.\n(setup_incoming_promotions): Set modes properly.\n\nFrom-SVN: r3575", "tree": {"sha": "8829f54a8b8ff39c65af7d76e197dba2ef3d31e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8829f54a8b8ff39c65af7d76e197dba2ef3d31e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/500c518b4de7d7f41364ee22d2600e86fb256a53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500c518b4de7d7f41364ee22d2600e86fb256a53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/500c518b4de7d7f41364ee22d2600e86fb256a53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/500c518b4de7d7f41364ee22d2600e86fb256a53/comments", "author": null, "committer": null, "parents": [{"sha": "e2eb57b721527a5e8740fe5a25a90bb63cb7ee86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2eb57b721527a5e8740fe5a25a90bb63cb7ee86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2eb57b721527a5e8740fe5a25a90bb63cb7ee86"}], "stats": {"total": 53, "additions": 50, "deletions": 3}, "files": [{"sha": "e849da14cf7abc86fe10e782d589c1e06b3873b1", "filename": "gcc/combine.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/500c518b4de7d7f41364ee22d2600e86fb256a53/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/500c518b4de7d7f41364ee22d2600e86fb256a53/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=500c518b4de7d7f41364ee22d2600e86fb256a53", "patch": "@@ -101,7 +101,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define LOAD_EXTEND ZERO_EXTEND\n #endif\n \n-#ifdef BYTE_LOAD_SIGN_EXTEND\n+#ifdef BYTE_LOADS_SIGN_EXTEND\n #define BYTE_LOADS_EXTEND\n #define LOAD_EXTEND SIGN_EXTEND\n #endif\n@@ -616,8 +616,8 @@ setup_incoming_promotions ()\n \t&& (reg = promoted_input_arg (regno, &mode, &unsignedp)) != 0)\n       record_value_for_reg (reg, first,\n \t\t\t    gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n-\t\t\t\t     mode,\n-\t\t\t\t     gen_rtx (CLOBBER, VOIDmode, const0_rtx)));\n+\t\t\t\t     GET_MODE (reg),\n+\t\t\t\t     gen_rtx (CLOBBER, mode, const0_rtx)));\n #endif\n }\n \f\n@@ -3099,6 +3099,16 @@ subst (x, from, to, in_dest, unique_copy)\n \treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n \t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\tXEXP (XEXP (x, 0), 1));\n+\n+      /* (ashiftrt foo C) where C is the number of bits in FOO minus 1\n+\t is (lt foo (const_int 0)), so we can perform the above\n+\t simplification.  */\n+\n+      if (XEXP (x, 1) == const1_rtx\n+\t  && GET_CODE (XEXP (x, 0)) == ASHIFTRT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n+\treturn gen_rtx_combine (GE, mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n #endif\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n@@ -4285,6 +4295,16 @@ subst (x, from, to, in_dest, unique_copy)\n \treturn gen_rtx_combine (reverse_condition (GET_CODE (XEXP (x, 0))),\n \t\t\t\tmode, XEXP (XEXP (x, 0), 0),\n \t\t\t\tXEXP (XEXP (x, 0), 1));\n+\n+      /* (lshiftrt foo C) where C is the number of bits in FOO minus 1\n+\t is (lt foo (const_int 0)), so we can perform the above\n+\t simplification.  */\n+\n+      if (XEXP (x, 1) == const1_rtx\n+\t  && GET_CODE (XEXP (x, 0)) == LSHIFTRT\n+\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n+\treturn gen_rtx_combine (GE, mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n #endif\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n@@ -5897,6 +5917,23 @@ simplify_and_const_int (x, mode, varop, constop)\n \t\t\t\t     XEXP (varop, 0), XEXP (varop, 1));\n \t  break;\n \n+\tcase LSHIFTRT:\n+\t  /* If we have (and (lshiftrt FOO C1) C2) where the combination of the\n+\t     shift and AND produces only copies of the sign bit (C2 is one less\n+\t     than a power of two), we can do this with just a shift.  */+\n+\n+\t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n+\t      && ((INTVAL (XEXP (varop, 1))\n+\t\t   + num_sign_bit_copies (XEXP (varop, 0),\n+\t\t\t\t\t  GET_MODE (XEXP (varop, 0))))\n+\t\t  >= GET_MODE_BITSIZE (GET_MODE (varop)))\n+\t      && exact_log2 (constop + 1) >= 0)\n+\t    varop\n+\t      = gen_rtx_combine (LSHIFTRT, GET_MODE (varop), XEXP (varop, 0),\n+\t\t\t\t GEN_INT (GET_MODE_BITSIZE (GET_MODE (varop))\n+\t\t\t\t\t  - exact_log2 (constop + 1)));\n+\t  break;\n+\n \tcase NE:\n \t  /* (and (ne FOO 0) CONST) can be (and FOO CONST) if CONST is\n \t     included in STORE_FLAG_VALUE and FOO has no bits that might be\n@@ -6829,6 +6866,16 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t  break;\n \t}\n \n+      /* If we are doing an arithmetic right shift and discarding all but\n+\t the sign bit copies, this is equivalent to doing a shift by the\n+\t bitsize minus one.  Convert it into that shift because it will often\n+\t allow other simplifications.  */\n+\n+      if (code == ASHIFTRT\n+\t  && (count + num_sign_bit_copies (varop, shift_mode)\n+\t      >= GET_MODE_BITSIZE (shift_mode)))\n+\tcount = GET_MODE_BITSIZE (shift_mode) - 1;\n+\n       /* We simplify the tests below and elsewhere by converting\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n \t `make_compound_operation' will convert it to a ASHIFTRT for"}]}