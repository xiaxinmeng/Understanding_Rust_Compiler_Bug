{"sha": "31427b974ed7b7dd54e28fec595e731bf6eea8ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE0MjdiOTc0ZWQ3YjdkZDU0ZTI4ZmVjNTk1ZTczMWJmNmVlYThiYQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-06-30T20:40:30Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-06-30T20:40:30Z"}, "message": "aarch64: Treat GNU and Advanced SIMD vectors as distinct [PR92789, PR95726]\n\nPR95726 is about template look-up for things like:\n\n    foo<float vecf __attribute__((vector_size(16)))>\n    foo<float32x4_t>\n\nThe immediate cause of the problem is that the hash function usually\nreturns different hashes for these types, yet the equality function\nthinks they are equal.  This then raises the question of how the types\nare supposed to be treated.\n\nI think the answer is that the GNU vector type should be treated as\ndistinct from float32x4_t, not least because the two types mangle\ndifferently.  However, each type should implicitly convert to the other.\n\nThis would mean that, as far as the PR is concerned, the hashing\nfunction is right to (sometimes) treat the types differently and\nthe equality function is wrong to treat them as the same.\n\nThe most obvious way to enforce the type difference is to use a\ntarget-specific type attribute.  That on its own is enough to fix\nthe PR.  The difficulty is deciding whether the knock-on effects\nare acceptable.\n\nOne obvious effect is that GCC then rejects:\n\n    typedef float vecf __attribute__((vector_size(16)));\n    vecf x;\n    float32x4_t &z = x;\n\non the basis that the types are no longer reference-compatible.\nI think that's again the correct behaviour, and consistent with\ncurrent Clang.\n\nA trickier question is whether:\n\n    vecf x;\n    float32x4_t y;\n    \u2026 c ? x : y \u2026\n\nshould be valid, and if so, what its type should be [PR92789].\nAs explained in the comment in the testcase, GCC and Clang both\naccepted this, but GCC chose the \u201cthen\u201d type while Clang chose\nthe \u201celse\u201d type.  This can lead to different mangling for (probably\nartificial) corner cases, as seen for \u201csel1\u201d and \u201csel2\u201d in the\ntestcase.\n\nAdding the attribute makes GCC reject the conditional expression\nas ambiguous.  I think that too is the correct behaviour, for the\nreasons described in the testcase.  However, it does seem to have\nthe potential to break existing code.\n\nIt looks like aarch64_comp_type_attributes is missing cases for\nthe SVE attributes, but I'll handle that in a separate patch.\n\n2020-06-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR target/92789\n\tPR target/95726\n\t* config/aarch64/aarch64.c (aarch64_attribute_table): Add\n\t\"Advanced SIMD type\".\n\t(aarch64_comp_type_attributes): Check that the \"Advanced SIMD type\"\n\tattributes are equal.\n\t* config/aarch64/aarch64-builtins.c: Include stringpool.h and\n\tattribs.h.\n\t(aarch64_mangle_builtin_vector_type): Use the mangling recorded\n\tin the \"Advanced SIMD type\" attribute.\n\t(aarch64_init_simd_builtin_types): Add an \"Advanced SIMD type\"\n\tattribute to each Advanced SIMD type, using the mangled type\n\tas the attribute's single argument.\n\ngcc/testsuite/\n\tPR target/92789\n\tPR target/95726\n\t* g++.target/aarch64/pr95726.C: New test.", "tree": {"sha": "4adde506baad9be86d88dcd507a76d03846c6c4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4adde506baad9be86d88dcd507a76d03846c6c4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31427b974ed7b7dd54e28fec595e731bf6eea8ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31427b974ed7b7dd54e28fec595e731bf6eea8ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31427b974ed7b7dd54e28fec595e731bf6eea8ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31427b974ed7b7dd54e28fec595e731bf6eea8ba/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67ef8cfc1c1d440eafa89a26710bced934a485dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ef8cfc1c1d440eafa89a26710bced934a485dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ef8cfc1c1d440eafa89a26710bced934a485dc"}], "stats": {"total": 95, "additions": 77, "deletions": 18}, "files": [{"sha": "e87a4559c36242a243b4ce7df838232e0105c268", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=31427b974ed7b7dd54e28fec595e731bf6eea8ba", "patch": "@@ -43,6 +43,8 @@\n #include \"gimple-iterator.h\"\n #include \"case-cfn-macros.h\"\n #include \"emit-rtl.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n #define v8qi_UP  E_V8QImode\n #define v4hi_UP  E_V4HImode\n@@ -639,18 +641,12 @@ aarch64_mangle_builtin_scalar_type (const_tree type)\n static const char *\n aarch64_mangle_builtin_vector_type (const_tree type)\n {\n-  int i;\n-  int nelts = sizeof (aarch64_simd_types) / sizeof (aarch64_simd_types[0]);\n-\n-  for (i = 0; i < nelts; i++)\n-    if (aarch64_simd_types[i].mode ==  TYPE_MODE (type)\n-\t&& TYPE_NAME (type)\n-\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t&& DECL_NAME (TYPE_NAME (type))\n-\t&& !strcmp\n-\t     (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n-\t      aarch64_simd_types[i].name))\n-      return aarch64_simd_types[i].mangle;\n+  tree attrs = TYPE_ATTRIBUTES (type);\n+  if (tree attr = lookup_attribute (\"Advanced SIMD type\", attrs))\n+    {\n+      tree mangled_name = TREE_VALUE (TREE_VALUE (attr));\n+      return IDENTIFIER_POINTER (mangled_name);\n+    }\n \n   return NULL;\n }\n@@ -802,10 +798,16 @@ aarch64_init_simd_builtin_types (void)\n \n       if (aarch64_simd_types[i].itype == NULL)\n \t{\n-\t  aarch64_simd_types[i].itype\n-\t    = build_distinct_type_copy\n-\t      (build_vector_type (eltype, GET_MODE_NUNITS (mode)));\n-\t  SET_TYPE_STRUCTURAL_EQUALITY (aarch64_simd_types[i].itype);\n+\t  tree type = build_vector_type (eltype, GET_MODE_NUNITS (mode));\n+\t  type = build_distinct_type_copy (type);\n+\t  SET_TYPE_STRUCTURAL_EQUALITY (type);\n+\n+\t  tree mangled_name = get_identifier (aarch64_simd_types[i].mangle);\n+\t  tree value = tree_cons (NULL_TREE, mangled_name, NULL_TREE);\n+\t  TYPE_ATTRIBUTES (type)\n+\t    = tree_cons (get_identifier (\"Advanced SIMD type\"), value,\n+\t\t\t TYPE_ATTRIBUTES (type));\n+\t  aarch64_simd_types[i].itype = type;\n \t}\n \n       tdecl = add_builtin_type (aarch64_simd_types[i].name,"}, {"sha": "57988f9330bc98321a086d90f9e3e2e1420f0ddb", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=31427b974ed7b7dd54e28fec595e731bf6eea8ba", "patch": "@@ -1429,6 +1429,7 @@ static const struct attribute_spec aarch64_attribute_table[] =\n   { \"arm_sve_vector_bits\", 1, 1, false, true,  false, true,\n \t\t\t  aarch64_sve::handle_arm_sve_vector_bits_attribute,\n \t\t\t  NULL },\n+  { \"Advanced SIMD type\", 1, 1, false, true,  false, true,  NULL, NULL },\n   { \"SVE type\",\t\t  3, 3, false, true,  false, true,  NULL, NULL },\n   { \"SVE sizeless type\",  0, 0, false, true,  false, true,  NULL, NULL },\n   { NULL,                 0, 0, false, false, false, false, NULL, NULL }\n@@ -22721,8 +22722,18 @@ aarch64_simd_clone_usable (struct cgraph_node *node)\n static int\n aarch64_comp_type_attributes (const_tree type1, const_tree type2)\n {\n-  if (lookup_attribute (\"aarch64_vector_pcs\", TYPE_ATTRIBUTES (type1))\n-      != lookup_attribute (\"aarch64_vector_pcs\", TYPE_ATTRIBUTES (type2)))\n+  auto check_attr = [&](const char *name) {\n+    tree attr1 = lookup_attribute (name, TYPE_ATTRIBUTES (type1));\n+    tree attr2 = lookup_attribute (name, TYPE_ATTRIBUTES (type2));\n+    if (!attr1 && !attr2)\n+      return true;\n+\n+    return attr1 && attr2 && attribute_value_equal (attr1, attr2);\n+  };\n+\n+  if (!check_attr (\"aarch64_vector_pcs\"))\n+    return 0;\n+  if (!check_attr (\"Advanced SIMD type\"))\n     return 0;\n   return 1;\n }"}, {"sha": "ddd69b8b0da489297a47a26354ca9e8eb512730e", "filename": "gcc/testsuite/g++.target/aarch64/pr95726.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr95726.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31427b974ed7b7dd54e28fec595e731bf6eea8ba/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr95726.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Faarch64%2Fpr95726.C?ref=31427b974ed7b7dd54e28fec595e731bf6eea8ba", "patch": "@@ -0,0 +1,46 @@\n+#include <arm_neon.h>\n+\n+typedef float vecf __attribute__((vector_size(16)));\n+\n+// This assertion must hold: vecf and float32x4_t have distinct identities\n+// and mangle differently, so they are not interchangeable.\n+template<typename T> struct bar;\n+template<> struct bar<vecf> { static const int x = 1; };\n+template<> struct bar<float32x4_t> { static const int x = 2; };\n+static_assert(bar<vecf>::x + bar<float32x4_t>::x == 3, \"boo\");\n+\n+// GCC 10.1 and earlier accepted this.  However, the rule should be\n+// that GNU vectors and Advanced SIMD vectors are distinct types but\n+// that each one implicitly converts to the other.  The types are not\n+// reference-compatible.\n+//\n+// The behavior tested below is consistent with Clang.\n+vecf x;\n+float32x4_t y;\n+float32x4_t &z = x; // { dg-error {cannot bind non-const lvalue reference} }\n+\n+// These assignment must be valid even in the strictest mode: vecf must\n+// implicitly convert to float32x4_t and vice versa.\n+void foo() { x = y; y = x; }\n+\n+// Previously GCC accepted this and took the type of \"d\" from the \"then\" arm.\n+// It therefore mangled the functions as:\n+//\n+//   _Z4sel1bRDv4_f\n+//   _Z4sel2bR13__Float32x4_t\n+//\n+// Clang currently also accepts it and takes the type of \"d\" from the\n+// \"else\" arm.  It therefore mangles the functions as follows, which is\n+// inconsistent with the old GCC behavior:\n+//\n+//   _Z4sel1b13__Float32x4_t\n+//   _Z4sel2bDv4_f\n+//\n+// Given that the types have distinct identities and that each one\n+// implicitly converts to the other (see above), the expression ought\n+// to be rejected as invalid.  This is consistent (by analogy) with the\n+// standard C++ handling of conditional expressions involving class types,\n+// in cases where the \"then\" value implicitly converts to the \"else\" type\n+// and the \"else\" value implicitly converts to the \"then\" type.\n+auto sel1(bool c, decltype(c ? x : y) d) { return d; } // { dg-error {operands to '\\?:' have different types} }\n+auto sel2(bool c, decltype(c ? y : x) d) { return d; } // { dg-error {operands to '\\?:' have different types} }"}]}