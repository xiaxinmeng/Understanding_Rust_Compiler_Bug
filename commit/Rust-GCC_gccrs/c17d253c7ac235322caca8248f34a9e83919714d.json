{"sha": "c17d253c7ac235322caca8248f34a9e83919714d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE3ZDI1M2M3YWMyMzUzMjJjYWNhODI0OGYzNGE5ZTgzOTE5NzE0ZA==", "commit": {"author": {"name": "Andi Kleen", "email": "ak@linux.intel.com", "date": "2011-10-04T14:12:37Z"}, "committer": {"name": "Andi Kleen", "email": "ak@gcc.gnu.org", "date": "2011-10-04T14:12:37Z"}, "message": "Maintain order of LTO sections\n\nCurrently when reading in LTO sections from ld -r files they can\nget randomly reordered based on hash tables and random IDs.\nThis causes reordering later when the final code is generated and\nalso makes crashes harder to reproduce.\n\nThis patch maintains explicit lists based on the input order and uses\nthose lists to preserve that order when starting the rest of the\nLTO passes.\n\nThis is the first step to working -fno-toplevel-reorder for\nLTO. But this needs more changes because the LTO partitioner\ncan still reorder.\n\nThis add two lists: one for the section and another one for\nthe file_decl_datas. This is needed because the sections are\nwalked twice through different data structures.\n\nIn addition some code becomes slightly cleaner because we don't need\nto pass state through abstract callbacks anymore, but\ncan just use direct type safe calls.\n\ngcc/lto/:\n\n2011-10-02   Andi Kleen <ak@linux.intel.com>\n\n\t* lto-object.c (lto_obj_add_section_data): Add list.\n\t(lto_obj_add_section): Fill in list.\n\t(ltoobj_build_section_table): Pass through list.\n\t* lto.c (file_data_list): Declare.\n\t(create_subid_section_table): Pass arguments directly.\n\tFill in list of file_datas.\n\t(lwstate): Delete.\n\t(lto_create_files_from_ids): Pass in direct arguments.\n\tDon't maintain list.\n\t(lto_file_read): Use explicit section and file data lists.\n\t(lto_read_all_file_options): Pass in section_list.\n\t* lto.h (lto_obj_build_section_table): Add list.\n\t(lto_section_slot): Add next.\n\t(lto_section_list): Declare.\n\nFrom-SVN: r179505", "tree": {"sha": "8e13f5db02816ade11570d10b3d459b2c9b7e71d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e13f5db02816ade11570d10b3d459b2c9b7e71d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c17d253c7ac235322caca8248f34a9e83919714d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17d253c7ac235322caca8248f34a9e83919714d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c17d253c7ac235322caca8248f34a9e83919714d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17d253c7ac235322caca8248f34a9e83919714d/comments", "author": null, "committer": null, "parents": [{"sha": "0d9bbe5476d3b2bb2815c8b3ec77fae607243511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d9bbe5476d3b2bb2815c8b3ec77fae607243511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d9bbe5476d3b2bb2815c8b3ec77fae607243511"}], "stats": {"total": 114, "additions": 78, "deletions": 36}, "files": [{"sha": "1f203a1a1b3ae25e2b04bb9296c1a3019bca1775", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=c17d253c7ac235322caca8248f34a9e83919714d", "patch": "@@ -1,3 +1,20 @@\n+2011-10-02   Andi Kleen <ak@linux.intel.com>\n+\n+\t* lto-object.c (lto_obj_add_section_data): Add list.\n+\t(lto_obj_add_section): Fill in list.\n+\t(ltoobj_build_section_table): Pass through list.\n+\t* lto.c (file_data_list): Declare.\n+\t(create_subid_section_table): Pass arguments directly.\n+\tFill in list of file_datas.\n+\t(lwstate): Delete.\n+\t(lto_create_files_from_ids): Pass in direct arguments.\n+\tDon't maintain list.\n+\t(lto_file_read): Use explicit section and file data lists.\n+\t(lto_read_all_file_options): Pass in section_list.\n+\t* lto.h (lto_obj_build_section_table): Add list.\n+\t(lto_section_slot): Add next.\n+\t(lto_section_list): Declare.\n+\n 2011-10-02  Jan Hubicka  <jh@suse.cz>\n \n \tPR lto/47247"}, {"sha": "daf3bd002a32a6781b2e9a3a219bf71d84d0cd58", "filename": "gcc/lto/lto-object.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-object.c?ref=c17d253c7ac235322caca8248f34a9e83919714d", "patch": "@@ -204,6 +204,8 @@ struct lto_obj_add_section_data\n   htab_t section_hash_table;\n   /* The offset of this file.  */\n   off_t base_offset;\n+  /* List in linker order */\n+  struct lto_section_list *list;\n };\n \n /* This is called for each section in the file.  */\n@@ -218,6 +220,7 @@ lto_obj_add_section (void *data, const char *name, off_t offset,\n   char *new_name;\n   struct lto_section_slot s_slot;\n   void **slot;\n+  struct lto_section_list *list = loasd->list;\n \n   if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n \t       strlen (LTO_SECTION_NAME_PREFIX)) != 0)\n@@ -228,12 +231,21 @@ lto_obj_add_section (void *data, const char *name, off_t offset,\n   slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n   if (*slot == NULL)\n     {\n-      struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n+      struct lto_section_slot *new_slot = XCNEW (struct lto_section_slot);\n \n       new_slot->name = new_name;\n       new_slot->start = loasd->base_offset + offset;\n       new_slot->len = length;\n       *slot = new_slot;\n+\n+      if (list != NULL)\n+        {\n+          if (!list->first)\n+            list->first = new_slot;\n+          if (list->last)\n+            list->last->next = new_slot;\n+          list->last = new_slot;\n+        }\n     }\n   else\n     {\n@@ -248,7 +260,7 @@ lto_obj_add_section (void *data, const char *name, off_t offset,\n    the start and size of each section in the .o file.  */\n \n htab_t\n-lto_obj_build_section_table (lto_file *lto_file)\n+lto_obj_build_section_table (lto_file *lto_file, struct lto_section_list *list)\n {\n   struct lto_simple_object *lo = (struct lto_simple_object *) lto_file;\n   htab_t section_hash_table;\n@@ -261,6 +273,7 @@ lto_obj_build_section_table (lto_file *lto_file)\n   gcc_assert (lo->sobj_r != NULL && lo->sobj_w == NULL);\n   loasd.section_hash_table = section_hash_table;\n   loasd.base_offset = lo->base.offset;\n+  loasd.list = list;\n   errmsg = simple_object_find_sections (lo->sobj_r, lto_obj_add_section,\n \t\t\t\t\t&loasd, &err);\n   if (errmsg != NULL)"}, {"sha": "a77eeb48c55505fdb99c5b22b854dff1571a8333", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=c17d253c7ac235322caca8248f34a9e83919714d", "patch": "@@ -1052,6 +1052,12 @@ lto_resolution_read (splay_tree file_ids, FILE *resolution, lto_file *file)\n     }\n }\n \n+/* List of file_decl_datas */\n+struct file_data_list\n+  {\n+    struct lto_file_decl_data *first, *last;\n+  };\n+\n /* Is the name for a id'ed LTO section? */\n \n static int \n@@ -1068,11 +1074,10 @@ lto_section_with_id (const char *name, unsigned HOST_WIDE_INT *id)\n /* Create file_data of each sub file id */\n \n static int \n-create_subid_section_table (void **slot, void *data)\n+create_subid_section_table (struct lto_section_slot *ls, splay_tree file_ids,\n+                            struct file_data_list *list)\n {\n   struct lto_section_slot s_slot, *new_slot;\n-  struct lto_section_slot *ls = *(struct lto_section_slot **)slot;\n-  splay_tree file_ids = (splay_tree)data;\n   unsigned HOST_WIDE_INT id;\n   splay_tree_node nd;\n   void **hash_slot;\n@@ -1095,6 +1100,13 @@ create_subid_section_table (void **slot, void *data)\n       file_data->id = id;\n       file_data->section_hash_table = lto_obj_create_section_hash_table ();;\n       lto_splay_tree_insert (file_ids, id, file_data);\n+\n+      /* Maintain list in linker order */\n+      if (!list->first)\n+        list->first = file_data;\n+      if (list->last)\n+        list->last->next = file_data;\n+      list->last = file_data;\n     }\n \n   /* Copy section into sub module hash table */\n@@ -1129,27 +1141,17 @@ lto_file_finalize (struct lto_file_decl_data *file_data, lto_file *file)\n   lto_free_section_data (file_data, LTO_section_decls, NULL, data, len);\n }\n \n-struct lwstate\n-{\n-  lto_file *file;\n-  struct lto_file_decl_data **file_data;\n-  int *count;\n-};\n-\n-/* Traverse ids and create a list of file_datas out of it. */      \n+/* Finalize FILE_DATA in FILE and increase COUNT. */\n \n-static int lto_create_files_from_ids (splay_tree_node node, void *data)\n+static int \n+lto_create_files_from_ids (lto_file *file, struct lto_file_decl_data *file_data, \n+\t\t\t   int *count)\n {\n-  struct lwstate *lw = (struct lwstate *)data;\n-  struct lto_file_decl_data *file_data = (struct lto_file_decl_data *)node->value;\n-\n-  lto_file_finalize (file_data, lw->file);\n+  lto_file_finalize (file_data, file);\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"Creating file %s with sub id \" HOST_WIDE_INT_PRINT_HEX \"\\n\", \n \t     file_data->file_name, file_data->id);\n-  file_data->next = *lw->file_data;\n-  *lw->file_data = file_data;\n-  (*lw->count)++;\n+  (*count)++;\n   return 0;\n }\n \n@@ -1166,29 +1168,31 @@ lto_file_read (lto_file *file, FILE *resolution_file, int *count)\n   struct lto_file_decl_data *file_data = NULL;\n   splay_tree file_ids;\n   htab_t section_hash_table;\n-  struct lwstate state;\n-  \n-  section_hash_table = lto_obj_build_section_table (file);\n+  struct lto_section_slot *section;\n+  struct file_data_list file_list;\n+  struct lto_section_list section_list;\n+ \n+  memset (&section_list, 0, sizeof (struct lto_section_list)); \n+  section_hash_table = lto_obj_build_section_table (file, &section_list);\n \n   /* Find all sub modules in the object and put their sections into new hash\n      tables in a splay tree. */\n   file_ids = lto_splay_tree_new ();\n-  htab_traverse (section_hash_table, create_subid_section_table, file_ids);\n-  \n+  memset (&file_list, 0, sizeof (struct file_data_list));\n+  for (section = section_list.first; section != NULL; section = section->next)\n+    create_subid_section_table (section, file_ids, &file_list);\n+\n   /* Add resolutions to file ids */\n   lto_resolution_read (file_ids, resolution_file, file);\n \n-  /* Finalize each lto file for each submodule in the merged object\n-     and create list for returning. */\n-  state.file = file;\n-  state.file_data = &file_data;\n-  state.count = count;\n-  splay_tree_foreach (file_ids, lto_create_files_from_ids, &state);\n-    \n+  /* Finalize each lto file for each submodule in the merged object */\n+  for (file_data = file_list.first; file_data != NULL; file_data = file_data->next)\n+    lto_create_files_from_ids (file, file_data, count);\n+ \n   splay_tree_delete (file_ids);\n   htab_delete (section_hash_table);\n \n-  return file_data;\n+  return file_list.first;\n }\n \n #if HAVE_MMAP_FILE && HAVE_SYSCONF && defined _SC_PAGE_SIZE\n@@ -2427,7 +2431,7 @@ lto_read_all_file_options (void)\n \n       file_data = XCNEW (struct lto_file_decl_data);\n       file_data->file_name = file->filename;\n-      file_data->section_hash_table = lto_obj_build_section_table (file);\n+      file_data->section_hash_table = lto_obj_build_section_table (file, NULL);\n \n       lto_read_file_options (file_data);\n "}, {"sha": "43fcca649ea6ef6bb79e3745ad6cf769bcef58ec", "filename": "gcc/lto/lto.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17d253c7ac235322caca8248f34a9e83919714d/gcc%2Flto%2Flto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.h?ref=c17d253c7ac235322caca8248f34a9e83919714d", "patch": "@@ -43,7 +43,8 @@ extern void lto_read_all_file_options (void);\n /* In lto-elf.c or lto-coff.c  */\n extern lto_file *lto_obj_file_open (const char *filename, bool writable);\n extern void lto_obj_file_close (lto_file *file);\n-extern htab_t lto_obj_build_section_table (lto_file *file);\n+struct lto_section_list;\n+extern htab_t lto_obj_build_section_table (lto_file *file, struct lto_section_list *list);\n extern htab_t lto_obj_create_section_hash_table (void);\n extern void lto_obj_begin_section (const char *name);\n extern void lto_obj_append_data (const void *data, size_t len, void *block);\n@@ -58,6 +59,13 @@ struct lto_section_slot\n   const char *name;\n   intptr_t start;\n   size_t len;\n+  struct lto_section_slot *next;\n+};\n+\n+/* A list of section slots */\n+struct lto_section_list\n+{\n+  struct lto_section_slot *first, *last;\n };\n \n int64_t lto_parse_hex (const char *p);"}]}