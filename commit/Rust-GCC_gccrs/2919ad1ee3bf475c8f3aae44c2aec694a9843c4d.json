{"sha": "2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjkxOWFkMWVlM2JmNDc1YzhmM2FhZTQ0YzJhZWM2OTRhOTg0M2M0ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T16:44:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T16:44:43Z"}, "message": "libgo: build roots index to speed up bulkBarrierPreWrite\n    \n    To reduce the amount of time spent in write barrier processing\n    (specifically runtime.bulkBarrierPreWrite), add support for building a\n    'GC roots index', basically a sorted list of all roots, so as to\n    allow more efficient lookups of gcdata structures for globals. The\n    previous implementation worked on the raw (unsorted) roots list\n    itself, which did not scale well.\n    \n    Reviewed-on: https://go-review.googlesource.com/132595\n\nFrom-SVN: r264276", "tree": {"sha": "cf54f17b22cc8d27bc1149aa3f7b310f13749579", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf54f17b22cc8d27bc1149aa3f7b310f13749579"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/comments", "author": null, "committer": null, "parents": [{"sha": "16ddcc28b5b1984d4ab51be4fb5e5b3870b21c89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16ddcc28b5b1984d4ab51be4fb5e5b3870b21c89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16ddcc28b5b1984d4ab51be4fb5e5b3870b21c89"}], "stats": {"total": 148, "additions": 125, "deletions": 23}, "files": [{"sha": "ca47d87b427d682d237db0b7823d5b3789906d00", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -1,4 +1,4 @@\n-acf852f838e6b99f907d84648be853fa2c374393\n+70bd9801911f8ed27df410d36a928166c37a68fd\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "dd6733fab8bd341b5c6cee659ce9be5f574c9436", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -1535,7 +1535,8 @@ Gogo::write_globals()\n \t      // Avoid putting runtime.gcRoots itself on the list.\n \t      if (this->compiling_runtime()\n \t\t  && this->package_name() == \"runtime\"\n-\t\t  && Gogo::unpack_hidden_name(no->name()) == \"gcRoots\")\n+\t\t  && (Gogo::unpack_hidden_name(no->name()) == \"gcRoots\"\n+                   || Gogo::unpack_hidden_name(no->name()) == \"gcRootsIndex\"))\n \t\t;\n \t      else\n \t\tvar_gc.push_back(no);"}, {"sha": "67b2bce7eb625ac1a5d00d5851b8569456a834ad", "filename": "libgo/go/runtime/cgocall.go", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fcgocall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fcgocall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fcgocall.go?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -243,17 +243,21 @@ func cgoCheckUnknownPointer(p unsafe.Pointer, msg string) (base, i uintptr) {\n \t\treturn\n \t}\n \n-\troots := gcRoots\n-\tfor roots != nil {\n-\t\tfor j := 0; j < roots.count; j++ {\n-\t\t\tpr := roots.roots[j]\n-\t\t\taddr := uintptr(pr.decl)\n-\t\t\tif cgoInRange(p, addr, addr+pr.size) {\n-\t\t\t\tcgoCheckBits(pr.decl, pr.gcdata, 0, pr.ptrdata)\n-\t\t\t\treturn\n-\t\t\t}\n+\tlo := 0\n+\thi := len(gcRootsIndex)\n+\tfor lo < hi {\n+\t\tm := lo + (hi-lo)/2\n+\t\tpr := gcRootsIndex[m]\n+\t\taddr := uintptr(pr.decl)\n+\t\tif cgoInRange(p, addr, addr+pr.size) {\n+\t\t\tcgoCheckBits(pr.decl, pr.gcdata, 0, pr.ptrdata)\n+\t\t\treturn\n+\t\t}\n+\t\tif uintptr(p) < addr {\n+\t\t\thi = m\n+\t\t} else {\n+\t\t\tlo = m + 1\n \t\t}\n-\t\troots = roots.next\n \t}\n \n \treturn"}, {"sha": "c6c8e6a3da8dc3b14b545b4acbd246443fc8c694", "filename": "libgo/go/runtime/mbitmap.go", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fmbitmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmbitmap.go?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -575,19 +575,23 @@ func bulkBarrierPreWrite(dst, src, size uintptr) {\n \tif !inheap(dst) {\n \t\t// If dst is a global, use the data or BSS bitmaps to\n \t\t// execute write barriers.\n-\t\troots := gcRoots\n-\t\tfor roots != nil {\n-\t\t\tfor i := 0; i < roots.count; i++ {\n-\t\t\t\tpr := roots.roots[i]\n-\t\t\t\taddr := uintptr(pr.decl)\n-\t\t\t\tif addr <= dst && dst < addr+pr.size {\n-\t\t\t\t\tif dst < addr+pr.ptrdata {\n-\t\t\t\t\t\tbulkBarrierBitmap(dst, src, size, dst-addr, pr.gcdata)\n-\t\t\t\t\t}\n-\t\t\t\t\treturn\n+\t\tlo := 0\n+\t\thi := len(gcRootsIndex)\n+\t\tfor lo < hi {\n+\t\t\tm := lo + (hi-lo)/2\n+\t\t\tpr := gcRootsIndex[m]\n+\t\t\taddr := uintptr(pr.decl)\n+\t\t\tif addr <= dst && dst < addr+pr.size {\n+\t\t\t\tif dst < addr+pr.ptrdata {\n+\t\t\t\t\tbulkBarrierBitmap(dst, src, size, dst-addr, pr.gcdata)\n \t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tif dst < addr {\n+\t\t\t\thi = m\n+\t\t\t} else {\n+\t\t\t\tlo = m + 1\n \t\t\t}\n-\t\t\troots = roots.next\n \t\t}\n \t\treturn\n \t}"}, {"sha": "cf7780c37f4cfe47f3b25c93fd06df12fa0bf9e1", "filename": "libgo/go/runtime/mgc_gccgo.go", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgc_gccgo.go?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -12,6 +12,7 @@ import (\n )\n \n // gcRoot is a single GC root: a variable plus a ptrmask.\n+//go:notinheap\n type gcRoot struct {\n \tdecl    unsafe.Pointer // Pointer to variable.\n \tsize    uintptr        // Size of variable.\n@@ -32,6 +33,97 @@ type gcRootList struct {\n // The compiler keeps this variable itself off the list.\n var gcRoots *gcRootList\n \n+// Slice containing pointers to all reachable gcRoot's sorted by\n+// starting address (generated at init time from 'gcRoots').\n+// The compiler also keeps this variable itself off the list.\n+// The storage backing this slice is allocated via persistentalloc(), the\n+// idea being that we don't want to treat the slice itself as a global\n+// variable, since it points to things that don't need to be scanned\n+// themselves.\n+var gcRootsIndex []*gcRoot\n+\n+// rootradixsort performs an in-place radix sort of the 'arr' rootptr slice.\n+// Note: not a stable sort, however we expect it to be called only on slices\n+// with no duplicate entries, so this should not matter.\n+func rootradixsort(arr []*gcRoot, lo, hi int, bit uint) {\n+\t// Partition the array into two bins based on the values at the\n+\t// specified bit position: 0's bin (grown from the left) and and\n+\t// 1's bin (grown from the right). We keep two boundary markers,\n+\t// the 0's boundary \"zbb\" (which grows to the right) and the 1's\n+\t// boundary \"obb\" (which grows to the left). At each step we\n+\t// examine the bit for the right-of-ZBB element: if it is zero, we\n+\t// leave it in place and move the ZBB to the right. If the bit is\n+\t// not zero, then we swap the ZBB and OBB elements and move the\n+\t// OBB to the left. When this is done, the two partitions are then\n+\t// sorted using the next lower bit.\n+\n+\t// 0's bin boundary, initially set to before the first element\n+\tzbb := lo - 1\n+\t// 1's bin boundary, set to just beyond the last element\n+\tobb := hi + 1\n+\t// mask to pick up bit of interest\n+\tbmask := uintptr(1) << bit\n+\n+\tfor obb-zbb > 1 {\n+\t\tzbbval := uintptr(arr[zbb+1].decl) & bmask\n+\t\tif zbbval == 0 {\n+\t\t\t// Move zbb one to the right\n+\t\t\tzbb++\n+\t\t} else {\n+\t\t\t// Move obb one to the left and swap\n+\t\t\tarr[obb-1], arr[zbb+1] = arr[zbb+1], arr[obb-1]\n+\t\t\tobb--\n+\t\t}\n+\t}\n+\n+\tif bit != 0 {\n+\t\t// NB: in most cases there is just a single partition to visit\n+\t\t// so if we wanted to reduce stack space we could check for this\n+\t\t// and insert a goto back up to the top.\n+\t\tif zbb-lo > 0 {\n+\t\t\trootradixsort(arr, lo, zbb, bit-1)\n+\t\t}\n+\t\tif hi-obb > 0 {\n+\t\t\trootradixsort(arr, obb, hi, bit-1)\n+\t\t}\n+\t}\n+}\n+\n+//go:nowritebarrier\n+func createGcRootsIndex() {\n+\t// Count roots\n+\tnroots := 0\n+\tgcr := gcRoots\n+\tfor gcr != nil {\n+\t\tnroots += gcr.count\n+\t\tgcr = gcr.next\n+\t}\n+\n+\t// Construct the gcRootsIndex slice. Use non-heap storage for the array\n+\t// backing the slice.\n+\tsp := (*notInHeapSlice)(unsafe.Pointer(&gcRootsIndex))\n+\tsp.array = (*notInHeap)(persistentalloc1(sys.PtrSize*uintptr(nroots), sys.PtrSize, &memstats.other_sys))\n+\tif sp.array == nil {\n+\t\tthrow(\"runtime: cannot allocate memory\")\n+\t}\n+\tsp.len = nroots\n+\tsp.cap = nroots\n+\n+\t// Populate the roots index slice\n+\tgcr = gcRoots\n+\tk := 0\n+\tfor gcr != nil {\n+\t\tfor i := 0; i < gcr.count; i++ {\n+\t\t\tgcRootsIndex[k] = &gcr.roots[i]\n+\t\t\tk++\n+\t\t}\n+\t\tgcr = gcr.next\n+\t}\n+\n+\t// Sort it by starting address.\n+\trootradixsort(gcRootsIndex, 0, nroots-1, sys.PtrSize*8-1)\n+}\n+\n // registerGCRoots is called by compiler-generated code.\n //go:linkname registerGCRoots runtime.registerGCRoots\n "}, {"sha": "74325e3974b8f55c8d80ed3c8cc08feb9ab87006", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2919ad1ee3bf475c8f3aae44c2aec694a9843c4d/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=2919ad1ee3bf475c8f3aae44c2aec694a9843c4d", "patch": "@@ -207,6 +207,7 @@ func main() {\n \n \tfn := main_init // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime\n \tfn()\n+\tcreateGcRootsIndex()\n \tclose(main_init_done)\n \n \tneedUnlock = false"}]}