{"sha": "dd42e13519fd78d873e5aeb4528162a499a299eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ0MmUxMzUxOWZkNzhkODczZTVhZWI0NTI4MTYyYTQ5OWEyOTllYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-12T20:56:15Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-12T20:56:15Z"}, "message": "cp-tree.h (dfs_skip_vbases): New function.\n\n\t* cp-tree.h (dfs_skip_vbases): New function.\n\t(find_vbase_instance): Likewise.\n\t* class.c (determine_primary_base): Allow a nearly empty base to\n\tserve as a primary base class under the new ABI.\n\t(get_class_offset_1): Rename to ...\n\t(dfs_get_class_offset): ... this.  Simplify.  Don't issue error\n\tmessages here.\n\t(get_class_offset): Use it.  Issue error messages here.\n\t(dfs_modify_vtables): Rely on dfs_unmarked_real_bases_queue_p to\n\tfind the right copies of virtual bases.\n\t(fixup_vtable_deltas1): Rename to ...\n\t(dfs_fixup_vtable_deltas): ... this.  Adjust to handle virtual\n\tbases as primary bases.\n\t(fixup_vtable_deltas): Remove.\n\t(override_one_vtable): Handle virtual bases as primary bases.\n\t(merge_overrides): Likewise.\n\t(finish_struct_1): Likewise.\n\t(dump_class_hierarchy): Dump primary-ness of bases as well.\n\t* search.c (mark_primary_bases): Use a pre-order traversal to\n\thandle primary virtual bases.\n\t(dfs_skip_vbases): New fiunction.\n\t(expand_upcast_fixups): Adjust to handle primary virtual bases.\n\t(fixup_virtual_upcast_offsets): Likewise.\n\t(fixup_all_virtual_upcast_offsets): Likewise.\n\t(dfs_find_vbase_instances): New function.\n\t(find_vbase_instance): Likewise.\n\nFrom-SVN: r31360", "tree": {"sha": "46c58bf1306e54ccc104249e3c6967c9fa1e82aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46c58bf1306e54ccc104249e3c6967c9fa1e82aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd42e13519fd78d873e5aeb4528162a499a299eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd42e13519fd78d873e5aeb4528162a499a299eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd42e13519fd78d873e5aeb4528162a499a299eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd42e13519fd78d873e5aeb4528162a499a299eb/comments", "author": null, "committer": null, "parents": [{"sha": "e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2"}], "stats": {"total": 295, "additions": 231, "deletions": 64}, "files": [{"sha": "89b74005ce0f57bf34d0670773087dda67d58098", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=dd42e13519fd78d873e5aeb4528162a499a299eb", "patch": "@@ -1,3 +1,32 @@\n+2000-01-12  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (dfs_skip_vbases): New function.\n+\t(find_vbase_instance): Likewise.\n+\t* class.c (determine_primary_base): Allow a nearly empty base to\n+\tserve as a primary base class under the new ABI.\n+\t(get_class_offset_1): Rename to ...\n+\t(dfs_get_class_offset): ... this.  Simplify.  Don't issue error\n+\tmessages here.\n+\t(get_class_offset): Use it.  Issue error messages here.\n+\t(dfs_modify_vtables): Rely on dfs_unmarked_real_bases_queue_p to\n+\tfind the right copies of virtual bases.\n+\t(fixup_vtable_deltas1): Rename to ...\n+\t(dfs_fixup_vtable_deltas): ... this.  Adjust to handle virtual\n+\tbases as primary bases.\n+\t(fixup_vtable_deltas): Remove.\n+\t(override_one_vtable): Handle virtual bases as primary bases.\n+\t(merge_overrides): Likewise.\n+\t(finish_struct_1): Likewise.\n+\t(dump_class_hierarchy): Dump primary-ness of bases as well.\n+\t* search.c (mark_primary_bases): Use a pre-order traversal to\n+\thandle primary virtual bases.\n+\t(dfs_skip_vbases): New fiunction.\n+\t(expand_upcast_fixups): Adjust to handle primary virtual bases.\n+\t(fixup_virtual_upcast_offsets): Likewise.\n+\t(fixup_all_virtual_upcast_offsets): Likewise.\n+\t(dfs_find_vbase_instances): New function.\n+\t(find_vbase_instance): Likewise.\n+\t\n 2000-01-11  Mumit Khan  <khan@xraylith.wisc.edu>\n \n \t* lex.c (DIR_SEPARATOR): Delete macro."}, {"sha": "7d9ab931ee73b41b4e6c91e18155b2c6c4188272", "filename": "gcc/cp/class.c", "status": "modified", "additions": 126, "deletions": 56, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dd42e13519fd78d873e5aeb4528162a499a299eb", "patch": "@@ -82,8 +82,7 @@ static tree get_basefndecls PROTO((tree, tree));\n static void set_rtti_entry PROTO((tree, tree, tree));\n static void build_vtable PROTO((tree, tree));\n static void prepare_fresh_vtable PROTO((tree, tree));\n-static void fixup_vtable_deltas1 PROTO((tree, tree));\n-static void fixup_vtable_deltas PROTO((tree, int, tree));\n+static tree dfs_fixup_vtable_deltas PROTO((tree, void *));\n static tree dfs_finish_vtbls PROTO((tree, void *));\n static void finish_vtbls PROTO((tree));\n static void modify_vtable_entry PROTO((tree, tree, tree));\n@@ -100,7 +99,7 @@ static void merge_overrides PROTO((tree, tree, int, tree));\n static void override_one_vtable PROTO((tree, tree, tree));\n static void mark_overriders PROTO((tree, tree));\n static void check_for_override PROTO((tree, tree));\n-static tree get_class_offset_1 PROTO((tree, tree, tree, tree, tree));\n+static tree dfs_get_class_offset PROTO((tree, void *));\n static tree get_class_offset PROTO((tree, tree, tree, tree));\n static void modify_one_vtable PROTO((tree, tree, tree));\n static tree dfs_modify_vtables PROTO((tree, void *));\n@@ -1672,9 +1671,25 @@ determine_primary_base (t, has_virtual_p)\n   if (!TYPE_VFIELD (t))\n     CLASSTYPE_VFIELD_PARENT (t) = -1;\n \n-  /* Now that we know what the primary base class is, we can run\n-     through the entire hierarchy marking the primary bases for future\n-     reference.  */\n+  /* The new ABI allows for the use of a \"nearly-empty\" virtual base\n+     class as the primary base class if no non-virtual polymorphic\n+     base can be found.  */\n+  if (flag_new_abi && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+    for (i = 0; i < n_baseclasses; ++i)\n+      {\n+\ttree base_binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n+\ttree basetype = BINFO_TYPE (base_binfo);\n+\n+\tif (TREE_VIA_VIRTUAL (base_binfo) \n+\t    && CLASSTYPE_NEARLY_EMPTY_P (basetype))\n+\t  {\n+\t    set_primary_base (t, i, has_virtual_p);\n+\t    CLASSTYPE_VFIELDS (t) = copy_list (CLASSTYPE_VFIELDS (basetype));\n+\t    break;\n+\t  }\n+      }\n+\n+  /* Mark the primary base classes at this point.  */\n   mark_primary_bases (t);\n }\n \f\n@@ -2266,6 +2281,9 @@ overrides (fndecl, base_fndecl)\n   return 0;\n }\n \n+/* Returns the BINFO_OFFSET for the base of BINFO that has the same\n+   type as CONTEXT.  */\n+\n static tree\n get_class_offset_1 (parent, binfo, context, t, fndecl)\n      tree parent, binfo, context, t, fndecl;\n@@ -2311,14 +2329,37 @@ get_class_offset_1 (parent, binfo, context, t, fndecl)\n   return rval;\n }\n \n-/* Get the offset to the CONTEXT subobject that is related to the\n-   given BINFO.  */\n+/* Called from get_class_offset via dfs_walk.  */\n+\n+static tree\n+dfs_get_class_offset (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree list = (tree) data;\n+  tree context = TREE_TYPE (list);\n+\n+  if (same_type_p (BINFO_TYPE (binfo), context))\n+    {\n+      if (TREE_VALUE (list))\n+\treturn error_mark_node;\n+      else\n+\tTREE_VALUE (list) = BINFO_OFFSET (binfo);\n+    }\n+  \n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Returns the BINFO_OFFSET for the subobject of BINFO that has the\n+   type given by CONTEXT.  */\n \n static tree\n get_class_offset (context, t, binfo, fndecl)\n      tree context, t, binfo, fndecl;\n {\n-  tree first_binfo = binfo;\n+  tree list;\n   tree offset;\n   int i;\n \n@@ -2338,11 +2379,28 @@ get_class_offset (context, t, binfo, fndecl)\n \treturn BINFO_OFFSET (binfo);\n     }\n \n-  /* Ok, not found in the less derived binfos, now check the more\n-     derived binfos.  */\n-  offset = get_class_offset_1 (first_binfo, TYPE_BINFO (t), context, t, fndecl);\n-  if (offset==0 || TREE_CODE (offset) != INTEGER_CST)\n-    my_friendly_abort (999);\t/* we have to find it.  */\n+  list = build_tree_list (t, NULL_TREE);\n+  TREE_TYPE (list) = context;\n+  offset = dfs_walk (TYPE_BINFO (t),\n+\t\t     dfs_get_class_offset,\n+\t\t     dfs_unmarked_real_bases_queue_p,\n+\t\t     list);\n+  dfs_walk (TYPE_BINFO (t), dfs_unmark, dfs_marked_real_bases_queue_p, t);\n+\n+  if (offset == error_mark_node)\n+    {\n+      error (\"every virtual function must have a unique final overrider\");\n+      cp_error (\"  found two (or more) `%T' class subobjects in `%T'\", \n+\t\tcontext, t);\n+      cp_error (\"  with virtual `%D' from virtual base class\", fndecl);\n+      offset = integer_zero_node;\n+    }\n+  else\n+    offset = TREE_VALUE (list);\n+\n+  my_friendly_assert (offset != NULL_TREE, 999);\n+  my_friendly_assert (TREE_CODE (offset) == INTEGER_CST, 999);\n+\n   return offset;\n }\n \n@@ -2473,9 +2531,6 @@ dfs_modify_vtables (binfo, data)\n       && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n     {\n       tree list = (tree) data;\n-\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\tbinfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), TREE_PURPOSE (list));\n       modify_one_vtable (binfo, TREE_PURPOSE (list), TREE_VALUE (list)); \n     }\n \n@@ -2499,13 +2554,23 @@ modify_all_vtables (t, fndecl)\n \n /* Fixup all the delta entries in this one vtable that need updating.  */\n \n-static void\n-fixup_vtable_deltas1 (binfo, t)\n-     tree binfo, t;\n+static tree\n+dfs_fixup_vtable_deltas (binfo, data)\n+     tree binfo;\n+     void *data;\n {\n   tree virtuals;\n   unsigned HOST_WIDE_INT n;\n-  \n+  tree t = (tree) data;\n+\n+  while (BINFO_PRIMARY_MARKED_P (binfo))\n+    {\n+      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+      /* If BINFO is virtual then we'll handle this base later.  */\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\treturn NULL_TREE;\n+    }\n+\n   virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n \n   while (virtuals)\n@@ -2559,33 +2624,8 @@ fixup_vtable_deltas1 (binfo, t)\n       ++n;\n       virtuals = TREE_CHAIN (virtuals);\n     }\n-}\n-\n-/* Fixup all the delta entries in all the direct vtables that need updating.\n-   This happens when we have non-overridden virtual functions from a\n-   virtual base class, that are at a different offset, in the new\n-   hierarchy, because the layout of the virtual bases has changed.  */\n \n-static void\n-fixup_vtable_deltas (binfo, init_self, t)\n-     tree binfo;\n-     int init_self;\n-     tree t;\n-{\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n-      if (! TREE_VIA_VIRTUAL (base_binfo))\n-\tfixup_vtable_deltas (base_binfo, is_not_base_vtable, t);\n-    }\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n-    fixup_vtable_deltas1 (binfo, t);\n+  return NULL_TREE;\n }\n \n /* Here, we already know that they match in every respect.\n@@ -2622,17 +2662,36 @@ override_one_vtable (binfo, old, t)\n {\n   tree virtuals;\n   tree old_virtuals;\n+  tree orig_binfo;\n+  tree orig_virtuals;\n   enum { REUSE_NEW, REUSE_OLD, UNDECIDED, NEITHER } choose = UNDECIDED;\n \n+  /* Either or both of BINFO or OLD might be primary base classes\n+     because merge_overrides is called with a vbase from the class we\n+     are definining and the corresponding vbase from one of its direct\n+     bases.  */\n+  orig_binfo = binfo;\n+  while (BINFO_PRIMARY_MARKED_P (binfo))\n+    {\n+      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+      /* If BINFO is virtual, then we'll handle this virtual base when\n+\t later.  */\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\treturn;\n+    }\n+  while (BINFO_PRIMARY_MARKED_P (old))\n+    old = BINFO_INHERITANCE_CHAIN (old);\n+\n   /* If we have already committed to modifying it, then don't try and\n      reuse another vtable.  */\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     choose = NEITHER;\n \n   virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n   old_virtuals = skip_rtti_stuff (old, BINFO_TYPE (binfo), NULL);\n+  orig_virtuals = skip_rtti_stuff (orig_binfo, BINFO_TYPE (binfo), NULL);\n \n-  while (virtuals)\n+  while (orig_virtuals)\n     {\n       tree fndecl = TREE_VALUE (virtuals);\n       tree old_fndecl = TREE_VALUE (old_virtuals);\n@@ -2705,6 +2764,7 @@ override_one_vtable (binfo, old, t)\n \t}\n       virtuals = TREE_CHAIN (virtuals);\n       old_virtuals = TREE_CHAIN (old_virtuals);\n+      orig_virtuals = TREE_CHAIN (orig_virtuals);\n     }\n \n   /* Let's reuse the old vtable.  */\n@@ -2739,8 +2799,8 @@ merge_overrides (binfo, old, do_self, t)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       tree old_base_binfo = TREE_VEC_ELT (old_binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (binfo));\n+      int is_not_base_vtable \n+\t= !BINFO_PRIMARY_MARKED_P (base_binfo);\n       if (! TREE_VIA_VIRTUAL (base_binfo))\n \tmerge_overrides (base_binfo, old_base_binfo, is_not_base_vtable, t);\n     }\n@@ -4563,9 +4623,15 @@ finish_struct_1 (t)\n \t    vbases = CLASSTYPE_VBASECLASSES (basetype);\n \t    while (vbases)\n \t      {\n-\t\tmerge_overrides (binfo_member (BINFO_TYPE (vbases),\n-\t\t\t\t\t       CLASSTYPE_VBASECLASSES (t)),\n-\t\t\t\t vbases, 1, t);\n+\t\ttree vbase;\n+\t\ttree basetype_vbase;\n+\n+\t\tvbase \n+\t\t  = find_vbase_instance (BINFO_TYPE (vbases), t);\n+\t\tbasetype_vbase \n+\t\t  = find_vbase_instance (BINFO_TYPE (vbases), basetype);\n+\n+\t\tmerge_overrides (vbase, basetype_vbase, 1, t);\n \t\tvbases = TREE_CHAIN (vbases);\n \t      }\n \t  }\n@@ -4613,11 +4679,14 @@ finish_struct_1 (t)\n       vbases = CLASSTYPE_VBASECLASSES (t);\n       while (vbases)\n \t{\n+\t  tree vbase;\n+\n \t  /* We might be able to shorten the amount of work we do by\n \t     only doing this for vtables that come from virtual bases\n \t     that have differing offsets, but don't want to miss any\n \t     entries.  */\n-\t  fixup_vtable_deltas (vbases, 1, t);\n+\t  vbase = find_vbase_instance (BINFO_TYPE (vbases), t);\n+\t  dfs_walk (vbase, dfs_fixup_vtable_deltas, dfs_skip_vbases, t);\n \t  vbases = TREE_CHAIN (vbases);\n \t}\n     }\n@@ -6015,10 +6084,11 @@ dump_class_hierarchy (binfo, indent)\n {\n   int i;\n \n-  fprintf (stderr, \"%*s0x%x (%s) %d\\n\", indent, \"\",\n+  fprintf (stderr, \"%*s0x%x (%s) %d %s\\n\", indent, \"\",\n \t   (unsigned int) binfo,\n \t   type_as_string (binfo, TS_PLAIN),\n-\t   TREE_INT_CST_LOW (BINFO_OFFSET (binfo)));\n+\t   TREE_INT_CST_LOW (BINFO_OFFSET (binfo)),\n+\t   BINFO_PRIMARY_MARKED_P (binfo) ? \"primary\" : \"\");\n \n   for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n     dump_class_hierarchy (BINFO_BASETYPE (binfo, i), indent + 2);"}, {"sha": "88b49a0fddad62911bee5a84d0fb73facab2f0eb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dd42e13519fd78d873e5aeb4528162a499a299eb", "patch": "@@ -3954,8 +3954,10 @@ extern tree dfs_skip_nonprimary_vbases_unmarkedp PROTO((tree, void *));\n extern tree dfs_skip_nonprimary_vbases_markedp  PROTO((tree, void *));\n extern tree dfs_unmarked_real_bases_queue_p     PROTO((tree, void *));\n extern tree dfs_marked_real_bases_queue_p       PROTO((tree, void *));\n+extern tree dfs_skip_vbases                     PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n extern tree convert_pointer_to_vbase            PROTO((tree, tree));\n+extern tree find_vbase_instance                 PROTO((tree, tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "1d6efed889d813cae0010c5c99eb402c897e0f23", "filename": "gcc/cp/search.c", "status": "modified", "additions": 74, "deletions": 8, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd42e13519fd78d873e5aeb4528162a499a299eb/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=dd42e13519fd78d873e5aeb4528162a499a299eb", "patch": "@@ -151,6 +151,7 @@ static int template_self_reference_p PROTO ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PROTO ((tree, tree));\n static tree dfs_mark_primary_bases PROTO((tree, void *));\n static tree get_shared_vbase_if_not_primary PROTO((tree, tree));\n+static tree dfs_find_vbase_instance PROTO((tree, void *));\n \n /* Allocate a level of searching.  */\n \n@@ -2189,9 +2190,14 @@ mark_primary_bases (type)\n {\n   tree vbase;\n \n-  /* Mark the TYPE_BINFO hierarchy.  */\n-  dfs_walk (TYPE_BINFO (type), dfs_mark_primary_bases, \n-\t    dfs_skip_nonprimary_vbases_unmarkedp, type);\n+  /* Mark the TYPE_BINFO hierarchy.  We need to mark primary bases in\n+     pre-order to deal with primary virtual bases.  (The virtual base\n+     would be skipped if it were not marked as primary, and that\n+     requires getting to dfs_mark_primary_bases before\n+     dfs_skip_nonprimary_vbases_unmarkedp has a chance to skip the\n+     virtual base.)  */\n+  dfs_walk_real (TYPE_BINFO (type), dfs_mark_primary_bases, NULL,\n+\t\t dfs_skip_nonprimary_vbases_unmarkedp, type);\n \n   /* Now go through the virtual base classes.  Any that are not\n      already primary will need to be allocated in TYPE, and so we need\n@@ -2289,6 +2295,20 @@ dfs_marked_real_bases_queue_p (binfo, data)\n   return binfo ? markedp (binfo, NULL) : NULL_TREE;\n }\n \n+/* A queue function that skips all virtual bases (and their \n+   bases).  */\n+\n+tree\n+dfs_skip_vbases (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  if (TREE_VIA_VIRTUAL (binfo))\n+    return NULL_TREE;\n+\n+  return binfo;\n+}\n+\n /* Called via dfs_walk from dfs_get_pure_virtuals.  */\n \n static tree\n@@ -2798,7 +2818,14 @@ expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n   tree vc;\n   tree delta;\n   unsigned HOST_WIDE_INT n;\n-  \n+\n+  while (BINFO_PRIMARY_MARKED_P (binfo))\n+    {\n+      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\treturn;\n+    }\n+\n   delta = purpose_member (vbase, *vbase_offsets);\n   if (! delta)\n     {\n@@ -2925,7 +2952,7 @@ fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, ori\n       tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n       int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (real_binfo));\n+\t= !BINFO_PRIMARY_MARKED_P (real_base_binfo);\n       if (! TREE_VIA_VIRTUAL (real_base_binfo))\n \tfixup_virtual_upcast_offsets (real_base_binfo, base_binfo,\n \t\t\t\t      is_not_base_vtable, can_elide, addr,\n@@ -2979,15 +3006,17 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n \t;\n       else\n \t{\n+\t  tree vbase;\n \t  tree vbase_offsets;\n \t  tree addr;\n \n+\t  vbase = find_vbase_instance (BINFO_TYPE (vbases), type);\n \t  vbase_offsets = NULL_TREE;\n-\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), decl_ptr);\n-\t  fixup_virtual_upcast_offsets (vbases,\n+\t  addr = convert_pointer_to_vbase (BINFO_TYPE (vbases), decl_ptr);\n+\t  fixup_virtual_upcast_offsets (vbase,\n \t\t\t\t\tTYPE_BINFO (BINFO_TYPE (vbases)),\n \t\t\t\t\t1, 0, addr, decl_ptr,\n-\t\t\t\t\ttype, vbases, &vbase_offsets);\n+\t\t\t\t\ttype, vbase, &vbase_offsets);\n \t}\n     }\n \n@@ -3074,6 +3103,43 @@ get_vbase_types (type)\n   CLASSTYPE_VBASECLASSES (type) = nreverse (CLASSTYPE_VBASECLASSES (type));\n   dfs_walk (TYPE_BINFO (type), dfs_vbase_unmark, markedp, 0);\n }\n+\n+/* Called from find_vbase_instance via dfs_walk.  */\n+\n+static tree\n+dfs_find_vbase_instance (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree base = TREE_VALUE ((tree) data);\n+\n+  if (BINFO_PRIMARY_MARKED_P (binfo)\n+      && same_type_p (BINFO_TYPE (binfo), base))\n+    return binfo;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Find the real occurrence of the virtual BASE (a class type) in the\n+   hierarchy dominated by TYPE.  */\n+\n+tree\n+find_vbase_instance (base, type)\n+     tree base;\n+     tree type;\n+{\n+  tree instance;\n+\n+  instance = BINFO_FOR_VBASE (base, type);\n+  if (!BINFO_VBASE_PRIMARY_P (instance))\n+    return instance;\n+\n+  return dfs_walk (TYPE_BINFO (type), \n+\t\t   dfs_find_vbase_instance, \n+\t\t   NULL,\n+\t\t   build_tree_list (type, base));\n+}\n+\n \f\n /* Debug info for C++ classes can get very large; try to avoid\n    emitting it everywhere."}]}