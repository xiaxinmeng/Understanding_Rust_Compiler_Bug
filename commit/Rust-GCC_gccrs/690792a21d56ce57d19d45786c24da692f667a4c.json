{"sha": "690792a21d56ce57d19d45786c24da692f667a4c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkwNzkyYTIxZDU2Y2U1N2QxOWQ0NTc4NmMyNGRhNjkyZjY2N2E0Yw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-06-06T10:30:30Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-06-06T10:30:30Z"}, "message": "g-os_lib.ads, [...] (Normalize_Pathname.Get_Directory): Correct obvious bug (return Dir; instead of return Directory;).\n\n2007-04-20  Vincent Celier  <celier@adacore.com>\n\n\t* g-os_lib.ads, g-os_lib.adb (Normalize_Pathname.Get_Directory):\n\tCorrect obvious bug (return Dir; instead of return Directory;).\n\t(Normalize_Pathname): Use Reference_Dir'Length, not Reference_Dir'Last\n\nFrom-SVN: r125421", "tree": {"sha": "44e1c30954dd29543d35a6cf64a02dc1d6f03c53", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44e1c30954dd29543d35a6cf64a02dc1d6f03c53"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/690792a21d56ce57d19d45786c24da692f667a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690792a21d56ce57d19d45786c24da692f667a4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/690792a21d56ce57d19d45786c24da692f667a4c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/690792a21d56ce57d19d45786c24da692f667a4c/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "751089b2718981880ac42d7f3d6013374460729b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/751089b2718981880ac42d7f3d6013374460729b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/751089b2718981880ac42d7f3d6013374460729b"}], "stats": {"total": 3367, "additions": 9, "deletions": 3358}, "files": [{"sha": "6ed36053a544b6e45b904ace931067837f98191a", "filename": "gcc/ada/g-os_lib.adb", "status": "modified", "additions": 5, "deletions": 2541, "changes": 2546, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690792a21d56ce57d19d45786c24da692f667a4c/gcc%2Fada%2Fg-os_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690792a21d56ce57d19d45786c24da692f667a4c/gcc%2Fada%2Fg-os_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.adb?ref=690792a21d56ce57d19d45786c24da692f667a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2006, AdaCore                     --\n+--                     Copyright (C) 1995-2007, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,2544 +31,8 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Case_Util;\n-with System.CRTL;\n-with System.Soft_Links;\n-with Unchecked_Conversion;\n-with Unchecked_Deallocation;\n-with System; use System;\n+--  This package does not require a body, since it is a package renaming. We\n+--  provide a dummy file containing a No_Body pragma so that previous versions\n+--  of the body (which did exist) will not intefere.\n \n-package body GNAT.OS_Lib is\n-\n-   --  Imported procedures Dup and Dup2 are used in procedures Spawn and\n-   --  Non_Blocking_Spawn.\n-\n-   function Dup (Fd : File_Descriptor) return File_Descriptor;\n-   pragma Import (C, Dup, \"__gnat_dup\");\n-\n-   procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);\n-   pragma Import (C, Dup2, \"__gnat_dup2\");\n-\n-   On_Windows : constant Boolean := Directory_Separator = '\\';\n-   --  An indication that we are on Windows. Used in Normalize_Pathname, to\n-   --  deal with drive letters in the beginning of absolute paths.\n-\n-   package SSL renames System.Soft_Links;\n-\n-   --  The following are used by Create_Temp_File\n-\n-   First_Temp_File_Name : constant String := \"GNAT-TEMP-000000.TMP\";\n-   --  Used to initialize Current_Temp_File_Name and Temp_File_Name_Last_Digit\n-\n-   Current_Temp_File_Name : String := First_Temp_File_Name;\n-   --  Name of the temp file last created\n-\n-   Temp_File_Name_Last_Digit : constant Positive :=\n-                                 First_Temp_File_Name'Last - 4;\n-   --  Position of the last digit in Current_Temp_File_Name\n-\n-   Max_Attempts : constant := 100;\n-   --  The maximum number of attempts to create a new temp file\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   function Args_Length (Args : Argument_List) return Natural;\n-   --  Returns total number of characters needed to create a string\n-   --  of all Args terminated by ASCII.NUL characters\n-\n-   function C_String_Length (S : Address) return Integer;\n-   --  Returns the length of a C string. Does check for null address\n-   --  (returns 0).\n-\n-   procedure Spawn_Internal\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Result       : out Integer;\n-      Pid          : out Process_Id;\n-      Blocking     : Boolean);\n-   --  Internal routine to implement the two Spawn (blocking/non blocking)\n-   --  routines. If Blocking is set to True then the spawn is blocking\n-   --  otherwise it is non blocking. In this latter case the Pid contains the\n-   --  process id number. The first three parameters are as in Spawn. Note that\n-   --  Spawn_Internal normalizes the argument list before calling the low level\n-   --  system spawn routines (see Normalize_Arguments).\n-   --\n-   --  Note: Normalize_Arguments is designed to do nothing if it is called more\n-   --  than once, so calling Normalize_Arguments before calling one of the\n-   --  spawn routines is fine.\n-\n-   function To_Path_String_Access\n-     (Path_Addr : Address;\n-      Path_Len  : Integer) return String_Access;\n-   --  Converts a C String to an Ada String. We could do this making use of\n-   --  Interfaces.C.Strings but we prefer not to import that entire package\n-\n-   ---------\n-   -- \"<\" --\n-   ---------\n-\n-   function \"<\"  (X, Y : OS_Time) return Boolean is\n-   begin\n-      return Long_Integer (X) < Long_Integer (Y);\n-   end \"<\";\n-\n-   ----------\n-   -- \"<=\" --\n-   ----------\n-\n-   function \"<=\"  (X, Y : OS_Time) return Boolean is\n-   begin\n-      return Long_Integer (X) <= Long_Integer (Y);\n-   end \"<=\";\n-\n-   ---------\n-   -- \">\" --\n-   ---------\n-\n-   function \">\"  (X, Y : OS_Time) return Boolean is\n-   begin\n-      return Long_Integer (X) > Long_Integer (Y);\n-   end \">\";\n-\n-   ----------\n-   -- \">=\" --\n-   ----------\n-\n-   function \">=\"  (X, Y : OS_Time) return Boolean is\n-   begin\n-      return Long_Integer (X) >= Long_Integer (Y);\n-   end \">=\";\n-\n-   -----------------\n-   -- Args_Length --\n-   -----------------\n-\n-   function Args_Length (Args : Argument_List) return Natural is\n-      Len : Natural := 0;\n-\n-   begin\n-      for J in Args'Range loop\n-         Len := Len + Args (J)'Length + 1; --  One extra for ASCII.NUL\n-      end loop;\n-\n-      return Len;\n-   end Args_Length;\n-\n-   -----------------------------\n-   -- Argument_String_To_List --\n-   -----------------------------\n-\n-   function Argument_String_To_List\n-     (Arg_String : String) return Argument_List_Access\n-   is\n-      Max_Args : constant Integer := Arg_String'Length;\n-      New_Argv : Argument_List (1 .. Max_Args);\n-      New_Argc : Natural := 0;\n-      Idx      : Integer;\n-\n-   begin\n-      Idx := Arg_String'First;\n-\n-      loop\n-         exit when Idx > Arg_String'Last;\n-\n-         declare\n-            Quoted  : Boolean := False;\n-            Backqd  : Boolean := False;\n-            Old_Idx : Integer;\n-\n-         begin\n-            Old_Idx := Idx;\n-\n-            loop\n-               --  An unquoted space is the end of an argument\n-\n-               if not (Backqd or Quoted)\n-                 and then Arg_String (Idx) = ' '\n-               then\n-                  exit;\n-\n-               --  Start of a quoted string\n-\n-               elsif not (Backqd or Quoted)\n-                 and then Arg_String (Idx) = '\"'\n-               then\n-                  Quoted := True;\n-\n-               --  End of a quoted string and end of an argument\n-\n-               elsif (Quoted and not Backqd)\n-                 and then Arg_String (Idx) = '\"'\n-               then\n-                  Idx := Idx + 1;\n-                  exit;\n-\n-               --  Following character is backquoted\n-\n-               elsif Arg_String (Idx) = '\\' then\n-                  Backqd := True;\n-\n-               --  Turn off backquoting after advancing one character\n-\n-               elsif Backqd then\n-                  Backqd := False;\n-\n-               end if;\n-\n-               Idx := Idx + 1;\n-               exit when Idx > Arg_String'Last;\n-            end loop;\n-\n-            --  Found an argument\n-\n-            New_Argc := New_Argc + 1;\n-            New_Argv (New_Argc) :=\n-              new String'(Arg_String (Old_Idx .. Idx - 1));\n-\n-            --  Skip extraneous spaces\n-\n-            while Idx <= Arg_String'Last and then Arg_String (Idx) = ' ' loop\n-               Idx := Idx + 1;\n-            end loop;\n-         end;\n-      end loop;\n-\n-      return new Argument_List'(New_Argv (1 .. New_Argc));\n-   end Argument_String_To_List;\n-\n-   ---------------------\n-   -- C_String_Length --\n-   ---------------------\n-\n-   function C_String_Length (S : Address) return Integer is\n-      function Strlen (S : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-   begin\n-      if S = Null_Address then\n-         return 0;\n-      else\n-         return Strlen (S);\n-      end if;\n-   end C_String_Length;\n-\n-   -----------\n-   -- Close --\n-   -----------\n-\n-   procedure Close (FD : File_Descriptor) is\n-      procedure C_Close (FD : File_Descriptor);\n-      pragma Import (C, C_Close, \"close\");\n-   begin\n-      C_Close (FD);\n-   end Close;\n-\n-   procedure Close (FD : File_Descriptor; Status : out Boolean) is\n-      function C_Close (FD : File_Descriptor) return Integer;\n-      pragma Import (C, C_Close, \"close\");\n-   begin\n-      Status := (C_Close (FD) = 0);\n-   end Close;\n-\n-   ---------------\n-   -- Copy_File --\n-   ---------------\n-\n-   procedure Copy_File\n-     (Name     : String;\n-      Pathname : String;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps)\n-   is\n-      From : File_Descriptor;\n-      To   : File_Descriptor;\n-\n-      Copy_Error : exception;\n-      --  Internal exception raised to signal error in copy\n-\n-      function Build_Path (Dir : String; File : String) return String;\n-      --  Returns pathname Dir catenated with File adding the directory\n-      --  separator only if needed.\n-\n-      procedure Copy (From, To : File_Descriptor);\n-      --  Read data from From and place them into To. In both cases the\n-      --  operations uses the current file position. Raises Constraint_Error\n-      --  if a problem occurs during the copy.\n-\n-      procedure Copy_To (To_Name : String);\n-      --  Does a straight copy from source to designated destination file\n-\n-      ----------------\n-      -- Build_Path --\n-      ----------------\n-\n-      function Build_Path (Dir : String; File : String) return String is\n-         Res : String (1 .. Dir'Length + File'Length + 1);\n-\n-         Base_File_Ptr : Integer;\n-         --  The base file name is File (Base_File_Ptr + 1 .. File'Last)\n-\n-         function Is_Dirsep (C : Character) return Boolean;\n-         pragma Inline (Is_Dirsep);\n-         --  Returns True if C is a directory separator. On Windows we\n-         --  handle both styles of directory separator.\n-\n-         ---------------\n-         -- Is_Dirsep --\n-         ---------------\n-\n-         function Is_Dirsep (C : Character) return Boolean is\n-         begin\n-            return C = Directory_Separator or else C = '/';\n-         end Is_Dirsep;\n-\n-      --  Start of processing for Build_Path\n-\n-      begin\n-         --  Find base file name\n-\n-         Base_File_Ptr := File'Last;\n-         while Base_File_Ptr >= File'First loop\n-            exit when Is_Dirsep (File (Base_File_Ptr));\n-            Base_File_Ptr := Base_File_Ptr - 1;\n-         end loop;\n-\n-         declare\n-            Base_File : String renames\n-                          File (Base_File_Ptr + 1 .. File'Last);\n-\n-         begin\n-            Res (1 .. Dir'Length) := Dir;\n-\n-            if Is_Dirsep (Dir (Dir'Last)) then\n-               Res (Dir'Length + 1 .. Dir'Length + Base_File'Length) :=\n-                 Base_File;\n-               return Res (1 .. Dir'Length + Base_File'Length);\n-\n-            else\n-               Res (Dir'Length + 1) := Directory_Separator;\n-               Res (Dir'Length + 2 .. Dir'Length + 1 + Base_File'Length) :=\n-                 Base_File;\n-               return Res (1 .. Dir'Length + 1 + Base_File'Length);\n-            end if;\n-         end;\n-      end Build_Path;\n-\n-      ----------\n-      -- Copy --\n-      ----------\n-\n-      procedure Copy (From, To : File_Descriptor) is\n-         Buf_Size : constant := 200_000;\n-         type Buf is array (1 .. Buf_Size) of Character;\n-         type Buf_Ptr is access Buf;\n-\n-         Buffer : Buf_Ptr;\n-         R      : Integer;\n-         W      : Integer;\n-\n-         Status_From : Boolean;\n-         Status_To   : Boolean;\n-         --  Statuses for the calls to Close\n-\n-         procedure Free is new Unchecked_Deallocation (Buf, Buf_Ptr);\n-\n-      begin\n-         --  Check for invalid descriptors, making sure that we do not\n-         --  accidentally leave an open file descriptor around.\n-\n-         if From = Invalid_FD then\n-            if To /= Invalid_FD then\n-               Close (To, Status_To);\n-            end if;\n-\n-            raise Copy_Error;\n-\n-         elsif To = Invalid_FD then\n-            Close (From, Status_From);\n-            raise Copy_Error;\n-         end if;\n-\n-         --  Allocate the buffer on the heap\n-\n-         Buffer := new Buf;\n-\n-         loop\n-            R := Read (From, Buffer (1)'Address, Buf_Size);\n-\n-            --  For VMS, the buffer may not be full. So, we need to try again\n-            --  until there is nothing to read.\n-\n-            exit when R = 0;\n-\n-            W := Write (To, Buffer (1)'Address, R);\n-\n-            if W < R then\n-\n-               --  Problem writing data, could be a disk full. Close files\n-               --  without worrying about status, since we are raising a\n-               --  Copy_Error exception in any case.\n-\n-               Close (From, Status_From);\n-               Close (To, Status_To);\n-\n-               Free (Buffer);\n-\n-               raise Copy_Error;\n-            end if;\n-         end loop;\n-\n-         Close (From, Status_From);\n-         Close (To, Status_To);\n-\n-         Free (Buffer);\n-\n-         if not (Status_From and Status_To) then\n-            raise Copy_Error;\n-         end if;\n-      end Copy;\n-\n-      -------------\n-      -- Copy_To --\n-      -------------\n-\n-      procedure Copy_To (To_Name : String) is\n-\n-         function Copy_Attributes\n-           (From, To : System.Address;\n-            Mode     : Integer) return Integer;\n-         pragma Import (C, Copy_Attributes, \"__gnat_copy_attribs\");\n-         --  Mode = 0 - copy only time stamps.\n-         --  Mode = 1 - copy time stamps and read/write/execute attributes\n-\n-         C_From : String (1 .. Name'Length + 1);\n-         C_To   : String (1 .. To_Name'Length + 1);\n-\n-      begin\n-         From := Open_Read (Name, Binary);\n-         To   := Create_File (To_Name, Binary);\n-         Copy (From, To);\n-\n-         --  Copy attributes\n-\n-         C_From (1 .. Name'Length) := Name;\n-         C_From (C_From'Last) := ASCII.Nul;\n-\n-         C_To (1 .. To_Name'Length) := To_Name;\n-         C_To (C_To'Last) := ASCII.Nul;\n-\n-         case Preserve is\n-\n-            when Time_Stamps =>\n-               if Copy_Attributes (C_From'Address, C_To'Address, 0) = -1 then\n-                  raise Copy_Error;\n-               end if;\n-\n-            when Full =>\n-               if Copy_Attributes (C_From'Address, C_To'Address, 1) = -1 then\n-                  raise Copy_Error;\n-               end if;\n-\n-            when None =>\n-               null;\n-         end case;\n-\n-      end Copy_To;\n-\n-   --  Start of processing for Copy_File\n-\n-   begin\n-      Success := True;\n-\n-      --  The source file must exist\n-\n-      if not Is_Regular_File (Name) then\n-         raise Copy_Error;\n-      end if;\n-\n-      --  The source file exists\n-\n-      case Mode is\n-\n-         --  Copy case, target file must not exist\n-\n-         when Copy =>\n-\n-            --  If the target file exists, we have an error\n-\n-            if Is_Regular_File (Pathname) then\n-               raise Copy_Error;\n-\n-            --  Case of target is a directory\n-\n-            elsif Is_Directory (Pathname) then\n-               declare\n-                  Dest : constant String := Build_Path (Pathname, Name);\n-\n-               begin\n-                  --  If target file exists, we have an error, else do copy\n-\n-                  if Is_Regular_File (Dest) then\n-                     raise Copy_Error;\n-                  else\n-                     Copy_To (Dest);\n-                  end if;\n-               end;\n-\n-            --  Case of normal copy to file (destination does not exist)\n-\n-            else\n-               Copy_To (Pathname);\n-            end if;\n-\n-         --  Overwrite case (destination file may or may not exist)\n-\n-         when Overwrite =>\n-            if Is_Directory (Pathname) then\n-               Copy_To (Build_Path (Pathname, Name));\n-            else\n-               Copy_To (Pathname);\n-            end if;\n-\n-         --  Append case (destination file may or may not exist)\n-\n-         when Append =>\n-\n-            --  Appending to existing file\n-\n-            if Is_Regular_File (Pathname) then\n-\n-               --  Append mode and destination file exists, append data at the\n-               --  end of Pathname.\n-\n-               From := Open_Read (Name, Binary);\n-               To   := Open_Read_Write (Pathname, Binary);\n-               Lseek (To, 0, Seek_End);\n-\n-               Copy (From, To);\n-\n-            --  Appending to directory, not allowed\n-\n-            elsif Is_Directory (Pathname) then\n-               raise Copy_Error;\n-\n-            --  Appending when target file does not exist\n-\n-            else\n-               Copy_To (Pathname);\n-            end if;\n-      end case;\n-\n-   --  All error cases are caught here\n-\n-   exception\n-      when Copy_Error =>\n-         Success := False;\n-   end Copy_File;\n-\n-   procedure Copy_File\n-     (Name     : C_File_Name;\n-      Pathname : C_File_Name;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps)\n-   is\n-      Ada_Name : String_Access :=\n-                   To_Path_String_Access\n-                     (Name, C_String_Length (Name));\n-\n-      Ada_Pathname : String_Access :=\n-                       To_Path_String_Access\n-                         (Pathname, C_String_Length (Pathname));\n-\n-   begin\n-      Copy_File (Ada_Name.all, Ada_Pathname.all, Success, Mode, Preserve);\n-      Free (Ada_Name);\n-      Free (Ada_Pathname);\n-   end Copy_File;\n-\n-   ----------------------\n-   -- Copy_Time_Stamps --\n-   ----------------------\n-\n-   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean) is\n-\n-      function Copy_Attributes\n-        (From, To : System.Address;\n-         Mode     : Integer) return Integer;\n-      pragma Import (C, Copy_Attributes, \"__gnat_copy_attribs\");\n-      --  Mode = 0 - copy only time stamps.\n-      --  Mode = 1 - copy time stamps and read/write/execute attributes\n-\n-   begin\n-      if Is_Regular_File (Source) and then Is_Writable_File (Dest) then\n-         declare\n-            C_Source : String (1 .. Source'Length + 1);\n-            C_Dest   : String (1 .. Dest'Length + 1);\n-         begin\n-            C_Source (1 .. Source'Length) := Source;\n-            C_Source (C_Source'Last)      := ASCII.NUL;\n-\n-            C_Dest (1 .. Dest'Length) := Dest;\n-            C_Dest (C_Dest'Last)      := ASCII.NUL;\n-\n-            if Copy_Attributes (C_Source'Address, C_Dest'Address, 0) = -1 then\n-               Success := False;\n-            else\n-               Success := True;\n-            end if;\n-         end;\n-\n-      else\n-         Success := False;\n-      end if;\n-   end Copy_Time_Stamps;\n-\n-   procedure Copy_Time_Stamps\n-     (Source, Dest : C_File_Name;\n-      Success      : out Boolean)\n-   is\n-      Ada_Source : String_Access :=\n-                     To_Path_String_Access\n-                       (Source, C_String_Length (Source));\n-\n-      Ada_Dest : String_Access :=\n-                   To_Path_String_Access\n-                     (Dest, C_String_Length (Dest));\n-   begin\n-      Copy_Time_Stamps (Ada_Source.all, Ada_Dest.all, Success);\n-      Free (Ada_Source);\n-      Free (Ada_Dest);\n-   end Copy_Time_Stamps;\n-\n-   -----------------\n-   -- Create_File --\n-   -----------------\n-\n-   function Create_File\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      function C_Create_File\n-        (Name  : C_File_Name;\n-         Fmode : Mode) return File_Descriptor;\n-      pragma Import (C, C_Create_File, \"__gnat_open_create\");\n-\n-   begin\n-      return C_Create_File (Name, Fmode);\n-   end Create_File;\n-\n-   function Create_File\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      C_Name : String (1 .. Name'Length + 1);\n-\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-      return Create_File (C_Name (C_Name'First)'Address, Fmode);\n-   end Create_File;\n-\n-   ---------------------\n-   -- Create_New_File --\n-   ---------------------\n-\n-   function Create_New_File\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      function C_Create_New_File\n-        (Name  : C_File_Name;\n-         Fmode : Mode) return File_Descriptor;\n-      pragma Import (C, C_Create_New_File, \"__gnat_open_new\");\n-\n-   begin\n-      return C_Create_New_File (Name, Fmode);\n-   end Create_New_File;\n-\n-   function Create_New_File\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      C_Name : String (1 .. Name'Length + 1);\n-\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-      return Create_New_File (C_Name (C_Name'First)'Address, Fmode);\n-   end Create_New_File;\n-\n-   -----------------------------\n-   -- Create_Output_Text_File --\n-   -----------------------------\n-\n-   function Create_Output_Text_File (Name : String) return File_Descriptor is\n-      function C_Create_File\n-        (Name : C_File_Name) return File_Descriptor;\n-      pragma Import (C, C_Create_File, \"__gnat_create_output_file\");\n-\n-      C_Name : String (1 .. Name'Length + 1);\n-\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-      return C_Create_File (C_Name (C_Name'First)'Address);\n-   end Create_Output_Text_File;\n-\n-   ----------------------\n-   -- Create_Temp_File --\n-   ----------------------\n-\n-   procedure Create_Temp_File\n-     (FD   : out File_Descriptor;\n-      Name : out Temp_File_Name)\n-   is\n-      function Open_New_Temp\n-        (Name  : System.Address;\n-         Fmode : Mode) return File_Descriptor;\n-      pragma Import (C, Open_New_Temp, \"__gnat_open_new_temp\");\n-\n-   begin\n-      FD := Open_New_Temp (Name'Address, Binary);\n-   end Create_Temp_File;\n-\n-   procedure Create_Temp_File\n-     (FD   : out File_Descriptor;\n-      Name : out String_Access)\n-   is\n-      Pos      : Positive;\n-      Attempts : Natural := 0;\n-      Current  : String (Current_Temp_File_Name'Range);\n-\n-   begin\n-      --  Loop until a new temp file can be created\n-\n-      File_Loop : loop\n-         Locked : begin\n-            --  We need to protect global variable Current_Temp_File_Name\n-            --  against concurrent access by different tasks.\n-\n-            SSL.Lock_Task.all;\n-\n-            --  Start at the last digit\n-\n-            Pos := Temp_File_Name_Last_Digit;\n-\n-            Digit_Loop :\n-            loop\n-               --  Increment the digit by one\n-\n-               case Current_Temp_File_Name (Pos) is\n-                  when '0' .. '8' =>\n-                     Current_Temp_File_Name (Pos) :=\n-                       Character'Succ (Current_Temp_File_Name (Pos));\n-                     exit Digit_Loop;\n-\n-                  when '9' =>\n-\n-                     --  For 9, set the digit to 0 and go to the previous digit\n-\n-                     Current_Temp_File_Name (Pos) := '0';\n-                     Pos := Pos - 1;\n-\n-                  when others =>\n-\n-                     --  If it is not a digit, then there are no available\n-                     --  temp file names. Return Invalid_FD. There is almost\n-                     --  no that this code will be ever be executed, since\n-                     --  it would mean that there are one million temp files\n-                     --  in the same directory!\n-\n-                     SSL.Unlock_Task.all;\n-                     FD := Invalid_FD;\n-                     Name := null;\n-                     exit File_Loop;\n-               end case;\n-            end loop Digit_Loop;\n-\n-            Current := Current_Temp_File_Name;\n-\n-            --  We can now release the lock, because we are no longer\n-            --  accessing Current_Temp_File_Name.\n-\n-            SSL.Unlock_Task.all;\n-\n-         exception\n-            when others =>\n-               SSL.Unlock_Task.all;\n-               raise;\n-         end Locked;\n-\n-         --  Attempt to create the file\n-\n-         FD := Create_New_File (Current, Binary);\n-\n-         if FD /= Invalid_FD then\n-            Name := new String'(Current);\n-            exit File_Loop;\n-         end if;\n-\n-         if not Is_Regular_File (Current) then\n-\n-            --  If the file does not already exist and we are unable to create\n-            --  it, we give up after Max_Attempts. Otherwise, we try again with\n-            --  the next available file name.\n-\n-            Attempts := Attempts + 1;\n-\n-            if Attempts >= Max_Attempts then\n-               FD := Invalid_FD;\n-               Name := null;\n-               exit File_Loop;\n-            end if;\n-         end if;\n-      end loop File_Loop;\n-   end Create_Temp_File;\n-\n-   -----------------\n-   -- Delete_File --\n-   -----------------\n-\n-   procedure Delete_File (Name : Address; Success : out Boolean) is\n-      R : Integer;\n-\n-      function unlink (A : Address) return Integer;\n-      pragma Import (C, unlink, \"unlink\");\n-\n-   begin\n-      R := unlink (Name);\n-      Success := (R = 0);\n-   end Delete_File;\n-\n-   procedure Delete_File (Name : String; Success : out Boolean) is\n-      C_Name : String (1 .. Name'Length + 1);\n-\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-\n-      Delete_File (C_Name'Address, Success);\n-   end Delete_File;\n-\n-   ---------------------\n-   -- File_Time_Stamp --\n-   ---------------------\n-\n-   function File_Time_Stamp (FD : File_Descriptor) return OS_Time is\n-      function File_Time (FD    : File_Descriptor) return OS_Time;\n-      pragma Import (C, File_Time, \"__gnat_file_time_fd\");\n-   begin\n-      return File_Time (FD);\n-   end File_Time_Stamp;\n-\n-   function File_Time_Stamp (Name : C_File_Name) return OS_Time is\n-      function File_Time (Name : Address) return OS_Time;\n-      pragma Import (C, File_Time, \"__gnat_file_time_name\");\n-   begin\n-      return File_Time (Name);\n-   end File_Time_Stamp;\n-\n-   function File_Time_Stamp (Name : String) return OS_Time is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return File_Time_Stamp (F_Name'Address);\n-   end File_Time_Stamp;\n-\n-   ---------------------------\n-   -- Get_Debuggable_Suffix --\n-   ---------------------------\n-\n-   function Get_Debuggable_Suffix return String_Access is\n-      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n-      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_debuggable_suffix_ptr\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Debuggable_Suffix;\n-\n-   ---------------------------\n-   -- Get_Executable_Suffix --\n-   ---------------------------\n-\n-   function Get_Executable_Suffix return String_Access is\n-      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n-      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_executable_suffix_ptr\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Executable_Suffix;\n-\n-   -----------------------\n-   -- Get_Object_Suffix --\n-   -----------------------\n-\n-   function Get_Object_Suffix return String_Access is\n-      procedure Get_Suffix_Ptr (Length, Ptr : Address);\n-      pragma Import (C, Get_Suffix_Ptr, \"__gnat_get_object_suffix_ptr\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      Suffix_Ptr    : Address;\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Get_Suffix_Ptr (Suffix_Length'Address, Suffix_Ptr'Address);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Suffix_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Object_Suffix;\n-\n-   ----------------------------------\n-   -- Get_Target_Debuggable_Suffix --\n-   ----------------------------------\n-\n-   function Get_Target_Debuggable_Suffix return String_Access is\n-      Target_Exec_Ext_Ptr : Address;\n-      pragma Import\n-        (C, Target_Exec_Ext_Ptr, \"__gnat_target_debuggable_extension\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Target_Debuggable_Suffix;\n-\n-   ----------------------------------\n-   -- Get_Target_Executable_Suffix --\n-   ----------------------------------\n-\n-   function Get_Target_Executable_Suffix return String_Access is\n-      Target_Exec_Ext_Ptr : Address;\n-      pragma Import\n-        (C, Target_Exec_Ext_Ptr, \"__gnat_target_executable_extension\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Suffix_Length := Strlen (Target_Exec_Ext_Ptr);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Target_Exec_Ext_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Target_Executable_Suffix;\n-\n-   ------------------------------\n-   -- Get_Target_Object_Suffix --\n-   ------------------------------\n-\n-   function Get_Target_Object_Suffix return String_Access is\n-      Target_Object_Ext_Ptr : Address;\n-      pragma Import\n-        (C, Target_Object_Ext_Ptr, \"__gnat_target_object_extension\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      function Strlen (Cstring : Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n-      Suffix_Length : Integer;\n-      Result        : String_Access;\n-\n-   begin\n-      Suffix_Length := Strlen (Target_Object_Ext_Ptr);\n-\n-      Result := new String (1 .. Suffix_Length);\n-\n-      if Suffix_Length > 0 then\n-         Strncpy (Result.all'Address, Target_Object_Ext_Ptr, Suffix_Length);\n-      end if;\n-\n-      return Result;\n-   end Get_Target_Object_Suffix;\n-\n-   ------------\n-   -- Getenv --\n-   ------------\n-\n-   function Getenv (Name : String) return String_Access is\n-      procedure Get_Env_Value_Ptr (Name, Length, Ptr : Address);\n-      pragma Import (C, Get_Env_Value_Ptr, \"__gnat_getenv\");\n-\n-      procedure Strncpy (Astring_Addr, Cstring : Address; N : Integer);\n-      pragma Import (C, Strncpy, \"strncpy\");\n-\n-      Env_Value_Ptr    : aliased Address;\n-      Env_Value_Length : aliased Integer;\n-      F_Name           : aliased String (1 .. Name'Length + 1);\n-      Result           : String_Access;\n-\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-\n-      Get_Env_Value_Ptr\n-        (F_Name'Address, Env_Value_Length'Address, Env_Value_Ptr'Address);\n-\n-      Result := new String (1 .. Env_Value_Length);\n-\n-      if Env_Value_Length > 0 then\n-         Strncpy (Result.all'Address, Env_Value_Ptr, Env_Value_Length);\n-      end if;\n-\n-      return Result;\n-   end Getenv;\n-\n-   ------------\n-   -- GM_Day --\n-   ------------\n-\n-   function GM_Day (Date : OS_Time) return Day_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return D;\n-   end GM_Day;\n-\n-   -------------\n-   -- GM_Hour --\n-   -------------\n-\n-   function GM_Hour (Date : OS_Time) return Hour_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return H;\n-   end GM_Hour;\n-\n-   ---------------\n-   -- GM_Minute --\n-   ---------------\n-\n-   function GM_Minute (Date : OS_Time) return Minute_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return Mn;\n-   end GM_Minute;\n-\n-   --------------\n-   -- GM_Month --\n-   --------------\n-\n-   function GM_Month (Date : OS_Time) return Month_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return Mo;\n-   end GM_Month;\n-\n-   ---------------\n-   -- GM_Second --\n-   ---------------\n-\n-   function GM_Second (Date : OS_Time) return Second_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return S;\n-   end GM_Second;\n-\n-   --------------\n-   -- GM_Split --\n-   --------------\n-\n-   procedure GM_Split\n-     (Date   : OS_Time;\n-      Year   : out Year_Type;\n-      Month  : out Month_Type;\n-      Day    : out Day_Type;\n-      Hour   : out Hour_Type;\n-      Minute : out Minute_Type;\n-      Second : out Second_Type)\n-   is\n-      procedure To_GM_Time\n-        (P_Time_T, P_Year, P_Month, P_Day, P_Hours, P_Mins, P_Secs : Address);\n-      pragma Import (C, To_GM_Time, \"__gnat_to_gm_time\");\n-\n-      T  : OS_Time := Date;\n-      Y  : Integer;\n-      Mo : Integer;\n-      D  : Integer;\n-      H  : Integer;\n-      Mn : Integer;\n-      S  : Integer;\n-\n-   begin\n-      --  Use the global lock because To_GM_Time is not thread safe\n-\n-      Locked_Processing : begin\n-         SSL.Lock_Task.all;\n-         To_GM_Time\n-           (T'Address, Y'Address, Mo'Address, D'Address,\n-            H'Address, Mn'Address, S'Address);\n-         SSL.Unlock_Task.all;\n-\n-      exception\n-         when others =>\n-            SSL.Unlock_Task.all;\n-            raise;\n-      end Locked_Processing;\n-\n-      Year   := Y + 1900;\n-      Month  := Mo + 1;\n-      Day    := D;\n-      Hour   := H;\n-      Minute := Mn;\n-      Second := S;\n-   end GM_Split;\n-\n-   -------------\n-   -- GM_Year --\n-   -------------\n-\n-   function GM_Year (Date : OS_Time) return Year_Type is\n-      Y  : Year_Type;\n-      Mo : Month_Type;\n-      D  : Day_Type;\n-      H  : Hour_Type;\n-      Mn : Minute_Type;\n-      S  : Second_Type;\n-\n-   begin\n-      GM_Split (Date, Y, Mo, D, H, Mn, S);\n-      return Y;\n-   end GM_Year;\n-\n-   ----------------------\n-   -- Is_Absolute_Path --\n-   ----------------------\n-\n-   function Is_Absolute_Path (Name : String) return Boolean is\n-      function Is_Absolute_Path\n-        (Name   : Address;\n-         Length : Integer) return Integer;\n-      pragma Import (C, Is_Absolute_Path, \"__gnat_is_absolute_path\");\n-   begin\n-      return Is_Absolute_Path (Name'Address, Name'Length) /= 0;\n-   end Is_Absolute_Path;\n-\n-   ------------------\n-   -- Is_Directory --\n-   ------------------\n-\n-   function Is_Directory (Name : C_File_Name) return Boolean is\n-      function Is_Directory (Name : Address) return Integer;\n-      pragma Import (C, Is_Directory, \"__gnat_is_directory\");\n-   begin\n-      return Is_Directory (Name) /= 0;\n-   end Is_Directory;\n-\n-   function Is_Directory (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Directory (F_Name'Address);\n-   end Is_Directory;\n-\n-   ----------------------\n-   -- Is_Readable_File --\n-   ----------------------\n-\n-   function Is_Readable_File (Name : C_File_Name) return Boolean is\n-      function Is_Readable_File (Name : Address) return Integer;\n-      pragma Import (C, Is_Readable_File, \"__gnat_is_readable_file\");\n-   begin\n-      return Is_Readable_File (Name) /= 0;\n-   end Is_Readable_File;\n-\n-   function Is_Readable_File (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Readable_File (F_Name'Address);\n-   end Is_Readable_File;\n-\n-   ---------------------\n-   -- Is_Regular_File --\n-   ---------------------\n-\n-   function Is_Regular_File (Name : C_File_Name) return Boolean is\n-      function Is_Regular_File (Name : Address) return Integer;\n-      pragma Import (C, Is_Regular_File, \"__gnat_is_regular_file\");\n-   begin\n-      return Is_Regular_File (Name) /= 0;\n-   end Is_Regular_File;\n-\n-   function Is_Regular_File (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Regular_File (F_Name'Address);\n-   end Is_Regular_File;\n-\n-   ----------------------\n-   -- Is_Symbolic_Link --\n-   ----------------------\n-\n-   function Is_Symbolic_Link (Name : C_File_Name) return Boolean is\n-      function Is_Symbolic_Link (Name : Address) return Integer;\n-      pragma Import (C, Is_Symbolic_Link, \"__gnat_is_symbolic_link\");\n-   begin\n-      return Is_Symbolic_Link (Name) /= 0;\n-   end Is_Symbolic_Link;\n-\n-   function Is_Symbolic_Link (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Symbolic_Link (F_Name'Address);\n-   end Is_Symbolic_Link;\n-\n-   ----------------------\n-   -- Is_Writable_File --\n-   ----------------------\n-\n-   function Is_Writable_File (Name : C_File_Name) return Boolean is\n-      function Is_Writable_File (Name : Address) return Integer;\n-      pragma Import (C, Is_Writable_File, \"__gnat_is_writable_file\");\n-   begin\n-      return Is_Writable_File (Name) /= 0;\n-   end Is_Writable_File;\n-\n-   function Is_Writable_File (Name : String) return Boolean is\n-      F_Name : String (1 .. Name'Length + 1);\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-      return Is_Writable_File (F_Name'Address);\n-   end Is_Writable_File;\n-\n-   -------------------------\n-   -- Locate_Exec_On_Path --\n-   -------------------------\n-\n-   function Locate_Exec_On_Path\n-     (Exec_Name : String) return String_Access\n-   is\n-      function Locate_Exec_On_Path (C_Exec_Name : Address) return Address;\n-      pragma Import (C, Locate_Exec_On_Path, \"__gnat_locate_exec_on_path\");\n-\n-      procedure Free (Ptr : System.Address);\n-      pragma Import (C, Free, \"free\");\n-\n-      C_Exec_Name  : String (1 .. Exec_Name'Length + 1);\n-      Path_Addr    : Address;\n-      Path_Len     : Integer;\n-      Result       : String_Access;\n-\n-   begin\n-      C_Exec_Name (1 .. Exec_Name'Length)   := Exec_Name;\n-      C_Exec_Name (C_Exec_Name'Last)        := ASCII.NUL;\n-\n-      Path_Addr := Locate_Exec_On_Path (C_Exec_Name'Address);\n-      Path_Len  := C_String_Length (Path_Addr);\n-\n-      if Path_Len = 0 then\n-         return null;\n-\n-      else\n-         Result := To_Path_String_Access (Path_Addr, Path_Len);\n-         Free (Path_Addr);\n-\n-         --  Always return an absolute path name\n-\n-         if not Is_Absolute_Path (Result.all) then\n-            declare\n-               Absolute_Path : constant String :=\n-                                 Normalize_Pathname (Result.all);\n-            begin\n-               Free (Result);\n-               Result := new String'(Absolute_Path);\n-            end;\n-         end if;\n-\n-         return Result;\n-      end if;\n-   end Locate_Exec_On_Path;\n-\n-   -------------------------\n-   -- Locate_Regular_File --\n-   -------------------------\n-\n-   function Locate_Regular_File\n-     (File_Name : C_File_Name;\n-      Path      : C_File_Name) return String_Access\n-   is\n-      function Locate_Regular_File\n-        (C_File_Name, Path_Val : Address) return Address;\n-      pragma Import (C, Locate_Regular_File, \"__gnat_locate_regular_file\");\n-\n-      procedure Free (Ptr : System.Address);\n-      pragma Import (C, Free, \"free\");\n-\n-      Path_Addr    : Address;\n-      Path_Len     : Integer;\n-      Result       : String_Access;\n-\n-   begin\n-      Path_Addr := Locate_Regular_File (File_Name, Path);\n-      Path_Len  := C_String_Length (Path_Addr);\n-\n-      if Path_Len = 0 then\n-         return null;\n-      else\n-         Result := To_Path_String_Access (Path_Addr, Path_Len);\n-         Free (Path_Addr);\n-         return Result;\n-      end if;\n-   end Locate_Regular_File;\n-\n-   function Locate_Regular_File\n-     (File_Name : String;\n-      Path      : String) return String_Access\n-   is\n-      C_File_Name : String (1 .. File_Name'Length + 1);\n-      C_Path      : String (1 .. Path'Length + 1);\n-      Result      : String_Access;\n-\n-   begin\n-      C_File_Name (1 .. File_Name'Length)   := File_Name;\n-      C_File_Name (C_File_Name'Last)        := ASCII.NUL;\n-\n-      C_Path    (1 .. Path'Length)          := Path;\n-      C_Path    (C_Path'Last)               := ASCII.NUL;\n-\n-      Result := Locate_Regular_File (C_File_Name'Address, C_Path'Address);\n-\n-      --  Always return an absolute path name\n-\n-      if Result /= null and then not Is_Absolute_Path (Result.all) then\n-         declare\n-            Absolute_Path : constant String := Normalize_Pathname (Result.all);\n-         begin\n-            Free (Result);\n-            Result := new String'(Absolute_Path);\n-         end;\n-      end if;\n-\n-      return Result;\n-   end Locate_Regular_File;\n-\n-   ------------------------\n-   -- Non_Blocking_Spawn --\n-   ------------------------\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List) return Process_Id\n-   is\n-      Junk : Integer;\n-      Pid  : Process_Id;\n-\n-   begin\n-      Spawn_Internal (Program_Name, Args, Junk, Pid, Blocking => False);\n-      return Pid;\n-   end Non_Blocking_Spawn;\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name           : String;\n-      Args                   : Argument_List;\n-      Output_File_Descriptor : File_Descriptor;\n-      Err_To_Out             : Boolean := True) return Process_Id\n-   is\n-      Saved_Output : File_Descriptor;\n-      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent warning\n-      Pid          : Process_Id;\n-\n-   begin\n-      if Output_File_Descriptor = Invalid_FD then\n-         return Invalid_Pid;\n-      end if;\n-\n-      --  Set standard output and, if specified, error to the temporary file\n-\n-      Saved_Output := Dup (Standout);\n-      Dup2 (Output_File_Descriptor, Standout);\n-\n-      if Err_To_Out then\n-         Saved_Error  := Dup (Standerr);\n-         Dup2 (Output_File_Descriptor, Standerr);\n-      end if;\n-\n-      --  Spawn the program\n-\n-      Pid := Non_Blocking_Spawn (Program_Name, Args);\n-\n-      --  Restore the standard output and error\n-\n-      Dup2 (Saved_Output, Standout);\n-\n-      if Err_To_Out then\n-         Dup2 (Saved_Error, Standerr);\n-      end if;\n-\n-      --  And close the saved standard output and error file descriptors\n-\n-      Close (Saved_Output);\n-\n-      if Err_To_Out then\n-         Close (Saved_Error);\n-      end if;\n-\n-      return Pid;\n-   end Non_Blocking_Spawn;\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Output_File  : String;\n-      Err_To_Out   : Boolean := True) return Process_Id\n-   is\n-      Output_File_Descriptor : constant File_Descriptor :=\n-                                 Create_Output_Text_File (Output_File);\n-      Result : Process_Id;\n-\n-   begin\n-      --  Do not attempt to spawn if the output file could not be created\n-\n-      if Output_File_Descriptor = Invalid_FD then\n-         return Invalid_Pid;\n-\n-      else\n-         Result := Non_Blocking_Spawn\n-                     (Program_Name, Args, Output_File_Descriptor, Err_To_Out);\n-\n-         --  Close the file just created for the output, as the file descriptor\n-         --  cannot be used anywhere, being a local value. It is safe to do\n-         --  that, as the file descriptor has been duplicated to form\n-         --  standard output and error of the spawned process.\n-\n-         Close (Output_File_Descriptor);\n-\n-         return Result;\n-      end if;\n-   end Non_Blocking_Spawn;\n-\n-   -------------------------\n-   -- Normalize_Arguments --\n-   -------------------------\n-\n-   procedure Normalize_Arguments (Args : in out Argument_List) is\n-\n-      procedure Quote_Argument (Arg : in out String_Access);\n-      --  Add quote around argument if it contains spaces\n-\n-      C_Argument_Needs_Quote : Integer;\n-      pragma Import (C, C_Argument_Needs_Quote, \"__gnat_argument_needs_quote\");\n-      Argument_Needs_Quote : constant Boolean := C_Argument_Needs_Quote /= 0;\n-\n-      --------------------\n-      -- Quote_Argument --\n-      --------------------\n-\n-      procedure Quote_Argument (Arg : in out String_Access) is\n-         Res          : String (1 .. Arg'Length * 2);\n-         J            : Positive := 1;\n-         Quote_Needed : Boolean  := False;\n-\n-      begin\n-         if Arg (Arg'First) /= '\"' or else Arg (Arg'Last) /= '\"' then\n-\n-            --  Starting quote\n-\n-            Res (J) := '\"';\n-\n-            for K in Arg'Range loop\n-\n-               J := J + 1;\n-\n-               if Arg (K) = '\"' then\n-                  Res (J) := '\\';\n-                  J := J + 1;\n-                  Res (J) := '\"';\n-                  Quote_Needed := True;\n-\n-               elsif Arg (K) = ' ' then\n-                  Res (J) := Arg (K);\n-                  Quote_Needed := True;\n-\n-               else\n-                  Res (J) := Arg (K);\n-               end if;\n-\n-            end loop;\n-\n-            if Quote_Needed then\n-\n-               --  If null terminated string, put the quote before\n-\n-               if Res (J) = ASCII.Nul then\n-                  Res (J) := '\"';\n-                  J := J + 1;\n-                  Res (J) := ASCII.Nul;\n-\n-               --  If argument is terminated by '\\', then double it. Otherwise\n-               --  the ending quote will be taken as-is. This is quite strange\n-               --  spawn behavior from Windows, but this is what we see!\n-\n-               else\n-                  if Res (J) = '\\' then\n-                     J := J + 1;\n-                     Res (J) := '\\';\n-                  end if;\n-\n-                  --  Ending quote\n-\n-                  J := J + 1;\n-                  Res (J) := '\"';\n-               end if;\n-\n-               declare\n-                  Old : String_Access := Arg;\n-\n-               begin\n-                  Arg := new String'(Res (1 .. J));\n-                  Free (Old);\n-               end;\n-            end if;\n-\n-         end if;\n-      end Quote_Argument;\n-\n-   --  Start of processing for Normalize_Arguments\n-\n-   begin\n-      if Argument_Needs_Quote then\n-         for K in Args'Range loop\n-            if Args (K) /= null and then Args (K)'Length /= 0 then\n-               Quote_Argument (Args (K));\n-            end if;\n-         end loop;\n-      end if;\n-   end Normalize_Arguments;\n-\n-   ------------------------\n-   -- Normalize_Pathname --\n-   ------------------------\n-\n-   function Normalize_Pathname\n-     (Name           : String;\n-      Directory      : String  := \"\";\n-      Resolve_Links  : Boolean := True;\n-      Case_Sensitive : Boolean := True) return String\n-   is\n-      Max_Path : Integer;\n-      pragma Import (C, Max_Path, \"__gnat_max_path_len\");\n-      --  Maximum length of a path name\n-\n-      procedure Get_Current_Dir\n-        (Dir    : System.Address;\n-         Length : System.Address);\n-      pragma Import (C, Get_Current_Dir, \"__gnat_get_current_dir\");\n-\n-      Path_Buffer : String (1 .. Max_Path + Max_Path + 2);\n-      End_Path    : Natural := 0;\n-      Link_Buffer : String (1 .. Max_Path + 2);\n-      Status      : Integer;\n-      Last        : Positive;\n-      Start       : Natural;\n-      Finish      : Positive;\n-\n-      Max_Iterations : constant := 500;\n-\n-      function Get_File_Names_Case_Sensitive return Integer;\n-      pragma Import\n-        (C, Get_File_Names_Case_Sensitive,\n-         \"__gnat_get_file_names_case_sensitive\");\n-\n-      Fold_To_Lower_Case : constant Boolean :=\n-                             not Case_Sensitive\n-                               and then Get_File_Names_Case_Sensitive = 0;\n-\n-      function Readlink\n-        (Path   : System.Address;\n-         Buf    : System.Address;\n-         Bufsiz : Integer) return Integer;\n-      pragma Import (C, Readlink, \"__gnat_readlink\");\n-\n-      function To_Canonical_File_Spec\n-        (Host_File : System.Address) return System.Address;\n-      pragma Import\n-        (C, To_Canonical_File_Spec, \"__gnat_to_canonical_file_spec\");\n-\n-      The_Name : String (1 .. Name'Length + 1);\n-      Canonical_File_Addr : System.Address;\n-      Canonical_File_Len  : Integer;\n-\n-      Need_To_Check_Drive_Letter : Boolean := False;\n-      --  Set to true if Name is an absolute path that starts with \"//\"\n-\n-      function Strlen (S : System.Address) return Integer;\n-      pragma Import (C, Strlen, \"strlen\");\n-\n-      function Final_Value (S : String) return String;\n-      --  Make final adjustment to the returned string.\n-      --  To compensate for non standard path name in Interix,\n-      --  if S is \"/x\" or starts with \"/x\", where x is a capital\n-      --  letter 'A' to 'Z', add an additional '/' at the beginning\n-      --  so that the returned value starts with \"//x\".\n-\n-      function Get_Directory  (Dir : String) return String;\n-      --  If Dir is not empty, return it, adding a directory separator\n-      --  if not already present, otherwise return current working directory\n-      --  with terminating directory separator.\n-\n-      -----------------\n-      -- Final_Value --\n-      -----------------\n-\n-      function Final_Value (S : String) return String is\n-         S1 : String := S;\n-         --  We may need to fold S to lower case, so we need a variable\n-\n-         Last : Natural;\n-\n-      begin\n-         --  Interix has the non standard notion of disk drive\n-         --  indicated by two '/' followed by a capital letter\n-         --  'A' .. 'Z'. One of the two '/' may have been removed\n-         --  by Normalize_Pathname. It has to be added again.\n-         --  For other OSes, this should not make no difference.\n-\n-         if Need_To_Check_Drive_Letter\n-           and then S'Length >= 2\n-           and then S (S'First) = '/'\n-           and then S (S'First + 1) in 'A' .. 'Z'\n-           and then (S'Length = 2 or else S (S'First + 2) = '/')\n-         then\n-            declare\n-               Result : String (1 .. S'Length + 1);\n-\n-            begin\n-               Result (1) := '/';\n-               Result (2 .. Result'Last) := S;\n-               Last := Result'Last;\n-\n-               if Fold_To_Lower_Case then\n-                  System.Case_Util.To_Lower (Result);\n-               end if;\n-\n-               --  Remove trailing directory separator, if any\n-\n-               if Last > 1 and then\n-                 (Result (Last) = '/' or else\n-                  Result (Last) = Directory_Separator)\n-               then\n-                  Last := Last - 1;\n-               end if;\n-\n-               return Result (1 .. Last);\n-            end;\n-\n-         else\n-            if Fold_To_Lower_Case then\n-               System.Case_Util.To_Lower (S1);\n-            end if;\n-\n-            --  Remove trailing directory separator, if any\n-\n-            Last := S1'Last;\n-\n-            if Last > 1\n-              and then (S1 (Last) = '/'\n-                          or else\n-                        S1 (Last) = Directory_Separator)\n-            then\n-               --  Special case for Windows: C:\\\n-\n-               if Last = 3\n-                 and then S1 (1) /= Directory_Separator\n-                 and then S1 (2) = ':'\n-               then\n-                  null;\n-\n-               else\n-                  Last := Last - 1;\n-               end if;\n-            end if;\n-\n-            return S1 (1 .. Last);\n-         end if;\n-      end Final_Value;\n-\n-      -------------------\n-      -- Get_Directory --\n-      -------------------\n-\n-      function Get_Directory (Dir : String) return String is\n-      begin\n-         --  Directory given, add directory separator if needed\n-\n-         if Dir'Length > 0 then\n-            if Dir (Dir'Last) = Directory_Separator then\n-               return Directory;\n-            else\n-               declare\n-                  Result : String (1 .. Dir'Length + 1);\n-               begin\n-                  Result (1 .. Dir'Length) := Dir;\n-                  Result (Result'Length) := Directory_Separator;\n-                  return Result;\n-               end;\n-            end if;\n-\n-         --  Directory name not given, get current directory\n-\n-         else\n-            declare\n-               Buffer   : String (1 .. Max_Path + 2);\n-               Path_Len : Natural := Max_Path;\n-\n-            begin\n-               Get_Current_Dir (Buffer'Address, Path_Len'Address);\n-\n-               if Buffer (Path_Len) /= Directory_Separator then\n-                  Path_Len := Path_Len + 1;\n-                  Buffer (Path_Len) := Directory_Separator;\n-               end if;\n-\n-               --  By default, the drive letter on Windows is in upper case\n-\n-               if On_Windows and then Path_Len >= 2 and then\n-                 Buffer (2) = ':'\n-               then\n-                  System.Case_Util.To_Upper (Buffer (1 .. 1));\n-               end if;\n-\n-               return Buffer (1 .. Path_Len);\n-            end;\n-         end if;\n-      end Get_Directory;\n-\n-      Reference_Dir : constant String := Get_Directory (Directory);\n-      --  Current directory name specified\n-\n-   --  Start of processing for Normalize_Pathname\n-\n-   begin\n-      --  Special case, if name is null, then return null\n-\n-      if Name'Length = 0 then\n-         return \"\";\n-      end if;\n-\n-      --  First, convert VMS file spec to Unix file spec.\n-      --  If Name is not in VMS syntax, then this is equivalent\n-      --  to put Name at the begining of Path_Buffer.\n-\n-      VMS_Conversion : begin\n-         The_Name (1 .. Name'Length) := Name;\n-         The_Name (The_Name'Last) := ASCII.NUL;\n-\n-         Canonical_File_Addr := To_Canonical_File_Spec (The_Name'Address);\n-         Canonical_File_Len  := Strlen (Canonical_File_Addr);\n-\n-         --  If VMS syntax conversion has failed, return an empty string\n-         --  to indicate the failure.\n-\n-         if Canonical_File_Len = 0 then\n-            return \"\";\n-         end if;\n-\n-         declare\n-            subtype Path_String is String (1 .. Canonical_File_Len);\n-            type    Path_String_Access is access Path_String;\n-\n-            function Address_To_Access is new\n-               Unchecked_Conversion (Source => Address,\n-                                     Target => Path_String_Access);\n-\n-            Path_Access : constant Path_String_Access :=\n-                            Address_To_Access (Canonical_File_Addr);\n-\n-         begin\n-            Path_Buffer (1 .. Canonical_File_Len) := Path_Access.all;\n-            End_Path := Canonical_File_Len;\n-            Last := 1;\n-         end;\n-      end VMS_Conversion;\n-\n-      --  Replace all '/' by Directory Separators (this is for Windows)\n-\n-      if Directory_Separator /= '/' then\n-         for Index in 1 .. End_Path loop\n-            if Path_Buffer (Index) = '/' then\n-               Path_Buffer (Index) := Directory_Separator;\n-            end if;\n-         end loop;\n-      end if;\n-\n-      --  Resolve directory names for Windows (formerly also VMS)\n-\n-      --  On VMS, if we have a Unix path such as /temp/..., and TEMP is a\n-      --  logical name, we must not try to resolve this logical name, because\n-      --  it may have multiple equivalences and if resolved we will only\n-      --  get the first one.\n-\n-      --  On Windows, if we have an absolute path starting with a directory\n-      --  separator, we need to have the drive letter appended in front.\n-\n-      --  On Windows, Get_Current_Dir will return a suitable directory\n-      --  name (path starting with a drive letter on Windows). So we take this\n-      --  drive letter and prepend it to the current path.\n-\n-      if On_Windows\n-        and then Path_Buffer (1) = Directory_Separator\n-        and then Path_Buffer (2) /= Directory_Separator\n-      then\n-         declare\n-            Cur_Dir : String := Get_Directory (\"\");\n-            --  Get the current directory to get the drive letter\n-\n-         begin\n-            if Cur_Dir'Length > 2\n-              and then Cur_Dir (Cur_Dir'First + 1) = ':'\n-            then\n-               Path_Buffer (3 .. End_Path + 2) := Path_Buffer (1 .. End_Path);\n-               Path_Buffer (1 .. 2) :=\n-                 Cur_Dir (Cur_Dir'First .. Cur_Dir'First + 1);\n-               End_Path := End_Path + 2;\n-            end if;\n-         end;\n-      end if;\n-\n-      --  Start the conversions\n-\n-      --  If this is not finished after Max_Iterations, give up and return an\n-      --  empty string.\n-\n-      for J in 1 .. Max_Iterations loop\n-\n-         --  If we don't have an absolute pathname, prepend the directory\n-         --  Reference_Dir.\n-\n-         if Last = 1\n-           and then not Is_Absolute_Path (Path_Buffer (1 .. End_Path))\n-         then\n-            Path_Buffer\n-              (Reference_Dir'Last + 1 .. Reference_Dir'Length + End_Path) :=\n-                 Path_Buffer (1 .. End_Path);\n-            End_Path := Reference_Dir'Length + End_Path;\n-            Path_Buffer (1 .. Reference_Dir'Length) := Reference_Dir;\n-            Last := Reference_Dir'Length;\n-         end if;\n-\n-         --  If name starts with \"//\", we may have a drive letter on Interix\n-\n-         if Last = 1 and then End_Path >= 3 then\n-            Need_To_Check_Drive_Letter := (Path_Buffer (1 .. 2)) = \"//\";\n-         end if;\n-\n-         Start  := Last + 1;\n-         Finish := Last;\n-\n-         --  Ensure that Windows network drives are kept, e.g: \\\\server\\drive-c\n-\n-         if Start = 2\n-           and then Directory_Separator = '\\'\n-           and then Path_Buffer (1 .. 2) = \"\\\\\"\n-         then\n-            Start := 3;\n-         end if;\n-\n-         --  If we have traversed the full pathname, return it\n-\n-         if Start > End_Path then\n-            return Final_Value (Path_Buffer (1 .. End_Path));\n-         end if;\n-\n-         --  Remove duplicate directory separators\n-\n-         while Path_Buffer (Start) = Directory_Separator loop\n-            if Start = End_Path then\n-               return Final_Value (Path_Buffer (1 .. End_Path - 1));\n-\n-            else\n-               Path_Buffer (Start .. End_Path - 1) :=\n-                 Path_Buffer (Start + 1 .. End_Path);\n-               End_Path := End_Path - 1;\n-            end if;\n-         end loop;\n-\n-         --  Find the end of the current field: last character or the one\n-         --  preceding the next directory separator.\n-\n-         while Finish < End_Path\n-           and then Path_Buffer (Finish + 1) /= Directory_Separator\n-         loop\n-            Finish := Finish + 1;\n-         end loop;\n-\n-         --  Remove \".\" field\n-\n-         if Start = Finish and then Path_Buffer (Start) = '.' then\n-            if Start = End_Path then\n-               if Last = 1 then\n-                  return (1 => Directory_Separator);\n-               else\n-\n-                  if Fold_To_Lower_Case then\n-                     System.Case_Util.To_Lower (Path_Buffer (1 .. Last - 1));\n-                  end if;\n-\n-                  return Path_Buffer (1 .. Last - 1);\n-\n-               end if;\n-\n-            else\n-               Path_Buffer (Last + 1 .. End_Path - 2) :=\n-                 Path_Buffer (Last + 3 .. End_Path);\n-               End_Path := End_Path - 2;\n-            end if;\n-\n-         --  Remove \"..\" fields\n-\n-         elsif Finish = Start + 1\n-           and then Path_Buffer (Start .. Finish) = \"..\"\n-         then\n-            Start := Last;\n-            loop\n-               Start := Start - 1;\n-               exit when Start < 1 or else\n-                 Path_Buffer (Start) = Directory_Separator;\n-            end loop;\n-\n-            if Start <= 1 then\n-               if Finish = End_Path then\n-                  return (1 => Directory_Separator);\n-\n-               else\n-                  Path_Buffer (1 .. End_Path - Finish) :=\n-                    Path_Buffer (Finish + 1 .. End_Path);\n-                  End_Path := End_Path - Finish;\n-                  Last := 1;\n-               end if;\n-\n-            else\n-               if Finish = End_Path then\n-                  return Final_Value (Path_Buffer (1 .. Start - 1));\n-\n-               else\n-                  Path_Buffer (Start + 1 .. Start + End_Path - Finish - 1) :=\n-                    Path_Buffer (Finish + 2 .. End_Path);\n-                  End_Path := Start + End_Path - Finish - 1;\n-                  Last := Start;\n-               end if;\n-            end if;\n-\n-         --  Check if current field is a symbolic link\n-\n-         elsif Resolve_Links then\n-            declare\n-               Saved : constant Character := Path_Buffer (Finish + 1);\n-\n-            begin\n-               Path_Buffer (Finish + 1) := ASCII.NUL;\n-               Status := Readlink (Path_Buffer'Address,\n-                                   Link_Buffer'Address,\n-                                   Link_Buffer'Length);\n-               Path_Buffer (Finish + 1) := Saved;\n-            end;\n-\n-            --  Not a symbolic link, move to the next field, if any\n-\n-            if Status <= 0 then\n-               Last := Finish + 1;\n-\n-            --  Replace symbolic link with its value\n-\n-            else\n-               if Is_Absolute_Path (Link_Buffer (1 .. Status)) then\n-                  Path_Buffer (Status + 1 .. End_Path - (Finish - Status)) :=\n-                  Path_Buffer (Finish + 1 .. End_Path);\n-                  End_Path := End_Path - (Finish - Status);\n-                  Path_Buffer (1 .. Status) := Link_Buffer (1 .. Status);\n-                  Last := 1;\n-\n-               else\n-                  Path_Buffer\n-                    (Last + Status + 1 .. End_Path - Finish + Last + Status) :=\n-                    Path_Buffer (Finish + 1 .. End_Path);\n-                  End_Path := End_Path - Finish + Last + Status;\n-                  Path_Buffer (Last + 1 .. Last + Status) :=\n-                    Link_Buffer (1 .. Status);\n-               end if;\n-            end if;\n-\n-         else\n-            Last := Finish + 1;\n-         end if;\n-      end loop;\n-\n-      --  Too many iterations: give up\n-\n-      --  This can happen when there is a circularity in the symbolic links: A\n-      --  is a symbolic link for B, which itself is a symbolic link, and the\n-      --  target of B or of another symbolic link target of B is A. In this\n-      --  case, we return an empty string to indicate failure to resolve.\n-\n-      return \"\";\n-   end Normalize_Pathname;\n-\n-   ---------------\n-   -- Open_Read --\n-   ---------------\n-\n-   function Open_Read\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      function C_Open_Read\n-        (Name  : C_File_Name;\n-         Fmode : Mode) return File_Descriptor;\n-      pragma Import (C, C_Open_Read, \"__gnat_open_read\");\n-   begin\n-      return C_Open_Read (Name, Fmode);\n-   end Open_Read;\n-\n-   function Open_Read\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      C_Name : String (1 .. Name'Length + 1);\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-      return Open_Read (C_Name (C_Name'First)'Address, Fmode);\n-   end Open_Read;\n-\n-   ---------------------\n-   -- Open_Read_Write --\n-   ---------------------\n-\n-   function Open_Read_Write\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      function C_Open_Read_Write\n-        (Name  : C_File_Name;\n-         Fmode : Mode) return File_Descriptor;\n-      pragma Import (C, C_Open_Read_Write, \"__gnat_open_rw\");\n-   begin\n-      return C_Open_Read_Write (Name, Fmode);\n-   end Open_Read_Write;\n-\n-   function Open_Read_Write\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor\n-   is\n-      C_Name : String (1 .. Name'Length + 1);\n-   begin\n-      C_Name (1 .. Name'Length) := Name;\n-      C_Name (C_Name'Last)      := ASCII.NUL;\n-      return Open_Read_Write (C_Name (C_Name'First)'Address, Fmode);\n-   end Open_Read_Write;\n-\n-   --------------------\n-   -- Pid_To_Integer --\n-   --------------------\n-\n-   function Pid_To_Integer (Pid : Process_Id) return Integer is\n-   begin\n-      return Integer (Pid);\n-   end Pid_To_Integer;\n-\n-   ----------\n-   -- Read --\n-   ----------\n-\n-   function Read\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer\n-   is\n-   begin\n-      return Integer (System.CRTL.read\n-        (System.CRTL.int (FD), System.CRTL.chars (A), System.CRTL.int (N)));\n-   end Read;\n-\n-   -----------------\n-   -- Rename_File --\n-   -----------------\n-\n-   procedure Rename_File\n-     (Old_Name : C_File_Name;\n-      New_Name : C_File_Name;\n-      Success  : out Boolean)\n-   is\n-      function rename (From, To : Address) return Integer;\n-      pragma Import (C, rename, \"rename\");\n-      R : Integer;\n-   begin\n-      R := rename (Old_Name, New_Name);\n-      Success := (R = 0);\n-   end Rename_File;\n-\n-   procedure Rename_File\n-     (Old_Name : String;\n-      New_Name : String;\n-      Success  : out Boolean)\n-   is\n-      C_Old_Name : String (1 .. Old_Name'Length + 1);\n-      C_New_Name : String (1 .. New_Name'Length + 1);\n-   begin\n-      C_Old_Name (1 .. Old_Name'Length) := Old_Name;\n-      C_Old_Name (C_Old_Name'Last)      := ASCII.NUL;\n-      C_New_Name (1 .. New_Name'Length) := New_Name;\n-      C_New_Name (C_New_Name'Last)      := ASCII.NUL;\n-      Rename_File (C_Old_Name'Address, C_New_Name'Address, Success);\n-   end Rename_File;\n-\n-   -----------------------\n-   -- Set_Close_On_Exec --\n-   -----------------------\n-\n-   procedure Set_Close_On_Exec\n-     (FD            : File_Descriptor;\n-      Close_On_Exec : Boolean;\n-      Status        : out Boolean)\n-   is\n-      function C_Set_Close_On_Exec\n-        (FD : File_Descriptor; Close_On_Exec : System.CRTL.int)\n-         return System.CRTL.int;\n-      pragma Import (C, C_Set_Close_On_Exec, \"__gnat_set_close_on_exec\");\n-   begin\n-      Status := C_Set_Close_On_Exec (FD, Boolean'Pos (Close_On_Exec)) = 0;\n-   end Set_Close_On_Exec;\n-\n-   --------------------\n-   -- Set_Executable --\n-   --------------------\n-\n-   procedure Set_Executable (Name : String) is\n-      procedure C_Set_Executable (Name : C_File_Name);\n-      pragma Import (C, C_Set_Executable, \"__gnat_set_executable\");\n-      C_Name : aliased String (Name'First .. Name'Last + 1);\n-   begin\n-      C_Name (Name'Range)  := Name;\n-      C_Name (C_Name'Last) := ASCII.NUL;\n-      C_Set_Executable (C_Name (C_Name'First)'Address);\n-   end Set_Executable;\n-\n-   --------------------\n-   -- Set_Read_Only --\n-   --------------------\n-\n-   procedure Set_Read_Only (Name : String) is\n-      procedure C_Set_Read_Only (Name : C_File_Name);\n-      pragma Import (C, C_Set_Read_Only, \"__gnat_set_readonly\");\n-      C_Name : aliased String (Name'First .. Name'Last + 1);\n-   begin\n-      C_Name (Name'Range)  := Name;\n-      C_Name (C_Name'Last) := ASCII.NUL;\n-      C_Set_Read_Only (C_Name (C_Name'First)'Address);\n-   end Set_Read_Only;\n-\n-   --------------------\n-   -- Set_Writable --\n-   --------------------\n-\n-   procedure Set_Writable (Name : String) is\n-      procedure C_Set_Writable (Name : C_File_Name);\n-      pragma Import (C, C_Set_Writable, \"__gnat_set_writable\");\n-      C_Name : aliased String (Name'First .. Name'Last + 1);\n-   begin\n-      C_Name (Name'Range)  := Name;\n-      C_Name (C_Name'Last) := ASCII.NUL;\n-      C_Set_Writable (C_Name (C_Name'First)'Address);\n-   end Set_Writable;\n-\n-   ------------\n-   -- Setenv --\n-   ------------\n-\n-   procedure Setenv (Name : String; Value : String) is\n-      F_Name  : String (1 .. Name'Length + 1);\n-      F_Value : String (1 .. Value'Length + 1);\n-\n-      procedure Set_Env_Value (Name, Value : System.Address);\n-      pragma Import (C, Set_Env_Value, \"__gnat_setenv\");\n-\n-   begin\n-      F_Name (1 .. Name'Length) := Name;\n-      F_Name (F_Name'Last)      := ASCII.NUL;\n-\n-      F_Value (1 .. Value'Length) := Value;\n-      F_Value (F_Value'Last)      := ASCII.NUL;\n-\n-      Set_Env_Value (F_Name'Address, F_Value'Address);\n-   end Setenv;\n-\n-   -----------\n-   -- Spawn --\n-   -----------\n-\n-   function Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List) return Integer\n-   is\n-      Junk   : Process_Id;\n-      Result : Integer;\n-   begin\n-      Spawn_Internal (Program_Name, Args, Result, Junk, Blocking => True);\n-      return Result;\n-   end Spawn;\n-\n-   procedure Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Success      : out Boolean)\n-   is\n-   begin\n-      Success := (Spawn (Program_Name, Args) = 0);\n-   end Spawn;\n-\n-   procedure Spawn\n-     (Program_Name           : String;\n-      Args                   : Argument_List;\n-      Output_File_Descriptor : File_Descriptor;\n-      Return_Code            : out Integer;\n-      Err_To_Out             : Boolean := True)\n-   is\n-      Saved_Output : File_Descriptor;\n-      Saved_Error  : File_Descriptor := Invalid_FD; -- prevent compiler warning\n-\n-   begin\n-      --  Set standard output and error to the temporary file\n-\n-      Saved_Output := Dup (Standout);\n-      Dup2 (Output_File_Descriptor, Standout);\n-\n-      if Err_To_Out then\n-         Saved_Error  := Dup (Standerr);\n-         Dup2 (Output_File_Descriptor, Standerr);\n-      end if;\n-\n-      --  Spawn the program\n-\n-      Return_Code := Spawn (Program_Name, Args);\n-\n-      --  Restore the standard output and error\n-\n-      Dup2 (Saved_Output, Standout);\n-\n-      if Err_To_Out then\n-         Dup2 (Saved_Error, Standerr);\n-      end if;\n-\n-      --  And close the saved standard output and error file descriptors\n-\n-      Close (Saved_Output);\n-\n-      if Err_To_Out then\n-         Close (Saved_Error);\n-      end if;\n-   end Spawn;\n-\n-   procedure Spawn\n-     (Program_Name  : String;\n-      Args          : Argument_List;\n-      Output_File   : String;\n-      Success       : out Boolean;\n-      Return_Code   : out Integer;\n-      Err_To_Out    : Boolean := True)\n-   is\n-      FD : File_Descriptor;\n-\n-   begin\n-      Success := True;\n-      Return_Code := 0;\n-\n-      FD := Create_Output_Text_File (Output_File);\n-\n-      if FD = Invalid_FD then\n-         Success := False;\n-         return;\n-      end if;\n-\n-      Spawn (Program_Name, Args, FD, Return_Code, Err_To_Out);\n-\n-      Close (FD, Success);\n-   end Spawn;\n-\n-   --------------------\n-   -- Spawn_Internal --\n-   --------------------\n-\n-   procedure Spawn_Internal\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Result       : out Integer;\n-      Pid          : out Process_Id;\n-      Blocking     : Boolean)\n-   is\n-\n-      procedure Spawn (Args : Argument_List);\n-      --  Call Spawn with given argument list\n-\n-      N_Args : Argument_List (Args'Range);\n-      --  Normalized arguments\n-\n-      -----------\n-      -- Spawn --\n-      -----------\n-\n-      procedure Spawn (Args : Argument_List) is\n-         type Chars is array (Positive range <>) of aliased Character;\n-         type Char_Ptr is access constant Character;\n-\n-         Command_Len : constant Positive := Program_Name'Length + 1\n-                                              + Args_Length (Args);\n-         Command_Last : Natural := 0;\n-         Command : aliased Chars (1 .. Command_Len);\n-         --  Command contains all characters of the Program_Name and Args, all\n-         --  terminated by ASCII.NUL characters\n-\n-         Arg_List_Len : constant Positive := Args'Length + 2;\n-         Arg_List_Last : Natural := 0;\n-         Arg_List : aliased array (1 .. Arg_List_Len) of Char_Ptr;\n-         --  List with pointers to NUL-terminated strings of the Program_Name\n-         --  and the Args and terminated with a null pointer. We rely on the\n-         --  default initialization for the last null pointer.\n-\n-         procedure Add_To_Command (S : String);\n-         --  Add S and a NUL character to Command, updating Last\n-\n-         function Portable_Spawn (Args : Address) return Integer;\n-         pragma Import (C, Portable_Spawn, \"__gnat_portable_spawn\");\n-\n-         function Portable_No_Block_Spawn (Args : Address) return Process_Id;\n-         pragma Import\n-           (C, Portable_No_Block_Spawn, \"__gnat_portable_no_block_spawn\");\n-\n-         --------------------\n-         -- Add_To_Command --\n-         --------------------\n-\n-         procedure Add_To_Command (S : String) is\n-            First : constant Natural := Command_Last + 1;\n-\n-         begin\n-            Command_Last := Command_Last + S'Length;\n-\n-            --  Move characters one at a time, because Command has aliased\n-            --  components.\n-\n-            --  But not volatile, so why is this necessary ???\n-\n-            for J in S'Range loop\n-               Command (First + J - S'First) := S (J);\n-            end loop;\n-\n-            Command_Last := Command_Last + 1;\n-            Command (Command_Last) := ASCII.NUL;\n-\n-            Arg_List_Last := Arg_List_Last + 1;\n-            Arg_List (Arg_List_Last) := Command (First)'Access;\n-         end Add_To_Command;\n-\n-      --  Start of processing for Spawn\n-\n-      begin\n-         Add_To_Command (Program_Name);\n-\n-         for J in Args'Range loop\n-            Add_To_Command (Args (J).all);\n-         end loop;\n-\n-         if Blocking then\n-            Pid     := Invalid_Pid;\n-            Result  := Portable_Spawn (Arg_List'Address);\n-         else\n-            Pid     := Portable_No_Block_Spawn (Arg_List'Address);\n-            Result  := Boolean'Pos (Pid /= Invalid_Pid);\n-         end if;\n-      end Spawn;\n-\n-   --  Start of processing for Spawn_Internal\n-\n-   begin\n-      --  Copy arguments into a local structure\n-\n-      for K in N_Args'Range loop\n-         N_Args (K) := new String'(Args (K).all);\n-      end loop;\n-\n-      --  Normalize those arguments\n-\n-      Normalize_Arguments (N_Args);\n-\n-      --  Call spawn using the normalized arguments\n-\n-      Spawn (N_Args);\n-\n-      --  Free arguments list\n-\n-      for K in N_Args'Range loop\n-         Free (N_Args (K));\n-      end loop;\n-   end Spawn_Internal;\n-\n-   ---------------------------\n-   -- To_Path_String_Access --\n-   ---------------------------\n-\n-   function To_Path_String_Access\n-     (Path_Addr : Address;\n-      Path_Len  : Integer) return String_Access\n-   is\n-      subtype Path_String is String (1 .. Path_Len);\n-      type    Path_String_Access is access Path_String;\n-\n-      function Address_To_Access is new\n-        Unchecked_Conversion (Source => Address,\n-                              Target => Path_String_Access);\n-\n-      Path_Access : constant Path_String_Access :=\n-                      Address_To_Access (Path_Addr);\n-\n-      Return_Val  : String_Access;\n-\n-   begin\n-      Return_Val := new String (1 .. Path_Len);\n-\n-      for J in 1 .. Path_Len loop\n-         Return_Val (J) := Path_Access (J);\n-      end loop;\n-\n-      return Return_Val;\n-   end To_Path_String_Access;\n-\n-   ------------------\n-   -- Wait_Process --\n-   ------------------\n-\n-   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean) is\n-      Status : Integer;\n-\n-      function Portable_Wait (S : Address) return Process_Id;\n-      pragma Import (C, Portable_Wait, \"__gnat_portable_wait\");\n-\n-   begin\n-      Pid := Portable_Wait (Status'Address);\n-      Success := (Status = 0);\n-   end Wait_Process;\n-\n-   -----------\n-   -- Write --\n-   -----------\n-\n-   function Write\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer\n-   is\n-   begin\n-      return Integer (System.CRTL.write\n-        (System.CRTL.int (FD), System.CRTL.chars (A), System.CRTL.int (N)));\n-   end Write;\n-\n-end GNAT.OS_Lib;\n+pragma No_Body;"}, {"sha": "aebffec7db8c1d15d33d5ee92d599bdba0c4052d", "filename": "gcc/ada/g-os_lib.ads", "status": "modified", "additions": 4, "deletions": 817, "changes": 821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/690792a21d56ce57d19d45786c24da692f667a4c/gcc%2Fada%2Fg-os_lib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/690792a21d56ce57d19d45786c24da692f667a4c/gcc%2Fada%2Fg-os_lib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-os_lib.ads?ref=690792a21d56ce57d19d45786c24da692f667a4c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2006, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2007, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -46,821 +46,8 @@\n --  Except where specifically noted, these routines are portable across all\n --  GNAT implementations on all supported operating systems.\n \n-with System;\n-with GNAT.Strings;\n+--  See file s-os_lib.ads for full documentation of the interface\n \n-package GNAT.OS_Lib is\n-   pragma Elaborate_Body (OS_Lib);\n+with System.OS_Lib;\n \n-   -----------------------\n-   -- String Operations --\n-   -----------------------\n-\n-   --  These are reexported from package Strings (which was introduced to\n-   --  avoid different packages declarting different types unnecessarily).\n-   --  See package GNAT.Strings for details.\n-\n-   subtype String_Access is Strings.String_Access;\n-\n-   function \"=\" (Left, Right : String_Access) return Boolean\n-     renames Strings.\"=\";\n-\n-   procedure Free (X : in out String_Access) renames Strings.Free;\n-\n-   subtype String_List is Strings.String_List;\n-\n-   function \"=\" (Left, Right : String_List) return Boolean\n-     renames Strings.\"=\";\n-\n-   function \"&\" (Left : String_Access; Right : String_Access)\n-     return String_List renames Strings.\"&\";\n-   function \"&\" (Left : String_Access; Right : String_List)\n-     return String_List renames Strings.\"&\";\n-   function \"&\" (Left : String_List; Right : String_Access)\n-     return String_List renames Strings.\"&\";\n-   function \"&\" (Left : String_List; Right : String_List)\n-     return String_List renames Strings.\"&\";\n-\n-   subtype String_List_Access is Strings.String_List_Access;\n-\n-   function \"=\" (Left, Right : String_List_Access) return Boolean\n-     renames Strings.\"=\";\n-\n-   procedure Free (Arg : in out String_List_Access)\n-     renames Strings.Free;\n-\n-   ---------------------\n-   -- Time/Date Stuff --\n-   ---------------------\n-\n-   type OS_Time is private;\n-   --  The OS's notion of time is represented by the private type OS_Time.\n-   --  This is the type returned by the File_Time_Stamp functions to obtain\n-   --  the time stamp of a specified file. Functions and a procedure (modeled\n-   --  after the similar subprograms in package Calendar) are provided for\n-   --  extracting information from a value of this type. Although these are\n-   --  called GM, the intention is not that they provide GMT times in all\n-   --  cases but rather the actual (time-zone independent) time stamp of the\n-   --  file (of course in Unix systems, this *is* in GMT form).\n-\n-   Invalid_Time : constant OS_Time;\n-   --  A special unique value used to flag an invalid time stamp value\n-\n-   subtype Year_Type   is Integer range 1900 .. 2099;\n-   subtype Month_Type  is Integer range    1 ..   12;\n-   subtype Day_Type    is Integer range    1 ..   31;\n-   subtype Hour_Type   is Integer range    0 ..   23;\n-   subtype Minute_Type is Integer range    0 ..   59;\n-   subtype Second_Type is Integer range    0 ..   59;\n-   --  Declarations similar to those in Calendar, breaking down the time\n-\n-   function Current_Time return OS_Time;\n-   --  Return the system clock value as OS_Time\n-\n-   function GM_Year    (Date : OS_Time) return Year_Type;\n-   function GM_Month   (Date : OS_Time) return Month_Type;\n-   function GM_Day     (Date : OS_Time) return Day_Type;\n-   function GM_Hour    (Date : OS_Time) return Hour_Type;\n-   function GM_Minute  (Date : OS_Time) return Minute_Type;\n-   function GM_Second  (Date : OS_Time) return Second_Type;\n-   --  Functions to extract information from OS_Time value\n-\n-   function \"<\"  (X, Y : OS_Time) return Boolean;\n-   function \">\"  (X, Y : OS_Time) return Boolean;\n-   function \">=\" (X, Y : OS_Time) return Boolean;\n-   function \"<=\" (X, Y : OS_Time) return Boolean;\n-   --  Basic comparison operators on OS_Time with obvious meanings. Note that\n-   --  these have Intrinsic convention, so for example it is not permissible\n-   --  to create accesses to any of these functions.\n-\n-   procedure GM_Split\n-     (Date   : OS_Time;\n-      Year   : out Year_Type;\n-      Month  : out Month_Type;\n-      Day    : out Day_Type;\n-      Hour   : out Hour_Type;\n-      Minute : out Minute_Type;\n-      Second : out Second_Type);\n-   --  Analogous to the Split routine in Ada.Calendar, takes an OS_Time\n-   --  and provides a representation of it as a set of component parts,\n-   --  to be interpreted as a date point in UTC.\n-\n-   ----------------\n-   -- File Stuff --\n-   ----------------\n-\n-   --  These routines give access to the open/creat/close/read/write level of\n-   --  I/O routines in the typical C library (these functions are not part of\n-   --  the ANSI C standard, but are typically available in all systems). See\n-   --  also package Interfaces.C_Streams for access to the stream level\n-   --  routines.\n-\n-   --  Note on file names. If a file name is passed as type String in any of\n-   --  the following specifications, then the name is a normal Ada string and\n-   --  need not be NUL-terminated. However, a trailing NUL character is\n-   --  permitted, and will be ignored (more accurately, the NUL and any\n-   --  characters that follow it will be ignored).\n-\n-   type File_Descriptor is new Integer;\n-   --  Corresponds to the int file handle values used in the C routines\n-\n-   Standin  : constant File_Descriptor := 0;\n-   Standout : constant File_Descriptor := 1;\n-   Standerr : constant File_Descriptor := 2;\n-   --  File descriptors for standard input output files\n-\n-   Invalid_FD : constant File_Descriptor := -1;\n-   --  File descriptor returned when error in opening/creating file;\n-\n-   type Mode is (Binary, Text);\n-   for Mode'Size use Integer'Size;\n-   for Mode use (Binary => 0, Text => 1);\n-   --  Used in all the Open and Create calls to specify if the file is to be\n-   --  opened in binary mode or text mode. In systems like Unix, this has no\n-   --  effect, but in systems capable of text mode translation, the use of\n-   --  Text as the mode parameter causes the system to do CR/LF translation\n-   --  and also to recognize the DOS end of file character on input. The use\n-   --  of Text where appropriate allows programs to take a portable Unix view\n-   --  of DOS-format files and process them appropriately.\n-\n-   function Open_Read\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Open file Name for reading, returning file descriptor File descriptor\n-   --  returned is Invalid_FD if file cannot be opened.\n-\n-   function Open_Read_Write\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Open file Name for both reading and writing, returning file descriptor.\n-   --  File descriptor returned is Invalid_FD if file cannot be opened.\n-\n-   function Create_File\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Creates new file with given name for writing, returning file descriptor\n-   --  for subsequent use in Write calls. File descriptor returned is\n-   --  Invalid_FD if file cannot be successfully created.\n-\n-   function Create_Output_Text_File (Name : String) return File_Descriptor;\n-   --  Creates new text file with given name suitable to redirect standard\n-   --  output, returning file descriptor. File descriptor returned is\n-   --  Invalid_FD if file cannot be successfully created.\n-\n-   function Create_New_File\n-     (Name  : String;\n-      Fmode : Mode) return File_Descriptor;\n-   --  Create new file with given name for writing, returning file descriptor\n-   --  for subsequent use in Write calls. This differs from Create_File in\n-   --  that it fails if the file already exists. File descriptor returned is\n-   --  Invalid_FD if the file exists or cannot be created.\n-\n-   Temp_File_Len : constant Integer := 12;\n-   --  Length of name returned by Create_Temp_File call (GNAT-XXXXXX & NUL)\n-\n-   subtype Temp_File_Name is String (1 .. Temp_File_Len);\n-   --  String subtype set by Create_Temp_File\n-\n-   procedure Create_Temp_File\n-     (FD   : out File_Descriptor;\n-      Name : out Temp_File_Name);\n-   --  Create and open for writing a temporary file in the current working\n-   --  directory. The name of the file and the File Descriptor are returned.\n-   --  The File Descriptor returned is Invalid_FD in the case of failure. No\n-   --  mode parameter is provided. Since this is a temporary file, there is no\n-   --  point in doing text translation on it.\n-   --\n-   --  On some OSes, the maximum number of temp files that can be created with\n-   --  this procedure may be limited. When the maximum is reached, this\n-   --  procedure returns Invalid_FD. On some OSes, there may be a race\n-   --  condition between processes trying to create temp files at the same\n-   --  time in the same directory using this procedure.\n-\n-   procedure Create_Temp_File\n-     (FD   : out File_Descriptor;\n-      Name : out String_Access);\n-   --  Create and open for writing a temporary file in the current working\n-   --  directory. The name of the file and the File Descriptor are returned.\n-   --  No mode parameter is provided. Since this is a temporary file, there is\n-   --  no point in doing text translation on it. It is the responsibility of\n-   --  the caller to deallocate the access value returned in Name.\n-   --\n-   --  This procedure will always succeed if the current working directory is\n-   --  writable. If the current working directory is not writable, then\n-   --  Invalid_FD is returned for the file descriptor and null for the Name.\n-   --  There is no race condition problem between processes trying to create\n-   --  temp files at the same time in the same directory.\n-\n-   procedure Close (FD : File_Descriptor; Status : out Boolean);\n-   --  Close file referenced by FD. Status is False if the underlying service\n-   --  failed. Reasons for failure include: disk full, disk quotas exceeded\n-   --  and invalid file descriptor (the file may have been closed twice).\n-\n-   procedure Close (FD : File_Descriptor);\n-   --  Close file referenced by FD. This form is used when the caller wants to\n-   --  ignore any possible error (see above for error cases).\n-\n-   procedure Set_Close_On_Exec\n-     (FD            : File_Descriptor;\n-      Close_On_Exec : Boolean;\n-      Status        : out Boolean);\n-   --  When Close_On_Exec is True, mark FD to be closed automatically when new\n-   --  program is executed by the calling process (i.e. prevent FD from being\n-   --  inherited by child processes). When Close_On_Exec is False, mark FD to\n-   --  not be closed on exec (i.e. allow it to be inherited). Status is False\n-   --  if the operation could not be performed.\n-\n-   procedure Delete_File (Name : String; Success : out Boolean);\n-   --  Deletes file. Success is set True or False indicating if the delete is\n-   --  successful.\n-\n-   procedure Rename_File\n-     (Old_Name : String;\n-      New_Name : String;\n-      Success  : out Boolean);\n-   --  Rename a file. Success is set True or False indicating if the rename is\n-   --  successful or not.\n-\n-   --  The following defines the mode for the Copy_File procedure below. Note\n-   --  that \"time stamps and other file attributes\" in the descriptions below\n-   --  refers to the creation and last modification times, and also the file\n-   --  access (read/write/execute) status flags.\n-\n-   type Copy_Mode is\n-     (Copy,\n-      --  Copy the file. It is an error if the target file already exists. The\n-      --  time stamps and other file attributes are preserved in the copy.\n-\n-      Overwrite,\n-      --  If the target file exists, the file is replaced otherwise the file\n-      --  is just copied. The time stamps and other file attributes are\n-      --  preserved in the copy.\n-\n-      Append);\n-      --  If the target file exists, the contents of the source file is\n-      --  appended at the end. Otherwise the source file is just copied. The\n-      --  time stamps and other file attributes are are preserved if the\n-      --  destination file does not exist.\n-\n-   type Attribute is\n-     (Time_Stamps,\n-      --  Copy time stamps from source file to target file. All other\n-      --  attributes are set to normal default values for file creation.\n-\n-      Full,\n-      --  All attributes are copied from the source file to the target file.\n-      --  This includes the timestamps, and for example also includes\n-      --  read/write/execute attributes in Unix systems.\n-\n-      None);\n-      --  No attributes are copied. All attributes including the time stamp\n-      --  values are set to normal default values for file creation.\n-\n-   --  Note: The default is Time_Stamps, which corresponds to the normal\n-   --  default on Windows style systems. Full corresponds to the typical\n-   --  effect of \"cp -p\" on Unix systems, and None corresponds to the typical\n-   --  effect of \"cp\" on Unix systems.\n-\n-   --  Note: Time_Stamps and Full are not supported on VMS and VxWorks\n-\n-   procedure Copy_File\n-     (Name     : String;\n-      Pathname : String;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps);\n-   --  Copy a file. Name must designate a single file (no wild cards allowed).\n-   --  Pathname can be a filename or directory name. In the latter case Name\n-   --  is copied into the directory preserving the same file name. Mode\n-   --  defines the kind of copy, see above with the default being a normal\n-   --  copy in which the target file must not already exist. Success is set to\n-   --  True or False indicating if the copy is successful (depending on the\n-   --  specified Mode).\n-   --\n-   --  Note: this procedure is only supported to a very limited extent on VMS.\n-   --  The only supported mode is Overwrite, and the only supported value for\n-   --  Preserve is None, resulting in the default action which for Overwrite\n-   --  is to leave attributes unchanged. Furthermore, the copy only works for\n-   --  simple text files.\n-\n-   procedure Copy_Time_Stamps (Source, Dest : String; Success : out Boolean);\n-   --  Copy Source file time stamps (last modification and last access time\n-   --  stamps) to Dest file. Source and Dest must be valid filenames,\n-   --  furthermore Dest must be writable. Success will be set to True if the\n-   --  operation was successful and False otherwise.\n-   --\n-   --  Note: this procedure is not supported on VMS and VxWorks. On these\n-   --  platforms, Success is always set to False.\n-\n-   function Read\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer;\n-   --  Read N bytes to address A from file referenced by FD. Returned value is\n-   --  count of bytes actually read, which can be less than N at EOF.\n-\n-   function Write\n-     (FD : File_Descriptor;\n-      A  : System.Address;\n-      N  : Integer) return Integer;\n-   --  Write N bytes from address A to file referenced by FD. The returned\n-   --  value is the number of bytes written, which can be less than N if a\n-   --  disk full condition was detected.\n-\n-   Seek_Cur : constant := 1;\n-   Seek_End : constant := 2;\n-   Seek_Set : constant := 0;\n-   --  Used to indicate origin for Lseek call\n-\n-   procedure Lseek\n-     (FD     : File_Descriptor;\n-      offset : Long_Integer;\n-      origin : Integer);\n-   pragma Import (C, Lseek, \"__gnat_lseek\");\n-   --  Sets the current file pointer to the indicated offset value, relative\n-   --  to the current position (origin = SEEK_CUR), end of file (origin =\n-   --  SEEK_END), or start of file (origin = SEEK_SET).\n-\n-   function File_Length (FD : File_Descriptor) return Long_Integer;\n-   pragma Import (C, File_Length, \"__gnat_file_length\");\n-   --  Get length of file from file descriptor FD\n-\n-   function File_Time_Stamp (Name : String) return OS_Time;\n-   --  Given the name of a file or directory, Name, obtains and returns the\n-   --  time stamp. This function can be used for an unopened file. Returns\n-   --  Invalid_Time is Name doesn't correspond to an existing file.\n-\n-   function File_Time_Stamp (FD : File_Descriptor) return OS_Time;\n-   --  Get time stamp of file from file descriptor FD Returns Invalid_Time is\n-   --  FD doesn't correspond to an existing file.\n-\n-   function Normalize_Pathname\n-     (Name           : String;\n-      Directory      : String  := \"\";\n-      Resolve_Links  : Boolean := True;\n-      Case_Sensitive : Boolean := True) return String;\n-   --  Returns a file name as an absolute path name, resolving all relative\n-   --  directories, and symbolic links. The parameter Directory is a fully\n-   --  resolved path name for a directory, or the empty string (the default).\n-   --  Name is the name of a file, which is either relative to the given\n-   --  directory name, if Directory is non-null, or to the current working\n-   --  directory if Directory is null. The result returned is the normalized\n-   --  name of the file. For most cases, if two file names designate the same\n-   --  file through different paths, Normalize_Pathname will return the same\n-   --  canonical name in both cases. However, there are cases when this is not\n-   --  true; for example, this is not true in Unix for two hard links\n-   --  designating the same file.\n-   --\n-   --  On Windows, the returned path will start with a drive letter except\n-   --  when Directory is not empty and does not include a drive letter. If\n-   --  Directory is empty (the default) and Name is a relative path or an\n-   --  absolute path without drive letter, the letter of the current drive\n-   --  will start the returned path. If Case_Sensitive is True (the default),\n-   --  then this drive letter will be forced to upper case (\"C:\\...\").\n-   --\n-   --  If Resolve_Links is set to True, then the symbolic links, on systems\n-   --  that support them, will be fully converted to the name of the file or\n-   --  directory pointed to. This is slightly less efficient, since it\n-   --  requires system calls.\n-   --\n-   --  If Name cannot be resolved or is null on entry (for example if there is\n-   --  symbolic link circularity, e.g. A is a symbolic link for B, and B is a\n-   --  symbolic link for A), then Normalize_Pathname returns an empty  string.\n-   --\n-   --  In VMS, if Name follows the VMS syntax file specification, it is first\n-   --  converted into Unix syntax. If the conversion fails, Normalize_Pathname\n-   --  returns an empty string.\n-   --\n-   --  For case-sensitive file systems, the value of Case_Sensitive parameter\n-   --  is ignored. For file systems that are not case-sensitive, such as\n-   --  Windows and OpenVMS, if this parameter is set to False, then the file\n-   --  and directory names are folded to lower case. This allows checking\n-   --  whether two files are the same by applying this function to their names\n-   --  and comparing the results. If Case_Sensitive is set to True, this\n-   --  function does not change the casing of file and directory names.\n-\n-   function Is_Absolute_Path (Name : String) return Boolean;\n-   --  Returns True if Name is an absolute path name, i.e. it designates a\n-   --  file or directory absolutely rather than relative to another directory.\n-\n-   function Is_Regular_File (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of an existing\n-   --  regular file. Returns True if so, False otherwise. Name may be an\n-   --  absolute path name or a relative path name, including a simple file\n-   --  name. If it is a relative path name, it is relative to the current\n-   --  working directory.\n-\n-   function Is_Directory (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of a directory.\n-   --  Returns True if so, False otherwise. Name may be an absolute path\n-   --  name or a relative path name, including a simple file name. If it is\n-   --  a relative path name, it is relative to the current working directory.\n-\n-   function Is_Readable_File (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of an existing file\n-   --  that is readable. Returns True if so, False otherwise. Note that this\n-   --  function simply interrogates the file attributes (e.g. using the C\n-   --  function stat), so it does not indicate a situation in which a file may\n-   --  not actually be readable due to some other process having exclusive\n-   --  access.\n-\n-   function Is_Writable_File (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the name of an existing file\n-   --  that is writable. Returns True if so, False otherwise. Note that this\n-   --  function simply interrogates the file attributes (e.g. using the C\n-   --  function stat), so it does not indicate a situation in which a file may\n-   --  not actually be writeable due to some other process having exclusive\n-   --  access.\n-\n-   function Is_Symbolic_Link (Name : String) return Boolean;\n-   --  Determines if the given string, Name, is the path of a symbolic link on\n-   --  systems that support it. Returns True if so, False if the path is not a\n-   --  symbolic link or if the system does not support symbolic links.\n-   --\n-   --  A symbolic link is an indirect pointer to a file; its directory entry\n-   --  contains the name of the file to which it is linked. Symbolic links may\n-   --  span file systems and may refer to directories.\n-\n-   procedure Set_Writable (Name : String);\n-   --  Change the permissions on the named file to make it writable\n-   --  for its owner.\n-\n-   procedure Set_Read_Only (Name : String);\n-   --  Change the permissions on the named file to make it non-writable\n-   --  for its owner.\n-\n-   procedure Set_Executable (Name : String);\n-   --  Change the permissions on the named file to make it executable\n-   --  for its owner.\n-\n-   function Locate_Exec_On_Path\n-     (Exec_Name : String) return String_Access;\n-   --  Try to locate an executable whose name is given by Exec_Name in the\n-   --  directories listed in the environment Path. If the Exec_Name doesn't\n-   --  have the executable suffix, it will be appended before the search.\n-   --  Otherwise works like Locate_Regular_File below.\n-   --\n-   --  Note that this function allocates some memory for the returned value.\n-   --  This memory needs to be deallocated after use.\n-\n-   function Locate_Regular_File\n-     (File_Name : String;\n-      Path      : String) return String_Access;\n-   --  Try to locate a regular file whose name is given by File_Name in the\n-   --  directories listed in Path. If a file is found, its full pathname is\n-   --  returned; otherwise, a null pointer is returned. If the File_Name given\n-   --  is an absolute pathname, then Locate_Regular_File just checks that the\n-   --  file exists and is a regular file. Otherwise, if the File_Name given\n-   --  includes directory information, Locate_Regular_File first checks if the\n-   --  file exists relative to the current directory. If it does not, or if\n-   --  the File_Name given is a simple file name, the Path argument is parsed\n-   --  according to OS conventions, and for each directory in the Path a check\n-   --  is made if File_Name is a relative pathname of a regular file from that\n-   --  directory.\n-   --\n-   --  Note that this function allocates some memory for the returned value.\n-   --  This memory needs to be deallocated after use.\n-\n-   function Get_Debuggable_Suffix return String_Access;\n-   --  Return the debuggable suffix convention. Usually this is the same as\n-   --  the convention for Get_Executable_Suffix. The result is allocated on\n-   --  the heap and should be freed after use to avoid storage leaks.\n-\n-   function Get_Target_Debuggable_Suffix return String_Access;\n-   --  Return the target debuggable suffix convention. Usually this is the\n-   --  same as the convention for Get_Executable_Suffix. The result is\n-   --  allocated on the heap and should be freed after use to avoid storage\n-   --  leaks.\n-\n-   function Get_Executable_Suffix return String_Access;\n-   --  Return the executable suffix convention. The result is allocated on the\n-   --  heap and should be freed after use to avoid storage leaks.\n-\n-   function Get_Object_Suffix return String_Access;\n-   --  Return the object suffix convention. The result is allocated on the heap\n-   --  and should be freed after use to avoid storage leaks.\n-\n-   function Get_Target_Executable_Suffix return String_Access;\n-   --  Return the target executable suffix convention. The result is allocated\n-   --  on the heap and should be freed after use to avoid storage leaks.\n-\n-   function Get_Target_Object_Suffix return String_Access;\n-   --  Return the target object suffix convention. The result is allocated on\n-   --  the heap and should be freed after use to avoid storage leaks.\n-\n-   --  The following section contains low-level routines using addresses to\n-   --  pass file name and executable name. In each routine the name must be\n-   --  Nul-Terminated. For complete documentation refer to the equivalent\n-   --  routine (using String in place of C_File_Name) defined above.\n-\n-   subtype C_File_Name is System.Address;\n-   --  This subtype is used to document that a parameter is the address of a\n-   --  null-terminated string containing the name of a file.\n-\n-   --  All the following functions need comments ???\n-\n-   function Open_Read\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n-\n-   function Open_Read_Write\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n-\n-   function Create_File\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n-\n-   function Create_New_File\n-     (Name  : C_File_Name;\n-      Fmode : Mode) return File_Descriptor;\n-\n-   procedure Delete_File (Name : C_File_Name; Success : out Boolean);\n-\n-   procedure Rename_File\n-     (Old_Name : C_File_Name;\n-      New_Name : C_File_Name;\n-      Success  : out Boolean);\n-\n-   procedure Copy_File\n-     (Name     : C_File_Name;\n-      Pathname : C_File_Name;\n-      Success  : out Boolean;\n-      Mode     : Copy_Mode := Copy;\n-      Preserve : Attribute := Time_Stamps);\n-\n-   procedure Copy_Time_Stamps\n-     (Source, Dest : C_File_Name;\n-      Success      : out Boolean);\n-\n-   function File_Time_Stamp (Name : C_File_Name) return OS_Time;\n-   --  Returns Invalid_Time is Name doesn't correspond to an existing file\n-\n-   function Is_Regular_File (Name : C_File_Name) return Boolean;\n-   function Is_Directory (Name : C_File_Name) return Boolean;\n-   function Is_Readable_File (Name : C_File_Name) return Boolean;\n-   function Is_Writable_File (Name : C_File_Name) return Boolean;\n-   function Is_Symbolic_Link (Name : C_File_Name) return Boolean;\n-\n-   function Locate_Regular_File\n-     (File_Name : C_File_Name;\n-      Path      : C_File_Name) return String_Access;\n-\n-   ------------------\n-   -- Subprocesses --\n-   ------------------\n-\n-   subtype Argument_List is String_List;\n-   --  Type used for argument list in call to Spawn. The lower bound of the\n-   --  array should be 1, and the length of the array indicates the number of\n-   --  arguments.\n-\n-   subtype Argument_List_Access is String_List_Access;\n-   --  Type used to return Argument_List without dragging in secondary stack.\n-   --  Note that there is a Free procedure declared for this subtype which\n-   --  frees the array and all referenced strings.\n-\n-   procedure Normalize_Arguments (Args : in out Argument_List);\n-   --  Normalize all arguments in the list. This ensure that the argument list\n-   --  is compatible with the running OS and will works fine with Spawn and\n-   --  Non_Blocking_Spawn for example. If Normalize_Arguments is called twice\n-   --  on the same list it will do nothing the second time. Note that Spawn\n-   --  and Non_Blocking_Spawn call Normalize_Arguments automatically, but\n-   --  since there is a guarantee that a second call does nothing, this\n-   --  internal call will have no effect if Normalize_Arguments is called\n-   --  before calling Spawn. The call to Normalize_Arguments assumes that the\n-   --  individual referenced arguments in Argument_List are on the heap, and\n-   --  may free them and reallocate if they are modified.\n-\n-   procedure Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Success      : out Boolean);\n-   --  This procedure spawns a program with a given list of arguments. The\n-   --  first parameter of is the name of the executable. The second parameter\n-   --  contains the arguments to be passed to this program. Success is False\n-   --  if the named program could not be spawned or its execution completed\n-   --  unsuccessfully. Note that the caller will be blocked until the\n-   --  execution of the spawned program is complete. For maximum portability,\n-   --  use a full path name for the Program_Name argument. On some systems\n-   --  (notably Unix systems) a simple file name may also work (if the\n-   --  executable can be located in the path).\n-   --\n-   --  \"Spawn\" should not be used in tasking applications. Why not??? More\n-   --  documentation would be helpful here ??? Is it really tasking programs,\n-   --  or tasking activity that cause trouble ???\n-   --\n-   --  Note: Arguments in Args that contain spaces and/or quotes such as\n-   --  \"--GCC=gcc -v\" or \"--GCC=\"\"gcc -v\"\"\" are not portable across all\n-   --  operating systems, and would not have the desired effect if they were\n-   --  passed directly to the operating system. To avoid this problem, Spawn\n-   --  makes an internal call to Normalize_Arguments, which ensures that such\n-   --  arguments are modified in a manner that ensures that the desired effect\n-   --  is obtained on all operating systems. The caller may call\n-   --  Normalize_Arguments explicitly before the call (e.g. to print out the\n-   --  exact form of arguments passed to the operating system). In this case\n-   --  the guarantee a second call to Normalize_Arguments has no effect\n-   --  ensures that the internal call will not affect the result. Note that\n-   --  the implicit call to Normalize_Arguments may free and reallocate some\n-   --  of the individual arguments.\n-   --\n-   --  This function will always set Success to False under VxWorks and other\n-   --  similar operating systems which have no notion of the concept of\n-   --  dynamically executable file.\n-\n-   function Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List) return Integer;\n-   --  Similar to the above procedure, but returns the actual status returned\n-   --  by the operating system, or -1 under VxWorks and any other similar\n-   --  operating systems which have no notion of separately spawnable programs.\n-   --\n-   --  \"Spawn\" should not be used in tasking applications.\n-\n-   procedure Spawn\n-     (Program_Name           : String;\n-      Args                   : Argument_List;\n-      Output_File_Descriptor : File_Descriptor;\n-      Return_Code            : out Integer;\n-      Err_To_Out             : Boolean := True);\n-   --  Similar to the procedure above, but redirects the output to the file\n-   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n-   --  Standard Error output is also redirected.\n-   --  Return_Code is set to the status code returned by the operating system\n-   --\n-   --  \"Spawn\" should not be used in tasking applications.\n-\n-   procedure Spawn\n-     (Program_Name  : String;\n-      Args          : Argument_List;\n-      Output_File   : String;\n-      Success       : out Boolean;\n-      Return_Code   : out Integer;\n-      Err_To_Out    : Boolean := True);\n-   --  Similar to the procedure above, but saves the output of the command to\n-   --  a file with the name Output_File.\n-   --\n-   --  Success is set to True if the command is executed and its output\n-   --  successfully written to the file. If Success is True, then Return_Code\n-   --  will be set to the status code returned by the operating system.\n-   --  Otherwise, Return_Code is undefined.\n-   --\n-   --  \"Spawn\" should not be used in tasking applications.\n-\n-   type Process_Id is private;\n-   --  A private type used to identify a process activated by the following\n-   --  non-blocking calls. The only meaningful operation on this type is a\n-   --  comparison for equality.\n-\n-   Invalid_Pid : constant Process_Id;\n-   --  A special value used to indicate errors, as described below\n-\n-   function Pid_To_Integer (Pid : Process_Id) return Integer;\n-   --  Convert a process id to an Integer. Useful for writing hash functions\n-   --  for type Process_Id or to compare two Process_Id (e.g. for sorting).\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List) return Process_Id;\n-   --  This is a non blocking call. The Process_Id of the spawned process is\n-   --  returned. Parameters are to be used as in Spawn. If Invalid_Pid is\n-   --  returned the program could not be spawned.\n-   --\n-   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name           : String;\n-      Args                   : Argument_List;\n-      Output_File_Descriptor : File_Descriptor;\n-      Err_To_Out             : Boolean := True) return Process_Id;\n-   --  Similar to the procedure above, but redirects the output to the file\n-   --  designated by Output_File_Descriptor. If Err_To_Out is True, then the\n-   --  Standard Error output is also redirected. Invalid_Pid is returned\n-   --  if the program could not be spawned successfully.\n-   --\n-   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   function Non_Blocking_Spawn\n-     (Program_Name : String;\n-      Args         : Argument_List;\n-      Output_File  : String;\n-      Err_To_Out   : Boolean := True) return Process_Id;\n-   --  Similar to the procedure above, but saves the output of the command to\n-   --  a file with the name Output_File.\n-   --\n-   --  Success is set to True if the command is executed and its output\n-   --  successfully written to the file. Invalid_Pid is returned if the output\n-   --  file could not be created or if the program could not be spawned\n-   --  successfully.\n-   --\n-   --  \"Non_Blocking_Spawn\" should not be used in tasking applications.\n-   --\n-   --  This function will always return Invalid_Pid under VxWorks, since there\n-   --  is no notion of executables under this OS.\n-\n-   procedure Wait_Process (Pid : out Process_Id; Success : out Boolean);\n-   --  Wait for the completion of any of the processes created by previous\n-   --  calls to Non_Blocking_Spawn. The caller will be suspended until one of\n-   --  these processes terminates (normally or abnormally). If any of these\n-   --  subprocesses terminates prior to the call to Wait_Process (and has not\n-   --  been returned by a previous call to Wait_Process), then the call to\n-   --  Wait_Process is immediate. Pid identifies the process that has\n-   --  terminated (matching the value returned from Non_Blocking_Spawn).\n-   --  Success is set to True if this sub-process terminated successfully. If\n-   --  Pid = Invalid_Pid, there were no subprocesses left to wait on.\n-   --\n-   --  This function will always set success to False under VxWorks, since\n-   --  there is no notion of executables under this OS.\n-\n-   function Argument_String_To_List\n-     (Arg_String : String) return Argument_List_Access;\n-   --  Take a string that is a program and its arguments and parse it into an\n-   --  Argument_List. Note that the result is allocated on the heap, and must\n-   --  be freed by the programmer (when it is no longer needed) to avoid\n-   --  memory leaks.\n-\n-   -------------------\n-   -- Miscellaneous --\n-   -------------------\n-\n-   function Getenv (Name : String) return String_Access;\n-   --  Get the value of the environment variable. Returns an access to the\n-   --  empty string if the environment variable does not exist or has an\n-   --  explicit null value (in some operating systems these are distinct\n-   --  cases, in others they are not; this interface abstracts away that\n-   --  difference. The argument is allocated on the heap (even in the null\n-   --  case), and needs to be freed explicitly when no longer needed to avoid\n-   --  memory leaks.\n-\n-   procedure Setenv (Name : String; Value : String);\n-   --  Set the value of the environment variable Name to Value. This call\n-   --  modifies the current environment, but does not modify the parent\n-   --  process environment. After a call to Setenv, Getenv (Name) will always\n-   --  return a String_Access referencing the same String as Value. This is\n-   --  true also for the null string case (the actual effect may be to either\n-   --  set an explicit null as the value, or to remove the entry, this is\n-   --  operating system dependent). Note that any following calls to Spawn\n-   --  will pass an environment to the spawned process that includes the\n-   --  changes made by Setenv calls. This procedure is not available on VMS.\n-\n-   procedure OS_Exit (Status : Integer);\n-   pragma Import (C, OS_Exit, \"__gnat_os_exit\");\n-   pragma No_Return (OS_Exit);\n-   --  Exit to OS with given status code (program is terminated). Note that\n-   --  this is abrupt termination. All tasks are immediately terminated. There\n-   --  is no finalization or other cleanup actions performed.\n-\n-   procedure OS_Abort;\n-   pragma Import (C, OS_Abort, \"abort\");\n-   pragma No_Return (OS_Abort);\n-   --  Exit to OS signalling an abort (traceback or other appropriate\n-   --  diagnostic information should be given if possible, or entry made to\n-   --  the debugger if that is possible).\n-\n-   function Errno return Integer;\n-   pragma Import (C, Errno, \"__get_errno\");\n-   --  Return the task-safe last error number\n-\n-   procedure Set_Errno (Errno : Integer);\n-   pragma Import (C, Set_Errno, \"__set_errno\");\n-   --  Set the task-safe error number\n-\n-   Directory_Separator : constant Character;\n-   --  The character that is used to separate parts of a pathname\n-\n-   Path_Separator : constant Character;\n-   --  The character to separate paths in an environment variable value\n-\n-private\n-   pragma Import (C, Path_Separator, \"__gnat_path_separator\");\n-   pragma Import (C, Directory_Separator, \"__gnat_dir_separator\");\n-   pragma Import (C, Current_Time, \"__gnat_current_time\");\n-\n-   type OS_Time is new Long_Integer;\n-   --  Type used for timestamps in the compiler. This type is used to hold\n-   --  time stamps, but may have a different representation than C's time_t.\n-   --  This type needs to match the declaration of OS_Time in adaint.h.\n-\n-   --  Add pragma Inline statements for comparison operations on OS_Time. It\n-   --  would actually be nice to use pragma Import (Intrinsic) here, but this\n-   --  was not properly supported till GNAT 3.15a, so that would cause\n-   --  bootstrap path problems. To be changed later ???\n-\n-   Invalid_Time : constant OS_Time := -1;\n-   --  This value should match the return valud by __gnat_file_time_*\n-\n-   pragma Inline (\"<\");\n-   pragma Inline (\">\");\n-   pragma Inline (\"<=\");\n-   pragma Inline (\">=\");\n-\n-   type Process_Id is new Integer;\n-   Invalid_Pid : constant Process_Id := -1;\n-\n-end GNAT.OS_Lib;\n+package GNAT.OS_Lib renames System.OS_Lib;"}]}