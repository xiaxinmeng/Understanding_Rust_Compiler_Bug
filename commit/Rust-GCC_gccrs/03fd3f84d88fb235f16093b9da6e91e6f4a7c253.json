{"sha": "03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNmZDNmODRkODhmYjIzNWYxNjA5M2I5ZGE2ZTkxZTZmNGE3YzI1Mw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-11-08T14:48:02Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-11-08T14:48:02Z"}, "message": "class.c, [...]: Fix comment formatting.\n\n\t* class.c, decl.c, lex.c, name-lookup.c, parser.c, pt.c,\n\tsearch.c, typeck2.c: Fix comment formatting.\n\nFrom-SVN: r90265", "tree": {"sha": "e9fb98404f857d20d8698ebaf018a3542d0aea64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9fb98404f857d20d8698ebaf018a3542d0aea64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/comments", "author": null, "committer": null, "parents": [{"sha": "517f199e1e6f9d5c52cc5f2b5fe8c9899b660ae8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517f199e1e6f9d5c52cc5f2b5fe8c9899b660ae8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517f199e1e6f9d5c52cc5f2b5fe8c9899b660ae8"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "f94382ed0aa45e0c15a2aec3b2a7eb0efbf17cbf", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -1,3 +1,8 @@\n+2004-11-08  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* class.c, decl.c, lex.c, name-lookup.c, parser.c, pt.c,\n+\tsearch.c, typeck2.c: Fix comment formatting.\n+\n 2004-11-04  Ulrich Weigand  <uweigand@de.ibm.com>\n \t\n \tPR tree-optimization/18184"}, {"sha": "63e2cf7466696d39537c2a9e56de293f74dd2326", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -1027,7 +1027,7 @@ add_method (tree type, tree method)\n \tVEC_quick_insert (tree, method_vec, slot, overload);\n     }\n   else\n-    /* Replace the current slot. */\n+    /* Replace the current slot.  */\n     VEC_replace (tree, method_vec, slot, overload);\n }\n \n@@ -4068,7 +4068,7 @@ check_bases_and_members (tree t)\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_CONTAINS_VPTR_P (t);\n \n-  /* Synthesize any needed methods.   */\n+  /* Synthesize any needed methods.  */\n   add_implicitly_declared_members (t, cant_have_default_ctor,\n \t\t\t\t   cant_have_const_ctor,\n \t\t\t\t   no_const_asn_ref);"}, {"sha": "b429a783e7f3c8921cb56574f4cb9bac52c9951d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -5992,7 +5992,7 @@ grokvardecl (tree type,\n \t or enumeration declared in a local scope) shall not be used to\n \t declare an entity with linkage.\n \n-\t Only check this for public decls for now. */\n+\t Only check this for public decls for now.  */\n       tree t1 = TREE_TYPE (decl);\n       tree t = no_linkage_check (t1, /*relaxed_p=*/false);\n       if (t)\n@@ -6010,11 +6010,11 @@ grokvardecl (tree type,\n \n \t\t   Note that while this construct is well formed in C++03\n \t\t   it is likely to become ill formed in C++0x.  See open\n-\t\t   CWG issue 389 and related issues. */\n+\t\t   CWG issue 389 and related issues.  */\n \t\t;\n \t      else\n \t\t{\n-\t\t  /* It's a typedef referring to an anonymous type. */\n+\t\t  /* It's a typedef referring to an anonymous type.  */\n \t\t  pedwarn (\"non-local variable %q#D uses anonymous type\",\n \t\t\t   decl);\n \t\t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n@@ -6437,7 +6437,7 @@ check_special_function_return_type (special_function_kind sfk,\n /* A variable or data member (whose unqualified name is IDENTIFIER)\n    has been declared with the indicated TYPE.  If the TYPE is not\n    acceptable, issue an error message and return a type to use for\n-   error-recovery purposes. */\n+   error-recovery purposes.  */\n \n tree\n check_var_type (tree identifier, tree type)\n@@ -9298,7 +9298,7 @@ xref_basetypes (tree ref, tree base_list)\n {\n   tree *basep;\n   tree binfo, base_binfo;\n-  unsigned max_vbases = 0; /* Maximum direct & indirect virtual bases. */\n+  unsigned max_vbases = 0; /* Maximum direct & indirect virtual bases.  */\n   unsigned max_bases = 0;  /* Maximum direct bases.  */\n   int i;\n   tree default_access;\n@@ -9606,7 +9606,7 @@ finish_enum (tree enumtype)\n      a smaller integral type would work, unless the user has\n      explicitly requested that we use the smallest possible type.  The\n      user can request that for all enumerations with a command line\n-     flag, or for just one enumeration with an attribute. */\n+     flag, or for just one enumeration with an attribute.  */\n \n   use_short_enum = flag_short_enums\n     || lookup_attribute (\"packed\", TYPE_ATTRIBUTES (enumtype));"}, {"sha": "d9775d94f0a28241a01863d0bd9092492f80836c", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -349,7 +349,7 @@ cxx_init (void)\n   cxx_init_decl_processing ();\n \n   /* Create the built-in __null node.  It is important that this is\n-     not shared. */\n+     not shared.  */\n   null_node = make_node (INTEGER_CST);\n   TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n "}, {"sha": "9031f05c2a1f70ffa9bd7eb52770669cbd9fb9b8", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -2783,7 +2783,7 @@ push_class_level_binding (tree name, tree x)\n   gcc_assert (TYPE_BEING_DEFINED (current_class_type));\n   /* We could have been passed a tree list if this is an ambiguous\n      declaration. If so, pull the declaration out because\n-     check_template_shadow will not handle a TREE_LIST. */\n+     check_template_shadow will not handle a TREE_LIST.  */\n   if (TREE_CODE (decl) == TREE_LIST \n       && TREE_TYPE (decl) == error_mark_node)\n     decl = TREE_VALUE (decl);"}, {"sha": "646013ad35afe09c82ea747092bfedc28cd2c5bf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -53,7 +53,7 @@ typedef struct cp_token GTY (())\n   ENUM_BITFIELD (rid) keyword : 8;\n   /* Token flags.  */\n   unsigned char flags;\n-  /* True if this token is from a system header. */\n+  /* True if this token is from a system header.  */\n   BOOL_BITFIELD in_system_header : 1;\n   /* True if this token is from a context where it is implicitly extern \"C\" */\n   BOOL_BITFIELD implicit_extern_c : 1;\n@@ -80,7 +80,7 @@ static const cp_token eof_token =\n /* The cp_lexer structure represents the C++ lexer.  It is responsible\n    for managing the token stream from the preprocessor and supplying\n    it to the parser.  Tokens are never added to the cp_lexer after\n-   it is created. */\n+   it is created.  */\n \n typedef struct cp_lexer GTY (())\n {\n@@ -92,7 +92,7 @@ typedef struct cp_lexer GTY (())\n   size_t buffer_length;\n   \n   /* A pointer just past the last available token.  The tokens\n-     in this lexer are [buffer, last_token). */\n+     in this lexer are [buffer, last_token).  */\n   cp_token_position GTY ((skip)) last_token;\n \n   /* The next available token.  If NEXT_TOKEN is &eof_token, then there are\n@@ -116,14 +116,14 @@ typedef struct cp_lexer GTY (())\n    allocate heap memory for it, since tokens are never removed from the\n    lexer's array.  There is also no need for the GC to walk through\n    a cp_token_cache, since everything in here is referenced through\n-   a lexer. */\n+   a lexer.  */\n \n typedef struct cp_token_cache GTY(())\n {\n-  /* The beginning of the token range. */\n+  /* The beginning of the token range.  */\n   cp_token * GTY((skip)) first;\n \n-  /* Points immediately after the last token in the range. */\n+  /* Points immediately after the last token in the range.  */\n   cp_token * GTY ((skip)) last;\n } cp_token_cache;\n \n@@ -211,7 +211,7 @@ static cp_token_cache *cp_token_cache_new\n \n /* A token type for tokens that are not tokens at all; these are used\n    to represent slots in the array where there used to be a token\n-   that has now been deleted. */\n+   that has now been deleted.  */\n #define CPP_PURGED ((enum cpp_ttype) (CPP_NESTED_NAME_SPECIFIER + 1))\n \n /* The number of token types, including C++-specific ones.  */\n@@ -237,7 +237,7 @@ cp_lexer_new_main (void)\n   size_t space;\n   cp_token *buffer;\n \n-  /* Tell cpplib we want CPP_PRAGMA tokens. */\n+  /* Tell cpplib we want CPP_PRAGMA tokens.  */\n   cpp_get_options (parse_in)->defer_pragmas = true;\n \n   /* Tell c_lex not to merge string constants.  */\n@@ -267,7 +267,7 @@ cp_lexer_new_main (void)\n   pos = buffer;\n   *pos = first_token;\n   \n-  /* Get the remaining tokens from the preprocessor. */\n+  /* Get the remaining tokens from the preprocessor.  */\n   while (pos->type != CPP_EOF)\n     {\n       pos++;\n@@ -321,7 +321,7 @@ cp_lexer_new_from_tokens (cp_token_cache *cache)\n   return lexer;\n }\n \n-/* Frees all resources associated with LEXER. */\n+/* Frees all resources associated with LEXER.  */\n \n static void\n cp_lexer_destroy (cp_lexer *lexer)\n@@ -382,7 +382,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n \n   /* On some systems, some header files are surrounded by an \n      implicit extern \"C\" block.  Set a flag in the token if it\n-     comes from such a header. */\n+     comes from such a header.  */\n   is_extern_c += pending_lang_change;\n   pending_lang_change = 0;\n   token->implicit_extern_c = is_extern_c > 0;\n@@ -405,7 +405,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer ATTRIBUTE_UNUSED ,\n     token->keyword = RID_MAX;\n }\n \n-/* Update the globals input_location and in_system_header from TOKEN.   */\n+/* Update the globals input_location and in_system_header from TOKEN.  */\n static inline void\n cp_lexer_set_source_position_from_token (cp_token *token)\n {\n@@ -588,7 +588,7 @@ cp_lexer_purge_tokens_after (cp_lexer *lexer, cp_token *tok)\n     }\n }\n \n-/* Consume and handle a pragma token.   */\n+/* Consume and handle a pragma token.  */\n static void\n cp_lexer_handle_pragma (cp_lexer *lexer)\n {\n@@ -715,7 +715,7 @@ cp_lexer_stop_debugging (cp_lexer* lexer)\n \n #endif /* ENABLE_CHECKING */\n \n-/* Create a new cp_token_cache, representing a range of tokens. */\n+/* Create a new cp_token_cache, representing a range of tokens.  */\n \n static cp_token_cache *\n cp_token_cache_new (cp_token *first, cp_token *last)\n@@ -1265,7 +1265,7 @@ typedef struct cp_parser GTY(())\n   bool in_type_id_in_expr_p;\n \n   /* TRUE if we are currently in a header file where declarations are\n-     implicitly extern \"C\". */\n+     implicitly extern \"C\".  */\n   bool implicit_extern_c;\n \n   /* TRUE if strings in expressions should be translated to the execution\n@@ -2361,7 +2361,7 @@ cp_parser_new (void)\n   /* We are not parsing a type-id inside an expression.  */\n   parser->in_type_id_in_expr_p = false;\n \n-  /* Declarations aren't implicitly extern \"C\". */\n+  /* Declarations aren't implicitly extern \"C\".  */\n   parser->implicit_extern_c = false;\n \n   /* String literals should be translated to the execution character set.  */\n@@ -2557,7 +2557,7 @@ cp_parser_translation_unit (cp_parser* parser)\n       /* If there are no tokens left then all went well.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n \t{\n-\t  /* Get rid of the token array; we don't need it any more. */\n+\t  /* Get rid of the token array; we don't need it any more.  */\n \t  cp_lexer_destroy (parser->lexer);\n \t  parser->lexer = NULL;\n \n@@ -5299,7 +5299,7 @@ cp_parser_binary_expression (cp_parser* parser)\n            will happen repeatedly;\n          - or, we found an operator which has lower priority.  This is the case \n            where the recursive descent *ascends*, as in `3 * 4 + 5' after\n-           parsing `3 * 4'. */\n+           parsing `3 * 4'.  */\n       if (new_prec <= prec)\n         {\n           if (sp == stack)\n@@ -5311,7 +5311,7 @@ cp_parser_binary_expression (cp_parser* parser)\n      get_rhs:\n       tree_type = binops_by_token[token->type].tree_type;\n \n-      /* We used the operator token. */\n+      /* We used the operator token.  */\n       cp_lexer_consume_token (parser->lexer);\n \n       /* Extract another operand.  It may be the RHS of this expression\n@@ -5320,7 +5320,7 @@ cp_parser_binary_expression (cp_parser* parser)\n \n       /* Get another operator token.  Look up its precedence to avoid\n          building a useless (immediately popped) stack entry for common\n-         cases such as 3 + 4 + 5 or 3 * 4 + 5.   */\n+         cases such as 3 + 4 + 5 or 3 * 4 + 5.  */\n       token = cp_lexer_peek_token (parser->lexer);\n       lookahead_prec = TOKEN_PRECEDENCE (token);\n       if (lookahead_prec > new_prec)\n@@ -6603,7 +6603,7 @@ cp_parser_declaration_seq_opt (cp_parser* parser)\n \t}\n \n       /* If we're entering or exiting a region that's implicitly\n-\t extern \"C\", modify the lang context appropriately. */\n+\t extern \"C\", modify the lang context appropriately.  */\n       if (!parser->implicit_extern_c && token->implicit_extern_c)\n \t{\n \t  push_lang_context (lang_name_c);\n@@ -8188,7 +8188,7 @@ cp_parser_type_parameter (cp_parser* parser)\n \t    && cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n \t  {\n \t    identifier = cp_parser_identifier (parser);\n-\t    /* Treat invalid names as if the parameter were nameless. */\n+\t    /* Treat invalid names as if the parameter were nameless.  */\n \t    if (identifier == error_mark_node)\n \t      identifier = NULL_TREE;\n \t  }\n@@ -9799,7 +9799,7 @@ cp_parser_enum_specifier (cp_parser* parser)\n   cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n \n   /* Look for trailing attributes to apply to this enumeration, and\n-     apply them if appropriate. */\n+     apply them if appropriate.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))\n     {\n       tree trailing_attr = cp_parser_attributes_opt (parser);\n@@ -11729,7 +11729,7 @@ cp_parser_parameter_declaration (cp_parser *parser,\n \t  cp_token *token;\n \n \t  /* Add tokens until we have processed the entire default\n-\t     argument.  We add the range [first_token, token). */\n+\t     argument.  We add the range [first_token, token).  */\n \t  first_token = cp_lexer_peek_token (parser->lexer);\n \t  while (true)\n \t    {\n@@ -15503,7 +15503,7 @@ cp_parser_next_token_starts_class_definition_p (cp_parser *parser)\n }\n \n /* Returns TRUE iff the next token is the \",\" or \">\" ending a\n-   template-argument.   */\n+   template-argument.  */\n \n static bool\n cp_parser_next_token_ends_template_argument_p (cp_parser *parser)\n@@ -15642,7 +15642,7 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n   parser->object_scope = NULL_TREE;\n }\n \n-/* Consume tokens up through a non-nested END token. */\n+/* Consume tokens up through a non-nested END token.  */\n \n static void\n cp_parser_cache_group (cp_parser *parser,"}, {"sha": "c35fd11fd3fe47c852ee79f5c44a4b1f9e011cd3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -3570,7 +3570,7 @@ convert_nontype_argument (tree type, tree expr)\n \t A template-argument for a non-type, non-template template-parameter\n \t shall be one of: [...]\n \n-\t -- the address of an object or function with external linkage.   */\n+\t -- the address of an object or function with external linkage.  */\n       if (!DECL_EXTERNAL_LINKAGE_P (expr))\n \t{\n \t  error (\"%qE is not a valid template argument for type %qT \"\n@@ -10792,7 +10792,7 @@ bt_instantiate_type_proc (binding_entry entry, void *data)\n \n /* Called from do_type_instantiation to instantiate a member\n    (a member function or a static member variable) of an\n-   explicitly instantiated class template. */\n+   explicitly instantiated class template.  */\n static void\n instantiate_class_member (tree decl, int extern_p)\n {\n@@ -10911,7 +10911,7 @@ do_type_instantiation (tree t, tree storage, tsubst_flags_t complain)\n        we don't have any arguments for them.  Note that the standard\n        is unclear on whether the instantiation of the members are\n        *explicit* instantiations or not.  However, the most natural\n-       interpretation is that it should be an explicit instantiation. */\n+       interpretation is that it should be an explicit instantiation.  */\n \n     if (! static_p)\n       for (tmp = TYPE_METHODS (t); tmp; tmp = TREE_CHAIN (tmp))\n@@ -11089,7 +11089,7 @@ template_for_substitution (tree decl)\n    If UNDEFINED_OK is nonzero, then instead we treat it as an implicit\n    instantiation.  UNDEFINED_OK is nonzero only if we are being used\n    to instantiate the members of an explicitly instantiated class\n-   template. */\n+   template.  */\n \n \n tree"}, {"sha": "635beeaef979edd6db9ed810058cca049b8f03c8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -82,7 +82,7 @@ static int n_contexts_saved;\n \n struct lookup_base_data_s\n {\n-  tree t;\t\t/* type being searched. */\n+  tree t;\t\t/* type being searched.  */\n   tree base;            /* The base type we're looking for.  */\n   tree binfo;           /* Found binfo.  */\n   bool via_virtual;  \t/* Found via a virtual path.  */\n@@ -851,7 +851,7 @@ dfs_accessible_post (tree binfo, void *data ATTRIBUTE_UNUSED)\n    then we can tell in what context the access is occurring by looking\n    at the most derived class along the path indicated by BINFO.  If\n    CONSIDER_LOCAL is true, do consider special access the current\n-   scope or friendship thereof we might have.   */\n+   scope or friendship thereof we might have.  */\n \n int \n accessible_p (tree type, tree decl, bool consider_local_p)\n@@ -2150,7 +2150,7 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n \t  tree *prev, other;\n \t  \n \t  if (!(virtual_depth || TREE_STATIC (level)))\n-\t    /* Neither is morally virtual, so cannot hide each other. */\n+\t    /* Neither is morally virtual, so cannot hide each other.  */\n \t    continue;\n \t  \n \t  if (!TREE_VALUE (level))\n@@ -2171,7 +2171,7 @@ check_hidden_convs (tree binfo, int virtual_depth, int virtualness,\n \t      if (same_type_p (to_type, TREE_TYPE (other)))\n \t\t{\n \t\t  if (they_hide_us)\n-\t\t    /* We are hidden. */\n+\t\t    /* We are hidden.  */\n \t\t    return 0;\n \n \t\t  if (we_hide_them)"}, {"sha": "ab95bc3e1b81606a74a473eba4b7515630436e13", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03fd3f84d88fb235f16093b9da6e91e6f4a7c253/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=03fd3f84d88fb235f16093b9da6e91e6f4a7c253", "patch": "@@ -214,7 +214,7 @@ complete_type_check_abstract (tree type)\n \n \t  /* Tweak input_location so that the diagnostic appears at the correct\n \t    location. Notice that this is only needed if the decl is an\n-\t    IDENTIFIER_NODE, otherwise cp_error_at. */\n+\t    IDENTIFIER_NODE, otherwise cp_error_at.  */\n \t  input_location = pat->locus;\n \t  abstract_virtuals_error (pat->decl, pat->type);\n \t  pat = pat->next;"}]}