{"sha": "44bb111a78b9636b80d4b40ef57b8b47a375c525", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRiYjExMWE3OGI5NjM2YjgwZDRiNDBlZjU3YjhiNDdhMzc1YzUyNQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-08-29T19:20:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-08-29T19:20:01Z"}, "message": "expr.h (enum block_op_methods): New.\n\n        * expr.h (enum block_op_methods): New.\n        (emit_block_move): Update prototype.\n        * expr.c (block_move_libcall_safe_for_call_parm): New.\n        (emit_block_move_via_loop): New.\n        (emit_block_move): Use them.  New argument METHOD.\n        (emit_push_insn): Always respect the given alignment.\n        (expand_assignment): Update call to emit_block_move.\n        (store_expr, store_field, expand_expr): Likewise.\n        * builtins.c (expand_builtin_apply): Likewise.\n        (expand_builtin_memcpy, expand_builtin_va_copy): Likewise.\n        * function.c (expand_function_end): Likewise.\n        * config/sh/sh.c (sh_initialize_trampoline): Likewise.\n        * config/sparc/sparc.c (sparc_va_arg): Likewise.\n        * calls.c (expand_call, emit_library_call_value_1): Likewise.\n        (save_fixed_argument_area): Use emit_block_move with\n        BLOCK_OP_CALL_PARM instead of move_by_pieces.\n        (restore_fixed_argument_area): Likewise.\n        (store_one_arg): Fix alignment parameter to emit_push_insn.\n\nFrom-SVN: r56661", "tree": {"sha": "44fb6efc1ab10d4d91c0a9304f749fed8e7f2159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44fb6efc1ab10d4d91c0a9304f749fed8e7f2159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44bb111a78b9636b80d4b40ef57b8b47a375c525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bb111a78b9636b80d4b40ef57b8b47a375c525", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44bb111a78b9636b80d4b40ef57b8b47a375c525", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44bb111a78b9636b80d4b40ef57b8b47a375c525/comments", "author": null, "committer": null, "parents": [{"sha": "08b3d1047a7cbcfc963e45063b763c38128374fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b3d1047a7cbcfc963e45063b763c38128374fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b3d1047a7cbcfc963e45063b763c38128374fc"}], "stats": {"total": 284, "additions": 230, "deletions": 54}, "files": [{"sha": "b2dcdf12dc5d0d6bcb5f95e9e9dfd34abfddba20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -1,3 +1,24 @@\n+2002-08-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.h (enum block_op_methods): New.\n+\t(emit_block_move): Update prototype.\n+\t* expr.c (block_move_libcall_safe_for_call_parm): New.\n+\t(emit_block_move_via_loop): New.\n+\t(emit_block_move): Use them.  New argument METHOD.\n+\t(emit_push_insn): Always respect the given alignment.\n+\t(expand_assignment): Update call to emit_block_move.\n+\t(store_expr, store_field, expand_expr): Likewise.\n+\t* builtins.c (expand_builtin_apply): Likewise.\n+\t(expand_builtin_memcpy, expand_builtin_va_copy): Likewise.\n+\t* function.c (expand_function_end): Likewise.\n+\t* config/sh/sh.c (sh_initialize_trampoline): Likewise.\n+\t* config/sparc/sparc.c (sparc_va_arg): Likewise.\n+\t* calls.c (expand_call, emit_library_call_value_1): Likewise.\n+\t(save_fixed_argument_area): Use emit_block_move with\n+\tBLOCK_OP_CALL_PARM instead of move_by_pieces.\n+\t(restore_fixed_argument_area): Likewise.\n+\t(store_one_arg): Fix alignment parameter to emit_push_insn.\n+\n 2002-08-29  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* install.texi (hppa64-hp-hpux11*): Document installation procedure."}, {"sha": "b2ad5375b77101c08b84e79bed813801dc45ab35", "filename": "gcc/builtins.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -1225,7 +1225,7 @@ expand_builtin_apply (function, arguments, argsize)\n   set_mem_align (dest, PARM_BOUNDARY);\n   src = gen_rtx_MEM (BLKmode, incoming_args);\n   set_mem_align (src, PARM_BOUNDARY);\n-  emit_block_move (dest, src, argsize);\n+  emit_block_move (dest, src, argsize, BLOCK_OP_NORMAL);\n \n   /* Refer to the argument block.  */\n   apply_args_size ();\n@@ -2000,7 +2000,8 @@ expand_builtin_memcpy (arglist, target, mode)\n       set_mem_align (src_mem, src_align);\n \n       /* Copy word part most expediently.  */\n-      dest_addr = emit_block_move (dest_mem, src_mem, len_rtx);\n+      dest_addr = emit_block_move (dest_mem, src_mem, len_rtx,\n+\t\t\t\t   BLOCK_OP_NORMAL);\n \n       if (dest_addr == 0)\n \t{\n@@ -3298,7 +3299,7 @@ expand_builtin_va_copy (arglist)\n       set_mem_align (srcb, TYPE_ALIGN (va_list_type_node));\n \n       /* Copy.  */\n-      emit_block_move (dstb, srcb, size);\n+      emit_block_move (dstb, srcb, size, BLOCK_OP_NORMAL);\n     }\n \n   return const0_rtx;"}, {"sha": "2e238094ffbb21ce75088ddd50053bd375566ac3", "filename": "gcc/calls.c", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -967,11 +967,8 @@ save_fixed_argument_area (reg_parm_stack_space, argblock,\n       if (save_mode == BLKmode)\n \t{\n \t  save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n-\t  /* Cannot use emit_block_move here because it can be done by a\n-\t     library call which in turn gets into this place again and deadly\n-\t     infinite recursion happens.  */\n-\t  move_by_pieces (validize_mem (save_area), stack_area, num_to_save,\n-\t\t\t  PARM_BOUNDARY);\n+\t  emit_block_move (validize_mem (save_area), stack_area,\n+\t\t\t   GEN_INT (num_to_save), BLOCK_OP_CALL_PARM);\n \t}\n       else\n \t{\n@@ -1008,11 +1005,9 @@ restore_fixed_argument_area (save_area, argblock, high_to_save, low_to_save)\n   if (save_mode != BLKmode)\n     emit_move_insn (stack_area, save_area);\n   else\n-    /* Cannot use emit_block_move here because it can be done by a library\n-       call which in turn gets into this place again and deadly infinite\n-       recursion happens.  */\n-    move_by_pieces (stack_area, validize_mem (save_area),\n-\t\t    high_to_save - low_to_save + 1, PARM_BOUNDARY);\n+    emit_block_move (stack_area, validize_mem (save_area),\n+\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t     BLOCK_OP_CALL_PARM);\n }\n #endif /* REG_PARM_STACK_SPACE */\n \n@@ -3317,9 +3312,9 @@ expand_call (exp, target, ignore)\n \t\tif (save_mode != BLKmode)\n \t\t  emit_move_insn (stack_area, args[i].save_area);\n \t\telse\n-\t\t  emit_block_move (stack_area,\n-\t\t\t\t   validize_mem (args[i].save_area),\n-\t\t\t\t   GEN_INT (args[i].size.constant));\n+\t\t  emit_block_move (stack_area, args[i].save_area,\n+\t\t\t\t   GEN_INT (args[i].size.constant),\n+\t\t\t\t   BLOCK_OP_CALL_PARM);\n \t      }\n \n \t  highest_outgoing_arg_in_use = initial_highest_arg_in_use;\n@@ -3909,8 +3904,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t    {\n \t      save_area = assign_stack_temp (BLKmode, num_to_save, 0);\n \t      set_mem_align (save_area, PARM_BOUNDARY);\n-\t      emit_block_move (validize_mem (save_area), stack_area,\n-\t\t\t       GEN_INT (num_to_save));\n+\t      emit_block_move (save_area, stack_area, GEN_INT (num_to_save),\n+\t\t\t       BLOCK_OP_CALL_PARM);\n \t    }\n \t  else\n \t    {\n@@ -3978,8 +3973,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t\t}\n \t    }\n \n-\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, 0, partial, reg, 0,\n-\t\t\t  argblock, GEN_INT (argvec[argnum].offset.constant),\n+\t  emit_push_insn (val, mode, NULL_TREE, NULL_RTX, PARM_BOUNDARY,\n+\t\t\t  partial, reg, 0, argblock,\n+\t\t\t  GEN_INT (argvec[argnum].offset.constant),\n \t\t\t  reg_parm_stack_space, ARGS_SIZE_RTX (alignment_pad));\n \n \t  /* Now mark the segment we just used.  */\n@@ -4180,8 +4176,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n \t  if (save_mode != BLKmode)\n \t    emit_move_insn (stack_area, save_area);\n \t  else\n-\t    emit_block_move (stack_area, validize_mem (save_area),\n-\t\t\t     GEN_INT (high_to_save - low_to_save + 1));\n+\t    emit_block_move (stack_area, save_area,\n+\t\t\t     GEN_INT (high_to_save - low_to_save + 1),\n+\t\t\t     BLOCK_OP_CALL_PARM);\n \t}\n #endif\n \n@@ -4358,7 +4355,8 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \t\t  arg->save_area = assign_temp (nt, 0, 1, 1);\n \t\t  preserve_temp_slots (arg->save_area);\n \t\t  emit_block_move (validize_mem (arg->save_area), stack_area,\n-\t\t\t\t   expr_size (arg->tree_value));\n+\t\t\t\t   expr_size (arg->tree_value),\n+\t\t\t\t   BLOCK_OP_CALL_PARM);\n \t\t}\n \t      else\n \t\t{\n@@ -4479,8 +4477,8 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n \n       /* This isn't already where we want it on the stack, so put it there.\n \t This can either be done with push or copy insns.  */\n-      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, 0,\n-\t\t      partial, reg, used - size, argblock,\n+      emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), NULL_RTX, \n+\t\t      PARM_BOUNDARY, partial, reg, used - size, argblock,\n \t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n \n@@ -4574,18 +4572,18 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n           {\n \t    rtx size_rtx1 = GEN_INT (reg_parm_stack_space - arg->offset.constant);\n \t    emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx1,\n-\t\t            TYPE_ALIGN (TREE_TYPE (pval)), partial, reg,\n-\t\t\t    excess, argblock, ARGS_SIZE_RTX (arg->offset),\n-\t\t\t    reg_parm_stack_space,\n+\t\t            MAX (PARM_BOUNDARY, TYPE_ALIGN (TREE_TYPE (pval))),\n+\t\t\t    partial, reg, excess, argblock,\n+\t\t\t    ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t            ARGS_SIZE_RTX (arg->alignment_pad));\n \t  }\n \t}\n \t\n \n       emit_push_insn (arg->value, arg->mode, TREE_TYPE (pval), size_rtx,\n-\t\t      TYPE_ALIGN (TREE_TYPE (pval)), partial, reg, excess,\n-\t\t      argblock, ARGS_SIZE_RTX (arg->offset),\n-\t\t      reg_parm_stack_space,\n+\t\t      MAX (PARM_BOUNDARY, TYPE_ALIGN (TREE_TYPE (pval))),\n+\t\t      partial, reg, excess, argblock,\n+\t\t      ARGS_SIZE_RTX (arg->offset), reg_parm_stack_space,\n \t\t      ARGS_SIZE_RTX (arg->alignment_pad));\n \n       /* Unless this is a partially-in-register argument, the argument is now"}, {"sha": "a6ce2be9d17d5ba3de3ee7fe8d37471d81f8d919", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -7301,7 +7301,7 @@ sh_initialize_trampoline (tramp, fnaddr, cxt)\n       src = gen_rtx_MEM (BLKmode, tramp_templ);\n       set_mem_align (dst, 256);\n       set_mem_align (src, 64);\n-      emit_block_move (dst, src, GEN_INT (fixed_len));\n+      emit_block_move (dst, src, GEN_INT (fixed_len), BLOCK_OP_NORMAL);\n \n       emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (tramp,\tfixed_len)),\n \t\t      fnaddr);"}, {"sha": "4a83b8a56128cbfd9b5ec0909f33864b2be58562", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -5347,7 +5347,8 @@ sparc_va_arg (valist, type)\n       PUT_MODE (tmp, BLKmode);\n       set_mem_alias_set (tmp, 0);\n       \n-      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize));\n+      dest_addr = emit_block_move (tmp, addr_rtx, GEN_INT (rsize),\n+\t\t\t\t   BLOCK_OP_NORMAL);\n       if (dest_addr != NULL_RTX)\n \taddr_rtx = dest_addr;\n       else"}, {"sha": "700b84084dac1ddb5e5124aa77f86017b6aa2c11", "filename": "gcc/expr.c", "status": "modified", "additions": 166, "deletions": 19, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -132,9 +132,11 @@ static unsigned HOST_WIDE_INT move_by_pieces_ninsns\n \t\t\t\t\t unsigned int));\n static void move_by_pieces_1\tPARAMS ((rtx (*) (rtx, ...), enum machine_mode,\n \t\t\t\t\t struct move_by_pieces *));\n+static bool block_move_libcall_safe_for_call_parm PARAMS ((void));\n static bool emit_block_move_via_movstr PARAMS ((rtx, rtx, rtx, unsigned));\n static rtx emit_block_move_via_libcall PARAMS ((rtx, rtx, rtx));\n static tree emit_block_move_libcall_fn PARAMS ((int));\n+static void emit_block_move_via_loop PARAMS ((rtx, rtx, rtx, unsigned));\n static rtx clear_by_pieces_1\tPARAMS ((PTR, HOST_WIDE_INT,\n \t\t\t\t\t enum machine_mode));\n static void clear_by_pieces\tPARAMS ((rtx, unsigned HOST_WIDE_INT,\n@@ -1677,16 +1679,43 @@ move_by_pieces_1 (genfun, mode, data)\n    Both X and Y must be MEM rtx's (perhaps inside VOLATILE) with mode BLKmode.\n    SIZE is an rtx that says how long they are.\n    ALIGN is the maximum alignment we can assume they have.\n+   METHOD describes what kind of copy this is, and what mechanisms may be used.\n \n    Return the address of the new block, if memcpy is called and returns it,\n    0 otherwise.  */\n \n rtx\n-emit_block_move (x, y, size)\n+emit_block_move (x, y, size, method)\n      rtx x, y, size;\n+     enum block_op_methods method;\n {\n+  bool may_use_call;\n   rtx retval = 0;\n-  unsigned int align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n+  unsigned int align;\n+\n+  switch (method)\n+    {\n+    case BLOCK_OP_NORMAL:\n+      may_use_call = true;\n+      break;\n+\n+    case BLOCK_OP_CALL_PARM:\n+      may_use_call = block_move_libcall_safe_for_call_parm ();\n+\n+      /* Make inhibit_defer_pop nonzero around the library call\n+\t to force it to pop the arguments right away.  */\n+      NO_DEFER_POP;\n+      break;\n+\n+    case BLOCK_OP_NO_LIBCALL:\n+      may_use_call = false;\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  align = MIN (MEM_ALIGN (x), MEM_ALIGN (y));\n \n   if (GET_MODE (x) != BLKmode)\n     abort ();\n@@ -1708,12 +1737,77 @@ emit_block_move (x, y, size)\n     move_by_pieces (x, y, INTVAL (size), align);\n   else if (emit_block_move_via_movstr (x, y, size, align))\n     ;\n-  else\n+  else if (may_use_call)\n     retval = emit_block_move_via_libcall (x, y, size);\n+  else\n+    emit_block_move_via_loop (x, y, size, align);\n+\n+  if (method == BLOCK_OP_CALL_PARM)\n+    OK_DEFER_POP;\n \n   return retval;\n }\n \n+/* A subroutine of emit_block_move.  Returns true if calling the \n+   block move libcall will not clobber any parameters which may have\n+   already been placed on the stack.  */\n+\n+static bool\n+block_move_libcall_safe_for_call_parm ()\n+{\n+  if (PUSH_ARGS)\n+    return true;\n+  else\n+    {\n+      /* Check to see whether memcpy takes all register arguments.  */\n+      static enum {\n+\ttakes_regs_uninit, takes_regs_no, takes_regs_yes\n+      } takes_regs = takes_regs_uninit;\n+\n+      switch (takes_regs)\n+\t{\n+\tcase takes_regs_uninit:\n+\t  {\n+\t    CUMULATIVE_ARGS args_so_far;\n+\t    tree fn, arg;\n+\n+\t    fn = emit_block_move_libcall_fn (false);\n+\t    INIT_CUMULATIVE_ARGS (args_so_far, TREE_TYPE (fn), NULL_RTX, 0);\n+\n+\t    arg = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+\t    for ( ; arg != void_list_node ; arg = TREE_CHAIN (arg))\n+\t      {\n+\t\tenum machine_mode mode\n+\t\t  = TYPE_MODE (TREE_TYPE (TREE_VALUE (arg)));\n+\t\trtx tmp = FUNCTION_ARG (args_so_far, mode, NULL_TREE, 1);\n+\t\tif (!tmp || !REG_P (tmp))\n+\t\t  goto fail_takes_regs;\n+#ifdef FUNCTION_ARG_PARTIAL_NREGS\n+\t\tif (FUNCTION_ARG_PARTIAL_NREGS (args_so_far, mode,\n+\t\t\t\t\t\tNULL_TREE, 1))\n+\t\t  goto fail_takes_regs;\n+#endif\n+\t\tFUNCTION_ARG_ADVANCE (args_so_far, mode, NULL_TREE, 1);\n+\t      }\n+\t  }\n+\t  takes_regs = takes_regs_yes;\n+\t  /* FALLTHRU */\n+\n+\tcase takes_regs_yes:\n+\t  return true;\n+\n+\tfail_takes_regs:\n+\t  takes_regs = takes_regs_no;\n+\t  /* FALLTHRU */\n+\tcase takes_regs_no:\n+\t  return false;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+}\n+\n /* A subroutine of emit_block_move.  Expand a movstr pattern; \n    return true if successful.  */\n \n@@ -1919,6 +2013,59 @@ emit_block_move_libcall_fn (for_call)\n \n   return fn;\n }\n+\n+/* A subroutine of emit_block_move.  Copy the data via an explicit\n+   loop.  This is used only when libcalls are forbidden.  */\n+/* ??? It'd be nice to copy in hunks larger than QImode.  */\n+\n+static void\n+emit_block_move_via_loop (x, y, size, align)\n+     rtx x, y, size;\n+     unsigned int align ATTRIBUTE_UNUSED;\n+{\n+  rtx cmp_label, top_label, iter, x_addr, y_addr, tmp;\n+  enum machine_mode iter_mode;\n+\n+  iter_mode = GET_MODE (size);\n+  if (iter_mode == VOIDmode)\n+    iter_mode = word_mode;\n+\n+  top_label = gen_label_rtx ();\n+  cmp_label = gen_label_rtx ();\n+  iter = gen_reg_rtx (iter_mode);\n+\n+  emit_move_insn (iter, const0_rtx);\n+\n+  x_addr = force_operand (XEXP (x, 0), NULL_RTX);\n+  y_addr = force_operand (XEXP (y, 0), NULL_RTX);\n+  do_pending_stack_adjust ();\n+\n+  emit_note (NULL, NOTE_INSN_LOOP_BEG);\n+\n+  emit_jump (cmp_label);\n+  emit_label (top_label);\n+\n+  tmp = convert_modes (Pmode, iter_mode, iter, true);\n+  x_addr = gen_rtx_PLUS (Pmode, x_addr, tmp);\n+  y_addr = gen_rtx_PLUS (Pmode, y_addr, tmp);\n+  x = change_address (x, QImode, x_addr);\n+  y = change_address (y, QImode, y_addr);\n+\n+  emit_move_insn (x, y);\n+\n+  tmp = expand_simple_binop (iter_mode, PLUS, iter, const1_rtx, iter,\n+\t\t\t     true, OPTAB_LIB_WIDEN);\n+  if (tmp != iter)\n+    emit_move_insn (iter, tmp);\n+\n+  emit_note (NULL, NOTE_INSN_LOOP_CONT);\n+  emit_label (cmp_label);\n+\n+  emit_cmp_and_jump_insns (iter, size, LT, NULL_RTX, iter_mode,\n+\t\t\t   true, top_label);\n+\n+  emit_note (NULL, NOTE_INSN_LOOP_END);\n+}\n \f\n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */\n@@ -3623,16 +3770,12 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\t of sibling calls.  */\n \t      set_mem_alias_set (target, 0);\n \t    }\n-\t  else\n-\t    set_mem_align (target, align);\n-\n-\t  /* Make inhibit_defer_pop nonzero around the library call\n-\t     to force it to pop the bcopy-arguments right away.  */\n-\t  NO_DEFER_POP;\n \n-\t  emit_block_move (target, xinner, size);\n+\t  /* ALIGN may well be better aligned than TYPE, e.g. due to\n+\t     PARM_BOUNDARY.  Assume the caller isn't lying.  */\n+\t  set_mem_align (target, align);\n \n-\t  OK_DEFER_POP;\n+\t  emit_block_move (target, xinner, size, BLOCK_OP_CALL_PARM);\n \t}\n     }\n   else if (partial > 0)\n@@ -3951,7 +4094,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       if (GET_CODE (to_rtx) == PARALLEL)\n \temit_group_load (to_rtx, value, int_size_in_bytes (TREE_TYPE (from)));\n       else if (GET_MODE (to_rtx) == BLKmode)\n-\temit_block_move (to_rtx, value, expr_size (from));\n+\temit_block_move (to_rtx, value, expr_size (from), BLOCK_OP_NORMAL);\n       else\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n@@ -4312,7 +4455,7 @@ store_expr (exp, target, want_value)\n \n \t  if (GET_CODE (size) == CONST_INT\n \t      && INTVAL (size) < TREE_STRING_LENGTH (exp))\n-\t    emit_block_move (target, temp, size);\n+\t    emit_block_move (target, temp, size, BLOCK_OP_NORMAL);\n \t  else\n \t    {\n \t      /* Compute the size of the data to copy from the string.  */\n@@ -4326,7 +4469,7 @@ store_expr (exp, target, want_value)\n \n \t      /* Copy that much.  */\n \t      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx, 0);\n-\t      emit_block_move (target, temp, copy_size_rtx);\n+\t      emit_block_move (target, temp, copy_size_rtx, BLOCK_OP_NORMAL);\n \n \t      /* Figure out how much is left in TARGET that we have to clear.\n \t\t Do all calculations in ptr_mode.  */\n@@ -4367,7 +4510,7 @@ store_expr (exp, target, want_value)\n       else if (GET_CODE (target) == PARALLEL)\n \temit_group_load (target, temp, int_size_in_bytes (TREE_TYPE (exp)));\n       else if (GET_MODE (temp) == BLKmode)\n-\temit_block_move (target, temp, expr_size (exp));\n+\temit_block_move (target, temp, expr_size (exp), BLOCK_OP_NORMAL);\n       else\n \temit_move_insn (target, temp);\n     }\n@@ -5295,7 +5438,8 @@ store_field (target, bitsize, bitpos, mode, exp, value_mode, unsignedp, type,\n \t  target = adjust_address (target, VOIDmode, bitpos / BITS_PER_UNIT);\n \t  emit_block_move (target, temp,\n \t\t\t   GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t    / BITS_PER_UNIT));\n+\t\t\t\t    / BITS_PER_UNIT),\n+\t\t\t   BLOCK_OP_NORMAL);\n \n \t  return value_mode == VOIDmode ? const0_rtx : target;\n \t}\n@@ -7218,7 +7362,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \t\temit_block_move (target, op0,\n \t\t\t\t GEN_INT ((bitsize + BITS_PER_UNIT - 1)\n-\t\t\t\t\t  / BITS_PER_UNIT));\n+\t\t\t\t\t  / BITS_PER_UNIT),\n+\t\t\t\t BLOCK_OP_NORMAL);\n \n \t\treturn target;\n \t      }\n@@ -7634,7 +7779,8 @@ expand_expr (exp, target, tmode, modifier)\n \n \t      if (GET_MODE (op0) == BLKmode)\n \t\temit_block_move (new_with_op0_mode, op0,\n-\t\t\t\t GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))));\n+\t\t\t\t GEN_INT (GET_MODE_SIZE (TYPE_MODE (type))),\n+\t\t\t\t BLOCK_OP_NORMAL);\n \t      else\n \t\temit_move_insn (new_with_op0_mode, op0);\n \n@@ -8856,7 +9002,8 @@ expand_expr (exp, target, tmode, modifier)\n \t      if (TYPE_ALIGN_OK (inner_type))\n \t\tabort ();\n \n-\t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)));\n+\t      emit_block_move (new, op0, expr_size (TREE_OPERAND (exp, 0)),\n+\t\t\t       BLOCK_OP_NORMAL);\n \t      op0 = new;\n \t    }\n "}, {"sha": "c3a1009a12a7be2f27689013c3a55f766574440e", "filename": "gcc/expr.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -394,7 +394,15 @@ extern rtx convert_modes PARAMS ((enum machine_mode, enum machine_mode,\n \t\t\t\t  rtx, int));\n \n /* Emit code to move a block Y to a block X.  */\n-extern rtx emit_block_move PARAMS ((rtx, rtx, rtx));\n+\n+enum block_op_methods\n+{\n+  BLOCK_OP_NORMAL,\n+  BLOCK_OP_CALL_PARM,\n+  BLOCK_OP_NO_LIBCALL\n+};\n+\n+extern rtx emit_block_move PARAMS ((rtx, rtx, rtx, enum block_op_methods));\n \n /* Copy all or part of a value X into registers starting at REGNO.\n    The number of registers to be filled is NREGS.  */"}, {"sha": "f1381fb935148744f8549618256d21f82f920d9b", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44bb111a78b9636b80d4b40ef57b8b47a375c525/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=44bb111a78b9636b80d4b40ef57b8b47a375c525", "patch": "@@ -6807,7 +6807,7 @@ expand_function_end (filename, line, end_bindings)\n #ifdef TRAMPOLINE_TEMPLATE\n       blktramp = replace_equiv_address (initial_trampoline, tramp);\n       emit_block_move (blktramp, initial_trampoline,\n-\t\t       GEN_INT (TRAMPOLINE_SIZE));\n+\t\t       GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n #endif\n       INITIALIZE_TRAMPOLINE (tramp, XEXP (DECL_RTL (function), 0), context);\n       seq = get_insns ();"}]}