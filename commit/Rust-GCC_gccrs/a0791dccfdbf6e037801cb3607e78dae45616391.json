{"sha": "a0791dccfdbf6e037801cb3607e78dae45616391", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA3OTFkY2NmZGJmNmUwMzc4MDFjYjM2MDdlNzhkYWU0NTYxNjM5MQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-09-01T13:38:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-09-01T13:38:31Z"}, "message": "tree-ssa-struct-aliases.c (find_func_aliases_for_builtin_call): Use stack auto_vecs for constraint expressions.\n\n2014-09-01  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-struct-aliases.c (find_func_aliases_for_builtin_call):\n\tUse stack auto_vecs for constraint expressions.\n\t(find_func_aliases_for_call): Likewise.\n\t(find_func_aliases): Likewise.\n\t(find_func_clobbers): Likewise.\n\nFrom-SVN: r214795", "tree": {"sha": "58dfd663efac3174b6de8e4626cbebc1d45c7427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58dfd663efac3174b6de8e4626cbebc1d45c7427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0791dccfdbf6e037801cb3607e78dae45616391", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0791dccfdbf6e037801cb3607e78dae45616391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0791dccfdbf6e037801cb3607e78dae45616391", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0791dccfdbf6e037801cb3607e78dae45616391/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27d79c2181523833c856dfefd204f1aef403a86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27d79c2181523833c856dfefd204f1aef403a86f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27d79c2181523833c856dfefd204f1aef403a86f"}], "stats": {"total": 90, "additions": 33, "deletions": 57}, "files": [{"sha": "b35f8bc8c86e33142138a05b728dd2e039d26685", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0791dccfdbf6e037801cb3607e78dae45616391/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0791dccfdbf6e037801cb3607e78dae45616391/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0791dccfdbf6e037801cb3607e78dae45616391", "patch": "@@ -1,3 +1,11 @@\n+2014-09-01  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-struct-aliases.c (find_func_aliases_for_builtin_call):\n+\tUse stack auto_vecs for constraint expressions.\n+\t(find_func_aliases_for_call): Likewise.\n+\t(find_func_aliases): Likewise.\n+\t(find_func_clobbers): Likewise.\n+\n 2014-09-01  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (phi_translate_1): Avoid re-allocating the"}, {"sha": "0ce71bd0db59ef12dc114e05ce20393a9c5c91e1", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0791dccfdbf6e037801cb3607e78dae45616391/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0791dccfdbf6e037801cb3607e78dae45616391/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=a0791dccfdbf6e037801cb3607e78dae45616391", "patch": "@@ -4129,8 +4129,8 @@ static bool\n find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n {\n   tree fndecl = gimple_call_fndecl (t);\n-  vec<ce_s> lhsc = vNULL;\n-  vec<ce_s> rhsc = vNULL;\n+  auto_vec<ce_s, 2> lhsc;\n+  auto_vec<ce_s, 4> rhsc;\n   varinfo_t fi;\n \n   if (gimple_call_builtin_p (t, BUILT_IN_NORMAL))\n@@ -4183,16 +4183,14 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t      else\n \t\tget_constraint_for (dest, &rhsc);\n \t      process_all_all_constraints (lhsc, rhsc);\n-\t      lhsc.release ();\n-\t      rhsc.release ();\n+\t      lhsc.truncate (0);\n+\t      rhsc.truncate (0);\n \t    }\n \t  get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n \t  get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n \t  do_deref (&lhsc);\n \t  do_deref (&rhsc);\n \t  process_all_all_constraints (lhsc, rhsc);\n-\t  lhsc.release ();\n-\t  rhsc.release ();\n \t  return true;\n \t}\n       case BUILT_IN_MEMSET:\n@@ -4209,8 +4207,7 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t      get_constraint_for (res, &lhsc);\n \t      get_constraint_for (dest, &rhsc);\n \t      process_all_all_constraints (lhsc, rhsc);\n-\t      lhsc.release ();\n-\t      rhsc.release ();\n+\t      lhsc.truncate (0);\n \t    }\n \t  get_constraint_for_ptr_offset (dest, NULL_TREE, &lhsc);\n \t  do_deref (&lhsc);\n@@ -4228,7 +4225,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t  ac.offset = 0;\n \t  FOR_EACH_VEC_ELT (lhsc, i, lhsp)\n \t      process_constraint (new_constraint (*lhsp, ac));\n-\t  lhsc.release ();\n \t  return true;\n \t}\n       case BUILT_IN_POSIX_MEMALIGN:\n@@ -4247,8 +4243,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t  tmpc.type = ADDRESSOF;\n \t  rhsc.safe_push (tmpc);\n \t  process_all_all_constraints (lhsc, rhsc);\n-\t  lhsc.release ();\n-\t  rhsc.release ();\n \t  return true;\n \t}\n       case BUILT_IN_ASSUME_ALIGNED:\n@@ -4260,8 +4254,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t      get_constraint_for (res, &lhsc);\n \t      get_constraint_for (dest, &rhsc);\n \t      process_all_all_constraints (lhsc, rhsc);\n-\t      lhsc.release ();\n-\t      rhsc.release ();\n \t    }\n \t  return true;\n \t}\n@@ -4303,8 +4295,8 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t    do_deref (&lhsc);\n \t    do_deref (&rhsc);\n \t    process_all_all_constraints (lhsc, rhsc);\n-\t    lhsc.release ();\n-\t    rhsc.release ();\n+\t    lhsc.truncate (0);\n+\t    rhsc.truncate (0);\n \t    /* For realloc the resulting pointer can be equal to the\n \t       argument as well.  But only doing this wouldn't be\n \t       correct because with ptr == 0 realloc behaves like malloc.  */\n@@ -4313,8 +4305,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t\tget_constraint_for (gimple_call_lhs (t), &lhsc);\n \t\tget_constraint_for (gimple_call_arg (t, 0), &rhsc);\n \t\tprocess_all_all_constraints (lhsc, rhsc);\n-\t\tlhsc.release ();\n-\t\trhsc.release ();\n \t      }\n \t    return true;\n \t  }\n@@ -4338,8 +4328,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t    rhsc.safe_push (nul);\n \t    get_constraint_for (gimple_call_lhs (t), &lhsc);\n \t    process_all_all_constraints (lhsc, rhsc);\n-\t    lhsc.release ();\n-\t    rhsc.release ();\n \t  }\n \treturn true;\n       /* Trampolines are special - they set up passing the static\n@@ -4361,17 +4349,15 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t\t  lhs = get_function_part_constraint (nfi, fi_static_chain);\n \t\t  get_constraint_for (frame, &rhsc);\n \t\t  FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n-\t\t      process_constraint (new_constraint (lhs, *rhsp));\n-\t\t  rhsc.release ();\n+\t\t    process_constraint (new_constraint (lhs, *rhsp));\n+\t\t  rhsc.truncate (0);\n \n \t\t  /* Make the frame point to the function for\n \t\t     the trampoline adjustment call.  */\n \t\t  get_constraint_for (tramp, &lhsc);\n \t\t  do_deref (&lhsc);\n \t\t  get_constraint_for (nfunc, &rhsc);\n \t\t  process_all_all_constraints (lhsc, rhsc);\n-\t\t  rhsc.release ();\n-\t\t  lhsc.release ();\n \n \t\t  return true;\n \t\t}\n@@ -4390,8 +4376,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t      get_constraint_for (tramp, &rhsc);\n \t      do_deref (&rhsc);\n \t      process_all_all_constraints (lhsc, rhsc);\n-\t      rhsc.release ();\n-\t      lhsc.release ();\n \t    }\n \t  return true;\n \t}\n@@ -4413,8 +4397,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t  do_deref (&lhsc);\n \t  get_constraint_for (src, &rhsc);\n \t  process_all_all_constraints (lhsc, rhsc);\n-\t  lhsc.release ();\n-\t  rhsc.release ();\n \t  return true;\n \t}\n       CASE_BUILT_IN_TM_LOAD (1):\n@@ -4435,8 +4417,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t  get_constraint_for (addr, &rhsc);\n \t  do_deref (&rhsc);\n \t  process_all_all_constraints (lhsc, rhsc);\n-\t  lhsc.release ();\n-\t  rhsc.release ();\n \t  return true;\n \t}\n       /* Variadic argument handling needs to be handled in IPA\n@@ -4465,7 +4445,6 @@ find_func_aliases_for_builtin_call (struct function *fn, gimple t)\n \t    }\n \t  FOR_EACH_VEC_ELT (lhsc, i, lhsp)\n \t    process_constraint (new_constraint (*lhsp, rhs));\n-\t  lhsc.release ();\n \t  /* va_list is clobbered.  */\n \t  make_constraint_to (get_call_clobber_vi (t)->id, valist);\n \t  return true;\n@@ -4508,8 +4487,6 @@ static void\n find_func_aliases_for_call (struct function *fn, gimple t)\n {\n   tree fndecl = gimple_call_fndecl (t);\n-  vec<ce_s> lhsc = vNULL;\n-  vec<ce_s> rhsc = vNULL;\n   varinfo_t fi;\n \n   if (fndecl != NULL_TREE\n@@ -4521,7 +4498,7 @@ find_func_aliases_for_call (struct function *fn, gimple t)\n   if (!in_ipa_mode\n       || (fndecl && !fi->is_fn_info))\n     {\n-      vec<ce_s> rhsc = vNULL;\n+      auto_vec<ce_s, 16> rhsc;\n       int flags = gimple_call_flags (t);\n \n       /* Const functions can return their arguments and addresses\n@@ -4541,10 +4518,10 @@ find_func_aliases_for_call (struct function *fn, gimple t)\n       if (gimple_call_lhs (t))\n \thandle_lhs_call (t, gimple_call_lhs (t),\n \t\t\t gimple_call_return_flags (t), rhsc, fndecl);\n-      rhsc.release ();\n     }\n   else\n     {\n+      auto_vec<ce_s, 2> rhsc;\n       tree lhsop;\n       unsigned j;\n \n@@ -4570,6 +4547,7 @@ find_func_aliases_for_call (struct function *fn, gimple t)\n       lhsop = gimple_call_lhs (t);\n       if (lhsop)\n \t{\n+\t  auto_vec<ce_s, 2> lhsc;\n \t  struct constraint_expr rhs;\n \t  struct constraint_expr *lhsp;\n \n@@ -4579,11 +4557,11 @@ find_func_aliases_for_call (struct function *fn, gimple t)\n \t      && DECL_RESULT (fndecl)\n \t      && DECL_BY_REFERENCE (DECL_RESULT (fndecl)))\n \t    {\n-\t      vec<ce_s> tem = vNULL;\n-\t      tem.safe_push (rhs);\n+\t      auto_vec<ce_s, 2> tem;\n+\t      tem.quick_push (rhs);\n \t      do_deref (&tem);\n+\t      gcc_checking_assert (tem.length () == 1);\n \t      rhs = tem[0];\n-\t      tem.release ();\n \t    }\n \t  FOR_EACH_VEC_ELT (lhsc, j, lhsp)\n \t    process_constraint (new_constraint (*lhsp, rhs));\n@@ -4602,7 +4580,7 @@ find_func_aliases_for_call (struct function *fn, gimple t)\n \t  lhs = get_function_part_constraint (fi, fi_result);\n \t  FOR_EACH_VEC_ELT (rhsc, j, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n-\t  rhsc.release ();\n+\t  rhsc.truncate (0);\n \t}\n \n       /* If we use a static chain, pass it along.  */\n@@ -4628,8 +4606,8 @@ static void\n find_func_aliases (struct function *fn, gimple origt)\n {\n   gimple t = origt;\n-  vec<ce_s> lhsc = vNULL;\n-  vec<ce_s> rhsc = vNULL;\n+  auto_vec<ce_s, 16> lhsc;\n+  auto_vec<ce_s, 16> rhsc;\n   struct constraint_expr *c;\n   varinfo_t fi;\n \n@@ -4715,14 +4693,13 @@ find_func_aliases (struct function *fn, gimple origt)\n \t  else if (code == COND_EXPR)\n \t    {\n \t      /* The result is a merge of both COND_EXPR arms.  */\n-\t      vec<ce_s> tmp = vNULL;\n+\t      auto_vec<ce_s, 2> tmp;\n \t      struct constraint_expr *rhsp;\n \t      unsigned i;\n \t      get_constraint_for_rhs (gimple_assign_rhs2 (t), &rhsc);\n \t      get_constraint_for_rhs (gimple_assign_rhs3 (t), &tmp);\n \t      FOR_EACH_VEC_ELT (tmp, i, rhsp)\n \t\trhsc.safe_push (*rhsp);\n-\t      tmp.release ();\n \t    }\n \t  else if (truth_value_p (code))\n \t    /* Truth value results are not pointer (parts).  Or at least\n@@ -4731,7 +4708,7 @@ find_func_aliases (struct function *fn, gimple origt)\n \t  else\n \t    {\n \t      /* All other operations are merges.  */\n-\t      vec<ce_s> tmp = vNULL;\n+\t      auto_vec<ce_s, 4> tmp;\n \t      struct constraint_expr *rhsp;\n \t      unsigned i, j;\n \t      get_constraint_for_rhs (gimple_assign_rhs1 (t), &rhsc);\n@@ -4742,7 +4719,6 @@ find_func_aliases (struct function *fn, gimple origt)\n \t\t    rhsc.safe_push (*rhsp);\n \t\t  tmp.truncate (0);\n \t\t}\n-\t      tmp.release ();\n \t    }\n \t  process_all_all_constraints (lhsc, rhsc);\n \t}\n@@ -4804,7 +4780,7 @@ find_func_aliases (struct function *fn, gimple origt)\n \t     any global memory.  */\n \t  if (op)\n \t    {\n-\t      vec<ce_s> lhsc = vNULL;\n+\t      auto_vec<ce_s, 2> lhsc;\n \t      struct constraint_expr rhsc, *lhsp;\n \t      unsigned j;\n \t      get_constraint_for (op, &lhsc);\n@@ -4813,7 +4789,6 @@ find_func_aliases (struct function *fn, gimple origt)\n \t      rhsc.type = SCALAR;\n \t      FOR_EACH_VEC_ELT (lhsc, j, lhsp)\n \t\tprocess_constraint (new_constraint (*lhsp, rhsc));\n-\t      lhsc.release ();\n \t    }\n \t}\n       for (i = 0; i < gimple_asm_ninputs (t); ++i)\n@@ -4836,9 +4811,6 @@ find_func_aliases (struct function *fn, gimple origt)\n \t    make_escape_constraint (op);\n \t}\n     }\n-\n-  rhsc.release ();\n-  lhsc.release ();\n }\n \n \n@@ -4866,8 +4838,8 @@ static void\n find_func_clobbers (struct function *fn, gimple origt)\n {\n   gimple t = origt;\n-  vec<ce_s> lhsc = vNULL;\n-  auto_vec<ce_s> rhsc;\n+  auto_vec<ce_s, 16> lhsc;\n+  auto_vec<ce_s, 16> rhsc;\n   varinfo_t fi;\n \n   /* Add constraints for clobbered/used in IPA mode.\n@@ -4906,7 +4878,7 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t  get_constraint_for_address_of (lhs, &rhsc);\n \t  FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhsc, *rhsp));\n-\t  rhsc.release ();\n+\t  rhsc.truncate (0);\n \t}\n     }\n \n@@ -4934,7 +4906,7 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t  get_constraint_for_address_of (rhs, &rhsc);\n \t  FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n-\t  rhsc.release ();\n+\t  rhsc.truncate (0);\n \t}\n     }\n \n@@ -4982,12 +4954,10 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t      lhs = get_function_part_constraint (fi, fi_clobbers);\n \t      FOR_EACH_VEC_ELT (lhsc, i, lhsp)\n \t\tprocess_constraint (new_constraint (lhs, *lhsp));\n-\t      lhsc.release ();\n \t      get_constraint_for_ptr_offset (src, NULL_TREE, &rhsc);\n \t      lhs = get_function_part_constraint (fi, fi_uses);\n \t      FOR_EACH_VEC_ELT (rhsc, i, rhsp)\n \t\tprocess_constraint (new_constraint (lhs, *rhsp));\n-\t      rhsc.release ();\n \t      return;\n \t    }\n \t  /* The following function clobbers memory pointed to by\n@@ -5003,7 +4973,6 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t      lhs = get_function_part_constraint (fi, fi_clobbers);\n \t      FOR_EACH_VEC_ELT (lhsc, i, lhsp)\n \t\tprocess_constraint (new_constraint (lhs, *lhsp));\n-\t      lhsc.release ();\n \t      return;\n \t    }\n \t  /* The following functions clobber their second and third\n@@ -5073,7 +5042,6 @@ find_func_clobbers (struct function *fn, gimple origt)\n \t  get_constraint_for_address_of (arg, &rhsc);\n \t  FOR_EACH_VEC_ELT (rhsc, j, rhsp)\n \t    process_constraint (new_constraint (lhs, *rhsp));\n-\t  rhsc.release ();\n \t}\n \n       /* Build constraints for propagating clobbers/uses along the"}]}