{"sha": "e13f1c1432140a43edd23a50c3916fa41fadd610", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTEzZjFjMTQzMjE0MGE0M2VkZDIzYTUwYzM5MTZmYTQxZmFkZDYxMA==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2006-03-20T21:00:18Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2006-03-20T21:00:18Z"}, "message": "re PR tree-optimization/26629 (tree load PRE does not work on array references)\n\n2006-03-20  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        PR tree-opt/26629\n        * tree-ssa-pre (phi_translate): Handle ARRAY_REF's operands.\n        (valid_in_set): Handle ARRAY_REF.\n        Change \"if min_variant or VH\" to asserts.\n        (create_component_ref_by_pieces): Handle ARRAY_REF.\n        (create_expression_by_pieces): Likewise.\n        (can_PRE_operation): ARRAY_REFs can now be PRE'd.\n\n2006-03-20  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        PR tree-opt/26629\n        * gcc.dg/tree-ssa/loadpre12.c: New test.\n        * gcc.dg/tree-ssa/loadpre13.c: New test.\n        * gcc.dg/tree-ssa/loadpre14.c: New test.\n        * gcc.dg/tree-ssa/loadpre15.c: New test.\n        * gcc.dg/tree-ssa/loadpre16.c: New test.\n        * gcc.dg/tree-ssa/loadpre17.c: New test.\n        * gcc.dg/tree-ssa/loadpre18.c: New test.\n        * gcc.dg/tree-ssa/loadpre19.c: New test.\n        * gcc.dg/tree-ssa/loadpre20.c: New test.\n        * gcc.dg/tree-ssa/loadpre21.c: New test.\n        * gcc.dg/tree-ssa/loadpre22.c: New test.\n\nFrom-SVN: r112227", "tree": {"sha": "62891f428e807856aeb41bc768c8ca8e04b03e7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62891f428e807856aeb41bc768c8ca8e04b03e7f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e13f1c1432140a43edd23a50c3916fa41fadd610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13f1c1432140a43edd23a50c3916fa41fadd610", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e13f1c1432140a43edd23a50c3916fa41fadd610", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e13f1c1432140a43edd23a50c3916fa41fadd610/comments", "author": null, "committer": null, "parents": [{"sha": "7a22dbec36019060c01d68ea8703e2a11d4d2247", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a22dbec36019060c01d68ea8703e2a11d4d2247", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a22dbec36019060c01d68ea8703e2a11d4d2247"}], "stats": {"total": 343, "additions": 318, "deletions": 25}, "files": [{"sha": "157a550c1bb29cb94256a1cb3a8443be9f518049", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -1,3 +1,13 @@\n+2006-03-20  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR tree-opt/26629\n+\t* tree-ssa-pre (phi_translate): Handle ARRAY_REF's operands.\n+\t(valid_in_set): Handle ARRAY_REF.\n+\tChange \"if min_variant or VH\" to asserts.\n+\t(create_component_ref_by_pieces): Handle ARRAY_REF.\n+\t(create_expression_by_pieces): Likewise.\n+\t(can_PRE_operation): ARRAY_REFs can now be PRE'd.\n+\n 2006-03-20  David Edelsohn  <edelsohn@gnu.org>\n \n \t* genpreds.c (write_insn_extra_address_constraint): Argument `c'"}, {"sha": "92e62fc66fa0c1fdade45be832e120dffb7d018e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -1,3 +1,18 @@\n+2006-03-20  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR tree-opt/26629\n+\t* gcc.dg/tree-ssa/loadpre12.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre13.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre14.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre15.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre16.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre17.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre18.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre19.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre20.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre21.c: New test.\n+\t* gcc.dg/tree-ssa/loadpre22.c: New test.\n+\n 2006-03-19  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26741"}, {"sha": "4a79c802b132cf9253b0170f8eada0d7f7c99747", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre12.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre12.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+type *t;\n+int g(int);\n+int f(int tt)\n+{\n+    type *t1 = t;\n+    if ((*t1)[0])\n+      (*t1)[0] = 2;\n+    return g((*t1)[0]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "420ad7162bcfc9bc30589a295ba453be408084fa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre13.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre13.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int t[2];\n+int g(int);\n+int f(int tt)\n+{\n+    if (t[0])\n+      t[0] = 2;\n+    return g(t[0]);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "f4c06f264d343e2af01ec0cca718f3f64ec04996", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre14.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre14.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  type c = {0, 1};\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[0];\n+  if (argc)\n+    {\n+      a = &c;\n+    }\n+  e = (*a)[0];\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "3e3ff7c4535edcd683853218212aeedd42c4e484", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre15.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre15.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc, int t)\n+{\n+  type c = {0, 1};\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[t];\n+  if (argc)\n+    {\n+      a = &c;\n+    }\n+  e = (*a)[t];\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "3702440f3d716fc033ff279540f270002ab1fb23", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre16.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre16.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[0];\n+  if (argc)\n+      a++;\n+  e = (*a)[0];\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "93c530d5e57861814b4957103ba3df4a7dcddead", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre17.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre17.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[argc];\n+  if (argc)\n+      a++;\n+  e = (*a)[argc];\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "21a1d0670088e4f2eb9fa30ab5d034694cef63b4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre18.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre18.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[argc];\n+  if (argc)\n+      argc++;\n+  e = (*a)[argc];\n+  return d + e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\" { xfail *-*-* } } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "62ded9a6d80b6eda731a4b64cec06a1577a35ee0", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre19.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre19.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[argc];\n+  if (!d)\n+      argc++;\n+  e = (*a)[argc];\n+  return e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"  } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "330b67a579f0c6f299e80819a7785c115d5d8a76", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre20.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre20.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int d, e;\n+  \n+  /* Should be able to eliminate the second load of *a along the main path. */\n+  d = (*a)[argc];\n+  if (!d)\n+      a++;\n+  e = (*a)[argc];\n+  return e;\n+}\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"  } } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "77caef6ded6557b48f2112f53f4e076eb3307a8c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre21.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre21.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int b;\n+  int i;\n+  int d, e;\n+\n+  /* Should be able to hoist this out of the loop.  */\n+  for (i = 0; i < argc; i++)\n+    {\n+      e = (*a)[0];\n+    }\n+  return d + e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "3c03c9b12f68878aca79abc55f7d8e12ebe13cc5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loadpre22.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floadpre22.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+typedef int type[2];\n+int main(type *a, int argc)\n+{\n+  int b;\n+  int i;\n+  int d, e;\n+\n+  /* Should be able to hoist this out of the loop.  */\n+  for (i = 0; i < argc; i++)\n+    {\n+      e = (*a)[argc];\n+    }\n+  return d + e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Eliminated: 1\" 1 \"pre\"} } */\n+/* { dg-final { cleanup-tree-dump \"pre\" } } */"}, {"sha": "eea38c3bca10b986e6e4d84b8a2cf003f237537d", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 109, "deletions": 25, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e13f1c1432140a43edd23a50c3916fa41fadd610/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=e13f1c1432140a43edd23a50c3916fa41fadd610", "patch": "@@ -1177,32 +1177,78 @@ phi_translate (tree expr, value_set_t set, basic_block pred,\n \n     case tcc_reference:\n       {\n-\ttree oldop1 = TREE_OPERAND (expr, 0);\n-\ttree newop1;\n+\ttree oldop0 = TREE_OPERAND (expr, 0);\n+\ttree oldop1 = NULL;\n+\ttree newop0;\n+\ttree newop1 = NULL;\n+\ttree oldop2 = NULL;\n+\ttree newop2 = NULL;\n+\ttree oldop3 = NULL;\n+\ttree newop3 = NULL;\n \ttree newexpr;\n \tVEC (tree, gc) * oldvuses = NULL;\n \tVEC (tree, gc) * newvuses = NULL;\n \n \tif (TREE_CODE (expr) != INDIRECT_REF\n-\t    && TREE_CODE (expr) != COMPONENT_REF)\n+\t    && TREE_CODE (expr) != COMPONENT_REF\n+\t    && TREE_CODE (expr) != ARRAY_REF)\n \t  return NULL;\n \n-\tnewop1 = phi_translate (find_leader (set, oldop1),\n+\tnewop0 = phi_translate (find_leader (set, oldop0),\n \t\t\t\tset, pred, phiblock);\n-\tif (newop1 == NULL)\n+\tif (newop0 == NULL)\n \t  return NULL;\n+\t\n+\tif (TREE_CODE (expr) == ARRAY_REF)\n+\t  {\n+\t    oldop1 = TREE_OPERAND (expr, 1);\n+\t    newop1 = phi_translate (find_leader (set, oldop1),\n+\t\t\t\t    set, pred, phiblock);\n+\t\n+\t    if (newop1 == NULL)\n+\t      return NULL;\n+\t    oldop2 = TREE_OPERAND (expr, 2);\n+\t    if (oldop2)\n+\t      {\n+\t\tnewop2 = phi_translate (find_leader (set, oldop2),\n+\t\t\t\t\tset, pred, phiblock);\n+\t    \n+\t\tif (newop2 == NULL)\n+\t\t  return NULL;\n+\t      }\n+\t    oldop3 = TREE_OPERAND (expr, 3);\n+\t    if (oldop3)\n+\t      {\n+\t\tnewop3 = phi_translate (find_leader (set, oldop3),\n+\t\t\t\t\tset, pred, phiblock);\n+\t\t\n+\t\tif (newop3 == NULL)\n+\t\t  return NULL;\n+\t      }\n+\t  }\n \n \toldvuses = VALUE_HANDLE_VUSES (get_value_handle (expr));\n \tif (oldvuses)\n \t  newvuses = translate_vuses_through_block (oldvuses, pred);\n-\n-\tif (newop1 != oldop1 || newvuses != oldvuses)\n+\t\n+\tif (newop0 != oldop0 || newvuses != oldvuses\n+\t    || newop1 != oldop1 \n+\t    || newop2 != oldop2 \n+\t    || newop3 != oldop3)\n \t  {\n \t    tree t;\n \n \t    newexpr = pool_alloc (reference_node_pool);\n \t    memcpy (newexpr, expr, tree_size (expr));\n-\t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop1);\n+\t    TREE_OPERAND (newexpr, 0) = get_value_handle (newop0);\n+\t    if (TREE_CODE (expr) == ARRAY_REF)\n+\t      {\n+\t\tTREE_OPERAND (newexpr, 1) = get_value_handle (newop1);\n+\t\tif (newop2)\n+\t\t  TREE_OPERAND (newexpr, 2) = get_value_handle (newop2);\n+\t\tif (newop3)\n+\t\t  TREE_OPERAND (newexpr, 3) = get_value_handle (newop3);\n+\t      }\n \n \t    t = fully_constant_expression (newexpr);\n \n@@ -1525,22 +1571,38 @@ valid_in_set (value_set_t set, tree expr, basic_block block)\n     case tcc_reference:\n       {\n \tif (TREE_CODE (expr) == INDIRECT_REF \n-\t    || TREE_CODE (expr) == COMPONENT_REF)\n+\t    || TREE_CODE (expr) == COMPONENT_REF\n+            || TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    tree op0 = TREE_OPERAND (expr, 0);\n-\t    if (is_gimple_min_invariant (op0)\n-\t\t|| TREE_CODE (op0) == VALUE_HANDLE)\n+\t    gcc_assert (is_gimple_min_invariant (op0)\n+\t\t\t|| TREE_CODE (op0) == VALUE_HANDLE);\n+\t    if (!set_contains_value (set, op0))\n+\t      return false;\n+\t    if (TREE_CODE (expr) == ARRAY_REF)\n \t      {\n-\t\tbool retval = set_contains_value (set, op0);\n-\t\tif (retval)\n-\t\t  {\n-\t\t    return set_contains_value (ANTIC_SAFE_LOADS (block),\n-\t\t\t\t\t       vh)\n-\t\t      || !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n-\t\t\t\t\t\t block);\n-\t\t  }\n-\t\treturn false;\n-\t      }\n+\t\ttree op1 = TREE_OPERAND (expr, 1);\n+\t\ttree op2 = TREE_OPERAND (expr, 2);\n+\t\ttree op3 = TREE_OPERAND (expr, 3);\n+\t\tgcc_assert (is_gimple_min_invariant (op1)\n+\t\t            || TREE_CODE (op1) == VALUE_HANDLE);\n+\t\tif (!set_contains_value (set, op1))\n+\t\t  return false;\n+\t\tgcc_assert (!op2 || is_gimple_min_invariant (op2)\n+\t\t            || TREE_CODE (op2) == VALUE_HANDLE);\n+\t\tif (op2\n+\t\t    && !set_contains_value (set, op2))\n+\t\t  return false;\n+\t\tgcc_assert (!op3 || is_gimple_min_invariant (op3)\n+\t\t            || TREE_CODE (op3) == VALUE_HANDLE);\n+\t\tif (op3\n+\t\t    && !set_contains_value (set, op3))\n+\t\t  return false;\n+\t    }\n+\t  return set_contains_value (ANTIC_SAFE_LOADS (block),\n+\t\t\t\t     vh)\n+\t    || !vuses_dies_in_block_x (VALUE_HANDLE_VUSES (vh),\n+\t\t\t\t       block);\n \t  }\n       }\n       return false;\n@@ -2091,7 +2153,8 @@ can_PRE_operation (tree op)\n     || COMPARISON_CLASS_P (op)\n     || TREE_CODE (op) == INDIRECT_REF\n     || TREE_CODE (op) == COMPONENT_REF\n-    || TREE_CODE (op) == CALL_EXPR;\n+    || TREE_CODE (op) == CALL_EXPR\n+    || TREE_CODE (op) == ARRAY_REF;\n }\n \n \n@@ -2105,8 +2168,8 @@ static VEC(tree,heap) *inserted_exprs;\n    to see which expressions need to be put into GC'able memory  */\n static VEC(tree, heap) *need_creation;\n \n-/* For COMPONENT_REF's, we can't have any intermediates for the\n-   COMPONENT_REF or INDIRECT_REF portion, because we'd end up with\n+/* For COMPONENT_REF's and ARRAY_REF's, we can't have any intermediates for the\n+   COMPONENT_REF or INDIRECT_REF or ARRAY_REF portion, because we'd end up with\n    trying to rename aggregates into ssa form directly, which is a no\n    no.\n \n@@ -2136,6 +2199,26 @@ create_component_ref_by_pieces (basic_block block, tree expr, tree stmts)\n \n   switch TREE_CODE (genop)\n     {\n+    case ARRAY_REF:\n+      {\n+\ttree op0;\n+\ttree op1, op2, op3;\n+\top0 = create_component_ref_by_pieces (block, \n+\t\t\t\t\t      TREE_OPERAND (genop, 0),\n+\t\t\t\t\t      stmts);\n+\top1 = TREE_OPERAND (genop, 1);\n+\tif (TREE_CODE (op1) == VALUE_HANDLE)\n+\t  op1 = find_or_generate_expression (block, op1, stmts);\n+\top2 = TREE_OPERAND (genop, 2);\n+\tif (op2 && TREE_CODE (op2) == VALUE_HANDLE)\n+\t  op2 = find_or_generate_expression (block, op2, stmts);\n+\top3 = TREE_OPERAND (genop, 3);\n+\tif (op3 && TREE_CODE (op3) == VALUE_HANDLE)\n+\t  op3 = find_or_generate_expression (block, op3, stmts);\n+\tfolded = build4 (ARRAY_REF, TREE_TYPE (genop), op0, op1, \n+\t\t\t      op2, op3);\n+\treturn folded;\n+      }\n     case COMPONENT_REF:\n       {\n \ttree op0;\n@@ -2259,7 +2342,8 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n       break;\n     case tcc_reference:\n       {\n-\tif (TREE_CODE (expr) == COMPONENT_REF)\n+\tif (TREE_CODE (expr) == COMPONENT_REF\n+\t    || TREE_CODE (expr) == ARRAY_REF)\n \t  {\n \t    folded = create_component_ref_by_pieces (block, expr, stmts);\n \t  }"}]}