{"sha": "de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGUwYTNmYTM4ZTJhZDhmMzM1OThiYjQ0YjcwYmQ5MDQ3ZDM2NmU5Nw==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2016-10-14T17:21:19Z"}, "committer": {"name": "Pat Haugen", "email": "pthaugen@gcc.gnu.org", "date": "2016-10-14T17:21:19Z"}, "message": "loop-unroll.c (unroll_loop_runtime_iterations): Condition initial loop peel to loops with exit test at the beginning.\n\n\t* loop-unroll.c (unroll_loop_runtime_iterations): Condition initial\n\tloop peel to loops with exit test at the beginning.\n\nFrom-SVN: r241173", "tree": {"sha": "e64dc78de5a910baa8f98945a488a47408d2d1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e64dc78de5a910baa8f98945a488a47408d2d1bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de0a3fa38e2ad8f33598bb44b70bd9047d366e97/comments", "author": null, "committer": null, "parents": [{"sha": "db2fb304fe27afd8939aa94a4b11f050e6f625b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2fb304fe27afd8939aa94a4b11f050e6f625b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db2fb304fe27afd8939aa94a4b11f050e6f625b3"}], "stats": {"total": 46, "additions": 31, "deletions": 15}, "files": [{"sha": "a998060b3b3f215df2ad099bc5085a7c7d1e9e74", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0a3fa38e2ad8f33598bb44b70bd9047d366e97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0a3fa38e2ad8f33598bb44b70bd9047d366e97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "patch": "@@ -1,3 +1,8 @@\n+2016-10-14  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* loop-unroll.c (unroll_loop_runtime_iterations): Condition initial\n+\tloop peel to loops with exit test at the beginning.\n+\n 2016-10-14  Pat Haugen  <pthaugen@us.ibm.com>\n \n \tPR rtl-optimization/68212"}, {"sha": "91118a310d004ec4d1f9da731206a5a86dc30ea9", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de0a3fa38e2ad8f33598bb44b70bd9047d366e97/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de0a3fa38e2ad8f33598bb44b70bd9047d366e97/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=de0a3fa38e2ad8f33598bb44b70bd9047d366e97", "patch": "@@ -858,7 +858,7 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   rtx old_niter, niter, tmp;\n   rtx_insn *init_code, *branch_code;\n   unsigned i, j, p;\n-  basic_block preheader, *body, swtch, ezc_swtch;\n+  basic_block preheader, *body, swtch, ezc_swtch = NULL;\n   int may_exit_copy, iter_freq, new_freq;\n   gcov_type iter_count, new_count;\n   unsigned n_peel;\n@@ -918,6 +918,16 @@ unroll_loop_runtime_iterations (struct loop *loop)\n   if (tmp != niter)\n     emit_move_insn (niter, tmp);\n \n+  /* For loops that exit at end, add one to niter to account for first pass\n+     through loop body before reaching exit test. */\n+  if (exit_at_end)\n+    {\n+      niter = expand_simple_binop (desc->mode, PLUS,\n+\t\t\t\t   niter, const1_rtx,\n+\t\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+      old_niter = niter;\n+    }\n+\n   /* Count modulo by ANDing it with max_unroll; we use the fact that\n      the number of unrollings is a power of two, and thus this is correct\n      even if there is overflow in the computation.  */\n@@ -936,20 +946,21 @@ unroll_loop_runtime_iterations (struct loop *loop)\n \n   auto_sbitmap wont_exit (max_unroll + 2);\n \n-  /* Peel the first copy of loop body (almost always we must leave exit test\n-     here; the only exception is when we have extra zero check and the number\n-     of iterations is reliable.  Also record the place of (possible) extra\n-     zero check.  */\n-  bitmap_clear (wont_exit);\n-  if (extra_zero_check\n-      && !desc->noloop_assumptions)\n-    bitmap_set_bit (wont_exit, 1);\n-  ezc_swtch = loop_preheader_edge (loop)->src;\n-  ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n-\t\t\t\t      1, wont_exit, desc->out_edge,\n-\t\t\t\t      &remove_edges,\n-\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ);\n-  gcc_assert (ok);\n+  if (extra_zero_check)\n+    {\n+      /* Peel the first copy of loop body.  Leave the exit test if the number\n+\t of iterations is not reliable.  Also record the place of the extra zero\n+\t check.  */\n+      bitmap_clear (wont_exit);\n+      if (!desc->noloop_assumptions)\n+\tbitmap_set_bit (wont_exit, 1);\n+      ezc_swtch = loop_preheader_edge (loop)->src;\n+      ok = duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n+\t\t\t\t\t  1, wont_exit, desc->out_edge,\n+\t\t\t\t\t  &remove_edges,\n+\t\t\t\t\t  DLTHE_FLAG_UPDATE_FREQ);\n+      gcc_assert (ok);\n+    }\n \n   /* Record the place where switch will be built for preconditioning.  */\n   swtch = split_edge (loop_preheader_edge (loop));"}]}