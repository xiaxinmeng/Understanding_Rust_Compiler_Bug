{"sha": "b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "node_id": "C_kwDOANBUbNoAKGI2ZGYxMTMyNDdiOWYzZjdjM2RiMGU2NWM0ODFkYWQ1YmNmZGRmYjQ", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-07-26T15:42:23Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2022-08-03T11:01:53Z"}, "message": "d: Merge upstream dmd d7772a2369, phobos 5748ca43f.\n\nIn upstream dmd, the compiler front-end and run-time have been merged\ntogether into one repository.  Both dmd and libdruntime now track that.\n\nD front-end changes:\n\n    - Deprecated `scope(failure)' blocks that contain `return' statements.\n    - Deprecated using integers for `version' or `debug' conditions.\n    - Deprecated returning a discarded void value from a function.\n    - `new' can now allocate an associative array.\n\nD runtime changes:\n\n    - Added avx512f detection to core.cpuid module.\n\nPhobos changes:\n\n    - Changed std.experimental.logger.core.sharedLog to return\n      shared(Logger).\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd d7772a2369.\n\t* dmd/VERSION: Bump version to v2.100.1.\n\t* d-codegen.cc (get_frameinfo): Check whether decision to generate\n\tclosure changed since semantic finished.\n\t* d-lang.cc (d_handle_option): Remove handling of -fdebug=level and\n\t-fversion=level.\n\t* decl.cc (DeclVisitor::visit (VarDeclaration *)): Generate evaluation\n\tof noreturn variable initializers before throw.\n\t* expr.cc (ExprVisitor::visit (AssignExp *)): Don't generate\n\tassignment for noreturn types, only evaluate for side effects.\n\t* lang.opt (fdebug=): Undocument -fdebug=level.\n\t(fversion=): Undocument -fversion=level.\n\nlibphobos/ChangeLog:\n\n\t* configure: Regenerate.\n\t* configure.ac (libtool_VERSION): Update to 4:0:0.\n\t* libdruntime/MERGE: Merge upstream druntime d7772a2369.\n\t* libdruntime/Makefile.am (DRUNTIME_DSOURCES): Add\n\tcore/internal/array/duplication.d.\n\t* libdruntime/Makefile.in: Regenerate.\n\t* src/MERGE: Merge upstream phobos 5748ca43f.\n\t* testsuite/libphobos.gc/nocollect.d:", "tree": {"sha": "31466a07292ad0cc289de7c23e39ba31b9e8b7c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31466a07292ad0cc289de7c23e39ba31b9e8b7c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ce76d940501cb04d14a0d36752b4f93473531c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64ce76d940501cb04d14a0d36752b4f93473531c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64ce76d940501cb04d14a0d36752b4f93473531c"}], "stats": {"total": 3784, "additions": 2497, "deletions": 1287}, "files": [{"sha": "3fd4bee58f6910aaefdff159e9e2a5742e10798b", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2826,8 +2826,15 @@ get_frameinfo (FuncDeclaration *fd)\n \n   DECL_LANG_FRAMEINFO (fds) = ffi;\n \n+  const bool requiresClosure = fd->requiresClosure;\n   if (fd->needsClosure ())\n     {\n+      /* This can shift due to templates being expanded that access alias\n+         symbols, give it a decent error for now.  */\n+      if (requiresClosure != fd->requiresClosure\n+\t  && (fd->nrvo_var || global.params.betterC))\n+\tfd->checkClosure ();\n+\n       /* Set-up a closure frame, this will be allocated on the heap.  */\n       FRAMEINFO_CREATES_FRAME (ffi) = 1;\n       FRAMEINFO_IS_CLOSURE (ffi) = 1;"}, {"sha": "04147edee32d1b1ce755982b9ebd7d84b7620a4e", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -456,16 +456,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       break;\n \n     case OPT_fdebug_:\n-      if (ISDIGIT (arg[0]))\n-\t{\n-\t  int level = integral_argument (arg);\n-\t  if (level != -1)\n-\t    {\n-\t      global.params.debuglevel = level;\n-\t      break;\n-\t    }\n-\t}\n-\n       if (Identifier::isValidIdentifier (CONST_CAST (char *, arg)))\n \t{\n \t  if (!global.params.debugids)\n@@ -713,16 +703,6 @@ d_handle_option (size_t scode, const char *arg, HOST_WIDE_INT value,\n       break;\n \n     case OPT_fversion_:\n-      if (ISDIGIT (arg[0]))\n-\t{\n-\t  int level = integral_argument (arg);\n-\t  if (level != -1)\n-\t    {\n-\t      global.params.versionlevel = level;\n-\t      break;\n-\t    }\n-\t}\n-\n       if (Identifier::isValidIdentifier (CONST_CAST (char *, arg)))\n \t{\n \t  if (!global.params.versionids)"}, {"sha": "58cea4dec3f77e411169c5b789765262fe293c2f", "filename": "gcc/d/decl.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdecl.cc?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -646,9 +646,12 @@ class DeclVisitor : public Visitor\n \tif (!d->isDataseg () && !d->isMember ()\n \t    && d->_init && !d->_init->isVoidInitializer ())\n \t  {\n+\t    /* Evaluate RHS for side effects first.  */\n+\t    Expression *ie = initializerToExpression (d->_init);\n+\t    add_stmt (build_expr (ie));\n+\n \t    Expression *e = d->type->defaultInitLiteral (d->loc);\n-\t    tree exp = build_expr (e);\n-\t    add_stmt (exp);\n+\t    add_stmt (build_expr (e));\n \t  }\n \n \treturn;"}, {"sha": "c358b69e3fc90a1f1e05e0626c605a3460ffac4d", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,4 +1,4 @@\n-56589f0f4d724c1c8022c57509a243f16a04228a\n+d7772a236983ec37b92d21b28bad3cd2de57b945\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "83a14f57e169f35ab46964cecd93530bae533ac3", "filename": "gcc/d/dmd/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FVERSION?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1 +1 @@\n-v2.100.0\n+v2.100.1"}, {"sha": "272e751cb51b51c15beadbc509724c1081aa7546", "filename": "gcc/d/dmd/arrayop.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Farrayop.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Farrayop.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Farrayop.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -111,8 +111,8 @@ bool checkNonAssignmentArrayOp(Expression e, bool suggestion = false)\n  * evaluation order as the actual array operations have no\n  * side-effect.\n  * References:\n- * https://github.com/dlang/druntime/blob/master/src/object.d#L3944\n- * https://github.com/dlang/druntime/blob/master/src/core/internal/array/operations.d\n+ * https://github.com/dlang/dmd/blob/cdfadf8a18f474e6a1b8352af2541efe3e3467cc/druntime/src/object.d#L4694\n+ * https://github.com/dlang/dmd/blob/master/druntime/src/core/internal/array/operations.d\n  */\n Expression arrayOp(BinExp e, Scope* sc)\n {"}, {"sha": "e118d7014f959f203343c0dd4726f36b370e1f10", "filename": "gcc/d/dmd/chkformat.d", "status": "modified", "additions": 356, "deletions": 138, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fchkformat.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -62,7 +62,7 @@ import dmd.target;\n bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expression[] args, bool isVa_list)\n {\n     //printf(\"checkPrintFormat('%.*s')\\n\", cast(int)format.length, format.ptr);\n-    size_t n, gnu_m_count;    // index in args / number of Format.GNU_m\n+    size_t n;    // index in args\n     for (size_t i = 0; i < format.length;)\n     {\n         if (format[i] != '%')\n@@ -79,6 +79,8 @@ bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expre\n \n         if (fmt == Format.percent)\n             continue;                   // \"%%\", no arguments\n+        if (fmt == Format.GNU_m)\n+            continue;                   // \"%m\", no arguments\n \n         if (isVa_list)\n         {\n@@ -88,14 +90,11 @@ bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expre\n             continue;\n         }\n \n-        if (fmt == Format.GNU_m)\n-            ++gnu_m_count;\n-\n         Expression getNextArg(ref bool skip)\n         {\n             if (n == args.length)\n             {\n-                if (args.length < (n + 1) - gnu_m_count)\n+                if (args.length < (n + 1))\n                     deprecation(loc, \"more format specifiers than %d arguments\", cast(int)n);\n                 else\n                     skip = true;\n@@ -207,7 +206,6 @@ bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expre\n                     errorMsg(null, e, \"ptrdiff_t\", t);\n                 break;\n \n-            case Format.GNU_a:  // Format.GNU_a is only for scanf\n             case Format.lg:\n             case Format.g:      // double\n                 if (t.ty != Tfloat64 && t.ty != Timaginary64)\n@@ -289,8 +287,8 @@ bool checkPrintfFormat(ref const Loc loc, scope const char[] format, scope Expre\n                 break;\n \n             case Format.GNU_m:\n-                break;  // not assert(0) because it may go through it if there are extra arguments\n-\n+            case Format.POSIX_ms:\n+            case Format.POSIX_mls:\n             case Format.percent:\n                 assert(0);\n         }\n@@ -481,8 +479,6 @@ bool checkScanfFormat(ref const Loc loc, scope const char[] format, scope Expres\n                     errorMsg(null, e, \"real*\", t);\n                 break;\n \n-            case Format.GNU_a:\n-            case Format.GNU_m:\n             case Format.c:\n             case Format.s:      // pointer to char string\n                 if (!(t.ty == Tpointer && (tnext.ty == Tchar || tnext.ty == Tint8 || tnext.ty == Tuns8)))\n@@ -500,10 +496,23 @@ bool checkScanfFormat(ref const Loc loc, scope const char[] format, scope Expres\n                     errorMsg(null, e, \"void**\", t);\n                 break;\n \n+            case Format.POSIX_ms: // pointer to pointer to char string\n+                Type tnext2 = tnext ? tnext.nextOf() : null;\n+                if (!(t.ty == Tpointer && tnext.ty == Tpointer && (tnext2.ty == Tchar || tnext2.ty == Tint8 || tnext2.ty == Tuns8)))\n+                    errorMsg(null, e, \"char**\", t);\n+                break;\n+\n+            case Format.POSIX_mls: // pointer to pointer to wchar_t string\n+                Type tnext2 = tnext ? tnext.nextOf() : null;\n+                if (!(t.ty == Tpointer && tnext.ty == Tpointer && tnext2.ty.isSomeChar && tnext2.size() == target.c.wchar_tsize))\n+                    errorMsg(null, e, \"wchar_t**\", t);\n+                break;\n+\n             case Format.error:\n                 deprecation(loc, \"format specifier `\\\"%.*s\\\"` is invalid\", cast(int)slice.length, slice.ptr);\n                 break;\n \n+            case Format.GNU_m:\n             case Format.percent:\n                 assert(0);\n         }\n@@ -567,35 +576,97 @@ Format parseScanfFormatSpecifier(scope const char[] format, ref size_t idx,\n             return error();\n     }\n \n-    /* Read the scanset\n-     * A scanset can be anything, so we just check that it is paired\n+    /* Read the specifier\n      */\n-    if (format[i] == '[')\n+    Format specifier;\n+    Modifier flags = Modifier.none;\n+    switch (format[i])\n     {\n-        while (i < length)\n-        {\n-            if (format[i] == ']')\n-                break;\n+        case 'm':\n+            // https://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html\n+            // POSIX.1-2017 C Extension (CX)\n+            flags = Modifier.m;\n             ++i;\n-        }\n+            if (i == length)\n+                return error();\n+            if (format[i] == 'l')\n+            {\n+                ++i;\n+                if (i == length)\n+                    return error();\n+                flags = Modifier.ml;\n+            }\n \n-        // no `]` found\n-        if (i == length)\n-            return error();\n+            // Check valid conversion types for %m.\n+            if (format[i] == 'c' || format[i] == 's')\n+                specifier = flags == Modifier.ml ? Format.POSIX_mls :\n+                                                   Format.POSIX_ms;\n+            else if (format[i] == 'C' || format[i] == 'S')\n+                specifier = flags == Modifier.m ? Format.POSIX_mls :\n+                                                  Format.error;\n+            else if (format[i] == '[')\n+                goto case '[';\n+            else\n+                specifier = Format.error;\n+            ++i;\n+            break;\n \n-        ++i;\n-        // no specifier after `]`\n-        // it could be mixed with the one above, but then idx won't have the right index\n-        if (i == length)\n-            return error();\n-    }\n+        case 'l':\n+            // Look for wchar_t scanset %l[..]\n+            immutable j = i + 1;\n+            if (j < length && format[j] == '[')\n+            {\n+                i = j;\n+                flags = Modifier.l;\n+                goto case '[';\n+            }\n+            goto default;\n \n-    /* Read the specifier\n-     */\n-    char genSpec;\n-    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n-    if (specifier == Format.error)\n-        return error();\n+        case '[':\n+            // Read the scanset\n+            i++;\n+            if (i == length)\n+                return error();\n+            // If the conversion specifier begins with `[]` or `[^]`, the right\n+            // bracket character is not the terminator, but in the scanlist.\n+            if (format[i] == '^')\n+            {\n+                i++;\n+                if (i == length)\n+                    return error();\n+            }\n+            if (format[i] == ']')\n+            {\n+                i++;\n+                if (i == length)\n+                    return error();\n+            }\n+            // A scanset can be anything, so we just check that it is paired\n+            while (i < length)\n+            {\n+                if (format[i] == ']')\n+                    break;\n+                ++i;\n+            }\n+            // no `]` found\n+            if (i == length)\n+                return error();\n+\n+            specifier = flags == Modifier.none ? Format.s         :\n+                        flags == Modifier.l    ? Format.ls        :\n+                        flags == Modifier.m    ? Format.POSIX_ms  :\n+                        flags == Modifier.ml   ? Format.POSIX_mls :\n+                                                 Format.error;\n+            ++i;\n+            break;\n+\n+        default:\n+            char genSpec;\n+            specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+            if (specifier == Format.error)\n+                return error();\n+            break;\n+    }\n \n     idx = i;\n     return specifier;  // success\n@@ -613,11 +684,13 @@ Format parseScanfFormatSpecifier(scope const char[] format, ref size_t idx,\n  *          even if `Format.error` is returned\n  *      widthStar = set if * for width\n  *      precisionStar = set if * for precision\n+ *      useGNUExts = true if parsing GNU format extensions\n  * Returns:\n  *      Format\n  */\n Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n-        out bool widthStar, out bool precisionStar) nothrow pure @safe\n+        out bool widthStar, out bool precisionStar, bool useGNUExts =\n+        findCondition(global.versionids, Identifier.idPool(\"CRuntime_Glibc\"))) nothrow pure @safe\n {\n     auto i = idx;\n     assert(format[i] == '%');\n@@ -730,14 +803,33 @@ Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n     /* Read the specifier\n      */\n     char genSpec;\n-    Format specifier = parseGenericFormatSpecifier(format, i, genSpec);\n-    if (specifier == Format.error)\n-        return error();\n+    Format specifier;\n+    switch (format[i])\n+    {\n+        case 'm':\n+            // https://www.gnu.org/software/libc/manual/html_node/Other-Output-Conversions.html\n+            if (useGNUExts)\n+            {\n+                specifier = Format.GNU_m;\n+                genSpec = format[i];\n+                ++i;\n+                break;\n+            }\n+            goto default;\n+\n+        default:\n+            specifier = parseGenericFormatSpecifier(format, i, genSpec);\n+            if (specifier == Format.error)\n+                return error();\n+            break;\n+    }\n \n     switch (genSpec)\n     {\n         case 'c':\n         case 's':\n+        case 'C':\n+        case 'S':\n             if (hash || zero)\n                 return error();\n             break;\n@@ -748,6 +840,11 @@ Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n                 return error();\n             break;\n \n+        case 'm':\n+            if (hash || zero || flags)\n+                return error();\n+            break;\n+\n         case 'n':\n             if (hash || zero || precision || width || flags)\n                 return error();\n@@ -761,6 +858,22 @@ Format parsePrintfFormatSpecifier(scope const char[] format, ref size_t idx,\n     return specifier;  // success\n }\n \n+/* Different kinds of conversion modifiers. */\n+enum Modifier\n+{\n+    none,\n+    h,          // short\n+    hh,         // char\n+    j,          // intmax_t\n+    l,          // wint_t/wchar_t\n+    ll,         // long long int\n+    L,          // long double\n+    m,          // char**\n+    ml,         // wchar_t**\n+    t,          // ptrdiff_t\n+    z           // size_t\n+}\n+\n /* Different kinds of formatting specifications, variations we don't\n    care about are merged. (Like we don't care about the difference between\n    f, e, g, a, etc.)\n@@ -799,8 +912,9 @@ enum Format\n     jn,         // pointer to intmax_t\n     zn,         // pointer to size_t\n     tn,         // pointer to ptrdiff_t\n-    GNU_a,      // GNU ext. : address to a string with no maximum size (scanf)\n-    GNU_m,      // GNU ext. : string corresponding to the error code in errno (printf) / length modifier (scanf)\n+    GNU_m,      // GNU ext. : string corresponding to the error code in errno (printf)\n+    POSIX_ms,   // POSIX ext. : dynamically allocated char string  (scanf)\n+    POSIX_mls,  // POSIX ext. : dynamically allocated wchar_t string (scanf)\n     percent,    // %% (i.e. no argument)\n     error,      // invalid format specification\n }\n@@ -820,38 +934,48 @@ enum Format\n  *      Format\n  */\n Format parseGenericFormatSpecifier(scope const char[] format,\n-    ref size_t idx, out char genSpecifier, bool useGNUExts =\n-    findCondition(global.versionids, Identifier.idPool(\"CRuntime_Glibc\"))) nothrow pure @trusted\n+    ref size_t idx, out char genSpecifier) nothrow pure @safe\n {\n     const length = format.length;\n \n     /* Read the `length modifier`\n      */\n     const lm = format[idx];\n-    bool lm1;        // if jztL\n-    bool lm2;        // if `hh` or `ll`\n-    if (lm == 'j' ||\n-        lm == 'z' ||\n-        lm == 't' ||\n-        lm == 'L')\n+    Modifier flags;\n+    switch (lm)\n     {\n-        ++idx;\n-        if (idx == length)\n-            return Format.error;\n-        lm1 = true;\n-    }\n-    else if (lm == 'h' || lm == 'l')\n-    {\n-        ++idx;\n-        if (idx == length)\n-            return Format.error;\n-        lm2 = lm == format[idx];\n-        if (lm2)\n-        {\n+        case 'j':\n+        case 'z':\n+        case 't':\n+        case 'L':\n+            flags = lm == 'j' ? Modifier.j :\n+                    lm == 'z' ? Modifier.z :\n+                    lm == 't' ? Modifier.t :\n+                                Modifier.L;\n             ++idx;\n             if (idx == length)\n                 return Format.error;\n-        }\n+            break;\n+\n+        case 'h':\n+        case 'l':\n+            ++idx;\n+            if (idx == length)\n+                return Format.error;\n+            if (lm == format[idx])\n+            {\n+                flags = lm == 'h' ? Modifier.hh : Modifier.ll;\n+                ++idx;\n+                if (idx == length)\n+                    return Format.error;\n+            }\n+            else\n+                flags = lm == 'h' ? Modifier.h : Modifier.l;\n+            break;\n+\n+        default:\n+            flags = Modifier.none;\n+            break;\n     }\n \n     /* Read the `specifier`\n@@ -863,103 +987,88 @@ Format parseGenericFormatSpecifier(scope const char[] format,\n     {\n         case 'd':\n         case 'i':\n-            if (lm == 'L')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'h' && lm2 ? Format.hhd :\n-                            lm == 'h'        ? Format.hd  :\n-                            lm == 'l' && lm2 ? Format.lld :\n-                            lm == 'l'        ? Format.ld  :\n-                            lm == 'j'        ? Format.jd  :\n-                            lm == 'z'        ? Format.zd  :\n-                            lm == 't'        ? Format.td  :\n-                                               Format.d;\n+            specifier = flags == Modifier.none ? Format.d   :\n+                        flags == Modifier.hh   ? Format.hhd :\n+                        flags == Modifier.h    ? Format.hd  :\n+                        flags == Modifier.ll   ? Format.lld :\n+                        flags == Modifier.l    ? Format.ld  :\n+                        flags == Modifier.j    ? Format.jd  :\n+                        flags == Modifier.z    ? Format.zd  :\n+                        flags == Modifier.t    ? Format.td  :\n+                                                 Format.error;\n             break;\n \n         case 'u':\n         case 'o':\n         case 'x':\n         case 'X':\n-            if (lm == 'L')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'h' && lm2 ? Format.hhu :\n-                            lm == 'h'        ? Format.hu  :\n-                            lm == 'l' && lm2 ? Format.llu :\n-                            lm == 'l'        ? Format.lu  :\n-                            lm == 'j'        ? Format.ju  :\n-                            lm == 'z'        ? Format.zd  :\n-                            lm == 't'        ? Format.td  :\n-                                               Format.u;\n+            specifier = flags == Modifier.none ? Format.u   :\n+                        flags == Modifier.hh   ? Format.hhu :\n+                        flags == Modifier.h    ? Format.hu  :\n+                        flags == Modifier.ll   ? Format.llu :\n+                        flags == Modifier.l    ? Format.lu  :\n+                        flags == Modifier.j    ? Format.ju  :\n+                        flags == Modifier.z    ? Format.zd  :\n+                        flags == Modifier.t    ? Format.td  :\n+                                                 Format.error;\n             break;\n \n-        case 'a':\n-            if (useGNUExts)\n-            {\n-                // https://www.gnu.org/software/libc/manual/html_node/Dynamic-String-Input.html\n-                specifier = Format.GNU_a;\n-                break;\n-            }\n-            goto case;\n-\n         case 'f':\n         case 'F':\n         case 'e':\n         case 'E':\n         case 'g':\n         case 'G':\n+        case 'a':\n         case 'A':\n-            if (lm == 'L')\n-                specifier = Format.Lg;\n-            else if (lm1 || lm2 || lm == 'h')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'l' ? Format.lg : Format.g;\n+            specifier = flags == Modifier.none ? Format.g  :\n+                        flags == Modifier.L    ? Format.Lg :\n+                        flags == Modifier.l    ? Format.lg :\n+                                                 Format.error;\n             break;\n \n         case 'c':\n-            if (lm1 || lm2 || lm == 'h')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'l' ? Format.lc : Format.c;\n+            specifier = flags == Modifier.none ? Format.c       :\n+                        flags == Modifier.l    ? Format.lc      :\n+                                                 Format.error;\n             break;\n \n         case 's':\n-            if (lm1 || lm2 || lm == 'h')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'l' ? Format.ls : Format.s;\n+            specifier = flags == Modifier.none ? Format.s       :\n+                        flags == Modifier.l    ? Format.ls      :\n+                                                 Format.error;\n             break;\n \n         case 'p':\n-            if (lm1 || lm2 || lm == 'h' || lm == 'l')\n-                specifier = Format.error;\n-            else\n-                specifier = Format.p;\n+            specifier = flags == Modifier.none ? Format.p :\n+                                                 Format.error;\n             break;\n \n         case 'n':\n-            if (lm == 'L')\n-                specifier = Format.error;\n-            else\n-                specifier = lm == 'l' && lm2 ? Format.lln :\n-                            lm == 'l'        ? Format.ln  :\n-                            lm == 'h' && lm2 ? Format.hhn :\n-                            lm == 'h'        ? Format.hn  :\n-                            lm == 'j'        ? Format.jn  :\n-                            lm == 'z'        ? Format.zn  :\n-                            lm == 't'        ? Format.tn  :\n-                                               Format.n;\n+            specifier = flags == Modifier.none ? Format.n   :\n+                        flags == Modifier.ll   ? Format.lln :\n+                        flags == Modifier.l    ? Format.ln  :\n+                        flags == Modifier.hh   ? Format.hhn :\n+                        flags == Modifier.h    ? Format.hn  :\n+                        flags == Modifier.j    ? Format.jn  :\n+                        flags == Modifier.z    ? Format.zn  :\n+                        flags == Modifier.t    ? Format.tn  :\n+                                                 Format.error;\n             break;\n \n-        case 'm':\n-            if (useGNUExts)\n-            {\n-                // https://www.gnu.org/software/libc/manual/html_node/Other-Output-Conversions.html\n-                specifier = Format.GNU_m;\n-                break;\n-            }\n-            goto default;\n+        case 'C':\n+            // POSIX.1-2017 X/Open System Interfaces (XSI)\n+            // %C format is equivalent to %lc\n+            specifier = flags == Modifier.none ? Format.lc :\n+                                                 Format.error;\n+            break;\n+\n+        case 'S':\n+            // POSIX.1-2017 X/Open System Interfaces (XSI)\n+            // %S format is equivalent to %ls\n+            specifier = flags == Modifier.none ? Format.ls :\n+                                                 Format.error;\n+            break;\n \n         default:\n             specifier = Format.error;\n@@ -1126,10 +1235,13 @@ unittest\n      assert(idx == 2);\n \n      idx = 0;\n-     Format g = parsePrintfFormatSpecifier(\"%a\", idx, widthStar, precisionStar);\n-     assert(g == Format.g || g == Format.GNU_a);\n+     assert(parsePrintfFormatSpecifier(\"%a\", idx, widthStar, precisionStar) == Format.g);\n      assert(idx == 2);\n \n+     idx = 0;\n+     assert(parsePrintfFormatSpecifier(\"%La\", idx, widthStar, precisionStar) == Format.Lg);\n+     assert(idx == 3);\n+\n      idx = 0;\n      assert(parsePrintfFormatSpecifier(\"%A\", idx, widthStar, precisionStar) == Format.g);\n      assert(idx == 2);\n@@ -1296,8 +1408,7 @@ unittest\n     assert(idx == 2);\n \n     idx = 0;\n-    g = parseScanfFormatSpecifier(\"%a\", idx, asterisk);\n-    assert(g == Format.g || g == Format.GNU_a);\n+    assert(parseScanfFormatSpecifier(\"%a\", idx, asterisk) == Format.g);\n     assert(idx == 2);\n \n     idx = 0;\n@@ -1322,15 +1433,25 @@ unittest\n \n     // scansets\n     idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%[a-zA-Z]s\", idx, asterisk) == Format.s);\n-    assert(idx == 10);\n+    assert(parseScanfFormatSpecifier(\"%[a-zA-Z]\", idx, asterisk) == Format.s);\n+    assert(idx == 9);\n     assert(!asterisk);\n \n     idx = 0;\n-    assert(parseScanfFormatSpecifier(\"%*25[a-z]hhd\", idx, asterisk) == Format.hhd);\n-    assert(idx == 12);\n+    assert(parseScanfFormatSpecifier(\"%*25l[a-z]\", idx, asterisk) == Format.ls);\n+    assert(idx == 10);\n     assert(asterisk);\n \n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%[]]\", idx, asterisk) == Format.s);\n+    assert(idx == 4);\n+    assert(!asterisk);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%[^]]\", idx, asterisk) == Format.s);\n+    assert(idx == 5);\n+    assert(!asterisk);\n+\n     // Too short formats\n     foreach (s; [\"%\", \"% \", \"%#\", \"%0\", \"%*\", \"%1\", \"%19\",\n                  \"%j\", \"%z\", \"%t\", \"%l\", \"%h\", \"%ll\", \"%hh\", \"%K\"])\n@@ -1354,11 +1475,108 @@ unittest\n     }\n \n     // Invalid scansets\n-    foreach (s; [\"%[]\", \"%[s\", \"%[0-9lld\", \"%[\", \"%[a-z]\"])\n+    foreach (s; [\"%[]\", \"%[^\", \"%[^]\", \"%[s\", \"%[0-9lld\", \"%[\", \"%l[^]\"])\n+    {\n+        idx = 0;\n+        assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n+        assert(idx == s.length);\n+    }\n+\n+    // Posix extensions\n+    foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n+                 \"%m\", \"%ma\", \"%md\", \"%ml\", \"%mm\", \"%mlb\", \"%mlj\", \"%mlr\", \"%mlz\",\n+                 \"%LC\", \"%lC\", \"%llC\", \"%jC\", \"%tC\", \"%hC\", \"%hhC\", \"%zC\",\n+                 \"%LS\", \"%lS\", \"%llS\", \"%jS\", \"%tS\", \"%hS\", \"%hhS\", \"%zS\"])\n     {\n         idx = 0;\n         assert(parseScanfFormatSpecifier(s, idx, asterisk) == Format.error);\n         assert(idx == s.length);\n     }\n \n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%mc\", idx, asterisk) == Format.POSIX_ms);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%ms\", idx, asterisk) == Format.POSIX_ms);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%m[0-9]\", idx, asterisk) == Format.POSIX_ms);\n+    assert(idx == 7);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%mlc\", idx, asterisk) == Format.POSIX_mls);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%mls\", idx, asterisk) == Format.POSIX_mls);\n+    assert(idx == 4);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%ml[^0-9]\", idx, asterisk) == Format.POSIX_mls);\n+    assert(idx == 9);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%mC\", idx, asterisk) == Format.POSIX_mls);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%mS\", idx, asterisk) == Format.POSIX_mls);\n+    assert(idx == 3);\n+\n+    idx = 0;\n+    assert(parsePrintfFormatSpecifier(\"%C\", idx, widthStar, precisionStar) == Format.lc);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%C\", idx, asterisk) == Format.lc);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parsePrintfFormatSpecifier(\"%S\", idx, widthStar, precisionStar) == Format.ls);\n+    assert(idx == 2);\n+\n+    idx = 0;\n+    assert(parseScanfFormatSpecifier(\"%S\", idx, asterisk) == Format.ls);\n+    assert(idx == 2);\n+\n+    // GNU extensions: explicitly toggle ISO/GNU flag.\n+    // ISO printf()\n+    bool useGNUExts = false;\n+    {\n+        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n+                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n+        {\n+            idx = 0;\n+            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n+            assert(idx == s.length);\n+        }\n+        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n+        {\n+            idx = 0;\n+            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n+            assert(idx == 2);\n+        }\n+    }\n+\n+    // GNU printf()\n+    useGNUExts = true;\n+    {\n+        foreach (s; [\"%jm\", \"%zm\", \"%tm\", \"%Lm\", \"%hm\", \"%hhm\", \"%lm\", \"%llm\",\n+                     \"%#m\", \"%+m\", \"%-m\", \"% m\", \"%0m\"])\n+        {\n+            idx = 0;\n+            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.error);\n+            assert(idx == s.length);\n+        }\n+\n+        // valid cases, all parsed as `%m`\n+        foreach (s; [\"%m\", \"%md\", \"%mz\", \"%mc\", \"%mm\", \"%msyz\", \"%ml\", \"%mlz\", \"%mlc\", \"%mlm\"])\n+        {\n+            idx = 0;\n+            assert(parsePrintfFormatSpecifier(s, idx, widthStar, precisionStar, useGNUExts) == Format.GNU_m);\n+            assert(idx == 2);\n+        }\n+    }\n }"}, {"sha": "1a26eaa434b0b0cd99afa515325727982584aa2f", "filename": "gcc/d/dmd/clone.d", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fclone.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fclone.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fclone.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1121,6 +1121,10 @@ private DtorDeclaration buildExternDDtor(AggregateDeclaration ad, Scope* sc)\n     if (!dtor)\n         return null;\n \n+    // Don't try to call `@disable`d dtors\n+    if (dtor.storage_class & STC.disable)\n+        return null;\n+\n     // Generate shim only when ABI incompatible on target platform\n     if (ad.classKind != ClassKind.cpp || !target.cpp.wrapDtorInExternD)\n         return dtor;"}, {"sha": "f4e44e812c8f92b8eb578ed813203c2f0878db3f", "filename": "gcc/d/dmd/constfold.d", "status": "modified", "additions": 20, "deletions": 103, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fconstfold.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fconstfold.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fconstfold.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -234,99 +234,9 @@ UnionExp Add(const ref Loc loc, Type type, Expression e1, Expression e2)\n \n UnionExp Min(const ref Loc loc, Type type, Expression e1, Expression e2)\n {\n-    UnionExp ue = void;\n-    if (type.isreal())\n-    {\n-        emplaceExp!(RealExp)(&ue, loc, e1.toReal() - e2.toReal(), type);\n-    }\n-    else if (type.isimaginary())\n-    {\n-        emplaceExp!(RealExp)(&ue, loc, e1.toImaginary() - e2.toImaginary(), type);\n-    }\n-    else if (type.iscomplex())\n-    {\n-        // This rigamarole is necessary so that -0.0 doesn't get\n-        // converted to +0.0 by doing an extraneous add with +0.0\n-        auto c1 = complex_t(CTFloat.zero);\n-        real_t r1 = CTFloat.zero;\n-        real_t i1 = CTFloat.zero;\n-        auto c2 = complex_t(CTFloat.zero);\n-        real_t r2 = CTFloat.zero;\n-        real_t i2 = CTFloat.zero;\n-        auto v = complex_t(CTFloat.zero);\n-        int x;\n-        if (e1.type.isreal())\n-        {\n-            r1 = e1.toReal();\n-            x = 0;\n-        }\n-        else if (e1.type.isimaginary())\n-        {\n-            i1 = e1.toImaginary();\n-            x = 3;\n-        }\n-        else\n-        {\n-            c1 = e1.toComplex();\n-            x = 6;\n-        }\n-        if (e2.type.isreal())\n-        {\n-            r2 = e2.toReal();\n-        }\n-        else if (e2.type.isimaginary())\n-        {\n-            i2 = e2.toImaginary();\n-            x += 1;\n-        }\n-        else\n-        {\n-            c2 = e2.toComplex();\n-            x += 2;\n-        }\n-        switch (x)\n-        {\n-        case 0 + 0:\n-            v = complex_t(r1 - r2);\n-            break;\n-        case 0 + 1:\n-            v = complex_t(r1, -i2);\n-            break;\n-        case 0 + 2:\n-            v = complex_t(r1 - creall(c2), -cimagl(c2));\n-            break;\n-        case 3 + 0:\n-            v = complex_t(-r2, i1);\n-            break;\n-        case 3 + 1:\n-            v = complex_t(CTFloat.zero, i1 - i2);\n-            break;\n-        case 3 + 2:\n-            v = complex_t(-creall(c2), i1 - cimagl(c2));\n-            break;\n-        case 6 + 0:\n-            v = complex_t(creall(c1) - r2, cimagl(c1));\n-            break;\n-        case 6 + 1:\n-            v = complex_t(creall(c1), cimagl(c1) - i2);\n-            break;\n-        case 6 + 2:\n-            v = c1 - c2;\n-            break;\n-        default:\n-            assert(0);\n-        }\n-        emplaceExp!(ComplexExp)(&ue, loc, v, type);\n-    }\n-    else if (SymOffExp soe = e1.isSymOffExp())\n-    {\n-        emplaceExp!(SymOffExp)(&ue, loc, soe.var, soe.offset - e2.toInteger());\n-        ue.exp().type = type;\n-    }\n-    else\n-    {\n-        emplaceExp!(IntegerExp)(&ue, loc, e1.toInteger() - e2.toInteger(), type);\n-    }\n+    // Compute e1-e2 as e1+(-e2)\n+    UnionExp neg = Neg(e2.type, e2);\n+    UnionExp ue = Add(loc, type, e1, neg.exp());\n     return ue;\n }\n \n@@ -1213,6 +1123,10 @@ UnionExp ArrayLength(Type type, Expression e1)\n         Expression e = (cast(TypeSArray)e1.type.toBasetype()).dim;\n         emplaceExp!(UnionExp)(&ue, e);\n     }\n+    else if (e1.isNullExp())\n+    {\n+        emplaceExp!(IntegerExp)(&ue, loc, 0, type);\n+    }\n     else\n         cantExp(ue);\n     return ue;\n@@ -1505,17 +1419,11 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n     Type t2 = e2.type.toBasetype();\n     //printf(\"Cat(e1 = %s, e2 = %s)\\n\", e1.toChars(), e2.toChars());\n     //printf(\"\\tt1 = %s, t2 = %s, type = %s\\n\", t1.toChars(), t2.toChars(), type.toChars());\n-    if (e1.op == EXP.null_ && (e2.op == EXP.int64 || e2.op == EXP.structLiteral))\n-    {\n-        e = e2;\n-        t = t1;\n-        goto L2;\n-    }\n-    else if ((e1.op == EXP.int64 || e1.op == EXP.structLiteral) && e2.op == EXP.null_)\n+\n+    /* e is the non-null operand, t is the type of the null operand\n+     */\n+    UnionExp catNull(Expression e, Type t)\n     {\n-        e = e1;\n-        t = t2;\n-    L2:\n         Type tn = e.type.toBasetype();\n         if (tn.ty.isSomeChar)\n         {\n@@ -1545,6 +1453,15 @@ UnionExp Cat(const ref Loc loc, Type type, Expression e1, Expression e2)\n         assert(ue.exp().type);\n         return ue;\n     }\n+\n+    if (e1.op == EXP.null_ && (e2.op == EXP.int64 || e2.op == EXP.structLiteral))\n+    {\n+        return catNull(e2, t1);\n+    }\n+    else if ((e1.op == EXP.int64 || e1.op == EXP.structLiteral) && e2.op == EXP.null_)\n+    {\n+        return catNull(e1, t2);\n+    }\n     else if (e1.op == EXP.null_ && e2.op == EXP.null_)\n     {\n         if (type == e1.type)"}, {"sha": "2679a63245c7546210e51898957baecebd81b462", "filename": "gcc/d/dmd/cparse.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fcparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fcparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fcparse.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1675,7 +1675,7 @@ final class CParser(AST) : Parser!AST\n             auto stags = applySpecifier(stag, specifier);\n             symbols.push(stags);\n \n-            if (tt.tok == TOK.enum_)\n+            if (0 && tt.tok == TOK.enum_)    // C11 proscribes enums with no members, but we allow it\n             {\n                 if (!tt.members)\n                     error(tt.loc, \"`enum %s` has no members\", stag.toChars());"}, {"sha": "afd19f3d0f5651ae529cfdec3a2e7dcd0ee9ba00", "filename": "gcc/d/dmd/dcast.d", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdcast.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdcast.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1106,9 +1106,14 @@ MATCH implicitConvTo(Expression e, Type t)\n \n     MATCH visitCond(CondExp e)\n     {\n-        auto result = visit(e);\n-        if (result != MATCH.nomatch)\n-            return result;\n+        e.econd = e.econd.optimize(WANTvalue);\n+        const opt = e.econd.toBool();\n+        if (opt.isPresent())\n+        {\n+            auto result = visit(e);\n+            if (result != MATCH.nomatch)\n+                return result;\n+        }\n \n         MATCH m1 = e.e1.implicitConvTo(t);\n         MATCH m2 = e.e2.implicitConvTo(t);\n@@ -2942,6 +2947,9 @@ Lagain:\n \n         t1 = Type.basic[ty1];\n         t2 = Type.basic[ty2];\n+\n+        if (!(t1 && t2))\n+            return null;\n         e1 = e1.castTo(sc, t1);\n         e2 = e2.castTo(sc, t2);\n         return Lret(Type.basic[ty]);"}, {"sha": "c8f6c2aab36147d600510fc42276355378047db8", "filename": "gcc/d/dmd/declaration.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdeclaration.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdeclaration.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdeclaration.h?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -684,6 +684,7 @@ class FuncDeclaration : public Declaration\n     const char *kind() const override;\n     bool isUnique();\n     bool needsClosure();\n+    bool checkClosure();\n     bool hasNestedFrameRefs();\n     ParameterList getParameterList();\n "}, {"sha": "890c3b6fef21780cc09de1c5c3d2c505a8c39fdd", "filename": "gcc/d/dmd/dinterpret.d", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdinterpret.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdinterpret.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdinterpret.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2352,19 +2352,24 @@ public:\n                 if (ExpInitializer ie = v._init.isExpInitializer())\n                 {\n                     result = interpretRegion(ie.exp, istate, goal);\n+                    return;\n                 }\n                 else if (v._init.isVoidInitializer())\n                 {\n                     result = voidInitLiteral(v.type, v).copy();\n                     // There is no AssignExp for void initializers,\n                     // so set it here.\n                     setValue(v, result);\n+                    return;\n                 }\n-                else\n+                else if (v._init.isArrayInitializer())\n                 {\n-                    e.error(\"declaration `%s` is not yet implemented in CTFE\", e.toChars());\n-                    result = CTFEExp.cantexp;\n+                    result = v._init.initializerToExpression(v.type);\n+                    if (result !is null)\n+                        return;\n                 }\n+                e.error(\"declaration `%s` is not yet implemented in CTFE\", e.toChars());\n+                result = CTFEExp.cantexp;\n             }\n             else if (v.type.size() == 0)\n             {"}, {"sha": "5e802dab8cc3fa42ef382bccf9d0b2dcf8ba6d55", "filename": "gcc/d/dmd/dmodule.d", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdmodule.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdmodule.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -619,7 +619,7 @@ extern (C++) final class Module : Package\n         else\n         {\n             // if module is not named 'package' but we're trying to read 'package.d', we're looking for a package module\n-            bool isPackageMod = (strcmp(toChars(), \"package\") != 0) && (strcmp(srcfile.name(), package_d) == 0 || (strcmp(srcfile.name(), package_di) == 0));\n+            bool isPackageMod = (strcmp(toChars(), \"package\") != 0) && isPackageFileName(srcfile);\n             if (isPackageMod)\n                 .error(loc, \"importing package '%s' requires a 'package.d' file which cannot be found in '%s'\", toChars(), srcfile.toChars());\n             else\n@@ -824,8 +824,7 @@ extern (C++) final class Module : Package\n \n         const(char)* srcname = srcfile.toChars();\n         //printf(\"Module::parse(srcname = '%s')\\n\", srcname);\n-        isPackageFile = (strcmp(srcfile.name(), package_d) == 0 ||\n-                         strcmp(srcfile.name(), package_di) == 0);\n+        isPackageFile = isPackageFileName(srcfile);\n         const(char)[] buf = cast(const(char)[]) this.src;\n \n         bool needsReencoding = true;\n@@ -1032,8 +1031,7 @@ extern (C++) final class Module : Package\n             }\n             assert(dst);\n             Module m = ppack ? ppack.isModule() : null;\n-            if (m && (strcmp(m.srcfile.name(), package_d) != 0 &&\n-                      strcmp(m.srcfile.name(), package_di) != 0))\n+            if (m && !isPackageFileName(m.srcfile))\n             {\n                 .error(md.loc, \"package name '%s' conflicts with usage as a module name in file %s\", ppack.toPrettyChars(), m.srcfile.toChars());\n             }"}, {"sha": "c940ff06c67b1ad7986db2ff7b213f9c28861ef7", "filename": "gcc/d/dmd/dsymbol.d", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdsymbol.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdsymbol.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2441,6 +2441,15 @@ Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n     auto sd = s.isScopeDsymbol(); // new declaration\n     auto sd2 = s2.isScopeDsymbol(); // existing declaration\n \n+    static if (log) void print(EnumDeclaration sd)\n+    {\n+        printf(\"members: %p\\n\", sd.members);\n+        printf(\"symtab: %p\\n\", sd.symtab);\n+        printf(\"endlinnum: %d\\n\", sd.endlinnum);\n+        printf(\"type: %s\\n\", sd.type.toChars());\n+        printf(\"memtype: %s\\n\", sd.memtype.toChars());\n+    }\n+\n     if (!sd2)\n     {\n         /* Look in tag table\n@@ -2473,6 +2482,23 @@ Dsymbol handleTagSymbols(ref Scope sc, Dsymbol s, Dsymbol s2, ScopeDsymbol sds)\n         {\n             sd2.members = sd.members; // transfer definition to sd2\n             sd.members = null;\n+            if (auto ed2 = sd2.isEnumDeclaration())\n+            {\n+                auto ed = sd.isEnumDeclaration();\n+                if (ed.memtype != ed2.memtype)\n+                    return null;        // conflict\n+\n+                // transfer ed's members to sd2\n+                ed2.members.foreachDsymbol( (s)\n+                {\n+                    if (auto em = s.isEnumMember())\n+                        em.ed = ed2;\n+                });\n+\n+                ed2.type = ed.type;\n+                ed2.memtype = ed.memtype;\n+                ed2.added = false;\n+            }\n             return sd2;\n         }\n         else"}, {"sha": "7f57cbe12cac1d8926d64545f156426dceae34de", "filename": "gcc/d/dmd/dsymbolsem.d", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdsymbolsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbolsem.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2023,7 +2023,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n     override void visit(EnumDeclaration ed)\n     {\n         //printf(\"EnumDeclaration::semantic(sd = %p, '%s') %s\\n\", sc.scopesym, sc.scopesym.toChars(), ed.toChars());\n-        //printf(\"EnumDeclaration::semantic() %p %s\\n\", this, ed.toChars());\n+        //printf(\"EnumDeclaration::semantic() %p %s\\n\", ed, ed.toChars());\n         if (ed.semanticRun >= PASS.semanticdone)\n             return; // semantic() already completed\n         if (ed.semanticRun == PASS.semantic)\n@@ -4442,7 +4442,10 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n              invd.semanticRun < PASS.semantic &&\n              !ad.isUnionDeclaration()           // users are on their own with union fields\n            )\n+        {\n+            invd.fixupInvariantIdent(ad.invs.length);\n             ad.invs.push(invd);\n+        }\n         if (!invd.type)\n             invd.type = new TypeFunction(ParameterList(), Type.tvoid, LINK.d, invd.storage_class);\n \n@@ -5713,6 +5716,7 @@ private extern(C++) final class DsymbolSemanticVisitor : Visitor\n  */\n void addEnumMembers(EnumDeclaration ed, Scope* sc, ScopeDsymbol sds)\n {\n+    //printf(\"addEnumMembers(ed: %p)\\n\", ed);\n     if (ed.added)\n         return;\n     ed.added = true;\n@@ -5736,6 +5740,7 @@ void addEnumMembers(EnumDeclaration ed, Scope* sc, ScopeDsymbol sds)\n             em.ed = ed;\n             if (isCEnum)\n             {\n+                //printf(\"adding EnumMember %s to %p\\n\", em.toChars(), ed);\n                 em.addMember(sc, ed);   // add em to ed's symbol table\n                 em.addMember(sc, sds);  // add em to symbol table that ed is in\n                 em.parent = ed; // restore it after previous addMember() changed it"}, {"sha": "02f12e42570c5b00e43b2574a5bf14e55c0d728e", "filename": "gcc/d/dmd/dtemplate.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdtemplate.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fdtemplate.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdtemplate.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -7323,7 +7323,7 @@ extern (C++) class TemplateInstance : ScopeDsymbol\n                         errors = true;\n                     }\n                 L1:\n-                    //printf(\"\\tnested inside %s\\n\", enclosing.toChars());\n+                    //printf(\"\\tnested inside %s as it references %s\\n\", enclosing.toChars(), sa.toChars());\n                     nested |= 1;\n                 }\n             }"}, {"sha": "c29d4999f26f2418238c0b781dcc6eab4a24119d", "filename": "gcc/d/dmd/entity.d", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fentity.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fentity.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fentity.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -17,18 +17,27 @@ import core.stdc.ctype;\n \n nothrow:\n \n-public int HtmlNamedEntity(const(char)* p, size_t length)\n+/**********************************\n+ * See if `name` is an HTML Named Entity\n+ * Params:\n+ *      name = name of the entity\n+ * Returns:\n+ *      code point corresponding to the named entity\n+ *      ~0 for not recognized as a named entity\n+ */\n+public uint HtmlNamedEntity(scope const char[] name) pure @nogc @safe\n {\n-    int tableIndex = tolower(*p) - 'a';\n-    if (tableIndex >= 0 && tableIndex < 26)\n+    const firstC = tolower(name[0]);\n+    if (firstC >= 'a' && firstC <= 'z')\n     {\n-        foreach (entity; namesTable[tableIndex])\n+        // Linear search (use hash table instead?)\n+        foreach (entity; namesTable[firstC - 'a'])\n         {\n-            if (entity.name == p[0 .. length])\n+            if (entity.name == name)\n                 return entity.value;\n         }\n     }\n-    return -1;\n+    return ~0;\n }\n \n private:"}, {"sha": "fb5e092d25bb7e1ba0019638e7f04742c3dd00da", "filename": "gcc/d/dmd/escape.d", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fescape.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fescape.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fescape.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -351,7 +351,7 @@ bool checkParamArgumentEscape(Scope* sc, FuncDeclaration fdc, Parameter par, STC\n         {\n             unsafeAssign!\"scope variable\"(v);\n         }\n-        else if (v.storage_class & STC.variadic && p == sc.func)\n+        else if (v.isTypesafeVariadicParameter && p == sc.func)\n         {\n             Type tb = v.type.toBasetype();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n@@ -649,7 +649,8 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n         Dsymbol p = v.toParent2();\n \n         if (va && !vaIsRef && !va.isScope() && !v.isScope() &&\n-            (va.storage_class & v.storage_class & (STC.maybescope | STC.variadic)) == STC.maybescope &&\n+            !v.isTypesafeVariadicParameter && !va.isTypesafeVariadicParameter &&\n+            (va.storage_class & v.storage_class & STC.maybescope) &&\n             p == fd)\n         {\n             /* Add v to va's list of dependencies\n@@ -663,7 +664,8 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n             !(v.storage_class & STC.return_) &&\n             v.isParameter() &&\n             fd.flags & FUNCFLAG.returnInprocess &&\n-            p == fd)\n+            p == fd &&\n+            !v.isTypesafeVariadicParameter)\n         {\n             if (log) printf(\"inferring 'return' for parameter %s in function %s\\n\", v.toChars(), fd.toChars());\n             inferReturn(fd, v, /*returnScope:*/ true); // infer addition of 'return' to make `return scope`\n@@ -735,7 +737,7 @@ bool checkAssignEscape(Scope* sc, Expression e, bool gag, bool byRef)\n             }\n             result |= sc.setUnsafeDIP1000(gag, ae.loc, \"scope variable `%s` assigned to non-scope `%s`\", v, e1);\n         }\n-        else if (v.storage_class & STC.variadic && p == fd)\n+        else if (v.isTypesafeVariadicParameter && p == fd)\n         {\n             Type tb = v.type.toBasetype();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n@@ -1022,7 +1024,7 @@ bool checkNewEscape(Scope* sc, Expression e, bool gag)\n                 continue;\n             }\n         }\n-        else if (v.storage_class & STC.variadic && p == sc.func)\n+        else if (v.isTypesafeVariadicParameter && p == sc.func)\n         {\n             Type tb = v.type.toBasetype();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n@@ -1194,7 +1196,8 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n             v.isParameter() &&\n             !v.doNotInferReturn &&\n             sc.func.flags & FUNCFLAG.returnInprocess &&\n-            p == sc.func)\n+            p == sc.func &&\n+            !v.isTypesafeVariadicParameter)\n         {\n             inferReturn(sc.func, v, /*returnScope:*/ true); // infer addition of 'return'\n             continue;\n@@ -1250,7 +1253,7 @@ private bool checkReturnEscapeImpl(Scope* sc, Expression e, bool refs, bool gag)\n                 }\n             }\n         }\n-        else if (v.storage_class & STC.variadic && p == sc.func)\n+        else if (v.isTypesafeVariadicParameter && p == sc.func)\n         {\n             Type tb = v.type.toBasetype();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n@@ -1627,7 +1630,7 @@ void escapeByValue(Expression e, EscapeByResults* er, bool live = false, bool re\n             {\n                 if (tb.ty == Tsarray)\n                     return;\n-                if (v.storage_class & STC.variadic)\n+                if (v.isTypesafeVariadicParameter)\n                 {\n                     er.byvalue.push(v);\n                     return;\n@@ -1943,7 +1946,7 @@ void escapeByRef(Expression e, EscapeByResults* er, bool live = false, bool retR\n             VarDeclaration v = ve.var.isVarDeclaration();\n             if (tb.ty == Tarray || tb.ty == Tsarray)\n             {\n-                if (v && v.storage_class & STC.variadic)\n+                if (v && v.isTypesafeVariadicParameter)\n                 {\n                     er.pushRef(v, retRefTransition);\n                     return;\n@@ -2586,3 +2589,15 @@ private bool checkScopeVarAddr(VarDeclaration v, Expression e, Scope* sc, bool g\n     return sc.setUnsafeDIP1000(gag, e.loc,\n         \"cannot take address of `scope` variable `%s` since `scope` applies to first indirection only\", v);\n }\n+\n+/****************************\n+ * Determine if `v` is a typesafe variadic parameter.\n+ * Params:\n+ *      v = variable to check\n+ * Returns:\n+ *      true if `v` is a variadic parameter\n+ */\n+bool isTypesafeVariadicParameter(VarDeclaration v)\n+{\n+    return !!(v.storage_class & STC.variadic);\n+}"}, {"sha": "30baabdad52855d86931db7f2e133b4b9889866e", "filename": "gcc/d/dmd/expressionsem.d", "status": "modified", "additions": 76, "deletions": 37, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fexpressionsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpressionsem.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -3463,8 +3463,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         if (!exp.arguments && exp.newtype.isTypeSArray())\n         {\n             auto ts = exp.newtype.isTypeSArray();\n-            edim = ts.dim;\n-            exp.newtype = ts.next;\n+            // check `new Value[Key]`\n+            ts.dim = ts.dim.expressionSemantic(sc);\n+            if (ts.dim.op == EXP.type)\n+            {\n+                exp.newtype = new TypeAArray(ts.next, ts.dim.isTypeExp().type);\n+            }\n+            else\n+            {\n+                edim = ts.dim;\n+                exp.newtype = ts.next;\n+            }\n         }\n \n         ClassDeclaration cdthis = null;\n@@ -3518,18 +3527,7 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             return setError();\n         }\n-        //https://issues.dlang.org/show_bug.cgi?id=20547\n-        //exp.arguments are the \"parameters\" to [], not to a real function\n-        //so the errors that come from preFunctionParameters are misleading\n-        if (originalNewtype.ty == Tsarray)\n-        {\n-            if (preFunctionParameters(sc, exp.arguments, false))\n-            {\n-                exp.error(\"cannot create a `%s` with `new`\", originalNewtype.toChars());\n-                return setError();\n-            }\n-        }\n-        else if (preFunctionParameters(sc, exp.arguments))\n+        if (preFunctionParameters(sc, exp.arguments))\n         {\n             return setError();\n         }\n@@ -3885,6 +3883,15 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n \n             exp.type = exp.type.pointerTo();\n         }\n+        else if (tb.ty == Taarray)\n+        {\n+            // e.g. `new Alias(args)`\n+            if (nargs)\n+            {\n+                exp.error(\"`new` cannot take arguments for an associative array\");\n+                return setError();\n+            }\n+        }\n         else\n         {\n             exp.error(\"cannot create a `%s` with `new`\", exp.type.toChars());\n@@ -5019,7 +5026,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                         sc.func.kind(), sc.func.toPrettyChars(), p, exp.e1.toChars());\n                     err = true;\n                 }\n-                if (tf.trust <= TRUST.system && sc.setUnsafe())\n+                if (tf.trust <= TRUST.system && sc.setUnsafe(true, exp.loc,\n+                    \"`@safe` function `%s` cannot call `@system` `%s`\", sc.func, exp.e1))\n                 {\n                     exp.error(\"`@safe` %s `%s` cannot call `@system` %s `%s`\",\n                         sc.func.kind(), sc.func.toPrettyChars(), p, exp.e1.toChars());\n@@ -7588,11 +7596,20 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         }\n \n         // Check for unsafe casts\n-        if (!isSafeCast(ex, t1b, tob) &&\n-            (!sc.func && sc.stc & STC.safe || sc.setUnsafe()))\n+        if (!isSafeCast(ex, t1b, tob))\n         {\n-            exp.error(\"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type.toChars(), exp.to.toChars());\n-            return setError();\n+            // This is an ad-hoc fix for https://issues.dlang.org/show_bug.cgi?id=19646\n+            // Should be replaced by a more general @system variables implementation\n+            if (!sc.func && sc.stc & STC.safe)\n+            {\n+                exp.error(\"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type.toChars(), exp.to.toChars());\n+                return setError();\n+            }\n+\n+            if (sc.setUnsafe(false, exp.loc, \"cast from `%s` to `%s` not allowed in safe code\", exp.e1.type, exp.to))\n+            {\n+                return setError();\n+            }\n         }\n \n         // `object.__ArrayCast` is a rewrite of an old runtime hook `_d_arraycast`. `_d_arraycast` was not built\n@@ -8900,6 +8917,15 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n             if ((t1.ty != Tstruct && t1.ty != Tclass && e2x.checkValue()) ||\n                 e2x.checkSharedAccess(sc))\n                 return setError();\n+\n+            if (e2x.type.isTypeNoreturn() && !e2x.isAssertExp() && !e2x.isThrowExp() && !e2x.isCallExp())\n+            {\n+                auto msg = new StringExp(e2x.loc, \"Accessed expression of type `noreturn`\");\n+                msg.type = Type.tstring;\n+                e2x = new AssertExp(e2x.loc, IntegerExp.literal!0, msg);\n+                e2x.type = Type.tnoreturn;\n+                return setResult(e2x);\n+            }\n             exp.e2 = e2x;\n         }\n \n@@ -9896,9 +9922,11 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                 ae.e2.type.nextOf &&\n                 ae.e1.type.nextOf.mutableOf.equals(ae.e2.type.nextOf.mutableOf);\n \n+            /* Unlike isArrayCtor above, lower all Rvalues. If the RHS is a literal,\n+             * then we do want to make a temporary for it and call its destructor.\n+             */\n             const isArraySetCtor =\n                 (ae.e1.isSliceExp || ae.e1.type.ty == Tsarray) &&\n-                ae.e2.isLvalue &&\n                 (ae.e2.type.ty == Tstruct || ae.e2.type.ty == Tsarray) &&\n                 ae.e1.type.nextOf &&\n                 ae.e1.type.nextOf.equivalent(ae.e2.type);\n@@ -10302,6 +10330,8 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n                     // `__appendtmp*` will be destroyed together with the array `exp.e1`.\n                     auto vd = eValue2.isDeclarationExp().declaration.isVarDeclaration();\n                     vd.storage_class |= STC.nodtor;\n+                    // Be more explicit that this \"declaration\" is local to the expression\n+                    vd.storage_class |= STC.exptemp;\n                 }\n \n                 auto ale = new ArrayLengthExp(exp.loc, value1);\n@@ -11870,6 +11900,17 @@ private extern (C++) final class ExpressionSemanticVisitor : Visitor\n         {\n             //printf(\"Lowering to __equals %s %s\\n\", exp.e1.toChars(), exp.e2.toChars());\n \n+            // https://issues.dlang.org/show_bug.cgi?id=22390\n+            // Equality comparison between array of noreturns simply lowers to length equality comparison\n+            if (t1.nextOf.isTypeNoreturn() && t2.nextOf.isTypeNoreturn())\n+            {\n+                Expression exp_l1 = new DotIdExp(exp.e1.loc, exp.e1, Id.length);\n+                Expression exp_l2 = new DotIdExp(exp.e2.loc, exp.e2, Id.length);\n+                auto e = new EqualExp(EXP.equal, exp.loc, exp_l1, exp_l2);\n+                result = e.expressionSemantic(sc);\n+                return;\n+            }\n+\n             if (!verifyHookExist(exp.loc, *sc, Id.__equals, \"equal checks on arrays\"))\n                 return setError();\n \n@@ -12638,7 +12679,7 @@ Expression semanticY(DotIdExp exp, Scope* sc, int flag)\n                     e = new CommaExp(exp.loc, eleft, e);\n                     e.type = Type.tvoid; // ambiguous type?\n                 }\n-                return e;\n+                return e.expressionSemantic(sc);\n             }\n             if (auto o = s.isOverloadSet())\n             {\n@@ -13131,26 +13172,24 @@ bool checkSharedAccess(Expression e, Scope* sc, bool returnRef = false)\n bool checkAddressVar(Scope* sc, Expression exp, VarDeclaration v)\n {\n     //printf(\"checkAddressVar(exp: %s, v: %s)\\n\", exp.toChars(), v.toChars());\n-    if (v)\n+    if (v is null)\n+        return true;\n+\n+    if (!v.canTakeAddressOf())\n+    {\n+        exp.error(\"cannot take address of `%s`\", exp.toChars());\n+        return false;\n+    }\n+    if (sc.func && !sc.intypeof && !v.isDataseg())\n     {\n-        if (!v.canTakeAddressOf())\n+        v.storage_class &= ~STC.maybescope;\n+        v.doNotInferScope = true;\n+        if (global.params.useDIP1000 != FeatureState.enabled &&\n+            !(v.storage_class & STC.temp) &&\n+            sc.setUnsafe(false, exp.loc, \"cannot take address of local `%s` in `@safe` function `%s`\", v, sc.func))\n         {\n-            exp.error(\"cannot take address of `%s`\", exp.toChars());\n             return false;\n         }\n-        if (sc.func && !sc.intypeof && !v.isDataseg())\n-        {\n-            const(char)* p = v.isParameter() ? \"parameter\" : \"local\";\n-            v.storage_class &= ~STC.maybescope;\n-            v.doNotInferScope = true;\n-            if (global.params.useDIP1000 != FeatureState.enabled &&\n-                !(v.storage_class & STC.temp) &&\n-                sc.setUnsafe())\n-            {\n-                exp.error(\"cannot take address of %s `%s` in `@safe` function `%s`\", p, v.toChars(), sc.func.toChars());\n-                return false;\n-            }\n-        }\n     }\n     return true;\n }"}, {"sha": "0ea73036a78ab93323be99d36d512a8279b17312", "filename": "gcc/d/dmd/file_manager.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ffile_manager.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ffile_manager.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffile_manager.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -20,6 +20,12 @@ import dmd.identifier;\n enum package_d  = \"package.\" ~ mars_ext;\n enum package_di = \"package.\" ~ hdr_ext;\n \n+/// Returns: whether a file with `name` is a special \"package.d\" module\n+bool isPackageFileName(scope FileName fileName) nothrow\n+{\n+    return FileName.equals(fileName.name, package_d) || FileName.equals(fileName.name, package_di);\n+}\n+\n final class FileManager\n {\n     private StringTable!(const(ubyte)[]) files;"}, {"sha": "7475cb4f9f59a1f1580f20ed6a8e8a5a34501e41", "filename": "gcc/d/dmd/func.d", "status": "modified", "additions": 46, "deletions": 16, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ffunc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ffunc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ffunc.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -867,6 +867,8 @@ extern (C++) class FuncDeclaration : Declaration\n             auto f = s.isFuncDeclaration();\n             if (!f)\n                 return 0;\n+            if (f.storage_class & STC.disable)\n+                return 0;\n             if (t.equals(f.type))\n             {\n                 fd = f;\n@@ -2048,9 +2050,11 @@ extern (C++) class FuncDeclaration : Declaration\n                     }\n                     if (!found)\n                     {\n-                        //printf(\"\\tadding sibling %s\\n\", fdthis.toPrettyChars());\n+                        //printf(\"\\tadding sibling %s to %s\\n\", fdthis.toPrettyChars(), toPrettyChars());\n                         if (!sc.intypeof && !(sc.flags & SCOPE.compile))\n+                        {\n                             siblingCallers.push(fdthis);\n+                        }\n                     }\n                 }\n \n@@ -2164,7 +2168,6 @@ extern (C++) class FuncDeclaration : Declaration\n         return false;\n \n     Lyes:\n-        //printf(\"\\tneeds closure\\n\");\n         return true;\n     }\n \n@@ -2176,14 +2179,21 @@ extern (C++) class FuncDeclaration : Declaration\n      * Returns:\n      *      true if any errors occur.\n      */\n-    extern (D) final bool checkClosure()\n+    extern (C++) final bool checkClosure()\n     {\n+        //printf(\"checkClosure() %s\\n\", toChars());\n         if (!needsClosure())\n             return false;\n \n         if (setGC())\n         {\n-            error(\"is `@nogc` yet allocates closures with the GC\");\n+            error(\"is `@nogc` yet allocates closure for `%s()` with the GC\", toChars());\n+            if (global.gag)     // need not report supplemental errors\n+                return true;\n+        }\n+        else if (global.params.betterC)\n+        {\n+            error(\"is `-betterC` yet allocates closure for `%s()` with the GC\", toChars());\n             if (global.gag)     // need not report supplemental errors\n                 return true;\n         }\n@@ -2216,7 +2226,7 @@ extern (C++) class FuncDeclaration : Declaration\n                                 break LcheckAncestorsOfANestedRef;\n                         }\n                         a.push(f);\n-                        .errorSupplemental(f.loc, \"%s closes over variable %s at %s\",\n+                        .errorSupplemental(f.loc, \"`%s` closes over variable `%s` at %s\",\n                             f.toPrettyChars(), v.toChars(), v.loc.toChars());\n                         break LcheckAncestorsOfANestedRef;\n                     }\n@@ -3293,7 +3303,8 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n                    td.kind(), td.parent.toPrettyChars(), td.ident.toChars(),\n                    tiargsBuf.peekChars(), fargsBuf.peekChars());\n \n-            printCandidates(loc, td, sc.isDeprecated());\n+            if (!global.gag || global.params.showGaggedErrors)\n+                printCandidates(loc, td, sc.isDeprecated());\n             return null;\n         }\n         /* This case used to happen when several ctors are mixed in an agregate.\n@@ -3331,7 +3342,8 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n         {\n             .error(loc, \"none of the overloads of `%s` are callable using a %sobject\",\n                    fd.ident.toChars(), thisBuf.peekChars());\n-            printCandidates(loc, fd, sc.isDeprecated());\n+            if (!global.gag || global.params.showGaggedErrors)\n+                printCandidates(loc, fd, sc.isDeprecated());\n             return null;\n         }\n \n@@ -3361,18 +3373,23 @@ FuncDeclaration resolveFuncCall(const ref Loc loc, Scope* sc, Dsymbol s,\n     {\n         .error(loc, \"none of the overloads of `%s` are callable using argument types `%s`\",\n                fd.toChars(), fargsBuf.peekChars());\n-        printCandidates(loc, fd, sc.isDeprecated());\n+        if (!global.gag || global.params.showGaggedErrors)\n+            printCandidates(loc, fd, sc.isDeprecated());\n         return null;\n     }\n \n     .error(loc, \"%s `%s%s%s` is not callable using argument types `%s`\",\n            fd.kind(), fd.toPrettyChars(), parametersTypeToChars(tf.parameterList),\n            tf.modToChars(), fargsBuf.peekChars());\n+\n     // re-resolve to check for supplemental message\n-    const(char)* failMessage;\n-    functionResolve(m, orig_s, loc, sc, tiargs, tthis, fargs, &failMessage);\n-    if (failMessage)\n-        errorSupplemental(loc, failMessage);\n+    if (!global.gag || global.params.showGaggedErrors)\n+    {\n+        const(char)* failMessage;\n+        functionResolve(m, orig_s, loc, sc, tiargs, tthis, fargs, &failMessage);\n+        if (failMessage)\n+            errorSupplemental(loc, failMessage);\n+    }\n     return null;\n }\n \n@@ -4220,6 +4237,7 @@ extern (C++) final class InvariantDeclaration : FuncDeclaration\n {\n     extern (D) this(const ref Loc loc, const ref Loc endloc, StorageClass stc, Identifier id, Statement fbody)\n     {\n+        // Make a unique invariant for now; we'll fix it up as we add it to the aggregate invariant list.\n         super(loc, endloc, id ? id : Identifier.generateId(\"__invariant\"), stc, null);\n         this.fbody = fbody;\n     }\n@@ -4256,6 +4274,15 @@ extern (C++) final class InvariantDeclaration : FuncDeclaration\n     {\n         v.visit(this);\n     }\n+\n+    extern (D) void fixupInvariantIdent(size_t offset)\n+    {\n+        OutBuffer idBuf;\n+        idBuf.writestring(\"__invariant\");\n+        idBuf.print(offset);\n+\n+        ident = Identifier.idPool(idBuf[]);\n+    }\n }\n \n \n@@ -4447,12 +4474,15 @@ void errorSupplementalInferredSafety(FuncDeclaration fd, int maxDepth, bool depr\n             errorFunc(s.loc, s.fmtStr,\n                 s.arg0 ? s.arg0.toChars() : \"\", s.arg1 ? s.arg1.toChars() : \"\", s.arg2 ? s.arg2.toChars() : \"\");\n         }\n-        else if (FuncDeclaration fd2 = cast(FuncDeclaration) s.arg0)\n+        else if (s.arg0.dyncast() == DYNCAST.dsymbol)\n         {\n-            if (maxDepth > 0)\n+            if (FuncDeclaration fd2 = (cast(Dsymbol) s.arg0).isFuncDeclaration())\n             {\n-                errorFunc(s.loc, \"which calls `%s`\", fd2.toPrettyChars());\n-                errorSupplementalInferredSafety(fd2, maxDepth - 1, deprecation);\n+                if (maxDepth > 0)\n+                {\n+                    errorFunc(s.loc, \"which calls `%s`\", fd2.toPrettyChars());\n+                    errorSupplementalInferredSafety(fd2, maxDepth - 1, deprecation);\n+                }\n             }\n         }\n     }"}, {"sha": "832c331c31411f6b8e3c8725dec46d90e55e47ce", "filename": "gcc/d/dmd/impcnvtab.d", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fimpcnvtab.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fimpcnvtab.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fimpcnvtab.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -64,6 +64,57 @@ enum ImpCnvTab impCnvTab = generateImpCnvTab();\n \n ImpCnvTab generateImpCnvTab()\n {\n+    TY[TMAX] typeTYs =\n+    [\n+        Tarray,\n+        Tsarray,\n+        Taarray,\n+        Tpointer,\n+        Treference,\n+        Tfunction,\n+        Tident,\n+        Tclass,\n+        Tstruct,\n+        Tenum,\n+        Tdelegate,\n+        Tnone,\n+        Tvoid,\n+        Tint8,\n+        Tuns8,\n+        Tint16,\n+        Tuns16,\n+        Tint32,\n+        Tuns32,\n+        Tint64,\n+        Tuns64,\n+        Tfloat32,\n+        Tfloat64,\n+        Tfloat80,\n+        Timaginary32,\n+        Timaginary64,\n+        Timaginary80,\n+        Tcomplex32,\n+        Tcomplex64,\n+        Tcomplex80,\n+        Tbool,\n+        Tchar,\n+        Twchar,\n+        Tdchar,\n+        Terror,\n+        Tinstance,\n+        Ttypeof,\n+        Ttuple,\n+        Tslice,\n+        Treturn,\n+        Tnull,\n+        Tvector,\n+        Tint128,\n+        Tuns128,\n+        Ttraits,\n+        Tmixin,\n+        Tnoreturn,\n+        Ttag,\n+    ];\n     ImpCnvTab impCnvTab;\n \n     // Set conversion tables\n@@ -375,5 +426,9 @@ ImpCnvTab generateImpCnvTab()\n \n     X(Tcomplex80,Tcomplex80,  Tcomplex80,Tcomplex80, Tcomplex80);\n \n+    // \"No type is implicitly convertible to noreturn, but noreturn is implicitly convertible to every other type\"\n+    foreach(convertToTy; typeTYs)\n+        X(Tnoreturn, convertToTy, convertToTy, convertToTy, convertToTy);\n+\n     return impCnvTab;\n }"}, {"sha": "a57671271048a6a10bd508e29f1ebc48eff0fa4d", "filename": "gcc/d/dmd/initsem.d", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Finitsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Finitsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Finitsem.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -567,18 +567,40 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n                     i.exp = e.optimize(WANTvalue);\n             }\n         }\n+\n+        // Look for the case of statically initializing an array with a single member.\n+        // Recursively strip static array / enum layers until a compatible element is found,\n+        // and return an `ArrayLiteralExp` repeating the initializer, or `null` if no match found\n+        // int[2][3] = 7       => [[7, 7], [7, 7], [7, 7]]\n+        // int[2] = new Object => null\n+        Expression sarrayRepeat(Type tb)\n         {\n-        // Look for the case of statically initializing an array\n-        // with a single member.\n-        auto tba = tb.isTypeSArray();\n-        if (tba && !tba.next.equals(ti.toBasetype().nextOf()) && i.exp.implicitConvTo(tba.next))\n+            auto tsa = tb.isTypeSArray();\n+            if (!tsa)\n+                return null;\n+\n+            // printf(\"i.exp = %s, tsa = %s\\n\", i.exp.toChars(), tsa.toChars());\n+            Expression elem = null;\n+            if (i.exp.implicitConvTo(tb.nextOf()))\n+                elem = i.exp.implicitCastTo(sc, tb.nextOf());\n+            else if (auto ae = sarrayRepeat(tb.nextOf().toBasetype()))\n+                elem = ae;\n+            else\n+                return null;\n+\n+            auto arrayElements = new Expressions(cast(size_t) tsa.dim.toInteger());\n+            foreach (ref e; *arrayElements)\n+                e = elem;\n+            return new ArrayLiteralExp(i.exp.loc, tb, elem, arrayElements);\n+        }\n+\n+        if (auto sa = sarrayRepeat(tb))\n         {\n-            /* If the variable is not actually used in compile time, array creation is\n-             * redundant. So delay it until invocation of toExpression() or toDt().\n-             */\n-            t = tb.nextOf();\n+            // printf(\"sa = %s\\n\", sa.toChars());\n+            i.exp = sa;\n         }\n \n+        {\n         auto tta = t.isTypeSArray();\n         if (i.exp.implicitConvTo(t))\n         {\n@@ -595,6 +617,7 @@ extern(C++) Initializer initializerSemantic(Initializer init, Scope* sc, ref Typ\n         }\n         else\n         {\n+            auto tba = tb.isTypeSArray();\n             // Look for mismatch of compile-time known length to emit\n             // better diagnostic message, as same as AssignExp::semantic.\n             if (tba && i.exp.implicitConvTo(tba.next.arrayOf()) > MATCH.nomatch)"}, {"sha": "11afcdd9f0b9a42366b9c273b654cfdd8e55609e", "filename": "gcc/d/dmd/lexer.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1326,7 +1326,7 @@ class Lexer\n                 switch (*p)\n                 {\n                 case ';':\n-                    c = HtmlNamedEntity(idstart, p - idstart);\n+                    c = HtmlNamedEntity(idstart[0 .. p - idstart]);\n                     if (c == ~0)\n                     {\n                         error(loc, \"unnamed character entity &%.*s;\", cast(int)(p - idstart), idstart);"}, {"sha": "369d60e208a9695c0797440647366366a28baf09", "filename": "gcc/d/dmd/mustuse.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fmustuse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fmustuse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmustuse.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -98,7 +98,7 @@ void checkMustUseReserved(Dsymbol sym)\n  */\n private bool isAssignment(Expression e)\n {\n-    if (e.isAssignExp || e.isBinAssignExp)\n+    if (e.isAssignExp || e.isBinAssignExp || e.isConstructExp || e.isBlitExp)\n         return true;\n     if (auto ce = e.isCallExp())\n     {"}, {"sha": "be28d082405e19f7247992b367df051da1c9457f", "filename": "gcc/d/dmd/optimize.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Foptimize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Foptimize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Foptimize.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1120,7 +1120,7 @@ Expression Expression_optimize(Expression e, int result, bool keepLvalue)\n                     e.e1 = ci;\n             }\n         }\n-        if (e.e1.op == EXP.string_ || e.e1.op == EXP.arrayLiteral || e.e1.op == EXP.assocArrayLiteral || e.e1.type.toBasetype().ty == Tsarray)\n+        if (e.e1.op == EXP.string_ || e.e1.op == EXP.arrayLiteral || e.e1.op == EXP.assocArrayLiteral || e.e1.type.toBasetype().ty == Tsarray || e.e1.op == EXP.null_)\n         {\n             ret = ArrayLength(e.type, e.e1).copy();\n         }"}, {"sha": "a2c364e7e15ccc9c1d6f2020c45b910350480fb4", "filename": "gcc/d/dmd/parse.d", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fparse.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fparse.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fparse.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2186,7 +2186,13 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         if (token.value == TOK.identifier)\n             s = new AST.DebugSymbol(token.loc, token.ident);\n         else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+        {\n+            // @@@DEPRECATED_2.111@@@\n+            // Deprecated in 2.101, remove in 2.111\n+            deprecation(\"`debug = <integer>` is deprecated, use debug identifiers instead\");\n+\n             s = new AST.DebugSymbol(token.loc, cast(uint)token.unsvalue);\n+        }\n         else\n         {\n             error(\"identifier or integer expected, not `%s`\", token.toChars());\n@@ -2215,7 +2221,13 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (token.value == TOK.identifier)\n                 id = token.ident;\n             else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+            {\n+                // @@@DEPRECATED_2.111@@@\n+                // Deprecated in 2.101, remove in 2.111\n+                deprecation(\"`debug( <integer> )` is deprecated, use debug identifiers instead\");\n+\n                 level = cast(uint)token.unsvalue;\n+            }\n             else\n                 error(\"identifier or integer expected inside `debug(...)`, not `%s`\", token.toChars());\n             loc = token.loc;\n@@ -2235,7 +2247,12 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n         if (token.value == TOK.identifier)\n             s = new AST.VersionSymbol(token.loc, token.ident);\n         else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+        {\n+            // @@@DEPRECATED_2.111@@@\n+            // Deprecated in 2.101, remove in 2.111\n+            deprecation(\"`version = <integer>` is deprecated, use version identifiers instead\");\n             s = new AST.VersionSymbol(token.loc, cast(uint)token.unsvalue);\n+        }\n         else\n         {\n             error(\"identifier or integer expected, not `%s`\", token.toChars());\n@@ -2269,7 +2286,13 @@ class Parser(AST, Lexer = dmd.lexer.Lexer) : Lexer\n             if (token.value == TOK.identifier)\n                 id = token.ident;\n             else if (token.value == TOK.int32Literal || token.value == TOK.int64Literal)\n+            {\n+                // @@@DEPRECATED_2.111@@@\n+                // Deprecated in 2.101, remove in 2.111\n+                deprecation(\"`version( <integer> )` is deprecated, use version identifiers instead\");\n+\n                 level = cast(uint)token.unsvalue;\n+            }\n             else if (token.value == TOK.unittest_)\n                 id = Identifier.idPool(Token.toString(TOK.unittest_));\n             else if (token.value == TOK.assert_)\n@@ -9312,13 +9335,10 @@ LagainStc:\n         {\n             AST.TypeAArray taa = cast(AST.TypeAArray)t;\n             AST.Type index = taa.index;\n+            // `new Type[expr]` is a static array\n             auto edim = AST.typeToExpression(index);\n-            if (!edim)\n-            {\n-                error(\"cannot create a `%s` with `new`\", t.toChars);\n-                return new AST.NullExp(loc);\n-            }\n-            t = new AST.TypeSArray(taa.next, edim);\n+            if (edim)\n+                t = new AST.TypeSArray(taa.next, edim);\n         }\n         else if (token.value == TOK.leftParenthesis && t.ty != Tsarray)\n         {"}, {"sha": "6f377700efc3aacb483dd4c55279b1c4c8f99e16", "filename": "gcc/d/dmd/semantic3.d", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fsemantic3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fsemantic3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fsemantic3.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -470,14 +470,6 @@ private extern(C++) final class Semantic3Visitor : Visitor\n                     if (f.parameterList.varargs == VarArg.typesafe && i + 1 == nparams)\n                     {\n                         stc |= STC.variadic;\n-                        auto vtypeb = vtype.toBasetype();\n-                        if (vtypeb.ty == Tarray || vtypeb.ty == Tclass)\n-                        {\n-                            /* Since it'll be pointing into the stack for the array\n-                             * contents, it needs to be `scope`\n-                             */\n-                            stc |= STC.scope_;\n-                        }\n                     }\n \n                     if ((funcdecl.flags & FUNCFLAG.inferScope) && !(fparam.storageClass & STC.scope_))\n@@ -1379,7 +1371,7 @@ private extern(C++) final class Semantic3Visitor : Visitor\n             funcdecl.flags &= ~FUNCFLAG.semantic3Errors;\n         if (funcdecl.type.ty == Terror)\n             funcdecl.errors = true;\n-        //printf(\"-FuncDeclaration::semantic3('%s.%s', sc = %p, loc = %s)\\n\", parent.toChars(), toChars(), sc, loc.toChars());\n+        //printf(\"-FuncDeclaration::semantic3('%s.%s', sc = %p, loc = %s)\\n\", funcdecl.parent.toChars(), funcdecl.toChars(), sc, funcdecl.loc.toChars());\n         //fflush(stdout);\n     }\n "}, {"sha": "e5e57535b373ec7963f3230d3fee109b5ef28a97", "filename": "gcc/d/dmd/statementsem.d", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fstatementsem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Fstatementsem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fstatementsem.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -733,9 +733,26 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n         {\n             assert(oaggr.type);\n \n-            fs.error(\"invalid `foreach` aggregate `%s` of type `%s`\", oaggr.toChars(), oaggr.type.toPrettyChars());\n-            if (isAggregate(fs.aggr.type))\n-                fs.loc.errorSupplemental(\"maybe define `opApply()`, range primitives, or use `.tupleof`\");\n+            fs.error(\"invalid `%s` aggregate `%s` of type `%s`\",\n+                Token.toChars(fs.op), oaggr.toChars(), oaggr.type.toPrettyChars());\n+\n+            if (auto ad = isAggregate(fs.aggr.type))\n+            {\n+                if (fs.op == TOK.foreach_reverse_)\n+                {\n+                    fs.loc.errorSupplemental(\"`foreach_reverse` works with bidirectional ranges\"~\n+                        \" (implementing `back` and `popBack`), aggregates implementing\" ~\n+                        \" `opApplyReverse`, or the result of an aggregate's `.tupleof` property\");\n+                    fs.loc.errorSupplemental(\"https://dlang.org/phobos/std_range_primitives.html#isBidirectionalRange\");\n+                }\n+                else\n+                {\n+                    fs.loc.errorSupplemental(\"`foreach` works with input ranges\"~\n+                        \" (implementing `front` and `popFront`), aggregates implementing\" ~\n+                        \" `opApply`, or the result of an aggregate's `.tupleof` property\");\n+                    fs.loc.errorSupplemental(\"https://dlang.org/phobos/std_range_primitives.html#isInputRange\");\n+                }\n+            }\n \n             return setError();\n         }\n@@ -2828,10 +2845,20 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n             rs.error(\"`return` statements cannot be in contracts\");\n             errors = true;\n         }\n-        if (sc.os && sc.os.tok != TOK.onScopeFailure)\n+        if (sc.os)\n         {\n-            rs.error(\"`return` statements cannot be in `%s` bodies\", Token.toChars(sc.os.tok));\n-            errors = true;\n+            // @@@DEPRECATED_2.112@@@\n+            // Deprecated in 2.100, transform into an error in 2.112\n+            if (sc.os.tok == TOK.onScopeFailure)\n+            {\n+                rs.deprecation(\"`return` statements cannot be in `scope(failure)` bodies.\");\n+                deprecationSupplemental(rs.loc, \"Use try-catch blocks for this purpose\");\n+            }\n+            else\n+            {\n+                rs.error(\"`return` statements cannot be in `%s` bodies\", Token.toChars(sc.os.tok));\n+                errors = true;\n+            }\n         }\n         if (sc.tf)\n         {\n@@ -2913,6 +2940,17 @@ package (dmd) extern (C++) final class StatementSemanticVisitor : Visitor\n                     rs.exp.type = texp;\n                 }\n \n+                // @@@DEPRECATED_2.111@@@\n+                const olderrors = global.startGagging();\n+                // uncomment to turn deprecation into an error when\n+                // deprecation cycle is over\n+                if (discardValue(rs.exp))\n+                {\n+                    //errors = true;\n+                }\n+                if (global.endGagging(olderrors))\n+                    rs.exp.deprecation(\"`%s` has no effect\", rs.exp.toChars());\n+\n                 /* Replace:\n                  *      return exp;\n                  * with:"}, {"sha": "5791a885068c8ea0c0db807da6e14f2c016610d3", "filename": "gcc/d/dmd/transitivevisitor.d", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftransitivevisitor.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -862,6 +862,12 @@ package mixin template ParseVisitMethods(AST)\n         visitFuncBody(d);\n     }\n \n+    override void visit(AST.CtorDeclaration d)\n+    {\n+        //printf(\"Visiting CtorDeclaration\\n\");\n+        visitFuncBody(d);\n+    }\n+\n     override void visit(AST.StaticCtorDeclaration d)\n     {\n         //printf(\"Visiting StaticCtorDeclaration\\n\");"}, {"sha": "b1f1b1fa167e871f4a3fd38d5ea5a986df500b5c", "filename": "gcc/d/dmd/typesem.d", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ftypesem.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fdmd%2Ftypesem.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Ftypesem.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1272,6 +1272,16 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                     errors = true;\n                 }\n \n+                const bool isTypesafeVariadic = i + 1 == dim &&\n+                                                tf.parameterList.varargs == VarArg.typesafe &&\n+                                                (t.isTypeDArray() || t.isTypeClass());\n+                if (isTypesafeVariadic)\n+                {\n+                    /* typesafe variadic arguments are constructed on the stack, so must be `scope`\n+                     */\n+                    fparam.storageClass |= STC.scope_ | STC.scopeinferred;\n+                }\n+\n                 if (fparam.storageClass & STC.return_)\n                 {\n                     if (fparam.isReference())\n@@ -1300,8 +1310,7 @@ extern(C++) Type typeSemantic(Type type, const ref Loc loc, Scope* sc)\n                         }\n                     }\n \n-                    if (i + 1 == dim && tf.parameterList.varargs == VarArg.typesafe &&\n-                        (t.isTypeDArray() || t.isTypeClass()))\n+                    if (isTypesafeVariadic)\n                     {\n                         /* This is because they can be constructed on the stack\n                          * https://dlang.org/spec/function.html#typesafe_variadic_functions"}, {"sha": "40c2689a3b9f66d5b6775a8d583d60fc8f9c51d9", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -873,6 +873,17 @@ class ExprVisitor : public Visitor\n \tgcc_unreachable ();\n       }\n \n+    /* Look for exp = noreturn;  */\n+    if (e->e2->type->isTypeNoreturn ())\n+      {\n+\t/* If the RHS is a `noreturn' expression, there is no point generating\n+\t   any code for the assignment, just evaluate side effects.  */\n+\ttree t1 = build_expr (e->e1);\n+\ttree t2 = build_expr (e->e2);\n+\tthis->result_ = compound_expr (t1, t2);\n+\treturn;\n+      }\n+\n     /* Look for array[] = n;  */\n     if (e->e1->op == EXP::slice)\n       {"}, {"sha": "da65239646860abae426674d49c125835f013e36", "filename": "gcc/d/lang.opt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Fd%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Flang.opt?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -249,7 +249,7 @@ Compile in debug code.\n \n fdebug=\n D Joined RejectNegative\n--fdebug=<level|ident>\tCompile in debug code, code <= <level>, or code identified by <ident>.\n+-fdebug=<ident>\tCompile in debug code identified by <ident>.\n \n fdoc\n D\n@@ -466,7 +466,7 @@ Compile in unittest code.\n \n fversion=\n D Joined RejectNegative\n--fversion=<level|ident>\tCompile in version code >= <level> or identified by <ident>.\n+-fversion=<ident>\tCompile in version code identified by <ident>.\n \n fweak-templates\n D Var(flag_weak_templates) Init(1)"}, {"sha": "7ec9f614ef8ee557a7d4394c4927701bf821f94b", "filename": "gcc/testsuite/gdc.test/compilable/backendfloatoptim.d", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbackendfloatoptim.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbackendfloatoptim.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fbackendfloatoptim.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,10 @@\n+// REQUIRED_ARGS: -O -inline\n+\n+//https://issues.dlang.org/show_bug.cgi?id=20143\n+real fun(int x) { return 0.0; }\n+\n+double bug()\n+{\n+    // value passed to fun is irrelevant\n+    return 0.0 / fun(420);\n+}"}, {"sha": "82c68f7a3a57b5f5a66fa0f66a509a953164697f", "filename": "gcc/testsuite/gdc.test/compilable/cppmangle3.d", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fcppmangle3.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -45,16 +45,12 @@ alias Alias(T) = T;\n static assert(is(Alias!(__traits(parent, Foo.bar)) == Foo));\n \n extern(C++, \"std\"):\n-debug = 456;\n debug = def;\n-version = 456;\n version = def;\n \n extern(C++, \"std\")\n {\n-    debug = 456;\n     debug = def;\n-    version = 456;\n     version = def;\n }\n "}, {"sha": "8caec434bdc8bd89739c62ee7c8db7ca84b194eb", "filename": "gcc/testsuite/gdc.test/compilable/must_use_initialize.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_initialize.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_initialize.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fmust_use_initialize.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,16 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23236\n+// can't initialize a @mustuse member in constructor\n+\n+import core.attribute;\n+\n+@mustuse struct MyError { }\n+\n+struct S\n+{\n+    MyError lastError;\n+\n+    this(int x)\n+    {\n+        this.lastError = MyError();\n+    }\n+}"}, {"sha": "e648a56d896ee1691ebc449f107d453f9b477225", "filename": "gcc/testsuite/gdc.test/compilable/noreturn1.d", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Fnoreturn1.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -122,3 +122,31 @@ noreturn testdg(noreturn delegate() dg)\n {\n     dg();\n }\n+\n+noreturn func()\n+{\n+    while(1)\n+    {\n+    }\n+}\n+alias AliasSeq(T...) = T;\n+alias Types = AliasSeq!(bool, byte, ubyte, short, ushort, int, uint,\n+                        long, ulong, char, wchar, dchar, float, double,\n+                        real);\n+void noreturnImplicit()\n+{\n+    /*\n+        Testing both ways because, although the underlying table\n+        is symmetrical the code that calls into it may be buggy.\n+    */\n+    {\n+        int x = 2 + func();\n+        int y = func() + 2;\n+    }\n+    foreach(T; Types)\n+    {\n+        T value;\n+        auto x = value + throw new Exception(\"Hello\");\n+        auto y = (throw new Exception(\"wow\")) + value;\n+    }\n+}"}, {"sha": "25617a9a398f96622b77f74a61cdb4389f93d5fc", "filename": "gcc/testsuite/gdc.test/compilable/test20832.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20832.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20832.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest20832.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,12 @@\n+// PERMUTE_ARGS: -preview=dip1000\n+// https://issues.dlang.org/show_bug.cgi?id=20823\n+\n+void boo(T)(  scope   void delegate(T[] data) fun) {}\n+void goo(T)(/+scope+/ void delegate(T[] data) fun) {}\n+\n+void main()\n+{\n+    void Execute(int[] data) {}\n+    goo(&Execute);\n+    boo(&Execute);\n+}"}, {"sha": "b485304c188fd20941022e92108d480277680868", "filename": "gcc/testsuite/gdc.test/compilable/test21177.d", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21177.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21177.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21177.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -4,15 +4,19 @@ DISABLED: win\n TEST_OUTPUT:\n ---\n compilable/test21177.d(103): Deprecation: more format specifiers than 0 arguments\n+compilable/test21177.d(111): Deprecation: more format specifiers than 0 arguments\n compilable/test21177.d(150): Deprecation: more format specifiers than 0 arguments\n compilable/test21177.d(151): Deprecation: more format specifiers than 0 arguments\n compilable/test21177.d(152): Deprecation: more format specifiers than 0 arguments\n compilable/test21177.d(153): Deprecation: more format specifiers than 0 arguments\n-compilable/test21177.d(200): Deprecation: more format specifiers than 0 arguments\n-compilable/test21177.d(203): Deprecation: format specifier `\"%m\"` is invalid\n-compilable/test21177.d(204): Deprecation: format specifier `\"%m\"` is invalid\n-compilable/test21177.d(205): Deprecation: argument `c` for format specification `\"%a\"` must be `float*`, not `char*`\n-compilable/test21177.d(206): Deprecation: argument `c` for format specification `\"%a\"` must be `float*`, not `char*`\n+compilable/test21177.d(154): Deprecation: more format specifiers than 0 arguments\n+compilable/test21177.d(155): Deprecation: more format specifiers than 0 arguments\n+compilable/test21177.d(202): Deprecation: format specifier `\"%m\"` is invalid\n+compilable/test21177.d(203): Deprecation: argument `d` for format specification `\"%mc\"` must be `char**`, not `int`\n+compilable/test21177.d(204): Deprecation: argument `c` for format specification `\"%ms\"` must be `char**`, not `char*`\n+compilable/test21177.d(205): Deprecation: format specifier `\"%ml\"` is invalid\n+compilable/test21177.d(206): Deprecation: argument `d` for format specification `\"%mlc\"` must be `wchar_t**`, not `int`\n+compilable/test21177.d(207): Deprecation: argument `c` for format specification `\"%mls\"` must be `wchar_t**`, not `char*`\n ---\n */\n \n@@ -27,50 +31,45 @@ void main()\n         #line 100\n         printf(\"%m this is a string in errno\");\n         printf(\"%s %m\", \"str\".ptr, 2);\n-        printf(\"%a\", 2.);\n+        printf(\"%m %a\", 2.);\n         printf(\"%m %m %s\");\n+        printf(\"%m\");\n         printf(\"%*m\");\n-\n+        pragma(msg, \"compilable/test21177.d(111): Deprecation: more format specifiers than 0 arguments\");\n+    }\n+    else\n+    {\n+        pragma(msg, \"compilable/test21177.d(103): Deprecation: more format specifiers than 0 arguments\");\n+        printf(\"%m\");\n+    }\n+    {\n         char* a, b;\n-        sscanf(\"salut poilu\", \"%a %m\", a, b);\n+        sscanf(\"salut poilu\", \"%ms %m[^\\n]\", &a, &b);\n         assert(!strcmp(a, b));\n         free(a);\n         free(b);\n \n-        char* t, p;\n-        sscanf(\"Tomate Patate\", \"%ms %as\", t, p);\n+        char* t; wchar_t* p;\n+        sscanf(\"Tomate Patate\", \"%mc %mlc\", &t, &p);\n         free(t);\n         free(p);\n \n         #line 150\n         sscanf(\"150\", \"%m\");\n         sscanf(\"151\", \"%ms\");\n-        sscanf(\"152\", \"%a\");\n-        sscanf(\"153\", \"%as\");\n-\n-        pragma(msg, \"compilable/test21177.d(200): Deprecation: more format specifiers than 0 arguments\");\n-        pragma(msg, \"compilable/test21177.d(203): Deprecation: format specifier `\\\"%m\\\"` is invalid\");\n-        pragma(msg, \"compilable/test21177.d(204): Deprecation: format specifier `\\\"%m\\\"` is invalid\");\n-        pragma(msg, \"compilable/test21177.d(205): Deprecation: argument `c` for format specification `\\\"%a\\\"` must be `float*`, not `char*`\");\n-        pragma(msg, \"compilable/test21177.d(206): Deprecation: argument `c` for format specification `\\\"%a\\\"` must be `float*`, not `char*`\");\n-    }\n-    else\n-    {\n-        // fake it\n-        pragma(msg, \"compilable/test21177.d(103): Deprecation: more format specifiers than 0 arguments\");\n-        pragma(msg, \"compilable/test21177.d(150): Deprecation: more format specifiers than 0 arguments\");\n-        pragma(msg, \"compilable/test21177.d(151): Deprecation: more format specifiers than 0 arguments\");\n-        pragma(msg, \"compilable/test21177.d(152): Deprecation: more format specifiers than 0 arguments\");\n-        pragma(msg, \"compilable/test21177.d(153): Deprecation: more format specifiers than 0 arguments\");\n+        sscanf(\"152\", \"%mc\");\n+        sscanf(\"153\", \"%ml\");\n+        sscanf(\"154\", \"%mls\");\n+        sscanf(\"155\", \"%mlc\");\n \n         #line 200\n-        printf(\"%m\");\n-\n         char* c;\n+        int d;\n         sscanf(\"204\", \"%m\", c);\n-        sscanf(\"205\", \"%ms\", c);\n-        sscanf(\"206\", \"%a\", c);\n-        sscanf(\"207\", \"%as\", c);\n-\n+        sscanf(\"205\", \"%mc\", d);\n+        sscanf(\"206\", \"%ms\", c);\n+        sscanf(\"207\", \"%ml\", d);\n+        sscanf(\"208\", \"%mlc\", d);\n+        sscanf(\"209\", \"%mls\", c);\n     }\n }"}, {"sha": "2c83e24611664f941f424fab52e4c910755f76cd", "filename": "gcc/testsuite/gdc.test/compilable/test21432.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21432.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21432.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest21432.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,25 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21432\n+auto issue21432()\n+{\n+    enum int[] a = [];\n+    return a;\n+}\n+\n+enum test21432a = issue21432;\n+\n+///////////////////////\n+\n+double issue21432b(double r)\n+{\n+    enum double[4] poly = [\n+        0x1.ffffffffffdbdp-2,\n+        0x1.555555555543cp-3,\n+        0x1.55555cf172b91p-5,\n+        0x1.1111167a4d017p-7,\n+    ];\n+\n+    immutable r2 = r * r;\n+    return r + r2 * (poly[0] + r * poly[1]) + r2 * r2 * (poly[2] + r * poly[3]);\n+}\n+\n+enum test21432b = issue21432b(-0x1p-1);"}, {"sha": "f045416c4c9a39992bab1c994794828cb455e085", "filename": "gcc/testsuite/gdc.test/compilable/test22390.d", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22390.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22390.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest22390.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,8 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22390\n+\n+int main()\n+{\n+    noreturn[] empty;\n+    assert(empty == empty);\n+    return 0;\n+}"}, {"sha": "9df4e4e7774c1648c74b849fa038dcf4fe83c5f5", "filename": "gcc/testsuite/gdc.test/compilable/test23082.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23082.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23082.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23082.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,17 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23082\n+\n+/*\n+TEST_OUTPUT:\n+---\n+bar\n+---\n+*/\n+\n+void foo()() {}\n+alias bar = foo;\n+void bar() { }\n+\n+void main()\n+{\n+    pragma(msg, __traits(parent, main).bar.stringof);\n+}"}, {"sha": "66da4cd69637e570d9c2e033d9c4c6d2e68b89e9", "filename": "gcc/testsuite/gdc.test/compilable/test23166.d", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23166.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23166.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23166.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,22 @@\n+// REQUIRED_ARGS: -inline\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23166\n+\n+// seg fault with -inline\n+\n+bool __equals(scope const char[] lhs, scope const char[] rhs)\n+{\n+    if (lhs.length != rhs.length)\n+        return false;\n+\n+    {\n+        import core.stdc.string : memcmp;\n+        return lhs.length == 0;\n+    }\n+    return true;\n+}\n+\n+int test(string type)\n+{\n+    return __equals(type, \"as-is\");\n+}"}, {"sha": "18b6d4ce8c5e4102da2418caf0b658e70945002d", "filename": "gcc/testsuite/gdc.test/compilable/test23172.d", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23172.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23172.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23172.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,33 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23172\n+\n+enum E : ubyte { // `ubyte` is needed to trigger the bug\n+    A,\n+    B,\n+}\n+\n+struct S {\n+    E e;\n+}\n+\n+void compiles(bool b, S s) {\n+    E e = b ? E.A : s.e;\n+}\n+\n+void errors(bool b, const ref S s) {\n+    E e = b ? E.A : s.e;\n+}\n+\n+// from https://issues.dlang.org/show_bug.cgi?id=23188\n+\n+enum Status : byte\n+{\n+    A, B, C\n+}\n+\n+Status foo()\n+{\n+    Status t = Status.A;\n+    const Status s = t;\n+\n+    return (s == Status.A) ? Status.B : s;  // <-- here\n+}"}, {"sha": "99772adeba4b280cfa994a1ddc8b4a16c4609724", "filename": "gcc/testsuite/gdc.test/compilable/test23235.d", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23235.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23235.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23235.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,20 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=23235\n+ */\n+\n+@safe:\n+\n+void awkk(string[] ppp...)\n+{\n+}\n+\n+void bark(string[] foo...) {\n+    awkk(foo);\n+}\n+\n+void cack(string[] bar...) {\n+    bark(bar);\n+}\n+\n+void test() {\n+    cack(\"abc\", \"def\");\n+}"}, {"sha": "1e5720128cae65360ae0605051d182bbd45505fc", "filename": "gcc/testsuite/gdc.test/compilable/test23256.d", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23256.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23256.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23256.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,6 @@\n+/* REQUIRED_ARGS: -os=windows\n+ */\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23256\n+\n+void test23256() { }"}, {"sha": "96da2721b1b96430d7f81aa161af1a4a47effaa0", "filename": "gcc/testsuite/gdc.test/compilable/test23262.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23262.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23262.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftest23262.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,17 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=23262\n+ */\n+\n+struct T()\n+{\n+    string[] tags;\n+\n+    this(string[] tags...)\n+    {\n+        this.tags = tags; // don't infer `return` attribute for `tags`\n+    }\n+}\n+\n+void test()\n+{\n+    T!() t;\n+}"}, {"sha": "659b5f776a59758bc5936044977ef51953df8a07", "filename": "gcc/testsuite/gdc.test/compilable/testgotoskips.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestgotoskips.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestgotoskips.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Fcompilable%2Ftestgotoskips.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,17 @@\n+/*\n+    Tests to defend against false positives from the goto skips over decl errors\n+*/\n+// https://issues.dlang.org/show_bug.cgi?id=23271\n+class A {\n+        private static A[] active;\n+        private void test() {\n+                foreach(a; active) {\n+                    if(a is this)\n+                         goto label;\n+                }\n+                // used to say Error: `goto` skips declaration of variable `s.A.test.__appendtmp4` at s.d(...)\n+                active ~= this;\n+            label:\n+                return;\n+        }\n+}"}, {"sha": "8360e1ac4844b38a14f7b1879e4a4ecc303e9d03", "filename": "gcc/testsuite/gdc.test/fail_compilation/attributediagnostic.d", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fattributediagnostic.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fattributediagnostic.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fattributediagnostic.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,12 +1,20 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/attributediagnostic.d(16): Error: `@safe` function `attributediagnostic.layer2` cannot call `@system` function `attributediagnostic.layer1`\n-fail_compilation/attributediagnostic.d(18):        which calls `attributediagnostic.layer0`\n-fail_compilation/attributediagnostic.d(20):        which calls `attributediagnostic.system`\n-fail_compilation/attributediagnostic.d(22):        which was inferred `@system` because of:\n-fail_compilation/attributediagnostic.d(22):        `asm` statement is assumed to be `@system` - mark it with `@trusted` if it is not\n-fail_compilation/attributediagnostic.d(17):        `attributediagnostic.layer1` is declared here\n+fail_compilation/attributediagnostic.d(24): Error: `@safe` function `attributediagnostic.layer2` cannot call `@system` function `attributediagnostic.layer1`\n+fail_compilation/attributediagnostic.d(26):        which calls `attributediagnostic.layer0`\n+fail_compilation/attributediagnostic.d(28):        which calls `attributediagnostic.system`\n+fail_compilation/attributediagnostic.d(30):        which was inferred `@system` because of:\n+fail_compilation/attributediagnostic.d(30):        `asm` statement is assumed to be `@system` - mark it with `@trusted` if it is not\n+fail_compilation/attributediagnostic.d(25):        `attributediagnostic.layer1` is declared here\n+fail_compilation/attributediagnostic.d(46): Error: `@safe` function `D main` cannot call `@system` function `attributediagnostic.system1`\n+fail_compilation/attributediagnostic.d(35):        which was inferred `@system` because of:\n+fail_compilation/attributediagnostic.d(35):        cast from `uint` to `int*` not allowed in safe code\n+fail_compilation/attributediagnostic.d(33):        `attributediagnostic.system1` is declared here\n+fail_compilation/attributediagnostic.d(47): Error: `@safe` function `D main` cannot call `@system` function `attributediagnostic.system2`\n+fail_compilation/attributediagnostic.d(41):        which was inferred `@system` because of:\n+fail_compilation/attributediagnostic.d(41):        `@safe` function `system2` cannot call `@system` `fsys`\n+fail_compilation/attributediagnostic.d(39):        `attributediagnostic.system2` is declared here\n ---\n */\n \n@@ -19,5 +27,22 @@ auto layer0() { system(); }\n \n auto system()\n {\n-\tasm {}\n+    asm {}\n+}\n+\n+auto system1()\n+{\n+    int* x = cast(int*) 0xDEADBEEF;\n+}\n+\n+auto fsys = function void() @system {};\n+auto system2()\n+{\n+    fsys();\n+}\n+\n+void main() @safe\n+{\n+    system1();\n+    system2();\n }"}, {"sha": "fa8915e5fa989b3bac5ccceadaa74383507a1e7c", "filename": "gcc/testsuite/gdc.test/fail_compilation/chkformat.d", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fchkformat.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -169,3 +169,21 @@ void test409() { char* p; printf(\"%llu\", p); }\n void test410() { char* p; printf(\"%lld\", p); }\n void test411() { char* p; printf(\"%ju\", p); }\n void test412() { char* p; printf(\"%jd\", p); }\n+\n+/* https://issues.dlang.org/show_bug.cgi?id=23247\n+TEST_OUTPUT:\n+---\n+fail_compilation/chkformat.d(501): Deprecation: argument `p` for format specification `\"%a\"` must be `double`, not `char*`\n+fail_compilation/chkformat.d(502): Deprecation: argument `p` for format specification `\"%La\"` must be `real`, not `char*`\n+fail_compilation/chkformat.d(503): Deprecation: argument `p` for format specification `\"%a\"` must be `float*`, not `char*`\n+fail_compilation/chkformat.d(504): Deprecation: argument `p` for format specification `\"%la\"` must be `double*`, not `char*`\n+fail_compilation/chkformat.d(505): Deprecation: argument `p` for format specification `\"%La\"` must be `real*`, not `char*`\n+---\n+*/\n+#line 500\n+\n+void test501() { char* p; printf(\"%a\", p); }\n+void test502() { char* p; printf(\"%La\", p); }\n+void test503() { char* p; scanf(\"%a\", p); }\n+void test504() { char* p; scanf(\"%la\", p); }\n+void test505() { char* p; scanf(\"%La\", p); }"}, {"sha": "7b2eca79b80d74ffd9c4555a9c1acb858f0d28dd", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag10319.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10319.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10319.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag10319.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,15 +1,17 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag10319.d(27): Error: `pure` function `D main` cannot call impure function `diag10319.foo`\n-fail_compilation/diag10319.d(27): Error: `@safe` function `D main` cannot call `@system` function `diag10319.foo`\n-fail_compilation/diag10319.d(16):        `diag10319.foo` is declared here\n-fail_compilation/diag10319.d(28): Error: `pure` function `D main` cannot call impure function `diag10319.bar!int.bar`\n-fail_compilation/diag10319.d(28): Error: `@safe` function `D main` cannot call `@system` function `diag10319.bar!int.bar`\n-fail_compilation/diag10319.d(18):        `diag10319.bar!int.bar` is declared here\n-fail_compilation/diag10319.d(27): Error: function `diag10319.foo` is not `nothrow`\n-fail_compilation/diag10319.d(28): Error: function `diag10319.bar!int.bar` is not `nothrow`\n-fail_compilation/diag10319.d(25): Error: function `D main` may throw but is marked as `nothrow`\n+fail_compilation/diag10319.d(29): Error: `pure` function `D main` cannot call impure function `diag10319.foo`\n+fail_compilation/diag10319.d(29): Error: `@safe` function `D main` cannot call `@system` function `diag10319.foo`\n+fail_compilation/diag10319.d(18):        `diag10319.foo` is declared here\n+fail_compilation/diag10319.d(30): Error: `pure` function `D main` cannot call impure function `diag10319.bar!int.bar`\n+fail_compilation/diag10319.d(30): Error: `@safe` function `D main` cannot call `@system` function `diag10319.bar!int.bar`\n+fail_compilation/diag10319.d(23):        which was inferred `@system` because of:\n+fail_compilation/diag10319.d(23):        cannot take address of local `x` in `@safe` function `bar`\n+fail_compilation/diag10319.d(20):        `diag10319.bar!int.bar` is declared here\n+fail_compilation/diag10319.d(29): Error: function `diag10319.foo` is not `nothrow`\n+fail_compilation/diag10319.d(30): Error: function `diag10319.bar!int.bar` is not `nothrow`\n+fail_compilation/diag10319.d(27): Error: function `D main` may throw but is marked as `nothrow`\n ---\n */\n "}, {"sha": "1be0f1e85a2cdf96bd31b383ba313df3ec90ac5b", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag11198.d", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag11198.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,12 +1,14 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag11198.d(15): Error: version `blah` declaration must be at module level\n-fail_compilation/diag11198.d(16): Error: debug `blah` declaration must be at module level\n-fail_compilation/diag11198.d(17): Error: version `1` level declaration must be at module level\n-fail_compilation/diag11198.d(18): Error: debug `2` level declaration must be at module level\n-fail_compilation/diag11198.d(19): Error: identifier or integer expected, not `\"\"`\n-fail_compilation/diag11198.d(20): Error: identifier or integer expected, not `\"\"`\n+fail_compilation/diag11198.d(17): Error: version `blah` declaration must be at module level\n+fail_compilation/diag11198.d(18): Error: debug `blah` declaration must be at module level\n+fail_compilation/diag11198.d(19): Deprecation: `version = <integer>` is deprecated, use version identifiers instead\n+fail_compilation/diag11198.d(19): Error: version `1` level declaration must be at module level\n+fail_compilation/diag11198.d(20): Deprecation: `debug = <integer>` is deprecated, use debug identifiers instead\n+fail_compilation/diag11198.d(20): Error: debug `2` level declaration must be at module level\n+fail_compilation/diag11198.d(21): Error: identifier or integer expected, not `\"\"`\n+fail_compilation/diag11198.d(22): Error: identifier or integer expected, not `\"\"`\n ---\n */\n "}, {"sha": "1d37a1ecbfe2c36ecd9f42e870c8607afa0be851", "filename": "gcc/testsuite/gdc.test/fail_compilation/diag12829.d", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12829.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12829.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fdiag12829.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,11 +1,11 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/diag12829.d(12): Error: function `diag12829.test1` is `@nogc` yet allocates closures with the GC\n-fail_compilation/diag12829.d(15):        diag12829.test1.__lambda2 closes over variable x at fail_compilation/diag12829.d(14)\n-fail_compilation/diag12829.d(19):        diag12829.test1.bar closes over variable x at fail_compilation/diag12829.d(14)\n-fail_compilation/diag12829.d(26): Error: function `diag12829.test2` is `@nogc` yet allocates closures with the GC\n-fail_compilation/diag12829.d(31):        diag12829.test2.S.foo closes over variable x at fail_compilation/diag12829.d(28)\n+fail_compilation/diag12829.d(12): Error: function `diag12829.test1` is `@nogc` yet allocates closure for `test1()` with the GC\n+fail_compilation/diag12829.d(15):        `diag12829.test1.__lambda2` closes over variable `x` at fail_compilation/diag12829.d(14)\n+fail_compilation/diag12829.d(19):        `diag12829.test1.bar` closes over variable `x` at fail_compilation/diag12829.d(14)\n+fail_compilation/diag12829.d(26): Error: function `diag12829.test2` is `@nogc` yet allocates closure for `test2()` with the GC\n+fail_compilation/diag12829.d(31):        `diag12829.test2.S.foo` closes over variable `x` at fail_compilation/diag12829.d(28)\n ---\n */\n "}, {"sha": "a526b908acdbe69d92c81d035843f8ba4255f74b", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail118.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail118.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,15 +1,17 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail118.d(43): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n-fail_compilation/fail118.d(43):        maybe define `opApply()`, range primitives, or use `.tupleof`\n-fail_compilation/fail118.d(44): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n-fail_compilation/fail118.d(44):        maybe define `opApply()`, range primitives, or use `.tupleof`\n-fail_compilation/fail118.d(47): Error: invalid `foreach` aggregate `s` of type `S*`\n-fail_compilation/fail118.d(49): Error: undefined identifier `unknown`\n-fail_compilation/fail118.d(37): Error: undefined identifier `doesNotExist`\n-fail_compilation/fail118.d(51): Error: template instance `fail118.error!()` error instantiating\n-fail_compilation/fail118.d(51): Error: invalid `foreach` aggregate `error()` of type `void`\n+fail_compilation/fail118.d(45): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n+fail_compilation/fail118.d(45):        `foreach` works with input ranges (implementing `front` and `popFront`), aggregates implementing `opApply`, or the result of an aggregate's `.tupleof` property\n+fail_compilation/fail118.d(45):        https://dlang.org/phobos/std_range_primitives.html#isInputRange\n+fail_compilation/fail118.d(46): Error: invalid `foreach` aggregate `Iter` of type `Iter`\n+fail_compilation/fail118.d(46):        `foreach` works with input ranges (implementing `front` and `popFront`), aggregates implementing `opApply`, or the result of an aggregate's `.tupleof` property\n+fail_compilation/fail118.d(46):        https://dlang.org/phobos/std_range_primitives.html#isInputRange\n+fail_compilation/fail118.d(49): Error: invalid `foreach` aggregate `s` of type `S*`\n+fail_compilation/fail118.d(51): Error: undefined identifier `unknown`\n+fail_compilation/fail118.d(39): Error: undefined identifier `doesNotExist`\n+fail_compilation/fail118.d(53): Error: template instance `fail118.error!()` error instantiating\n+fail_compilation/fail118.d(53): Error: invalid `foreach` aggregate `error()` of type `void`\n ---\n */\n "}, {"sha": "c14977d0f12490ed4cb6999546159de8ee6bbbfb", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail20547.d", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20547.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64ce76d940501cb04d14a0d36752b4f93473531c/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20547.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail20547.d?ref=64ce76d940501cb04d14a0d36752b4f93473531c", "patch": "@@ -1,15 +0,0 @@\n-/*\n-TEST_OUTPUT:\n----\n-fail_compilation/fail20547.d(12): Error: cannot create a `string[string]` with `new`\n-fail_compilation/fail20547.d(14): Error: cannot create a `string[string]` with `new`\n----\n-*/\n-\n-void main()\n-{\n-    //https://issues.dlang.org/show_bug.cgi?id=11790\n-    string[string] crash = new string[string];\n-    //https://issues.dlang.org/show_bug.cgi?id=20547\n-    int[string] c = new typeof(crash);\n-}"}, {"sha": "5a4933ef325e188b9dfa184ebe5e47adbdf653a1", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail22134.d", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22134.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22134.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail22134.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,17 @@\n+// https://issues.dlang.org/show_bug.cgi?id=22134\n+/* REQUIRED_ARGS: -de\n+TEST_OUTPUT:\n+---\n+fail_compilation/fail22134.d(12): Deprecation: `this.arr[i]` has no effect\n+---\n+*/\n+struct StackBuffer\n+{\n+    auto opIndex(size_t i)\n+    {\n+        return arr[i];\n+    }\n+\n+private:\n+    void[] arr;\n+}"}, {"sha": "519244c1cdfab2449efc66accbdad08f6b37cb55", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail23181.d", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23181.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23181.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail23181.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,16 @@\n+/* https://issues.dlang.org/show_bug.cgi?id=23181\n+TEST_OUTPUT:\n+---\n+$p:druntime/import/core/lifetime.d$($n$): Error: struct `fail23181.fail23181.NoPostblit` is not copyable because it has a disabled postblit\n+$p:druntime/import/core/internal/array/construction.d$($n$): Error: template instance `core.lifetime.copyEmplace!(NoPostblit, NoPostblit)` error instantiating\n+fail_compilation/fail23181.d(15):        instantiated from here: `_d_arraysetctor!(NoPostblit[], NoPostblit)`\n+---\n+*/\n+void fail23181()\n+{\n+    struct NoPostblit\n+    {\n+        @disable this(this);\n+    }\n+    NoPostblit[4] noblit23181 = NoPostblit();\n+}"}, {"sha": "d807dc8f3aa6b3d2dd5e7765a182b1dcd7e0edd3", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail261.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail261.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,8 +1,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/fail261.d(19): Error: invalid `foreach` aggregate `range` of type `MyRange`\n-fail_compilation/fail261.d(19):        maybe define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/fail261.d(20): Error: invalid `foreach` aggregate `range` of type `MyRange`\n+fail_compilation/fail261.d(20):        `foreach` works with input ranges (implementing `front` and `popFront`), aggregates implementing `opApply`, or the result of an aggregate's `.tupleof` property\n+fail_compilation/fail261.d(20):        https://dlang.org/phobos/std_range_primitives.html#isInputRange\n ---\n */\n "}, {"sha": "89b2351acfe00be4227fcf8644ee7c12b74a2a6f", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail58.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail58.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -7,15 +7,15 @@ fail_compilation/fail58.d(30): Error: function `fail58.SomeFunc(dchar[] pText, o\n fail_compilation/fail58.d(30):        cannot pass argument `\"\"` of type `string` to parameter `dchar[] pText`\n ---\n */\n-debug(1) import std.stdio;\n+debug import std.stdio;\n const int anything = -1000; // Line #2\n dchar[] SomeFunc( dchar[] pText, out int pStopPosn)\n {\n     if (pText.length == 0)\n         pStopPosn = 0;\n     else\n         pStopPosn = -1;\n-    debug(1) writefln(\"DEBUG: using '%s' we get %d\", pText, pStopPosn);\n+    debug writefln(\"DEBUG: using '%s' we get %d\", pText, pStopPosn);\n     return pText.dup;\n }\n \n@@ -24,12 +24,12 @@ int main(char[][] pArgs)\n     int sp;\n \n     SomeFunc(\"123\", sp);\n-    debug(1) writefln(\"DEBUG: got %d\", sp);\n+    debug writefln(\"DEBUG: got %d\", sp);\n     assert(sp == -1);\n \n     SomeFunc(\"\", sp);\n //    if (sp != 0){} // Line #22\n-    debug(1) writefln(\"DEBUG: got %d\", sp);\n+    debug writefln(\"DEBUG: got %d\", sp);\n     assert(sp == -1);\n     return 0;\n }"}, {"sha": "ee84a84ce79336b1234d5692084eb42d6d852845", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail6889.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6889.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6889.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail6889.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -55,7 +55,7 @@ L1:\n     scope(failure) { L2: goto L1; } // OK\n     goto L2;                        // NG\n \n-    scope(failure) { return; }      // OK\n+\n \n     foreach (i; 0..1)\n     {"}, {"sha": "001c7d75443c4f6160ae3d4b51d76558cfc4d34e", "filename": "gcc/testsuite/gdc.test/fail_compilation/fail7848.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7848.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7848.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ffail7848.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -9,12 +9,12 @@ fail_compilation/fail7848.d(21):        `fail7848.func` is declared here\n fail_compilation/fail7848.d(27): Error: `@nogc` function `fail7848.C.__unittest_L25_C30` cannot call non-@nogc function `fail7848.func`\n fail_compilation/fail7848.d(27): Error: function `fail7848.func` is not `nothrow`\n fail_compilation/fail7848.d(25): Error: function `fail7848.C.__unittest_L25_C30` may throw but is marked as `nothrow`\n-fail_compilation/fail7848.d(32): Error: `pure` function `fail7848.C.__invariant1` cannot call impure function `fail7848.func`\n-fail_compilation/fail7848.d(32): Error: `@safe` function `fail7848.C.__invariant1` cannot call `@system` function `fail7848.func`\n+fail_compilation/fail7848.d(32): Error: `pure` function `fail7848.C.__invariant0` cannot call impure function `fail7848.func`\n+fail_compilation/fail7848.d(32): Error: `@safe` function `fail7848.C.__invariant0` cannot call `@system` function `fail7848.func`\n fail_compilation/fail7848.d(21):        `fail7848.func` is declared here\n-fail_compilation/fail7848.d(32): Error: `@nogc` function `fail7848.C.__invariant1` cannot call non-@nogc function `fail7848.func`\n+fail_compilation/fail7848.d(32): Error: `@nogc` function `fail7848.C.__invariant0` cannot call non-@nogc function `fail7848.func`\n fail_compilation/fail7848.d(32): Error: function `fail7848.func` is not `nothrow`\n-fail_compilation/fail7848.d(30): Error: function `fail7848.C.__invariant1` may throw but is marked as `nothrow`\n+fail_compilation/fail7848.d(30): Error: function `fail7848.C.__invariant0` may throw but is marked as `nothrow`\n ---\n */\n "}, {"sha": "24e39da85bbdc4ba718fbd013d470c913394833a", "filename": "gcc/testsuite/gdc.test/fail_compilation/ice11856_1.d", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fice11856_1.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,8 +1,11 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/ice11856_1.d(13): Error: none of the overloads of template `ice11856_1.g` are callable using argument types `!()(A)`\n-fail_compilation/ice11856_1.d(11):        Candidate is: `g(T)(T x)`\n+fail_compilation/ice11856_1.d(16): Error: none of the overloads of template `ice11856_1.g` are callable using argument types `!()(A)`\n+fail_compilation/ice11856_1.d(14):        Candidate is: `g(T)(T x)`\n+  with `T = A`\n+  must satisfy the following constraint:\n+`       is(typeof(x.f()))`\n ---\n */\n struct A {}"}, {"sha": "b50a616ac974bd40c3f956e017ca316a95df417a", "filename": "gcc/testsuite/gdc.test/fail_compilation/misc_parser_err_cov1.d", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fmisc_parser_err_cov1.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -10,7 +10,6 @@ fail_compilation/misc_parser_err_cov1.d(31): Error: expression expected, not `)`\n fail_compilation/misc_parser_err_cov1.d(32): Error: `type identifier : specialization` expected following `is`\n fail_compilation/misc_parser_err_cov1.d(33): Error: semicolon expected following auto declaration, not `auto`\n fail_compilation/misc_parser_err_cov1.d(33): Error: found `+` when expecting `(` following `mixin`\n-fail_compilation/misc_parser_err_cov1.d(34): Error: cannot create a `char[float]` with `new`\n fail_compilation/misc_parser_err_cov1.d(35): Error: `key:value` expected for associative array literal\n fail_compilation/misc_parser_err_cov1.d(36): Error: basic type expected, not `;`\n fail_compilation/misc_parser_err_cov1.d(36): Error: `{ members }` expected for anonymous class\n@@ -44,7 +43,7 @@ void main()\n     auto tt = __traits(<o<);\n     auto b = is ;\n     auto mx1 = mixin +);\n-    auto aa1 = new char[float];\n+\n     aa +=  [key:value, key];\n     auto anon1 = new class;\n     auto anon2 = new class {};"}, {"sha": "ebc23fb352e736dc9122c55589f9fa496cea74c0", "filename": "gcc/testsuite/gdc.test/fail_compilation/newaa.d", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnewaa.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnewaa.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnewaa.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,19 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/newaa.d(14): Error: cannot implicitly convert expression `new string[string]` of type `string[string]` to `int[string]`\n+fail_compilation/newaa.d(15): Error: function expected before `()`, not `new int[int]` of type `int[int]`\n+fail_compilation/newaa.d(17): Error: `new` cannot take arguments for an associative array\n+---\n+*/\n+#line 9\n+void main()\n+{\n+    //https://issues.dlang.org/show_bug.cgi?id=11790\n+    string[string] crash = new string[string];\n+    //https://issues.dlang.org/show_bug.cgi?id=20547\n+    int[string] c = new typeof(crash);\n+    auto d = new int[int](5);\n+    alias AA = char[string];\n+    auto e = new AA(5);\n+}"}, {"sha": "3bd7167acbac0112fa1de61969cab782adffcd7b", "filename": "gcc/testsuite/gdc.test/fail_compilation/nogc3.d", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc3.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc3.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fnogc3.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -43,10 +43,10 @@ fail_compilation/nogc3.d(35): Error: `@nogc` function `nogc3.testCall` cannot ca\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/nogc3.d(52): Error: function `nogc3.testClosure1` is `@nogc` yet allocates closures with the GC\n-fail_compilation/nogc3.d(55):        nogc3.testClosure1.bar closes over variable x at fail_compilation/nogc3.d(54)\n-fail_compilation/nogc3.d(64): Error: function `nogc3.testClosure3` is `@nogc` yet allocates closures with the GC\n-fail_compilation/nogc3.d(67):        nogc3.testClosure3.bar closes over variable x at fail_compilation/nogc3.d(66)\n+fail_compilation/nogc3.d(52): Error: function `nogc3.testClosure1` is `@nogc` yet allocates closure for `testClosure1()` with the GC\n+fail_compilation/nogc3.d(55):        `nogc3.testClosure1.bar` closes over variable `x` at fail_compilation/nogc3.d(54)\n+fail_compilation/nogc3.d(64): Error: function `nogc3.testClosure3` is `@nogc` yet allocates closure for `testClosure3()` with the GC\n+fail_compilation/nogc3.d(67):        `nogc3.testClosure3.bar` closes over variable `x` at fail_compilation/nogc3.d(66)\n ---\n */\n @nogc auto testClosure1()"}, {"sha": "2a69fe04f845e40b1fe96602bb5811b47a28205e", "filename": "gcc/testsuite/gdc.test/fail_compilation/retscope.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Fretscope.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -54,8 +54,8 @@ void test2(scope int* p, int[] a ...) @safe\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/retscope.d(75): Error: function `retscope.HTTP.Impl.onReceive` is `@nogc` yet allocates closures with the GC\n-fail_compilation/retscope.d(77):        retscope.HTTP.Impl.onReceive.__lambda1 closes over variable this at fail_compilation/retscope.d(75)\n+fail_compilation/retscope.d(75): Error: function `retscope.HTTP.Impl.onReceive` is `@nogc` yet allocates closure for `onReceive()` with the GC\n+fail_compilation/retscope.d(77):        `retscope.HTTP.Impl.onReceive.__lambda1` closes over variable `this` at fail_compilation/retscope.d(75)\n ---\n */\n "}, {"sha": "73ec588c777370d2a65b3eea1da47be2e873869f", "filename": "gcc/testsuite/gdc.test/fail_compilation/test13786.d", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest13786.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest13786.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest13786.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,11 +1,13 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test13786.d(14): Error: debug `123` level declaration must be at module level\n-fail_compilation/test13786.d(15): Error: debug `abc` declaration must be at module level\n-fail_compilation/test13786.d(16): Error: version `123` level declaration must be at module level\n-fail_compilation/test13786.d(17): Error: version `abc` declaration must be at module level\n-fail_compilation/test13786.d(20): Error: template instance `test13786.T!()` error instantiating\n+fail_compilation/test13786.d(16): Deprecation: `debug = <integer>` is deprecated, use debug identifiers instead\n+fail_compilation/test13786.d(18): Deprecation: `version = <integer>` is deprecated, use version identifiers instead\n+fail_compilation/test13786.d(16): Error: debug `123` level declaration must be at module level\n+fail_compilation/test13786.d(17): Error: debug `abc` declaration must be at module level\n+fail_compilation/test13786.d(18): Error: version `123` level declaration must be at module level\n+fail_compilation/test13786.d(19): Error: version `abc` declaration must be at module level\n+fail_compilation/test13786.d(22): Error: template instance `test13786.T!()` error instantiating\n ---\n */\n "}, {"sha": "6c80471c77bfa41e165a138bc172a2acedda4b47", "filename": "gcc/testsuite/gdc.test/fail_compilation/test16193.d", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16193.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16193.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest16193.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2,8 +2,8 @@\n REQUIRED_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/test16193.d(38): Error: function `test16193.abc` is `@nogc` yet allocates closures with the GC\n-fail_compilation/test16193.d(40):        test16193.abc.__foreachbody2 closes over variable x at fail_compilation/test16193.d(39)\n+fail_compilation/test16193.d(38): Error: function `test16193.abc` is `@nogc` yet allocates closure for `abc()` with the GC\n+fail_compilation/test16193.d(40):        `test16193.abc.__foreachbody2` closes over variable `x` at fail_compilation/test16193.d(39)\n ---\n */\n //fail_compilation/test16193.d(22): To enforce `@safe`, the compiler allocates a closure unless `opApply()` uses `scope`"}, {"sha": "2d99524da3521ead3af179230d43e03317bd3daf", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21443.d", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21443.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21443.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21443.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,21 @@\n+// https://issues.dlang.org/show_bug.cgi?id=21443\n+// REQUIRED_ARGS: -de\n+\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test21443.d(14): Deprecation: `return` statements cannot be in `scope(failure)` bodies.\n+fail_compilation/test21443.d(14):        Use try-catch blocks for this purpose\n+---\n+*/\n+\n+ulong get () @safe nothrow\n+{\n+    scope (failure) return 10;\n+    throw new Error(\"\");\n+}\n+\n+void main () @safe\n+{\n+    assert(get() == 10);  // passes\n+}"}, {"sha": "9b07eba0df64c5fcab8a73c0372035308e4a8f1d", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21912.d", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21912.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2,14 +2,14 @@\n PERMUTE_ARGS: -preview=dip1000\n TEST_OUTPUT:\n ---\n-fail_compilation/test21912.d(24): Error: function `test21912.escapeParam` is `@nogc` yet allocates closures with the GC\n-fail_compilation/test21912.d(26):        test21912.escapeParam.__lambda2 closes over variable i at fail_compilation/test21912.d(24)\n-fail_compilation/test21912.d(29): Error: function `test21912.escapeAssign` is `@nogc` yet allocates closures with the GC\n-fail_compilation/test21912.d(31):        test21912.escapeAssign.__lambda3 closes over variable i at fail_compilation/test21912.d(29)\n-fail_compilation/test21912.d(40): Error: function `test21912.escapeAssignRef` is `@nogc` yet allocates closures with the GC\n-fail_compilation/test21912.d(42):        test21912.escapeAssignRef.__lambda3 closes over variable i at fail_compilation/test21912.d(40)\n-fail_compilation/test21912.d(51): Error: function `test21912.escapeParamInferred` is `@nogc` yet allocates closures with the GC\n-fail_compilation/test21912.d(53):        test21912.escapeParamInferred.__lambda2 closes over variable i at fail_compilation/test21912.d(51)\n+fail_compilation/test21912.d(24): Error: function `test21912.escapeParam` is `@nogc` yet allocates closure for `escapeParam()` with the GC\n+fail_compilation/test21912.d(26):        `test21912.escapeParam.__lambda2` closes over variable `i` at fail_compilation/test21912.d(24)\n+fail_compilation/test21912.d(29): Error: function `test21912.escapeAssign` is `@nogc` yet allocates closure for `escapeAssign()` with the GC\n+fail_compilation/test21912.d(31):        `test21912.escapeAssign.__lambda3` closes over variable `i` at fail_compilation/test21912.d(29)\n+fail_compilation/test21912.d(40): Error: function `test21912.escapeAssignRef` is `@nogc` yet allocates closure for `escapeAssignRef()` with the GC\n+fail_compilation/test21912.d(42):        `test21912.escapeAssignRef.__lambda3` closes over variable `i` at fail_compilation/test21912.d(40)\n+fail_compilation/test21912.d(51): Error: function `test21912.escapeParamInferred` is `@nogc` yet allocates closure for `escapeParamInferred()` with the GC\n+fail_compilation/test21912.d(53):        `test21912.escapeParamInferred.__lambda2` closes over variable `i` at fail_compilation/test21912.d(51)\n ---\n */\n @nogc:"}, {"sha": "e513dc248c6417fa17d50a53dbec09d2df00ee38", "filename": "gcc/testsuite/gdc.test/fail_compilation/test21939.d", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21939.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21939.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest21939.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2,8 +2,9 @@\n /*\n TEST_OUTPUT:\n ---\n-fail_compilation/test21939.d(10): Error: invalid `foreach` aggregate `Object` of type `Object`\n-fail_compilation/test21939.d(10):        maybe define `opApply()`, range primitives, or use `.tupleof`\n+fail_compilation/test21939.d(11): Error: invalid `foreach` aggregate `Object` of type `Object`\n+fail_compilation/test21939.d(11):        `foreach` works with input ranges (implementing `front` and `popFront`), aggregates implementing `opApply`, or the result of an aggregate's `.tupleof` property\n+fail_compilation/test21939.d(11):        https://dlang.org/phobos/std_range_primitives.html#isInputRange\n ---\n */\n "}, {"sha": "8c4eca9c5637cb5fadb9c277ec25260dd3439d95", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23022.d", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23022.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23022.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23022.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,15 @@\n+/*\n+REQUIRED_ARGS: -preview=dip1000\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23022.d(14): Error: scope parameter `p` may not be returned\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23022\n+// Typesafe variadic parameter should not infer return\n+\n+auto ir(string[] p...)\n+{\n+    return p;\n+}"}, {"sha": "325d89bd6c227179f1ff152be1fd9b1d50a19990", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23112.d", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23112.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23112.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23112.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,30 @@\n+/* REQUIRED_ARGS: -betterC\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23112.d(106): Error: function `test23112.bar` is `@nogc` yet allocates closure for `bar()` with the GC\n+fail_compilation/test23112.d(108):        `test23112.bar.f` closes over variable `a` at fail_compilation/test23112.d(106)\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23112\n+\n+#line 100\n+\n+struct Forward(alias F)\n+{\n+    auto call()() { return F(); }\n+}\n+\n+auto bar(int a) nothrow @safe\n+{\n+    auto f()\n+    {\n+        return a;\n+    }\n+    return Forward!f();\n+}\n+\n+extern(C) void main()\n+{\n+    assert(bar(3).call() == 3);\n+}"}, {"sha": "eb79cd81565eda2bb9802e0e1e1d5c9a8af45a33", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23170.d", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23170.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23170.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23170.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,12 @@\n+/*\r\n+TEST_OUTPUT:\r\n+---\r\n+fail_compilation/test23170.d(10): Error: array literal in `@nogc` delegate `test23170.__lambda5` may cause a GC allocation\r\n+---\r\n+*/\r\n+// https://issues.dlang.org/show_bug.cgi?id=23170\r\n+\r\n+@nogc:\r\n+enum lambda = () => badAlias([1, 2, 3]);\r\n+alias badAlias = (int[] array) => id(array);\r\n+int[] id(int[] array) { return array; }\r"}, {"sha": "d7c12ed3207da85f2161d8ee73d31a3af82aea38", "filename": "gcc/testsuite/gdc.test/fail_compilation/test23216.d", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23216.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23216.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Ffail_compilation%2Ftest23216.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,24 @@\n+/*\n+TEST_OUTPUT:\n+---\n+fail_compilation/test23216.d(23): Error: invalid `foreach_reverse` aggregate `r` of type `Range`\n+fail_compilation/test23216.d(23):        `foreach_reverse` works with bidirectional ranges (implementing `back` and `popBack`), aggregates implementing `opApplyReverse`, or the result of an aggregate's `.tupleof` property\n+fail_compilation/test23216.d(23):        https://dlang.org/phobos/std_range_primitives.html#isBidirectionalRange\n+---\n+*/\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23216\n+// Better Error Message For foreach_reverse Without Bidirectional Range\n+\n+struct Range\n+{\n+    bool empty = true;\n+    int front = 0;\n+    void popFront() { }\n+}\n+\n+void main()\n+{\n+    Range r;\n+    foreach_reverse (word; r) { }\n+}"}, {"sha": "1382f2d35ce0cfa059578b546afc581d23a366a4", "filename": "gcc/testsuite/gdc.test/runnable/closure.d", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclosure.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclosure.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fclosure.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -922,7 +922,10 @@ void test14730()\n \n // This is questionable case. Currently it works without any errors,\n // but not sure it's really intentional\n-\n+// It showed up again in https://issues.dlang.org/show_bug.cgi?id=23112\n+// where it's an @safe issue so it's a bug.\n+static if (0)\n+{\n struct S14730x(alias f)\n {\n     auto foo()() { return f(0); }\n@@ -947,6 +950,7 @@ void test14730x()\n     // *after* the semantic3 completion of makeS() function.\n     assert(s.foo() == 10);\n }\n+}\n \n /************************************/\n \n@@ -981,7 +985,7 @@ int main()\n     test9685b();\n     test12406();\n     test14730();\n-    test14730x();\n+    //test14730x();\n \n     printf(\"Success\\n\");\n     return 0;"}, {"sha": "f93aef541ce0c3711a26c6590ce676125d2abbe1", "filename": "gcc/testsuite/gdc.test/runnable/evalorder.d", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fevalorder.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fevalorder.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fevalorder.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -46,6 +46,12 @@ int mul11ret3(T)(ref T s)\n     return 3;\n }\n \n+auto cat11ret3(T)(ref T s)\n+{\n+    s ~= 11;\n+    return [3];\n+}\n+\n void add()\n {\n     static int test1(int val) { val += add8ret3(val); return val; }\n@@ -147,6 +153,25 @@ void shr()\n     static assert(test(0x80) == 0x40);\n }\n \n+void cat()\n+{\n+    static auto test1(int[] val) { val ~= cat11ret3(val); return val; }\n+    assert(test1([1]) == [1, 11, 3]);\n+    static assert(test1([1]) == [1, 11, 3]);\n+\n+    static auto test2(int[] val) { val = val ~ cat11ret3(val); return val; }\n+    // FIXME: assert(test2([1]) == [1, 3]);\n+    static assert(test2([1]) == [1, 3]);\n+\n+    static auto test3(int[] val) { (val ~= 7) ~= cat11ret3(val); return val; }\n+    assert(test3([2]) == [2, 7, 11, 3]);\n+    static assert(test3([2]) == [2, 7, 11, 3]);\n+\n+    static auto test4(int[] val) { (val ~= cat11ret3(val)) ~= 7; return val; }\n+    assert(test4([2]) == [2, 11, 3, 7]);\n+    static assert(test4([2]) == [2, 11, 3, 7]);\n+}\n+\n void ldc_github_1617()\n {\n     add();\n@@ -156,6 +181,7 @@ void ldc_github_1617()\n     addptr();\n     lhsCast();\n     shr();\n+    cat();\n }\n \n /******************************************/"}, {"sha": "6e31c07f9cb50337a209b4efd627bd70b367f9ab", "filename": "gcc/testsuite/gdc.test/runnable/lexer.d", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Flexer.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,5 +1,11 @@\n // REQUIRED_ARGS:\n-\n+/*\n+TEST_OUTPUT:\n+---\n+runnable/lexer.d(81): Deprecation: `version( <integer> )` is deprecated, use version identifiers instead\n+runnable/lexer.d(82): Deprecation: `debug( <integer> )` is deprecated, use debug identifiers instead\n+---\n+*/\n \n /*********************************************************/\n "}, {"sha": "5ed46c1625023c3bc0d52e9c1d72369f38c5f85a", "filename": "gcc/testsuite/gdc.test/runnable/noreturn1.d", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fnoreturn1.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -261,6 +261,37 @@ void testThrowDtor()\n \n /*****************************************/\n \n+noreturn func()\n+{\n+    throw new Exception(\"B\");\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23120\n+void test23120()\n+{\n+    string a;\n+    try\n+    {\n+        noreturn q = throw new Exception (\"A\");\n+    }\n+    catch(Exception e)\n+    {\n+        a ~= e.msg;\n+    }\n+\n+    try\n+    {\n+        noreturn z = func();\n+    }\n+    catch(Exception e)\n+    {\n+        a ~= e.msg;\n+    }\n+\n+    assert(a == \"AB\");\n+}\n+\n+/*****************************************/\n int main()\n {\n     test1();\n@@ -269,5 +300,6 @@ int main()\n     testThrowExpression();\n     testThrowSideEffect();\n     testThrowDtor();\n+    test23120();\n     return 0;\n }"}, {"sha": "333b60058279c17e06890f59cfc7f1bb55092c75", "filename": "gcc/testsuite/gdc.test/runnable/test11.d", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest11.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1193,41 +1193,6 @@ void test63()\n      printf(\"%.*s\\n\", cast(int)s.length, s.ptr);\n }\n \n-\n-/**************************************/\n-\n-debug = 3;\n-\n-void test64()\n-{\n-    debug(5)\n-    {\n-        assert(0);\n-    }\n-    debug(3)\n-    {\n-        int x = 3;\n-    }\n-    assert(x == 3);\n-}\n-\n-/**************************************/\n-\n-version = 3;\n-\n-void test65()\n-{\n-    version(5)\n-    {\n-        assert(0);\n-    }\n-    version(3)\n-    {\n-        int x = 3;\n-    }\n-    assert(x == 3);\n-}\n-\n /**************************************/\n // https://issues.dlang.org/show_bug.cgi?id=8809\n \n@@ -1381,8 +1346,6 @@ int main(string[] argv)\n     test61();\n     test62();\n     test63();\n-    test64();\n-    test65();\n     test8809();\n     test9734();\n "}, {"sha": "29fcfa757746b5fc63d34e0ecada984367464f47", "filename": "gcc/testsuite/gdc.test/runnable/test18973.d", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18973.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18973.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest18973.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,25 @@\n+// This is a runnable test as we are testing a linker error\n+\n+// https://issues.dlang.org/show_bug.cgi?id=18973\n+struct X {\n+    @disable size_t toHash() const;\n+    @disable string toString() const;\n+    @disable bool opEquals(const ref X) const;\n+    @disable int opCmp(const ref X) const;\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=9161\n+public struct dummy\n+{\n+    static auto opCall(C)(in C[] name)\n+    {\n+        return name;\n+    }\n+\n+    @disable ~this(); //comment this out to avoid error\n+}\n+\n+void main()\n+{\n+    assert(dummy(\"ABCDE\") == \"ABCDE\");\n+}"}, {"sha": "eda6172abc040dae9ab7fed35236d8789888d6cb", "filename": "gcc/testsuite/gdc.test/runnable/test19.d", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest19.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -59,22 +59,7 @@ void test2()\n void test3()\n {\n     debug printf(\"debug\\n\");\n-    debug(1) printf(\"debug(1)\\n\");\n-    debug(2) printf(\"debug(2)\\n\");\n-    debug(3) printf(\"debug(3)\\n\");\n     debug(bar) printf(\"debug(bar)\\n\");\n-    debug(10) assert(0);\n-\n-    debug(1)\n-    {\n-        int d1 = 3;\n-\n-        printf(\"debug(1) { }\\n\");\n-    }\n-    debug(2)\n-    {\n-        printf(\"debug(2): d1 = %d\\n\", d1);\n-    }\n }\n \n /* ================================ */"}, {"sha": "b3c5916ada500b5d7a10c371d98f13c360e16bd1", "filename": "gcc/testsuite/gdc.test/runnable/test20734.d", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20734.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20734.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest20734.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -16,6 +16,7 @@ extern(C) int main() nothrow @nogc @safe\n {\n     takeScopeSlice([ S(1), S(2) ]); // @nogc => no GC allocation\n     (() @trusted { assert(numDtor == 2); })(); // stack-allocated array literal properly destructed\n+    assert23100([]);\n     return 0;\n }\n \n@@ -26,3 +27,9 @@ void test23098() @safe\n {\n     f23098([10, 20]);\n }\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23100\n+void assert23100(scope int[] d) @safe nothrow @nogc\n+{\n+    assert(!d);\n+}"}, {"sha": "b961690a2bc12bff91a9a61515ae9dbbcd9c615e", "filename": "gcc/testsuite/gdc.test/runnable/test23181.d", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23181.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23181.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest23181.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,27 @@\n+// https://issues.dlang.org/show_bug.cgi?id=23181\n+void main()\n+{\n+    int count;\n+    struct HasDtor\n+    {\n+        ~this() { ++count; }\n+    }\n+\n+    // array[] = elem()\n+    // -> creates temporary to construct array and calls destructor.\n+    {\n+        count = 0;\n+        HasDtor[4] dtor1 = HasDtor();\n+        assert(count == 1);\n+    }\n+    assert(count == 5);\n+\n+    // array[] = array[elem()]\n+    // -> constructs array using direct emplacement.\n+    {\n+        count = 0;\n+        HasDtor[2] dtor2 = [HasDtor(), HasDtor()];\n+        assert(count == 0);\n+    }\n+    assert(count == 2);\n+}"}, {"sha": "d65ba0eb7ad3109d9272c0be09d559077cbfb5b9", "filename": "gcc/testsuite/gdc.test/runnable/test8.d", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Ftest8.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -591,6 +591,44 @@ void test34()\n             assert(b[i][j] == 16);\n }\n \n+/***********************************/\n+// https://issues.dlang.org/show_bug.cgi?id=19178\n+\n+float[3][4] arr2f = 10;\n+Int3_4[1] arr3i = 20;\n+short[3][4][1][1] arr4s = 30;\n+\n+enum Int3 : int[3] {\n+    a = [0, 1, 2],\n+}\n+\n+enum Int3_4 : Int3[4] {\n+    b = Int3[4].init,\n+}\n+\n+struct S35\n+{\n+    int[3][3] arr = [2, 1];\n+}\n+\n+void test35()\n+{\n+    for (int i = 0; i < 4; i++)\n+    {\n+        for (int j = 0; j < 3; j++)\n+        {\n+            // printf(\"[%d %d]: %f %d %d\\n\", i, j, arr2f[i][j], arr3i[0][i][j], arr4s[0][0][i][j]);\n+            assert(arr2f[i][j] == 10);\n+            assert(arr3i[0][i][j] == 20);\n+            assert(arr4s[0][0][i][j] == 30);\n+        }\n+    }\n+\n+    S35 t = S35.init;\n+    assert(t.arr[0] == [2, 2, 2]);\n+    assert(t.arr[1] == [1, 1, 1]);\n+    assert(t.arr[2] == [0, 0, 0]);\n+}\n /***********************************/\n \n string itoa(int i)\n@@ -868,6 +906,7 @@ int main()\n     test32();\n     test33();\n     test34();\n+    test35();\n     test36();\n     test37();\n     test38();"}, {"sha": "e225d5e4be3e8e698ae84a60ccf4669cbffa9cd2", "filename": "gcc/testsuite/gdc.test/runnable/version.d", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fversion.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fversion.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fversion.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,10 +1,9 @@\n /*\n PERMUTE_ARGS:\n-REQUIRED_ARGS: -version=3 -version=foo\n+REQUIRED_ARGS: -version=foo\n RUN_OUTPUT:\n ---\n i = 2\n-i = 2\n ---\n */\n \n@@ -15,20 +14,6 @@ extern(C) int printf(const char*, ...);\n void test1()\n {\n     int i = 3;\n-\n-    version(2)\n-    {\n-        i = 2;\n-    }\n-    else\n-    {\n-        i = 0;\n-    }\n-    printf(\"i = %d\\n\", i);\n-    assert(i == 2);\n-\n-    i = 3;\n-\n     version(foo)\n     {\n         i = 2;\n@@ -47,10 +32,6 @@ version(foo)\n {\n     version = bar;\n }\n-else\n-{\n-    version = 4;\n-}\n \n void test2()\n {\n@@ -59,8 +40,6 @@ void test2()\n     }\n     else\n         assert(0);\n-\n-    version(4) assert(0);\n }\n \n /*******************************************/"}, {"sha": "01ac20c0bafadc6b262081d8dab83783aca1b5d4", "filename": "gcc/testsuite/gdc.test/runnable/warning1.d", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fwarning1.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fwarning1.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.test%2Frunnable%2Fwarning1.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -133,15 +133,6 @@ void test6518()\n     }\n }\n \n-/******************************************/\n-// https://issues.dlang.org/show_bug.cgi?id=7232\n-\n-bool test7232()\n-{\n-    scope(failure) return false;\n-    return true;\n-}\n-\n /***************************************************/\n \n struct S9332"}, {"sha": "69d2d440d69c098f69fcb49ba6928f95ad73c435", "filename": "libphobos/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fconfigure?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -15554,7 +15554,7 @@ SPEC_PHOBOS_DEPS=\"$LIBS\"\n \n \n # Libdruntime / phobos soname version\n-libtool_VERSION=3:0:0\n+libtool_VERSION=4:0:0\n \n \n # Set default flags (after DRUNTIME_WERROR!)"}, {"sha": "8bdf7332b86a001d315429f10bf432c784be6a9f", "filename": "libphobos/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fconfigure.ac?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -253,7 +253,7 @@ SPEC_PHOBOS_DEPS=\"$LIBS\"\n AC_SUBST(SPEC_PHOBOS_DEPS)\n \n # Libdruntime / phobos soname version\n-libtool_VERSION=3:0:0\n+libtool_VERSION=4:0:0\n AC_SUBST(libtool_VERSION)\n \n # Set default flags (after DRUNTIME_WERROR!)"}, {"sha": "c358b69e3fc90a1f1e05e0626c605a3460ffac4d", "filename": "libphobos/libdruntime/MERGE", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMERGE?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,4 +1,4 @@\n-651389b52243dcadb338dd0c14dd27e7850cda8d\n+d7772a236983ec37b92d21b28bad3cd2de57b945\n \n The first line of this file holds the git revision number of the last\n-merge done from the dlang/druntime repository.\n+merge done from the dlang/dmd repository."}, {"sha": "2e1e91da79f918886cafdce25191a22902a0009e", "filename": "libphobos/libdruntime/Makefile.am", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.am?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -174,14 +174,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/internal/array/appending.d core/internal/array/capacity.d \\\n \tcore/internal/array/casting.d core/internal/array/comparison.d \\\n \tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n-\tcore/internal/array/equality.d core/internal/array/operations.d \\\n-\tcore/internal/array/utils.d core/internal/atomic.d \\\n-\tcore/internal/attributes.d core/internal/container/array.d \\\n-\tcore/internal/container/common.d core/internal/container/hashtab.d \\\n-\tcore/internal/container/treap.d core/internal/convert.d \\\n-\tcore/internal/dassert.d core/internal/destruction.d \\\n-\tcore/internal/entrypoint.d core/internal/gc/bits.d \\\n-\tcore/internal/gc/impl/conservative/gc.d \\\n+\tcore/internal/array/duplication.d core/internal/array/equality.d \\\n+\tcore/internal/array/operations.d core/internal/array/utils.d \\\n+\tcore/internal/atomic.d core/internal/attributes.d \\\n+\tcore/internal/container/array.d core/internal/container/common.d \\\n+\tcore/internal/container/hashtab.d core/internal/container/treap.d \\\n+\tcore/internal/convert.d core/internal/dassert.d \\\n+\tcore/internal/destruction.d core/internal/entrypoint.d \\\n+\tcore/internal/gc/bits.d core/internal/gc/impl/conservative/gc.d \\\n \tcore/internal/gc/impl/manual/gc.d core/internal/gc/impl/proto/gc.d \\\n \tcore/internal/gc/os.d core/internal/gc/pooltable.d \\\n \tcore/internal/gc/proxy.d core/internal/hash.d core/internal/lifetime.d \\"}, {"sha": "de6656c552b2e6268b0f13ea8b136bf28737de8c", "filename": "libphobos/libdruntime/Makefile.in", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2FMakefile.in?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -196,6 +196,7 @@ am__objects_1 = core/atomic.lo core/attribute.lo core/bitop.lo \\\n \tcore/internal/array/comparison.lo \\\n \tcore/internal/array/concatenation.lo \\\n \tcore/internal/array/construction.lo \\\n+\tcore/internal/array/duplication.lo \\\n \tcore/internal/array/equality.lo \\\n \tcore/internal/array/operations.lo core/internal/array/utils.lo \\\n \tcore/internal/atomic.lo core/internal/attributes.lo \\\n@@ -841,14 +842,14 @@ DRUNTIME_DSOURCES = core/atomic.d core/attribute.d core/bitop.d \\\n \tcore/internal/array/appending.d core/internal/array/capacity.d \\\n \tcore/internal/array/casting.d core/internal/array/comparison.d \\\n \tcore/internal/array/concatenation.d core/internal/array/construction.d \\\n-\tcore/internal/array/equality.d core/internal/array/operations.d \\\n-\tcore/internal/array/utils.d core/internal/atomic.d \\\n-\tcore/internal/attributes.d core/internal/container/array.d \\\n-\tcore/internal/container/common.d core/internal/container/hashtab.d \\\n-\tcore/internal/container/treap.d core/internal/convert.d \\\n-\tcore/internal/dassert.d core/internal/destruction.d \\\n-\tcore/internal/entrypoint.d core/internal/gc/bits.d \\\n-\tcore/internal/gc/impl/conservative/gc.d \\\n+\tcore/internal/array/duplication.d core/internal/array/equality.d \\\n+\tcore/internal/array/operations.d core/internal/array/utils.d \\\n+\tcore/internal/atomic.d core/internal/attributes.d \\\n+\tcore/internal/container/array.d core/internal/container/common.d \\\n+\tcore/internal/container/hashtab.d core/internal/container/treap.d \\\n+\tcore/internal/convert.d core/internal/dassert.d \\\n+\tcore/internal/destruction.d core/internal/entrypoint.d \\\n+\tcore/internal/gc/bits.d core/internal/gc/impl/conservative/gc.d \\\n \tcore/internal/gc/impl/manual/gc.d core/internal/gc/impl/proto/gc.d \\\n \tcore/internal/gc/os.d core/internal/gc/pooltable.d \\\n \tcore/internal/gc/proxy.d core/internal/hash.d core/internal/lifetime.d \\\n@@ -1208,6 +1209,8 @@ core/internal/array/concatenation.lo:  \\\n \tcore/internal/array/$(am__dirstamp)\n core/internal/array/construction.lo:  \\\n \tcore/internal/array/$(am__dirstamp)\n+core/internal/array/duplication.lo:  \\\n+\tcore/internal/array/$(am__dirstamp)\n core/internal/array/equality.lo: core/internal/array/$(am__dirstamp)\n core/internal/array/operations.lo:  \\\n \tcore/internal/array/$(am__dirstamp)"}, {"sha": "1c2ac0677046fc7b76450c7f06cce14a214492ef", "filename": "libphobos/libdruntime/core/cpuid.d", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fcpuid.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -170,6 +170,8 @@ public:\n     bool hle()          {return _hle;}\n     /// Is RTM (restricted transactional memory) supported\n     bool rtm()          {return _rtm;}\n+    /// Is AVX512F supported\n+    bool avx512f()      {return _avx512f;}\n     /// Is rdseed supported\n     bool hasRdseed()    {return _hasRdseed;}\n     /// Is SHA supported\n@@ -279,6 +281,7 @@ private immutable\n     bool _avx2;\n     bool _hle;\n     bool _rtm;\n+    bool _avx512f;\n     bool _hasRdseed;\n     bool _hasSha;\n     bool _amd3dnow;\n@@ -389,6 +392,7 @@ CpuFeatures* getCpuFeatures() @nogc nothrow\n     enum : uint\n     {\n         FSGSBASE_BIT = 1 << 0,\n+        SGX_BIT = 1 << 2,\n         BMI1_BIT = 1 << 3,\n         HLE_BIT = 1 << 4,\n         AVX2_BIT = 1 << 5,\n@@ -397,8 +401,19 @@ CpuFeatures* getCpuFeatures() @nogc nothrow\n         ERMS_BIT = 1 << 9,\n         INVPCID_BIT = 1 << 10,\n         RTM_BIT = 1 << 11,\n+        AVX512F_BIT = 1 << 16,\n+        AVX512DQ_BIT = 1 << 17,\n         RDSEED_BIT = 1 << 18,\n+        ADX_BIT = 1 << 19,\n+        AVX512IFMA_BIT = 1 << 21,\n+        CLFLUSHOPT_BIT = 1 << 23,\n+        CLWB_BIT = 1 << 24,\n+        AVX512PF_BIT = 1 << 26,\n+        AVX512ER_BIT = 1 << 27,\n+        AVX512CD_BIT = 1 << 28,\n         SHA_BIT = 1 << 29,\n+        AVX512BW_BIT = 1 << 30,\n+        AVX512VL_BIT = 1 << 31,\n     }\n     // feature flags XFEATURES_ENABLED_MASK\n     enum : ulong\n@@ -1122,6 +1137,7 @@ shared static this()\n     _avx2 =           avx && (cf.extfeatures & AVX2_BIT) != 0;\n     _hle =            (cf.extfeatures & HLE_BIT) != 0;\n     _rtm =            (cf.extfeatures & RTM_BIT) != 0;\n+    _avx512f =        (cf.extfeatures & AVX512F_BIT) != 0;\n     _hasRdseed =      (cf.extfeatures&RDSEED_BIT)!=0;\n     _hasSha =         (cf.extfeatures&SHA_BIT)!=0;\n     _amd3dnow =       (cf.amdfeatures&AMD_3DNOW_BIT)!=0;"}, {"sha": "46eb9b2755613d863c1a25a35e783758259b7127", "filename": "libphobos/libdruntime/core/int128.d", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fint128.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fint128.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -943,5 +943,3 @@ unittest\n     assert(rol(C7_9, 1) == rol1(C7_9));\n     assert(ror(C7_9, 1) == ror1(C7_9));\n }\n-\n-"}, {"sha": "616d27cfe8327aff2986bc9234b44b91cd90b6e4", "filename": "libphobos/libdruntime/core/internal/array/appending.d", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fappending.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -30,26 +30,14 @@ template _d_arrayappendcTXImpl(Tarr : T[], T)\n      * Returns:\n      *  The new value of `px`\n      * Bugs:\n-    *   This function template was ported from a much older runtime hook that bypassed safety,\n-    *   purity, and throwabilty checks. To prevent breaking existing code, this function template\n-    *   is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n+     *  This function template was ported from a much older runtime hook that bypassed safety,\n+     *  purity, and throwabilty checks. To prevent breaking existing code, this function template\n+     *  is temporarily declared `@trusted pure` until the implementation can be brought up to modern D expectations.\n      */\n-    static if (isCopyingNothrow!T) // `nothrow` deduction doesn't work, so this is needed\n-        ref Tarr _d_arrayappendcTX(return ref scope Tarr px, size_t n) @trusted pure nothrow\n-        {\n-            pragma(inline, false);\n-\n-            mixin(_d_arrayappendcTXBody);\n-        }\n-    else\n-        ref Tarr _d_arrayappendcTX(return ref scope Tarr px, size_t n) @trusted pure nothrow\n-        {\n-            pragma(inline, false);\n-\n-            mixin(_d_arrayappendcTXBody);\n-        }\n-\n-    private enum _d_arrayappendcTXBody = q{\n+    ref Tarr _d_arrayappendcTX(return ref scope Tarr px, size_t n) @trusted pure nothrow\n+    {\n+        // needed for CTFE: https://github.com/dlang/druntime/pull/3870#issuecomment-1178800718\n+        pragma(inline, false);\n         version (D_TypeInfo)\n         {\n             auto ti = typeid(Tarr);\n@@ -64,7 +52,7 @@ template _d_arrayappendcTXImpl(Tarr : T[], T)\n         }\n         else\n             assert(0, \"Cannot append arrays if compiling without support for runtime type information!\");\n-    };\n+    }\n \n     /**\n      * TraceGC wrapper around $(REF _d_arrayappendcTX, rt,array,appending,_d_arrayappendcTXImpl)."}, {"sha": "41dfab6f349c56778c1b23d47a47baf5253ffed7", "filename": "libphobos/libdruntime/core/internal/array/duplication.d", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Farray%2Fduplication.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -0,0 +1,346 @@\n+/**\n+The `.dup` and `.idup` properties for Associative Arrays and Dynamic Arrays\n+\n+Copyright: Copyright Digital Mars 2000 - 2022.\n+License: Distributed under the $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n+    (See accompanying file LICENSE)\n+Source: $(DRUNTIMESRC core/internal/_array/_duplication.d)\n+*/\n+module core.internal.array.duplication;\n+\n+private extern (C) void[] _d_newarrayU(const scope TypeInfo ti, size_t length) pure nothrow;\n+\n+U[] _dup(T, U)(scope T[] a) pure nothrow @trusted if (__traits(isPOD, T))\n+{\n+    if (__ctfe)\n+        return _dupCtfe!(T, U)(a);\n+\n+    import core.stdc.string : memcpy;\n+    auto arr = _d_newarrayU(typeid(T[]), a.length);\n+    memcpy(arr.ptr, cast(const(void)*) a.ptr, T.sizeof * a.length);\n+    return *cast(U[]*) &arr;\n+}\n+\n+U[] _dupCtfe(T, U)(scope T[] a)\n+{\n+    static if (is(T : void))\n+        assert(0, \"Cannot dup a void[] array at compile time.\");\n+    else\n+    {\n+        U[] res;\n+        foreach (ref e; a)\n+            res ~= e;\n+        return res;\n+    }\n+}\n+\n+U[] _dup(T, U)(T[] a) if (!__traits(isPOD, T))\n+{\n+    // note: copyEmplace is `@system` inside a `@trusted` block, so the __ctfe branch\n+    // has the extra duty to infer _dup `@system` when the copy-constructor is `@system`.\n+    if (__ctfe)\n+        return _dupCtfe!(T, U)(a);\n+\n+    import core.lifetime: copyEmplace;\n+    U[] res = () @trusted {\n+        auto arr = cast(U*) _d_newarrayU(typeid(T[]), a.length);\n+        size_t i;\n+        scope (failure)\n+        {\n+            import core.internal.lifetime: emplaceInitializer;\n+            // Initialize all remaining elements to not destruct garbage\n+            foreach (j; i .. a.length)\n+                emplaceInitializer(cast() arr[j]);\n+        }\n+        for (; i < a.length; i++)\n+        {\n+            copyEmplace(a.ptr[i], arr[i]);\n+        }\n+        return cast(U[])(arr[0..a.length]);\n+    } ();\n+\n+    return res;\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=22107\n+@safe unittest\n+{\n+    static int i;\n+    @safe struct S\n+    {\n+        this(this) { i++; }\n+    }\n+\n+    void fun(scope S[] values...) @safe\n+    {\n+        values.dup;\n+    }\n+}\n+\n+@safe unittest\n+{\n+    static struct S1 { int* p; }\n+    static struct S2 { @disable this(); }\n+    static struct S3 { @disable this(this); }\n+\n+    int dg1() pure nothrow @safe\n+    {\n+        {\n+           char[] m;\n+           string i;\n+           m = m.dup;\n+           i = i.idup;\n+           m = i.dup;\n+           i = m.idup;\n+        }\n+        {\n+           S1[] m;\n+           immutable(S1)[] i;\n+           m = m.dup;\n+           i = i.idup;\n+           static assert(!is(typeof(m.idup)));\n+           static assert(!is(typeof(i.dup)));\n+        }\n+        {\n+            S3[] m;\n+            immutable(S3)[] i;\n+            static assert(!is(typeof(m.dup)));\n+            static assert(!is(typeof(i.idup)));\n+        }\n+        {\n+            shared(S1)[] m;\n+            m = m.dup;\n+            static assert(!is(typeof(m.idup)));\n+        }\n+        {\n+            int[] a = (inout(int)) { inout(const(int))[] a; return a.dup; }(0);\n+        }\n+        return 1;\n+    }\n+\n+    int dg2() pure nothrow @safe\n+    {\n+        {\n+           S2[] m = [S2.init, S2.init];\n+           immutable(S2)[] i = [S2.init, S2.init];\n+           m = m.dup;\n+           m = i.dup;\n+           i = m.idup;\n+           i = i.idup;\n+        }\n+        return 2;\n+    }\n+\n+    enum a = dg1();\n+    enum b = dg2();\n+    assert(dg1() == a);\n+    assert(dg2() == b);\n+}\n+\n+@system unittest\n+{\n+    static struct Sunpure { this(this) @safe nothrow {} }\n+    static struct Sthrow { this(this) @safe pure {} }\n+    static struct Sunsafe { this(this) @system pure nothrow {} }\n+    static struct Snocopy { @disable this(this); }\n+\n+    [].dup!Sunpure;\n+    [].dup!Sthrow;\n+    cast(void) [].dup!Sunsafe;\n+    static assert(!__traits(compiles, () pure    { [].dup!Sunpure; }));\n+    static assert(!__traits(compiles, () nothrow { [].dup!Sthrow; }));\n+    static assert(!__traits(compiles, () @safe   { [].dup!Sunsafe; }));\n+    static assert(!__traits(compiles, ()         { [].dup!Snocopy; }));\n+\n+    [].idup!Sunpure;\n+    [].idup!Sthrow;\n+    [].idup!Sunsafe;\n+    static assert(!__traits(compiles, () pure    { [].idup!Sunpure; }));\n+    static assert(!__traits(compiles, () nothrow { [].idup!Sthrow; }));\n+    static assert(!__traits(compiles, () @safe   { [].idup!Sunsafe; }));\n+    static assert(!__traits(compiles, ()         { [].idup!Snocopy; }));\n+}\n+\n+@safe unittest\n+{\n+    // test that the copy-constructor is called with .dup\n+    static struct ArrElem\n+    {\n+        int a;\n+        this(int a)\n+        {\n+            this.a = a;\n+        }\n+        this(ref const ArrElem)\n+        {\n+            a = 2;\n+        }\n+        this(ref ArrElem) immutable\n+        {\n+            a = 3;\n+        }\n+    }\n+\n+    auto arr = [ArrElem(1), ArrElem(1)];\n+\n+    ArrElem[] b = arr.dup;\n+    assert(b[0].a == 2 && b[1].a == 2);\n+\n+    immutable ArrElem[] c = arr.idup;\n+    assert(c[0].a == 3 && c[1].a == 3);\n+}\n+\n+@system unittest\n+{\n+    static struct Sunpure { this(ref const typeof(this)) @safe nothrow {} }\n+    static struct Sthrow { this(ref const typeof(this)) @safe pure {} }\n+    static struct Sunsafe { this(ref const typeof(this)) @system pure nothrow {} }\n+    [].dup!Sunpure;\n+    [].dup!Sthrow;\n+    cast(void) [].dup!Sunsafe;\n+    static assert(!__traits(compiles, () pure    { [].dup!Sunpure; }));\n+    static assert(!__traits(compiles, () nothrow { [].dup!Sthrow; }));\n+    static assert(!__traits(compiles, () @safe   { [].dup!Sunsafe; }));\n+\n+    // for idup to work on structs that have copy constructors, it is necessary\n+    // that the struct defines a copy constructor that creates immutable objects\n+    static struct ISunpure { this(ref const typeof(this)) immutable @safe nothrow {} }\n+    static struct ISthrow { this(ref const typeof(this)) immutable @safe pure {} }\n+    static struct ISunsafe { this(ref const typeof(this)) immutable @system pure nothrow {} }\n+    [].idup!ISunpure;\n+    [].idup!ISthrow;\n+    [].idup!ISunsafe;\n+    static assert(!__traits(compiles, () pure    { [].idup!ISunpure; }));\n+    static assert(!__traits(compiles, () nothrow { [].idup!ISthrow; }));\n+    static assert(!__traits(compiles, () @safe   { [].idup!ISunsafe; }));\n+}\n+\n+@safe unittest\n+{\n+    static int*[] pureFoo() pure { return null; }\n+    { char[] s; immutable x = s.dup; }\n+    { immutable x = (cast(int*[])null).dup; }\n+    { immutable x = pureFoo(); }\n+    { immutable x = pureFoo().dup; }\n+}\n+\n+@safe unittest\n+{\n+    auto a = [1, 2, 3];\n+    auto b = a.dup;\n+    debug(SENTINEL) {} else\n+        assert(b.capacity >= 3);\n+}\n+\n+@system unittest\n+{\n+    // Bugzilla 12580\n+    void[] m = [0];\n+    shared(void)[] s = [cast(shared)1];\n+    immutable(void)[] i = [cast(immutable)2];\n+\n+    s = s.dup;\n+    static assert(is(typeof(s.dup) == shared(void)[]));\n+\n+    m = i.dup;\n+    i = m.dup;\n+    i = i.idup;\n+    i = m.idup;\n+    i = s.idup;\n+    i = s.dup;\n+    static assert(!__traits(compiles, m = s.dup));\n+}\n+\n+@safe unittest\n+{\n+    // Bugzilla 13809\n+    static struct S\n+    {\n+        this(this) {}\n+        ~this() {}\n+    }\n+\n+    S[] arr;\n+    auto a = arr.dup;\n+}\n+\n+@system unittest\n+{\n+    // Bugzilla 16504\n+    static struct S\n+    {\n+        __gshared int* gp;\n+        int* p;\n+        // postblit and hence .dup could escape\n+        this(this) { gp = p; }\n+    }\n+\n+    int p;\n+    scope S[1] arr = [S(&p)];\n+    auto a = arr.dup; // dup does escape\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=21983\n+// dup/idup destroys partially constructed arrays on failure\n+@safe unittest\n+{\n+    static struct SImpl(bool postblit)\n+    {\n+        int num;\n+        long l = 0xDEADBEEF;\n+\n+        static if (postblit)\n+        {\n+            this(this)\n+            {\n+                if (this.num == 3)\n+                    throw new Exception(\"\");\n+            }\n+        }\n+        else\n+        {\n+            this(scope ref const SImpl other)\n+            {\n+                if (other.num == 3)\n+                    throw new Exception(\"\");\n+\n+                this.num = other.num;\n+                this.l = other.l;\n+            }\n+        }\n+\n+        ~this() @trusted\n+        {\n+            if (l != 0xDEADBEEF)\n+            {\n+                import core.stdc.stdio;\n+                printf(\"Unexpected value: %lld\\n\", l);\n+                fflush(stdout);\n+                assert(false);\n+            }\n+        }\n+    }\n+\n+    alias Postblit = SImpl!true;\n+    alias Copy = SImpl!false;\n+\n+    static int test(S)()\n+    {\n+        S[4] arr = [ S(1), S(2), S(3), S(4) ];\n+        try\n+        {\n+            arr.dup();\n+            assert(false);\n+        }\n+        catch (Exception)\n+        {\n+            return 1;\n+        }\n+    }\n+\n+    static assert(test!Postblit());\n+    assert(test!Postblit());\n+\n+    static assert(test!Copy());\n+    assert(test!Copy());\n+}"}, {"sha": "07486c216f0b7e4905af9dfd7ac7aa092acd1672", "filename": "libphobos/libdruntime/core/internal/dassert.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Finternal%2Fdassert.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -14,7 +14,7 @@\n  *\n  * Copyright: D Language Foundation 2018 - 2020\n  * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source:    $(LINK2 https://github.com/dlang/druntime/blob/master/src/core/internal/dassert.d, _dassert.d)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/druntime/src/core/internal/dassert.d, _dassert.d)\n  * Documentation: https://dlang.org/phobos/core_internal_dassert.html\n  */\n module core.internal.dassert;"}, {"sha": "75e671cb34ba7fac1a717a89229a808808907da1", "filename": "libphobos/libdruntime/core/runtime.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fruntime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fruntime.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -4,7 +4,7 @@\n  * Copyright: Copyright Sean Kelly 2005 - 2009.\n  * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n  * Authors:   Sean Kelly\n- * Source:    $(LINK2 https://github.com/dlang/druntime/blob/master/src/core/runtime.d, _runtime.d)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/druntime/src/core/runtime.d, _runtime.d)\n  * Documentation: https://dlang.org/phobos/core_runtime.html\n  */\n "}, {"sha": "c992a5ff0de1c13fd28a672902252e9fb90cf3ed", "filename": "libphobos/libdruntime/core/stdc/errno.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Ferrno.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -8,7 +8,7 @@\n  *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).\n  *    (See accompanying file LICENSE)\n  * Authors:   Sean Kelly, Alex R\u00f8nne Petersen\n- * Source:    https://github.com/dlang/druntime/blob/master/src/core/stdc/errno.d\n+ * Source:    https://github.com/dlang/dmd/blob/master/druntime/src/core/stdc/errno.d\n  * Standards: ISO/IEC 9899:1999 (E)\n  */\n "}, {"sha": "fc98350e139d7e2f9db9fdd5fb38486994b191df", "filename": "libphobos/libdruntime/core/stdc/stdio.d", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fstdio.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -9,7 +9,7 @@\n  *    (See accompanying file LICENSE)\n  * Authors:   Sean Kelly,\n  *            Alex R\u00f8nne Petersen\n- * Source:    https://github.com/dlang/druntime/blob/master/src/core/stdc/stdio.d\n+ * Source:    https://github.com/dlang/dmd/blob/master/druntime/src/core/stdc/stdio.d\n  * Standards: ISO/IEC 9899:1999 (E)\n  */\n \n@@ -1286,6 +1286,57 @@ version (MinGW)\n     ///\n     alias __mingw_scanf scanf;\n }\n+else version (CRuntime_Glibc)\n+{\n+    ///\n+    pragma(printf)\n+    int fprintf(FILE* stream, scope const char* format, scope const ...);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_fscanf(FILE* stream, scope const char* format, scope ...);\n+    ///\n+    alias fscanf = __isoc99_fscanf;\n+    ///\n+    pragma(printf)\n+    int sprintf(scope char* s, scope const char* format, scope const ...);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_sscanf(scope const char* s, scope const char* format, scope ...);\n+    ///\n+    alias sscanf = __isoc99_sscanf;\n+    ///\n+    pragma(printf)\n+    int vfprintf(FILE* stream, scope const char* format, va_list arg);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_vfscanf(FILE* stream, scope const char* format, va_list arg);\n+    ///\n+    alias vfscanf = __isoc99_vfscanf;\n+    ///\n+    pragma(printf)\n+    int vsprintf(scope char* s, scope const char* format, va_list arg);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_vsscanf(scope const char* s, scope const char* format, va_list arg);\n+    ///\n+    alias vsscanf = __isoc99_vsscanf;\n+    ///\n+    pragma(printf)\n+    int vprintf(scope const char* format, va_list arg);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_vscanf(scope const char* format, va_list arg);\n+    ///\n+    alias vscanf = __isoc99_vscanf;\n+    ///\n+    pragma(printf)\n+    int printf(scope const char* format, scope const ...);\n+    ///\n+    pragma(scanf)\n+    int __isoc99_scanf(scope const char* format, scope ...);\n+    ///\n+    alias scanf = __isoc99_scanf;\n+}\n else\n {\n     ///"}, {"sha": "d0870290854f9a06e9680c8c1fd7e3b8a203a78a", "filename": "libphobos/libdruntime/core/stdc/wchar_.d", "status": "modified", "additions": 66, "deletions": 24, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fstdc%2Fwchar_.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -127,30 +127,72 @@ alias wchar_t wint_t;\n ///\n enum wchar_t WEOF = 0xFFFF;\n \n-///\n-int fwprintf(FILE* stream, const scope wchar_t* format, scope const ...);\n-///\n-int fwscanf(FILE* stream, const scope wchar_t* format, scope ...);\n-///\n-int swprintf(wchar_t* s, size_t n, const scope wchar_t* format, scope const ...);\n-///\n-int swscanf(const scope wchar_t* s, const scope wchar_t* format, scope ...);\n-///\n-int vfwprintf(FILE* stream, const scope wchar_t* format, va_list arg);\n-///\n-int vfwscanf(FILE* stream, const scope wchar_t* format, va_list arg);\n-///\n-int vswprintf(wchar_t* s, size_t n, const scope wchar_t* format, va_list arg);\n-///\n-int vswscanf(const scope wchar_t* s, const scope wchar_t* format, va_list arg);\n-///\n-int vwprintf(const scope wchar_t* format, va_list arg);\n-///\n-int vwscanf(const scope wchar_t* format, va_list arg);\n-///\n-int wprintf(const scope wchar_t* format, scope const ...);\n-///\n-int wscanf(const scope wchar_t* format, scope ...);\n+version (CRuntime_Glibc)\n+{\n+    ///\n+    int fwprintf(FILE* stream, const scope wchar_t* format, scope const ...);\n+    ///\n+    int __isoc99_fwscanf(FILE* stream, const scope wchar_t* format, scope ...);\n+    ///\n+    alias fwscanf = __isoc99_fwscanf;\n+    ///\n+    int swprintf(wchar_t* s, size_t n, const scope wchar_t* format, scope const ...);\n+    ///\n+    int __isoc99_swscanf(const scope wchar_t* s, const scope wchar_t* format, scope ...);\n+    ///\n+    alias swscanf = __isoc99_swscanf;\n+    ///\n+    int vfwprintf(FILE* stream, const scope wchar_t* format, va_list arg);\n+    ///\n+    int __isoc99_vfwscanf(FILE* stream, const scope wchar_t* format, va_list arg);\n+    ///\n+    alias vfwscanf = __isoc99_vfwscanf;\n+    ///\n+    int vswprintf(wchar_t* s, size_t n, const scope wchar_t* format, va_list arg);\n+    ///\n+    int __isoc99_vswscanf(const scope wchar_t* s, const scope wchar_t* format, va_list arg);\n+    ///\n+    alias vswscanf = __isoc99_vswscanf;\n+    ///\n+    int vwprintf(const scope wchar_t* format, va_list arg);\n+    ///\n+    int __isoc99_vwscanf(const scope wchar_t* format, va_list arg);\n+    ///\n+    alias vwscanf = __isoc99_vwscanf;\n+    ///\n+    int wprintf(const scope wchar_t* format, scope const ...);\n+    ///\n+    int __isoc99_wscanf(const scope wchar_t* format, scope ...);\n+    ///\n+    alias wscanf = __isoc99_wscanf;\n+}\n+else\n+{\n+    ///\n+    int fwprintf(FILE* stream, const scope wchar_t* format, scope const ...);\n+    ///\n+    int fwscanf(FILE* stream, const scope wchar_t* format, scope ...);\n+    ///\n+    int swprintf(wchar_t* s, size_t n, const scope wchar_t* format, scope const ...);\n+    ///\n+    int swscanf(const scope wchar_t* s, const scope wchar_t* format, scope ...);\n+    ///\n+    int vfwprintf(FILE* stream, const scope wchar_t* format, va_list arg);\n+    ///\n+    int vfwscanf(FILE* stream, const scope wchar_t* format, va_list arg);\n+    ///\n+    int vswprintf(wchar_t* s, size_t n, const scope wchar_t* format, va_list arg);\n+    ///\n+    int vswscanf(const scope wchar_t* s, const scope wchar_t* format, va_list arg);\n+    ///\n+    int vwprintf(const scope wchar_t* format, va_list arg);\n+    ///\n+    int vwscanf(const scope wchar_t* format, va_list arg);\n+    ///\n+    int wprintf(const scope wchar_t* format, scope const ...);\n+    ///\n+    int wscanf(const scope wchar_t* format, scope ...);\n+}\n \n // No unsafe pointer manipulation.\n @trusted"}, {"sha": "dc42a2dc450d2b772e8be7b6d7cf13d081ca1b3e", "filename": "libphobos/libdruntime/core/sys/darwin/mach/getsect.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fgetsect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fgetsect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdarwin%2Fmach%2Fgetsect.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -468,4 +468,3 @@ const(section)* getsectbynamefromheaderwithswap_64(\n     const scope char* section,\n     int fSwap\n );\n-"}, {"sha": "1a85ba606a19b859ee5e5eda7f49cbacbfc60385", "filename": "libphobos/libdruntime/core/sys/dragonflybsd/string.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fdragonflybsd%2Fstring.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -19,4 +19,3 @@ static if (__BSD_VISIBLE)\n {\n     pure void* memmem(return scope const void* haystack, size_t haystacklen, scope const void* needle, size_t needlelen);\n }\n-"}, {"sha": "4b56229687c74bbbd45e2c7def464691b4d647c2", "filename": "libphobos/libdruntime/core/sys/linux/sys/time.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Ftime.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -65,4 +65,3 @@ extern (D) pure @safe @nogc nothrow {\n     }\n \n }\n-"}, {"sha": "6446ff8b9a303eff97967b0067f3874f66b0c961", "filename": "libphobos/libdruntime/core/sys/linux/sys/xattr.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fxattr.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fxattr.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Fsys%2Fxattr.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -66,4 +66,3 @@ ssize_t flistxattr (int __fd, char *list, size_t size);\n int removexattr (const scope char *path, const scope char *name);\n int lremovexattr (const scope char *path, const scope char *name);\n int fremovexattr (int fd, const scope char *name);\n-"}, {"sha": "4d5d886269a7cfa667f78dbef2ea587a8432fa40", "filename": "libphobos/libdruntime/core/sys/linux/tipc.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ftipc.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ftipc.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Flinux%2Ftipc.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -208,4 +208,3 @@ enum: int\n         TIPC_DEST_DROPPABLE = 129,\n         TIPC_CONN_TIMEOUT   = 130,\n }\n-"}, {"sha": "542e83a1679d267cd525f89ed7b08e1c5fffc0e6", "filename": "libphobos/libdruntime/core/sys/posix/signal.d", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsignal.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -14,7 +14,7 @@ module core.sys.posix.signal;\n import core.sys.posix.config;\n public import core.stdc.signal;\n public import core.sys.posix.sys.types; // for pid_t\n-//public import core.sys.posix.time;      // for timespec, now defined here\n+public import core.sys.posix.time; // for timespec\n \n version (OSX)\n     version = Darwin;\n@@ -2804,83 +2804,6 @@ else\n     static assert(false, \"Unsupported platform\");\n }\n \n-//\n-// Timer (TMR)\n-//\n-/*\n-NOTE: This should actually be defined in core.sys.posix.time.\n-      It is defined here instead to break a circular import.\n-\n-struct timespec\n-{\n-    time_t  tv_sec;\n-    int     tv_nsec;\n-}\n-*/\n-\n-version (linux)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (Darwin)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (FreeBSD)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (NetBSD)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (OpenBSD)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (DragonFlyBSD)\n-{\n-    struct timespec\n-    {\n-        time_t  tv_sec;\n-        c_long  tv_nsec;\n-    }\n-}\n-else version (Solaris)\n-{\n-    struct timespec\n-    {\n-        time_t tv_sec;\n-        c_long tv_nsec;\n-    }\n-\n-    alias timespec timestruc_t;\n-}\n-else\n-{\n-    static assert(false, \"Unsupported platform\");\n-}\n-\n //\n // Realtime Signals (RTS)\n //"}, {"sha": "206496261b098f157aadebf776d74c7730ff322f", "filename": "libphobos/libdruntime/core/sys/posix/spawn.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fspawn.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fspawn.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fspawn.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -4,7 +4,7 @@\n  * Copyright: Copyright (C) 2018 by The D Language Foundation, All Rights Reserved\n  * Authors:   Petar Kirov\n  * License:   $(LINK2 https://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)\n- * Source:    $(LINK2 https://github.com/dlang/druntime/blob/master/src/core/sys/posix/spawn.d, _spawn.d)\n+ * Source:    $(LINK2 https://github.com/dlang/dmd/blob/master/druntime/src/core/sys/posix/spawn.d, _spawn.d)\n  * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition\n  */\n module core.sys.posix.spawn;"}, {"sha": "d0d3d60ff468b9ed71428119028c89a834ebc34f", "filename": "libphobos/libdruntime/core/sys/posix/stdio.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fstdio.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -487,7 +487,7 @@ else version (CRuntime_Musl)\n \n version (HaveMemstream)\n {\n-    FILE*  fmemopen(const scope void* buf, in size_t size, const scope char* mode);\n+    FILE*  fmemopen(const scope void* buf, size_t size, const scope char* mode);\n     FILE*  open_memstream(char** ptr, size_t* sizeloc);\n     version (CRuntime_UClibc) {} else\n     FILE*  open_wmemstream(wchar_t** ptr, size_t* sizeloc);"}, {"sha": "925976d3e33c5ea2891a6a80b084c51d48540b3b", "filename": "libphobos/libdruntime/core/sys/posix/sys/select.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fsys%2Fselect.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -608,4 +608,3 @@ pure unittest\n         assert(!FD_ISSET(i, &fd));\n     }\n }\n-"}, {"sha": "ff3a3c46cd033a142807ee4396a41b03fd27ba66", "filename": "libphobos/libdruntime/core/sys/posix/time.d", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Ftime.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -167,9 +167,6 @@ else\n CLOCK_PROCESS_CPUTIME_ID (TMR|CPT)\n CLOCK_THREAD_CPUTIME_ID (TMR|TCT)\n \n-NOTE: timespec must be defined in core.sys.posix.signal to break\n-      a circular import.\n-\n struct timespec\n {\n     time_t  tv_sec;\n@@ -199,6 +196,69 @@ int timer_getoverrun(timer_t);\n int timer_settime(timer_t, int, const scope itimerspec*, itimerspec*);\n */\n \n+version (linux)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (Darwin)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (FreeBSD)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (NetBSD)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (OpenBSD)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (DragonFlyBSD)\n+{\n+    struct timespec\n+    {\n+        time_t  tv_sec;\n+        c_long  tv_nsec;\n+    }\n+}\n+else version (Solaris)\n+{\n+    struct timespec\n+    {\n+        time_t tv_sec;\n+        c_long tv_nsec;\n+    }\n+\n+    alias timespec timestruc_t;\n+}\n+else\n+{\n+    static assert(false, \"Unsupported platform\");\n+}\n+\n version (CRuntime_Glibc)\n {\n     enum CLOCK_PROCESS_CPUTIME_ID = 2;"}, {"sha": "e8c2f87bbd3740b117c10de815d9277836a3e95c", "filename": "libphobos/libdruntime/core/sys/posix/ucontext.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fposix%2Fucontext.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1628,4 +1628,3 @@ version (Solaris)\n     int addrtosymstr(uintptr_t, char*, int);\n     int printstack(int);\n }\n-"}, {"sha": "c56be3b00f832034726b5dba9952bf5936f7d9b2", "filename": "libphobos/libdruntime/core/sys/solaris/sys/priocntl.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fpriocntl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fpriocntl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fpriocntl.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -113,4 +113,3 @@ struct pcadmin_t\n     id_t    pc_cid;\n     caddr_t pc_cladmin;\n }\n-"}, {"sha": "8bd91157007b6d5daf579199d6990047f77867ee", "filename": "libphobos/libdruntime/core/sys/solaris/sys/procset.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fprocset.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fprocset.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fsolaris%2Fsys%2Fprocset.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -50,4 +50,3 @@ void setprocset(ref procset_t psp, idop_t op, idtype_t ltype, id_t lid, idtype_t\n     psp.p_ridtype = rtype;\n     psp.p_rid = rid;\n }\n-"}, {"sha": "d0a8fb9f08760d263e4e669d358a235558a428b8", "filename": "libphobos/libdruntime/core/sys/windows/cguid.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fcguid.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -10,4 +10,3 @@ module core.sys.windows.cguid;\n version (Windows):\n \n import core.sys.windows.basetyps;\n-"}, {"sha": "d8c5e95edbdcc7f24a0dcf632a0d0914ababa095", "filename": "libphobos/libdruntime/core/sys/windows/ntsecpkg.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fntsecpkg.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fntsecpkg.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fntsecpkg.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -444,4 +444,3 @@ alias NTSTATUS function(ULONG, PULONG,\n  PSECPKG_FUNCTION_TABLE *, PULONG) SpLsaModeInitializeFn;\n alias NTSTATUS function(ULONG, PULONG,\n  PSECPKG_USER_FUNCTION_TABLE *, PULONG) SpUserModeInitializeFn;\n-"}, {"sha": "b58c14ae1fee67e04ae0bc9206fac7e0ef9a8b98", "filename": "libphobos/libdruntime/core/sys/windows/olectlid.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Folectlid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Folectlid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Folectlid.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -10,4 +10,3 @@ module core.sys.windows.olectlid;\n version (Windows):\n \n import core.sys.windows.basetyps;\n-"}, {"sha": "e0c1af1045a1029af15598154cddefdef74c1107", "filename": "libphobos/libdruntime/core/sys/windows/shlguid.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fshlguid.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fshlguid.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fshlguid.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -16,4 +16,3 @@ import core.sys.windows.basetyps, core.sys.windows.w32api;\n \n // I think this is just a helper macro for other win32 headers?\n //MACRO #define DEFINE_SHLGUID(n,l,w1,w2) DEFINE_GUID(n,l,w1,w2,0xC0,0,0,0,0,0,0,0x46)\n-"}, {"sha": "21e982daa81b58109b79f2c005d5afaf43417478", "filename": "libphobos/libdruntime/core/sys/windows/sspi.d", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fsspi.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fsspi.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fcore%2Fsys%2Fwindows%2Fsspi.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -380,4 +380,3 @@ version (Unicode) {\n     alias QUERY_SECURITY_PACKAGE_INFO_FN_A QUERY_SECURITY_PACKAGE_INFO_FN;\n     alias INIT_SECURITY_INTERFACE_A INIT_SECURITY_INTERFACE;\n }\n-"}, {"sha": "8ef6548981f8f32c1db91b847765a91e6b36ea0a", "filename": "libphobos/libdruntime/object.d", "status": "modified", "additions": 3, "deletions": 337, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fobject.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Fobject.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Fobject.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -3765,6 +3765,7 @@ private size_t getArrayHash(const scope TypeInfo element, const scope void* ptr,\n     if (!is(const(T) : T))\n {\n     import core.internal.traits : Unconst;\n+    import core.internal.array.duplication : _dup;\n     static assert(is(T : Unconst!T), \"Cannot implicitly convert type \"~T.stringof~\n                   \" to \"~Unconst!T.stringof~\" in dup.\");\n \n@@ -3786,13 +3787,15 @@ private size_t getArrayHash(const scope TypeInfo element, const scope void* ptr,\n @property T[] dup(T)(const(T)[] a)\n     if (is(const(T) : T))\n {\n+    import core.internal.array.duplication : _dup;\n     return _dup!(const(T), T)(a);\n }\n \n \n /// Provide the .idup array property.\n @property immutable(T)[] idup(T)(T[] a)\n {\n+    import core.internal.array.duplication : _dup;\n     static assert(is(T : immutable(T)), \"Cannot implicitly convert type \"~T.stringof~\n                   \" to immutable in idup.\");\n     return _dup!(T, immutable(T))(a);\n@@ -3813,73 +3816,6 @@ private size_t getArrayHash(const scope TypeInfo element, const scope void* ptr,\n     assert(s == \"abc\");\n }\n \n-private U[] _dup(T, U)(scope T[] a) pure nothrow @trusted if (__traits(isPOD, T))\n-{\n-    if (__ctfe)\n-        return _dupCtfe!(T, U)(a);\n-\n-    import core.stdc.string : memcpy;\n-    auto arr = _d_newarrayU(typeid(T[]), a.length);\n-    memcpy(arr.ptr, cast(const(void)*) a.ptr, T.sizeof * a.length);\n-    return *cast(U[]*) &arr;\n-}\n-\n-private U[] _dupCtfe(T, U)(scope T[] a)\n-{\n-    static if (is(T : void))\n-        assert(0, \"Cannot dup a void[] array at compile time.\");\n-    else\n-    {\n-        U[] res;\n-        foreach (ref e; a)\n-            res ~= e;\n-        return res;\n-    }\n-}\n-\n-private U[] _dup(T, U)(T[] a) if (!__traits(isPOD, T))\n-{\n-    // note: copyEmplace is `@system` inside a `@trusted` block, so the __ctfe branch\n-    // has the extra duty to infer _dup `@system` when the copy-constructor is `@system`.\n-    if (__ctfe)\n-        return _dupCtfe!(T, U)(a);\n-\n-    import core.lifetime: copyEmplace;\n-    U[] res = () @trusted {\n-        auto arr = cast(U*) _d_newarrayU(typeid(T[]), a.length);\n-        size_t i;\n-        scope (failure)\n-        {\n-            import core.internal.lifetime: emplaceInitializer;\n-            // Initialize all remaining elements to not destruct garbage\n-            foreach (j; i .. a.length)\n-                emplaceInitializer(cast() arr[j]);\n-        }\n-        for (; i < a.length; i++)\n-        {\n-            copyEmplace(a.ptr[i], arr[i]);\n-        }\n-        return cast(U[])(arr[0..a.length]);\n-    } ();\n-\n-    return res;\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=22107\n-@safe unittest\n-{\n-    static int i;\n-    @safe struct S\n-    {\n-        this(this) { i++; }\n-    }\n-\n-    void fun(scope S[] values...) @safe\n-    {\n-        values.dup;\n-    }\n-}\n-\n // HACK:  This is a lie.  `_d_arraysetcapacity` is neither `nothrow` nor `pure`, but this lie is\n // necessary for now to prevent breaking code.\n private extern (C) size_t _d_arraysetcapacity(const TypeInfo ti, size_t newcapacity, void[]* arrptr) pure nothrow;\n@@ -4067,8 +4003,6 @@ auto ref inout(T[]) assumeSafeAppend(T)(auto ref inout(T[]) arr) nothrow @system\n     assert(is(typeof(b3) == immutable(int[])));\n }\n \n-private extern (C) void[] _d_newarrayU(const scope TypeInfo ti, size_t length) pure nothrow;\n-\n private void _doPostblit(T)(T[] arr)\n {\n     // infer static postblit type, run postblit if any\n@@ -4085,274 +4019,6 @@ private void _doPostblit(T)(T[] arr)\n     }\n }\n \n-@safe unittest\n-{\n-    static struct S1 { int* p; }\n-    static struct S2 { @disable this(); }\n-    static struct S3 { @disable this(this); }\n-\n-    int dg1() pure nothrow @safe\n-    {\n-        {\n-           char[] m;\n-           string i;\n-           m = m.dup;\n-           i = i.idup;\n-           m = i.dup;\n-           i = m.idup;\n-        }\n-        {\n-           S1[] m;\n-           immutable(S1)[] i;\n-           m = m.dup;\n-           i = i.idup;\n-           static assert(!is(typeof(m.idup)));\n-           static assert(!is(typeof(i.dup)));\n-        }\n-        {\n-            S3[] m;\n-            immutable(S3)[] i;\n-            static assert(!is(typeof(m.dup)));\n-            static assert(!is(typeof(i.idup)));\n-        }\n-        {\n-            shared(S1)[] m;\n-            m = m.dup;\n-            static assert(!is(typeof(m.idup)));\n-        }\n-        {\n-            int[] a = (inout(int)) { inout(const(int))[] a; return a.dup; }(0);\n-        }\n-        return 1;\n-    }\n-\n-    int dg2() pure nothrow @safe\n-    {\n-        {\n-           S2[] m = [S2.init, S2.init];\n-           immutable(S2)[] i = [S2.init, S2.init];\n-           m = m.dup;\n-           m = i.dup;\n-           i = m.idup;\n-           i = i.idup;\n-        }\n-        return 2;\n-    }\n-\n-    enum a = dg1();\n-    enum b = dg2();\n-    assert(dg1() == a);\n-    assert(dg2() == b);\n-}\n-\n-@system unittest\n-{\n-    static struct Sunpure { this(this) @safe nothrow {} }\n-    static struct Sthrow { this(this) @safe pure {} }\n-    static struct Sunsafe { this(this) @system pure nothrow {} }\n-    static struct Snocopy { @disable this(this); }\n-\n-    [].dup!Sunpure;\n-    [].dup!Sthrow;\n-    cast(void) [].dup!Sunsafe;\n-    static assert(!__traits(compiles, () pure    { [].dup!Sunpure; }));\n-    static assert(!__traits(compiles, () nothrow { [].dup!Sthrow; }));\n-    static assert(!__traits(compiles, () @safe   { [].dup!Sunsafe; }));\n-    static assert(!__traits(compiles, ()         { [].dup!Snocopy; }));\n-\n-    [].idup!Sunpure;\n-    [].idup!Sthrow;\n-    [].idup!Sunsafe;\n-    static assert(!__traits(compiles, () pure    { [].idup!Sunpure; }));\n-    static assert(!__traits(compiles, () nothrow { [].idup!Sthrow; }));\n-    static assert(!__traits(compiles, () @safe   { [].idup!Sunsafe; }));\n-    static assert(!__traits(compiles, ()         { [].idup!Snocopy; }));\n-}\n-\n-@safe unittest\n-{\n-    // test that the copy-constructor is called with .dup\n-    static struct ArrElem\n-    {\n-        int a;\n-        this(int a)\n-        {\n-            this.a = a;\n-        }\n-        this(ref const ArrElem)\n-        {\n-            a = 2;\n-        }\n-        this(ref ArrElem) immutable\n-        {\n-            a = 3;\n-        }\n-    }\n-\n-    auto arr = [ArrElem(1), ArrElem(1)];\n-\n-    ArrElem[] b = arr.dup;\n-    assert(b[0].a == 2 && b[1].a == 2);\n-\n-    immutable ArrElem[] c = arr.idup;\n-    assert(c[0].a == 3 && c[1].a == 3);\n-}\n-\n-@system unittest\n-{\n-    static struct Sunpure { this(ref const typeof(this)) @safe nothrow {} }\n-    static struct Sthrow { this(ref const typeof(this)) @safe pure {} }\n-    static struct Sunsafe { this(ref const typeof(this)) @system pure nothrow {} }\n-    [].dup!Sunpure;\n-    [].dup!Sthrow;\n-    cast(void) [].dup!Sunsafe;\n-    static assert(!__traits(compiles, () pure    { [].dup!Sunpure; }));\n-    static assert(!__traits(compiles, () nothrow { [].dup!Sthrow; }));\n-    static assert(!__traits(compiles, () @safe   { [].dup!Sunsafe; }));\n-\n-    // for idup to work on structs that have copy constructors, it is necessary\n-    // that the struct defines a copy constructor that creates immutable objects\n-    static struct ISunpure { this(ref const typeof(this)) immutable @safe nothrow {} }\n-    static struct ISthrow { this(ref const typeof(this)) immutable @safe pure {} }\n-    static struct ISunsafe { this(ref const typeof(this)) immutable @system pure nothrow {} }\n-    [].idup!ISunpure;\n-    [].idup!ISthrow;\n-    [].idup!ISunsafe;\n-    static assert(!__traits(compiles, () pure    { [].idup!ISunpure; }));\n-    static assert(!__traits(compiles, () nothrow { [].idup!ISthrow; }));\n-    static assert(!__traits(compiles, () @safe   { [].idup!ISunsafe; }));\n-}\n-\n-@safe unittest\n-{\n-    static int*[] pureFoo() pure { return null; }\n-    { char[] s; immutable x = s.dup; }\n-    { immutable x = (cast(int*[])null).dup; }\n-    { immutable x = pureFoo(); }\n-    { immutable x = pureFoo().dup; }\n-}\n-\n-@safe unittest\n-{\n-    auto a = [1, 2, 3];\n-    auto b = a.dup;\n-    debug(SENTINEL) {} else\n-        assert(b.capacity >= 3);\n-}\n-\n-@system unittest\n-{\n-    // Bugzilla 12580\n-    void[] m = [0];\n-    shared(void)[] s = [cast(shared)1];\n-    immutable(void)[] i = [cast(immutable)2];\n-\n-    s = s.dup;\n-    static assert(is(typeof(s.dup) == shared(void)[]));\n-\n-    m = i.dup;\n-    i = m.dup;\n-    i = i.idup;\n-    i = m.idup;\n-    i = s.idup;\n-    i = s.dup;\n-    static assert(!__traits(compiles, m = s.dup));\n-}\n-\n-@safe unittest\n-{\n-    // Bugzilla 13809\n-    static struct S\n-    {\n-        this(this) {}\n-        ~this() {}\n-    }\n-\n-    S[] arr;\n-    auto a = arr.dup;\n-}\n-\n-@system unittest\n-{\n-    // Bugzilla 16504\n-    static struct S\n-    {\n-        __gshared int* gp;\n-        int* p;\n-        // postblit and hence .dup could escape\n-        this(this) { gp = p; }\n-    }\n-\n-    int p;\n-    scope S[1] arr = [S(&p)];\n-    auto a = arr.dup; // dup does escape\n-}\n-\n-// https://issues.dlang.org/show_bug.cgi?id=21983\n-// dup/idup destroys partially constructed arrays on failure\n-@safe unittest\n-{\n-    static struct SImpl(bool postblit)\n-    {\n-        int num;\n-        long l = 0xDEADBEEF;\n-\n-        static if (postblit)\n-        {\n-            this(this)\n-            {\n-                if (this.num == 3)\n-                    throw new Exception(\"\");\n-            }\n-        }\n-        else\n-        {\n-            this(scope ref const SImpl other)\n-            {\n-                if (other.num == 3)\n-                    throw new Exception(\"\");\n-\n-                this.num = other.num;\n-                this.l = other.l;\n-            }\n-        }\n-\n-        ~this() @trusted\n-        {\n-            if (l != 0xDEADBEEF)\n-            {\n-                import core.stdc.stdio;\n-                printf(\"Unexpected value: %lld\\n\", l);\n-                fflush(stdout);\n-                assert(false);\n-            }\n-        }\n-    }\n-\n-    alias Postblit = SImpl!true;\n-    alias Copy = SImpl!false;\n-\n-    static int test(S)()\n-    {\n-        S[4] arr = [ S(1), S(2), S(3), S(4) ];\n-        try\n-        {\n-            arr.dup();\n-            assert(false);\n-        }\n-        catch (Exception)\n-        {\n-            return 1;\n-        }\n-    }\n-\n-    static assert(test!Postblit());\n-    assert(test!Postblit());\n-\n-    static assert(test!Copy());\n-    assert(test!Copy());\n-}\n-\n /**\n Destroys the given object and optionally resets to initial state. It's used to\n _destroy an object, calling its destructor or finalizer so it no longer"}, {"sha": "c1391b8538f0de9838eb1964a4543de2d3dabb7a", "filename": "libphobos/libdruntime/rt/dylib_fixes.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Frt%2Fdylib_fixes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Flibdruntime%2Frt%2Fdylib_fixes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Flibdruntime%2Frt%2Fdylib_fixes.c?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -25,4 +25,3 @@ __attribute__((destructor)) static void finalizer ()\n {\n     rt_term();\n }\n-"}, {"sha": "1f0cfbf3e29d57e74552b1cb8ad9704124e3a058", "filename": "libphobos/src/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2FMERGE?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,4 +1,4 @@\n-1516ecad932d88a1618163384e6f69009d125391\n+5748ca43fd5c3e31ce7a8511f542b67e5d5a3dc6\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/phobos repository."}, {"sha": "e6a10435d2bf144154f35499d460aade3544ace1", "filename": "libphobos/src/etc/c/curl.d", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fetc%2Fc%2Fcurl.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fetc%2Fc%2Fcurl.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fetc%2Fc%2Fcurl.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1372,9 +1372,9 @@ alias curl_TimeCond = int;\n /** curl_strequal() and curl_strnequal() are subject for removal in a future\n    libcurl, see lib/README.curlx for details */\n extern (C) {\n-int  curl_strequal(in const(char) *s1, in const(char) *s2);\n+int  curl_strequal(scope const(char) *s1, scope const(char) *s2);\n /// ditto\n-int  curl_strnequal(in const(char) *s1, in const(char) *s2, size_t n);\n+int  curl_strnequal(scope const(char) *s1, scope const(char) *s2, size_t n);\n }\n enum CurlForm {\n     nothing, /********** the first one is unused ************/\n@@ -1464,7 +1464,7 @@ CURLFORMcode  curl_formadd(curl_httppost **httppost, curl_httppost **last_post,.\n  * Should return the buffer length passed to it as the argument \"len\" on\n  *   success.\n  */\n-alias curl_formget_callback = size_t function(void *arg, in const(char) *buf, size_t len);\n+alias curl_formget_callback = size_t function(void *arg, const(char) *buf, size_t len);\n \n /**\n  * Name: curl_formget()\n@@ -1494,7 +1494,7 @@ void  curl_formfree(curl_httppost *form);\n  * Returns a malloc()'ed string that MUST be curl_free()ed after usage is\n  * complete. DEPRECATED - see lib/README.curlx\n  */\n-char * curl_getenv(in const(char) *variable);\n+char * curl_getenv(scope const(char) *variable);\n \n /**\n  * Name: curl_version()\n@@ -1514,10 +1514,10 @@ char * curl_version();\n  * %XX versions). This function returns a new allocated string or NULL if an\n  * error occurred.\n  */\n-char * curl_easy_escape(CURL *handle, in const(char) *string, int length);\n+char * curl_easy_escape(CURL *handle, scope const(char) *string, int length);\n \n /** the previous version: */\n-char * curl_escape(in const(char) *string, int length);\n+char * curl_escape(scope const(char) *string, int length);\n \n \n /**\n@@ -1531,10 +1531,10 @@ char * curl_escape(in const(char) *string, int length);\n  * Conversion Note: On non-ASCII platforms the ASCII %XX codes are\n  * converted into the host encoding.\n  */\n-char * curl_easy_unescape(CURL *handle, in const(char) *string, int length, int *outlength);\n+char * curl_easy_unescape(CURL *handle, scope const(char) *string, int length, int *outlength);\n \n /** the previous version */\n-char * curl_unescape(in const(char) *string, int length);\n+char * curl_unescape(scope const(char) *string, int length);\n \n /**\n  * Name: curl_free()\n@@ -1608,7 +1608,7 @@ struct curl_slist\n  * Appends a string to a linked list. If no list exists, it will be created\n  * first. Returns the new list, after appending.\n  */\n-curl_slist * curl_slist_append(curl_slist *, in const(char) *);\n+curl_slist * curl_slist_append(curl_slist *, const(char) *);\n \n /**\n  * Name: curl_slist_free_all()"}, {"sha": "b810fbb92582c55600c55bb2d6f713d5a45ce277", "filename": "libphobos/src/std/algorithm/comparison.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fcomparison.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1027,7 +1027,7 @@ template equal(alias pred = \"a == b\")\n         }\n     }\n \n-    private bool equalLoop(Rs...)(Rs rs)\n+    private bool equalLoop(Rs...)(ref Rs rs)\n     {\n         for (; !rs[0].empty; rs[0].popFront)\n             static foreach (r; rs[1 .. $])"}, {"sha": "300a8978fe513ec1a030226cd2da834d84cf6a43", "filename": "libphobos/src/std/algorithm/iteration.d", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fiteration.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1263,19 +1263,22 @@ public:\n \n // filter\n /**\n-Implements the higher order filter function. The predicate is passed to\n-$(REF unaryFun, std,functional), and can either accept a string, or any callable\n-that can be executed via `pred(element)`.\n+`filter!(predicate)(range)` returns a new range containing only elements `x` in `range` for\n+which `predicate(x)` returns `true`.\n+\n+The predicate is passed to $(REF unaryFun, std,functional), and can be either a string, or\n+any callable that can be executed via `pred(element)`.\n \n Params:\n     predicate = Function to apply to each element of range\n \n Returns:\n-    `filter!(predicate)(range)` returns a new range containing only elements `x` in `range` for\n-    which `predicate(x)` returns `true`.\n+    An input range that contains the filtered elements. If `range` is at least a forward range, the return value of `filter`\n+    will also be a forward range.\n \n See_Also:\n-    $(HTTP en.wikipedia.org/wiki/Filter_(higher-order_function), Filter (higher-order function))\n+    $(HTTP en.wikipedia.org/wiki/Filter_(higher-order_function), Filter (higher-order function)),\n+    $(REF filterBidirectional, std,algorithm,iteration)\n  */\n template filter(alias predicate)\n if (is(typeof(unaryFun!predicate)))"}, {"sha": "daa4b99045e7acd73ec11b5873cbfded4abe7cfb", "filename": "libphobos/src/std/algorithm/searching.d", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Falgorithm%2Fsearching.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2512,6 +2512,8 @@ RandomAccessRange find(RandomAccessRange, alias pred, InputRange)(\n Convenience function. Like find, but only returns whether or not the search\n was successful.\n \n+For more information about `pred` see $(LREF find).\n+\n See_Also:\n $(REF among, std,algorithm,comparison) for checking a value against multiple possibilities.\n  +/\n@@ -2622,6 +2624,8 @@ Advances `r` until it finds the first two adjacent elements `a`,\n `b` that satisfy `pred(a, b)`. Performs $(BIGOH r.length)\n evaluations of `pred`.\n \n+For more information about `pred` see $(LREF find).\n+\n Params:\n     pred = The predicate to satisfy.\n     r = A $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives) to\n@@ -2698,6 +2702,8 @@ Advances `seq` by calling `seq.popFront` until either\n `find!(pred)(choices, seq.front)` is `true`, or `seq` becomes empty.\n Performs $(BIGOH seq.length * choices.length) evaluations of `pred`.\n \n+For more information about `pred` see $(LREF find).\n+\n Params:\n     pred = The predicate to use for determining a match.\n     seq = The $(REF_ALTTEXT input range, isInputRange, std,range,primitives) to\n@@ -2758,6 +2764,8 @@ if (isInputRange!InputRange && isForwardRange!ForwardRange)\n  * Similarly, the haystack is positioned so as `pred` evaluates to `false` for\n  * `haystack.front`.\n  *\n+ * For more information about `pred` see $(LREF find).\n+\n  * Params:\n  *  haystack = The\n  *   $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives) to search\n@@ -2882,6 +2890,8 @@ $(REF_ALTTEXT forward range, isForwardRange, std,range,primitives) and\n the type of `result[0]` and `result[1]` is the same as $(REF takeExactly,\n std,range).\n \n+For more information about `pred` see $(LREF find).\n+\n Params:\n     pred = Predicate to use for comparing needle against haystack.\n     haystack = The range to search.\n@@ -4595,6 +4605,8 @@ $(REF_ALTTEXT input range, isInputRange, std,range,primitives) starts with (one\n of) the given needle(s) or, if no needles are given,\n if its front element fulfils predicate `pred`.\n \n+For more information about `pred` see $(LREF find).\n+\n Params:\n \n     pred = Predicate to use in comparing the elements of the haystack and the"}, {"sha": "9164e0798659bd05cef9dca5b080920be963b4ae", "filename": "libphobos/src/std/conv.d", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fconv.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fconv.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fconv.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -3419,17 +3419,20 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         }\n     }\n \n+    Target result = cast(Target) (sign ? -ldval : ldval);\n+\n     // if overflow occurred\n-    enforce(ldval != real.infinity, new ConvException(\"Range error\"));\n+    import std.math : isFinite;\n+    enforce(isFinite(result), new ConvException(\"Range error\"));\n \n     advanceSource();\n     static if (doCount)\n     {\n-        return tuple!(\"data\", \"count\")(cast (Target) (sign ? -ldval : ldval), count);\n+        return tuple!(\"data\", \"count\")(result, count);\n     }\n     else\n     {\n-        return cast (Target) (sign ? -ldval : ldval);\n+        return result;\n     }\n }\n \n@@ -3785,6 +3788,16 @@ if (isInputRange!Source && isSomeChar!(ElementType!Source) && !is(Source == enum\n         assertThrown!ConvException(parse!double(s));\n }\n \n+@safe unittest // https://issues.dlang.org/show_bug.cgi?id=22637\n+{\n+    import std.exception : assertThrown, assertNotThrown;\n+    auto src = \"9991232549867999698999493543521458974414359998784641646846435132132543645435456345634541999999999999999\"\n+    ~ \"9999999943321231321311999231345312413646846354354354399999934153465464654646464654134135354199999999996515734999\"\n+    ~ \"9999999320135273486741354354731567431324134999999999999999999999999999999999999999999999135411.9\";\n+    assertThrown!ConvException(parse!double(src));\n+    static if (real.max_10_exp > 310) assertNotThrown!ConvException(parse!real(src));\n+}\n+\n /**\n Parsing one character off a range returns the first element and calls `popFront`.\n "}, {"sha": "2be5a2ea150f2c9a3505928e05a5f109a99d0072", "filename": "libphobos/src/std/experimental/checkedint.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Fcheckedint.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1,6 +1,6 @@\n \n /**\n- * This module is now deprecated, use $(MREF std, experimental)\n+ * This module is now deprecated, use $(MREF std, checkedint)\n  * instead.\n  *\n  * Copyright: Copyright The D Language Foundation 2005 - 2015."}, {"sha": "f3c69324ba1daa0e229752e3868c5fa0b192a50b", "filename": "libphobos/src/std/experimental/logger/core.d", "status": "modified", "additions": 123, "deletions": 53, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fcore.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -4,6 +4,7 @@ Source: $(PHOBOSSRC std/experimental/logger/core.d)\n */\n module std.experimental.logger.core;\n \n+import core.atomic : atomicLoad, atomicOp, atomicStore, MemoryOrder;\n import core.sync.mutex : Mutex;\n import std.datetime.date : DateTime;\n import std.datetime.systime : Clock, SysTime;\n@@ -555,14 +556,14 @@ abstract class Logger\n     Params:\n          lv = `LogLevel` to use for this `Logger` instance.\n     */\n-    this(LogLevel lv) @safe\n+    this(this This)(LogLevel lv)\n     {\n         this.logLevel_ = lv;\n         this.fatalHandler_ = delegate() {\n             throw new Error(\"A fatal log message was logged\");\n         };\n \n-        this.mutex = new Mutex();\n+        this.mutex = new typeof(mutex)();\n     }\n \n     /** A custom logger must implement this method in order to work in a\n@@ -661,7 +662,7 @@ abstract class Logger\n     /// Ditto\n     @property final void logLevel(const LogLevel lv) @safe @nogc\n     {\n-        synchronized (mutex) this.logLevel_ = lv;\n+        atomicStore(this.logLevel_, lv);\n     }\n \n     /** This `delegate` is called in case a log message with\n@@ -1403,28 +1404,28 @@ abstract class Logger\n \n // Thread Global\n \n-private __gshared Logger stdSharedDefaultLogger;\n+private shared Logger stdSharedDefaultLogger;\n private shared Logger stdSharedLogger;\n private shared LogLevel stdLoggerGlobalLogLevel = LogLevel.all;\n \n /* This method returns the global default Logger.\n  * Marked @trusted because of excessive reliance on __gshared data\n  */\n-private @property Logger defaultSharedLoggerImpl() @trusted\n+private @property shared(Logger) defaultSharedLoggerImpl() @trusted\n {\n     import core.lifetime : emplace;\n     import std.stdio : stderr;\n \n     __gshared align(__traits(classInstanceAlignment, FileLogger))\n-        void[__traits(classInstanceSize, FileLogger)] _buffer;\n+        void[__traits(classInstanceSize, FileLogger)] _buffer = void;\n \n     import std.concurrency : initOnce;\n     initOnce!stdSharedDefaultLogger({\n         auto buffer = cast(ubyte[]) _buffer;\n-        return emplace!FileLogger(buffer, stderr, LogLevel.info);\n+        return cast(shared) emplace!(FileLogger)(buffer, stderr, LogLevel.info);\n     }());\n \n-    return stdSharedDefaultLogger;\n+    return atomicLoad(stdSharedDefaultLogger);\n }\n \n /** This property sets and gets the default `Logger`. Unless set to another\n@@ -1452,19 +1453,12 @@ if (sharedLog !is myLogger)\n     sharedLog = new myLogger;\n -------------\n */\n-@property Logger sharedLog() @safe\n+@property shared(Logger) sharedLog() @safe\n {\n-    static auto trustedLoad(ref shared Logger logger) @trusted\n-    {\n-        import core.atomic : atomicLoad, MemoryOrder;\n-        return cast() atomicLoad!(MemoryOrder.acq)(logger);\n-            //FIXME: Casting shared away here. Not good. See issue 16232.\n-    }\n-\n     // If we have set up our own logger use that\n-    if (auto logger = trustedLoad(stdSharedLogger))\n+    if (auto logger = atomicLoad!(MemoryOrder.seq)(stdSharedLogger))\n     {\n-        return logger;\n+        return atomicLoad(logger);\n     }\n     else\n     {\n@@ -1474,10 +1468,9 @@ if (sharedLog !is myLogger)\n }\n \n /// Ditto\n-@property void sharedLog(Logger logger) @trusted\n+@property void sharedLog(shared(Logger) logger) @safe\n {\n-    import core.atomic : atomicStore, MemoryOrder;\n-    atomicStore!(MemoryOrder.rel)(stdSharedLogger, cast(shared) logger);\n+    atomicStore!(MemoryOrder.seq)(stdSharedLogger, atomicLoad(logger));\n }\n \n /** This methods get and set the global `LogLevel`.\n@@ -1523,9 +1516,12 @@ class StdForwardLogger : Logger\n         this.fatalHandler = delegate() {};\n     }\n \n-    override protected void writeLogMsg(ref LogEntry payload)\n+    override protected void writeLogMsg(ref LogEntry payload) @trusted\n     {\n-          sharedLog.forwardMsg(payload);\n+        synchronized (sharedLog.mutex)\n+        {\n+            (cast() sharedLog).forwardMsg(payload);\n+        }\n     }\n }\n \n@@ -1535,6 +1531,40 @@ class StdForwardLogger : Logger\n     auto nl1 = new StdForwardLogger(LogLevel.all);\n }\n \n+@safe unittest\n+{\n+    import core.thread : Thread, msecs;\n+\n+    static class RaceLogger : Logger\n+    {\n+        int value;\n+        this() @safe shared\n+        {\n+            super(LogLevel.init);\n+        }\n+        override void writeLogMsg(ref LogEntry payload) @safe\n+        {\n+            import core.thread : Thread, msecs;\n+            if (payload.msg == \"foo\")\n+            {\n+                value = 42;\n+                () @trusted { Thread.sleep(100.msecs); }();\n+                assert(value == 42, \"Another thread changed the value\");\n+            }\n+            else\n+            {\n+                () @trusted { Thread.sleep(50.msecs); } ();\n+                value = 13;\n+            }\n+        }\n+    }\n+\n+    sharedLog = new shared RaceLogger;\n+    scope(exit) { sharedLog = null; }\n+    () @trusted { new Thread(() { log(\"foo\"); }).start(); }();\n+    log(\"bar\");\n+}\n+\n /** This `LogLevel` is unqiue to every thread.\n \n The thread local `Logger` will use this `LogLevel` to filter log calls\n@@ -1561,7 +1591,7 @@ private @property Logger stdThreadLocalLogImpl() @trusted\n }\n \n /** This function returns a thread unique `Logger`, that by default\n-propergates all data logged to it to the `sharedLog`.\n+propagates all data logged to it to the `sharedLog`.\n \n These properties can be used to set and get this `Logger`. Every\n modification to this `Logger` will only be visible in the thread the\n@@ -1671,10 +1701,12 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     auto oldunspecificLogger = sharedLog;\n     scope(exit) {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n     }\n \n-    sharedLog = tl1;\n+    () @trusted {\n+        sharedLog = cast(shared) tl1;\n+    }();\n \n     log();\n     assert(tl1.line == __LINE__ - 1);\n@@ -1793,22 +1825,34 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n     assert(l.line == lineNumber);\n     assert(l.logLevel == LogLevel.all);\n \n-    auto oldunspecificLogger = sharedLog;\n+    Logger oldunspecificLogger;\n+    () @trusted {\n+        oldunspecificLogger = cast() sharedLog;\n+    }();\n \n     assert(oldunspecificLogger.logLevel == LogLevel.info,\n          to!string(oldunspecificLogger.logLevel));\n \n     assert(l.logLevel == LogLevel.all);\n-    sharedLog = l;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) l;\n+    }();\n+\n     assert(globalLogLevel == LogLevel.all,\n             to!string(globalLogLevel));\n \n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        () @trusted {\n+            sharedLog = atomicLoad(cast(shared) oldunspecificLogger);\n+        }();\n     }\n \n-    assert(sharedLog.logLevel == LogLevel.all);\n+    () @trusted {\n+        assert((cast() sharedLog).logLevel == LogLevel.all);\n+    }();\n+\n     assert(stdThreadLocalLog.logLevel == LogLevel.all);\n     assert(globalLogLevel == LogLevel.all);\n \n@@ -1880,13 +1924,14 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n     string filename = deleteme ~ __FUNCTION__ ~ \".tempLogFile\";\n     FileLogger l = new FileLogger(filename);\n     auto oldunspecificLogger = sharedLog;\n-    sharedLog = l;\n+\n+    sharedLog = cast(shared) l;\n \n     scope(exit)\n     {\n         remove(filename);\n         assert(!exists(filename));\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n@@ -1923,16 +1968,19 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n     scope(exit)\n     {\n         remove(filename);\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n     string notWritten = \"this should not be written to file\";\n     string written = \"this should be written to file\";\n \n     auto l = new FileLogger(filename);\n-    sharedLog = l;\n-    sharedLog.logLevel = LogLevel.critical;\n+    sharedLog = cast(shared) l;\n+\n+    () @trusted {\n+        (cast() sharedLog).logLevel = LogLevel.critical;\n+    }();\n \n     log(LogLevel.error, false, notWritten);\n     log(LogLevel.critical, true, written);\n@@ -1974,11 +2022,14 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     auto mem = new TestLogger;\n     mem.fatalHandler = delegate() {};\n-    sharedLog = mem;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) mem;\n+    }();\n \n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n@@ -2221,11 +2272,14 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     auto mem = new TestLogger;\n     mem.fatalHandler = delegate() {};\n-    sharedLog = mem;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) mem;\n+    }();\n \n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n@@ -2477,10 +2531,13 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     stdThreadLocalLog.logLevel = LogLevel.all;\n \n-    sharedLog = mem;\n+    () @trusted {\n+        sharedLog = cast(shared) mem;\n+    }();\n+\n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n@@ -2707,12 +2764,15 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n     auto tl = new TestLogger(LogLevel.info);\n-    sharedLog = tl;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) tl;\n+    }();\n \n     trace(\"trace\");\n     assert(tl.msg.indexOf(\"trace\") == -1);\n@@ -2730,15 +2790,18 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n \n     scope(exit)\n     {\n-        sharedLog = oldunspecificLogger;\n+        sharedLog = atomicLoad(oldunspecificLogger);\n         globalLogLevel = LogLevel.all;\n     }\n \n     auto logger = new MultiLogger(LogLevel.error);\n \n     auto tl = new TestLogger(LogLevel.info);\n     logger.insertLogger(\"required\", tl);\n-    sharedLog = logger;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) logger;\n+    }();\n \n     trace(\"trace\");\n     assert(tl.msg.indexOf(\"trace\") == -1);\n@@ -2774,22 +2837,20 @@ version (StdUnittest) private void testFuncNames(Logger logger) @safe\n // Workaround for atomics not allowed in @safe code\n private auto trustedLoad(T)(ref shared T value) @trusted\n {\n-    import core.atomic : atomicLoad, MemoryOrder;\n     return atomicLoad!(MemoryOrder.acq)(value);\n }\n \n // ditto\n private void trustedStore(T)(ref shared T dst, ref T src) @trusted\n {\n-    import core.atomic : atomicStore, MemoryOrder;\n     atomicStore!(MemoryOrder.rel)(dst, src);\n }\n \n // check that thread-local logging does not propagate\n // to shared logger\n @system unittest\n {\n-    import core.atomic, core.thread, std.concurrency;\n+    import core.thread, std.concurrency;\n \n     static shared logged_count = 0;\n \n@@ -2826,10 +2887,13 @@ private void trustedStore(T)(ref shared T dst, ref T src) @trusted\n     auto oldSharedLog = sharedLog;\n     scope(exit)\n     {\n-        sharedLog = oldSharedLog;\n+        sharedLog = atomicLoad(oldSharedLog);\n     }\n \n-    sharedLog = new IgnoredLog;\n+    () @trusted {\n+        sharedLog = cast(shared) new IgnoredLog;\n+    }();\n+\n     Thread[] spawned;\n \n     foreach (i; 0 .. 4)\n@@ -2849,7 +2913,9 @@ private void trustedStore(T)(ref shared T dst, ref T src) @trusted\n \n @safe unittest\n {\n-    auto dl = cast(FileLogger) sharedLog;\n+    auto dl = () @trusted {\n+        return cast(FileLogger) cast() sharedLog;\n+    }();\n     assert(dl !is null);\n     assert(dl.logLevel == LogLevel.info);\n     assert(globalLogLevel == LogLevel.all);\n@@ -2946,7 +3012,7 @@ private void trustedStore(T)(ref shared T dst, ref T src) @trusted\n     auto oldShared = sharedLog;\n     scope(exit)\n     {\n-        sharedLog = oldShared;\n+        sharedLog = atomicLoad(oldShared);\n         if (exists(fn))\n         {\n             remove(fn);\n@@ -2956,7 +3022,11 @@ private void trustedStore(T)(ref shared T dst, ref T src) @trusted\n     auto ts = [ \"Test log 1\", \"Test log 2\", \"Test log 3\"];\n \n     auto fl = new FileLogger(fn);\n-    sharedLog = fl;\n+\n+    () @trusted {\n+        sharedLog = cast(shared) fl;\n+    }();\n+\n     assert(exists(fn));\n \n     foreach (t; ts)"}, {"sha": "457012e21b53ef6316ee7c5003a9c09812d52b27", "filename": "libphobos/src/std/experimental/logger/filelogger.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Ffilelogger.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -259,7 +259,7 @@ class FileLogger : Logger\n     file.close();\n }\n \n-@safe unittest\n+@system unittest\n {\n     auto dl = cast(FileLogger) sharedLog;\n     assert(dl !is null);"}, {"sha": "3593690196449219389cc16e2b673af6c4ac3e98", "filename": "libphobos/src/std/experimental/logger/multilogger.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fexperimental%2Flogger%2Fmultilogger.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -187,7 +187,7 @@ class MultiLogger : Logger\n     assert(line.indexOf(iMsg) != -1, line ~ \":\" ~ tMsg);\n }\n \n-@safe unittest\n+@system unittest\n {\n     auto dl = cast(FileLogger) sharedLog;\n     assert(dl !is null);"}, {"sha": "d6cac41ef04cc2bf348053e4ca75112ccf954ad0", "filename": "libphobos/src/std/file.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Ffile.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Ffile.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ffile.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1510,7 +1510,7 @@ private\n         ushort bitmapcount, reserved;\n         attrgroup_t commonattr, volattr, dirattr, fileattr, forkattr;\n     }\n-    extern(C) int setattrlist(in char* path, scope ref attrlist attrs,\n+    extern(C) int setattrlist(scope const(char)* path, scope ref attrlist attrs,\n         scope void* attrbuf, size_t attrBufSize, c_ulong options) nothrow @nogc @system;\n }\n "}, {"sha": "2fd6ff729906de86f9b9e62df8ffcc09ac595c35", "filename": "libphobos/src/std/format/internal/write.d", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Finternal%2Fwrite.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1337,7 +1337,7 @@ if (is(StringTypeOf!T) && !is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToSt\n /*\n     Static-size arrays are formatted as dynamic arrays.\n  */\n-void formatValueImpl(Writer, T, Char)(auto ref Writer w, auto ref const(T) obj,\n+void formatValueImpl(Writer, T, Char)(auto ref Writer w, auto ref T obj,\n     scope const ref FormatSpec!Char f)\n if (is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n {\n@@ -1782,13 +1782,13 @@ void formatChar(Writer)(ref Writer w, in dchar c, in char quote)\n     Associative arrays are formatted by using `':'` and $(D \", \") as\n     separators, and enclosed by `'['` and `']'`.\n  */\n-void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)\n+void formatValueImpl(Writer, T, Char)(auto ref Writer w, T obj, scope const ref FormatSpec!Char f)\n if (is(AssocArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))\n {\n     import std.format : enforceFmt, formatValue;\n     import std.range.primitives : put;\n \n-    AssocArrayTypeOf!(const(T)) val = obj;\n+    AssocArrayTypeOf!T val = obj;\n     const spec = f.spec;\n \n     enforceFmt(spec == 's' || spec == '(',"}, {"sha": "3f6f33adf6e9fc326fb628a6f4b937b84eb334a0", "filename": "libphobos/src/std/format/package.d", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fformat%2Fpackage.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1356,6 +1356,30 @@ if (isSomeChar!Char)\n     assert(result == \"    1\");\n }\n \n+// https://issues.dlang.org/show_bug.cgi?id=23245\n+@safe unittest\n+{\n+    static struct S\n+    {\n+        string toString() { return \"S\"; }\n+    }\n+\n+    S[1] s;\n+    assert(format(\"%s\", s) == \"[S]\");\n+}\n+\n+// https://issues.dlang.org/show_bug.cgi?id=23246\n+@safe unittest\n+{\n+    static struct S\n+    {\n+        string toString() { return \"S\"; }\n+    }\n+\n+    S[int] s = [0 : S()];\n+    assert(format(\"%s\", s) == \"[0:S]\");\n+}\n+\n /// ditto\n typeof(fmt) format(alias fmt, Args...)(Args args)\n if (isSomeString!(typeof(fmt)))"}, {"sha": "19982ec216a5c00a065af3ced7e5893d2a9ea313", "filename": "libphobos/src/std/math/package.d", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fmath%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fmath%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath%2Fpackage.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -383,6 +383,7 @@ template floatTraits(T)\n             enum ushort EXPBIAS = 0x3FE0;\n             enum uint EXPMASK_INT = 0x7FF0_0000;\n             enum uint MANTISSAMASK_INT = 0x000F_FFFF; // for the MSB only\n+            enum ulong MANTISSAMASK_LONG = 0x000F_FFFF_FFFF_FFFF;\n             enum realFormat = RealFormat.ieeeDouble;\n             version (LittleEndian)\n             {"}, {"sha": "7dbe89b2deeff0c91ec5ba0960c41cbc4094d2b9", "filename": "libphobos/src/std/math/rounding.d", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fmath%2Frounding.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fmath%2Frounding.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fmath%2Frounding.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -908,7 +908,9 @@ T floorImpl(T)(const T x) @trusted pure nothrow @nogc\n \n         // Other kinds of extractors for real formats.\n         static if (F.realFormat == RealFormat.ieeeSingle)\n-            int vi;\n+            uint vi;\n+        else static if (F.realFormat == RealFormat.ieeeDouble)\n+            ulong vi;\n     }\n     floatBits y = void;\n     y.rv = x;\n@@ -919,15 +921,14 @@ T floorImpl(T)(const T x) @trusted pure nothrow @nogc\n     static if (F.realFormat == RealFormat.ieeeSingle)\n     {\n         int exp = ((y.vi >> (T.mant_dig - 1)) & 0xff) - 0x7f;\n+        enum mantissa_mask = F.MANTISSAMASK_INT;\n+        enum sign_shift = 31;\n     }\n     else static if (F.realFormat == RealFormat.ieeeDouble)\n     {\n-        int exp = ((y.vu[F.EXPPOS_SHORT] >> 4) & 0x7ff) - 0x3ff;\n-\n-        version (LittleEndian)\n-            int pos = 0;\n-        else\n-            int pos = 3;\n+        long exp = ((y.vi >> (T.mant_dig - 1)) & 0x7ff) - 0x3ff;\n+        enum mantissa_mask = F.MANTISSAMASK_LONG;\n+        enum sign_shift = 63;\n     }\n     else static if (F.realFormat == RealFormat.ieeeExtended ||\n                     F.realFormat == RealFormat.ieeeExtended53)\n@@ -959,18 +960,21 @@ T floorImpl(T)(const T x) @trusted pure nothrow @nogc\n             return 0.0;\n     }\n \n-    static if (F.realFormat == RealFormat.ieeeSingle)\n+    static if (F.realFormat == RealFormat.ieeeSingle ||\n+               F.realFormat == RealFormat.ieeeDouble)\n     {\n         if (exp < (T.mant_dig - 1))\n         {\n             // Clear all bits representing the fraction part.\n-            const uint fraction_mask = F.MANTISSAMASK_INT >> exp;\n+            // Note: the fraction mask represents the floating point number 0.999999...\n+            // i.e: `2.0 ^^ (exp - T.mant_dig + 1) * (fraction_mask + 1) == 1.0`\n+            const fraction_mask = mantissa_mask >> exp;\n \n             if ((y.vi & fraction_mask) != 0)\n             {\n-                // If 'x' is negative, then first substract 1.0 from the value.\n-                if (y.vi < 0)\n-                    y.vi += 0x00800000 >> exp;\n+                // If 'x' is negative, then first substract (1.0 - T.epsilon) from the value.\n+                if (y.vi >> sign_shift)\n+                    y.vi += fraction_mask;\n                 y.vi &= ~fraction_mask;\n             }\n         }"}, {"sha": "b2206ce56ba8d02f878eda8bf44632b772c3c38d", "filename": "libphobos/src/std/random.d", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Frandom.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Frandom.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Frandom.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -2762,7 +2762,7 @@ Returns:\n     return a `ref` to the $(D range element), otherwise it will return\n     a copy.\n  */\n-auto ref choice(Range, RandomGen = Random)(auto ref Range range, ref RandomGen urng)\n+auto ref choice(Range, RandomGen = Random)(Range range, ref RandomGen urng)\n if (isRandomAccessRange!Range && hasLength!Range && isUniformRNG!RandomGen)\n {\n     assert(range.length > 0,\n@@ -2772,7 +2772,22 @@ if (isRandomAccessRange!Range && hasLength!Range && isUniformRNG!RandomGen)\n }\n \n /// ditto\n-auto ref choice(Range)(auto ref Range range)\n+auto ref choice(Range)(Range range)\n+{\n+    return choice(range, rndGen);\n+}\n+\n+/// ditto\n+auto ref choice(Range, RandomGen = Random)(ref Range range, ref RandomGen urng)\n+if (isRandomAccessRange!Range && hasLength!Range && isUniformRNG!RandomGen)\n+{\n+    assert(range.length > 0,\n+           __PRETTY_FUNCTION__ ~ \": invalid Range supplied. Range cannot be empty\");\n+    return range[uniform(size_t(0), $, urng)];\n+}\n+\n+/// ditto\n+auto ref choice(Range)(ref Range range)\n {\n     return choice(range, rndGen);\n }\n@@ -2827,6 +2842,39 @@ auto ref choice(Range)(auto ref Range range)\n            \"Choice did not return a valid element from the given Range\");\n }\n \n+@safe unittest // issue 18631\n+{\n+    auto rng = MinstdRand0(42);\n+    const a = [0,1,2];\n+    const(int[]) b = [0, 1, 2];\n+    auto x = choice(a);\n+    auto y = choice(b);\n+    auto z = choice(cast(const)[1, 2, 3]);\n+    auto x1 = choice(a, rng);\n+    auto y1 = choice(b, rng);\n+    auto z1 = choice(cast(const)[1, 2, 3], rng);\n+}\n+\n+@safe unittest // Ref range (issue 18631 PR)\n+{\n+    struct TestRange\n+    {\n+        int x;\n+        ref int front() return {return x;}\n+        ref int back() return {return x;}\n+        void popFront() {}\n+        void popBack() {}\n+        bool empty = false;\n+        TestRange save() {return this;}\n+        size_t length = 10;\n+        alias opDollar = length;\n+        ref int opIndex(size_t i) return {return x;}\n+    }\n+\n+    TestRange r = TestRange(10);\n+    int* s = &choice(r);\n+}\n+\n /**\n Shuffles elements of `r` using `gen` as a shuffler. `r` must be\n a random-access range with length.  If no RNG is specified, `rndGen`\n@@ -3008,8 +3056,16 @@ if (isRandomAccessRange!Range)\n }\n \n /**\n-Rolls a dice with relative probabilities stored in $(D\n-proportions). Returns the index in `proportions` that was chosen.\n+Get a random index into a list of weights corresponding to each index\n+\n+Similar to rolling a die with relative probabilities stored in `proportions`.\n+Returns the index in `proportions` that was chosen.\n+\n+Note:\n+    Usually, dice are 'fair', meaning that each side has equal probability\n+    to come up, in which case `1 + uniform(0, 6)` can simply be used.\n+    In future Phobos versions, this function might get renamed to something like\n+    `weightedChoice` to avoid confusion.\n \n Params:\n     rnd = (optional) random number generator to use; if not\n@@ -3055,6 +3111,9 @@ if (isNumeric!Num)\n ///\n @safe unittest\n {\n+    auto d6  = 1 + dice(1, 1, 1, 1, 1, 1); // fair dice roll\n+    auto d6b = 1 + dice(2, 1, 1, 1, 1, 1); // double the chance to roll '1'\n+\n     auto x = dice(0.5, 0.5);   // x is 0 or 1 in equal proportions\n     auto y = dice(50, 50);     // y is 0 or 1 in equal proportions\n     auto z = dice(70, 20, 10); // z is 0 70% of the time, 1 20% of the time,"}, {"sha": "a1fe962906bde5380c0573633a7d2f2e9edf5477", "filename": "libphobos/src/std/stdio.d", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fstdio.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fstdio.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fstdio.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1132,10 +1132,9 @@ each item is inferred from the size and type of the input array, respectively.\n \n Returns: The slice of `buffer` containing the data that was actually read.\n This will be shorter than `buffer` if EOF was reached before the buffer\n-could be filled.\n+could be filled. If the buffer is empty, it will be returned.\n \n-Throws: `Exception` if `buffer` is empty.\n-        `ErrnoException` if the file is not opened or the call to `fread` fails.\n+Throws: `ErrnoException` if the file is not opened or the call to `fread` fails.\n \n `rawRead` always reads in binary mode on Windows.\n  */\n@@ -1144,7 +1143,7 @@ Throws: `Exception` if `buffer` is empty.\n         import std.exception : enforce, errnoEnforce;\n \n         if (!buffer.length)\n-            throw new Exception(\"rawRead must take a non-empty buffer\");\n+            return buffer;\n         enforce(isOpen, \"Attempting to read from an unopened file\");\n         version (Windows)\n         {\n@@ -1211,6 +1210,16 @@ Throws: `Exception` if `buffer` is empty.\n         }\n     }\n \n+    // https://issues.dlang.org/show_bug.cgi?id=13893\n+    @system unittest\n+    {\n+        import std.exception : assertNotThrown;\n+\n+        File f;\n+        ubyte[0] u;\n+        assertNotThrown(f.rawRead(u));\n+    }\n+\n /**\n Calls $(HTTP cplusplus.com/reference/clibrary/cstdio/fwrite.html, fwrite) for the file\n handle. The number of items to write and the size of each"}, {"sha": "160665c6a3102093735d34be6e9ea653ef106eb3", "filename": "libphobos/src/std/sumtype.d", "status": "modified", "additions": 76, "deletions": 72, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Fsumtype.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Fsumtype.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -1941,79 +1941,8 @@ private template matchImpl(Flag!\"exhaustive\" exhaustive, handlers...)\n     auto ref matchImpl(SumTypes...)(auto ref SumTypes args)\n     if (allSatisfy!(isSumType, SumTypes) && args.length > 0)\n     {\n-        enum typeCount(SumType) = SumType.Types.length;\n         alias stride(size_t i) = .stride!(i, Map!(typeCount, SumTypes));\n-\n-        /* A TagTuple represents a single possible set of tags that `args`\n-         * could have at runtime.\n-         *\n-         * Because D does not allow a struct to be the controlling expression\n-         * of a switch statement, we cannot dispatch on the TagTuple directly.\n-         * Instead, we must map each TagTuple to a unique integer and generate\n-         * a case label for each of those integers.\n-         *\n-         * This mapping is implemented in `fromCaseId` and `toCaseId`. It uses\n-         * the same technique that's used to map index tuples to memory offsets\n-         * in a multidimensional static array.\n-         *\n-         * For example, when `args` consists of two SumTypes with two member\n-         * types each, the TagTuples corresponding to each case label are:\n-         *\n-         *   case 0:  TagTuple([0, 0])\n-         *   case 1:  TagTuple([1, 0])\n-         *   case 2:  TagTuple([0, 1])\n-         *   case 3:  TagTuple([1, 1])\n-         *\n-         * When there is only one argument, the caseId is equal to that\n-         * argument's tag.\n-         */\n-        static struct TagTuple\n-        {\n-            size_t[SumTypes.length] tags;\n-            alias tags this;\n-\n-            invariant\n-            {\n-                static foreach (i; 0 .. tags.length)\n-                {\n-                    assert(tags[i] < SumTypes[i].Types.length, \"Invalid tag\");\n-                }\n-            }\n-\n-            this(ref const(SumTypes) args)\n-            {\n-                static foreach (i; 0 .. tags.length)\n-                {\n-                    tags[i] = args[i].tag;\n-                }\n-            }\n-\n-            static TagTuple fromCaseId(size_t caseId)\n-            {\n-                TagTuple result;\n-\n-                // Most-significant to least-significant\n-                static foreach_reverse (i; 0 .. result.length)\n-                {\n-                    result[i] = caseId / stride!i;\n-                    caseId %= stride!i;\n-                }\n-\n-                return result;\n-            }\n-\n-            size_t toCaseId()\n-            {\n-                size_t result;\n-\n-                static foreach (i; 0 .. tags.length)\n-                {\n-                    result += tags[i] * stride!i;\n-                }\n-\n-                return result;\n-            }\n-        }\n+        alias TagTuple = .TagTuple!(SumTypes);\n \n         /*\n          * A list of arguments to be passed to a handler needed for the case\n@@ -2149,6 +2078,81 @@ private template matchImpl(Flag!\"exhaustive\" exhaustive, handlers...)\n     }\n }\n \n+private enum typeCount(SumType) = SumType.Types.length;\n+\n+/* A TagTuple represents a single possible set of tags that `args`\n+ * could have at runtime.\n+ *\n+ * Because D does not allow a struct to be the controlling expression\n+ * of a switch statement, we cannot dispatch on the TagTuple directly.\n+ * Instead, we must map each TagTuple to a unique integer and generate\n+ * a case label for each of those integers.\n+ *\n+ * This mapping is implemented in `fromCaseId` and `toCaseId`. It uses\n+ * the same technique that's used to map index tuples to memory offsets\n+ * in a multidimensional static array.\n+ *\n+ * For example, when `args` consists of two SumTypes with two member\n+ * types each, the TagTuples corresponding to each case label are:\n+ *\n+ *   case 0:  TagTuple([0, 0])\n+ *   case 1:  TagTuple([1, 0])\n+ *   case 2:  TagTuple([0, 1])\n+ *   case 3:  TagTuple([1, 1])\n+ *\n+ * When there is only one argument, the caseId is equal to that\n+ * argument's tag.\n+ */\n+private struct TagTuple(SumTypes...)\n+{\n+    size_t[SumTypes.length] tags;\n+    alias tags this;\n+\n+    alias stride(size_t i) = .stride!(i, Map!(typeCount, SumTypes));\n+\n+    invariant\n+    {\n+        static foreach (i; 0 .. tags.length)\n+        {\n+            assert(tags[i] < SumTypes[i].Types.length, \"Invalid tag\");\n+        }\n+    }\n+\n+    this(ref const(SumTypes) args)\n+    {\n+        static foreach (i; 0 .. tags.length)\n+        {\n+            tags[i] = args[i].tag;\n+        }\n+    }\n+\n+    static TagTuple fromCaseId(size_t caseId)\n+    {\n+        TagTuple result;\n+\n+        // Most-significant to least-significant\n+        static foreach_reverse (i; 0 .. result.length)\n+        {\n+            result[i] = caseId / stride!i;\n+            caseId %= stride!i;\n+        }\n+\n+        return result;\n+    }\n+\n+    size_t toCaseId()\n+    {\n+        size_t result;\n+\n+        static foreach (i; 0 .. tags.length)\n+        {\n+            result += tags[i] * stride!i;\n+        }\n+\n+        return result;\n+    }\n+}\n+\n // Matching\n @safe unittest\n {"}, {"sha": "4ecfb1051d1787576d75ef2cde5464abc4ed2739", "filename": "libphobos/src/std/typecons.d", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Ftypecons.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Ftypecons.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -4905,8 +4905,14 @@ if (is(Interface == interface) && is(BaseClass == class))\n         // - try default first\n         // - only on a failure run & return fallback\n         enum fallback = q{\n-            scope (failure) return fallback.%1$s(args);\n-            return default_.%1$s(args);\n+            try\n+            {\n+                return default_.%1$s(args);\n+            }\n+            catch (Exception)\n+            {\n+                return fallback.%1$s(args);\n+            }\n         }.format(__traits(identifier, func));\n     }\n \n@@ -6589,15 +6595,11 @@ if (!is(T == class) && !(is(T == interface)))\n         private enum enableGCScan = hasIndirections!T;\n     }\n \n-    // TODO remove pure when https://issues.dlang.org/show_bug.cgi?id=15862 has been fixed\n     extern(C) private pure nothrow @nogc static\n     {\n         pragma(mangle, \"free\") void pureFree( void *ptr );\n         static if (enableGCScan)\n-        {\n-            pragma(mangle, \"gc_addRange\") void pureGcAddRange( in void* p, size_t sz, const TypeInfo ti = null );\n-            pragma(mangle, \"gc_removeRange\") void pureGcRemoveRange( in void* p );\n-        }\n+            import core.memory : GC;\n     }\n \n     /// `RefCounted` storage implementation.\n@@ -6637,7 +6639,7 @@ if (!is(T == class) && !(is(T == interface)))\n             {\n                 import std.internal.memory : enforceCalloc;\n                 _store = cast(Impl*) enforceCalloc(1, Impl.sizeof);\n-                pureGcAddRange(&_store._payload, T.sizeof);\n+                GC.addRange(&_store._payload, T.sizeof);\n             }\n             else\n             {\n@@ -6650,7 +6652,7 @@ if (!is(T == class) && !(is(T == interface)))\n         {\n             static if (enableGCScan)\n             {\n-                pureGcRemoveRange(&this._store._payload);\n+                GC.removeRange(&this._store._payload);\n             }\n             pureFree(_store);\n             _store = null;"}, {"sha": "e12a70cfe80ba7255e17fa4645ea1aec7d6b8366", "filename": "libphobos/src/std/uni/package.d", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Fsrc%2Fstd%2Funi%2Fpackage.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -7032,9 +7032,7 @@ template genericDecodeGrapheme(bool getValue)\n             case RI:\n                 if (isRegionalIndicator(ch))\n                     mixin(eat);\n-                else\n-                    goto L_End_Extend;\n-            break;\n+                goto L_End_Extend;\n             case L:\n                 if (isHangL(ch))\n                     mixin(eat);\n@@ -7166,6 +7164,10 @@ if (isInputRange!Input && is(immutable ElementType!Input == immutable dchar))\n     s = \"\\u11A8\\u0308\\uAC01\";\n     assert(equal(decodeGrapheme(s)[], \"\\u11A8\\u0308\"));\n     assert(equal(decodeGrapheme(s)[], \"\\uAC01\"));\n+\n+    // Two Union Jacks of the Great Britain\n+    s = \"\\U0001F1EC\\U0001F1E7\\U0001F1EC\\U0001F1E7\";\n+    assert(equal(decodeGrapheme(s)[], \"\\U0001F1EC\\U0001F1E7\"));\n }\n \n /++"}, {"sha": "64ed2221134a1beea2c8240af3e3ecdd25ae245d", "filename": "libphobos/testsuite/libphobos.gc/nocollect.d", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Ftestsuite%2Flibphobos.gc%2Fnocollect.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6df113247b9f3f7c3db0e65c481dad5bcfddfb4/libphobos%2Ftestsuite%2Flibphobos.gc%2Fnocollect.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libphobos%2Ftestsuite%2Flibphobos.gc%2Fnocollect.d?ref=b6df113247b9f3f7c3db0e65c481dad5bcfddfb4", "patch": "@@ -12,4 +12,4 @@ void main()\n \n     stats = GC.profileStats();\n     assert(stats.numCollections == 0);\n-}\n\\ No newline at end of file\n+}"}]}