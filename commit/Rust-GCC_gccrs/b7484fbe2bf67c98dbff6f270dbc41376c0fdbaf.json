{"sha": "b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc0ODRmYmUyYmY2N2M5OGRiZmY2ZjI3MGRiYzQxMzc2YzBmZGJhZg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-15T23:03:59Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1995-03-15T23:03:59Z"}, "message": "58th Cygnus<->FSF merge\n\nFrom-SVN: r9186", "tree": {"sha": "381c1b9543e7f35718d41a09e9e3275a75d455d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/381c1b9543e7f35718d41a09e9e3275a75d455d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/comments", "author": null, "committer": null, "parents": [{"sha": "a0dabda52b4085f759f495d3e60b6583d7b3668c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0dabda52b4085f759f495d3e60b6583d7b3668c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0dabda52b4085f759f495d3e60b6583d7b3668c"}], "stats": {"total": 2402, "additions": 1459, "deletions": 943}, "files": [{"sha": "aa13e96d2062aba453a590d36bdc34b0ea89f07b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 347, "deletions": 13, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1,3 +1,80 @@\n+Mon Mar 13 21:00:28 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator, case ARRAY_REF): Wrap the exp with fold,\n+\tand convert the size and integer_one_node to the index type.\n+\n+Mon Mar 13 08:01:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (get_member_function_from_ptrfunc): Save the instance\n+\targument, and tack it onto the front of the COND_EXPR to make the\n+\tsemantics come out right.  Grab the instance argument from\n+\t'*instance_ptrptr', rather than having it passed in separately.\n+\t\n+\t* various: Change various consed-up comparison operations to have\n+\tboolean type.  Remove the instance argument in calls to\n+\tget_member_function_from_ptrfunc.\n+\n+\t* error.c (dump_expr): Dump true and false as \"true\" and \"false\".\n+\n+\t* decl2.c (finish_file): Also set DECL_STATIC_FUNCTION_P on the\n+\tglobal init function.\n+\n+\t* decl.c (finish_function): Only set DECL_EXTERNAL here if the\n+\tinline function is public.\n+\n+Sat Mar 11 00:58:03 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (is_friend): Be more careful about checking\n+\tDECL_CLASS_CONTEXT on non-member functions.\n+\n+\t* decl2.c (finish_vtable_vardecl): Don't bother calling\n+\tassemble_external here.\n+\t(prune_vtable_vardecl): New function that just splices out the\n+\tvtable decl from the top-level decls.\n+\t(import_export_inline): Unset DECL_EXTERNAL at first.\n+\t(finish_file): Don't bother calling assemble_external here.  Do\n+\tsplice out all of the vtables.\n+\n+Fri Mar 10 14:42:29 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (finish_function): If we're not emitting the function yet,\n+\tcall assemble_external for it.\n+\n+\t* decl2.c (finish_prevtable_vardecl): Don't call mark_vtable_entries\n+\there.\n+\t(finish_vtable_vardecl): Don't do the linkage deduction thing here.\n+\tAlso don't splice out the current vtable if it is unused.\n+\t(finish_file): Move the second walk_vtables and the synthesis check\n+\tinside the 'reconsider' loop.  Move thunk emission after the\n+\t'reconsider' loop.\n+\n+Thu Mar  9 16:28:16 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* pt.c (tsubst): Don't bother calling cp_build_type_variant, since it\n+\twas passing bogus values for readonly and volatile from the original\n+\ttemplate decl, not the resultant type of the tsubst call.\n+\n+\t* class.c (duplicate_tag_error): Use cp_error_at to point out the\n+\tprevious definition of the tag.\n+\n+Thu Mar  9 10:46:17 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_function): Clear base_init_insns and protect_list.\n+\t(struct cp_function): Add base_init_insns field.\n+\t(push_cp_function_context): Also save base_init_insns.\n+\t(pop_cp_function_context): Also restore base_init_insns.\n+\n+Wed Mar  8 13:31:44 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* init.c (member_init_ok_or_else): Check for initializing a static\n+\tmember here.\n+\t(emit_base_init): Instead of here.\n+\n+Tue Mar  7 16:03:26 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Disable synthesis as needed.\n+\t* lex.c (cons_up_default_function): Ditto.\n+\n Tue Mar  7 10:14:29 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \n \t* parse.y: New rules to allow attributes in a prefix position.\n@@ -10,6 +87,234 @@ Tue Mar  7 10:14:29 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n \t(grokdeclarator): Added code to support machine attributes.\n \t* Makefile.in (stamp-parse): Expect 5 shift/reduce failures.\n \n+Mon Mar  6 15:07:02 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (build_method_call): Don't synthesize methods outside of a\n+\tfunction.\n+\n+\tMake base initialization more re-entrant so that synthesis on the\n+\tfly will work (and, eventually, template instantation on the fly).\n+\t* init.c (sort_member_init): Don't bother with members that can't be\n+\tinitialized.  Reorganize a bit.  Don't initialize base members here.\n+\t(sort_base_init): New function, like sort_member_init, but for base\n+\tclasses.  Steals some code from emit_base_init.\n+\t(emit_base_init): Simplify.  Call sort_{member,base}_init before\n+\tdoing any initialization, so we don't have to save\n+\tcurrent_{member,base}_init_list in push_cp_function_context.\n+\t(expand_aggr_vbase_init_1): Adjust for sort_base_init.\n+\t(expand_aggr_vbase_init): Simplify.\n+\t* decl.c (struct cp_function): Add protect_list field.\n+\t(push_cp_function_context): Also save protect_list.\n+\t(pop_cp_function_context): Also restore protect_list.\n+\t* call.c (build_method_call): Enable synthesis at point of call.\n+\t* lex.c (cons_up_default_function): Ditto.\n+\n+\t* parse.y: Turn -ansi checks back into -pedantic checks.\n+\n+\t* init.c (build_new): Fix -fcheck-new for array new.\n+\n+Sat Mar  4 15:55:42 1995  Fergus Henderson  <fjh@cs.mu.oz.au>\n+\n+\t* typeck.c (build_compound_expr): warn if left-hand operand of\n+\tcomma expression has no side-effects.\n+\n+Fri Mar  3 15:16:45 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (primary): Change 'object qualified_id *' rules to 'object\n+\toverqualified_id *'.\n+\n+Fri Mar  3 12:48:17 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* parse.y (unary_expr): Catch doing sizeof an overloaded function.\n+\tMake the error look the same as the one we issue in c_sizeof.\n+\n+\t* typeck.c (build_binary_op_nodefault): Give an error for trying\n+\tto compare a pointer-to-member to `void *'.\n+\n+Fri Mar  3 11:28:50 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_unary_op): Handle bool increment with smoke and\n+\tmirrors here, rather than in expand_increment where it belongs,\n+\tbecause Kenner doesn't agree with me.\n+\n+Fri Mar  3 00:08:10 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokparms): Catch a PARM_DECL being used for a default\n+\targument as well.\n+\n+Thu Mar  2 20:05:54 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* init.c (build_new): Don't allow new on a function type.\n+\n+\t* parse.y (primary): Avoid a crash when seeing if the arg is of\n+\tthe same type as that given for the typespec in an explicit dtor call.\n+\n+Thu Mar  2 00:49:38 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (finish_function): Change test for calling\n+\tmark_inline_for_output.\n+\n+Wed Mar  1 11:23:46 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Complain if\n+\tbuild_default_binary_type_conversion fails.\n+\n+\t* init.c (expand_default_init): Handle arguments of unknown type\n+\tproperly.\n+\n+\t* cvt.c (build_expr_type_conversion): Only complain about ambiguity\n+\tif 'complain'.\n+\t* various: Pass 'complain'.\n+\n+\t* typeck.c (comptypes): Be more picky about comparing UPTs.\n+\n+Wed Mar  1 11:03:41 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): If declarator is null, say that the\n+\ttype used has an incomplete type.\n+\n+Wed Mar  1 10:06:20 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* pt.c (instantiate_template): Copy the template arguments to the\n+\tpermanent_obstack.  Also use simple_cst_equal to compare them when\n+\tlooking for a previous instantiation.\n+\n+\t* tree.c (make_deep_copy): Support copying INTEGER_TYPEs (assuming\n+\tthey are array domain types).\n+\n+Tue Feb 28 23:24:55 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cp-tree.h: Define WANT_* constants for passing to\n+\tbuild_expr_type_conversion.\n+\t* cvt.c (build_expr_type_conversion): New function to build\n+\tconversion to one of a group of suitable types.\n+\t(build_default_binary_type_conversion): Use it.\n+\t* decl2.c (grok_array_decl): Ditto.\n+\t* typeck.c (build_unary_op): Ditto.\n+\t(build_array_ref): Tidy up a bit.\n+\t(build_binary_op): Ditto.\n+\n+Tue Feb 28 19:57:31 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Don't allow decl of an argument as `void'.\n+\n+Tue Feb 28 17:23:36 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* parse.y (typed_declspecs1): Add 'typespec reserved_typespecquals\n+\treserved_declspecs' rule.\n+\n+\t* parse.y (expr_or_declarator): Remove notype_qualified_id rule.\n+\t(direct_notype_declarator): Ditto.\n+\t(complex_direct_notype_declarator): Add notype_qualified_id rule.\n+\n+\t* lex.c (real_yylex): Handle :> digraph properly.\n+\n+Tue Feb 28 12:26:29 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Check if it's a friend, not if it's\n+\tnon-virtual, that's being initialized.  Move the check up to\n+\tbefore FRIENDP would get cleared.  Catch an unnamed var/field\n+\tbeing declared void.  Say just `field' instead of `structure field'\n+\tin the error message.  Only go for the operator name if DECLARATOR\n+\tis non-null.\n+\n+Tue Feb 28 00:08:01 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (start_function): Complain about abstract return type.\n+\t(grokdeclarator): Complain about declaring constructors and\n+\tdestructors to be const or volatile.  Complain about declaring\n+\tdestructors to be static.\n+\n+\t* pt.c (uses_template_parms): Handle pmfs.\n+\n+\t* decl.c (grokdeclarator): Don't call variable_size for array bounds\n+\tthat only depend on template constant parameters.\n+\n+Mon Feb 27 15:38:16 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* error.c (dump_decl): Only look to see if it's a vtable if we\n+\tactually have a name to check out.\n+\n+Mon Feb 27 13:37:53 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* cvt.c (convert_to_aggr): Lose misleading shortcut.\n+\n+Sun Feb 26 17:27:32 1995  Doug Evans  <dje@canuck.cygnus.com>\n+\n+\t* decl.c (set_nested_typename): Always set DECL_IGNORED_P,\n+\tnot just for dwarf.\n+\n+Sun Feb 26 00:10:18 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Don't allow a static member to be\n+\tdeclared `register'.\n+\n+\t* init.c (make_friend_class): Move up to a pedwarn for the warning\n+\tabout a class declaring friends with itself.\n+\n+\t* decl.c (grokdeclarator): You can't do `volatile friend class foo'\n+\tor `inline friend class foo'.  Only try to make a friend out of\n+\tTYPE if we didn't already reset it to integer_type_node.\n+\n+Sat Feb 25 22:32:03 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Don't allow initialization of a\n+\tnon-virtual function.\n+\n+\t* decl.c (start_function): Do a pedwarn if we're changing `main'\n+\tto have an int return type.\n+\n+Sat Feb 25 00:02:05 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_modify_expr): Handle simple assignment from\n+\tTARGET_EXPRs by building up an RTL_EXPR to force expansion.  Whew.\n+\n+Fri Feb 24 18:27:14 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* decl.c (grokdeclarator): Also don't allow virtual outside of a\n+\tclass decl for a scope method definition performed at global binding.\n+\n+\t* init.c (build_offset_ref): Don't allow creation of an OFFSET_REF\n+\tof a bitfield.\n+\n+\t* decl.c (grokdeclarator): Don't allow a const to be declared mutable.\n+\n+\t* typeck.c (build_binary_op): Return an error_mark_node if either\n+\tone of the args turned into an error_mark_node when we tried to\n+\tuse default_conversion.\n+\n+\t* typeck.c (build_unary_op): Forbid using postfix -- on a bool.\n+\n+\t* decl.c (grokdeclarator): Allow `signed' and `unsigned' to be\n+\tused on `__wchar_t'.\n+\n+Fri Feb 24 13:59:53 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* except.c (end_protect_partials): Do it the right way.\n+\n+Wed Feb 22 15:42:56 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* typeck.c (build_binary_op_nodefault): Upgrade warning about\n+\tcomparing distinct pointer types to pedwarn.\n+\n+\t* typeck2.c (digest_init): Cope with extra braces.\n+\n+\t* typeck.c (build_binary_op_nodefault): Use tree_int_cst_sgn instead\n+\tof INT_CST_LT (..., interger_zero_node).\n+\n+Wed Feb 22 14:45:52 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* except.c [!TRY_NEW_EH] (end_protect_partials): Define dummy\n+\tfunction for systems that don't have EH.\n+\n+Tue Feb 21 19:18:31 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* call.c (can_convert_arg): Like can_convert, but takes an arg as\n+\twell.\n+\n+\t* pt.c (type_unification): Allow implicit conversions for parameters\n+\tthat do not depend on template parameters.\n+\n Tue Feb 21 18:43:48 1995  Douglas Rupp  (drupp@cs.washington.edu)\n \n \t* Make-lang.in, config-lang.in: ($exeext): New macro.\n@@ -19,17 +324,46 @@ Tue Feb 21 18:43:48 1995  Douglas Rupp  (drupp@cs.washington.edu)\n \t* cp/g++.c: Added #ifdefs for sys/file.h and process.h for NT.\n \tModified spawnvp to have to correct number of arguments for OS/2, NT.\n \n-Thu Feb  2 15:07:58 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+Tue Feb 21 18:36:55 1995  Mike Stump  <mrs@cygnus.com>\n+\n+\t* decl.c (finish_function): Add calls to end_protect_partials to end\n+\tthe exception region that protects constructors so that partially\n+\tconstructed objects can be partially destructed when the constructor\n+\tthrows an exception.\n+\t* init.c (perform_member_init, sort_member_init, emit_base_init):\n+\tAdded support for partially constructed objects.\n+\t* init.c (build_partial_cleanup_for): New routine to do partial\n+\tcleanups of a base class.\n+\t* decl2.c (finish_file): Move the emitting of the exception table\n+\tdown, after we emit all code that might have exception regions in\n+\tthem.\n+\t* except.c (end_protect_partials, might_have_exceptions_p): New\n+\troutines.\n+\t(emit_exception_table): Always output table if called.\n+\t* cp-tree.h (protect_list, end_protect_partials,\n+\tmight_have_exceptions_p, emit_exception_table): Added.\n+\n+Tue Feb 21 16:05:59 1995  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* gc.c (build_typeid): Pass a NULL_TREE, not the bogus, unused\n+\taddress of a local variable.\n+\t* class.c (build_vfn_ref): Only try to build the PLUS_EXPR if we\n+\twere given a non-null PTR_TO_INSTPTR.\n+\n+Tue Feb 21 01:53:18 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n+\n+\t* decl.c (duplicate_decls): Always lay out the merged decl.\n+\n+\t* decl2.c (finish_vtable_vardecl): Don't do vtable hack on templates.\n+\t(finish_prevtable_vardecl): Ditto.\n \n-        * class.c (build_vbase_path): Bash types to make the backend happy.\n-        * cvt.c (build_up_reference): Bash the types bashed by\n-        build_vbase_path to be reference types instead of pointer types.\n-        (convert_to_reference): Ditto.\n+\t* method.c (synthesize_method): Set interface_{unknown,only}\n+\taccording to the settings for our class, not the file where it comes\n+\tfrom.\n \n-Wed Jan 25 15:02:09 1995  David S. Miller  (davem@nadzieja.rutgers.edu)\n+Sat Feb 18 12:26:48 1995  Mike Stump  <mrs@cygnus.com>\n \n-\t* class.c (instantiate_type): Change error message text.\n-\t* typeck2.c (store_init_value): Likewise.\n+\t* except.c: Handle systems that define __i386__ but not __i386.\n \n Fri Feb 17 15:31:31 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \n@@ -518,6 +852,11 @@ Tue Jan 24 16:36:31 1995  Jason Merrill  <jason@phydeaux.cygnus.com>\n \t* typeck2.c (build_functional_cast): Don't assume that a NOP_EXPR\n \twill suffice to convert from integer_zero_node.\n \n+Wed Jan 25 15:02:09 1995  David S. Miller  (davem@nadzieja.rutgers.edu)\n+\n+\t* class.c (instantiate_type): Change error message text.\n+\t* typeck2.c (store_init_value): Likewise.\n+\n Mon Jan 23 21:57:14 1995  Mike Stump  <mrs@cygnus.com>\n \n \t* pt.c (tsubst): When we copy a node, don't forget to copy\n@@ -4034,11 +4373,6 @@ Fri Apr 22 03:27:26 1994  Doug Evans  (dje@cygnus.com)\n \t* Language directory reorganization.\n \tSee parent makefile.\n \n-Fri Apr 22 03:27:26 1994  Doug Evans  (dje@cygnus.com)\n-\n-\t* Language directory reorganization.\n-\tSee parent makefile.\n-\n Thu Apr 21 18:27:57 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n \n \t* cp-tree.h (THUNK_DELTA):  It is normally negative, so"}, {"sha": "dd267f3784145f586982bb1f1b06ec2ad325b980", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -194,14 +194,15 @@ parse.o : $(PARSE_C) $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h lex.h\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(BIG_SWITCHFLAG) \\\n   `echo $(PARSE_C) | sed 's,^\\./,,'`\n \n+CONFLICTS = expect 5 shift/reduce confict and 38 reduce/reduce conflicts.\n $(PARSE_H) : $(PARSE_C)\n $(PARSE_C) : $(srcdir)/parse.y\n-\t@echo expect 5 shift/reduce confict and 39 reduce/reduce conflicts.\n+\t@echo $(CONFLICTS)\n \tcd $(srcdir); $(BISON) $(BISONFLAGS) -d -o parse.c parse.y\n \tcd $(srcdir); grep '^#define[ \t]*YYEMPTY' parse.c >>parse.h\n #$(PARSE_C) $(PARSE_H) : stamp-parse ; @true\n #stamp-parse: $(srcdir)/parse.y\n-#\t@echo expect 1 shift/reduce confict and 39 reduce/reduce conflicts.\n+#\t@echo $(CONFLICTS)\n #\t$(BISON) $(BISONFLAGS) -d $(srcdir)/parse.y\n #\tgrep '^#define[ \t]*YYEMPTY' y.tab.c >>y.tab.h\n #\t$(srcdir)/../move-if-change y.tab.c $(PARSE_C)"}, {"sha": "3079d147734c34dad885c16a8b42c071e6955426", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -593,6 +593,15 @@ can_convert (to, from)\n   return h.code < USER_CODE;\n }\n \n+int\n+can_convert_arg (to, from, arg)\n+     tree to, from, arg;\n+{\n+  struct harshness_code h;\n+  h = convert_harshness (to, from, arg);\n+  return h.code < USER_CODE;\n+}\n+\n #ifdef DEBUG_MATCHING\n static char *\n print_harshness (h)\n@@ -2371,9 +2380,12 @@ build_method_call (instance, name, parms, basetype_path, flags)\n   assemble_external (function);\n \n #if 0\n+  /* Is it a synthesized method that needs to be synthesized?  */\n   if (DECL_ARTIFICIAL (function) && ! flag_no_inline\n       && DECL_SAVED_INSNS (function) == 0\n-      && ! TREE_ASM_WRITTEN (function))\n+      && ! TREE_ASM_WRITTEN (function)\n+      /* Kludge: don't synthesize for default args.  */\n+      && current_function_decl)\n     synthesize_method (function);\n #endif\n "}, {"sha": "f296dc9b421b6ae15513cad095fe3f02afa7c5cb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -240,7 +240,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t\t    {\n \t\t      null_expr = build1 (NOP_EXPR, TYPE_POINTER_TO (last_virtual), integer_zero_node);\n \t\t      expr = build (COND_EXPR, TYPE_POINTER_TO (last_virtual),\n-\t\t\t\t    build (EQ_EXPR, integer_type_node, expr,\n+\t\t\t\t    build (EQ_EXPR, boolean_type_node, expr,\n \t\t\t\t\t   integer_zero_node),\n \t\t\t\t    null_expr, nonnull_expr);\n \t\t    }\n@@ -323,7 +323,7 @@ build_vbase_path (code, type, expr, path, alias_this)\n \t    expr = save_expr (expr);\n \n \t  return build (COND_EXPR, type,\n-\t\t\tbuild (EQ_EXPR, integer_type_node, expr, integer_zero_node),\n+\t\t\tbuild (EQ_EXPR, boolean_type_node, expr, integer_zero_node),\n \t\t\tnull_expr,\n \t\t\tbuild (code, type, expr, offset));\n \t}\n@@ -490,11 +490,12 @@ build_vfn_ref (ptr_to_instptr, instance, idx)\n     return aref;\n   else\n     {\n-      *ptr_to_instptr\n-\t= build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n-\t\t *ptr_to_instptr,\n-\t\t convert (ptrdiff_type_node,\n-\t\t\t  build_component_ref (aref, delta_identifier, 0, 0)));\n+      if (ptr_to_instptr)\n+\t*ptr_to_instptr\n+\t  = build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n+\t\t   *ptr_to_instptr,\n+\t\t   convert (ptrdiff_type_node,\n+\t\t\t    build_component_ref (aref, delta_identifier, 0, 0)));\n       return build_component_ref (aref, pfn_identifier, 0, 0);\n     }\n }\n@@ -2020,6 +2021,7 @@ duplicate_tag_error (t)\n      tree t;\n {\n   cp_error (\"redefinition of `%#T'\", t);\n+  cp_error_at (\"previous definition here\", t);\n \n   /* Pretend we haven't defined this type.  */\n "}, {"sha": "528c23a03d6c105aae67d9d790cb1299d46ef2fb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1836,6 +1836,17 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define CONV_C_CAST      (CONV_IMPLICIT | CONV_STATIC | CONV_CONST \\\n \t\t\t  | CONV_REINTERPRET | CONV_PRIVATE | CONV_FORCE_TEMP)\n \n+/* Used by build_expr_type_conversion to indicate which types are\n+   acceptable as arguments to the expression under consideration.  */\n+\n+#define WANT_INT\t1 /* integer types, including bool */\n+#define WANT_FLOAT\t2 /* floating point types */\n+#define WANT_ENUM\t4 /* enumerated types */\n+#define WANT_POINTER\t8 /* pointer types */\n+#define WANT_NULL      16 /* null pointer constant */\n+\n+#define WANT_ARITH\t(WANT_INT | WANT_FLOAT)\n+\n /* Anatomy of a DECL_FRIENDLIST (which is a TREE_LIST):\n    purpose = friend name (IDENTIFIER_NODE);\n    value = TREE_LIST of FUNCTION_DECLS;\n@@ -1913,8 +1924,8 @@ extern tree convert\t\t\t\tPROTO((tree, tree));\n extern tree cp_convert\t\t\t\tPROTO((tree, tree, int, int));\n extern tree convert_force\t\t\tPROTO((tree, tree, int));\n extern tree build_type_conversion\t\tPROTO((enum tree_code, tree, tree, int));\n+extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n-extern int build_default_unary_type_conversion\tPROTO((enum tree_code, tree *));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n \n /* decl.c */\n@@ -2042,9 +2053,10 @@ extern tree get_namespace_id\t\t\tPROTO((void));\n /* in edsel.c */\n \n /* in except.c */\n-\n+extern tree protect_list;\n extern void start_protect\t\t\tPROTO((void));\n extern void end_protect\t\t\t\tPROTO((tree));\n+extern void end_protect_partials\t\t();\n extern void expand_exception_blocks\t\tPROTO((void));\n extern void expand_start_try_stmts\t\tPROTO((void));\n extern void expand_end_try_stmts\t\tPROTO((void));\n@@ -2053,7 +2065,8 @@ extern void expand_end_all_catch\t\tPROTO((void));\n extern void start_catch_block\t\t\tPROTO((tree, tree));\n extern void end_catch_block\t\t\tPROTO((void));\n extern void expand_throw\t\t\tPROTO((tree));\n-extern int build_exception_table\t\tPROTO((void));\n+extern int might_have_exceptions_p\t\tPROTO((void));\n+extern void emit_exception_table\t\tPROTO((void));\n extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n \n@@ -2093,7 +2106,7 @@ extern tree get_type_value\t\t\tPROTO((tree));\n extern tree build_member_call\t\t\tPROTO((tree, tree, tree));\n extern tree build_offset_ref\t\t\tPROTO((tree, tree));\n extern tree get_member_function\t\t\tPROTO((tree *, tree, tree));\n-extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree, tree));\n+extern tree get_member_function_from_ptrfunc\tPROTO((tree *, tree));\n extern tree resolve_offset_ref\t\t\tPROTO((tree));\n extern tree decl_constant_value\t\t\tPROTO((tree));\n extern int is_friend_type\t\t\tPROTO((tree, tree));"}, {"sha": "e87b168a23325e6f9cb00ad9026e5b18c61c2f26", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 203, "deletions": 127, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -903,6 +903,7 @@ convert_to_aggr (type, expr, msgp, protect)\n   parmlist = tree_cons (NULL_TREE, integer_zero_node, parmlist);\n   parmtypes = tree_cons (NULL_TREE, TYPE_POINTER_TO (basetype), parmtypes);\n \n+#if 0\n   method_name = build_decl_overload (name, parmtypes, 1);\n \n   /* constructors are up front.  */\n@@ -936,6 +937,7 @@ convert_to_aggr (type, expr, msgp, protect)\n \t}\n       fndecl = DECL_CHAIN (fndecl);\n     }\n+#endif\n \n   /* No exact conversion was found.  See if an approximate\n      one will do.  */\n@@ -1548,7 +1550,7 @@ build_type_conversion (code, xtype, expr, for_sure)\n \t    {\n \t      cp_error (\"ambiguous conversion from `%T' to `%T'\", basetype,\n \t\t\txtype);\n-\t      cp_error (\"  candidate conversion functions include `%T' and `%T'\",\n+\t      cp_error (\"  candidate conversions include `%T' and `%T'\",\n \t\t\tTREE_VALUE (winner), TREE_VALUE (conv));\n \t      return NULL_TREE;\n \t    }\n@@ -1564,154 +1566,228 @@ build_type_conversion (code, xtype, expr, for_sure)\n   return NULL_TREE;\n }\n \n-/* Must convert two aggregate types to non-aggregate type.\n-   Attempts to find a non-ambiguous, \"best\" type conversion.\n-\n-   Return 1 on success, 0 on failure.\n+/* Convert the given EXPR to one of a group of types suitable for use in an\n+   expression.  DESIRES is a combination of various WANT_* flags (q.v.)\n+   which indicates which types are suitable.  If COMPLAIN is 1, complain\n+   about ambiguity; otherwise, the caller will deal with it.  */\n \n-   @@ What are the real semantics of this supposed to be??? */\n-int\n-build_default_binary_type_conversion (code, arg1, arg2)\n-     enum tree_code code;\n-     tree *arg1, *arg2;\n+tree\n+build_expr_type_conversion (desires, expr, complain)\n+     int desires;\n+     tree expr;\n+     int complain;\n {\n-  tree type1 = TREE_TYPE (*arg1);\n-  tree type2 = TREE_TYPE (*arg2);\n-\n-  if (TREE_CODE (type1) == REFERENCE_TYPE\n-      || TREE_CODE (type1) == POINTER_TYPE)\n-    type1 = TREE_TYPE (type1);\n-  if (TREE_CODE (type2) == REFERENCE_TYPE\n-      || TREE_CODE (type2) == POINTER_TYPE)\n-    type2 = TREE_TYPE (type2);\n+  tree basetype = TREE_TYPE (expr);\n+  tree conv;\n+  tree winner = NULL_TREE;\n \n-  if (TREE_CODE (TYPE_NAME (type1)) != TYPE_DECL)\n+  if (TREE_CODE (basetype) == OFFSET_TYPE)\n     {\n-      tree decl = typedecl_for_tag (type1);\n-      if (decl)\n-\terror (\"type conversion nonexistent for type `%s'\",\n-\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n-      else\n-\terror (\"type conversion nonexistent for non-C++ type\");\n-      return 0;\n-    }\n-  if (TREE_CODE (TYPE_NAME (type2)) != TYPE_DECL)\n-    {\n-      tree decl = typedecl_for_tag (type2);\n-      if (decl)\n-\terror (\"type conversion nonexistent for type `%s'\",\n-\t       IDENTIFIER_POINTER (decl));\n-      else\n-\terror (\"type conversion nonexistent for non-C++ type\");\n-      return 0;\n+      expr = resolve_offset_ref (expr);\n+      basetype = TREE_TYPE (expr);\n     }\n \n-  if (!IS_AGGR_TYPE (type1) || !TYPE_HAS_CONVERSION (type1))\n-    {\n-      if (!IS_AGGR_TYPE (type2) || !TYPE_HAS_CONVERSION (type2))\n-\tcp_error (\"no conversion from `%T' and `%T' to types with default `%O' \",\n-\t\t  type1, type2, code);\n-      else\n-\tcp_error (\"no conversion from `%T' to type with default `%O'\",\n-\t\t  type1, code);\n-      return 0;\n-    }\n-  else if (!IS_AGGR_TYPE (type2) || !TYPE_HAS_CONVERSION (type2))\n-    {\n-      cp_error (\"no conversion from `%T' to type with default `%O'\",\n-\t\ttype2, code);\n-      return 0;\n-    }\n+  if (! IS_AGGR_TYPE (basetype))\n+    switch (TREE_CODE (basetype))\n+      {\n+      case INTEGER_TYPE:\n+\tif ((desires & WANT_NULL) && TREE_CODE (expr) == INTEGER_CST\n+\t    && integer_zerop (expr))\n+\t  return expr;\n+\t/* else fall through... */\n+\n+      case BOOLEAN_TYPE:\n+\treturn (desires & WANT_INT) ? expr : NULL_TREE;\n+      case ENUMERAL_TYPE:\n+\treturn (desires & WANT_ENUM) ? expr : NULL_TREE;\n+      case REAL_TYPE:\n+\treturn (desires & WANT_FLOAT) ? expr : NULL_TREE;\n+      case POINTER_TYPE:\n+\treturn (desires & WANT_POINTER) ? expr : NULL_TREE;\n+\t\n+      case FUNCTION_TYPE:\n+      case ARRAY_TYPE:\n+\treturn (desires & WANT_POINTER) ? default_conversion (expr)\n+     \t                                : NULL_TREE;\n+      default:\n+\treturn NULL_TREE;\n+      }\n \n-  if (code == TRUTH_ANDIF_EXPR\n-      || code == TRUTH_ORIF_EXPR)\n-    {\n-      *arg1 = convert (boolean_type_node, *arg1);\n-      *arg2 = convert (boolean_type_node, *arg2);\n-    }\n-  else if (TYPE_HAS_INT_CONVERSION (type1))\n-    {\n-      if (TYPE_HAS_REAL_CONVERSION (type1))\n-\tcp_pedwarn (\"ambiguous type conversion for type `%T', defaulting to int\",\n-\t\t    type1);\n-      *arg1 = build_type_conversion (code, integer_type_node, *arg1, 1);\n-      *arg2 = build_type_conversion (code, integer_type_node, *arg2, 1);\n-    }\n-  else if (TYPE_HAS_REAL_CONVERSION (type1))\n-    {\n-      *arg1 = build_type_conversion (code, double_type_node, *arg1, 1);\n-      *arg2 = build_type_conversion (code, double_type_node, *arg2, 1);\n-    }\n-  else\n-    {\n-      *arg1 = build_type_conversion (code, ptr_type_node, *arg1, 1);\n-      if (*arg1 == error_mark_node)\n-\terror (\"ambiguous pointer conversion\");\n-      *arg2 = build_type_conversion (code, ptr_type_node, *arg2, 1);\n-      if (*arg1 != error_mark_node && *arg2 == error_mark_node)\n-\terror (\"ambiguous pointer conversion\");\n-    }\n-  if (*arg1 == 0)\n-    {\n-      if (*arg2 == 0 && type1 != type2)\n-\tcp_error (\"default type conversion for types `%T' and `%T' failed\",\n-\t\t  type1, type2);\n-      else\n-\tcp_error (\"default type conversion for type `%T' failed\", type1);\n-      return 0;\n-    }\n-  else if (*arg2 == 0)\n+  if (! TYPE_HAS_CONVERSION (basetype))\n+    return NULL_TREE;\n+\n+  for (conv = lookup_conversions (basetype); conv; conv = TREE_CHAIN (conv))\n     {\n-      cp_error (\"default type conversion for type `%T' failed\", type2);\n-      return 0;\n+      int win = 0;\n+\n+      if (winner && TREE_PURPOSE (winner) == TREE_PURPOSE (conv))\n+\tcontinue;\n+\n+      switch (TREE_CODE (TREE_VALUE (conv)))\n+\t{\n+\tcase BOOLEAN_TYPE:\n+\tcase INTEGER_TYPE:\n+\t  win = (desires & WANT_INT); break;\n+\tcase ENUMERAL_TYPE:\n+\t  win = (desires & WANT_ENUM); break;\n+\tcase REAL_TYPE:\n+\t  win = (desires & WANT_FLOAT); break;\n+\tcase POINTER_TYPE:\n+\t  win = (desires & WANT_POINTER); break;\n+\t}\n+\n+      if (win)\n+\t{\n+\t  if (winner)\n+\t    {\n+\t      if (complain)\n+\t\t{\n+\t\t  cp_error (\"ambiguous default type conversion from `%T'\",\n+\t\t\t    basetype);\n+\t\t  cp_error (\"  candidate conversions include `%T' and `%T'\",\n+\t\t\t    TREE_VALUE (winner), TREE_VALUE (conv));\n+\t\t}\n+\t      return error_mark_node;\n+\t    }\n+\t  else\n+\t    winner = conv;\n+\t}\n     }\n-  return 1;\n+\n+  if (winner)\n+    return build_type_conversion_1 (TREE_VALUE (winner), basetype, expr,\n+\t\t\t\t    TREE_PURPOSE (winner), 1);\n+\n+  return NULL_TREE;\n }\n \n-/* Must convert an aggregate type to non-aggregate type.\n+/* Must convert two aggregate types to non-aggregate type.\n    Attempts to find a non-ambiguous, \"best\" type conversion.\n \n    Return 1 on success, 0 on failure.\n \n-   The type of the argument is expected to be of aggregate type here.\n-\n    @@ What are the real semantics of this supposed to be??? */\n int\n-build_default_unary_type_conversion (code, arg)\n+build_default_binary_type_conversion (code, arg1, arg2)\n      enum tree_code code;\n-     tree *arg;\n+     tree *arg1, *arg2;\n {\n-  tree type = TREE_TYPE (*arg);\n-\n-  if (! TYPE_HAS_CONVERSION (type))\n+  switch (code)\n     {\n-      cp_error (\"type conversion required for type `%T'\", type);\n-      return 0;\n-    }\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+    case FLOOR_DIV_EXPR:\n+    case ROUND_DIV_EXPR:\n+    case EXACT_DIV_EXPR:\n+      *arg1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n+      *arg2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n+      break;\n \n-  if (code == TRUTH_NOT_EXPR)\n-    *arg = convert (boolean_type_node, *arg);\n-  else if (TYPE_HAS_INT_CONVERSION (type))\n-    {\n-      if (TYPE_HAS_REAL_CONVERSION (type))\n-\tcp_pedwarn (\"ambiguous type conversion for type `%T', defaulting to int\",\n-\t\t    type);\n-      *arg = build_type_conversion (code, integer_type_node, *arg, 1);\n-    }\n-  else if (TYPE_HAS_REAL_CONVERSION (type))\n-    *arg = build_type_conversion (code, double_type_node, *arg, 1);\n-  else\n-    {\n-      *arg = build_type_conversion (code, ptr_type_node, *arg, 1);\n-      if (*arg == error_mark_node)\n-\terror (\"ambiguous pointer conversion\");\n-    }\n-  if (*arg == NULL_TREE)\n-    {\n-      cp_error (\"default type conversion for type `%T' failed\", type);\n-      return 0;\n+    case TRUNC_MOD_EXPR:\n+    case FLOOR_MOD_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_XOR_EXPR:\n+    case BIT_IOR_EXPR:\n+      *arg1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, *arg1, 0);\n+      *arg2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, *arg2, 0);\n+      break;\n+\n+    case PLUS_EXPR:\n+      {\n+\ttree a1, a2, p1, p2;\n+\tint wins;\n+\n+\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n+\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n+\tp1 = build_expr_type_conversion (WANT_POINTER, *arg1, 0);\n+\tp2 = build_expr_type_conversion (WANT_POINTER, *arg2, 0);\n+\n+\twins = (a1 && a2) + (a1 && p2) + (p1 && a2);\n+\n+\tif (wins > 1)\n+\t  error (\"ambiguous default type conversion for `operator +'\");\n+\n+\tif (a1 && a2)\n+\t  *arg1 = a1, *arg2 = a2;\n+\telse if (a1 && p2)\n+\t  *arg1 = a1, *arg2 = p2;\n+\telse\n+\t  *arg1 = p1, *arg2 = a2;\n+\tbreak;\n+      }\n+\n+    case MINUS_EXPR:\n+      {\n+\ttree a1, a2, p1, p2;\n+\tint wins;\n+\n+\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n+\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n+\tp1 = build_expr_type_conversion (WANT_POINTER, *arg1, 0);\n+\tp2 = build_expr_type_conversion (WANT_POINTER, *arg2, 0);\n+\n+\twins = (a1 && a2) + (p1 && p2) + (p1 && a2);\n+\n+\tif (wins > 1)\n+\t  error (\"ambiguous default type conversion for `operator -'\");\n+\n+\tif (a1 && a2)\n+\t  *arg1 = a1, *arg2 = a2;\n+\telse if (p1 && p2)\n+\t  *arg1 = p1, *arg2 = p2;\n+\telse\n+\t  *arg1 = p1, *arg2 = a2;\n+\tbreak;\n+      }\n+\n+    case GT_EXPR:\n+    case LT_EXPR:\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      {\n+\ttree a1, a2, p1, p2;\n+\tint wins;\n+\n+\ta1 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg1, 0);\n+\ta2 = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, *arg2, 0);\n+\tp1 = build_expr_type_conversion (WANT_POINTER | WANT_NULL, *arg1, 0);\n+\tp2 = build_expr_type_conversion (WANT_POINTER | WANT_NULL, *arg2, 0);\n+\n+\twins = (a1 && a2) + (p1 && p2);\n+\n+\tif (wins > 1)\n+\t  cp_error (\"ambiguous default type conversion for `%O'\", code);\n+\n+\tif (a1 && a2)\n+\t  *arg1 = a1, *arg2 = a2;\n+\telse\n+\t  *arg1 = p1, *arg2 = p2;\n+\tbreak;\n+      }\n+\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      *arg1 = convert (boolean_type_node, *arg1);\n+      *arg2 = convert (boolean_type_node, *arg2);\n+      break;\n+\n+    default:\n+      *arg1 = NULL_TREE;\n+      *arg2 = NULL_TREE;\n     }\n-  return 1;\n+\n+  if (*arg1 == error_mark_node || *arg2 == error_mark_node)\n+    cp_error (\"ambiguous default type conversion for `%O'\", code);\n+\n+  if (*arg1 && *arg2)\n+    return 1;\n+\n+  return 0;\n }\n \n /* Implements integral promotion (4.1) and float->double promotion. */"}, {"sha": "1ef0ebd8f19a8948a78a0f997ac440ad9900831a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 138, "deletions": 76, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1664,13 +1664,10 @@ set_nested_typename (decl, classname, name, type)\n     type_decl = build_decl (TYPE_DECL, nested, type);\n     DECL_NESTED_TYPENAME (type_decl) = nested;\n     SET_DECL_ARTIFICIAL (type_decl);\n-#ifdef DWARF_DEBUGGING_INFO\n-    /* Mark the TYPE_DECL node created just above as a\n-       gratuitous one so that dwarfout.c will know not to\n-       generate a TAG_typedef DIE for it.  */\n-    if (write_symbols == DWARF_DEBUG)\n-      DECL_IGNORED_P (type_decl) = 1;\n-#endif /* DWARF_DEBUGGING_INFO */\n+    /* Mark the TYPE_DECL node created just above as a gratuitous one so that\n+       dwarfout.c will know not to generate a TAG_typedef DIE for it, and\n+       sdbout.c won't try to output a .def for \"::foo\".  */\n+    DECL_IGNORED_P (type_decl) = 1;\n \n     /* Remove this when local classes are fixed.  */\n     SET_IDENTIFIER_TYPE_VALUE (nested, type);\n@@ -2447,21 +2444,16 @@ duplicate_decls (newdecl, olddecl)\n       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;\n \n       /* Lay the type out, unless already done.  */\n-      if (oldtype != TREE_TYPE (newdecl))\n-\t{\n-\t  if (TREE_TYPE (newdecl) != error_mark_node)\n-\t    layout_type (TREE_TYPE (newdecl));\n-\t  if (TREE_CODE (newdecl) != FUNCTION_DECL\n-\t      && TREE_CODE (newdecl) != TYPE_DECL\n-\t      && TREE_CODE (newdecl) != CONST_DECL\n-\t      && TREE_CODE (newdecl) != TEMPLATE_DECL)\n-\t    layout_decl (newdecl, 0);\n-\t}\n-      else\n-\t{\n-\t  /* Since the type is OLDDECL's, make OLDDECL's size go with.  */\n-\t  DECL_SIZE (newdecl) = DECL_SIZE (olddecl);\n-\t}\n+      if (oldtype != TREE_TYPE (newdecl)\n+\t  && TREE_TYPE (newdecl) != error_mark_node)\n+\tlayout_type (TREE_TYPE (newdecl));\n+\n+      if (TREE_CODE (newdecl) == VAR_DECL\n+\t  || TREE_CODE (newdecl) == PARM_DECL\n+\t  || TREE_CODE (newdecl) == RESULT_DECL\n+\t  || TREE_CODE (newdecl) == FIELD_DECL\n+\t  || TREE_CODE (newdecl) == TYPE_DECL)\n+\tlayout_decl (newdecl, 0);\n \n       /* Merge the type qualifiers.  */\n       if (TREE_READONLY (newdecl))\n@@ -7660,7 +7652,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n       if (TREE_CODE (type) == REAL_TYPE)\n \terror (\"short, signed or unsigned invalid for `%s'\", name);\n-      else if (TREE_CODE (type) != INTEGER_TYPE || type == wchar_type_node)\n+      else if (TREE_CODE (type) != INTEGER_TYPE)\n \terror (\"long, short, signed or unsigned invalid for `%s'\", name);\n       else if (RIDBIT_SETP (RID_LONG, specbits)\n \t       && RIDBIT_SETP (RID_SHORT, specbits))\n@@ -7780,6 +7772,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  error (\"non-object member `%s' cannot be declared `mutable'\", name);\n \t  RIDBIT_RESET (RID_MUTABLE, specbits);\n \t}\n+      else if (constp)\n+\t{\n+\t  error (\"const `%s' cannot be declared `mutable'\", name);\n+\t  RIDBIT_RESET (RID_MUTABLE, specbits);\n+\t}\n       else if (staticp)\n \t{\n \t  error (\"static `%s' cannot be declared `mutable'\", name);\n@@ -7820,7 +7817,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n     }\n \n   /* Give error if `virtual' is used outside of class declaration.  */\n-  if (virtualp && current_class_name == NULL_TREE)\n+  if (virtualp\n+      && (current_class_name == NULL_TREE || decl_context != FIELD))\n     {\n       error (\"virtual outside class declaration\");\n       virtualp = 0;\n@@ -7972,14 +7970,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t{\n \t  if (decl_context == FIELD)\n \t    {\n-\t      tree tmp = TREE_OPERAND (declarator, 0);\n-\t      register int op = IDENTIFIER_OPNAME_P (tmp);\n+\t      tree tmp = NULL_TREE;\n+\t      register int op = 0;\n+\n+\t      if (declarator)\n+\t\t{\n+\t\t  tmp = TREE_OPERAND (declarator, 0);\n+\t\t  op = IDENTIFIER_OPNAME_P (tmp);\n+\t\t}\n \t      error (\"storage class specified for %s `%s'\",\n \t\t     IS_SIGNATURE (current_class_type)\n \t\t     ? (op\n \t\t\t? \"signature member operator\"\n \t\t\t: \"signature member function\")\n-\t\t     : (op ? \"member operator\" : \"structure field\"),\n+\t\t     : (op ? \"member operator\" : \"field\"),\n \t\t     op ? operator_name_string (tmp) : name);\n \t    }\n \t  else\n@@ -8092,6 +8096,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  {\n \t    register tree itype = NULL_TREE;\n \t    register tree size = TREE_OPERAND (declarator, 1);\n+\t    /* The index is a signed object `sizetype' bits wide.  */\n+\t    tree index_type = signed_type (sizetype);\n \n \t    declarator = TREE_OPERAND (declarator, 0);\n \n@@ -8181,8 +8187,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\tcp_error (\"size of array `%D' is negative\", dname);\n \t\t\tsize = integer_one_node;\n \t\t      }\n-\t\t    itype = build_index_type (size_binop (MINUS_EXPR, size,\n-\t\t\t\t\t\t\t  integer_one_node));\n \t\t  }\n \t\telse\n \t\t  {\n@@ -8194,15 +8198,20 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\telse\n \t\t\t  cp_pedwarn (\"ANSI C++ forbids variable-size array\");\n \t\t      }\n-\t\t  dont_grok_size:\n-\t\t    itype =\n-\t\t      build_binary_op (MINUS_EXPR, size, integer_one_node, 1);\n \t\t    /* Make sure the array size remains visibly nonconstant\n-\t\t       even if it is (eg) a const variable with known value.  */\n+\t\t       even if it is (eg) a const variable with known value. */\n \t\t    size_varies = 1;\n-\t\t    itype = variable_size (itype);\n-\t\t    itype = build_index_type (itype);\n \t\t  }\n+\n+\t      dont_grok_size:\n+\t\titype =\n+\t\t  fold (build_binary_op (MINUS_EXPR,\n+\t\t\t\t\t convert (index_type, size),\n+\t\t\t\t\t convert (index_type,\n+\t\t\t\t\t\t  integer_one_node), 1));\n+\t\tif (! TREE_CONSTANT (itype))\n+\t\t  itype = variable_size (itype);\n+\t\titype = build_index_type (itype);\n \t\tresume_momentary (yes);\n \t      }\n \n@@ -8262,10 +8271,14 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t    if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n \t      inner_decl = TREE_OPERAND (inner_decl, 1);\n \n+\t    /* Pick up type qualifiers which should be applied to `this'.  */\n+\t    quals = TREE_OPERAND (declarator, 2);\n+\n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n \t    funcdecl_p =\n-\t      inner_decl && TREE_CODE (inner_decl) == IDENTIFIER_NODE;\n+\t      inner_decl && (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n+\t\t\t     || TREE_CODE (inner_decl) == BIT_NOT_EXPR);\n \n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n@@ -8289,14 +8302,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t       may not be static.  */\n \t\t    if (staticp == 2)\n \t\t      error (\"destructor cannot be static member function\");\n-\t\t    if (TYPE_READONLY (type))\n-\t\t      {\n-\t\t\terror (\"destructors cannot be declared `const'\");\n-\t\t\treturn void_type_node;\n-\t\t      }\n-\t\t    if (TYPE_VOLATILE (type))\n+\t\t    if (quals)\n \t\t      {\n-\t\t\terror (\"destructors cannot be declared `volatile'\");\n+\t\t\terror (\"destructors cannot be declared `const' or `volatile'\");\n \t\t\treturn void_type_node;\n \t\t      }\n \t\t    if (decl_context == FIELD)\n@@ -8320,16 +8328,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\t\tpedwarn (\"constructors cannot be declared virtual\");\n \t\t\tvirtualp = 0;\n \t\t      }\n-\t\t    if (TYPE_READONLY (type))\n+\t\t    if (quals)\n \t\t      {\n-\t\t\terror (\"constructors cannot be declared `const'\");\n+\t\t\terror (\"constructors cannot be declared `const' or `volatile'\");\n \t\t\treturn void_type_node;\n  \t\t      }\n-\t\t    if (TYPE_VOLATILE (type))\n-\t\t      {\n-\t\t\terror (\"constructors cannot be declared `volatile'\");\n-\t\t\treturn void_type_node;\n-\t\t      }\n \t\t    {\n \t\t      RID_BIT_TYPE tmp_bits;\n \t\t      bcopy ((void*)&specbits, (void*)&tmp_bits, sizeof(RID_BIT_TYPE));\n@@ -8358,20 +8361,22 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t\tif (decl_context == FIELD)\n \t\t  staticp = 0;\n \t      }\n-\t    else if (friendp && virtualp)\n+\t    else if (friendp)\n \t      {\n-\t\t/* Cannot be both friend and virtual.  */\n-\t\terror (\"virtual functions cannot be friends\");\n-\t\tRIDBIT_RESET (RID_FRIEND, specbits);\n-\t\tfriendp = 0;\n+\t\tif (initialized)\n+\t\t  error (\"can't initialize friend function `%s'\", name);\n+\t\tif (virtualp)\n+\t\t  {\n+\t\t    /* Cannot be both friend and virtual.  */\n+\t\t    error (\"virtual functions cannot be friends\");\n+\t\t    RIDBIT_RESET (RID_FRIEND, specbits);\n+\t\t    friendp = 0;\n+\t\t  }\n \t      }\n \n \t    if (decl_context == NORMAL && friendp)\n \t      error (\"friend declaration not in class definition\");\n \n-\t    /* Pick up type qualifiers which should be applied to `this'.  */\n-\t    quals = TREE_OPERAND (declarator, 2);\n-\n \t    /* Traditionally, declaring return type float means double.  */\n \n \t    if (flag_traditional\n@@ -8836,13 +8841,28 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n       /* Special case: \"friend class foo\" looks like a TYPENAME context.  */\n       if (friendp)\n \t{\n-\t  /* A friendly class?  */\n-\t  if (current_class_type)\n-\t    make_friend_class (current_class_type, TYPE_MAIN_VARIANT (type));\n-\t  else\n-\t    error(\"trying to make class `%s' a friend of global scope\",\n-\t\t  TYPE_NAME_STRING (type));\n-\t  type = void_type_node;\n+\t  if (volatilep)\n+\t    {\n+\t      cp_error (\"`volatile' specified for friend class declaration\");\n+\t      volatilep = 0;\n+\t    }\n+\t  if (inlinep)\n+\t    {\n+\t      cp_error (\"`inline' specified for friend class declaration\");\n+\t      inlinep = 0;\n+\t    }\n+\n+\t  /* Only try to do this stuff if we didn't already give up.  */\n+\t  if (type != integer_type_node)\n+\t    {\n+\t      /* A friendly class?  */\n+\t      if (current_class_type)\n+\t\tmake_friend_class (current_class_type, TYPE_MAIN_VARIANT (type));\n+\t      else\n+\t\terror (\"trying to make class `%s' a friend of global scope\",\n+\t\t       TYPE_NAME_STRING (type));\n+\t      type = void_type_node;\n+\t    }\n \t}\n       else if (quals)\n \t{\n@@ -8878,7 +8898,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \n   if (TYPE_MAIN_VARIANT (type) == void_type_node && decl_context != PARM)\n     {\n-      if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n+      if (! declarator)\n+\terror (\"unnamed variable or field declared void\");\n+      else if (TREE_CODE (declarator) == IDENTIFIER_NODE)\n \t{\n \t  if (IDENTIFIER_OPNAME_P (declarator))\n #if 0\t\t\t\t/* How could this happen? */\n@@ -8921,6 +8943,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t  type = build_pointer_type (type);\n \telse if (TREE_CODE (type) == OFFSET_TYPE)\n \t  type = build_pointer_type (type);\n+\telse if (type == void_type_node && declarator)\n+\t  {\n+\t    error (\"declaration of `%s' as void\", name);\n+\t    return NULL_TREE;\n+\t  }\n \n \tdecl = build_decl (PARM_DECL, declarator, type);\n \n@@ -9030,7 +9057,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \telse if (TYPE_SIZE (type) == NULL_TREE && !staticp\n \t\t && (TREE_CODE (type) != ARRAY_TYPE || initialized == 0))\n \t  {\n-\t    cp_error (\"field `%D' has incomplete type\", declarator);\n+\t    if (declarator)\n+\t      cp_error (\"field `%D' has incomplete type\", declarator);\n+\t    else\n+\t      cp_error (\"name `%T' has incomplete type\", type);\n \n \t    /* If we're instantiating a template, tell them which\n \t       instantiation made the field's type be incomplete.  */\n@@ -9302,6 +9332,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, raises)\n \t        staticp = 0;\n \t\tRIDBIT_RESET (RID_STATIC, specbits);\n \t      }\n+\t    if (RIDBIT_SETP (RID_REGISTER, specbits) && TREE_STATIC (decl))\n+\t      {\n+\t\tcp_error (\"static member `%D' declared `register'\", decl);\n+\t\tRIDBIT_RESET (RID_REGISTER, specbits);\n+\t      }\n \t    if (RIDBIT_SETP (RID_EXTERN, specbits))\n \t      {\n \t        cp_error (\"cannot explicitly declare member `%#D' to have extern linkage\",\n@@ -9583,7 +9618,8 @@ grokparms (first_parm, funcdef_flag)\n \t\t      any_init++;\n \t\t      if (TREE_CODE (init) == SAVE_EXPR)\n \t\t\tPARM_DECL_EXPR (init) = 1;\n-\t\t      else if (TREE_CODE (init) == VAR_DECL)\n+\t\t      else if (TREE_CODE (init) == VAR_DECL\n+\t\t\t       || TREE_CODE (init) == PARM_DECL)\n \t\t\t{\n \t\t\t  if (IDENTIFIER_LOCAL_VALUE (DECL_NAME (init)))\n \t\t\t    {\n@@ -10656,6 +10692,8 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n   original_result_rtx = NULL_RTX;\n   current_function_obstack_index = 0;\n   current_function_obstack_usage = 0;\n+  base_init_insns = NULL_RTX;\n+  protect_list = NULL_TREE;\n \n   clear_temp_name ();\n \n@@ -10751,7 +10789,7 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \t  if (TREE_TYPE (TREE_TYPE (decl1)) != integer_type_node)\n \t    {\n \t      if (pedantic || warn_return_type)\n-\t\twarning (\"return type for `main' changed to integer type\");\n+\t\tpedwarn (\"return type for `main' changed to integer type\");\n \t      TREE_TYPE (decl1) = fntype = default_function_type;\n \t    }\n \t  warn_about_return_type = 0;\n@@ -10795,6 +10833,10 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n       DECL_RESULT (decl1) = build_decl (RESULT_DECL, 0, TREE_TYPE (fntype));\n     }\n \n+  if (TYPE_LANG_SPECIFIC (TREE_TYPE (fntype))\n+      && CLASSTYPE_ABSTRACT_VIRTUALS (TREE_TYPE (fntype)))\n+    abstract_virtuals_error (decl1, TREE_TYPE (fntype));\n+\n   if (warn_about_return_type)\n     warning (\"return-type defaults to `int'\");\n \n@@ -10824,14 +10866,19 @@ start_function (declspecs, declarator, raises, pre_parsed_p)\n \tDECL_EXTERNAL (decl1) = current_extern_inline;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n+  else if (current_extern_inline)\n+    {\n+      /* `extern inline' acts like a declaration except for\n+\t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n+      DECL_EXTERNAL (decl1) = 1;\n+      DECL_INTERFACE_KNOWN (decl1) = 1;\n+    }\n   else\n     {\n       /* This is a definition, not a reference.\n-\t So normally clear DECL_EXTERNAL.\n-\t However, `extern inline' acts like a declaration except for\n-\t defining how to inline.  So set DECL_EXTERNAL in that case.  */\n-      DECL_EXTERNAL (decl1) = current_extern_inline;\n-\n+\t So clear DECL_EXTERNAL.  */\n+      DECL_EXTERNAL (decl1) = 0;\n+      \n       if (DECL_INLINE (decl1) && (DECL_FUNCTION_MEMBER_P (decl1)\n \t\t\t\t  || DECL_TEMPLATE_INSTANTIATION (decl1)))\n \t/* We know nothing yet */;\n@@ -11423,6 +11470,7 @@ finish_function (lineno, call_poplevel, nested)\n \n       if (DECL_CONSTRUCTOR_P (current_function_decl))\n \t{\n+\t  end_protect_partials ();\n \t  expand_label (ctor_label);\n \t  ctor_label = NULL_TREE;\n \n@@ -11503,6 +11551,8 @@ finish_function (lineno, call_poplevel, nested)\n       if (mark != get_last_insn ())\n \treorder_insns (next_insn (mark), get_last_insn (), last_parm_insn);\n \n+      end_protect_partials ();\n+\n       /* This is where the body of the constructor ends.  */\n       expand_label (ctor_label);\n       ctor_label = NULL_TREE;\n@@ -11643,8 +11693,14 @@ finish_function (lineno, call_poplevel, nested)\n   /* Run the optimizers and output the assembler code for this function.  */\n   rest_of_compilation (fndecl);\n \n-  if (DECL_DEFER_OUTPUT (fndecl))\n-    mark_inline_for_output (fndecl);\n+  if (DECL_SAVED_INSNS (fndecl) && ! TREE_ASM_WRITTEN (fndecl))\n+    {\n+      /* Set DECL_EXTERNAL so that assemble_external will be called as\n+         necessary.  We'll clear it again in import_export_inline.  */\n+      if (TREE_PUBLIC (fndecl))\n+\tDECL_EXTERNAL (fndecl) = 1;\n+      mark_inline_for_output (fndecl);\n+    }\n \n   if (ctype && TREE_ASM_WRITTEN (fndecl))\n     note_debug_info_needed (ctype);\n@@ -12121,7 +12177,9 @@ struct cp_function\n   tree shadowed_labels;\n   tree ctor_label;\n   tree dtor_label;\n+  tree protect_list;\n   rtx result_rtx;\n+  rtx base_init_insns;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n };\n@@ -12156,6 +12214,8 @@ push_cp_function_context (toplev)\n   p->just_assigned_this = current_function_just_assigned_this;\n   p->parms_stored = current_function_parms_stored;\n   p->result_rtx = original_result_rtx;\n+  p->base_init_insns = base_init_insns;\n+  p->protect_list = protect_list;\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -12197,10 +12257,12 @@ pop_cp_function_context (toplev)\n   current_binding_level = p->binding_level;\n   ctor_label = p->ctor_label;\n   dtor_label = p->dtor_label;\n+  protect_list = p->protect_list;\n   current_function_assigns_this = p->assigns_this;\n   current_function_just_assigned_this = p->just_assigned_this;\n   current_function_parms_stored = p->parms_stored;\n   original_result_rtx = p->result_rtx;\n+  base_init_insns = p->base_init_insns;\n \n   free (p);\n }"}, {"sha": "6cc04204cd9a23883cb1b7d7d623172fdb9851f1", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 81, "deletions": 86, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1027,6 +1027,7 @@ grok_array_decl (array_expr, index_exp)\n      tree array_expr, index_exp;\n {\n   tree type = TREE_TYPE (array_expr);\n+  tree p1, p2, i1, i2;\n \n   if (type == error_mark_node || index_exp == error_mark_node)\n     return error_mark_node;\n@@ -1049,28 +1050,38 @@ grok_array_decl (array_expr, index_exp)\n \t\t\t   array_expr, index_exp, NULL_TREE);\n \n   /* Otherwise, create an ARRAY_REF for a pointer or array type.  */\n-  if (TREE_CODE (type) == POINTER_TYPE\n-      || TREE_CODE (type) == ARRAY_TYPE)\n-    return build_array_ref (array_expr, index_exp);\n \n-  /* Woops, looks like they did something like `5[a]' instead of `a[5]'.\n-     We don't emit a warning or error for this, since it's allowed\n-     by ARM $8.2.4.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    p1 = array_expr;\n+  else\n+    p1 = build_expr_type_conversion (WANT_POINTER, array_expr, 0);\n \n-  type = TREE_TYPE (index_exp);\n+  if (TREE_CODE (TREE_TYPE (index_exp)) == ARRAY_TYPE)\n+    p2 = index_exp;\n+  else\n+    p2 = build_expr_type_conversion (WANT_POINTER, index_exp, 0);\n \n-  if (TREE_CODE (type) == OFFSET_TYPE\n-      || TREE_CODE (type) == REFERENCE_TYPE)\n-    type = TREE_TYPE (type);\n+  i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, 0);\n+  i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, 0);\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n-      || TREE_CODE (type) == ARRAY_TYPE)\n-    return build_array_ref (index_exp, array_expr);\n+  if ((p1 && i2) && (i1 && p2))\n+    error (\"ambiguous conversion for array subscript\");\n \n-  /* The expression E1[E2] is identical (by definition) to *((E1)+(E2)).  */\n-  return build_indirect_ref (build_binary_op (PLUS_EXPR, array_expr,\n-\t\t\t\t\t      index_exp, 1),\n-\t\t\t     \"array indexing\");\n+  if (p1 && i2)\n+    array_expr = p1, index_exp = i2;\n+  else if (i1 && p2)\n+    array_expr = p2, index_exp = i1;\n+  else\n+    {\n+      cp_error (\"invalid types `%T[%T]' for array subscript\",\n+\t\ttype, TREE_TYPE (index_exp));\n+      return error_mark_node;\n+    }\n+\n+  if (array_expr == error_mark_node || index_exp == error_mark_node)\n+    error (\"ambiguous conversion for array subscript\");\n+\n+  return build_array_ref (array_expr, index_exp);\n }\n \n /* Given the cast expression EXP, checking out its validity.   Either return\n@@ -2487,8 +2498,8 @@ import_export_vtable (decl, type, final)\n     }\n   else\n     {\n-      /* We can only do this optimization if we have real non-inline\n-\t virtual functions in our class, or if we come from a template.  */\n+      /* We can only wait to decide if we have real non-inline virtual\n+\t functions in our class, or if we come from a template.  */\n \n       int found = CLASSTYPE_TEMPLATE_INSTANTIATION (type);\n \n@@ -2543,7 +2554,8 @@ finish_prevtable_vardecl (prev, vars)\n   tree ctype = DECL_CONTEXT (vars);\n   import_export_template (ctype);\n \n-  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype))\n+  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype)\n+      && ! CLASSTYPE_TEMPLATE_INSTANTIATION (ctype))\n     {\n       tree method;\n       for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n@@ -2562,59 +2574,25 @@ finish_prevtable_vardecl (prev, vars)\n \n   import_export_vtable (vars, ctype, 1);\n \n-  if (write_virtuals >= 0\n+  if (flag_rtti && write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n-      extern tree the_null_vtable_entry;\n-\n       /* Kick out the type descriptor before writing out the vtable.  */\n-      if (flag_rtti)\n-\t{\n-\t  build_t_desc (ctype, 1);\n-\t}\n-\n-      /* Write it out.  */\n-      mark_vtable_entries (vars);\n+      build_t_desc (ctype, 1);\n     }\n }\n     \n static void\n finish_vtable_vardecl (prev, vars)\n      tree prev, vars;\n {\n-  tree ctype = DECL_CONTEXT (vars);\n-  import_export_template (ctype);\n-\n-  if (CLASSTYPE_INTERFACE_UNKNOWN (ctype) && TYPE_VIRTUAL_P (ctype))\n-    {\n-      tree method;\n-      for (method = CLASSTYPE_METHODS (ctype); method != NULL_TREE;\n-\t   method = DECL_NEXT_METHOD (method))\n-\t{\n-\t  if (DECL_VINDEX (method) != NULL_TREE && !DECL_SAVED_INSNS (method)\n-\t      && !DECL_ABSTRACT_VIRTUAL_P (method))\n-\t    {\n-\t      SET_CLASSTYPE_INTERFACE_KNOWN (ctype);\n-\t      CLASSTYPE_VTABLE_NEEDS_WRITING (ctype) = ! DECL_EXTERNAL (method);\n-\t      CLASSTYPE_INTERFACE_ONLY (ctype) = DECL_EXTERNAL (method);\n-\t      if (flag_rtti)\n-\t\tcp_warning (\"compiler error: rtti entry for `%T' decided too late\", ctype);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  import_export_vtable (vars, ctype, 1);\n-\n   if (write_virtuals >= 0\n       && ! DECL_EXTERNAL (vars) && (TREE_PUBLIC (vars) || TREE_USED (vars)))\n     {\n-      extern tree the_null_vtable_entry;\n-\n       /* Write it out.  */\n       mark_vtable_entries (vars);\n       if (TREE_TYPE (DECL_INITIAL (vars)) == 0)\n-\t  store_init_value (vars, DECL_INITIAL (vars));\n+\tstore_init_value (vars, DECL_INITIAL (vars));\n \n #ifdef DWARF_DEBUGGING_INFO\n       if (write_symbols == DWARF_DEBUG)\n@@ -2646,8 +2624,18 @@ finish_vtable_vardecl (prev, vars)\n \n       rest_of_decl_compilation (vars, NULL_PTR, 1, 1);\n     }\n-  else if (TREE_USED (vars))\n-    assemble_external (vars);\n+  else if (! TREE_USED (vars))\n+    /* We don't know what to do with this one yet.  */\n+    return;\n+\n+  /* We know that PREV must be non-zero here.  */\n+  TREE_CHAIN (prev) = TREE_CHAIN (vars);\n+}\n+\n+static void\n+prune_vtable_vardecl (prev, vars)\n+     tree prev, vars;\n+{\n   /* We know that PREV must be non-zero here.  */\n   TREE_CHAIN (prev) = TREE_CHAIN (vars);\n }\n@@ -2731,6 +2719,8 @@ import_export_inline (decl)\n   if (DECL_INTERFACE_KNOWN (decl))\n     return;\n \n+  DECL_EXTERNAL (decl) = 0;\n+\n   if (DECL_TEMPLATE_INSTANTIATION (decl))\n     {\n       if (DECL_IMPLICIT_INSTANTIATION (decl) && flag_implicit_templates)\n@@ -2773,7 +2763,6 @@ finish_file ()\n   tree fnname;\n   tree vars = static_aggregates;\n   int needs_cleaning = 0, needs_messing_up = 0;\n-  int have_exception_handlers = build_exception_table ();\n \n   if (flag_detailed_statistics)\n     dump_tree_statistics ();\n@@ -2788,7 +2777,7 @@ finish_file ()\n      we'll need here.  */\n   push_lang_context (lang_name_c);\n \n-  if (static_ctors || vars || have_exception_handlers)\n+  if (static_ctors || vars || might_have_exceptions_p ())\n     needs_messing_up = 1;\n   if (static_dtors)\n     needs_cleaning = 1;\n@@ -2900,7 +2889,7 @@ finish_file ()\n       push_momentary ();\n       expand_start_bindings (0);\n \n-      if (have_exception_handlers)\n+      if (might_have_exceptions_p ())\n \tregister_exception_table ();\n \n       while (vars)\n@@ -2931,6 +2920,7 @@ finish_file ()\n \t      /* 9.5p5: The initializer of a static member of a class has\n \t\t the same acess rights as a member function.  */\n \t      DECL_CLASS_CONTEXT (current_function_decl) = DECL_CONTEXT (decl);\n+\t      DECL_STATIC_FUNCTION_P (current_function_decl) = 1;\n \n #if 0\n \t      if (init)\n@@ -3061,30 +3051,9 @@ finish_file ()\n   pushdecl (vars);\n #endif\n \n-  walk_vtables ((void (*)())0, finish_vtable_vardecl);\n   if (flag_handle_signatures)\n     walk_sigtables ((void (*)())0, finish_sigtable_vardecl);\n \n-  for (vars = saved_inlines; vars; vars = TREE_CHAIN (vars))\n-    {\n-      tree decl = TREE_VALUE (vars);\n-\n-      if (DECL_ARTIFICIAL (decl)\n-\t  && ! DECL_INITIAL (decl)\n-\t  && TREE_USED (decl))\n-\tsynthesize_method (decl);\n-    }\n-\n-  for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n-    {\n-      if (TREE_CODE (vars) == THUNK_DECL)\n-\temit_thunk (vars);\n-      else if (TREE_CODE (vars) == FUNCTION_DECL\n-\t       && ! DECL_INTERFACE_KNOWN (vars)\n-\t       && DECL_DECLARED_STATIC (vars))\n-\tTREE_PUBLIC (vars) = 0;\n-    }\n-\n   /* Now write out inline functions which had their addresses taken and\n      which were not declared virtual and which were not declared `extern\n      inline'.  */\n@@ -3098,10 +3067,23 @@ finish_file ()\n \ttree place = TREE_CHAIN (saved_inlines);\n \treconsider = 0;\n \n+\twalk_vtables ((void (*)())0, finish_vtable_vardecl);\n+\n \tfor (; place; place = TREE_CHAIN (place))\n \t  {\n \t    tree decl = TREE_VALUE (place);\n \n+\t    if (DECL_ARTIFICIAL (decl) && ! DECL_INITIAL (decl))\n+\t      {\n+\t\tif (TREE_USED (decl))\n+\t\t  synthesize_method (decl);\n+\t\telse\n+\t\t  {\n+\t\t    last = place;\n+\t\t    continue;\n+\t\t  }\n+\t      }\n+\n \t    if (TREE_ASM_WRITTEN (decl) || DECL_SAVED_INSNS (decl) == 0)\n \t      {\n \t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n@@ -3114,9 +3096,7 @@ finish_file ()\n \t      {\n \t\tTREE_CHAIN (last) = TREE_CHAIN (place);\n \n-\t\tif (DECL_EXTERNAL (decl))\n-\t\t  assemble_external (decl);\n-\t\telse\n+\t\tif (! DECL_EXTERNAL (decl))\n \t\t  {\n \t\t    reconsider = 1;\n \t\t    temporary_allocation ();\n@@ -3132,6 +3112,21 @@ finish_file ()\n       }\n   }\n \n+  walk_vtables ((void (*)())0, prune_vtable_vardecl);\n+\n+  for (vars = getdecls (); vars; vars = TREE_CHAIN (vars))\n+    {\n+      if (TREE_CODE (vars) == THUNK_DECL)\n+\temit_thunk (vars);\n+      else if (TREE_CODE (vars) == FUNCTION_DECL\n+\t       && ! DECL_INTERFACE_KNOWN (vars)\n+\t       && DECL_DECLARED_STATIC (vars))\n+\tTREE_PUBLIC (vars) = 0;\n+    }\n+\n+  if (might_have_exceptions_p ())\n+    emit_exception_table ();\n+\n   if (write_virtuals == 2)\n     {\n       /* Now complain about an virtual function tables promised"}, {"sha": "215dd17924033c278d4d3030827b490c38abaad0", "filename": "gcc/cp/error.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -585,7 +585,7 @@ dump_decl (t, v)\n       break;\n       \n     case VAR_DECL:\n-      if (VTABLE_NAME_P (DECL_NAME (t)))\n+      if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n \t  OB_PUTS (\"vtable for \");\n \t  dump_type (DECL_CONTEXT (t), v);\n@@ -933,9 +933,16 @@ dump_expr (t, nop)\n \t    char *p = enum_name_string (t, type);\n \t    OB_PUTCP (p);\n \t  }\n-\telse if (type == char_type_node\n-\t\t || type == signed_char_type_node\n-\t\t || type == unsigned_char_type_node)\n+\telse if (type == boolean_type_node)\n+\t  {\n+\t    if (t == boolean_false_node)\n+\t      OB_PUTS (\"false\");\n+\t    else if (t == boolean_true_node)\n+\t      OB_PUTS (\"true\");\n+\t    else\n+\t      my_friendly_abort (366);\n+\t  }\n+\telse if (type == char_type_node)\n \t  {\n \t    OB_PUTC ('\\'');\n \t    dump_char (TREE_INT_CST_LOW (t));"}, {"sha": "607d5034f2a55f3255912c7bd720c46b6f61345a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -31,6 +31,8 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"expr.h\"\n \n+tree protect_list;\n+\n extern void (*interim_eh_hook)\tPROTO((tree));\n \n /* holds the fndecl for __builtin_return_address () */\n@@ -53,6 +55,11 @@ tree builtin_return_address_fndecl;\n #define __mips\n #endif\n #endif\n+#ifdef __i386__\n+#ifndef __i386\n+#define __i386\n+#endif\n+#endif\n #if defined(__i386) || defined(__rs6000) || defined(__hppa) || defined(__mc68000) || defined (__mips) || defined (__arm) || defined (__alpha)\n #define TRY_NEW_EH\n #endif\n@@ -872,11 +879,13 @@ void\n end_protect (finalization)\n      tree finalization;\n {\n-  struct ehEntry *entry = pop_eh_entry (&ehstack);\n+  struct ehEntry *entry;\n \n   if (! doing_eh (0))\n     return;\n \n+  entry = pop_eh_entry (&ehstack);\n+\n   emit_label (entry->end_label);\n \n   entry->finalization = finalization;\n@@ -1574,11 +1583,29 @@ expand_throw (exp)\n /* end of: my-cp-except.c */\n #endif\n \n+void\n+end_protect_partials () {\n+  while (protect_list)\n+    {\n+      end_protect (TREE_VALUE (protect_list));\n+      protect_list = TREE_CHAIN (protect_list);\n+    }\n+}\n+\n+int\n+might_have_exceptions_p ()\n+{\n+#ifdef TRY_NEW_EH\n+  if (eh_table_output_queue.head)\n+    return 1;\n+#endif\n+  return 0;\n+}\n \n /* Output the exception table.\n  Return the number of handlers.  */\n-int\n-build_exception_table ()\n+void\n+emit_exception_table ()\n {\n   int count = 0;\n #ifdef TRY_NEW_EH\n@@ -1587,7 +1614,15 @@ build_exception_table ()\n   tree eh_node_decl;\n \n   if (! doing_eh (0))\n-    return 0;\n+    return;\n+\n+  exception_section ();\n+\n+  /* Beginning marker for table. */\n+  ASM_OUTPUT_ALIGN (asm_out_file, 2);\n+  ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_TABLE__\");\n+  output_exception_table_entry (asm_out_file,\n+\t\t\t\tconst0_rtx, const0_rtx, const0_rtx);\n \n  while (entry = dequeue_eh_entry (&eh_table_output_queue))\n    {\n@@ -1596,32 +1631,18 @@ build_exception_table ()\n      if (context && ! TREE_ASM_WRITTEN (context))\n        continue;\n \n-     if (count == 0)\n-       {\n-\t exception_section ();\n-\n-\t /* Beginning marker for table. */\n-\t ASM_OUTPUT_ALIGN (asm_out_file, 2);\n-\t ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_TABLE__\");\n-\t output_exception_table_entry (asm_out_file,\n-\t\t\t\t       const0_rtx, const0_rtx, const0_rtx);\n-       }\n      count++;\n      output_exception_table_entry (asm_out_file,\n \t\t\t\t   entry->start_label, entry->end_label,\n \t\t\t\t   entry->exception_handler_label);\n   }\n \n-  if (count)\n-    {\n-      /* Ending marker for table. */\n-      ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_END__\");\n-      output_exception_table_entry (asm_out_file,\n-\t\t\t\t    constm1_rtx, constm1_rtx, constm1_rtx);\n-    }\n+  /* Ending marker for table. */\n+  ASM_OUTPUT_LABEL (asm_out_file, \"__EXCEPTION_END__\");\n+  output_exception_table_entry (asm_out_file,\n+\t\t\t\tconstm1_rtx, constm1_rtx, constm1_rtx);\n \n #endif /* TRY_NEW_EH */\n-  return count;\n }\n \n void"}, {"sha": "01c5bcb896a3140d4b49470140a71cd7307c042c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 359, "deletions": 350, "changes": 709, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -157,8 +157,8 @@ expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n /* 348 - 351 */\n /* Subroutine of emit_base_init.  */\n static void\n-perform_member_init (member, name, init, explicit)\n-     tree member, name, init;\n+perform_member_init (member, name, init, explicit, protect_list)\n+     tree member, name, init, *protect_list;\n      int explicit;\n {\n   tree decl;\n@@ -223,27 +223,44 @@ perform_member_init (member, name, init, explicit)\n \t}\n     }\n   expand_cleanups_to (NULL_TREE);\n-  if (flag_handle_exceptions && TYPE_NEEDS_DESTRUCTOR (type))\n-    cp_warning (\"caution, member `%D' may not be destroyed in the presense of an exception during construction\", member);\n+\n+  if (TYPE_NEEDS_DESTRUCTOR (type))\n+    {\n+      tree expr = build_component_ref (C_C_D, name, 0, explicit);\n+      expr = build_delete (type, expr, integer_zero_node,\n+\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\n+      if (expr != error_mark_node)\n+\t{\n+\t  start_protect ();\n+\t  *protect_list = tree_cons (NULL_TREE, expr, *protect_list);\n+\t}\n+    }\n }\n \n+extern int warn_reorder;\n+\n /* Subroutine of emit_member_init.  */\n static tree\n sort_member_init (t)\n      tree t;\n {\n-  extern int warn_reorder;\n   tree x, member, name, field, init;\n   tree init_list = NULL_TREE;\n   tree fields_to_unmark = NULL_TREE;\n-  int found;\n   int last_pos = 0;\n   tree last_field;\n \n   for (member = TYPE_FIELDS (t); member ; member = TREE_CHAIN (member))\n     {\n       int pos;\n-      found = 0;\n+\n+      /* member could be, for example, a CONST_DECL for an enumerated\n+\t tag; we don't want to try to initialize that, since it already\n+\t has a value.  */\n+      if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n+\tcontinue;\n+\n       for (x = current_member_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n \t{\n \t  /* If we cleared this out, then pay no attention to it.  */\n@@ -266,17 +283,9 @@ sort_member_init (t)\n \n \t  if (field == member)\n \t    {\n-\t      /* See if we already found an initializer for this field.  */\n-\t      if (found)\n-\t\t{\n-\t\t  if (DECL_NAME (field))\n-\t\t    cp_error (\"multiple initializations given for member `%D'\",\n-\t\t\t      field);\n-\t\t  continue;\n-\t\t}\n-\t      else\n+\t      if (warn_reorder)\n \t\t{\n-\t\t  if (pos < last_pos && warn_reorder)\n+\t\t  if (pos < last_pos)\n \t\t    {\n \t\t      cp_warning_at (\"member initializers for `%#D'\", last_field);\n \t\t      cp_warning_at (\"  and `%#D'\", field);\n@@ -286,78 +295,193 @@ sort_member_init (t)\n \t\t  last_field = field;\n \t\t}\n \n-\t      init_list = chainon (init_list,\n-\t\t\t\t   build_tree_list (name, TREE_VALUE (x)));\n \t      /* Make sure we won't try to work on this init again.  */\n \t      TREE_PURPOSE (x) = NULL_TREE;\n-\t      found = 1;\n-\t      break;\n+\t      x = build_tree_list (name, TREE_VALUE (x));\n+\t      goto got_it;\n \t    }\n \t}\n \n       /* If we didn't find MEMBER in the list, create a dummy entry\n \t so the two lists (INIT_LIST and the list of members) will be\n \t symmetrical.  */\n-      if (! found)\n-\tinit_list = chainon (init_list, build_tree_list (NULL_TREE, NULL_TREE));\n+      x = build_tree_list (NULL_TREE, NULL_TREE);\n+    got_it:\n+      init_list = chainon (init_list, x); \n     }\n \n+  /* Initializers for base members go at the end.  */\n   for (x = current_member_init_list ; x ; x = TREE_CHAIN (x))\n     {\n-      if (TREE_PURPOSE (x))\n+      name = TREE_PURPOSE (x);\n+      if (name)\n \t{\n-\t  name = TREE_PURPOSE (x);\n-\t  init = TREE_VALUE (x);\n-\t  /* XXX: this may need the COMPONENT_REF operand 0 check if\n-\t     it turns out we actually get them.  */\n-\t  field = IDENTIFIER_CLASS_VALUE (name);\n-\n-\t  /* If one member shadows another, get the outermost one.  */\n-\t  if (TREE_CODE (field) == TREE_LIST)\n+\t  if (purpose_member (name, init_list))\n \t    {\n-\t      field = TREE_VALUE (field);\n-\t      if (decl_type_context (field) != current_class_type)\n-\t\tcp_error (\"field `%D' not in immediate context\", field);\n+\t      cp_error (\"multiple initializations given for member `%D'\",\n+\t\t\tIDENTIFIER_CLASS_VALUE (name));\n+\t      continue;\n \t    }\n+\t      \n+\t  init_list = chainon (init_list,\n+\t\t\t       build_tree_list (name, TREE_VALUE (x)));\n+\t  TREE_PURPOSE (x) = NULL_TREE;\n+\t}\n+    }\n \n-#if 0\n-\t  /* It turns out if you have an anonymous union in the\n-\t     class, a member from it can end up not being on the\n-\t     list of fields (rather, the type is), and therefore\n-\t     won't be seen by the for loop above.  */\n+  return init_list;\n+}\n \n-\t  /* The code in this for loop is derived from a general loop\n-\t     which had this check in it.  Theoretically, we've hit\n-\t     every initialization for the list of members in T, so\n-\t     we shouldn't have anything but these left in this list.  */\n-\t  my_friendly_assert (DECL_FIELD_CONTEXT (field) != t, 351);\n-#endif\n+static void\n+sort_base_init (t, rbase_ptr, vbase_ptr)\n+     tree t, *rbase_ptr, *vbase_ptr;\n+{\n+  tree binfos = BINFO_BASETYPES (TYPE_BINFO (t));\n+  int n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  int i;\n+  tree x;\n+  tree last;\n+\n+  /* For warn_reorder.  */\n+  int last_pos = 0;\n+  tree last_base = NULL_TREE;\n+\n+  tree rbases = NULL_TREE;\n+  tree vbases = NULL_TREE;\n \n-\t  if (TREE_HAS_CONSTRUCTOR (field))\n+  /* First walk through and splice out vbase and invalid initializers.\n+     Also replace names with binfos.  */\n+\n+  last = tree_cons (NULL_TREE, NULL_TREE, current_base_init_list);\n+  for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n+    {\n+      tree basename = TREE_PURPOSE (x);\n+      tree binfo;\n+\n+      if (basename == NULL_TREE)\n+\t{\n+\t  /* Initializer for single base class.  Must not\n+\t     use multiple inheritance or this is ambiguous.  */\n+\t  switch (n_baseclasses)\n \t    {\n-\t      if (DECL_NAME (field))\n-\t\terror (\"multiple initializations given for member `%s'\",\n-\t\t       IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t      continue;\n+\t    case 0:\n+\t      cp_error (\"`%T' does not have a base class to initialize\",\n+\t\t\tcurrent_class_type);\n+\t      return;\n+\t    case 1:\n+\t      break;\n+\t    default:\n+\t      cp_error (\"unnamed initializer ambiguous for `%T' which uses multiple inheritance\",\n+\t\t\tcurrent_class_type);\n+\t      return;\n \t    }\n+\t  binfo = TREE_VEC_ELT (binfos, 0);\n+\t}\n+      else if (is_aggr_typedef (basename, 1))\n+\t{\n+\t  binfo = binfo_or_else (IDENTIFIER_TYPE_VALUE (basename), t);\n+\t  if (binfo == NULL_TREE)\n+\t    continue;\n \n-\t  TREE_HAS_CONSTRUCTOR (field) = 1;\n-\t  fields_to_unmark = tree_cons (NULL_TREE, field, fields_to_unmark);\n+\t  /* Virtual base classes are special cases.  Their initializers\n+\t     are recorded with this constructor, and they are used when\n+\t     this constructor is the top-level constructor called.  */\n+\t  if (TREE_VIA_VIRTUAL (binfo))\n+\t    {\n+\t      tree v = CLASSTYPE_VBASECLASSES (t);\n+\t      while (BINFO_TYPE (v) != BINFO_TYPE (binfo))\n+\t\tv = TREE_CHAIN (v);\n \n-\t  perform_member_init (field, name, init, 1);\n-\t  TREE_PURPOSE (x) = NULL_TREE;\n+\t      vbases = tree_cons (v, TREE_VALUE (x), vbases);\n+\t      continue;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, if it is not an immediate base class, complain.  */\n+\t      for (i = n_baseclasses-1; i >= 0; i--)\n+\t\tif (BINFO_TYPE (binfo) == BINFO_TYPE (TREE_VEC_ELT (binfos, i)))\n+\t\t  break;\n+\t      if (i < 0)\n+\t\t{\n+\t\t  cp_error (\"`%T' is not an immediate base class of `%T'\",\n+\t\t\t    IDENTIFIER_TYPE_VALUE (basename),\n+\t\t\t    current_class_type);\n+\t\t  continue;\n+\t\t}\n+\t    }\n \t}\n+      else\n+\tmy_friendly_abort (365);\n+\n+      TREE_PURPOSE (x) = binfo;\n+      TREE_CHAIN (last) = x;\n+      last = x;\n     }\n+  TREE_CHAIN (last) = NULL_TREE;\n \n-  /* Unmark fields which are initialized for the base class.  */\n-  while (fields_to_unmark)\n+  /* Now walk through our regular bases and make sure they're initialized.  */\n+\n+  for (i = 0; i < n_baseclasses; ++i)\n     {\n-      TREE_HAS_CONSTRUCTOR (TREE_VALUE (fields_to_unmark)) = 0;\n-      /* XXX is this a memory leak? */\n-      fields_to_unmark = TREE_CHAIN (fields_to_unmark);\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      int pos;\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n+\n+      for (x = current_base_init_list, pos = 0; x; x = TREE_CHAIN (x), ++pos)\n+\t{\n+\t  tree binfo = TREE_PURPOSE (x);\n+\n+\t  if (binfo == NULL_TREE)\n+\t    continue;\n+\n+\t  if (binfo == base_binfo)\n+\t    {\n+\t      if (warn_reorder)\n+\t\t{\n+\t\t  if (pos < last_pos)\n+\t\t    {\n+\t\t      cp_warning_at (\"base initializers for `%#T'\", last_base);\n+\t\t      cp_warning_at (\"  and `%#T'\", BINFO_TYPE (binfo));\n+\t\t      warning (\"  will be re-ordered to match inheritance order\");\n+\t\t    }\n+\t\t  last_pos = pos;\n+\t\t  last_base = BINFO_TYPE (binfo);\n+\t\t}\n+\n+\t      /* Make sure we won't try to work on this init again.  */\n+\t      TREE_PURPOSE (x) = NULL_TREE;\n+\t      x = build_tree_list (binfo, TREE_VALUE (x));\n+\t      goto got_it;\n+\t    }\n+\t}\n+\n+      /* If we didn't find BASE_BINFO in the list, create a dummy entry\n+\t so the two lists (RBASES and the list of bases) will be\n+\t symmetrical.  */\n+      x = build_tree_list (NULL_TREE, NULL_TREE);\n+    got_it:\n+      rbases = chainon (rbases, x);\n     }\n \n-  return init_list;\n+  *rbase_ptr = rbases;\n+  *vbase_ptr = vbases;\n+}\n+\n+/* Perform partial cleanups for a base for exception handling.  */\n+static tree\n+build_partial_cleanup_for (binfo)\n+     tree binfo;\n+{\n+  tree expr = convert_pointer_to_real (binfo,\n+\t\t\t\t       build_unary_op (ADDR_EXPR, C_C_D, 0));\n+\n+  return build_delete (TREE_TYPE (expr),\n+\t\t       expr,\n+\t\t       integer_zero_node,\n+\t\t       LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n }\n \n /* Perform whatever initializations have yet to be done on the base\n@@ -385,13 +509,14 @@ emit_base_init (t, immediately)\n {\n   extern tree in_charge_identifier;\n \n-  tree member, vbases;\n-  tree init_list;\n-  int pass, start;\n+  tree member, x;\n+  tree mem_init_list;\n+  tree rbase_init_list, vbase_init_list;\n   tree t_binfo = TYPE_BINFO (t);\n   tree binfos = BINFO_BASETYPES (t_binfo);\n   int i, n_baseclasses = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n-  int have_init_list = 0, from_init_list;\n+\n+  my_friendly_assert (protect_list == NULL_TREE, 999);\n \n   if (! immediately)\n     {\n@@ -407,282 +532,145 @@ emit_base_init (t, immediately)\n     emit_line_note_force (DECL_SOURCE_FILE (current_function_decl),\n \t\t\t  DECL_SOURCE_LINE (current_function_decl));\n \n-  start = ! TYPE_USES_VIRTUAL_BASECLASSES (t);\n-  for (pass = start; pass < 2; pass++)\n-    {\n-      tree vbase_init_list = NULL_TREE;\n-\n-      for (init_list = current_base_init_list; init_list;\n-\t   init_list = TREE_CHAIN (init_list))\n-\t{\n-\t  tree basename = TREE_PURPOSE (init_list);\n-\t  tree binfo;\n-\t  tree init = TREE_VALUE (init_list);\n-\n-\t  if (basename == NULL_TREE)\n-\t    {\n-\t      /* Initializer for single base class.  Must not\n-\t\t use multiple inheritance or this is ambiguous.  */\n-\t      switch (n_baseclasses)\n-\t\t{\n-\t\tcase 0:\n-\t\t  cp_error (\"`%T' does not have a base class to initialize\",\n-\t\t\t    current_class_type);\n-\t\t  return;\n-\t\tcase 1:\n-\t\t  break;\n-\t\tdefault:\n-\t\t  cp_error (\"unnamed initializer ambiguous for `%T' which uses multiple inheritance\",\n-\t\t\t    current_class_type);\n-\t\t  return;\n-\t\t}\n-\t      binfo = TREE_VEC_ELT (binfos, 0);\n-\t    }\n-\t  else if (is_aggr_typedef (basename, 1))\n-\t    {\n-\t      binfo = binfo_or_else (IDENTIFIER_TYPE_VALUE (basename), t);\n-\t      if (binfo == NULL_TREE)\n-\t\tcontinue;\n-\n-\t      /* Virtual base classes are special cases.  Their initializers\n-\t\t are recorded with this constructor, and they are used when\n-\t\t this constructor is the top-level constructor called.  */\n-\t      if (! TREE_VIA_VIRTUAL (binfo))\n-\t\t{\n-\t\t  /* Otherwise, if it is not an immediate base class, complain.  */\n-\t\t  for (i = n_baseclasses-1; i >= 0; i--)\n-\t\t    if (BINFO_TYPE (binfo) == BINFO_TYPE (TREE_VEC_ELT (binfos, i)))\n-\t\t      break;\n-\t\t  if (i < 0)\n-\t\t    {\n-\t\t      cp_error (\"`%T' is not an immediate base class of `%T'\",\n-\t\t\t\tIDENTIFIER_TYPE_VALUE (basename),\n-\t\t\t\tcurrent_class_type);\n-\t\t      continue;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else\n-\t    continue;\n-\n-\t  /* The base initialization list goes up to the first\n-\t     base class which can actually use it.  */\n-\n-\t  if (pass == start)\n-\t    {\n-\t      char *msgp = (! TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (binfo)))\n-\t\t? \"cannot pass initialization up to class `%s'\" : 0;\n-\n-\t      while (! TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (binfo))\n-\t\t     && BINFO_BASETYPES (binfo) != NULL_TREE\n-\t\t     && TREE_VEC_LENGTH (BINFO_BASETYPES (binfo)) == 1)\n-\t\t{\n-\t\t  /* ?? This should be fixed in RENO by forcing\n-\t\t     default constructors to exist.  */\n-\t\t  SET_BINFO_BASEINIT_MARKED (binfo);\n-\t\t  binfo = BINFO_BASETYPE (binfo, 0);\n-\t\t}\n-\n-\t      /* We used to give an error if this wasn't true, saying that\n-\t\t there's no constructor for the initialization of basename.\n-\t\t This turned out to be incorrect---it should use the\n-\t\t default constructor, since a user could try to initialize\n-\t\t the class in a derived class's base initializer list.  */\n-\t      if (TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (binfo)))\n-\t\t{\n-\t\t  if (msgp)\n-\t\t    {\n-\t\t      if (pedantic)\n-\t\t\terror_with_aggr_type (binfo, msgp);\n-\t\t      else\n-\t\t\tmsgp = NULL;\n-\t\t    }\n-\t\t}\n-\n-\t      if (BINFO_BASEINIT_MARKED (binfo))\n-\t\t{\n-\t\t  msgp = \"class `%s' initializer already specified\";\n-\t\t  error (msgp, IDENTIFIER_POINTER (basename));\n-\t\t}\n-\n-\t      if (msgp)\n-\t\tcontinue;\n-\n-\t      SET_BINFO_BASEINIT_MARKED (binfo);\n-\t      if (TREE_VIA_VIRTUAL (binfo))\n-\t\t{\n-\t\t  vbase_init_list = tree_cons (init, BINFO_TYPE (binfo),\n-\t\t\t\t\t       vbase_init_list);\n-\t\t  continue;\n-\t\t}\n-\t      if (pass == 0)\n-\t\tcontinue;\n-\t    }\n-\t  else if (TREE_VIA_VIRTUAL (binfo))\n-\t    continue;\n+  mem_init_list = sort_member_init (t);\n+  current_member_init_list = NULL_TREE;\n \n-\t  member = convert_pointer_to (binfo, current_class_decl);\n-\t  expand_aggr_init_1 (binfo, 0,\n-\t\t\t      build_indirect_ref (member, NULL_PTR), init,\n-\t\t\t      BINFO_OFFSET_ZEROP (binfo), LOOKUP_NORMAL);\n-\t  expand_cleanups_to (NULL_TREE);\n-\t}\n+  sort_base_init (t, &rbase_init_list, &vbase_init_list);\n+  current_base_init_list = NULL_TREE;\n \n-      if (pass == 0)\n-\t{\n-\t  tree first_arg = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n-\t  tree vbases;\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n+    {\n+      tree first_arg = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n \n-\t  if (DECL_NAME (current_function_decl) == NULL_TREE\n-\t      && TREE_CHAIN (first_arg) != NULL_TREE)\n-\t    {\n-\t      /* If there are virtual baseclasses without initialization\n-\t\t specified, and this is a default X(X&) constructor,\n-\t\t build the initialization list so that each virtual baseclass\n-\t\t of the new object is initialized from the virtual baseclass\n-\t\t of the incoming arg.  */\n-\t      tree init_arg = build_unary_op (ADDR_EXPR, TREE_CHAIN (first_arg), 0);\n-\t      for (vbases = CLASSTYPE_VBASECLASSES (t);\n-\t\t   vbases; vbases = TREE_CHAIN (vbases))\n-\t\t{\n-\t\t  if (BINFO_BASEINIT_MARKED (vbases) == 0)\n-\t\t    {\n-\t\t      member = convert_pointer_to (vbases, init_arg);\n-\t\t      if (member == init_arg)\n-\t\t\tmember = TREE_CHAIN (first_arg);\n-\t\t      else\n-\t\t\tTREE_TYPE (member) = build_reference_type (BINFO_TYPE (vbases));\n-\t\t      vbase_init_list = tree_cons (convert_from_reference (member),\n-\t\t\t\t\t\t   vbases, vbase_init_list);\n-\t\t      SET_BINFO_BASEINIT_MARKED (vbases);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  expand_start_cond (first_arg, 0);\n-\t  expand_aggr_vbase_init (t_binfo, C_C_D, current_class_decl,\n-\t\t\t\t  vbase_init_list);\n-\t  expand_end_cond ();\n-\t}\n+      expand_start_cond (first_arg, 0);\n+      expand_aggr_vbase_init (t_binfo, C_C_D, current_class_decl,\n+\t\t\t      vbase_init_list);\n+      expand_end_cond ();\n     }\n-  current_base_init_list = NULL_TREE;\n \n-  /* Now, perform default initialization of all base classes which\n-     have not yet been initialized, and unmark baseclasses which\n-     have been initialized.  */\n+  /* Now, perform initialization of non-virtual base classes.  */\n   for (i = 0; i < n_baseclasses; i++)\n     {\n       tree base = current_class_decl;\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n+      tree init = void_list_node;\n+\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n \n #if 0 /* Once unsharing happens soon enough.  */\n       my_friendly_assert (BINFO_INHERITANCE_CHAIN (base_binfo) == t_binfo);\n #else\n       BINFO_INHERITANCE_CHAIN (base_binfo) = t_binfo;\n #endif\n \n-      if (TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (base_binfo)))\n-\t{\n-\t  if (! TREE_VIA_VIRTUAL (base_binfo)\n-\t      && ! BINFO_BASEINIT_MARKED (base_binfo))\n-\t    {\n-\t      tree ref;\n+      if (TREE_PURPOSE (rbase_init_list))\n+\tinit = TREE_VALUE (rbase_init_list);\n+      else if (TYPE_NEEDS_CONSTRUCTING (BINFO_TYPE (base_binfo)))\n+\tinit = NULL_TREE;\n \n-\t      if (BINFO_OFFSET_ZEROP (base_binfo))\n-\t\tbase = build1 (NOP_EXPR,\n-\t\t\t       TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n-\t\t\t       current_class_decl);\n-\t      else\n-\t\tbase = build (PLUS_EXPR,\n-\t\t\t      TYPE_POINTER_TO (BINFO_TYPE (base_binfo)),\n-\t\t\t      current_class_decl, BINFO_OFFSET (base_binfo));\n-\n-\t      ref = build_indirect_ref (base, NULL_PTR);\n-\t      expand_aggr_init_1 (base_binfo, 0, ref, NULL_TREE,\n-\t\t\t\t  BINFO_OFFSET_ZEROP (base_binfo),\n-\t\t\t\t  LOOKUP_NORMAL);\n-\t      expand_cleanups_to (NULL_TREE);\n-\t    }\n+      if (init != void_list_node)\n+\t{\n+\t  member = convert_pointer_to (base_binfo, current_class_decl);\n+\t  expand_aggr_init_1 (base_binfo, 0,\n+\t\t\t      build_indirect_ref (member, NULL_PTR), init,\n+\t\t\t      BINFO_OFFSET_ZEROP (base_binfo), LOOKUP_NORMAL);\n+\t  expand_cleanups_to (NULL_TREE);\n \t}\n-      CLEAR_BINFO_BASEINIT_MARKED (base_binfo);\n \n-      if (! TYPE_USES_VIRTUAL_BASECLASSES (t))\n+      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n-\t  while (! TYPE_HAS_CONSTRUCTOR (BINFO_TYPE (base_binfo))\n-\t\t && BINFO_BASETYPES (base_binfo) != NULL_TREE\n-\t\t && TREE_VEC_LENGTH (BINFO_BASETYPES (base_binfo)) == 1)\n-\t    {\n-\t      /* ?? This should be fixed in RENO by forcing\n-\t\t default constructors to exist.  It is needed for symmetry\n-\t\t with code above.  */\n-\t      base_binfo = BINFO_BASETYPE (base_binfo, 0);\n-\t      CLEAR_BINFO_BASEINIT_MARKED (base_binfo);\n-\t    }\n+\t  start_protect ();\n+\t  protect_list = tree_cons (NULL_TREE,\n+\t\t\t\t    build_partial_cleanup_for (base_binfo),\n+\t\t\t\t    protect_list);\n \t}\n+\n+      rbase_init_list = TREE_CHAIN (rbase_init_list);\n     }\n \n   /* Initialize all the virtual function table fields that\n      do come from virtual base classes. */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n     expand_indirect_vtbls_init (t_binfo, C_C_D, current_class_decl, 0);\n-  for (vbases = CLASSTYPE_VBASECLASSES (t); vbases; vbases = TREE_CHAIN (vbases))\n-    CLEAR_BINFO_BASEINIT_MARKED (vbases);\n \n   /* Initialize all the virtual function table fields that\n      do not come from virtual base classes.  */\n   expand_direct_vtbls_init (t_binfo, t_binfo, 1, 1, current_class_decl);\n \n-  if (current_member_init_list)\n-    {\n-      init_list = sort_member_init (t);\n-      have_init_list = 1;\n-    }\n-\n   for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n     {\n       tree init, name;\n-      from_init_list = 0;\n+      int from_init_list;\n+\n+      /* member could be, for example, a CONST_DECL for an enumerated\n+\t tag; we don't want to try to initialize that, since it already\n+\t has a value.  */\n+      if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n+\tcontinue;\n \n       /* See if we had a user-specified member initialization.  */\n-      if (have_init_list)\n+      if (TREE_PURPOSE (mem_init_list))\n \t{\n-\t  if (TREE_PURPOSE (init_list))\n-\t    {\n-\t      name = TREE_PURPOSE (init_list);\n-\t      init = TREE_VALUE (init_list);\n-\t      from_init_list = 1;\n+\t  name = TREE_PURPOSE (mem_init_list);\n+\t  init = TREE_VALUE (mem_init_list);\n+\t  from_init_list = 1;\n \n-\t      if (TREE_STATIC (member))\n-\t\t{\n-\t\t  cp_error (\"field `%#D' is static; only point of initialization is its declaration\",\n-\t\t\t    member);\n-\t\t  continue;\n-\t\t}\n-\n-\t      /* Also see if it's ever a COMPONENT_REF here.  If it is, we\n-\t\t need to do `expand_assignment (name, init, 0, 0);' and\n-\t\t a continue.  */\n-\t      my_friendly_assert (TREE_CODE (name) != COMPONENT_REF, 349);\n-\t    }\n-\n-\t  init_list = TREE_CHAIN (init_list);\n+\t  /* Also see if it's ever a COMPONENT_REF here.  If it is, we\n+\t     need to do `expand_assignment (name, init, 0, 0);' and\n+\t     a continue.  */\n+\t  my_friendly_assert (TREE_CODE (name) != COMPONENT_REF, 349);\n \t}\n-\n-      if (! from_init_list)\n+      else\n \t{\n-\t  /* member could be, for example, a CONST_DECL for an enumerated\n-\t     tag; we don't want to try to initialize that, since it already\n-\t     has a value.  */\n-\t  if (TREE_CODE (member) != FIELD_DECL || !DECL_NAME (member))\n-\t    continue;\n-\n \t  name = DECL_NAME (member);\n \t  init = DECL_INITIAL (member);\n+\n+\t  from_init_list = 0;\n \t}\n \n-      perform_member_init (member, name, init, from_init_list);\n+      perform_member_init (member, name, init, from_init_list, &protect_list);\n+      mem_init_list = TREE_CHAIN (mem_init_list);\n     }\n \n-  current_member_init_list = NULL_TREE;\n+  /* Now initialize any members from our bases.  */\n+  while (mem_init_list)\n+    {\n+      tree name, init, field;\n+\n+      if (TREE_PURPOSE (mem_init_list))\n+\t{\n+\t  name = TREE_PURPOSE (mem_init_list);\n+\t  init = TREE_VALUE (mem_init_list);\n+\t  /* XXX: this may need the COMPONENT_REF operand 0 check if\n+\t     it turns out we actually get them.  */\n+\t  field = IDENTIFIER_CLASS_VALUE (name);\n+\n+\t  /* If one member shadows another, get the outermost one.  */\n+\t  if (TREE_CODE (field) == TREE_LIST)\n+\t    {\n+\t      field = TREE_VALUE (field);\n+\t      if (decl_type_context (field) != current_class_type)\n+\t\tcp_error (\"field `%D' not in immediate context\", field);\n+\t    }\n+\n+#if 0\n+\t  /* It turns out if you have an anonymous union in the\n+\t     class, a member from it can end up not being on the\n+\t     list of fields (rather, the type is), and therefore\n+\t     won't be seen by the for loop above.  */\n+\n+\t  /* The code in this for loop is derived from a general loop\n+\t     which had this check in it.  Theoretically, we've hit\n+\t     every initialization for the list of members in T, so\n+\t     we shouldn't have anything but these left in this list.  */\n+\t  my_friendly_assert (DECL_FIELD_CONTEXT (field) != t, 351);\n+#endif\n+\n+\t  perform_member_init (field, name, init, 1, &protect_list);\n+\t}\n+      mem_init_list = TREE_CHAIN (mem_init_list);\n+    }\n \n   if (! immediately)\n     {\n@@ -750,14 +738,13 @@ static void\n expand_aggr_vbase_init_1 (binfo, exp, addr, init_list)\n      tree binfo, exp, addr, init_list;\n {\n-  tree init = value_member (BINFO_TYPE (binfo), init_list);\n+  tree init = purpose_member (binfo, init_list);\n   tree ref = build_indirect_ref (addr, NULL_PTR);\n   if (init)\n-    init = TREE_PURPOSE (init);\n+    init = TREE_VALUE (init);\n   /* Call constructors, but don't set up vtables.  */\n   expand_aggr_init_1 (binfo, exp, ref, init, 0, LOOKUP_COMPLAIN);\n   expand_cleanups_to (NULL_TREE);\n-  CLEAR_BINFO_VBASE_INIT_MARKED (binfo);\n }\n \n /* Initialize this object's virtual base class pointers.  This must be\n@@ -781,38 +768,14 @@ expand_aggr_vbase_init (binfo, exp, addr, init_list)\n       if (result)\n \texpand_expr_stmt (build_compound_expr (result));\n \n-      /* Mark everything as having an initializer\n-\t (either explicit or default).  */\n-      for (vbases = CLASSTYPE_VBASECLASSES (type);\n-\t   vbases; vbases = TREE_CHAIN (vbases))\n-\tSET_BINFO_VBASE_INIT_MARKED (vbases);\n-\n-      /* First, initialize baseclasses which could be baseclasses\n-\t for other virtual baseclasses.  */\n-      for (vbases = CLASSTYPE_VBASECLASSES (type);\n-\t   vbases; vbases = TREE_CHAIN (vbases))\n-\t/* Don't initialize twice.  */\n-\tif (BINFO_VBASE_INIT_MARKED (vbases))\n-\t  {\n-\t    tree tmp = result;\n-\n-\t    while (BINFO_TYPE (vbases) != BINFO_TYPE (TREE_PURPOSE (tmp)))\n-\t      tmp = TREE_CHAIN (tmp);\n-\t    expand_aggr_vbase_init_1 (vbases, exp,\n-\t\t\t\t      TREE_OPERAND (TREE_VALUE (tmp), 0),\n-\t\t\t\t      init_list);\n-\t  }\n-\n-      /* Now initialize the baseclasses which don't have virtual baseclasses.  */\n-      for (; result; result = TREE_CHAIN (result))\n-\t/* Don't initialize twice.  */\n-\tif (BINFO_VBASE_INIT_MARKED (TREE_PURPOSE (result)))\n-\t  {\n-\t    my_friendly_abort (47);\n-\t    expand_aggr_vbase_init_1 (TREE_PURPOSE (result), exp,\n-\t\t\t\t      TREE_OPERAND (TREE_VALUE (result), 0),\n-\t\t\t\t      init_list);\n-\t  }\n+      for (vbases = CLASSTYPE_VBASECLASSES (type); vbases;\n+\t   vbases = TREE_CHAIN (vbases))\n+\t{\n+\t  tree tmp = purpose_member (vbases, result);\n+\t  expand_aggr_vbase_init_1 (vbases, exp,\n+\t\t\t\t    TREE_OPERAND (TREE_VALUE (tmp), 0),\n+\t\t\t\t    init_list);\n+\t}\n     }\n }\n \n@@ -862,7 +825,7 @@ member_init_ok_or_else (field, type, member_name)\n   if (field == NULL_TREE)\n     {\n       cp_error (\"class `%T' does not have any field named `%s'\", type,\n-\t\t  member_name);\n+\t\tmember_name);\n       return 0;\n     }\n   if (DECL_CONTEXT (field) != type\n@@ -872,6 +835,13 @@ member_init_ok_or_else (field, type, member_name)\n \t\tfield);\n       return 0;\n     }\n+  if (TREE_STATIC (field))\n+    {\n+      cp_error (\"field `%#D' is static; only point of initialization is its declaration\",\n+\t\tfield);\n+      return 0;\n+    }\n+\n   return 1;\n }\n \n@@ -1209,7 +1179,8 @@ expand_default_init (binfo, true_exp, exp, type, init, alias_this, flags)\n   tree rval;\n   tree parms;\n \n-  if (init == NULL_TREE || TREE_CODE (init) == TREE_LIST)\n+  if (init == NULL_TREE\n+      || (TREE_CODE (init) == TREE_LIST && ! TREE_TYPE (init)))\n     {\n       parms = init;\n       if (parms)\n@@ -2044,6 +2015,12 @@ build_offset_ref (cname, name)\n       return t;\n     }\n \n+  if (TREE_CODE (t) == FIELD_DECL && DECL_BIT_FIELD (t))\n+    {\n+      cp_error (\"illegal pointer to bit field `%D'\", t);\n+      return error_mark_node;\n+    }\n+\n   /* static class functions too.  */\n   if (TREE_CODE (t) == FUNCTION_DECL && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n     my_friendly_abort (53);\n@@ -2085,7 +2062,7 @@ get_member_function (exp_addr_ptr, exp, member)\n       if (UNITS_PER_WORD <= 1)\n \tmy_friendly_abort (54);\n \n-      e1 = build (GT_EXPR, integer_type_node, e0, integer_zero_node);\n+      e1 = build (GT_EXPR, boolean_type_node, e0, integer_zero_node);\n       e1 = build_compound_expr (tree_cons (NULL_TREE, exp_addr,\n \t\t\t\t\t   build_tree_list (NULL_TREE, e1)));\n       e1 = save_expr (e1);\n@@ -2240,7 +2217,7 @@ resolve_offset_ref (exp)\n     }\n   else if (TYPE_PTRMEMFUNC_P (TREE_TYPE (member)))\n     {\n-      return get_member_function_from_ptrfunc (&addr, base, member);\n+      return get_member_function_from_ptrfunc (&addr, member);\n     }\n   my_friendly_abort (56);\n   /* NOTREACHED */\n@@ -2322,7 +2299,13 @@ is_friend (type, supplicant)\n     {\n       tree list = DECL_FRIENDLIST (TYPE_NAME (type));\n       tree name = DECL_NAME (supplicant);\n-      tree ctype = DECL_CLASS_CONTEXT (supplicant);\n+      tree ctype;\n+\n+      if (DECL_FUNCTION_MEMBER_P (supplicant))\n+\tctype = DECL_CLASS_CONTEXT (supplicant);\n+      else\n+\tctype = NULL_TREE;\n+\n       for (; list ; list = TREE_CHAIN (list))\n \t{\n \t  if (name == TREE_PURPOSE (list))\n@@ -2353,8 +2336,14 @@ is_friend (type, supplicant)\n     }      \n \n   {\n-    tree context = declp ? DECL_CLASS_CONTEXT (supplicant)\n-\t\t\t : DECL_CONTEXT (TYPE_NAME (supplicant));\n+    tree context;\n+\n+    if (! declp)\n+      context = DECL_CONTEXT (TYPE_NAME (supplicant));\n+    else if (DECL_FUNCTION_MEMBER_P (supplicant))\n+      context = DECL_CLASS_CONTEXT (supplicant);\n+    else\n+      context = NULL_TREE;\n \n     if (context)\n       return is_friend (type, context);\n@@ -2508,7 +2497,7 @@ make_friend_class (type, friend_type)\n     }\n   if (type == friend_type)\n     {\n-      warning (\"class `%s' is implicitly friends with itself\",\n+      pedwarn (\"class `%s' is implicitly friends with itself\",\n \t       TYPE_NAME_STRING (type));\n       return;\n     }\n@@ -2803,7 +2792,7 @@ build_new (placement, decl, init, use_global_new)\n {\n   tree type, true_type, size, rval;\n   tree nelts;\n-  tree alloc_expr;\n+  tree alloc_expr, alloc_temp;\n   int has_array = 0;\n   enum tree_code code = NEW_EXPR;\n \n@@ -2927,6 +2916,12 @@ build_new (placement, decl, init, use_global_new)\n       type = true_type = TREE_TYPE (type);\n     }\n \n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    {\n+      error (\"new cannot be applied to a function type\");\n+      return error_mark_node;\n+    }\n+\n   /* When the object being created is an array, the new-expression yields a\n      pointer to the initial element (if any) of the array.  For example,\n      both new int and new int[10] return an int*.  5.3.4.  */\n@@ -2956,7 +2951,7 @@ build_new (placement, decl, init, use_global_new)\n \n   if (true_type == void_type_node)\n     {\n-      error (\"invalid type for new: `void'\");\n+      error (\"invalid type `void' for new\");\n       return error_mark_node;\n     }\n \n@@ -3032,12 +3027,19 @@ build_new (placement, decl, init, use_global_new)\n       TREE_CALLS_NEW (rval) = 1;\n     }\n \n-  if (flag_check_new)\n+  if (flag_check_new && rval)\n     {\n-      if (rval)\n-\trval = save_expr (rval);\n-      alloc_expr = rval;\n+      /* For array new, we need to make sure that the call to new is\n+\t not expanded as part of the RTL_EXPR for the initialization,\n+\t so we can't just use save_expr here.  */\n+\n+      alloc_temp = get_temp_name (TREE_TYPE (rval), 0);\n+      alloc_expr = build (MODIFY_EXPR, TREE_TYPE (rval), alloc_temp, rval);\n+      TREE_SIDE_EFFECTS (alloc_expr) = 1;\n+      rval = alloc_temp;\n     }\n+  else\n+    alloc_expr = NULL_TREE;\n \n   /* if rval is NULL_TREE I don't have to allocate it, but are we totally\n      sure we have some extra bytes in that case for the BI_header_size\n@@ -3184,10 +3186,17 @@ build_new (placement, decl, init, use_global_new)\n \n  done:\n \n-  if (flag_check_new && alloc_expr && rval != alloc_expr)\n+  if (alloc_expr)\n     {\n-      tree ifexp = build_binary_op (NE_EXPR, alloc_expr, integer_zero_node, 1);\n-      rval = build_conditional_expr (ifexp, rval, alloc_expr);\n+      /* Did we modify the storage?  */\n+      if (rval != alloc_temp)\n+\t{\n+\t  tree ifexp = build_binary_op (NE_EXPR, alloc_expr,\n+\t\t\t\t\tinteger_zero_node, 1);\n+\t  rval = build_conditional_expr (ifexp, rval, alloc_temp);\n+\t}\n+      else\n+\trval = alloc_expr;\n     }\n \n   if (rval && TREE_TYPE (rval) != build_pointer_type (type))\n@@ -3354,7 +3363,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    }\n \t}\n \n-      expand_start_cond (build (GE_EXPR, integer_type_node,\n+      expand_start_cond (build (GE_EXPR, boolean_type_node,\n \t\t\t\titerator, integer_zero_node), 0);\n       expand_start_loop_continue_elsewhere (1);\n \n@@ -3394,7 +3403,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \texpand_assignment (base2,\n \t\t\t   build (PLUS_EXPR, TYPE_POINTER_TO (type), base2, size), 0, 0);\n       expand_loop_continue_here ();\n-      expand_exit_loop_if_false (0, build (NE_EXPR, integer_type_node,\n+      expand_exit_loop_if_false (0, build (NE_EXPR, boolean_type_node,\n \t\t\t\t\t   build (PREDECREMENT_EXPR, integer_type_node, iterator, integer_one_node), minus_one));\n \n       if (obey_regdecls)\n@@ -3975,7 +3984,7 @@ build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n \n   body = tree_cons (NULL_TREE,\n \t\t    build (EXIT_EXPR, void_type_node,\n-\t\t\t   build (EQ_EXPR, integer_type_node, base, tbase)),\n+\t\t\t   build (EQ_EXPR, boolean_type_node, base, tbase)),\n \t\t    body);\n \n   loop = build (LOOP_EXPR, void_type_node, build_compound_expr (body));\n@@ -4031,7 +4040,7 @@ build_vec_delete (base, maxindex, elt_size, auto_delete_vec, auto_delete,\n \n   /* Outermost wrapper: If pointer is null, punt.  */\n   body = build (COND_EXPR, void_type_node,\n-\t\tbuild (NE_EXPR, integer_type_node, base, integer_zero_node),\n+\t\tbuild (NE_EXPR, boolean_type_node, base, integer_zero_node),\n \t\tbody, integer_zero_node);\n   body = build1 (NOP_EXPR, void_type_node, body);\n "}, {"sha": "6cbc00671b29538841670eb51553ffbda8a90e40", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -4541,8 +4541,6 @@ real_yylex ()\n \t  { value = '}'; goto done; }\n \telse if (c == '%' && c1 == ':')\n \t  { value = '#'; goto done; }\n-\telse if (c == ':' && c1 == '>')\n-\t  { value = ']'; goto done; }\n \n \tnextchar = c1;\n \ttoken_buffer[1] = 0;\n@@ -4560,6 +4558,11 @@ real_yylex ()\n \t  value = SCOPE;\n \t  yylval.itype = 1;\n \t}\n+      else if (c == '>')\n+\t{\n+\t  value = ']';\n+\t  goto done;\n+\t}\n       else\n \t{\n \t  nextchar = c;"}, {"sha": "29b64e69e3dd246f8a631e61fab793fcc595712e", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -2211,12 +2211,14 @@ synthesize_method (fndecl)\n   int nested = (current_function_decl != NULL_TREE);\n   int toplev = (decl_function_context (fndecl) == NULL_TREE);\n   char *f = input_filename;\n+  tree base = DECL_CLASS_CONTEXT (fndecl);\n \n   if (nested)\n     push_cp_function_context (toplev);\n \n   input_filename = DECL_SOURCE_FILE (fndecl);\n-  extract_interface_info ();\n+  interface_unknown = CLASSTYPE_INTERFACE_UNKNOWN (base);\n+  interface_only = CLASSTYPE_INTERFACE_ONLY (base);\n   start_function (NULL_TREE, fndecl, NULL_TREE, 1);\n   store_parm_decls ();\n "}, {"sha": "d9430eca6cb1cff9f15f7c6522e9ccb518872199", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1074,8 +1074,10 @@ unary_expr:\n \t            {\n \t\t      tree t = TREE_VALUE ($2);\n \t\t      if (t != NULL_TREE\n-\t\t\t  && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-\t\t\tpedwarn (\"ANSI C++ forbids using sizeof() on a function\");\n+\t\t\t  && ((TREE_TYPE (t)\n+\t\t\t      && TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+\t\t\t      || is_overloaded_fn (t)))\n+\t\t\tpedwarn (\"ANSI C++ forbids taking the sizeof a function type\");\n \t\t    }\n \t\t  $$ = c_sizeof (TREE_TYPE ($2)); }\n \t| SIZEOF '(' type_id ')'  %prec HYPERUNARY\n@@ -1142,7 +1144,7 @@ new_initializer:\n \t   syntactically valid but semantically invalid.  */\n \t| '=' init\n \t\t{\n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids initialization of new expression with `='\");\n \t\t  $$ = $2;\n \t\t}\n@@ -1169,7 +1171,7 @@ cast_expr:\n \t\t{ \n \t\t  tree init = build_nt (CONSTRUCTOR, NULL_TREE,\n \t\t\t\t\tnreverse ($3)); \n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids constructor-expressions\");\n \t\t  /* Indicate that this was a GNU C constructor expression.  */\n \t\t  TREE_HAS_CONSTRUCTOR (init) = 1;\n@@ -1289,7 +1291,6 @@ unqualified_id:\n \n expr_or_declarator:\n \t  notype_unqualified_id\n-\t| notype_qualified_id\n \t| '*' expr_or_declarator %prec UNARY\n \t\t{ $$ = build_parse_node (INDIRECT_REF, $2); }\n \t| '&' expr_or_declarator %prec UNARY\n@@ -1301,9 +1302,6 @@ expr_or_declarator:\n direct_notype_declarator:\n \t  complex_direct_notype_declarator\n \t| notype_unqualified_id\n-\t| notype_qualified_id\n-\t\t{ push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n-\t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n \t| '(' expr_or_declarator ')'\n \t\t{ $$ = finish_decl_parsing ($2); }\n \t;\n@@ -1360,7 +1358,7 @@ primary:\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n \t\t{ tree rtl_exp;\n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  rtl_exp = expand_end_stmt_expr ($<ttype>2);\n \t\t  /* The statements have side effects, so the group does.  */\n@@ -1554,7 +1552,7 @@ primary:\n \t| object unqualified_id  %prec UNARY\n \t\t{ got_object = NULL_TREE;\n \t\t  $$ = build_component_ref ($$, $2, NULL_TREE, 1); }\n-\t| object qualified_id %prec UNARY\n+\t| object overqualified_id %prec UNARY\n \t\t{ got_object = NULL_TREE;\n \t\t  $$ = build_object_ref ($$, OP0 ($2), OP1 ($2)); }\n \t| object unqualified_id '(' nonnull_exprlist ')'\n@@ -1589,7 +1587,7 @@ primary:\n \t\t\t\t\t  (LOOKUP_NORMAL|LOOKUP_AGGR));\n #endif\n \t\t}\n-\t| object qualified_id '(' nonnull_exprlist ')'\n+\t| object overqualified_id '(' nonnull_exprlist ')'\n \t\t{\n \t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n@@ -1601,7 +1599,7 @@ primary:\n \t\t  else\n \t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), $4);\n \t\t}\n-\t| object qualified_id LEFT_RIGHT\n+\t| object overqualified_id LEFT_RIGHT\n \t\t{\n \t\t  got_object = NULL_TREE;\n \t\t  if (IS_SIGNATURE (IDENTIFIER_TYPE_VALUE (OP0 ($2))))\n@@ -1617,8 +1615,9 @@ primary:\n \t| object '~' TYPESPEC LEFT_RIGHT\n \t\t{\n \t\t  got_object = NULL_TREE;\n-\t\t  if (TREE_CODE (TREE_TYPE ($1)) \n-\t\t      != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3))))\n+\t\t  if (IDENTIFIER_GLOBAL_VALUE ($3)\n+\t\t      && (TREE_CODE (TREE_TYPE ($1)) \n+\t\t\t  != TREE_CODE (TREE_TYPE (IDENTIFIER_GLOBAL_VALUE ($3)))))\n \t\t    cp_error (\"`%E' is not of type `%T'\", $1, $3);\n \t\t  $$ = convert (void_type_node, $1);\n \t\t}\n@@ -1654,7 +1653,7 @@ primary_no_id:\n \t\t    }\n \t\t  $<ttype>$ = expand_start_stmt_expr (); }\n \t  compstmt ')'\n-\t\t{ if (flag_ansi)\n+\t\t{ if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  $$ = expand_end_stmt_expr ($<ttype>2); }\n \t| primary_no_id '(' nonnull_exprlist ')'\n@@ -1816,6 +1815,8 @@ typed_declspecs1:\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, $$); }\n \t| typespec reserved_declspecs\t%prec HYPERUNARY\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $$, $2); }\n+\t| typespec reserved_typespecquals reserved_declspecs\n+\t\t{ $$ = decl_tree_cons (NULL_TREE, $$, chainon ($2, $3)); }\n \t| declmods typespec reserved_declspecs\n \t\t{ $$ = decl_tree_cons (NULL_TREE, $2, chainon ($3, $$)); }\n \t| declmods typespec reserved_typespecquals\n@@ -1902,11 +1903,11 @@ typespec: structsp\n \t| complete_type_name\n \t| TYPEOF '(' expr ')'\n \t\t{ $$ = TREE_TYPE ($3);\n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| TYPEOF '(' type_id ')'\n \t\t{ $$ = groktypename ($3);\n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids `typeof'\"); }\n \t| SIGOF '(' expr ')'\n \t\t{ tree type = TREE_TYPE ($3);\n@@ -2763,7 +2764,7 @@ new_type_id:\n \t   non-constant dimension.  */\n \t| '(' type_id ')' '[' expr ']'\n \t\t{\n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids array dimensions with parenthesized type in new\");\n \t\t  $$ = build_parse_node (ARRAY_REF, TREE_VALUE ($2), $5);\n \t\t  $$ = build_decl_list (TREE_PURPOSE ($2), $$);\n@@ -2905,6 +2906,9 @@ complex_direct_notype_declarator:\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, $3); }\n \t| direct_notype_declarator '[' ']'\n \t\t{ $$ = build_parse_node (ARRAY_REF, $$, NULL_TREE); }\n+\t| notype_qualified_id\n+\t\t{ push_nested_class (TREE_TYPE (OP0 ($$)), 3);\n+\t\t  TREE_COMPLEXITY ($$) = current_class_depth; }\n \t;\n \n qualified_id:\n@@ -3107,7 +3111,7 @@ errstmt:  error ';'\n maybe_label_decls:\n \t  /* empty */\n \t| label_decls\n-\t\t{ if (flag_ansi)\n+\t\t{ if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids label declarations\"); }\n \t;\n \n@@ -3323,7 +3327,7 @@ simple_stmt:\n \t\t  register tree label\n \t\t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n-\t\t  if (flag_ansi)\n+\t\t  if (pedantic)\n \t\t    pedwarn (\"ANSI C++ forbids range expressions in switch statement\");\n \t\t  if (value1 != error_mark_node\n \t\t      && value2 != error_mark_node)"}, {"sha": "5ac3b633b3f1a945d72e5e68e35c31c1cf24d885", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -755,6 +755,8 @@ uses_template_parms (t)\n     case REFERENCE_TYPE:\n       return uses_template_parms (TREE_TYPE (t));\n     case RECORD_TYPE:\n+      if (TYPE_PTRMEMFUNC_FLAG (t))\n+\treturn uses_template_parms (TYPE_PTRMEMFUNC_FN_TYPE (t));\n     case UNION_TYPE:\n       if (!TYPE_NAME (t))\n \treturn 0;\n@@ -1153,9 +1155,8 @@ tsubst (t, args, nargs, in_decl)\n       && type != integer_type_node\n       && type != void_type_node\n       && type != char_type_node)\n-    type = cp_build_type_variant (tsubst (type, args, nargs, in_decl),\n-\t\t\t\t TYPE_READONLY (type),\n-\t\t\t\t TYPE_VOLATILE (type));\n+    type = tsubst (type, args, nargs, in_decl);\n+\n   switch (TREE_CODE (t))\n     {\n     case RECORD_TYPE:\n@@ -1679,12 +1680,16 @@ instantiate_template (tmpl, targ_ptr)\n   my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n   len = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n \n+  i = len;\n+  while (i--)\n+    targ_ptr[i] = copy_to_permanent (targ_ptr[i]);\n+\n   for (fndecl = DECL_TEMPLATE_INSTANTIATIONS (tmpl);\n        fndecl; fndecl = TREE_CHAIN (fndecl))\n     {\n       tree *t1 = &TREE_VEC_ELT (TREE_PURPOSE (fndecl), 0);\n       for (i = len - 1; i >= 0; i--)\n-\tif (t1[i] != targ_ptr[i])\n+\tif (simple_cst_equal (t1[i], targ_ptr[i]) <= 0)\n \t  goto no_match;\n \n       /* Here, we have a match.  */\n@@ -2036,6 +2041,15 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n \treturn 1;\n       if (arg == unknown_type_node)\n \treturn 1;\n+\n+      if (! uses_template_parms (parm)\n+\t  && TREE_CODE_CLASS (TREE_CODE (arg)) != 't')\n+\t{\n+\t  if (can_convert_arg (parm, TREE_TYPE (arg), arg))\n+\t    continue;\n+\t  return 1;\n+\t}\n+\t\n #if 0\n       if (TREE_CODE (arg) == VAR_DECL)\n \targ = TREE_TYPE (arg);"}, {"sha": "763d768148caa1c1c59f94810fcf4b0c362ff7e4", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -1740,6 +1740,9 @@ make_deep_copy (t)\n     case ARRAY_TYPE:\n       return build_array_type (make_deep_copy (TREE_TYPE (t)),\n \t\t\t       make_deep_copy (TYPE_DOMAIN (t)));\n+    case INTEGER_TYPE:\n+      return build_index_type (make_deep_copy (TYPE_MAX_VALUE (t)));\n+\n     case OFFSET_TYPE:\n       return build_offset_type (make_deep_copy (TYPE_OFFSET_BASETYPE (t)),\n \t\t\t\tmake_deep_copy (TREE_TYPE (t)));\n@@ -1749,6 +1752,7 @@ make_deep_copy (t)\n \t build_function_type\n \t (make_deep_copy (TREE_TYPE (t)),\n \t  make_deep_copy (TREE_CHAIN (TYPE_ARG_TYPES (t)))));\n+\n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_P (t))\n \treturn build_ptrmemfunc_type"}, {"sha": "b7f51d2a3fd9e14b4ea019f6a6c9a40bd84591b2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 172, "deletions": 223, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -719,7 +719,28 @@ comptypes (type1, type2, strict)\n       return 1;\n \n     case UNINSTANTIATED_P_TYPE:\n-      return UPT_TEMPLATE (t1) == UPT_TEMPLATE (t2);\n+      if (UPT_TEMPLATE (t1) != UPT_TEMPLATE (t2))\n+\treturn 0;\n+      {\n+\tint i = TREE_VEC_LENGTH (UPT_PARMS (t1));\n+\ttree *p1 = &TREE_VEC_ELT (UPT_PARMS (t1), 0);\n+\ttree *p2 = &TREE_VEC_ELT (UPT_PARMS (t2), 0);\n+\t\n+\twhile (i--)\n+\t  {\n+\t    if (TREE_CODE_CLASS (TREE_CODE (p1[i])) == 't')\n+\t      {\n+\t\tif (! comptypes (p1[i], p2[i], 1))\n+\t\t  return 0;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (simple_cst_equal (p1[i], p2[i]) <= 0)\n+\t\t  return 0;\n+\t      }\n+\t  }\n+      }\n+      return 1;\n     }\n   return attrval == 2 && val == 1 ? 2 : val;\n }\n@@ -1834,26 +1855,6 @@ build_array_ref (array, idx)\n     return error_mark_node;\n \n   itype = TREE_TYPE (idx);\n-  /* We must check here for the reference, so we can do the possible\n-     conversions immediately afterwards.  */\n-  if (TREE_CODE (itype) == REFERENCE_TYPE)\n-    {\n-      idx = convert_from_reference (idx);\n-      itype = TREE_TYPE (idx);\n-    }\n-\n-  if (IS_AGGR_TYPE (itype))\n-    {\n-      if (TYPE_HAS_INT_CONVERSION (itype))\n-\tidx = build_type_conversion (CONVERT_EXPR,\n-\t\t\t\t     integer_type_node, idx, 1);\n-      else\n-\t{\n-\t  error_with_aggr_type (itype,\n-\t\t\t\t\"type `%s' requires integer conversion for array indexing\");\n-\t  return error_mark_node;\n-\t}\n-    }\n \n   if (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE\n       && TREE_CODE (array) != INDIRECT_REF)\n@@ -1902,19 +1903,19 @@ build_array_ref (array, idx)\n \t    return error_mark_node;\n \t}\n \n-      /* Note in C++ we don't bother warning about subscripting a\n-\t `register' array, since it's valid in C++ to take the address\n-\t of something with that storage specification.  */\n       if (pedantic && !lvalue_p (array))\n \tpedwarn (\"ANSI C++ forbids subscripting non-lvalue array\");\n \n-      if (pedantic)\n+      /* Note in C++ it is valid to subscript a `register' array, since\n+\t it is valid to take the address of something with that\n+\t storage specification.  */\n+      if (extra_warnings)\n \t{\n \t  tree foo = array;\n \t  while (TREE_CODE (foo) == COMPONENT_REF)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && DECL_REGISTER (foo))\n-\t    pedwarn (\"ANSI C++ forbids subscripting non-lvalue array\");\n+\t    warning (\"subscripting array declared `register'\");\n \t}\n \n       type = TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (array)));\n@@ -2122,7 +2123,7 @@ build_x_function_call (function, params, decl)\n \tdecl = C_C_D;\n \n       decl_addr = build_unary_op (ADDR_EXPR, decl, 0);\n-      function = get_member_function_from_ptrfunc (&decl_addr, decl,\n+      function = get_member_function_from_ptrfunc (&decl_addr,\n \t\t\t\t\t\t   TREE_OPERAND (function, 1));\n       params = tree_cons (NULL_TREE, decl_addr, params);\n       return build_function_call (function, params);\n@@ -2184,9 +2185,8 @@ build_x_function_call (function, params, decl)\n    instance to use, if the member points to a virtual member.  */\n \n tree\n-get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n+get_member_function_from_ptrfunc (instance_ptrptr, function)\n      tree *instance_ptrptr;\n-     tree instance;\n      tree function;\n {\n   if (TREE_CODE (function) == OFFSET_REF)\n@@ -2200,7 +2200,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       tree index = save_expr (build_component_ref (function,\n \t\t\t\t\t\t   index_identifier,\n \t\t\t\t\t\t   0, 0));\n-      tree e1 = build (GT_EXPR, delta_type_node, index,\n+      tree e1 = build (GT_EXPR, boolean_type_node, index,\n \t\t       convert (delta_type_node, integer_zero_node));\n       tree delta = convert (ptrdiff_type_node,\n \t\t\t    build_component_ref (function, delta_identifier, 0, 0));\n@@ -2209,9 +2209,16 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       tree e3;\n       tree aref, vtbl;\n \n+      tree instance;\n+      tree instance_ptr = *instance_ptrptr;\n+\n+      if (TREE_SIDE_EFFECTS (instance_ptr))\n+\tinstance_ptr = save_expr (instance_ptr);\n+\n       /* convert down to the right base, before using the instance. */\n-      instance = convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n-\t\t\t\t\t  build_unary_op (ADDR_EXPR, instance, 0));\n+      instance\n+\t= convert_pointer_to_real (TYPE_METHOD_BASETYPE (TREE_TYPE (fntype)),\n+\t\t\t\t   instance_ptr);\n       if (instance == error_mark_node)\n \treturn instance;\n \n@@ -2238,9 +2245,8 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n \t\t\t\t   delta, 1);\n \t}\n \n-      *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (*instance_ptrptr),\n-\t\t\t\t*instance_ptrptr,\n-\t\t\t\tdelta);\n+      *instance_ptrptr = build (PLUS_EXPR, TREE_TYPE (instance_ptr),\n+\t\t\t\tinstance_ptr, delta);\n       if (flag_vtable_thunks)\n \te2 = aref;\n       else\n@@ -2249,6 +2255,12 @@ get_member_function_from_ptrfunc (instance_ptrptr, instance, function)\n       e3 = PFN_FROM_PTRMEMFUNC (function);\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n       function = build_conditional_expr (e1, e2, e3);\n+\n+      /* Make sure this doesn't get evaluated first inside one of the\n+         branches of the COND_EXPR.  */\n+      if (TREE_CODE (instance_ptr) == SAVE_EXPR)\n+\tfunction = build (COMPOUND_EXPR, TREE_TYPE (function),\n+\t\t\t  instance_ptr, function);\n     }\n   return function;\n }\n@@ -2325,7 +2337,7 @@ build_function_call_real (function, params, require_complete, flags)\n     {\n       tree instance_ptr = build_unary_op (ADDR_EXPR, C_C_D, 0);\n       fntype = TYPE_PTRMEMFUNC_FN_TYPE (fntype);\n-      function = get_member_function_from_ptrfunc (&instance_ptr, C_C_D, function);\n+      function = get_member_function_from_ptrfunc (&instance_ptr, function);\n     }\n \n   is_method = (TREE_CODE (fntype) == POINTER_TYPE\n@@ -2715,7 +2727,6 @@ build_binary_op (code, arg1, arg2, convert_p)\n      tree arg1, arg2;\n      int convert_p;\n {\n-  tree type1, type2;\n   tree args[2];\n \n   args[0] = arg1;\n@@ -2724,64 +2735,39 @@ build_binary_op (code, arg1, arg2, convert_p)\n   if (convert_p)\n     {\n       tree args_save [2];\n+      tree type0, type1;\n       args[0] = args_save [0] = default_conversion (args[0]);\n       args[1] = args_save [1] = default_conversion (args[1]);\n \n+      if (args[0] == error_mark_node || args[1] == error_mark_node)\n+\treturn error_mark_node;\n+\n+      type0 = TREE_TYPE (args[0]);\n+      type1 = TREE_TYPE (args[1]);\n+\n       if (type_unknown_p (args[0]))\n \t{\n-\t  args[0] = instantiate_type (TREE_TYPE (args[1]), args[0], 1);\n+\t  args[0] = instantiate_type (type1, args[0], 1);\n \t  args[0] = default_conversion (args[0]);\n \t}\n       else if (type_unknown_p (args[1]))\n \t{\n-\t  args[1] = require_instantiated_type (TREE_TYPE (args[0]),\n-\t\t\t\t\t       args[1],\n+\t  args[1] = require_instantiated_type (type0, args[1],\n \t\t\t\t\t       error_mark_node);\n \t  args[1] = default_conversion (args[1]);\n \t}\n \n-      type1 = TREE_TYPE (args[0]);\n-      type2 = TREE_TYPE (args[1]);\n-\n-      if (IS_AGGR_TYPE_2 (type1, type2))\n+      if (IS_AGGR_TYPE (type0) || IS_AGGR_TYPE (type1))\n \t{\n \t  /* Try to convert this to something reasonable.  */\n \t  if (! build_default_binary_type_conversion(code, &args[0], &args[1]))\n-\t    return error_mark_node;\n-\t}\n-      else if (IS_AGGR_TYPE (type1) || IS_AGGR_TYPE (type2))\n-\t{\n-\t  int convert_index = IS_AGGR_TYPE (type2);\n-\t  /* Avoid being tripped up by things like (ARG1 != 0).  */\n-\t  tree types[2], try;\n-\t  \n-\t  types[0] = type1; types[1] = type2;\n-\t  if (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n-\t    try = build_type_conversion (code, boolean_type_node,\n-\t\t\t\t\t args[convert_index], 1);\n-\t  else\n-\t    {\n-\t      try = build_type_conversion (code, types[convert_index ^ 1],\n-\t\t\t\t\t   args[convert_index], 1);\n-\t  \n-\t      if (try == 0\n-\t\t  && args[1] == integer_zero_node\n-\t\t  && (code == NE_EXPR || code == EQ_EXPR))\n-\t\ttry = build_type_conversion (code, ptr_type_node,\n-\t\t\t\t\t     args[convert_index], 1);\n-\t    }\n-\n-\t  if (try == 0)\n \t    {\n \t      cp_error (\"no match for `%O(%#T, %#T)'\", code,\n \t\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n \t      return error_mark_node;\n \t    }\n-\t  if (try == error_mark_node)\n-\t    error (\"ambiguous pointer conversion\");\n-\t  args[convert_index] = try;\n \t}\n-\n+      \n       if (args[0] == args_save[0])\n \targs[0] = arg1;\n       if (args[1] == args_save[1])\n@@ -3094,7 +3080,7 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t    {\n \t      tree base = common_base_type (tt0, tt1);\n \t      if (base == NULL_TREE)\n-\t\tcp_warning (\"comparison of distinct object pointer types `%T' and `%T'\", type0, type1);\n+\t\tcp_pedwarn (\"comparison of distinct object pointer types `%T' and `%T'\", type0, type1);\n \t      else if (base == error_mark_node)\n \t\t{\n \t\t  cp_error (\"comparison of pointer types `%T' and `%T' requires conversion to ambiguous supertype\", type0, type1);\n@@ -3119,6 +3105,8 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE\n \t\t  && tree_int_cst_lt (TYPE_SIZE (type0), TYPE_SIZE (type1)))\n \t\tpedwarn (\"ANSI C++ forbids comparison of `void *' with function pointer\");\n+\t      else if (TREE_CODE (tt1) == OFFSET_TYPE)\n+\t\tpedwarn (\"ANSI C++ forbids conversion of a pointer to member to `void *'\");\n \t    }\n \t  else if (tt1 == void_type_node)\n \t    {\n@@ -3291,18 +3279,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t}\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n-\t{\n-\t  op1 = null_pointer_node;\n-\t  if (pedantic)\n-\t    pedwarn (\"ordered comparison of pointer with integer zero\");\n-\t}\n+\top1 = null_pointer_node;\n       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST\n \t       && integer_zerop (op0))\n-\t{\n-\t  op0 = null_pointer_node;\n-\t  if (pedantic)\n-\t    pedwarn (\"ANSI C++ forbids ordered comparison of pointer with integer zero\");\n-\t}\n+\top0 = null_pointer_node;\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  if (pedantic)\n@@ -3482,14 +3462,10 @@ build_binary_op_nodefault (code, orig_op0, orig_op1, error_code)\n \t  /* Do the checking based on the original operand trees, so that\n \t     casts will be considered, but default promotions won't be.  */\n \t  if (TREE_UNSIGNED (comp_type)\n-\t      && ((op0_signed\n-\t\t   && (TREE_CODE (op0) != INTEGER_CST\n-\t\t       || (TREE_CODE (op0) == INTEGER_CST\n-\t\t\t   && INT_CST_LT (op0, integer_zero_node))))\n-\t\t  || (op1_signed\n-\t\t      && (TREE_CODE (op1) != INTEGER_CST\n-\t\t\t  || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t      && INT_CST_LT (op1, integer_zero_node))))))\n+\t      && ((op0_signed && (TREE_CODE (orig_op0) != INTEGER_CST\n+\t\t\t\t  || tree_int_cst_sgn (orig_op0) == -1))\n+\t\t  || (op1_signed && (TREE_CODE (orig_op1) != INTEGER_CST\n+\t\t\t\t     || tree_int_cst_sgn (orig_op1) == -1))))\n \t    warning (\"comparison between signed and unsigned\");\n \n \t  /* Warn if two unsigned values are being compared in a size\n@@ -3830,121 +3806,46 @@ build_unary_op (code, xarg, noconvert)\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   register tree arg = xarg;\n   register tree argtype = 0;\n-  register enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n   char *errstring = NULL;\n   tree val;\n-  int isaggrtype;\n \n-  if (typecode == ERROR_MARK)\n+  if (arg == error_mark_node)\n     return error_mark_node;\n \n-  if (typecode == REFERENCE_TYPE && code != ADDR_EXPR && ! noconvert)\n-    {\n-      arg = convert_from_reference (arg);\n-      typecode = TREE_CODE (TREE_TYPE (arg));\n-    }\n-\n-  if (typecode == ENUMERAL_TYPE)\n-    typecode = INTEGER_TYPE;\n-\n-  if (typecode == BOOLEAN_TYPE && ! noconvert)\n-    typecode = INTEGER_TYPE;\n-\n-  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n-\n   switch (code)\n     {\n     case CONVERT_EXPR:\n       /* This is used for unary plus, because a CONVERT_EXPR\n \t is enough to prevent anybody from looking inside for\n \t associativity, but won't generate any code.  */\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n-        errstring = \"wrong type argument to unary plus\";\n-      else if (!noconvert)\n-\targ = default_conversion (arg);\n-      arg = build1 (NON_LVALUE_EXPR, TREE_TYPE (arg), arg);\n-      break;\n-\n-    case NEGATE_EXPR:\n-      if (typecode == OFFSET_TYPE)\n-\t{\n-\t  arg = resolve_offset_ref (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n-\t}\n-\n-      if (isaggrtype)\n+      if (!(arg = build_expr_type_conversion\n+\t    (WANT_ARITH | WANT_ENUM | WANT_POINTER, arg, 1)))\n+\terrstring = \"wrong type argument to unary plus\";\n+      else\n \t{\n \t  if (!noconvert)\n-\t    arg = default_conversion (arg);\n-\t  else\n-\t    {\n-\t      cp_error (\"type conversion for type `%T' not allowed\",\n-\t\t\t  TREE_TYPE (arg));\n-\t      return error_mark_node;\n-\t    }\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  noconvert = 1;\n+\t   arg = default_conversion (arg);\n+\t  arg = build1 (NON_LVALUE_EXPR, TREE_TYPE (arg), arg);\n \t}\n+      break;\n \n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n-        errstring = \"wrong type argument to unary minus\";\n+    case NEGATE_EXPR:\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+\terrstring = \"wrong type argument to unary minus\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case BIT_NOT_EXPR:\n-      if (typecode == OFFSET_TYPE)\n-\t{\n-\t  arg = resolve_offset_ref (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n-\t}\n-\n-      if (isaggrtype)\n-\t{\n-\t  if (!noconvert)\n-\t    arg = default_conversion (arg);\n-\t  else\n-\t    {\n-\t      cp_error (\"type conversion for type `%T' not allowed\",\n-\t\t\t  TREE_TYPE (arg));\n-\t      return error_mark_node;\n-\t    }\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  noconvert = 1;\n-\t}\n-\n-      if (typecode != INTEGER_TYPE)\n-        errstring = \"wrong type argument to bit-complement\";\n+      if (!(arg = build_expr_type_conversion (WANT_INT | WANT_ENUM, arg, 1)))\n+\terrstring = \"wrong type argument to bit-complement\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n \n     case ABS_EXPR:\n-      if (typecode == OFFSET_TYPE)\n-\t{\n-\t  arg = resolve_offset_ref (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n-\t}\n-\n-      if (isaggrtype)\n-\t{\n-\t  if (!noconvert)\n-\t    arg = default_conversion (arg);\n-\t  else\n-\t    {\n-\t      cp_error (\"type conversion for type `%T' not allowed\",\n-\t\t\t  TREE_TYPE (arg));\n-\t      return error_mark_node;\n-\t    }\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  noconvert = 1;\n-\t}\n-\n-      if (!(typecode == INTEGER_TYPE || typecode == REAL_TYPE))\n-        errstring = \"wrong type argument to abs\";\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_ENUM, arg, 1)))\n+\terrstring = \"wrong type argument to abs\";\n       else if (!noconvert)\n \targ = default_conversion (arg);\n       break;\n@@ -3973,21 +3874,8 @@ build_unary_op (code, xarg, noconvert)\n \n       /* Report invalid types.  */\n \n-      if (typecode == OFFSET_TYPE)\n-\t{\n-\t  arg = resolve_offset_ref (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t  isaggrtype = IS_AGGR_TYPE_CODE (typecode);\n-\t}\n-\n-      if (isaggrtype)\n-\t{\n-\t  arg = default_conversion (arg);\n-\t  typecode = TREE_CODE (TREE_TYPE (arg));\n-\t}\n-\n-      if (typecode != POINTER_TYPE\n-\t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n+      if (!(arg = build_expr_type_conversion (WANT_ARITH | WANT_POINTER,\n+\t\t\t\t\t      arg, 1)))\n \t{\n \t  if (code == PREINCREMENT_EXPR)\n \t    errstring =\"no pre-increment operator for type\";\n@@ -4024,7 +3912,7 @@ build_unary_op (code, xarg, noconvert)\n \t    \n \t/* Compute the increment.  */\n \n-\tif (typecode == POINTER_TYPE)\n+\tif (TREE_CODE (argtype) == POINTER_TYPE)\n \t  {\n \t    enum tree_code tmp = TREE_CODE (TREE_TYPE (argtype));\n \t    if (TYPE_SIZE (TREE_TYPE (argtype)) == 0)\n@@ -4081,7 +3969,37 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t\t   ? \"increment\" : \"decrement\")))\n \t  return error_mark_node;\n \n-\tval = build (code, TREE_TYPE (arg), arg, inc);\n+\t/* Forbid using -- on `bool'.  */\n+\tif (TREE_TYPE (arg) == boolean_type_node)\n+\t  {\n+\t    if (code == POSTDECREMENT_EXPR || code == PREDECREMENT_EXPR)\n+\t      {\n+\t\tcp_error (\"invalid use of `--' on bool variable `%D'\", arg);\n+\t\treturn error_mark_node;\n+\t      }\n+#if 0\n+\t    /* This will only work if someone can convince Kenner to accept\n+\t       my patch to expand_increment. (jason)  */\n+\t    val = build (code, TREE_TYPE (arg), arg, inc);\n+#else\n+\t    if (code == POSTINCREMENT_EXPR)\n+\t      {\n+\t\targ = stabilize_reference (arg);\n+\t\tval = build (MODIFY_EXPR, TREE_TYPE (arg), arg,\n+\t\t\t     boolean_true_node);\n+\t\tTREE_SIDE_EFFECTS (val) = 1;\n+\t\targ = save_expr (arg);\n+\t\tval = build (COMPOUND_EXPR, TREE_TYPE (arg), val, arg);\n+\t\tval = build (COMPOUND_EXPR, TREE_TYPE (arg), arg, val);\n+\t      }\n+\t    else\n+\t      val = build (MODIFY_EXPR, TREE_TYPE (arg), arg,\n+\t\t\t   boolean_true_node);\n+#endif\n+\t  }\n+\telse\n+\t  val = build (code, TREE_TYPE (arg), arg, inc);\n+\n \tTREE_SIDE_EFFECTS (val) = 1;\n \treturn convert (result_type, val);\n       }\n@@ -4090,7 +4008,8 @@ build_unary_op (code, xarg, noconvert)\n       /* Note that this operation never does default_conversion\n \t regardless of NOCONVERT.  */\n \n-      if (typecode == REFERENCE_TYPE)\n+      argtype = TREE_TYPE (arg);\n+      if (TREE_CODE (argtype) == REFERENCE_TYPE)\n \t{\n \t  arg = build1 (CONVERT_EXPR, build_pointer_type (TREE_TYPE (TREE_TYPE (arg))), arg);\n \t  TREE_REFERENCE_EXPR (arg) = 1;\n@@ -4194,13 +4113,12 @@ build_unary_op (code, xarg, noconvert)\n \t;\n       /* Anything not already handled and not a true memory reference\n \t is an error.  */\n-      else if (typecode != FUNCTION_TYPE\n-\t       && typecode != METHOD_TYPE\n+      else if (TREE_CODE (argtype) != FUNCTION_TYPE\n+\t       && TREE_CODE (argtype) != METHOD_TYPE\n \t       && !lvalue_or_else (arg, \"unary `&'\"))\n \treturn error_mark_node;\n \n       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */\n-      argtype = TREE_TYPE (arg);\n       /* If the lvalue is const or volatile,\n \t merge that into the type that the address will point to.  */\n       if (TREE_CODE_CLASS (TREE_CODE (arg)) == 'd'\n@@ -4900,10 +4818,25 @@ build_compound_expr (list)\n \n   rest = build_compound_expr (TREE_CHAIN (list));\n \n-  /* When pedantic, a compound expression can be neither an lvalue\n-     nor an integer constant expression.  */\n-  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)) && ! pedantic)\n-    return rest;\n+  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n+    {\n+      /* the left-hand operand of a comma expression is like an expression\n+         statement: we should warn if it doesn't have any side-effects,\n+         unless it was explicitly cast to (void).  */\n+      if ((extra_warnings || warn_unused)\n+           && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n+                && TREE_TYPE (TREE_VALUE(list)) == void_type_node))\n+        warning(\"left-hand operand of comma expression has no effect\");\n+\n+      /* When pedantic, a compound expression can be neither an lvalue\n+         nor an integer constant expression.  */\n+      if (! pedantic)\n+        return rest;\n+    }\n+#if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n+  else if (warn_unused)\n+    warn_if_unused_value (TREE_VALUE(list));\n+#endif\n \n   return build (COMPOUND_EXPR, TREE_TYPE (rest),\n \t\tbreak_out_cleanups (TREE_VALUE (list)), rest);\n@@ -5629,8 +5562,6 @@ build_modify_expr (lhs, modifycode, rhs)\n \tcp_error (\"`%T' does not define operator=\", lhstype);\n       else if (! TYPE_HAS_REAL_ASSIGNMENT (lhstype)\n \t       && ! TYPE_HAS_COMPLEX_ASSIGN_REF (lhstype)\n-\t       /* FIXME find some way to deal with TARGET_EXPRs here.  */\n-\t       && TREE_CODE (newrhs) != TARGET_EXPR\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t/* Do the default thing */;\n       else\n@@ -5697,7 +5628,11 @@ build_modify_expr (lhs, modifycode, rhs)\n \t  newrhs = build_binary_op (modifycode, lhs, rhs_tmp, 1);\n \t}\n       else\n-\treturn error_mark_node;\n+\t{\n+\t  cp_error (\"no match for `%O(%#T, %#T)'\", modifycode,\n+\t\t    TREE_TYPE (lhs), TREE_TYPE (rhs));\n+\t  return error_mark_node;\n+\t}\n     }\n   else\n     {\n@@ -6008,18 +5943,32 @@ build_modify_expr (lhs, modifycode, rhs)\n \t}\n       else\n \tnewrhs = convert_for_assignment (lhstype, newrhs, \"assignment\",\n-\t\t\t\t       NULL_TREE, 0);\n-      if (flag_elide_constructors == 0\n-\t  && TREE_CODE (newrhs) == CALL_EXPR\n-\t  && TREE_ADDRESSABLE (lhstype))\n+\t\t\t\t\t NULL_TREE, 0);\n+      if (TREE_CODE (newrhs) == CALL_EXPR\n+\t  && TYPE_NEEDS_CONSTRUCTING (lhstype))\n+\tnewrhs = build_cplus_new (lhstype, newrhs, 0);\n+\n+      if (TREE_CODE (newrhs) == TARGET_EXPR)\n \t{\n-\t  /* Can't initialized directly from a CALL_EXPR, since\n-\t     we don't know about what doesn't alias what.  */\n+\t  /* Can't initialize directly from a TARGET_EXPR, since that would\n+\t     cause the lhs to be constructed twice.  So we force the\n+\t     TARGET_EXPR to be expanded.  expand_expr should really do this\n+\t     by itself.  */\n+\n+\t  tree xval = make_node (RTL_EXPR);\n+\t  rtx rtxval;\n \n-\t  tree temp = get_temp_name (lhstype, 0);\n-\t  newrhs = build (COMPOUND_EXPR, lhstype,\n-\t\t\t  build_modify_expr (temp, INIT_EXPR, newrhs),\n-\t\t\t  temp);\n+\t  do_pending_stack_adjust ();\n+\t  start_sequence_for_rtl_expr (xval);\n+\t  emit_note (0, -1);\n+\t  rtxval = expand_expr (newrhs, NULL, VOIDmode, 0);\n+\t  do_pending_stack_adjust ();\n+\t  TREE_SIDE_EFFECTS (xval) = 1;\n+\t  RTL_EXPR_SEQUENCE (xval) = get_insns ();\n+\t  end_sequence ();\n+\t  RTL_EXPR_RTL (xval) = rtxval;\n+\t  TREE_TYPE (xval) = lhstype;\n+\t  newrhs = xval;\n \t}\n     }\n \n@@ -6172,15 +6121,15 @@ get_delta_difference (from, to, force)\n \t}\n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n-\t  warning (\"pointer to member conversion to virtual base class will only work if your very careful\");\n+\t  warning (\"pointer to member conversion to virtual base class will only work if you are very careful\");\n \t}\n       return build_binary_op (MINUS_EXPR,\n \t\t\t      integer_zero_node,\n \t\t\t      BINFO_OFFSET (binfo), 1);\n     }\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n-      warning (\"pointer to member conversion from virtual base class will only work if your very careful\");\n+      warning (\"pointer to member conversion from virtual base class will only work if you are very careful\");\n     }\n   return BINFO_OFFSET (binfo);\n }\n@@ -6241,7 +6190,7 @@ build_ptrmemfunc (type, pfn, force)\n \t\t\t\t\tforce);\n \t  delta = build_binary_op (PLUS_EXPR, delta, ndelta, 1);\n \t  delta2 = build_binary_op (PLUS_EXPR, ndelta2, delta2, 1);\n-\t  e1 = fold (build (GT_EXPR, integer_type_node, index, integer_zero_node));\n+\t  e1 = fold (build (GT_EXPR, boolean_type_node, index, integer_zero_node));\n \t  \n \t  u = build_nt (CONSTRUCTOR, 0, tree_cons (delta2_identifier, delta2, NULL_TREE));\n \t  u = build_nt (CONSTRUCTOR, 0, tree_cons (NULL_TREE, delta,"}, {"sha": "38015215f91e9657675ee34b1b69cd97f759e79f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b7484fbe2bf67c98dbff6f270dbc41376c0fdbaf", "patch": "@@ -329,7 +329,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 364.  Free: */\n+/* First used: 0 (reserved), Last used: 366.  Free: */\n \n static int abortcount = 0;\n \n@@ -855,6 +855,14 @@ digest_init (type, init, tail)\n \t    }\n \t  init = element;\n \t}\n+      while (TREE_CODE (init) == CONSTRUCTOR)\n+\t{\n+\t  cp_pedwarn (\"braces around scalar initializer for `%T'\", type);\n+\t  init = CONSTRUCTOR_ELTS (init);\n+\t  if (TREE_CHAIN (init))\n+\t    cp_pedwarn (\"ignoring extra initializers for `%T'\", type);\n+\t  init = TREE_VALUE (init);\n+\t}\n \n       return convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n \t\t\t\t\t \"initialization\", NULL_TREE, 0);"}]}