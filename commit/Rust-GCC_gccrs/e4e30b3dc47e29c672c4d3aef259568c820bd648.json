{"sha": "e4e30b3dc47e29c672c4d3aef259568c820bd648", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRlMzBiM2RjNDdlMjljNjcyYzRkM2FlZjI1OTU2OGM4MjBiZDY0OA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-01-06T03:20:44Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-01-06T03:20:44Z"}, "message": "c4x.md (addqi3): If the destination operand is a hard register other than an extended precision...\n\n\t* config/c4x/c4x.md (addqi3): If the destination operand is\n\ta hard register other than an extended precision register,\n\temit addqi3_noclobber.\n\t(*addqi3_noclobber_reload): New pattern added so that reload\n\twill recognise a store of a pseudo, equivalent to the sum\n\tof the frame pointer and a constant, as an add insn.\n\nFrom-SVN: r24511", "tree": {"sha": "0d0e8ee5ff7680de5148469d190523bda51eb144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d0e8ee5ff7680de5148469d190523bda51eb144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4e30b3dc47e29c672c4d3aef259568c820bd648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e30b3dc47e29c672c4d3aef259568c820bd648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4e30b3dc47e29c672c4d3aef259568c820bd648", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4e30b3dc47e29c672c4d3aef259568c820bd648/comments", "author": null, "committer": null, "parents": [{"sha": "2f197d2fea50781416712f02b730cfae2d3c4bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f197d2fea50781416712f02b730cfae2d3c4bbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f197d2fea50781416712f02b730cfae2d3c4bbd"}], "stats": {"total": 42, "additions": 41, "deletions": 1}, "files": [{"sha": "83d6683f1ac524702243b361255282b88b5a1cae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4e30b3dc47e29c672c4d3aef259568c820bd648/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4e30b3dc47e29c672c4d3aef259568c820bd648/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4e30b3dc47e29c672c4d3aef259568c820bd648", "patch": "@@ -1,3 +1,12 @@\n+Thu Jan  7 00:12:24 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.md (addqi3): If the destination operand is\n+\ta hard register other than an extended precision register,\n+\temit addqi3_noclobber.\n+\t(*addqi3_noclobber_reload): New pattern added so that reload\n+\twill recognise a store of a pseudo, equivalent to the sum\n+\tof the frame pointer and a constant, as an add insn.\n+\n Wed Jan  6 03:18:53 1999  Mark Elbrecht  <snowball3@usa.net.\n \n \t* configure.in (pc-msdosdjgpp): Set x_make to x-go32."}, {"sha": "083014247d799f8df03f75620c946b775f71ae94", "filename": "gcc/config/c4x/c4x.md", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4e30b3dc47e29c672c4d3aef259568c820bd648/gcc%2Fconfig%2Fc4x%2Fc4x.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4e30b3dc47e29c672c4d3aef259568c820bd648/gcc%2Fconfig%2Fc4x%2Fc4x.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.md?ref=e4e30b3dc47e29c672c4d3aef259568c820bd648", "patch": "@@ -1537,7 +1537,9 @@\n               (clobber (reg:CC_NOOV 21))])]\n   \"\"\n   \"legitimize_operands (PLUS, operands, QImode);\n-   if (reload_in_progress)\n+   if (reload_in_progress\n+       || (! IS_PSEUDO_REGNO (operands[0]) \n+           && ! IS_EXT_REG (REGNO (operands[0]))))\n    {\n       emit_insn (gen_addqi3_noclobber (operands[0], operands[1], operands[2]));\n       DONE;\n@@ -1631,6 +1633,35 @@\n ; Default to int16 data attr.\n \n \n+; This pattern is required during reload when eliminate_regs_in_insn\n+; effectively converts a move insn into an add insn when the src\n+; operand is the frame pointer plus a constant.  Without this\n+; pattern, gen_addqi3 can be called with a register for operand0\n+; that can clobber CC.\n+; For example, we may have (set (mem (reg ar0)) (reg 99))\n+; with (set (reg 99) (plus (reg ar3) (const_int 8)))\n+; Now since ar3, the frame pointer, is unchanging within the function,\n+; (plus (reg ar3) (const_int 8)) is considered a constant.\n+; eliminate_regs_in_insn substitutes this constant to give\n+; (set (mem (reg ar0)) (plus (reg ar3) (const_int 8))).\n+; This is an invalid C4x insn but if we don't provide a pattern\n+; for it, it will be considered to be a move insn for reloading.\n+; The nasty bit is that a GENERAL_REGS class register, say r0,\n+; may be allocated to reload the PLUS and thus gen_reload will\n+; emit an add insn that may clobber CC.\n+(define_insn \"*addqi3_noclobber_reload\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=c,?c,c\")\n+        (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0\")\n+                 (match_operand:QI 2 \"src_operand\" \"JR,rS<>,g\")))]\n+  \"reload_in_progress\"\n+  \"@\n+   addi3\\\\t%2,%1,%0\n+   addi3\\\\t%2,%1,%0\n+   addi\\\\t%2,%0\"\n+  [(set_attr \"type\" \"binary,binary,binary\")])\n+; Default to int16 data attr.\n+\n+\n (define_insn \"*addqi3_carry_clobber\"\n   [(set (match_operand:QI 0 \"reg_operand\" \"=d,?d,d,c,?c,c\")\n         (plus:QI (match_operand:QI 1 \"src_operand\" \"%rR,rS<>,0,rR,rS<>,0\")"}]}