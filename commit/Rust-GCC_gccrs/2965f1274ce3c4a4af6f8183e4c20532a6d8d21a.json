{"sha": "2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk2NWYxMjc0Y2UzYzRhNGFmNmY4MTgzZTRjMjA1MzJhNmQ4ZDIxYQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-03T16:28:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-03T16:28:28Z"}, "message": "cfganal.c (single_pred_edge_ignoring_loop_edges): New function extracted from tree-ssa-dom.c.\n\n\t* cfganal.c (single_pred_edge_ignoring_loop_edges): New function\n\textracted from tree-ssa-dom.c.\n\t* cfganal.h (single_pred_edge_ignoring_loop_edges): Prototype.\n\t* tree-ssa-dom.c (single_incoming_edge_ignoring_loop_edges): Remove.\n\t(record_equivalences_from_incoming_edge): Add additional argument\n\tto single_pred_edge_ignoring_loop_edges call.\n\t* tree-ssa-uncprop.c (single_incoming_edge_ignoring_loop_edges): Remove.\n\t(uncprop_dom_walker::before_dom_children): Add additional argument\n\tto single_pred_edge_ignoring_loop_edges call.\n\t* tree-ssa-sccvn.c (sccvn_dom_walker::before_dom_children): Use\n\tsingle_pred_edge_ignoring_loop_edges rather than open coding.\n\t* tree-vrp.c (evrp_dom_walker::before_dom_children): Similarly.\n\nFrom-SVN: r254383", "tree": {"sha": "4814bac5f4aad32e4d50b6ce78bfbbf51585bd5a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4814bac5f4aad32e4d50b6ce78bfbbf51585bd5a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/comments", "author": null, "committer": null, "parents": [{"sha": "63626547937ea54b251ad9480b306d9f8e793a0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63626547937ea54b251ad9480b306d9f8e793a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63626547937ea54b251ad9480b306d9f8e793a0c"}], "stats": {"total": 169, "additions": 66, "deletions": 103}, "files": [{"sha": "2fc7db44f7be2e97f66e77c44e554d15c9da6195", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -1,3 +1,18 @@\n+2017-11-03  Jeff Law  <law@redhat.com>\n+\n+\t* cfganal.c (single_pred_edge_ignoring_loop_edges): New function\n+\textracted from tree-ssa-dom.c.\n+\t* cfganal.h (single_pred_edge_ignoring_loop_edges): Prototype.\n+\t* tree-ssa-dom.c (single_incoming_edge_ignoring_loop_edges): Remove.\n+\t(record_equivalences_from_incoming_edge): Add additional argument\n+\tto single_pred_edge_ignoring_loop_edges call.\n+\t* tree-ssa-uncprop.c (single_incoming_edge_ignoring_loop_edges): Remove.\n+\t(uncprop_dom_walker::before_dom_children): Add additional argument\n+\tto single_pred_edge_ignoring_loop_edges call.\n+\t* tree-ssa-sccvn.c (sccvn_dom_walker::before_dom_children): Use\n+\tsingle_pred_edge_ignoring_loop_edges rather than open coding.\n+\t* tree-vrp.c (evrp_dom_walker::before_dom_children): Similarly.\n+\n 2017-11-03  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* match.pd (-(-A)): Rewrite."}, {"sha": "8bf8a53fa58542d00b6a07ba50e5934709901f25", "filename": "gcc/cfganal.c", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -1554,3 +1554,42 @@ single_pred_before_succ_order (void)\n #undef MARK_VISITED\n #undef VISITED_P\n }\n+\n+/* Ignoring loop backedges, if BB has precisely one incoming edge then\n+   return that edge.  Otherwise return NULL.\n+\n+   When IGNORE_NOT_EXECUTABLE is true, also ignore edges that are not marked\n+   as executable.  */\n+\n+edge\n+single_pred_edge_ignoring_loop_edges (basic_block bb,\n+\t\t\t\t      bool ignore_not_executable)\n+{\n+  edge retval = NULL;\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      /* A loop back edge can be identified by the destination of\n+\t the edge dominating the source of the edge.  */\n+      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n+\tcontinue;\n+\n+      /* We can safely ignore edges that are not executable.  */\n+      if (ignore_not_executable\n+\t  && (e->flags & EDGE_EXECUTABLE) == 0)\n+\tcontinue;\n+\n+      /* If we have already seen a non-loop edge, then we must have\n+\t multiple incoming non-loop edges and thus we return NULL.  */\n+      if (retval)\n+\treturn NULL;\n+\n+      /* This is the first non-loop incoming edge we have found.  Record\n+\t it.  */\n+      retval = e;\n+    }\n+\n+  return retval;\n+}"}, {"sha": "c5cb51d9cf82d8a94a04974e39faf61ba08e3fca", "filename": "gcc/cfganal.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -77,5 +77,8 @@ extern void bitmap_intersection_of_preds (sbitmap, sbitmap *, basic_block);\n extern void bitmap_union_of_succs (sbitmap, sbitmap *, basic_block);\n extern void bitmap_union_of_preds (sbitmap, sbitmap *, basic_block);\n extern basic_block * single_pred_before_succ_order (void);\n+extern edge single_incoming_edge_ignoring_loop_edges (basic_block, bool);\n+extern edge single_pred_edge_ignoring_loop_edges (basic_block, bool);\n+\n \n #endif /* GCC_CFGANAL_H */"}, {"sha": "eb85b4a09ad763200d840a1c767a4a62d0f90da3", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -113,7 +113,6 @@ static void eliminate_redundant_computations (gimple_stmt_iterator *,\n \t\t\t\t\t      class avail_exprs_stack *);\n static void record_equivalences_from_stmt (gimple *, int,\n \t\t\t\t\t   class avail_exprs_stack *);\n-static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n static void dump_dominator_optimization_stats (FILE *file,\n \t\t\t\t\t       hash_table<expr_elt_hasher> *);\n \n@@ -1057,39 +1056,6 @@ record_equivalences_from_phis (basic_block bb)\n     }\n }\n \n-/* Ignoring loop backedges, if BB has precisely one incoming edge then\n-   return that edge.  Otherwise return NULL.  */\n-static edge\n-single_incoming_edge_ignoring_loop_edges (basic_block bb)\n-{\n-  edge retval = NULL;\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      /* A loop back edge can be identified by the destination of\n-\t the edge dominating the source of the edge.  */\n-      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n-\tcontinue;\n-\n-      /* We can safely ignore edges that are not executable.  */\n-      if ((e->flags & EDGE_EXECUTABLE) == 0)\n-\tcontinue;\n-\n-      /* If we have already seen a non-loop edge, then we must have\n-\t multiple incoming non-loop edges and thus we return NULL.  */\n-      if (retval)\n-\treturn NULL;\n-\n-      /* This is the first non-loop incoming edge we have found.  Record\n-\t it.  */\n-      retval = e;\n-    }\n-\n-  return retval;\n-}\n-\n /* Record any equivalences created by the incoming edge to BB into\n    CONST_AND_COPIES and AVAIL_EXPRS_STACK.  If BB has more than one\n    incoming edge, then no equivalence is created.  */\n@@ -1107,7 +1073,7 @@ record_equivalences_from_incoming_edge (basic_block bb,\n      the parent was followed.  */\n   parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n \n-  e = single_incoming_edge_ignoring_loop_edges (bb);\n+  e = single_pred_edge_ignoring_loop_edges (bb, true);\n \n   /* If we had a single incoming edge from our parent block, then enter\n      any data associated with the edge into our tables.  */"}, {"sha": "f5bc28efa7096bc2843faf7f544f7ad0897ef140", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -4847,34 +4847,18 @@ sccvn_dom_walker::after_dom_children (basic_block bb)\n edge\n sccvn_dom_walker::before_dom_children (basic_block bb)\n {\n-  edge e;\n-  edge_iterator ei;\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Visiting BB %d\\n\", bb->index);\n \n   /* If we have a single predecessor record the equivalence from a\n      possible condition on the predecessor edge.  */\n-  edge pred_e = NULL;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      /* Ignore simple backedges from this to allow recording conditions\n-         in loop headers.  */\n-      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n-\tcontinue;\n-      if (! pred_e)\n-\tpred_e = e;\n-      else\n-\t{\n-\t  pred_e = NULL;\n-\t  break;\n-\t}\n-    }\n+  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n   if (pred_e)\n     {\n       /* Check if there are multiple executable successor edges in\n \t the source block.  Otherwise there is no additional info\n \t to be recorded.  */\n+      edge_iterator ei;\n       edge e2;\n       FOR_EACH_EDGE (e2, ei, pred_e->src->succs)\n \tif (e2 != pred_e"}, {"sha": "35a49d284206b5029279f39457ffebccebc7432a", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -408,40 +408,10 @@ uncprop_into_successor_phis (basic_block bb)\n     }\n }\n \n-/* Ignoring loop backedges, if BB has precisely one incoming edge then\n-   return that edge.  Otherwise return NULL.  */\n-static edge\n-single_incoming_edge_ignoring_loop_edges (basic_block bb)\n-{\n-  edge retval = NULL;\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      /* A loop back edge can be identified by the destination of\n-\t the edge dominating the source of the edge.  */\n-      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n-\tcontinue;\n-\n-      /* If we have already seen a non-loop edge, then we must have\n-\t multiple incoming non-loop edges and thus we return NULL.  */\n-      if (retval)\n-\treturn NULL;\n-\n-      /* This is the first non-loop incoming edge we have found.  Record\n-\t it.  */\n-      retval = e;\n-    }\n-\n-  return retval;\n-}\n-\n edge\n uncprop_dom_walker::before_dom_children (basic_block bb)\n {\n   basic_block parent;\n-  edge e;\n   bool recorded = false;\n \n   /* If this block is dominated by a single incoming edge and that edge\n@@ -450,7 +420,7 @@ uncprop_dom_walker::before_dom_children (basic_block bb)\n   parent = get_immediate_dominator (CDI_DOMINATORS, bb);\n   if (parent)\n     {\n-      e = single_incoming_edge_ignoring_loop_edges (bb);\n+      edge e = single_pred_edge_ignoring_loop_edges (bb, false);\n \n       if (e && e->src == parent && e->aux)\n \t{"}, {"sha": "541c5c4eaf955eda4c457d7e4ebe8c531dfcb25a", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2965f1274ce3c4a4af6f8183e4c20532a6d8d21a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2965f1274ce3c4a4af6f8183e4c20532a6d8d21a", "patch": "@@ -10970,33 +10970,17 @@ evrp_dom_walker::try_find_new_range (tree name,\n edge\n evrp_dom_walker::before_dom_children (basic_block bb)\n {\n-  tree op0 = NULL_TREE;\n-  edge_iterator ei;\n-  edge e;\n-\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n \n   stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n \n-  edge pred_e = NULL;\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    {\n-      /* Ignore simple backedges from this to allow recording conditions\n-\t in loop headers.  */\n-      if (dominated_by_p (CDI_DOMINATORS, e->src, e->dest))\n-\tcontinue;\n-      if (! pred_e)\n-\tpred_e = e;\n-      else\n-\t{\n-\t  pred_e = NULL;\n-\t  break;\n-\t}\n-    }\n+  edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n   if (pred_e)\n     {\n       gimple *stmt = last_stmt (pred_e->src);\n+      tree op0 = NULL_TREE;\n+\n       if (stmt\n \t  && gimple_code (stmt) == GIMPLE_COND\n \t  && (op0 = gimple_cond_lhs (stmt))\n@@ -11040,6 +11024,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \n   /* Visit PHI stmts and discover any new VRs possible.  */\n   bool has_unvisited_preds = false;\n+  edge_iterator ei;\n+  edge e;\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     if (e->flags & EDGE_EXECUTABLE\n \t&& !(e->src->flags & BB_VISITED))"}]}