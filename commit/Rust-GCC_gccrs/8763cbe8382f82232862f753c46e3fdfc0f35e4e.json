{"sha": "8763cbe8382f82232862f753c46e3fdfc0f35e4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODc2M2NiZTgzODJmODIyMzI4NjJmNzUzYzQ2ZTNmZGZjMGYzNWU0ZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-05-31T19:49:13Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-05-31T19:49:13Z"}, "message": "Initial revision\n\nFrom-SVN: r23", "tree": {"sha": "67458e60cc9cdb4686547071a3f83e024fc6139a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67458e60cc9cdb4686547071a3f83e024fc6139a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8763cbe8382f82232862f753c46e3fdfc0f35e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8763cbe8382f82232862f753c46e3fdfc0f35e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8763cbe8382f82232862f753c46e3fdfc0f35e4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8763cbe8382f82232862f753c46e3fdfc0f35e4e/comments", "author": null, "committer": null, "parents": [{"sha": "9bc4ecdf3c769a33cfb1bb4f09e21b16f2ac2431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc4ecdf3c769a33cfb1bb4f09e21b16f2ac2431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bc4ecdf3c769a33cfb1bb4f09e21b16f2ac2431"}], "stats": {"total": 440, "additions": 440, "deletions": 0}, "files": [{"sha": "25cd96b64535e9c2e221ea2e1eb4ab5d35127ce0", "filename": "gcc/config/m68k/3b1g.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fm68k%2F3b1g.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fm68k%2F3b1g.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2F3b1g.h?ref=8763cbe8382f82232862f753c46e3fdfc0f35e4e", "patch": "@@ -0,0 +1,63 @@\n+/* Definitions of target machine for GNU compiler, for a 3b1 using GAS.\n+   Copyright (C) 1987, 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"tm-m68k.h\"\n+\n+/* See tm-m68k.h.  0 means 68000 with no 68881.  */\n+#define TARGET_DEFAULT 0\n+\n+/* Define __HAVE_68881 in preprocessor only if -m68881 is specified.\n+   This will control the use of inline 68881 insns in certain macros.\n+   Also inform the program which CPU this is for.  */\n+#define CPP_SPEC \"%{m68881:-D__HAVE_68881__} \\\n+%{!ansi:%{m68020:-Dmc68020}%{mc68020:-Dmc68020}%{!mc68020:%{!m68020:-Dmc68010}}}\"\n+\n+/* -m68020 requires special flags to the assembler.  */\n+#define ASM_SPEC \\\n+ \"%{m68020:-mc68020}%{mc68020:-mc68020}%{!mc68020:%{!m68020:-mc68010}}\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+#define CPP_PREDEFINES \"-Dmc68000 -Dmc68k -Dunix -Dunixpc\"\n+\n+/* This is (not really) BSD, so (but) it wants DBX format.  */\n+#define DBX_DEBUGGING_INFO\n+\n+/* Brain damage. */\n+#define SCCS_DIRECTIVE\n+\n+/* Specify how to pad function arguments.\n+   Value should be `upward', `downward' or `none'.\n+   Same as the default, except no padding for large or variable-size args.  */\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\t\\\n+  (((MODE) == BLKmode\t\t\t\t\t\t\t\\\n+    ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE))\t== INTEGER_CST\t\t\\\n+       && int_size_in_bytes (TYPE) < PARM_BOUNDARY / BITS_PER_UNIT)\t\\\n+    : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\t\\\n+   ? downward : none)\n+\n+/* Override part of the obstack macros.  */\n+#define __PTR_TO_INT(P) ((int)(P))\n+#define __INT_TO_PTR(P) ((char *)(P))\n+\n+/* Every structure or union's size must be a multiple of 2 bytes.  */\n+#define STRUCTURE_SIZE_BOUNDARY 16\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+#define TARGET_MEM_FUNCTIONS\n+"}, {"sha": "d6fb5c3419914b01152b920457162a3d13828b7c", "filename": "gcc/config/ns32k/merlin.h", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fns32k%2Fmerlin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fmerlin.h?ref=8763cbe8382f82232862f753c46e3fdfc0f35e4e", "patch": "@@ -0,0 +1,229 @@\n+/* Definitions of target machine for GNU compiler.  MERLIN NS32000 version.\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+   By Mark Mason (mason@reed.bitnet, pyramid!unify!mason@uunet.uu.net).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* Two flags to control how addresses are printed in assembler insns.  */\n+\n+#define SEQUENT_ADDRESS_BUG 1\n+#define SEQUENT_BASE_REGS\n+\n+#include \"tm-ns32k.h\"\n+\n+/* This is BSD, so it wants DBX format.  */\n+#define DBX_DEBUGGING_INFO\n+\n+/* Sequent has some changes in the format of DBX symbols.  */\n+#define DBX_NO_XREFS 1\n+\n+/* Don't split DBX symbols into continuations.  */\n+#define DBX_CONTIN_LENGTH 0\n+\n+#define TARGET_DEFAULT 1\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (32000, UTek syntax)\");\n+\n+/* These control the C++ compiler somehow.  */\n+#define FASCIST_ASSEMBLER\n+#define USE_COLLECT\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+\t\"-Dns32000 -Dns32k -Dns16000 -Dmerlin -Dunix -DUtek -Dbsd\"\n+\n+/* This is how to align the code that follows an unconditional branch.\n+   Don't define it, since it confuses the assembler (we hear).  */\n+\n+#undef ASM_OUTPUT_ALIGN_CODE\n+\n+/* Assember pseudo-op for shared data segment. */\n+#define SHARED_SECTION_ASM_OP \".shdata\"\n+\n+/* %$ means print the prefix for an immediate operand. */\n+\n+#ifdef UTEK_ASM\n+#undef PRINT_OPERAND\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (CODE == '$') putc('$', FILE);\t\t\t\t\t\\\n+  else if (CODE == '?');\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_INT)\t\t\t\t\t\\\n+    fprintf(FILE, \"$%d\", INTVAL(X));\t\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      rtx xfoo;\t\t\t\t\t\t\t\t\\\n+      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n+      switch (GET_CODE (xfoo))\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\tcase MEM:\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (XEXP (xfoo, 0)) == REG)\t\t\t\t\\\n+\t    if (REGNO (XEXP (xfoo, 0)) == STACK_POINTER_REGNUM)\t\t\\\n+\t      fprintf (FILE, \"0(0(sp))\");\t\t\t\t\\\n+\t    else fprintf (FILE, \"0(0(%s))\",\t\t\t\t\\\n+\t\t\t  reg_names[REGNO (XEXP (xfoo, 0))]);\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (GET_CODE (XEXP (xfoo, 0)) == SYMBOL_REF\t\t\\\n+\t\t  || GET_CODE (XEXP (xfoo, 0)) == CONST)\t\t\\\n+\t        {\t\t\t\t\t\t\t\\\n+\t\t  fprintf(FILE, \"0(\");\t\t\t\t\t\\\n+\t\t  output_address(xfoo);\t\t\t\t\t\\\n+\t\t  fprintf(FILE, \"(sb))\");\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t        {\t\t\t\t\t\t\t\\\n+\t\t  fprintf (FILE, \"0(\");\t\t\t\t\t\\\n+\t\t  output_address (xfoo);\t\t\t\t\\\n+\t\t  putc (')', FILE);\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase REG:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"0(%s)\", reg_names[REGNO (xfoo)]);\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase PRE_DEC:\t\t\t\t\t\t\t\\\n+\tcase POST_INC:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"tos\");\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tcase CONST_INT:\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"$%d\", INTVAL (xfoo));\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\tdefault:\t\t\t\t\t\t\t\\\n+\t  output_address (xfoo);\t\t\t\t\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n+      { union { double d; int i[2]; } u;\t\t\t\t\\\n+\tu.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+\tfprintf (FILE, \"$0d%.20e\", u.d); }\t\t\t\t\\\n+    else { union { double d; int i[2]; } u;\t\t\t\t\\\n+\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n+\t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n+  else output_addr_const (FILE, X); }\n+\n+#undef  FUNCTION_PROLOGUE\n+\n+/* This differs from the one in tm-ns32k.h in printing a bitmask\n+   rather than a register list in the enter or save instruction.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno, g_regs_used = 0;\t\t\t\t\\\n+  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n+  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno]\t\t\t\t\t\\\n+\t&& ! call_used_regs[regno])\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  *bufp = -1;\t\t\t\t\t\t\t\\\n+  for (; regno < 16; regno++)\t\t\t\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n+      *fbufp++ = regno;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  *fbufp = -1;\t\t\t\t\t\t\t\\\n+  bufp = used_regs_buf;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tenter \");\t\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tsave \");\t\t\t\t\t\\\n+  if (frame_pointer_needed || g_regs_used)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char mask = 0;\t\t\t\t\t\t\\\n+      while (*bufp >= 0)\t\t\t\t\t\\\n+\tmask |= 1 << *bufp++;\t\t\t\t\t\\\n+      fprintf (FILE, \"$0x%x\", (int) mask & 0xff);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \",%d\\n\", SIZE);\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\n\");\t\t\t\t\t\\\n+  fbufp = used_fregs_buf;\t\t\t\t\t\\\n+  while (*fbufp >= 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\t\\\n+\tfprintf (FILE, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\t\\\n+\t  fbufp += 2;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef  FUNCTION_EPILOGUE\n+\n+/* This differs from the one in tm-ns32k.h in printing a bitmask\n+   rather than a register list in the exit or restore instruction.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n+  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  *fbufp++ = -2;\t\t\t\t\t\t\\\n+  for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n+       *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  fbufp--;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno]\t\t\t\t\t\\\n+\t&& ! call_used_regs[regno])\t\t\t\t\\\n+    {                                                         \t\\\n+      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n+    }                                                         \t\\\n+  while (fbufp > used_fregs_buf)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\t\\\n+\t  fbufp -= 2;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else fprintf (FILE, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\texit \");\t\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\trestore \");\t\t\t\t\\\n+  if (g_regs_used || frame_pointer_needed)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      char mask = 0;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      while (bufp > used_regs_buf)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  /* Utek assembler takes care of reversing this */\t\\\n+\t  mask |= 1 << *--bufp;\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"$0x%x\\n\", (int) mask & 0xff);\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\tret %d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\tret 0\\n\"); }\n+\n+#endif /* UTEK_ASM */\n+\n+#undef PRINT_OPERAND_ADDRESS\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address(FILE, ADDR)"}, {"sha": "6c637ef7f328f5f6ef5866d27a252cf8cb6236e9", "filename": "gcc/config/sparc/pbd.h", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fsparc%2Fpbd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8763cbe8382f82232862f753c46e3fdfc0f35e4e/gcc%2Fconfig%2Fsparc%2Fpbd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpbd.h?ref=8763cbe8382f82232862f753c46e3fdfc0f35e4e", "patch": "@@ -0,0 +1,148 @@\n+/* Definitions of target machine for GNU compiler.\n+\n+   Citicorp/TTI Unicom PBD version\n+   (using GAS and  COFF (encapsulated is unacceptable) )\n+\n+   Copyright (C) 1990 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"tm-sparc.h\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-Dsparc -DUnicomPBD -Dunix\"\n+\n+/* We want DBX format for use with gdb under COFF.  */\n+\n+#define DBX_DEBUGGING_INFO\n+#define DBX_IN_COFF\n+\n+/* Generate calls to memcpy, memcmp and memset.  */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* we use /lib/libp/lib*  when profiling */\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shlib:%{p:-L/lib/libp} %{pg:-L/lib/libp} -lc} \\\n+   %{shlib:-lc_s crtn.o%s }\"\n+\n+/* shared libraries need to use crt1.o  */\n+\n+#ifdef USE_GPLUS_IFILE\n+#define STARTFILE_SPEC \\\n+  \"g++.ifile%s %{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n+   %{shlib:crt1.o%s } \"\n+#else\n+#define STARTFILE_SPEC \\\n+  \"%{!shlib:%{pg:mcrt0.o%s}%{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}\\\n+   %{shlib:crt1.o%s } \"\n+#endif\n+\n+/* cpp has to support a #sccs directive for the /usr/include files */\n+\n+#define SCCS_DIRECTIVE\n+\n+#ifndef __GNUC__\n+#define USE_C_ALLOCA\n+#endif\n+\n+\n+#undef  ASM_OUTPUT_LABELREF\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"%s\", NAME)\n+\n+/* fixes: */\n+/*\n+ *  Internal labels are prefixed with a period.\n+ */\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)                   \\\n+        sprintf (LABEL, \"*.%s%d\", PREFIX, NUM)\n+\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#undef  ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)                      \\\n+        fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#undef  ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The 68000 does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n+\n+/* Underscores are not used on Unicom PBB coff systems. */\n+#define NO_UNDERSCORES\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tsethi %%hi(.LP%d),%%o0\\n\\tcall mcount\\n\\tor %%lo(.LP%d),%%o0,%%o0\\n\", \\\n+\t   (LABELNO), (LABELNO))\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#undef FUNCTION_BLOCK_PROFILER\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \"\\tsethi %%hi(.LPBX0),%%o0\\n\\tld [%%lo(.LPBX0)+%%o0],%%o1\\n\\ttst %%o1\\n\\tbne .LPY%d\\n\\tnop\\n\\tcall ___bb_init_func\\n\\tnop\\n.LPY%d:\\n\",  \\\n+\t   (LABELNO), (LABELNO))\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#undef BLOCK_PROFILER\n+#define BLOCK_PROFILER(FILE, BLOCKNO) \\\n+{\t\t\t\t\t\t\t\t\\\n+  int blockn = (BLOCKNO);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tsethi %%hi(.LPBX2+%d),%%g1\\n\\tld [%%lo(.LPBX2+%d)+%%g1],%%g2\\n\\\n+\\tadd %%g2,1,%%g2\\n\\tst %%g2,[%%lo(.LPBX2+%d)+%%g1]\\n\",\t\t\\\n+\t   4 * blockn, 4 * blockn, 4 * blockn);\t\t\t\\\n+  CC_STATUS_INIT;  /* We have clobbered %g1.  Also %g2.  */\t\\\n+}\n+/*   This is needed for SunOS 4.0, and should not hurt for 3.2\n+   versions either.  */\n+#undef ASM_OUTPUT_SOURCE_LINE(file, line) \n+#define ASM_OUTPUT_SOURCE_LINE(file, line)\t\t\\\n+  { static int sym_lineno = 1;\t\t\t\t\\\n+    fprintf (file, \".stabn 68,0,%d,.LM%d\\n.LM%d:\\n\",\t\\\n+\t     line, sym_lineno, sym_lineno);\t\t\\\n+    sym_lineno += 1; }\n+\n+#define ASM_INT_OP \".long \""}]}