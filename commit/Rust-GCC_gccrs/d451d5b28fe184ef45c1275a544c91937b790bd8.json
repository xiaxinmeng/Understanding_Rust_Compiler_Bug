{"sha": "d451d5b28fe184ef45c1275a544c91937b790bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQ1MWQ1YjI4ZmUxODRlZjQ1YzEyNzVhNTQ0YzkxOTM3Yjc5MGJkOA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-05-12T17:34:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-05-12T17:34:38Z"}, "message": "cp-tree.h (LOOKUP_LIST_ONLY): New.\n\n\t* cp-tree.h (LOOKUP_LIST_ONLY): New.\n\t* call.c (add_candidates): Enforce it.\n\t(build_new_method_call): Try non-list ctor if no viable list ctor.\n\t(build_user_type_conversion_1): Likewise.\n\nFrom-SVN: r159334", "tree": {"sha": "349a445b9584ca18552e20bbb78d6abc89307290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/349a445b9584ca18552e20bbb78d6abc89307290"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d451d5b28fe184ef45c1275a544c91937b790bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d451d5b28fe184ef45c1275a544c91937b790bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d451d5b28fe184ef45c1275a544c91937b790bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d451d5b28fe184ef45c1275a544c91937b790bd8/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "404f08f8d52a28a0590e858c339c68ca7f78ccfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/404f08f8d52a28a0590e858c339c68ca7f78ccfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/404f08f8d52a28a0590e858c339c68ca7f78ccfd"}], "stats": {"total": 126, "additions": 102, "deletions": 24}, "files": [{"sha": "97dcc8d7aec558cd5638befd9f5e267abad7e122", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d451d5b28fe184ef45c1275a544c91937b790bd8", "patch": "@@ -1,5 +1,10 @@\n 2010-05-12  Jason Merrill  <jason@redhat.com>\n \n+\t* cp-tree.h (LOOKUP_LIST_ONLY): New.\n+\t* call.c (add_candidates): Enforce it.\n+\t(build_new_method_call): Try non-list ctor if no viable list ctor.\n+\t(build_user_type_conversion_1): Likewise.\n+\n \t* call.c (add_candidates): Distinguish between type(x) and\n \tx.operator type().\n \t(convert_class_to_reference): Set LOOKUP_NO_CONVERSION."}, {"sha": "c618b2938af8e01166584366a09a53990d73723b", "filename": "gcc/cp/call.c", "status": "modified", "additions": 72, "deletions": 24, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d451d5b28fe184ef45c1275a544c91937b790bd8", "patch": "@@ -2860,6 +2860,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n   if (ctors)\n     {\n       int ctorflags = flags;\n+      bool try_single_arg = true;\n       ctors = BASELINK_FUNCTIONS (ctors);\n \n       first_arg = build_int_cst (build_pointer_type (totype), 0);\n@@ -2868,28 +2869,44 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \t  /* For list-initialization we consider explicit constructors, but\n \t     give an error if one is selected.  */\n \t  ctorflags &= ~LOOKUP_ONLYCONVERTING;\n+\t  /* If the class has a list ctor, try passing the list as a single\n+\t     argument first, but only consider list ctors.  */\n \t  if (TYPE_HAS_LIST_CTOR (totype))\n-\t    args = make_tree_vector_single (expr);\n+\t    ctorflags |= LOOKUP_LIST_ONLY;\n \t  else\n-\t    {\n-\t      args = ctor_to_vec (expr);\n-\t      /* We still allow more conversions within an init-list.  */\n-\t      ctorflags &= ~LOOKUP_NO_CONVERSION;\n-\t      /* But not for the copy ctor.  */\n-\t      ctorflags |= LOOKUP_NO_COPY_CTOR_CONVERSION;\n-\t    }\n+\t    try_single_arg = false;\n \t}\n-      else\n-\targs = make_tree_vector_single (expr);\n \n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (OVL_CURRENT (ctors))\n \t\t  && !DECL_HAS_VTT_PARM_P (OVL_CURRENT (ctors)));\n \n-      add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n-\t\t      TYPE_BINFO (totype), TYPE_BINFO (totype),\n-\t\t      ctorflags, &candidates);\n+      /* If EXPR is not an initializer-list, or if totype has a list\n+\t constructor, try EXPR as a single argument.  */\n+      if (try_single_arg)\n+\t{\n+\t  args = make_tree_vector_single (expr);\n+\t  add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n+\t\t\t  TYPE_BINFO (totype), TYPE_BINFO (totype),\n+\t\t\t  ctorflags, &candidates);\n+\t}\n+\n+      /* If we didn't find a suitable list constructor for an initializer-list,\n+\t try breaking it apart.  */\n+      if (!candidates && BRACE_ENCLOSED_INITIALIZER_P (expr))\n+\t{\n+\t  args = ctor_to_vec (expr);\n+\t  /* We aren't looking for list-ctors anymore.  */\n+\t  ctorflags &= ~LOOKUP_LIST_ONLY;\n+\t  /* We still allow more conversions within an init-list.  */\n+\t  ctorflags &= ~LOOKUP_NO_CONVERSION;\n+\t  /* But not for the copy ctor.  */\n+\t  ctorflags |= LOOKUP_NO_COPY_CTOR_CONVERSION;\n+\t  add_candidates (ctors, first_arg, args, NULL_TREE, NULL_TREE, false,\n+\t\t\t  TYPE_BINFO (totype), TYPE_BINFO (totype),\n+\t\t\t  ctorflags, &candidates);\n+\t}\n \n       for (cand = candidates; cand; cand = cand->next)\n \t{\n@@ -4009,6 +4026,7 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n {\n   tree ctype;\n   const VEC(tree,gc) *non_static_args;\n+  bool check_list_ctor;\n   bool check_converting;\n   unification_kind_t strict;\n   tree fn;\n@@ -4020,6 +4038,7 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n   fn = OVL_CURRENT (fns);\n   if (DECL_CONV_FN_P (fn))\n     {\n+      check_list_ctor = false;\n       check_converting = !!(flags & LOOKUP_ONLYCONVERTING);\n       if (flags & LOOKUP_NO_CONVERSION)\n \t/* We're doing return_type(x).  */\n@@ -4036,9 +4055,15 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n   else\n     {\n       if (DECL_CONSTRUCTOR_P (fn))\n-\tcheck_converting = !!(flags & LOOKUP_ONLYCONVERTING);\n+\t{\n+\t  check_list_ctor = !!(flags & LOOKUP_LIST_ONLY);\n+\t  check_converting = !!(flags & LOOKUP_ONLYCONVERTING);\n+\t}\n       else\n-\tcheck_converting = false;\n+\t{\n+\t  check_list_ctor = false;\n+\t  check_converting = false;\n+\t}\n       strict = DEDUCE_CALL;\n       ctype = conversion_path ? BINFO_TYPE (conversion_path) : NULL_TREE;\n     }\n@@ -4058,6 +4083,8 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n \n       if (check_converting && DECL_NONCONVERTING_P (fn))\n \tcontinue;\n+      if (check_list_ctor && !is_list_ctor (fn))\n+\tcontinue;\n \n       /* Figure out which set of arguments to use.  */\n       if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n@@ -6188,6 +6215,8 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n   tree orig_fns;\n   VEC(tree,gc) *orig_args = NULL;\n   void *p;\n+  tree list = NULL_TREE;\n+  bool try_normal;\n \n   gcc_assert (instance != NULL_TREE);\n \n@@ -6300,27 +6329,46 @@ build_new_method_call (tree instance, tree fns, VEC(tree,gc) **args,\n     name = complete_dtor_identifier;\n \n   /* If CONSTRUCTOR_IS_DIRECT_INIT is set, this was a T{ } form\n-     initializer, not T({ }).  If the type doesn't have a list ctor,\n-     break apart the list into separate ctor args.  */\n+     initializer, not T({ }).  If the type doesn't have a list ctor (or no\n+     viable list ctor), break apart the list into separate ctor args.  */\n+  try_normal = true;\n   if (DECL_CONSTRUCTOR_P (fn) && args != NULL && !VEC_empty (tree, *args)\n       && BRACE_ENCLOSED_INITIALIZER_P (VEC_index (tree, *args, 0))\n-      && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *args, 0))\n-      && !TYPE_HAS_LIST_CTOR (basetype))\n+      && CONSTRUCTOR_IS_DIRECT_INIT (VEC_index (tree, *args, 0)))\n     {\n       gcc_assert (VEC_length (tree, *args) == 1);\n-      *args = ctor_to_vec (VEC_index (tree, *args, 0));\n+      list = VEC_index (tree, *args, 0);\n+\n+      if (TYPE_HAS_LIST_CTOR (basetype))\n+\tflags |= LOOKUP_LIST_ONLY;\n+      else\n+\ttry_normal = false;\n     }\n \n   first_mem_arg = instance_ptr;\n \n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n \n-  add_candidates (fns, first_mem_arg, args ? *args : NULL, optype,\n-\t\t  explicit_targs, template_only, conversion_path,\n-\t\t  access_binfo, flags, &candidates);\n+  any_viable_p = false;\n+  if (try_normal)\n+    {\n+      add_candidates (fns, first_mem_arg, user_args, optype,\n+\t\t      explicit_targs, template_only, conversion_path,\n+\t\t      access_binfo, flags, &candidates);\n+      candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+    }\n+\n+  if (!any_viable_p && list)\n+    {\n+      VEC(tree,gc) *list_args = ctor_to_vec (list);\n+      flags &= ~LOOKUP_LIST_ONLY;\n+      add_candidates (fns, first_mem_arg, list_args, optype,\n+\t\t      explicit_targs, template_only, conversion_path,\n+\t\t      access_binfo, flags, &candidates);\n+      candidates = splice_viable (candidates, pedantic, &any_viable_p);\n+    }\n \n-  candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)\n     {\n       if (complain & tf_error)"}, {"sha": "6b35fb97ebc089ab6c214d9791d2d42e8f1bc0bd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d451d5b28fe184ef45c1275a544c91937b790bd8", "patch": "@@ -4137,6 +4137,8 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define LOOKUP_NO_COPY_CTOR_CONVERSION (LOOKUP_NO_NARROWING << 1)\n /* This is the first parameter of a copy constructor.  */\n #define LOOKUP_COPY_PARM (LOOKUP_NO_COPY_CTOR_CONVERSION << 1)\n+/* We only want to consider list constructors.  */\n+#define LOOKUP_LIST_ONLY (LOOKUP_COPY_PARM << 1)\n \n #define LOOKUP_NAMESPACES_ONLY(F)  \\\n   (((F) & LOOKUP_PREFER_NAMESPACES) && !((F) & LOOKUP_PREFER_TYPES))"}, {"sha": "f0f5c2390a955f09a1356aff50109590b0c4ccf0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d451d5b28fe184ef45c1275a544c91937b790bd8", "patch": "@@ -1,5 +1,7 @@\n 2010-05-12  Jason Merrill  <jason@redhat.com>\n \n+\t* g++.dg/cpp0x/initlist32.C: New.\n+\n \t* g++.dg/template/conv11.C: New.\n \t* g++.dg/conversion/op1.C: Adjust expected error.\n "}, {"sha": "78bbb5ef9964d1b5069e7d5911ab48da0e35d106", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist32.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist32.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d451d5b28fe184ef45c1275a544c91937b790bd8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist32.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist32.C?ref=d451d5b28fe184ef45c1275a544c91937b790bd8", "patch": "@@ -0,0 +1,21 @@\n+// Test that we try normal init if no list ctor is viable.\n+// { dg-options \"-std=c++0x\" }\n+\n+#include <initializer_list>\n+\n+struct B {};\n+\n+struct C\n+{\n+  C(B);\n+};\n+\n+struct A\n+{\n+  A(std::initializer_list<int>);\n+  A(B) { }\n+  A(C);\n+};\n+\n+B b;\n+A a{b};"}]}