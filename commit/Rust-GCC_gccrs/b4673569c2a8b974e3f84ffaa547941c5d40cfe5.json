{"sha": "b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2NzM1NjljMmE4Yjk3NGUzZjg0ZmZhYTU0Nzk0MWM1ZDQwY2ZlNQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-10-30T09:21:09Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-10-30T09:21:09Z"}, "message": "re PR tree-optimization/65930 (Reduction with sign-change not handled)\n\n2019-10-30  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/65930\n\t* tree-vect-loop.c (vect_is_simple_reduction): For reduction\n\tchains also allow a leading and trailing conversion.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Handle\n\tintermediate reduction chains.\n\t(vect_analyze_slp_instance): Likewise.  Build a SLP\n\tnode for a trailing conversion manually.\n\n\t* gcc.dg/vect/pr65930-2.c: New testcase.\n\nFrom-SVN: r277603", "tree": {"sha": "6d7ec270bf5b9c3eba3ecbbab321a2c4ef3ef3b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d7ec270bf5b9c3eba3ecbbab321a2c4ef3ef3b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91c4891af8f7edd32689a9917db5ae81f4ab0c72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91c4891af8f7edd32689a9917db5ae81f4ab0c72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91c4891af8f7edd32689a9917db5ae81f4ab0c72"}], "stats": {"total": 96, "additions": 91, "deletions": 5}, "files": [{"sha": "618197d1fbe9f34e45012bc754744a85ed0834c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "patch": "@@ -1,3 +1,13 @@\n+2019-10-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65930\n+\t* tree-vect-loop.c (vect_is_simple_reduction): For reduction\n+\tchains also allow a leading and trailing conversion.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Handle\n+\tintermediate reduction chains.\n+\t(vect_analyze_slp_instance): Likewise.  Build a SLP\n+\tnode for a trailing conversion manually.\n+\n 2019-10-30  Martin Liska  <mliska@suse.cz>\n \n \t* cgraph.c (cgraph_node::local_info): Transform to ..."}, {"sha": "23caef029631340729770f3946c82fa7b685cd00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "patch": "@@ -1,3 +1,8 @@\n+2019-10-30  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/65930\n+\t* gcc.dg/vect/pr65930-2.c: New testcase.\n+\n 2019-10-30  Mark Eggleston <mark.eggleston@codethink.com>\n \n \t* gfortran.dg/no_overwrite_recursive_1.f90: New test."}, {"sha": "9cfb9b102d9b518c5a7f2f011c9a871b81604b3c", "filename": "gcc/testsuite/gcc.dg/vect/pr65930-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr65930-2.c?ref=b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+int __attribute__((noipa))\n+bar (unsigned int *x, int n)\n+{\n+  int sum = 4;\n+  x = __builtin_assume_aligned (x, __BIGGEST_ALIGNMENT__);\n+  for (int i = 0; i < n; ++i)\n+    sum += x[i*4+0]+ x[i*4 + 1] + x[i*4 + 2] + x[i*4 + 3];\n+  return sum;\n+}\n+\n+int\n+main ()\n+{\n+  static int a[16] __attribute__((aligned(__BIGGEST_ALIGNMENT__)))\n+    = { 1, 3, 5, 8, 9, 10, 17, 18, 23, 29, 30, 55, 42, 2, 3, 1 };\n+  check_vect ();\n+  if (bar (a, 4) != 260)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"vectorized 1 loops\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"Loop contains only SLP stmts\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"vectorizing stmts using SLP\" \"vect\" } } */"}, {"sha": "fa873e9b435037e5a81dda6615cab809d2d4de48", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "patch": "@@ -3005,14 +3005,21 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       for (i = path.length () - 1; i >= 1; --i)\n \t{\n \t  gimple *stmt = USE_STMT (path[i].second);\n-\t  if (gimple_assign_rhs_code (stmt) != code\n+\t  stmt_vec_info stmt_info = loop_info->lookup_stmt (stmt);\n+\t  STMT_VINFO_REDUC_IDX (stmt_info)\n+\t    = path[i].second->use - gimple_assign_rhs1_ptr (stmt);\n+\t  enum tree_code stmt_code = gimple_assign_rhs_code (stmt);\n+\t  bool leading_conversion = (CONVERT_EXPR_CODE_P (stmt_code)\n+\t\t\t\t     && (i == 1 || i == path.length () - 1));\n+\t  if ((stmt_code != code && !leading_conversion)\n \t      /* We can only handle the final value in epilogue\n \t\t generation for reduction chains.  */\n \t      || (i != 1 && !has_single_use (gimple_assign_lhs (stmt))))\n \t    is_slp_reduc = false;\n-\t  stmt_vec_info stmt_info = loop_info->lookup_stmt (stmt);\n-\t  STMT_VINFO_REDUC_IDX (stmt_info)\n-\t    = path[i].second->use - gimple_assign_rhs1_ptr (stmt);\n+\t  /* For reduction chains we support a trailing/leading\n+\t     conversions.  We do not store those in the actual chain.  */\n+\t  if (leading_conversion)\n+\t    continue;\n \t  reduc_chain.safe_push (stmt_info);\n \t}\n       if (is_slp_reduc && reduc_chain.length () > 1)"}, {"sha": "4b1a231bb6ddf60b4e943fe9066fb87f97a4993a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4673569c2a8b974e3f84ffaa547941c5d40cfe5/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=b4673569c2a8b974e3f84ffaa547941c5d40cfe5", "patch": "@@ -419,6 +419,13 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n \n       if (first)\n \t{\n+\t  /* For the swapping logic below force vect_reduction_def\n+\t     for the reduction op in a SLP reduction group.  */\n+\t  if (!STMT_VINFO_DATA_REF (stmt_info)\n+\t      && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+\t      && (int)i == STMT_VINFO_REDUC_IDX (stmt_info)\n+\t      && def_stmt_info)\n+\t    dt = vect_reduction_def;\n \t  oprnd_info->first_dt = dt;\n \t  oprnd_info->first_op_type = TREE_TYPE (oprnd);\n \t}\n@@ -2041,7 +2048,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n       /* Mark the first element of the reduction chain as reduction to properly\n \t transform the node.  In the reduction analysis phase only the last\n \t element of the chain is marked as reduction.  */\n-      STMT_VINFO_DEF_TYPE (stmt_info) = vect_reduction_def;\n+      STMT_VINFO_DEF_TYPE (stmt_info)\n+\t= STMT_VINFO_DEF_TYPE (scalar_stmts.last ());\n       STMT_VINFO_REDUC_DEF (vect_orig_stmt (stmt_info))\n \t= STMT_VINFO_REDUC_DEF (vect_orig_stmt (scalar_stmts.last ()));\n     }\n@@ -2071,6 +2079,34 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   delete bst_map;\n   if (node != NULL)\n     {\n+      /* If this is a reduction chain with a conversion in front\n+         amend the SLP tree with a node for that.  */\n+      if (!dr\n+\t  && REDUC_GROUP_FIRST_ELEMENT (stmt_info)\n+\t  && STMT_VINFO_DEF_TYPE (stmt_info) != vect_reduction_def)\n+\t{\n+\t  /* Get at the conversion stmt - we know it's the single use\n+\t     of the last stmt of the reduction chain.  */\n+\t  gimple *tem = vect_orig_stmt (scalar_stmts[group_size - 1])->stmt;\n+\t  use_operand_p use_p;\n+\t  gimple *use_stmt;\n+\t  bool r = single_imm_use (gimple_assign_lhs (tem), &use_p, &use_stmt);\n+\t  gcc_assert (r);\n+\t  next_info = vinfo->lookup_stmt (use_stmt);\n+\t  next_info = vect_stmt_to_vectorize (next_info);\n+\t  scalar_stmts = vNULL;\n+\t  scalar_stmts.create (group_size);\n+\t  for (unsigned i = 0; i < group_size; ++i)\n+\t    scalar_stmts.quick_push (next_info);\n+\t  slp_tree conv = vect_create_new_slp_node (scalar_stmts);\n+\t  SLP_TREE_CHILDREN (conv).quick_push (node);\n+\t  node = conv;\n+\t  /* We also have to fake this conversion stmt as SLP reduction group\n+\t     so we don't have to mess with too much code elsewhere.  */\n+\t  REDUC_GROUP_FIRST_ELEMENT (next_info) = next_info;\n+\t  REDUC_GROUP_NEXT_ELEMENT (next_info) = NULL;\n+\t}\n+\n       /* Calculate the unrolling factor based on the smallest type.  */\n       poly_uint64 unrolling_factor\n \t= calculate_unrolling_factor (max_nunits, group_size);"}]}