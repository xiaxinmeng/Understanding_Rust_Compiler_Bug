{"sha": "405a745b2e01783dd0e12bd80010cdf055747f73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1YTc0NWIyZTAxNzgzZGQwZTEyYmQ4MDAxMGNkZjA1NTc0N2Y3Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-09-26T07:24:48Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-26T07:24:48Z"}, "message": "parse.y (member_init): Also imply typename here.\n\n\t* parse.y (member_init): Also imply typename here.  Remove ancient\n\textension for initializing base members.\n\nFrom-SVN: r15720", "tree": {"sha": "0777fa569f922579dc4b2572287a622291687682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0777fa569f922579dc4b2572287a622291687682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/405a745b2e01783dd0e12bd80010cdf055747f73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405a745b2e01783dd0e12bd80010cdf055747f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405a745b2e01783dd0e12bd80010cdf055747f73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405a745b2e01783dd0e12bd80010cdf055747f73/comments", "author": null, "committer": null, "parents": [{"sha": "1e60a96e070d15f5daaed0f4966d042640d2ad59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e60a96e070d15f5daaed0f4966d042640d2ad59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e60a96e070d15f5daaed0f4966d042640d2ad59"}], "stats": {"total": 108, "additions": 50, "deletions": 58}, "files": [{"sha": "e83908ae61ebfc0b47b6179579286a4c17812e5d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=405a745b2e01783dd0e12bd80010cdf055747f73", "patch": "@@ -1,3 +1,8 @@\n+Fri Sep 26 00:22:56 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* parse.y (member_init): Also imply typename here.  Remove ancient\n+\textension for initializing base members.\n+\n Thu Sep 25 11:11:13 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \tHandle multi-level typenames and implicit typename in base list."}, {"sha": "3d53e1c36bd723fda9743a278e658fafde766f86", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 37, "deletions": 47, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=405a745b2e01783dd0e12bd80010cdf055747f73", "patch": "@@ -16,71 +16,73 @@\n \n      + Inlining of template functions works without any extra effort or\n        modifications.\n-\n      + Instantiations of class templates and methods defined in the class\n        body are deferred until they are actually needed (unless\n        -fexternal-templates is specified).\n-\n      + Nested types in class templates work.\n-\n      + Static data member templates work.\n-\n      + Member function templates are now supported.\n-\n      + Partial specialization of class templates is now supported.\n-\n      + The new 'template <>' specialization syntax is now accepted and\n        ignored.\n-\n      + Explicit instantiation of template constructors and destructors is\n-       now supported. Use the following source code, as an example.\n+       now supported.  For instance:\n \n-       template A<int>::A(const A&);\n+            template A<int>::A(const A&);\n \n-  Possible problems (caused by complying with the ANSI/ISO draft):\n+  Things you may need to fix in your code:\n \n+     + Syntax errors in templates that are never instantiated will now be\n+       diagnosed.\n      + Types and class templates used in templates must be declared\n        first, or the compiler will assume they are not types, and fail.\n-\n      + Similarly, nested types of template type parameters must be tagged\n-       with the 'typename' keyword.  In many cases, the compiler will tell\n-       you where you need to add 'typename'.\n+       with the 'typename' keyword, except in base lists.  In many cases,\n+       but not all, the compiler will tell you where you need to add\n+       'typename'.  For more information, see\n \n-     + Syntax errors in templates that are never instantiated will now be\n-       diagnosed.\n+            http://www.cygnus.com/misc/wp/dec96pub/template.html#temp.res\n \n   Other features:\n \n      + Default function arguments in templates will not be evaluated (or\n        checked for semantic validity) unless they are needed.  Default\n        arguments in class bodies will not be parsed until the class\n        definition is complete.\n-\n      + The -ftemplate-depth-NN flag can be used to increase the maximum\n-       recursive template instantiation depth, defaulting to 17. If you need\n-       to use this flag, the compiler will tell you.\n+       recursive template instantiation depth, which defaults to 17. If you\n+       need to use this flag, the compiler will tell you.\n \n   Still not supported:\n \n+     + Member class templates.\n      + Template template parameters.\n+     + Template friends.\n+     + Explicit qualification of function templates.\n \n * Exception handling support has been significantly improved and is on by\n   default.  This can result in significant runtime overhead.  You can turn\n   it off with -fno-exceptions.\n \n-* Synthesized methods are now emitted in any translation units that need\n-  an out-of-line copy. They are no longer affected by #pragma interface\n-  or #pragma implementation.\n+* RTTI support has been rewritten to work properly and is now on by default.\n+  This means code that uses virtual functions will have a modest space\n+  overhead.  You can use the -fno-rtti flag to disable RTTI support.\n \n * On ELF systems, duplicate copies of symbols with 'initialized common'\n   linkage (such as template instantiations, vtables, and extern inlines)\n   will now be discarded by the GNU linker, so you don't need to use -frepo.\n   This support requires GNU ld from binutils 2.8 or later.\n \n-* __FUNCTION__ and __PRETTY_FUNCTION__ are now treated as variables by the\n-  parser; previously they were treated as string constants.  So code like\n-  `printf (__FUNCTION__ \": foo\")' must be rewritten to \n-  `printf (\"%s: foo\", __FUNCTION__)'.  This is necessary for templates.\n+* The overload resolution code has been rewritten to conform to the latest\n+  C++ Working Paper.  Built-in operators are now considered as candidates\n+  in operator overload resolution.  Function template overloading chooses\n+  the more specialized template, and handles base classes in type deduction\n+  and guiding declarations properly.  In this release the old code can\n+  still be selected with -fno-ansi-overloading, although this is not\n+  supported and will be removed in a future release.\n+\n+* Standard usage syntax for the std namespace is supported; std is treated\n+  as an alias for global scope.  General namespaces are still not supported.\n \n * New flags:\n \n@@ -103,40 +105,28 @@\n \n      + The new flag, -fno-weak, disables the use of weak symbols.\n \n+* Synthesized methods are now emitted in any translation units that need\n+  an out-of-line copy. They are no longer affected by #pragma interface\n+  or #pragma implementation.\n+\n+* __FUNCTION__ and __PRETTY_FUNCTION__ are now treated as variables by the\n+  parser; previously they were treated as string constants.  So code like\n+  `printf (__FUNCTION__ \": foo\")' must be rewritten to \n+  `printf (\"%s: foo\", __FUNCTION__)'.  This is necessary for templates.\n+\n * local static variables in extern inline functions will be shared between\n   translation units.\n \n-* Standard usage syntax for the std namespace is supported; std is treated\n-  as an alias for global scope.  General namespaces are still not supported.\n-\n * -fvtable-thunks is supported for all targets, and is the default for \n   Linux with glibc 2.x (also called libc 6.x).\n \n-* RTTI support has been rewritten to work properly and is now on by default.\n-  This means code that uses virtual functions will have a modest space\n-  overhead.  You can use the -fno-rtti flag to disable RTTI support.\n-\n-* The internal interface between RTTI-using code and the RTTI support\n-  library has changed, so code that uses dynamic_cast should be\n-  recompiled. The RTTI support library has moved from libstdc++ to\n-  libgcc, so you no longer need to link against libstdc++ for a program\n-  that doesn't use the \"hosted\" library.\n-\n * bool is now always the same size as another built-in type. Previously,\n   a 64-bit RISC target using a 32-bit ABI would have 32-bit pointers and a\n   64-bit bool. This should only affect Irix 6, which was not supported in\n   2.7.2.\n \n * new (nothrow) is now supported.\n \n-* The overload resolution code has been rewritten to conform to the latest\n-  C++ Working Paper.  Built-in operators are now considered as candidates\n-  in operator overload resolution.  Function template overloading chooses\n-  the more specialized template, and handles base classes in type deduction\n-  and guiding declarations properly.  In this release the old code can\n-  still be selected with -fno-ansi-overloading, although this is not\n-  supported and will be removed in a future release.\n-\n * Synthesized destructors are no longer made virtual just because the class\n   already has virtual functions, only if they override a virtual destructor\n   in a base class.  The compiler will warn if this affects your code.\n@@ -159,7 +149,7 @@\n   function's argument list.\n \n * Definition of nested types outside of their containing class is now\n-  supported. Use the following source code, as an example.\n+  supported.  For instance:\n \n        struct A {\n               struct B;"}, {"sha": "e11e1f10493db0bf12d0679f7fa5be57e45e9c2d", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405a745b2e01783dd0e12bd80010cdf055747f73/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=405a745b2e01783dd0e12bd80010cdf055747f73", "patch": "@@ -794,19 +794,16 @@ member_init:\n \t\t{ expand_member_init (current_class_ref, $1, $3); }\n \t| notype_identifier LEFT_RIGHT\n \t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n-\t| complete_type_name '(' nonnull_exprlist ')'\n+\t| nonnested_type '(' nonnull_exprlist ')'\n \t\t{ expand_member_init (current_class_ref, $1, $3); }\n-\t| complete_type_name LEFT_RIGHT\n+\t| nonnested_type LEFT_RIGHT\n \t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n-\t/* GNU extension */\n-\t| notype_qualified_id '(' nonnull_exprlist ')'\n-\t\t{\n-\t\t  do_member_init (OP0 ($1), OP1 ($1), $3);\n-\t\t}\n-\t| notype_qualified_id LEFT_RIGHT\n-\t\t{\n-\t\t  do_member_init (OP0 ($1), OP1 ($1), void_type_node);\n-\t\t}\n+\t| typename_sub '(' nonnull_exprlist ')'\n+\t\t{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),\n+\t\t\t\t      $3); }\n+\t| typename_sub LEFT_RIGHT\n+\t\t{ expand_member_init (current_class_ref, TYPE_MAIN_DECL ($1),\n+\t\t\t\t      void_type_node); }\n \t;\n \n identifier:"}]}