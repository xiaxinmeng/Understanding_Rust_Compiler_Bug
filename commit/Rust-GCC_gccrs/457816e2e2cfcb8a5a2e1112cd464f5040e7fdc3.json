{"sha": "457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU3ODE2ZTJlMmNmY2I4YTVhMmUxMTEyY2Q0NjRmNTA0MGU3ZmRjMw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-20T09:51:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-09-20T09:51:37Z"}, "message": "(subst, simplify_and_const_int, significant_bits): Treat BYTE_LOADS_SIGN_EXTEND just like BYTE_LOADS_ZERO_EXTEND.\n\n(subst, simplify_and_const_int, significant_bits): Treat\nBYTE_LOADS_SIGN_EXTEND just like BYTE_LOADS_ZERO_EXTEND.\n(num_sign_bit_copies, case MEM): New case for BYTE_LOADS_SIGN_EXTEND.\n(num_sign_bit_copies, case SUBREG): Handle just like significant_bits.\n\nFrom-SVN: r2189", "tree": {"sha": "2a1dfa278070ec0a829313ae5033e2531d98a7cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a1dfa278070ec0a829313ae5033e2531d98a7cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3/comments", "author": null, "committer": null, "parents": [{"sha": "46da6b3a5a0124b854ec6b9ad518187b8df4e805", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46da6b3a5a0124b854ec6b9ad518187b8df4e805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46da6b3a5a0124b854ec6b9ad518187b8df4e805"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "aaf376c63c0f5efbbd6ac3a3fddcc8996eb438cb", "filename": "gcc/combine.c", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=457816e2e2cfcb8a5a2e1112cd464f5040e7fdc3", "patch": "@@ -3746,11 +3746,11 @@ subst (x, from, to, in_dest, unique_copy)\n \t means that we only care about the low bits of the result.\n \n \t However, on most machines (those with BYTE_LOADS_ZERO_EXTEND\n-\t not defined), we cannot perform a narrower operation that\n-\t requested since the high-order bits will be undefined.  On\n-\t machine where BYTE_LOADS_ZERO_EXTEND are defined, however, this\n-\t transformation is safe as long as M1 and M2 have the same number\n-\t of words.  */\n+\t and BYTES_LOADS_SIGN_EXTEND not defined), we cannot perform a\n+\t narrower operation that requested since the high-order bits will\n+\t be undefined.  On machine where BYTE_LOADS_*_EXTEND is defined,\n+\t however, this transformation is safe as long as M1 and M2 have\n+\t the same number of words.  */\n  \n       if (GET_CODE (SET_SRC (x)) == SUBREG\n \t  && subreg_lowpart_p (SET_SRC (x))\n@@ -3759,7 +3759,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t       / UNITS_PER_WORD)\n \t      == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x))))\n \t\t   + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n-#ifndef BYTE_LOADS_ZERO_EXTEND\n+#if ! defined(BYTE_LOADS_ZERO_EXTEND) && ! defined (BYTE_LOADS_SIGN_EXTEND)\n \t  && (GET_MODE_SIZE (GET_MODE (SET_SRC (x)))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (SET_SRC (x)))))\n #endif\n@@ -5581,11 +5581,11 @@ simplify_and_const_int (x, mode, varop, constop)\n \tcase SUBREG:\n \t  if (subreg_lowpart_p (varop)\n \t      /* We can ignore the effect this SUBREG if it narrows the mode\n-\t\t or, on machines where byte operations zero extend, if the\n+\t\t or, on machines where byte operations extend, if the\n \t\t constant masks to zero all the bits the mode doesn't have.  */\n \t      && ((GET_MODE_SIZE (GET_MODE (varop))\n \t\t   < GET_MODE_SIZE (GET_MODE (SUBREG_REG (varop))))\n-#ifdef BYTE_LOADS_ZERO_EXTEND\n+#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n \t\t  || (0 == (constop\n \t\t\t    & GET_MODE_MASK (GET_MODE (varop))\n \t\t\t    & ~ GET_MODE_MASK (GET_MODE (SUBREG_REG (varop)))))\n@@ -6048,7 +6048,7 @@ significant_bits (x, mode)\n \t      <= HOST_BITS_PER_WIDE_INT))\n \t{\n \t  significant &= significant_bits (SUBREG_REG (x), mode);\n-#ifndef BYTE_LOADS_ZERO_EXTEND\n+#if ! defined(BYTE_LOADS_ZERO_EXTEND) && ! defined(BYTE_LOADS_SIGN_EXTEND)\n \t  /* On many CISC machines, accessing an object in a wider mode\n \t     causes the high-order bits to become undefined.  So they are\n \t     not known to be zero.  */\n@@ -6161,6 +6161,12 @@ num_sign_bit_copies (x, mode)\n \treturn num_sign_bit_copies (tem, mode);\n       break;\n \n+#ifdef BYTE_LOADS_SIGN_EXTEND\n+    case MEM:\n+      /* Some RISC machines sign-extend all loads of smaller than a word.  */\n+      return MAX (1, bitwidth - GET_MODE_BITSIZE (GET_MODE (x)) + 1);\n+#endif\n+\n     case CONST_INT:\n       /* If the constant is negative, take its 1's complement and remask.\n \t Then see how many zero bits we have.  */\n@@ -6179,6 +6185,19 @@ num_sign_bit_copies (x, mode)\n \t\t\t  - (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n \t\t\t     - bitwidth)));\n \t}\n+\n+#if defined(BYTE_LOADS_ZERO_EXTEND) || defined(BYTE_LOADS_SIGN_EXTEND)\n+      /* For paradoxical SUBREGs, just look inside since, on machines with\n+\t one of these defined, we assume that operations are actually \n+\t performed on the full register.  Note that we are passing MODE\n+\t to the recursive call, so the number of sign bit copies will\n+\t remain relative to that mode, not the inner mode.  */\n+\n+      if (GET_MODE_SIZE (GET_MODE (x))\n+\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\treturn num_sign_bit_copies (SUBREG_REG (x), mode);\n+#endif\n+\n       break;\n \n     case SIGN_EXTRACT:"}]}