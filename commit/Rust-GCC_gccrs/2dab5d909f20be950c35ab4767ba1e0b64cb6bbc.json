{"sha": "2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmRhYjVkOTA5ZjIwYmU5NTBjMzVhYjQ3NjdiYTFlMGI2NGNiNmJiYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-03-07T14:31:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-03-07T14:31:03Z"}, "message": "runtime: use a fence instruction before rdtsc\n    \n    This implements the same choices made in the gc runtime, except that\n    for 32-bit x86 we only use the fence instruction if the processor\n    supports SSE2.\n    \n    The code here is hacked up for speed; the gc runtime uses straight\n    assembler.\n    \n    Reviewed-on: https://go-review.googlesource.com/97715\n\nFrom-SVN: r258336", "tree": {"sha": "a2f3871cade9720ac021f8cdb38d3be3270e83be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2f3871cade9720ac021f8cdb38d3be3270e83be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc/comments", "author": null, "committer": null, "parents": [{"sha": "6cde8c545b8a300409863c70526189d3f7f659df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cde8c545b8a300409863c70526189d3f7f659df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cde8c545b8a300409863c70526189d3f7f659df"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "26293e56fce3ba2ff9f673f9d0620fb19731971a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "patch": "@@ -1,4 +1,4 @@\n-3287064c24cbf0c50776cdb87a720d29130b4363\n+2a07cd31927ac943104f55d2b696e53e7cd073b3\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "c65a7e0a950b8dae55b861607828f81e3d373117", "filename": "libgo/runtime/runtime_c.c", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc/libgo%2Fruntime%2Fruntime_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2dab5d909f20be950c35ab4767ba1e0b64cb6bbc/libgo%2Fruntime%2Fruntime_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime_c.c?ref=2dab5d909f20be950c35ab4767ba1e0b64cb6bbc", "patch": "@@ -33,13 +33,47 @@ runtime_atoi(const byte *p, intgo len)\n \treturn n;\n }\n \n+#if defined(__i386__) || defined(__x86_64__) || defined (__s390__) || defined (__s390x__)\n+\n+// When cputicks is just asm instructions, skip the split stack\n+// prologue for speed.\n+\n+int64 runtime_cputicks(void) __attribute__((no_split_stack));\n+\n+#endif\n+\n+// Whether the processor supports SSE2.\n+#if defined (__i386__)\n+static _Bool hasSSE2;\n+\n+// Force appropriate CPU level so that we can call the lfence/mfence\n+// builtins.\n+\n+#pragma GCC push_options\n+#pragma GCC target(\"sse2\")\n+\n+#elif defined(__x86_64__)\n+#define hasSSE2 true\n+#endif\n+\n+#if defined(__i386__) || defined(__x86_64__)\n+// Whether to use lfence, as opposed to mfence.\n+// Set based on cpuid.\n+static _Bool lfenceBeforeRdtsc;\n+#endif // defined(__i386__) || defined(__x86_64__)\n+\n int64\n runtime_cputicks(void)\n {\n-#if defined(__386__) || defined(__x86_64__)\n-  uint32 low, high;\n-  asm(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n-  return (int64)(((uint64)high << 32) | (uint64)low);\n+#if defined(__i386__) || defined(__x86_64__)\n+  if (hasSSE2) {\n+    if (lfenceBeforeRdtsc) {\n+      __builtin_ia32_lfence();\n+    } else {\n+      __builtin_ia32_mfence();\n+    }\n+  }\n+  return __builtin_ia32_rdtsc();\n #elif defined (__s390__) || defined (__s390x__)\n   uint64 clock = 0;\n   /* stckf may not write the return variable in case of a clock error, so make\n@@ -56,6 +90,10 @@ runtime_cputicks(void)\n #endif\n }\n \n+#if defined(__i386__)\n+#pragma GCC pop_options\n+#endif\n+\n void\n runtime_signalstack(byte *p, uintptr n)\n {\n@@ -146,8 +184,21 @@ runtime_cpuinit()\n #if defined(__i386__) || defined(__x86_64__)\n \tunsigned int eax, ebx, ecx, edx;\n \n+\tif (__get_cpuid(0, &eax, &ebx, &ecx, &edx)) {\n+\t\tif (eax != 0\n+\t\t    && ebx == 0x756E6547    // \"Genu\"\n+\t\t    && edx == 0x49656E69    // \"ineI\"\n+\t\t    && ecx == 0x6C65746E) { // \"ntel\"\n+\t\t\tlfenceBeforeRdtsc = true;\n+\t\t}\n+\t}\n \tif (__get_cpuid(1, &eax, &ebx, &ecx, &edx)) {\n \t\tsetCpuidECX(ecx);\n+#if defined(__i386__)\n+\t\tif ((edx & bit_SSE2) != 0) {\n+\t\t\thasSSE2 = true;\n+\t\t}\n+#endif\n \t}\n \n #if defined(HAVE_AS_X86_AES)"}]}