{"sha": "3f561db7ca1fba70a90c3ff9f7682b7841585258", "node_id": "C_kwDOANBUbNoAKDNmNTYxZGI3Y2ExZmJhNzBhOTBjM2ZmOWY3NjgyYjc4NDE1ODUyNTg", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-08-12T20:49:16Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-10-01T06:13:39Z"}, "message": "[Ada] More work on efficiency improvements\n\ngcc/ada/\n\n\t* table.ads (Table_Type): Remove \"aliased\"; no longer needed by\n\tAtree.  Besides it contradicted the comment a few lines above,\n\t\"--  Note: We do not make the table components aliased...\".\n\t* types.ads: Move type Slot to Atree.\n\t* atree.ads: Move type Slot fromt Types to here.  Move type\n\tNode_Header from Seinfo to here.\n\t* atree.adb: Avoid the need for aliased components of the Slots\n\ttable.  Instead of 'Access, use a getter and setter.  Misc\n\tcleanups.\n\t(Print_Statistics): Print statistics about node and entity kind\n\tfrequencies. Give 3 digit fractions instead of percentages.\n\t* (Get_Original_Node_Count, Set_Original_Node_Count): Statistics\n\tfor calls to Original_Node and Set_Original_Node.\n\t(Original_Node, Set_Original_Node): Gather statistics by calling\n\tthe above.\n\t(Print_Field_Statistics): Print Original_Node statistics.\n\t(Update_Kind_Statistics): Remove, and put all statistics\n\tgathering under \"if Atree_Statistics_Enabled\", which is a flag\n\tgenerated in Seinfo by Gen_IL.\n\t* gen_il-gen.adb (Compute_Field_Offsets): Choose offsets of\n\tNkind, Ekind, and Homonym first. This causes a slight efficiency\n\timprovement.  Misc cleanups.  Do not generate Node_Header; it is\n\tnow hand-written in Atree.  When choosing the order in which to\n\tassign offsets, weight by the frequency of the node type, so the\n\tmore common nodes get their field offsets assigned earlier.  Add\n\tmore special cases.\n\t(Compute_Type_Sizes): Remove this and related things.\n\tThere was a comment: \"At some point we can instrument Atree to\n\tprint out accurate size statistics, and remove this code.\" We\n\thave Atree statistics, so we now remove this code.\n\t(Put_Seinfo): Generate Atree_Statistics_Enabled, which is equal\n\tto Statistics_Enabled. This allows Atree to say \"if\n\tAtree_Statistics_Enabled then <gather statistics>\" for\n\tefficiency. When Atree_Statistics_Enabled is False, the \"if ...\"\n\twill be optimized away.\n\t* gen_il-internals.ads (Type_Frequency): New table of kind\n\tfrequencies.\n\t* gen_il-internals.adb: Minor comment improvement.\n\t* gen_il-fields.ads: Remove unused subtypes.  Suppress style\n\tchecks in the Type_Frequency table.  If we regenerate this\n\ttable (see -gnatd.A) we don't want to have to fiddle with\n\tcasing.\n\t* impunit.adb: Minor.\n\t* sinfo-utils.adb: Minor.\n\t* debug.adb: Minor comment improvement.", "tree": {"sha": "632c7498e7dd06afbfad5bc717c05f2a695f68b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/632c7498e7dd06afbfad5bc717c05f2a695f68b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f561db7ca1fba70a90c3ff9f7682b7841585258", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f561db7ca1fba70a90c3ff9f7682b7841585258", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f561db7ca1fba70a90c3ff9f7682b7841585258", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f561db7ca1fba70a90c3ff9f7682b7841585258/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a81dbb618e3ac6cd42ac6f296a96296e099ac1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a81dbb618e3ac6cd42ac6f296a96296e099ac1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a81dbb618e3ac6cd42ac6f296a96296e099ac1f"}], "stats": {"total": 951, "additions": 590, "deletions": 361}, "files": [{"sha": "98614e89e968abbf4ab2dd1971d4dbb02d55ea77", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 178, "deletions": 63, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -211,10 +211,6 @@ package body Atree is\n      (Old_N : Entity_Id; New_Kind : Entity_Kind);\n    --  Above are the same as the ones for nodes, but for entities\n \n-   procedure Update_Kind_Statistics (Field : Node_Or_Entity_Field);\n-   --  Increment Set_Count (Field). This is in a procedure so we can put it in\n-   --  pragma Debug for efficiency.\n-\n    procedure Init_Nkind (N : Node_Id; Val : Node_Kind);\n    --  Initialize the Nkind field, which must not have been set already. This\n    --  cannot be used to modify an already-initialized Nkind field. See also\n@@ -639,7 +635,7 @@ package body Atree is\n       --  S is the slot at that offset. V is the amount to shift by.\n \n       function In_NH (Slot_Off : Field_Offset) return Boolean is\n-        (Slot_Off < Seinfo.N_Head);\n+        (Slot_Off < N_Head);\n       --  In_NH stands for \"in Node_Header\", not \"in New Hampshire\"\n \n       function Get_Slot\n@@ -648,8 +644,13 @@ package body Atree is\n          (if In_NH (Slot_Off) then\n             Node_Offsets.Table (N).Slots (Slot_Off)\n           else Slots.Table (Node_Offsets.Table (N).Offset + Slot_Off));\n-      --  Get the slot, either directly from the node header, or indirectly\n-      --  from the Slots table.\n+      --  Get the slot value, either directly from the node header, or\n+      --  indirectly from the Slots table.\n+\n+      procedure Set_Slot\n+        (N : Node_Or_Entity_Id; Slot_Off : Field_Offset; S : Slot);\n+      --  Set the slot value, either directly from the node header, or\n+      --  indirectly from the Slots table, to S.\n \n       function Get_1_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_1_Bit\n@@ -730,13 +731,15 @@ package body Atree is\n          return Raw;\n       end Get_32_Bit_Val;\n \n-      type Slot_Ptr is access all Slot;\n-      function Get_Slot_Ptr\n-        (N : Node_Or_Entity_Id; Slot_Off : Field_Offset)\n-         return Slot_Ptr is\n-         (if In_NH (Slot_Off) then\n-            Node_Offsets.Table (N).Slots (Slot_Off)'Access\n-          else Slots.Table (Node_Offsets.Table (N).Offset + Slot_Off)'Access);\n+      procedure Set_Slot\n+        (N : Node_Or_Entity_Id; Slot_Off : Field_Offset; S : Slot) is\n+      begin\n+         if In_NH (Slot_Off) then\n+            Node_Offsets.Table (N).Slots (Slot_Off) := S;\n+         else\n+            Slots.Table (Node_Offsets.Table (N).Offset + Slot_Off) := S;\n+         end if;\n+      end Set_Slot;\n \n       procedure Set_1_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_1_Bit)\n@@ -745,12 +748,13 @@ package body Atree is\n          Mask : constant := 2**F_Size - 1;\n          F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n          Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n-         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n-         S : Slot renames Ptr.all;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n          V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n          pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n+         Set_Slot\n+           (N, Slot_Off,\n+            (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V));\n       end Set_1_Bit_Val;\n \n       procedure Set_2_Bit_Val\n@@ -760,12 +764,13 @@ package body Atree is\n          Mask : constant := 2**F_Size - 1;\n          F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n          Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n-         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n-         S : Slot renames Ptr.all;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n          V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n          pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n+         Set_Slot\n+           (N, Slot_Off,\n+            (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V));\n       end Set_2_Bit_Val;\n \n       procedure Set_4_Bit_Val\n@@ -775,12 +780,13 @@ package body Atree is\n          Mask : constant := 2**F_Size - 1;\n          F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n          Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n-         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n-         S : Slot renames Ptr.all;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n          V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n          pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n+         Set_Slot\n+           (N, Slot_Off,\n+            (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V));\n       end Set_4_Bit_Val;\n \n       procedure Set_8_Bit_Val\n@@ -790,26 +796,25 @@ package body Atree is\n          Mask : constant := 2**F_Size - 1;\n          F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n          Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n-         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n-         S : Slot renames Ptr.all;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n          V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n          pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n+         Set_Slot\n+           (N, Slot_Off,\n+            (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V));\n       end Set_8_Bit_Val;\n \n       procedure Set_32_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_32_Bit)\n       is\n          F_Size : constant := 32;\n-         --  No Mask needed\n+         --  No Mask needed; this one doesn't do read-modify-write\n          F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n          Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n-         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n-         S : Slot renames Ptr.all;\n          pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := Slot (Val);\n+         Set_Slot (N, Slot_Off, Slot (Val));\n       end Set_32_Bit_Val;\n \n       ----------------------\n@@ -836,9 +841,9 @@ package body Atree is\n \n    end Atree_Private_Part;\n \n-   ---------------\n-   -- Set_Field --\n-   ---------------\n+   ---------------------\n+   -- Get_Field_Value --\n+   ---------------------\n \n    function Get_Node_Field_Union is new Get_32_Bit_Field (Union_Id)\n      with Inline;\n@@ -848,10 +853,10 @@ package body Atree is\n    function Get_Field_Value\n      (N : Node_Id; Field : Node_Or_Entity_Field) return Field_Size_32_Bit\n    is\n-      Desc : Seinfo.Field_Descriptor renames Field_Descriptors (Field);\n+      Desc : Field_Descriptor renames Field_Descriptors (Field);\n \n    begin\n-      case Seinfo.Field_Size (Desc.Kind) is\n+      case Field_Size (Desc.Kind) is\n          when 1 => return Field_Size_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n          when 2 => return Field_Size_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n          when 4 => return Field_Size_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n@@ -860,13 +865,17 @@ package body Atree is\n       end case;\n    end Get_Field_Value;\n \n+   ---------------------\n+   -- Set_Field_Value --\n+   ---------------------\n+\n    procedure Set_Field_Value\n      (N : Node_Id; Field : Node_Or_Entity_Field; Val : Field_Size_32_Bit)\n    is\n-      Desc : Seinfo.Field_Descriptor renames Field_Descriptors (Field);\n+      Desc : Field_Descriptor renames Field_Descriptors (Field);\n \n    begin\n-      case Seinfo.Field_Size (Desc.Kind) is\n+      case Field_Size (Desc.Kind) is\n          when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_Size_1_Bit (Val));\n          when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_Size_2_Bit (Val));\n          when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_Size_4_Bit (Val));\n@@ -974,17 +983,15 @@ package body Atree is\n    Nkind_Offset : constant Field_Offset :=\n      Field_Descriptors (F_Nkind).Offset;\n \n-   procedure Update_Kind_Statistics (Field : Node_Or_Entity_Field) is\n-   begin\n-      Set_Count (Field) := Set_Count (Field) + 1;\n-   end Update_Kind_Statistics;\n-\n    procedure Set_Node_Kind_Type is new Set_8_Bit_Field (Node_Kind) with Inline;\n \n    procedure Init_Nkind (N : Node_Id; Val : Node_Kind) is\n       pragma Assert (Field_Is_Initial_Zero (N, F_Nkind));\n    begin\n-      pragma Debug (Update_Kind_Statistics (F_Nkind));\n+      if Atree_Statistics_Enabled then\n+         Set_Count (F_Nkind) := Set_Count (F_Nkind) + 1;\n+      end if;\n+\n       Set_Node_Kind_Type (N, Nkind_Offset, Val);\n    end Init_Nkind;\n \n@@ -1016,7 +1023,7 @@ package body Atree is\n                declare\n                   New_Off_F : constant Node_Offset := Alloc_Slots (New_Size);\n                begin\n-                  All_Node_Offsets (N).Offset := New_Off_F - Seinfo.N_Head;\n+                  All_Node_Offsets (N).Offset := New_Off_F - N_Head;\n                   Copy_Dynamic_Slots (Old_Off_F, New_Off_F, Old_Size);\n                   pragma Debug\n                     (Zero_Dynamic_Slots (Old_Off_F, Old_Off_F + Old_Size - 1));\n@@ -1027,7 +1034,10 @@ package body Atree is\n          Zero_Dynamic_Slots (Off_F (N) + Old_Size, Slots.Last);\n       end if;\n \n-      pragma Debug (Update_Kind_Statistics (F_Nkind));\n+      if Atree_Statistics_Enabled then\n+         Set_Count (F_Nkind) := Set_Count (F_Nkind) + 1;\n+      end if;\n+\n       Set_Node_Kind_Type (N, Nkind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n \n@@ -1060,7 +1070,10 @@ package body Atree is\n       --  For now, we are allocating all entities with the same size, so we\n       --  don't need to reallocate slots here.\n \n-      pragma Debug (Update_Kind_Statistics (F_Ekind));\n+      if Atree_Statistics_Enabled then\n+         Set_Count (F_Nkind) := Set_Count (F_Ekind) + 1;\n+      end if;\n+\n       Set_Entity_Kind_Type (N, Ekind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n \n@@ -1078,7 +1091,7 @@ package body Atree is\n             Sz : constant Slot_Count := Size_In_Slots_To_Alloc (Kind);\n             Sl : constant Node_Offset := Alloc_Slots (Sz);\n          begin\n-            Node_Offsets.Table (Result).Offset := Sl - Seinfo.N_Head;\n+            Node_Offsets.Table (Result).Offset := Sl - N_Head;\n             Zero_Dynamic_Slots (Sl, Sl + Sz - 1);\n             Zero_Header_Slots (Result);\n          end;\n@@ -1141,7 +1154,7 @@ package body Atree is\n             New_Offset : constant Field_Offset := Alloc_Slots (New_Size);\n          begin\n             pragma Debug (Zero_Slots (N));\n-            Node_Offsets.Table (N).Offset := New_Offset - Seinfo.N_Head;\n+            Node_Offsets.Table (N).Offset := New_Offset - N_Head;\n             Zero_Dynamic_Slots (New_Offset, New_Offset + New_Size - 1);\n             Zero_Header_Slots (N);\n          end;\n@@ -1229,7 +1242,7 @@ package body Atree is\n       if D_Size < S_Size then\n          pragma Debug (Zero_Slots (Destination)); -- destroy old slots\n          Node_Offsets.Table (Destination).Offset :=\n-           Alloc_Slots (S_Size) - Seinfo.N_Head;\n+           Alloc_Slots (S_Size) - N_Head;\n       end if;\n \n       Copy_Slots (Source, Destination);\n@@ -1447,7 +1460,7 @@ package body Atree is\n         (Is_Entity (E1) and then Is_Entity (E2)\n            and then not In_List (E1) and then not In_List (E2));\n \n-      Old_E1 : constant Seinfo.Node_Header := Node_Offsets.Table (E1);\n+      Old_E1 : constant Node_Header := Node_Offsets.Table (E1);\n \n    begin\n       Node_Offsets.Table (E1) := Node_Offsets.Table (E2);\n@@ -1546,7 +1559,6 @@ package body Atree is\n    begin\n       for J in Fields'Range loop\n          declare\n-            use Seinfo;\n             Desc : Field_Descriptor renames Field_Descriptors (Fields (J));\n          begin\n             if Desc.Kind in Node_Id_Field | List_Id_Field then\n@@ -1698,7 +1710,7 @@ package body Atree is\n \n       return New_Id : constant Node_Id := Alloc_Node_Id do\n          Node_Offsets.Table (New_Id).Offset :=\n-           Alloc_Slots (S_Size) - Seinfo.N_Head;\n+           Alloc_Slots (S_Size) - N_Head;\n          Orig_Nodes.Append (New_Id);\n          Copy_Slots (Source, New_Id);\n \n@@ -1858,7 +1870,7 @@ package body Atree is\n \n    function Off_F (N : Node_Id) return Node_Offset is\n    begin\n-      return Off_0 (N) + Seinfo.N_Head;\n+      return Off_0 (N) + N_Head;\n    end Off_F;\n \n    -----------\n@@ -1881,6 +1893,9 @@ package body Atree is\n    function Original_Node (Node : Node_Id) return Node_Id is\n    begin\n       pragma Debug (Validate_Node (Node));\n+      if Atree_Statistics_Enabled then\n+         Get_Original_Node_Count := Get_Original_Node_Count + 1;\n+      end if;\n \n       return Orig_Nodes.Table (Node);\n    end Original_Node;\n@@ -2176,6 +2191,9 @@ package body Atree is\n    procedure Set_Original_Node (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Debug (Validate_Node_Write (N));\n+      if Atree_Statistics_Enabled then\n+         Set_Original_Node_Count := Set_Original_Node_Count + 1;\n+      end if;\n \n       Orig_Nodes.Table (N) := Val;\n    end Set_Original_Node;\n@@ -2271,7 +2289,7 @@ package body Atree is\n    begin\n       return\n         (if Kind in N_Entity then Einfo.Entities.Max_Entity_Size\n-         else Sinfo.Nodes.Size (Kind)) - Seinfo.N_Head;\n+         else Sinfo.Nodes.Size (Kind)) - N_Head;\n       --  Unfortunately, we don't know the Entity_Kind, so we have to use the\n       --  max.\n    end Size_In_Slots_To_Alloc;\n@@ -2300,7 +2318,7 @@ package body Atree is\n \n    function Size_In_Slots_Dynamic (N : Node_Or_Entity_Id) return Slot_Count is\n    begin\n-      return Size_In_Slots (N) - Seinfo.N_Head;\n+      return Size_In_Slots (N) - N_Head;\n    end Size_In_Slots_Dynamic;\n \n    -------------------\n@@ -2492,9 +2510,104 @@ package body Atree is\n    -- Print_Statistics --\n    ----------------------\n \n-   procedure Print_Statistics is\n+   procedure Print_Node_Statistics;\n+   procedure Print_Field_Statistics;\n+   --  Helpers for Print_Statistics\n+\n+   procedure Write_Ratio (X : Nat_64; Y : Pos_64);\n+   --  Write the value of (X/Y) without using 'Image (approximately)\n+\n+   procedure Write_Ratio (X : Nat_64; Y : Pos_64) is\n+      pragma Assert (X <= Y);\n+      Ratio : constant Nat := Nat ((Long_Float (X) / Long_Float (Y)) * 1000.0);\n+   begin\n+      Write_Str (\" (\");\n+\n+      if Ratio = 0 then\n+         Write_Str (\"0.000\");\n+      elsif Ratio in 1 .. 9 then\n+         Write_Str (\"0.00\");\n+         Write_Int (Ratio);\n+      elsif Ratio in 10 .. 99 then\n+         Write_Str (\"0.0\");\n+         Write_Int (Ratio);\n+      elsif Ratio in 100 .. 999 then\n+         Write_Str (\"0.\");\n+         Write_Int (Ratio);\n+      else\n+         Write_Int (Ratio / 1000);\n+      end if;\n+\n+      Write_Str (\")\");\n+   end Write_Ratio;\n+\n+   procedure Print_Node_Statistics is\n+      subtype Count is Nat_64;\n+      Node_Counts : array (Node_Kind) of Count := (others => 0);\n+      Entity_Counts : array (Entity_Kind) of Count := (others => 0);\n+\n+      All_Node_Offsets : Node_Offsets.Table_Type renames\n+        Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n+   begin\n+      Write_Int (Int (Node_Offsets.Last));\n+      Write_Line (\" nodes (including entities)\");\n+      Write_Int (Int (Slots.Last));\n+      Write_Line (\" non-header slots\");\n+\n+      for N in All_Node_Offsets'Range loop\n+         declare\n+            K : constant Node_Kind := Nkind (N);\n+\n+         begin\n+            Node_Counts (K) := Node_Counts (K) + 1;\n+\n+            if K in N_Entity then\n+               Entity_Counts (Ekind (N)) := Entity_Counts (Ekind (N)) + 1;\n+            end if;\n+         end;\n+      end loop;\n+\n+      for K in Node_Kind loop\n+         declare\n+            Count : constant Nat_64 := Node_Counts (K);\n+         begin\n+            Write_Int_64 (Count);\n+            Write_Ratio (Count, Int_64 (Node_Offsets.Last));\n+            Write_Str (\" \");\n+            Write_Str (Node_Kind'Image (K));\n+            Write_Str (\" \");\n+            Write_Int (Int (Sinfo.Nodes.Size (K)));\n+            Write_Str (\" slots\");\n+            Write_Eol;\n+         end;\n+      end loop;\n+\n+      for K in Entity_Kind loop\n+         declare\n+            Count : constant Nat_64 := Entity_Counts (K);\n+         begin\n+            Write_Int_64 (Count);\n+            Write_Ratio (Count, Int_64 (Node_Offsets.Last));\n+            Write_Str (\" \");\n+            Write_Str (Entity_Kind'Image (K));\n+            Write_Str (\" \");\n+            Write_Int (Int (Einfo.Entities.Size (K)));\n+            Write_Str (\" slots\");\n+            Write_Eol;\n+         end;\n+      end loop;\n+   end Print_Node_Statistics;\n+\n+   procedure Print_Field_Statistics is\n       Total, G_Total, S_Total : Call_Count := 0;\n    begin\n+      Write_Int_64 (Get_Original_Node_Count);\n+      Write_Str (\" + \");\n+      Write_Int_64 (Set_Original_Node_Count);\n+      Write_Eol;\n+      Write_Line (\" Original_Node_Count getter and setter calls\");\n+      Write_Eol;\n+\n       Write_Line (\"Frequency of field getter and setter calls:\");\n \n       for Field in Node_Or_Entity_Field loop\n@@ -2520,19 +2633,13 @@ package body Atree is\n             S : constant Call_Count := Set_Count (Field);\n             GS : constant Call_Count := G + S;\n \n-            Percent : constant Int :=\n-              Int ((Long_Float (GS) / Long_Float (Total)) * 100.0);\n-\n-            use Seinfo;\n             Desc : Field_Descriptor renames Field_Descriptors (Field);\n             Slot : constant Field_Offset :=\n               (Field_Size (Desc.Kind) * Desc.Offset) / Slot_Size;\n \n          begin\n             Write_Int_64 (GS);\n-            Write_Str (\" (\");\n-            Write_Int (Percent);\n-            Write_Str (\"%)\");\n+            Write_Ratio (GS, Total);\n             Write_Str (\" = \");\n             Write_Int_64 (G);\n             Write_Str (\" + \");\n@@ -2546,6 +2653,14 @@ package body Atree is\n             Write_Eol;\n          end;\n       end loop;\n+   end Print_Field_Statistics;\n+\n+   procedure Print_Statistics is\n+   begin\n+      Write_Eol;\n+      Write_Eol;\n+      Print_Node_Statistics;\n+      Print_Field_Statistics;\n    end Print_Statistics;\n \n end Atree;"}, {"sha": "2f3ca40ad08ebb3253ed2852d0c1456fcbfae62d", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -48,7 +48,7 @@ with Alloc;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Einfo.Entities; use Einfo.Entities;\n with Types;          use Types;\n-with Seinfo;\n+with Seinfo;         use Seinfo;\n with System;         use System;\n with Table;\n with Unchecked_Conversion;\n@@ -653,11 +653,30 @@ package Atree is\n       --  table. We use zero-origin addressing, so the Offset into the Slots\n       --  table will point 3 slots before slot 3.\n \n-      pragma Assert (Seinfo.N_Head <= Min_Node_Size);\n-      pragma Assert (Seinfo.N_Head <= Min_Entity_Size);\n+      pragma Assert (N_Head <= Min_Node_Size);\n+      pragma Assert (N_Head <= Min_Entity_Size);\n+\n+      Slot_Size : constant := 32;\n+      type Slot is mod 2**Slot_Size;\n+      for Slot'Size use Slot_Size;\n+\n+      --  The type Slot is defined in Types as a 32-bit modular integer. It\n+      --  is logically split into the appropriate numbers of components of\n+      --  appropriate size, but this splitting is not explicit because packed\n+      --  arrays cannot be properly interfaced in C/C++ and packed records are\n+      --  way too slow.\n+\n+      type Node_Header_Slots is\n+        array (Field_Offset range 0 .. N_Head - 1) of Slot;\n+      type Node_Header is record\n+         Slots : Node_Header_Slots;\n+         Offset : Node_Offset'Base;\n+      end record;\n+      pragma Assert (Node_Header'Size = (N_Head + 1) * Slot_Size);\n+      pragma Assert (Node_Header'Size = 16 * 8);\n \n       package Node_Offsets is new Table.Table\n-        (Table_Component_Type => Seinfo.Node_Header,\n+        (Table_Component_Type => Node_Header,\n          Table_Index_Type     => Node_Id'Base,\n          Table_Low_Bound      => First_Node_Id,\n          Table_Initial        => Alloc.Node_Offsets_Initial,\n@@ -671,12 +690,6 @@ package Atree is\n       --  Short names for use in gdb, not used in real code. Note that gdb\n       --  can't find Node_Offsets.Table without a full expanded name.\n \n-      --  The type Slot is defined in Types as a 32-bit modular integer. It\n-      --  is logically split into the appropriate numbers of components of\n-      --  appropriate size, but this splitting is not explicit because packed\n-      --  arrays cannot be properly interfaced in C/C++ and packed records are\n-      --  way too slow.\n-\n       function Shift_Left (S : Slot; V : Natural) return Slot;\n       pragma Import (Intrinsic, Shift_Left);\n \n@@ -870,6 +883,8 @@ package Atree is\n    --  Number of calls to each getter and setter. See documentaton for\n    --  -gnatd.A.\n \n+   Get_Original_Node_Count, Set_Original_Node_Count : Call_Count := 0;\n+\n    procedure Print_Statistics;\n \n end Atree;"}, {"sha": "7b2b147c6f775b821f196510fd7fa7bb60af877f", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -831,8 +831,9 @@ package body Debug is\n    --       targets that do not use the GCC back end, this switch is ignored.\n \n    --  d.A  Enable statistics printing in Atree. First set Statistics_Enabled\n-   --       in gen_il-gen.adb to True, then rebuild, then run the compiler with\n-   --       -gnatd.A. You might want to apply \"sort -nr\" to the output.\n+   --       in gen_il-gen.adb to True, then rebuild, then run the compiler\n+   --       with -gnatd.A. You might want to apply \"sort -nr\" to parts of the\n+   --       output.\n \n    --  d.B  Generate a bug box when we see an abort_statement, even though\n    --       there is no bug. Useful for testing Comperr.Compiler_Abort: write"}, {"sha": "f8bfe6e0b24c09f245d719c7baf47628d3303ede", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -23,8 +23,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Gen_IL.Types;\n-\n package Gen_IL.Fields is\n \n    --  The following is \"optional field enumeration\" -- i.e. it is Field_Enum\n@@ -36,8 +34,7 @@ package Gen_IL.Fields is\n    --  which might need to be kept in sync when modifying this.\n \n    --  Be sure to put new fields in the appropriate subrange (Field_Enum,\n-   --  Node_Header_Field, Node_Field, Entity_Field -- search for comments\n-   --  below).\n+   --  Node_Field, Entity_Field -- search for comments below).\n \n    type Opt_Field_Enum is\n      (No_Field,\n@@ -943,13 +940,4 @@ package Gen_IL.Fields is\n    --  Enumeration of fields -- Opt_Field_Enum without the special null value\n    --  No_Field.\n \n-   subtype Node_Header_Field is Field_Enum with Predicate =>\n-     Node_Header_Field in Nkind .. Link | Ekind;\n-\n-   use Gen_IL.Types;\n-\n-   subtype Node_Header_Type is Type_Enum range\n-     Node_Kind_Type .. Union_Id;\n-   --  Types of node header fields\n-\n end Gen_IL.Fields;"}, {"sha": "305a99ae35c83b3da0ca1ed2faff996a94f06b29", "filename": "gcc/ada/gen_il-gen.adb", "status": "modified", "additions": 32, "deletions": 258, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -503,8 +503,6 @@ package body Gen_IL.Gen is\n       Min_Entity_Size : Field_Offset := Field_Offset'Last;\n       Max_Entity_Size : Field_Offset := 0;\n \n-      Average_Node_Size_In_Slots : Long_Float;\n-\n       Node_Field_Types_Used, Entity_Field_Types_Used : Type_Set;\n \n       Setter_Needs_Parent : Field_Set :=\n@@ -1001,16 +999,16 @@ package body Gen_IL.Gen is\n               Image (Gen_IL.Internals.Bit_Offset'Last) & \" is too small)\";\n          end Choose_Offset;\n \n-         Num_Concrete_Have_Field : array (Field_Enum) of Type_Count :=\n+         Weighted_Node_Frequency : array (Field_Enum) of Type_Count :=\n            (others => 0);\n          --  Number of concrete types that have each field\n \n          function More_Types_Have_Field (F1, F2 : Field_Enum) return Boolean is\n-           (Num_Concrete_Have_Field (F1) > Num_Concrete_Have_Field (F2));\n+           (Weighted_Node_Frequency (F1) > Weighted_Node_Frequency (F2));\n          --  True if F1 appears in more concrete types than F2\n \n          function Sort_Less (F1, F2 : Field_Enum) return Boolean is\n-           (if Num_Concrete_Have_Field (F1) = Num_Concrete_Have_Field (F2) then\n+           (if Weighted_Node_Frequency (F1) = Weighted_Node_Frequency (F2) then\n               F1 < F2\n             else More_Types_Have_Field (F1, F2));\n \n@@ -1019,15 +1017,18 @@ package body Gen_IL.Gen is\n \n          All_Fields : Field_Vector;\n \n+      --  Start of processing for Compute_Field_Offsets\n+\n       begin\n \n-         --  Compute the number of types that have each field\n+         --  Compute the number of types that have each field, weighted by the\n+         --  frequency of such nodes.\n \n          for T in Concrete_Type loop\n             for F in Field_Enum loop\n                if Fields_Per_Node (T) (F) then\n-                  Num_Concrete_Have_Field (F) :=\n-                    Num_Concrete_Have_Field (F) + 1;\n+                  Weighted_Node_Frequency (F) :=\n+                    Weighted_Node_Frequency (F) + Type_Frequency (T);\n                end if;\n             end loop;\n          end loop;\n@@ -1042,13 +1043,6 @@ package body Gen_IL.Gen is\n             Append (All_Fields, F);\n          end loop;\n \n-         --  Force Homonym to be at offset zero, which speeds up the\n-         --  compiler. The Sort below will place Homonym first in\n-         --  All_Fields.\n-\n-         Num_Concrete_Have_Field (Homonym) :=\n-           Num_Concrete_Have_Field (Nkind) + 1;\n-\n          --  Sort All_Fields based on how many concrete types have the field.\n          --  This is for efficiency; we want to choose the offsets of the most\n          --  common fields first, so they get low numbers.\n@@ -1069,7 +1063,22 @@ package body Gen_IL.Gen is\n          --  get low offsets, so they will wind up in the node header for\n          --  faster access.\n \n+         Choose_Offset (Nkind);\n+         pragma Assert (Field_Table (Nkind).Offset = 0);\n+         Choose_Offset (Ekind);\n+         pragma Assert (Field_Table (Ekind).Offset = 1);\n          Choose_Offset (Homonym);\n+         pragma Assert (Field_Table (Homonym).Offset = 1);\n+         Choose_Offset (Is_Immediately_Visible);\n+         pragma Assert (Field_Table (Is_Immediately_Visible).Offset = 16);\n+         Choose_Offset (From_Limited_With);\n+         pragma Assert (Field_Table (From_Limited_With).Offset = 17);\n+         Choose_Offset (Is_Potentially_Use_Visible);\n+         pragma Assert (Field_Table (Is_Potentially_Use_Visible).Offset = 18);\n+         Choose_Offset (Is_Generic_Instance);\n+         pragma Assert (Field_Table (Is_Generic_Instance).Offset = 19);\n+         Choose_Offset (Scope);\n+         pragma Assert (Field_Table (Scope).Offset = 2);\n \n          --  Then loop through them all, skipping the ones we did above\n \n@@ -1086,231 +1095,6 @@ package body Gen_IL.Gen is\n       ------------------------\n \n       procedure Compute_Type_Sizes is\n-         --  Node_Counts is the number of nodes of each kind created during\n-         --  compilation of a large example. This is used purely to compute an\n-         --  estimate of the average node size. New node types can default to\n-         --  \"others => 0\". At some point we can instrument Atree to print out\n-         --  accurate size statistics, and remove this code.\n-\n-         Node_Counts : constant array (Concrete_Node) of Natural :=\n-           (N_Identifier => 429298,\n-            N_Defining_Identifier => 231636,\n-            N_Integer_Literal => 90892,\n-            N_Parameter_Specification => 62811,\n-            N_Attribute_Reference => 47150,\n-            N_Expanded_Name => 37375,\n-            N_Selected_Component => 30699,\n-            N_Subprogram_Declaration => 20744,\n-            N_Freeze_Entity => 20314,\n-            N_Procedure_Specification => 18901,\n-            N_Object_Declaration => 18023,\n-            N_Function_Specification => 16570,\n-            N_Range => 16216,\n-            N_Explicit_Dereference => 12198,\n-            N_Component_Association => 11188,\n-            N_Unchecked_Type_Conversion => 11165,\n-            N_Subtype_Indication => 10727,\n-            N_Procedure_Call_Statement => 10056,\n-            N_Subtype_Declaration => 8141,\n-            N_Handled_Sequence_Of_Statements => 8078,\n-            N_Null => 7288,\n-            N_Aggregate => 7222,\n-            N_String_Literal => 7152,\n-            N_Function_Call => 6958,\n-            N_Simple_Return_Statement => 6911,\n-            N_And_Then => 6867,\n-            N_Op_Eq => 6845,\n-            N_Call_Marker => 6683,\n-            N_Pragma_Argument_Association => 6525,\n-            N_Component_Definition => 6487,\n-            N_Assignment_Statement => 6483,\n-            N_With_Clause => 6480,\n-            N_Null_Statement => 5917,\n-            N_Index_Or_Discriminant_Constraint => 5877,\n-            N_Generic_Association => 5667,\n-            N_Full_Type_Declaration => 5573,\n-            N_If_Statement => 5553,\n-            N_Subprogram_Body => 5455,\n-            N_Op_Add => 5443,\n-            N_Type_Conversion => 5260,\n-            N_Component_Declaration => 5059,\n-            N_Raise_Constraint_Error => 4840,\n-            N_Formal_Concrete_Subprogram_Declaration => 4602,\n-            N_Expression_With_Actions => 4598,\n-            N_Op_Ne => 3854,\n-            N_Indexed_Component => 3834,\n-            N_Op_Subtract => 3777,\n-            N_Package_Specification => 3490,\n-            N_Subprogram_Renaming_Declaration => 3445,\n-            N_Pragma => 3427,\n-            N_Case_Statement_Alternative => 3272,\n-            N_Block_Statement => 3239,\n-            N_Parameter_Association => 3213,\n-            N_Op_Lt => 3020,\n-            N_Op_Not => 2926,\n-            N_Character_Literal => 2914,\n-            N_Others_Choice => 2769,\n-            N_Or_Else => 2576,\n-            N_Itype_Reference => 2511,\n-            N_Defining_Operator_Symbol => 2487,\n-            N_Component_List => 2470,\n-            N_Formal_Object_Declaration => 2262,\n-            N_Generic_Subprogram_Declaration => 2227,\n-            N_Real_Literal => 2156,\n-            N_Op_Gt => 2156,\n-            N_Access_To_Object_Definition => 1984,\n-            N_Op_Le => 1975,\n-            N_Op_Ge => 1942,\n-            N_Package_Renaming_Declaration => 1811,\n-            N_Formal_Type_Declaration => 1756,\n-            N_Qualified_Expression => 1746,\n-            N_Package_Declaration => 1729,\n-            N_Record_Definition => 1651,\n-            N_Allocator => 1521,\n-            N_Op_Concat => 1377,\n-            N_Access_Definition => 1358,\n-            N_Case_Statement => 1322,\n-            N_Number_Declaration => 1316,\n-            N_Generic_Package_Declaration => 1311,\n-            N_Slice => 1078,\n-            N_Constrained_Array_Definition => 1068,\n-            N_Exception_Renaming_Declaration => 1011,\n-            N_Implicit_Label_Declaration => 978,\n-            N_Exception_Handler => 966,\n-            N_Private_Type_Declaration => 898,\n-            N_Operator_Symbol => 872,\n-            N_Formal_Private_Type_Definition => 867,\n-            N_Range_Constraint => 849,\n-            N_Aspect_Specification => 837,\n-            N_Variant => 834,\n-            N_Discriminant_Specification => 746,\n-            N_Loop_Statement => 744,\n-            N_Derived_Type_Definition => 731,\n-            N_Freeze_Generic_Entity => 702,\n-            N_Iteration_Scheme => 686,\n-            N_Package_Instantiation => 658,\n-            N_Loop_Parameter_Specification => 632,\n-            N_Attribute_Definition_Clause => 608,\n-            N_Compilation_Unit_Aux => 599,\n-            N_Compilation_Unit => 599,\n-            N_Label => 572,\n-            N_Goto_Statement => 572,\n-            N_In => 564,\n-            N_Enumeration_Type_Definition => 523,\n-            N_Object_Renaming_Declaration => 482,\n-            N_If_Expression => 476,\n-            N_Exception_Declaration => 472,\n-            N_Reference => 455,\n-            N_Incomplete_Type_Declaration => 438,\n-            N_Use_Package_Clause => 401,\n-            N_Unconstrained_Array_Definition => 360,\n-            N_Variant_Part => 340,\n-            N_Defining_Program_Unit_Name => 336,\n-            N_Op_And => 334,\n-            N_Raise_Program_Error => 329,\n-            N_Formal_Discrete_Type_Definition => 319,\n-            N_Contract => 311,\n-            N_Not_In => 305,\n-            N_Designator => 285,\n-            N_Component_Clause => 247,\n-            N_Formal_Signed_Integer_Type_Definition => 244,\n-            N_Raise_Statement => 214,\n-            N_Op_Expon => 205,\n-            N_Op_Minus => 202,\n-            N_Op_Multiply => 158,\n-            N_Exit_Statement => 130,\n-            N_Function_Instantiation => 129,\n-            N_Discriminant_Association => 123,\n-            N_Private_Extension_Declaration => 119,\n-            N_Extended_Return_Statement => 117,\n-            N_Op_Divide => 107,\n-            N_Op_Or => 103,\n-            N_Signed_Integer_Type_Definition => 101,\n-            N_Record_Representation_Clause => 76,\n-            N_Unchecked_Expression => 70,\n-            N_Op_Abs => 63,\n-            N_Elsif_Part => 62,\n-            N_Formal_Floating_Point_Definition => 59,\n-            N_Formal_Package_Declaration => 58,\n-            N_Modular_Type_Definition => 55,\n-            N_Abstract_Subprogram_Declaration => 52,\n-            N_Validate_Unchecked_Conversion => 49,\n-            N_Defining_Character_Literal => 36,\n-            N_Raise_Storage_Error => 33,\n-            N_Compound_Statement => 29,\n-            N_Procedure_Instantiation => 28,\n-            N_Access_Procedure_Definition => 25,\n-            N_Floating_Point_Definition => 20,\n-            N_Use_Type_Clause => 19,\n-            N_Op_Plus => 14,\n-            N_Package_Body => 13,\n-            N_Op_Rem => 13,\n-            N_Enumeration_Representation_Clause => 13,\n-            N_Access_Function_Definition => 11,\n-            N_Extension_Aggregate => 11,\n-            N_Formal_Ordinary_Fixed_Point_Definition => 10,\n-            N_Op_Mod => 10,\n-            N_Expression_Function => 9,\n-            N_Delay_Relative_Statement => 9,\n-            N_Quantified_Expression => 7,\n-            N_Formal_Derived_Type_Definition => 7,\n-            N_Free_Statement => 7,\n-            N_Iterator_Specification => 5,\n-            N_Op_Shift_Left => 5,\n-            N_Formal_Modular_Type_Definition => 4,\n-            N_Generic_Package_Renaming_Declaration => 1,\n-            N_Empty => 1,\n-            N_Real_Range_Specification => 1,\n-            N_Ordinary_Fixed_Point_Definition => 1,\n-            N_Op_Shift_Right => 1,\n-            N_Error => 1,\n-            N_Mod_Clause => 1,\n-            others => 0);\n-\n-         Total_Node_Count : constant Long_Float := 1370676.0;\n-\n-         type Node_Frequency_Table is array (Concrete_Node) of Long_Float;\n-\n-         function Init_Node_Frequency return Node_Frequency_Table;\n-         --  Compute the value of the Node_Frequency table\n-\n-         function Average_Type_Size_In_Slots return Long_Float;\n-         --  Compute the average over all concrete node types of the size,\n-         --  weighted by the frequency of that node type.\n-\n-         function Init_Node_Frequency return Node_Frequency_Table is\n-            Result : Node_Frequency_Table := (others => 0.0);\n-\n-         begin\n-            for T in Concrete_Node loop\n-               Result (T) := Long_Float (Node_Counts (T)) / Total_Node_Count;\n-            end loop;\n-\n-            return Result;\n-         end Init_Node_Frequency;\n-\n-         Node_Frequency : constant Node_Frequency_Table := Init_Node_Frequency;\n-         --  Table mapping concrete node types to the relative frequency of\n-         --  that node, in our large example. The sum of these values should\n-         --  add up to approximately 1.0. For example, if Node_Frequency(K) =\n-         --  0.02, then that means that approximately 2% of all nodes are K\n-         --  nodes.\n-\n-         function Average_Type_Size_In_Slots return Long_Float is\n-            --  We don't have data on entities, so we leave those out\n-\n-            Result : Long_Float := 0.0;\n-         begin\n-            for T in Concrete_Node loop\n-               Result := Result +\n-                 Node_Frequency (T) * Long_Float (Type_Size_In_Slots (T));\n-            end loop;\n-\n-            return Result;\n-         end Average_Type_Size_In_Slots;\n-\n-      --  Start of processing for Compute_Type_Sizes\n-\n       begin\n          for T in Concrete_Type loop\n             declare\n@@ -1351,8 +1135,6 @@ package body Gen_IL.Gen is\n          Max_Node_Size := To_Size_In_Slots (Max_Node_Bit_Size);\n          Min_Entity_Size := To_Size_In_Slots (Min_Entity_Bit_Size);\n          Max_Entity_Size := To_Size_In_Slots (Max_Entity_Bit_Size);\n-\n-         Average_Node_Size_In_Slots := Average_Type_Size_In_Slots;\n       end Compute_Type_Sizes;\n \n       ----------------------------------------\n@@ -1573,7 +1355,7 @@ package body Gen_IL.Gen is\n          case Root is\n             when Node_Kind =>\n                Put_Getter_Decl (S, Nkind);\n-               Put (S, \"function K (N : Node_Id) return Node_Kind renames Nkind;\" & LF);\n+               Put (S, \"function K (N : Node_Id) return Node_Kind renames \" & Image (Nkind) & \";\" & LF);\n                Put (S, \"--  Shorthand for use in predicates and preconditions below\" & LF);\n                Put (S, \"--  There is no procedure Set_Nkind.\" & LF);\n                Put (S, \"--  See Init_Nkind and Mutate_Nkind in Atree.\" & LF & LF);\n@@ -1767,7 +1549,6 @@ package body Gen_IL.Gen is\n          Put (S, \" with \" & Inline);\n          Increase_Indent (S, 2);\n          Put_Precondition (S, F);\n-\n          Decrease_Indent (S, 2);\n          Put (S, \";\" & LF);\n       end Put_Getter_Decl;\n@@ -1781,8 +1562,8 @@ package body Gen_IL.Gen is\n       is\n          Rec : Field_Info renames Field_Table (F).all;\n \n-         Off : constant Field_Offset := Rec.Offset;\n          F_Size : constant Bit_Offset := Field_Size (Rec.Field_Type);\n+         Off : constant Field_Offset := Rec.Offset;\n          F_Per_Slot : constant Field_Offset :=\n            SS / Field_Offset (Field_Size (Rec.Field_Type));\n          Slot_Off : constant Field_Offset := Off / F_Per_Slot;\n@@ -2215,8 +1996,7 @@ package body Gen_IL.Gen is\n                     Image (Min_Node_Size) & \";\" & LF);\n                Put (S, \"Max_Node_Size : constant Field_Offset := \" &\n                     Image (Max_Node_Size) & \";\" & LF & LF);\n-               Put (S, \"Average_Node_Size_In_Slots : constant := \" &\n-                    Average_Node_Size_In_Slots'Img & \";\" & LF & LF);\n+\n             when Entity_Kind =>\n                Put (S, LF & \"Min_Entity_Size : constant Field_Offset := \" &\n                     Image (Min_Entity_Size) & \";\" & LF);\n@@ -2468,22 +2248,16 @@ package body Gen_IL.Gen is\n          Put (S, \"Kind : Field_Kind;\" & LF);\n          Put (S, \"Offset : Field_Offset;\" & LF);\n          Decrease_Indent (S, 3);\n-         Put (S, \"end record;\" & LF);\n+         Put (S, \"end record;\" & LF & LF);\n \n          --  Print out the node header types. Note that the Offset field is of\n          --  the base type, because we are using zero-origin addressing in\n          --  Atree.\n \n-         Put (S, \"\" & LF);\n-         Put (S, \"N_Head : constant Field_Offset := \" & N_Head & \";\" & LF);\n-         Put (S, \"type Node_Header_Slots is\" & LF);\n-         Put (S, \"  array (Field_Offset range 0 .. N_Head - 1) of aliased Slot;\" & LF);\n-         Put (S, \"type Node_Header is record\" & LF);\n-         Put (S, \"   Slots : Node_Header_Slots;\" & LF);\n-         Put (S, \"   Offset : Node_Offset'Base;\" & LF);\n-         Put (S, \"end record;\" & LF);\n-         Put (S, \"pragma Assert (Node_Header'Size = (\" & N_Head &\n-                \" + 1) * \" & SSS & \");\" & LF);\n+         Put (S, \"N_Head : constant Field_Offset := \" & N_Head & \";\" & LF & LF);\n+\n+         Put (S, \"Atree_Statistics_Enabled : constant Boolean := \" &\n+                Capitalize (Boolean'Image (Statistics_Enabled)) & \";\" & LF);\n \n          Decrease_Indent (S, 3);\n          Put (S, LF & \"end Seinfo;\" & LF);"}, {"sha": "fe1af78ca1221a64a04f7819f7c4a81fa4de288a", "filename": "gcc/ada/gen_il-internals.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-internals.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-internals.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -255,7 +255,7 @@ package body Gen_IL.Internals is\n    begin\n       case F is\n          --  Special cases for the same reason as in the above Image\n-         --  function.\n+         --  function for Opt_Type_Enum.\n \n          when Alloc_For_BIP_Return =>\n             return \"Alloc_For_BIP_Return\";"}, {"sha": "a811e0b410081793253cfe9c6c2013fe1ec21e85", "filename": "gcc/ada/gen_il-internals.ads", "status": "modified", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-internals.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fgen_il-internals.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-internals.ads?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -277,4 +277,344 @@ package Gen_IL.Internals is\n    --  Return \"Node\" or \"Entity\" depending on whether Root = Node_Kind or\n    --  Entity_Kind.\n \n+   pragma Style_Checks (Off);\n+   --  We don't want warnings about wrong casing in the Type_Frequency table;\n+   --  this table is not intended to be particularly readable.\n+\n+   --  The Type_Frequency table shows the frequency of nodes and entity kinds\n+   --  printed by -gnatd.A for a large example. It is used in the field offset\n+   --  computations for efficiency. Note that N_Defining_Identifier,\n+   --  N_Defining_Operator_Symbol, and N_Defining_Character_Literal are set to\n+   --  zero, because the Ekind is what matters for those.\n+\n+   Type_Frequency : constant array (Concrete_Type) of Type_Count :=\n+     (N_Identifier => 3496964, -- (0.354) 7 slots\n+      N_Defining_Identifier => 0, -- 1468484, -- (0.149) 8 slots\n+      N_Integer_Literal => 455415, -- (0.046) 6 slots\n+      E_In_Parameter => 391008, -- (0.040) 42 slots\n+      N_Attribute_Reference => 330825, -- (0.033) 9 slots\n+      N_Expanded_Name => 329509, -- (0.033) 8 slots\n+      N_Selected_Component => 328862, -- (0.033) 8 slots\n+      N_Parameter_Specification => 321313, -- (0.033) 7 slots\n+      E_Void => 173019, -- (0.018) 59 slots\n+      N_Explicit_Dereference => 155113, -- (0.016) 8 slots\n+      N_Procedure_Call_Statement => 125403, -- (0.013) 8 slots\n+      N_Object_Declaration => 115610, -- (0.012) 8 slots\n+      E_Component => 108208, -- (0.011) 49 slots\n+      N_Procedure_Specification => 106277, -- (0.011) 7 slots\n+      E_Procedure => 104063, -- (0.011) 62 slots\n+      N_Unchecked_Type_Conversion => 94477, -- (0.010) 7 slots\n+      N_Range => 91413, -- (0.009) 6 slots\n+      E_Function => 90035, -- (0.009) 62 slots\n+      N_Handled_Sequence_Of_Statements => 87930, -- (0.009) 8 slots\n+      N_Subprogram_Declaration => 85248, -- (0.009) 7 slots\n+      N_Parameter_Association => 81464, -- (0.008) 8 slots\n+      N_Indexed_Component => 80049, -- (0.008) 7 slots\n+      N_Freeze_Entity => 79904, -- (0.008) 8 slots\n+      N_Call_Marker => 79521, -- (0.008) 4 slots\n+      N_Assignment_Statement => 76554, -- (0.008) 8 slots\n+      N_Function_Specification => 76052, -- (0.008) 7 slots\n+      N_Function_Call => 75028, -- (0.008) 9 slots\n+      N_Op_Eq => 74874, -- (0.008) 8 slots\n+      E_Constant => 66667, -- (0.007) 47 slots\n+      N_If_Statement => 60066, -- (0.006) 8 slots\n+      N_Component_Association => 54642, -- (0.006) 7 slots\n+      N_Subprogram_Body => 53805, -- (0.005) 10 slots\n+      N_Type_Conversion => 53383, -- (0.005) 7 slots\n+      E_In_Out_Parameter => 52936, -- (0.005) 38 slots\n+      N_Simple_Return_Statement => 52436, -- (0.005) 7 slots\n+      N_Subtype_Indication => 49535, -- (0.005) 6 slots\n+      N_Raise_Constraint_Error => 49069, -- (0.005) 6 slots\n+      N_Null => 46850, -- (0.005) 5 slots\n+      N_Itype_Reference => 45422, -- (0.005) 4 slots\n+      E_Anonymous_Access_Type => 45149, -- (0.005) 44 slots\n+      N_And_Then => 44721, -- (0.005) 8 slots\n+      N_Block_Statement => 44328, -- (0.004) 10 slots\n+      N_Subtype_Declaration => 43149, -- (0.004) 6 slots\n+      N_Op_Not => 40531, -- (0.004) 7 slots\n+      E_Array_Subtype => 40051, -- (0.004) 50 slots\n+      N_Expression_With_Actions => 36726, -- (0.004) 7 slots\n+      E_Access_Subprogram_Type => 36700, -- (0.004) 45 slots\n+      E_Signed_Integer_Subtype => 36659, -- (0.004) 43 slots\n+      N_String_Literal => 34815, -- (0.004) 7 slots\n+      N_Aggregate => 33899, -- (0.003) 8 slots\n+      N_Index_Or_Discriminant_Constraint => 33546, -- (0.003) 4 slots\n+      E_Variable => 33102, -- (0.003) 55 slots\n+      E_Block => 32829, -- (0.003) 58 slots\n+      N_Op_Ne => 32127, -- (0.003) 8 slots\n+      N_Pragma_Argument_Association => 31504, -- (0.003) 7 slots\n+      N_Null_Statement => 30816, -- (0.003) 5 slots\n+      N_Aspect_Specification => 29667, -- (0.003) 9 slots\n+      N_Pragma => 28317, -- (0.003) 9 slots\n+      N_Generic_Association => 26297, -- (0.003) 8 slots\n+      N_Formal_Concrete_Subprogram_Declaration => 25843, -- (0.003) 6 slots\n+      N_Op_Lt => 25328, -- (0.003) 8 slots\n+      E_String_Literal_Subtype => 25272, -- (0.003) 48 slots\n+      N_Full_Type_Declaration => 25258, -- (0.003) 7 slots\n+      N_With_Clause => 24370, -- (0.002) 9 slots\n+      N_Op_Add => 23839, -- (0.002) 8 slots\n+      E_Subprogram_Body => 23790, -- (0.002) 42 slots\n+      E_Return_Statement => 23098, -- (0.002) 51 slots\n+      N_Or_Else => 22858, -- (0.002) 8 slots\n+      N_Implicit_Label_Declaration => 21687, -- (0.002) 5 slots\n+      N_Others_Choice => 21579, -- (0.002) 4 slots\n+      E_Out_Parameter => 21513, -- (0.002) 38 slots\n+      N_Op_Subtract => 21441, -- (0.002) 8 slots\n+      N_Op_Ge => 21116, -- (0.002) 8 slots\n+      N_Component_Definition => 21075, -- (0.002) 7 slots\n+      N_Case_Statement_Alternative => 19664, -- (0.002) 8 slots\n+      N_Loop_Statement => 19507, -- (0.002) 9 slots\n+      E_Package => 19029, -- (0.002) 53 slots\n+      N_Op_Gt => 18619, -- (0.002) 8 slots\n+      N_Op_Le => 16564, -- (0.002) 8 slots\n+      N_Formal_Object_Declaration => 16219, -- (0.002) 7 slots\n+      E_Discriminant => 16091, -- (0.002) 56 slots\n+      N_Component_Declaration => 15858, -- (0.002) 7 slots\n+      N_Iteration_Scheme => 15719, -- (0.002) 8 slots\n+      N_Access_To_Object_Definition => 14875, -- (0.002) 5 slots\n+      E_Record_Subtype => 14569, -- (0.001) 52 slots\n+      N_Generic_Subprogram_Declaration => 14320, -- (0.001) 7 slots\n+      N_Package_Specification => 13323, -- (0.001) 8 slots\n+      N_Exception_Handler => 12841, -- (0.001) 8 slots\n+      E_Enumeration_Literal => 11608, -- (0.001) 42 slots\n+      N_Subprogram_Renaming_Declaration => 10991, -- (0.001) 9 slots\n+      N_In => 10794, -- (0.001) 8 slots\n+      E_Allocator_Type => 10751, -- (0.001) 44 slots\n+      E_General_Access_Type => 10451, -- (0.001) 44 slots\n+      E_Generic_Procedure => 9837, -- (0.001) 41 slots\n+      N_Package_Renaming_Declaration => 9395, -- (0.001) 8 slots\n+      N_Access_Definition => 9388, -- (0.001) 6 slots\n+      N_Qualified_Expression => 9012, -- (0.001) 7 slots\n+      E_Enumeration_Subtype => 8560, -- (0.001) 46 slots\n+      N_Allocator => 8474, -- (0.001) 8 slots\n+      N_Package_Declaration => 8099, -- (0.001) 10 slots\n+      N_Formal_Type_Declaration => 7964, -- (0.001) 7 slots\n+      N_Exit_Statement => 7960, -- (0.001) 8 slots\n+      N_Component_List => 7829, -- (0.001) 5 slots\n+      N_Defining_Operator_Symbol => 0, -- 7525, -- (0.001) 8 slots\n+      N_Case_Statement => 7271, -- (0.001) 7 slots\n+      N_Expression_Function => 7242, -- (0.001) 9 slots\n+      N_Loop_Parameter_Specification => 7042, -- (0.001) 7 slots\n+      N_Character_Literal => 6842, -- (0.001) 7 slots\n+      N_Op_Concat => 6565, -- (0.001) 8 slots\n+      N_Not_In => 6341, -- (0.001) 8 slots\n+      N_Label => 6133, -- (0.001) 9 slots\n+      N_Goto_Statement => 6133, -- (0.001) 8 slots\n+      E_Label => 6133, -- (0.001) 57 slots\n+      E_Loop => 6008, -- (0.001) 41 slots\n+      N_Generic_Package_Declaration => 5808, -- (0.001) 10 slots\n+      N_If_Expression => 5800, -- (0.001) 7 slots\n+      N_Record_Definition => 5628, -- (0.001) 7 slots\n+      N_Slice => 5461, -- (0.001) 7 slots\n+      N_Reference => 5332, -- (0.001) 7 slots\n+      E_Generic_Package => 5268, -- (0.001) 59 slots\n+      E_Record_Type => 4838, -- (0.000) 51 slots\n+      N_Raise_Program_Error => 4675, -- (0.000) 6 slots\n+      N_Raise_Statement => 4628, -- (0.000) 8 slots\n+      N_Use_Type_Clause => 4487, -- (0.000) 9 slots\n+      E_Array_Type => 4325, -- (0.000) 48 slots\n+      E_Operator => 4308, -- (0.000) 55 slots\n+      N_Freeze_Generic_Entity => 4249, -- (0.000) 4 slots\n+      N_Constrained_Array_Definition => 4244, -- (0.000) 5 slots\n+      N_Object_Renaming_Declaration => 4067, -- (0.000) 8 slots\n+      N_Formal_Private_Type_Definition => 4018, -- (0.000) 8 slots\n+      E_Loop_Parameter => 3870, -- (0.000) 38 slots\n+      N_Real_Literal => 3759, -- (0.000) 7 slots\n+      N_Attribute_Definition_Clause => 3724, -- (0.000) 8 slots\n+      N_Exception_Renaming_Declaration => 3697, -- (0.000) 8 slots\n+      E_Class_Wide_Type => 3674, -- (0.000) 48 slots\n+      E_Exception => 3632, -- (0.000) 24 slots\n+      N_Range_Constraint => 3506, -- (0.000) 4 slots\n+      E_Access_Type => 3487, -- (0.000) 44 slots\n+      E_Subprogram_Type => 3248, -- (0.000) 47 slots\n+      N_Package_Instantiation => 3005, -- (0.000) 8 slots\n+      E_Access_Attribute_Type => 2959, -- (0.000) 44 slots\n+      N_Op_And => 2957, -- (0.000) 8 slots\n+      E_Generic_In_Parameter => 2704, -- (0.000) 31 slots\n+      N_Derived_Type_Definition => 2688, -- (0.000) 7 slots\n+      N_Variant => 2535, -- (0.000) 8 slots\n+      E_Record_Subtype_With_Private => 2327, -- (0.000) 50 slots\n+      N_Private_Type_Declaration => 2287, -- (0.000) 6 slots\n+      E_Private_Type => 1890, -- (0.000) 48 slots\n+      N_Discriminant_Specification => 1864, -- (0.000) 7 slots\n+      N_Procedure_Instantiation => 1659, -- (0.000) 8 slots\n+      N_Op_Multiply => 1634, -- (0.000) 8 slots\n+      E_Access_Subtype => 1606, -- (0.000) 44 slots\n+      N_Defining_Program_Unit_Name => 1463, -- (0.000) 8 slots\n+      N_Number_Declaration => 1461, -- (0.000) 7 slots\n+      E_Named_Integer => 1430, -- (0.000) 19 slots\n+      N_Use_Package_Clause => 1369, -- (0.000) 9 slots\n+      N_Compilation_Unit_Aux => 1341, -- (0.000) 8 slots\n+      N_Compilation_Unit => 1341, -- (0.000) 8 slots\n+      N_Elsif_Part => 1331, -- (0.000) 7 slots\n+      N_Operator_Symbol => 1305, -- (0.000) 7 slots\n+      E_Limited_Private_Type => 1299, -- (0.000) 48 slots\n+      E_Generic_Function => 1292, -- (0.000) 41 slots\n+      E_Enumeration_Type => 1186, -- (0.000) 47 slots\n+      N_Enumeration_Type_Definition => 1169, -- (0.000) 6 slots\n+      N_Unchecked_Expression => 1112, -- (0.000) 7 slots\n+      N_Op_Or => 1107, -- (0.000) 8 slots\n+      N_Designator => 1100, -- (0.000) 9 slots\n+      N_Formal_Discrete_Type_Definition => 1086, -- (0.000) 4 slots\n+      N_Variant_Part => 1072, -- (0.000) 8 slots\n+      N_Formal_Package_Declaration => 1047, -- (0.000) 8 slots\n+      N_Quantified_Expression => 1033, -- (0.000) 8 slots\n+      E_Record_Type_With_Private => 1017, -- (0.000) 51 slots\n+      N_Package_Body => 999, -- (0.000) 9 slots\n+      N_Unconstrained_Array_Definition => 973, -- (0.000) 5 slots\n+      E_Private_Subtype => 971, -- (0.000) 48 slots\n+      N_Incomplete_Type_Declaration => 863, -- (0.000) 6 slots\n+      E_Incomplete_Type => 863, -- (0.000) 48 slots\n+      N_Contract => 859, -- (0.000) 6 slots\n+      E_Package_Body => 852, -- (0.000) 46 slots\n+      N_Extended_Return_Statement => 801, -- (0.000) 8 slots\n+      N_Op_Divide => 724, -- (0.000) 8 slots\n+      N_Extension_Aggregate => 718, -- (0.000) 8 slots\n+      N_Function_Instantiation => 642, -- (0.000) 8 slots\n+      N_Exception_Declaration => 594, -- (0.000) 7 slots\n+      N_Discriminant_Association => 552, -- (0.000) 7 slots\n+      N_Iterator_Specification => 543, -- (0.000) 8 slots\n+      N_Private_Extension_Declaration => 540, -- (0.000) 8 slots\n+      N_Formal_Signed_Integer_Type_Definition => 512, -- (0.000) 4 slots\n+      E_Modular_Integer_Subtype => 490, -- (0.000) 44 slots\n+      N_Component_Clause => 468, -- (0.000) 7 slots\n+      E_Signed_Integer_Type => 399, -- (0.000) 43 slots\n+      N_Op_Minus => 356, -- (0.000) 7 slots\n+      N_Raise_Expression => 337, -- (0.000) 8 slots\n+      N_Case_Expression_Alternative => 336, -- (0.000) 8 slots\n+      N_Op_Expon => 280, -- (0.000) 8 slots\n+      N_Abstract_Subprogram_Declaration => 250, -- (0.000) 6 slots\n+      E_Modular_Integer_Type => 232, -- (0.000) 44 slots\n+      N_Modular_Type_Definition => 214, -- (0.000) 7 slots\n+      N_Compound_Statement => 212, -- (0.000) 6 slots\n+      N_Free_Statement => 209, -- (0.000) 8 slots\n+      N_Record_Representation_Clause => 197, -- (0.000) 9 slots\n+      N_Access_Procedure_Definition => 195, -- (0.000) 6 slots\n+      E_Limited_Private_Subtype => 178, -- (0.000) 48 slots\n+      N_Access_Function_Definition => 172, -- (0.000) 7 slots\n+      N_Op_Mod => 163, -- (0.000) 8 slots\n+      N_Validate_Unchecked_Conversion => 156, -- (0.000) 5 slots\n+      E_Anonymous_Access_Subprogram_Type => 155, -- (0.000) 44 slots\n+      N_Op_Rem => 147, -- (0.000) 8 slots\n+      N_Formal_Incomplete_Type_Definition => 140, -- (0.000) 4 slots\n+      N_Signed_Integer_Type_Definition => 137, -- (0.000) 6 slots\n+      N_Case_Expression => 132, -- (0.000) 7 slots\n+      N_Op_Plus => 129, -- (0.000) 7 slots\n+      E_Incomplete_Subtype => 129, -- (0.000) 48 slots\n+      N_Op_Abs => 119, -- (0.000) 7 slots\n+      N_Op_Shift_Right => 109, -- (0.000) 8 slots\n+      E_Floating_Point_Subtype => 94, -- (0.000) 43 slots\n+      N_Op_Shift_Left => 72, -- (0.000) 8 slots\n+      E_Floating_Point_Type => 59, -- (0.000) 43 slots\n+      N_Formal_Derived_Type_Definition => 53, -- (0.000) 7 slots\n+      N_Formal_Floating_Point_Definition => 40, -- (0.000) 4 slots\n+      N_Defining_Character_Literal => 0, -- 36, -- (0.000) 8 slots\n+      N_Formal_Modular_Type_Definition => 27, -- (0.000) 4 slots\n+      E_Ordinary_Fixed_Point_Subtype => 23, -- (0.000) 44 slots\n+      E_Abstract_State => 22, -- (0.000) 48 slots\n+      E_Named_Real => 20, -- (0.000) 19 slots\n+      N_Floating_Point_Definition => 19, -- (0.000) 6 slots\n+      N_Subunit => 17, -- (0.000) 8 slots\n+      N_Enumeration_Representation_Clause => 17, -- (0.000) 9 slots\n+      N_Entry_Declaration => 17, -- (0.000) 7 slots\n+      N_Subprogram_Body_Stub => 16, -- (0.000) 8 slots\n+      N_Unused_At_Start => 15, -- (0.000) 4 slots\n+      E_Entry => 14, -- (0.000) 42 slots\n+      N_Formal_Ordinary_Fixed_Point_Definition => 12, -- (0.000) 4 slots\n+      E_Class_Wide_Subtype => 9, -- (0.000) 52 slots\n+      E_Protected_Subtype => 8, -- (0.000) 48 slots\n+      E_Ordinary_Fixed_Point_Type => 8, -- (0.000) 44 slots\n+      N_Op_Xor => 7, -- (0.000) 8 slots\n+      E_Generic_In_Out_Parameter => 7, -- (0.000) 31 slots\n+      N_Protected_Type_Declaration => 6, -- (0.000) 8 slots\n+      N_Protected_Definition => 6, -- (0.000) 8 slots\n+      N_Task_Type_Declaration => 4, -- (0.000) 8 slots\n+      N_Task_Definition => 4, -- (0.000) 8 slots\n+      N_Protected_Body => 4, -- (0.000) 9 slots\n+      E_Task_Subtype => 4, -- (0.000) 50 slots\n+      E_Protected_Type => 4, -- (0.000) 49 slots\n+      E_Access_Protected_Subprogram_Type => 4, -- (0.000) 45 slots\n+      N_Entry_Call_Statement => 3, -- (0.000) 8 slots\n+      E_Task_Type => 3, -- (0.000) 50 slots\n+      N_Raise_Storage_Error => 2, -- (0.000) 6 slots\n+      N_Package_Body_Stub => 2, -- (0.000) 8 slots\n+      N_Generic_Procedure_Renaming_Declaration => 2, -- (0.000) 8 slots\n+      N_Task_Body => 1, -- (0.000) 10 slots\n+      N_Single_Protected_Declaration => 1, -- (0.000) 8 slots\n+      N_Real_Range_Specification => 1, -- (0.000) 6 slots\n+      N_Ordinary_Fixed_Point_Definition => 1, -- (0.000) 6 slots\n+      N_Error => 1, -- (0.000) 6 slots\n+      N_Entry_Body_Formal_Part => 1, -- (0.000) 6 slots\n+      N_Entry_Body => 1, -- (0.000) 10 slots\n+      N_Empty => 1, -- (0.000) 6 slots\n+      N_Delay_Relative_Statement => 1, -- (0.000) 7 slots\n+      E_Protected_Body => 1, -- (0.000) 35 slots\n+\n+      Between_Concrete_Node_And_Concrete_Entity_Types => 0,\n+\n+      --  The rest had frequency 0 (i.e. no such nodes were created in the\n+      --  example), but we set them to 1, so we won't lose information when\n+      --  multiplying. We use \"others\", so that if new node types are added,\n+      --  we don't have to modify the table; new node types are unlikely to\n+      --  be very common.\n+\n+      others => 1\n+      --  N_Variable_Reference_Marker => 0, (0.000) 4 slots\n+      --  N_Unused_At_End => 0, (0.000) 4 slots\n+      --  N_Triggering_Alternative => 0, (0.000) 6 slots\n+      --  N_Timed_Entry_Call => 0, (0.000) 5 slots\n+      --  N_Terminate_Alternative => 0, (0.000) 6 slots\n+      --  N_Task_Body_Stub => 0, (0.000) 8 slots\n+      --  N_Target_Name => 0, (0.000) 5 slots\n+      --  N_Single_Task_Declaration => 0, (0.000) 8 slots\n+      --  N_Selective_Accept => 0, (0.000) 5 slots\n+      --  N_Scil_Membership_Test => 0, (0.000) 5 slots\n+      --  N_Scil_Dispatch_Table_Tag_Init => 0, (0.000) 4 slots\n+      --  N_Scil_Dispatching_Call => 0, (0.000) 6 slots\n+      --  N_Return_When_Statement => 0, (0.000) 7 slots\n+      --  N_Requeue_Statement => 0, (0.000) 8 slots\n+      --  N_Raise_When_Statement => 0, (0.000) 8 slots\n+      --  N_Push_Storage_Error_Label => 0, (0.000) 4 slots\n+      --  N_Push_Program_Error_Label => 0, (0.000) 4 slots\n+      --  N_Push_Constraint_Error_Label => 0, (0.000) 4 slots\n+      --  N_Protected_Body_Stub => 0, (0.000) 8 slots\n+      --  N_Pop_Storage_Error_Label => 0, (0.000) 4 slots\n+      --  N_Pop_Program_Error_Label => 0, (0.000) 4 slots\n+      --  N_Pop_Constraint_Error_Label => 0, (0.000) 4 slots\n+      --  N_Op_Shift_Right_Arithmetic => 0, (0.000) 8 slots\n+      --  N_Op_Rotate_Right => 0, (0.000) 8 slots\n+      --  N_Op_Rotate_Left => 0, (0.000) 8 slots\n+      --  N_Mod_Clause => 0, (0.000) 7 slots\n+      --  N_Iterated_Element_Association => 0, (0.000) 8 slots\n+      --  N_Iterated_Component_Association => 0, (0.000) 8 slots\n+      --  N_Goto_When_Statement => 0, (0.000) 8 slots\n+      --  N_Generic_Package_Renaming_Declaration => 0, (0.000) 8 slots\n+      --  N_Generic_Function_Renaming_Declaration => 0, (0.000) 8 slots\n+      --  N_Formal_Decimal_Fixed_Point_Definition => 0, (0.000) 4 slots\n+      --  N_Formal_Abstract_Subprogram_Declaration => 0, (0.000) 6 slots\n+      --  N_Entry_Index_Specification => 0, (0.000) 7 slots\n+      --  N_Entry_Call_Alternative => 0, (0.000) 6 slots\n+      --  N_Digits_Constraint => 0, (0.000) 6 slots\n+      --  N_Delta_Constraint => 0, (0.000) 6 slots\n+      --  N_Delta_Aggregate => 0, (0.000) 8 slots\n+      --  N_Delay_Until_Statement => 0, (0.000) 7 slots\n+      --  N_Delay_Alternative => 0, (0.000) 7 slots\n+      --  N_Decimal_Fixed_Point_Definition => 0, (0.000) 6 slots\n+      --  N_Conditional_Entry_Call => 0, (0.000) 5 slots\n+      --  N_Code_Statement => 0, (0.000) 7 slots\n+      --  N_At_Clause => 0, (0.000) 9 slots\n+      --  N_Asynchronous_Select => 0, (0.000) 5 slots\n+      --  N_Accept_Statement => 0, (0.000) 8 slots\n+      --  N_Accept_Alternative => 0, (0.000) 8 slots\n+      --  N_Abort_Statement => 0, (0.000) 4 slots\n+      --  N_Abortable_Part => 0, (0.000) 5 slots\n+      --  E_Task_Body => 0, (0.000) 39 slots\n+      --  E_Exception_Type => 0, (0.000) 45 slots\n+      --  E_Entry_Index_Parameter => 0, (0.000) 19 slots\n+      --  E_Entry_Family => 0, (0.000) 42 slots\n+      --  E_Decimal_Fixed_Point_Type => 0, (0.000) 52 slots\n+      --  E_Decimal_Fixed_Point_Subtype => 0, (0.000) 52 slots\n+      --  E_Anonymous_Access_Protected_Subprogram_Type => 0, (0.000) 45 slots\n+     ); -- Type_Frequency\n+\n end Gen_IL.Internals;"}, {"sha": "5fe13532de8e5baab82da26b6875e0350987ca33", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -23,14 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Errout;         use Errout;\n-with Sinfo;          use Sinfo;\n-with Sinfo.Nodes;    use Sinfo.Nodes;\n-with Fname.UF;       use Fname.UF;\n-with Lib;            use Lib;\n-with Namet;          use Namet;\n-with Opt;            use Opt;\n-with Uname;          use Uname;\n+with Errout;      use Errout;\n+with Sinfo;       use Sinfo;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n+with Fname.UF;    use Fname.UF;\n+with Lib;         use Lib;\n+with Namet;       use Namet;\n+with Opt;         use Opt;\n+with Uname;       use Uname;\n \n --  Note: this package body is used by GNAT Studio and GNATBench to supply a\n --  list of entries for help on available library routines."}, {"sha": "cf0ecc10eff6f97ecf7665d65063091c97bd942a", "filename": "gcc/ada/sinfo-utils.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fsinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Fsinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.adb?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;\n+with Atree;  use Atree;\n with Debug;  use Debug;\n with Output; use Output;\n with Seinfo;"}, {"sha": "e934c27a5043137eef655f3dc475abca2363dc5b", "filename": "gcc/ada/table.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -102,7 +102,7 @@ package Table is\n       --  mode parameters with scalar values.\n \n       type Table_Type is\n-        array (Table_Index_Type range <>) of aliased Table_Component_Type;\n+        array (Table_Index_Type range <>) of Table_Component_Type;\n \n       subtype Big_Table_Type is\n         Table_Type (Table_Low_Bound .. Table_Index_Type'Last);"}, {"sha": "673f7c6d628c19b7e73f9378289c0b94a49280e2", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f561db7ca1fba70a90c3ff9f7682b7841585258/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=3f561db7ca1fba70a90c3ff9f7682b7841585258", "patch": "@@ -1014,8 +1014,4 @@ package Types is\n    type Offset_Array is\n      array (Offset_Array_Index range <>) of Opt_Field_Offset;\n \n-   Slot_Size : constant := 32;\n-   type Slot is mod 2**Slot_Size;\n-   for Slot'Size use Slot_Size;\n-\n end Types;"}]}