{"sha": "e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "node_id": "C_kwDOANBUbNoAKGU0OWRkMjJmYzIzM2YzYjdiN2RjY2E0YmQxYmEyZTdlYTZkZWE3MWM", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-10T15:52:37Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-02-10T15:52:37Z"}, "message": "Remove unsued functions in the GCC wrapper", "tree": {"sha": "865177df733ea597f487d7728f21e117b0966bdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/865177df733ea597f487d7728f21e117b0966bdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "859732e4d167dfe83b29cebc757f21ba2c342f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/859732e4d167dfe83b29cebc757f21ba2c342f33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/859732e4d167dfe83b29cebc757f21ba2c342f33"}], "stats": {"total": 334, "additions": 0, "deletions": 334}, "files": [{"sha": "ca4157580bcfe2307b3a432d990c25e8fdcddca5", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "patch": "@@ -491,119 +491,6 @@ class Backend\n \t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n \n-  // Create an implicit variable that is compiler-defined.  This is\n-  // used when generating GC data and roots, when storing the values\n-  // of a slice constructor, and for the zero value of types.  This returns a\n-  // Bvariable because it corresponds to an initialized variable in C.\n-  //\n-  // NAME is the name to use for the initialized variable this will create.\n-  //\n-  // ASM_NAME is encoded assembler-friendly version of the name, or the\n-  // empty string if no encoding is needed.\n-  //\n-  // TYPE is the type of the implicit variable.\n-  //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_CONSTANT is true if the implicit variable should be treated like it is\n-  // immutable.  For slice initializers, if the values must be copied to the\n-  // heap, the variable IS_CONSTANT.\n-  //\n-  // IS_COMMON is true if the implicit variable should\n-  // be treated as a common variable (multiple definitions with\n-  // different sizes permitted in different object files, all merged\n-  // into the largest definition at link time); this will be true for\n-  // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n-  //\n-  // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable *implicit_variable (const std::string &name,\n-\t\t\t\t\tconst std::string &asm_name, tree type,\n-\t\t\t\t\tbool is_hidden, bool is_constant,\n-\t\t\t\t\tbool is_common, int64_t alignment)\n-    = 0;\n-\n-  // Set the initial value of a variable created by implicit_variable.\n-  // This must be called even if there is no initializer, i.e., INIT is NULL.\n-  // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are\n-  // the same ones passed to implicit_variable.  INIT will be a composite\n-  // literal of type TYPE.  It will not contain any function calls or anything\n-  // else that can not be put into a read-only data section.\n-  // It may contain the address of variables created by implicit_variable.\n-  //\n-  // If IS_COMMON is true, INIT will be NULL, and the\n-  // variable should be initialized to all zeros.\n-  virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t   tree type, bool is_hidden,\n-\t\t\t\t\t   bool is_constant, bool is_common,\n-\t\t\t\t\t   tree init)\n-    = 0;\n-\n-  // Create a reference to a named implicit variable defined in some\n-  // other package.  This will be a variable created by a call to\n-  // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n-  // IS_COMMON passed as false.  This corresponds to an extern global\n-  // variable in C.\n-  virtual Bvariable *implicit_variable_reference (const std::string &name,\n-\t\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t\t  tree type)\n-    = 0;\n-\n-  // Create a named immutable initialized data structure.  This is\n-  // used for type descriptors, map descriptors, and function\n-  // descriptors.  This returns a Bvariable because it corresponds to\n-  // an initialized const variable in C.\n-  //\n-  // NAME is the name to use for the initialized global variable which\n-  // this call will create.\n-  //\n-  // ASM_NAME is the encoded, assembler-friendly version of NAME, or\n-  // the empty string if no encoding is needed.\n-  //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_COMMON is true if NAME may be defined by several packages, and\n-  // the linker should merge all such definitions.  If IS_COMMON is\n-  // false, NAME should be defined in only one file.  In general\n-  // IS_COMMON will be true for the type descriptor of an unnamed type\n-  // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be\n-  // true.\n-  //\n-  // TYPE will be a struct type; the type of the returned expression\n-  // must be a pointer to this struct type.\n-  //\n-  // We must create the named structure before we know its\n-  // initializer, because the initializer may refer to its own\n-  // address.  After calling this the frontend will call\n-  // immutable_struct_set_init.\n-  virtual Bvariable *\n-  immutable_struct (const std::string &name, const std::string &asm_name,\n-\t\t    bool is_hidden, bool is_common, tree type, Location)\n-    = 0;\n-\n-  // Set the initial value of a variable created by immutable_struct.\n-  // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n-  // the same ones passed to immutable_struct.  INITIALIZER will be a\n-  // composite literal of type TYPE.  It will not contain any function\n-  // calls or anything else that can not be put into a read-only data\n-  // section.  It may contain the address of variables created by\n-  // immutable_struct.\n-  virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  tree type, Location, tree initializer)\n-    = 0;\n-\n-  // Create a reference to a named immutable initialized data\n-  // structure defined in some other package.  This will be a\n-  // structure created by a call to immutable_struct with the same\n-  // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n-  // corresponds to an extern const global variable in C.\n-  virtual Bvariable *immutable_struct_reference (const std::string &name,\n-\t\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t\t tree type, Location)\n-    = 0;\n-\n   // Labels.\n \n   // Create a new label.  NAME will be empty if this is a label"}, {"sha": "22a1df6beed646c702f9599e8117fec9e634cb6e", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=e49dd22fc233f3b7b7dcca4bd1ba2e7ea6dea71c", "patch": "@@ -321,24 +321,6 @@ class Gcc_backend : public Backend\n   Bvariable *temporary_variable (tree, tree, tree, tree, bool, Location,\n \t\t\t\t tree *);\n \n-  Bvariable *implicit_variable (const std::string &, const std::string &, tree,\n-\t\t\t\tbool, bool, bool, int64_t);\n-\n-  void implicit_variable_set_init (Bvariable *, const std::string &, tree, bool,\n-\t\t\t\t   bool, bool, tree);\n-\n-  Bvariable *implicit_variable_reference (const std::string &,\n-\t\t\t\t\t  const std::string &, tree);\n-\n-  Bvariable *immutable_struct (const std::string &, const std::string &, bool,\n-\t\t\t       bool, tree, Location);\n-\n-  void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  tree, Location, tree);\n-\n-  Bvariable *immutable_struct_reference (const std::string &,\n-\t\t\t\t\t const std::string &, tree, Location);\n-\n   // Labels.\n \n   tree label (tree, const std::string &name, Location);\n@@ -2620,209 +2602,6 @@ Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n   return new Bvariable (var);\n }\n \n-// Create an implicit variable that is compiler-defined.  This is used when\n-// generating GC root variables and storing the values of a slice initializer.\n-\n-Bvariable *\n-Gcc_backend::implicit_variable (const std::string &name,\n-\t\t\t\tconst std::string &asm_name, tree type_tree,\n-\t\t\t\tbool is_hidden, bool is_constant,\n-\t\t\t\tbool is_common, int64_t alignment)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-\n-  tree decl = build_decl (BUILTINS_LOCATION, VAR_DECL,\n-\t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_EXTERNAL (decl) = 0;\n-  TREE_PUBLIC (decl) = !is_hidden;\n-  TREE_STATIC (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (is_common)\n-    {\n-      DECL_COMMON (decl) = 1;\n-\n-      // When the initializer for one implicit_variable refers to another,\n-      // it needs to know the visibility of the referenced struct so that\n-      // compute_reloc_for_constant will return the right value.  On many\n-      // systems calling make_decl_one_only will mark the decl as weak,\n-      // which will change the return value of compute_reloc_for_constant.\n-      // We can't reliably call make_decl_one_only yet, because we don't\n-      // yet know the initializer.  This issue doesn't arise in C because\n-      // Rust initializers, unlike C initializers, can be indirectly\n-      // recursive.  To ensure that compute_reloc_for_constant computes\n-      // the right value if some other initializer refers to this one, we\n-      // mark this symbol as weak here.  We undo that below in\n-      // immutable_struct_set_init before calling mark_decl_one_only.\n-      DECL_WEAK (decl) = 1;\n-    }\n-  if (is_constant)\n-    {\n-      TREE_READONLY (decl) = 1;\n-      TREE_CONSTANT (decl) = 1;\n-    }\n-  if (alignment != 0)\n-    {\n-      SET_DECL_ALIGN (decl, alignment * BITS_PER_UNIT);\n-      DECL_USER_ALIGN (decl) = 1;\n-    }\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Set the initalizer for a variable created by implicit_variable.\n-// This is where we finish compiling the variable.\n-\n-void\n-Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\t tree, bool, bool, bool is_common,\n-\t\t\t\t\t tree init_tree)\n-{\n-  tree decl = var->get_decl ();\n-  if (decl == error_mark_node || init_tree == error_mark_node)\n-    return;\n-\n-  DECL_INITIAL (decl) = init_tree;\n-\n-  // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n-  // See the comment where DECL_WEAK is set in implicit_variable.\n-  if (is_common)\n-    {\n-      DECL_WEAK (decl) = 0;\n-      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n-    }\n-\n-  resolve_unique_section (decl, 2, 1);\n-\n-  rest_of_decl_compilation (decl, 1, 0);\n-}\n-\n-// Return a reference to an implicit variable defined in another package.\n-\n-Bvariable *\n-Gcc_backend::implicit_variable_reference (const std::string &name,\n-\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t  tree type_tree)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-\n-  tree decl = build_decl (BUILTINS_LOCATION, VAR_DECL,\n-\t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  TREE_STATIC (decl) = 0;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Create a named immutable initialized data structure.\n-\n-Bvariable *\n-Gcc_backend::immutable_struct (const std::string &name,\n-\t\t\t       const std::string &asm_name, bool is_hidden,\n-\t\t\t       bool is_common, tree type_tree,\n-\t\t\t       Location location)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n-\t\t\t  get_identifier_from_string (name),\n-\t\t\t  build_qualified_type (type_tree, TYPE_QUAL_CONST));\n-  TREE_STATIC (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-  TREE_CONSTANT (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (!is_hidden)\n-    TREE_PUBLIC (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-\n-  // When the initializer for one immutable_struct refers to another,\n-  // it needs to know the visibility of the referenced struct so that\n-  // compute_reloc_for_constant will return the right value.  On many\n-  // systems calling make_decl_one_only will mark the decl as weak,\n-  // which will change the return value of compute_reloc_for_constant.\n-  // We can't reliably call make_decl_one_only yet, because we don't\n-  // yet know the initializer.  This issue doesn't arise in C because\n-  // Rust initializers, unlike C initializers, can be indirectly\n-  // recursive.  To ensure that compute_reloc_for_constant computes\n-  // the right value if some other initializer refers to this one, we\n-  // mark this symbol as weak here.  We undo that below in\n-  // immutable_struct_set_init before calling mark_decl_one_only.\n-  if (is_common)\n-    DECL_WEAK (decl) = 1;\n-\n-  // We don't call rest_of_decl_compilation until we have the\n-  // initializer.\n-\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Set the initializer for a variable created by immutable_struct.\n-// This is where we finish compiling the variable.\n-\n-void\n-Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\tbool, bool is_common, tree, Location,\n-\t\t\t\t\ttree init_tree)\n-{\n-  tree decl = var->get_decl ();\n-  if (decl == error_mark_node || init_tree == error_mark_node)\n-    return;\n-\n-  DECL_INITIAL (decl) = init_tree;\n-\n-  // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n-  // See the comment where DECL_WEAK is set in immutable_struct.\n-  if (is_common)\n-    {\n-      DECL_WEAK (decl) = 0;\n-      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n-    }\n-\n-  // These variables are often unneeded in the final program, so put\n-  // them in their own section so that linker GC can discard them.\n-  resolve_unique_section (decl, compute_reloc_for_constant (init_tree), 1);\n-\n-  rest_of_decl_compilation (decl, 1, 0);\n-}\n-\n-// Return a reference to an immutable initialized data structure\n-// defined in another package.\n-\n-Bvariable *\n-Gcc_backend::immutable_struct_reference (const std::string &name,\n-\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t tree type_tree, Location location)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n-\t\t\t  get_identifier_from_string (name),\n-\t\t\t  build_qualified_type (type_tree, TYPE_QUAL_CONST));\n-  TREE_READONLY (decl) = 1;\n-  TREE_CONSTANT (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  DECL_EXTERNAL (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n // Make a label.\n \n tree"}]}