{"sha": "62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJiYjBjOTdmZGJiNzBmNmY5M2ZiMGQ3N2UxNzQzMTE3YWU1MzkzMA==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-04-13T09:03:18Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-04-13T09:03:18Z"}, "message": "boost_concept_check.h: Uglify, fork from Boost.\n\n2001-04-13  Phil Edwards  <pme@sources.redhat.com>\n\n\t* include/bits/boost_concept_check.h:  Uglify, fork from Boost.\n\t* include/bits/concept_check.h:  Uglify.\n\t* include/bits/stl_algo.h:  Likewise.\n\t* include/bits/stl_algobase.h:  Likewise.\n\t* include/bits/stl_deque.h:  Likewise.\n\t* include/bits/stl_heap.h:  Likewise.\n\t* include/bits/stl_iterator_base_funcs.h:  Likewise.\n\t* include/bits/stl_list.h:  Likewise.\n\t* include/bits/stl_map.h:  Likewise.\n\t* include/bits/stl_multimap.h:  Likewise.\n\t* include/bits/stl_multiset.h:  Likewise.\n\t* include/bits/stl_numeric.h:  Likewise.\n\t* include/bits/stl_queue.h:  Likewise.\n\t* include/bits/stl_set.h:  Likewise.\n\t* include/bits/stl_stack.h:  Likewise.\n\t* include/bits/stl_vector.h:  Likewise.\n\t* include/ext/hash_map:  Likewise.\n\t* include/ext/hash_set:  Likewise.\n\t* include/ext/slist:  Likewise.\n\nFrom-SVN: r41333", "tree": {"sha": "ffe43ada1f426fe58435372a972b8f83f7612961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffe43ada1f426fe58435372a972b8f83f7612961"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/comments", "author": null, "committer": null, "parents": [{"sha": "1f212504cfbdf59f951e1a1dc655544bc8a50c9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f212504cfbdf59f951e1a1dc655544bc8a50c9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f212504cfbdf59f951e1a1dc655544bc8a50c9c"}], "stats": {"total": 2018, "additions": 1024, "deletions": 994}, "files": [{"sha": "0c68727f98ce6b3730520e7f6491f1f2da66151a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -1,3 +1,25 @@\n+2001-04-13  Phil Edwards  <pme@sources.redhat.com>\n+\n+\t* include/bits/boost_concept_check.h:  Uglify, fork from Boost.\n+\t* include/bits/concept_check.h:  Uglify.\n+\t* include/bits/stl_algo.h:  Likewise.\n+\t* include/bits/stl_algobase.h:  Likewise.\n+\t* include/bits/stl_deque.h:  Likewise.\n+\t* include/bits/stl_heap.h:  Likewise.\n+\t* include/bits/stl_iterator_base_funcs.h:  Likewise.\n+\t* include/bits/stl_list.h:  Likewise.\n+\t* include/bits/stl_map.h:  Likewise.\n+\t* include/bits/stl_multimap.h:  Likewise.\n+\t* include/bits/stl_multiset.h:  Likewise.\n+\t* include/bits/stl_numeric.h:  Likewise.\n+\t* include/bits/stl_queue.h:  Likewise.\n+\t* include/bits/stl_set.h:  Likewise.\n+\t* include/bits/stl_stack.h:  Likewise.\n+\t* include/bits/stl_vector.h:  Likewise.\n+\t* include/ext/hash_map:  Likewise.\n+\t* include/ext/hash_set:  Likewise.\n+\t* include/ext/slist:  Likewise.\n+\n 2001-04-13  Gabriel Dos Reis  <gdr@codesourcery.com>\n \n \t* testsuite/23_containers/set_operators.cc: Just try to compile."}, {"sha": "be6bc27245c1e7c91b7b4c384d0a15899314e7e7", "filename": "libstdc++-v3/include/bits/boost_concept_check.h", "status": "modified", "additions": 623, "deletions": 615, "changes": 1238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fboost_concept_check.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -7,181 +7,184 @@\n //\n \n // GCC Note:  based on version 1.12.0 of the Boost library.\n-#ifndef BOOST_CONCEPT_CHECKS_HPP\n-#define BOOST_CONCEPT_CHECKS_HPP\n+#ifndef _GLIBCPP_BOOST_CONCEPT_CHECK\n+#define _GLIBCPP_BOOST_CONCEPT_CHECK 1\n \n #pragma GCC system_header\n #include <bits/stl_iterator_base_types.h>    // for traits and tags\n #include <utility>                           // for pair<>\n \n \n-namespace boost {\n+namespace __gnu_cxx\n+{\n \n-template <class T> void ignore_unused_variable_warning(const T&) { }\n+#define _IsUnused __attribute__ ((__unused__))\n \n-template <class Concept>\n-void function_requires()\n+template <class _Concept>\n+void __function_requires()\n {\n-  void (Concept::*x)() = &Concept::constraints;\n-  ignore_unused_variable_warning(x);\n+  void (_Concept::*__x)() _IsUnused = &_Concept::__constraints;\n }\n \n \n-#define BOOST_CLASS_REQUIRES(type_var, ns, concept) \\\n-  typedef void (ns::concept <type_var>::* func##type_var##concept)(); \\\n-  template <func##type_var##concept _Tp1> \\\n-  struct concept_checking_##type_var##concept { }; \\\n-  typedef concept_checking_##type_var##concept< \\\n-    &ns::concept <type_var>::constraints> \\\n-    concept_checking_typedef_##type_var##concept\n-\n-#define BOOST_CLASS_REQUIRES2(type_var1, type_var2, ns, concept) \\\n-  typedef void (ns::concept <type_var1,type_var2>::* func##type_var1##type_var2##concept)(); \\\n-  template <func##type_var1##type_var2##concept _Tp1> \\\n-  struct concept_checking_##type_var1##type_var2##concept { }; \\\n-  typedef concept_checking_##type_var1##type_var2##concept< \\\n-    &ns::concept <type_var1,type_var2>::constraints> \\\n-    concept_checking_typedef_##type_var1##type_var2##concept\n-\n-#define BOOST_CLASS_REQUIRES3(type_var1, type_var2, type_var3, ns, concept) \\\n-  typedef void (ns::concept <type_var1,type_var2,type_var3>::* func##type_var1##type_var2##type_var3##concept)(); \\\n-  template <func##type_var1##type_var2##type_var3##concept _Tp1> \\\n-  struct concept_checking_##type_var1##type_var2##type_var3##concept { }; \\\n-  typedef concept_checking_##type_var1##type_var2##type_var3##concept< \\\n-    &ns::concept <type_var1,type_var2,type_var3>::constraints>  \\\n-  concept_checking_typedef_##type_var1##type_var2##type_var3##concept\n-\n-#define BOOST_CLASS_REQUIRES4(type_var1, type_var2, type_var3, type_var4, ns, concept) \\\n-  typedef void (ns::concept <type_var1,type_var2,type_var3,type_var4>::* func##type_var1##type_var2##type_var3##type_var4##concept)(); \\\n-  template <func##type_var1##type_var2##type_var3##type_var4##concept _Tp1> \\\n-  struct concept_checking_##type_var1##type_var2##type_var3##type_var4##concept { }; \\\n-  typedef concept_checking_##type_var1##type_var2##type_var3##type_var4##concept< \\\n-    &ns::concept <type_var1,type_var2,type_var3,type_var4>::constraints>  \\\n-    concept_checking_typedef_##type_var1##type_var2##type_var3##type_var4##concept\n-\n-\n-template <class T, class U>\n-struct require_same { };\n-\n-template <class T>\n-struct require_same<T,T> { typedef T type; };\n-\n-  template <class T, class U>\n-  struct SameTypeConcept\n-  {\n-    void constraints() {\n-      typedef typename require_same<T, U>::type req;\n-    }\n-  };\n-\n-  template <class T>\n-  struct IntegerConcept {\n-    void constraints() { \n-      errortype_must_be_an_integer_type();\n-    }\n-  };\n-  template <> struct IntegerConcept<short> { void constraints() {} };\n-  template <> struct IntegerConcept<unsigned short> { void constraints() {} };\n-  template <> struct IntegerConcept<int> { void constraints() {} };\n-  template <> struct IntegerConcept<unsigned int> { void constraints() {} };\n-  template <> struct IntegerConcept<long> { void constraints() {} };\n-  template <> struct IntegerConcept<unsigned long> { void constraints() {} };\n-  // etc.\n-\n-  template <class T>\n-  struct SignedIntegerConcept {\n-    void constraints() { \n-      errortype_must_be_a_signed_integer_type();\n-    }\n-  };\n-  template <> struct SignedIntegerConcept<short> { void constraints() {} };\n-  template <> struct SignedIntegerConcept<int> { void constraints() {} };\n-  template <> struct SignedIntegerConcept<long> { void constraints() {} };\n-  // etc.\n-\n-  template <class T>\n-  struct UnsignedIntegerConcept {\n-    void constraints() { \n-      errortype_must_be_an_unsigned_integer_type();\n-    }\n-  };\n-  template <> struct UnsignedIntegerConcept<unsigned short>\n-    { void constraints() {} };\n-  template <> struct UnsignedIntegerConcept<unsigned int>\n-    { void constraints() {} };\n-  template <> struct UnsignedIntegerConcept<unsigned long>\n-    { void constraints() {} };\n-  // etc.\n+// ??? Should the \"concept_checking*\" structs begin with more than _ ?\n+#define _GLIBCPP_CLASS_REQUIRES(_type_var, _ns, _concept) \\\n+  typedef void (_ns::_concept <_type_var>::* _func##_type_var##_concept)(); \\\n+  template <_func##_type_var##_concept _Tp1> \\\n+  struct _concept_checking##_type_var##_concept { }; \\\n+  typedef _concept_checking##_type_var##_concept< \\\n+    &_ns::_concept <_type_var>::__constraints> \\\n+    _concept_checking_typedef##_type_var##_concept\n+\n+#define _GLIBCPP_CLASS_REQUIRES2(_type_var1, _type_var2, _ns, _concept) \\\n+  typedef void (_ns::_concept <_type_var1,_type_var2>::* _func##_type_var1##_type_var2##_concept)(); \\\n+  template <_func##_type_var1##_type_var2##_concept _Tp1> \\\n+  struct _concept_checking##_type_var1##_type_var2##_concept { }; \\\n+  typedef _concept_checking##_type_var1##_type_var2##_concept< \\\n+    &_ns::_concept <_type_var1,_type_var2>::__constraints> \\\n+    _concept_checking_typedef##_type_var1##_type_var2##_concept\n+\n+#define _GLIBCPP_CLASS_REQUIRES3(_type_var1, _type_var2, _type_var3, _ns, _concept) \\\n+  typedef void (_ns::_concept <_type_var1,_type_var2,_type_var3>::* _func##_type_var1##_type_var2##_type_var3##_concept)(); \\\n+  template <_func##_type_var1##_type_var2##_type_var3##_concept _Tp1> \\\n+  struct _concept_checking##_type_var1##_type_var2##_type_var3##_concept { }; \\\n+  typedef _concept_checking##_type_var1##_type_var2##_type_var3##_concept< \\\n+    &_ns::_concept <_type_var1,_type_var2,_type_var3>::__constraints>  \\\n+  _concept_checking_typedef##_type_var1##_type_var2##_type_var3##_concept\n+\n+#define _GLIBCPP_CLASS_REQUIRES4(_type_var1, _type_var2, _type_var3, _type_var4, _ns, _concept) \\\n+  typedef void (_ns::_concept <_type_var1,_type_var2,_type_var3,_type_var4>::* _func##_type_var1##_type_var2##_type_var3##_type_var4##_concept)(); \\\n+  template <_func##_type_var1##_type_var2##_type_var3##_type_var4##_concept _Tp1> \\\n+  struct _concept_checking##_type_var1##_type_var2##_type_var3##_type_var4##_concept { }; \\\n+  typedef _concept_checking##_type_var1##_type_var2##_type_var3##_type_var4##_concept< \\\n+  &_ns::_concept <_type_var1,_type_var2,_type_var3,_type_var4>::__constraints> \\\n+    _concept_checking_typedef##_type_var1##_type_var2##_type_var3##_type_var4##_concept\n+\n+\n+template <class _Tp1, class _Tp2>\n+struct _Aux_require_same { };\n+\n+template <class _Tp>\n+struct _Aux_require_same<_Tp,_Tp> { typedef _Tp _Type; };\n+\n+  template <class _Tp1, class _Tp2>\n+  struct _SameTypeConcept\n+  {\n+    void __constraints() {\n+      typedef typename _Aux_require_same<_Tp1, _Tp2>::_Type _Required;\n+    }\n+  };\n+\n+  template <class _Tp>\n+  struct _IntegerConcept {\n+    void __constraints() { \n+      __error_type_must_be_an_integer_type();\n+    }\n+  };\n+  template <> struct _IntegerConcept<short> { void __constraints() {} };\n+  template <> struct _IntegerConcept<unsigned short> { void __constraints(){} };\n+  template <> struct _IntegerConcept<int> { void __constraints() {} };\n+  template <> struct _IntegerConcept<unsigned int> { void __constraints() {} };\n+  template <> struct _IntegerConcept<long> { void __constraints() {} };\n+  template <> struct _IntegerConcept<unsigned long> { void __constraints() {} };\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template <> struct _IntegerConcept<long long> { void __constraints() {} };\n+  template <> struct _IntegerConcept<unsigned long long>\n+                                                { void __constraints() {} };\n+#endif\n+\n+  template <class _Tp>\n+  struct _SignedIntegerConcept {\n+    void __constraints() { \n+      __error_type_must_be_a_signed_integer_type();\n+    }\n+  };\n+  template <> struct _SignedIntegerConcept<short> { void __constraints() {} };\n+  template <> struct _SignedIntegerConcept<int> { void __constraints() {} };\n+  template <> struct _SignedIntegerConcept<long> { void __constraints() {} };\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template <> struct _SignedIntegerConcept<long long> { void __constraints(){}};\n+#endif\n+\n+  template <class _Tp>\n+  struct _UnsignedIntegerConcept {\n+    void __constraints() { \n+      __error_type_must_be_an_unsigned_integer_type();\n+    }\n+  };\n+  template <> struct _UnsignedIntegerConcept<unsigned short>\n+    { void __constraints() {} };\n+  template <> struct _UnsignedIntegerConcept<unsigned int>\n+    { void __constraints() {} };\n+  template <> struct _UnsignedIntegerConcept<unsigned long>\n+    { void __constraints() {} };\n+#ifdef _GLIBCPP_USE_LONG_LONG\n+  template <> struct _UnsignedIntegerConcept<unsigned long long>\n+    { void __constraints() {} };\n+#endif\n \n   //===========================================================================\n   // Basic Concepts\n \n-  template <class TT>\n-  struct DefaultConstructibleConcept\n+  template <class _Tp>\n+  struct _DefaultConstructibleConcept\n   {\n-    void constraints() {\n-      TT a;               // require default constructor\n-      ignore_unused_variable_warning(a);\n+    void __constraints() {\n+      _Tp __a _IsUnused;                // require default constructor\n     }\n   };\n \n-  template <class TT>\n-  struct AssignableConcept\n+  template <class _Tp>\n+  struct _AssignableConcept\n   {\n-    void constraints() {\n-      a = a;              // require assignment operator\n-      const_constraints(a);\n+    void __constraints() {\n+      __a = __a;                        // require assignment operator\n+      __const_constraints(__a);\n     }\n-    void const_constraints(const TT& b) {\n-      a = b;              // const required for argument to assignment\n+    void __const_constraints(const _Tp& __b) {\n+      __a = __b;                   // const required for argument to assignment\n     }\n-    TT a;\n+    _Tp __a;\n   };\n \n-  template <class TT>\n-  struct CopyConstructibleConcept\n+  template <class _Tp>\n+  struct _CopyConstructibleConcept\n   {\n-    void constraints() {\n-      TT a(b);            // require copy constructor\n-      TT* ptr = &a;       // require address of operator\n-      const_constraints(a);\n-      ignore_unused_variable_warning(ptr);\n+    void __constraints() {\n+      _Tp __a(__b);                     // require copy constructor\n+      _Tp* __ptr _IsUnused = &__a;      // require address of operator\n+      __const_constraints(__a);\n     }\n-    void const_constraints(const TT& a) {\n-      TT c(a);            // require const copy constructor\n-      const TT* ptr = &a; // require const address of operator\n-      ignore_unused_variable_warning(c);\n-      ignore_unused_variable_warning(ptr);\n+    void __const_constraints(const _Tp& __a) {\n+      _Tp __c(__a) _IsUnused;           // require const copy constructor\n+      const _Tp* __ptr _IsUnused = &__a; // require const address of operator\n     }\n-    TT b;\n+    _Tp __b;\n   };\n \n   // The SGI STL version of Assignable requires copy constructor and operator=\n-  template <class TT>\n-  struct SGIAssignableConcept\n+  template <class _Tp>\n+  struct _SGIAssignableConcept\n   {\n-    void constraints() {\n-      TT b(a);\n-      a = a;              // require assignment operator\n-      const_constraints(a);\n-      ignore_unused_variable_warning(b);\n+    void __constraints() {\n+      _Tp __b(__a) _IsUnused;\n+      __a = __a;                        // require assignment operator\n+      __const_constraints(__a);\n     }\n-    void const_constraints(const TT& b) {\n-      TT c(b);\n-      a = b;              // const required for argument to assignment\n-      ignore_unused_variable_warning(c);\n+    void __const_constraints(const _Tp& __b) {\n+      _Tp __c(__b) _IsUnused;\n+      __a = __b;              // const required for argument to assignment\n     }\n-    TT a;\n+    _Tp __a;\n   };\n \n-  template <class X, class Y>\n-  struct ConvertibleConcept\n+  template <class _From, class _To>\n+  struct _ConvertibleConcept\n   {\n-    void constraints() {\n-      Y y = x;\n-      ignore_unused_variable_warning(y);\n+    void __constraints() {\n+      _To __y _IsUnused = __x;\n     }\n-    X x;\n+    _From __x;\n   };\n \n   // The C++ standard requirements for many concepts talk about return\n@@ -193,695 +196,700 @@ struct require_same<T,T> { typedef T type; };\n   // 2) stay with convertible to bool, and also\n   //    specify stuff about all the logical operators.\n   // For now we just test for convertible to bool.\n-  template <class TT>\n-  void require_boolean_expr(const TT& t) {\n-    bool x = t;\n-    ignore_unused_variable_warning(x);\n+  template <class _Tp>\n+  void __aux_require_boolean_expr(const _Tp& __t) {\n+    bool __x _IsUnused = __t;\n   }\n \n-  template <class TT>\n-  struct EqualityComparableConcept\n+// FIXME\n+  template <class _Tp>\n+  struct _EqualityComparableConcept\n   {\n-    void constraints() {\n-      require_boolean_expr(a == b);\n-      require_boolean_expr(a != b);\n+    void __constraints() {\n+      __aux_require_boolean_expr(__a == __b);\n+      __aux_require_boolean_expr(__a != __b);\n     }\n-    TT a, b;\n+    _Tp __a, __b;\n   };\n \n-  template <class TT>\n-  struct LessThanComparableConcept\n+  template <class _Tp>\n+  struct _LessThanComparableConcept\n   {\n-    void constraints() {\n-      require_boolean_expr(a < b);\n+    void __constraints() {\n+      __aux_require_boolean_expr(__a < __b);\n     }\n-    TT a, b;\n+    _Tp __a, __b;\n   };\n \n   // This is equivalent to SGI STL's LessThanComparable.\n-  template <class TT>\n-  struct ComparableConcept\n+  template <class _Tp>\n+  struct _ComparableConcept\n   {\n-    void constraints() {\n-      require_boolean_expr(a < b);\n-      require_boolean_expr(a > b);\n-      require_boolean_expr(a <= b);\n-      require_boolean_expr(a >= b);\n+    void __constraints() {\n+      __aux_require_boolean_expr(__a < __b);\n+      __aux_require_boolean_expr(__a > __b);\n+      __aux_require_boolean_expr(__a <= __b);\n+      __aux_require_boolean_expr(__a >= __b);\n     }\n-    TT a, b;\n+    _Tp __a, __b;\n   };\n \n-#define BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(OP,NAME) \\\n-  template <class First, class Second> \\\n-  struct NAME { \\\n-    void constraints() { (void)constraints_(); } \\\n-    bool constraints_() {  \\\n-      return  a OP b; \\\n+#define _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(_OP,_NAME) \\\n+  template <class _First, class _Second> \\\n+  struct _NAME { \\\n+    void __constraints() { (void)__constraints_(); } \\\n+    bool __constraints_() {  \\\n+      return  __a _OP __b; \\\n     } \\\n-    First a; \\\n-    Second b; \\\n+    _First __a; \\\n+    _Second __b; \\\n   }\n \n-#define BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(OP,NAME) \\\n-  template <class Ret, class First, class Second> \\\n-  struct NAME { \\\n-    void constraints() { (void)constraints_(); } \\\n-    Ret constraints_() {  \\\n-      return a OP b; \\\n+#define _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(_OP,_NAME) \\\n+  template <class _Ret, class _First, class _Second> \\\n+  struct _NAME { \\\n+    void __constraints() { (void)__constraints_(); } \\\n+    _Ret __constraints_() {  \\\n+      return __a _OP __b; \\\n     } \\\n-    First a; \\\n-    Second b; \\\n+    _First __a; \\\n+    _Second __b; \\\n   }\n \n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(==, EqualOpConcept);\n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(!=, NotEqualOpConcept);\n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<, LessThanOpConcept);\n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<=, LessEqualOpConcept);\n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>, GreaterThanOpConcept);\n-  BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>=, GreaterEqualOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(==, _EqualOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(!=, _NotEqualOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<, _LessThanOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(<=, _LessEqualOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>, _GreaterThanOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT(>=, _GreaterEqualOpConcept);\n \n-  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(+, PlusOpConcept);\n-  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(*, TimesOpConcept);\n-  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(/, DivideOpConcept);\n-  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(-, SubtractOpConcept);\n-  BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT(%, ModOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(+, _PlusOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(*, _TimesOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(/, _DivideOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(-, _SubtractOpConcept);\n+  _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT(%, _ModOpConcept);\n \n-#undef BOOST_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT\n-#undef BOOST_DEFINE_BINARY_OPERATOR_CONSTRAINT\n+#undef _GLIBCPP_DEFINE_BINARY_PREDICATE_OP_CONSTRAINT\n+#undef _GLIBCPP_DEFINE_BINARY_OPERATOR_CONSTRAINT\n \n   //===========================================================================\n   // Function Object Concepts\n \n-  template <class Func, class Return>\n-  struct GeneratorConcept\n+  template <class _Func, class _Return>\n+  struct _GeneratorConcept\n   {\n-    void constraints() {\n-      const Return& r = f();   // require operator() member function\n-      ignore_unused_variable_warning(r);\n+    void __constraints() {\n+      const _Return& __r _IsUnused = __f();// require operator() member function\n     }\n-    Func f;\n+    _Func __f;\n   };\n \n \n-  template <class Func>\n-  struct GeneratorConcept<Func,void>\n+  template <class _Func>\n+  struct _GeneratorConcept<_Func,void>\n   {\n-    void constraints() {\n-      f();              // require operator() member function\n+    void __constraints() {\n+      __f();                            // require operator() member function\n     }\n-    Func f;\n+    _Func __f;\n   };\n \n-  template <class Func, class Return, class Arg>\n-  struct UnaryFunctionConcept\n+  template <class _Func, class _Return, class _Arg>\n+  struct _UnaryFunctionConcept\n   {\n-    void constraints() {\n-      r = f(arg); // require operator()\n+    void __constraints() {\n+      __r = __f(__arg);                  // require operator()\n     }\n-    Func f;\n-    Arg arg;\n-    Return r;\n+    _Func __f;\n+    _Arg __arg;\n+    _Return __r;\n   };\n \n-  template <class Func, class Arg>\n-  struct UnaryFunctionConcept<Func, void, Arg> {\n-    void constraints() { \n-      f(arg);                 // require operator()\n+  template <class _Func, class _Arg>\n+  struct _UnaryFunctionConcept<_Func, void, _Arg> {\n+    void __constraints() { \n+      __f(__arg);                       // require operator()\n     }\n-    Func f;\n+    _Func __f;\n+    _Arg __arg;\n   };\n \n-  template <class Func, class Return, class First, class Second>\n-  struct BinaryFunctionConcept\n+  template <class _Func, class _Return, class _First, class _Second>\n+  struct _BinaryFunctionConcept\n   {\n-    void constraints() { \n-      r = f(first, second); // require operator()\n+    void __constraints() { \n+      __r = __f(__first, __second);     // require operator()\n     }\n-    Func f;\n-    First first;\n-    Second second;\n-    Return r;\n+    _Func __f;\n+    _First __first;\n+    _Second __second;\n+    _Return __r;\n   };\n \n-  template <class Func, class First, class Second>\n-  struct BinaryFunctionConcept<Func, void, First, Second>\n+  template <class _Func, class _First, class _Second>\n+  struct _BinaryFunctionConcept<_Func, void, _First, _Second>\n   {\n-    void constraints() {\n-      f(first, second); // require operator()\n+    void __constraints() {\n+      __f(__first, __second);           // require operator()\n     }\n-    Func f;\n-    First first;\n-    Second second;\n+    _Func __f;\n+    _First __first;\n+    _Second __second;\n   };\n \n-  template <class Func, class Arg>\n-  struct UnaryPredicateConcept\n+  template <class _Func, class _Arg>\n+  struct _UnaryPredicateConcept\n   {\n-    void constraints() {\n-      require_boolean_expr(f(arg)); // require operator() returning bool\n+    void __constraints() {\n+      __aux_require_boolean_expr(__f(__arg)); // require op() returning bool\n     }\n-    Func f;\n-    Arg arg;\n+    _Func __f;\n+    _Arg __arg;\n   };\n \n-  template <class Func, class First, class Second>\n-  struct BinaryPredicateConcept\n+  template <class _Func, class _First, class _Second>\n+  struct _BinaryPredicateConcept\n   {\n-    void constraints() {\n-      require_boolean_expr(f(a, b)); // require operator() returning bool\n+    void __constraints() {\n+      __aux_require_boolean_expr(__f(__a, __b)); // require op() returning bool\n     }\n-    Func f;\n-    First a;\n-    Second b;\n+    _Func __f;\n+    _First __a;\n+    _Second __b;\n   };\n \n   // use this when functor is used inside a container class like std::set\n-  template <class Func, class First, class Second>\n-  struct Const_BinaryPredicateConcept {\n-    void constraints() { \n-      const_constraints(f);\n+  template <class _Func, class _First, class _Second>\n+  struct _Const_BinaryPredicateConcept {\n+    void __constraints() { \n+      __const_constraints(__f);\n     }\n-    void const_constraints(const Func& fun) {\n-      function_requires<BinaryPredicateConcept<Func, First, Second> >();\n+    void __const_constraints(const _Func& __fun) {\n+      __function_requires<_BinaryPredicateConcept<_Func, _First, _Second> >();\n       // operator() must be a const member function\n-      require_boolean_expr(fun(a, b));\n+      __aux_require_boolean_expr(__fun(__a, __b));\n     }\n-    Func f;\n-    First a;\n-    Second b;\n+    _Func __f;\n+    _First __a;\n+    _Second __b;\n   };\n \n   //===========================================================================\n   // Iterator Concepts\n \n-  template <class TT>\n-  struct TrivialIteratorConcept\n+  template <class _Tp>\n+  struct _TrivialIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< AssignableConcept<TT> >();\n-      function_requires< DefaultConstructibleConcept<TT> >();\n-      function_requires< EqualityComparableConcept<TT> >();\n-      typedef typename std::iterator_traits<TT>::value_type V;\n-      (void)*i;           // require dereference operator\n+    void __constraints() {\n+      __function_requires< _DefaultConstructibleConcept<_Tp> >();\n+      __function_requires< _AssignableConcept<_Tp> >();\n+      __function_requires< _EqualityComparableConcept<_Tp> >();\n+      typedef typename std::iterator_traits<_Tp>::value_type _V;\n+      (void)*__i;                       // require dereference operator\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n-  template <class TT>\n-  struct Mutable_TrivialIteratorConcept\n+  template <class _Tp>\n+  struct _Mutable_TrivialIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< TrivialIteratorConcept<TT> >();\n-      *i = *j;            // require dereference and assignment\n+    void __constraints() {\n+      __function_requires< _TrivialIteratorConcept<_Tp> >();\n+      *__i = *__j;                      // require dereference and assignment\n     }\n-    TT i, j;\n+    _Tp __i, __j;\n   };\n \n-  template <class TT>\n-  struct InputIteratorConcept\n+  template <class _Tp>\n+  struct _InputIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< TrivialIteratorConcept<TT> >();\n+    void __constraints() {\n+      __function_requires< _TrivialIteratorConcept<_Tp> >();\n       // require iterator_traits typedef's\n-      typedef typename std::iterator_traits<TT>::difference_type D;\n-      function_requires< SignedIntegerConcept<D> >();\n-      typedef typename std::iterator_traits<TT>::reference R;\n-      typedef typename std::iterator_traits<TT>::pointer P;\n-      typedef typename std::iterator_traits<TT>::iterator_category C;\n-      function_requires< ConvertibleConcept<\n-        typename std::iterator_traits<TT>::iterator_category,\n+      typedef typename std::iterator_traits<_Tp>::difference_type _D;\n+      __function_requires< _SignedIntegerConcept<_D> >();\n+      typedef typename std::iterator_traits<_Tp>::reference _R;\n+      typedef typename std::iterator_traits<_Tp>::pointer _Pt;\n+      typedef typename std::iterator_traits<_Tp>::iterator_category _Cat;\n+      __function_requires< _ConvertibleConcept<\n+        typename std::iterator_traits<_Tp>::iterator_category,\n         std::input_iterator_tag> >();\n-      ++i;                // require preincrement operator\n-      i++;                // require postincrement operator\n+      ++__i;                            // require preincrement operator\n+      __i++;                            // require postincrement operator\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n-  template <class TT, class ValueT>\n-  struct OutputIteratorConcept\n+  template <class _Tp, class _ValueT>\n+  struct _OutputIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< AssignableConcept<TT> >();\n-      ++i;                // require preincrement operator\n-      i++;                // require postincrement operator\n-      *i++ = t;           // require postincrement and assignment\n+    void __constraints() {\n+      __function_requires< _AssignableConcept<_Tp> >();\n+      ++__i;                            // require preincrement operator\n+      __i++;                            // require postincrement operator\n+      *__i++ = __t;                     // require postincrement and assignment\n     }\n-    TT i;\n-    ValueT t;\n+    _Tp __i;\n+    _ValueT __t;\n   };\n \n-  template <class TT>\n-  struct ForwardIteratorConcept\n+  template <class _Tp>\n+  struct _ForwardIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< InputIteratorConcept<TT> >();\n-      function_requires< ConvertibleConcept<\n-        typename std::iterator_traits<TT>::iterator_category,\n+    void __constraints() {\n+      __function_requires< _InputIteratorConcept<_Tp> >();\n+      __function_requires< _ConvertibleConcept<\n+        typename std::iterator_traits<_Tp>::iterator_category,\n         std::forward_iterator_tag> >();\n-      typedef typename std::iterator_traits<TT>::reference reference;\n-      reference r = *i;\n-      ignore_unused_variable_warning(r);\n+      typedef typename std::iterator_traits<_Tp>::reference _R;\n+      _R __r _IsUnused = *__i;\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n-  template <class TT>\n-  struct Mutable_ForwardIteratorConcept\n+  template <class _Tp>\n+  struct _Mutable_ForwardIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< ForwardIteratorConcept<TT> >();\n-      *i++ = *i;         // require postincrement and assignment\n+    void __constraints() {\n+      __function_requires< _ForwardIteratorConcept<_Tp> >();\n+      *__i++ = *__i;                    // require postincrement and assignment\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n-  template <class TT>\n-  struct BidirectionalIteratorConcept\n+  template <class _Tp>\n+  struct _BidirectionalIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< ForwardIteratorConcept<TT> >();\n-      function_requires< ConvertibleConcept<\n-        typename std::iterator_traits<TT>::iterator_category,\n+    void __constraints() {\n+      __function_requires< _ForwardIteratorConcept<_Tp> >();\n+      __function_requires< _ConvertibleConcept<\n+        typename std::iterator_traits<_Tp>::iterator_category,\n         std::bidirectional_iterator_tag> >();\n-      --i;                // require predecrement operator\n-      i--;                // require postdecrement operator\n+      --__i;                            // require predecrement operator\n+      __i--;                            // require postdecrement operator\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n-  template <class TT>\n-  struct Mutable_BidirectionalIteratorConcept\n+  template <class _Tp>\n+  struct _Mutable_BidirectionalIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< BidirectionalIteratorConcept<TT> >();\n-      function_requires< Mutable_ForwardIteratorConcept<TT> >();\n-      *i-- = *i;                  // require postdecrement and assignment\n+    void __constraints() {\n+      __function_requires< _BidirectionalIteratorConcept<_Tp> >();\n+      __function_requires< _Mutable_ForwardIteratorConcept<_Tp> >();\n+      *__i-- = *__i;                    // require postdecrement and assignment\n     }\n-    TT i;\n+    _Tp __i;\n   };\n \n \n-  template <class TT>\n-  struct RandomAccessIteratorConcept\n+  template <class _Tp>\n+  struct _RandomAccessIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< BidirectionalIteratorConcept<TT> >();\n-      function_requires< ComparableConcept<TT> >();\n-      function_requires< ConvertibleConcept<\n-        typename std::iterator_traits<TT>::iterator_category,\n+    void __constraints() {\n+      __function_requires< _BidirectionalIteratorConcept<_Tp> >();\n+      __function_requires< _ComparableConcept<_Tp> >();\n+      __function_requires< _ConvertibleConcept<\n+        typename std::iterator_traits<_Tp>::iterator_category,\n         std::random_access_iterator_tag> >();\n-      typedef typename std::iterator_traits<TT>::reference R;\n+      // ??? We don't use _R, are we just checking for \"referenceability\"?\n+      typedef typename std::iterator_traits<_Tp>::reference _R;\n \n-      i += n;             // require assignment addition operator\n-      i = i + n; i = n + i; // require addition with difference type\n-      i -= n;             // require assignment subtraction operator\n-      i = i - n;                  // require subtraction with difference type\n-      n = i - j;                  // require difference operator\n-      (void)i[n];                 // require element access operator\n+      __i += __n;                       // require assignment addition operator\n+      __i = __i + __n; __i = __n + __i; // require addition with difference type\n+      __i -= __n;                       // require assignment subtraction op\n+      __i = __i - __n;                  // require subtraction with\n+                                        //            difference type\n+      __n = __i - __j;                  // require difference operator\n+      (void)__i[__n];                   // require element access operator\n     }\n-    TT a, b;\n-    TT i, j;\n-    typename std::iterator_traits<TT>::difference_type n;\n+    _Tp __a, __b;\n+    _Tp __i, __j;\n+    typename std::iterator_traits<_Tp>::difference_type __n;\n   };\n \n-  template <class TT>\n-  struct Mutable_RandomAccessIteratorConcept\n+  template <class _Tp>\n+  struct _Mutable_RandomAccessIteratorConcept\n   {\n-    void constraints() {\n-      function_requires< RandomAccessIteratorConcept<TT> >();\n-      function_requires< Mutable_BidirectionalIteratorConcept<TT> >();\n-      i[n] = *i;                  // require element access and assignment\n+    void __constraints() {\n+      __function_requires< _RandomAccessIteratorConcept<_Tp> >();\n+      __function_requires< _Mutable_BidirectionalIteratorConcept<_Tp> >();\n+      __i[__n] = *__i;                  // require element access and assignment\n     }\n-    TT i;\n-    typename std::iterator_traits<TT>::difference_type n;\n+    _Tp __i;\n+    typename std::iterator_traits<_Tp>::difference_type __n;\n   };\n \n   //===========================================================================\n   // Container Concepts\n \n-  template <class Container>\n-  struct ContainerConcept\n-  {\n-    typedef typename Container::value_type value_type;\n-    typedef typename Container::difference_type difference_type;\n-    typedef typename Container::size_type size_type;\n-    typedef typename Container::const_reference const_reference;\n-    typedef typename Container::const_pointer const_pointer;\n-    typedef typename Container::const_iterator const_iterator;\n-\n-    void constraints() {\n-      function_requires< InputIteratorConcept<const_iterator> >();\n-      function_requires< AssignableConcept<Container> >();\n-      const Container c;\n-      i = c.begin();\n-      i = c.end();\n-      n = c.size();\n-      n = c.max_size();\n-      b = c.empty();\n-    }\n-    bool b;\n-    const_iterator i;\n-    size_type n;\n-  };\n-\n-  template <class Container>\n-  struct Mutable_ContainerConcept\n-  {\n-    typedef typename Container::value_type value_type;\n-    typedef typename Container::reference reference;\n-    typedef typename Container::iterator iterator;\n-    typedef typename Container::pointer pointer;\n+  template <class _Container>\n+  struct _ContainerConcept\n+  {\n+    typedef typename _Container::value_type _Value_type;\n+    typedef typename _Container::difference_type _Difference_type;\n+    typedef typename _Container::size_type _Size_type;\n+    typedef typename _Container::const_reference _Const_reference;\n+    typedef typename _Container::const_pointer _Const_pointer;\n+    typedef typename _Container::const_iterator _Const_iterator;\n+\n+    void __constraints() {\n+      __function_requires< _InputIteratorConcept<_Const_iterator> >();\n+      __function_requires< _AssignableConcept<_Container> >();\n+      const _Container __c;\n+      __i = __c.begin();\n+      __i = __c.end();\n+      __n = __c.size();\n+      __n = __c.max_size();\n+      __b = __c.empty();\n+    }\n+    bool __b;\n+    _Const_iterator __i;\n+    _Size_type __n;\n+  };\n+\n+  template <class _Container>\n+  struct _Mutable_ContainerConcept\n+  {\n+    typedef typename _Container::value_type _Value_type;\n+    typedef typename _Container::reference _Reference;\n+    typedef typename _Container::iterator _Iterator;\n+    typedef typename _Container::pointer _Pointer;\n     \n-    void constraints() {\n-      function_requires< ContainerConcept<Container> >();\n-      function_requires< AssignableConcept<value_type> >();\n-      function_requires< InputIteratorConcept<iterator> >();\n+    void __constraints() {\n+      __function_requires< _ContainerConcept<_Container> >();\n+      __function_requires< _AssignableConcept<_Value_type> >();\n+      __function_requires< _InputIteratorConcept<_Iterator> >();\n \n-      i = c.begin();\n-      i = c.end();\n-      c.swap(c2);\n+      __i = __c.begin();\n+      __i = __c.end();\n+      __c.swap(__c2);\n     }\n-    iterator i;\n-    Container c, c2;\n+    _Iterator _i;\n+    _Container __c, __c2;\n   };\n \n-  template <class ForwardContainer>\n-  struct ForwardContainerConcept\n+  template <class _ForwardContainer>\n+  struct _ForwardContainerConcept\n   {\n-    void constraints() {\n-      function_requires< ContainerConcept<ForwardContainer> >();\n-      typedef typename ForwardContainer::const_iterator const_iterator;\n-      function_requires< ForwardIteratorConcept<const_iterator> >();\n+    void __constraints() {\n+      __function_requires< _ContainerConcept<_ForwardContainer> >();\n+      typedef typename _ForwardContainer::const_iterator _Const_iterator;\n+      __function_requires< _ForwardIteratorConcept<_Const_iterator> >();\n     }\n   };  \n \n-  template <class ForwardContainer>\n-  struct Mutable_ForwardContainerConcept\n+  template <class _ForwardContainer>\n+  struct _Mutable_ForwardContainerConcept\n   {\n-    void constraints() {\n-      function_requires< ForwardContainerConcept<ForwardContainer> >();\n-      function_requires< Mutable_ContainerConcept<ForwardContainer> >();\n-      typedef typename ForwardContainer::iterator iterator;\n-      function_requires< Mutable_ForwardIteratorConcept<iterator> >();\n+    void __constraints() {\n+      __function_requires< _ForwardContainerConcept<_ForwardContainer> >();\n+      __function_requires< _Mutable_ContainerConcept<_ForwardContainer> >();\n+      typedef typename _ForwardContainer::iterator _Iterator;\n+      __function_requires< _Mutable_ForwardIteratorConcept<_Iterator> >();\n     }\n   };  \n \n-  template <class ReversibleContainer>\n-  struct ReversibleContainerConcept\n+  template <class _ReversibleContainer>\n+  struct _ReversibleContainerConcept\n   {\n-    typedef typename ReversibleContainer::const_iterator const_iterator;\n-    typedef typename ReversibleContainer::const_reverse_iterator\n-      const_reverse_iterator;\n+    typedef typename _ReversibleContainer::const_iterator _Const_iterator;\n+    typedef typename _ReversibleContainer::const_reverse_iterator\n+      _Const_reverse_iterator;\n \n-    void constraints() {\n-      function_requires< ForwardContainerConcept<ReversibleContainer> >();\n-      function_requires< BidirectionalIteratorConcept<const_iterator> >();\n-      function_requires< BidirectionalIteratorConcept<const_reverse_iterator> >();\n+    void __constraints() {\n+      __function_requires< _ForwardContainerConcept<_ReversibleContainer> >();\n+      __function_requires< _BidirectionalIteratorConcept<_Const_iterator> >();\n+      __function_requires<\n+        _BidirectionalIteratorConcept<_Const_reverse_iterator> >();\n \n-      const ReversibleContainer c;\n-      const_reverse_iterator i = c.rbegin();\n-      i = c.rend();\n+      const _ReversibleContainer __c;\n+      _Const_reverse_iterator __i = __c.rbegin();\n+      __i = __c.rend();\n     }\n   };\n \n-  template <class ReversibleContainer>\n-  struct Mutable_ReversibleContainerConcept\n+  template <class _ReversibleContainer>\n+  struct _Mutable_ReversibleContainerConcept\n   {\n-    typedef typename ReversibleContainer::iterator iterator;\n-    typedef typename ReversibleContainer::reverse_iterator reverse_iterator;\n+    typedef typename _ReversibleContainer::iterator _Iterator;\n+    typedef typename _ReversibleContainer::reverse_iterator _Reverse_iterator;\n \n-    void constraints() {\n-      function_requires< ReversibleContainerConcept<ReversibleContainer> >();\n-      function_requires< Mutable_ForwardContainerConcept<ReversibleContainer> >();\n-      function_requires< Mutable_BidirectionalIteratorConcept<iterator> >();\n-      function_requires< Mutable_BidirectionalIteratorConcept<reverse_iterator> >();\n+    void __constraints() {\n+      __function_requires<_ReversibleContainerConcept<_ReversibleContainer> >();\n+      __function_requires<\n+        _Mutable_ForwardContainerConcept<_ReversibleContainer> >();\n+      __function_requires<_Mutable_BidirectionalIteratorConcept<_Iterator> >();\n+      __function_requires<\n+        _Mutable_BidirectionalIteratorConcept<_Reverse_iterator> >();\n \n-      reverse_iterator i = c.rbegin();\n-      i = c.rend();\n+      _Reverse_iterator __i = __c.rbegin();\n+      __i = __c.rend();\n     }\n-    ReversibleContainer c;\n+    _ReversibleContainer __c;\n   };\n \n-  template <class RandomAccessContainer>\n-  struct RandomAccessContainerConcept\n+  template <class _RandomAccessContainer>\n+  struct _RandomAccessContainerConcept\n   {\n-    typedef typename RandomAccessContainer::size_type size_type;\n-    typedef typename RandomAccessContainer::const_reference const_reference;\n-    typedef typename RandomAccessContainer::const_iterator const_iterator;\n-    typedef typename RandomAccessContainer::const_reverse_iterator\n-      const_reverse_iterator;\n+    typedef typename _RandomAccessContainer::size_type _Size_type;\n+    typedef typename _RandomAccessContainer::const_reference _Const_reference;\n+    typedef typename _RandomAccessContainer::const_iterator _Const_iterator;\n+    typedef typename _RandomAccessContainer::const_reverse_iterator\n+      _Const_reverse_iterator;\n \n-    void constraints() {\n-      function_requires< ReversibleContainerConcept<RandomAccessContainer> >();\n-      function_requires< RandomAccessIteratorConcept<const_iterator> >();\n-      function_requires< RandomAccessIteratorConcept<const_reverse_iterator> >();\n+    void __constraints() {\n+      __function_requires<\n+        _ReversibleContainerConcept<_RandomAccessContainer> >();\n+      __function_requires< _RandomAccessIteratorConcept<_Const_iterator> >();\n+      __function_requires<\n+        _RandomAccessIteratorConcept<_Const_reverse_iterator> >();\n \n-      const RandomAccessContainer c;\n-      const_reference r = c[n];\n-      ignore_unused_variable_warning(r);\n+      const _RandomAccessContainer __c;\n+      _Const_reference __r _IsUnused = __c[__n];\n     }\n-    size_type n;\n+    _Size_type __n;\n   };\n \n-  template <class RandomAccessContainer>\n-  struct Mutable_RandomAccessContainerConcept\n+  template <class _RandomAccessContainer>\n+  struct _Mutable_RandomAccessContainerConcept\n   {\n-    typedef typename RandomAccessContainer::size_type size_type;\n-    typedef typename RandomAccessContainer::reference reference;\n-    typedef typename RandomAccessContainer::iterator iterator;\n-    typedef typename RandomAccessContainer::reverse_iterator reverse_iterator;\n+    typedef typename _RandomAccessContainer::size_type _Size_type;\n+    typedef typename _RandomAccessContainer::reference _Reference;\n+    typedef typename _RandomAccessContainer::iterator _Iterator;\n+    typedef typename _RandomAccessContainer::reverse_iterator _Reverse_iterator;\n \n-    void constraints() {\n-      function_requires< RandomAccessContainerConcept<RandomAccessContainer> >();\n-      function_requires< Mutable_ReversibleContainerConcept<RandomAccessContainer> >();\n-      function_requires< Mutable_RandomAccessIteratorConcept<iterator> >();\n-      function_requires< Mutable_RandomAccessIteratorConcept<reverse_iterator> >();\n+    void __constraints() {\n+      __function_requires<\n+        _RandomAccessContainerConcept<_RandomAccessContainer> >();\n+      __function_requires<\n+        _Mutable_ReversibleContainerConcept<_RandomAccessContainer> >();\n+      __function_requires< _Mutable_RandomAccessIteratorConcept<_Iterator> >();\n+      __function_requires<\n+        _Mutable_RandomAccessIteratorConcept<_Reverse_iterator> >();\n \n-      reference r = c[i];\n-      ignore_unused_variable_warning(r);\n+      _Reference __r _IsUnused = __c[__i];\n     }\n-    size_type i;\n-    RandomAccessContainer c;\n+    _Size_type __i;\n+    _RandomAccessContainer __c;\n   };\n \n   // A Sequence is inherently mutable\n-  template <class Sequence>\n-  struct SequenceConcept\n+  template <class _Sequence>\n+  struct _SequenceConcept\n   {\n+    typedef typename _Sequence::reference _Reference;\n+    typedef typename _Sequence::const_reference _Const_reference;\n \n-    typedef typename Sequence::reference reference;\n-    typedef typename Sequence::const_reference const_reference;\n-\n-    void constraints() {\n+    void __constraints() {\n       // Matt Austern's book puts DefaultConstructible here, the C++\n       // standard places it in Container\n       //    function_requires< DefaultConstructible<Sequence> >();\n-      function_requires< Mutable_ForwardContainerConcept<Sequence> >();\n-      function_requires< DefaultConstructibleConcept<Sequence> >();\n+      __function_requires< _Mutable_ForwardContainerConcept<_Sequence> >();\n+      __function_requires< _DefaultConstructibleConcept<_Sequence> >();\n \n-      Sequence \n-        c(n),\n-        c2(n, t),\n-        c3(first, last);\n+      _Sequence \n+        __c(__n) _IsUnused,\n+        __c2(__n, __t) _IsUnused,\n+        __c3(__first, __last) _IsUnused;\n \n-      c.insert(p, t);\n-      c.insert(p, n, t);\n-      c.insert(p, first, last);\n+      __c.insert(__p, __t);\n+      __c.insert(__p, __n, __t);\n+      __c.insert(__p, __first, __last);\n \n-      c.erase(p);\n-      c.erase(p, q);\n+      __c.erase(__p);\n+      __c.erase(__p, __q);\n \n-      reference r = c.front();\n+      _Reference __r _IsUnused = __c.front();\n \n-      ignore_unused_variable_warning(c);\n-      ignore_unused_variable_warning(c2);\n-      ignore_unused_variable_warning(c3);\n-      ignore_unused_variable_warning(r);\n-      const_constraints(c);\n+      __const_constraints(__c);\n     }\n-    void const_constraints(const Sequence& c) {\n-      const_reference r = c.front();\n-      ignore_unused_variable_warning(r);\n+    void __const_constraints(const _Sequence& __c) {\n+      _Const_reference __r _IsUnused = __c.front();\n     }\n-    typename Sequence::value_type t;\n-    typename Sequence::size_type n;\n-    typename Sequence::value_type* first, *last;\n-    typename Sequence::iterator p, q;\n+    typename _Sequence::value_type __t;\n+    typename _Sequence::size_type __n;\n+    typename _Sequence::value_type *__first, *__last;\n+    typename _Sequence::iterator __p, __q;\n   };\n \n-  template <class FrontInsertionSequence>\n-  struct FrontInsertionSequenceConcept\n+  template <class _FrontInsertionSequence>\n+  struct _FrontInsertionSequenceConcept\n   {\n-    void constraints() {\n-      function_requires< SequenceConcept<FrontInsertionSequence> >();\n+    void __constraints() {\n+      __function_requires< _SequenceConcept<_FrontInsertionSequence> >();\n \n-      c.push_front(t);\n-      c.pop_front();\n+      __c.push_front(__t);\n+      __c.pop_front();\n     }\n-    FrontInsertionSequence c;\n-    typename FrontInsertionSequence::value_type t;\n+    _FrontInsertionSequence __c;\n+    typename _FrontInsertionSequence::value_type __t;\n   };\n \n-  template <class BackInsertionSequence>\n-  struct BackInsertionSequenceConcept\n+  template <class _BackInsertionSequence>\n+  struct _BackInsertionSequenceConcept\n   {\n-    typedef typename BackInsertionSequence::reference reference;\n-    typedef typename BackInsertionSequence::const_reference const_reference;\n+    typedef typename _BackInsertionSequence::reference _Reference;\n+    typedef typename _BackInsertionSequence::const_reference _Const_reference;\n \n-    void constraints() {\n-      function_requires< SequenceConcept<BackInsertionSequence> >();\n+    void __constraints() {\n+      __function_requires< _SequenceConcept<_BackInsertionSequence> >();\n \n-      c.push_back(t);\n-      c.pop_back();\n-      reference r = c.back();\n-      ignore_unused_variable_warning(r);\n+      __c.push_back(__t);\n+      __c.pop_back();\n+      _Reference __r _IsUnused = __c.back();\n     }\n-    void const_constraints(const BackInsertionSequence& c) {\n-      const_reference r = c.back();\n-      ignore_unused_variable_warning(r);\n+    void __const_constraints(const _BackInsertionSequence& __c) {\n+      _Const_reference __r _IsUnused = __c.back();\n     };\n-    BackInsertionSequence c;\n-    typename BackInsertionSequence::value_type t;\n+    _BackInsertionSequence __c;\n+    typename _BackInsertionSequence::value_type __t;\n   };\n \n-  template <class AssociativeContainer>\n-  struct AssociativeContainerConcept\n+  template <class _AssociativeContainer>\n+  struct _AssociativeContainerConcept\n   {\n-    void constraints() {\n-      function_requires< ForwardContainerConcept<AssociativeContainer> >();\n-      function_requires< DefaultConstructibleConcept<AssociativeContainer> >();\n+    void __constraints() {\n+      __function_requires< _ForwardContainerConcept<_AssociativeContainer> >();\n+      __function_requires<\n+        _DefaultConstructibleConcept<_AssociativeContainer> >();\n     \n-      i = c.find(k);\n-      r = c.equal_range(k);\n-      c.erase(k);\n-      c.erase(i);\n-      c.erase(r.first, r.second);\n-      const_constraints(c);\n-    }\n-    void const_constraints(const AssociativeContainer& c) {\n-      ci = c.find(k);\n-      n = c.count(k);\n-      cr = c.equal_range(k);\n-    }\n-    typedef typename AssociativeContainer::iterator iterator;\n-    typedef typename AssociativeContainer::const_iterator const_iterator;\n-\n-    AssociativeContainer c;\n-    iterator i;\n-    std::pair<iterator,iterator> r;\n-    const_iterator ci;\n-    std::pair<const_iterator,const_iterator> cr;\n-    typename AssociativeContainer::key_type k;\n-    typename AssociativeContainer::size_type n;\n-  };\n-\n-  template <class UniqueAssociativeContainer>\n-  struct UniqueAssociativeContainerConcept\n-  {\n-    void constraints() {\n-      function_requires< AssociativeContainerConcept<UniqueAssociativeContainer> >();\n+      __i = __c.find(__k);\n+      __r = __c.equal_range(__k);\n+      __c.erase(__k);\n+      __c.erase(__i);\n+      __c.erase(__r.first, __r.second);\n+      __const_constraints(__c);\n+    }\n+    void __const_constraints(const _AssociativeContainer& __c) {\n+      __ci = __c.find(__k);\n+      __n = __c.count(__k);\n+      __cr = __c.equal_range(__k);\n+    }\n+    typedef typename _AssociativeContainer::iterator _Iterator;\n+    typedef typename _AssociativeContainer::const_iterator _Const_iterator;\n+\n+    _AssociativeContainer __c;\n+    _Iterator __i;\n+    std::pair<_Iterator,_Iterator> __r;\n+    _Const_iterator __ci;\n+    std::pair<_Const_iterator,_Const_iterator> __cr;\n+    typename _AssociativeContainer::key_type __k;\n+    typename _AssociativeContainer::size_type __n;\n+  };\n+\n+  template <class _UniqueAssociativeContainer>\n+  struct _UniqueAssociativeContainerConcept\n+  {\n+    void __constraints() {\n+      __function_requires<\n+        _AssociativeContainerConcept<_UniqueAssociativeContainer> >();\n     \n-      UniqueAssociativeContainer c(first, last);\n+      _UniqueAssociativeContainer __c(__first, __last);\n       \n-      pos_flag = c.insert(t);\n-      c.insert(first, last);\n-\n-      ignore_unused_variable_warning(c);\n+      __pos_flag = __c.insert(__t);\n+      __c.insert(__first, __last);\n     }\n-    std::pair<typename UniqueAssociativeContainer::iterator, bool> pos_flag;\n-    typename UniqueAssociativeContainer::value_type t;\n-    typename UniqueAssociativeContainer::value_type* first, *last;\n+    std::pair<typename _UniqueAssociativeContainer::iterator, bool> __pos_flag;\n+    typename _UniqueAssociativeContainer::value_type __t;\n+    typename _UniqueAssociativeContainer::value_type *__first, *__last;\n   };\n \n-  template <class MultipleAssociativeContainer>\n-  struct MultipleAssociativeContainerConcept\n+  template <class _MultipleAssociativeContainer>\n+  struct _MultipleAssociativeContainerConcept\n   {\n-    void constraints() {\n-      function_requires< AssociativeContainerConcept<MultipleAssociativeContainer> >();\n+    void __constraints() {\n+      __function_requires<\n+        _AssociativeContainerConcept<_MultipleAssociativeContainer> >();\n \n-      MultipleAssociativeContainer c(first, last);\n+      _MultipleAssociativeContainer __c(__first, __last);\n       \n-      pos = c.insert(t);\n-      c.insert(first, last);\n+      __pos = __c.insert(__t);\n+      __c.insert(__first, __last);\n \n-      ignore_unused_variable_warning(c);\n-      ignore_unused_variable_warning(pos);\n     }\n-    typename MultipleAssociativeContainer::iterator pos;\n-    typename MultipleAssociativeContainer::value_type t;\n-    typename MultipleAssociativeContainer::value_type* first, *last;\n+    typename _MultipleAssociativeContainer::iterator __pos _IsUnused;\n+    typename _MultipleAssociativeContainer::value_type __t;\n+    typename _MultipleAssociativeContainer::value_type *__first, *__last;\n   };\n \n-  template <class SimpleAssociativeContainer>\n-  struct SimpleAssociativeContainerConcept\n+  template <class _SimpleAssociativeContainer>\n+  struct _SimpleAssociativeContainerConcept\n   {\n-    void constraints() {\n-      function_requires< AssociativeContainerConcept<SimpleAssociativeContainer> >();\n-      typedef typename SimpleAssociativeContainer::key_type key_type;\n-      typedef typename SimpleAssociativeContainer::value_type value_type;\n-      typedef typename require_same<key_type, value_type>::type req;\n+    void __constraints() {\n+      __function_requires<\n+        _AssociativeContainerConcept<_SimpleAssociativeContainer> >();\n+      typedef typename _SimpleAssociativeContainer::key_type _Key_type;\n+      typedef typename _SimpleAssociativeContainer::value_type _Value_type;\n+      typedef typename _Aux_require_same<_Key_type, _Value_type>::_Type\n+        _Requqired;\n     }\n   };\n \n-  template <class SimpleAssociativeContainer>\n-  struct PairAssociativeContainerConcept\n+  template <class _SimpleAssociativeContainer>\n+  struct _PairAssociativeContainerConcept\n   {\n-    void constraints() {\n-      function_requires< AssociativeContainerConcept<SimpleAssociativeContainer> >();\n-      typedef typename SimpleAssociativeContainer::key_type key_type;\n-      typedef typename SimpleAssociativeContainer::value_type value_type;\n-      typedef typename SimpleAssociativeContainer::mapped_type mapped_type;\n-      typedef std::pair<const key_type, mapped_type> required_value_type;\n-      typedef typename require_same<value_type, required_value_type>::type req;\n+    void __constraints() {\n+      __function_requires<\n+        _AssociativeContainerConcept<_SimpleAssociativeContainer> >();\n+      typedef typename _SimpleAssociativeContainer::key_type _Key_type;\n+      typedef typename _SimpleAssociativeContainer::value_type _Value_type;\n+      typedef typename _SimpleAssociativeContainer::mapped_type _Mapped_type;\n+      typedef std::pair<const _Key_type, _Mapped_type> _Required_value_type;\n+      typedef typename _Aux_require_same<_Value_type,\n+        _Required_value_type>::_Type _Required;\n     }\n   };\n \n-  template <class SortedAssociativeContainer>\n-  struct SortedAssociativeContainerConcept\n+  template <class _SortedAssociativeContainer>\n+  struct _SortedAssociativeContainerConcept\n   {\n-    void constraints() {\n-      function_requires< AssociativeContainerConcept<SortedAssociativeContainer> >();\n-      function_requires< ReversibleContainerConcept<SortedAssociativeContainer> >();\n+    void __constraints() {\n+      __function_requires<\n+        _AssociativeContainerConcept<_SortedAssociativeContainer> >();\n+      __function_requires<\n+        _ReversibleContainerConcept<_SortedAssociativeContainer> >();\n \n-      SortedAssociativeContainer \n-        c(kc),\n-        c2(first, last),\n-        c3(first, last, kc);\n+      _SortedAssociativeContainer \n+        __c(__kc) _IsUnused,\n+        __c2(__first, __last) _IsUnused,\n+        __c3(__first, __last, __kc) _IsUnused;\n \n-      p = c.upper_bound(k);\n-      p = c.lower_bound(k);\n-      r = c.equal_range(k);\n+      __p = __c.upper_bound(__k);\n+      __p = __c.lower_bound(__k);\n+      __r = __c.equal_range(__k);\n       \n-      c.insert(p, t);\n-      \n-      ignore_unused_variable_warning(c);\n-      ignore_unused_variable_warning(c2);\n-      ignore_unused_variable_warning(c3);\n-    }\n-    void const_constraints(const SortedAssociativeContainer& c) {\n-      kc = c.key_comp();\n-      vc = c.value_comp();\n-\n-      cp = c.upper_bound(k);\n-      cp = c.lower_bound(k);\n-      cr = c.equal_range(k);\n-    }\n-    typename SortedAssociativeContainer::key_compare kc;\n-    typename SortedAssociativeContainer::value_compare vc;\n-    typename SortedAssociativeContainer::value_type t;\n-    typename SortedAssociativeContainer::key_type k;\n-    typedef typename SortedAssociativeContainer::iterator iterator;\n-    typedef typename SortedAssociativeContainer::const_iterator const_iterator;\n-    iterator p;\n-    const_iterator cp;\n-    std::pair<iterator,iterator> r;\n-    std::pair<const_iterator,const_iterator> cr;\n-    typename SortedAssociativeContainer::value_type* first, *last;\n+      __c.insert(__p, __t);\n+    }\n+    void __const_constraints(const _SortedAssociativeContainer& __c) {\n+      __kc = __c.key_comp();\n+      __vc = __c.value_comp();\n+\n+      __cp = __c.upper_bound(__k);\n+      __cp = __c.lower_bound(__k);\n+      __cr = __c.equal_range(__k);\n+    }\n+    typename _SortedAssociativeContainer::key_compare __kc;\n+    typename _SortedAssociativeContainer::value_compare __vc;\n+    typename _SortedAssociativeContainer::value_type __t;\n+    typename _SortedAssociativeContainer::key_type __k;\n+    typedef typename _SortedAssociativeContainer::iterator _Iterator;\n+    typedef typename _SortedAssociativeContainer::const_iterator\n+      _Const_iterator;\n+\n+    _Iterator __p;\n+    _Const_iterator __cp;\n+    std::pair<_Iterator,_Iterator> __r;\n+    std::pair<_Const_iterator,_Const_iterator> __cr;\n+    typename _SortedAssociativeContainer::value_type *__first, *__last;\n   };\n \n   // HashedAssociativeContainer\n \n-} // namespace boost\n+} // namespace __gnu_cxx\n+\n+#undef _IsUnused\n+\n+#endif // _GLIBCPP_BOOST_CONCEPT_CHECK\n \n-#endif // BOOST_CONCEPT_CHECKS_HPP\n "}, {"sha": "79cf29c88299f63057a5d40b4e50adc366f6a8da", "filename": "libstdc++-v3/include/bits/concept_check.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fconcept_check.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -55,11 +55,11 @@\n #if defined(_GLIBCPP_NO_CONCEPT_CHECKS) || defined(_STL_NO_CONCEPT_CHECKS) \\\n     || defined(NDEBUG)\n \n-#define glibcpp_function_requires(...)\n-#define glibcpp_class_requires(a,b)\n-#define glibcpp_class_requires2(a,b,c)\n-#define glibcpp_class_requires3(a,b,c,d)\n-#define glibcpp_class_requires4(a,b,c,d,e)\n+#define __glibcpp_function_requires(...)\n+#define __glibcpp_class_requires(_a,_b)\n+#define __glibcpp_class_requires2(_a,_b,_c)\n+#define __glibcpp_class_requires3(_a,_b,_c,_d)\n+#define __glibcpp_class_requires4(_a,_b,_c,_d,_e)\n \n #else // the checks are on\n \n@@ -74,18 +74,18 @@\n // BinaryPredicateConcept.  The preprocessor tries to split things up on\n // the commas in the template argument list.  We can't use an inner pair of\n // parenthesis to hide the commas, because \"boost::(Temp<Foo,Bar>)\" isn't\n-// a valid instantiation pattern.\n-\n-#define glibcpp_function_requires(...)                         \\\n-            boost::function_requires< boost::__VA_ARGS__ >()\n-#define glibcpp_class_requires(a,C)                            \\\n-            BOOST_CLASS_REQUIRES(a, boost, C)\n-#define glibcpp_class_requires2(a,b,C)                         \\\n-            BOOST_CLASS_REQUIRES2(a, b, boost, C)\n-#define glibcpp_class_requires3(a,b,c,C)                       \\\n-            BOOST_CLASS_REQUIRES3(a, b, c, boost, C)\n-#define glibcpp_class_requires4(a,b,c,d,C)                     \\\n-            BOOST_CLASS_REQUIRES4(a, b, c, d, boost, C)\n+// a valid instantiation pattern.  Thus, we steal a feature from C99.\n+\n+#define __glibcpp_function_requires(...)                                 \\\n+            __gnu_cxx::__function_requires< __gnu_cxx::__VA_ARGS__ >()\n+#define __glibcpp_class_requires(_a,_C)                                  \\\n+            _GLIBCPP_CLASS_REQUIRES(_a, __gnu_cxx, _C)\n+#define __glibcpp_class_requires2(_a,_b,_C)                              \\\n+            _GLIBCPP_CLASS_REQUIRES2(_a, _b, __gnu_cxx, _C)\n+#define __glibcpp_class_requires3(_a,_b,_c,_C)                           \\\n+            _GLIBCPP_CLASS_REQUIRES3(_a, _b, _c, __gnu_cxx, _C)\n+#define __glibcpp_class_requires4(_a,_b,_c,_d,_C)                        \\\n+            _GLIBCPP_CLASS_REQUIRES4(_a, _b, _c, _d, __gnu_cxx, _C)\n \n #endif // enable/disable\n "}, {"sha": "721d9aae950fe01385e9f76c2f2fc1b3ada040d6", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 255, "deletions": 255, "changes": 510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -33,7 +33,7 @@\n \n #include <bits/stl_heap.h>\n \n-// See concept_check.h for the glibcpp_*_requires macros.\n+// See concept_check.h for the __glibcpp_*_requires macros.\n \n namespace std\n {\n@@ -44,7 +44,7 @@ template <class _Tp>\n inline const _Tp& __median(const _Tp& __a, const _Tp& __b, const _Tp& __c)\n {\n   // concept requirements\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n   if (__a < __b)\n     if (__b < __c)\n       return __b;\n@@ -65,7 +65,7 @@ inline const _Tp&\n __median(const _Tp& __a, const _Tp& __b, const _Tp& __c, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(BinaryFunctionConcept<_Compare, bool, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryFunctionConcept<_Compare, bool, _Tp, _Tp>);\n   if (__comp(__a, __b))\n     if (__comp(__b, __c))\n       return __b;\n@@ -86,7 +86,7 @@ template <class _InputIter, class _Function>\n _Function for_each(_InputIter __first, _InputIter __last, _Function __f)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n   for ( ; __first != __last; ++__first)\n     __f(*__first);\n   return __f;\n@@ -195,8 +195,8 @@ inline _InputIter find(_InputIter __first, _InputIter __last,\n                        const _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n             typename iterator_traits<_InputIter>::value_type, _Tp>);\n   return find(__first, __last, __val, __iterator_category(__first));\n }\n@@ -206,8 +206,8 @@ inline _InputIter find_if(_InputIter __first, _InputIter __last,\n                           _Predicate __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n           typename iterator_traits<_InputIter>::value_type>);\n   return find_if(__first, __last, __pred, __iterator_category(__first));\n }\n@@ -218,8 +218,8 @@ template <class _ForwardIter>\n _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n   \ttypename iterator_traits<_ForwardIter>::value_type>);\n   if (__first == __last)\n     return __last;\n@@ -237,8 +237,8 @@ _ForwardIter adjacent_find(_ForwardIter __first, _ForwardIter __last,\n                            _BinaryPredicate __binary_pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n         typename iterator_traits<_ForwardIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n   if (__first == __last)\n@@ -263,10 +263,10 @@ void count(_InputIter __first, _InputIter __last, const _Tp& __value,\n            _Size& __n)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter>::value_type >);\n-  glibcpp_function_requires(EqualityComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<_Tp>);\n   for ( ; __first != __last; ++__first)\n     if (*__first == __value)\n       ++__n;\n@@ -277,8 +277,8 @@ void count_if(_InputIter __first, _InputIter __last, _Predicate __pred,\n               _Size& __n)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_InputIter>::value_type>);\n   for ( ; __first != __last; ++__first)\n     if (__pred(*__first))\n@@ -290,10 +290,10 @@ typename iterator_traits<_InputIter>::difference_type\n count(_InputIter __first, _InputIter __last, const _Tp& __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter>::value_type >);\n-  glibcpp_function_requires(EqualityComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<_Tp>);\n   typename iterator_traits<_InputIter>::difference_type __n = 0;\n   for ( ; __first != __last; ++__first)\n     if (*__first == __value)\n@@ -306,8 +306,8 @@ typename iterator_traits<_InputIter>::difference_type\n count_if(_InputIter __first, _InputIter __last, _Predicate __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_InputIter>::value_type>);\n   typename iterator_traits<_InputIter>::difference_type __n = 0;\n   for ( ; __first != __last; ++__first)\n@@ -324,9 +324,9 @@ _ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                      _ForwardIter2 __first2, _ForwardIter2 __last2) \n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n \n@@ -376,9 +376,9 @@ _ForwardIter1 search(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                      _BinaryPred  __predicate) \n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPred,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPred,\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n \n@@ -437,10 +437,10 @@ _ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,\n                       _Integer __count, const _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(EqualityComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<_Tp>);\n \n   if (__count <= 0)\n     return __first;\n@@ -469,8 +469,8 @@ _ForwardIter search_n(_ForwardIter __first, _ForwardIter __last,\n                       _BinaryPred __binary_pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPred,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPred,\n         typename iterator_traits<_ForwardIter>::value_type, _Tp>);\n \n   if (__count <= 0)\n@@ -511,12 +511,12 @@ _ForwardIter2 swap_ranges(_ForwardIter1 __first1, _ForwardIter1 __last1,\n                           _ForwardIter2 __first2)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_ForwardIter2>::value_type,\n         typename iterator_traits<_ForwardIter1>::value_type>);\n \n@@ -532,8 +532,8 @@ _OutputIter transform(_InputIter __first, _InputIter __last,\n                       _OutputIter __result, _UnaryOperation __unary_op)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n \n   for ( ; __first != __last; ++__first, ++__result)\n@@ -548,10 +548,10 @@ _OutputIter transform(_InputIter1 __first1, _InputIter1 __last1,\n                       _BinaryOperation __binary_op)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n-        // XXX really should be \"the type returned by _BinaryOperation\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n+        // XXX really should be \"the type returned by _BinaryOperation\"\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)\n@@ -566,10 +566,10 @@ void replace(_ForwardIter __first, _ForwardIter __last,\n              const _Tp& __old_value, const _Tp& __new_value)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_ForwardIter>::value_type, _Tp>);\n-  glibcpp_function_requires(ConvertibleConcept<_Tp,\n+  __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   for ( ; __first != __last; ++__first)\n@@ -582,10 +582,10 @@ void replace_if(_ForwardIter __first, _ForwardIter __last,\n                 _Predicate __pred, const _Tp& __new_value)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(ConvertibleConcept<_Tp,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   for ( ; __first != __last; ++__first)\n@@ -599,10 +599,10 @@ _OutputIter replace_copy(_InputIter __first, _InputIter __last,\n                          const _Tp& __old_value, const _Tp& __new_value)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_InputIter>::value_type, _Tp>);\n \n   for ( ; __first != __last; ++__first, ++__result)\n@@ -616,10 +616,10 @@ _OutputIter replace_copy_if(_InputIter __first, _InputIter __last,\n                             _Predicate __pred, const _Tp& __new_value)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_InputIter>::value_type>);\n \n   for ( ; __first != __last; ++__first, ++__result)\n@@ -633,8 +633,8 @@ template <class _ForwardIter, class _Generator>\n void generate(_ForwardIter __first, _ForwardIter __last, _Generator __gen)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(GeneratorConcept<_Generator,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_GeneratorConcept<_Generator,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   for ( ; __first != __last; ++__first)\n@@ -646,7 +646,7 @@ _OutputIter generate_n(_OutputIter __first, _Size __n, _Generator __gen)\n {\n /*\n   // XXX concept requirements\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         \"the return type of _Generator\" ??   >);\n */\n \n@@ -662,10 +662,10 @@ _OutputIter remove_copy(_InputIter __first, _InputIter __last,\n                         _OutputIter __result, const _Tp& __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_InputIter>::value_type, _Tp>);\n \n   for ( ; __first != __last; ++__first)\n@@ -681,10 +681,10 @@ _OutputIter remove_copy_if(_InputIter __first, _InputIter __last,\n                            _OutputIter __result, _Predicate __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_InputIter>::value_type>);\n \n   for ( ; __first != __last; ++__first)\n@@ -700,10 +700,10 @@ _ForwardIter remove(_ForwardIter __first, _ForwardIter __last,\n                     const _Tp& __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(ConvertibleConcept<_Tp,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_ForwardIter>::value_type, _Tp>);\n \n   __first = find(__first, __last, __value);\n@@ -717,8 +717,8 @@ _ForwardIter remove_if(_ForwardIter __first, _ForwardIter __last,\n                        _Predicate __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   __first = find_if(__first, __last, __pred);\n@@ -770,10 +770,10 @@ inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,\n                                _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -788,7 +788,7 @@ _OutputIter __unique_copy(_InputIter __first, _InputIter __last,\n                           _BinaryPredicate __binary_pred, _Tp*)\n {\n   // concept requirements -- iterators already checked\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate, _Tp, _Tp>);\n \n   _Tp __value = *__first;\n   *__result = __value;\n@@ -818,7 +818,7 @@ _ForwardIter __unique_copy(_InputIter __first, _InputIter __last,\n                            forward_iterator_tag)\n {\n   // concept requirements -- iterators already checked\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n         typename iterator_traits<_ForwardIter>::value_type,\n         typename iterator_traits<_InputIter>::value_type>);\n \n@@ -834,8 +834,8 @@ inline _OutputIter unique_copy(_InputIter __first, _InputIter __last,\n                                _BinaryPredicate __binary_pred)\n {\n   // concept requirements -- predicates checked later\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -847,8 +847,8 @@ template <class _ForwardIter>\n _ForwardIter unique(_ForwardIter __first, _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   __first = adjacent_find(__first, __last);\n@@ -860,8 +860,8 @@ _ForwardIter unique(_ForwardIter __first, _ForwardIter __last,\n                     _BinaryPredicate __binary_pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n         typename iterator_traits<_ForwardIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n@@ -892,7 +892,7 @@ template <class _BidirectionalIter>\n inline void reverse(_BidirectionalIter __first, _BidirectionalIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_BidirectionalIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n         _BidirectionalIter>);\n   __reverse(__first, __last, __iterator_category(__first));\n }\n@@ -903,8 +903,8 @@ _OutputIter reverse_copy(_BidirectionalIter __first,\n                          _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n   while (__first != __last) {\n@@ -972,7 +972,7 @@ _BidirectionalIter __rotate(_BidirectionalIter __first,\n                             bidirectional_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_BidirectionalIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n         _BidirectionalIter>);\n \n   if (__first == __middle)\n@@ -1003,7 +1003,7 @@ _RandomAccessIter __rotate(_RandomAccessIter __first,\n                            _Distance *, _Tp *)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n \n   _Distance __n = __last   - __first;\n@@ -1061,7 +1061,7 @@ inline _ForwardIter rotate(_ForwardIter __first, _ForwardIter __middle,\n                            _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n \n   return __rotate(__first, __middle, __last,\n                   __distance_type(__first),\n@@ -1073,8 +1073,8 @@ _OutputIter rotate_copy(_ForwardIter __first, _ForwardIter __middle,\n                         _ForwardIter __last, _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   return copy(__first, __middle, copy(__middle, __last, __result));\n@@ -1100,7 +1100,7 @@ inline void random_shuffle(_RandomAccessIter __first,\n                            _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n \n   if (__first == __last) return;\n@@ -1113,7 +1113,7 @@ void random_shuffle(_RandomAccessIter __first, _RandomAccessIter __last,\n                     _RandomNumberGenerator& __rand)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n \n   if (__first == __last) return;\n@@ -1128,8 +1128,8 @@ _OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,\n                             _OutputIter __out, const _Distance __n)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   _Distance __remaining = 0;\n@@ -1156,10 +1156,10 @@ _OutputIter random_sample_n(_ForwardIter __first, _ForwardIter __last,\n                             _RandomNumberGenerator& __rand)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(UnaryFunctionConcept<\n+  __glibcpp_function_requires(_UnaryFunctionConcept<\n         _RandomNumberGenerator, _Distance, _Distance>);\n \n   _Distance __remaining = 0;\n@@ -1208,7 +1208,7 @@ _RandomAccessIter __random_sample(_InputIter __first, _InputIter __last,\n                                   const _Distance __n)\n {\n   // concept requirements\n-  glibcpp_function_requires(UnaryFunctionConcept<\n+  __glibcpp_function_requires(_UnaryFunctionConcept<\n         _RandomNumberGenerator, _Distance, _Distance>);\n \n   _Distance __m = 0;\n@@ -1233,8 +1233,8 @@ random_sample(_InputIter __first, _InputIter __last,\n               _RandomAccessIter __out_first, _RandomAccessIter __out_last) \n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n \n   return __random_sample(__first, __last,\n@@ -1250,8 +1250,8 @@ random_sample(_InputIter __first, _InputIter __last,\n               _RandomNumberGenerator& __rand) \n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n \n   return __random_sample(__first, __last,\n@@ -1316,8 +1316,8 @@ inline _ForwardIter partition(_ForwardIter __first,\n \t\t\t      _Predicate   __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   return __partition(__first, __last, __pred, __iterator_category(__first));\n@@ -1397,8 +1397,8 @@ inline _ForwardIter stable_partition(_ForwardIter __first,\n                                      _Predicate __pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(UnaryPredicateConcept<_Predicate,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_UnaryPredicateConcept<_Predicate,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   if (__first == __last)\n@@ -1630,9 +1630,9 @@ template <class _RandomAccessIter>\n inline void sort(_RandomAccessIter __first, _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n   if (__first != __last) {\n@@ -1648,9 +1648,9 @@ inline void sort(_RandomAccessIter __first, _RandomAccessIter __last,\n                  _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_RandomAccessIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -1881,9 +1881,9 @@ inline void stable_sort(_RandomAccessIter __first,\n                         _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n   __stable_sort_aux(__first, __last,\n@@ -1896,9 +1896,9 @@ inline void stable_sort(_RandomAccessIter __first,\n                         _RandomAccessIter __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_RandomAccessIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -1928,9 +1928,9 @@ inline void partial_sort(_RandomAccessIter __first,\n                          _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n   __partial_sort(__first, __middle, __last, __value_type(__first));\n@@ -1954,9 +1954,9 @@ inline void partial_sort(_RandomAccessIter __first,\n                          _RandomAccessIter __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_RandomAccessIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -1997,13 +1997,13 @@ partial_sort_copy(_InputIter __first, _InputIter __last,\n                   _RandomAccessIter __result_last)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_InputIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter>::value_type>);\n \n   return __partial_sort_copy(__first, __last, __result_first, __result_last, \n@@ -2046,13 +2046,13 @@ partial_sort_copy(_InputIter __first, _InputIter __last,\n                   _RandomAccessIter __result_last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_InputIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_RandomAccessIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -2087,9 +2087,9 @@ inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n                         _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n   __nth_element(__first, __nth, __last, __value_type(__first));\n@@ -2120,9 +2120,9 @@ inline void nth_element(_RandomAccessIter __first, _RandomAccessIter __nth,\n                         _RandomAccessIter __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_RandomAccessIter>::value_type,\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -2161,10 +2161,10 @@ inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,\n \t\t\t\tconst _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n \n   return __lower_bound(__first, __last, __val,\n                        __distance_type(__first));\n@@ -2199,10 +2199,10 @@ inline _ForwardIter lower_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n \n   return __lower_bound(__first, __last, __val, __comp,\n                        __distance_type(__first));\n@@ -2237,10 +2237,10 @@ inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n \n   return __upper_bound(__first, __last, __val,\n                        __distance_type(__first));\n@@ -2275,10 +2275,10 @@ inline _ForwardIter upper_bound(_ForwardIter __first, _ForwardIter __last,\n                                 const _Tp& __val, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n \n   return __upper_bound(__first, __last, __val, __comp,\n                        __distance_type(__first));\n@@ -2320,10 +2320,10 @@ inline pair<_ForwardIter, _ForwardIter>\n equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n \n   return __equal_range(__first, __last, __val,\n                        __distance_type(__first));\n@@ -2366,10 +2366,10 @@ equal_range(_ForwardIter __first, _ForwardIter __last, const _Tp& __val,\n             _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n \n   return __equal_range(__first, __last, __val, __comp,\n                        __distance_type(__first));\n@@ -2380,10 +2380,10 @@ bool binary_search(_ForwardIter __first, _ForwardIter __last,\n                    const _Tp& __val)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n \n   _ForwardIter __i = lower_bound(__first, __last, __val);\n   return __i != __last && !(__val < *__i);\n@@ -2395,10 +2395,10 @@ bool binary_search(_ForwardIter __first, _ForwardIter __last,\n                    _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(SameTypeConcept<_Tp,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_SameTypeConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _Tp>);\n \n   _ForwardIter __i = lower_bound(__first, __last, __val, __comp);\n   return __i != __last && !__comp(__val, *__i);\n@@ -2412,14 +2412,14 @@ _OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,\n                   _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2) {\n@@ -2443,14 +2443,14 @@ _OutputIter merge(_InputIter1 __first1, _InputIter1 __last1,\n                   _OutputIter __result, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -2762,9 +2762,9 @@ inline void inplace_merge(_BidirectionalIter __first,\n                           _BidirectionalIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_BidirectionalIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n         _BidirectionalIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n   if (__first == __middle || __middle == __last)\n@@ -2779,9 +2779,9 @@ inline void inplace_merge(_BidirectionalIter __first,\n                           _BidirectionalIter __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_BidirectionalIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<\n         _BidirectionalIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_BidirectionalIter>::value_type,\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n@@ -2802,12 +2802,12 @@ bool includes(_InputIter1 __first1, _InputIter1 __last1,\n               _InputIter2 __first2, _InputIter2 __last2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2)\n@@ -2826,12 +2826,12 @@ bool includes(_InputIter1 __first1, _InputIter1 __last1,\n               _InputIter2 __first2, _InputIter2 __last2, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -2852,14 +2852,14 @@ _OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,\n                       _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2) {\n@@ -2888,14 +2888,14 @@ _OutputIter set_union(_InputIter1 __first1, _InputIter1 __last1,\n                       _OutputIter __result, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -2924,14 +2924,14 @@ _OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,\n                              _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2) \n@@ -2955,14 +2955,14 @@ _OutputIter set_intersection(_InputIter1 __first1, _InputIter1 __last1,\n                              _OutputIter __result, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -2986,14 +2986,14 @@ _OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,\n                            _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2)\n@@ -3018,14 +3018,14 @@ _OutputIter set_difference(_InputIter1 __first1, _InputIter1 __last1,\n                            _OutputIter __result, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -3051,14 +3051,14 @@ set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n                          _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n \n   while (__first1 != __last1 && __first2 != __last2)\n@@ -3088,14 +3088,14 @@ set_symmetric_difference(_InputIter1 __first1, _InputIter1 __last1,\n                          _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(SameTypeConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_SameTypeConcept<\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_InputIter1>::value_type,\n         typename iterator_traits<_InputIter2>::value_type>);\n \n@@ -3124,8 +3124,8 @@ template <class _ForwardIter>\n _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   if (__first == __last) return __first;\n@@ -3141,8 +3141,8 @@ _ForwardIter max_element(_ForwardIter __first, _ForwardIter __last,\n \t\t\t _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_ForwardIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n@@ -3157,8 +3157,8 @@ template <class _ForwardIter>\n _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   if (__first == __last) return __first;\n@@ -3174,8 +3174,8 @@ _ForwardIter min_element(_ForwardIter __first, _ForwardIter __last,\n \t\t\t _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_ForwardIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n@@ -3194,8 +3194,8 @@ template <class _BidirectionalIter>\n bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n   if (__first == __last)\n@@ -3230,8 +3230,8 @@ bool next_permutation(_BidirectionalIter __first, _BidirectionalIter __last,\n                       _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_BidirectionalIter>::value_type,\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n@@ -3266,8 +3266,8 @@ template <class _BidirectionalIter>\n bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n   if (__first == __last)\n@@ -3302,8 +3302,8 @@ bool prev_permutation(_BidirectionalIter __first, _BidirectionalIter __last,\n                       _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_Compare,\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_Compare,\n         typename iterator_traits<_BidirectionalIter>::value_type,\n         typename iterator_traits<_BidirectionalIter>::value_type>);\n \n@@ -3341,9 +3341,9 @@ _InputIter find_first_of(_InputIter __first1, _InputIter __last1,\n                          _ForwardIter __first2, _ForwardIter __last2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_InputIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n@@ -3360,12 +3360,12 @@ _InputIter find_first_of(_InputIter __first1, _InputIter __last1,\n                          _BinaryPredicate __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_InputIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate,\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n         typename iterator_traits<_InputIter>::value_type,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n@@ -3439,8 +3439,8 @@ __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n            bidirectional_iterator_tag, bidirectional_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter1>);\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter2>);\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter1>);\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter2>);\n \n   typedef reverse_iterator<_BidirectionalIter1> _RevIter1;\n   typedef reverse_iterator<_BidirectionalIter2> _RevIter2;\n@@ -3468,8 +3468,8 @@ __find_end(_BidirectionalIter1 __first1, _BidirectionalIter1 __last1,\n            _BinaryPredicate __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter1>);\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIter2>);\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter1>);\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIter2>);\n \n   typedef reverse_iterator<_BidirectionalIter1> _RevIter1;\n   typedef reverse_iterator<_BidirectionalIter2> _RevIter2;\n@@ -3497,9 +3497,9 @@ find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n          _ForwardIter2 __first2, _ForwardIter2 __last2)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(EqualOpConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_EqualOpConcept<\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n \n@@ -3516,9 +3516,9 @@ find_end(_ForwardIter1 __first1, _ForwardIter1 __last1,\n          _BinaryPredicate __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_BinaryPredicate,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n \n@@ -3563,8 +3563,8 @@ template <class _RandomAccessIter>\n inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(RandomAccessIteratorConcept<_RandomAccessIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n   return __is_heap(__first, __last - __first);\n@@ -3576,8 +3576,8 @@ inline bool is_heap(_RandomAccessIter __first, _RandomAccessIter __last,\n                     _StrictWeakOrdering __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(RandomAccessIteratorConcept<_RandomAccessIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_StrictWeakOrdering,\n+  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n         typename iterator_traits<_RandomAccessIter>::value_type, \n         typename iterator_traits<_RandomAccessIter>::value_type>);\n \n@@ -3592,8 +3592,8 @@ template <class _ForwardIter>\n bool is_sorted(_ForwardIter __first, _ForwardIter __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   if (__first == __last)\n@@ -3613,8 +3613,8 @@ bool is_sorted(_ForwardIter __first, _ForwardIter __last,\n                _StrictWeakOrdering __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(BinaryPredicateConcept<_StrictWeakOrdering,\n+  __glibcpp_function_requires(_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n         typename iterator_traits<_ForwardIter>::value_type, \n         typename iterator_traits<_ForwardIter>::value_type>);\n "}, {"sha": "a70da2db8717191bb10b6b90fd0dc799902bc429", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -68,12 +68,12 @@ template <class _ForwardIter1, class _ForwardIter2>\n inline void iter_swap(_ForwardIter1 __a, _ForwardIter2 __b)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter1>);\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter2>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter1>);\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter2>);\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_ForwardIter1>::value_type,\n         typename iterator_traits<_ForwardIter2>::value_type>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_ForwardIter2>::value_type,\n         typename iterator_traits<_ForwardIter1>::value_type>);\n \n@@ -84,7 +84,7 @@ template <class _Tp>\n inline void swap(_Tp& __a, _Tp& __b)\n {\n   // concept requirements\n-  glibcpp_function_requires(SGIAssignableConcept<_Tp>);\n+  __glibcpp_function_requires(_SGIAssignableConcept<_Tp>);\n \n   _Tp __tmp = __a;\n   __a = __b;\n@@ -100,15 +100,15 @@ inline void swap(_Tp& __a, _Tp& __b)\n template <class _Tp>\n inline const _Tp& min(const _Tp& __a, const _Tp& __b) {\n   // concept requirements\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n   //return __b < __a ? __b : __a;\n   if (__b < __a) return __b; return __a;\n }\n \n template <class _Tp>\n inline const _Tp& max(const _Tp& __a, const _Tp& __b) {\n   // concept requirements\n-  glibcpp_function_requires(LessThanComparableConcept<_Tp>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<_Tp>);\n   //return  __a < __b ? __b : __a;\n   if (__a < __b) return __b; return __a;\n }\n@@ -244,8 +244,8 @@ inline _OutputIter copy(_InputIter __first, _InputIter __last,\n                         _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n \n    typedef typename _Is_normal_iterator<_InputIter>::_Normal __Normal;\n@@ -362,9 +362,9 @@ template <typename _BI1, typename _BI2>\n inline _BI2 copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(BidirectionalIteratorConcept<_BI1>);\n-  glibcpp_function_requires(Mutable_BidirectionalIteratorConcept<_BI2>);\n-  glibcpp_function_requires(ConvertibleConcept<\n+  __glibcpp_function_requires(_BidirectionalIteratorConcept<_BI1>);\n+  __glibcpp_function_requires(_Mutable_BidirectionalIteratorConcept<_BI2>);\n+  __glibcpp_function_requires(_ConvertibleConcept<\n         typename iterator_traits<_BI1>::value_type,\n         typename iterator_traits<_BI2>::value_type>);\n \n@@ -409,8 +409,8 @@ inline pair<_InputIter, _OutputIter>\n copy_n(_InputIter __first, _Size __count, _OutputIter __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,\n         typename iterator_traits<_InputIter>::value_type>);\n \n   return __copy_n(__first, __count, __result);\n@@ -424,7 +424,7 @@ template <class _ForwardIter, class _Tp>\n void fill(_ForwardIter __first, _ForwardIter __last, const _Tp& __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n \n   for ( ; __first != __last; ++__first)\n     *__first = __value;\n@@ -434,7 +434,7 @@ template <class _OutputIter, class _Size, class _Tp>\n _OutputIter fill_n(_OutputIter __first, _Size __n, const _Tp& __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIter,_Tp>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIter,_Tp>);\n \n   for ( ; __n > 0; --__n, ++__first)\n     *__first = __value;\n@@ -496,11 +496,11 @@ pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n                                         _InputIter2 __first2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter2>::value_type>);\n \n   while (__first1 != __last1 && *__first1 == *__first2) {\n@@ -517,8 +517,8 @@ pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,\n                                         _BinaryPredicate __binary_pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n \n   while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {\n     ++__first1;\n@@ -532,11 +532,11 @@ inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(EqualityComparableConcept<\n+  __glibcpp_function_requires(_EqualityComparableConcept<\n         typename iterator_traits<_InputIter2>::value_type>);\n \n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n@@ -550,8 +550,8 @@ inline bool equal(_InputIter1 __first1, _InputIter1 __last1,\n                   _InputIter2 __first2, _BinaryPredicate __binary_pred)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n \n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     if (!__binary_pred(*__first1, *__first2))\n@@ -568,11 +568,11 @@ bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n                              _InputIter2 __first2, _InputIter2 __last2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter2>::value_type>);\n \n   for ( ; __first1 != __last1 && __first2 != __last2\n@@ -591,8 +591,8 @@ bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,\n                              _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n \n   for ( ; __first1 != __last1 && __first2 != __last2\n         ; ++__first1, ++__first2) {\n@@ -688,11 +688,11 @@ int lexicographical_compare_3way(_InputIter1 __first1, _InputIter1 __last1,\n                                  _InputIter2 __first2, _InputIter2 __last2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter2>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter2>);\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter1>::value_type>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_InputIter2>::value_type>);\n \n   return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);"}, {"sha": "25fd6682a2d6357ba159aca8abffc3f65a6b58ce", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -357,7 +357,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n class deque : protected _Deque_base<_Tp, _Alloc> {\n \n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n \n   typedef _Deque_base<_Tp, _Alloc> _Base;\n public:                         // Basic types"}, {"sha": "0770d7cf2aa2d02fc4dceb64289b1ea8f357dbf4", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -63,9 +63,9 @@ inline void\n push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIterator>::value_type>);\n \n   __push_heap_aux(__first, __last,\n@@ -104,7 +104,7 @@ push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n \n   __push_heap_aux(__first, __last, __comp,\n@@ -155,9 +155,9 @@ inline void pop_heap(_RandomAccessIterator __first,\n                      _RandomAccessIterator __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIterator>::value_type>);\n \n   __pop_heap_aux(__first, __last, __value_type(__first));\n@@ -212,7 +212,7 @@ pop_heap(_RandomAccessIterator __first,\n          _RandomAccessIterator __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n \n   __pop_heap_aux(__first, __last, __value_type(__first), __comp);\n@@ -239,9 +239,9 @@ inline void\n make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIterator>::value_type>);\n \n   __make_heap(__first, __last,\n@@ -272,7 +272,7 @@ make_heap(_RandomAccessIterator __first,\n           _RandomAccessIterator __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n \n   __make_heap(__first, __last, __comp,\n@@ -283,9 +283,9 @@ template <class _RandomAccessIterator>\n void sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n-  glibcpp_function_requires(LessThanComparableConcept<\n+  __glibcpp_function_requires(_LessThanComparableConcept<\n         typename iterator_traits<_RandomAccessIterator>::value_type>);\n \n   while (__last - __first > 1)\n@@ -298,7 +298,7 @@ sort_heap(_RandomAccessIterator __first,\n           _RandomAccessIterator __last, _Compare __comp)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_RandomAccessIteratorConcept<\n+  __glibcpp_function_requires(_Mutable_RandomAccessIteratorConcept<\n         _RandomAccessIterator>);\n \n   while (__last - __first > 1)"}, {"sha": "5288eda03f1118bd6b05885a3b22701d1378b465", "filename": "libstdc++-v3/include/bits/stl_iterator_base_funcs.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_iterator_base_funcs.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -51,7 +51,7 @@ inline void __distance(_InputIterator __first, _InputIterator __last,\n                        _Distance& __n, input_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n   while (__first != __last) { ++__first; ++__n; }\n }\n \n@@ -61,7 +61,7 @@ inline void __distance(_RandomAccessIterator __first,\n                        _Distance& __n, random_access_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(RandomAccessIteratorConcept<_RandomAccessIterator>);\n+  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n   __n += __last - __first;\n }\n \n@@ -78,7 +78,7 @@ inline typename iterator_traits<_InputIterator>::difference_type\n __distance(_InputIterator __first, _InputIterator __last, input_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n   typename iterator_traits<_InputIterator>::difference_type __n = 0;\n   while (__first != __last) {\n     ++__first; ++__n;\n@@ -92,7 +92,7 @@ __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,\n            random_access_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(RandomAccessIteratorConcept<_RandomAccessIterator>);\n+  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n   return __last - __first;\n }\n \n@@ -110,7 +110,7 @@ template <class _InputIter, class _Distance>\n inline void __advance(_InputIter& __i, _Distance __n, input_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIter>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIter>);\n   while (__n--) ++__i;\n }\n \n@@ -119,7 +119,7 @@ inline void __advance(_BidirectionalIterator& __i, _Distance __n,\n                       bidirectional_iterator_tag)\n {\n   // concept requirements\n-glibcpp_function_requires(BidirectionalIteratorConcept<_BidirectionalIterator>);\n+__glibcpp_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>);\n   if (__n >= 0)\n     while (__n--) ++__i;\n   else\n@@ -131,7 +131,7 @@ inline void __advance(_RandomAccessIterator& __i, _Distance __n,\n                       random_access_iterator_tag)\n {\n   // concept requirements\n-  glibcpp_function_requires(RandomAccessIteratorConcept<_RandomAccessIterator>);\n+  __glibcpp_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>);\n   __i += __n;\n }\n "}, {"sha": "d837556cc9f5f574c44a2d6b4627e2647ca62148", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -201,7 +201,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n class list : protected _List_base<_Tp, _Alloc>\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n \n   typedef _List_base<_Tp, _Alloc> _Base;\n protected:"}, {"sha": "f1024fa2f5b1d69b0e98face7ab747dcb5ca2021", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -41,8 +41,8 @@ template <class _Key, class _Tp, class _Compare = less<_Key>,\n class map\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires4(_Compare, bool, _Key, _Key, BinaryFunctionConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n \n public:\n   // typedefs:"}, {"sha": "c35708eb591f47e33d53818c8210343aa730bb6c", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -55,8 +55,8 @@ template <class _Key, class _Tp, class _Compare, class _Alloc>\n class multimap\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires4(_Compare, bool, _Key, _Key, BinaryFunctionConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n \n public:\n "}, {"sha": "bb4e5a98108eff05928b2465a259f95486d1ba8d", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -54,8 +54,8 @@ template <class _Key, class _Compare, class _Alloc>\n class multiset\n {\n   // concept requirements\n-  glibcpp_class_requires(_Key, SGIAssignableConcept);\n-  glibcpp_class_requires4(_Compare, bool, _Key, _Key, BinaryFunctionConcept);\n+  __glibcpp_class_requires(_Key, _SGIAssignableConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n \n public:\n "}, {"sha": "ccafd374488931015ca9c394d55e781e20a3b4d5", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -39,7 +39,7 @@ template <class _InputIterator, class _Tp>\n _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n \n   for ( ; __first != __last; ++__first)\n     __init = __init + *__first;\n@@ -51,7 +51,7 @@ _Tp accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n               _BinaryOperation __binary_op)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n \n   for ( ; __first != __last; ++__first)\n     __init = __binary_op(__init, *__first);\n@@ -63,8 +63,8 @@ _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n                  _InputIterator2 __first2, _Tp __init)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator2>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n \n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     __init = __init + (*__first1 * *__first2);\n@@ -79,8 +79,8 @@ _Tp inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n                  _BinaryOperation2 __binary_op2)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator1>);\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator2>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator1>);\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator2>);\n \n   for ( ; __first1 != __last1; ++__first1, ++__first2)\n     __init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n@@ -106,8 +106,8 @@ partial_sum(_InputIterator __first, _InputIterator __last,\n             _OutputIterator __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIterator,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n         typename iterator_traits<_InputIterator>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -135,8 +135,8 @@ partial_sum(_InputIterator __first, _InputIterator __last,\n             _OutputIterator __result, _BinaryOperation __binary_op)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIterator,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n         typename iterator_traits<_InputIterator>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -165,8 +165,8 @@ adjacent_difference(_InputIterator __first,\n                     _InputIterator __last, _OutputIterator __result)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIterator,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n         typename iterator_traits<_InputIterator>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -196,8 +196,8 @@ adjacent_difference(_InputIterator __first, _InputIterator __last,\n                     _OutputIterator __result, _BinaryOperation __binary_op)\n {\n   // concept requirements\n-  glibcpp_function_requires(InputIteratorConcept<_InputIterator>);\n-  glibcpp_function_requires(OutputIteratorConcept<_OutputIterator,\n+  __glibcpp_function_requires(_InputIteratorConcept<_InputIterator>);\n+  __glibcpp_function_requires(_OutputIteratorConcept<_OutputIterator,\n         typename iterator_traits<_InputIterator>::value_type>);\n \n   if (__first == __last) return __result;\n@@ -262,8 +262,8 @@ void\n iota(_ForwardIter __first, _ForwardIter __last, _Tp __value)\n {\n   // concept requirements\n-  glibcpp_function_requires(Mutable_ForwardIteratorConcept<_ForwardIter>);\n-  glibcpp_function_requires(ConvertibleConcept<_Tp,\n+  __glibcpp_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIter>);\n+  __glibcpp_function_requires(_ConvertibleConcept<_Tp,\n         typename iterator_traits<_ForwardIter>::value_type>);\n \n   while (__first != __last)"}, {"sha": "ad27ba72db9af966be56f359024a47d57e178c5f", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -53,11 +53,11 @@ template <class _Tp, class _Sequence>\n class queue\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires(_Sequence, FrontInsertionSequenceConcept);\n-  glibcpp_class_requires(_Sequence, BackInsertionSequenceConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires(_Sequence, _FrontInsertionSequenceConcept);\n+  __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept);\n   typedef typename _Sequence::value_type _Sequence_value_type;\n-  glibcpp_class_requires2(_Tp, _Sequence_value_type, SameTypeConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n \n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const queue<_Tp1, _Seq1>&,\n@@ -136,12 +136,12 @@ template <class _Tp,\n class priority_queue\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires(_Sequence, SequenceConcept);\n-  glibcpp_class_requires(_Sequence, RandomAccessContainerConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires(_Sequence, _SequenceConcept);\n+  __glibcpp_class_requires(_Sequence, _RandomAccessContainerConcept);\n   typedef typename _Sequence::value_type _Sequence_value_type;\n-  glibcpp_class_requires2(_Tp, _Sequence_value_type, SameTypeConcept);\n-  glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, BinaryFunctionConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept);\n \n public:\n   typedef typename _Sequence::value_type      value_type;"}, {"sha": "3cfffb4b9d03a5e3ab608d32dfc2db950480a73a", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -55,8 +55,8 @@ template <class _Key, class _Compare, class _Alloc>\n class set\n {\n   // concept requirements\n-  glibcpp_class_requires(_Key, SGIAssignableConcept);\n-  glibcpp_class_requires4(_Compare, bool, _Key, _Key, BinaryFunctionConcept);\n+  __glibcpp_class_requires(_Key, _SGIAssignableConcept);\n+  __glibcpp_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept);\n \n public:\n   // typedefs:"}, {"sha": "9f4fd4606044f933e6ab72b4a05a4d962949e141", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -53,10 +53,10 @@ template <class _Tp, class _Sequence>\n class stack\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires(_Sequence, BackInsertionSequenceConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept);\n   typedef typename _Sequence::value_type _Sequence_value_type;\n-  glibcpp_class_requires2(_Tp, _Sequence_value_type, SameTypeConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n \n   template <class _Tp1, class _Seq1>\n   friend bool operator== (const stack<_Tp1, _Seq1>&,"}, {"sha": "4bc0253edc1ad1c9190627d4b65dfe01a6c442f4", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -118,7 +118,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n class vector : protected _Vector_base<_Tp, _Alloc> \n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n \n private:\n   typedef _Vector_base<_Tp, _Alloc> _Base;"}, {"sha": "8386cb91c1f950792302cfec69420b5147ca2d4d", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -204,10 +204,10 @@ template <class _Key, class _Tp, class _HashFcn, class _EqualKey, class _Alloc>\n class hash_multimap\n {\n   // concept requirements\n-  glibcpp_class_requires(_Key, SGIAssignableConcept);\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n-  glibcpp_class_requires3(_HashFcn, size_t, _Key, UnaryFunctionConcept);\n-  glibcpp_class_requires3(_EqualKey, _Key, _Key, BinaryPredicateConcept);\n+  __glibcpp_class_requires(_Key, _SGIAssignableConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n+  __glibcpp_class_requires3(_HashFcn, size_t, _Key, _UnaryFunctionConcept);\n+  __glibcpp_class_requires3(_EqualKey, _Key, _Key, _BinaryPredicateConcept);\n \n private:\n   typedef hashtable<pair<const _Key, _Tp>, _Key, _HashFcn,"}, {"sha": "a6568e135a2bbcff47699093ab96edcac87df9b8", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -54,9 +54,9 @@ template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n class hash_set\n {\n   // concept requirements\n-  glibcpp_class_requires(_Value, SGIAssignableConcept);\n-  glibcpp_class_requires3(_HashFcn, size_t, _Value, UnaryFunctionConcept);\n-  glibcpp_class_requires3(_EqualKey, _Value, _Value, BinaryPredicateConcept);\n+  __glibcpp_class_requires(_Value, _SGIAssignableConcept);\n+  __glibcpp_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept);\n+  __glibcpp_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept);\n \n private:\n   typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, \n@@ -205,9 +205,9 @@ template <class _Value, class _HashFcn, class _EqualKey, class _Alloc>\n class hash_multiset\n {\n   // concept requirements\n-  glibcpp_class_requires(_Value, SGIAssignableConcept);\n-  glibcpp_class_requires3(_HashFcn, size_t, _Value, UnaryFunctionConcept);\n-  glibcpp_class_requires3(_EqualKey, _Value, _Value, BinaryPredicateConcept);\n+  __glibcpp_class_requires(_Value, _SGIAssignableConcept);\n+  __glibcpp_class_requires3(_HashFcn, size_t, _Value, _UnaryFunctionConcept);\n+  __glibcpp_class_requires3(_EqualKey, _Value, _Value, _BinaryPredicateConcept);\n \n private:\n   typedef hashtable<_Value, _Value, _HashFcn, _Identity<_Value>, "}, {"sha": "134e9846f2f9cd4380fa5979d6d2b0588b54aede", "filename": "libstdc++-v3/include/ext/slist", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62bb0c97fdbb70f6f93fb0d77e1743117ae53930/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fslist?ref=62bb0c97fdbb70f6f93fb0d77e1743117ae53930", "patch": "@@ -258,7 +258,7 @@ template <class _Tp, class _Alloc = allocator<_Tp> >\n class slist : private _Slist_base<_Tp,_Alloc>\n {\n   // concept requirements\n-  glibcpp_class_requires(_Tp, SGIAssignableConcept);\n+  __glibcpp_class_requires(_Tp, _SGIAssignableConcept);\n \n private:\n   typedef _Slist_base<_Tp,_Alloc> _Base;"}]}