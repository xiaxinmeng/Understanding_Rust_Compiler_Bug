{"sha": "a08acce83a052a8b800eddaaae36e51e8de57643", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA4YWNjZTgzYTA1MmE4YjgwMGVkZGFhYWUzNmU1MWU4ZGU1NzY0Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2018-07-02T15:29:16Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2018-07-02T15:29:16Z"}, "message": "aarch64: Add movprfx patterns alternatives\n\n    * config/aarch64/aarch64-protos.h, config/aarch64/aarch64.c\n    (aarch64_sve_prepare_conditional_op): Remove.\n    * config/aarch64/aarch64-sve.md (cond_<SVE_INT_BINARY><SVE_I>):\n    Allow aarch64_simd_reg_or_zero as select operand; remove\n    the aarch64_sve_prepare_conditional_op call.\n    (cond_<SVE_INT_BINARY_SD><SVE_SDI>): Likewise.\n    (cond_<SVE_COND_FP_BINARY><SVE_F>): Likewise.\n    (*cond_<SVE_INT_BINARY><SVE_I>_z): New pattern.\n    (*cond_<SVE_INT_BINARY_SD><SVE_SDI>_z): New pattern.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>_z): New pattern.\n    (*cond_<SVE_INT_BINARY><SVE_I>_any): New pattern.\n    (*cond_<SVE_INT_BINARY_SD><SVE_SDI>_any): New pattern.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>_any): New pattern\n    and a splitters to match all of the *_any patterns.\n    * config/aarch64/predicates.md (aarch64_sve_any_binary_operator): New.\n\n    * config/aarch64/iterators.md (SVE_INT_BINARY_REV): Remove.\n    (SVE_COND_FP_BINARY_REV): Remove.\n    (sve_int_op_rev, sve_fp_op_rev): New.\n    * config/aarch64/aarch64-sve.md (*cond_<SVE_INT_BINARY><SVE_I>_0): New.\n    (*cond_<SVE_INT_BINARY_SD><SVE_SDI>_0): New.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>_0): New.\n    (*cond_<SVE_INT_BINARY><SVE_I>_2): Rename, add movprfx alternative.\n    (*cond_<SVE_INT_BINARY_SD><SVE_SDI>_2): Similarly.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>_2): Similarly.\n    (*cond_<SVE_INT_BINARY><SVE_I>_3): Similarly; use sve_int_op_rev.\n    (*cond_<SVE_INT_BINARY_SD><SVE_SDI>_3): Similarly.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>_3): Similarly; use sve_fp_op_rev.\n\n    * config/aarch64/aarch64-sve.md (cond_<SVE_COND_FP_BINARY><SVE_F>):\n    Remove match_dup 1 from the inner unspec.\n    (*cond_<SVE_COND_FP_BINARY><SVE_F>): Likewise.\n\n    * config/aarch64/aarch64.md (movprfx): New attr.\n    (length): Default movprfx to 8.\n    * config/aarch64/aarch64-sve.md (*mul<SVE_I>3): Add movprfx alt.\n    (*madd<SVE_I>, *msub<SVE_I): Likewise.\n    (*<su>mul<SVE_I>3_highpart): Likewise.\n    (*<SVE_INT_BINARY_SD><SVE_SDI>3): Likewise.\n    (*v<ASHIFT><SVE_I>3): Likewise.\n    (*<su><MAXMIN><SVE_I>3): Likewise.\n    (*<su><MAXMIN><SVE_F>3): Likewise.\n    (*fma<SVE_F>4, *fnma<SVE_F>4): Likewise.\n    (*fms<SVE_F>4, *fnms<SVE_F>4): Likewise.\n    (*div<SVE_F>4): Likewise.\n\nFrom-SVN: r262312", "tree": {"sha": "6f0e10df81f6adc719dc46e3e6188633784db90f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6f0e10df81f6adc719dc46e3e6188633784db90f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a08acce83a052a8b800eddaaae36e51e8de57643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08acce83a052a8b800eddaaae36e51e8de57643", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a08acce83a052a8b800eddaaae36e51e8de57643", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a08acce83a052a8b800eddaaae36e51e8de57643/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1234faf487fdfa79bbb9e0f0e305cce08b676aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1234faf487fdfa79bbb9e0f0e305cce08b676aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1234faf487fdfa79bbb9e0f0e305cce08b676aea"}], "stats": {"total": 617, "additions": 430, "deletions": 187}, "files": [{"sha": "0a8395949cf6d92d1f00bce2dd704ef940b6c090", "filename": "gcc/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -1,3 +1,51 @@\n+2018-07-02  Richard Henderson  <richard.henderson@linaro.org>\n+\n+\t* config/aarch64/aarch64-protos.h, config/aarch64/aarch64.c\n+\t(aarch64_sve_prepare_conditional_op): Remove.\n+\t* config/aarch64/aarch64-sve.md (cond_<SVE_INT_BINARY><SVE_I>):\n+\tAllow aarch64_simd_reg_or_zero as select operand; remove\n+\tthe aarch64_sve_prepare_conditional_op call.\n+\t(cond_<SVE_INT_BINARY_SD><SVE_SDI>): Likewise.\n+\t(cond_<SVE_COND_FP_BINARY><SVE_F>): Likewise.\n+\t(*cond_<SVE_INT_BINARY><SVE_I>_z): New pattern.\n+\t(*cond_<SVE_INT_BINARY_SD><SVE_SDI>_z): New pattern.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>_z): New pattern.\n+\t(*cond_<SVE_INT_BINARY><SVE_I>_any): New pattern.\n+\t(*cond_<SVE_INT_BINARY_SD><SVE_SDI>_any): New pattern.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>_any): New pattern\n+\tand a splitters to match all of the *_any patterns.\n+\t* config/aarch64/predicates.md (aarch64_sve_any_binary_operator): New.\n+\n+\t* config/aarch64/iterators.md (SVE_INT_BINARY_REV): Remove.\n+\t(SVE_COND_FP_BINARY_REV): Remove.\n+\t(sve_int_op_rev, sve_fp_op_rev): New.\n+\t* config/aarch64/aarch64-sve.md (*cond_<SVE_INT_BINARY><SVE_I>_0): New.\n+\t(*cond_<SVE_INT_BINARY_SD><SVE_SDI>_0): New.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>_0): New.\n+\t(*cond_<SVE_INT_BINARY><SVE_I>_2): Rename, add movprfx alternative.\n+\t(*cond_<SVE_INT_BINARY_SD><SVE_SDI>_2): Similarly.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>_2): Similarly.\n+\t(*cond_<SVE_INT_BINARY><SVE_I>_3): Similarly; use sve_int_op_rev.\n+\t(*cond_<SVE_INT_BINARY_SD><SVE_SDI>_3): Similarly.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>_3): Similarly; use sve_fp_op_rev.\n+\n+\t* config/aarch64/aarch64-sve.md (cond_<SVE_COND_FP_BINARY><SVE_F>):\n+\tRemove match_dup 1 from the inner unspec.\n+\t(*cond_<SVE_COND_FP_BINARY><SVE_F>): Likewise.\n+\n+\t* config/aarch64/aarch64.md (movprfx): New attr.\n+\t(length): Default movprfx to 8.\n+\t* config/aarch64/aarch64-sve.md (*mul<SVE_I>3): Add movprfx alt.\n+\t(*madd<SVE_I>, *msub<SVE_I): Likewise.\n+\t(*<su>mul<SVE_I>3_highpart): Likewise.\n+\t(*<SVE_INT_BINARY_SD><SVE_SDI>3): Likewise.\n+\t(*v<ASHIFT><SVE_I>3): Likewise.\n+\t(*<su><MAXMIN><SVE_I>3): Likewise.\n+\t(*<su><MAXMIN><SVE_F>3): Likewise.\n+\t(*fma<SVE_F>4, *fnma<SVE_F>4): Likewise.\n+\t(*fms<SVE_F>4, *fnms<SVE_F>4): Likewise.\n+\t(*div<SVE_F>4): Likewise.\n+\n 2018-07-02  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_recog_widen_shift_pattern): Fix typo"}, {"sha": "514ddc457ca09d78a2bdb0fe72252eab8d823928", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -513,7 +513,6 @@ bool aarch64_gen_adjusted_ldpstp (rtx *, bool, scalar_mode, RTX_CODE);\n void aarch64_expand_sve_vec_cmp_int (rtx, rtx_code, rtx, rtx);\n bool aarch64_expand_sve_vec_cmp_float (rtx, rtx_code, rtx, rtx, bool);\n void aarch64_expand_sve_vcond (machine_mode, machine_mode, rtx *);\n-void aarch64_sve_prepare_conditional_op (rtx *, unsigned int, bool);\n #endif /* RTX_CODE */\n \n void aarch64_init_builtins (void);"}, {"sha": "b16d04551593c8538f0fcd09bbccf128dac92937", "filename": "gcc/config/aarch64/aarch64-sve.md", "status": "modified", "additions": 349, "deletions": 131, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve.md?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -937,47 +937,53 @@\n ;; to gain much and would make the instruction seem less uniform to the\n ;; register allocator.\n (define_insn \"*mul<mode>3\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (mult:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"%0, 0\")\n-\t     (match_operand:SVE_I 3 \"aarch64_sve_mul_operand\" \"vsm, w\"))]\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"%0, 0, w\")\n+\t     (match_operand:SVE_I 3 \"aarch64_sve_mul_operand\" \"vsm, w, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    mul\\t%0.<Vetype>, %0.<Vetype>, #%3\n-   mul\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+   mul\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;mul\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n (define_insn \"*madd<mode>\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w, ?&w\")\n \t(plus:SVE_I\n \t  (unspec:SVE_I\n-\t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t     (mult:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0, w\")\n-\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w, w\"))]\n+\t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t     (mult:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0, w, w\")\n+\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w, w, w\"))]\n \t    UNSPEC_MERGE_PTRUE)\n-\t  (match_operand:SVE_I 4 \"register_operand\" \"w, 0\")))]\n+\t  (match_operand:SVE_I 4 \"register_operand\" \"w, 0, w\")))]\n   \"TARGET_SVE\"\n   \"@\n    mad\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n-   mla\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+   mla\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %4\\;mla\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n (define_insn \"*msub<mode>3\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w, ?&w\")\n \t(minus:SVE_I\n-\t  (match_operand:SVE_I 4 \"register_operand\" \"w, 0\")\n+\t  (match_operand:SVE_I 4 \"register_operand\" \"w, 0, w\")\n \t  (unspec:SVE_I\n-\t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t     (mult:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0, w\")\n-\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w, w\"))]\n+\t    [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t     (mult:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0, w, w\")\n+\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w, w, w\"))]\n \t    UNSPEC_MERGE_PTRUE)))]\n   \"TARGET_SVE\"\n   \"@\n    msb\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n-   mls\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+   mls\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %4\\;mls\\t%0.<Vetype>, %1/m, %2.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated highpart multiplication.\n@@ -997,15 +1003,18 @@\n \n ;; Predicated highpart multiplication.\n (define_insn \"*<su>mul<mode>3_highpart\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (unspec:SVE_I [(match_operand:SVE_I 2 \"register_operand\" \"%0\")\n-\t\t\t  (match_operand:SVE_I 3 \"register_operand\" \"w\")]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_I [(match_operand:SVE_I 2 \"register_operand\" \"%0, w\")\n+\t\t\t  (match_operand:SVE_I 3 \"register_operand\" \"w, w\")]\n \t\t\t MUL_HIGHPART)]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n-  \"<su>mulh\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"@\n+   <su>mulh\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<su>mulh\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Unpredicated division.\n@@ -1025,17 +1034,19 @@\n \n ;; Division predicated with a PTRUE.\n (define_insn \"*<optab><mode>3\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_SDI\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (SVE_INT_BINARY_SD:SVE_SDI\n-\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w\")\n-\t     (match_operand:SVE_SDI 3 \"aarch64_sve_mul_operand\" \"w, 0\"))]\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w, w\")\n+\t     (match_operand:SVE_SDI 3 \"aarch64_sve_mul_operand\" \"w, 0, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n-   <sve_int_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+   <sve_int_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated NEG, NOT and POPCOUNT.\n@@ -1222,17 +1233,19 @@\n ;; or X isn't likely to gain much and would make the instruction seem\n ;; less uniform to the register allocator.\n (define_insn \"*v<optab><mode>3\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (ASHIFT:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"w, 0\")\n-\t     (match_operand:SVE_I 3 \"aarch64_sve_<lr>shift_operand\" \"D<lr>, w\"))]\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"w, 0, w\")\n+\t     (match_operand:SVE_I 3 \"aarch64_sve_<lr>shift_operand\" \"D<lr>, w, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    <shift>\\t%0.<Vetype>, %2.<Vetype>, #%3\n-   <shift>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+   <shift>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<shift>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; LSL, LSR and ASR by a scalar, which expands into one of the vector\n@@ -1723,14 +1736,17 @@\n \n ;; Integer MIN/MAX predicated with a PTRUE.\n (define_insn \"*<su><maxmin><mode>3\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_I\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (MAXMIN:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0\")\n-\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w\"))]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (MAXMIN:SVE_I (match_operand:SVE_I 2 \"register_operand\" \"%0, w\")\n+\t\t\t (match_operand:SVE_I 3 \"register_operand\" \"w, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n-  \"<su><maxmin>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"@\n+   <su><maxmin>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<su><maxmin>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Unpredicated floating-point MIN/MAX.\n@@ -1749,14 +1765,17 @@\n \n ;; Floating-point MIN/MAX predicated with a PTRUE.\n (define_insn \"*<su><maxmin><mode>3\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (FMAXMIN:SVE_F (match_operand:SVE_F 2 \"register_operand\" \"%0\")\n-\t\t\t  (match_operand:SVE_F 3 \"register_operand\" \"w\"))]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (FMAXMIN:SVE_F (match_operand:SVE_F 2 \"register_operand\" \"%0, w\")\n+\t\t\t  (match_operand:SVE_F 3 \"register_operand\" \"w, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n-  \"f<maxmin>nm\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"@\n+   f<maxmin>nm\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;f<maxmin>nm\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Unpredicated fmin/fmax.\n@@ -1776,15 +1795,18 @@\n \n ;; fmin/fmax predicated with a PTRUE.\n (define_insn \"*<maxmin_uns><mode>3\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (unspec:SVE_F [(match_operand:SVE_F 2 \"register_operand\" \"%0\")\n-\t\t\t  (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_F [(match_operand:SVE_F 2 \"register_operand\" \"%0, w\")\n+\t\t\t  (match_operand:SVE_F 3 \"register_operand\" \"w, w\")]\n \t\t\t FMAXMIN_UNS)]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n-  \"<maxmin_uns_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"@\n+   <maxmin_uns_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<maxmin_uns_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n )\n \n ;; Predicated integer operations with select.\n@@ -1795,13 +1817,10 @@\n \t   (SVE_INT_BINARY:SVE_I\n \t     (match_operand:SVE_I 2 \"register_operand\")\n \t     (match_operand:SVE_I 3 \"register_operand\"))\n-\t   (match_operand:SVE_I 4 \"register_operand\")]\n+\t   (match_operand:SVE_I 4 \"aarch64_simd_reg_or_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-{\n-  bool commutative_p = (GET_RTX_CLASS (<CODE>) == RTX_COMM_ARITH);\n-  aarch64_sve_prepare_conditional_op (operands, 5, commutative_p);\n-})\n+)\n \n (define_expand \"cond_<optab><mode>\"\n   [(set (match_operand:SVE_SDI 0 \"register_operand\")\n@@ -1810,66 +1829,191 @@\n \t   (SVE_INT_BINARY_SD:SVE_SDI\n \t     (match_operand:SVE_SDI 2 \"register_operand\")\n \t     (match_operand:SVE_SDI 3 \"register_operand\"))\n-\t   (match_operand:SVE_SDI 4 \"register_operand\")]\n+\t   (match_operand:SVE_SDI 4 \"aarch64_simd_reg_or_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-{\n-  bool commutative_p = (GET_RTX_CLASS (<CODE>) == RTX_COMM_ARITH);\n-  aarch64_sve_prepare_conditional_op (operands, 5, commutative_p);\n-})\n+)\n \n-;; Predicated integer operations.\n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+;; Predicated integer operations with select matching the output operand.\n+(define_insn \"*cond_<optab><mode>_0\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"+w, w, ?&w\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (SVE_INT_BINARY:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"0, w, w\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w, 0, w\"))\n+\t   (match_dup 0)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %1/m, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n+)\n+\n+(define_insn \"*cond_<optab><mode>_0\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"+w, w, ?&w\")\n+\t(unspec:SVE_SDI\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (SVE_INT_BINARY_SD:SVE_SDI\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w, w\")\n+\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w, 0, w\"))\n+\t   (match_dup 0)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %1/m, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n+)\n+\n+;; Predicated integer operations with select matching the first operand.\n+(define_insn \"*cond_<optab><mode>_2\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (SVE_INT_BINARY:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"0, w\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w, w\"))\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+(define_insn \"*cond_<optab><mode>_2\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_SDI\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (SVE_INT_BINARY_SD:SVE_SDI\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0, w\")\n+\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w, w\"))\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated integer operations with select matching the second operand.\n+(define_insn \"*cond_<optab><mode>_3\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (SVE_INT_BINARY:SVE_I\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"0, w\"))\n+\t   (match_dup 3)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %3\\;<sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+(define_insn \"*cond_<optab><mode>_3\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_SDI\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (SVE_INT_BINARY_SD:SVE_SDI\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"w, w\")\n+\t     (match_operand:SVE_SDI 3 \"register_operand\" \"0, w\"))\n+\t   (match_dup 3)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %3\\;<sve_int_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated integer operations with select matching zero.\n+(define_insn \"*cond_<optab><mode>_z\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_I\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n \t   (SVE_INT_BINARY:SVE_I\n-\t     (match_operand:SVE_I 2 \"register_operand\" \"0\")\n+\t     (match_operand:SVE_I 2 \"register_operand\" \"w\")\n \t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n-\t   (match_dup 2)]\n+\t   (match_operand:SVE_I 4 \"aarch64_simd_imm_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w\")\n+(define_insn \"*cond_<optab><mode>_z\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_SDI\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n \t   (SVE_INT_BINARY_SD:SVE_SDI\n-\t     (match_operand:SVE_SDI 2 \"register_operand\" \"0\")\n+\t     (match_operand:SVE_SDI 2 \"register_operand\" \"w\")\n \t     (match_operand:SVE_SDI 3 \"register_operand\" \"w\"))\n-\t   (match_dup 2)]\n+\t   (match_operand:SVE_SDI 4 \"aarch64_simd_imm_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_int_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n-;; Predicated integer operations with the operands reversed.\n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_I 0 \"register_operand\" \"=w\")\n+;; Synthetic predications with select unmatched.\n+(define_insn \"*cond_<optab><mode>_any\"\n+  [(set (match_operand:SVE_I 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_I\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (SVE_INT_BINARY_REV:SVE_I\n+\t   (SVE_INT_BINARY:SVE_I\n \t     (match_operand:SVE_I 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_I 3 \"register_operand\" \"0\"))\n-\t   (match_dup 3)]\n+\t     (match_operand:SVE_I 3 \"register_operand\" \"w\"))\n+\t   (match_operand:SVE_I 4 \"register_operand\"   \"w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_int_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  \"#\"\n )\n \n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=w\")\n+(define_insn \"*cond_<optab><mode>_any\"\n+  [(set (match_operand:SVE_SDI 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_SDI\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n-\t   (SVE_INT_BINARY_SD:SVE_SDI\n+\t   (SVE_INT_BINARY_SD:SVE_I\n \t     (match_operand:SVE_SDI 2 \"register_operand\" \"w\")\n-\t     (match_operand:SVE_SDI 3 \"register_operand\" \"0\"))\n-\t   (match_dup 3)]\n+\t     (match_operand:SVE_SDI 3 \"register_operand\" \"w\"))\n+\t   (match_operand:SVE_SDI 4 \"register_operand\"   \"w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_int_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  \"#\"\n+)\n+\n+(define_split\n+  [(set (match_operand:SVE_I 0 \"register_operand\")\n+\t(unspec:SVE_I\n+\t  [(match_operand:<VPRED> 1 \"register_operand\")\n+\t   (match_operator:SVE_I 5 \"aarch64_sve_any_binary_operator\"\n+\t     [(match_operand:SVE_I 2 \"register_operand\")\n+\t      (match_operand:SVE_I 3 \"register_operand\")])\n+\t   (match_operand:SVE_I 4 \"register_operand\")]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE && reload_completed\n+   && !(rtx_equal_p (operands[0], operands[4])\n+        || rtx_equal_p (operands[2], operands[4])\n+        || rtx_equal_p (operands[3], operands[4]))\"\n+  ; Not matchable by any one insn or movprfx insn.  We need a separate select.\n+  [(set (match_dup 0)\n+\t(unspec:SVE_I [(match_dup 1) (match_dup 2) (match_dup 4)]\n+                      UNSPEC_SEL))\n+   (set (match_dup 0)\n+\t(unspec:SVE_I\n+\t  [(match_dup 1)\n+\t   (match_op_dup 5 [(match_dup 0) (match_dup 3)])\n+           (match_dup 0)]\n+\t  UNSPEC_SEL))]\n )\n \n ;; Set operand 0 to the last active element in operand 3, or to tied\n@@ -2146,17 +2290,19 @@\n \n ;; fma predicated with a PTRUE.\n (define_insn \"*fma<mode>4\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (fma:SVE_F (match_operand:SVE_F 3 \"register_operand\" \"%0, w\")\n-\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")\n-\t\t      (match_operand:SVE_F 2 \"register_operand\" \"w, 0\"))]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (fma:SVE_F (match_operand:SVE_F 3 \"register_operand\" \"%0, w, w\")\n+\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")\n+\t\t      (match_operand:SVE_F 2 \"register_operand\" \"w, 0, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fmad\\t%0.<Vetype>, %1/m, %4.<Vetype>, %2.<Vetype>\n-   fmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+   fmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n+   movprfx\\t%0, %2\\;fmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated fnma (%0 = (-%1 * %2) + %3).\n@@ -2177,18 +2323,20 @@\n \n ;; fnma predicated with a PTRUE.\n (define_insn \"*fnma<mode>4\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (fma:SVE_F (neg:SVE_F\n-\t\t\t(match_operand:SVE_F 3 \"register_operand\" \"%0, w\"))\n-\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")\n-\t\t      (match_operand:SVE_F 2 \"register_operand\" \"w, 0\"))]\n+\t\t\t(match_operand:SVE_F 3 \"register_operand\" \"%0, w, w\"))\n+\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")\n+\t\t      (match_operand:SVE_F 2 \"register_operand\" \"w, 0, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fmsb\\t%0.<Vetype>, %1/m, %4.<Vetype>, %2.<Vetype>\n-   fmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+   fmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n+   movprfx\\t%0, %2\\;fmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated fms (%0 = (%1 * %2) - %3).\n@@ -2209,18 +2357,20 @@\n \n ;; fms predicated with a PTRUE.\n (define_insn \"*fms<mode>4\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (fma:SVE_F (match_operand:SVE_F 3 \"register_operand\" \"%0, w\")\n-\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (fma:SVE_F (match_operand:SVE_F 3 \"register_operand\" \"%0, w, w\")\n+\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")\n \t\t      (neg:SVE_F\n-\t\t\t(match_operand:SVE_F 2 \"register_operand\" \"w, 0\")))]\n+\t\t\t(match_operand:SVE_F 2 \"register_operand\" \"w, 0, w\")))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fnmsb\\t%0.<Vetype>, %1/m, %4.<Vetype>, %2.<Vetype>\n-   fnmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+   fnmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n+   movprfx\\t%0, %2\\;fnmls\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated fnms (%0 = (-%1 * %2) - %3).\n@@ -2242,19 +2392,21 @@\n \n ;; fnms predicated with a PTRUE.\n (define_insn \"*fnms<mode>4\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n \t   (fma:SVE_F (neg:SVE_F\n-\t\t\t(match_operand:SVE_F 3 \"register_operand\" \"%0, w\"))\n-\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w\")\n+\t\t\t(match_operand:SVE_F 3 \"register_operand\" \"%0, w, w\"))\n+\t\t      (match_operand:SVE_F 4 \"register_operand\" \"w, w, w\")\n \t\t      (neg:SVE_F\n-\t\t\t(match_operand:SVE_F 2 \"register_operand\" \"w, 0\")))]\n+\t\t\t(match_operand:SVE_F 2 \"register_operand\" \"w, 0, w\")))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fnmad\\t%0.<Vetype>, %1/m, %4.<Vetype>, %2.<Vetype>\n-   fnmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+   fnmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\n+   movprfx\\t%0, %2\\;fnmla\\t%0.<Vetype>, %1/m, %3.<Vetype>, %4.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated floating-point division.\n@@ -2273,16 +2425,18 @@\n \n ;; Floating-point division predicated with a PTRUE.\n (define_insn \"*div<mode>3\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w\")\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, w, ?&w\")\n \t(unspec:SVE_F\n-\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n-\t   (div:SVE_F (match_operand:SVE_F 2 \"register_operand\" \"0, w\")\n-\t\t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0\"))]\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (div:SVE_F (match_operand:SVE_F 2 \"register_operand\" \"0, w, w\")\n+\t\t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w\"))]\n \t  UNSPEC_MERGE_PTRUE))]\n   \"TARGET_SVE\"\n   \"@\n    fdiv\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n-   fdivr\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+   fdivr\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %2\\;fdiv\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n )\n \n ;; Unpredicated FNEG, FABS and FSQRT.\n@@ -2645,47 +2799,111 @@\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n-\t      (match_operand:SVE_F 2 \"register_operand\")\n+\t     [(match_operand:SVE_F 2 \"register_operand\")\n \t      (match_operand:SVE_F 3 \"register_operand\")]\n \t     SVE_COND_FP_BINARY)\n-\t   (match_operand:SVE_F 4 \"register_operand\")]\n+\t   (match_operand:SVE_F 4 \"aarch64_simd_reg_or_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-{\n-  aarch64_sve_prepare_conditional_op (operands, 5, <commutative>);\n-})\n+)\n \n-;; Predicated floating-point operations.\n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+;; Predicated floating-point operations with select matching output.\n+(define_insn \"*cond_<optab><mode>_0\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"+w, w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"0, w, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, 0, w\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_dup 0)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   <sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %1/m, %2\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,*,yes\")]\n+)\n+\n+;; Predicated floating-point operations with select matching first operand.\n+(define_insn \"*cond_<optab><mode>_2\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"0, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w, w\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_dup 2)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\n+   movprfx\\t%0, %2\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated floating-point operations with select matching second operand.\n+(define_insn \"*cond_<optab><mode>_3\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w, ?&w\")\n+\t(unspec:SVE_F\n+\t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl, Upl\")\n+\t   (unspec:SVE_F\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"w, w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"0, w\")]\n+\t     SVE_COND_FP_BINARY)\n+\t   (match_dup 3)]\n+\t  UNSPEC_SEL))]\n+  \"TARGET_SVE\"\n+  \"@\n+   <sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\n+   movprfx\\t%0, %3\\;<sve_fp_op_rev>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  [(set_attr \"movprfx\" \"*,yes\")]\n+)\n+\n+;; Predicated floating-point operations with select matching zero.\n+(define_insn \"*cond_<optab><mode>_z\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n-\t      (match_operand:SVE_F 2 \"register_operand\" \"0\")\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"w\")\n \t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n \t     SVE_COND_FP_BINARY)\n-\t   (match_dup 2)]\n+\t   (match_operand:SVE_F 4 \"aarch64_simd_imm_zero\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  \"movprfx\\t%0.<Vetype>, %1/z, %2.<Vetype>\\;<sve_fp_op>\\t%0.<Vetype>, %1/m, %0.<Vetype>, %3.<Vetype>\"\n+  [(set_attr \"movprfx\" \"yes\")]\n )\n \n-;; Predicated floating-point operations with the operands reversed.\n-(define_insn \"*cond_<optab><mode>\"\n-  [(set (match_operand:SVE_F 0 \"register_operand\" \"=w\")\n+;; Synthetic predication of floating-point operations with select unmatched.\n+(define_insn_and_split \"*cond_<optab><mode>_any\"\n+  [(set (match_operand:SVE_F 0 \"register_operand\" \"=&w\")\n \t(unspec:SVE_F\n \t  [(match_operand:<VPRED> 1 \"register_operand\" \"Upl\")\n \t   (unspec:SVE_F\n-\t     [(match_dup 1)\n-\t      (match_operand:SVE_F 2 \"register_operand\" \"w\")\n-\t      (match_operand:SVE_F 3 \"register_operand\" \"0\")]\n+\t     [(match_operand:SVE_F 2 \"register_operand\" \"w\")\n+\t      (match_operand:SVE_F 3 \"register_operand\" \"w\")]\n \t     SVE_COND_FP_BINARY)\n-\t   (match_dup 3)]\n+\t   (match_operand:SVE_F 4 \"register_operand\" \"w\")]\n \t  UNSPEC_SEL))]\n   \"TARGET_SVE\"\n-  \"<sve_fp_op>r\\t%0.<Vetype>, %1/m, %0.<Vetype>, %2.<Vetype>\"\n+  \"#\"\n+  \"&& reload_completed\n+   && !(rtx_equal_p (operands[0], operands[4])\n+        || rtx_equal_p (operands[2], operands[4])\n+        || rtx_equal_p (operands[3], operands[4]))\"\n+  ; Not matchable by any one insn or movprfx insn.  We need a separate select.\n+  [(set (match_dup 0)\n+\t(unspec:SVE_F [(match_dup 1) (match_dup 2) (match_dup 4)] UNSPEC_SEL))\n+   (set (match_dup 0)\n+\t(unspec:SVE_F\n+\t  [(match_dup 1)\n+\t   (unspec:SVE_F [(match_dup 0) (match_dup 3)] SVE_COND_FP_BINARY)\n+           (match_dup 0)]\n+\t  UNSPEC_SEL))]\n )\n \n ;; Shift an SVE vector left and insert a scalar into element 0."}, {"sha": "d75d45f4b8be99439bbe2e8bab978f1dc46ac654", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -16058,54 +16058,6 @@ aarch64_expand_sve_vcond (machine_mode data_mode, machine_mode cmp_mode,\n   emit_set_insn (ops[0], gen_rtx_UNSPEC (data_mode, vec, UNSPEC_SEL));\n }\n \n-/* Prepare a cond_<optab><mode> operation that has the operands\n-   given by OPERANDS, where:\n-\n-   - operand 0 is the destination\n-   - operand 1 is a predicate\n-   - operands 2 to NOPS - 2 are the operands to an operation that is\n-     performed for active lanes\n-   - operand NOPS - 1 specifies the values to use for inactive lanes.\n-\n-   COMMUTATIVE_P is true if operands 2 and 3 are commutative.  In that case,\n-   no pattern is provided for a tie between operands 3 and NOPS - 1.  */\n-\n-void\n-aarch64_sve_prepare_conditional_op (rtx *operands, unsigned int nops,\n-\t\t\t\t    bool commutative_p)\n-{\n-  /* We can do the operation directly if the \"else\" value matches one\n-     of the other inputs.  */\n-  for (unsigned int i = 2; i < nops - 1; ++i)\n-    if (rtx_equal_p (operands[i], operands[nops - 1]))\n-      {\n-\tif (i == 3 && commutative_p)\n-\t  std::swap (operands[2], operands[3]);\n-\treturn;\n-      }\n-\n-  /* If the \"else\" value is different from the other operands, we have\n-     the choice of doing a SEL on the output or a SEL on an input.\n-     Neither choice is better in all cases, but one advantage of\n-     selecting the input is that it can avoid a move when the output\n-     needs to be distinct from the inputs.  E.g. if operand N maps to\n-     register N, selecting the output would give:\n-\n-\tMOVPRFX Z0.S, Z2.S\n-\tADD Z0.S, P1/M, Z0.S, Z3.S\n-\tSEL Z0.S, P1, Z0.S, Z4.S\n-\n-     whereas selecting the input avoids the MOVPRFX:\n-\n-\tSEL Z0.S, P1, Z2.S, Z4.S\n-\tADD Z0.S, P1/M, Z0.S, Z3.S.  */\n-  machine_mode mode = GET_MODE (operands[0]);\n-  rtx temp = gen_reg_rtx (mode);\n-  rtvec vec = gen_rtvec (3, operands[1], operands[2], operands[nops - 1]);\n-  emit_set_insn (temp, gen_rtx_UNSPEC (mode, vec, UNSPEC_SEL));\n-  operands[2] = operands[nops - 1] = temp;\n-}\n-\n /* Implement TARGET_MODES_TIEABLE_P.  In principle we should always return\n    true.  However due to issues with register allocation it is preferable\n    to avoid tieing integer scalar and FP scalar modes.  Executing integer"}, {"sha": "a014a012cc1b800c34552f08765eaefc2f973795", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -251,9 +251,6 @@\n ;; will be disabled when !TARGET_SVE.\n (define_attr \"sve\" \"no,yes\" (const_string \"no\"))\n \n-(define_attr \"length\" \"\"\n-  (const_int 4))\n-\n ;; Attribute that controls whether an alternative is enabled or not.\n ;; Currently it is only used to disable alternatives which touch fp or simd\n ;; registers when -mgeneral-regs-only is specified.\n@@ -277,6 +274,14 @@\n ;; 1 :=: yes\n (define_attr \"far_branch\" \"\" (const_int 0))\n \n+;; Attribute that specifies whether the alternative uses MOVPRFX.\n+(define_attr \"movprfx\" \"no,yes\" (const_string \"no\"))\n+\n+(define_attr \"length\" \"\"\n+  (cond [(eq_attr \"movprfx\" \"yes\")\n+           (const_int 8)\n+        ] (const_int 4)))\n+\n ;; Strictly for compatibility with AArch32 in pipeline models, since AArch64 has\n ;; no predicated insns.\n (define_attr \"predicated\" \"yes,no\" (const_string \"no\"))"}, {"sha": "965dc6bf4f3472a0865fb165b80783b4d6cd29c2", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -1207,11 +1207,11 @@\n ;; SVE floating-point unary operations.\n (define_code_iterator SVE_FP_UNARY [neg abs sqrt])\n \n+;; SVE integer binary operations.\n (define_code_iterator SVE_INT_BINARY [plus minus mult smax umax smin umin\n \t\t\t\t      and ior xor])\n \n-(define_code_iterator SVE_INT_BINARY_REV [minus])\n-\n+;; SVE integer binary division operations.\n (define_code_iterator SVE_INT_BINARY_SD [div udiv])\n \n ;; SVE integer comparisons.\n@@ -1402,6 +1402,19 @@\n \t\t\t      (not \"not\")\n \t\t\t      (popcount \"cnt\")])\n \n+(define_code_attr sve_int_op_rev [(plus \"add\")\n+\t\t\t          (minus \"subr\")\n+\t\t\t          (mult \"mul\")\n+\t\t\t          (div \"sdivr\")\n+\t\t\t          (udiv \"udivr\")\n+\t\t\t          (smin \"smin\")\n+\t\t\t          (smax \"smax\")\n+\t\t\t          (umin \"umin\")\n+\t\t\t          (umax \"umax\")\n+\t\t\t          (and \"and\")\n+\t\t\t          (ior \"orr\")\n+\t\t\t          (xor \"eor\")])\n+\n ;; The floating-point SVE instruction that implements an rtx code.\n (define_code_attr sve_fp_op [(plus \"fadd\")\n \t\t\t     (neg \"fneg\")\n@@ -1550,8 +1563,6 @@\n \t\t\t\t\t UNSPEC_COND_MUL UNSPEC_COND_DIV\n \t\t\t\t\t UNSPEC_COND_MAX UNSPEC_COND_MIN])\n \n-(define_int_iterator SVE_COND_FP_BINARY_REV [UNSPEC_COND_SUB UNSPEC_COND_DIV])\n-\n (define_int_iterator SVE_COND_FP_CMP [UNSPEC_COND_LT UNSPEC_COND_LE\n \t\t\t\t      UNSPEC_COND_EQ UNSPEC_COND_NE\n \t\t\t\t      UNSPEC_COND_GE UNSPEC_COND_GT])\n@@ -1802,6 +1813,13 @@\n \t\t\t    (UNSPEC_COND_MAX \"fmaxnm\")\n \t\t\t    (UNSPEC_COND_MIN \"fminnm\")])\n \n+(define_int_attr sve_fp_op_rev [(UNSPEC_COND_ADD \"fadd\")\n+\t\t\t        (UNSPEC_COND_SUB \"fsubr\")\n+\t\t\t        (UNSPEC_COND_MUL \"fmul\")\n+\t\t\t        (UNSPEC_COND_DIV \"fdivr\")\n+\t\t\t        (UNSPEC_COND_MAX \"fmaxnm\")\n+\t\t\t        (UNSPEC_COND_MIN \"fminnm\")])\n+\n (define_int_attr commutative [(UNSPEC_COND_ADD \"true\")\n \t\t\t      (UNSPEC_COND_SUB \"false\")\n \t\t\t      (UNSPEC_COND_MUL \"true\")"}, {"sha": "4acbc218a8da554b72c86aa512bdbc4423bbd117", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a08acce83a052a8b800eddaaae36e51e8de57643/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=a08acce83a052a8b800eddaaae36e51e8de57643", "patch": "@@ -625,3 +625,6 @@\n ;; A special predicate that doesn't match a particular mode.\n (define_special_predicate \"aarch64_any_register_operand\"\n   (match_code \"reg\"))\n+\n+(define_predicate \"aarch64_sve_any_binary_operator\"\n+  (match_code \"plus,minus,mult,div,udiv,smax,umax,smin,umin,and,ior,xor\"))"}]}