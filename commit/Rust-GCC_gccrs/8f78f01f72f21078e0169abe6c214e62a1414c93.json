{"sha": "8f78f01f72f21078e0169abe6c214e62a1414c93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY3OGYwMWY3MmYyMTA3OGUwMTY5YWJlNmMyMTRlNjJhMTQxNGM5Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-08-17T17:32:37Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-08-17T17:32:37Z"}, "message": "re PR c++/16965 (Confusing mismatch in error messages)\n\n\tPR c++/16965\n\t* cp-tree.h (qualified_name_lookup_error): Add parameter.\n\t* name-lookup.c (do_class_using_decl): Restrict set of entities\n\tpassed to cp_emit_debug_info_for_using more carefully.\n\t(lookup_qualified_name): Allow lookup_member to return sets of\n\tambiguous entries.\n\t* parser.c (cp_parser_lookup_name): Add ambiguous_p parameter.\n\t(cp_parser_primary_expression): Handle ambiguous lookups.\n\t(cp_parser_template_name): Adjust use of cp_parser_lookup_name.\n\t(cp_parser_template_argument): Likewise.\n\t(cp_parser_elaborate_type_specifier): Likewise.\n\t(cp_parser_namespace_name): Likewise.\n\t(cp_parser_class_name): Likewise.\n\t(cp_parser_lookup_name_simple): Likewise.\n\t* pt.c (tsubst_qualified_id): Handle ambiguous results.\n\t(tsubst_expr): Likewise.\n\t* semantics.c (qualified_name_lookup_error): Add decl paramter.\n\tFor ambiguous lookups, print candidates.\n\n\tPR c++/16965\n\t* g++.dg/parse/error17.C: New test.\n\nFrom-SVN: r86137", "tree": {"sha": "697ec760d74298d58c6bb50a122c01bbfe86c05b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/697ec760d74298d58c6bb50a122c01bbfe86c05b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f78f01f72f21078e0169abe6c214e62a1414c93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f78f01f72f21078e0169abe6c214e62a1414c93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f78f01f72f21078e0169abe6c214e62a1414c93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f78f01f72f21078e0169abe6c214e62a1414c93/comments", "author": null, "committer": null, "parents": [{"sha": "13a98f14d2c358714567c8284f7eefa419f2b076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a98f14d2c358714567c8284f7eefa419f2b076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a98f14d2c358714567c8284f7eefa419f2b076"}], "stats": {"total": 135, "additions": 107, "deletions": 28}, "files": [{"sha": "7ccf881bd5417ed3afca783dbfc339aa9b6a9b8b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -1,3 +1,24 @@\n+2004-08-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16965\n+\t* cp-tree.h (qualified_name_lookup_error): Add parameter.\n+\t* name-lookup.c (do_class_using_decl): Restrict set of entities\n+\tpassed to cp_emit_debug_info_for_using more carefully.\n+\t(lookup_qualified_name): Allow lookup_member to return sets of\n+\tambiguous entries.\n+\t* parser.c (cp_parser_lookup_name): Add ambiguous_p parameter.\n+\t(cp_parser_primary_expression): Handle ambiguous lookups.\n+\t(cp_parser_template_name): Adjust use of cp_parser_lookup_name.\n+\t(cp_parser_template_argument): Likewise.\n+\t(cp_parser_elaborate_type_specifier): Likewise.\n+\t(cp_parser_namespace_name): Likewise.\n+\t(cp_parser_class_name): Likewise.\n+\t(cp_parser_lookup_name_simple): Likewise.\n+\t* pt.c (tsubst_qualified_id): Handle ambiguous results.\n+\t(tsubst_expr): Likewise.\n+\t* semantics.c (qualified_name_lookup_error): Add decl paramter.\n+\tFor ambiguous lookups, print candidates.\n+\n 2004-08-16  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/6749"}, {"sha": "04a39b7d08b81575d4037600435bc577388b485b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -4166,7 +4166,7 @@ extern tree finish_template_type                (tree, tree, int);\n extern tree finish_base_specifier               (tree, tree, bool);\n extern void finish_member_declaration           (tree);\n extern void check_multiple_declarators          (void);\n-extern void qualified_name_lookup_error\t\t(tree, tree);\n+extern void qualified_name_lookup_error\t\t(tree, tree, tree);\n extern tree finish_id_expression                (tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *, tree *,\n \t\t\t\t\t\t bool, bool, bool *, "}, {"sha": "ccef113b5bcb5a66133b827a05b9c4d37691f4fd", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -2953,7 +2953,7 @@ do_class_using_decl (tree decl)\n       tree r;\n \n       r = lookup_qualified_name (scope, name, false, false);\n-      if (r && TREE_CODE (r) != ERROR_MARK)\n+      if (r && (DECL_P (r) || TREE_CODE (r) == OVERLOAD))\n \tcp_emit_debug_info_for_using (r, scope);\n     }\n   return value;\n@@ -3813,7 +3813,7 @@ unqualified_namespace_lookup (tree name, int flags)\n \n    Returns a DECL (or OVERLOAD, or BASELINK) representing the\n    declaration found.  If no suitable declaration can be found,\n-   ERROR_MARK_NODE is returned.  Iif COMPLAIN is true and SCOPE is\n+   ERROR_MARK_NODE is returned.  If COMPLAIN is true and SCOPE is\n    neither a class-type nor a namespace a diagnostic is issued.  */\n \n tree\n@@ -3834,7 +3834,7 @@ lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n   else if (is_aggr_type (scope, complain))\n     {\n       tree t;\n-      t = lookup_member (scope, name, 0, is_type_p);\n+      t = lookup_member (scope, name, 2, is_type_p);\n       if (t)\n \treturn t;\n     }"}, {"sha": "fa41ce6b00d083e2a4e441efed35124988790fd5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -1831,7 +1831,7 @@ static void cp_parser_label_declaration\n /* Utility Routines */\n \n static tree cp_parser_lookup_name\n-  (cp_parser *, tree, bool, bool, bool, bool);\n+  (cp_parser *, tree, bool, bool, bool, bool, bool *);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree);\n static tree cp_parser_maybe_treat_template_as_class\n@@ -2905,7 +2905,18 @@ cp_parser_primary_expression (cp_parser *parser,\n \t/* Look up the name.  */\n \telse\n \t  {\n-\t    decl = cp_parser_lookup_name_simple (parser, id_expression);\n+\t    bool ambiguous_p;\n+\n+\t    decl = cp_parser_lookup_name (parser, id_expression,\n+\t\t\t\t\t  /*is_type=*/false,\n+\t\t\t\t\t  /*is_template=*/false,\n+\t\t\t\t\t  /*is_namespace=*/false,\n+\t\t\t\t\t  /*check_dependency=*/true,\n+\t\t\t\t\t  &ambiguous_p);\n+\t    /* If the lookup was ambiguous, an error will already have\n+\t       been issued.  */\n+\t    if (ambiguous_p)\n+\t      return error_mark_node;\n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  Just propagate the\n \t       name.  */\n@@ -8331,7 +8342,8 @@ cp_parser_type_parameter (cp_parser* parser)\n \t\t\t\t\t/*is_type=*/false,\n \t\t\t\t\t/*is_template=*/is_template,\n \t\t\t\t\t/*is_namespace=*/false,\n-\t\t\t\t\t/*check_dependency=*/true);\n+\t\t\t\t\t/*check_dependency=*/true,\n+\t\t\t\t\t/*ambiguous_p=*/NULL);\n \t    /* See if the default argument is valid.  */\n \t    default_argument\n \t      = check_template_template_default_arg (default_argument);\n@@ -8710,7 +8722,8 @@ cp_parser_template_name (cp_parser* parser,\n \t\t\t\t/*is_type=*/false,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n-\t\t\t\tcheck_dependency_p);\n+\t\t\t\tcheck_dependency_p,\n+\t\t\t\t/*ambiguous_p=*/NULL);\n   decl = maybe_get_template_decl_from_type_decl (decl);\n \n   /* If DECL is a template, then the name was a template-name.  */\n@@ -8900,7 +8913,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t\t  /*is_type=*/false,\n \t\t\t\t\t  /*is_template=*/template_p,\n \t\t\t\t\t  /*is_namespace=*/false,\n-\t\t\t\t\t  /*check_dependency=*/true);\n+\t\t\t\t\t  /*check_dependency=*/true,\n+\t\t\t\t\t  /*ambiguous_p=*/NULL);\n       if (TREE_CODE (argument) != TEMPLATE_DECL\n \t  && TREE_CODE (argument) != UNBOUND_CLASS_TEMPLATE)\n \tcp_parser_error (parser, \"expected template-name\");\n@@ -9753,7 +9767,8 @@ cp_parser_elaborated_type_specifier (cp_parser* parser,\n \t\t\t\t\t/*is_type=*/true,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n-\t\t\t\t\t/*check_dependency=*/true);\n+\t\t\t\t\t/*check_dependency=*/true,\n+\t\t\t\t\t/*ambiguous_p=*/NULL);\n \n \t  /* If we are parsing friend declaration, DECL may be a\n \t     TEMPLATE_DECL tree node here.  However, we need to check\n@@ -10029,7 +10044,8 @@ cp_parser_namespace_name (cp_parser* parser)\n \t\t\t\t\t  /*is_type=*/false,\n \t\t\t\t\t  /*is_template=*/false,\n \t\t\t\t\t  /*is_namespace=*/true,\n-\t\t\t\t\t  /*check_dependency=*/true);\n+\t\t\t\t\t  /*check_dependency=*/true,\n+\t\t\t\t\t  /*ambiguous_p=*/NULL);\n   /* If it's not a namespace, issue an error.  */\n   if (namespace_decl == error_mark_node\n       || TREE_CODE (namespace_decl) != NAMESPACE_DECL)\n@@ -12239,7 +12255,8 @@ cp_parser_class_name (cp_parser *parser,\n \t\t\t\t\ttype_p,\n \t\t\t\t\t/*is_template=*/false,\n \t\t\t\t\t/*is_namespace=*/false,\n-\t\t\t\t\tcheck_dependency_p);\n+\t\t\t\t\tcheck_dependency_p,\n+\t\t\t\t\t/*ambiguous_p=*/NULL);\n \t}\n     }\n   else\n@@ -14121,16 +14138,24 @@ cp_parser_label_declaration (cp_parser* parser)\n    are ignored.\n \n    If CHECK_DEPENDENCY is TRUE, names are not looked up in dependent\n-   types.  */\n+   types.  \n+\n+   If AMBIGUOUS_P is non-NULL, it is set to true if name-lookup\n+   results in an ambiguity, and false otherwise.  */\n \n static tree\n cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       bool is_type, bool is_template, bool is_namespace,\n-\t\t       bool check_dependency)\n+\t\t       bool check_dependency,\n+\t\t       bool *ambiguous_p)\n {\n   tree decl;\n   tree object_type = parser->context->object_type;\n \n+  /* Assume that the lookup will be unambiguous.  */\n+  if (ambiguous_p)\n+    *ambiguous_p = false;\n+\n   /* Now that we have looked up the name, the OBJECT_TYPE (if any) is\n      no longer valid.  Note that if we are parsing tentatively, and\n      the parse fails, OBJECT_TYPE will be automatically restored.  */\n@@ -14278,6 +14303,8 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n   /* If it's a TREE_LIST, the result of the lookup was ambiguous.  */\n   if (TREE_CODE (decl) == TREE_LIST)\n     {\n+      if (ambiguous_p)\n+\t*ambiguous_p = true;\n       /* The error message we have to print is too complicated for\n \t cp_parser_error, so we incorporate its actions directly.  */\n       if (!cp_parser_simulate_error (parser))\n@@ -14319,7 +14346,8 @@ cp_parser_lookup_name_simple (cp_parser* parser, tree name)\n \t\t\t\t/*is_type=*/false,\n \t\t\t\t/*is_template=*/false,\n \t\t\t\t/*is_namespace=*/false,\n-\t\t\t\t/*check_dependency=*/true);\n+\t\t\t\t/*check_dependency=*/true,\n+\t\t\t\t/*ambiguous_p=*/NULL);\n }\n \n /* If DECL is a TEMPLATE_DECL that can be treated like a TYPE_DECL in"}, {"sha": "74322df0663d16a8cc1342a3caa4d918e071fc87", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -7396,18 +7396,28 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     }\n   \n   if (DECL_P (expr))\n-    check_accessibility_of_qualified_id (expr, /*object_type=*/NULL_TREE,\n-\t\t\t\t\t scope);\n-  \n-  /* Remember that there was a reference to this entity.  */\n-  if (DECL_P (expr))\n-    mark_used (expr);\n+    {\n+      check_accessibility_of_qualified_id (expr, /*object_type=*/NULL_TREE,\n+\t\t\t\t\t   scope);\n+      /* Remember that there was a reference to this entity.  */\n+      mark_used (expr);\n+    }\n+\n+  if (expr == error_mark_node || TREE_CODE (expr) == TREE_LIST)\n+    {\n+      if (complain & tf_error)\n+\tqualified_name_lookup_error (scope, \n+\t\t\t\t     TREE_OPERAND (qualified_id, 1),\n+\t\t\t\t     expr);\n+      return error_mark_node;\n+    }\n \n   if (is_template)\n     expr = lookup_template_function (expr, template_args);\n \n   if (expr == error_mark_node && complain & tf_error)\n-    qualified_name_lookup_error (scope, TREE_OPERAND (qualified_id, 1));\n+    qualified_name_lookup_error (scope, TREE_OPERAND (qualified_id, 1),\n+\t\t\t\t expr);\n   else if (TYPE_P (scope))\n     {\n       expr = (adjust_result_of_qualified_name_lookup \n@@ -7855,8 +7865,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    decl = lookup_qualified_name (scope, name,\n \t\t\t\t\t  /*is_type_p=*/false,\n \t\t\t\t\t  /*complain=*/false);\n-\t    if (decl == error_mark_node)\n-\t      qualified_name_lookup_error (scope, name);\n+\t    if (decl == error_mark_node || TREE_CODE (decl) == TREE_LIST)\n+\t      qualified_name_lookup_error (scope, name, decl);\n \t    else\n \t      do_local_using_decl (decl, scope, name);\n \t  }\n@@ -8510,7 +8520,8 @@ tsubst_copy_and_build (tree t,\n \t\t\t    args);\n \t    else\n \t      {\n-\t\tqualified_name_lookup_error (TREE_TYPE (object), tmpl);\n+\t\tqualified_name_lookup_error (TREE_TYPE (object), tmpl,\n+\t\t\t\t\t     member);\n \t\treturn error_mark_node;\n \t      }\n \t  }"}, {"sha": "f21c926d1dd2c08f9c37a096a612c45dfb96b556", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -2290,15 +2290,21 @@ check_multiple_declarators (void)\n     error (\"multiple declarators in template declaration\");\n }\n \n-/* Issue a diagnostic that NAME cannot be found in SCOPE.  */\n+/* Issue a diagnostic that NAME cannot be found in SCOPE.  DECL is\n+   what we found when we tried to do the lookup.  */\n \n void\n-qualified_name_lookup_error (tree scope, tree name)\n+qualified_name_lookup_error (tree scope, tree name, tree decl)\n {\n   if (TYPE_P (scope))\n     {\n       if (!COMPLETE_TYPE_P (scope))\n \terror (\"incomplete type `%T' used in nested name specifier\", scope);\n+      else if (TREE_CODE (decl) == TREE_LIST)\n+\t{\n+\t  error (\"reference to `%T::%D' is ambiguous\", scope, name);\n+\t  print_candidates (decl);\n+\t}\n       else\n \terror (\"`%D' is not a member of `%T'\", name, scope);\n     }\n@@ -2374,7 +2380,7 @@ finish_id_expression (tree id_expression,\n \t      /* If the qualifying type is non-dependent (and the name\n \t\t does not name a conversion operator to a dependent\n \t\t type), issue an error.  */\n-\t      qualified_name_lookup_error (scope, id_expression);\n+\t      qualified_name_lookup_error (scope, id_expression, decl);\n \t      return error_mark_node;\n \t    }\n \t  else if (!scope)"}, {"sha": "cd593ddcc7244ac754ade69a1b5a927dfe590289", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -1,3 +1,8 @@\n+2004-08-17  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/16965\n+\t* g++.dg/parse/error17.C: New test.\n+\t\n 2004-08-17  Dorit Naishlos  <dorit@il.ibm.com>\n \n \t* gcc.dg/vect: New directory for vectorizer tests."}, {"sha": "2a8f3f829ca52f1e03d9f4b4dd56097fd3653868", "filename": "gcc/testsuite/g++.dg/parse/error17.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f78f01f72f21078e0169abe6c214e62a1414c93/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror17.C?ref=8f78f01f72f21078e0169abe6c214e62a1414c93", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/16965\n+\n+template <typename T> struct B { \n+  static int Bar(T); // { dg-error \"\" }\n+}; \n+struct D : B<int>, B<char> {}; \n+ \n+int i2 = D::Bar(2); // { dg-error \"\" }"}]}