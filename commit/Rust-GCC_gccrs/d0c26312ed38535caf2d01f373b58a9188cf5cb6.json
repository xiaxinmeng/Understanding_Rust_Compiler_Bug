{"sha": "d0c26312ed38535caf2d01f373b58a9188cf5cb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBjMjYzMTJlZDM4NTM1Y2FmMmQwMWYzNzNiNThhOTE4OGNmNWNiNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-12T11:27:24Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-12T11:27:24Z"}, "message": "decl.c (gnat_to_gnu_entity): Tidy up code, improve comments and fix formatting nits.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Tidy up\n\tcode, improve comments and fix formatting nits.\n\nFrom-SVN: r159312", "tree": {"sha": "de8b411a7031807e053841dd839af3e8e6e97cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de8b411a7031807e053841dd839af3e8e6e97cf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0c26312ed38535caf2d01f373b58a9188cf5cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c26312ed38535caf2d01f373b58a9188cf5cb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0c26312ed38535caf2d01f373b58a9188cf5cb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0c26312ed38535caf2d01f373b58a9188cf5cb6/comments", "author": null, "committer": null, "parents": [{"sha": "101422f0496f2c01f30cb507d59dfdc405a87007", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/101422f0496f2c01f30cb507d59dfdc405a87007", "html_url": "https://github.com/Rust-GCC/gccrs/commit/101422f0496f2c01f30cb507d59dfdc405a87007"}], "stats": {"total": 214, "additions": 104, "deletions": 110}, "files": [{"sha": "1f0d92e037de2249891aa61ecfc3fb1ba5524df0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c26312ed38535caf2d01f373b58a9188cf5cb6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c26312ed38535caf2d01f373b58a9188cf5cb6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d0c26312ed38535caf2d01f373b58a9188cf5cb6", "patch": "@@ -1,3 +1,8 @@\n+2010-05-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Access_Type>: Tidy up\n+\tcode, improve comments and fix formatting nits.\n+\n 2010-05-12  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/utils.c (update_pointer_to): Return early if the old"}, {"sha": "49a06fbfd7db6dc506ef75b6fd09442801d8bdc1", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 99, "deletions": 110, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0c26312ed38535caf2d01f373b58a9188cf5cb6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0c26312ed38535caf2d01f373b58a9188cf5cb6/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=d0c26312ed38535caf2d01f373b58a9188cf5cb6", "patch": "@@ -3358,21 +3358,23 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Anonymous_Access_Type:\n     case E_General_Access_Type:\n       {\n+\t/* The designated type and its equivalent type for gigi.  */\n \tEntity_Id gnat_desig_type = Directly_Designated_Type (gnat_entity);\n \tEntity_Id gnat_desig_equiv = Gigi_Equivalent_Type (gnat_desig_type);\n+\t/* Whether it comes from a limited with.  */\n \tbool is_from_limited_with\n \t  = (IN (Ekind (gnat_desig_equiv), Incomplete_Kind)\n \t     && From_With_Type (gnat_desig_equiv));\n-\n-\t/* Get the \"full view\" of this entity.  If this is an incomplete\n+\t/* The \"full view\" of the designated type.  If this is an incomplete\n \t   entity from a limited with, treat its non-limited view as the full\n \t   view.  Otherwise, if this is an incomplete or private type, use the\n \t   full view.  In the former case, we might point to a private type,\n \t   in which case, we need its full view.  Also, we want to look at the\n \t   actual type used for the representation, so this takes a total of\n \t   three steps.  */\n \tEntity_Id gnat_desig_full_direct_first\n-\t  = (is_from_limited_with ? Non_Limited_View (gnat_desig_equiv)\n+\t  = (is_from_limited_with\n+\t     ? Non_Limited_View (gnat_desig_equiv)\n \t     : (IN (Ekind (gnat_desig_equiv), Incomplete_Or_Private_Kind)\n \t\t? Full_View (gnat_desig_equiv) : Empty));\n \tEntity_Id gnat_desig_full_direct\n@@ -3383,27 +3385,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     : gnat_desig_full_direct_first);\n \tEntity_Id gnat_desig_full\n \t  = Gigi_Equivalent_Type (gnat_desig_full_direct);\n-\n-\t/* This the type actually used to represent the designated type,\n-\t   either gnat_desig_full or gnat_desig_equiv.  */\n+\t/* The type actually used to represent the designated type, either\n+\t   gnat_desig_full or gnat_desig_equiv.  */\n \tEntity_Id gnat_desig_rep;\n-\n \t/* True if this is a pointer to an unconstrained array.  */\n \tbool is_unconstrained_array;\n-\n \t/* We want to know if we'll be seeing the freeze node for any\n \t   incomplete type we may be pointing to.  */\n \tbool in_main_unit\n \t  = (Present (gnat_desig_full)\n \t     ? In_Extended_Main_Code_Unit (gnat_desig_full)\n \t     : In_Extended_Main_Code_Unit (gnat_desig_type));\n-\n \t/* True if we make a dummy type here.  */\n-\tbool got_fat_p = false;\n-\t/* True if the dummy is a fat pointer.  */\n \tbool made_dummy = false;\n-\ttree gnu_desig_type = NULL_TREE;\n+\t/* True if the dummy type is a fat pointer.  */\n+\tbool got_fat_p = false;\n+\t/* The mode to be used for the pointer type.  */\n \tenum machine_mode p_mode = mode_for_size (esize, MODE_INT, 0);\n+\t/* The GCC type used for the designated type.  */\n+\ttree gnu_desig_type = NULL_TREE;\n \n \tif (!targetm.valid_pointer_mode (p_mode))\n \t  p_mode = ptr_mode;\n@@ -3416,22 +3416,21 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   issues.  This can lose some code efficiency, but there is no\n \t   alternative.  */\n \tif (Ekind (gnat_desig_equiv) == E_Array_Subtype\n-\t    && ! Is_Constrained (gnat_desig_equiv))\n+\t    && !Is_Constrained (gnat_desig_equiv))\n \t  gnat_desig_equiv = Etype (gnat_desig_equiv);\n \tif (Present (gnat_desig_full)\n \t    && ((Ekind (gnat_desig_full) == E_Array_Subtype\n-\t\t && ! Is_Constrained (gnat_desig_full))\n+\t\t && !Is_Constrained (gnat_desig_full))\n \t\t|| (Ekind (gnat_desig_full) == E_Record_Subtype\n \t\t    && Ekind (Etype (gnat_desig_full)) == E_Record_Type)))\n \t  gnat_desig_full = Etype (gnat_desig_full);\n \n-\t/* Now set the type that actually marks the representation of\n-\t   the designated type and also flag whether we have a unconstrained\n-\t   array.  */\n-\tgnat_desig_rep = gnat_desig_full ? gnat_desig_full : gnat_desig_equiv;\n+\t/* Set the type that's actually the representation of the designated\n+\t   type and also flag whether we have a unconstrained array.  */\n+\tgnat_desig_rep\n+\t  = Present (gnat_desig_full) ? gnat_desig_full : gnat_desig_equiv;\n \tis_unconstrained_array\n-\t  = (Is_Array_Type (gnat_desig_rep)\n-\t     && ! Is_Constrained (gnat_desig_rep));\n+\t  = Is_Array_Type (gnat_desig_rep) && !Is_Constrained (gnat_desig_rep);\n \n \t/* If we are pointing to an incomplete type whose completion is an\n \t   unconstrained array, make a fat pointer type.  The two types in our\n@@ -3442,31 +3441,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (is_unconstrained_array\n \t    && (Present (gnat_desig_full)\n \t\t|| (present_gnu_tree (gnat_desig_equiv)\n-\t\t    && TYPE_IS_DUMMY_P (TREE_TYPE\n-\t\t\t\t\t(get_gnu_tree (gnat_desig_equiv))))\n-\t\t|| (No (gnat_desig_full) && ! in_main_unit\n-\t\t    && defer_incomplete_level != 0\n-\t\t    && ! present_gnu_tree (gnat_desig_equiv))\n-\t\t|| (in_main_unit && is_from_limited_with\n-\t\t    && Present (Freeze_Node (gnat_desig_rep)))))\n+\t\t    && TYPE_IS_DUMMY_P\n+\t\t       (TREE_TYPE (get_gnu_tree (gnat_desig_equiv))))\n+\t\t|| (!in_main_unit\n+\t\t    && defer_incomplete_level\n+\t\t    && !present_gnu_tree (gnat_desig_equiv))\n+\t\t|| (in_main_unit\n+\t\t    && is_from_limited_with\n+\t\t    && Present (Freeze_Node (gnat_desig_equiv)))))\n \t  {\n-\t    tree gnu_old;\n-\n \t    if (present_gnu_tree (gnat_desig_rep))\n-\t      gnu_old = TREE_TYPE (get_gnu_tree (gnat_desig_rep));\n+\t      gnu_desig_type = TREE_TYPE (get_gnu_tree (gnat_desig_rep));\n \t    else\n \t      {\n-\t\tgnu_old = make_dummy_type (gnat_desig_rep);\n-\n+\t\tgnu_desig_type = make_dummy_type (gnat_desig_rep);\n \t\t/* Show the dummy we get will be a fat pointer.  */\n \t\tgot_fat_p = made_dummy = true;\n \t      }\n \n-\t    /* If the call above got something that has a pointer, that\n-\t       pointer is our type.  This could have happened either\n-\t       because the type was elaborated or because somebody\n-\t       else executed the code below.  */\n-\t    gnu_type = TYPE_POINTER_TO (gnu_old);\n+\t    /* If the call above got something that has a pointer, the pointer\n+\t       is our type.  This could have happened either because the type\n+\t       was elaborated or because somebody else executed the code.  */\n+\t    gnu_type = TYPE_POINTER_TO (gnu_desig_type);\n \t    if (!gnu_type)\n \t      {\n \t\ttree gnu_template_type = make_node (ENUMERAL_TYPE);\n@@ -3484,18 +3480,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tTYPE_DUMMY_P (gnu_array_type) = 1;\n \n \t\tgnu_type = make_node (RECORD_TYPE);\n-\t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_old);\n-\t\tTYPE_POINTER_TO (gnu_old) = gnu_type;\n+\t\tSET_TYPE_UNCONSTRAINED_ARRAY (gnu_type, gnu_desig_type);\n+\t\tTYPE_POINTER_TO (gnu_desig_type) = gnu_type;\n \n \t\tfields\n-\t\t  = chainon (chainon (NULL_TREE,\n-\t\t\t\t      create_field_decl\n-\t\t\t\t      (get_identifier (\"P_ARRAY\"),\n+\t\t  = create_field_decl (get_identifier (\"P_ARRAY\"),\n \t\t\t\t       gnu_ptr_array, gnu_type,\n-\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0)),\n-\t\t\t     create_field_decl (get_identifier (\"P_BOUNDS\"),\n-\t\t\t\t\t\tgnu_ptr_template, gnu_type,\n-\t\t\t\t\t\tNULL_TREE, NULL_TREE, 0, 0));\n+\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n+\t\tTREE_CHAIN (fields)\n+\t\t  = create_field_decl (get_identifier (\"P_BOUNDS\"),\n+\t\t\t\t       gnu_ptr_template, gnu_type,\n+\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0);\n \n \t\t/* Make sure we can place this into a register.  */\n \t\tTYPE_ALIGN (gnu_type)\n@@ -3506,10 +3501,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   of its fields are incomplete.  */\n \t\tfinish_record_type (gnu_type, fields, 0, false);\n \n-\t\tTYPE_OBJECT_RECORD_TYPE (gnu_old) = make_node (RECORD_TYPE);\n-\t\tTYPE_NAME (TYPE_OBJECT_RECORD_TYPE (gnu_old))\n+\t\tTYPE_OBJECT_RECORD_TYPE (gnu_desig_type)\n+\t\t  = make_node (RECORD_TYPE);\n+\t\tTYPE_NAME (TYPE_OBJECT_RECORD_TYPE (gnu_desig_type))\n \t\t  = create_concat_name (gnat_desig_equiv, \"XUT\");\n-\t\tTYPE_DUMMY_P (TYPE_OBJECT_RECORD_TYPE (gnu_old)) = 1;\n+\t\tTYPE_DUMMY_P (TYPE_OBJECT_RECORD_TYPE (gnu_desig_type)) = 1;\n \t      }\n \t  }\n \n@@ -3518,35 +3514,35 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t && present_gnu_tree (gnat_desig_full))\n \t  gnu_desig_type = TREE_TYPE (get_gnu_tree (gnat_desig_full));\n \n-\t/* Get the type of the thing we are to point to and build a pointer\n-\t   to it.  If it is a reference to an incomplete or private type with a\n+\t/* Get the type of the thing we are to point to and build a pointer to\n+\t   it.  If it is a reference to an incomplete or private type with a\n \t   full view that is a record, make a dummy type node and get the\n \t   actual type later when we have verified it is safe.  */\n-\telse if ((! in_main_unit\n-\t\t  && ! present_gnu_tree (gnat_desig_equiv)\n+\telse if ((!in_main_unit\n+\t\t  && !present_gnu_tree (gnat_desig_equiv)\n \t\t  && Present (gnat_desig_full)\n-\t\t  && ! present_gnu_tree (gnat_desig_full)\n+\t\t  && !present_gnu_tree (gnat_desig_full)\n \t\t  && Is_Record_Type (gnat_desig_full))\n-\t\t /* Likewise if we are pointing to a record or array and we\n-\t\t    are to defer elaborating incomplete types.  We do this\n-\t\t    since this access type may be the full view of some\n-\t\t    private type.  Note that the unconstrained array case is\n-\t\t    handled above.  */\n-\t\t || ((! in_main_unit || imported_p)\n-\t\t     && defer_incomplete_level != 0\n-\t\t     && ! present_gnu_tree (gnat_desig_equiv)\n-\t\t     && ((Is_Record_Type (gnat_desig_rep)\n-\t\t\t  || Is_Array_Type (gnat_desig_rep))))\n+\t\t /* Likewise if we are pointing to a record or array and we are\n+\t\t    to defer elaborating incomplete types.  We do this as this\n+\t\t    access type may be the full view of a private type.  Note\n+\t\t    that the unconstrained array case is handled above.  */\n+\t\t || ((!in_main_unit || imported_p)\n+\t\t     && defer_incomplete_level\n+\t\t     && !present_gnu_tree (gnat_desig_equiv)\n+\t\t     && (Is_Record_Type (gnat_desig_rep)\n+\t\t\t || Is_Array_Type (gnat_desig_rep)))\n \t\t /* If this is a reference from a limited_with type back to our\n-\t\t    main unit and there's a Freeze_Node for it, either we have\n+\t\t    main unit and there's a freeze node for it, either we have\n \t\t    already processed the declaration and made the dummy type,\n \t\t    in which case we just reuse the latter, or we have not yet,\n \t\t    in which case we make the dummy type and it will be reused\n-\t\t    when the declaration is processed.  In both cases, the\n-\t\t    pointer eventually created below will be automatically\n-\t\t    adjusted when the Freeze_Node is processed.  Note that the\n+\t\t    when the declaration is finally processed.  In both cases,\n+\t\t    the pointer eventually created below will be automatically\n+\t\t    adjusted when the freeze node is processed.  Note that the\n \t\t    unconstrained array case is handled above.  */\n-\t\t ||  (in_main_unit && is_from_limited_with\n+\t\t ||  (in_main_unit\n+\t\t      && is_from_limited_with\n \t\t      && Present (Freeze_Node (gnat_desig_rep))))\n \t  {\n \t    gnu_desig_type = make_dummy_type (gnat_desig_equiv);\n@@ -3562,13 +3558,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    TREE_TYPE (gnu_type) = TYPE_POINTER_TO (gnu_type) = gnu_type;\n \t  }\n \n-\t/* If expansion is disabled, the equivalent type of a concurrent\n-\t   type is absent, so build a dummy pointer type.  */\n+\t/* If expansion is disabled, the equivalent type of a concurrent type\n+\t   is absent, so build a dummy pointer type.  */\n \telse if (type_annotate_only && No (gnat_desig_equiv))\n \t  gnu_type = ptr_void_type_node;\n \n-\t/* Finally, handle the straightforward case where we can just\n-\t   elaborate our designated type and point to it.  */\n+\t/* Finally, handle the default case where we can just elaborate our\n+\t   designated type.  */\n \telse\n \t  gnu_desig_type = gnat_to_gnu_type (gnat_desig_equiv);\n \n@@ -3580,11 +3576,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    break;\n \t  }\n \n-\t/* If we have a GCC type for the designated type, possibly modify it\n-\t   if we are pointing only to constant objects and then make a pointer\n-\t   to it.  Don't do this for unconstrained arrays.  */\n-\tif (!gnu_type && gnu_desig_type)\n+\t/* If we have not done it yet, build the pointer type the usual way.  */\n+\tif (!gnu_type)\n \t  {\n+\t    /* Modify the designated type if we are pointing only to constant\n+\t       objects, but don't do it for unconstrained arrays.  */\n \t    if (Is_Access_Constant (gnat_entity)\n \t\t&& TREE_CODE (gnu_desig_type) != UNCONSTRAINED_ARRAY_TYPE)\n \t      {\n@@ -3623,17 +3619,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t     No_Strict_Aliasing (gnat_entity));\n \t  }\n \n-\t/* If we are not defining this object and we made a dummy pointer,\n+\t/* If we are not defining this object and we have made a dummy pointer,\n \t   save our current definition, evaluate the actual type, and replace\n \t   the tentative type we made with the actual one.  If we are to defer\n-\t   actually looking up the actual type, make an entry in the\n-\t   deferred list.  If this is from a limited with, we have to defer\n-\t   to the end of the current spec in two cases: first if the\n-\t   designated type is in the current unit and second if the access\n-\t   type is.  */\n-\tif ((! in_main_unit || is_from_limited_with) && made_dummy)\n+\t   actually looking up the actual type, make an entry in the deferred\n+\t   list.  If this is from a limited with, we have to defer to the end\n+\t   of the current spec in two cases: first if the designated type is\n+\t   in the current unit and second if the access type itself is.  */\n+\tif ((!in_main_unit || is_from_limited_with) && made_dummy)\n \t  {\n-\t    tree gnu_old_type\n+\t    bool is_from_limited_with_in_main_unit\n+\t      = (is_from_limited_with\n+\t\t && (in_main_unit\n+\t\t     || In_Extended_Main_Code_Unit (gnat_entity)));\n+\t    tree gnu_old_desig_type\n \t      = TYPE_IS_FAT_POINTER_P (gnu_type)\n \t\t? TYPE_UNCONSTRAINED_ARRAY (gnu_type) : TREE_TYPE (gnu_type);\n \n@@ -3652,37 +3651,27 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    save_gnu_tree (gnat_entity, gnu_decl, false);\n \t    saved = true;\n \n-\t    if (defer_incomplete_level == 0\n-\t\t&& ! (is_from_limited_with\n-\t\t      && (in_main_unit\n-\t\t\t  || In_Extended_Main_Code_Unit (gnat_entity))))\n-\t      update_pointer_to (TYPE_MAIN_VARIANT (gnu_old_type),\n-\t\t\t\t gnat_to_gnu_type (gnat_desig_equiv));\n-\n-\t      /* Note that the call to gnat_to_gnu_type here might have\n-\t\t updated gnu_old_type directly, in which case it is not a\n-\t\t dummy type any more when we get into update_pointer_to.\n+\t    /* Note that the call to gnat_to_gnu_type on gnat_desig_equiv might\n+\t       update gnu_old_desig_type directly, in which case it will not be\n+\t       a dummy type any more when we get into update_pointer_to.\n \n-\t\t This may happen for instance when the designated type is a\n-\t\t record type, because their elaboration starts with an\n-\t\t initial node from make_dummy_type, which may yield the same\n-\t\t node as the one we got.\n+\t       This can happen e.g. when the designated type is a record type,\n+\t       because their elaboration starts with an initial node from\n+\t       make_dummy_type, which may be the same node as the one we got.\n \n-\t\t Besides, variants of this non-dummy type might have been\n-\t\t created along the way.  update_pointer_to is expected to\n-\t\t properly take care of those situations.  */\n+\t       Besides, variants of this non-dummy type might have been created\n+\t       along the way.  update_pointer_to is expected to properly take\n+\t       care of those situations.  */\n+\t    if (!defer_incomplete_level && !is_from_limited_with_in_main_unit)\n+\t      update_pointer_to (TYPE_MAIN_VARIANT (gnu_old_desig_type),\n+\t\t\t\t gnat_to_gnu_type (gnat_desig_equiv));\n \t    else\n \t      {\n-\t\tstruct incomplete *p\n-\t\t  = (struct incomplete *) xmalloc (sizeof\n-\t\t\t\t\t\t   (struct incomplete));\n+\t\tstruct incomplete *p = XNEW (struct incomplete);\n \t\tstruct incomplete **head\n-\t\t  = (is_from_limited_with\n-\t\t     && (in_main_unit\n-\t\t\t || In_Extended_Main_Code_Unit (gnat_entity))\n+\t\t  = (is_from_limited_with_in_main_unit\n \t\t     ? &defer_limited_with : &defer_incomplete_list);\n-\n-\t\tp->old_type = gnu_old_type;\n+\t\tp->old_type = gnu_old_desig_type;\n \t\tp->full_type = gnat_desig_equiv;\n \t\tp->next = *head;\n \t\t*head = p;"}]}