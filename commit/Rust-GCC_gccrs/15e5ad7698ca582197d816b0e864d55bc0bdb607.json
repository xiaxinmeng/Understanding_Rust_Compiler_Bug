{"sha": "15e5ad7698ca582197d816b0e864d55bc0bdb607", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVlNWFkNzY5OGNhNTgyMTk3ZDgxNmIwZTg2NGQ1NWJjMGJkYjYwNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-25T20:52:28Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2002-03-25T20:52:28Z"}, "message": "toplev.c: Don't include setjmp.h.\n\n\t* toplev.c: Don't include setjmp.h.  Kill float_handler_set,\n\tfloat_handled, float_handler, float_signal, set_float_handler,\n\tand do_float_handler.  Set handler for SIGFPE to crash_signal.\n\t* toplev.h: Don't prototype do_float_handler.\n\n\t* c-lex.c: Fold parse_float into lex_number.  Make warning\n\tabout portability of hex float constants more informative, and\n\tdon't issue it on top of a syntax error.\n\t* fold-const.c: Fold const_binop_1 and fold_convert_1 into\n\ttheir callers.\n\t* real.h: Define REAL_VALUE_ABS here...\n\t* simplify-rtx.c: ... not here.  Fold check_fold_consts,\n\tsimplify_unary_real, simplify_binary_real, and\n\tsimplify_binary_is2orm1 into their callers.\n\t* tree.c: Fold build_real_from_int_cst_1 into caller.\n\n\t* doc/tm.texi: Document REAL_VALUE_ABS and REAL_VALUE_NEGATIVE.\n\n\t* tsystem.h: Include float.h here...\n\t* libgcc2.c: ... not here.\n\njava:\n\t* lex.c: Change java_perform_atof to take normal parameters\n\tinstead of a pointer to a parameter block.  Call it directly\n\tfrom java_lex.\n\ntestsuite:\n\t* gcc.dg/c90-hexfloat-1.c: Adjust error regexps.\n\nFrom-SVN: r51336", "tree": {"sha": "8c35b0cf468101ecc396f5eb7631e99dc328e79c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c35b0cf468101ecc396f5eb7631e99dc328e79c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15e5ad7698ca582197d816b0e864d55bc0bdb607", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e5ad7698ca582197d816b0e864d55bc0bdb607", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e5ad7698ca582197d816b0e864d55bc0bdb607", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e5ad7698ca582197d816b0e864d55bc0bdb607/comments", "author": null, "committer": null, "parents": [{"sha": "99ffa1e37aad3fafd771f47b56c0085ce5544727", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99ffa1e37aad3fafd771f47b56c0085ce5544727", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99ffa1e37aad3fafd771f47b56c0085ce5544727"}], "stats": {"total": 777, "additions": 217, "deletions": 560}, "files": [{"sha": "10063e10d271a7b5f0d6f40f30069a882d3f2dcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -1,3 +1,26 @@\n+2002-03-25  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* toplev.c: Don't include setjmp.h.  Kill float_handler_set,\n+\tfloat_handled, float_handler, float_signal, set_float_handler,\n+\tand do_float_handler.  Set handler for SIGFPE to crash_signal.\n+\t* toplev.h: Don't prototype do_float_handler.\n+\n+\t* c-lex.c: Fold parse_float into lex_number.  Make warning\n+\tabout portability of hex float constants more informative, and\n+\tdon't issue it on top of a syntax error.\n+\t* fold-const.c: Fold const_binop_1 and fold_convert_1 into\n+\ttheir callers.\n+\t* real.h: Define REAL_VALUE_ABS here...\n+\t* simplify-rtx.c: ... not here.  Fold check_fold_consts,\n+\tsimplify_unary_real, simplify_binary_real, and\n+\tsimplify_binary_is2orm1 into their callers.\n+\t* tree.c: Fold build_real_from_int_cst_1 into caller.\n+\n+\t* doc/tm.texi: Document REAL_VALUE_ABS and REAL_VALUE_NEGATIVE.\n+\n+\t* tsystem.h: Include float.h here...\n+\t* libgcc2.c: ... not here.\n+\n 2002-03-25  Nick Clifton  <nickc@cambridge.redhat.com>\n \n \tFixes for: PR bootstrap/3591, target/5676\n@@ -52,7 +75,7 @@\n \n 2002-03-24  Richard Henderson  <rth@redhat.com>\n \n-\t* recog.c (peephole2_optimize): Split blocks when EH insns are \n+\t* recog.c (peephole2_optimize): Split blocks when EH insns are\n \tgenerated in the middle of a block.  Do global life update if\n \tzapped EH edges.\n \n@@ -63,7 +86,7 @@\n 2002-03-24  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \tpreprocessor/3951\n-\t* gcc.c (cpp_options): Pass -MD through as -MD not -M -MF.\t\n+\t* gcc.c (cpp_options): Pass -MD through as -MD not -M -MF.\n \t* cppinit.c (cpp_handle_option): Set no_ouput if -MD or -MMD.\n \t(init_dependency_output): Don't make no_output decision here.\n \n@@ -154,7 +177,7 @@ objc:\n \tPR java/5489\n \t* arm.md (return, sibcall_epilogue): Pass const_true_rtx as the\n \toperand argument to output_return_instruction.\n-\t* arm.c (arm_print_operand, case 'd'): If the operand is \n+\t* arm.c (arm_print_operand, case 'd'): If the operand is\n \tconst_true_rtx then just return.\n \t(arm_print_operand, case 'D'): If the operand is const_true_rtx\n \tthen abort.\n@@ -171,7 +194,7 @@ objc:\n \t(warn_switch): Update comment.\n \t* stmt.c (expand_end_case): Check for and, when\n \twarn_switch_no_default, warn of a missing default case.\n-\t\n+\n 2002-03-23  Alan Modra  <amodra@bigpond.net.au>\n \n \t* real.h (N): Special case 128 bit doubles."}, {"sha": "0b910a63aaca3d940bf0c4b3420fe094a8adcef3", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -921,20 +921,28 @@ package body Sem_Eval is\n          declare\n             Arr : constant Node_Id := Constant_Value (Entity (Prefix (Op)));\n             Sub : constant Node_Id := First (Expressions (Op));\n-            Ind : constant Node_Id := First_Index (Etype (Arr));\n-            Lbd : constant Node_Id := Type_Low_Bound (Etype (Ind));\n+            Aty : constant Node_Id := Etype (Arr);\n \n             Lin : Nat;\n             --  Linear one's origin subscript value for array reference\n \n+            Lbd : Node_Id;\n+            --  Lower bound of the first array index\n+\n             Elm : Node_Id;\n             --  Value from constant array\n \n          begin\n+            if Ekind (Aty) = E_String_Literal_Subtype then\n+               Lbd := String_Literal_Low_Bound (Aty);\n+            else\n+               Lbd := Type_Low_Bound (Etype (First_Index (Aty)));\n+            end if;\n+\n             if Compile_Time_Known_Value (Sub)\n               and then Nkind (Arr) = N_Aggregate\n               and then Compile_Time_Known_Value (Lbd)\n-              and then Is_Discrete_Type (Component_Type (Etype (Arr)))\n+              and then Is_Discrete_Type (Component_Type (Aty))\n             then\n                Lin := UI_To_Int (Expr_Value (Sub) - Expr_Value (Lbd)) + 1;\n "}, {"sha": "29c15e799094f45e13f3c0d6480b23078d9ce598", "filename": "gcc/c-lex.c", "status": "modified", "additions": 36, "deletions": 90, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -84,7 +84,6 @@ int c_header_level;\t /* depth in C headers - C++ only */\n /* Nonzero tells yylex to ignore \\ in string constants.  */\n static int ignore_escape_flag;\n \n-static void parse_float\t\tPARAMS ((PTR));\n static tree lex_number\t\tPARAMS ((const char *, unsigned int));\n static tree lex_string\t\tPARAMS ((const unsigned char *, unsigned int,\n \t\t\t\t\t int));\n@@ -703,67 +702,6 @@ struct try_type type_sequence[] =\n };\n #endif /* 0 */\n \f\n-struct pf_args\n-{\n-  /* Input */\n-  const char *str;\n-  int fflag;\n-  int lflag;\n-  int base;\n-  /* Output */\n-  int conversion_errno;\n-  REAL_VALUE_TYPE value;\n-  tree type;\n-};\n- \n-static void\n-parse_float (data)\n-  PTR data;\n-{\n-  struct pf_args * args = (struct pf_args *) data;\n-  const char *typename;\n-\n-  args->conversion_errno = 0;\n-  args->type = double_type_node;\n-  typename = \"double\";\n-\n-  /* The second argument, machine_mode, of REAL_VALUE_ATOF\n-     tells the desired precision of the binary result\n-     of decimal-to-binary conversion.  */\n-\n-  if (args->fflag)\n-    {\n-      if (args->lflag)\n-\terror (\"both 'f' and 'l' suffixes on floating constant\");\n-\n-      args->type = float_type_node;\n-      typename = \"float\";\n-    }\n-  else if (args->lflag)\n-    {\n-      args->type = long_double_type_node;\n-      typename = \"long double\";\n-    }\n-  else if (flag_single_precision_constant)\n-    {\n-      args->type = float_type_node;\n-      typename = \"float\";\n-    }\n-\n-  errno = 0;\n-  if (args->base == 16)\n-    args->value = REAL_VALUE_HTOF (args->str, TYPE_MODE (args->type));\n-  else\n-    args->value = REAL_VALUE_ATOF (args->str, TYPE_MODE (args->type));\n-\n-  args->conversion_errno = errno;\n-  /* A diagnostic is required here by some ISO C testsuites.\n-     This is not pedwarn, because some people don't want\n-     an error for this.  */\n-  if (REAL_VALUE_ISINF (args->value) && pedantic)\n-    warning (\"floating point number exceeds range of '%s'\", typename);\n-}\n- \n int\n c_lex (value)\n      tree *value;\n@@ -974,14 +912,11 @@ lex_number (str, len)\n   if (floatflag != NOT_FLOAT)\n     {\n       tree type;\n-      int imag, fflag, lflag, conversion_errno;\n+      const char *typename;\n+      int imag, fflag, lflag;\n       REAL_VALUE_TYPE real;\n-      struct pf_args args;\n       char *copy;\n \n-      if (base == 16 && pedantic && !flag_isoc99)\n-\tpedwarn (\"floating constant may not be in radix 16\");\n-\n       if (base == 16 && floatflag != AFTER_EXPON)\n \tERROR (\"hexadecimal floating constant has no exponent\");\n \n@@ -1046,34 +981,45 @@ lex_number (str, len)\n \t    ERROR (\"invalid suffix on floating constant\");\n \t  }\n \n-      /* Setup input for parse_float() */\n-      args.str = copy;\n-      args.fflag = fflag;\n-      args.lflag = lflag;\n-      args.base = base;\n+      type = double_type_node;\n+      typename = \"double\";\n+\t\n+      if (fflag)\n+\t{\n+\t  if (lflag)\n+\t    ERROR (\"both 'f' and 'l' suffixes on floating constant\");\n \n-      /* Convert string to a double, checking for overflow.  */\n-      if (do_float_handler (parse_float, (PTR) &args))\n+\t  type = float_type_node;\n+\t  typename = \"float\";\n+\t}\n+      else if (lflag)\n \t{\n-\t  /* Receive output from parse_float() */\n-\t  real = args.value;\n+\t  type = long_double_type_node;\n+\t  typename = \"long double\";\n \t}\n+      else if (flag_single_precision_constant)\n+\t{\n+\t  type = float_type_node;\n+\t  typename = \"float\";\n+\t}\n+\n+      /* Warn about this only after we know we're not issuing an error.  */\n+      if (base == 16 && pedantic && !flag_isoc99)\n+\tpedwarn (\"hexadecimal floating constants are only valid in C99\");\n+\n+      /* The second argument, machine_mode, of REAL_VALUE_ATOF\n+\t tells the desired precision of the binary result\n+\t of decimal-to-binary conversion.  */\n+      if (base == 16)\n+\treal = REAL_VALUE_HTOF (copy, TYPE_MODE (type));\n       else\n-\t  /* We got an exception from parse_float() */\n-\t  ERROR (\"floating constant out of range\");\n-\n-      /* Receive output from parse_float() */\n-      conversion_errno = args.conversion_errno;\n-      type = args.type;\n-\t    \n-#ifdef ERANGE\n-      /* ERANGE is also reported for underflow,\n-\t so test the value to distinguish overflow from that.  */\n-      if (conversion_errno == ERANGE && pedantic\n-\t  && (REAL_VALUES_LESS (dconst1, real)\n-\t      || REAL_VALUES_LESS (real, dconstm1)))\n+\treal = REAL_VALUE_ATOF (copy, TYPE_MODE (type));\n+\n+      /* A diagnostic is required here by some ISO C testsuites.\n+\t This is not pedwarn, because some people don't want\n+\t an error for this.  */\n+      if (REAL_VALUE_ISINF (real) && pedantic)\n \twarning (\"floating point number exceeds range of 'double'\");\n-#endif\n \n       /* Create a node with determined type and value.  */\n       if (imag)"}, {"sha": "021d02321bbf1be6ed7ad4bd05231636aefdcb82", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -7829,6 +7829,10 @@ decimal and hexadecimal floating point constants, using the syntax\n defined by the C language for both.\n @end deftypefn\n \n+@deftypefn Macro int REAL_VALUE_NEGATIVE (REAL_VALUE_TYPE @var{x})\n+Returns 1 if @var{x} is negative (including negative zero), 0 otherwise.  \n+@end deftypefn\n+\n @deftypefn Macro int REAL_VALUE_ISINF (REAL_VALUE_TYPE @var{x})\n Determines whether @var{x} represents infinity (positive or negative).\n @end deftypefn\n@@ -7856,6 +7860,10 @@ target's floating point format cannot represent infinity, it will call\n Returns the negative of the floating point value @var{x}.\n @end deftypefn\n \n+@deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_ABS (REAL_VALUE_TYPE @var{x})\n+Returns the absolute value of @var{x}.\n+@end deftypefn\n+\n @deftypefn Macro REAL_VALUE_TYPE REAL_VALUE_TRUNCATE (REAL_VALUE_TYPE @var{mode}, enum machine_mode @var{x})\n Truncates the floating point value @var{x} to fit in @var{mode}.  The\n return value is still a full-size @code{REAL_VALUE_TYPE}, but it has an"}, {"sha": "4c5b91ed11eed82298e42399e90a18bfc1fff2fa", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 84, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -65,11 +65,9 @@ static tree split_tree\t\tPARAMS ((tree, enum tree_code, tree *, tree *,\n \t\t\t\t\t int));\n static tree associate_trees\tPARAMS ((tree, tree, enum tree_code, tree));\n static tree int_const_binop\tPARAMS ((enum tree_code, tree, tree, int));\n-static void const_binop_1\tPARAMS ((PTR));\n static tree const_binop\t\tPARAMS ((enum tree_code, tree, tree, int));\n static hashval_t size_htab_hash\tPARAMS ((const void *));\n static int size_htab_eq\t\tPARAMS ((const void *, const void *));\n-static void fold_convert_1\tPARAMS ((PTR));\n static tree fold_convert\tPARAMS ((tree, tree));\n static enum tree_code invert_tree_comparison PARAMS ((enum tree_code));\n static enum tree_code swap_tree_comparison PARAMS ((enum tree_code));\n@@ -1199,32 +1197,6 @@ int_const_binop (code, arg1, arg2, notrunc)\n   return t;\n }\n \n-/* Define input and output argument for const_binop_1.  */\n-struct cb_args\n-{\n-  enum tree_code code;\t\t/* Input: tree code for operation.  */\n-  tree type;\t\t\t/* Input: tree type for operation.  */\n-  REAL_VALUE_TYPE d1, d2;\t/* Input: floating point operands.  */\n-  tree t;\t\t\t/* Output: constant for result.  */\n-};\n-\n-/* Do the real arithmetic for const_binop while protected by a\n-   float overflow handler.  */\n-\n-static void\n-const_binop_1 (data)\n-     PTR data;\n-{\n-  struct cb_args *args = (struct cb_args *) data;\n-  REAL_VALUE_TYPE value;\n-\n-  REAL_ARITHMETIC (value, args->code, args->d1, args->d2);\n-\n-  args->t\n-    = build_real (args->type,\n-\t\t  real_value_truncate (TYPE_MODE (args->type), value));\n-}\n-\n /* Combine two constants ARG1 and ARG2 under operation CODE to produce a new\n    constant.  We assume ARG1 and ARG2 have the same data type, or at least\n    are the same kind of constant and the same machine mode.\n@@ -1247,9 +1219,8 @@ const_binop (code, arg1, arg2, notrunc)\n     {\n       REAL_VALUE_TYPE d1;\n       REAL_VALUE_TYPE d2;\n-      int overflow = 0;\n+      REAL_VALUE_TYPE value;\n       tree t;\n-      struct cb_args args;\n \n       d1 = TREE_REAL_CST (arg1);\n       d2 = TREE_REAL_CST (arg2);\n@@ -1261,24 +1232,14 @@ const_binop (code, arg1, arg2, notrunc)\n       else if (REAL_VALUE_ISNAN (d2))\n \treturn arg2;\n \n-      /* Setup input for const_binop_1() */\n-      args.type = TREE_TYPE (arg1);\n-      args.d1 = d1;\n-      args.d2 = d2;\n-      args.code = code;\n+      REAL_ARITHMETIC (value, code, d1, d2);\n \n-      if (do_float_handler (const_binop_1, (PTR) &args))\n-\t/* Receive output from const_binop_1.  */\n-\tt = args.t;\n-      else\n-\t{\n-\t  /* We got an exception from const_binop_1.  */\n-\t  t = copy_node (arg1);\n-\t  overflow = 1;\n-\t}\n+      t = build_real (TREE_TYPE (arg1),\n+\t\t      real_value_truncate (TYPE_MODE (TREE_TYPE (arg1)),\n+\t\t\t\t\t   value));\n \n       TREE_OVERFLOW (t)\n-\t= (force_fit_type (t, overflow)\n+\t= (force_fit_type (t, 0)\n \t   | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n       TREE_CONSTANT_OVERFLOW (t)\n \t= TREE_OVERFLOW (t)\n@@ -1530,27 +1491,6 @@ size_diffop (arg0, arg1)\n \t\t       convert (ctype, size_binop (MINUS_EXPR, arg1, arg0)));\n }\n \f\n-/* This structure is used to communicate arguments to fold_convert_1.  */\n-struct fc_args\n-{\n-  tree arg1;\t\t\t/* Input: value to convert.  */\n-  tree type;\t\t\t/* Input: type to convert value to.  */\n-  tree t;\t\t\t/* Output: result of conversion.  */\n-};\n-\n-/* Function to convert floating-point constants, protected by floating\n-   point exception handler.  */\n-\n-static void\n-fold_convert_1 (data)\n-     PTR data;\n-{\n-  struct fc_args *args = (struct fc_args *) data;\n-\n-  args->t = build_real (args->type,\n-\t\t\treal_value_truncate (TYPE_MODE (args->type),\n-\t\t\t\t\t     TREE_REAL_CST (args->arg1)));\n-}\n \n /* Given T, a tree representing type conversion of ARG1, a constant,\n    return a constant tree representing the result of conversion.  */\n@@ -1650,33 +1590,19 @@ fold_convert (t, arg1)\n \treturn build_real_from_int_cst (type, arg1);\n       if (TREE_CODE (arg1) == REAL_CST)\n \t{\n-\t  struct fc_args args;\n-\n \t  if (REAL_VALUE_ISNAN (TREE_REAL_CST (arg1)))\n \t    {\n \t      t = arg1;\n \t      TREE_TYPE (arg1) = type;\n \t      return t;\n \t    }\n \n-\t  /* Setup input for fold_convert_1() */\n-\t  args.arg1 = arg1;\n-\t  args.type = type;\n-\n-\t  if (do_float_handler (fold_convert_1, (PTR) &args))\n-\t    {\n-\t      /* Receive output from fold_convert_1() */\n-\t      t = args.t;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* We got an exception from fold_convert_1() */\n-\t      overflow = 1;\n-\t      t = copy_node (arg1);\n-\t    }\n+\t  t = build_real (type,\n+\t\t\t  real_value_truncate (TYPE_MODE (type),\n+\t\t\t\t\t       TREE_REAL_CST (arg1)));\n \n \t  TREE_OVERFLOW (t)\n-\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, overflow);\n+\t    = TREE_OVERFLOW (arg1) | force_fit_type (t, 0);\n \t  TREE_CONSTANT_OVERFLOW (t)\n \t    = TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg1);\n \t  return t;"}, {"sha": "cb18fc596d6805c57a719c720e3b7454c0d3ca39", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -1,3 +1,9 @@\n+2002-03-25  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* lex.c: Change java_perform_atof to take normal parameters\n+\tinstead of a pointer to a parameter block.  Call it directly\n+\tfrom java_lex.\n+\n 2002-03-22  Mark Wielaard  <mark@klomp.org>\n \n \tFix for PR java/5368:\n@@ -32,10 +38,10 @@\n \n 2002-03-20  Nic Ferrier  <nferrier@tapsellferrier.co.uk>\n \n-       \t* gcj.texi: @code{gcj} becomes @command{gcj}. \n-\t@code{gcc} becomes @command{gcc}. \n-        GcjRaw changed to gnu.gcc.RawData.\n-\t\n+       \t* gcj.texi: @code{gcj} becomes @command{gcj}.\n+\t@code{gcc} becomes @command{gcc}.\n+\tGcjRaw changed to gnu.gcc.RawData.\n+\n 2002-03-20  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* decl.c (start_java_method): Use new hook.\n@@ -257,18 +263,18 @@\n \n 2002-02-20  Nic Ferrier  <nferrier@tapsellferrier.co.uk>\n \n-\t* gcj.texi: Option `--classpath' becomes `--CLASSPATH.'Option \n-\t`--CLASSPATH' becomes `--classpath.' \n-\t* gjavah.c: Likewise. \n-\t* jcf-dump.c: Likewise. \n-\t* lang-options.h: Likewise. \n-\t* lang.c: Likewise. \n-\t* jcf-path.c: Updated comment. \n-\t(jcf_path_classpath_arg): Renamed `jcf_path_CLASSPATH_arg.' \n-\t(jcf_path_CLASSPATH_arg): Renamed `jcf_path_classpath_arg.' \n-\t* jcf.h (jcf_path_CLASSPATH_arg): Ditto. \n-\t(jcf_path_CLASSPATH_arg): Ditto. \n-\t(classpath_u): Updated leading comment. \n+\t* gcj.texi: Option `--classpath' becomes `--CLASSPATH.'Option\n+\t`--CLASSPATH' becomes `--classpath.'\n+\t* gjavah.c: Likewise.\n+\t* jcf-dump.c: Likewise.\n+\t* lang-options.h: Likewise.\n+\t* lang.c: Likewise.\n+\t* jcf-path.c: Updated comment.\n+\t(jcf_path_classpath_arg): Renamed `jcf_path_CLASSPATH_arg.'\n+\t(jcf_path_CLASSPATH_arg): Renamed `jcf_path_classpath_arg.'\n+\t* jcf.h (jcf_path_CLASSPATH_arg): Ditto.\n+\t(jcf_path_CLASSPATH_arg): Ditto.\n+\t(classpath_u): Updated leading comment.\n \n 2002-02-20  Per Bothner  <per@bothner.com>\n \n@@ -352,7 +358,7 @@\n \tcurrent_function_decl before building JNI stub.\n \n 2002-01-26 Andreas Tobler <a.tobler@schweiz.ch>\n-\t\n+\n \t* gcc/java/builtins.c (sqrt_builtin): Use BUILT_IN_SQRT, not\n \tBUILT_IN_SQRTF.\n "}, {"sha": "8c661189a3934423a48cc5cef3f6297475a79c18", "filename": "gcc/java/lex.c", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -828,46 +828,41 @@ java_parse_escape_sequence ()\n     }\n }\n \n-/* Isolate the code which may raise an arithmetic exception in its\n-   own function.  */\n-\n #ifndef JC1_LITE\n-struct jpa_args\n-{\n-  YYSTYPE *java_lval;\n-  char *literal_token;\n-  int fflag;\n-  int number_beginning;\n-};\n-\n #define IS_ZERO(X) (ereal_cmp (X, dconst0) == 0)\n \n-static void java_perform_atof\tPARAMS ((PTR));\n+/* Subroutine of java_lex: converts floating-point literals to tree\n+   nodes.  LITERAL_TOKEN is the input literal, JAVA_LVAL is where to\n+   store the result.  FFLAG indicates whether the literal was tagged\n+   with an 'f', indicating it is of type 'float'; NUMBER_BEGINNING\n+   is the line number on which to report any error.  */\n+\n+static void java_perform_atof\tPARAMS ((YYSTYPE *, char *, int, int));\n \n static void\n-java_perform_atof (av)\n-     PTR av;\n+java_perform_atof (java_lval, literal_token, fflag, number_beginning)\n+     YYSTYPE *java_lval;\n+     char *literal_token;\n+     int fflag;\n+     int number_beginning;\n {\n-  struct jpa_args *a = (struct jpa_args *)av;\n-  YYSTYPE *java_lval = a->java_lval;\n-  int number_beginning = a->number_beginning;\n   REAL_VALUE_TYPE value;\n-  tree type = (a->fflag ? FLOAT_TYPE_NODE : DOUBLE_TYPE_NODE);\n+  tree type = (fflag ? FLOAT_TYPE_NODE : DOUBLE_TYPE_NODE);\n \n   SET_REAL_VALUE_ATOF (value,\n-\t\t       REAL_VALUE_ATOF (a->literal_token, TYPE_MODE (type)));\n+\t\t       REAL_VALUE_ATOF (literal_token, TYPE_MODE (type)));\n \n   if (REAL_VALUE_ISINF (value) || REAL_VALUE_ISNAN (value))\n     {\n-      JAVA_FLOAT_RANGE_ERROR ((a->fflag ? \"float\" : \"double\"));\n+      JAVA_FLOAT_RANGE_ERROR (fflag ? \"float\" : \"double\");\n       value = DCONST0;\n     }\n   else if (IS_ZERO (value))\n     {\n       /* We check to see if the value is really 0 or if we've found an\n \t underflow.  We do this in the most primitive imaginable way.  */\n       int really_zero = 1;\n-      char *p = a->literal_token;\n+      char *p = literal_token;\n       if (*p == '-')\n \t++p;\n       while (*p && *p != 'e' && *p != 'E')\n@@ -1161,9 +1156,6 @@ java_lex (java_lval)\n \t\t}\n \t      else\n \t\t{\n-#ifndef JC1_LITE\n-\t\t  struct jpa_args a;\n-#endif\n \t\t  if (stage != 4) /* Don't push back fF/dD.  */\n \t\t    java_unget_unicode ();\n \t\t  \n@@ -1176,17 +1168,10 @@ java_lex (java_lval)\n \t\t  JAVA_LEX_LIT (literal_token, radix);\n \n #ifndef JC1_LITE\n-\t\t  a.literal_token = literal_token;\n-\t\t  a.fflag = fflag;\n-\t\t  a.java_lval = java_lval;\n-\t\t  a.number_beginning = number_beginning;\n-\t\t  if (do_float_handler (java_perform_atof, (PTR) &a))\n-\t\t    return FP_LIT_TK;\n-\n-\t\t  JAVA_FLOAT_RANGE_ERROR ((fflag ? \"float\" : \"double\"));\n-#else\n-\t\t  return FP_LIT_TK;\n+\t\t  java_perform_atof (java_lval, literal_token,\n+\t\t\t\t     fflag, number_beginning);\n #endif\n+\t\t  return FP_LIT_TK;\n \t\t}\n \t    }\n \t} /* JAVA_ASCII_FPCHAR (c) */"}, {"sha": "a06b7951ab9268494be05c34c75d4f58d46dc9db", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -1065,11 +1065,8 @@ __floatdidf (DWtype u)\n #define WORD_SIZE (sizeof (Wtype) * BITS_PER_UNIT)\n #define HIGH_HALFWORD_COEFF (((UDWtype) 1) << (WORD_SIZE / 2))\n #define HIGH_WORD_COEFF (((UDWtype) 1) << WORD_SIZE)\n-#define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)\n-\n-/* GCC guarantees this header exists at this point.  */\n-#include <float.h>\n \n+#define DI_SIZE (sizeof (DWtype) * BITS_PER_UNIT)\n #define DF_SIZE DBL_MANT_DIG\n #define SF_SIZE FLT_MANT_DIG\n "}, {"sha": "ae9427b20049af7a0f02f94f865417c105ae6401", "filename": "gcc/real.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -161,6 +161,10 @@ extern REAL_VALUE_TYPE real_value_truncate PARAMS ((enum machine_mode,\n \n #define REAL_VALUE_NEGATE ereal_negate\n \n+/* Compute the absolute value of a floating-point value X.  */\n+#define REAL_VALUE_ABS(x) \\\n+   (REAL_VALUE_NEGATIVE (x) ? REAL_VALUE_NEGATE (x) : (x))\n+\n /* Determine whether a floating-point value X is infinite.  */\n #define REAL_VALUE_ISINF(x) (target_isinf (x))\n "}, {"sha": "3bc2824b58ad9708e4a18e3003de6405d0c55ecb", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 59, "deletions": 200, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -101,11 +101,6 @@ static int simplify_plus_minus_op_data_cmp PARAMS ((const void *,\n static rtx simplify_plus_minus\t\tPARAMS ((enum rtx_code,\n \t\t\t\t\t\t enum machine_mode, rtx,\n \t\t\t\t\t\t rtx, int));\n-static void check_fold_consts\t\tPARAMS ((PTR));\n-static void simplify_unary_real\t\tPARAMS ((PTR));\n-static void simplify_binary_real\tPARAMS ((PTR));\n-static void simplify_binary_is2orm1\tPARAMS ((PTR));\n-\n \f\n /* Negate a CONST_INT rtx, truncating (because a conversion from a\n    maximally negative number can overflow).  */\n@@ -341,65 +336,6 @@ simplify_replace_rtx (x, old, new)\n   return x;\n }\n \f\n-/* Subroutine of simplify_unary_operation, called via do_float_handler.\n-   Handles simplification of unary ops on floating point values.  */\n-struct simplify_unary_real_args\n-{\n-  rtx operand;\n-  rtx result;\n-  enum machine_mode mode;\n-  enum rtx_code code;\n-  bool want_integer;\n-};\n-#define REAL_VALUE_ABS(d_) \\\n-   (REAL_VALUE_NEGATIVE (d_) ? REAL_VALUE_NEGATE (d_) : (d_))\n-\n-static void\n-simplify_unary_real (p)\n-     PTR p;\n-{\n-  REAL_VALUE_TYPE d;\n-\n-  struct simplify_unary_real_args *args =\n-    (struct simplify_unary_real_args *) p;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, args->operand);\n-\n-  if (args->want_integer)\n-    {\n-      HOST_WIDE_INT i;\n-\n-      switch (args->code)\n-\t{\n-\tcase FIX:\t\ti = REAL_VALUE_FIX (d);\t\t  break;\n-\tcase UNSIGNED_FIX:\ti = REAL_VALUE_UNSIGNED_FIX (d);  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      args->result = gen_int_mode (i, args->mode);\n-    }\n-  else\n-    {\n-      switch (args->code)\n-\t{\n-\tcase SQRT:\n-\t  /* We don't attempt to optimize this.  */\n-\t  args->result = 0;\n-\t  return;\n-\n-\tcase ABS:\t      d = REAL_VALUE_ABS (d);\t\t\tbreak;\n-\tcase NEG:\t      d = REAL_VALUE_NEGATE (d);\t\tbreak;\n-\tcase FLOAT_TRUNCATE:  d = real_value_truncate (args->mode, d);  break;\n-\tcase FLOAT_EXTEND:    /* All this does is change the mode.  */  break;\n-\tcase FIX:\t      d = REAL_VALUE_RNDZINT (d);\t\tbreak;\n-\tcase UNSIGNED_FIX:    d = REAL_VALUE_UNSIGNED_RNDZINT (d);\tbreak;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      args->result = CONST_DOUBLE_FROM_REAL_VALUE (d, args->mode);\n-    }\n-}\n-\n /* Try to simplify a unary operation CODE whose output mode is to be\n    MODE with input operand OP whose mode was originally OP_MODE.\n    Return zero if no simplification can be made.  */\n@@ -638,33 +574,43 @@ simplify_unary_operation (code, mode, op, op_mode)\n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     {\n-      struct simplify_unary_real_args args;\n-      args.operand = trueop;\n-      args.mode = mode;\n-      args.code = code;\n-      args.want_integer = false;\n+      REAL_VALUE_TYPE d;\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n \n-      if (do_float_handler (simplify_unary_real, (PTR) &args))\n-\treturn args.result;\n+      switch (code)\n+\t{\n+\tcase SQRT:\n+\t  /* We don't attempt to optimize this.  */\n+\t  return 0;\n \n-      return 0;\n+\tcase ABS:\t      d = REAL_VALUE_ABS (d);\t\t\tbreak;\n+\tcase NEG:\t      d = REAL_VALUE_NEGATE (d);\t\tbreak;\n+\tcase FLOAT_TRUNCATE:  d = real_value_truncate (mode, d);\tbreak;\n+\tcase FLOAT_EXTEND:    /* All this does is change the mode.  */  break;\n+\tcase FIX:\t      d = REAL_VALUE_RNDZINT (d);\t\tbreak;\n+\tcase UNSIGNED_FIX:    d = REAL_VALUE_UNSIGNED_RNDZINT (d);\tbreak;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return CONST_DOUBLE_FROM_REAL_VALUE (d, mode);\n     }\n \n   else if (GET_CODE (trueop) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (trueop)) == MODE_FLOAT\n \t   && GET_MODE_CLASS (mode) == MODE_INT\n \t   && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      struct simplify_unary_real_args args;\n-      args.operand = trueop;\n-      args.mode = mode;\n-      args.code = code;\n-      args.want_integer = true;\n-\n-      if (do_float_handler (simplify_unary_real, (PTR) &args))\n-\treturn args.result;\n-\n-      return 0;\n+      HOST_WIDE_INT i;\n+      REAL_VALUE_TYPE d;\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop);\n+      switch (code)\n+\t{\n+\tcase FIX:\t\ti = REAL_VALUE_FIX (d);\t\t  break;\n+\tcase UNSIGNED_FIX:\ti = REAL_VALUE_UNSIGNED_FIX (d);  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+      return gen_int_mode (i, mode);\n     }\n \n   /* This was formerly used only for non-IEEE float.\n@@ -740,64 +686,6 @@ simplify_unary_operation (code, mode, op, op_mode)\n     }\n }\n \f\n-/* Subroutine of simplify_binary_operation, called via do_float_handler.\n-   Handles simplification of binary ops on floating point values.  */\n-struct simplify_binary_real_args\n-{\n-  rtx trueop0, trueop1;\n-  rtx result;\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-};\n-\n-static void\n-simplify_binary_real (p)\n-     PTR p;\n-{\n-  REAL_VALUE_TYPE f0, f1, value;\n-  struct simplify_binary_real_args *args =\n-    (struct simplify_binary_real_args *) p;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (f0, args->trueop0);\n-  REAL_VALUE_FROM_CONST_DOUBLE (f1, args->trueop1);\n-  f0 = real_value_truncate (args->mode, f0);\n-  f1 = real_value_truncate (args->mode, f1);\n-\n-  if (args->code == DIV\n-      && !MODE_HAS_INFINITIES (args->mode)\n-      && REAL_VALUES_EQUAL (f1, dconst0))\n-    {\n-      args->result = 0;\n-      return;\n-    }\n-  REAL_ARITHMETIC (value, rtx_to_tree_code (args->code), f0, f1);\n-\n-  value = real_value_truncate (args->mode, value);\n-  args->result = CONST_DOUBLE_FROM_REAL_VALUE (value, args->mode);\n-}\n-\n-/* Another subroutine called via do_float_handler.  This one tests\n-   the floating point value given against 2. and -1.  */\n-struct simplify_binary_is2orm1_args\n-{\n-  rtx value;\n-  bool is_2;\n-  bool is_m1;\n-};\n-\n-static void\n-simplify_binary_is2orm1 (p)\n-     PTR p;\n-{\n-  REAL_VALUE_TYPE d;\n-  struct simplify_binary_is2orm1_args *args =\n-    (struct simplify_binary_is2orm1_args *) p;\n-\n-  REAL_VALUE_FROM_CONST_DOUBLE (d, args->value);\n-  args->is_2 = REAL_VALUES_EQUAL (d, dconst2);\n-  args->is_m1 = REAL_VALUES_EQUAL (d, dconstm1);\n-}\n-\n /* Simplify a binary operation CODE with result mode MODE, operating on OP0\n    and OP1.  Return 0 if no simplification is possible.\n \n@@ -837,15 +725,22 @@ simplify_binary_operation (code, mode, op0, op1)\n       && GET_CODE (trueop1) == CONST_DOUBLE\n       && mode == GET_MODE (op0) && mode == GET_MODE (op1))\n     {\n-      struct simplify_binary_real_args args;\n-      args.trueop0 = trueop0;\n-      args.trueop1 = trueop1;\n-      args.mode = mode;\n-      args.code = code;\n-\n-      if (do_float_handler (simplify_binary_real, (PTR) &args))\n-\treturn args.result;\n-      return 0;\n+      REAL_VALUE_TYPE f0, f1, value;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (f0, trueop0);\n+      REAL_VALUE_FROM_CONST_DOUBLE (f1, trueop1);\n+      f0 = real_value_truncate (mode, f0);\n+      f1 = real_value_truncate (mode, f1);\n+\n+      if (code == DIV\n+\t  && !MODE_HAS_INFINITIES (mode)\n+\t  && REAL_VALUES_EQUAL (f1, dconst0))\n+\treturn 0;\n+\n+      REAL_ARITHMETIC (value, rtx_to_tree_code (code), f0, f1);\n+\n+      value = real_value_truncate (mode, value);\n+      return CONST_DOUBLE_FROM_REAL_VALUE (value, mode);\n     }\n \n   /* We can fold some multi-word operations.  */\n@@ -1276,20 +1171,18 @@ simplify_binary_operation (code, mode, op0, op1)\n \t      && ! rtx_equal_function_value_matters)\n \t    return gen_rtx_ASHIFT (mode, op0, GEN_INT (val));\n \n+\t  /* x*2 is x+x and x*(-1) is -x */\n \t  if (GET_CODE (trueop1) == CONST_DOUBLE\n-\t      && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT)\n+\t      && GET_MODE_CLASS (GET_MODE (trueop1)) == MODE_FLOAT\n+\t      && GET_MODE (op0) == mode)\n \t    {\n-\t      struct simplify_binary_is2orm1_args args;\n-\n-\t      args.value = trueop1;\n-\t      if (! do_float_handler (simplify_binary_is2orm1, (PTR) &args))\n-\t\treturn 0;\n+\t      REAL_VALUE_TYPE d;\n+\t      REAL_VALUE_FROM_CONST_DOUBLE (d, trueop1);\n \n-\t      /* x*2 is x+x and x*(-1) is -x */\n-\t      if (args.is_2 && GET_MODE (op0) == mode)\n+\t      if (REAL_VALUES_EQUAL (d, dconst2))\n \t\treturn gen_rtx_PLUS (mode, op0, copy_rtx (op0));\n \n-\t      else if (args.is_m1 && GET_MODE (op0) == mode)\n+\t      if (REAL_VALUES_EQUAL (d, dconstm1))\n \t\treturn gen_rtx_NEG (mode, op0);\n \t    }\n \t  break;\n@@ -1923,35 +1816,6 @@ simplify_plus_minus (code, mode, op0, op1, force)\n   return negate ? gen_rtx_NEG (mode, result) : result;\n }\n \n-struct cfc_args\n-{\n-  rtx op0, op1;\t\t\t/* Input */\n-  int equal, op0lt, op1lt;\t/* Output */\n-  int unordered;\n-};\n-\n-static void\n-check_fold_consts (data)\n-  PTR data;\n-{\n-  struct cfc_args *args = (struct cfc_args *) data;\n-  REAL_VALUE_TYPE d0, d1;\n-\n-  /* We may possibly raise an exception while reading the value.  */\n-  args->unordered = 1;\n-  REAL_VALUE_FROM_CONST_DOUBLE (d0, args->op0);\n-  REAL_VALUE_FROM_CONST_DOUBLE (d1, args->op1);\n-\n-  /* Comparisons of Inf versus Inf are ordered.  */\n-  if (REAL_VALUE_ISNAN (d0)\n-      || REAL_VALUE_ISNAN (d1))\n-    return;\n-  args->equal = REAL_VALUES_EQUAL (d0, d1);\n-  args->op0lt = REAL_VALUES_LESS (d0, d1);\n-  args->op1lt = REAL_VALUES_LESS (d1, d0);\n-  args->unordered = 0;\n-}\n-\n /* Like simplify_binary_operation except used for relational operators.\n    MODE is the mode of the operands, not that of the result.  If MODE\n    is VOIDmode, both operands must also be VOIDmode and we compare the\n@@ -2035,17 +1899,13 @@ simplify_relational_operation (code, mode, op0, op1)\n \t   && GET_CODE (trueop1) == CONST_DOUBLE\n \t   && GET_MODE_CLASS (GET_MODE (trueop0)) == MODE_FLOAT)\n     {\n-      struct cfc_args args;\n+      REAL_VALUE_TYPE d0, d1;\n \n-      /* Setup input for check_fold_consts() */\n-      args.op0 = trueop0;\n-      args.op1 = trueop1;\n-      \n-      \n-      if (!do_float_handler (check_fold_consts, (PTR) &args))\n-\targs.unordered = 1;\n+      REAL_VALUE_FROM_CONST_DOUBLE (d0, trueop0);\n+      REAL_VALUE_FROM_CONST_DOUBLE (d1, trueop1);\n \n-      if (args.unordered)\n+      /* Comparisons are unordered iff at least one of the values is NaN. */\n+      if (REAL_VALUE_ISNAN (d0) || REAL_VALUE_ISNAN (d1))\n \tswitch (code)\n \t  {\n \t  case UNEQ:\n@@ -2068,10 +1928,9 @@ simplify_relational_operation (code, mode, op0, op1)\n \t    return 0;\n \t  }\n \n-      /* Receive output from check_fold_consts() */\n-      equal = args.equal;\n-      op0lt = op0ltu = args.op0lt;\n-      op1lt = op1ltu = args.op1lt;\n+      equal = REAL_VALUES_EQUAL (d0, d1);\n+      op0lt = op0ltu = REAL_VALUES_LESS (d0, d1);\n+      op1lt = op1ltu = REAL_VALUES_LESS (d1, d0);\n     }\n \n   /* Otherwise, see if the operands are both integers.  */"}, {"sha": "540c2f6fd1cfacf583e4b1c2b7e9b1f4e09cd445", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -1,3 +1,7 @@\n+2002-03-25  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* gcc.dg/c90-hexfloat-1.c: Adjust error regexps.\n+\n 2002-03-25  Bob Wilson  <bob.wilson@acm.org>\n \n \t* g++.old-deja/g++.jason/thunk3.C: Add xtensa-*-* to list of\n@@ -62,7 +66,7 @@\n \n 2002-03-22  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n-        * gcc.dg/cpp/multiline.c: Update to match.\n+\t* gcc.dg/cpp/multiline.c: Update to match.\n \n 2002-03-22  Alexandre Oliva  <aoliva@redhat.com>\n \n@@ -74,13 +78,13 @@\n \n 2002-03-21  David Edelsohn  <edelsohn@gnu.org>\n \n-        * gcc.dg/20020312-2.c: Add rs6000 target.\n+\t* gcc.dg/20020312-2.c: Add rs6000 target.\n \n \t* gcc.c-torture/compile/20020319-1.c: New test.\n \n 2002-03-21  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n-\t* g++.old-deja/g++.eh/ia64-1.C: Use [ijkl]_[0-9] as variable names. \n+\t* g++.old-deja/g++.eh/ia64-1.C: Use [ijkl]_[0-9] as variable names.\n \t(A, E): Handle this.\n \n 2002-03-20  Jason Merrill  <jason@redhat.com>\n@@ -197,15 +201,15 @@ Thu Mar 14 14:28:38 2002  Jeffrey A Law  (law@cygnus.com)\n \n 2002-03-12  David Edelsohn  <edelsohn@gnu.org>\n \n-        * gcc.dg/20020103-1.c: Add rs6000 target and macro.\n+\t* gcc.dg/20020103-1.c: Add rs6000 target and macro.\n \n 2002-03-12  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/20020312-1.c: New test case.\n \n 2002-03-11  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * gcc.dg/altivec-1.c: Cleanup and use altivec.h.\n+\t* gcc.dg/altivec-1.c: Cleanup and use altivec.h.\n \n 2002-03-11  Richard Henderson  <rth@redhat.com>\n \n@@ -279,7 +283,7 @@ Thu Mar  7 10:05:31 2002  Jeffrey A Law  (law@redhat.com)\n \n 2002-03-03  Aldy Hernandez  <aldyh@redhat.com>\n \n-        * gcc.dg/20020103-1.c: Add other -D ppc variants.\n+\t* gcc.dg/20020103-1.c: Add other -D ppc variants.\n \n 2002-03-02  Nathan Sidwell  <nathan@codesourcery.com>\n "}, {"sha": "2dd90a1e681714a6f6581afa1ba1b6ea68d69f1f", "filename": "gcc/testsuite/gcc.dg/c90-hexfloat-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-hexfloat-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-hexfloat-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc90-hexfloat-1.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -4,8 +4,8 @@\n /* { dg-options \"-std=iso9899:1990 -pedantic-errors\" } */\n \n double d = 0x1.2p2; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"radix 16\" \"hex float error\" { target *-*-* } 6 } */\n+/* { dg-error \"hexadecimal floating\" \"hex float error\" { target *-*-* } 6 } */\n double d1 = 0x1p2; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n-/* { dg-error \"radix 16\" \"hex float error\" { target *-*-* } 8 } */\n+/* { dg-error \"hexadecimal floating\" \"hex float error\" { target *-*-* } 8 } */\n double d2 = 0x1...p2; /* { dg-bogus \"warning\" \"warning in place of error\" } */\n /* { dg-error \"too many decimal points\" \"bad hex float\" { target *-*-* } 10 } */"}, {"sha": "8c7517e2fea45a16c7036a1c6612b67b0a5b7028", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 74, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -29,7 +29,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef FFS  /* Some systems define this in param.h.  */\n #include \"system.h\"\n #include <signal.h>\n-#include <setjmp.h>\n \n #ifdef HAVE_SYS_RESOURCE_H\n # include <sys/resource.h>\n@@ -109,9 +108,7 @@ static void finalize PARAMS ((void));\n \n static void set_target_switch PARAMS ((const char *));\n \n-static void float_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n static void crash_signal PARAMS ((int)) ATTRIBUTE_NORETURN;\n-static void set_float_handler PARAMS ((jmp_buf));\n static void compile_file PARAMS ((void));\n static void display_help PARAMS ((void));\n static void display_target_options PARAMS ((void));\n@@ -1626,73 +1623,6 @@ floor_log2_wide (x)\n   return log;\n }\n \n-static int float_handler_set;\n-int float_handled;\n-jmp_buf float_handler;\n-\n-/* Signals actually come here.  */\n-\n-static void\n-float_signal (signo)\n-     /* If this is missing, some compilers complain.  */\n-     int signo ATTRIBUTE_UNUSED;\n-{\n-  if (float_handled == 0)\n-    crash_signal (signo);\n-  float_handled = 0;\n-\n-  /* On System-V derived systems, we must reinstall the signal handler.\n-     This is harmless on BSD-derived systems.  */\n-  signal (SIGFPE, float_signal);\n-  longjmp (float_handler, 1);\n-}\n-\n-/* Specify where to longjmp to when a floating arithmetic error happens.\n-   If HANDLER is 0, it means don't handle the errors any more.  */\n-\n-static void\n-set_float_handler (handler)\n-     jmp_buf handler;\n-{\n-  float_handled = (handler != 0);\n-  if (handler)\n-    memcpy (float_handler, handler, sizeof (float_handler));\n-\n-  if (float_handled && ! float_handler_set)\n-    {\n-      signal (SIGFPE, float_signal);\n-      float_handler_set = 1;\n-    }\n-}\n-\n-/* This is a wrapper function for code which might elicit an\n-   arithmetic exception.  That code should be passed in as a function\n-   pointer FN, and one argument DATA.  DATA is usually a struct which\n-   contains the real input and output for function FN.  This function\n-   returns 0 (failure) if longjmp was called (i.e. an exception\n-   occurred.)  It returns 1 (success) otherwise.  */\n-\n-int\n-do_float_handler (fn, data)\n-     void (*fn) PARAMS ((PTR));\n-     PTR data;\n-{\n-  jmp_buf buf;\n-\n-  if (setjmp (buf))\n-    {\n-      /* We got here via longjmp () caused by an exception in function\n-         fn ().  */\n-      set_float_handler (NULL);\n-      return 0;\n-    }\n-\n-  set_float_handler (buf);\n-  (*fn)(data);\n-  set_float_handler (NULL);\n-  return 1;\n-}\n-\n /* Handler for fatal signals, such as SIGSEGV.  These are transformed\n    into ICE messages, which is much more user friendly.  */\n \n@@ -4565,10 +4495,6 @@ general_init (argv0)\n \n   gcc_init_libintl ();\n \n-  /* Install handler for SIGFPE, which may be received while we do\n-     compile-time floating point arithmetic.  */\n-  signal (SIGFPE, float_signal);\n-\n   /* Trap fatal signals, e.g. SIGSEGV, and convert them to ICE messages.  */\n #ifdef SIGSEGV\n   signal (SIGSEGV, crash_signal);\n@@ -4585,6 +4511,9 @@ general_init (argv0)\n #if defined SIGIOT && (!defined SIGABRT || SIGABRT != SIGIOT)\n   signal (SIGIOT, crash_signal);\n #endif\n+#ifdef SIGFPE\n+  signal (SIGFPE, crash_signal);\n+#endif\n \n   /* Initialize the diagnostics reporting machinery, so option parsing\n      can give warnings and errors.  */"}, {"sha": "b488e14938ca432254219f57febc228583decc43", "filename": "gcc/toplev.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -88,7 +88,6 @@ extern void error_for_asm\t\tPARAMS ((struct rtx_def *,\n extern void warning_for_asm\t\tPARAMS ((struct rtx_def *,\n \t\t\t\t\t\t const char *, ...));\n extern void warn_deprecated_use\t\tPARAMS ((union tree_node *));\n-extern int do_float_handler PARAMS ((void (*) (PTR), PTR));\n \n #ifdef BUFSIZ\n extern void output_quoted_string\tPARAMS ((FILE *, const char *));"}, {"sha": "96a2d3b7160ba1a7e0fda6eb713e596fec9069fa", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -122,7 +122,6 @@ struct type_hash\n \n htab_t type_hash_table;\n \n-static void build_real_from_int_cst_1 PARAMS ((PTR));\n static void set_type_quals PARAMS ((tree, int));\n static void append_random_chars PARAMS ((char *));\n static int type_hash_eq PARAMS ((const void*, const void*));\n@@ -591,31 +590,8 @@ real_value_from_int_cst (type, i)\n   return d;\n }\n \n-/* Args to pass to and from build_real_from_int_cst_1.  */\n-\n-struct brfic_args\n-{\n-  tree type;\t\t\t/* Input: type to conver to.  */\n-  tree i;\t\t\t/* Input: operand to convert.  */\n-  REAL_VALUE_TYPE d;\t\t/* Output: floating point value.  */\n-};\n-\n-/* Convert an integer to a floating point value while protected by a floating\n-   point exception handler.  */\n-\n-static void\n-build_real_from_int_cst_1 (data)\n-     PTR data;\n-{\n-  struct brfic_args *args = (struct brfic_args *) data;\n-\n-  args->d = real_value_from_int_cst (args->type, args->i);\n-}\n-\n /* Given a tree representing an integer constant I, return a tree\n-   representing the same value as a floating-point constant of type TYPE.\n-   We cannot perform this operation if there is no way of doing arithmetic\n-   on floating-point values.  */\n+   representing the same value as a floating-point constant of type TYPE.  */\n \n tree\n build_real_from_int_cst (type, i)\n@@ -625,27 +601,13 @@ build_real_from_int_cst (type, i)\n   tree v;\n   int overflow = TREE_OVERFLOW (i);\n   REAL_VALUE_TYPE d;\n-  struct brfic_args args;\n \n   v = make_node (REAL_CST);\n   TREE_TYPE (v) = type;\n \n-  /* Setup input for build_real_from_int_cst_1() */\n-  args.type = type;\n-  args.i = i;\n-\n-  if (do_float_handler (build_real_from_int_cst_1, (PTR) &args))\n-    /* Receive output from build_real_from_int_cst_1() */\n-    d = args.d;\n-  else\n-    {\n-      /* We got an exception from build_real_from_int_cst_1() */\n-      d = dconst0;\n-      overflow = 1;\n-    }\n+  d = real_value_from_int_cst (type, i);\n \n   /* Check for valid float value for this type on this target machine.  */\n-\n #ifdef CHECK_FLOAT_VALUE\n   CHECK_FLOAT_VALUE (TYPE_MODE (type), d, overflow);\n #endif"}, {"sha": "104c766375133a847484fd3c352e0db6bfc9526f", "filename": "gcc/tsystem.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15e5ad7698ca582197d816b0e864d55bc0bdb607/gcc%2Ftsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsystem.h?ref=15e5ad7698ca582197d816b0e864d55bc0bdb607", "patch": "@@ -33,8 +33,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define HAVE_DECL_GETOPT 1\n #endif\n \n-/* GCC supplies this header.  */\n+/* GCC supplies these headers.  */\n #include <stddef.h>\n+#include <float.h>\n \n #ifdef inhibit_libc\n "}]}