{"sha": "9a5de4d5af1c10a8c097de30ee4c71457216e975", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE1ZGU0ZDVhZjFjMTBhOGMwOTdkZTMwZWU0YzcxNDU3MjE2ZTk3NQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-28T08:01:19Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-28T08:46:23Z"}, "message": "OpenMP: Add iterator support to Fortran's depend; add affinity clause\n\ngcc/c-family/ChangeLog:\n\n\t* c-pragma.h (enum pragma_omp_clause): Add PRAGMA_OMP_CLAUSE_AFFINITY.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_clause_affinity): New.\n\t(c_parser_omp_clause_name, c_parser_omp_variable_list,\n\tc_parser_omp_all_clauses, OMP_TASK_CLAUSE_MASK): Handle affinity clause.\n\t* c-typeck.c (handle_omp_array_sections_1, handle_omp_array_sections,\n\tc_finish_omp_clauses): Likewise.\n\ngcc/cp/ChangeLog:\n\n\t* parser.c (cp_parser_omp_clause_affinity): New.\n\t(cp_parser_omp_clause_name, cp_parser_omp_var_list_no_open,\n\tcp_parser_omp_all_clauses, OMP_TASK_CLAUSE_MASK): Handle affinity\n\tclause.\n\t* semantics.c (handle_omp_array_sections_1, handle_omp_array_sections,\n\tfinish_omp_clauses): Likewise.\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_iterator): New.\n\t(show_omp_namelist): Handle iterators.\n\t(show_omp_clauses): Handle affinity.\n\t* gfortran.h (gfc_free_omp_namelist): New union with 'udr' and new 'ns'.\n\t* match.c (gfc_free_omp_namelist): Add are to choose union element.\n\t* openmp.c (gfc_free_omp_clauses, gfc_match_omp_detach,\n\tgfc_match_omp_clause_reduction, gfc_match_omp_flush): Update\n\tcall to gfc_free_omp_namelist.\n\t(gfc_match_omp_variable_list): Likewise; permit preceeding whitespace.\n\t(enum omp_mask1): Add OMP_CLAUSE_AFFINITY.\n\t(gfc_match_iterator): New.\n\t(gfc_match_omp_clauses): Use it; update call to gfc_free_omp_namelist.\n\t(OMP_TASK_CLAUSES): Add OMP_CLAUSE_AFFINITY.\n\t(gfc_match_omp_taskwait): Match depend clause.\n\t(resolve_omp_clauses): Handle affinity; update for udr/union change.\n\t(gfc_resolve_omp_directive): Resolve clauses of taskwait.\n\t* st.c (gfc_free_statement): Update gfc_free_omp_namelist call.\n\t* trans-openmp.c (gfc_trans_omp_array_reduction_or_udr): Likewise\n\t(handle_iterator): New.\n\t(gfc_trans_omp_clauses): Handle iterators for depend/affinity clause.\n\t(gfc_trans_omp_taskwait): Handle depend clause.\n\t(gfc_trans_omp_directive): Update call.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (gimplify_omp_affinity): New.\n\t(gimplify_scan_omp_clauses): Call it; remove affinity clause afterwards.\n\t* tree-core.h (enum omp_clause_code): Add OMP_CLAUSE_AFFINITY.\n\t* tree-pretty-print.c (dump_omp_clause): Handle OMP_CLAUSE_AFFINITY.\n\t* tree.c (omp_clause_num_ops, omp_clause_code_name): Add clause.\n\t(walk_tree_1): Handle OMP_CLAUSE_AFFINITY.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/depend-iterator-2.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/affinity-1.c: New test.\n\t* c-c++-common/gomp/affinity-2.c: New test.\n\t* c-c++-common/gomp/affinity-3.c: New test.\n\t* c-c++-common/gomp/affinity-4.c: New test.\n\t* c-c++-common/gomp/affinity-5.c: New test.\n\t* c-c++-common/gomp/affinity-6.c: New test.\n\t* c-c++-common/gomp/affinity-7.c: New test.\n\t* gfortran.dg/gomp/affinity-clause-1.f90: New test.\n\t* gfortran.dg/gomp/affinity-clause-2.f90: New test.\n\t* gfortran.dg/gomp/affinity-clause-3.f90: New test.\n\t* gfortran.dg/gomp/affinity-clause-4.f90: New test.\n\t* gfortran.dg/gomp/affinity-clause-5.f90: New test.\n\t* gfortran.dg/gomp/affinity-clause-6.f90: New test.\n\t* gfortran.dg/gomp/depend-iterator-1.f90: New test.\n\t* gfortran.dg/gomp/depend-iterator-2.f90: New test.\n\t* gfortran.dg/gomp/depend-iterator-3.f90: New test.\n\t* gfortran.dg/gomp/taskwait.f90: New test.", "tree": {"sha": "0212be39ff9d0d7d03256e1122992209e1edcb80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0212be39ff9d0d7d03256e1122992209e1edcb80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a5de4d5af1c10a8c097de30ee4c71457216e975", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5de4d5af1c10a8c097de30ee4c71457216e975", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a5de4d5af1c10a8c097de30ee4c71457216e975", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a5de4d5af1c10a8c097de30ee4c71457216e975/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b43f6ace51c08dc2bae3c91a2a11300356c573d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b43f6ace51c08dc2bae3c91a2a11300356c573d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b43f6ace51c08dc2bae3c91a2a11300356c573d"}], "stats": {"total": 1906, "additions": 1763, "deletions": 143}, "files": [{"sha": "e4fd3c9b7404086b0f46c67694a7b393ef07b12d", "filename": "gcc/c-family/c-pragma.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc-family%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc-family%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pragma.h?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -86,6 +86,7 @@ enum pragma_kind {\n enum pragma_omp_clause {\n   PRAGMA_OMP_CLAUSE_NONE = 0,\n \n+  PRAGMA_OMP_CLAUSE_AFFINITY,\n   PRAGMA_OMP_CLAUSE_ALIGNED,\n   PRAGMA_OMP_CLAUSE_ALLOCATE,\n   PRAGMA_OMP_CLAUSE_BIND,"}, {"sha": "d71fd0abe90b53e4d143cf46e27fea7821376d79", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -12601,7 +12601,9 @@ c_parser_omp_clause_name (c_parser *parser)\n       switch (p[0])\n \t{\n \tcase 'a':\n-\t  if (!strcmp (\"aligned\", p))\n+\t  if (!strcmp (\"affinity\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_AFFINITY;\n+\t  else if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n \t  else if (!strcmp (\"allocate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALLOCATE;\n@@ -12900,7 +12902,7 @@ c_parser_omp_variable_list (c_parser *parser,\n   while (1)\n     {\n       bool array_section_p = false;\n-      if (kind == OMP_CLAUSE_DEPEND)\n+      if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t{\n \t  if (c_parser_next_token_is_not (parser, CPP_NAME)\n \t      || c_parser_peek_token (parser)->id_kind != C_ID_ID)\n@@ -13040,6 +13042,7 @@ c_parser_omp_variable_list (c_parser *parser,\n \t\t  t = build_component_ref (op_loc, t, ident, comp_loc);\n \t\t}\n \t      /* FALLTHROUGH  */\n+\t    case OMP_CLAUSE_AFFINITY:\n \t    case OMP_CLAUSE_DEPEND:\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n@@ -13090,7 +13093,7 @@ c_parser_omp_variable_list (c_parser *parser,\n \n \t\t  t = tree_cons (low_bound, length, t);\n \t\t}\n-\t      if (kind == OMP_CLAUSE_DEPEND\n+\t      if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t  && t != error_mark_node\n \t\t  && parser->tokens_avail != 2)\n \t\t{\n@@ -13130,7 +13133,7 @@ c_parser_omp_variable_list (c_parser *parser,\n       else\n \tlist = tree_cons (t, NULL_TREE, list);\n \n-      if (kind == OMP_CLAUSE_DEPEND)\n+      if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t{\n \t  parser->tokens = &parser->tokens_buf[0];\n \t  parser->tokens_avail = tokens_avail;\n@@ -15508,6 +15511,69 @@ c_parser_omp_iterators (c_parser *parser)\n   return ret ? ret : error_mark_node;\n }\n \n+/* OpenMP 5.0:\n+   affinity ( [aff-modifier :] variable-list )\n+   aff-modifier:\n+     iterator ( iterators-definition )  */\n+\n+static tree\n+c_parser_omp_clause_affinity (c_parser *parser, tree list)\n+{\n+  location_t clause_loc = c_parser_peek_token (parser)->location;\n+  tree nl, iterators = NULL_TREE;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (c_parser_next_token_is (parser, CPP_NAME))\n+    {\n+      const char *p = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+      bool parse_iter = ((strcmp (\"iterator\", p) == 0)\n+\t\t\t && (c_parser_peek_2nd_token (parser)->type\n+\t\t\t     == CPP_OPEN_PAREN));\n+      if (parse_iter)\n+\t{\n+\t  unsigned n = 3;\n+\t  parse_iter = (c_parser_check_balanced_raw_token_sequence (parser, &n)\n+\t\t\t&& (c_parser_peek_nth_token_raw (parser, n)->type\n+\t\t\t    == CPP_CLOSE_PAREN)\n+\t\t\t&& (c_parser_peek_nth_token_raw (parser, n + 1)->type\n+\t\t\t    == CPP_COLON));\n+\t}\n+      if (parse_iter)\n+\t{\n+\t  iterators = c_parser_omp_iterators (parser);\n+\t  if (!c_parser_require (parser, CPP_COLON, \"expected %<:%>\"))\n+\t    {\n+\t      if (iterators)\n+\t\tpop_scope ();\n+\t      parens.skip_until_found_close (parser);\n+\t      return list;\n+\t    }\n+\t}\n+    }\n+  nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_AFFINITY,\n+\t\t\t\t   list);\n+  if (iterators)\n+    {\n+      tree block = pop_scope ();\n+      if (iterators == error_mark_node)\n+\titerators = NULL_TREE;\n+      else\n+\t{\n+\t  TREE_VEC_ELT (iterators, 5) = block;\n+\t  for (tree c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\t    OMP_CLAUSE_DECL (c) = build_tree_list (iterators,\n+\t\t\t\t\t\t   OMP_CLAUSE_DECL (c));\n+\t}\n+    }\n+\n+  parens.skip_until_found_close (parser);\n+  return nl;\n+}\n+\n+\n /* OpenMP 4.0:\n    depend ( depend-kind: variable-list )\n \n@@ -16474,6 +16540,10 @@ c_parser_omp_all_clauses (c_parser *parser, omp_clause_mask mask,\n \t  clauses = c_parser_omp_clause_linear (parser, clauses); \n \t  c_name = \"linear\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_AFFINITY:\n+\t  clauses = c_parser_omp_clause_affinity (parser, clauses);\n+\t  c_name = \"affinity\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n \t  clauses = c_parser_omp_clause_depend (parser, clauses);\n \t  c_name = \"depend\";\n@@ -19249,7 +19319,8 @@ c_parser_omp_single (location_t loc, c_parser *parser, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_AFFINITY))\n \n static tree\n c_parser_omp_task (location_t loc, c_parser *parser, bool *if_p)"}, {"sha": "bee01df123490f347a6c326b93167afe4a072825", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -13064,7 +13064,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       if (error_operand_p (t))\n \treturn error_mark_node;\n       ret = t;\n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t  && TYPE_ATOMIC (strip_array_types (TREE_TYPE (t))))\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c), \"%<_Atomic%> %qE in %qs clause\",\n@@ -13115,14 +13116,16 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t       && TYPE_ATOMIC (TREE_TYPE (t)))\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c), \"%<_Atomic%> %qD in %qs clause\",\n \t\t    t, omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t       && VAR_P (t)\n \t       && DECL_THREAD_LOCAL_P (t))\n \t{\n@@ -13131,7 +13134,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n+\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n \t  && TYPE_ATOMIC (TREE_TYPE (t))\n \t  && POINTER_TYPE_P (TREE_TYPE (t)))\n \t{\n@@ -13202,7 +13206,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     {\n       if (!integer_nonzerop (length))\n \t{\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n@@ -13270,7 +13275,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t}\n \t      if (tree_int_cst_equal (size, low_bound))\n \t\t{\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n@@ -13291,7 +13297,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t    }\n \t  else if (length == NULL_TREE)\n \t    {\n-\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n@@ -13329,7 +13336,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t}\n       else if (length == NULL_TREE)\n \t{\n-\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n@@ -13374,6 +13382,7 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n       /* If there is a pointer type anywhere but in the very first\n \t array-section-subscript, the array section can't be contiguous.  */\n       if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n \t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c),\n@@ -13410,7 +13419,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n   unsigned int first_non_one = 0;\n   auto_vec<tree, 10> types;\n   tree *tp = &OMP_CLAUSE_DECL (c);\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY)\n       && TREE_CODE (*tp) == TREE_LIST\n       && TREE_PURPOSE (*tp)\n       && TREE_CODE (TREE_PURPOSE (*tp)) == TREE_VEC)\n@@ -13422,7 +13432,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n     return true;\n   if (first == NULL_TREE)\n     return false;\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY)\n     {\n       tree t = *tp;\n       tree tem = NULL_TREE;\n@@ -14531,6 +14542,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  break;\n \n+\tcase OMP_CLAUSE_AFFINITY:\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -14539,7 +14551,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n \t      break;\n \t    }\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t      && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n \t    {\n \t      gcc_assert (TREE_CODE (t) == TREE_LIST);\n \t      for (; t; t = TREE_CHAIN (t))\n@@ -14585,7 +14598,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    {\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n-\t      else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t       && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n@@ -14600,17 +14614,22 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE is not lvalue expression nor array section in \"\n-\t\t\t\"%<depend%> clause\", t);\n+\t\t\t\"%qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (TREE_CODE (t) == COMPONENT_REF\n \t\t   && DECL_C_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t    {\n+\t      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY);\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"bit-field %qE in %qs clause\", t, \"depend\");\n+\t\t\t\"bit-field %qE in %qs clause\", t,\n+\t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n \t    {\n \t      if (!c_omp_depend_t_p (TREE_TYPE (t)))\n \t\t{\n@@ -14621,7 +14640,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t}\n \t    }\n-\t  else if (c_omp_depend_t_p (TREE_TYPE (t)))\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && c_omp_depend_t_p (TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE should not have %<omp_depend_t%> type in \""}, {"sha": "84c6be87873d2e672bae6499217408611ab44f4e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 77, "deletions": 9, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -35117,7 +35117,9 @@ cp_parser_omp_clause_name (cp_parser *parser)\n       switch (p[0])\n \t{\n \tcase 'a':\n-\t  if (!strcmp (\"aligned\", p))\n+\t  if (!strcmp (\"affinity\", p))\n+\t    result = PRAGMA_OMP_CLAUSE_AFFINITY;\n+\t  else if (!strcmp (\"aligned\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALIGNED;\n \t  else if (!strcmp (\"allocate\", p))\n \t    result = PRAGMA_OMP_CLAUSE_ALLOCATE;\n@@ -35376,7 +35378,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n     {\n       tree name, decl;\n \n-      if (kind == OMP_CLAUSE_DEPEND)\n+      if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \tcp_parser_parse_tentatively (parser);\n       token = cp_lexer_peek_token (parser->lexer);\n       if (kind != 0\n@@ -35405,7 +35407,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\t\t  /*optional_p=*/false);\n \t  if (name == error_mark_node)\n \t    {\n-\t      if (kind == OMP_CLAUSE_DEPEND\n+\t      if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t  && cp_parser_simulate_error (parser))\n \t\tgoto depend_lvalue;\n \t      goto skip_comma;\n@@ -35417,7 +35419,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t    decl = name;\n \t  if (decl == error_mark_node)\n \t    {\n-\t      if (kind == OMP_CLAUSE_DEPEND\n+\t      if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t  && cp_parser_simulate_error (parser))\n \t\tgoto depend_lvalue;\n \t      cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,\n@@ -35463,6 +35465,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t\t\t\t\t\t      &idk, loc);\n \t\t}\n \t      /* FALLTHROUGH.  */\n+\t    case OMP_CLAUSE_AFFINITY:\n \t    case OMP_CLAUSE_DEPEND:\n \t    case OMP_CLAUSE_REDUCTION:\n \t    case OMP_CLAUSE_IN_REDUCTION:\n@@ -35489,12 +35492,12 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t      /* Look for `:'.  */\n \t\t      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n \t\t\t{\n-\t\t\t  if (kind == OMP_CLAUSE_DEPEND\n+\t\t\t  if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t\t      && cp_parser_simulate_error (parser))\n \t\t\t    goto depend_lvalue;\n \t\t\t  goto skip_comma;\n \t\t\t}\n-\t\t      if (kind == OMP_CLAUSE_DEPEND)\n+\t\t      if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t\tcp_parser_commit_to_tentative_parse (parser);\n \t\t      if (!cp_lexer_next_token_is (parser->lexer,\n \t\t\t\t\t\t   CPP_CLOSE_SQUARE))\n@@ -35508,7 +35511,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t\t  if (!cp_parser_require (parser, CPP_CLOSE_SQUARE,\n \t\t\t\t\t  RT_CLOSE_SQUARE))\n \t\t    {\n-\t\t      if (kind == OMP_CLAUSE_DEPEND\n+\t\t      if ((kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t\t\t  && cp_parser_simulate_error (parser))\n \t\t\tgoto depend_lvalue;\n \t\t      goto skip_comma;\n@@ -35521,7 +35524,7 @@ cp_parser_omp_var_list_no_open (cp_parser *parser, enum omp_clause_code kind,\n \t      break;\n \t    }\n \n-\t  if (kind == OMP_CLAUSE_DEPEND)\n+\t  if (kind == OMP_CLAUSE_DEPEND || kind == OMP_CLAUSE_AFFINITY)\n \t    {\n \t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n \t\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN)\n@@ -37761,6 +37764,66 @@ cp_parser_omp_iterators (cp_parser *parser)\n   return ret ? ret : error_mark_node;\n }\n \n+/* OpenMP 5.0:\n+   affinity ( [aff-modifier :] variable-list )\n+   aff-modifier:\n+     iterator ( iterators-definition )  */\n+\n+static tree\n+cp_parser_omp_clause_affinity (cp_parser *parser, tree list)\n+{\n+  tree nlist, c, iterators = NULL_TREE;\n+\n+  matching_parens parens;\n+  if (!parens.require_open (parser))\n+    return list;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      tree id = cp_lexer_peek_token (parser->lexer)->u.value;\n+      const char *p = IDENTIFIER_POINTER (id);\n+      bool parse_iter = ((strcmp (\"iterator\", p) == 0)\n+\t\t\t && (cp_lexer_nth_token_is (parser->lexer, 2,\n+\t\t\t\t\t\t    CPP_OPEN_PAREN)));\n+      if (parse_iter)\n+\t{\n+\t  size_t n = cp_parser_skip_balanced_tokens (parser, 2);\n+\t  parse_iter = cp_lexer_nth_token_is (parser->lexer, n, CPP_COLON);\n+\t}\n+      if (parse_iter)\n+\t{\n+\t  begin_scope (sk_omp, NULL);\n+\t  iterators = cp_parser_omp_iterators (parser);\n+\t  if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\t    {\n+\t      if (iterators)\n+\t\tpoplevel (0, 1, 0);\n+\t      cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t     /*recovering=*/true,\n+\t\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t\t     /*consume_paren=*/true);\n+\t      return list;\n+\t    }\n+\t}\n+    }\n+  nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_AFFINITY,\n+\t\t\t\t\t  list, NULL);\n+  if (iterators)\n+    {\n+      tree block = poplevel (1, 1, 0);\n+      if (iterators == error_mark_node)\n+\titerators = NULL_TREE;\n+      else\n+\t{\n+\t  TREE_VEC_ELT (iterators, 5) = block;\n+\t  for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n+\t    OMP_CLAUSE_DECL (c) = build_tree_list (iterators,\n+\t\t\t\t\t\t   OMP_CLAUSE_DECL (c));\n+\t}\n+    }\n+  return nlist;\n+}\n+\n /* OpenMP 4.0:\n    depend ( depend-kind : variable-list )\n \n@@ -38753,6 +38816,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  }\n \t  c_name = \"linear\";\n \t  break;\n+\tcase PRAGMA_OMP_CLAUSE_AFFINITY:\n+\t  clauses = cp_parser_omp_clause_affinity (parser, clauses);\n+\t  c_name = \"affinity\";\n+\t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n \t  clauses = cp_parser_omp_clause_depend (parser, clauses,\n \t\t\t\t\t\t token->location);\n@@ -41349,7 +41416,8 @@ cp_parser_omp_single (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_PRIORITY)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_ALLOCATE)\t\\\n \t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_IN_REDUCTION)\t\\\n-\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH))\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_DETACH)\t\\\n+\t| (OMP_CLAUSE_MASK_1 << PRAGMA_OMP_CLAUSE_AFFINITY))\n \n static tree\n cp_parser_omp_task (cp_parser *parser, cp_token *pragma_tok, bool *if_p)"}, {"sha": "6fafd0648e079965463b0c09175c184a163eb76b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -4993,7 +4993,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t    \" clauses\");\n \t  return error_mark_node;\n \t}\n-      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+      else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t       && VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c),\n@@ -5080,7 +5081,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n     {\n       if (!integer_nonzerop (length))\n \t{\n-\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n+\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n \t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n@@ -5148,7 +5150,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t}\n \t      if (tree_int_cst_equal (size, low_bound))\n \t\t{\n-\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n+\t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION\n \t\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_TASK_REDUCTION)\n@@ -5169,7 +5172,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t    }\n \t  else if (length == NULL_TREE)\n \t    {\n-\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n \t\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n@@ -5207,7 +5211,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t}\n       else if (length == NULL_TREE)\n \t{\n-\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+\t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_REDUCTION\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_IN_REDUCTION\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_TASK_REDUCTION)\n@@ -5251,7 +5256,8 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t}\n       /* If there is a pointer type anywhere but in the very first\n \t array-section-subscript, the array section can't be contiguous.  */\n-      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n+      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n+\t  && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t  && TREE_CODE (TREE_CHAIN (t)) == TREE_LIST)\n \t{\n \t  error_at (OMP_CLAUSE_LOCATION (c),\n@@ -5299,7 +5305,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n   unsigned int first_non_one = 0;\n   auto_vec<tree, 10> types;\n   tree *tp = &OMP_CLAUSE_DECL (c);\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+  if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+       || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY)\n       && TREE_CODE (*tp) == TREE_LIST\n       && TREE_PURPOSE (*tp)\n       && TREE_CODE (TREE_PURPOSE (*tp)) == TREE_VEC)\n@@ -5311,7 +5318,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n     return true;\n   if (first == NULL_TREE)\n     return false;\n-  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND)\n+  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY)\n     {\n       tree t = *tp;\n       tree tem = NULL_TREE;\n@@ -7445,6 +7453,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    }\n \t  goto handle_field_decl;\n \n+\tcase OMP_CLAUSE_AFFINITY:\n \tcase OMP_CLAUSE_DEPEND:\n \t  t = OMP_CLAUSE_DECL (c);\n \t  if (t == NULL_TREE)\n@@ -7453,7 +7462,8 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\t  == OMP_CLAUSE_DEPEND_SOURCE);\n \t      break;\n \t    }\n-\t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n+\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t      && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n \t    {\n \t      if (cp_finish_omp_clause_depend_sink (c))\n \t\tremove = true;\n@@ -7478,7 +7488,9 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t    {\n \t      if (handle_omp_array_sections (c, ort))\n \t\tremove = true;\n-\t      else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t      else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t       && (OMP_CLAUSE_DEPEND_KIND (c)\n+\t\t\t   == OMP_CLAUSE_DEPEND_DEPOBJ))\n \t\t{\n \t\t  error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t    \"%<depend%> clause with %<depobj%> dependence \"\n@@ -7503,22 +7515,28 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      if (DECL_P (t))\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t  \"%qD is not lvalue expression nor array section \"\n-\t\t\t  \"in %<depend%> clause\", t);\n+\t\t\t  \"in %qs clause\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      else\n \t\terror_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t  \"%qE is not lvalue expression nor array section \"\n-\t\t\t  \"in %<depend%> clause\", t);\n+\t\t\t  \"in %qs clause\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n \t  else if (TREE_CODE (t) == COMPONENT_REF\n \t\t   && TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL\n \t\t   && DECL_BIT_FIELD (TREE_OPERAND (t, 1)))\n \t    {\n+\t      gcc_assert (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t\t  || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY);\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"bit-field %qE in %qs clause\", t, \"depend\");\n+\t\t\t\"bit-field %qE in %qs clause\", t,\n+\t\t\t  omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_DEPOBJ)\n \t    {\n \t      if (!c_omp_depend_t_p (TYPE_REF_P (TREE_TYPE (t))\n \t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n@@ -7531,9 +7549,10 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t  remove = true;\n \t\t}\n \t    }\n-\t  else if (c_omp_depend_t_p (TYPE_REF_P (TREE_TYPE (t))\n-\t\t\t\t     ? TREE_TYPE (TREE_TYPE (t))\n-\t\t\t\t     : TREE_TYPE (t)))\n+\t  else if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND\n+\t\t   && c_omp_depend_t_p (TYPE_REF_P (TREE_TYPE (t))\n+\t\t\t\t\t? TREE_TYPE (TREE_TYPE (t))\n+\t\t\t\t\t: TREE_TYPE (t)))\n \t    {\n \t      error_at (OMP_CLAUSE_LOCATION (c),\n \t\t\t\"%qE should not have %<omp_depend_t%> type in \""}, {"sha": "93ff572cbd26a7a794e200519ebe0c84487a3922", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -1297,11 +1297,56 @@ show_code (int level, gfc_code *c)\n     show_code_node (level, c);\n }\n \n+static void\n+show_iterator (gfc_namespace *ns)\n+{\n+  for (gfc_symbol *sym = ns->proc_name; sym; sym = sym->tlink)\n+    {\n+      gfc_constructor *c;\n+      if (sym != ns->proc_name)\n+\tfputc (',', dumpfile);\n+      fputs (sym->name, dumpfile);\n+      fputc ('=', dumpfile);\n+      c = gfc_constructor_first (sym->value->value.constructor);\n+      show_expr (c->expr);\n+      fputc (':', dumpfile);\n+      c = gfc_constructor_next (c);\n+      show_expr (c->expr);\n+      c = gfc_constructor_next (c);\n+      if (c)\n+\t{\n+\t  fputc (':', dumpfile);\n+\t  show_expr (c->expr);\n+\t}\n+    }\n+}\n+\n static void\n show_omp_namelist (int list_type, gfc_omp_namelist *n)\n {\n+  gfc_namespace *ns_iter = NULL, *ns_curr = gfc_current_ns;\n+  gfc_omp_namelist *n2 = n;\n   for (; n; n = n->next)\n     {\n+      gfc_current_ns = ns_curr;\n+      if (list_type == OMP_LIST_AFFINITY || list_type == OMP_LIST_DEPEND)\n+\t{\n+\t  gfc_current_ns = n->u2.ns ? n->u2.ns : ns_curr;\n+\t  if (n->u2.ns != ns_iter)\n+\t    {\n+\t      if (n != n2)\n+\t\tfputs (list_type == OMP_LIST_AFFINITY\n+\t\t       ? \") AFFINITY(\" : \") DEPEND(\", dumpfile);\n+\t      if (n->u2.ns)\n+\t\t{\n+\t\t  fputs (\"ITERATOR(\", dumpfile);\n+\t\t  show_iterator (n->u2.ns);\n+\t\t  fputc (')', dumpfile);\n+\t\t  fputc (list_type == OMP_LIST_AFFINITY ? ':' : ',', dumpfile);\n+\t\t}\n+\t    }\n+\t  ns_iter = n->u2.ns;\n+\t}\n       if (list_type == OMP_LIST_REDUCTION)\n \tswitch (n->u.reduction_op)\n \t  {\n@@ -1321,8 +1366,8 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  case OMP_REDUCTION_IOR: fputs (\"ior:\", dumpfile); break;\n \t  case OMP_REDUCTION_IEOR: fputs (\"ieor:\", dumpfile); break;\n \t  case OMP_REDUCTION_USER:\n-\t    if (n->udr)\n-\t      fprintf (dumpfile, \"%s:\", n->udr->udr->name);\n+\t    if (n->u2.udr)\n+\t      fprintf (dumpfile, \"%s:\", n->u2.udr->udr->name);\n \t    break;\n \t  default: break;\n \t  }\n@@ -1387,6 +1432,7 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n       if (n->next)\n \tfputc (',', dumpfile);\n     }\n+  gfc_current_ns = ns_curr;\n }\n \n \n@@ -1610,6 +1656,7 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t  case OMP_LIST_SHARED: type = \"SHARED\"; break;\n \t  case OMP_LIST_COPYIN: type = \"COPYIN\"; break;\n \t  case OMP_LIST_UNIFORM: type = \"UNIFORM\"; break;\n+\t  case OMP_LIST_AFFINITY: type = \"AFFINITY\"; break;\n \t  case OMP_LIST_ALIGNED: type = \"ALIGNED\"; break;\n \t  case OMP_LIST_LINEAR: type = \"LINEAR\"; break;\n \t  case OMP_LIST_DEPEND: type = \"DEPEND\"; break;"}, {"sha": "55fba04642a5930f23c6f1c411d47a7ee75760ee", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -1257,7 +1257,11 @@ typedef struct gfc_omp_namelist\n       struct gfc_common_head *common;\n       bool lastprivate_conditional;\n     } u;\n-  struct gfc_omp_namelist_udr *udr;\n+  union\n+    {\n+      struct gfc_omp_namelist_udr *udr;\n+      gfc_namespace *ns;\n+    } u2;\n   struct gfc_omp_namelist *next;\n   locus where;\n }\n@@ -1275,6 +1279,7 @@ enum\n   OMP_LIST_SHARED,\n   OMP_LIST_COPYIN,\n   OMP_LIST_UNIFORM,\n+  OMP_LIST_AFFINITY,\n   OMP_LIST_ALIGNED,\n   OMP_LIST_LINEAR,\n   OMP_LIST_DEPEND,\n@@ -3321,7 +3326,7 @@ void gfc_free_iterator (gfc_iterator *, int);\n void gfc_free_forall_iterator (gfc_forall_iterator *);\n void gfc_free_alloc_list (gfc_alloc *);\n void gfc_free_namelist (gfc_namelist *);\n-void gfc_free_omp_namelist (gfc_omp_namelist *);\n+void gfc_free_omp_namelist (gfc_omp_namelist *, bool);\n void gfc_free_equiv (gfc_equiv *);\n void gfc_free_equiv_until (gfc_equiv *, gfc_equiv *);\n void gfc_free_data (gfc_data *);"}, {"sha": "294620130387edba4207d8907b1c42adee84178a", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -5470,20 +5470,22 @@ gfc_free_namelist (gfc_namelist *name)\n /* Free an OpenMP namelist structure.  */\n \n void\n-gfc_free_omp_namelist (gfc_omp_namelist *name)\n+gfc_free_omp_namelist (gfc_omp_namelist *name, bool free_ns)\n {\n   gfc_omp_namelist *n;\n \n   for (; name; name = n)\n     {\n       gfc_free_expr (name->expr);\n-      if (name->udr)\n-\t{\n-\t  if (name->udr->combiner)\n-\t    gfc_free_statement (name->udr->combiner);\n-\t  if (name->udr->initializer)\n-\t    gfc_free_statement (name->udr->initializer);\n-\t  free (name->udr);\n+      if (free_ns)\n+\tgfc_free_namespace (name->u2.ns);\n+      else if (name->u2.udr)\n+\t{\n+\t  if (name->u2.udr->combiner)\n+\t    gfc_free_statement (name->u2.udr->combiner);\n+\t  if (name->u2.udr->initializer)\n+\t    gfc_free_statement (name->u2.udr->initializer);\n+\t  free (name->u2.udr);\n \t}\n       n = name->next;\n       free (name);"}, {"sha": "4ed6a0d64c8719c67ff1673d20ca71556bba9684", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 265, "deletions": 42, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"arith.h\"\n #include \"match.h\"\n #include \"parse.h\"\n+#include \"constructor.h\"\n #include \"diagnostic.h\"\n #include \"gomp-constants.h\"\n \n@@ -103,7 +104,8 @@ gfc_free_omp_clauses (gfc_omp_clauses *c)\n   gfc_free_expr (c->num_workers_expr);\n   gfc_free_expr (c->vector_length_expr);\n   for (i = 0; i < OMP_LIST_NUM; i++)\n-    gfc_free_omp_namelist (c->lists[i]);\n+    gfc_free_omp_namelist (c->lists[i],\n+\t\t\t   i == OMP_LIST_AFFINITY || i == OMP_LIST_DEPEND);\n   gfc_free_expr_list (c->wait_list);\n   gfc_free_expr_list (c->tile_list);\n   free (CONST_CAST (char *, c->critical_name));\n@@ -355,7 +357,7 @@ gfc_match_omp_variable_list (const char *str, gfc_omp_namelist **list,\n   gfc_error (\"Syntax error in OpenMP variable list at %C\");\n \n cleanup:\n-  gfc_free_omp_namelist (head);\n+  gfc_free_omp_namelist (head, false);\n   gfc_current_locus = old_loc;\n   return MATCH_ERROR;\n }\n@@ -445,7 +447,7 @@ gfc_match_omp_to_link (const char *str, gfc_omp_namelist **list)\n   gfc_error (\"Syntax error in OpenMP variable list at %C\");\n \n cleanup:\n-  gfc_free_omp_namelist (head);\n+  gfc_free_omp_namelist (head, false);\n   gfc_current_locus = old_loc;\n   return MATCH_ERROR;\n }\n@@ -552,7 +554,7 @@ gfc_match_omp_depend_sink (gfc_omp_namelist **list)\n   gfc_error (\"Syntax error in OpenMP DEPEND SINK list at %C\");\n \n cleanup:\n-  gfc_free_omp_namelist (head);\n+  gfc_free_omp_namelist (head, false);\n   gfc_current_locus = old_loc;\n   return MATCH_ERROR;\n }\n@@ -843,6 +845,7 @@ enum omp_mask1\n   OMP_CLAUSE_CAPTURE,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_MEMORDER,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_DETACH,  /* OpenMP 5.0.  */\n+  OMP_CLAUSE_AFFINITY,  /* OpenMP 5.0.  */\n   OMP_CLAUSE_NOWAIT,\n   /* This must come last.  */\n   OMP_MASK1_LAST\n@@ -996,6 +999,132 @@ gfc_match_omp_map_clause (gfc_omp_namelist **list, gfc_omp_map_op map_op,\n   return false;\n }\n \n+static match\n+gfc_match_iterator (gfc_namespace **ns, bool permit_var)\n+{\n+  locus old_loc = gfc_current_locus;\n+\n+  if (gfc_match (\"iterator ( \") != MATCH_YES)\n+    return MATCH_NO;\n+\n+  gfc_typespec ts;\n+  gfc_symbol *last = NULL;\n+  gfc_expr *begin, *end, *step;\n+  *ns = gfc_build_block_ns (gfc_current_ns);\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  while (true)\n+    {\n+      locus prev_loc = gfc_current_locus;\n+      if (gfc_match_type_spec (&ts) == MATCH_YES\n+\t  && gfc_match (\" :: \") == MATCH_YES)\n+\t{\n+\t  if (ts.type != BT_INTEGER)\n+\t    {\n+\t      gfc_error (\"Expected INTEGER type at %L\", &prev_loc);\n+\t      return MATCH_ERROR;\n+\t    }\n+\t  permit_var = false;\n+\t}\n+      else\n+\t{\n+\t  ts.type = BT_INTEGER;\n+\t  ts.kind = gfc_default_integer_kind;\n+\t  gfc_current_locus = prev_loc;\n+\t}\n+      prev_loc = gfc_current_locus;\n+      if (gfc_match_name (name) != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected identifier at %C\");\n+\t  goto failed;\n+\t}\n+      if (gfc_find_symtree ((*ns)->sym_root, name))\n+\t{\n+\t  gfc_error (\"Same identifier %qs specified again at %C\", name);\n+\t  goto failed;\n+\t}\n+\n+      gfc_symbol *sym = gfc_new_symbol (name, *ns);\n+      if (last)\n+\tlast->tlink = sym;\n+      else\n+\t(*ns)->proc_name = sym;\n+      last = sym;\n+      sym->declared_at = prev_loc;\n+      sym->ts = ts;\n+      sym->attr.flavor = FL_VARIABLE;\n+      sym->attr.artificial = 1;\n+      sym->attr.referenced = 1;\n+      sym->refs++;\n+      gfc_symtree *st = gfc_new_symtree (&(*ns)->sym_root, name);\n+      st->n.sym = sym;\n+\n+      prev_loc = gfc_current_locus;\n+      if (gfc_match (\" = \") != MATCH_YES)\n+\tgoto failed;\n+      permit_var = false;\n+      begin = end = step = NULL;\n+      if (gfc_match (\"%e : \", &begin) != MATCH_YES\n+\t  || gfc_match (\"%e \", &end) != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Expected range-specification at %C\");\n+\t  gfc_free_expr (begin);\n+\t  gfc_free_expr (end);\n+\t  return MATCH_ERROR;\n+\t}\n+      if (':' == gfc_peek_ascii_char ())\n+\t{\n+\t  step = gfc_get_expr ();\n+\t  if (gfc_match (\": %e \", &step) != MATCH_YES)\n+\t    {\n+\t      gfc_free_expr (begin);\n+\t      gfc_free_expr (end);\n+\t      gfc_free_expr (step);\n+\t      goto failed;\n+\t    }\n+\t}\n+\n+      gfc_expr *e = gfc_get_expr ();\n+      e->where = prev_loc;\n+      e->expr_type = EXPR_ARRAY;\n+      e->ts = ts;\n+      e->rank = 1;\n+      e->shape = gfc_get_shape (1);\n+      mpz_init_set_ui (e->shape[0], step ? 3 : 2);\n+      gfc_constructor_append_expr (&e->value.constructor, begin, &begin->where);\n+      gfc_constructor_append_expr (&e->value.constructor, end, &end->where);\n+      if (step)\n+\tgfc_constructor_append_expr (&e->value.constructor, step, &step->where);\n+      sym->value = e;\n+\n+      if (gfc_match (\") \") == MATCH_YES)\n+\tbreak;\n+      if (gfc_match (\", \") != MATCH_YES)\n+\tgoto failed;\n+    }\n+  return MATCH_YES;\n+\n+failed:\n+  gfc_namespace *prev_ns = NULL;\n+  for (gfc_namespace *it = gfc_current_ns->contained; it; it = it->sibling)\n+    {\n+      if (it == *ns)\n+\t{\n+\t  if (prev_ns)\n+\t    prev_ns->sibling = it->sibling;\n+\t  else\n+\t    gfc_current_ns->contained = it->sibling;\n+\t  gfc_free_namespace (it);\n+\t  break;\n+\t}\n+      prev_ns = it;\n+    }\n+  *ns = NULL;\n+  if (!permit_var)\n+    return MATCH_ERROR;\n+  gfc_current_locus = old_loc;\n+  return MATCH_NO;\n+}\n+\n /* reduction ( reduction-modifier, reduction-operator : variable-list )\n    in_reduction ( reduction-operator : variable-list )\n    task_reduction ( reduction-operator : variable-list )  */\n@@ -1138,16 +1267,16 @@ gfc_match_omp_clause_reduction (char pc, gfc_omp_clauses *c, bool openacc,\n       *head = NULL;\n       gfc_error_now (\"!$OMP DECLARE REDUCTION %s not found at %L\",\n \t\t     buffer, &old_loc);\n-      gfc_free_omp_namelist (n);\n+      gfc_free_omp_namelist (n, false);\n     }\n   else\n     for (n = *head; n; n = n->next)\n       {\n \tn->u.reduction_op = rop;\n \tif (udr)\n \t  {\n-\t    n->udr = gfc_get_omp_namelist_udr ();\n-\t    n->udr->udr = udr;\n+\t    n->u2.udr = gfc_get_omp_namelist_udr ();\n+\t    n->u2.udr->udr = udr;\n \t  }\n      }\n   return MATCH_YES;\n@@ -1202,7 +1331,7 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \n \t      if (end_colon && gfc_match (\" %e )\", &alignment) != MATCH_YES)\n \t\t{\n-\t\t  gfc_free_omp_namelist (*head);\n+\t\t  gfc_free_omp_namelist (*head, false);\n \t\t  gfc_current_locus = old_loc;\n \t\t  *head = NULL;\n \t\t  break;\n@@ -1230,6 +1359,36 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      needs_space = true;\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_AFFINITY)\n+\t      && gfc_match (\"affinity ( \") == MATCH_YES)\n+\t    {\n+\t      gfc_namespace *ns_iter = NULL, *ns_curr = gfc_current_ns;\n+\t      match m = gfc_match_iterator (&ns_iter, true);\n+\t      if (m == MATCH_ERROR)\n+\t\tbreak;\n+\t      if (m == MATCH_YES && gfc_match (\" : \") != MATCH_YES)\n+\t\t{\n+\t\t  gfc_error (\"Expected %<:%> at %C\");\n+\t\t  break;\n+\t\t}\n+\t      if (ns_iter)\n+\t\tgfc_current_ns = ns_iter;\n+\t      head = NULL;\n+\t      m = gfc_match_omp_variable_list (\"\", &c->lists[OMP_LIST_AFFINITY],\n+\t\t\t\t\t       false, NULL, &head, true);\n+\t      gfc_current_ns = ns_curr;\n+\t      if (m == MATCH_ERROR)\n+\t\tbreak;\n+\t      if (ns_iter)\n+\t\t{\n+\t\t  for (gfc_omp_namelist *n = *head; n; n = n->next)\n+\t\t    {\n+\t\t      n->u2.ns = ns_iter;\n+\t\t      ns_iter->refs++;\n+\t\t    }\n+\t\t}\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_ASYNC)\n \t      && !c->async\n \t      && gfc_match (\"async\") == MATCH_YES)\n@@ -1374,6 +1533,12 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t  if ((mask & OMP_CLAUSE_DEPEND)\n \t      && gfc_match (\"depend ( \") == MATCH_YES)\n \t    {\n+\t      gfc_namespace *ns_iter = NULL, *ns_curr = gfc_current_ns;\n+\t      match m_it = gfc_match_iterator (&ns_iter, false);\n+\t      if (m_it == MATCH_ERROR)\n+\t\tbreak;\n+\t      if (m_it == MATCH_YES && gfc_match (\" , \") != MATCH_YES)\n+\t\tbreak;\n \t      match m = MATCH_YES;\n \t      gfc_omp_depend_op depend_op = OMP_DEPEND_OUT;\n \t      if (gfc_match (\"inout\") == MATCH_YES)\n@@ -1389,11 +1554,24 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      else if (!c->depend_source\n \t\t       && gfc_match (\"source )\") == MATCH_YES)\n \t\t{\n+\t\t  if (m_it == MATCH_YES)\n+\t\t    {\n+\t\t      gfc_error (\"ITERATOR may not be combined with SOURCE \"\n+\t\t\t\t \"at %C\");\n+\t\t      gfc_free_omp_clauses (c);\n+\t\t      return MATCH_ERROR;\n+\t\t    }\n \t\t  c->depend_source = true;\n \t\t  continue;\n \t\t}\n \t      else if (gfc_match (\"sink : \") == MATCH_YES)\n \t\t{\n+\t\t  if (m_it == MATCH_YES)\n+\t\t    {\n+\t\t      gfc_error (\"ITERATOR may not be combined with SINK \"\n+\t\t\t\t \"at %C\");\n+\t\t      break;\n+\t\t    }\n \t\t  if (gfc_match_omp_depend_sink (&c->lists[OMP_LIST_DEPEND])\n \t\t      == MATCH_YES)\n \t\t    continue;\n@@ -1402,19 +1580,26 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t      else\n \t\tm = MATCH_NO;\n \t      head = NULL;\n-\t      if (m == MATCH_YES\n-\t\t  && gfc_match_omp_variable_list (\" : \",\n-\t\t\t\t\t\t  &c->lists[OMP_LIST_DEPEND],\n-\t\t\t\t\t\t  false, NULL, &head,\n-\t\t\t\t\t\t  true) == MATCH_YES)\n+\t      if (ns_iter)\n+\t\tgfc_current_ns = ns_iter;\n+\t      if (m == MATCH_YES)\n+\t\tm = gfc_match_omp_variable_list (\" : \",\n+\t\t\t\t\t\t &c->lists[OMP_LIST_DEPEND],\n+\t\t\t\t\t\t false, NULL, &head, true);\n+\t      gfc_current_ns = ns_curr;\n+\t      if (m == MATCH_YES)\n \t\t{\n \t\t  gfc_omp_namelist *n;\n \t\t  for (n = *head; n; n = n->next)\n-\t\t    n->u.depend_op = depend_op;\n+\t\t    {\n+\t\t      n->u.depend_op = depend_op;\n+\t\t      n->u2.ns = ns_iter;\n+\t\t      if (ns_iter)\n+\t\t\tns_iter->refs++;\n+\t\t    }\n \t\t  continue;\n \t\t}\n-\t      else\n-\t\tgfc_current_locus = old_loc;\n+\t      break;\n \t    }\n \t  if ((mask & OMP_CLAUSE_DETACH)\n \t      && !openacc\n@@ -1666,15 +1851,15 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t    end_colon = true;\n \t\t  else if (gfc_match (\" )\") != MATCH_YES)\n \t\t    {\n-\t\t      gfc_free_omp_namelist (*head);\n+\t\t      gfc_free_omp_namelist (*head, false);\n \t\t      gfc_current_locus = old_loc;\n \t\t      *head = NULL;\n \t\t      break;\n \t\t    }\n \t\t}\n \t      if (end_colon && gfc_match (\" %e )\", &step) != MATCH_YES)\n \t\t{\n-\t\t  gfc_free_omp_namelist (*head);\n+\t\t  gfc_free_omp_namelist (*head, false);\n \t\t  gfc_current_locus = old_loc;\n \t\t  *head = NULL;\n \t\t  break;\n@@ -2844,7 +3029,7 @@ gfc_match_oacc_routine (void)\n    | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF | OMP_CLAUSE_DEFAULT\t\t\\\n    | OMP_CLAUSE_UNTIED | OMP_CLAUSE_FINAL | OMP_CLAUSE_MERGEABLE\t\\\n    | OMP_CLAUSE_DEPEND | OMP_CLAUSE_PRIORITY | OMP_CLAUSE_IN_REDUCTION\t\\\n-   | OMP_CLAUSE_DETACH)\n+   | OMP_CLAUSE_DETACH | OMP_CLAUSE_AFFINITY)\n #define OMP_TASKLOOP_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_PRIVATE) | OMP_CLAUSE_FIRSTPRIVATE\t\t\\\n    | OMP_CLAUSE_LASTPRIVATE | OMP_CLAUSE_SHARED | OMP_CLAUSE_IF\t\t\\\n@@ -3097,14 +3282,14 @@ gfc_match_omp_flush (void)\n     {\n       gfc_error (\"List specified together with memory order clause in FLUSH \"\n \t\t \"directive at %C\");\n-      gfc_free_omp_namelist (list);\n+      gfc_free_omp_namelist (list, false);\n       gfc_free_omp_clauses (c);\n       return MATCH_ERROR;\n     }\n   if (gfc_match_omp_eos () != MATCH_YES)\n     {\n       gfc_error (\"Unexpected junk after $OMP FLUSH statement at %C\");\n-      gfc_free_omp_namelist (list);\n+      gfc_free_omp_namelist (list, false);\n       gfc_free_omp_clauses (c);\n       return MATCH_ERROR;\n     }\n@@ -4252,14 +4437,13 @@ gfc_match_omp_taskloop_simd (void)\n match\n gfc_match_omp_taskwait (void)\n {\n-  if (gfc_match_omp_eos () != MATCH_YES)\n+  if (gfc_match_omp_eos () == MATCH_YES)\n     {\n-      gfc_error (\"Unexpected junk after TASKWAIT clause at %C\");\n-      return MATCH_ERROR;\n+      new_st.op = EXEC_OMP_TASKWAIT;\n+      new_st.ext.omp_clauses = NULL;\n+      return MATCH_YES;\n     }\n-  new_st.op = EXEC_OMP_TASKWAIT;\n-  new_st.ext.omp_clauses = NULL;\n-  return MATCH_YES;\n+  return match_omp (EXEC_OMP_TASKWAIT, omp_mask (OMP_CLAUSE_DEPEND));\n }\n \n \n@@ -4825,7 +5009,7 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n   gfc_omp_linear_op linear_op = OMP_LINEAR_DEFAULT;\n   static const char *clause_names[]\n     = { \"PRIVATE\", \"FIRSTPRIVATE\", \"LASTPRIVATE\", \"COPYPRIVATE\", \"SHARED\",\n-\t\"COPYIN\", \"UNIFORM\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"MAP\",\n+\t\"COPYIN\", \"UNIFORM\", \"AFFINITY\", \"ALIGNED\", \"LINEAR\", \"DEPEND\", \"MAP\",\n \t\"TO\", \"FROM\", \"INCLUSIVE\", \"EXCLUSIVE\",\n \t\"REDUCTION\", \"REDUCTION\" /*inscan*/, \"REDUCTION\" /*task*/,\n \t\"IN_REDUCTION\", \"TASK_REDUCTION\",\n@@ -5273,13 +5457,48 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t  }\n \t      }\n \t    break;\n+\t  case OMP_LIST_AFFINITY:\n \t  case OMP_LIST_DEPEND:\n \t  case OMP_LIST_MAP:\n \t  case OMP_LIST_TO:\n \t  case OMP_LIST_FROM:\n \t  case OMP_LIST_CACHE:\n \t    for (; n != NULL; n = n->next)\n \t      {\n+\t\tif ((list == OMP_LIST_DEPEND || list == OMP_LIST_AFFINITY)\n+\t\t    && n->u2.ns && !n->u2.ns->resolved)\n+\t\t  {\n+\t\t    n->u2.ns->resolved = 1;\n+\t\t    for (gfc_symbol *sym = n->u2.ns->proc_name; sym;\n+\t\t\t sym = sym->tlink)\n+\t\t      {\n+\t\t\tgfc_constructor *c;\n+\t\t\tc = gfc_constructor_first (sym->value->value.constructor);\n+\t\t\tif (!gfc_resolve_expr (c->expr)\n+\t\t\t    || c->expr->ts.type != BT_INTEGER\n+\t\t\t    || c->expr->rank != 0)\n+\t\t\t  gfc_error (\"Scalar integer expression for range begin\"\n+\t\t\t\t     \" expected at %L\", &c->expr->where);\n+\t\t\tc = gfc_constructor_next (c);\n+\t\t\tif (!gfc_resolve_expr (c->expr)\n+\t\t\t    || c->expr->ts.type != BT_INTEGER\n+\t\t\t    || c->expr->rank != 0)\n+\t\t\t  gfc_error (\"Scalar integer expression for range end \"\n+\t\t\t\t     \"expected at %L\", &c->expr->where);\n+\t\t\tc = gfc_constructor_next (c);\n+\t\t\tif (c && (!gfc_resolve_expr (c->expr)\n+\t\t\t\t  || c->expr->ts.type != BT_INTEGER\n+\t\t\t\t  || c->expr->rank != 0))\n+\t\t\t  gfc_error (\"Scalar integer expression for range step \"\n+\t\t\t\t     \"expected at %L\", &c->expr->where);\n+\t\t\telse if (c\n+\t\t\t\t && c->expr->expr_type == EXPR_CONSTANT\n+\t\t\t\t && mpz_cmp_si (c->expr->value.integer, 0) == 0)\n+\t\t\t  gfc_error (\"Nonzero range step expected at %L\",\n+\t\t\t\t     &c->expr->where);\n+\t\t      }\n+\t\t  }\n+\n \t\tif (list == OMP_LIST_DEPEND)\n \t\t  {\n \t\t    if (n->u.depend_op == OMP_DEPEND_SINK_FIRST\n@@ -5421,17 +5640,20 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t\t\t n->sym->name, name, &n->where);\n \t\t\t      break;\n \t\t\t    }\n-\t\t\t  else if (list == OMP_LIST_DEPEND\n+\t\t\t  else if ((list == OMP_LIST_DEPEND\n+\t\t\t\t    || list == OMP_LIST_AFFINITY)\n \t\t\t\t   && ar->start[i]\n \t\t\t\t   && ar->start[i]->expr_type == EXPR_CONSTANT\n \t\t\t\t   && ar->end[i]\n \t\t\t\t   && ar->end[i]->expr_type == EXPR_CONSTANT\n \t\t\t\t   && mpz_cmp (ar->start[i]->value.integer,\n \t\t\t\t\t       ar->end[i]->value.integer) > 0)\n \t\t\t    {\n-\t\t\t      gfc_error (\"%qs in DEPEND clause at %L is a \"\n+\t\t\t      gfc_error (\"%qs in %s clause at %L is a \"\n \t\t\t\t\t \"zero size array section\",\n-\t\t\t\t\t n->sym->name, &n->where);\n+\t\t\t\t\t n->sym->name,\n+\t\t\t\t\t list == OMP_LIST_DEPEND\n+\t\t\t\t\t ? \"DEPEND\" : \"AFFINITY\", &n->where);\n \t\t\t      break;\n \t\t\t    }\n \t\t      }\n@@ -5675,23 +5897,23 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\tbreak;\n \t\t      }\n \t\t    if (!bad)\n-\t\t      n->udr = NULL;\n+\t\t      n->u2.udr = NULL;\n \t\t    else\n \t\t      {\n \t\t\tconst char *udr_name = NULL;\n-\t\t\tif (n->udr)\n+\t\t\tif (n->u2.udr)\n \t\t\t  {\n-\t\t\t    udr_name = n->udr->udr->name;\n-\t\t\t    n->udr->udr\n+\t\t\t    udr_name = n->u2.udr->udr->name;\n+\t\t\t    n->u2.udr->udr\n \t\t\t      = gfc_find_omp_udr (NULL, udr_name,\n \t\t\t\t\t\t  &n->sym->ts);\n-\t\t\t    if (n->udr->udr == NULL)\n+\t\t\t    if (n->u2.udr->udr == NULL)\n \t\t\t      {\n-\t\t\t\tfree (n->udr);\n-\t\t\t\tn->udr = NULL;\n+\t\t\t\tfree (n->u2.udr);\n+\t\t\t\tn->u2.udr = NULL;\n \t\t\t      }\n \t\t\t  }\n-\t\t\tif (n->udr == NULL)\n+\t\t\tif (n->u2.udr == NULL)\n \t\t\t  {\n \t\t\t    if (udr_name == NULL)\n \t\t\t      switch (n->u.reduction_op)\n@@ -5730,14 +5952,14 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t\t  }\n \t\t\telse\n \t\t\t  {\n-\t\t\t    gfc_omp_udr *udr = n->udr->udr;\n+\t\t\t    gfc_omp_udr *udr = n->u2.udr->udr;\n \t\t\t    n->u.reduction_op = OMP_REDUCTION_USER;\n-\t\t\t    n->udr->combiner\n+\t\t\t    n->u2.udr->combiner\n \t\t\t      = resolve_omp_udr_clause (n, udr->combiner_ns,\n \t\t\t\t\t\t\tudr->omp_out,\n \t\t\t\t\t\t\tudr->omp_in);\n \t\t\t    if (udr->initializer_ns)\n-\t\t\t      n->udr->initializer\n+\t\t\t      n->u2.udr->initializer\n \t\t\t\t= resolve_omp_udr_clause (n,\n \t\t\t\t\t\t\t  udr->initializer_ns,\n \t\t\t\t\t\t\t  udr->omp_priv,\n@@ -7369,6 +7591,7 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns)\n     case EXEC_OMP_TARGET_PARALLEL:\n     case EXEC_OMP_TARGET_TEAMS:\n     case EXEC_OMP_TASK:\n+    case EXEC_OMP_TASKWAIT:\n     case EXEC_OMP_TEAMS:\n     case EXEC_OMP_WORKSHARE:\n     case EXEC_OMP_DEPOBJ:"}, {"sha": "7d0e2c147319be353384ae4e56d36af1baa4b8c0", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -268,7 +268,7 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_OMP_FLUSH:\n-      gfc_free_omp_namelist (p->ext.omp_namelist);\n+      gfc_free_omp_namelist (p->ext.omp_namelist, false);\n       break;\n \n     case EXEC_OMP_BARRIER:"}, {"sha": "7ea7aa37efd75aca9dfbcaeebd8c896f41355216", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 159, "deletions": 39, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"trans-array.h\"\n #include \"trans-const.h\"\n #include \"arith.h\"\n+#include \"constructor.h\"\n #include \"gomp-constants.h\"\n #include \"omp-general.h\"\n #include \"omp-low.h\"\n@@ -1910,7 +1911,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   locus old_loc = gfc_current_locus;\n   const char *iname;\n   bool t;\n-  gfc_omp_udr *udr = n->udr ? n->udr->udr : NULL;\n+  gfc_omp_udr *udr = n->u2.udr ? n->u2.udr->udr : NULL;\n \n   decl = OMP_CLAUSE_DECL (c);\n   gfc_current_locus = where;\n@@ -2029,9 +2030,9 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       t = gfc_resolve_expr (e2);\n       gcc_assert (t);\n     }\n-  else if (n->udr->initializer->op == EXEC_ASSIGN)\n+  else if (n->u2.udr->initializer->op == EXEC_ASSIGN)\n     {\n-      e2 = gfc_copy_expr (n->udr->initializer->expr2);\n+      e2 = gfc_copy_expr (n->u2.udr->initializer->expr2);\n       t = gfc_resolve_expr (e2);\n       gcc_assert (t);\n     }\n@@ -2040,7 +2041,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       struct omp_udr_find_orig_data cd;\n       cd.omp_udr = udr;\n       cd.omp_orig_seen = false;\n-      gfc_code_walker (&n->udr->initializer,\n+      gfc_code_walker (&n->u2.udr->initializer,\n \t\t       gfc_dummy_code_callback, omp_udr_find_orig, &cd);\n       if (cd.omp_orig_seen)\n \tOMP_CLAUSE_REDUCTION_OMP_ORIG_REF (c) = 1;\n@@ -2090,11 +2091,11 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n       iname = \"ieor\";\n       break;\n     case ERROR_MARK:\n-      if (n->udr->combiner->op == EXEC_ASSIGN)\n+      if (n->u2.udr->combiner->op == EXEC_ASSIGN)\n \t{\n \t  gfc_free_expr (e3);\n-\t  e3 = gfc_copy_expr (n->udr->combiner->expr1);\n-\t  e4 = gfc_copy_expr (n->udr->combiner->expr2);\n+\t  e3 = gfc_copy_expr (n->u2.udr->combiner->expr1);\n+\t  e4 = gfc_copy_expr (n->u2.udr->combiner->expr2);\n \t  t = gfc_resolve_expr (e3);\n \t  gcc_assert (t);\n \t  t = gfc_resolve_expr (e4);\n@@ -2144,7 +2145,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   if (e2)\n     stmt = gfc_trans_assignment (e1, e2, false, false);\n   else\n-    stmt = gfc_trans_call (n->udr->initializer, false,\n+    stmt = gfc_trans_call (n->u2.udr->initializer, false,\n \t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n@@ -2157,7 +2158,7 @@ gfc_trans_omp_array_reduction_or_udr (tree c, gfc_omp_namelist *n, locus where)\n   if (e4)\n     stmt = gfc_trans_assignment (e3, e4, false, true);\n   else\n-    stmt = gfc_trans_call (n->udr->combiner, false,\n+    stmt = gfc_trans_call (n->u2.udr->combiner, false,\n \t\t\t   NULL_TREE, NULL_TREE, false);\n   if (TREE_CODE (stmt) != BIND_EXPR)\n     stmt = build3_v (BIND_EXPR, NULL, stmt, poplevel (1, 0));\n@@ -2432,14 +2433,77 @@ gfc_trans_omp_array_section (stmtblock_t *block, gfc_omp_namelist *n,\n \t\t\t\t\t ptr, ptr2);\n }\n \n+static tree\n+handle_iterator (gfc_namespace *ns, stmtblock_t *iter_block, tree block)\n+{\n+  tree list = NULL_TREE;\n+  for (gfc_symbol *sym = ns->proc_name; sym; sym = sym->tlink)\n+    {\n+      gfc_constructor *c;\n+      gfc_se se;\n+\n+      tree last = make_tree_vec (6);\n+      tree iter_var = gfc_get_symbol_decl (sym);\n+      tree type = TREE_TYPE (iter_var);\n+      TREE_VEC_ELT (last, 0) = iter_var;\n+      DECL_CHAIN (iter_var) = BLOCK_VARS (block);\n+      BLOCK_VARS (block) = iter_var;\n+\n+      /* begin */\n+      c = gfc_constructor_first (sym->value->value.constructor);\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, c->expr);\n+      gfc_add_block_to_block (iter_block, &se.pre);\n+      gfc_add_block_to_block (iter_block, &se.post);\n+      TREE_VEC_ELT (last, 1) = fold_convert (type,\n+\t\t\t\t\t     gfc_evaluate_now (se.expr,\n+\t\t\t\t\t\t\t       iter_block));\n+      /* end */\n+      c = gfc_constructor_next (c);\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr (&se, c->expr);\n+      gfc_add_block_to_block (iter_block, &se.pre);\n+      gfc_add_block_to_block (iter_block, &se.post);\n+      TREE_VEC_ELT (last, 2) = fold_convert (type,\n+\t\t\t\t\t     gfc_evaluate_now (se.expr,\n+\t\t\t\t\t\t\t       iter_block));\n+      /* step */\n+      c = gfc_constructor_next (c);\n+      tree step;\n+      if (c)\n+\t{\n+\t  gfc_init_se (&se, NULL);\n+\t  gfc_conv_expr (&se, c->expr);\n+\t  gfc_add_block_to_block (iter_block, &se.pre);\n+\t  gfc_add_block_to_block (iter_block, &se.post);\n+\t  gfc_conv_expr (&se, c->expr);\n+\t  step = fold_convert (type,\n+\t\t\t       gfc_evaluate_now (se.expr,\n+\t\t\t\t\t\t iter_block));\n+\t}\n+      else\n+\tstep = build_int_cst (type, 1);\n+      TREE_VEC_ELT (last, 3) = step;\n+      /* orig_step */\n+      TREE_VEC_ELT (last, 4) = save_expr (step);\n+      TREE_CHAIN (last) = list;\n+      list = last;\n+    }\n+  return list;\n+}\n+\n static tree\n gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t       locus where, bool declare_simd = false,\n \t\t       bool openacc = false)\n {\n-  tree omp_clauses = NULL_TREE, chunk_size, c;\n+  tree omp_clauses = NULL_TREE, prev_clauses, chunk_size, c;\n+  tree iterator = NULL_TREE;\n+  tree tree_block = NULL_TREE;\n+  stmtblock_t iter_block;\n   int list, ifc;\n   enum omp_clause_code clause_code;\n+  gfc_omp_namelist *prev = NULL;\n   gfc_se se;\n \n   if (clauses == NULL)\n@@ -2642,10 +2706,38 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      }\n \t  }\n \t  break;\n+\tcase OMP_LIST_AFFINITY:\n \tcase OMP_LIST_DEPEND:\n+\t  iterator = NULL_TREE;\n+\t  prev = NULL;\n+\t  prev_clauses = omp_clauses;\n \t  for (; n != NULL; n = n->next)\n \t    {\n-\t      if (n->u.depend_op == OMP_DEPEND_SINK_FIRST)\n+\t      if (iterator && prev->u2.ns != n->u2.ns)\n+\t\t{ \n+\t\t  BLOCK_SUBBLOCKS (tree_block) = gfc_finish_block (&iter_block);\n+\t\t  TREE_VEC_ELT (iterator, 5) = tree_block;\n+\t\t  for (tree c = omp_clauses; c != prev_clauses;\n+\t\t       c = OMP_CLAUSE_CHAIN (c))\n+\t\t    OMP_CLAUSE_DECL (c) = build_tree_list (iterator,\n+\t\t\t\t\t\t\t   OMP_CLAUSE_DECL (c));\n+\t\t  prev_clauses = omp_clauses;\n+\t\t  iterator = NULL_TREE;\n+\t\t}\n+\t      if (n->u2.ns && (!prev || prev->u2.ns != n->u2.ns))\n+\t\t{\n+\t\t  gfc_init_block (&iter_block);\n+\t\t  tree_block = make_node (BLOCK);\n+\t\t  TREE_USED (tree_block) = 1;\n+\t\t  BLOCK_VARS (tree_block) = NULL_TREE;\n+\t\t  iterator = handle_iterator (n->u2.ns, block,\n+\t\t\t\t\t      tree_block);\n+\t\t}\n+\t      if (!iterator)\n+\t\tgfc_init_block (&iter_block);\n+\t      prev = n;\n+\t      if (list == OMP_LIST_DEPEND\n+\t\t  && n->u.depend_op == OMP_DEPEND_SINK_FIRST)\n \t\t{\n \t\t  tree vec = NULL_TREE;\n \t\t  unsigned int i;\n@@ -2699,7 +2791,10 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t      if (!n->sym->attr.referenced)\n \t\tcontinue;\n \n-\t      tree node = build_omp_clause (input_location, OMP_CLAUSE_DEPEND);\n+\t      tree node = build_omp_clause (input_location,\n+\t\t\t\t\t    list == OMP_LIST_DEPEND\n+\t\t\t\t\t    ? OMP_CLAUSE_DEPEND\n+\t\t\t\t\t    : OMP_CLAUSE_AFFINITY);\n \t      if (n->expr == NULL || n->expr->ref->u.ar.type == AR_FULL)\n \t\t{\n \t\t  tree decl = gfc_trans_omp_variable (n->sym, false);\n@@ -2733,35 +2828,47 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t      gfc_conv_expr_descriptor (&se, n->expr);\n \t\t      ptr = gfc_conv_array_data (se.expr);\n \t\t    }\n-\t\t  gfc_add_block_to_block (block, &se.pre);\n-\t\t  gfc_add_block_to_block (block, &se.post);\n+\t\t  gfc_add_block_to_block (&iter_block, &se.pre);\n+\t\t  gfc_add_block_to_block (&iter_block, &se.post);\n \t\t  ptr = fold_convert (build_pointer_type (char_type_node),\n \t\t\t\t      ptr);\n \t\t  OMP_CLAUSE_DECL (node) = build_fold_indirect_ref (ptr);\n \t\t}\n-\t      switch (n->u.depend_op)\n-\t\t{\n-\t\tcase OMP_DEPEND_IN:\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_IN;\n-\t\t  break;\n-\t\tcase OMP_DEPEND_OUT:\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_OUT;\n-\t\t  break;\n-\t\tcase OMP_DEPEND_INOUT:\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_INOUT;\n-\t\t  break;\n-\t\tcase OMP_DEPEND_MUTEXINOUTSET:\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node)\n-\t\t    = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n-\t\t  break;\n-\t\tcase OMP_DEPEND_DEPOBJ:\n-\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_DEPOBJ;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n-\t\t}\n+\t      if (list == OMP_LIST_DEPEND)\n+\t\tswitch (n->u.depend_op)\n+\t\t  {\n+\t\t  case OMP_DEPEND_IN:\n+\t\t    OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_IN;\n+\t\t    break;\n+\t\t  case OMP_DEPEND_OUT:\n+\t\t    OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_OUT;\n+\t\t    break;\n+\t\t  case OMP_DEPEND_INOUT:\n+\t\t    OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_INOUT;\n+\t\t    break;\n+\t\t  case OMP_DEPEND_MUTEXINOUTSET:\n+\t\t    OMP_CLAUSE_DEPEND_KIND (node)\n+\t\t      = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n+\t\t    break;\n+\t\t  case OMP_DEPEND_DEPOBJ:\n+\t\t    OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_DEPOBJ;\n+\t\t    break;\n+\t\t  default:\n+\t\t    gcc_unreachable ();\n+\t\t  }\n+\t      if (!iterator)\n+\t\tgfc_add_block_to_block (block, &iter_block);\n \t      omp_clauses = gfc_trans_add_clause (node, omp_clauses);\n \t    }\n+\t  if (iterator)\n+\t    { \n+\t      BLOCK_SUBBLOCKS (tree_block) = gfc_finish_block (&iter_block);\n+\t      TREE_VEC_ELT (iterator, 5) = tree_block;\n+\t      for (tree c = omp_clauses; c != prev_clauses;\n+\t\t   c = OMP_CLAUSE_CHAIN (c))\n+\t\tOMP_CLAUSE_DECL (c) = build_tree_list (iterator,\n+\t\t\t\t\t\t       OMP_CLAUSE_DECL (c));\n+\t    }\n \t  break;\n \tcase OMP_LIST_MAP:\n \t  for (; n != NULL; n = n->next)\n@@ -5857,10 +5964,23 @@ gfc_trans_omp_taskgroup (gfc_code *code)\n }\n \n static tree\n-gfc_trans_omp_taskwait (void)\n+gfc_trans_omp_taskwait (gfc_code *code)\n {\n-  tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n-  return build_call_expr_loc (input_location, decl, 0);\n+  if (!code->ext.omp_clauses)\n+    {\n+      tree decl = builtin_decl_explicit (BUILT_IN_GOMP_TASKWAIT);\n+      return build_call_expr_loc (input_location, decl, 0);\n+    }\n+  stmtblock_t block;\n+  gfc_start_block (&block);\n+  tree stmt = make_node (OMP_TASK);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TASK_BODY (stmt) = NULL_TREE;\n+  OMP_TASK_CLAUSES (stmt) = gfc_trans_omp_clauses (&block,\n+\t\t\t\t\t\t   code->ext.omp_clauses,\n+\t\t\t\t\t\t   code->loc);\n+  gfc_add_expr_to_block (&block, stmt);\n+  return gfc_finish_block (&block);\n }\n \n static tree\n@@ -6492,7 +6612,7 @@ gfc_trans_omp_directive (gfc_code *code)\n     case EXEC_OMP_TASKLOOP_SIMD:\n       return gfc_trans_omp_taskloop (code);\n     case EXEC_OMP_TASKWAIT:\n-      return gfc_trans_omp_taskwait ();\n+      return gfc_trans_omp_taskwait (code);\n     case EXEC_OMP_TASKYIELD:\n       return gfc_trans_omp_taskyield ();\n     case EXEC_OMP_TEAMS:"}, {"sha": "d60fc95db0100e96a274ab78b17968022b1a18b8", "filename": "gcc/gimplify.c", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -7841,6 +7841,131 @@ find_decl_expr (tree *tp, int *walk_subtrees, void *data)\n   return NULL_TREE;\n }\n \n+\n+/* Gimplify the affinity clause but effectively ignore it.\n+   Generate:\n+     var = begin;\n+     if ((step > 1) ? var <= end : var > end)\n+       locatator_var_expr;  */\n+\n+static void\n+gimplify_omp_affinity (tree *list_p, gimple_seq *pre_p)\n+{\n+  tree last_iter = NULL_TREE;\n+  tree last_bind = NULL_TREE;\n+  tree label = NULL_TREE;\n+  tree *last_body = NULL;\n+  for (tree c = *list_p; c; c = OMP_CLAUSE_CHAIN (c))\n+    if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY)\n+      {\n+\ttree t = OMP_CLAUSE_DECL (c);\n+\tif (TREE_CODE (t) == TREE_LIST\n+\t\t    && TREE_PURPOSE (t)\n+\t\t    && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t  {\n+\t    if (TREE_VALUE (t) == null_pointer_node)\n+\t      continue;\n+\t    if (TREE_PURPOSE (t) != last_iter)\n+\t      {\n+\t\tif (last_bind)\n+\t\t  {\n+\t\t    append_to_statement_list (label, last_body);\n+\t\t    gimplify_and_add (last_bind, pre_p);\n+\t\t    last_bind = NULL_TREE;\n+\t\t  }\n+\t\tfor (tree it = TREE_PURPOSE (t); it; it = TREE_CHAIN (it))\n+\t\t  {\n+\t\t    if (gimplify_expr (&TREE_VEC_ELT (it, 1), pre_p, NULL,\n+\t\t\t\t       is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| gimplify_expr (&TREE_VEC_ELT (it, 2), pre_p, NULL,\n+\t\t\t\t\t  is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| gimplify_expr (&TREE_VEC_ELT (it, 3), pre_p, NULL,\n+\t\t\t\t\t  is_gimple_val, fb_rvalue) == GS_ERROR\n+\t\t\t|| (gimplify_expr (&TREE_VEC_ELT (it, 4), pre_p, NULL,\n+\t\t\t\t\t   is_gimple_val, fb_rvalue)\n+\t\t\t    == GS_ERROR))\n+\t\t      return;\n+\t\t  }\n+\t    last_iter = TREE_PURPOSE (t);\n+\t    tree block = TREE_VEC_ELT (TREE_PURPOSE (t), 5);\n+\t    last_bind = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (block),\n+\t\t\t\tNULL, block);\n+\t    last_body = &BIND_EXPR_BODY (last_bind);\n+\t    tree cond = NULL_TREE;\n+\t    location_t loc = OMP_CLAUSE_LOCATION (c);\n+\t    for (tree it = TREE_PURPOSE (t); it; it = TREE_CHAIN (it))\n+\t      {\n+\t\ttree var = TREE_VEC_ELT (it, 0);\n+\t\ttree begin = TREE_VEC_ELT (it, 1);\n+\t\ttree end = TREE_VEC_ELT (it, 2);\n+\t\ttree step = TREE_VEC_ELT (it, 3);\n+\t\tloc = DECL_SOURCE_LOCATION (var);\n+\t\ttree tem = build2_loc (loc, MODIFY_EXPR, void_type_node,\n+\t\t\t\t       var, begin);\n+\t\tappend_to_statement_list_force (tem, last_body);\n+\n+\t\ttree cond1 = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t\t       step, build_zero_cst (TREE_TYPE (step)));\n+\t\ttree cond2 = fold_build2_loc (loc, LE_EXPR, boolean_type_node,\n+\t\t\t\t\t      var, end);\n+\t\ttree cond3 = fold_build2_loc (loc, GT_EXPR, boolean_type_node,\n+\t\t\t\t\t      var, end);\n+\t\tcond1 = fold_build3_loc (loc, COND_EXPR, boolean_type_node,\n+\t\t\t\t\t cond1, cond2, cond3);\n+\t\tif (cond)\n+\t\t  cond = fold_build2_loc (loc, TRUTH_AND_EXPR,\n+\t\t\t\t\t  boolean_type_node, cond, cond1);\n+\t\telse\n+\t\t  cond = cond1;\n+\t      }\n+\t    tree cont_label = create_artificial_label (loc);\n+\t    label = build1 (LABEL_EXPR, void_type_node, cont_label);\n+\t    tree tem = fold_build3_loc (loc, COND_EXPR, void_type_node, cond,\n+\t\t\t\t\tvoid_node,\n+\t\t\t\t\tbuild_and_jump (&cont_label));\n+\t    append_to_statement_list_force (tem, last_body);\n+\t      }\n+\t    if (TREE_CODE (TREE_VALUE (t)) == COMPOUND_EXPR)\n+\t      {\n+\t\tappend_to_statement_list (TREE_OPERAND (TREE_VALUE (t), 0),\n+\t\t\t\t\t  last_body);\n+\t\tTREE_VALUE (t) = TREE_OPERAND (TREE_VALUE (t), 1);\n+\t      }\n+\t    if (error_operand_p (TREE_VALUE (t)))\n+\t      return;\n+\t    append_to_statement_list_force (TREE_VALUE (t), last_body);\n+\t    TREE_VALUE (t) = null_pointer_node;\n+\t  }\n+\telse\n+\t  {\n+\t    if (last_bind)\n+\t      {\n+\t\tappend_to_statement_list (label, last_body);\n+\t\tgimplify_and_add (last_bind, pre_p);\n+\t\tlast_bind = NULL_TREE;\n+\t      }\n+\t    if (TREE_CODE (OMP_CLAUSE_DECL (c)) == COMPOUND_EXPR)\n+\t      {\n+\t\tgimplify_expr (&TREE_OPERAND (OMP_CLAUSE_DECL (c), 0), pre_p,\n+\t\t\t       NULL, is_gimple_val, fb_rvalue);\n+\t\tOMP_CLAUSE_DECL (c) = TREE_OPERAND (OMP_CLAUSE_DECL (c), 1);\n+\t      }\n+\t    if (error_operand_p (OMP_CLAUSE_DECL (c)))\n+\t      return;\n+\t    if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n+\t\t\t       is_gimple_val, fb_rvalue) == GS_ERROR)\n+\t      return;\n+\t    gimplify_and_add (OMP_CLAUSE_DECL (c), pre_p);\n+\t  }\n+      }\n+  if (last_bind)\n+    {\n+      append_to_statement_list (label, last_body);\n+      gimplify_and_add (last_bind, pre_p);\n+    }\n+  return;\n+}\n+\n /* If *LIST_P contains any OpenMP depend clauses with iterators,\n    lower all the depend clauses by populating corresponding depend\n    array.  Returns 0 if there are no such depend clauses, or\n@@ -9527,6 +9652,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \n \t  goto do_add;\n \n+\tcase OMP_CLAUSE_AFFINITY:\n+\t  gimplify_omp_affinity (list_p, pre_p);\n+\t  remove = true;\n+\t  break;\n \tcase OMP_CLAUSE_DEPEND:\n \t  if (OMP_CLAUSE_DEPEND_KIND (c) == OMP_CLAUSE_DEPEND_SINK)\n \t    {"}, {"sha": "4af52f4e944ace33233bf335f0671b5c52ed9b9d", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-1.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,24 @@\n+void\n+foo(int x)\n+{ \n+  int a = 1;\n+  int b[5] = {1, 0, 1, 1, 0};\n+  int cc = 7;\n+  int d[5][5] = {{1, 2, 3, 4, 5},  {6, 7, 8, 9, 10},  {1, 2, 3, 4, 5},\n+\t\t {6, 7, 8, 9, 10}, {-1, -2, -3, -4,-5}};\n+#pragma omp taskgroup\n+ {\n+  #pragma omp task affinity(a)\n+    ;\n+  #pragma omp task affinity(iterator(i=(int)__builtin_cos(1.0+a):5, jj =2:5:2) : b[i], d[i][jj])\n+    ;\n+  #pragma omp task affinity(iterator(i=(int)__builtin_cos(1.0+a):5) : b[i], d[i][i])\n+    ;\n+  #pragma omp task affinity (iterator(i=1:5): a)\n+    ;\n+  #pragma omp task affinity (iterator(i=1:5): a) affinity(iterator(i=1:5) : x)\n+    ;\n+  #pragma omp task affinity (iterator(unsigned long j=1:5, k=7:4:-1) : b[j+k],a) affinity (cc)\n+    ;\n+ }\n+}"}, {"sha": "7f3029605be0fa2d1422a8790fe6b3eecc1aaf33", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-2.c", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-2.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,232 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp\" } */\n+\n+extern int a[][10], a2[][10];\n+int b[10], c[10][2], d[10], e[10], f[10];\n+int b2[10], c2[10][2], d2[10], e2[10], f2[10];\n+int k[10], l[10], m[10], n[10], o;\n+int *p;\n+void bar (void);\n+int t[10];\n+#pragma omp threadprivate (t)\n+\n+void\n+foo (int g[3][10], int h[4][8], int i[2][10], int j[][9],\n+     int g2[3][10], int h2[4][8], int i2[2][10], int j2[][9])\n+{\n+  #pragma omp task affinity( bar[2:5]) /* { dg-error \"is not a variable\" } */\n+    ;\n+  #pragma omp task affinity( t[2:5])\n+    ;\n+  #pragma omp task affinity( k[0.5:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task affinity( l[:7.5f]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task affinity( m[p:]) /* { dg-error \"low bound \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task affinity( n[:p]) /* { dg-error \"length \\[^\\n\\r]* of array section does not have integral type\" } */\n+    ;\n+  #pragma omp task affinity( o[2:5]) /* { dg-error \"does not have pointer or array type\" } */\n+    ;\n+  #pragma omp task affinity( a[:][2:4]) /* { dg-error \"array type length expression must be specified\" } */\n+    ;\n+  #pragma omp task affinity( b[-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    ;\n+  #pragma omp task affinity( c[:-3][1:1]) /* { dg-error \"negative length in array section\" } */\n+    ;\n+  #pragma omp task affinity( d[11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( e[:11]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( f[1:10]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( g[:][2:4]) /* { dg-error \"for array function parameter length expression must be specified\" } */\n+    ;\n+  #pragma omp task affinity( h[2:2][-1:]) /* { dg-error \"negative low bound in array section\" } */\n+    ;\n+  #pragma omp task affinity( h[:1][:-3]) /* { dg-error \"negative length in array section\" } */\n+    ;\n+  #pragma omp task affinity( i[:1][11:]) /* { dg-error \"low bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( j[3:4][:10]) /* { dg-error \"length \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( j[30:10][5:5]) /* { dg-error \"high bound \\[^\\n\\r]* above array section size\" } */\n+    ;\n+  #pragma omp task affinity( a2[:3][2:4])\n+    ;\n+  #pragma omp task affinity( b2[0:])\n+    ;\n+  #pragma omp task affinity( c2[:3][1:1])\n+    ;\n+  #pragma omp task affinity( d2[9:])\n+    ;\n+  #pragma omp task affinity( e2[:10])\n+    ;\n+  #pragma omp task affinity( f2[1:9])\n+    ;\n+  #pragma omp task affinity( g2[:2][2:4])\n+    ;\n+  #pragma omp task affinity( h2[2:2][0:])\n+    ;\n+  #pragma omp task affinity( h2[:1][:3])\n+    ;\n+  #pragma omp task affinity( i2[:1][9:])\n+    ;\n+  #pragma omp task affinity( j2[3:4][:9])\n+    ;\n+  #pragma omp task affinity( j2[30:10][5:4])\n+    ;\n+}\n+\n+void bar2 (int a[10][10][10]);\n+\n+void\n+foo2 (int a[10][10][10], int **b)\n+{\n+  int c[10][10][10];\n+  #pragma omp task affinity( a[2:4][3:][:7], b[1:7][2:8])\n+    bar2 (a);\n+  int i = 1, j = 3, k = 2, l = 6;\n+  #pragma omp task affinity( a[++i:++j][++k:][:++l])\n+    bar2 (a);\n+  #pragma omp task affinity( a[7:2][:][:], c[5:2][:][:])\n+  {\n+    bar2 (c);\n+    bar2 (a);\n+  }\n+}\n+\n+void\n+foo3 (int a[10][10][10], int **b, int x)\n+{\n+  int c[10][10][10];\n+  #pragma omp task affinity( a[2:4][3:0][:7])\t/* { dg-error \"zero length array section\" } */\n+    bar2 (a);\n+  #pragma omp task affinity( b[:7][0:0][:0]) /* { dg-error \"zero length array section\" } */\n+    bar2 (a);\n+  #pragma omp task affinity( c[:][:][10:])\t/* { dg-error \"zero length array section\" } */\n+    bar2 (c);\n+  #pragma omp task affinity( a[2:4][3:0][:x])\t/* { dg-error \"zero length array section\" } */\n+    bar2 (a);\n+  #pragma omp task affinity( b[:x][0:0][:0]) /* { dg-error \"zero length array section\" } */\n+    bar2 (a);\n+  #pragma omp task affinity( c[:][x-2:x][10:])\t/* { dg-error \"zero length array section\" } */\n+    bar2 (c);\n+}\n+\n+void\n+foo4 (int *p, int (*q)[10], int r[10], int s[10][10])\n+{\n+  int a[10], b[10][10];\n+  #pragma omp task affinity ( p[-1:2])\n+  ;\n+  #pragma omp task affinity ( q[-1:2][2:4])\n+  ;\n+  #pragma omp task affinity ( q[-1:2][-2:4]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( r[-1:2])\n+  ;\n+  #pragma omp task affinity ( s[-1:2][2:4])\n+  ;\n+  #pragma omp task affinity ( s[-1:2][-2:4]) /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( a[-1:2])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( b[-1:2][2:4])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( b[1:2][-2:4])\t /* { dg-error \"negative low bound in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( p[2:-3])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( q[2:-3][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( q[2:3][0:-1])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( r[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( s[2:-5][:])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( s[2:5][0:-4])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( a[2:-5])\t /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( b[2:-5][0:10]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+  #pragma omp task affinity ( b[2:5][0:-4]) /* { dg-error \"negative length in array section in\" } */\n+  ;\n+}\n+\n+struct T { int c[3]; };\n+struct S { int a; struct T *b; struct T g; };\n+struct S sd[10];\n+struct S *se[10];\n+struct S *sf;\n+struct S sh;\n+struct U { int a : 5; };\n+struct U si;\n+\n+\n+void\n+foo5 (void)\n+{\n+  #pragma omp task affinity( sd)\n+  ;\n+  #pragma omp task affinity( sd[2])\n+  ;\n+  #pragma omp task affinity( sd[:])\n+  ;\n+  #pragma omp task affinity( sd[2:2])\n+  ;\n+  #pragma omp task affinity( sd[:2])\n+  ;\n+  #pragma omp task affinity( sd[1].b->c[2])\n+  ;\n+  #pragma omp task affinity( sd[0].a)\n+  ;\n+  #pragma omp task affinity( se[3]->a)\n+  ;\n+  #pragma omp task affinity( se[2]->b->c)\n+  ;\n+  #pragma omp task affinity( se[1]->b->c[2])\n+  ;\n+  #pragma omp task affinity( (*sf).a)\n+  ;\n+  #pragma omp task affinity( sf->b->c[0])\n+  ;\n+  #pragma omp task affinity( sf)\n+  ;\n+  #pragma omp task affinity( *sf)\n+  ;\n+  #pragma omp task affinity( sf[0])\n+  ;\n+  #pragma omp task affinity( sf[0].a)\n+  ;\n+  #pragma omp task affinity( sh.g.c[2])\n+  ;\n+}\n+\n+void\n+foo6 (void)\n+{\n+  #pragma omp task affinity( sd[:2].b->c[2])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( sd[1:].b->c[2])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( sd[0:1].a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( se[3:2]->a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( se[2:2]->b->c)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( se[1]->b->c[2:1])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( sf + 0)\t\t/* { dg-error \"'sf' is not lvalue expression nor array section in 'affinity' clause\" } */\n+  ;\n+  #pragma omp task affinity( sf[0:1].a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( sh.g.c[2:1])\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity( si.a)\t\t/* { dg-error \"bit-field 'si\\\\..*a' in 'affinity' clause\" } */\n+  ;\n+}\n+/* { dg-additional-options \"-Wno-volatile\" { target c++ } } */"}, {"sha": "1a476543048996726b0253c3b63945d3b86f7788", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-3.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-3.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-additional-options \"-Wno-volatile\" { target c++ } } */\n+\n+int arr[64], arr2[64];\n+struct S { int a[4]; } k;\n+short arr4[4];\n+volatile int v;\n+#define TEST_EQ(x,y) ({ int o[x == y ? 1 : -1]; 0; })\n+\n+void\n+foo (unsigned char i, signed char j)\n+{\n+  #pragma omp task affinity (iterator (j=6:2:-2) : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\taffinity(arr[0]) \\\n+\taffinity (iterator (long long i=__LONG_LONG_MAX__ - 4:__LONG_LONG_MAX__ - 2:2, \\\n+\t\t\t  unsigned short j=~0U-16:~0U-8:3, \\\n+\t\t\t  short *k=&arr4[1]:&arr4[2]:1) : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]]) \\\n+\taffinity( k)\n+    v++;\n+}\n+\n+void\n+bar (unsigned char i, signed char j)\n+{\n+  int m = j;\n+  int n = j + 2;\n+  #pragma omp task affinity (iterator (j=6:2:m) : \\\n+\tarr[TEST_EQ (sizeof (j), sizeof (int)), \\\n+\t    TEST_EQ (sizeof (i), sizeof (unsigned char)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (struct S)), j], \\\n+\tarr2[TEST_EQ (((__typeof (j)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (i)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (k.a[0])) -1) < 0, 1), j]) \\\n+\taffinity( arr[0]) \\\n+\taffinity (iterator (long long i=__LONG_LONG_MAX__ - 4 - n:__LONG_LONG_MAX__ - 2:2, \\\n+\t\t\t  unsigned short j=~0U-16:~0U-8-n:3, \\\n+\t\t\t  short *k=&arr4[1]:&arr4[n + 2]:1) : \\\n+\tarr[TEST_EQ (sizeof (i), sizeof (long long)), \\\n+\t    TEST_EQ (sizeof (j), sizeof (unsigned short)), \\\n+\t    TEST_EQ (sizeof (k), sizeof (short *)), \\\n+\t    TEST_EQ (sizeof (*k), sizeof (short)), i - __LONG_LONG_MAX__ + 4], \\\n+\tarr2[TEST_EQ (((__typeof (i)) -1) < 0, 1), \\\n+\t     TEST_EQ (((__typeof (j)) -1) < 0, 0), \\\n+\t     TEST_EQ (((__typeof (*k)) -1) < 0, 1), j - (~0U-16)], \\\n+\tarr2[k - &arr4[0]:10]) \\\n+\taffinity( k)\n+    v++;\n+}\n+\n+void\n+baz (void)\n+{\n+  #pragma omp parallel\n+  #pragma omp master\n+  {\n+    #pragma omp task affinity(iterator(unsigned long int k = 0 : 2) : \\\n+\tarr[TEST_EQ (sizeof (k), sizeof (unsigned long)), \\\n+\t    TEST_EQ (((__typeof (k)) -1) < 0, 0), k]) \\\n+\taffinity(iterator(signed char s = -3 : -12 : -1) : \\\n+\tarr[TEST_EQ (sizeof (s), sizeof (signed char)), \\\n+\t    TEST_EQ (((__typeof (s)) -1) < 0, 1), s + 12])\n+      v++;\n+  }\n+}"}, {"sha": "dee3ed97783941ce9f1ae03b11f1ca3d8f1e01bb", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-4.c", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-4.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,103 @@\n+int a, b[64];\n+struct S { int c; } *d, *e;\n+struct T;\n+struct T *f, *g;\n+int *h;\n+\n+void\n+f1 (void)\n+{\n+  #pragma omp task affinity (iterator : a)\n+  ;\n+  /* { dg-error \"'iterator' undeclared \" \"\" { target c } .-2 } */\n+  /* { dg-error \"found ':' in nested-name-specifier, expected '::'\" \"\" { target c++ } .-3 } */\n+  /* { dg-error \"'iterator' has not been declared\" \"\" { target c++ } .-4 } */\n+}\n+\n+void\n+f2 (void)\n+{\n+  #pragma omp task affinity (iterator (for = 0 : 2) : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (5 = 0 : 2) : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i : 0 : 2) : a)\t/* { dg-error \"expected '='|name a type|expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0, 1 : 2) : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = (0, 1) : 2) : a)\n+  ;\n+  #pragma omp task affinity (iterator (i = 0 : 1 : 2 : 3) : a)\t/* { dg-error \"expected '.'\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0 : 2, 3) : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0 : 10 : 2, 3) : a)\t/* { dg-error \"expected\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0:1), iterator (j = 0:1) : a)\n+  ;\n+  /* { dg-error \"'iterator' undeclared \" \"\" { target c } .-2 } */\n+  /* { dg-error \"'i' was not declared in this scope\" \"\" { target c++ } .-3 } */\n+  /* { dg-error \"'iterator' was not declared in this scope\" \"\" { target c++ } .-4 } */\n+  /* { dg-error \"'j' was not declared in this scope\" \"\" { target c++ } .-5 } */\n+  /* { dg-error \"expected '\\\\)' before ':' token\" \"\" { target c++ } .-6 } */\n+}\n+\n+void\n+f3 (void)\n+{\n+  #pragma omp task affinity (iterator (i = 0:32) : b[i*2:2])\n+  ;\n+  #pragma omp task affinity (iterator (struct S i = 0:1) : a)\t\t/* { dg-error \"iterator 'i' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task affinity (iterator (void i = 0:1) : a)\t\t/* { dg-error \"iterator 'i' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task affinity (iterator (float f = 0.2:0.4) : a)\t/* { dg-error \"iterator 'f' has neither integral nor pointer type\" } */\n+  ;\n+  #pragma omp task affinity (iterator (struct S *p = d:e:2) : a)\n+  ;\n+  #pragma omp task affinity (iterator (struct T *p = f:g) , a)\n+  ;\n+  /* { dg-error \"'iterator' undeclared \" \"\" { target c } .-2 } */\n+  /* { dg-error \"expected primary-expression before 'struct'\" \"\" { target c++ } .-3 } */\n+  /* { dg-error \"'iterator' was not declared in this scope\" \"\" { target c++ } .-4 } */\n+}\n+\n+void\n+f4 (void)\n+{\n+  #pragma omp task affinity (iterator (int i = 0:4, \\\n+\t\t\t\t     struct U { int (*p)[i + 2]; } *p = 0:2) : a)\t/* { dg-error \"type of iterator 'p' refers to outer iterator 'i'\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t\t/* { dg-error \"types may not be defined in iterator type|not an integral constant\" \"\" { target c++ } .-1 } */\n+  #pragma omp task affinity (iterator (i = 0:4, j = i:16) : a)\t/* { dg-error \"begin expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0:4, j = 2:i:1) : a)\t/* { dg-error \"end expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 0:4, j = 2:8:i) : a)\t/* { dg-error \"step expression refers to outer iterator 'i'\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = *d:2)  : a)\t/* { dg-error \"aggregate value used where an integer was expected\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-error \"invalid cast from type 'S' to type 'int'\" \"\" { target c++ } .-1 } */\n+  #pragma omp task affinity (iterator (i = 2:*d:2) : a)\t/* { dg-error \"aggregate value used where an integer was expected\" \"\" { target c } } */\n+  ;\t\t\t\t\t\t\t\t/* { dg-error \"invalid cast from type 'S' to type 'int'\" \"\" { target c++ } .-1 } */\n+  #pragma omp task affinity (iterator (i = 2:4:*d) : a)\t/* { dg-error \"iterator step with non-integral type\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 1.25:2.5:3) : a)\n+  ;\n+  #pragma omp task affinity (iterator (i = 1:2:3.5) : a)\t/* { dg-error \"iterator step with non-integral type\" } */\n+  ;\n+  #pragma omp task affinity (iterator (int *p = 23 : h) : a)\n+  ;\n+  #pragma omp task affinity (iterator (short i=1:3:0) : a)\t/* { dg-error \"iterator 'i' has zero step\" } */\n+  ;\n+  #pragma omp task affinity (iterator (i = 1 : 3 : 3 - 3) : a)\t/* { dg-error \"iterator 'i' has zero step\" } */\n+  ;\n+  #pragma omp task affinity (iterator (int *p = &b[6]:&b[9]:4 - 4) : a)\t/* { dg-error \"iterator 'p' has zero step\" } */\n+  ;\n+  #pragma omp task affinity (iterator (const int i = 0 : 2) : a)\t/* { dg-error \"const qualified\" } */\n+  ;\n+  #pragma omp task affinity (iterator (const long long unsigned i = 0 : 2) : a)\t/* { dg-error \"const qualified\" } */\n+  ;\n+#if !defined (__cplusplus) && __STDC_VERSION__ >= 201112L\n+  #pragma omp task affinity (iterator (_Atomic unsigned i = 0 : 2) : a)\t/* { dg-error \"_Atomic\" \"\" { target c } } */\n+  ;\n+#endif\n+}"}, {"sha": "194286d5818870387c097a46c0f4a4b3c3d83194", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-5.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-5.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+int bar (int);\n+int bar2 (int);\n+\n+void foobar()\n+{\n+  int d[64], e[64], f[64];\n+#pragma omp task affinity (d, e[bar(5)], f[4:10])\n+  ;\n+}\n+\n+void\n+foo (void)\n+{\n+  int a[64];\n+#pragma omp task affinity (iterator (j=bar(0):bar(1):bar(2))  : a[bar(j)])\n+  ;\n+}\n+void\n+qux (void)\n+{\n+  int a[64], b[64], c[64];\n+#pragma omp task affinity (iterator (j=bar(0):bar(1):bar(2))  : a[bar(j+1)], b[bar(j+2)], c[bar(j+3)])\n+  ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(5\\\\);\" 1 \"gimple\" } }  */\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(0\\\\);\" 2 \"gimple\" } }  */\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(1\\\\);\" 2 \"gimple\" } }  */\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(2\\\\);\" 2 \"gimple\" } }  */\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(j\\\\);\" 1 \"gimple\" } }  */\n+/* { dg-final { scan-tree-dump-times \"= bar \\\\(_.\\\\);\" 3 \"gimple\" } }  */"}, {"sha": "0c9cd59cccff68dfd619361877f3d3bcaee66c23", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-6.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-6.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-additional-options \"-fdump-tree-gimple\" } */\n+int bar (int);\n+int bar2 (int);\n+\n+void foobar()\n+{\n+  int d[64], e[64], f[64];\n+#pragma omp parallel default(none)  /* { dg-note \"enclosing 'parallel'\" }  */\n+#pragma omp task affinity (d, e[bar(5)], f[4:10])\n+  ;\n+/* { dg-error \"'f' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-2 }  */\n+/* { dg-error \"'e' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-3 }  */\n+/* { dg-error \"'d' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-4 }  */\n+}\n+\n+void\n+foo (void)\n+{\n+  int a[64];\n+#pragma omp parallel default(none)  /* { dg-note \"enclosing 'parallel'\" }  */\n+#pragma omp task affinity (iterator (j=bar(0):bar(1):bar(2))  : a[bar(j)])\n+  ;\n+/* { dg-error \"'a' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-2 }  */\n+}\n+\n+void\n+qux (void)\n+{\n+  int a[64], b[64], c[64];\n+#pragma omp parallel default(none)  /* { dg-note \"enclosing 'parallel'\" }  */\n+#pragma omp task affinity (iterator (j=bar(0):bar(1):bar(2))  : a[bar(j+1)], b[bar(j+2)], c[bar(j+3)])\n+  ;\n+/* { dg-error \"'a' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-2 }  */\n+/* { dg-error \"'c' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-3 }  */\n+/* { dg-error \"'b' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-4 }  */\n+}"}, {"sha": "11684f521adf679ed254e4ff9d0c627103fbf4fa", "filename": "gcc/testsuite/c-c++-common/gomp/affinity-7.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Faffinity-7.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-additional-options \"-fdump-tree-original\" }  */\n+int var[20];\n+\n+int *\n+iterator(int i)\n+{\n+  return &var[i];\n+}\n+\n+void\n+foo (void)\n+{\n+  int iterator[10], i;\n+  #pragma omp task affinity(iterator(i=4:2) : iterator[i] )\n+   ;\n+  #pragma omp task affinity(iterator)\n+   ;\n+  #pragma omp task affinity(iterator[4:3])\n+   ;\n+}\n+\n+void\n+bar (void)\n+{\n+  int j = 3;\n+   ;\n+  #pragma omp task affinity(iterator(i=4:2) : iterator(i)[2] )\n+   ;\n+  #pragma omp task affinity(iterator(j)[4])\n+   ;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(int i=4:2:1\\\\):iterator\\\\\\[SAVE_EXPR <i>\\\\\\]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\\\[4\\\\\\]\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(int i=4:2:1\\\\):\\\\*\\\\(iterator \\\\(i\\\\) \\\\+ 8\\\\)\\\\)\" 1 \"original\" } } */\n+/* { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(\\\\*\\\\(iterator \\\\(j\\\\) \\\\+ 16\\\\)\\\\)\" 1 \"original\" } } */"}, {"sha": "13bdd36d0b4d37365d17da1021625c96235a276d", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-1.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-1.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,33 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+subroutine foo(x)\n+  integer :: x\n+  integer :: a, b(5), cc, d(5,5)\n+  !$omp taskgroup\n+    !$omp task affinity(a)\n+    !$omp end task\n+    !$omp task affinity(iterator(i=int(cos(1.0+a)):5, jj =2:5:2) : b(i), d(i,jj))\n+    !$omp end task\n+    !$omp task affinity(iterator(i=int(cos(1.0+a)):5) : b(i), d(i,i))\n+    !$omp end task\n+    !$omp task affinity (iterator(i=1:5): a)\n+    !$omp end task\n+    !$omp task affinity (iterator(i=1:5): a) affinity(iterator(i=1:5) : x)\n+    !$omp end task\n+    !$omp task affinity (iterator(integer(8) :: j=1:5, k=7:4:-1) : b(j+k),a) affinity (cc)\n+    !$omp end task\n+ !$omp end taskgroup\n+end\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(a\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"D\\\\.\\[0-9\\]+ = .integer.kind=4.. __builtin_cosf ..real.kind=4.. a \\\\+ 1.0e\\\\+0\\\\);\" 2 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) jj=2:5:2, integer\\\\(kind=4\\\\) i=D\\\\.\\[0-9\\]+:5:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &b\\\\\\[.* <?i>? \\\\+ -1\\\\\\]\\\\) affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) jj=2:5:2, integer\\\\(kind=4\\\\) i=D\\\\.\\[0-9\\]+:5:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &d\\\\\\[\\\\(.*jj \\\\* 5 \\\\+ .* <?i>?\\\\) \\\\+ -6\\\\\\]\\\\)\" 1 \"original\" } }\n+\n+! { dg final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=D.3938:5:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &b\\\\\\[\\\\(.* <?i>? \\\\+ -1\\\\\\]\\\\) affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=D\\\\.\\[0-9\\]+:5:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &d\\\\\\[\\\\(\\\\(integer\\\\(kind=8\\\\)\\\\) i \\\\+ -1\\\\) \\\\* 6\\\\\\]\\\\)\"  1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=1:5:1\\\\):a\\\\)\\[^ \\]\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=1:5:1\\\\):a\\\\) affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=1:5:1\\\\):\\\\*x\\\\)\"  1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) k=7:4:-1, integer\\\\(kind=8\\\\) j=1:5:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &b\\\\\\[\\\\(?\\\\(integer\\\\(kind=.\\\\).* \\[jk\\] \\\\+ .*\\[kj\\]\\\\) \\\\+ -1\\\\\\]\\\\) affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) k=7:4:-1, integer\\\\(kind=8\\\\) j=1:5:1\\\\):a\\\\) affinity\\\\(cc\\\\)\" 1 \"original\" } }"}, {"sha": "54768a8aeb28d1efe22f0ddade52a884698ee291", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-2.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-2.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,27 @@\n+subroutine foo\n+  implicit none\n+  external bar\n+  integer :: i, b(10)\n+  !$omp task affinity(bar(1)) ! { dg-error \"not a variable\" }\n+  !!$omp end task\n+  !$omp task affinity(b(1.0))  ! { dg-warning \"Legacy Extension: REAL array index\" }\n+  !$omp end task\n+  !$omp task affinity( iterator( real :: i=1.0:5:1) : b(i))  ! { dg-error \"Expected INTEGER type\" }\n+  !!$omp end task\n+  !$omp task affinity(iterator(i=1.0:5:1) : b(i))  ! { dg-error \"Scalar integer expression for range begin expected\" }\n+  !$omp end task\n+  !$omp task affinity(iterator(i=1:5.0:1) : b(i))  ! { dg-error \"Scalar integer expression for range end expected\" }\n+  !$omp end task\n+  !$omp task affinity(iterator(i=1:5:1.0) : b(i))  ! { dg-error \"Scalar integer expression for range step expected\" }\n+  !$omp end task\n+  !$omp task affinity(iterator(j=1:3:5, i=1:5:0) : b(i))  ! { dg-error \"Nonzero range step expected\" }\n+  !$omp end task\n+  !$omp task affinity(iterator(=1:5:0) : b(i))  ! { dg-error \"31:Syntax error in OpenMP variable list\" }\n+  !!$omp end task\n+  !$omp task affinity(iterator(b(2)=1:5:0) : b(i))  ! { dg-error \"31:Syntax error in OpenMP variable list\" }\n+  !!$omp end task\n+  !$omp task affinity(iterator(i=1:5:0, i=4:6) : b(i))  ! { dg-error \"Same identifier 'i' specified again\" }\n+  !!$omp end task\n+  !$omp task affinity(iterator(i=1) : b(i))  ! { dg-error \"Expected range-specification\" }\n+  !!$omp end task\n+end"}, {"sha": "3fd39fe6b8be363d74e318aa603ec8bddb8c9752", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-3.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-3.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,14 @@\n+! { dg-additional-options \"-fdump-tree-gimple\" }\n+subroutine foo\n+  integer :: A(10), B(10), C(10)\n+  interface\n+    integer function ibar(x)\n+      integer :: x\n+    end function ibar\n+  end interface\n+\n+  !$omp task affinity (iterator(j=ibar(0):ibar(1):ibar(2)) : a(ibar(j)), b(j), c(j))\n+  !$omp end task\n+end\n+! { dg-final { scan-tree-dump-times \"= ibar \\\\(&C\\\\.\" 3 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"= ibar \\\\(j\\\\.\" 1 \"gimple\" } }"}, {"sha": "0d07efd3f3012e756b206b48062728d67bb3bb56", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-4.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-4.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,16 @@\n+subroutine foo\n+  integer :: A(10), B(10), C(10)\n+  interface\n+    integer function ibar(x)\n+      integer :: x\n+    end function ibar\n+  end interface\n+\n+  !$omp parallel default(none)  ! { dg-note \"enclosing 'parallel'\" }\n+  !$omp task affinity (iterator(j=ibar(0):ibar(1):ibar(2)) : a(ibar(j)), b(j), c(j))\n+  !$omp end task\n+  !$omp end parallel\n+! { dg-error \"'a' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-3 }\n+! { dg-error \"'b' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-4 }\n+! { dg-error \"'c' not specified in enclosing 'parallel'\" \"\" { target *-*-* } .-5 }\n+end"}, {"sha": "538b5a54191fa81cbe878b707a7c123b562802d1", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-5.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-5.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,23 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+implicit none\n+integer :: iterator(10), i\n+\n+!$omp taskgroup\n+  !$omp task affinity(iterator)\n+  !$omp end task\n+\n+  !$omp task affinity(iterator(3))\n+  !$omp end task\n+\n+  !$omp task affinity(iterator(i=1:10) : iterator(i))\n+  !$omp end task\n+\n+!$omp end taskgroup\n+\n+end\n+\n+! { dg-final { scan-tree-dump-times \"pragma omp task affinity\\\\(iterator\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(\\\\*\\\\(c_char \\\\*\\\\) &iterator\\\\\\[2\\\\\\]\\\\)\" 1 \"original\" } }\n+\n+! { dg-final { scan-tree-dump-times \"#pragma omp task affinity\\\\(iterator\\\\(integer\\\\(kind=4\\\\) i=1:10:1\\\\):\\\\*\\\\(c_char \\\\*\\\\) &iterator\\\\\\[.* <?i>? \\\\+ -1\\\\\\]\\\\)\" 1 \"original\" } }"}, {"sha": "90ec0acd1e10e0cf44731b65722f7b33f762f3c2", "filename": "gcc/testsuite/gfortran.dg/gomp/affinity-clause-6.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Faffinity-clause-6.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,24 @@\n+implicit none\n+integer :: iterator(10), i\n+\n+!$omp taskgroup\n+  !$omp task affinity(iterator)\n+  !$omp end task\n+\n+  !$omp task affinity(iterator(3))\n+  !$omp end task\n+\n+  !$omp task affinity(iterator(i=1:10) : iterator(i))\n+  !$omp end task\n+\n+  !$omp task affinity(iterator(integer :: i))  ! { dg-error \"Failed to match clause at\" }\n+  !!$omp end task\n+\n+  !$omp task affinity(iterator(integer :: i=1:1))  ! { dg-error \"Expected ':' at\" }\n+  !!$omp end task\n+\n+  !$omp task affinity(iterator(i=)) ! { dg-error \"Expected range-specification at\" }\n+!  !$omp end task\n+!$omp end taskgroup\n+\n+end"}, {"sha": "cad36aaf8b71fd4a1b1ee2c563d6c99a4a7b71d8", "filename": "gcc/testsuite/gfortran.dg/gomp/depend-iterator-1.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-1.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+\n+module mymod\n+  implicit none (type, external)\n+  integer, target :: var(0:5) = [0,1,2,3,4,5]\n+end module mymod\n+\n+program main\n+  use mymod\n+  implicit none\n+\n+  type t\n+    integer :: x(0:64)\n+    integer :: y\n+  end type t\n+  type(t) :: dep2(0:64)\n+  integer :: dep1(0:64)\n+\n+  integer arr(0:63)\n+  !$omp parallel\n+  !$omp master\n+  block\n+    integer :: i\n+    do i = 0, 63\n+      !$omp task depend (iterator (j=i:i+1) , out : dep1 (j))\n+        arr(i) = i\n+      !$omp end task\n+      !$omp task depend (iterator (j=i:i+1) , out : dep2 (j))\n+        arr(i) = i\n+      !$omp end task\n+      !$omp task depend (iterator (j=i:i+1) , out : dep2 (j)%y)\n+        arr(i) = i\n+      !$omp end task\n+      !$omp task depend (iterator (j=i:i+1) , out : dep2 (j)%x(j))\n+        arr(i) = i\n+      !$omp end task\n+      !$omp task depend (out : dep2 (:4))\n+        arr(i) = i\n+      !$omp end task\n+      !$omp taskwait depend(out: dep1(1))\n+    end do\n+  end block\n+  !$omp end master\n+  !$omp end parallel\n+end"}, {"sha": "fa826a71097a49c809a9061bf498149ef66b1287", "filename": "gcc/testsuite/gfortran.dg/gomp/depend-iterator-2.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-2.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do run }\n+\n+module mymod\n+  implicit none (type, external)\n+  integer, target :: var(0:5) = [0,1,2,3,4,5]\n+contains\n+  function foo (i)\n+    integer :: i\n+    integer, pointer :: foo\n+    foo => var(mod(i, 6))\n+  end\n+end module mymod\n+\n+program main\n+  use mymod\n+  implicit none\n+\n+  type t\n+    integer :: x(0:64)\n+    integer :: y\n+  end type t\n+  type(t) :: dep2(0:64)\n+  integer :: dep1(0:64)\n+\n+  integer arr(0:63)\n+  !$omp parallel\n+  !$omp master\n+  block\n+    integer :: i\n+    do i = 0, 63\n+      ! NB: Revoking foo (pointer returning function) as in 'foo(i)' is a variable in the Fortran sense\n+      !$omp task depend (iterator (j=i:i+1) , out : foo (j)) ! { dg-error \"is not a variable\" }\n+        arr(i) = i\n+      !!$omp end task\n+    !$omp task depend(iterator(i=1:5), source )  ! { dg-error \"ITERATOR may not be combined with SOURCE\" }\n+  !!$omp end task\n+  !$omp task affinity (iterator(i=1:5): a) depend(iterator(i=1:5), sink : x) ! { dg-error \"ITERATOR may not be combined with SINK\" }\n+  !!$omp end task\n+\n+    end do\n+  end block\n+  !$omp end master\n+  !$omp end parallel\n+end"}, {"sha": "85465ee4c7afad2974cc526ff02d854fd71edbc2", "filename": "gcc/testsuite/gfortran.dg/gomp/depend-iterator-3.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepend-iterator-3.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,27 @@\n+subroutine foo\n+  implicit none\n+  external bar\n+  integer :: i, b(10)\n+  !$omp task depend(in : bar(1)) ! { dg-error \"not a variable\" }\n+  !!$omp end task\n+  !$omp task depend(out : b(1.0))  ! { dg-warning \"Legacy Extension: REAL array index\" }\n+  !$omp end task\n+  !$omp task depend( iterator( real :: i=1.0:5:1), in : b(i))  ! { dg-error \"Expected INTEGER type\" }\n+  !!$omp end task\n+  !$omp task depend(iterator(i=1.0:5:1), out : b(i))  ! { dg-error \"Scalar integer expression for range begin expected\" }\n+  !$omp end task\n+  !$omp task depend(iterator(i=1:5.0:1), in : b(i))  ! { dg-error \"Scalar integer expression for range end expected\" }\n+  !$omp end task\n+  !$omp task depend(iterator(i=1:5:1.0), in : b(i))  ! { dg-error \"Scalar integer expression for range step expected\" }\n+  !$omp end task\n+  !$omp task depend(iterator(j=1:3:5, i=1:5:0), out : b(i))  ! { dg-error \"Nonzero range step expected\" }\n+  !$omp end task\n+  !$omp task depend(iterator(=1:5:0), in : b(i))  ! { dg-error \"Expected identifier\" }\n+  !!$omp end task\n+  !$omp task depend(iterator(b(2)=1:5:1), in : b(i))  ! { dg-error \"Failed to match clause\" }\n+  !!$omp end task\n+  !$omp task depend(iterator(i=1:5:0, i=4:6), out: b(i))  ! { dg-error \"Same identifier 'i' specified again\" }\n+  !!$omp end task\n+  !$omp task depend(iterator(i=1) ,out: b(i))  ! { dg-error \"Expected range-specification\" }\n+  !!$omp end task\n+end"}, {"sha": "80ae24a1191b931ad87bc06a83b9879ddeb55ec4", "filename": "gcc/testsuite/gfortran.dg/gomp/taskwait.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftaskwait.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftaskwait.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftaskwait.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,7 @@\n+! { dg-additional-options \"-fdump-tree-original\" }\n+!$omp taskwait\n+!$omp taskwait depend(out:foo)\n+end\n+\n+! { dg-final { scan-tree-dump-times \"__builtin_GOMP_taskwait \\\\(\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"#pragma omp taskwait depend\\\\(out:foo\\\\)\" 1 \"original\" } }"}, {"sha": "e15e6c651f01e39ef1c9d0971a9072f773716edc", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -277,6 +277,9 @@ enum omp_clause_code {\n   /* OpenMP clause: linear (variable-list[:linear-step]).  */\n   OMP_CLAUSE_LINEAR,\n \n+  /* OpenMP clause: affinity([depend-modifier :] variable-list).  */\n+  OMP_CLAUSE_AFFINITY,\n+\n   /* OpenMP clause: aligned (variable-list[:alignment]).  */\n   OMP_CLAUSE_ALIGNED,\n "}, {"sha": "d8a4f55b2aeb5bad5f7ff1525b9bde9eb7e58891", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -743,6 +743,22 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n       pp_right_paren (pp);\n       break;\n \n+    case OMP_CLAUSE_AFFINITY:\n+      pp_string (pp, \"affinity(\");\n+      {\n+\ttree t = OMP_CLAUSE_DECL (clause);\n+\tif (TREE_CODE (t) == TREE_LIST\n+\t    && TREE_PURPOSE (t)\n+\t    && TREE_CODE (TREE_PURPOSE (t)) == TREE_VEC)\n+\t  {\n+\t    dump_omp_iterators (pp, TREE_PURPOSE (t), spc, flags);\n+\t    pp_colon (pp);\n+\t    t = TREE_VALUE (t);\n+\t  }\n+\tdump_generic_node (pp, t, spc, flags, false);\n+      }\n+      pp_right_paren (pp);\n+      break;\n     case OMP_CLAUSE_DEPEND:\n       pp_string (pp, \"depend(\");\n       switch (OMP_CLAUSE_DEPEND_KIND (clause))\n@@ -803,8 +819,11 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t    pp_colon (pp);\n \t    t = TREE_VALUE (t);\n \t  }\n-\tpp_string (pp, name);\n-\tpp_colon (pp);\n+\tif (name[0])\n+\t  {\n+\t    pp_string (pp, name);\n+\t    pp_colon (pp);\n+\t  }\n \tdump_generic_node (pp, t, spc, flags, false);\n \tpp_right_paren (pp);\n       }"}, {"sha": "1aa6e557a049377a0d7000bdb60f959bfb5d7f1f", "filename": "gcc/tree.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -289,6 +289,7 @@ unsigned const char omp_clause_num_ops[] =\n   1, /* OMP_CLAUSE_COPYIN  */\n   1, /* OMP_CLAUSE_COPYPRIVATE  */\n   3, /* OMP_CLAUSE_LINEAR  */\n+  1, /* OMP_CLAUSE_AFFINITY  */\n   2, /* OMP_CLAUSE_ALIGNED  */\n   2, /* OMP_CLAUSE_ALLOCATE  */\n   1, /* OMP_CLAUSE_DEPEND  */\n@@ -375,6 +376,7 @@ const char * const omp_clause_code_name[] =\n   \"copyin\",\n   \"copyprivate\",\n   \"linear\",\n+  \"affinity\",\n   \"aligned\",\n   \"allocate\",\n   \"depend\",\n@@ -11091,6 +11093,7 @@ walk_tree_1 (tree *tp, walk_tree_fn func, void *data,\n \t  WALK_SUBTREE (OMP_CLAUSE_OPERAND (*tp, 1));\n \t  /* FALLTHRU */\n \n+\tcase OMP_CLAUSE_AFFINITY:\n \tcase OMP_CLAUSE_ASYNC:\n \tcase OMP_CLAUSE_WAIT:\n \tcase OMP_CLAUSE_WORKER:"}, {"sha": "05090d36c807593c51728943dbd93997ab8eaac4", "filename": "libgomp/testsuite/libgomp.fortran/depend-iterator-2.f90", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a5de4d5af1c10a8c097de30ee4c71457216e975/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-iterator-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a5de4d5af1c10a8c097de30ee4c71457216e975/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-iterator-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepend-iterator-2.f90?ref=9a5de4d5af1c10a8c097de30ee4c71457216e975", "patch": "@@ -0,0 +1,89 @@\n+module m\n+  implicit none (type, external)\n+  integer, volatile :: v\n+contains\n+subroutine foo (p, i)\n+  integer :: p(0:*)\n+  integer :: i\n+  !$omp task depend (out: p(0))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (in: p(0))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (inout: p(0))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (mutexinoutset: p(0))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (out: p(0)) depend (in: p(1))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (in: p(0)) depend (inout: p(1))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (inout: p(0)) depend (mutexinoutset: p(1))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (mutexinoutset: p(0)) depend (out: p(1))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , out : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , in : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , inout : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , mutexinoutset : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , out : p(j)) depend (iterator (j=0:2) , in : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , in : p(j)) depend (iterator (j=0:2) , inout : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , inout : p(j)) depend (iterator (j=0:2) , mutexinoutset : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:2) , mutexinoutset : p(j)) depend (iterator (j=0:2) , out : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , out : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , in : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , inout : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , mutexinoutset : p(j))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , out : p(j)) depend (iterator (j=0:i) , in : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , in : p(j)) depend (iterator (j=0:i) , inout : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , inout : p(j)) depend (iterator (j=0:i) , mutexinoutset : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+  !$omp task depend (iterator (j=0:i) , mutexinoutset : p(j)) depend (iterator (j=0:i) , out : p(j + 2))\n+    v = v + 1\n+  !$omp end task\n+end\n+end module\n+\n+program main\n+  use m\n+  implicit none (external, type)\n+  integer p(4)\n+  call foo (p, 2)\n+  call foo (p, -1)\n+end"}]}