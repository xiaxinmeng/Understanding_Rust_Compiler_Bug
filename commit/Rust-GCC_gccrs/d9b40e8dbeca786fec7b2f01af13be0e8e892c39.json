{"sha": "d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliNDBlOGRiZWNhNzg2ZmVjN2IyZjAxYWYxM2JlMGU4ZTg5MmMzOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-03-19T12:51:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-03-19T12:51:28Z"}, "message": "i386.h (machine_function): New fields use_fast_prologue_epilogue.\n\n\t* i386.h (machine_function): New fields use_fast_prologue_epilogue.\n\t* i386.c (use_fast_prologue_epilogue): Remove.\n\t(ix86_frame): New field save_regs-using_mov;\n\t(ix86_compute_frame_layout):  Decide on fast prologues;\n\tallocate saved registers in red zone.\n\t(ix86_expand_epilogue, ix86_expand_prolgoues): Obey new parameters.\n\nFrom-SVN: r64579", "tree": {"sha": "1c90fa89017a7fc684eead643f2ef294b91c3aa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c90fa89017a7fc684eead643f2ef294b91c3aa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/comments", "author": null, "committer": null, "parents": [{"sha": "38b2a9713feb97b645f4ecec5de23c0051261d6c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b2a9713feb97b645f4ecec5de23c0051261d6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b2a9713feb97b645f4ecec5de23c0051261d6c"}], "stats": {"total": 105, "additions": 66, "deletions": 39}, "files": [{"sha": "29a35b8c3f92a064282fbfc1a5e36ea7cb7c846b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "patch": "@@ -1,3 +1,12 @@\n+Wed Mar 19 11:28:45 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.h (machine_function): New fields use_fast_prologue_epilogue.\n+\t* i386.c (use_fast_prologue_epilogue): Remove.\n+\t(ix86_frame): New field save_regs-using_mov;\n+\t(ix86_compute_frame_layout):  Decide on fast prologues;\n+\tallocate saved registers in red zone.\n+\t(ix86_expand_epilogue, ix86_expand_prolgoues): Obey new parameters.\n+\n 2003-03-19  Nick Clifton  <nickc@redhat.com>\n \n \t* config/mcore/mcore.h (CPP_SPEC): Remove trailing semi-colon."}, {"sha": "5959a91fb532bd690e92b92957dc82ce07322028", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "patch": "@@ -530,10 +530,6 @@ const int x86_ext_80387_constants = m_K6 | m_ATHLON | m_PENT4 | m_PPRO;\n    epilogue code.  */\n #define FAST_PROLOGUE_INSN_COUNT 20\n \n-/* Set by prologue expander and used by epilogue expander to determine\n-   the style used.  */\n-static int use_fast_prologue_epilogue;\n-\n /* Names for 8 (low), 8 (high), and 16-bit registers, respectively.  */\n static const char *const qi_reg_name[] = QI_REGISTER_NAMES;\n static const char *const qi_high_reg_name[] = QI_HIGH_REGISTER_NAMES;\n@@ -724,6 +720,10 @@ struct ix86_frame\n   HOST_WIDE_INT frame_pointer_offset;\n   HOST_WIDE_INT hard_frame_pointer_offset;\n   HOST_WIDE_INT stack_pointer_offset;\n+\n+  /* When save_regs_using_mov is set, emit prologue using\n+     move instead of push instructions.  */\n+  bool save_regs_using_mov;\n };\n \n /* Used to enable/disable debugging features.  */\n@@ -4914,6 +4914,37 @@ ix86_compute_frame_layout (frame)\n   frame->nregs = ix86_nsaved_regs ();\n   total_size = size;\n \n+  if (!optimize_size && !reload_completed)\n+    {\n+      int count = frame->nregs;\n+\n+      /* The fast prologue uses move instead of push to save registers.  This\n+         is significantly longer, but also executes faster as modern hardware\n+         can execute the moves in parallel, but can't do that for push/pop.\n+\t \n+\t Be careful about choosing what prologue to emit:  When function takes\n+\t many instructions to execute we may use slow version as well as in\n+\t case function is known to be outside hot spot (this is known with\n+\t feedback only).  Weight the size of function by number of registers\n+\t to save as it is cheap to use one or two push instructions but very\n+\t slow to use many of them.  */\n+      if (count)\n+\tcount = (count - 1) * FAST_PROLOGUE_INSN_COUNT;\n+      if (cfun->function_frequency < FUNCTION_FREQUENCY_NORMAL\n+\t  || (flag_branch_probabilities\n+\t      && cfun->function_frequency < FUNCTION_FREQUENCY_HOT))\n+        cfun->machine->use_fast_prologue_epilogue = false;\n+      else\n+        cfun->machine->use_fast_prologue_epilogue\n+\t   = !expensive_function_p (count);\n+    }\n+  if (TARGET_PROLOGUE_USING_MOVE\n+      && cfun->machine->use_fast_prologue_epilogue)\n+    frame->save_regs_using_mov = true;\n+  else\n+    frame->save_regs_using_mov = false;\n+\n+\n   /* Skip return address and saved base pointer.  */\n   offset = frame_pointer_needed ? UNITS_PER_WORD * 2 : UNITS_PER_WORD;\n \n@@ -4986,10 +5017,15 @@ ix86_compute_frame_layout (frame)\n     (size + frame->padding1 + frame->padding2\n      + frame->outgoing_arguments_size + frame->va_arg_size);\n \n+  if (!frame->to_allocate && frame->nregs <= 1)\n+    frame->save_regs_using_mov = false;\n+\n   if (TARGET_64BIT && TARGET_RED_ZONE && current_function_sp_is_unchanging\n       && current_function_is_leaf)\n     {\n       frame->red_zone_size = frame->to_allocate;\n+      if (frame->save_regs_using_mov)\n+\tframe->red_zone_size += frame->nregs * UNITS_PER_WORD;\n       if (frame->red_zone_size > RED_ZONE_SIZE - RED_ZONE_RESERVE)\n \tframe->red_zone_size = RED_ZONE_SIZE - RED_ZONE_RESERVE;\n     }\n@@ -5058,35 +5094,9 @@ ix86_expand_prologue ()\n   rtx insn;\n   bool pic_reg_used;\n   struct ix86_frame frame;\n-  int use_mov = 0;\n   HOST_WIDE_INT allocate;\n \n   ix86_compute_frame_layout (&frame);\n-  if (!optimize_size)\n-    {\n-      int count = frame.nregs;\n-\n-      /* The fast prologue uses move instead of push to save registers.  This\n-         is significantly longer, but also executes faster as modern hardware\n-         can execute the moves in parallel, but can't do that for push/pop.\n-\t \n-\t Be careful about choosing what prologue to emit:  When function takes\n-\t many instructions to execute we may use slow version as well as in\n-\t case function is known to be outside hot spot (this is known with\n-\t feedback only).  Weight the size of function by number of registers\n-\t to save as it is cheap to use one or two push instructions but very\n-\t slow to use many of them.  */\n-      if (count)\n-\tcount = (count - 1) * FAST_PROLOGUE_INSN_COUNT;\n-      if (cfun->function_frequency < FUNCTION_FREQUENCY_NORMAL\n-\t  || (flag_branch_probabilities\n-\t      && cfun->function_frequency < FUNCTION_FREQUENCY_HOT))\n-\tuse_fast_prologue_epilogue = 0;\n-      else\n-        use_fast_prologue_epilogue = !expensive_function_p (count);\n-      if (TARGET_PROLOGUE_USING_MOVE)\n-        use_mov = use_fast_prologue_epilogue;\n-    }\n \n   /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n      slower on all targets.  Also sdb doesn't like it.  */\n@@ -5101,16 +5111,19 @@ ix86_expand_prologue ()\n     }\n \n   allocate = frame.to_allocate;\n-  /* In case we are dealing only with single register and empty frame,\n-     push is equivalent of the mov+add sequence.  */\n-  if (allocate == 0 && frame.nregs <= 1)\n-    use_mov = 0;\n \n-  if (!use_mov)\n+  if (!frame.save_regs_using_mov)\n     ix86_emit_save_regs ();\n   else\n     allocate += frame.nregs * UNITS_PER_WORD;\n \n+  /* When using red zone we may start register saving before allocating\n+     the stack frame saving one cycle of the prologue.  */\n+  if (TARGET_RED_ZONE && frame.save_regs_using_mov)\n+    ix86_emit_save_regs_using_mov (frame_pointer_needed ? hard_frame_pointer_rtx\n+\t\t\t\t   : stack_pointer_rtx,\n+\t\t\t\t   -frame.nregs * UNITS_PER_WORD);\n+\n   if (allocate == 0)\n     ;\n   else if (! TARGET_STACK_PROBE || allocate < CHECK_STACK_LIMIT)\n@@ -5144,7 +5157,7 @@ ix86_expand_prologue ()\n          call.  */\n       emit_insn (gen_blockage (const0_rtx));\n     }\n-  if (use_mov)\n+  if (frame.save_regs_using_mov && !TARGET_RED_ZONE)\n     {\n       if (!frame_pointer_needed || !frame.to_allocate)\n         ix86_emit_save_regs_using_mov (stack_pointer_rtx, frame.to_allocate);\n@@ -5243,11 +5256,12 @@ ix86_expand_epilogue (style)\n      tuning in future.  */\n   if ((!sp_valid && frame.nregs <= 1)\n       || (TARGET_EPILOGUE_USING_MOVE\n-\t  && use_fast_prologue_epilogue\n+\t  && cfun->machine->use_fast_prologue_epilogue\n \t  && (frame.nregs > 1 || frame.to_allocate))\n       || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n       || (frame_pointer_needed && TARGET_USE_LEAVE\n-\t  && use_fast_prologue_epilogue && frame.nregs == 1)\n+\t  && cfun->machine->use_fast_prologue_epilogue\n+\t  && frame.nregs == 1)\n       || current_function_calls_eh_return)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n@@ -5294,7 +5308,8 @@ ix86_expand_epilogue (style)\n \t\t    GEN_INT (frame.to_allocate\n \t\t\t     + frame.nregs * UNITS_PER_WORD)));\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n-      else if (TARGET_USE_LEAVE || optimize_size || !use_fast_prologue_epilogue)\n+      else if (TARGET_USE_LEAVE || optimize_size\n+\t       || !cfun->machine->use_fast_prologue_epilogue)\n \temit_insn (TARGET_64BIT ? gen_leave_rex64 () : gen_leave ());\n       else\n \t{"}, {"sha": "ce666221bf9a6cdc106e8d80096addd34151522f", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b40e8dbeca786fec7b2f01af13be0e8e892c39/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=d9b40e8dbeca786fec7b2f01af13be0e8e892c39", "patch": "@@ -3220,6 +3220,9 @@ struct machine_function GTY(())\n   int save_varrargs_registers;\n   int accesses_prev_frame;\n   int optimize_mode_switching;\n+  /* Set by ix86_compute_frame_layout and used by prologue/epilogue expander to\n+     determine the style used.  */\n+  int use_fast_prologue_epilogue;\n };\n \n #define ix86_stack_locals (cfun->machine->stack_locals)"}]}