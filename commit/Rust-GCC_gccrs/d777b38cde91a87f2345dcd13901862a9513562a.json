{"sha": "d777b38cde91a87f2345dcd13901862a9513562a", "node_id": "C_kwDOANBUbNoAKGQ3NzdiMzhjZGU5MWE4N2YyMzQ1ZGNkMTM5MDE4NjJhOTUxMzU2MmE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-13T22:53:23Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-11-13T22:53:23Z"}, "message": "analyzer: new warning: -Wanalyzer-tainted-assertion [PR106235]\n\nThis patch adds a new -Wanalyzer-tainted-assertion warning to\n-fanalyzer's \"taint\" mode (which also requires -fanalyzer-checker=taint).\n\nIt complains about attacker-controlled values being used in assertions,\nor in any expression affecting control flow that guards a \"noreturn\"\nfunction.  As noted in the docs part of the patch, in such cases:\n\n  - when assertion-checking is enabled: an attacker could trigger\n    a denial of service by injecting an assertion failure\n\n  - when assertion-checking is disabled, such as by defining NDEBUG,\n    an attacker could inject data that subverts the process, since it\n    presumably violates a precondition that is being assumed by the code.\n\nFor example, given:\n\n#include <assert.h>\n\nint __attribute__((tainted_args))\ntest_tainted_assert (int n)\n{\n  assert (n > 0);\n  return n * n;\n}\n\ncompiling with\n  -fanalyzer -fanalyzer-checker=taint\ngives:\n\nt.c: In function 'test_tainted_assert':\nt.c:6:3: warning: use of attacked-controlled value in condition for assertion [CWE-617] [-Wanalyzer-tainted-assertion]\n    6 |   assert (n > 0);\n      |   ^~~~~~\n  'test_tainted_assert': event 1\n    |\n    |    4 | test_tainted_assert (int n)\n    |      | ^~~~~~~~~~~~~~~~~~~\n    |      | |\n    |      | (1) function 'test_tainted_assert' marked with '__attribute__((tainted_args))'\n    |\n    +--> 'test_tainted_assert': event 2\n           |\n           |    4 | test_tainted_assert (int n)\n           |      | ^~~~~~~~~~~~~~~~~~~\n           |      | |\n           |      | (2) entry to 'test_tainted_assert'\n           |\n         'test_tainted_assert': events 3-6\n           |\n           |/usr/include/assert.h:106:10:\n           |  106 |       if (expr)                                                         \\\n           |      |          ^\n           |      |          |\n           |      |          (3) use of attacker-controlled value for control flow\n           |      |          (4) following 'false' branch (when 'n <= 0')...\n           |......\n           |  109 |         __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);   \\\n           |      |         ~~~~~~~~~~~~~\n           |      |         |\n           |      |         (5) ...to here\n           |      |         (6) treating '__assert_fail' as an assertion failure handler due to '__attribute__((__noreturn__))'\n           |\n\nThe testcases have various examples for BUG and BUG_ON from the\nLinux kernel; there, the diagnostic treats \"panic\" as an assertion\nfailure handler, due to '__attribute__((__noreturn__))'.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/106235\n\t* analyzer.opt (Wanalyzer-tainted-assertion): New.\n\t* checker-path.cc (checker_path::fixup_locations): Pass false to\n\tpending_diagnostic::fixup_location.\n\t* diagnostic-manager.cc (get_emission_location): Pass true to\n\tpending_diagnostic::fixup_location.\n\t* pending-diagnostic.cc (pending_diagnostic::fixup_location): Add\n\tbool param.\n\t* pending-diagnostic.h (pending_diagnostic::fixup_location): Add\n\tbool param to decl.\n\t* sm-taint.cc (taint_state_machine::m_tainted_control_flow): New.\n\t(taint_diagnostic::describe_state_change): Drop \"final\".\n\t(class tainted_assertion): New.\n\t(taint_state_machine::taint_state_machine): Initialize\n\tm_tainted_control_flow.\n\t(taint_state_machine::alt_get_inherited_state): Support\n\tcomparisons being tainted, based on their arguments.\n\t(is_assertion_failure_handler_p): New.\n\t(taint_state_machine::on_stmt): Complain about calls to assertion\n\tfailure handlers guarded by an attacker-controller conditional.\n\tDetect attacker-controlled gcond conditionals and gswitch index\n\tvalues.\n\t(taint_state_machine::check_control_flow_arg_for_taint): New.\n\ngcc/ChangeLog:\n\tPR analyzer/106235\n\t* doc/gcc/gcc-command-options/option-summary.rst: Add\n\t-Wno-analyzer-tainted-assertion.\n\t* doc/gcc/gcc-command-options/options-that-control-static-analysis.rst:\n\tAdd -Wno-analyzer-tainted-assertion.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/106235\n\t* gcc.dg/analyzer/taint-assert-BUG_ON.c: New test.\n\t* gcc.dg/analyzer/taint-assert-macro-expansion.c: New test.\n\t* gcc.dg/analyzer/taint-assert.c: New test.\n\t* gcc.dg/analyzer/taint-assert-system-header.c: New test.\n\t* gcc.dg/analyzer/test-assert.h: New header.\n\t* gcc.dg/plugin/analyzer_gil_plugin.c\n\t(gil_diagnostic::fixup_location): Add bool param.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "deaa3de833f7d2f00338b187c2cc7d6c1e7d119f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/deaa3de833f7d2f00338b187c2cc7d6c1e7d119f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d777b38cde91a87f2345dcd13901862a9513562a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d777b38cde91a87f2345dcd13901862a9513562a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d777b38cde91a87f2345dcd13901862a9513562a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d777b38cde91a87f2345dcd13901862a9513562a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58e7732a2feddf475e72b232bf16494d84a41acf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58e7732a2feddf475e72b232bf16494d84a41acf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58e7732a2feddf475e72b232bf16494d84a41acf"}], "stats": {"total": 842, "additions": 821, "deletions": 21}, "files": [{"sha": "49448697046a40b7b455cd3413df5fc2b0e2257d", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -174,6 +174,10 @@ Wanalyzer-tainted-array-index\n Common Var(warn_analyzer_tainted_array_index) Init(1) Warning\n Warn about code paths in which an unsanitized value is used as an array index.\n \n+Wanalyzer-tainted-assertion\n+Common Var(warn_analyzer_tainted_assertion) Init(1) Warning\n+Warn about code paths in which an 'assert()' is made involving an unsanitized value.\n+\n Wanalyzer-tainted-divisor\n Common Var(warn_analyzer_tainted_divisor) Init(1) Warning\n Warn about code paths in which an unsanitized value is used as a divisor."}, {"sha": "e548ede38218a1f49fcfe679c3c8087b437051fd", "filename": "gcc/analyzer/checker-path.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fchecker-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fchecker-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fchecker-path.cc?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -1316,7 +1316,7 @@ void\n checker_path::fixup_locations (pending_diagnostic *pd)\n {\n   for (checker_event *e : m_events)\n-    e->set_location (pd->fixup_location (e->get_location ()));\n+    e->set_location (pd->fixup_location (e->get_location (), false));\n }\n \n /* Return true if there is a (start_cfg_edge_event, end_cfg_edge_event) pair"}, {"sha": "1b19e58201b37e54e4dfcadeeb0cc57995ee452e", "filename": "gcc/analyzer/diagnostic-manager.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fdiagnostic-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fdiagnostic-manager.cc?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -933,7 +933,7 @@ get_emission_location (const gimple *stmt, function *fun,\n   location_t loc = get_stmt_location (stmt, fun);\n \n   /* Allow the pending_diagnostic to fix up the location.  */\n-  loc = pd.fixup_location (loc);\n+  loc = pd.fixup_location (loc, true);\n \n   return loc;\n }"}, {"sha": "53cab2065ddd68987a18b314d32d7bf6a1ef08e8", "filename": "gcc/analyzer/pending-diagnostic.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fpending-diagnostic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.cc?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -153,7 +153,7 @@ fixup_location_in_macro_p (cpp_hashnode *macro)\n    Don't unwind inside macros for which fixup_location_in_macro_p is true.  */\n \n location_t\n-pending_diagnostic::fixup_location (location_t loc) const\n+pending_diagnostic::fixup_location (location_t loc, bool) const\n {\n   if (linemap_location_from_macro_expansion_p (line_table, loc))\n     {"}, {"sha": "5d5d126b342091c438c58bfdb382156c262ceae2", "filename": "gcc/analyzer/pending-diagnostic.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fpending-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fpending-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fpending-diagnostic.h?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -214,10 +214,10 @@ class pending_diagnostic\n      diagnostic deduplication.  */\n   static bool same_tree_p (tree t1, tree t2);\n \n-  /* A vfunc for fixing up locations (both the primary location for the\n-     diagnostic, and for events in their paths), e.g. to avoid unwinding\n-     inside specific macros.  */\n-  virtual location_t fixup_location (location_t loc) const;\n+  /* Vfunc for fixing up locations, e.g. to avoid unwinding\n+     inside specific macros.  PRIMARY is true for the primary location\n+     for the diagnostic, and FALSE for events in their paths.  */\n+  virtual location_t fixup_location (location_t loc, bool primary) const;\n \n   /* For greatest precision-of-wording, the various following \"describe_*\"\n      virtual functions give the pending diagnostic a way to describe events"}, {"sha": "a2b442a4ef28e2a92150606f24b366ca49a8d71f", "filename": "gcc/analyzer/sm-taint.cc", "status": "modified", "additions": 170, "deletions": 13, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fsm-taint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fanalyzer%2Fsm-taint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-taint.cc?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -109,6 +109,10 @@ class taint_state_machine : public state_machine\n   state_t combine_states (state_t s0, state_t s1) const;\n \n private:\n+  void check_control_flow_arg_for_taint (sm_context *sm_ctxt,\n+\t\t\t\t\t const gimple *stmt,\n+\t\t\t\t\t tree expr) const;\n+\n   void check_for_tainted_size_arg (sm_context *sm_ctxt,\n \t\t\t\t   const supernode *node,\n \t\t\t\t   const gcall *call,\n@@ -130,6 +134,9 @@ class taint_state_machine : public state_machine\n \n   /* Stop state, for a value we don't want to track any more.  */\n   state_t m_stop;\n+\n+  /* Global state, for when the last condition had tainted arguments.  */\n+  state_t m_tainted_control_flow;\n };\n \n /* Class for diagnostics relating to taint_state_machine.  */\n@@ -149,8 +156,7 @@ class taint_diagnostic : public pending_diagnostic\n \t    && m_has_bounds == other.m_has_bounds);\n   }\n \n-  label_text describe_state_change (const evdesc::state_change &change)\n-    final override\n+  label_text describe_state_change (const evdesc::state_change &change) override\n   {\n     if (change.m_new_state == m_sm.m_tainted)\n       {\n@@ -761,6 +767,100 @@ class tainted_allocation_size : public taint_diagnostic\n   enum memory_space m_mem_space;\n };\n \n+/* Concrete taint_diagnostic subclass for reporting attacker-controlled\n+   value being used as part of the condition of an assertion.  */\n+\n+class tainted_assertion : public taint_diagnostic\n+{\n+public:\n+  tainted_assertion (const taint_state_machine &sm, tree arg,\n+\t\t     tree assert_failure_fndecl)\n+  : taint_diagnostic (sm, arg, BOUNDS_NONE),\n+    m_assert_failure_fndecl (assert_failure_fndecl)\n+  {\n+    gcc_assert (m_assert_failure_fndecl);\n+  }\n+\n+  const char *get_kind () const final override\n+  {\n+    return \"tainted_assertion\";\n+  }\n+\n+  bool subclass_equal_p (const pending_diagnostic &base_other) const override\n+  {\n+    if (!taint_diagnostic::subclass_equal_p (base_other))\n+      return false;\n+    const tainted_assertion &other\n+      = (const tainted_assertion &)base_other;\n+    return m_assert_failure_fndecl == other.m_assert_failure_fndecl;\n+  }\n+\n+  int get_controlling_option () const final override\n+  {\n+    return OPT_Wanalyzer_tainted_assertion;\n+  }\n+\n+  bool emit (rich_location *rich_loc) final override\n+  {\n+    diagnostic_metadata m;\n+    /* \"CWE-617: Reachable Assertion\".  */\n+    m.add_cwe (617);\n+\n+    return warning_meta (rich_loc, m, get_controlling_option (),\n+\t\t\t \"use of attacked-controlled value in\"\n+\t\t\t \" condition for assertion\");\n+  }\n+\n+  location_t fixup_location (location_t loc,\n+\t\t\t     bool primary) const final override\n+  {\n+    if (primary)\n+      /* For the primary location we want to avoid being in e.g. the\n+\t <assert.h> system header, since this would suppress the\n+\t diagnostic.  */\n+      return expansion_point_location_if_in_system_header (loc);\n+    else if (in_system_header_at (loc))\n+      /* For events, we want to show the implemenation of the assert\n+\t macro when we're describing them.  */\n+      return linemap_resolve_location (line_table, loc,\n+\t\t\t\t       LRK_SPELLING_LOCATION,\n+\t\t\t\t       NULL);\n+    else\n+      return pending_diagnostic::fixup_location (loc, primary);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change) override\n+  {\n+    if (change.m_new_state == m_sm.m_tainted_control_flow)\n+      return change.formatted_print\n+\t(\"use of attacker-controlled value for control flow\");\n+    return taint_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) final override\n+  {\n+    if (mention_noreturn_attribute_p ())\n+      return ev.formatted_print\n+\t(\"treating %qE as an assertion failure handler\"\n+\t \" due to %<__attribute__((__noreturn__))%>\",\n+\t m_assert_failure_fndecl);\n+    else\n+      return ev.formatted_print\n+\t(\"treating %qE as an assertion failure handler\",\n+\t m_assert_failure_fndecl);\n+  }\n+\n+private:\n+  bool mention_noreturn_attribute_p () const\n+  {\n+    if (fndecl_built_in_p (m_assert_failure_fndecl, BUILT_IN_UNREACHABLE))\n+      return false;\n+    return true;\n+  }\n+\n+  tree m_assert_failure_fndecl;\n+};\n+\n /* taint_state_machine's ctor.  */\n \n taint_state_machine::taint_state_machine (logger *logger)\n@@ -770,6 +870,7 @@ taint_state_machine::taint_state_machine (logger *logger)\n   m_has_lb = add_state (\"has_lb\");\n   m_has_ub = add_state (\"has_ub\");\n   m_stop = add_state (\"stop\");\n+  m_tainted_control_flow = add_state (\"tainted-control-flow\");\n }\n \n state_machine::state_t\n@@ -810,6 +911,15 @@ taint_state_machine::alt_get_inherited_state (const sm_state_map &map,\n \t  {\n \t  default:\n \t    break;\n+\n+\t  case EQ_EXPR:\n+\t  case GE_EXPR:\n+\t  case LE_EXPR:\n+\t  case NE_EXPR:\n+\t  case GT_EXPR:\n+\t  case LT_EXPR:\n+\t  case UNORDERED_EXPR:\n+\t  case ORDERED_EXPR:\n \t  case PLUS_EXPR:\n \t  case MINUS_EXPR:\n \t  case MULT_EXPR:\n@@ -823,17 +933,6 @@ taint_state_machine::alt_get_inherited_state (const sm_state_map &map,\n \t    }\n \t    break;\n \n-\t  case EQ_EXPR:\n-\t  case GE_EXPR:\n-\t  case LE_EXPR:\n-\t  case NE_EXPR:\n-\t  case GT_EXPR:\n-\t  case LT_EXPR:\n-\t  case UNORDERED_EXPR:\n-\t  case ORDERED_EXPR:\n-\t    /* Comparisons are just booleans.  */\n-\t    return m_start;\n-\n \t  case BIT_AND_EXPR:\n \t  case RSHIFT_EXPR:\n \t    return NULL;\n@@ -844,6 +943,19 @@ taint_state_machine::alt_get_inherited_state (const sm_state_map &map,\n   return NULL;\n }\n \n+/* Return true iff FNDECL should be considered to be an assertion failure\n+   handler by -Wanalyzer-tainted-assertion. */\n+\n+static bool\n+is_assertion_failure_handler_p (tree fndecl)\n+{\n+  // i.e. \"noreturn\"\n+  if (TREE_THIS_VOLATILE (fndecl))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Implementation of state_machine::on_stmt vfunc for taint_state_machine.  */\n \n bool\n@@ -871,6 +983,14 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \t/* External function with \"access\" attribute. */\n \tif (sm_ctxt->unknown_side_effects_p ())\n \t  check_for_tainted_size_arg (sm_ctxt, node, call, callee_fndecl);\n+\n+\tif (is_assertion_failure_handler_p (callee_fndecl)\n+\t    && sm_ctxt->get_global_state () == m_tainted_control_flow)\n+\t  {\n+\t    sm_ctxt->warn (node, call, NULL_TREE,\n+\t\t\t   make_unique<tainted_assertion> (*this, NULL_TREE,\n+\t\t\t\t\t\t\t   callee_fndecl));\n+\t  }\n       }\n   // TODO: ...etc; many other sources of untrusted data\n \n@@ -897,9 +1017,46 @@ taint_state_machine::on_stmt (sm_context *sm_ctxt,\n \t}\n     }\n \n+  if (const gcond *cond = dyn_cast <const gcond *> (stmt))\n+    {\n+      /* Reset the state of \"tainted-control-flow\" before each\n+\t control flow statement, so that only the last one before\n+\t an assertion-failure-handler counts.  */\n+      sm_ctxt->set_global_state (m_start);\n+      check_control_flow_arg_for_taint (sm_ctxt, cond, gimple_cond_lhs (cond));\n+      check_control_flow_arg_for_taint (sm_ctxt, cond, gimple_cond_rhs (cond));\n+    }\n+\n+  if (const gswitch *switch_ = dyn_cast <const gswitch *> (stmt))\n+    {\n+      /* Reset the state of \"tainted-control-flow\" before each\n+\t control flow statement, so that only the last one before\n+\t an assertion-failure-handler counts.  */\n+      sm_ctxt->set_global_state (m_start);\n+      check_control_flow_arg_for_taint (sm_ctxt, switch_,\n+\t\t\t\t\tgimple_switch_index (switch_));\n+    }\n+\n   return false;\n }\n \n+/* If EXPR is tainted, mark this execution path with the\n+   \"tainted-control-flow\" global state, in case we're about\n+   to call an assertion-failure-handler.  */\n+\n+void\n+taint_state_machine::check_control_flow_arg_for_taint (sm_context *sm_ctxt,\n+\t\t\t\t\t\t       const gimple *stmt,\n+\t\t\t\t\t\t       tree expr) const\n+{\n+  const region_model *old_model = sm_ctxt->get_old_region_model ();\n+  const svalue *sval = old_model->get_rvalue (expr, NULL);\n+  state_t state = sm_ctxt->get_state (stmt, sval);\n+  enum bounds b;\n+  if (get_taint (state, TREE_TYPE (expr), &b))\n+    sm_ctxt->set_global_state (m_tainted_control_flow);\n+}\n+\n /* Implementation of state_machine::on_condition vfunc for taint_state_machine.\n    Potentially transition state 'tainted' to 'has_ub' or 'has_lb',\n    and states 'has_ub' and 'has_lb' to 'stop'.  */"}, {"sha": "b90b6600d700bbbc276e865ecac01cdb1989df94", "filename": "gcc/doc/gcc/gcc-command-options/option-summary.rst", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foption-summary.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foption-summary.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foption-summary.rst?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -309,6 +309,7 @@ in the following sections.\n   :option:`-Wno-analyzer-shift-count-overflow` |gol|\n   :option:`-Wno-analyzer-stale-setjmp-buffer` |gol|\n   :option:`-Wno-analyzer-tainted-allocation-size` |gol|\n+  :option:`-Wno-analyzer-tainted-assertion` |gol|\n   :option:`-Wno-analyzer-tainted-array-index` |gol|\n   :option:`-Wno-analyzer-tainted-divisor` |gol|\n   :option:`-Wno-analyzer-tainted-offset` |gol|"}, {"sha": "18f73d95e1e96662a013a235eff05aa6494a6bf2", "filename": "gcc/doc/gcc/gcc-command-options/options-that-control-static-analysis.rst", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcc%2Fgcc-command-options%2Foptions-that-control-static-analysis.rst?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -549,6 +549,66 @@ Options That Control Static Analysis\n \n   Default setting; overrides :option:`-Wno-analyzer-tainted-allocation-size`.\n \n+.. option:: -Wno-analyzer-tainted-assertion\n+\n+  This warning requires both :option:`-fanalyzer` and\n+  :option:`-fanalyzer-checker=taint` to enable it;\n+  use :option:`-Wno-analyzer-tainted-assertion` to disable it.\n+\n+  This diagnostic warns for paths through the code in which a value\n+  that could be under an attacker's control is used as part of a\n+  condition without being first sanitized, and that condition guards a\n+  call to a function marked with attribute :fn-attr:`noreturn`\n+  (such as the function ``__builtin_unreachable``).  Such functions\n+  typically indicate abnormal termination of the program, such as for\n+  assertion failure handlers.  For example:\n+\n+  .. code-block:: c\n+\n+    assert (some_tainted_value < SOME_LIMIT);\n+\n+  In such cases:\n+\n+  * when assertion-checking is enabled: an attacker could trigger\n+    a denial of service by injecting an assertion failure\n+\n+  * when assertion-checking is disabled, such as by defining ``NDEBUG``,\n+    an attacker could inject data that subverts the process, since it\n+    presumably violates a precondition that is being assumed by the code.\n+\n+  Note that when assertion-checking is disabled, the assertions are\n+  typically removed by the preprocessor before the analyzer has a chance\n+  to \"see\" them, so this diagnostic can only generate warnings on builds\n+  in which assertion-checking is enabled.\n+\n+  For the purpose of this warning, any function marked with attribute\n+  :fn-attr:`noreturn` is considered as a possible assertion failure\n+  handler, including ``__builtin_unreachable``.  Note that these functions\n+  are sometimes removed by the optimizer before the analyzer \"sees\" them.\n+  Hence optimization should be disabled when attempting to trigger this\n+  diagnostic.\n+\n+  See `CWE-617: Reachable Assertion <https://cwe.mitre.org/data/definitions/617.html>`_.\n+\n+  The warning can also report problematic constructions such as\n+\n+  .. code-block:: c\n+\n+     switch (some_tainted_value) {\n+     case 0:\n+       /* [...etc; various valid cases omitted...] */\n+       break;\n+\n+     default:\n+       __builtin_unreachable (); /* BUG: attacker can trigger this  */\n+     }\n+\n+  despite the above not being an assertion failure, strictly speaking.\n+\n+.. option:: -Wanalyzer-tainted-assertion\n+\n+  Default setting; overrides :option:`-Wno-analyzer-tainted-assertion`.\n+\n .. option:: -Wno-analyzer-tainted-array-index\n \n   This warning requires both :option:`-fanalyzer` and"}, {"sha": "8aef0a44a6d3f4b0f792b39ac625de67df750e6b", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-assert-BUG_ON.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-BUG_ON.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-BUG_ON.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-BUG_ON.c?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -0,0 +1,76 @@\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* We need this, otherwise the warnings are emitted inside the macros, which\n+   makes it hard to write the DejaGnu directives.  */\n+/* { dg-additional-options \" -ftrack-macro-expansion=0\" } */\n+\n+/* Adapted from code in the Linux kernel, which has this: */\n+/* SPDX-License-Identifier: GPL-2.0 */\n+\n+#define __noreturn __attribute__ ((__noreturn__))\n+\n+void panic(const char *fmt, ...) __noreturn;\n+\n+int _printk(const char *fmt, ...);\n+#define __printk_index_emit(...) do {} while (0)\n+#define printk_index_wrap(_p_func, _fmt, ...)\t\t\t\t\\\n+\t({\t\t\t\t\t\t\t\t\\\n+\t\t__printk_index_emit(_fmt, NULL, NULL);\t\t\t\\\n+\t\t_p_func(_fmt, ##__VA_ARGS__);\t\t\t\t\\\n+\t})\n+#define printk(fmt, ...) printk_index_wrap(_printk, fmt, ##__VA_ARGS__)\n+#define barrier_before_unreachable() do { } while (0)\n+\n+#define BUG() do { \\\n+\tprintk(\"BUG: failure at %s:%d/%s()!\\n\", __FILE__, __LINE__, __func__); \\\n+\tbarrier_before_unreachable(); \\\n+\tpanic(\"BUG!\"); \\\n+} while (0)\n+\n+#define BUG_ON(condition) do { if (condition) BUG(); } while (0)\n+\n+void __attribute__((tainted_args))\n+test_BUG(int n)\n+{\n+  if (n > 100) /* { dg-message \"use of attacker-controlled value for control flow\" } */\n+    BUG(); /* { dg-warning \"-Wanalyzer-tainted-assertion\" \"warning\" } */\n+  /* { dg-message \"treating 'panic' as an assertion failure handler due to '__attribute__\\\\(\\\\(__noreturn__\\\\)\\\\)'\" \"final event\" { target *-*-* } .-1 } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_BUG_ON(int n)\n+{\n+  BUG_ON(n > 100); /* { dg-warning \"-Wanalyzer-tainted-assertion\" \"warning\" } */\n+  /* { dg-message \"treating 'panic' as an assertion failure handler due to '__attribute__\\\\(\\\\(__noreturn__\\\\)\\\\)'\" \"final event\" { target *-*-* } .-1 } */\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_BUG_1(int n)\n+{\n+  switch (n) { /* { dg-message \"use of attacker-controlled value for control flow\" } */\n+  default:\n+  case 0:\n+    return 5;\n+  case 1:\n+    return 22;\n+  case 2:\n+    return -1;\n+  case 42:\n+    BUG (); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+  }\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_BUG(int n)\n+{\n+  switch (n) { /* { dg-message \"use of attacker-controlled value for control flow\" } */\n+  case 0:\n+    return 5;\n+  case 1:\n+    return 22;\n+  case 2:\n+    return -1;\n+  }\n+  BUG (); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}"}, {"sha": "24b175a09734eac9dc39ea524b7c71bdb7185a68", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-assert-macro-expansion.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-macro-expansion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-macro-expansion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-macro-expansion.c?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -0,0 +1,96 @@\n+/* Integration test of how the execution path looks for\n+   -Wanalyzer-tainted-assertion with macro-tracking enabled\n+   (the default).  */\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* { dg-additional-options \"-fdiagnostics-show-path-depths\" } */\n+/* { dg-additional-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+/* An assertion macro that has a call to a __noreturn__ function.  */\n+\n+extern void my_assert_fail (const char *expr, const char *file, int line)\n+  __attribute__ ((__noreturn__));\n+\n+#define MY_ASSERT_1(EXPR) \\\n+  do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0) /* { dg-warning \"use of attacked-controlled value in condition for assertion \\\\\\[CWE-617\\\\\\] \\\\\\[-Wanalyzer-tainted-assertion\\\\\\]\" } */\n+\n+int __attribute__((tainted_args))\n+test_tainted_MY_ASSERT_1 (int n)\n+{\n+  MY_ASSERT_1 (n > 0);\n+  return n * n;\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+// note: in expansion of macro 'MY_ASSERT_1'\n+/* { dg-begin-multiline-output \"\" }\n+   MY_ASSERT_1 (n > 0);\n+   ^~~~~~~~~~~\n+  'test_tainted_MY_ASSERT_1': event 1 (depth 0)\n+    |\n+    | test_tainted_MY_ASSERT_1 (int n)\n+    | ^~~~~~~~~~~~~~~~~~~~~~~~\n+    | |\n+    | (1) function 'test_tainted_MY_ASSERT_1' marked with '__attribute__((tainted_args))'\n+    |\n+    +--> 'test_tainted_MY_ASSERT_1': event 2 (depth 1)\n+           |\n+           | test_tainted_MY_ASSERT_1 (int n)\n+           | ^~~~~~~~~~~~~~~~~~~~~~~~\n+           | |\n+           | (2) entry to 'test_tainted_MY_ASSERT_1'\n+           |\n+         'test_tainted_MY_ASSERT_1': event 3 (depth 1)\n+           |\n+           |   do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+           |           ^\n+           |           |\n+           |           (3) use of attacker-controlled value for control flow\n+   { dg-end-multiline-output \"\" } */\n+// note: in expansion of macro 'MY_ASSERT_1'\n+/* { dg-begin-multiline-output \"\" }\n+           |   MY_ASSERT_1 (n > 0);\n+           |   ^~~~~~~~~~~\n+           |\n+         'test_tainted_MY_ASSERT_1': event 4 (depth 1)\n+           |\n+           |   do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+           |           ^\n+           |           |\n+           |           (4) following 'true' branch (when 'n <= 0')...\n+   { dg-end-multiline-output \"\" } */\n+// note: in expansion of macro 'MY_ASSERT_1'\n+/* { dg-begin-multiline-output \"\" }\n+           |   MY_ASSERT_1 (n > 0);\n+           |   ^~~~~~~~~~~\n+           |\n+         'test_tainted_MY_ASSERT_1': event 5 (depth 1)\n+           |\n+           |   do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+           |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |                     |\n+           |                     (5) ...to here\n+   { dg-end-multiline-output \"\" } */\n+// note: in expansion of macro 'MY_ASSERT_1'\n+/* { dg-begin-multiline-output \"\" }\n+           |   MY_ASSERT_1 (n > 0);\n+           |   ^~~~~~~~~~~\n+           |\n+         'test_tainted_MY_ASSERT_1': event 6 (depth 1)\n+           |\n+           |   do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+           |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+           |                     |\n+           |                     (6) treating 'my_assert_fail' as an assertion failure handler due to '__attribute__((__noreturn__))'\n+   { dg-end-multiline-output \"\" } */\n+// note: in expansion of macro 'MY_ASSERT_1'\n+/* { dg-begin-multiline-output \"\" }\n+           |   MY_ASSERT_1 (n > 0);\n+           |   ^~~~~~~~~~~\n+           |\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "a65853c7886a59ceb44fafddfb81a54bd1aaad7b", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-assert-system-header.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-system-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-system-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert-system-header.c?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -0,0 +1,52 @@\n+/* Integration test of how the execution path looks for\n+   -Wanalyzer-tainted-assertion with macro-tracking enabled\n+   (the default), where the assertion macro is defined in\n+   a system header.  */\n+\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* { dg-additional-options \"-fdiagnostics-show-path-depths\" } */\n+/* { dg-additional-options \"-fdiagnostics-path-format=inline-events -fdiagnostics-show-caret\" } */\n+\n+/* An assertion macro that has a call to a __noreturn__ function.  */\n+\n+/* This is marked as a system header.  */\n+#include \"test-assert.h\"\n+\n+int __attribute__((tainted_args))\n+test_tainted_assert (int n)\n+{\n+  assert (n > 0); /* { dg-warning \"use of attacked-controlled value in condition for assertion \\\\\\[CWE-617\\\\\\] \\\\\\[-Wanalyzer-tainted-assertion\\\\\\]\" } */\n+  return n * n;\n+}\n+\n+/* { dg-begin-multiline-output \"\" }\n+   assert (n > 0);\n+   ^~~~~~\n+  'test_tainted_assert': event 1 (depth 0)\n+    |\n+    | test_tainted_assert (int n)\n+    | ^~~~~~~~~~~~~~~~~~~\n+    | |\n+    | (1) function 'test_tainted_assert' marked with '__attribute__((tainted_args))'\n+    |\n+    +--> 'test_tainted_assert': event 2 (depth 1)\n+           |\n+           | test_tainted_assert (int n)\n+           | ^~~~~~~~~~~~~~~~~~~\n+           | |\n+           | (2) entry to 'test_tainted_assert'\n+           |\n+         'test_tainted_assert': events 3-6 (depth 1)\n+           |\n+           |\n+           |   do { if (!(EXPR)) __assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+           |           ^         ~~~~~~~~~~~~~\n+           |           |         |\n+           |           |         (5) ...to here\n+           |           |         (6) treating '__assert_fail' as an assertion failure handler due to '__attribute__((__noreturn__))'\n+           |           (3) use of attacker-controlled value for control flow\n+           |           (4) following 'true' branch (when 'n <= 0')...\n+           |\n+   { dg-end-multiline-output \"\" } */"}, {"sha": "b09f8c51a1612f95dd67371f75a0f583bc1b2ae9", "filename": "gcc/testsuite/gcc.dg/analyzer/taint-assert.c", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftaint-assert.c?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -0,0 +1,346 @@\n+// TODO: remove need for this option\n+/* { dg-additional-options \"-fanalyzer-checker=taint\" } */\n+\n+/* We need this, otherwise the warnings are emitted inside the macros, which\n+   makes it hard to write the DejaGnu directives.  */\n+/* { dg-additional-options \" -ftrack-macro-expansion=0\" } */\n+\n+#include \"analyzer-decls.h\"\n+\n+/* An assertion macro that has a call to a __noreturn__ function.  */\n+\n+extern void my_assert_fail (const char *expr, const char *file, int line)\n+  __attribute__ ((__noreturn__));\n+\n+#define MY_ASSERT_1(EXPR) \\\n+  do { if (!(EXPR)) my_assert_fail (#EXPR, __FILE__, __LINE__); } while (0)\n+\n+int\n+test_not_tainted_MY_ASSERT_1 (int n)\n+{\n+  MY_ASSERT_1 (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+int __attribute__((tainted_args))\n+test_tainted_MY_ASSERT_1 (int n)\n+{\n+  MY_ASSERT_1 (n > 0); /* { dg-warning \"use of attacked-controlled value in condition for assertion \\\\\\[CWE-617\\\\\\] \\\\\\[-Wanalyzer-tainted-assertion\\\\\\]\" \"warning\" } */\n+  /* { dg-message \"treating 'my_assert_fail' as an assertion failure handler due to '__attribute__\\\\(\\\\(__noreturn__\\\\)\\\\)'\" \"final event\" { target *-*-* } .-1 } */\n+  return n * n;\n+}\n+\n+\n+/* An assertion macro that has a call to __builtin_unreachable.  */\n+\n+#define MY_ASSERT_2(EXPR)\t\t\t\t\t\\\n+  do { if (!(EXPR)) __builtin_unreachable (); } while (0)\n+\n+int\n+test_not_tainted_MY_ASSERT_2 (int n)\n+{\n+  MY_ASSERT_2 (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+int __attribute__((tainted_args))\n+test_tainted_MY_ASSERT_2 (int n)\n+{\n+  MY_ASSERT_2 (n > 0); /* { dg-warning \"-Wanalyzer-tainted-assertion\" \"warning\" } */\n+  /* { dg-message \"treating '__builtin_unreachable' as an assertion failure handler\" \"final event\" { target *-*-* } .-1 } */\n+  return n * n;\n+}\n+\n+\n+/* An assertion macro that's preprocessed away.\n+   The analyzer doesn't see this, so can't warn.  */\n+\n+#define MY_ASSERT_3(EXPR)  do { } while (0)\n+\n+int\n+test_not_tainted_MY_ASSERT_3 (int n)\n+{\n+  MY_ASSERT_3 (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+int __attribute__((tainted_args))\n+test_tainted_MY_ASSERT_3 (int n)\n+{\n+  MY_ASSERT_3 (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+\n+/* A macro that isn't an assertion.  */\n+\n+extern void do_something_benign ();\n+\n+#define NOT_AN_ASSERT(EXPR) \\\n+  do { if (!(EXPR)) do_something_benign (); } while (0)\n+\n+int\n+test_not_tainted_NOT_AN_ASSERT (int n)\n+{\n+  NOT_AN_ASSERT (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+int __attribute__((tainted_args))\n+test_tainted_NOT_AN_ASSERT (int n)\n+{\n+  NOT_AN_ASSERT (n > 0); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+  return n * n;\n+}\n+\n+\n+/* A condition that isn't an assertion.  */\n+\n+int __attribute__((tainted_args))\n+test_tainted_condition (int n)\n+{\n+  if (n > 0) /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+    return 1;\n+  else\n+    return -1;\n+}\n+\n+\n+/* More complicated expressions in assertions.  */\n+\n+int g;\n+\n+void __attribute__((tainted_args))\n+test_compound_condition_in_assert_1 (int n)\n+{\n+  MY_ASSERT_1 ((n * 2) < (g + 3)); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_compound_condition_in_assert_2 (int x, int y)\n+{\n+  MY_ASSERT_1 (x < 100 && y < 100); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_compound_condition_in_assert_3 (int x, int y)\n+{\n+  MY_ASSERT_1 (x < 100 || y < 100); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_sanitized_expression_in_assert (int n)\n+{\n+  __analyzer_dump_state (\"taint\", n); /* { dg-warning \"state: 'tainted'\" } */\n+  if (n < 0 || n >= 100)\n+    return;\n+  __analyzer_dump_state (\"taint\", n); /* { dg-warning \"state: 'stop'\" } */  \n+  MY_ASSERT_1 (n < 200); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_sanitization_then_ok_assertion (unsigned n)\n+{\n+  if (n >= 100)\n+    return;\n+\n+  /* Shouldn't warn here, as g isn't attacker-controlled.  */\n+  MY_ASSERT_1 (g > 42); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_good_assert_then_bad_assert (unsigned n)\n+{\n+  /* Shouldn't warn here, as g isn't attacker-controlled.  */\n+  MY_ASSERT_1 (g > 42); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+\n+  /* ...but n is: */\n+  MY_ASSERT_1 (n < 100); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_bad_assert_then_good_assert (unsigned n)\n+{\n+  MY_ASSERT_1 (n < 100); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+  MY_ASSERT_1 (g > 42); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+\n+/* */\n+\n+void __attribute__((tainted_args))\n+test_zero_MY_ASSERT_1 (unsigned n)\n+{\n+  if (n >= 100)\n+    MY_ASSERT_1 (0); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_nonzero_MY_ASSERT_1 (unsigned n)\n+{\n+  if (n >= 100)\n+    MY_ASSERT_1 (1); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_zero_MY_ASSERT_2 (unsigned n)\n+{\n+  if (n >= 100)\n+    MY_ASSERT_2 (0); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+void __attribute__((tainted_args))\n+test_nonzero_MY_ASSERT_2 (unsigned n)\n+{\n+  if (n >= 100)\n+    MY_ASSERT_2 (1); /* { dg-bogus \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+\n+/* Assertions that call a subroutine to do validity checking.  */\n+ \n+static int\n+__analyzer_valid_1 (int x)\n+{\n+  return x < 100;\n+}\n+\n+void __attribute__((tainted_args))\n+test_assert_calling_valid_1 (int n)\n+{\n+  MY_ASSERT_1 (__analyzer_valid_1 (n)); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+ \n+static int\n+__analyzer_valid_2 (int x)\n+{\n+  return x < 100;\n+}\n+\n+void __attribute__((tainted_args))\n+test_assert_calling_valid_2 (int n)\n+{\n+  MY_ASSERT_1 (__analyzer_valid_2 (n)); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}\n+\n+static int\n+__analyzer_valid_3 (int x, int y)\n+{\n+  if (x >= 100)\n+    return 0;\n+  if (y >= 100)\n+    return 0;\n+  return 1;\n+}\n+\n+void __attribute__((tainted_args))\n+test_assert_calling_valid_3 (int a, int b)\n+{\n+  MY_ASSERT_1 (__analyzer_valid_3 (a, b)); /* { dg-warning \"-Wanalyzer-tainted-assertion\" \"TODO\" { xfail *-*-* } } */\n+}\n+\n+\n+/* 'switch' statements with supposedly unreachable cases/defaults.  */\n+\n+int __attribute__((tainted_args))\n+test_switch_default (int n)\n+{\n+  switch (n) /* { dg-message \"use of attacker-controlled value for control flow\" \"why\" } */\n+             /* { dg-message \"following 'default:' branch\" \"dest\" { target *-*-* } .-1 } */\n+    {\n+    case 0:\n+      return 5;\n+    case 1:\n+      return 22;\n+    case 2:\n+      return -1;\n+    default:\n+      /* The wording is rather inaccurate here.  */\n+      __builtin_unreachable (); /* { dg-warning \"use of attacked-controlled value in condition for assertion\" } */\n+    }\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_unhandled_case (int n)\n+{\n+  switch (n) /* { dg-message \"use of attacker-controlled value for control flow\" \"why\" } */\n+             /* { dg-message \"following 'default:' branch\" \"dest\" { target *-*-* } .-1 } */\n+    {\n+    case 0:\n+      return 5;\n+    case 1:\n+      return 22;\n+    case 2:\n+      return -1;\n+    }\n+\n+  /* The wording is rather inaccurate here.  */\n+  __builtin_unreachable (); /* { dg-warning \"use of attacked-controlled value in condition for assertion\" } */\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_bogus_case_MY_ASSERT_1 (int n)\n+{\n+  switch (n)\n+    {\n+    default:\n+    case 0:\n+      return 5;\n+    case 1:\n+      return 22;\n+    case 2:\n+      return -1;\n+    case 42:\n+      MY_ASSERT_1 (0); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+    }\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_bogus_case_MY_ASSERT_2 (int n)\n+{\n+  switch (n)\n+    {\n+    default:\n+    case 0:\n+      return 5;\n+    case 1:\n+      return 22;\n+    case 2:\n+      return -1;\n+    case 42:\n+      MY_ASSERT_2 (0); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+    }\n+}\n+\n+int __attribute__((tainted_args))\n+test_switch_bogus_case_unreachable (int n)\n+{\n+  switch (n)\n+    {\n+    default:\n+    case 0:\n+      return 5;\n+    case 1:\n+      return 22;\n+    case 2:\n+      return -1;\n+    case 42:\n+      /* This case gets optimized away before we see it.  */\n+      __builtin_unreachable ();\n+    }\n+}\n+\n+\n+/* Contents of a struct.  */\n+\n+struct s\n+{\n+  int x;\n+  int y;\n+};\n+\n+int __attribute__((tainted_args))\n+test_assert_struct (struct s *p)\n+{\n+  MY_ASSERT_1 (p->x < p->y); /* { dg-warning \"-Wanalyzer-tainted-assertion\" } */\n+}"}, {"sha": "4a24b720ac8c3d84f001433344bdf9915d07e3cd", "filename": "gcc/testsuite/gcc.dg/analyzer/test-assert.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-assert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-assert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftest-assert.h?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -0,0 +1,7 @@\n+#pragma GCC system_header\n+\n+extern void __assert_fail (const char *expr, const char *file, int line)\n+  __attribute__ ((__noreturn__));\n+\n+#define assert(EXPR) \\\n+  do { if (!(EXPR)) __assert_fail (#EXPR, __FILE__, __LINE__); } while (0)"}, {"sha": "e494315bb34536003c8cdd1906f50a488c675357", "filename": "gcc/testsuite/gcc.dg/plugin/analyzer_gil_plugin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d777b38cde91a87f2345dcd13901862a9513562a/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fplugin%2Fanalyzer_gil_plugin.c?ref=d777b38cde91a87f2345dcd13901862a9513562a", "patch": "@@ -89,7 +89,8 @@ class gil_diagnostic : public pending_diagnostic\n     return 0;\n   }\n \n-  location_t fixup_location (location_t loc) const final override\n+  location_t fixup_location (location_t loc,\n+\t\t\t     bool) const final override\n   {\n     /* Ideally we'd check for specific macros here, and only\n        resolve certain macros.  */"}]}