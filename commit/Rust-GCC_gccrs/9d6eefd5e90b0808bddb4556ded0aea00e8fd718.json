{"sha": "9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ2ZWVmZDVlOTBiMDgwOGJkZGI0NTU2ZGVkMGFlYTAwZThmZDcxOA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-05-25T07:42:28Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2006-05-25T07:42:28Z"}, "message": "tree-vrp.c (extract_range_from_assert): Set the range to VARYING for LT and GT if the computed range is effectively empty.\n\n\t* tree-vrp.c (extract_range_from_assert): Set the range to VARYING\n\tfor LT and GT if the computed range is effectively empty.\n\nFrom-SVN: r114108", "tree": {"sha": "ffe30e35826d449fa90b712b1bfaec8d72d8da2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffe30e35826d449fa90b712b1bfaec8d72d8da2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d6eefd5e90b0808bddb4556ded0aea00e8fd718/comments", "author": null, "committer": null, "parents": [{"sha": "c3c690eafade457d5f883345a1ba93d0cbb852f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3c690eafade457d5f883345a1ba93d0cbb852f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3c690eafade457d5f883345a1ba93d0cbb852f8"}], "stats": {"total": 47, "additions": 34, "deletions": 13}, "files": [{"sha": "64117ca1d5c2daf925c348d4bffc5e74c6de9034", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6eefd5e90b0808bddb4556ded0aea00e8fd718/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6eefd5e90b0808bddb4556ded0aea00e8fd718/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "patch": "@@ -1,4 +1,9 @@\n-2006-06-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+2006-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* tree-vrp.c (extract_range_from_assert): Set the range to VARYING\n+\tfor LT and GT if the computed range is effectively empty.\n+\n+2006-05-24  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/27627\n \t* pa/pa-modes.def: Use mips_single_format, mips_double_format and"}, {"sha": "3ac01fb70f36f55eb2057c3a964bba444e17321c", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d6eefd5e90b0808bddb4556ded0aea00e8fd718/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d6eefd5e90b0808bddb4556ded0aea00e8fd718/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=9d6eefd5e90b0808bddb4556ded0aea00e8fd718", "patch": "@@ -939,14 +939,22 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  max = limit_vr->max;\n \t}\n \n-      /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n-      if (cond_code == LT_EXPR)\n+      /* If the maximum value forces us to be out of bounds, simply punt.\n+\t It would be pointless to try and do anything more since this\n+\t all should be optimized away above us.  */\n+      if (cond_code == LT_EXPR && compare_values (max, min) == 0)\n+\tset_value_range_to_varying (vr_p);\n+      else\n \t{\n-\t  tree one = build_int_cst (type, 1);\n-\t  max = fold_build2 (MINUS_EXPR, type, max, one);\n-\t}\n+\t  /* For LT_EXPR, we create the range [MIN, MAX - 1].  */\n+\t  if (cond_code == LT_EXPR)\n+\t    {\n+\t      tree one = build_int_cst (type, 1);\n+\t      max = fold_build2 (MINUS_EXPR, type, max, one);\n+\t    }\n \n-      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t}\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n     {\n@@ -962,14 +970,22 @@ extract_range_from_assert (value_range_t *vr_p, tree expr)\n \t  min = limit_vr->min;\n \t}\n \n-      /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n-      if (cond_code == GT_EXPR)\n+      /* If the minimum value forces us to be out of bounds, simply punt.\n+\t It would be pointless to try and do anything more since this\n+\t all should be optimized away above us.  */\n+      if (cond_code == GT_EXPR && compare_values (min, max) == 0)\n+\tset_value_range_to_varying (vr_p);\n+      else\n \t{\n-\t  tree one = build_int_cst (type, 1);\n-\t  min = fold_build2 (PLUS_EXPR, type, min, one);\n-\t}\n+\t  /* For GT_EXPR, we create the range [MIN + 1, MAX].  */\n+\t  if (cond_code == GT_EXPR)\n+\t    {\n+\t      tree one = build_int_cst (type, 1);\n+\t      min = fold_build2 (PLUS_EXPR, type, min, one);\n+\t    }\n \n-      set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t  set_value_range (vr_p, VR_RANGE, min, max, vr_p->equiv);\n+\t}\n     }\n   else\n     gcc_unreachable ();"}]}