{"sha": "1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViNDU0N2IxMDU4ZDZhNGUxOTEyYWMwZjE1Y2MwYTY5YmY0ZmQ3OA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2016-10-24T16:53:20Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2016-10-24T16:53:20Z"}, "message": "PR middle-end/77735 - FAIL: gcc.dg/tree-ssa/builtin-sprintf-warn-1.c\n\ngcc/ChangeLog:\n\n\tPR middle-end/77735\n\t* builtins.c (string_length): New function.\n\t(c_strlen): Use string_length.  Correctly handle wide strings.\n\t* gimple-ssa-sprintf.c (target_max_value, target_size_max): New\n\tfunctions.\n\t(target_int_max): Call target_max_value.\n\t(format_result::knownrange): New data member.\n\t(fmtresult::fmtresult): Define default constructor.\n\t(format_integer): Use it and set format_result::knownrange.\n\tHandle global constants.\n\t(format_floating_max): Add third argument.\n\t(format_floating): Recompute maximum value for %a for each argument.\n\t(get_string_length): Use fmtresult default ctor.\n\t(format_string): Set format_result::knownrange.\n\t(format_directive): Check format_result::knownrange.\n\t(add_bytes): Same.  Correct caret placement in diagnostics.\n\t(pass_sprintf_length::compute_format_length): Set\n\tformat_result::knownrange.\n\t(pass_sprintf_length::handle_gimple_call): Use target_size_max.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/77735\n\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Adjust/relax.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: Add test cases.\n\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: XFAIL for LP64 only.\n\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n\nFrom-SVN: r241489", "tree": {"sha": "3fd153c90170bbed75e929c3a8588d01578162b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fd153c90170bbed75e929c3a8588d01578162b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94caf86019219030154f76b786f9de08c2b81275", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94caf86019219030154f76b786f9de08c2b81275", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94caf86019219030154f76b786f9de08c2b81275"}], "stats": {"total": 761, "additions": 560, "deletions": 201}, "files": [{"sha": "a8528b91c41f95d70f1d07e2881209cbe9e5ae52", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -1,3 +1,25 @@\n+2016-10-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77735\n+\t* builtins.c (string_length): New function.\n+\t(c_strlen): Use string_length.  Correctly handle wide strings.\n+\t* gimple-ssa-sprintf.c (target_max_value, target_size_max): New\n+\tfunctions.\n+\t(target_int_max): Call target_max_value.\n+\t(format_result::knownrange): New data member.\n+\t(fmtresult::fmtresult): Define default constructor.\n+\t(format_integer): Use it and set format_result::knownrange.\n+\tHandle global constants.\n+\t(format_floating_max): Add third argument.\n+\t(format_floating): Recompute maximum value for %a for each argument.\n+\t(get_string_length): Use fmtresult default ctor.\n+\t(format_string): Set format_result::knownrange.\n+\t(format_directive): Check format_result::knownrange.\n+\t(add_bytes): Same.  Correct caret placement in diagnostics.\n+\t(pass_sprintf_length::compute_format_length): Set\n+\tformat_result::knownrange.\n+\t(pass_sprintf_length::handle_gimple_call): Use target_size_max.\n+\n 2016-10-24  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_in_large_data_p, ix86_expand_builtin): Use"}, {"sha": "997c0e8c1cbe00e7853b06809a2a50cd29b638fa", "filename": "gcc/builtins.c", "status": "modified", "additions": 75, "deletions": 28, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -503,9 +503,44 @@ get_pointer_alignment (tree exp)\n   return align;\n }\n \n-/* Compute the length of a C string.  TREE_STRING_LENGTH is not the right\n-   way, because it could contain a zero byte in the middle.\n-   TREE_STRING_LENGTH is the size of the character array, not the string.\n+/* Return the number of non-zero elements in the sequence\n+   [ PTR, PTR + MAXELTS ) where each element's size is ELTSIZE bytes.\n+   ELTSIZE must be a power of 2 less than 8.  Used by c_strlen.  */\n+\n+static unsigned\n+string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n+{\n+  gcc_checking_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n+\n+  unsigned n;\n+\n+  if (eltsize == 1)\n+    {\n+      /* Optimize the common case of plain char.  */\n+      for (n = 0; n < maxelts; n++)\n+\t{\n+\t  const char *elt = (const char*) ptr + n;\n+\t  if (!*elt)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      for (n = 0; n < maxelts; n++)\n+\t{\n+\t  const char *elt = (const char*) ptr + n * eltsize;\n+\t  if (!memcmp (elt, \"\\0\\0\\0\\0\", eltsize))\n+\t    break;\n+\t}\n+    }\n+  return n;\n+}\n+\n+/* Compute the length of a null-terminated character string or wide\n+   character string handling character sizes of 1, 2, and 4 bytes.\n+   TREE_STRING_LENGTH is not the right way because it evaluates to\n+   the size of the character array in bytes (as opposed to characters)\n+   and because it can contain a zero byte in the middle.\n \n    ONLY_VALUE should be nonzero if the result is not going to be emitted\n    into the instruction stream and zero if it is going to be expanded.\n@@ -526,12 +561,6 @@ get_pointer_alignment (tree exp)\n tree\n c_strlen (tree src, int only_value)\n {\n-  tree offset_node;\n-  HOST_WIDE_INT offset;\n-  int max;\n-  const char *ptr;\n-  location_t loc;\n-\n   STRIP_NOPS (src);\n   if (TREE_CODE (src) == COND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n@@ -548,25 +577,36 @@ c_strlen (tree src, int only_value)\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n     return c_strlen (TREE_OPERAND (src, 1), only_value);\n \n-  loc = EXPR_LOC_OR_LOC (src, input_location);\n+  location_t loc = EXPR_LOC_OR_LOC (src, input_location);\n \n-  src = string_constant (src, &offset_node);\n+  /* Offset from the beginning of the string in bytes.  */\n+  tree byteoff;\n+  src = string_constant (src, &byteoff);\n   if (src == 0)\n     return NULL_TREE;\n \n-  max = TREE_STRING_LENGTH (src) - 1;\n-  ptr = TREE_STRING_POINTER (src);\n+  /* Determine the size of the string element.  */\n+  unsigned eltsize\n+    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (src))));\n+\n+  /* Set MAXELTS to sizeof (SRC) / sizeof (*SRC) - 1, the maximum possible\n+     length of SRC.  */\n+  unsigned maxelts = TREE_STRING_LENGTH (src) / eltsize - 1;\n \n-  if (offset_node && TREE_CODE (offset_node) != INTEGER_CST)\n+  /* PTR can point to the byte representation of any string type, including\n+     char* and wchar_t*.  */\n+  const char *ptr = TREE_STRING_POINTER (src);\n+\n+  if (byteoff && TREE_CODE (byteoff) != INTEGER_CST)\n     {\n       /* If the string has an internal zero byte (e.g., \"foo\\0bar\"), we can't\n \t compute the offset to the following null if we don't know where to\n \t start searching for it.  */\n-      int i;\n-\n-      for (i = 0; i < max; i++)\n-\tif (ptr[i] == 0)\n+      if (string_length (ptr, eltsize, maxelts) < maxelts)\n+\t{\n+\t  /* Return when an embedded null character is found.  */\n \t  return NULL_TREE;\n+\t}\n \n       /* We don't know the starting offset, but we do know that the string\n \t has no internal zero bytes.  We can assume that the offset falls\n@@ -575,27 +615,31 @@ c_strlen (tree src, int only_value)\n \t and return that.  This would perhaps not be valid if we were dealing\n \t with named arrays in addition to literal string constants.  */\n \n-      return size_diffop_loc (loc, size_int (max), offset_node);\n+      return size_diffop_loc (loc, size_int (maxelts * eltsize), byteoff);\n     }\n \n+  /* Offset from the beginning of the string in elements.  */\n+  HOST_WIDE_INT eltoff;\n+\n   /* We have a known offset into the string.  Start searching there for\n      a null character if we can represent it as a single HOST_WIDE_INT.  */\n-  if (offset_node == 0)\n-    offset = 0;\n-  else if (! tree_fits_shwi_p (offset_node))\n-    offset = -1;\n+  if (byteoff == 0)\n+    eltoff = 0;\n+  else if (! tree_fits_shwi_p (byteoff))\n+    eltoff = -1;\n   else\n-    offset = tree_to_shwi (offset_node);\n+    eltoff = tree_to_shwi (byteoff) / eltsize;\n \n   /* If the offset is known to be out of bounds, warn, and call strlen at\n      runtime.  */\n-  if (offset < 0 || offset > max)\n+  if (eltoff < 0 || eltoff > maxelts)\n     {\n      /* Suppress multiple warnings for propagated constant strings.  */\n       if (only_value != 2\n \t  && !TREE_NO_WARNING (src))\n         {\n-          warning_at (loc, 0, \"offset outside bounds of constant string\");\n+\t  warning_at (loc, 0, \"offset %qwi outside bounds of constant string\",\n+\t\t      eltoff);\n           TREE_NO_WARNING (src) = 1;\n         }\n       return NULL_TREE;\n@@ -605,9 +649,12 @@ c_strlen (tree src, int only_value)\n      constructed with build_string will have nulls appended, we win even\n      if we get handed something like (char[4])\"abcd\".\n \n-     Since OFFSET is our starting index into the string, no further\n+     Since ELTOFF is our starting index into the string, no further\n      calculation is needed.  */\n-  return ssize_int (strlen (ptr + offset));\n+  unsigned len = string_length (ptr + eltoff * eltsize, eltsize,\n+\t\t\t\tmaxelts - eltoff);\n+\n+  return ssize_int (len);\n }\n \n /* Return a constant integer corresponding to target reading"}, {"sha": "3138ad3624ffe6ae6d9f59fba1f5014783c761cb", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 221, "deletions": 114, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -79,6 +79,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"substring-locations.h\"\n #include \"diagnostic.h\"\n \n+/* The likely worst case value of MB_LEN_MAX for the target, large enough\n+   for UTF-8.  Ideally, this would be obtained by a target hook if it were\n+   to be used for optimization but it's good enough as is for warnings.  */\n+#define target_mb_len_max   6\n+\n namespace {\n \n const pass_data pass_data_sprintf_length = {\n@@ -150,17 +155,30 @@ struct format_result\n   unsigned HOST_WIDE_INT number_chars_max;\n \n   /* True when the range given by NUMBER_CHARS_MIN and NUMBER_CHARS_MAX\n-     is the output of all directives determined to be bounded to some\n-     subrange of their types or possible lengths, false otherwise.\n+     can be relied on for value range propagation, false otherwise.\n+     This means that BOUNDED must not be set if the number of bytes\n+     produced by any directive is unspecified or implementation-\n+     defined (unless the implementation's behavior is known and\n+     determined via a target hook).\n      Note that BOUNDED only implies that the length of a function's\n      output is known to be within some range, not that it's constant\n-     and a candidate for folding.  */\n+     and a candidate for string folding.  BOUNDED is a stronger\n+     guarantee than KNOWNRANGE.  */\n   bool bounded;\n \n+  /* True when the range above is obtained from known values of\n+     directive arguments or their bounds and not the result of\n+     heuristics that depend on warning levels.  It is used to\n+     issue stricter diagnostics in cases where strings of unknown\n+     lengths are bounded by the arrays they are determined to\n+     refer to.  KNOWNRANGE must not be used to set the range of\n+     the return value of a call.  */\n+  bool knownrange;\n+\n   /* True when the output of the formatted call is constant (and\n      thus a candidate for string constant folding).  This is rare\n      and typically requires that the arguments of all directives\n-     are also constant.  Constant implies bounded.  */\n+     are also constant.  CONSTANT implies BOUNDED.  */\n   bool constant;\n \n   /* True if no individual directive resulted in more than 4095 bytes\n@@ -216,15 +234,31 @@ target_int_min ()\n   return int_min;\n }\n \n-/* Return the value of INT_MAX for the target.  */\n+/* Return the largest value for TYPE on the target.  */\n \n static unsigned HOST_WIDE_INT\n-target_int_max ()\n+target_max_value (tree type)\n {\n-  const unsigned HOST_WIDE_INT int_max\n+  const unsigned HOST_WIDE_INT max_value\n     = HOST_WIDE_INT_M1U >> (HOST_BITS_PER_WIDE_INT\n-\t\t\t    - TYPE_PRECISION (integer_type_node) + 1);\n-  return int_max;\n+\t\t\t    - TYPE_PRECISION (type) + 1);\n+  return max_value;\n+}\n+\n+/* Return the value of INT_MAX for the target.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+target_int_max ()\n+{\n+  return target_max_value (integer_type_node);\n+}\n+\n+/* Return the value of SIZE_MAX for the target.  */\n+\n+static inline unsigned HOST_WIDE_INT\n+target_size_max ()\n+{\n+  return target_max_value (size_type_node);\n }\n \n /* Return the constant initial value of DECL if available or DECL\n@@ -412,18 +446,30 @@ struct result_range\n \n struct fmtresult\n {\n+  fmtresult ()\n+  : argmin (), argmax (), knownrange (), bounded (), constant ()\n+  {\n+    range.min = range.max = HOST_WIDE_INT_MAX;\n+  }\n+\n   /* The range a directive's argument is in.  */\n   tree argmin, argmax;\n \n   /* The minimum and maximum number of bytes that a directive\n      results in on output for an argument in the range above.  */\n   result_range range;\n \n+  /* True when the range above is obtained from a known value of\n+     a directive's argument or its bounds and not the result of\n+     heuristics that depend on warning levels.  */\n+  bool knownrange;\n+\n   /* True when the range is the result of an argument determined\n      to be bounded to a subrange of its type or value (such as by\n      value range propagation or the width of the formt directive),\n      false otherwise.  */\n   bool bounded;\n+\n   /* True when the output of a directive is constant.  This is rare\n      and typically requires that the argument(s) of the directive\n      are also constant (such as determined by constant propagation,\n@@ -730,7 +776,7 @@ format_integer (const conversion_spec &, tree);\n static fmtresult\n format_pointer (const conversion_spec &spec, tree arg)\n {\n-  fmtresult res = fmtresult ();\n+  fmtresult res;\n \n   /* Determine the target's integer format corresponding to \"%p\".  */\n   const char *flags;\n@@ -869,14 +915,7 @@ format_integer (const conversion_spec &spec, tree arg)\n       break;\n \n     default:\n-      {\n-\tfmtresult res = fmtresult ();\n-\tres.range.min = HOST_WIDE_INT_MAX;\n-\tres.range.max = HOST_WIDE_INT_MAX;\n-\tres.bounded = false;\n-\tres.constant = false;\n-\treturn res;\n-      }\n+\treturn fmtresult ();\n     }\n \n   /* The type of the argument to the directive, either deduced from\n@@ -897,12 +936,13 @@ format_integer (const conversion_spec &spec, tree arg)\n     {\n       /* The minimum and maximum number of bytes produced by\n \t the directive.  */\n-      fmtresult res = fmtresult ();\n+      fmtresult res;\n \n       /* When a constant argument has been provided use its value\n \t rather than type to determine the length of the output.  */\n       res.bounded = true;\n       res.constant = true;\n+      res.knownrange = true;\n \n       /* Base to format the number in.  */\n       int base;\n@@ -975,12 +1015,10 @@ format_integer (const conversion_spec &spec, tree arg)\n       /* Don't bother with invalid arguments since they likely would\n \t have already been diagnosed, and disable any further checking\n \t of the format string by returning [-1, -1].  */\n-      fmtresult res = fmtresult ();\n-      res.range.min = res.range.max = HOST_WIDE_INT_M1U;\n-      return res;\n+      return fmtresult ();\n     }\n \n-  fmtresult res = fmtresult ();\n+  fmtresult res;\n \n   /* Using either the range the non-constant argument is in, or its\n      type (either \"formal\" or actual), create a range of values that\n@@ -1029,9 +1067,10 @@ format_integer (const conversion_spec &spec, tree arg)\n \t      argmax = res.argmax;\n \t    }\n \n-\t  /* The argument is bounded by the range of values determined\n-\t     by Value Range Propagation.  */\n+\t  /* The argument is bounded by the known range of values\n+\t     determined by Value Range Propagation.  */\n \t  res.bounded = true;\n+\t  res.knownrange = true;\n \t}\n       else if (range_type == VR_ANTI_RANGE)\n \t{\n@@ -1047,6 +1086,12 @@ format_integer (const conversion_spec &spec, tree arg)\n \t  if (is_gimple_assign (def))\n \t    {\n \t      tree_code code = gimple_assign_rhs_code (def);\n+\t      if (code == INTEGER_CST)\n+\t\t{\n+\t\t  arg = gimple_assign_rhs1 (def);\n+\t\t  return format_integer (spec, arg);\n+\t\t}\n+\n \t      if (code == NOP_EXPR)\n \t\targtype = TREE_TYPE (gimple_assign_rhs1 (def));\n \t    }\n@@ -1111,7 +1156,7 @@ format_integer (const conversion_spec &spec, tree arg)\n    SPEC the largest value in the real floating TYPE.  */\n \n static int\n-format_floating_max (tree type, char spec)\n+format_floating_max (tree type, char spec, int prec = -1)\n {\n   machine_mode mode = TYPE_MODE (type);\n \n@@ -1136,9 +1181,21 @@ format_floating_max (tree type, char spec)\n   mpfr_init2 (x, rfmt->p);\n   mpfr_from_real (x, &rv, GMP_RNDN);\n \n-  const char fmt[] = { '%', 'R', spec, '\\0' };\n-  int n = mpfr_snprintf (NULL, 0, fmt, x);\n-  return n;\n+  int n;\n+\n+  if (-1 < prec)\n+    {\n+      const char fmt[] = { '%', '.', '*', 'R', spec, '\\0' };\n+      n = mpfr_snprintf (NULL, 0, fmt, prec, x);\n+    }\n+  else\n+    {\n+      const char fmt[] = { '%', 'R', spec, '\\0' };\n+      n = mpfr_snprintf (NULL, 0, fmt, x);\n+    }\n+\n+  /* Return a value one greater to account for the leading minus sign.  */\n+  return n + 1;\n }\n \n /* Return a range representing the minimum and maximum number of bytes\n@@ -1170,19 +1227,11 @@ format_floating (const conversion_spec &spec, int width, int prec)\n       break;\n \n     default:\n-      {\n-\tfmtresult res = fmtresult ();\n-\tres.range.min = HOST_WIDE_INT_MAX;\n-\tres.range.max = HOST_WIDE_INT_MAX;\n-\tres.bounded = false;\n-\tres.constant = false;\n-\treturn res;\n-      }\n+      return fmtresult ();\n     }\n \n   /* The minimum and maximum number of bytes produced by the directive.  */\n-  fmtresult res = fmtresult ();\n-  res.constant = false;\n+  fmtresult res;\n \n   /* Log10 of of the maximum number of exponent digits for the type.  */\n   int logexpdigs = 2;\n@@ -1206,13 +1255,11 @@ format_floating (const conversion_spec &spec, int width, int prec)\n       {\n \t/* The minimum output is \"0x.p+0\".  */\n \tres.range.min = 6 + (prec > 0 ? prec : 0);\n+\tres.range.max = format_floating_max (type, 'a', prec);\n \n-\t/* Compute the maximum just once.  */\n-\tstatic const int a_max[] = {\n-\t  format_floating_max (double_type_node, 'a'),\n-\t  format_floating_max (long_double_type_node, 'a')\n-\t};\n-\tres.range.max = a_max [ldbl];\n+\t/* The output of \"%a\" is fully specified only when precision\n+\t   is explicitly specified.  */\n+\tres.bounded = -1 < prec;\n \tbreak;\n       }\n \n@@ -1229,6 +1276,9 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \t   included), plus the difference between the minimum exponent\n \t   of 2 and the maximum exponent for the type.  */\n \tres.range.max = res.range.min + !sign + logexpdigs - 2;\n+\n+\t/* \"%e\" is fully specified and the range of bytes is bounded.  */\n+\tres.bounded = true;\n \tbreak;\n       }\n \n@@ -1245,6 +1295,9 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \t  format_floating_max (long_double_type_node, 'f')\n \t};\n \tres.range.max = f_max [ldbl];\n+\n+\t/* \"%f\" is fully specified and the range of bytes is bounded.  */\n+\tres.bounded = true;\n \tbreak;\n       }\n     case 'G':\n@@ -1259,18 +1312,14 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \t  format_floating_max (long_double_type_node, 'g')\n \t};\n \tres.range.max = g_max [ldbl];\n+\n+\t/* \"%g\" is fully specified and the range of bytes is bounded.  */\n+\tres.bounded = true;\n \tbreak;\n       }\n \n     default:\n-      {\n-\tfmtresult res = fmtresult ();\n-\tres.range.min = HOST_WIDE_INT_MAX;\n-\tres.range.max = HOST_WIDE_INT_MAX;\n-\tres.bounded = false;\n-\tres.constant = false;\n-\treturn res;\n-      }\n+      return fmtresult ();\n     }\n \n   if (width > 0)\n@@ -1281,9 +1330,6 @@ format_floating (const conversion_spec &spec, int width, int prec)\n \tres.range.max = width;\n     }\n \n-  /* The argument is only considered bounded when the range of output\n-     bytes is exact.  */\n-  res.bounded = res.range.min == res.range.max;\n   return res;\n }\n \n@@ -1298,7 +1344,7 @@ format_floating (const conversion_spec &spec, tree arg)\n   int prec = -1;\n \n   /* The minimum and maximum number of bytes produced by the directive.  */\n-  fmtresult res = fmtresult ();\n+  fmtresult res;\n   res.constant = arg && TREE_CODE (arg) == REAL_CST;\n \n   if (spec.have_width)\n@@ -1390,7 +1436,16 @@ format_floating (const conversion_spec &spec, tree arg)\n \t  *minmax[i] = mpfr_snprintf (NULL, 0, fmtstr, mpfrval);\n \t}\n \n-      res.bounded = res.range.min < target_int_max ();\n+      /* The output of all directives except \"%a\" is fully specified\n+\t and so the result is bounded unless it exceeds INT_MAX.\n+\t For \"%a\" the output is fully specified only when precision\n+\t is explicitly specified.  */\n+      res.bounded = ((TOUPPER (spec.specifier) != 'A'\n+\t\t      || (0 <= prec && (unsigned) prec < target_int_max ()))\n+\t\t     && res.range.min < target_int_max ());\n+\n+      /* The range of output is known even if the result isn't bounded.  */\n+      res.knownrange = true;\n       return res;\n     }\n \n@@ -1405,14 +1460,7 @@ static fmtresult\n get_string_length (tree str)\n {\n   if (!str)\n-    {\n-      fmtresult res;\n-      res.range.min = HOST_WIDE_INT_MAX;\n-      res.range.max = HOST_WIDE_INT_MAX;\n-      res.bounded = false;\n-      res.constant = false;\n-      return res;\n-    }\n+    return fmtresult ();\n \n   if (tree slen = c_strlen (str, 1))\n     {\n@@ -1421,6 +1469,7 @@ get_string_length (tree str)\n       res.range.min = res.range.max = tree_to_shwi (slen);\n       res.bounded = true;\n       res.constant = true;\n+      res.knownrange = true;\n       return res;\n     }\n \n@@ -1434,7 +1483,7 @@ get_string_length (tree str)\n \n   if (lenrange [0] || lenrange [1])\n     {\n-      fmtresult res = fmtresult ();\n+      fmtresult res;\n \n       res.range.min = (tree_fits_uhwi_p (lenrange[0])\n \t\t       ? tree_to_uhwi (lenrange[0]) : 1 < warn_format_length);\n@@ -1445,11 +1494,13 @@ get_string_length (tree str)\n \t by STR are known to be bounded (though not necessarily by their\n \t actual length but perhaps by their maximum possible length).  */\n       res.bounded = res.range.max < target_int_max ();\n+      res.knownrange = res.bounded;\n \n       /* Set RES.CONSTANT to false even though that may be overly\n \t conservative in rare cases like: 'x ? a : b' where a and\n \t b have the same lengths and consist of the same characters.  */\n       res.constant = false;\n+\n       return res;\n     }\n \n@@ -1479,7 +1530,7 @@ format_string (const conversion_spec &spec, tree arg)\n     prec = (TREE_CODE (spec.star_precision) == INTEGER_CST\n \t    ? tree_to_shwi (spec.star_precision) : -1);\n \n-  fmtresult res = fmtresult ();\n+  fmtresult res;\n \n   /* The maximum number of bytes for an unknown wide character argument\n      to a \"%lc\" directive adjusted for precision but not field width.  */\n@@ -1515,13 +1566,16 @@ format_string (const conversion_spec &spec, tree arg)\n \t     locale, which is unfortunately, unknown.  */\n \t  res.range.min = 1 == warn_format_length ? !nul : nul < 1;\n \t  res.range.max = max_bytes_for_unknown_wc;\n-\t  res.bounded = true;\n+\t  /* The range above is good enough to issue warnings but not\n+\t     for value range propagation, so clear BOUNDED.  */\n+\t  res.bounded = false;\n \t}\n       else\n \t{\n-\t  /* A plain '%c' directive.  */\n+\t  /* A plain '%c' directive.  Its ouput is exactly 1.  */\n \t  res.range.min = res.range.max = 1;\n \t  res.bounded = true;\n+\t  res.knownrange = true;\n \t  res.constant = arg && TREE_CODE (arg) == INTEGER_CST;\n \t}\n     }\n@@ -1533,24 +1587,35 @@ format_string (const conversion_spec &spec, tree arg)\n \t{\n \t  gcc_checking_assert (slen.range.min == slen.range.max);\n \n-\t  res.bounded = true;\n-\n \t  /* A '%s' directive with a string argument with constant length.  */\n \t  res.range = slen.range;\n \n+\t  /* The output of \"%s\" and \"%ls\" directives with a constant\n+\t     string is in a known range.  For \"%s\" it is the length\n+\t     of the string.  For \"%ls\" it is in the range [length,\n+\t     length * MB_LEN_MAX].  (The final range can be further\n+\t     constrained by width and precision but it's always known.)  */\n+\t  res.knownrange = true;\n+\n \t  if (spec.modifier == FMT_LEN_l)\n \t    {\n-\t      if (warn_format_length > 2)\n+\t      bounded = false;\n+\n+\t      if (warn_format_length > 1)\n \t\t{\n-\t\t  res.range.min *= 6;\n+\t\t  /* Leave the minimum number of bytes the wide string\n+\t\t     converts to equal to its length and set the maximum\n+\t\t     to the worst case length which is the string length\n+\t\t     multiplied by MB_LEN_MAX.  */\n \n \t\t  /* It's possible to be smarter about computing the maximum\n \t\t     by scanning the wide string for any 8-bit characters and\n \t\t     if it contains none, using its length for the maximum.\n \t\t     Even though this would be simple to do it's unlikely to\n \t\t     be worth it when dealing with wide characters.  */\n-\t\t  res.range.max *= 6;\n+\t\t  res.range.max *= target_mb_len_max;\n \t\t}\n+\n \t      /* For a wide character string, use precision as the maximum\n \t\t even if precision is greater than the string length since\n \t\t the number of bytes the string converts to may be greater\n@@ -1559,7 +1624,12 @@ format_string (const conversion_spec &spec, tree arg)\n \t\tres.range.max = prec;\n \t    }\n \t  else\n-\t    res.constant = true;\n+\t    {\n+\t      /* The output od a \"%s\" directive with a constant argument\n+\t\t is bounded, constant, and obviously in a known range.  */\n+\t      res.bounded = true;\n+\t      res.constant = true;\n+\t    }\n \n \t  if (0 <= prec && (unsigned)prec < res.range.min)\n \t    {\n@@ -1577,9 +1647,11 @@ format_string (const conversion_spec &spec, tree arg)\n \n \t  if (0 <= prec)\n \t    {\n-\t      if ((unsigned)prec < slen.range.min\n-\t\t  || slen.range.min >= target_int_max ())\n+\t      if (slen.range.min >= target_int_max ())\n+\t\tslen.range.min = max_bytes_for_unknown_str;\n+\t      else if ((unsigned)prec < slen.range.min)\n \t\tslen.range.min = prec;\n+\n \t      if ((unsigned)prec < slen.range.max\n \t\t  || slen.range.max >= target_int_max ())\n \t\tslen.range.max = prec;\n@@ -1597,6 +1669,7 @@ format_string (const conversion_spec &spec, tree arg)\n \t     specified to limit the number of bytes or when the number\n \t     of bytes is known or contrained to some range.  */\n \t  res.bounded = 0 <= prec || slen.bounded;\n+\t  res.knownrange = slen.knownrange;\n \t  res.constant = false;\n \t}\n     }\n@@ -1613,6 +1686,11 @@ format_string (const conversion_spec &spec, tree arg)\n       && bounded)\n     res.bounded = true;\n \n+  /* When precision is specified the range of characters on output\n+     is known to be bounded by it.  */\n+  if (-1 < prec)\n+    res.knownrange = true;\n+\n   return res;\n }\n \n@@ -1655,29 +1733,46 @@ format_directive (const pass_sprintf_length::call_info &info,\n   /* Compute the (approximate) length of the formatted output.  */\n   fmtresult fmtres = spec.fmtfunc (spec, arg);\n \n-  /* The overall result is bounded only if the output of every\n-     directive is exact or bounded.  */\n-  res->bounded = res->bounded && fmtres.bounded;\n-  res->constant = res->constant && fmtres.constant;\n+  /* The overall result is bounded and constant only if the output\n+     of every directive is bounded and constant, respectively.  */\n+  res->bounded &= fmtres.bounded;\n+  res->constant &= fmtres.constant;\n \n-  if (fmtres.range.max >= HOST_WIDE_INT_MAX)\n-    {\n-      /* Disable exact and maximum length checking after a failure\n-\t to determine the maximum number of characters (for example\n-\t for wide characters or wide character strings) but continue\n-\t tracking the minimum number of characters.  */\n-      res->number_chars_max = HOST_WIDE_INT_M1U;\n-      res->number_chars = HOST_WIDE_INT_M1U;\n-    }\n+  /* Record whether the output of all directives is known to be\n+     bounded by some maximum, implying that their arguments are\n+     either known exactly or determined to be in a known range\n+     or, for strings, limited by the upper bounds of the arrays\n+     they refer to.  */\n+  res->knownrange &= fmtres.knownrange;\n \n-  if (fmtres.range.min >= HOST_WIDE_INT_MAX)\n+  if (!fmtres.knownrange)\n     {\n-      /* Disable exact length checking after a failure to determine\n-\t even the minimum number of characters (it shouldn't happen\n-\t except in an error) but keep tracking the minimum and maximum\n-\t number of characters.  */\n-      res->number_chars = HOST_WIDE_INT_M1U;\n-      return;\n+      /* Only when the range is known, check it against the host value\n+\t of INT_MAX.  Otherwise the range doesn't correspond to known\n+\t values of the argument.  */\n+      if (fmtres.range.max >= target_int_max ())\n+\t{\n+\t  /* Normalize the MAX counter to avoid having to deal with it\n+\t     later.  The counter can be less than HOST_WIDE_INT_M1U\n+\t     when compiling for an ILP32 target on an LP64 host.  */\n+\t  fmtres.range.max = HOST_WIDE_INT_M1U;\n+\t  /* Disable exact and maximum length checking after a failure\n+\t     to determine the maximum number of characters (for example\n+\t     for wide characters or wide character strings) but continue\n+\t     tracking the minimum number of characters.  */\n+\t  res->number_chars_max = HOST_WIDE_INT_M1U;\n+\t  res->number_chars = HOST_WIDE_INT_M1U;\n+\t}\n+\n+      if (fmtres.range.min >= target_int_max ())\n+\t{\n+\t  /* Disable exact length checking after a failure to determine\n+\t     even the minimum number of characters (it shouldn't happen\n+\t     except in an error) but keep tracking the minimum and maximum\n+\t     number of characters.  */\n+\t  res->number_chars = HOST_WIDE_INT_M1U;\n+\t  return;\n+\t}\n     }\n \n   /* Compute the number of available bytes in the destination.  There\n@@ -1725,11 +1820,15 @@ format_directive (const pass_sprintf_length::call_info &info,\n \t\t}\n \t    }\n \t  else if (navail < fmtres.range.max\n-\t\t   && (fmtres.bounded || 1 < warn_format_length))\n+\t\t   && (((spec.specifier == 's'\n+\t\t\t && fmtres.range.max < HOST_WIDE_INT_MAX)\n+\t\t\t/* && (spec.precision || spec.star_precision) */)\n+\t\t       || 1 < warn_format_length))\n \t    {\n \t      /* The maximum directive output is longer than there is\n-\t\t room in the destination and the output is either bounded\n-\t\t or the warning level is greater than 1.  */\n+\t\t room in the destination and the output length is either\n+\t\t explicitly constrained by the precision (for strings)\n+ \t\t or the warning level is greater than 1.  */\n \t      if (fmtres.range.max >= HOST_WIDE_INT_MAX)\n \t\t{\n \t\t  const char* fmtstr\n@@ -1910,18 +2009,21 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \n   /* If issuing a diagnostic (only when one hasn't already been issued),\n      distinguish between a possible overflow (\"may write\") and a certain\n-     overflow somewhere \"past the end.\"  (Ditto for truncation.)  */\n+     overflow somewhere \"past the end.\"  (Ditto for truncation.)\n+     KNOWNRANGE is used to warn even at level 1 about possibly writing\n+     past the end or truncation due to strings of unknown lengths that\n+     are bounded by the arrays they are known to refer to.  */\n   if (!res->warned\n       && (avail_range.max < nbytes\n-\t  || ((res->bounded || 1 < warn_format_length)\n+\t  || ((res->knownrange || 1 < warn_format_length)\n \t      && avail_range.min < nbytes)))\n     {\n       /* Set NAVAIL to the number of available bytes used to decide\n \t whether or not to issue a warning below.  The exact kind of\n \t warning will depend on AVAIL_RANGE.  */\n       unsigned HOST_WIDE_INT navail = avail_range.max;\n       if (nbytes <= navail && avail_range.min < HOST_WIDE_INT_MAX\n-\t  && (res->bounded || 1 < warn_format_length))\n+\t  && (res->knownrange || 1 < warn_format_length))\n \tnavail = avail_range.min;\n \n       /* Compute the offset of the first format character that is beyond\n@@ -1932,8 +2034,12 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \n       size_t len = strlen (info.fmtstr + off);\n \n+      /* Create a location that underscores the substring of the format\n+\t string that is or may be written past the end (or is or may be\n+\t truncated), pointing the caret at the first character of the\n+\t substring.  */\n       substring_loc loc\n-\t(info.fmtloc, TREE_TYPE (info.format), off - !len, len ? off : 0,\n+\t(info.fmtloc, TREE_TYPE (info.format), off, len ? off : 0,\n \t off + len - !!len);\n \n       /* Is the output of the last directive the result of the argument\n@@ -1944,7 +2050,7 @@ add_bytes (const pass_sprintf_length::call_info &info,\n \t= (res->number_chars_min < res->number_chars_max\n \t   && res->number_chars_min < info.objsize);\n \n-      if (!end && (nbytes - navail) == 1)\n+      if (!end && ((nbytes - navail) == 1 || boundrange))\n \t{\n \t  /* There is room for the rest of the format string but none\n \t     for the terminating nul.  */\n@@ -2082,10 +2188,11 @@ pass_sprintf_length::compute_format_length (const call_info &info,\n   /* Reset exact, minimum, and maximum character counters.  */\n   res->number_chars = res->number_chars_min = res->number_chars_max = 0;\n \n-  /* No directive has been seen yet so the output is bounded and constant\n-     (with no conversion producing more than 4K bytes) until determined\n-     otherwise.  */\n+  /* No directive has been seen yet so the length of output is bounded\n+     by the known range [0, 0] and constant (with no conversion producing\n+     more than 4K bytes) until determined otherwise.  */\n   res->bounded = true;\n+  res->knownrange = true;\n   res->constant = true;\n   res->under4k = true;\n   res->floating = false;\n@@ -2591,10 +2698,10 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator gsi)\n       if (TREE_CODE (size) == INTEGER_CST)\n \t{\n \t  dstsize = tree_to_uhwi (size);\n-\t  /* No object can be larger than HOST_WIDE_INT_MAX bytes\n-\t     (half the address space).  This imposes a limit that's\n-\t     one byte less than that.  */\n-\t  if (dstsize >= HOST_WIDE_INT_MAX)\n+\t  /* No object can be larger than SIZE_MAX bytes (half the address\n+\t     space) on the target.  This imposes a limit that's one byte\n+\t     less than that.  */\n+\t  if (dstsize >= target_size_max () / 2)\n \t    warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n \t\t\t\"specified destination size %wu too large\",\n \t\t\tdstsize);\n@@ -2640,7 +2747,7 @@ pass_sprintf_length::handle_gimple_call (gimple_stmt_iterator gsi)\n       info.objsize = dstsize < objsize ? dstsize : objsize;\n \n       if (info.bounded\n-\t  && dstsize != HOST_WIDE_INT_M1U && objsize < dstsize)\n+\t  && dstsize < target_size_max () / 2 && objsize < dstsize)\n \t{\n \t  warning_at (gimple_location (info.callstmt), OPT_Wformat_length_,\n \t\t      \"specified size %wu exceeds the size %wu \""}, {"sha": "28c755036d84c372bdf4e3d2f64fffa0f7aab27c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -1,3 +1,14 @@\n+2016-10-24  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR middle-end/77735\n+\t* gcc.dg/tree-ssa/builtin-sprintf-2.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-1.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-2.c: Same.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-3.c: Adjust/relax.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-4.c: Add test cases.\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-6.c: XFAIL for LP64 only.\n+\t* gcc.dg/tree-ssa/builtin-sprintf.c: Add test cases.\n+\n 2016-10-24  Richard Biener  <rguenther@suse.de>\n \n \tPR testsuite/71491"}, {"sha": "1996665e2b3487dd13aca67cc2674837a13a4347", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-2.c", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-2.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -1,5 +1,5 @@\n /* Test to verify that the return value of calls to __builtin_sprintf\n-   is not folded if the call has undefined behavior even if it would\n+   is not folded if the call isn't fully specified, even if it would\n    otherwise produce a known number of bytes on output, and that if\n    the return value is in a known range the range is not made\n    available to subsequent passes and doesn't affect branching and\n@@ -22,7 +22,8 @@ char buf8k [8192];\n #define CAT(a, b)      concat (a, b)\n \n #define EQL(expect, size, fmt, ...)\t\t\t\t\t\\\n-  void CAT (test_on_line_, __LINE__)(void)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  CAT (test_on_line_, __LINE__)(void)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -37,7 +38,8 @@ char buf8k [8192];\n    to the formatted function is not treated as a constant or made available\n    to subsequent optimization passes.  */\n #define RNG(min, max, size, fmt, ...)\t\t\t\t\t\\\n-  void CAT (test_on_line_, __LINE__)(void)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  CAT (test_on_line_, __LINE__)(void)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     if (!LINE || LINE == __LINE__)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -52,6 +54,9 @@ extern int i;\n extern long li;\n extern char *str;\n \n+extern double d;\n+extern long double ld;\n+\n /* Verify that overflowing the destination object disables the return\n    value optimization.  */\n EQL (0, 0, \"%c\",  ' ');\n@@ -78,7 +83,15 @@ enum { imax2 = (INT_MAX / 2) * 2 };\n EQL (imax2, -1, \"%*c%*c\", INT_MAX / 2, 'x', INT_MAX / 2, 'y');\n \n /* Verify that range information for calls that overflow the destination\n-   isn't available.  */\n+   isn't available.\n+\n+     +-- lower bound of the tested range\n+     |   +-- upper bound of the tested range\n+     |   |   +-- size of destination buffer\n+     |   |   |  +-- format string\n+     |   |   |  |       +-- argument(s)\n+     |   |   |  |       |\n+     V   V   V  V       V  */\n RNG (0,  0,  0, \"%hhi\", i)\n RNG (0,  0,  1, \"%hhi\", i)\n RNG (0,  1,  1, \"%hhi\", i)\n@@ -190,11 +203,36 @@ RNG (0, 10, 10, \"%i\", i)\n \n #endif\n \n+/* Verify that the output of a \"%a\" directive with no precision is not\n+   considered constant or within a known range (the number of digits\n+   after the decimal point is unspecified in this case).  The hardcoded\n+   ranges correspond to Glibc values.  */\n+RNG (6,  6,  7, \"%a\",       0.0)    /* Glibc output: \"0x0p+0\"  */\n+RNG (6,  6,  7, \"%a\",       d)\n+RNG (6,  6,  7, \"%.4096a\",  d)\n+\n+RNG (6,  6,  7, \"%La\",      0.0L)   /* Glibc output: \"0x0p+0\"  */\n+RNG (6,  6,  7, \"%La\",      ld)\n+RNG (6,  6,  7, \"%.4096La\", ld)\n+\n+/* Verify that the result of formatting an unknown string isn't optimized\n+   into a non-negative range.  The string could be longer that 4,095 bytes,\n+   resulting in the formatting function having undefined behavior (and\n+   returning a negative value as Glibc can for some directives).  */\n+RNG (0,  INT_MAX, -1, \"%-s\", str);\n+\n /* Verify the result of a conditional expression involving a string\n    literal and an unknown string isn't optimized.  */\n RNG (0,  1,   4, \"%-s\", i ? str : \"123\");\n RNG (0,  1,   4, \"%-s\", i ? \"123\" : str);\n \n+/* Verfy that the output involving wide strings is not optimized\n+   (the output is actually bounded by a function of MB_LEN_MAX\n+   which should be at least 6 to accommodate UTF-8 but this isn't\n+   implemented yet).  */\n+RNG (0,  5,   7, \"%ls\",   L\"1\");\n+RNG (0,  6,   8, \"%s%ls\", \"1\", L\"2\");\n+\n /* Verify that no call to abort has been eliminated and that each call\n    is at the beginning of a basic block (and thus the result of a branch).\n    This latter test tries to verify that the test preceding the call to\n@@ -214,5 +252,5 @@ RNG (0,  1,   4, \"%-s\", i ? \"123\" : str);\n \n */\n \n-/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 105 \"optimized\" { target { ilp32 || lp64 } } } } */\n-/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 74 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } } */\n+/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 114 \"optimized\" { target { ilp32 || lp64 } } } } */\n+/* { dg-final { scan-tree-dump-times \">:\\n *__builtin_abort\" 83 \"optimized\" { target { { ! ilp32 } && { ! lp64 } } } } } */"}, {"sha": "5779a95f8df3db01583d951a972e540cafb36bee", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-1.c", "status": "modified", "additions": 78, "deletions": 19, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-1.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -37,6 +37,18 @@ typedef __WINT_TYPE__ wint_t;\n \n typedef unsigned char UChar;\n \n+/* Constants used to verify the pass can determine their values even\n+   without optimization.  */\n+const int cst0   =  0;\n+const int cst1   =  1;\n+const int cst10  = 10;\n+\n+/* Initialized global variables used to verify that the pass doesn't\n+   use their initial values (they could be modified by calls to other\n+   functions).  */\n+int var0  =  0;\n+int var10 = 10;\n+\n const char s0[] = \"\";\n const char s1[] = \"1\";\n const char s2[] = \"12\";\n@@ -372,6 +384,13 @@ void test_sprintf_chk_s_const (void)\n   T (3, \"%.0ls\",    L\"1\");\n   T (3, \"%.1ls\",    L\"1\");\n   T (3, \"%.2ls\",    L\"1\");\n+  T (3, \"%ls\",      L\"12\");\n+\n+  T (3, \"%ls\",      L\"123\");    /* { dg-warning \"nul past the end\" } */\n+  T (3, \"%.0ls\",    L\"123\");\n+  T (3, \"%.1ls\",    L\"123\");\n+  T (3, \"%.2ls\",    L\"123\");\n+  T (3, \"%.3ls\",    L\"123\");    /* { dg-warning \"nul past the end\" } */\n }\n \n /* Exercise the \"%hhd\", \"%hhi\", \"%hho\", \"%hhu\", and \"%hhx\" directives\n@@ -382,7 +401,9 @@ void test_sprintf_chk_hh_const (void)\n   T (-1, \"%hhd\",        0);\n \n   T (1, \"%hhd\",         0);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhd\",      cst0);     /* { dg-warning \"nul past the end\" } */\n   T (1, \"%hhd\",         1);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhd\",      cst1);     /* { dg-warning \"nul past the end\" } */\n   T (1, \"%hhd\",        -1);     /* { dg-warning \"into a region\" } */\n   T (1, \"%+hhd\",        0);     /* { dg-warning \"into a region\" } */\n   T (1, \"%+hhd\",        1);     /* { dg-warning \"into a region\" } */\n@@ -402,6 +423,7 @@ void test_sprintf_chk_hh_const (void)\n   T (2, \"%+hhi\",        9);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"%-hhi\",        9);\n   T (2, \"%hhi\",        10);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%hhi\",     cst10);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"%hhi\",        -1);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"% hhi\",       -1);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"%+hhi\",       -1);     /* { dg-warning \"nul past the end\" } */\n@@ -863,6 +885,35 @@ void test_sprintf_chk_z_const (void)\n   T ( 2, \"%zu\",        (size_t)10); /* { dg-warning \"nul past the end\" } */\n }\n \n+void test_sprintf_chk_a_const (void)\n+{\n+  T (-1, \"%a\",  0.0);\n+  T (-1, \"%la\", 0.0);\n+\n+  /* The least number of bytes on output is 6 for \"0x0p+0\".  When precision\n+     is missing the number of digits after the decimal point isn't fully\n+     specified by C (it seems like a defect).  */\n+  T (0, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (0, \"%la\",  0.0);          /* { dg-warning \"into a region\" } */\n+  T (1, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (2, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (3, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (4, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (5, \"%a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (6, \"%a\",   0.0);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (7, \"%a\",   0.0);\n+\n+  T (0, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (0, \"%.0la\",  0.0);          /* { dg-warning \"into a region\" } */\n+  T (1, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (2, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (3, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (4, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (5, \"%.0a\",   0.0);          /* { dg-warning \"into a region\" } */\n+  T (6, \"%.0a\",   0.0);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (7, \"%.0a\",   0.0);\n+}\n+\n void test_sprintf_chk_e_const (void)\n {\n   T (-1, \"%E\",   0.0);\n@@ -893,20 +944,23 @@ void test_sprintf_chk_e_const (void)\n   T ( 6, \"%.0e\", 1.0);\n \n   /* The actual output of the following directives depends on the rounding\n-     mode.  Verify that the warning correctly reflects that.  */\n-  T (12, \"%e\",  9.999999e+99);  /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%e\",  9.9999994e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%e\",  9.9999995e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%e\",  9.9999996e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%e\",  9.9999997e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%e\",  9.9999998e+99); /* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-\n-  T (12, \"%Le\", 9.9999994e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%Le\", 9.9999995e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%Le\", 9.9999996e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%Le\", 9.9999997e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%Le\", 9.9999998e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n-  T (12, \"%Le\", 9.9999999e+99L);/* { dg-warning \"directive writing between 12 and 13 bytes\" } */\n+     mode.  Verify that the warning correctly reflects that.  At level 1,\n+     since the minimum number of bytes output by the directive fits the\n+     space the directive itself isn't diagnosed but the terminating nul\n+     is.  The directive is diagnosed at level 2.  */\n+  T (12, \"%e\",  9.999999e+99);  /* { dg-warning \"terminating nul\" } */\n+  T (12, \"%e\",  9.9999994e+99); /* { dg-warning \"terminating nul\" } */\n+  T (12, \"%e\",  9.9999995e+99); /* { dg-warning \"terminating nul\" } */\n+  T (12, \"%e\",  9.9999996e+99); /* { dg-warning \"terminating nul\" } */\n+  T (12, \"%e\",  9.9999997e+99); /* { dg-warning \"terminating nul\" } */\n+  T (12, \"%e\",  9.9999998e+99); /* { dg-warning \"terminating nul\" } */\n+\n+  T (12, \"%Le\", 9.9999994e+99L);/* { dg-warning \"terminating nul\" } */\n+  T (12, \"%Le\", 9.9999995e+99L);/* { dg-warning \"terminating nul\" } */\n+  T (12, \"%Le\", 9.9999996e+99L);/* { dg-warning \"terminating nul\" } */\n+  T (12, \"%Le\", 9.9999997e+99L);/* { dg-warning \"terminating nul\" } */\n+  T (12, \"%Le\", 9.9999998e+99L);/* { dg-warning \"terminating nul\" } */\n+  T (12, \"%Le\", 9.9999999e+99L);/* { dg-warning \"terminating nul\" } */\n }\n \n /* At -Wformat-length level 1 unknown numbers are assumed to have\n@@ -936,12 +990,14 @@ void test_sprintf_chk_hh_nonconst (int a)\n {\n   T (-1, \"%hhd\",        a);\n \n-  T (0, \"%hhd\",         a);     /* { dg-warning \"into a region\" } */\n+  T (0, \"%hhd\",         a);     /* { dg-warning \".%hhd. directive writing between 1 and . bytes into a region of size 0\" } */\n+  T (0, \"%hhi\",      var0);     /* { dg-warning \"into a region\" } */\n   T (0, \"%hhi\",         a);     /* { dg-warning \"into a region\" } */\n   T (0, \"%hhu\",         a);     /* { dg-warning \"into a region\" } */\n   T (0, \"%hhx\",         a);     /* { dg-warning \"into a region\" } */\n \n   T (1, \"%hhd\",         a);     /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%hhd\",      var0);     /* { dg-warning \"nul past the end\" } */\n   T (1, \"%hhi\",         a);     /* { dg-warning \"nul past the end\" } */\n   T (1, \"%hhu\",         a);     /* { dg-warning \"nul past the end\" } */\n   T (1, \"%hhx\",         a);     /* { dg-warning \"nul past the end\" } */\n@@ -954,19 +1010,23 @@ void test_sprintf_chk_hh_nonconst (int a)\n   T (1, \"%-hhi\",        a);     /* { dg-warning \"nul past the end\" } */\n \n   T (2, \"%hhd\",         a);\n+  T (2, \"%hhd\",      var0);\n+  T (2, \"%hhd\",     var10);\n   T (2, \"%hhi\",         a);\n   T (2, \"%hho\",         a);\n   T (2, \"%hhu\",         a);\n   T (2, \"%hhx\",         a);\n \n   T (2, \"% hhd\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hhd\",     var0);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"% hhd\",    var10);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"% hhi\",        a);     /* { dg-warning \"nul past the end\" } */\n   T (2, \"% hho\",        a);     /* { dg-warning \". . flag used with .%o.\" } */\n   T (2, \"% hhu\",        a);     /* { dg-warning \". . flag used with .%u.\" } */\n   T (2, \"% hhx\",        a);     /* { dg-warning \". . flag used with .%x.\" } */\n \n-  T (2, \"#%hho\",        a);     /* { dg-warning \"nul past the end\" } */\n-  T (2, \"#%hhx\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%#hho\",        a);     /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%#hhx\",        a);     /* { dg-warning \".%#hhx. directive writing between 3 and . bytes into a region of size 2\" } */\n \n   T (3, \"%2hhd\",        a);\n   T (3, \"%2hhi\",        a);\n@@ -1086,8 +1146,7 @@ void test_sprintf_chk_e_nonconst (double d)\n   T ( 1, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n   T ( 2, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n   T ( 3, \"%e\",          d);           /* { dg-warning \"into a region\" } */\n-  T (12, \"%e\",          d);           /* { dg-warning \"past the end\" } */\n-  T (12, \"%e\",          d);           /* { dg-warning \"past the end\" } */\n+  T (12, \"%e\",          d);           /* { dg-warning \"nul past the end\" } */\n   T (13, \"%E\",          d);           /* 1.000000E+00 */\n   T (13, \"%e\",          d);\n   T (14, \"%E\",          d);"}, {"sha": "e19768e1b65d8fb3c580ab08969ef3bd1f01e59b", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-2.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-2.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -47,10 +47,13 @@ void test_s_const (void)\n   T (1, \"%*ls\",  0, L\"\\0\");\n   T (1, \"%*ls\",  1, L\"\");       /* { dg-warning \"nul past the end\" } */\n \n-  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (1, \"%ls\",      L\"1\");      /* { dg-warning \"directive writing between 1 and 6 bytes into a region of size 1\" } */\n   T (1, \"%.0ls\",    L\"1\");\n   T (2, \"%.0ls\",    L\"1\");\n   T (2, \"%.1ls\",    L\"1\");\n+  T (2, \"%.2ls\",    L\"1\");      /* { dg-warning \"nul past the end\" } */\n+  T (2, \"%.3ls\",    L\"1\");      /* { dg-warning \"directive writing between 1 and 3 bytes into a region of size 2\" } */\n+  T (2, \"%.2ls\",    L\"12\");     /* { dg-warning \"nul past the end\" } */\n \n   /* The \"%.2ls\" directive below will write at a minimum 1 byte (because\n      L\"1\" is known and can be assumed to convert to at least one multibyte\n@@ -64,6 +67,12 @@ void test_s_const (void)\n   T (2, \"%.0ls\",    L\"1\");\n   T (2, \"%.1ls\",    L\"1\");\n   T (3, \"%.2ls\",    L\"1\");\n+  T (3, \"%.2ls\",    L\"12\");\n+  T (3, \"%.3ls\",    L\"12\");     /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%.3ls\",    L\"123\");\n+  T (4, \"%.4ls\",    L\"123\");    /* { dg-warning \"nul past the end\" } */\n+  T (4, \"%.5ls\",    L\"123\");    /* { dg-warning \"directive writing between 3 and 5 bytes into a region of size 4\" } */\n+  T (4, \"%.6ls\",    L\"123\");    /* { dg-warning \"directive writing between 3 and 6 bytes into a region of size 4\" } */\n }\n \n \n@@ -86,7 +95,9 @@ void test_s_nonconst (const char *s, const wchar_t *ws, struct Arrays *a)\n   T (1, \"%.0s\", s);\n   T (1, \"%.1s\", s);             /* { dg-warning \"writing a terminating nul\" } */\n \n-  T (1, \"%ls\",  ws);            /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%.0ls\",  ws);\n+  T (1, \"%.1ls\",  ws);          /* { dg-warning \"writing a terminating nul\" } */\n+  T (1, \"%ls\",    ws);          /* { dg-warning \"writing a terminating nul\" } */\n \n   /* Verify that the size of the array is used in lieu of its length.\n      The minus sign disables GCC's sprintf to strcpy transformation.  */"}, {"sha": "8d97fa879abc812649a6b022134fa7c69df095d4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-3.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-3.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -175,9 +175,9 @@ void test_sprintf_chk_range_schar (signed char *a)\n   T ( 3, \"%i\",  R (  0, 100));  /* { dg-warning \"may write a terminating nul past the end of the destination\" } */\n \n   /* The following call may write as few as 3 bytes and as many as 5.\n-     It's judgment call how best to diagnose it to make the potential\n+     It's a judgment call how best to diagnose it to make the potential\n      problem clear.  */\n-  T ( 3, \"%i%i\", R (1, 10), R (9, 10));   /* { dg-warning \".%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+  T ( 3, \"%i%i\", R (1, 10), R (9, 10));   /* { dg-warning \"may write a terminating nul past the end|.%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n \n   T ( 4, \"%i%i\", R (10, 11), R (12, 13));   /* { dg-warning \"nul past the end\" } */\n \n@@ -187,7 +187,7 @@ void test_sprintf_chk_range_schar (signed char *a)\n   T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 9), R (0, 10));  /* { dg-warning \"may write a terminating nul past the end\" } */\n   T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n   T ( 6, \"%i_%i_%i\", R (0, 10), R (0, 9), R (0, 9));  /* { dg-warning \"may write a terminating nul past the end\" } */\n-  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \".%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n+  T ( 6, \"%i_%i_%i\", R (0, 9), R (0, 10), R (0, 10)); /* { dg-warning \"may write a terminating nul past the end|.%i. directive writing between 1 and 2 bytes into a region of size 1\" } */\n }\n \n void test_sprintf_chk_range_uchar (unsigned char *a, unsigned char *b)"}, {"sha": "faa5806aa52b3255f12fc55377f1dfd9cc870fbf", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-4.c", "status": "modified", "additions": 77, "deletions": 17, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-4.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -3,31 +3,91 @@\n \n extern int sprintf (char*, const char*, ...);\n \n-char dst [8];\n+char dst [3];\n \n void test (void)\n {\n-  sprintf (dst + 7, \"%-s\", \"1\");\n-  /* { dg-warning \"writing a terminating nul past the end of the destination\" \"\" { target *-*-* } 10 }\n-     { dg-message \"format output 2 bytes into a destination of size 1\" \"\" { target *-*-* } 10 }\n-     { dg-begin-multiline-output \"\" }\n-   sprintf (dst + 7, \"%-s\", \"1\");\n-                      ~~^~\n-     { dg-end-multiline-output \"\" }\n-     { dg-begin-multiline-output \"\" }\n-   sprintf (dst + 7, \"%-s\", \"1\");\n+  /* Verify thet the caret points to the (invisible) nul character\n+     at the end of the format string (i.e., its closing quote).\n+     The redundant argument is there to get around GCC bug 77799.  */\n+  sprintf (dst + 2, \"1\", 0);\n+  /* { dg-warning \"writing a terminating nul past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n+     { dg-message \"format output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n+   sprintf (dst + 2, \"1\", 0);\n+                     ^~~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"-Wformat-length output\" }\n+   sprintf (dst + 2, \"1\", 0);\n+                      ~^\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"note\" }\n+   sprintf (dst + 2, \"1\", 0);\n+   ^~~~~~~~~~~~~~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* Verify thet the caret points at the first format character written\n+     past the end of the destination.  */\n+  sprintf (dst, \"1234\", 0);\n+  /* { dg-warning \"writing format character .4. at offset 3 past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n+     { dg-message \"format output 5 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n+     { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n+   sprintf (dst, \"1234\", 0);\n+                 ^~~~~~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"-Wformat-length output\" }\n+   sprintf (dst, \"1234\", 0);\n+                     ^\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"note\" }\n+   sprintf (dst, \"1234\", 0);\n+   ^~~~~~~~~~~~~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* Verify thet the caret points at the first format character written\n+     past the end of the destination and the rest of the format string\n+     is underlined.  */\n+  sprintf (dst, \"12345\", 0);\n+  /* { dg-warning \"writing format character .4. at offset 3 past the end of the destination\" \"nul warning\" { target *-*-* } .-1 }\n+     { dg-message \"format output 6 bytes into a destination of size 3\" \"note\" { target *-*-* } .-2 }\n+     { dg-begin-multiline-output \"-Wformat output: redundant argument\" }\n+   sprintf (dst, \"12345\", 0);\n+                 ^~~~~~~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"-Wformat-length output\" }\n+   sprintf (dst, \"12345\", 0);\n+                     ^~\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"note\" }\n+   sprintf (dst, \"12345\", 0);\n+   ^~~~~~~~~~~~~~~~~~~~~~~~~\n+     { dg-end-multiline-output \"\" } */\n+\n+  /* Same as above but with a directive.  The minus flag is used to\n+     get around GCC bug 77671.  */\n+  sprintf (dst + 2, \"%-s\", \"1\");\n+  /* { dg-warning \"writing a terminating nul past the end of the destination\" \"warning\" { target *-*-* } .-1 }\n+     { dg-message \"format output 2 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-begin-multiline-output \"-Wformat-length output\" }\n+   sprintf (dst + 2, \"%-s\", \"1\");\n+                      ~~~^\n+     { dg-end-multiline-output \"\" }\n+     { dg-begin-multiline-output \"note\" }\n+   sprintf (dst + 2, \"%-s\", \"1\");\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    { dg-end-multiline-output \"\" } */\n \n-  sprintf (dst + 7, \"%-s\", \"abcd\");\n-  /* { dg-warning \".%-s. directive writing 4 bytes into a region of size 1\" \"\" { target *-*-* } 22 }\n-     { dg-message \"format output 5 bytes into a destination of size 1\" \"\" { target *-*-* } 22 }\n-     { dg-begin-multiline-output \"\" }\n-   sprintf (dst + 7, \"%-s\", \"abcd\");\n+  sprintf (dst + 2, \"%-s\", \"abcd\");\n+  /* { dg-warning \".%-s. directive writing 4 bytes into a region of size 1\" \"warning\" { target *-*-* } .-1 }\n+     { dg-message \"format output 5 bytes into a destination of size 1\" \"note\" { target *-*-* } .-2 }\n+     { dg-begin-multiline-output \"-Wformat-length output\" }\n+   sprintf (dst + 2, \"%-s\", \"abcd\");\n                       ^~~   ~~~~~~\n      { dg-end-multiline-output \"\" }\n-     { dg-begin-multiline-output \"\" }\n-   sprintf (dst + 7, \"%-s\", \"abcd\");\n+     { dg-begin-multiline-output \"note\" }\n+   sprintf (dst + 2, \"%-s\", \"abcd\");\n    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n     { dg-end-multiline-output \"\" } */\n }\n+\n+/* { dg-prune-output \"too many arguments for format\" } */"}, {"sha": "0cb02b78e81114d16cf9b32fb21f77066f3cf926", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-6.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -88,5 +88,5 @@ void fllong (long j, char *p)\n   if (k > 999)\n     return;\n \n-  snprintf (p, 4, \"%3llu\", k);   /* { dg-bogus \"\" \"unsigned long long\" { xfail *-*-* } } */\n+  snprintf (p, 4, \"%3llu\", k);   /* { dg-bogus \"\" \"unsigned long long\" { xfail lp64 } } */\n }"}, {"sha": "916df79bb9b3e554e573f0d69e98d6a258aa9dcc", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf.c?ref=1eb4547b1058d6a4e1912ac0f15cc0a69bf4fd78", "patch": "@@ -359,23 +359,27 @@ test_x (unsigned char uc, unsigned short us, unsigned ui)\n }\n \n static void __attribute__ ((noinline, noclone))\n-test_a_double (void)\n+test_a_double (double d)\n {\n-  EQL ( 6,  7, \"%a\",   0.0);        /* 0x0p+0 */\n-  EQL ( 6,  7, \"%a\",   1.0);        /* 0x8p-3 */\n-  EQL ( 6,  7, \"%a\",   2.0);        /* 0x8p-2 */\n-\n+  EQL ( 6,  7, \"%.0a\", 0.0);        /* 0x0p+0 */\n+  EQL ( 6,  7, \"%.0a\", 1.0);        /* 0x8p-3 */\n+  EQL ( 6,  7, \"%.0a\", 2.0);        /* 0x8p-2 */\n   EQL ( 8,  9, \"%.1a\", 3.0);        /* 0xc.0p-2 */\n-  EQL ( 9, 10, \"%.2a\", 4.0);        /* 0xa.00p-1 */\n+  EQL ( 9, 10, \"%.2a\", 4.0);        /* 0x8.00p-1 */\n+  EQL (10, 11, \"%.3a\", 5.0);        /* 0xa.000p-1 */\n+\n+\t                            /* d is in [ 0, -DBL_MAX ] */\n+  RNG ( 6, 10, 11, \"%.0a\", d);      /* 0x0p+0 ... -0x2p+1023 */\n+  RNG ( 6, 12, 13, \"%.1a\", d);      /* 0x0p+0 ... -0x2.0p+1023 */\n+  RNG ( 6, 13, 14, \"%.2a\", d);      /* 0x0p+0 ... -0x2.00p+1023 */\n }\n \n static void __attribute__ ((noinline, noclone))\n test_a_long_double (void)\n {\n-  EQL ( 6,  7, \"%La\",   0.0L);      /* 0x0p+0 */\n-  EQL ( 6,  7, \"%La\",   1.0L);      /* 0x8p-3 */\n-  EQL ( 6,  7, \"%La\",   2.0L);      /* 0x8p-2 */\n-\n+  EQL ( 6,  7, \"%.0La\", 0.0L);      /* 0x0p+0 */\n+  EQL ( 6,  7, \"%.0La\", 1.0L);      /* 0x8p-3 */\n+  EQL ( 6,  7, \"%.0La\", 2.0L);      /* 0x8p-2 */\n   EQL ( 8,  9, \"%.1La\", 3.0L);      /* 0xc.0p-2 */\n   EQL ( 9, 10, \"%.2La\", 4.0L);      /* 0xa.00p-1 */\n }\n@@ -525,7 +529,7 @@ int main (void)\n   test_d_i (0xdeadbeef, 0xdeadbeefL);\n   test_x ('?', 0xdead, 0xdeadbeef);\n \n-  test_a_double ();\n+  test_a_double (0.0);\n   test_e_double ();\n   test_f_double ();\n "}]}