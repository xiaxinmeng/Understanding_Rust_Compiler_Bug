{"sha": "7813b280435f2e19c53df9f8b04a3d28bb561aa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgxM2IyODA0MzVmMmUxOWM1M2RmOWY4YjA0YTNkMjhiYjU2MWFhOA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2017-06-29T09:21:57Z"}, "committer": {"name": "Michael Collison", "email": "collison@gcc.gnu.org", "date": "2017-06-29T09:21:57Z"}, "message": "re PR target/70119 (AArch64 should take advantage of implicit truncation of variable shift amount without defining SHIFT_COUNT_TRUNCATED)\n\n2017-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\tPR target/70119\n\t* config/aarch64/aarch64.md (*aarch64_<optab>_reg_<mode>3_mask1):\n\tNew pattern.\n\t(*aarch64_reg_<mode>3_neg_mask2): New pattern.\n\t(*aarch64_reg_<mode>3_minus_mask): New pattern.\n\t(*aarch64_<optab>_reg_di3_mask2): New pattern.\n\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Account for cost\n\tof shift when the shift amount is masked with constant equal to\n\tthe size of the mode.\n\t* config/aarch64/predicates.md (subreg_lowpart_operator): New\n\tpredicate.\n\n\n2017-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\tPR target/70119\n\t* gcc.target/aarch64/var_shift_mask_1.c: New test.\n\nCo-Authored-By: Michael Collison <michael.collison@arm.com>\n\nFrom-SVN: r249774", "tree": {"sha": "98563d3d1aa4ffabc13c0d3178f3f9ad5dfe9233", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/98563d3d1aa4ffabc13c0d3178f3f9ad5dfe9233"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7813b280435f2e19c53df9f8b04a3d28bb561aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7813b280435f2e19c53df9f8b04a3d28bb561aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7813b280435f2e19c53df9f8b04a3d28bb561aa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7813b280435f2e19c53df9f8b04a3d28bb561aa8/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "696bafe61327dbf2ce2dee7262af8f18b23fcfa1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/696bafe61327dbf2ce2dee7262af8f18b23fcfa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/696bafe61327dbf2ce2dee7262af8f18b23fcfa1"}], "stats": {"total": 227, "additions": 213, "deletions": 14}, "files": [{"sha": "17feaec7574a1ddf23921ec7bb3cf19b23a6935b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -1,3 +1,18 @@\n+2017-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\tPR target/70119\n+\t* config/aarch64/aarch64.md (*aarch64_<optab>_reg_<mode>3_mask1):\n+\tNew pattern.\n+\t(*aarch64_reg_<mode>3_neg_mask2): New pattern.\n+\t(*aarch64_reg_<mode>3_minus_mask): New pattern.\n+\t(*aarch64_<optab>_reg_di3_mask2): New pattern.\n+\t* config/aarch64/aarch64.c (aarch64_rtx_costs): Account for cost\n+\tof shift when the shift amount is masked with constant equal to\n+\tthe size of the mode.\n+\t* config/aarch64/predicates.md (subreg_lowpart_operator): New\n+\tpredicate.\n+\n 2017-06-29  Martin Liska  <mliska@suse.cz>\n \n \t* config/i386/i386.opt: Change range from [1,5] to [0,5]."}, {"sha": "5cf41fc0606cc73ae975827258a94ad23ec9cb46", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -7541,17 +7541,26 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n         }\n       else\n         {\n-\t  if (speed)\n+\t  if (VECTOR_MODE_P (mode))\n \t    {\n-\t      if (VECTOR_MODE_P (mode))\n-\t\t{\n-\t\t  /* Vector shift (register).  */\n-\t\t  *cost += extra_cost->vect.alu;\n-\t\t}\n-\t      else\n+\t      if (speed)\n+\t\t/* Vector shift (register).  */\n+\t\t*cost += extra_cost->vect.alu;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (speed)\n+\t\t/* LSLV.  */\n+\t\t*cost += extra_cost->alu.shift_reg;\n+\n+\t      if (GET_CODE (op1) == AND && REG_P (XEXP (op1, 0))\n+\t\t  && CONST_INT_P (XEXP (op1, 1))\n+\t\t  && INTVAL (XEXP (op1, 1)) == GET_MODE_BITSIZE (mode) - 1)\n \t\t{\n-\t\t  /* LSLV.  */\n-\t\t  *cost += extra_cost->alu.shift_reg;\n+\t\t  *cost += rtx_cost (op0, mode, (rtx_code) code, 0, speed);\n+\t\t  /* We already demanded XEXP (op1, 0) to be REG_P, so\n+\t\t     don't recurse into it.  */\n+\t\t  return true;\n \t\t}\n \t    }\n \t  return false;  /* All arguments need to be in registers.  */\n@@ -7580,14 +7589,27 @@ aarch64_rtx_costs (rtx x, machine_mode mode, int outer ATTRIBUTE_UNUSED,\n \t}\n       else\n \t{\n-\n-\t  /* ASR (register) and friends.  */\n-\t  if (speed)\n+\t  if (VECTOR_MODE_P (mode))\n \t    {\n-\t      if (VECTOR_MODE_P (mode))\n+\t      if (speed)\n+\t\t/* Vector shift (register).  */\n \t\t*cost += extra_cost->vect.alu;\n-\t      else\n+\t    }\n+\t  else\n+\t    {\n+\t      if (speed)\n+\t\t/* ASR (register) and friends.  */\n \t\t*cost += extra_cost->alu.shift_reg;\n+\n+\t      if (GET_CODE (op1) == AND && REG_P (XEXP (op1, 0))\n+\t\t  && CONST_INT_P (XEXP (op1, 1))\n+\t\t  && INTVAL (XEXP (op1, 1)) == GET_MODE_BITSIZE (mode) - 1)\n+\t\t{\n+\t\t  *cost += rtx_cost (op0, mode, (rtx_code) code, 0, speed);\n+\t\t  /* We already demanded XEXP (op1, 0) to be REG_P, so\n+\t\t     don't recurse into it.  */\n+\t\t  return true;\n+\t\t}\n \t    }\n \t  return false;  /* All arguments need to be in registers.  */\n \t}"}, {"sha": "e6e7e64390ca081144a8b013070b5cddc0a165cb", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -3942,6 +3942,97 @@\n   }\n )\n \n+;; When the LSL, LSR, ASR, ROR instructions operate on all register arguments\n+;; they truncate the shift/rotate amount by the size of the registers they\n+;; operate on: 32 for W-regs, 64 for X-regs.  This allows us to optimise away\n+;; such redundant masking instructions.  GCC can do that automatically when\n+;; SHIFT_COUNT_TRUNCATED is true, but we can't enable it for TARGET_SIMD\n+;; because some of the SISD shift alternatives don't perform this truncations.\n+;; So this pattern exists to catch such cases.\n+\n+(define_insn \"*aarch64_<optab>_reg_<mode>3_mask1\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=r\")\n+\t(SHIFT:GPI\n+\t  (match_operand:GPI 1 \"register_operand\" \"r\")\n+\t  (match_operator 4 \"subreg_lowpart_operator\"\n+\t   [(and:GPI (match_operand:GPI 2 \"register_operand\" \"r\")\n+\t\t     (match_operand 3 \"const_int_operand\" \"n\"))])))]\n+  \"(~INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode) - 1)) == 0\"\n+  \"<shift>\\t%<w>0, %<w>1, %<w>2\"\n+  [(set_attr \"type\" \"shift_reg\")]\n+)\n+\n+(define_insn_and_split \"*aarch64_reg_<mode>3_neg_mask2\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=&r\")\n+\t(SHIFT:GPI\n+\t  (match_operand:GPI 1 \"register_operand\" \"r\")\n+\t  (match_operator 4 \"subreg_lowpart_operator\"\n+\t  [(neg:SI (and:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t\t   (match_operand 3 \"const_int_operand\" \"n\")))])))]\n+  \"((~INTVAL (operands[3]) & (GET_MODE_BITSIZE (<MODE>mode) - 1)) == 0)\"\n+  \"#\"\n+  \"&& true\"\n+  [(const_int 0)]\n+  {\n+    rtx tmp = (can_create_pseudo_p () ? gen_reg_rtx (SImode)\n+\t       : operands[0]);\n+    emit_insn (gen_negsi2 (tmp, operands[2]));\n+\n+    rtx and_op = gen_rtx_AND (SImode, tmp, operands[3]);\n+    rtx subreg_tmp = gen_rtx_SUBREG (GET_MODE (operands[4]), and_op,\n+\t\t\t\t     SUBREG_BYTE (operands[4]));\n+    emit_insn (gen_<optab><mode>3 (operands[0], operands[1], subreg_tmp));\n+    DONE;\n+  }\n+)\n+\n+(define_insn_and_split \"*aarch64_reg_<mode>3_minus_mask\"\n+  [(set (match_operand:GPI 0 \"register_operand\" \"=&r\")\n+\t(ashift:GPI\n+\t  (match_operand:GPI 1 \"register_operand\" \"r\")\n+\t  (minus:QI (match_operand 2 \"const_int_operand\" \"n\")\n+\t\t    (match_operator 5 \"subreg_lowpart_operator\"\n+\t\t    [(and:SI (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t     (match_operand 4 \"const_int_operand\" \"n\"))]))))]\n+  \"((~INTVAL (operands[4]) & (GET_MODE_BITSIZE (<MODE>mode) - 1)) == 0)\n+   && INTVAL (operands[2]) == GET_MODE_BITSIZE (<MODE>mode)\"\n+  \"#\"\n+  \"&& true\"\n+  [(const_int 0)]\n+  {\n+    rtx tmp = (can_create_pseudo_p () ? gen_reg_rtx (SImode)\n+\t       : operands[0]);\n+\n+    emit_insn (gen_negsi2 (tmp, operands[3]));\n+\n+    rtx and_op = gen_rtx_AND (SImode, tmp, operands[4]);\n+    rtx subreg_tmp = gen_rtx_SUBREG (GET_MODE (operands[5]), and_op,\n+\t\t\t\t     SUBREG_BYTE (operands[5]));\n+\n+    emit_insn (gen_ashl<mode>3 (operands[0], operands[1], subreg_tmp));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"*aarch64_<optab>_reg_di3_mask2\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(SHIFT:DI\n+\t  (match_operand:DI 1 \"register_operand\" \"r\")\n+\t  (match_operator 4 \"subreg_lowpart_operator\"\n+\t   [(and:SI (match_operand:SI 2 \"register_operand\" \"r\")\n+\t\t     (match_operand 3 \"aarch64_shift_imm_di\" \"Usd\"))])))]\n+  \"((~INTVAL (operands[3]) & (GET_MODE_BITSIZE (DImode)-1)) == 0)\"\n+{\n+  rtx xop[3];\n+  xop[0] = operands[0];\n+  xop[1] = operands[1];\n+  xop[2] = gen_lowpart (GET_MODE (operands[4]), operands[2]);\n+  output_asm_insn (\"<shift>\\t%x0, %x1, %x2\", xop);\n+  return \"\";\n+}\n+  [(set_attr \"type\" \"shift_reg\")]\n+)\n+\n ;; Logical left shift using SISD or Integer instruction\n (define_insn \"*aarch64_ashl_sisd_or_int_<mode>3\"\n   [(set (match_operand:GPI 0 \"register_operand\" \"=r,r,w,w\")"}, {"sha": "ad8a43c2b2cda559983a313bdba5623fd68e43cd", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -35,6 +35,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"op == CONST0_RTX (mode)\")))\n \n+(define_special_predicate \"subreg_lowpart_operator\"\n+  (and (match_code \"subreg\")\n+       (match_test \"subreg_lowpart_p (op)\")))\n+\n (define_predicate \"aarch64_ccmp_immediate\"\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE (INTVAL (op), -31, 31)\")))"}, {"sha": "54a2bc134a80d218e90469b8fecccb4c90d5ec6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -1,3 +1,9 @@\n+2016-06-29  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\tPR target/70119\n+\t* gcc.target/aarch64/var_shift_mask_1.c: New test.\n+\n 2017-06-28  Sebastian Peryt  <sebastian.peryt@intel.com>\n \n \t* gcc.target/i386/avx512vl-vpermd-1.c (_mm256_permutexvar_epi32):"}, {"sha": "e2b020ef3c41c6b626d479ecbbbfaac8cccde0c7", "filename": "gcc/testsuite/gcc.target/aarch64/var_shift_mask_1.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvar_shift_mask_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7813b280435f2e19c53df9f8b04a3d28bb561aa8/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvar_shift_mask_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fvar_shift_mask_1.c?ref=7813b280435f2e19c53df9f8b04a3d28bb561aa8", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+\n+/* The integer variable shift and rotate instructions truncate their\n+   shift amounts by the datasize.  Make sure that we don't emit a redundant\n+   masking operation.  */\n+\n+unsigned\n+f1 (unsigned x, int y)\n+{\n+  return x << (y & 31);\n+}\n+\n+unsigned long\n+f2 (unsigned long x, int y)\n+{\n+  return x << (y & 63);\n+}\n+\n+unsigned long\n+f3 (unsigned long bit_addr, int y)\n+{\n+  unsigned long bitnumb = bit_addr & 63;\n+  return (1L << bitnumb);\n+}\n+\n+unsigned int\n+f4 (unsigned int x, unsigned int y)\n+{\n+  y &= 31;\n+  return x >> y | (x << (32 - y));\n+}\n+\n+unsigned long\n+f5 (unsigned long x, unsigned long y)\n+{\n+  y &= 63;\n+  return x >> y | (x << (64 - y));\n+}\n+\n+unsigned long\n+f6 (unsigned long x, unsigned long y)\n+{\n+\n+  return (x << (64 - (y & 63)));\n+\n+}\n+\n+unsigned long\n+f7 (unsigned long x, unsigned long y)\n+{\n+  return (x << -(y & 63));\n+}\n+\n+/* { dg-final { scan-assembler-times \"lsl\\tw\\[0-9\\]+, w\\[0-9\\]+, w\\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"lsl\\tx\\[0-9\\]+, x\\[0-9\\]+, x\\[0-9\\]+\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ror\\tw\\[0-9\\]+, w\\[0-9\\]+, w\\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ror\\tx\\[0-9\\]+, x\\[0-9\\]+, x\\[0-9\\]+\" 1 } } */\n+/* { dg-final { scan-assembler-not \"and\\tw\\[0-9\\]+, w\\[0-9\\]+, 31\" } } */\n+/* { dg-final { scan-assembler-not \"and\\tx\\[0-9\\]+, x\\[0-9\\]+, 63\" } } */\n+/* { dg-final { scan-assembler-not \"sub\\tw\\[0-9\\]+, w\\[0-9\\]+, w\\[0-9\\]+\" } } */"}]}