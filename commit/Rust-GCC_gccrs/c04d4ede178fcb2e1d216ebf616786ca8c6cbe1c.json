{"sha": "c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA0ZDRlZGUxNzhmY2IyZTFkMjE2ZWJmNjE2Nzg2Y2E4YzZjYmUxYw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-10-15T13:14:15Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2016-10-15T13:14:15Z"}, "message": "PR 48587 Newunit allocator\n\nCurrently GFortran newer reuses unit numbers allocated with NEWUNIT=,\ninstead having a simple counter that is decremented each time such a\nunit is opened.  For a long running program which repeatedly opens\nfiles with NEWUNIT= and closes them, the counter can wrap around and\ncause an abort.  This patch replaces the counter with an allocator\nthat keeps track of which units numbers are allocated, and can reuse\nthem once they have been deallocated.  Since operating systems tend to\nlimit the number of simultaneous open files for a process to a\nrelatively modest number, a relatively simple approach with a linear\nscan through an array suffices.  Though as a small optimization there\nis a low water indicator keeping track of the index for which all unit\nnumbers below are already allocated.  This linear scan also ensures\nthat we always allocate the smallest available unit number.\n\n2016-10-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/48587\n        * io/io.h (get_unique_unit_number): Remove prototype.\n        (newunit_alloc): New prototype.\n        * io/open.c (st_open): Call newunit_alloc.\n        * io/unit.c (newunits,newunit_size,newunit_lwi): New static\n        variables.\n        (GFC_FIRST_NEWUNIT): Rename to NEWUNIT_START.\n        (next_available_newunit): Remove variable.\n        (get_unit): Call newunit_alloc, don't try to create negative\n        external unit.\n        (close_unit_1): Call newunit_free.\n        (close_units): Free newunits array.\n        (get_unique_number): Remove function.\n        (newunit_alloc): New function.\n        (newunit_free): New function.\n        * io/transfer.c (data_transfer_init): Check for invalid unit\n        number.\n\ntestsuite ChangeLog:\n\n2016-10-15  Janne Blomqvist  <jb@gcc.gnu.org>\n\n        PR libfortran/48587\n        * gfortran.dg/negative_unit2.f90: New testcase.\n\nFrom-SVN: r241199", "tree": {"sha": "05afbe2773ef57d4fffd38d55a4f9a577ac6e90f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05afbe2773ef57d4fffd38d55a4f9a577ac6e90f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/comments", "author": null, "committer": null, "parents": [{"sha": "64190f049ac8117b403b038ca35bc771132b6e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64190f049ac8117b403b038ca35bc771132b6e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64190f049ac8117b403b038ca35bc771132b6e73"}], "stats": {"total": 150, "additions": 123, "deletions": 27}, "files": [{"sha": "0e48772d7983fa9397320be88a9552a912038b51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -1,3 +1,8 @@\n+2016-10-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/48587\n+        * gfortran.dg/negative_unit2.f90: New test.\n+\n 2016-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/77959"}, {"sha": "bf7af2b4dbbbab0b2ff05dfb41ad3dc26932eacf", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -1,3 +1,23 @@\n+2016-10-15  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+        PR libfortran/48587\n+        * io/io.h (get_unique_unit_number): Remove prototype.\n+        (newunit_alloc): New prototype.\n+        * io/open.c (st_open): Call newunit_alloc.\n+        * io/unit.c (newunits,newunit_size,newunit_lwi): New static\n+        variables.\n+        (GFC_FIRST_NEWUNIT): Rename to NEWUNIT_START.\n+        (next_available_newunit): Remove variable.\n+        (get_unit): Call newunit_alloc, don't try to create negative\n+        external unit.\n+        (close_unit_1): Call newunit_free.\n+        (close_units): Free newunits array.\n+        (get_unique_number): Remove function.\n+        (newunit_alloc): New function.\n+        (newunit_free): New function.\n+        * io/transfer.c (data_transfer_init): Check for invalid unit\n+        number.\n+\n 2016-10-09  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         PR libfortran/67585"}, {"sha": "aaacc089fc7e8d2186e5aa3ac31a3d1ebe5ba344", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -715,8 +715,9 @@ internal_proto (finish_last_advance_record);\n extern int unit_truncate (gfc_unit *, gfc_offset, st_parameter_common *);\n internal_proto (unit_truncate);\n \n-extern GFC_INTEGER_4 get_unique_unit_number (st_parameter_common *);\n-internal_proto(get_unique_unit_number);\n+extern int newunit_alloc (void);\n+internal_proto(newunit_alloc);\n+\n \n /* open.c */\n "}, {"sha": "2e7163d33c61dc6363d2657c81083ce3b425d150", "filename": "libgfortran/io/open.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Fopen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Fopen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fopen.c?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -812,7 +812,7 @@ st_open (st_parameter_open *opp)\n   if ((opp->common.flags & IOPARM_LIBRETURN_MASK) == IOPARM_LIBRETURN_OK)\n     {\n       if ((opp->common.flags & IOPARM_OPEN_HAS_NEWUNIT))\n-\topp->common.unit = get_unique_unit_number(&opp->common);\n+\topp->common.unit = newunit_alloc ();\n       else if (opp->common.unit < 0)\n \t{\n \t  u = find_unit (opp->common.unit);"}, {"sha": "7696cca2306f1d0538111d54a89ff1e85f8244d8", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -2601,7 +2601,15 @@ data_transfer_init (st_parameter_dt *dtp, int read_flag)\n \n   dtp->u.p.current_unit = get_unit (dtp, 1);\n \n-  if (dtp->u.p.current_unit->s == NULL)\n+  if (dtp->u.p.current_unit == NULL)\n+    {\n+      /* This means we tried to access an external unit < 0 without\n+\t having opened it first with NEWUNIT=.  */\n+      generate_error (&dtp->common, LIBERROR_BAD_OPTION,\n+\t\t      \"Invalid unit number in statement\");\n+      return;\n+    }\n+  else if (dtp->u.p.current_unit->s == NULL)\n     {  /* Open the unit with some default flags.  */\n        st_parameter_open opp;\n        unit_convert conv;"}, {"sha": "41cd52f26063abeff66e47587b250a66831478ea", "filename": "libgfortran/io/unit.c", "status": "modified", "additions": 85, "deletions": 23, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Funit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c/libgfortran%2Fio%2Funit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Funit.c?ref=c04d4ede178fcb2e1d216ebf616786ca8c6cbe1c", "patch": "@@ -29,6 +29,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"unix.h\"\n #include <stdlib.h>\n #include <string.h>\n+#include <assert.h>\n \n \n /* IO locking rules:\n@@ -68,19 +69,42 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n    on it.  unlock_unit or close_unit must be always called only with the\n    private lock held.  */\n \n-/* Subroutines related to units */\n \n-/* Unit number to be assigned when NEWUNIT is used in an OPEN statement.  */\n-#define GFC_FIRST_NEWUNIT -10\n+\n+/* Table of allocated newunit values.  A simple solution would be to\n+   map OS file descriptors (fd's) to unit numbers, e.g. with newunit =\n+   -fd - 2, however that doesn't work since Fortran allows an existing\n+   unit number to be reassociated with a new file. Thus the simple\n+   approach may lead to a situation where we'd try to assign a\n+   (negative) unit number which already exists. Hence we must keep\n+   track of allocated newunit values ourselves. This is the purpose of\n+   the newunits array. The indices map to newunit values as newunit =\n+   -index + NEWUNIT_FIRST. E.g. newunits[0] having the value true\n+   means that a unit with number NEWUNIT_FIRST exists. Similar to\n+   POSIX file descriptors, we always allocate the lowest (in absolute\n+   value) available unit number.\n+ */\n+static bool *newunits;\n+static int newunit_size; /* Total number of elements in the newunits array.  */\n+/* Low water indicator for the newunits array. Below the LWI all the\n+   units are allocated, above and equal to the LWI there may be both\n+   allocated and free units. */\n+static int newunit_lwi;\n+static void newunit_free (int);\n+\n+/* Unit numbers assigned with NEWUNIT start from here.  */\n+#define NEWUNIT_START -10\n+\n+\n #define NEWUNIT_STACK_SIZE 16\n-static GFC_INTEGER_4 next_available_newunit = GFC_FIRST_NEWUNIT;\n \n /* A stack to save previously used newunit-assigned unit numbers to\n    allow them to be reused without reallocating the gfc_unit structure\n    which is still in the treap.  */\n static gfc_saved_unit newunit_stack[NEWUNIT_STACK_SIZE];\n static int newunit_tos = 0; /* Index to Top of Stack.  */\n \n+\n #define CACHE_SIZE 3\n static gfc_unit *unit_cache[CACHE_SIZE];\n gfc_offset max_offset;\n@@ -551,7 +575,7 @@ get_unit (st_parameter_dt *dtp, int do_create)\n       if ((dtp->common.flags & IOPARM_DT_HAS_UDTIO) != 0)\n \t{\n \t  dtp->u.p.unit_is_internal = 1;\n-\t  dtp->common.unit = get_unique_unit_number (&dtp->common);\n+\t  dtp->common.unit = newunit_alloc ();\n \t  unit = get_gfc_unit (dtp->common.unit, do_create);\n \t  set_internal_unit (dtp, unit, kind);\n \t  fbuf_init (unit, 128);\n@@ -567,7 +591,7 @@ get_unit (st_parameter_dt *dtp, int do_create)\n \t    }\n \t  else\n \t    {\n-\t      dtp->common.unit = get_unique_unit_number (&dtp->common);\n+\t      dtp->common.unit = newunit_alloc ();\n \t      unit = xcalloc (1, sizeof (gfc_unit));\n \t      fbuf_init (unit, 128);\n \t    }\n@@ -579,8 +603,12 @@ get_unit (st_parameter_dt *dtp, int do_create)\n   dtp->u.p.unit_is_internal = 0;\n   dtp->internal_unit = NULL;\n   dtp->internal_unit_desc = NULL;\n-  unit = get_gfc_unit (dtp->common.unit, do_create);\n-  return unit;\n+  /* For an external unit with unit number < 0 creating it on the fly\n+     is not allowed, such units must be created with\n+     OPEN(NEWUNIT=...).  */\n+  if (dtp->common.unit < 0)\n+    return get_gfc_unit (dtp->common.unit, 0);\n+  return get_gfc_unit (dtp->common.unit, do_create);\n }\n \n \n@@ -734,6 +762,9 @@ close_unit_1 (gfc_unit *u, int locked)\n   free_format_hash_table (u);\n   fbuf_destroy (u);\n \n+  if (u->unit_number <= NEWUNIT_START)\n+    newunit_free (u->unit_number);\n+\n   if (!locked)\n     __gthread_mutex_unlock (&u->lock);\n \n@@ -788,6 +819,9 @@ close_units (void)\n \tfree (newunit_stack[newunit_tos].unit->s);\n \tfree (newunit_stack[newunit_tos--].unit);\n       }\n+\n+  free (newunits);\n+\n #ifdef HAVE_FREELOCALE\n   freelocale (c_locale);\n #endif\n@@ -885,25 +919,53 @@ finish_last_advance_record (gfc_unit *u)\n   fbuf_flush (u, u->mode);\n }\n \n+\n /* Assign a negative number for NEWUNIT in OPEN statements or for\n    internal units.  */\n-GFC_INTEGER_4\n-get_unique_unit_number (st_parameter_common *common)\n+int\n+newunit_alloc (void)\n {\n-  GFC_INTEGER_4 num;\n-\n-#ifdef HAVE_SYNC_FETCH_AND_ADD\n-  num = __sync_fetch_and_add (&next_available_newunit, -1);\n-#else\n   __gthread_mutex_lock (&unit_lock);\n-  num = next_available_newunit--;\n-  __gthread_mutex_unlock (&unit_lock);\n-#endif\n-  /* Do not allow NEWUNIT numbers to wrap.  */\n-  if (num > GFC_FIRST_NEWUNIT)\n+  if (!newunits)\n     {\n-      generate_error (common, LIBERROR_INTERNAL, \"NEWUNIT exhausted\");\n-      return 0;\n+      newunits = xcalloc (16, 1);\n+      newunit_size = 16;\n     }\n-  return num;\n+\n+  /* Search for the next available newunit.  */\n+  for (int ii = newunit_lwi; ii < newunit_size; ii++)\n+    {\n+      if (!newunits[ii])\n+        {\n+          newunits[ii] = true;\n+          newunit_lwi = ii + 1;\n+\t  __gthread_mutex_unlock (&unit_lock);\n+          return -ii + NEWUNIT_START;\n+        }\n+    }\n+\n+  /* Search failed, bump size of array and allocate the first\n+     available unit.  */\n+  int old_size = newunit_size;\n+  newunit_size *= 2;\n+  newunits = xrealloc (newunits, newunit_size);\n+  memset (newunits + old_size, 0, old_size);\n+  newunits[old_size] = true;\n+  newunit_lwi = old_size + 1;\n+    __gthread_mutex_unlock (&unit_lock);\n+  return -old_size + NEWUNIT_START;\n+}\n+\n+\n+/* Free a previously allocated newunit= unit number.  unit_lock must\n+   be held when calling.  */\n+\n+static void\n+newunit_free (int unit)\n+{\n+  int ind = -unit + NEWUNIT_START;\n+  assert(ind >= 0 && ind < newunit_size);\n+  newunits[ind] = false;\n+  if (ind < newunit_lwi)\n+    newunit_lwi = ind;\n }"}]}