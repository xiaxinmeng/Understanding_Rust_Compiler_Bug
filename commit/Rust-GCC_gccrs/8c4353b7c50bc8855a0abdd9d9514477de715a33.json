{"sha": "8c4353b7c50bc8855a0abdd9d9514477de715a33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGM0MzUzYjdjNTBiYzg4NTVhMGFiZGQ5ZDk1MTQ0NzdkZTcxNWEzMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-09-10T13:44:07Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-09-10T13:44:07Z"}, "message": "tree.c (type_hash_eq): For ARRAY_TYPEs also compare TYPE_SIZE.\n\n2010-09-10  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.c (type_hash_eq): For ARRAY_TYPEs also compare\n\tTYPE_SIZE.\n\t(build_index_type): Implement in terms of build_range_type.\n\t(build_range_type): Do not allow NULL_TREE type, improve\n\thashing to cover more cases.  Set TYPE_STRUCTURAL_EQUALITY_P\n\tif we didn't hash.\n\t* c-decl.c (grokdeclarator): When modifying TYPE_SIZE manually\n\tcreate a distinct copy of the type.\n\nFrom-SVN: r164174", "tree": {"sha": "95b9637b447d189f3b6b054784820287a5fe2aa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95b9637b447d189f3b6b054784820287a5fe2aa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c4353b7c50bc8855a0abdd9d9514477de715a33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4353b7c50bc8855a0abdd9d9514477de715a33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c4353b7c50bc8855a0abdd9d9514477de715a33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c4353b7c50bc8855a0abdd9d9514477de715a33/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a7c764a96ca48293b863196a073eb119453e1a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c764a96ca48293b863196a073eb119453e1a3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c764a96ca48293b863196a073eb119453e1a3b"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "3f9e53d1213d5772fbbfef866c2f01213114ed35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c4353b7c50bc8855a0abdd9d9514477de715a33", "patch": "@@ -1,3 +1,14 @@\n+2010-09-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.c (type_hash_eq): For ARRAY_TYPEs also compare\n+\tTYPE_SIZE.\n+\t(build_index_type): Implement in terms of build_range_type.\n+\t(build_range_type): Do not allow NULL_TREE type, improve\n+\thashing to cover more cases.  Set TYPE_STRUCTURAL_EQUALITY_P\n+\tif we didn't hash.\n+\t* c-decl.c (grokdeclarator): When modifying TYPE_SIZE manually\n+\tcreate a distinct copy of the type.\n+\n 2010-09-10  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* configure: Regenerated."}, {"sha": "03836b5e6449fadb0476a7f2dd35dfa6eda4d9e5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=8c4353b7c50bc8855a0abdd9d9514477de715a33", "patch": "@@ -5458,6 +5458,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\tif (size && integer_zerop (size))\n \t\t  {\n \t\t    gcc_assert (itype);\n+\t\t    type = build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n \t\t    TYPE_SIZE (type) = bitsize_zero_node;\n \t\t    TYPE_SIZE_UNIT (type) = size_zero_node;\n \t\t    SET_TYPE_STRUCTURAL_EQUALITY (type);\n@@ -5466,6 +5467,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t  {\n \t\t    gcc_assert (itype);\n \t\t    /* The type is complete.  C99 6.7.5.2p4  */\n+\t\t    type = build_distinct_type_copy (TYPE_MAIN_VARIANT (type));\n \t\t    TYPE_SIZE (type) = bitsize_zero_node;\n \t\t    TYPE_SIZE_UNIT (type) = size_zero_node;\n \t\t    SET_TYPE_STRUCTURAL_EQUALITY (type);"}, {"sha": "bc2149109d6a6a70ee9add76d5980a9369b39e14", "filename": "gcc/tree.c", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c4353b7c50bc8855a0abdd9d9514477de715a33/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8c4353b7c50bc8855a0abdd9d9514477de715a33", "patch": "@@ -7034,41 +7034,6 @@ build_type_no_quals (tree t)\n     }\n }\n \n-/* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.\n-   MAXVAL should be the maximum value in the domain\n-   (one less than the length of the array).\n-\n-   The maximum value that MAXVAL can have is INT_MAX for a HOST_WIDE_INT.\n-   We don't enforce this limit, that is up to caller (e.g. language front end).\n-   The limit exists because the result is a signed type and we don't handle\n-   sizes that use more than one HOST_WIDE_INT.  */\n-\n-tree\n-build_index_type (tree maxval)\n-{\n-  tree itype = make_node (INTEGER_TYPE);\n-\n-  TREE_TYPE (itype) = sizetype;\n-  TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n-  TYPE_MIN_VALUE (itype) = size_zero_node;\n-  TYPE_MAX_VALUE (itype) = fold_convert (sizetype, maxval);\n-  SET_TYPE_MODE (itype, TYPE_MODE (sizetype));\n-  TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n-  TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (sizetype);\n-  TYPE_ALIGN (itype) = TYPE_ALIGN (sizetype);\n-  TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (sizetype);\n-\n-  if (host_integerp (maxval, 1))\n-    return type_hash_canon (tree_low_cst (maxval, 1), itype);\n-  else\n-    {\n-      /* Since we cannot hash this type, we need to compare it using\n-\t structural equality checks. */\n-      SET_TYPE_STRUCTURAL_EQUALITY (itype);\n-      return itype;\n-    }\n-}\n-\n #define MAX_INT_CACHED_PREC \\\n   (HOST_BITS_PER_WIDE_INT > 64 ? HOST_BITS_PER_WIDE_INT : 64)\n static GTY(()) tree nonstandard_integer_type_cache[2 * MAX_INT_CACHED_PREC + 2];\n@@ -7111,16 +7076,15 @@ build_nonstandard_integer_type (unsigned HOST_WIDE_INT precision,\n \n /* Create a range of some discrete type TYPE (an INTEGER_TYPE,\n    ENUMERAL_TYPE or BOOLEAN_TYPE), with low bound LOWVAL and\n-   high bound HIGHVAL.  If TYPE is NULL, sizetype is used.  */\n+   high bound HIGHVAL.  */\n \n tree\n build_range_type (tree type, tree lowval, tree highval)\n {\n   tree itype = make_node (INTEGER_TYPE);\n+  hashval_t hash;\n \n   TREE_TYPE (itype) = type;\n-  if (type == NULL_TREE)\n-    type = sizetype;\n \n   TYPE_MIN_VALUE (itype) = fold_convert (type, lowval);\n   TYPE_MAX_VALUE (itype) = highval ? fold_convert (type, highval) : NULL;\n@@ -7132,12 +7096,35 @@ build_range_type (tree type, tree lowval, tree highval)\n   TYPE_ALIGN (itype) = TYPE_ALIGN (type);\n   TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (type);\n \n-  if (host_integerp (lowval, 0) && highval != 0 && host_integerp (highval, 0))\n-    return type_hash_canon (tree_low_cst (highval, 0)\n-\t\t\t    - tree_low_cst (lowval, 0),\n-\t\t\t    itype);\n-  else\n-    return itype;\n+  if ((TYPE_MIN_VALUE (itype)\n+       && TREE_CODE (TYPE_MIN_VALUE (itype)) != INTEGER_CST)\n+      || (TYPE_MAX_VALUE (itype)\n+\t  && TREE_CODE (TYPE_MAX_VALUE (itype)) != INTEGER_CST))\n+    {\n+      /* Since we cannot reliably merge this type, we need to compare it using\n+\t structural equality checks.  */\n+      SET_TYPE_STRUCTURAL_EQUALITY (itype);\n+      return itype;\n+    }\n+  hash = iterative_hash_expr (TYPE_MIN_VALUE (itype), 0);\n+  hash = iterative_hash_expr (TYPE_MAX_VALUE (itype), hash);\n+  hash = iterative_hash_hashval_t (TYPE_HASH (type), hash);\n+  return type_hash_canon (hash, itype);\n+}\n+\n+/* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.\n+   MAXVAL should be the maximum value in the domain\n+   (one less than the length of the array).\n+\n+   The maximum value that MAXVAL can have is INT_MAX for a HOST_WIDE_INT.\n+   We don't enforce this limit, that is up to caller (e.g. language front end).\n+   The limit exists because the result is a signed type and we don't handle\n+   sizes that use more than one HOST_WIDE_INT.  */\n+\n+tree\n+build_index_type (tree maxval)\n+{\n+  return build_range_type (sizetype, size_zero_node, maxval);\n }\n \n /* Return true if the debug information for TYPE, a subtype, should be emitted"}]}