{"sha": "2f25972039c2c1c424c03fd29ff00200a64b6b0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyNTk3MjAzOWMyYzFjNDI0YzAzZmQyOWZmMDAyMDBhNjRiNmIwZQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-06-27T16:20:38Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-06-27T16:20:38Z"}, "message": "lra-constraints.c (inherit_in_ebb): Process static hard regs too.\n\n2013-06-27  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* lra-constraints.c (inherit_in_ebb): Process static hard regs\n\ttoo.  Process OP_INOUT regs for splitting too.\n\nFrom-SVN: r200475", "tree": {"sha": "d4d1cc5d81b4cf83c0e0b5ea9da578f4a718070a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4d1cc5d81b4cf83c0e0b5ea9da578f4a718070a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f25972039c2c1c424c03fd29ff00200a64b6b0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f25972039c2c1c424c03fd29ff00200a64b6b0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f25972039c2c1c424c03fd29ff00200a64b6b0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f25972039c2c1c424c03fd29ff00200a64b6b0e/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fef4d2b3eb0ce6f6863c2780aa1e75ca76afd248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fef4d2b3eb0ce6f6863c2780aa1e75ca76afd248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fef4d2b3eb0ce6f6863c2780aa1e75ca76afd248"}], "stats": {"total": 249, "additions": 131, "deletions": 118}, "files": [{"sha": "bd319c03e5b870062a28d9ce783c4f757cb6b073", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f25972039c2c1c424c03fd29ff00200a64b6b0e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f25972039c2c1c424c03fd29ff00200a64b6b0e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f25972039c2c1c424c03fd29ff00200a64b6b0e", "patch": "@@ -1,3 +1,8 @@\n+2013-06-27  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* lra-constraints.c (inherit_in_ebb): Process static hard regs\n+\ttoo.  Process OP_INOUT regs for splitting too.\n+\n 2013-06-27  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tree-vect-stmts.c (vectorizable_store): Move ptr_incr var"}, {"sha": "4ac20fd9553fa794d0d6647c73f682206637ccea", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 126, "deletions": 118, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f25972039c2c1c424c03fd29ff00200a64b6b0e/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f25972039c2c1c424c03fd29ff00200a64b6b0e/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=2f25972039c2c1c424c03fd29ff00200a64b6b0e", "patch": "@@ -4762,76 +4762,81 @@ inherit_in_ebb (rtx head, rtx tail)\n \t}\n       else if (INSN_P (curr_insn))\n \t{\n+\t  int iter;\n \t  int max_uid = get_max_uid ();\n \n \t  curr_id = lra_get_insn_recog_data (curr_insn);\n+\t  curr_static_id = curr_id->insn_static_data;\n \t  to_inherit_num = 0;\n \t  /* Process insn definitions.\t*/\n-\t  for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\t    if (reg->type != OP_IN\n-\t\t&& (dst_regno = reg->regno) < lra_constraint_new_regno_start)\n-\t      {\n-\t\tif (dst_regno >= FIRST_PSEUDO_REGISTER && reg->type == OP_OUT\n-\t\t    && reg_renumber[dst_regno] < 0 && ! reg->subreg_p\n-\t\t    && usage_insns[dst_regno].check == curr_usage_insns_check\n-\t\t    && (next_usage_insns\n-\t\t\t= usage_insns[dst_regno].insns) != NULL_RTX)\n-\t\t  {\n-\t\t    struct lra_insn_reg *r;\n-\n-\t\t    for (r = curr_id->regs; r != NULL; r = r->next)\n-\t\t      if (r->type != OP_OUT && r->regno == dst_regno)\n-\t\t\tbreak;\n-\t\t    /* Don't do inheritance if the pseudo is also\n-\t\t       used in the insn.  */\n-\t\t    if (r == NULL)\n-\t\t      /* We can not do inheritance right now\n-\t\t\t because the current insn reg info (chain\n-\t\t\t regs) can change after that.  */\n-\t\t      add_to_inherit (dst_regno, next_usage_insns);\n-\t\t  }\n-\t\t/* We can not process one reg twice here because of\n-\t\t   usage_insns invalidation.  */\n-\t\tif ((dst_regno < FIRST_PSEUDO_REGISTER\n-\t\t     || reg_renumber[dst_regno] >= 0)\n-\t\t    && ! reg->subreg_p && reg->type == OP_OUT)\n-\t\t  {\n-\t\t    HARD_REG_SET s;\n-\n-\t\t    if (split_if_necessary (dst_regno, reg->biggest_mode,\n-\t\t\t\t\t    potential_reload_hard_regs,\n-\t\t\t\t\t    false, curr_insn, max_uid))\n-\t\t      change_p = true;\n-\t\t    CLEAR_HARD_REG_SET (s);\n-\t\t    if (dst_regno < FIRST_PSEUDO_REGISTER)\n-\t\t      add_to_hard_reg_set (&s, reg->biggest_mode, dst_regno);\n-\t\t    else\n-\t\t      add_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),\n-\t\t\t\t\t   reg_renumber[dst_regno]);\n-\t\t    AND_COMPL_HARD_REG_SET (live_hard_regs, s);\n-\t\t  }\n-\t\t/* We should invalidate potential inheritance or\n-\t\t   splitting for the current insn usages to the next\n-\t\t   usage insns (see code below) as the output pseudo\n-\t\t   prevents this.  */\n-\t\tif ((dst_regno >= FIRST_PSEUDO_REGISTER\n-\t\t     && reg_renumber[dst_regno] < 0)\n-\t\t    || (reg->type == OP_OUT && ! reg->subreg_p\n-\t\t\t&& (dst_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t    || reg_renumber[dst_regno] >= 0)))\n-\t\t  {\n-\t\t    /* Invalidate and mark definitions.  */\n-\t\t    if (dst_regno >= FIRST_PSEUDO_REGISTER)\n-\t\t      usage_insns[dst_regno].check = -(int) INSN_UID (curr_insn);\n-\t\t    else\n-\t\t      {\n-\t\t\tnregs = hard_regno_nregs[dst_regno][reg->biggest_mode];\n-\t\t\tfor (i = 0; i < nregs; i++)\n-\t\t\t  usage_insns[dst_regno + i].check\n-\t\t\t    = -(int) INSN_UID (curr_insn);\n-\t\t      }\n-\t\t  }\n-\t      }\n+\t  for (iter = 0; iter < 2; iter++)\n+\t    for (reg = iter == 0 ? curr_id->regs : curr_static_id->hard_regs;\n+\t\t reg != NULL;\n+\t\t reg = reg->next)\n+\t      if (reg->type != OP_IN\n+\t\t  && (dst_regno = reg->regno) < lra_constraint_new_regno_start)\n+\t\t{\n+\t\t  if (dst_regno >= FIRST_PSEUDO_REGISTER && reg->type == OP_OUT\n+\t\t      && reg_renumber[dst_regno] < 0 && ! reg->subreg_p\n+\t\t      && usage_insns[dst_regno].check == curr_usage_insns_check\n+\t\t      && (next_usage_insns\n+\t\t\t  = usage_insns[dst_regno].insns) != NULL_RTX)\n+\t\t    {\n+\t\t      struct lra_insn_reg *r;\n+\n+\t\t      for (r = curr_id->regs; r != NULL; r = r->next)\n+\t\t\tif (r->type != OP_OUT && r->regno == dst_regno)\n+\t\t\t  break;\n+\t\t      /* Don't do inheritance if the pseudo is also\n+\t\t\t used in the insn.  */\n+\t\t      if (r == NULL)\n+\t\t\t/* We can not do inheritance right now\n+\t\t\t   because the current insn reg info (chain\n+\t\t\t   regs) can change after that.  */\n+\t\t\tadd_to_inherit (dst_regno, next_usage_insns);\n+\t\t    }\n+\t\t  /* We can not process one reg twice here because of\n+\t\t     usage_insns invalidation.  */\n+\t\t  if ((dst_regno < FIRST_PSEUDO_REGISTER\n+\t\t       || reg_renumber[dst_regno] >= 0)\n+\t\t    && ! reg->subreg_p && reg->type != OP_IN)\n+\t\t    {\n+\t\t      HARD_REG_SET s;\n+\n+\t\t      if (split_if_necessary (dst_regno, reg->biggest_mode,\n+\t\t\t\t\t      potential_reload_hard_regs,\n+\t\t\t\t\t      false, curr_insn, max_uid))\n+\t\t\tchange_p = true;\n+\t\t      CLEAR_HARD_REG_SET (s);\n+\t\t      if (dst_regno < FIRST_PSEUDO_REGISTER)\n+\t\t\tadd_to_hard_reg_set (&s, reg->biggest_mode, dst_regno);\n+\t\t      else\n+\t\t\tadd_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),\n+\t\t\t\t\t     reg_renumber[dst_regno]);\n+\t\t      AND_COMPL_HARD_REG_SET (live_hard_regs, s);\n+\t\t    }\n+\t\t  /* We should invalidate potential inheritance or\n+\t\t     splitting for the current insn usages to the next\n+\t\t     usage insns (see code below) as the output pseudo\n+\t\t     prevents this.  */\n+\t\t  if ((dst_regno >= FIRST_PSEUDO_REGISTER\n+\t\t       && reg_renumber[dst_regno] < 0)\n+\t\t      || (reg->type == OP_OUT && ! reg->subreg_p\n+\t\t\t  && (dst_regno < FIRST_PSEUDO_REGISTER\n+\t\t\t      || reg_renumber[dst_regno] >= 0)))\n+\t\t    {\n+\t\t      /* Invalidate and mark definitions.  */\n+\t\t      if (dst_regno >= FIRST_PSEUDO_REGISTER)\n+\t\t\tusage_insns[dst_regno].check = -(int) INSN_UID (curr_insn);\n+\t\t      else\n+\t\t\t{\n+\t\t\t  nregs = hard_regno_nregs[dst_regno][reg->biggest_mode];\n+\t\t\t  for (i = 0; i < nregs; i++)\n+\t\t\t    usage_insns[dst_regno + i].check\n+\t\t\t      = -(int) INSN_UID (curr_insn);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n \t  if (! JUMP_P (curr_insn))\n \t    for (i = 0; i < to_inherit_num; i++)\n \t      if (inherit_reload_reg (true, to_inherit[i].regno,\n@@ -4876,59 +4881,62 @@ inherit_in_ebb (rtx head, rtx tail)\n \t    }\n \t  to_inherit_num = 0;\n \t  /* Process insn usages.  */\n-\t  for (reg = curr_id->regs; reg != NULL; reg = reg->next)\n-\t    if ((reg->type != OP_OUT\n-\t\t || (reg->type == OP_OUT && reg->subreg_p))\n-\t\t&& (src_regno = reg->regno) < lra_constraint_new_regno_start)\n-\t      {\n-\t\tif (src_regno >= FIRST_PSEUDO_REGISTER\n-\t\t    && reg_renumber[src_regno] < 0 && reg->type == OP_IN)\n-\t\t  {\n-\t\t    if (usage_insns[src_regno].check == curr_usage_insns_check\n-\t\t\t&& (next_usage_insns\n-\t\t\t    = usage_insns[src_regno].insns) != NULL_RTX\n-\t\t\t&& NONDEBUG_INSN_P (curr_insn))\n-\t\t      add_to_inherit (src_regno, next_usage_insns);\n-\t\t    else if (usage_insns[src_regno].check\n-\t\t\t     != -(int) INSN_UID (curr_insn))\n-                      /* Add usages but only if the reg is not set up\n-                         in the same insn.  */\n-\t\t      add_next_usage_insn (src_regno, curr_insn, reloads_num);\n-\t\t  }\n-\t\telse if (src_regno < FIRST_PSEUDO_REGISTER\n-\t\t\t || reg_renumber[src_regno] >= 0)\n-\t\t  {\n-\t\t    bool before_p;\n-\t\t    rtx use_insn = curr_insn;\n-\n-\t\t    before_p = (JUMP_P (curr_insn)\n-\t\t\t\t|| (CALL_P (curr_insn) && reg->type == OP_IN));\n-\t\t    if (NONDEBUG_INSN_P (curr_insn)\n-\t\t\t&& split_if_necessary (src_regno, reg->biggest_mode,\n-\t\t\t\t\t       potential_reload_hard_regs,\n-\t\t\t\t\t       before_p, curr_insn, max_uid))\n-\t\t      {\n-\t\t\tif (reg->subreg_p)\n-\t\t\t  lra_risky_transformations_p = true;\n-\t\t\tchange_p = true;\n-\t\t\t/* Invalidate.\t*/\n-\t\t\tusage_insns[src_regno].check = 0;\n-\t\t\tif (before_p)\n-\t\t\t  use_insn = PREV_INSN (curr_insn);\n-\t\t      }\n-\t\t    if (NONDEBUG_INSN_P (curr_insn))\n-\t\t      {\n-\t\t\tif (src_regno < FIRST_PSEUDO_REGISTER)\n-\t\t\t  add_to_hard_reg_set (&live_hard_regs,\n-\t\t\t\t\t       reg->biggest_mode, src_regno);\n-\t\t\telse\n-\t\t\t  add_to_hard_reg_set (&live_hard_regs,\n-\t\t\t\t\t       PSEUDO_REGNO_MODE (src_regno),\n-\t\t\t\t\t       reg_renumber[src_regno]);\n-\t\t      }\n-\t\t    add_next_usage_insn (src_regno, use_insn, reloads_num);\n-\t\t  }\n-\t      }\n+\t  for (iter = 0; iter < 2; iter++)\n+\t    for (reg = iter == 0 ? curr_id->regs : curr_static_id->hard_regs;\n+\t\t reg != NULL;\n+\t\t reg = reg->next)\n+\t      if ((reg->type != OP_OUT\n+\t\t   || (reg->type == OP_OUT && reg->subreg_p))\n+\t\t  && (src_regno = reg->regno) < lra_constraint_new_regno_start)\n+\t\t{\n+\t\t  if (src_regno >= FIRST_PSEUDO_REGISTER\n+\t\t      && reg_renumber[src_regno] < 0 && reg->type == OP_IN)\n+\t\t    {\n+\t\t      if (usage_insns[src_regno].check == curr_usage_insns_check\n+\t\t\t  && (next_usage_insns\n+\t\t\t      = usage_insns[src_regno].insns) != NULL_RTX\n+\t\t\t  && NONDEBUG_INSN_P (curr_insn))\n+\t\t\tadd_to_inherit (src_regno, next_usage_insns);\n+\t\t      else if (usage_insns[src_regno].check\n+\t\t\t       != -(int) INSN_UID (curr_insn))\n+\t\t\t/* Add usages but only if the reg is not set up\n+\t\t\t   in the same insn.  */\n+\t\t\tadd_next_usage_insn (src_regno, curr_insn, reloads_num);\n+\t\t    }\n+\t\t  else if (src_regno < FIRST_PSEUDO_REGISTER\n+\t\t\t   || reg_renumber[src_regno] >= 0)\n+\t\t    {\n+\t\t      bool before_p;\n+\t\t      rtx use_insn = curr_insn;\n+\n+\t\t      before_p = (JUMP_P (curr_insn)\n+\t\t\t\t  || (CALL_P (curr_insn) && reg->type == OP_IN));\n+\t\t      if (NONDEBUG_INSN_P (curr_insn)\n+\t\t\t  && split_if_necessary (src_regno, reg->biggest_mode,\n+\t\t\t\t\t\t potential_reload_hard_regs,\n+\t\t\t\t\t\t before_p, curr_insn, max_uid))\n+\t\t\t{\n+\t\t\t  if (reg->subreg_p)\n+\t\t\t    lra_risky_transformations_p = true;\n+\t\t\t  change_p = true;\n+\t\t\t  /* Invalidate.\t*/\n+\t\t\t  usage_insns[src_regno].check = 0;\n+\t\t\t  if (before_p)\n+\t\t\t    use_insn = PREV_INSN (curr_insn);\n+\t\t\t}\n+\t\t      if (NONDEBUG_INSN_P (curr_insn))\n+\t\t\t{\n+\t\t\t  if (src_regno < FIRST_PSEUDO_REGISTER)\n+\t\t\t    add_to_hard_reg_set (&live_hard_regs,\n+\t\t\t\t\t\t reg->biggest_mode, src_regno);\n+\t\t\t  else\n+\t\t\t    add_to_hard_reg_set (&live_hard_regs,\n+\t\t\t\t\t\t PSEUDO_REGNO_MODE (src_regno),\n+\t\t\t\t\t\t reg_renumber[src_regno]);\n+\t\t\t}\n+\t\t      add_next_usage_insn (src_regno, use_insn, reloads_num);\n+\t\t    }\n+\t\t}\n \t  for (i = 0; i < to_inherit_num; i++)\n \t    {\n \t      src_regno = to_inherit[i].regno;"}]}