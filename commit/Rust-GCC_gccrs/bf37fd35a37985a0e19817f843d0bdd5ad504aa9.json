{"sha": "bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "node_id": "C_kwDOANBUbNoAKGJmMzdmZDM1YTM3OTg1YTBlMTk4MTdmODQzZDBiZGQ1YWQ1MDRhYTk", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:07Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2022-01-10T14:47:07Z"}, "message": "ira: Add a ira_loop_border_costs class\n\nThe final index into (ira_)memory_move_cost is 1 for loads and\n0 for stores.  Thus the combination:\n\n  entry_freq * memory_cost[1] + exit_freq * memory_cost[0]\n\nis the cost of loading a register on entry to a loop and\nstoring it back on exit from the loop.  This is the cost to\nuse if the register is successfully allocated within the\nloop but is spilled in the parent loop.  Similarly:\n\n  entry_freq * memory_cost[0] + exit_freq * memory_cost[1]\n\nis the cost of storing a register on entry to the loop and\nrestoring it on exit from the loop.  This is the cost to\nuse if the register is spilled within the loop but is\nsuccessfully allocated in the parent loop.\n\nThe patch adds a helper class for calculating these values and\nmechanically replaces the existing instances.  There is no attempt to\neditorialise the choice between using \u201cspill inside\u201d and \u201cspill outside\u201d\ncosts.  (I think one of them is the wrong way round, but a later patch\ndeals with that.)\n\nNo functional change intended.\n\ngcc/\n\tPR rtl-optimization/98782\n\t* ira-int.h (ira_loop_border_costs): New class.\n\t* ira-color.c (ira_loop_border_costs::ira_loop_border_costs):\n\tNew constructor.\n\t(calculate_allocno_spill_cost): Use ira_loop_border_costs.\n\t(color_pass): Likewise.\n\t(move_spill_restore): Likewise.", "tree": {"sha": "18f11c46d70b04c1791c53656c61a6e57b463e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18f11c46d70b04c1791c53656c61a6e57b463e10"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf37fd35a37985a0e19817f843d0bdd5ad504aa9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8d3c98746098e2784be7144c1ccc9fcc34a0888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8d3c98746098e2784be7144c1ccc9fcc34a0888", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8d3c98746098e2784be7144c1ccc9fcc34a0888"}], "stats": {"total": 132, "additions": 86, "deletions": 46}, "files": [{"sha": "66c11710b972edb9c935f9209291bf49b9d81c6f", "filename": "gcc/ira-color.c", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf37fd35a37985a0e19817f843d0bdd5ad504aa9/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf37fd35a37985a0e19817f843d0bdd5ad504aa9/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "patch": "@@ -2567,13 +2567,23 @@ ira_loop_edge_freq (ira_loop_tree_node_t loop_node, int regno, bool exit_p)\n   return REG_FREQ_FROM_EDGE_FREQ (freq);\n }\n \n+/* Construct an object that describes the boundary between A and its\n+   parent allocno.  */\n+ira_loop_border_costs::ira_loop_border_costs (ira_allocno_t a)\n+  : m_mode (ALLOCNO_MODE (a)),\n+    m_class (ALLOCNO_CLASS (a)),\n+    m_entry_freq (ira_loop_edge_freq (ALLOCNO_LOOP_TREE_NODE (a),\n+\t\t\t\t      ALLOCNO_REGNO (a), false)),\n+    m_exit_freq (ira_loop_edge_freq (ALLOCNO_LOOP_TREE_NODE (a),\n+\t\t\t\t     ALLOCNO_REGNO (a), true))\n+{\n+}\n+\n /* Calculate and return the cost of putting allocno A into memory.  */\n static int\n calculate_allocno_spill_cost (ira_allocno_t a)\n {\n   int regno, cost;\n-  machine_mode mode;\n-  enum reg_class rclass;\n   ira_allocno_t parent_allocno;\n   ira_loop_tree_node_t parent_node, loop_node;\n \n@@ -2586,24 +2596,12 @@ calculate_allocno_spill_cost (ira_allocno_t a)\n     return cost;\n   if ((parent_allocno = parent_node->regno_allocno_map[regno]) == NULL)\n     return cost;\n-  mode = ALLOCNO_MODE (a);\n-  rclass = ALLOCNO_CLASS (a);\n+  ira_loop_border_costs border_costs (a);\n   if (ALLOCNO_HARD_REGNO (parent_allocno) < 0)\n-    cost -= (ira_memory_move_cost[mode][rclass][0]\n-\t     * ira_loop_edge_freq (loop_node, regno, true)\n-\t     + ira_memory_move_cost[mode][rclass][1]\n-\t     * ira_loop_edge_freq (loop_node, regno, false));\n+    cost -= border_costs.spill_outside_loop_cost ();\n   else\n-    {\n-      ira_init_register_move_cost_if_necessary (mode);\n-      cost += ((ira_memory_move_cost[mode][rclass][1]\n-\t\t* ira_loop_edge_freq (loop_node, regno, true)\n-\t\t+ ira_memory_move_cost[mode][rclass][0]\n-\t\t* ira_loop_edge_freq (loop_node, regno, false))\n-\t       - (ira_register_move_cost[mode][rclass][rclass]\n-\t\t  * (ira_loop_edge_freq (loop_node, regno, false)\n-\t\t     + ira_loop_edge_freq (loop_node, regno, true))));\n-    }\n+    cost += (border_costs.spill_inside_loop_cost ()\n+\t     - border_costs.move_between_loops_cost ());\n   return cost;\n }\n \n@@ -3342,7 +3340,7 @@ static void\n color_pass (ira_loop_tree_node_t loop_tree_node)\n {\n   int regno, hard_regno, index = -1, n;\n-  int cost, exit_freq, enter_freq;\n+  int cost;\n   unsigned int j;\n   bitmap_iterator bi;\n   machine_mode mode;\n@@ -3466,8 +3464,6 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\t}\n \t      continue;\n \t    }\n-\t  exit_freq = ira_loop_edge_freq (subloop_node, regno, true);\n-\t  enter_freq = ira_loop_edge_freq (subloop_node, regno, false);\n \t  ira_assert (regno < ira_reg_equiv_len);\n \t  if (ira_equiv_no_lvalue_p (regno))\n \t    {\n@@ -3483,16 +3479,16 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t    }\n \t  else if (hard_regno < 0)\n \t    {\n+\t      ira_loop_border_costs border_costs (subloop_allocno);\n \t      ALLOCNO_UPDATED_MEMORY_COST (subloop_allocno)\n-\t\t-= ((ira_memory_move_cost[mode][rclass][1] * enter_freq)\n-\t\t    + (ira_memory_move_cost[mode][rclass][0] * exit_freq));\n+\t\t-= border_costs.spill_outside_loop_cost ();\n \t    }\n \t  else\n \t    {\n+\t      ira_loop_border_costs border_costs (subloop_allocno);\n \t      aclass = ALLOCNO_CLASS (subloop_allocno);\n \t      ira_init_register_move_cost_if_necessary (mode);\n-\t      cost = (ira_register_move_cost[mode][rclass][rclass]\n-\t\t      * (exit_freq + enter_freq));\n+\t      cost = border_costs.move_between_loops_cost ();\n \t      ira_allocate_and_set_or_copy_costs\n \t\t(&ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno), aclass,\n \t\t ALLOCNO_UPDATED_CLASS_COST (subloop_allocno),\n@@ -3508,8 +3504,7 @@ color_pass (ira_loop_tree_node_t loop_tree_node)\n \t\tALLOCNO_UPDATED_CLASS_COST (subloop_allocno)\n \t\t  = ALLOCNO_UPDATED_HARD_REG_COSTS (subloop_allocno)[index];\n \t      ALLOCNO_UPDATED_MEMORY_COST (subloop_allocno)\n-\t\t+= (ira_memory_move_cost[mode][rclass][0] * enter_freq\n-\t\t    + ira_memory_move_cost[mode][rclass][1] * exit_freq);\n+\t\t+= border_costs.spill_inside_loop_cost ();\n \t    }\n \t}\n     }\n@@ -3550,7 +3545,6 @@ move_spill_restore (void)\n {\n   int cost, regno, hard_regno, hard_regno2, index;\n   bool changed_p;\n-  int enter_freq, exit_freq;\n   machine_mode mode;\n   enum reg_class rclass;\n   ira_allocno_t a, parent_allocno, subloop_allocno;\n@@ -3605,38 +3599,28 @@ move_spill_restore (void)\n \t\t       - (ALLOCNO_HARD_REG_COSTS (subloop_allocno) == NULL\n \t\t\t  ? ALLOCNO_CLASS_COST (subloop_allocno)\n \t\t\t  : ALLOCNO_HARD_REG_COSTS (subloop_allocno)[index]));\n-\t      exit_freq = ira_loop_edge_freq (subloop_node, regno, true);\n-\t      enter_freq = ira_loop_edge_freq (subloop_node, regno, false);\n+\t      ira_loop_border_costs border_costs (subloop_allocno);\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (subloop_allocno)) < 0)\n-\t\tcost -= (ira_memory_move_cost[mode][rclass][0] * exit_freq\n-\t\t\t + ira_memory_move_cost[mode][rclass][1] * enter_freq);\n+\t\tcost -= border_costs.spill_outside_loop_cost ();\n \t      else\n \t\t{\n-\t\t  cost\n-\t\t    += (ira_memory_move_cost[mode][rclass][0] * exit_freq\n-\t\t\t+ ira_memory_move_cost[mode][rclass][1] * enter_freq);\n+\t\t  cost += border_costs.spill_outside_loop_cost ();\n \t\t  if (hard_regno2 != hard_regno)\n-\t\t    cost -= (ira_register_move_cost[mode][rclass][rclass]\n-\t\t\t     * (exit_freq + enter_freq));\n+\t\t    cost -= border_costs.move_between_loops_cost ();\n \t\t}\n \t    }\n \t  if ((parent = loop_node->parent) != NULL\n \t      && (parent_allocno = parent->regno_allocno_map[regno]) != NULL)\n \t    {\n \t      ira_assert (rclass == ALLOCNO_CLASS (parent_allocno));\n-\t      exit_freq\t= ira_loop_edge_freq (loop_node, regno, true);\n-\t      enter_freq = ira_loop_edge_freq (loop_node, regno, false);\n+\t      ira_loop_border_costs border_costs (a);\n \t      if ((hard_regno2 = ALLOCNO_HARD_REGNO (parent_allocno)) < 0)\n-\t\tcost -= (ira_memory_move_cost[mode][rclass][0] * exit_freq\n-\t\t\t + ira_memory_move_cost[mode][rclass][1] * enter_freq);\n+\t\tcost -= border_costs.spill_outside_loop_cost ();\n \t      else\n \t\t{\n-\t\t  cost\n-\t\t    += (ira_memory_move_cost[mode][rclass][1] * exit_freq\n-\t\t\t+ ira_memory_move_cost[mode][rclass][0] * enter_freq);\n+\t\t  cost += border_costs.spill_inside_loop_cost ();\n \t\t  if (hard_regno2 != hard_regno)\n-\t\t    cost -= (ira_register_move_cost[mode][rclass][rclass]\n-\t\t\t     * (exit_freq + enter_freq));\n+\t\t    cost -= border_costs.move_between_loops_cost ();\n \t\t}\n \t    }\n \t  if (cost < 0)"}, {"sha": "b32c80d4c9e6a81f2e6d21ac042066a015022656", "filename": "gcc/ira-int.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf37fd35a37985a0e19817f843d0bdd5ad504aa9/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf37fd35a37985a0e19817f843d0bdd5ad504aa9/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=bf37fd35a37985a0e19817f843d0bdd5ad504aa9", "patch": "@@ -1539,4 +1539,60 @@ ira_need_caller_save_p (ira_allocno_t a, unsigned int regno)\n \t\t\t\t     ALLOCNO_MODE (a), regno);\n }\n \n+/* Represents the boundary between an allocno in one loop and its parent\n+   allocno in the enclosing loop.  It is usually possible to change a\n+   register's allocation on this boundary; the class provides routines\n+   for calculating the cost of such changes.  */\n+class ira_loop_border_costs\n+{\n+public:\n+  ira_loop_border_costs (ira_allocno_t);\n+\n+  int move_between_loops_cost () const;\n+  int spill_outside_loop_cost () const;\n+  int spill_inside_loop_cost () const;\n+\n+private:\n+  /* The mode and class of the child allocno.  */\n+  machine_mode m_mode;\n+  reg_class m_class;\n+\n+  /* Sums the frequencies of the entry edges and the exit edges.  */\n+  int m_entry_freq, m_exit_freq;\n+};\n+\n+/* Return the cost of storing the register on entry to the loop and\n+   loading it back on exit from the loop.  This is the cost to use if\n+   the register is spilled within the loop but is successfully allocated\n+   in the parent loop.  */\n+inline int\n+ira_loop_border_costs::spill_inside_loop_cost () const\n+{\n+  return (m_entry_freq * ira_memory_move_cost[m_mode][m_class][0]\n+\t  + m_exit_freq * ira_memory_move_cost[m_mode][m_class][1]);\n+}\n+\n+/* Return the cost of loading the register on entry to the loop and\n+   storing it back on exit from the loop.  This is the cost to use if\n+   the register is successfully allocated within the loop but is spilled\n+   in the parent loop.  */\n+inline int\n+ira_loop_border_costs::spill_outside_loop_cost () const\n+{\n+  return (m_entry_freq * ira_memory_move_cost[m_mode][m_class][1]\n+\t  + m_exit_freq * ira_memory_move_cost[m_mode][m_class][0]);\n+}\n+\n+/* Return the cost of moving the pseudo register between different hard\n+   registers on entry and exit from the loop.  This is the cost to use\n+   if the register is successfully allocated within both this loop and\n+   the parent loop, but the allocations for the loops differ.  */\n+inline int\n+ira_loop_border_costs::move_between_loops_cost () const\n+{\n+  ira_init_register_move_cost_if_necessary (m_mode);\n+  auto move_cost = ira_register_move_cost[m_mode][m_class][m_class];\n+  return move_cost * (m_entry_freq + m_exit_freq);\n+}\n+\n #endif /* GCC_IRA_INT_H */"}]}