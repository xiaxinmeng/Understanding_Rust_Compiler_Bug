{"sha": "344332e87bda8e91370598dced1b9f3a0f12d35f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ0MzMyZTg3YmRhOGU5MTM3MDU5OGRjZWQxYjlmM2EwZjEyZDM1Zg==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-19T18:59:16Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-03-19T18:59:16Z"}, "message": "re PR target/50751 (SH Target: Displacement addressing does not work for QImode and HImode)\n\n\tPR target/50751\n\t* config/sh/sh.h (CONST_OK_FOR_K04, CONST_OK_FOR_K12, DISP_ADDR_P,\n\tDISP_ADDR_OFFSET): New macros.\n\t* config/sh/sh.c (sh_address_cost): Add SH2A special case.\n\t(sh_legitimate_index_p): Allow QImode displacements for non-SH2A.\n\t(sh_legitimize_address): Add QImode displacement handling.\n\t(sh_cannot_change_mode_class): Disallow GENERAL_REGS for SFmode \n\tvector subregs.\n\t(sh_secondary_reload): Add QImode displacement handling.\n\t* config/sh/predicates.md (movsrc_no_disp_mem_operand): New predicate.\n\t* config/sh/constraints.md (K04, Snd, Sdd): New constraints.\n\t* config/sh/sh.md (extendqisi2): Remove constraints from expander.\n\t(*extendqisi2_compact): Rename to *extendqisi2_compact_reg, restrict\n\tto register operands only.\n\t(*extendqisi2_compact_mem_disp, *extendqisi2_compact_snd): New insns.\n\t(extendqihi2): Change insn to expander.\n\t(*extendqihi2_compact_reg): New insn.\n\t(movqi_i, movqi): Replace with ... \n\t(movqi, *movqi_reg_reg, *movqi_store_mem_disp12,\n\t*movqi_load_mem_disp, *movqi_load_mem_disp): ... these.\n\tAdd new peepholes for QImode displacement addressing.\n\nFrom-SVN: r185534", "tree": {"sha": "9e2d1ac348fb139421d0ed1bae0011e40bcfdd63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e2d1ac348fb139421d0ed1bae0011e40bcfdd63"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/344332e87bda8e91370598dced1b9f3a0f12d35f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344332e87bda8e91370598dced1b9f3a0f12d35f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/344332e87bda8e91370598dced1b9f3a0f12d35f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/344332e87bda8e91370598dced1b9f3a0f12d35f/comments", "author": null, "committer": null, "parents": [{"sha": "26b808448f313cd214311c371a9ea204c58ba66b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26b808448f313cd214311c371a9ea204c58ba66b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26b808448f313cd214311c371a9ea204c58ba66b"}], "stats": {"total": 390, "additions": 331, "deletions": 59}, "files": [{"sha": "0417c4097be77666daa95cc68af47ada5af22700", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -1,3 +1,29 @@\n+2012-03-19  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/50751\n+\t* config/sh/sh.h (CONST_OK_FOR_K04, CONST_OK_FOR_K12, DISP_ADDR_P,\n+\tDISP_ADDR_OFFSET): New macros.\n+\t* config/sh/sh.c (sh_address_cost): Add SH2A special case.\n+\t(sh_legitimate_index_p): Allow QImode displacements for non-SH2A.\n+\t(sh_legitimize_address): Add QImode displacement handling.\n+\t(sh_cannot_change_mode_class): Disallow GENERAL_REGS for SFmode \n+\tvector subregs.\n+\t(sh_secondary_reload): Add QImode displacement handling.\n+\t* config/sh/predicates.md (movsrc_no_disp_mem_operand): New predicate.\n+        * config/sh/constraints.md (K04, Snd, Sdd): New constraints.\n+        * config/sh/sh.md (extendqisi2): Remove constraints from \n+        expander.\n+        (*extendqisi2_compact): Rename to *extendqisi2_compact_reg, \n+        restrict to register operands only.\n+        (*extendqisi2_compact_mem_disp, *extendqisi2_compact_snd): New \n+        insns.\n+        (extendqihi2): Change insn to expander.\n+        (*extendqihi2_compact_reg): New insn.\n+        (movqi_i, movqi): Replace with ... \n+        (movqi, *movqi_reg_reg, *movqi_store_mem_disp12,\n+        *movqi_load_mem_disp, *movqi_load_mem_disp): ... these.\n+        Add new peepholes for QImode displacement addressing.\n+\n 2012-03-19  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/14710"}, {"sha": "1f2ccf95107197d61f4bf6fe13f921b01d7dc64c", "filename": "gcc/config/sh/constraints.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fconstraints.md?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -123,6 +123,7 @@\n        (match_test \"ival >=  -134217728 && ival <= 134217727\")\n        (match_test \"(ival & 255) == 0\")\n        (match_test \"TARGET_SH2A\")))\n+\n (define_constraint \"J16\"\n   \"0xffffffff00000000 or 0x00000000ffffffff.\"\n   (and (match_code \"const_int\")\n@@ -133,6 +134,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival >= 0 && ival <= 7\")))\n \n+(define_constraint \"K04\"\n+  \"An unsigned 4-bit constant, as used in mov.b displacement addressing.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival >= 0 && ival <= 15\")))\n+\n (define_constraint \"K08\"\n   \"An unsigned 8-bit constant, as used in and, or, etc.\"\n   (and (match_code \"const_int\")\n@@ -266,3 +272,11 @@\n        (match_test \"GET_CODE (XEXP (op, 0)) == PLUS\")\n        (match_test \"REG_P (XEXP (XEXP (op, 0), 0))\")\n        (match_test \"satisfies_constraint_K12 (XEXP (XEXP (op, 0), 1))\")))\n+\n+(define_memory_constraint \"Snd\"\n+  \"A memory reference that excludes displacement addressing.\"\n+  (match_test \"! DISP_ADDR_P (op)\"))\n+\n+(define_memory_constraint \"Sdd\"\n+  \"A memory reference that uses displacement addressing.\"\n+  (match_test \"DISP_ADDR_P (op)\"))"}, {"sha": "ebcff4522215f6206365d30ce0ff7e6624a69f3c", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -418,6 +418,30 @@\n   return general_operand (op, mode);\n })\n \n+;; Same as movsrc_operand, but rejects displacement addressing.\n+\n+(define_predicate \"movsrc_no_disp_mem_operand\"\n+  (match_code \"subreg,reg,const_int,const_double,mem,symbol_ref,label_ref,const,const_vector\")\n+{\n+  if (!general_movsrc_operand (op, mode))\n+    return 0;\n+\n+  if ((mode == QImode || mode == HImode)\n+      && mode == GET_MODE (op)\n+      && (MEM_P (op)\n+\t  || (GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))))\n+    {\n+      rtx x = XEXP ((MEM_P (op) ? op : SUBREG_REG (op)), 0);\n+\n+      if (GET_CODE (x) == PLUS\n+\t  && REG_P (XEXP (x, 0))\n+\t  && CONST_INT_P (XEXP (x, 1)))\n+\treturn 0;\n+    }\n+\n+  return 1;\n+})\n+\n ;; Returns 1 if OP can be a destination of a move. Same as\n ;; general_operand, but no preinc allowed.\n "}, {"sha": "4b5db674e827e7d39cb2482d4ffdc973797ed8ae", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -3137,6 +3137,11 @@ static int\n sh_address_cost (rtx X,\n \t         bool speed ATTRIBUTE_UNUSED)\n {\n+  /*  SH2A supports 4 byte displacement mov insns with higher offsets.\n+      Consider those as more expensive than 2 byte insns.  */\n+  if (DISP_ADDR_P (X) && GET_MODE (X) == QImode)\n+    return DISP_ADDR_OFFSET (X) < 16 ? 0 : 1;\n+\n   return (GET_CODE (X) == PLUS\n \t  && ! CONSTANT_P (XEXP (X, 1))\n \t  && ! TARGET_SHMEDIA ? 1 : 0);\n@@ -9606,11 +9611,13 @@ sh_legitimate_index_p (enum machine_mode mode, rtx op)\n \n       if (TARGET_SH2A)\n \t{\n-\t  if (GET_MODE_SIZE (mode) == 1\n-\t\t&& (unsigned) INTVAL (op) < 4096)\n+\t  if (mode == QImode && (unsigned) INTVAL (op) < 4096)\n \t    return true;\n \t}\n \n+      if (mode == QImode && (unsigned) INTVAL (op) < 16)\n+\treturn true;\n+\n       if ((GET_MODE_SIZE (mode) == 4\n \t   && (unsigned) INTVAL (op) < 64\n \t   && !(INTVAL (op) & 3)\n@@ -9816,6 +9823,25 @@ sh_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n \t}\n     }\n \n+  /* This could be generalized for SImode, HImode, QImode displacement\n+     addressing.  */\n+  if (mode == QImode && GET_CODE (x) == PLUS\n+      && BASE_REGISTER_RTX_P (XEXP (x, 0)) && CONST_INT_P (XEXP (x, 1)))\n+    {\n+      rtx index_rtx = XEXP (x, 1);\n+      HOST_WIDE_INT offset = INTVAL (index_rtx);\n+      HOST_WIDE_INT offset_base = offset & ~15;\n+    \n+      if (offset - offset_base <= 16)\n+\t{\n+\t  rtx sum = expand_binop (Pmode, add_optab, XEXP (x, 0),\n+\t\t\t      GEN_INT (offset_base), NULL_RTX, 0,\n+\t\t\t      OPTAB_LIB_WIDEN);\n+\n+\t  return gen_rtx_PLUS (Pmode, sum, GEN_INT (offset - offset_base));\n+\t}\n+    }\n+\n   return x;\n }\n \n@@ -11444,8 +11470,13 @@ sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n {\n   /* We want to enable the use of SUBREGs as a means to\n      VEC_SELECT a single element of a vector.  */\n+\n+  /* This effectively disallows using GENERAL_REGS for SFmode vector subregs.\n+     This can be problematic when SFmode vector subregs need to be accessed\n+     on the stack with displacement addressing, as it happens with -O0.\n+     Thus we disallow the mode change for -O0.  */\n   if (to == SFmode && VECTOR_MODE_P (from) && GET_MODE_INNER (from) == SFmode)\n-    return (reg_classes_intersect_p (GENERAL_REGS, rclass));\n+    return optimize ? (reg_classes_intersect_p (GENERAL_REGS, rclass)) : false;\n \n   if (GET_MODE_SIZE (from) != GET_MODE_SIZE (to))\n     {\n@@ -11460,7 +11491,7 @@ sh_cannot_change_mode_class (enum machine_mode from, enum machine_mode to,\n \t    return reg_classes_intersect_p (DF_HI_REGS, rclass);\n \t}\n     }\n-  return 0;\n+  return false;\n }\n \n /* Return true if registers in machine mode MODE will likely be\n@@ -12472,6 +12503,25 @@ sh_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   if (rclass == FPUL_REGS && true_regnum (x) == -1)\n     return GENERAL_REGS;\n \n+  /* Force mov.b displacement addressing insn to use R0 as the other operand.\n+     On SH2A could also just leave it alone here, which would result in a\n+     4 byte move insn being generated instead.  However, for this to work\n+     the insns must have the appropriate alternatives.  */\n+  if (mode == QImode && rclass != R0_REGS\n+      && DISP_ADDR_P (x) && DISP_ADDR_OFFSET (x) < 16)\n+    return R0_REGS;\n+\n+  /* When reload is trying to address a QImode or HImode subreg on the stack, \n+     force any subreg byte into R0_REGS, as this is going to become a\n+     displacement address.\n+     We could restrict this to SUBREG_BYTE (x) > 0, but if the actual reg\n+     is on the stack, the memref to it might already require a displacement\n+     and that has to be added to the final address.  At this point we don't\n+     know the cumulative displacement so we assume the worst case.  */\n+  if ((mode == QImode || mode == HImode) && rclass != R0_REGS \n+      && GET_CODE (x) == SUBREG && true_regnum (x) == -1)\n+    return R0_REGS;\n+\n   return NO_REGS;\n }\n "}, {"sha": "008c6fa0b6f22e25cebd232359a19f47a0dbf7b3", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -1210,12 +1210,24 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n   ((HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) 0xffffffff) \\\n    || (HOST_BITS_PER_WIDE_INT >= 64 && (VALUE) == (HOST_WIDE_INT) -1 << 32))\n \n+#define CONST_OK_FOR_K04(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n+\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 15)\n+\n #define CONST_OK_FOR_K08(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 255)\n \n+#define CONST_OK_FOR_K12(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n+\t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 4095)\n+\n #define ZERO_EXTRACT_ANDMASK(EXTRACT_SZ_RTX, EXTRACT_POS_RTX)\\\n   (((1 << INTVAL (EXTRACT_SZ_RTX)) - 1) << INTVAL (EXTRACT_POS_RTX))\n \n+#define DISP_ADDR_P(X) (MEM_P (X) && GET_CODE (XEXP (X, 0)) == PLUS \\\n+\t\t\t && REG_P (XEXP (XEXP (X, 0), 0)) \\\n+\t\t\t && CONST_INT_P (XEXP (XEXP (X, 0), 1)))\n+\n+#define DISP_ADDR_OFFSET(X) (INTVAL (XEXP (XEXP (X, 0), 1)))\n+\n #if 0\n #define SECONDARY_INOUT_RELOAD_CLASS(CLASS,MODE,X,ELSE) \\\n   ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\"}, {"sha": "31160b0d1d4884b66072137882ba920e6eac96e7", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 201, "deletions": 55, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/344332e87bda8e91370598dced1b9f3a0f12d35f/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=344332e87bda8e91370598dced1b9f3a0f12d35f", "patch": "@@ -4871,24 +4871,56 @@ label:\n }\")\n \n (define_expand \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_extend_operand\" \"r,m\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_extend_operand\" \"\")))]\n   \"\"\n   \"\")\n \n-(define_insn \"*extendqisi2_compact\"\n+(define_insn \"*extendqisi2_compact_reg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_movsrc_operand\" \"r,m\")))]\n+\t(sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r,t\")))]\n   \"TARGET_SH1\"\n   \"@\n \texts.b\t%1,%0\n-\tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 2)\n-       (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))])])\n+\tmovt\t%0\"\n+  [(set_attr \"type\" \"arith,arith\")])\n+\n+;; FIXME: Fold non-SH2A and SH2A alternatives with \"enabled\" attribute.\n+;; See movqi insns.\n+(define_insn \"*extendqisi2_compact_mem_disp\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n+\t(sign_extend:SI\n+\t (mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K04,N\")))))]\n+  \"TARGET_SH1 && ! TARGET_SH2A && CONST_OK_FOR_K04 (INTVAL (operands[2]))\"\n+  \"@\n+\tmov.b\t@(%O2,%1),%0\n+\tmov.b\t@%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*extendqisi2_compact_mem_disp\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r,r\")\n+\t(sign_extend:SI\n+\t (mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n+\t\t\t  (match_operand:SI 2 \"const_int_operand\" \"K04,N,K12\")))))]\n+  \"TARGET_SH2A\n+   && (CONST_OK_FOR_K04 (INTVAL (operands[2]))\n+       || (CONST_OK_FOR_K12 (INTVAL (operands[2]))))\"\n+  \"@\n+\tmov.b\t@(%O2,%1),%0\n+\tmov.b\t@%1,%0\n+\tmov.b\t@(%O2,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+;; This will take care of other QImode addressing modes than displacement\n+;; addressing.\n+(define_insn \"*extendqisi2_compact_snd\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"movsrc_no_disp_mem_operand\" \"Snd\")))]\n+  \"TARGET_SH1\"\n+  \"mov.b\t%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n \n (define_insn \"*extendqisi2_media\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n@@ -4919,19 +4951,18 @@ label:\n \t\t\t   subreg_lowpart_offset (SImode, GET_MODE (op1)));\n }\")\n \n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_movsrc_operand\" \"r,m\")))]\n+(define_expand \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"\")))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*extendqihi2_compact_reg\"\n+  [(set (match_operand:HI 0 \"arith_reg_dest\" \"=r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n-  \"@\n-\texts.b\t%1,%0\n-\tmov.b\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load\")\n-   (set_attr_alternative \"length\"\n-     [(const_int 2)\n-       (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))])])\n+  \"exts.b\t%1,%0\"\n+  [(set_attr \"type\" \"arith\")])\n \n /* It would seem useful to combine the truncXi patterns into the movXi\n    patterns, but unary operators are ignored when matching constraints,\n@@ -5475,33 +5506,90 @@ label:\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n-(define_insn \"movqi_i\"\n-  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m,r,r,l\")\n-\t(match_operand:QI 1 \"general_movsrc_operand\"  \"r,i,m,r,t,l,r\"))]\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"{ if (prepare_move_operands (operands, QImode)) DONE; }\")\n+\n+;; If movqi_reg_reg is specified as an alternative of movqi, movqi will be\n+;; selected to copy QImode regs.  If one of them happens to be allocated\n+;; on the stack, reload will stick to movqi insn and generate wrong\n+;; displacement addressing because of the generic m alternatives.  \n+;; With the movqi_reg_reg being specified before movqi it will be intially \n+;; picked to load/store regs.  If the regs regs are on the stack reload will\n+;; try other insns and not stick to movqi_reg_reg.\n+(define_insn \"*movqi_reg_reg\"\n+  [(set (match_operand:QI 0 \"arith_reg_dest\"   \"=r,r\")\n+\t(match_operand:QI 1 \"register_operand\" \"r,t\"))]\n+  \"TARGET_SH1\"\n+  \"@\n+\tmov\t%1,%0\n+\tmovt\t%0\"\n+  [(set_attr \"type\" \"move,arith\")])\n+\n+;; FIXME: The non-SH2A and SH2A variants should be combined by adding\n+;; \"enabled\" attribute as it is done in other targets.\n+(define_insn \"*movqi_store_mem_disp04\"\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"K04,N\")))\n+\t(match_operand:QI 2 \"arith_reg_operand\" \"z,r\"))]\n+  \"TARGET_SH1 && CONST_OK_FOR_K04 (INTVAL (operands[1]))\"\n+  \"@\n+\tmov.b\t%2,@(%O1,%0)\n+\tmov.b\t%2,@%0\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*movqi_store_mem_disp12\"\n+  [(set (mem:QI (plus:SI (match_operand:SI 0 \"arith_reg_operand\" \"%r\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"K12\")))\n+\t(match_operand:QI 2 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH2A && CONST_OK_FOR_K12 (INTVAL (operands[1]))\"\n+  \"mov.b\t%2,@(%O1,%0)\"\n+  [(set_attr \"type\" \"store\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movqi_load_mem_disp\"\n+  [(set (match_operand:QI 0 \"arith_reg_dest\" \"=z,r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"K04,N\"))))]\n+  \"TARGET_SH1 && ! TARGET_SH2A && CONST_OK_FOR_K04 (INTVAL (operands[2]))\"\n+  \"@\n+\tmov.b\t@(%O2,%1),%0\n+\tmov.b\t@%1,%0\"\n+  [(set_attr \"type\" \"load\")])\n+\n+(define_insn \"*movqi_load_mem_disp\"\n+  [(set (match_operand:QI 0 \"arith_reg_dest\" \"=z,r,r\")\n+\t(mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%r,r,r\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"K04,N,K12\"))))]\n+  \"TARGET_SH2A\n+   && (CONST_OK_FOR_K04 (INTVAL (operands[2]))\n+       || CONST_OK_FOR_K12 (INTVAL (operands[2])))\"\n+  \"@\n+\tmov.b\t@(%O2,%1),%0\n+\tmov.b\t@%1,%0\n+\tmov.b\t@(%O2,%1),%0\"\n+  [(set_attr \"type\" \"load\")\n+   (set_attr \"length\" \"2,2,4\")])\n+\n+;; The m constraints basically allow any kind of addresses to be used with any\n+;; source/target register as the other operand.  This is not true for \n+;; displacement addressing modes on anything but SH2A.  That's why the\n+;; specialized load/store insns are specified above.\n+(define_insn \"*movqi\"\n+  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,l\")\n+\t(match_operand:QI 1 \"general_movsrc_operand\"  \"i,m,r,l,r\"))]\n   \"TARGET_SH1\n    && (arith_reg_operand (operands[0], QImode)\n        || arith_reg_operand (operands[1], QImode))\"\n   \"@\n-\tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.b\t%1,%0\n \tmov.b\t%1,%0\n-\tmovt\t%0\n \tsts\t%1,%0\n \tlds\t%1,%0\"\n- [(set_attr \"type\" \"move,movi8,load,store,arith,prget,prset\")\n-  (set_attr_alternative \"length\"\n-     [(const_int 2)\n-      (const_int 2)\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (if_then_else\n-\t(match_test \"TARGET_SH2A\")\n-\t(const_int 4) (const_int 2))\n-      (const_int 2)\n-      (const_int 2)\n-      (const_int 2)])])\n+ [(set_attr \"type\" \"movi8,load,store,prget,prset\")])\n \n (define_insn \"*movqi_media\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m\")\n@@ -5520,12 +5608,6 @@ label:\n \t       (const_string \"user\")]\n \t      (const_string \"ignore\")))])\n \n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\"  \"\"))]\n-  \"\"\n-  \"{ if (prepare_move_operands (operands, QImode)) DONE; }\")\n-\n (define_expand \"reload_inqi\"\n   [(set (match_operand:SI 2 \"\" \"=&r\")\n \t(match_operand:QI 1 \"inqhi_operand\" \"\"))\n@@ -7036,14 +7118,6 @@ label:\n   [(set (match_dup 2) (match_dup 1))\n    (set (match_dup 0) (match_dup 2))]\n   \"\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(match_operand:SI 1 \"memory_operand\" \"\"))\n-   (clobber (reg:SI R0_REG))]\n-  \"TARGET_SH1\"\n-  [(set (match_dup 0) (match_dup 1))]\n-  \"\")\n \f\n ;; ------------------------------------------------------------------------\n ;; Define the real conditional branch instructions.\n@@ -11684,6 +11758,78 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"TARGET_SH2\"\n   \"dt\t%0\")\n \n+;; The following peepholes fold load sequences for which reload was not\n+;; able to generate a displacement addressing move insn.\n+;; This can happen when reload has to transform a move insn \n+;; without displacement into one with displacement.  Or when reload can't\n+;; fit a displacement into the insn's constraints.  In the latter case, the\n+;; load destination reg remains at r0, which reload compensates by inserting\n+;; another mov insn.\n+\n+;; Fold sequence:\n+;;\tmov #54,r0\n+;;\tmov.b @(r0,r15),r0\n+;;\tmov r0,r3\n+;; into:\n+;;\tmov.b @(54,r15),r3\n+;;\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI\n+\t (mem:QI (plus:SI (match_dup 0)\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\" \"\")))))\n+   (set (match_operand:QI 4 \"arith_reg_dest\" \"\")\n+\t(match_operand:QI 5 \"arith_reg_operand\" \"\"))]\n+  \"TARGET_SH2A\n+   && CONST_OK_FOR_K12 (INTVAL (operands[1]))\n+   && REGNO (operands[2]) == REGNO (operands[5])\n+   && peep2_reg_dead_p (3, operands[5])\"\n+  [(set (match_dup 4) (mem:QI (plus:SI (match_dup 3) (match_dup 1))))]\n+  \"\")\n+\n+;; Fold sequence:\n+;;\tmov #54,r0\n+;;\tmov.b @(r0,r15),r1\n+;; into:\n+;;\tmov.b @(54,r15),r1\n+;;\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(match_operand:SI 1 \"const_int_operand\" \"\"))\n+   (set (match_operand:SI 2 \"arith_reg_dest\" \"\")\n+\t (sign_extend:SI\n+\t (mem:QI (plus:SI (match_dup 0)\n+\t\t\t  (match_operand:SI 3 \"arith_reg_operand\" \"\")))))]\n+  \"TARGET_SH2A\n+   && CONST_OK_FOR_K12 (INTVAL (operands[1]))\n+   && (peep2_reg_dead_p (2, operands[0])\n+       || REGNO (operands[0]) == REGNO (operands[2]))\"\n+  [(set (match_dup 2)\n+\t(sign_extend:SI (mem:QI (plus:SI (match_dup 3) (match_dup 1)))))]\n+  \"\")\n+\n+;; Fold sequence:\n+;;\tmov.b @(r0,r15),r0\n+;;\tmov r0,r3\n+;; into:\n+;;\tmov.b @(r0,r15),r3\n+;;\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(sign_extend:SI\n+\t (mem:QI (plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t\t  (match_operand:SI 2 \"arith_reg_operand\" \"\")))))\n+   (set (match_operand:QI 3 \"arith_reg_dest\" \"\")\n+\t(match_operand:QI 4 \"arith_reg_operand\" \"\"))]\n+  \"TARGET_SH1\n+   && REGNO (operands[0]) == REGNO (operands[4])\n+   && peep2_reg_dead_p (2, operands[0])\"\n+  [(set (match_dup 3)\n+\t(mem:QI (plus:SI (match_dup 1) (match_dup 2))))]\n+  \"\")\n+\n ;; These convert sequences such as `mov #k,r0; add r15,r0; mov.l @r0,rn'\n ;; to `mov #k,r0; mov.l @(r0,r15),rn'.  These sequences are generated by\n ;; reload when the constant is too large for a reg+offset address."}]}