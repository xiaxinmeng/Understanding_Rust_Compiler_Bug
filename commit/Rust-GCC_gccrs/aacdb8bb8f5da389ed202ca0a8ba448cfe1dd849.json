{"sha": "aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFjZGI4YmI4ZjVkYTM4OWVkMjAyY2EwYThiYTQ0OGNmZTFkZDg0OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:08:22Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-11-16T11:08:22Z"}, "message": "Initial revision\n\nFrom-SVN: r13186", "tree": {"sha": "ac5acc8153693b99ecfbccef8b1fb8425fbaf219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac5acc8153693b99ecfbccef8b1fb8425fbaf219"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/comments", "author": null, "committer": null, "parents": [{"sha": "477c16e36e9548cff9ce12690490f1f120c9cbbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/477c16e36e9548cff9ce12690490f1f120c9cbbd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/477c16e36e9548cff9ce12690490f1f120c9cbbd"}], "stats": {"total": 505, "additions": 505, "deletions": 0}, "files": [{"sha": "12ac24098ce70e5e97b7daa749df4f115a859667", "filename": "gcc/config/alpha/t-vms", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Ft-vms", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Ft-vms", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-vms?ref=aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "patch": "@@ -0,0 +1,6 @@\n+# Do not build libgcc1.\n+LIBGCC1 = \n+CROSS_LIBGCC1 =\n+\n+LIB2FUNCS_EXTRA = tramp.s\n+"}, {"sha": "30918aae2a419c081b06f2deac820a9f7da84124", "filename": "gcc/config/alpha/vms.h", "status": "added", "additions": 413, "deletions": 0, "changes": 413, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms.h?ref=aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "patch": "@@ -0,0 +1,413 @@\n+/* Output variables, constants and external declarations, for GNU compiler.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define OPEN_VMS 1\n+\n+/* This enables certain macros in alpha.h, which will make an indirect\n+   reference to an external symbol an invalid address.  This needs to be\n+   defined before we include alpha.h, since it determines which macros\n+   are used for GO_IF_*.  */\n+\n+#define NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+#include \"alpha/alpha.h\"\n+\n+/* Predefine this in CPP because VMS limits the size of command options\n+   and GNU CPP is not used on VMS except with GNU C.  */\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \\\n+\"-Dalpha -D__ALPHA -Dvms -DVMS -D__alpha__ -D__alpha -D__vms__ -D__VMS__\\\n+ -D__VMS_VER=70000022 \\\n+ -D__GNUC__=2 -D__GNUC_MINOR__=7 -Asystem(vms) -Acpu(alpha) -Amachine(alpha)\"\n+\n+#undef CPP_SPEC\n+#define CPP_SPEC \"\\\n+%{mfloat-ieee:-D__IEEE_FLOAT} \\\n+%{mfloat-vax:-D__G_FLOAT} \\\n+%{!mfloat-vax:-D__IEEE_FLOAT} \\\n+%{!.S:\t-D__LANGUAGE_C__ -D__LANGUAGE_C %{!ansi:-DLANGUAGE_C}}  \\\n+%{.S:\t-D__LANGUAGE_ASSEMBLY__ -D__LANGUAGE_ASSEMBLY %{!ansi:-DLANGUAGE_ASSEMBLY}} \\\n+%{.cc:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n+%{.cxx:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n+%{.C:\t-D__LANGUAGE_C_PLUS_PLUS__ -D__LANGUAGE_C_PLUS_PLUS -D__cplusplus} \\\n+%{.m:\t-D__LANGUAGE_OBJECTIVE_C__ -D__LANGUAGE_OBJECTIVE_C}\"\n+\n+/* We allow $'s in identifiers unless -ansi is used .. */\n+\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* These match the definitions used in DECCRTL, the VMS C run-time library\n+\n+#define SIZE_TYPE\t\"unsigned int\"\n+#define PTRDIFF_TYPE\t\"int\"\n+*/\n+\n+/* Use memcpy for structure copying, and so forth.  */\n+#define TARGET_MEM_FUNCTIONS\n+\n+/* By default, allow $ to be part of an identifier.  */\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+/* no-soft-float, fp-regs, gas, open_vms, float-ieee  */\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 263\n+#undef TARGET_NAME   \n+#define TARGET_NAME \"openVMS/Alpha\"\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (%s)\", TARGET_NAME);           \n+\n+/* The structure return address arrives as an \"argument\" on VMS.  */\n+#undef STRUCT_VALUE_REGNUM\n+#define STRUCT_VALUE 0\n+#undef PCC_STATIC_STRUCT_RETURN\n+\n+/* no floating emulation.  */\n+#undef REAL_ARITHMETIC\n+\n+/* \"long\" is 32 bits.  */\n+#undef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 32\n+\n+/* Pointer is 32 bits but the hardware has 64-bit addresses, sign extended. */\n+#undef POINTER_SIZE\n+#define POINTER_SIZE 32\n+#define POINTERS_EXTEND_UNSIGNED 0\n+\n+/* No data type wants to be aligned rounder than this. */\n+#undef BIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 128       /* X Complex */\n+#define MAX_OFILE_ALIGNMENT 524288  /* 8 x 2^16 by DEC Test CD40VRA */\n+\n+#undef FIXED_REGISTERS\n+#define FIXED_REGISTERS  \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }\n+\n+#undef CALL_USED_REGISTERS\n+#define CALL_USED_REGISTERS  \\\n+ {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, \\\n+  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n+\n+#undef HARD_FRAME_POINTER_REGNUM\n+#define HARD_FRAME_POINTER_REGNUM 29\n+\n+#undef CAN_ELIMINATE\n+#define CAN_ELIMINATE(FROM, TO)  \\\n+((TO) != STACK_POINTER_REGNUM || ! alpha_using_fp ())\n+\n+#undef INITIAL_ELIMINATION_OFFSET\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+{ if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) = alpha_sa_size () + alpha_pv_save_size ();\t\t\\\n+  else if ((FROM) == ARG_POINTER_REGNUM)\t\t\t\t\\\n+    (OFFSET) = (ALPHA_ROUND (alpha_sa_size () + alpha_pv_save_size ()\t\\\n+\t\t\t     + get_frame_size ()\t\t\t\\\n+\t\t\t     + current_function_pretend_args_size)\t\\\n+\t\t- current_function_pretend_args_size);\t\t\t\\\n+  if ((TO) == STACK_POINTER_REGNUM)\t\t\t\t\t\\\n+    (OFFSET) += ALPHA_ROUND (current_function_outgoing_args_size);\t\\\n+}\n+\n+#undef FUNCTION_ARG_ADVANCE\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+  if (MUST_PASS_IN_STACK (MODE, TYPE))\t\t\t\t\t\\\n+    (CUM) = (CUM & ~0xff) + 6;\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (CUM) += ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\n+\n+#undef FUNCTION_ARG_PARTIAL_NREGS\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\t\\\n+((CUM & 0xff) < 6 && 6 < (CUM & 0xff)\t\t\t\t\t\\\n+   + ALPHA_ARG_SIZE (MODE, TYPE, NAMED)\t\t\t\t\t\\\n+ ? 6 - (CUM & 0xff) : 0)\n+\n+extern char *vmskrunch ();\n+#undef ENCODE_SECTION_INFO\n+#define ENCODE_SECTION_INFO(DECL)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (DECL) == FUNCTION_DECL && ! TREE_PUBLIC (DECL)) \\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (DECL), 0)) = 1;\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE_CLASS (TREE_CODE (DECL)) == 'd'\t\t\t\\\n+      && GET_CODE (DECL_RTL (DECL)) == MEM\t\t\t\\\n+      && GET_CODE (XEXP (DECL_RTL (DECL), 0)) == SYMBOL_REF)\t\\\n+\tXSTR (XEXP (DECL_RTL (DECL), 0), 0)\t\t\t\\\n+\t  = vmskrunch (XSTR (XEXP (DECL_RTL (DECL), 0), 0));\t\\\n+} while (0)\n+\n+/* Don't use BLKmode if VAX floats are used.  */\n+#undef SETUP_INCOMING_VARARGS\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM & 0xff) < 6)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL))\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  move_block_from_reg\t\t\t\t\t\t\\\n+\t    (16 + (CUM & 0xff),\t\t\t\t\t\t\\\n+\t     gen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t      plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t     ((CUM & 0xff) + 6)* UNITS_PER_WORD)),\\\n+\t     6 - (CUM & 0xff), (6 - (CUM & 0xff)) * UNITS_PER_WORD);\t\\\n+\t  if (!TARGET_FLOAT_VAX || !TARGET_FPREGS)\t\t\t\\\n+\t    move_block_from_reg\t\t\t\t\t\t\\\n+\t      (16 + (TARGET_FPREGS ? 32 : 0) + (CUM & 0xff),\t\t\\\n+\t\tgen_rtx (MEM, BLKmode,\t\t\t\t\t\\\n+\t\t\t plus_constant (virtual_incoming_args_rtx,\t\\\n+\t\t\t\t\t(CUM & 0xff) * UNITS_PER_WORD)),\\\n+\t\t6 - (CUM & 0xff), (6 - (CUM & 0xff)) * UNITS_PER_WORD);\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int i;\t\t\t\t\t\t\t\\\n+\t      for (i = (CUM & 0xff); i < 6; i++)\t\t\t\\\n+\t\temit_move_insn (\t\t\t\t\t\\\n+\t\t  gen_rtx (MEM, DFmode,\t\t\t\t\t\\\n+\t\t    plus_constant (virtual_incoming_args_rtx,\t\t\\\n+\t\t\t\t   i * UNITS_PER_WORD)),\t\t\\\n+\t\t  gen_rtx (REG, DFmode, 48+i));\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+      PRETEND_SIZE = 12 * UNITS_PER_WORD;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE,NAME,DECL)\t\\\n+{\t\t\t\t\t\t\t\\\n+   alpha_function_name = vmskrunch (NAME);\t\t\\\n+}\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  alpha_write_verstamp (FILE);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set noreorder\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.set volatile\\n\");\t\t\t\t\\\n+  ASM_OUTPUT_SOURCE_FILENAME (FILE, main_input_filename);\t\\\n+}\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tlong t;\t\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\t\\\n+\tfprintf (FILE, \"\\t.long 0x%lx\\n\", t & 0xffffffff);\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tchar str[30];\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_DECIMAL ((VALUE), \"%.20e\", str);\t\t\t\\\n+\tfprintf (FILE, \"\\t.%c_floating %s\\n\", (TARGET_FLOAT_VAX)?'f':'s', str);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define LINK_SECTION_ASM_OP \".link\"\n+\n+#define READONLY_SECTION_ASM_OP \".rdata\"\n+\n+#undef EXTRA_SECTIONS\n+#define EXTRA_SECTIONS\tin_link, in_rdata\n+\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+readonly_section ()\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_rdata)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", READONLY_SECTION_ASM_OP);\t\\\n+      in_section = in_rdata;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\t\t\t\t\t\t\t\t\\\n+void\t\t\t\t\t\t\t\t\\\n+link_section ()\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (in_section != in_link)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (asm_out_file, \"%s\\n\", LINK_SECTION_ASM_OP); \t\\\n+      in_section = in_link;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL) abort ()\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, \"\\t.quad $%d\\n\", (VALUE) + 32)\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION readonly_section\n+\n+#define ASM_FILE_END(FILE) alpha_write_linkage (FILE);\n+\n+#undef FUNCTION_ARG\n+void *function_arg ();\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\tfunction_arg (&CUM, MODE, TYPE, NAMED)\n+\n+#undef CASE_VECTOR_MODE\n+#define CASE_VECTOR_MODE DImode\n+#undef CASE_VECTOR_PC_RELATIVE\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+{ ASM_OUTPUT_ALIGN (FILE, 3); ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM); }\n+\n+#define NO_MD_PROTOTYPES\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments. \n+\n+   CUM is as above.\n+\n+   MODE and TYPE are the mode and type of the current parameter.\n+\n+   PRETEND_SIZE is a variable that should be set to the amount of stack\n+   that must be pushed by the prolog to pretend that our caller pushed\n+   it.\n+\n+   Normally, this macro will push all remaining incoming registers on the\n+   stack and set PRETEND_SIZE to the length of the registers pushed. \n+\n+   For VMS, we allocate space for all 6 arg registers plus a count.\n+\n+   However, if NO registers need to be saved, don't allocate any space.\n+   This is not only because we won't need the space, but because AP includes\n+   the current_pretend_args_size and we don't want to mess up any\n+   ap-relative addresses already made.   */\n+   \n+\n+#undef SETUP_INCOMING_VARARGS\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM) < 6)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL))\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  emit_move_insn (gen_rtx (REG, DImode, 1),\t\\\n+\t\t\t  virtual_incoming_args_rtx);\t\\\n+\t  emit_insn (gen_arg_home ());\t\t\t\\\n+\t}\t\t\t\t\t\t\\\n+\t\t\t\t\t\t        \\\n+      PRETEND_SIZE = 7 * UNITS_PER_WORD;\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+}\n+\f\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.\n+\n+   The trampoline should set the static chain pointer to value placed\n+   into the trampoline and should branch to the specified routine.  \n+   Note that $27 has been set to the address of the trampoline, so we can\n+   use it for addressability of the two data items.  Trampolines are always\n+   aligned to FUNCTION_BOUNDARY, which is 64 bits.  */\n+\n+#undef TRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+{\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.quad 0\\n\");\t\t\\\n+  fprintf (FILE, \"\\t.linkage __tramp\\n\");\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#undef TRAMPOLINE_SIZE\n+#define TRAMPOLINE_SIZE    24\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#undef INITIALIZE_TRAMPOLINE\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode, (TRAMP)), (FNADDR));\t\t\\\n+  emit_move_insn (gen_rtx (MEM, Pmode,\t\t\t\t\t\\\n+\t\t\t   memory_address (Pmode,\t\t\t\\\n+\t\t\t\t\t   plus_constant ((TRAMP), 16))), \\\n+\t\t  (CXT));\t\t\t\t\t\t\\\n+}\n+\n+#undef TRANSFER_FROM_TRAMPOLINE\n+\n+#undef SDB_DEBUGGING_INFO\n+#undef MIPS_DEBUGGING_INFO\n+\n+#ifndef DBX_DEBUGGING_INFO\n+#define DBX_DEBUGGING_INFO\n+#endif\n+\n+#ifdef PREFERRED_DEBUGGING_TYPE\n+#undef PREFERRED_DEBUGGING_TYPE\n+#endif\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+#ifdef ASM_FORMAT_PRIVATE_NAME\n+#undef ASM_FORMAT_PRIVATE_NAME\n+#endif\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n+  sprintf ((OUTPUT), \"%s___%d\", (NAME), (LABELNO)))\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \"-nocpp %{pg}\"\n+\n+#undef ASM_FINAL_SPEC\n+\n+#undef LIBGCC_SPEC\n+#define LIBGCC_SPEC \"-lgcc2 -lgcclib\"\n+\n+#define OPTIMIZATION_OPTIONS                       \\\n+{                                                  \\\n+   write_symbols = PREFERRED_DEBUGGING_TYPE;       \\\n+   debug_info_level = (enum debug_info_level) 2;   \\\n+}\n+\n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS                           \\\n+{                                                  \\\n+   if (write_symbols == NO_DEBUG)                  \\\n+     debug_info_level = (enum debug_info_level) 0; \\\n+   override_options ();                            \\\n+}\n+\n+#undef LINK_SPEC\n+#define LINK_SPEC \"%{g3:-g3} %{g0:-g0}\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"\"\n+\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC \"gnu_cc:[000000]crt0.obj\"\n+\n+/* Define the names of the division and modulus functions.  */\n+#define DIVSI3_LIBCALL \"ots$div_i\"\n+#define DIVDI3_LIBCALL \"ots$div_l\"\n+#define UDIVSI3_LIBCALL \"ots$div_ui\"\n+#define UDIVDI3_LIBCALL \"ots$div_ul\"\n+#define MODSI3_LIBCALL \"ots$mod_i\"\n+#define MODDI3_LIBCALL \"ots$mod_l\"\n+#define UMODSI3_LIBCALL \"ots$rem_ui\"\n+#define UMODDI3_LIBCALL \"ots$rem_ul\""}, {"sha": "c96423a6e5ae69f75b985dd9a53f3923ab403d80", "filename": "gcc/config/alpha/xm-vms.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Fxm-vms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849/gcc%2Fconfig%2Falpha%2Fxm-vms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fxm-vms.h?ref=aacdb8bb8f5da389ed202ca0a8ba448cfe1dd849", "patch": "@@ -0,0 +1,86 @@\n+/* Configuration for GNU C-compiler for openVMS/Alpha.\n+   Copyright (C)  1996 Free Software Foundation, Inc.\n+   Contributed by Klaus Kaempf (kkaempf@progis.de).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* If compiling with DECC, need to fix problem with <stdio.h>\n+   which defines a macro called FILE_TYPE that breaks \"tree.h\".\n+   Fortunately it uses #ifndef to suppress multiple inclusions.\n+   Three possible cases:\n+        1) <stdio.h> has already been included -- ours will be no-op;\n+        2) <stdio.h> will be included after us -- \"theirs\" will be no-op;\n+        3) <stdio.h> isn't needed -- including it here shouldn't hurt.\n+   In all three cases, the problem macro will be removed here.  */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#ifdef __DECC\n+#undef FILE_TYPE\n+#endif\n+\n+#undef HOST_BITS_PER_LONG\n+#define HOST_BITS_PER_LONG 32\n+\n+#define HOST_WIDE_INT long long\n+#define HOST_BITS_PER_WIDE_INT 64\n+\n+#undef SUCCESS_EXIT_CODE\n+#define SUCCESS_EXIT_CODE 1\n+#undef FATAL_EXIT_CODE\n+#define FATAL_EXIT_CODE (44 | 0x10000000)  /* Abort, and no DCL message.  */\n+\n+/* A couple of conditionals for execution machine are controlled here.  */\n+#ifndef VMS\n+#define VMS\n+#endif\n+\n+/* Define a local equivalent (sort of) for unlink */\n+#define unlink remove\n+#define NEED_ATEXIT\n+\n+#define NO_SYS_PARAMS_H\t\t/* Don't have <sys/params.h> */\n+#define NO_STAB_H\t\t/* Don't have <stab.h> */\n+#define USE_C_ALLOCA\t\t/* Using alloca.c */\n+\n+#define HAVE_FCNTL_H 1\n+#define HAVE_STDLIB_H 1\n+#define HAVE_UNISTD_H 1\n+#define HAVE_STRING_H 1\n+#define STDC_HEADERS 1\n+\n+/* Use ANSI/SYSV style byte manipulation routines instead of BSD ones.  */\n+\n+#define bcopy(s,d,n)\tmemcpy((d),(s),(n))\n+#define bzero(d,n)\tmemset((d),0,(n))\n+#define bcmp(l,r,n)\tmemcmp((l),(r),(n))\n+\n+#define index\tstrchr\n+#define rindex\tstrrchr\n+\n+#if __STDC__\n+extern void *alloca (size_t);\n+#else\n+extern char *alloca (unsigned int);\n+#endif\n+\n+#define OBJECT_SUFFIX \".obj\"\n+#define EXECUTABLE_SUFFIX \".exe\"\n+#define DIR_SEPARATOR ']'\n+#define PATH_SEPARATOR ','"}]}