{"sha": "c50594233b1cf896e3383fd4f2988819d2bba440", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUwNTk0MjMzYjFjZjg5NmUzMzgzZmQ0ZjI5ODg4MTlkMmJiYTQ0MA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@bigpond.net.au", "date": "2001-08-27T15:52:35Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2001-08-27T15:52:35Z"}, "message": "rs6000.c (mask_operand): Rewrite without bit-shifting loop.\n\n\t* config/rs6000/rs6000.c (mask_operand): Rewrite without\n\tbit-shifting loop.\n\t(mask64_operand): Likewise.\n\t(rldic_operand): Delete.\n\t(includes_lshift64_p): Delete.\n\t(includes_rldic_lshift_p): New function.\n\t(includes_rldicr_lshift_p): New function.\n\t(print_operand): Don't call rldic_operand in case 'W'.\n\t* config/rs6000/rs6000-protos.h (rldic_operand): Remove.\n\t(includes_lshift64_p): Remove.\n\t(includes_rldic_lshift_p): Declare.\n\t(includes_rldicr_lshift_p): Declare.\n\t* config/rs6000/rs6000.h (PREDICATE_CODES): Remove rldic_operand.\n\t* config/rs6000/rs6000.md <ashldi3_internal 64 bit patterns>:\n\tReplace match_operand rldic_operand predicate with\n\tconst_int_operand.  Replace includes_lshift64_p condition with\n\tincludes_rldic_lshift_p.\n\t<ashldi3_internal 64 bit rldicr patterns>: New.\n\nFrom-SVN: r45192", "tree": {"sha": "50af4f9077687a22c24751668bbbe8a3bd6ee6bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50af4f9077687a22c24751668bbbe8a3bd6ee6bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c50594233b1cf896e3383fd4f2988819d2bba440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50594233b1cf896e3383fd4f2988819d2bba440", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c50594233b1cf896e3383fd4f2988819d2bba440", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50594233b1cf896e3383fd4f2988819d2bba440/comments", "author": null, "committer": null, "parents": [{"sha": "c34cce440404a66643a1cf32388fa5c40f7d92d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c34cce440404a66643a1cf32388fa5c40f7d92d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c34cce440404a66643a1cf32388fa5c40f7d92d1"}], "stats": {"total": 475, "additions": 317, "deletions": 158}, "files": [{"sha": "bf70736c125a8e84ac99ea9a9aea23321d9d3d47", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c50594233b1cf896e3383fd4f2988819d2bba440", "patch": "@@ -1,3 +1,24 @@\n+2001-08-27  Alan Modra  <amodra@bigpond.net.au>\n+\n+\t* config/rs6000/rs6000.c (mask_operand): Rewrite without\n+\tbit-shifting loop.\n+\t(mask64_operand): Likewise.\n+\t(rldic_operand): Delete.\n+\t(includes_lshift64_p): Delete.\n+\t(includes_rldic_lshift_p): New function.\n+\t(includes_rldicr_lshift_p): New function.\n+\t(print_operand): Don't call rldic_operand in case 'W'.\n+\t* config/rs6000/rs6000-protos.h (rldic_operand): Remove.\n+\t(includes_lshift64_p): Remove.\n+\t(includes_rldic_lshift_p): Declare.\n+\t(includes_rldicr_lshift_p): Declare.\n+\t* config/rs6000/rs6000.h (PREDICATE_CODES): Remove rldic_operand.\n+\t* config/rs6000/rs6000.md <ashldi3_internal 64 bit patterns>:\n+\tReplace match_operand rldic_operand predicate with\n+\tconst_int_operand.  Replace includes_lshift64_p condition with\n+\tincludes_rldic_lshift_p.\n+\t<ashldi3_internal 64 bit rldicr patterns>: New.\n+\n 2001-08-27  Andreas Jaeger  <aj@suse.de>\n \n \t* emit-rtl.c: Use VA_OPEN/VA_CLOSE/VA_FIXEDARG throughout."}, {"sha": "3a205e29e005d245ea7f10ace052226310eff201", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=c50594233b1cf896e3383fd4f2988819d2bba440", "patch": "@@ -60,7 +60,6 @@ extern int non_logical_cint_operand PARAMS ((rtx, enum machine_mode));\n extern int logical_operand PARAMS ((rtx, enum machine_mode));\n extern int mask_operand PARAMS ((rtx, enum machine_mode));\n extern int mask64_operand PARAMS ((rtx, enum machine_mode));\n-extern int rldic_operand PARAMS ((rtx, enum machine_mode));\n extern int and64_operand PARAMS ((rtx, enum machine_mode));\n extern int and_operand PARAMS ((rtx, enum machine_mode));\n extern int count_register_operand PARAMS ((rtx, enum machine_mode));\n@@ -86,7 +85,8 @@ extern int boolean_or_operator PARAMS ((rtx, enum machine_mode));\n extern int min_max_operator PARAMS ((rtx, enum machine_mode));\n extern int includes_lshift_p PARAMS ((rtx, rtx));\n extern int includes_rshift_p PARAMS ((rtx, rtx));\n-extern int includes_lshift64_p PARAMS ((rtx, rtx));\n+extern int includes_rldic_lshift_p PARAMS ((rtx, rtx));\n+extern int includes_rldicr_lshift_p PARAMS ((rtx, rtx));\n extern int registers_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern int addrs_ok_for_quad_peep PARAMS ((rtx, rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,"}, {"sha": "c902564baee0d8871aa7830ae9a7a7a9ab288403", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 206, "deletions": 145, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c50594233b1cf896e3383fd4f2988819d2bba440", "patch": "@@ -1158,26 +1158,36 @@ mask_operand (op, mode)\n      register rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  HOST_WIDE_INT c;\n-  int i;\n-  int last_bit_value;\n-  int transitions = 0;\n+  unsigned HOST_WIDE_INT c, lsb;\n \n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n \n   c = INTVAL (op);\n \n-  if (c == 0 || c == ~0)\n+  /* We don't change the number of transitions by inverting,\n+     so make sure we start with the LS bit zero.  */\n+  if (c & 1)\n+    c = ~c;\n+\n+  /* Reject all zeros or all ones.  */\n+  if (c == 0)\n     return 0;\n \n-  last_bit_value = c & 1;\n+  /* Find the first transition.  */\n+  lsb = c & -c;\n+\n+  /* Invert to look for a second transition.  */\n+  c = ~c;\n \n-  for (i = 1; i < 32; i++)\n-    if (((c >>= 1) & 1) != last_bit_value)\n-      last_bit_value ^= 1, transitions++;\n+  /* Erase first transition.  */\n+  c &= -lsb;\n \n-  return transitions <= 2;\n+  /* Find the second transition (if any).  */\n+  lsb = c & -c;\n+\n+  /* Match if all the bits above are 1's (or c is zero).  */\n+  return c == -lsb;\n }\n \n /* Return 1 if the operand is a constant that is a PowerPC64 mask.\n@@ -1192,133 +1202,49 @@ mask64_operand (op, mode)\n {\n   if (GET_CODE (op) == CONST_INT)\n     {\n-      HOST_WIDE_INT c = INTVAL (op);\n-      int i;\n-      int last_bit_value;\n-      int transitions = 0;\n-\n-      if (c == 0 || c == ~0)\n-\treturn 0;\n-\n-      last_bit_value = c & 1;\n-\n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((c >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n+      unsigned HOST_WIDE_INT c, lsb;\n \n-      return transitions <= 1;\n-    }\n-  else if (GET_CODE (op) == CONST_DOUBLE\n-\t   && (mode == VOIDmode || mode == DImode))\n-    {\n-      HOST_WIDE_INT low = CONST_DOUBLE_LOW (op);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      HOST_WIDE_INT high = CONST_DOUBLE_HIGH (op);\n-#endif\n-      int i;\n-      int last_bit_value;\n-      int transitions = 0;\n+      /* We don't change the number of transitions by inverting,\n+\t so make sure we start with the LS bit zero.  */\n+      c = INTVAL (op);\n+      if (c & 1)\n+\tc = ~c;\n \n-      if ((low == 0\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  && high == 0\n-#endif\n-\t   )\n-\t  || (low == ~0\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t      && high == ~0\n-#endif\n-\t      ))\n+      /* Reject all zeros or all ones.  */\n+      if (c == 0)\n \treturn 0;\n \n-      last_bit_value = low & 1;\n-\n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((low >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n-\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      if ((high & 1) != last_bit_value)\n-\tlast_bit_value ^= 1, transitions++;\n-\n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((high >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n-#endif\n-\n-      return transitions <= 1;\n-    }\n-  else\n-    return 0;\n-}\n-\n-/* Return 1 if the operand is a constant that is a PowerPC64 mask.\n-   It is if there are no more than two 1->0 or 0->1 transitions.\n-   Reject all ones and all zeros, since these should have been optimized\n-   away and confuse the making of MB and ME.  */\n-\n-int\n-rldic_operand (op, mode)\n-     register rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT c = INTVAL (op);\n-      int i;\n-      int last_bit_value;\n-      int transitions = 0;\n-\n-      if (c == 0 || c == ~0)\n-\treturn 0;\n-\n-      last_bit_value = c & 1;\n-\n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((c >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n-\n-      return transitions <= 2;\n+      /* Find the transition, and check that all bits above are 1's.  */\n+      lsb = c & -c;\n+      return c == -lsb;\n     }\n   else if (GET_CODE (op) == CONST_DOUBLE\n \t   && (mode == VOIDmode || mode == DImode))\n     {\n-      HOST_WIDE_INT low = CONST_DOUBLE_LOW (op);\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      HOST_WIDE_INT high = CONST_DOUBLE_HIGH (op);\n-#endif\n-      int i;\n-      int last_bit_value;\n-      int transitions = 0;\n-\n-      if ((low == 0\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t  && high == 0\n-#endif\n-\t   )\n-\t  || (low == ~0\n-#if HOST_BITS_PER_WIDE_INT == 32\n-\t      && high == ~0\n-#endif\n-\t      ))\n-\treturn 0;\n+      unsigned HOST_WIDE_INT low, high, lsb;\n \n-      last_bit_value = low & 1;\n+      if (HOST_BITS_PER_WIDE_INT < 64)\n+\thigh = CONST_DOUBLE_HIGH (op);\n \n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((low >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n+      low = CONST_DOUBLE_LOW (op);\n+      if (low & 1)\n+\t{\n+\t  if (HOST_BITS_PER_WIDE_INT < 64)\n+\t    high = ~high;\n+\t  low = ~low;\n+\t}\n \n-#if HOST_BITS_PER_WIDE_INT == 32\n-      if ((high & 1) != last_bit_value)\n-\tlast_bit_value ^= 1, transitions++;\n+      if (low == 0)\n+\t{\n+\t  if (HOST_BITS_PER_WIDE_INT >= 64 || high == 0)\n+\t    return 0;\n \n-      for (i = 1; i < HOST_BITS_PER_WIDE_INT; i++)\n-\tif (((high >>= 1) & 1) != last_bit_value)\n-\t  last_bit_value ^= 1, transitions++;\n-#endif\n+\t  lsb = high & -high;\n+\t  return high == -lsb;\n+\t}\n \n-      return transitions <= 2;\n+      lsb = low & -low;\n+      return low == -lsb && (HOST_BITS_PER_WIDE_INT >= 64 || high == ~0);\n     }\n   else\n     return 0;\n@@ -3705,36 +3631,174 @@ includes_rshift_p (shiftop, andop)\n   return (INTVAL (andop) & ~shift_mask) == 0;\n }\n \n-/* Return 1 if ANDOP is a mask that has no bits on that are not in the\n-   mask required to convert the result of a rotate insn into a shift\n-   left insn of SHIFTOP bits.  */\n+/* Return 1 if ANDOP is a mask suitable for use with an rldic insn\n+   to perform a left shift.  It must have exactly SHIFTOP least\n+   signifigant 0's, then one or more 1's, then zero or more 0's.  */\n \n int\n-includes_lshift64_p (shiftop, andop)\n+includes_rldic_lshift_p (shiftop, andop)\n      register rtx shiftop;\n      register rtx andop;\n {\n-#if HOST_BITS_PER_WIDE_INT == 64\n-  unsigned HOST_WIDE_INT shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+  if (GET_CODE (andop) == CONST_INT)\n+    {\n+      unsigned HOST_WIDE_INT c, lsb, shift_mask;\n \n-  shift_mask <<= INTVAL (shiftop);\n+      c = INTVAL (andop);\n+      if (c == 0 || c == ~(unsigned HOST_WIDE_INT) 0)\n+\treturn 0;\n \n-  return (INTVAL (andop) & ~shift_mask) == 0;\n-#else\n-  unsigned HOST_WIDE_INT shift_mask_low = ~(unsigned HOST_WIDE_INT) 0;\n-  unsigned HOST_WIDE_INT shift_mask_high = ~(unsigned HOST_WIDE_INT) 0;\n+      shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+      shift_mask <<= INTVAL (shiftop);\n+\n+      /* Find the least signifigant one bit.  */\n+      lsb = c & -c;\n+\n+      /* It must coincide with the LSB of the shift mask.  */\n+      if (-lsb != shift_mask)\n+\treturn 0;\n+\n+      /* Invert to look for the next transition (if any).  */\n+      c = ~c;\n+\n+      /* Remove the low group of ones (originally low group of zeros).  */\n+      c &= -lsb;\n+\n+      /* Again find the lsb, and check we have all 1's above.  */\n+      lsb = c & -c;\n+      return c == -lsb;\n+    }\n+  else if (GET_CODE (andop) == CONST_DOUBLE\n+\t   && (GET_MODE (andop) == VOIDmode || GET_MODE (andop) == DImode))\n+    {\n+      unsigned HOST_WIDE_INT low, high, lsb;\n+      unsigned HOST_WIDE_INT shift_mask_low, shift_mask_high;\n+\n+      low = CONST_DOUBLE_LOW (andop);\n+      if (HOST_BITS_PER_WIDE_INT < 64)\n+\thigh = CONST_DOUBLE_HIGH (andop);\n+\n+      if ((low == 0 && (HOST_BITS_PER_WIDE_INT >= 64 || high == 0))\n+\t  || (low == ~(unsigned HOST_WIDE_INT) 0\n+\t      && (HOST_BITS_PER_WIDE_INT >= 64\n+\t\t  || high == ~(unsigned HOST_WIDE_INT) 0)))\n+\treturn 0;\n+\n+      if (HOST_BITS_PER_WIDE_INT < 64 && low == 0)\n+\t{\n+\t  shift_mask_high = ~(unsigned HOST_WIDE_INT) 0;\n+\t  if (INTVAL (shiftop) > 32)\n+\t    shift_mask_high <<= INTVAL (shiftop) - 32;\n \n-  shift_mask_low <<= INTVAL (shiftop);\n+\t  lsb = high & -high;\n+\n+\t  if (-lsb != shift_mask_high || INTVAL (shiftop) < 32)\n+\t    return 0;\n+\n+\t  high = ~high;\n+\t  high &= -lsb;\n+\n+\t  lsb = high & -high;\n+\t  return high == -lsb;\n+\t}\n+\n+      shift_mask_low = ~(unsigned HOST_WIDE_INT) 0;\n+      shift_mask_low <<= INTVAL (shiftop);\n+\n+      lsb = low & -low;\n+\n+      if (-lsb != shift_mask_low)\n+\treturn 0;\n+\n+      if (HOST_BITS_PER_WIDE_INT < 64)\n+\thigh = ~high;\n+      low = ~low;\n+      low &= -lsb;\n+\n+      if (HOST_BITS_PER_WIDE_INT < 64 && low == 0)\n+\t{\n+\t  lsb = high & -high;\n+\t  return high == -lsb;\n+\t}\n+\n+      lsb = low & -low;\n+      return low == -lsb && (HOST_BITS_PER_WIDE_INT >= 64 || high == ~0);\n+    }\n+  else\n+    return 0;\n+}\n \n-  if (INTVAL (shiftop) > 32)\n-    shift_mask_high <<= (INTVAL (shiftop) - 32);\n+/* Return 1 if ANDOP is a mask suitable for use with an rldicr insn\n+   to perform a left shift.  It must have SHIFTOP or more least\n+   signifigant 0's, with the remainder of the word 1's.  */\n \n+int\n+includes_rldicr_lshift_p (shiftop, andop)\n+     register rtx shiftop;\n+     register rtx andop;\n+{\n   if (GET_CODE (andop) == CONST_INT)\n-    return (INTVAL (andop) & ~shift_mask_low) == 0;\n+    {\n+      unsigned HOST_WIDE_INT c, lsb;\n+      unsigned HOST_WIDE_INT shift_mask;\n+\n+      shift_mask = ~(unsigned HOST_WIDE_INT) 0;\n+      shift_mask <<= INTVAL (shiftop);\n+      c = INTVAL (andop);\n+\n+      /* Find the least signifigant one bit.  */\n+      lsb = c & -c;\n+\n+      /* It must be covered by the shift mask.\n+\t This test also rejects c == 0. */\n+      if ((lsb & shift_mask) == 0)\n+\treturn 0;\n+\n+      /* Check we have all 1's above the transition, and reject all 1's.  */\n+      return c == -lsb && lsb != 1;\n+    }\n+  else if (GET_CODE (andop) == CONST_DOUBLE\n+\t   && (GET_MODE (andop) == VOIDmode || GET_MODE (andop) == DImode))\n+    {\n+      unsigned HOST_WIDE_INT low, lsb, shift_mask_low;\n+\n+      low = CONST_DOUBLE_LOW (andop);\n+\n+      if (HOST_BITS_PER_WIDE_INT < 64)\n+\t{\n+\t  unsigned HOST_WIDE_INT high, shift_mask_high;\n+\n+\t  high = CONST_DOUBLE_HIGH (andop);\n+\n+\t  if (low == 0)\n+\t    {\n+\t      shift_mask_high = ~(unsigned HOST_WIDE_INT) 0;\n+\t      if (INTVAL (shiftop) > 32)\n+\t\tshift_mask_high <<= INTVAL (shiftop) - 32;\n+\n+\t      lsb = high & -high;\n+\n+\t      if ((lsb & shift_mask_high) == 0)\n+\t\treturn 0;\n+\n+\t      return high == -lsb;\n+\t    }\n+\t  if (high != ~0)\n+\t    return 0;\n+\t}\n+\n+      shift_mask_low = ~(unsigned HOST_WIDE_INT) 0;\n+      shift_mask_low <<= INTVAL (shiftop);\n+\n+      lsb = low & -low;\n+\n+      if ((lsb & shift_mask_low) == 0)\n+\treturn 0;\n+\n+      return low == -lsb && lsb != 1;\n+    }\n   else\n-    return ((CONST_DOUBLE_HIGH (andop) & ~shift_mask_high) == 0\n-\t    && (CONST_DOUBLE_LOW (andop) & ~shift_mask_low) == 0);\n-#endif\n+    return 0;\n }\n \n /* Return 1 if REGNO (reg1) == REGNO (reg2) - 1 making them candidates\n@@ -4537,9 +4601,6 @@ print_operand (file, x, code)\n \n     case 'W':\n       /* MB value for a PowerPC64 rldic operand.  */\n-      if (! rldic_operand (x, VOIDmode))\n-\toutput_operand_lossage (\"invalid %%W value\");\n-\n       val = (GET_CODE (x) == CONST_INT\n \t     ? INTVAL (x) : CONST_DOUBLE_HIGH (x));\n "}, {"sha": "b602dfb8526235e9b4850145154e9613c00cba78", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=c50594233b1cf896e3383fd4f2988819d2bba440", "patch": "@@ -2585,7 +2585,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\t   \\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\t   \\\n   {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t   \\\n-  {\"rldic_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\t   \\\n   {\"count_register_operand\", {REG}},\t\t\t\t\t   \\\n   {\"xer_operand\", {REG}},\t\t\t\t\t\t   \\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\t   \\"}, {"sha": "d116a6353843713bd21320d856650b0378079002", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c50594233b1cf896e3383fd4f2988819d2bba440/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c50594233b1cf896e3383fd4f2988819d2bba440", "patch": "@@ -6559,19 +6559,19 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"rldic_operand\" \"n\")))]\n-  \"TARGET_POWERPC64 && includes_lshift64_p (operands[2], operands[3])\"\n+\t\t(match_operand:DI 3 \"const_int_operand\" \"n\")))]\n+  \"TARGET_POWERPC64 && includes_rldic_lshift_p (operands[2], operands[3])\"\n   \"rldic %0,%1,%H2,%W3\")\n \n (define_insn \"ashldi3_internal5\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"rldic_operand\" \"n,n\"))\n+\t\t (match_operand:DI 3 \"const_int_operand\" \"n,n\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n-  \"TARGET_POWERPC64 && includes_lshift64_p (operands[2], operands[3])\"\n+  \"TARGET_POWERPC64 && includes_rldic_lshift_p (operands[2], operands[3])\"\n   \"@\n    rldic. %4,%1,%H2,%W3\n    #\"\n@@ -6583,10 +6583,11 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"rldic_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"const_int_operand\" \"\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_POWERPC64 && includes_lshift64_p (operands[2], operands[3]) && reload_completed\"\n+  \"TARGET_POWERPC64 && reload_completed\n+   && includes_rldic_lshift_p (operands[2], operands[3])\"\n   [(set (match_dup 4)\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n \t\t(match_dup 3)))\n@@ -6600,11 +6601,11 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t    (match_operand:DI 3 \"rldic_operand\" \"n,n\"))\n+\t\t    (match_operand:DI 3 \"const_int_operand\" \"n,n\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_POWERPC64 && includes_lshift64_p (operands[2], operands[3])\"\n+  \"TARGET_POWERPC64 && includes_rldic_lshift_p (operands[2], operands[3])\"\n   \"@\n    rldic. %0,%1,%H2,%W3\n    #\"\n@@ -6616,11 +6617,88 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"rldic_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"const_int_operand\" \"\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n-  \"TARGET_POWERPC64 && includes_lshift64_p (operands[2], operands[3]) && reload_completed\"\n+  \"TARGET_POWERPC64 && reload_completed\n+   && includes_rldic_lshift_p (operands[2], operands[3])\"\n+  [(set (match_dup 0)\n+\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n+\t\t(match_dup 3)))\n+   (set (match_dup 4)\n+\t(compare:CC (match_dup 0)\n+\t\t    (const_int 0)))]\n+  \"\")\n+\n+(define_insn \"*ashldi3_internal7\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+\t\t(match_operand:DI 3 \"mask64_operand\" \"S\")))]\n+  \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n+  \"rldicr %0,%1,%H2,%S3\")\n+\n+(define_insn \"ashldi3_internal8\"\n+  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC\n+\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"S,S\"))\n+\t (const_int 0)))\n+   (clobber (match_scratch:DI 4 \"=r,r\"))]\n+  \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n+  \"@\n+   rldicr. %4,%1,%H2,%S3\n+   #\"\n+  [(set_attr \"type\" \"delayed_compare\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_split\n+  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n+\t(compare:CC\n+\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t (const_int 0)))\n+   (clobber (match_scratch:DI 4 \"\"))]\n+  \"TARGET_POWERPC64 && reload_completed\n+   && includes_rldicr_lshift_p (operands[2], operands[3])\"\n+  [(set (match_dup 4)\n+\t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n+\t\t(match_dup 3)))\n+   (set (match_dup 0)\n+\t(compare:CC (match_dup 4)\n+\t\t    (const_int 0)))]\n+  \"\")\n+\n+(define_insn \"*ashldi3_internal9\"\n+  [(set (match_operand:CC 4 \"cc_reg_operand\" \"=x,?y\")\n+\t(compare:CC\n+\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n+\t\t    (match_operand:DI 3 \"mask64_operand\" \"S,S\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n+  \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n+  \"@\n+   rldicr. %0,%1,%H2,%S3\n+   #\"\n+  [(set_attr \"type\" \"delayed_compare\")\n+   (set_attr \"length\" \"4,8\")])\n+\n+(define_split\n+  [(set (match_operand:CC 4 \"cc_reg_not_cr0_operand\" \"\")\n+\t(compare:CC\n+\t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t (const_int 0)))\n+   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n+\t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n+  \"TARGET_POWERPC64 && reload_completed\n+   && includes_rldicr_lshift_p (operands[2], operands[3])\"\n   [(set (match_dup 0)\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2))\n \t\t(match_dup 3)))"}]}