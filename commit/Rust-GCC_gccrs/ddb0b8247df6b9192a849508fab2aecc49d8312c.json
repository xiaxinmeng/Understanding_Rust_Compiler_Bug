{"sha": "ddb0b8247df6b9192a849508fab2aecc49d8312c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiMGI4MjQ3ZGY2YjkxOTJhODQ5NTA4ZmFiMmFlY2M0OWQ4MzEyYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-04-29T16:22:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-04-29T16:22:35Z"}, "message": "lto-partition.c: Include sreal.h\n\n\n\t* lto-partition.c: Include sreal.h\n\t(add_symbol_to_partition_1): Use size instead of self_size\n\tfor size estimate.\n\t(account_reference_p): New.\n\t(lto_balanced_map): Use 64bit arithmetics for size calculatoins; cleanup;\n\tfix accounting errors in boundary size; add debug output; combine cost\n\tas cost/size instead of cost/internal; reduce the partitioning error to\n\t+- 1/8 of the parttion size.\n\nFrom-SVN: r259749", "tree": {"sha": "4ef395f7c7fcc0cdec6de1769e85c3c9e7f4f407", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ef395f7c7fcc0cdec6de1769e85c3c9e7f4f407"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddb0b8247df6b9192a849508fab2aecc49d8312c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb0b8247df6b9192a849508fab2aecc49d8312c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb0b8247df6b9192a849508fab2aecc49d8312c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb0b8247df6b9192a849508fab2aecc49d8312c/comments", "author": null, "committer": null, "parents": [{"sha": "8d70b61edda10e97686da47decfc7f93ff0bc7c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d70b61edda10e97686da47decfc7f93ff0bc7c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d70b61edda10e97686da47decfc7f93ff0bc7c9"}], "stats": {"total": 140, "additions": 91, "deletions": 49}, "files": [{"sha": "6d00e4ebdfbcad47c254df2acc1bd1eb033a7a69", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb0b8247df6b9192a849508fab2aecc49d8312c/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb0b8247df6b9192a849508fab2aecc49d8312c/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=ddb0b8247df6b9192a849508fab2aecc49d8312c", "patch": "@@ -1,3 +1,14 @@\n+2018-04-19  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto-partition.c: Include sreal.h\n+\t(add_symbol_to_partition_1): Use size instead of self_size\n+\tfor size estimate.\n+\t(account_reference_p): New.\n+\t(lto_balanced_map): Use 64bit arithmetics for size calculatoins; cleanup;\n+\tfix accounting errors in boundary size; add debug output; combine cost\n+\tas cost/size instead of cost/internal; reduce the partitioning error to\n+\t+- 1/8 of the parttion size.\n+\n 2018-04-19  Martin Liska  <mliska@suse.cz>\n \n \t* lto-symtab.c (lto_symtab_resolve_symbols): Do not bail out"}, {"sha": "d83eba297ec06c41bb68e717f74db31a384c0662", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 80, "deletions": 49, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb0b8247df6b9192a849508fab2aecc49d8312c/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb0b8247df6b9192a849508fab2aecc49d8312c/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=ddb0b8247df6b9192a849508fab2aecc49d8312c", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n #include \"lto-partition.h\"\n+#include \"sreal.h\"\n \n vec<ltrans_partition> ltrans_partitions;\n \n@@ -152,8 +153,8 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     {\n       struct cgraph_edge *e;\n-      if (!node->alias)\n-        part->insns += ipa_fn_summaries->get (cnode)->self_size;\n+      if (!node->alias && c == SYMBOL_PARTITION)\n+        part->insns += ipa_fn_summaries->get (cnode)->size;\n \n       /* Add all inline clones and callees that are duplicated.  */\n       for (e = cnode->callees; e; e = e->next_callee)\n@@ -276,8 +277,9 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \tdelete partition->initializers_visited;\n       partition->initializers_visited = NULL;\n \n-      if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node)))\n-        partition->insns -= ipa_fn_summaries->get (cnode)->self_size;\n+      if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node))\n+          && node->get_partitioning_class () == SYMBOL_PARTITION)\n+        partition->insns -= ipa_fn_summaries->get (cnode)->size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n     }\n@@ -408,6 +410,24 @@ add_sorted_nodes (vec<symtab_node *> &next_nodes, ltrans_partition partition)\n       add_symbol_to_partition (partition, node);\n }\n \n+/* Return true if we should account reference from N1 to N2 in cost\n+   of partition boundary.  */\n+\n+bool\n+account_reference_p (symtab_node *n1, symtab_node *n2)\n+{\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (n1))\n+    n1 = cnode;\n+  /* Do not account recursion - the code below will handle it incorrectly\n+     otherwise.  Also do not account references to external symbols.\n+     They will never become local.  */\n+  if (n1 == n2 \n+      || DECL_EXTERNAL (n2->decl)\n+      || !n2->definition)\n+    return false;\n+  return true;\n+}\n+\n \n /* Group cgraph nodes into equally-sized partitions.\n \n@@ -457,14 +477,14 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   auto_vec<varpool_node *> varpool_order;\n   int i;\n   struct cgraph_node *node;\n-  int original_total_size, total_size = 0, best_total_size = 0;\n-  int partition_size;\n+  int64_t original_total_size, total_size = 0;\n+  int64_t partition_size;\n   ltrans_partition partition;\n   int last_visited_node = 0;\n   varpool_node *vnode;\n-  int cost = 0, internal = 0;\n-  int best_n_nodes = 0, best_i = 0, best_cost =\n-    INT_MAX, best_internal = 0;\n+  int64_t cost = 0, internal = 0;\n+  int best_n_nodes = 0, best_i = 0;\n+  int64_t best_cost = -1, best_internal = 0, best_size = 0;\n   int npartitions;\n   int current_order = -1;\n   int noreorder_pos = 0;\n@@ -513,15 +533,16 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \n   /* Compute partition size and create the first partition.  */\n   if (PARAM_VALUE (MIN_PARTITION_SIZE) > max_partition_size)\n-    fatal_error (input_location, \"min partition size cannot be greater than max partition size\");\n+    fatal_error (input_location, \"min partition size cannot be greater \"\n+\t\t \"than max partition size\");\n \n   partition_size = total_size / n_lto_partitions;\n   if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n     partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n   npartitions = 1;\n   partition = new_partition (\"\");\n   if (symtab->dump_file)\n-    fprintf (symtab->dump_file, \"Total unit size: %i, partition size: %i\\n\",\n+    fprintf (symtab->dump_file, \"Total unit size: %\" PRId64 \", partition size: %\" PRId64 \"\\n\",\n \t     total_size, partition_size);\n \n   auto_vec<symtab_node *> next_nodes;\n@@ -540,17 +561,11 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \tnext_nodes.safe_push (varpool_order[varpool_pos++]);\n       while (noreorder_pos < (int)noreorder.length ()\n \t     && noreorder[noreorder_pos]->order < current_order)\n-\t{\n-\t  if (!noreorder[noreorder_pos]->alias)\n-\t    total_size -= ipa_fn_summaries->get (noreorder[noreorder_pos])->size;\n-\t  next_nodes.safe_push (noreorder[noreorder_pos++]);\n-\t}\n+\tnext_nodes.safe_push (noreorder[noreorder_pos++]);\n       add_sorted_nodes (next_nodes, partition);\n \n       if (!symbol_partitioned_p (order[i]))\n         add_symbol_to_partition (partition, order[i]);\n-      if (!order[i]->alias)\n-        total_size -= ipa_fn_summaries->get (order[i])->size;\n \t  \n \n       /* Once we added a new node to the partition, we also want to add\n@@ -567,7 +582,6 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t it and thus we need to subtract it from COST.  */\n       while (last_visited_node < lto_symtab_encoder_size (partition->encoder))\n \t{\n-\t  symtab_node *refs_node;\n \t  int j;\n \t  struct ipa_ref *ref = NULL;\n \t  symtab_node *snode = lto_symtab_encoder_deref (partition->encoder,\n@@ -577,15 +591,16 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t    {\n \t      struct cgraph_edge *edge;\n \n-\t      refs_node = node;\n \n \t      last_visited_node++;\n \n \t      gcc_assert (node->definition || node->weakref);\n \n \t      /* Compute boundary cost of callgraph edges.  */\n \t      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t\tif (edge->callee->definition)\n+\t\t/* Inline edges will always end up local.  */\n+\t\tif (edge->inline_failed\n+\t\t    && account_reference_p (node, edge->callee))\n \t\t  {\n \t\t    int edge_cost = edge->frequency ();\n \t\t    int index;\n@@ -602,6 +617,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t      cost += edge_cost;\n \t\t  }\n \t      for (edge = node->callers; edge; edge = edge->next_caller)\n+\t\tif (edge->inline_failed\n+\t\t    && account_reference_p (edge->caller, node))\n \t\t{\n \t\t  int edge_cost = edge->frequency ();\n \t\t  int index;\n@@ -614,27 +631,24 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t\t\t\t\t     edge->caller);\n \t\t  if (index != LCC_NOT_FOUND\n \t\t      && index < last_visited_node - 1)\n-\t\t    cost -= edge_cost;\n+\t\t    cost -= edge_cost, internal += edge_cost;\n \t\t  else\n \t\t    cost += edge_cost;\n \t\t}\n \t    }\n \t  else\n-\t    {\n-\t      refs_node = snode;\n-\t      last_visited_node++;\n-\t    }\n+\t    last_visited_node++;\n \n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n-\t  for (j = 0; refs_node->iterate_reference (j, ref); j++)\n-\t    if (is_a <varpool_node *> (ref->referred))\n+\t  for (j = 0; snode->iterate_reference (j, ref); j++)\n+\t    if (!account_reference_p (snode, ref->referred))\n+\t      ;\n+\t    else if (is_a <varpool_node *> (ref->referred))\n \t      {\n \t\tint index;\n \n \t\tvnode = dyn_cast <varpool_node *> (ref->referred);\n-\t\tif (!vnode->definition)\n-\t\t  continue;\n \t\tif (!symbol_partitioned_p (vnode)\n \t\t    && !vnode->no_reorder\n \t\t    && vnode->get_partitioning_class () == SYMBOL_PARTITION)\n@@ -652,8 +666,6 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\tint index;\n \n \t\tnode = dyn_cast <cgraph_node *> (ref->referred);\n-\t\tif (!node->definition)\n-\t\t  continue;\n \t\tindex = lto_symtab_encoder_lookup (partition->encoder,\n \t\t\t\t\t\t   node);\n \t\tif (index != LCC_NOT_FOUND\n@@ -662,8 +674,10 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\telse\n \t\t  cost++;\n \t      }\n-\t  for (j = 0; refs_node->iterate_referring (j, ref); j++)\n-\t    if (is_a <varpool_node *> (ref->referring))\n+\t  for (j = 0; snode->iterate_referring (j, ref); j++)\n+\t    if (!account_reference_p (ref->referring, snode))\n+\t      ;\n+\t    else if (is_a <varpool_node *> (ref->referring))\n \t      {\n \t\tint index;\n \n@@ -682,7 +696,7 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t\t\t\t\t   vnode);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n-\t\t  cost--;\n+\t\t  cost--, internal++;\n \t\telse\n \t\t  cost++;\n \t      }\n@@ -696,36 +710,41 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t\t\t\t\t\t   node);\n \t\tif (index != LCC_NOT_FOUND\n \t\t    && index < last_visited_node - 1)\n-\t\t  cost--;\n+\t\t  cost--, internal++;\n \t\telse\n \t\t  cost++;\n \t      }\n \t}\n \n-      /* If the partition is large enough, start looking for smallest boundary cost.  */\n-      if (partition->insns < partition_size * 3 / 4\n-\t  || best_cost == INT_MAX\n-\t  || ((!cost \n-\t       || (best_internal * (HOST_WIDE_INT) cost\n-\t\t   > (internal * (HOST_WIDE_INT)best_cost)))\n-  \t      && partition->insns < partition_size * 5 / 4))\n+      gcc_assert (cost >= 0 && internal >= 0);\n+\n+      /* If the partition is large enough, start looking for smallest boundary cost.\n+         If partition still seems too small (less than 7/8 of target weight) accept\n+\t any cost.  If partition has right size, optimize for highest internal/cost.\n+\t Later we stop building partition if its size is 9/8 of the target wight.  */\n+      if (partition->insns < partition_size * 7 / 8\n+\t  || best_cost == -1\n+\t  || (!cost \n+\t      || ((sreal)best_internal * (sreal) cost\n+\t\t  < ((sreal) internal * (sreal)best_cost))))\n \t{\n \t  best_cost = cost;\n \t  best_internal = internal;\n+\t  best_size = partition->insns;\n \t  best_i = i;\n \t  best_n_nodes = lto_symtab_encoder_size (partition->encoder);\n-\t  best_total_size = total_size;\n \t  best_varpool_pos = varpool_pos;\n \t}\n       if (symtab->dump_file)\n-\tfprintf (symtab->dump_file, \"Step %i: added %s/%i, size %i, cost %i/%i \"\n-\t\t \"best %i/%i, step %i\\n\", i,\n+\tfprintf (symtab->dump_file, \"Step %i: added %s/%i, size %i, \"\n+\t\t \"cost %\" PRId64 \"/%\" PRId64 \" \"\n+\t\t \"best %\" PRId64 \"/%\" PRId64\", step %i\\n\", i,\n \t\t order[i]->name (), order[i]->order,\n \t\t partition->insns, cost, internal,\n \t\t best_cost, best_internal, best_i);\n       /* Partition is too large, unwind into step when best cost was reached and\n \t start new partition.  */\n-      if (partition->insns > 2 * partition_size\n+      if (partition->insns > 9 * partition_size / 8\n \t  || partition->insns > max_partition_size)\n \t{\n \t  if (best_i != i)\n@@ -736,21 +755,26 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t      undo_partition (partition, best_n_nodes);\n \t      varpool_pos = best_varpool_pos;\n \t    }\n+\t  gcc_assert (best_size == partition->insns);\n \t  i = best_i;\n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file,\n+\t\t     \"Partition insns: %i (want %\" PRId64 \")\\n\",\n+\t\t     partition->insns, partition_size);\n  \t  /* When we are finished, avoid creating empty partition.  */\n \t  while (i < n_nodes - 1 && symbol_partitioned_p (order[i + 1]))\n \t    i++;\n \t  if (i == n_nodes - 1)\n \t    break;\n+\t  total_size -= partition->insns;\n \t  partition = new_partition (\"\");\n \t  last_visited_node = 0;\n-\t  total_size = best_total_size;\n \t  cost = 0;\n \n \t  if (symtab->dump_file)\n \t    fprintf (symtab->dump_file, \"New partition\\n\");\n \t  best_n_nodes = 0;\n-\t  best_cost = INT_MAX;\n+\t  best_cost = -1;\n \n \t  /* Since the size of partitions is just approximate, update the size after\n \t     we finished current one.  */\n@@ -760,6 +784,10 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t    /* Watch for overflow.  */\n \t    partition_size = INT_MAX / 16;\n \n+\t  if (symtab->dump_file)\n+\t    fprintf (symtab->dump_file,\n+\t\t     \"Total size: %\" PRId64 \" partition_size: %\" PRId64 \"\\n\",\n+\t\t     total_size, partition_size);\n \t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n \t    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n \t  npartitions ++;\n@@ -779,6 +807,9 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n     next_nodes.safe_push (varpool_order[varpool_pos++]);\n   while (noreorder_pos < (int)noreorder.length ())\n     next_nodes.safe_push (noreorder[noreorder_pos++]);\n+  /* For one partition the cost of boundary should be 0 unless we added final\n+     symbols here (these are not accounted) or we have accounting bug.  */\n+  gcc_assert (next_nodes.length () || npartitions != 1 || !best_cost);\n   add_sorted_nodes (next_nodes, partition);\n \n   free (order);"}]}