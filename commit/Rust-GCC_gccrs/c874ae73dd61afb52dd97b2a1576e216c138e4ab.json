{"sha": "c874ae73dd61afb52dd97b2a1576e216c138e4ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg3NGFlNzNkZDYxYWZiNTJkZDk3YjJhMTU3NmUyMTZjMTM4ZTRhYg==", "commit": {"author": {"name": "Tobias Schl\u00fcter", "email": "tobias.schlueter@physik.uni-muenchen.de", "date": "2004-08-19T22:35:47Z"}, "committer": {"name": "Tobias Schl\u00fcter", "email": "tobi@gcc.gnu.org", "date": "2004-08-19T22:35:47Z"}, "message": "re PR fortran/17074 (Unclassifiable statement in IF-clause / Simple IF followed by WHERE)\n\nfortran/\n PR fortran/17074\n* match.c (match_simple_forall, match_simple_where): Forward-declare.\n(gfc_match_if): Order statement list alphabetically, add WHERE and\new functions.\n(gfc_match_forall): Use match_forall_header.\n\ntestsuite/\nPR fortran/17074\n* gfortran.dg/simpleif_1.f90: New test.\n\nFrom-SVN: r86290", "tree": {"sha": "22939e27fc65306dcecf94990bcb215537bc5aca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22939e27fc65306dcecf94990bcb215537bc5aca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c874ae73dd61afb52dd97b2a1576e216c138e4ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c874ae73dd61afb52dd97b2a1576e216c138e4ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c874ae73dd61afb52dd97b2a1576e216c138e4ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c874ae73dd61afb52dd97b2a1576e216c138e4ab/comments", "author": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TobiSchluter", "id": 11887541, "node_id": "MDQ6VXNlcjExODg3NTQx", "avatar_url": "https://avatars.githubusercontent.com/u/11887541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TobiSchluter", "html_url": "https://github.com/TobiSchluter", "followers_url": "https://api.github.com/users/TobiSchluter/followers", "following_url": "https://api.github.com/users/TobiSchluter/following{/other_user}", "gists_url": "https://api.github.com/users/TobiSchluter/gists{/gist_id}", "starred_url": "https://api.github.com/users/TobiSchluter/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TobiSchluter/subscriptions", "organizations_url": "https://api.github.com/users/TobiSchluter/orgs", "repos_url": "https://api.github.com/users/TobiSchluter/repos", "events_url": "https://api.github.com/users/TobiSchluter/events{/privacy}", "received_events_url": "https://api.github.com/users/TobiSchluter/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "401d6e7bf17405f21501b602d6469c9c2384e75d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/401d6e7bf17405f21501b602d6469c9c2384e75d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/401d6e7bf17405f21501b602d6469c9c2384e75d"}], "stats": {"total": 219, "additions": 200, "deletions": 19}, "files": [{"sha": "1adf05549cc708920f924d60429c22facf687584", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c874ae73dd61afb52dd97b2a1576e216c138e4ab", "patch": "@@ -1,3 +1,14 @@\n+2004-08-19  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+ \t(Port from g95)\n+\n+ \tPR fortran/17074\n+\t* match.c (match_simple_forall, match_simple_where): Forward-declare.\n+\t(gfc_match_if): Order statement list alphabetically, add WHERE and\n+\t\tFORALL, remove double PAUSE.\n+\t(gfc_match_simple_where, match_forall_header,\n+ \tgfc_match_simple_forall): New functions.\n+\t(gfc_match_forall): Use match_forall_header.\n+\t\n 2004-08-19  Paul Brook  <paul@codesourcery.com>\n \n \tPR fortran/17091"}, {"sha": "65af46ad779fff9cd7fbbf8efa052b25e7f800db", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 168, "deletions": 19, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=c874ae73dd61afb52dd97b2a1576e216c138e4ab", "patch": "@@ -912,6 +912,9 @@ gfc_match_pointer_assignment (void)\n    multiple times in order to guarantee that the symbol table ends up\n    in the proper state.  */\n \n+static match match_simple_forall (void);\n+static match match_simple_where (void);\n+\n match\n gfc_match_if (gfc_statement * if_type)\n {\n@@ -1025,6 +1028,7 @@ gfc_match_if (gfc_statement * if_type)\n   gfc_clear_error ();\n \n   match (\"allocate\", gfc_match_allocate, ST_ALLOCATE)\n+    match (\"assign\", gfc_match_assign, ST_LABEL_ASSIGNMENT)\n     match (\"backspace\", gfc_match_backspace, ST_BACKSPACE)\n     match (\"call\", gfc_match_call, ST_CALL)\n     match (\"close\", gfc_match_close, ST_CLOSE)\n@@ -1033,7 +1037,7 @@ gfc_match_if (gfc_statement * if_type)\n     match (\"deallocate\", gfc_match_deallocate, ST_DEALLOCATE)\n     match (\"end file\", gfc_match_endfile, ST_END_FILE)\n     match (\"exit\", gfc_match_exit, ST_EXIT)\n-    match (\"assign\", gfc_match_assign, ST_LABEL_ASSIGNMENT)\n+    match (\"forall\", match_simple_forall, ST_FORALL)\n     match (\"go to\", gfc_match_goto, ST_GOTO)\n     match (\"inquire\", gfc_match_inquire, ST_INQUIRE)\n     match (\"nullify\", gfc_match_nullify, ST_NULLIFY)\n@@ -1043,8 +1047,8 @@ gfc_match_if (gfc_statement * if_type)\n     match (\"read\", gfc_match_read, ST_READ)\n     match (\"return\", gfc_match_return, ST_RETURN)\n     match (\"rewind\", gfc_match_rewind, ST_REWIND)\n-    match (\"pause\", gfc_match_stop, ST_PAUSE)\n     match (\"stop\", gfc_match_stop, ST_STOP)\n+    match (\"where\", match_simple_where, ST_WHERE)\n     match (\"write\", gfc_match_write, ST_WRITE)\n \n   /* All else has failed, so give up.  See if any of the matchers has\n@@ -3170,6 +3174,51 @@ gfc_match_case (void)\n \n /********************* WHERE subroutines ********************/\n \n+/* Match the rest of a simple WHERE statement that follows an IF statement.  \n+ */\n+\n+static match\n+match_simple_where (void)\n+{\n+  gfc_expr *expr;\n+  gfc_code *c;\n+  match m;\n+\n+  m = gfc_match (\" ( %e )\", &expr);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  m = gfc_match_assignment ();\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    goto syntax;\n+\n+  c = gfc_get_code ();\n+\n+  c->op = EXEC_WHERE;\n+  c->expr = expr;\n+  c->next = gfc_get_code ();\n+\n+  *c->next = new_st;\n+  gfc_clear_new_st ();\n+\n+  new_st.op = EXEC_WHERE;\n+  new_st.block = c;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_WHERE);\n+\n+cleanup:\n+  gfc_free_expr (expr);\n+  return MATCH_ERROR;\n+}\n+\n /* Match a WHERE statement.  */\n \n match\n@@ -3374,27 +3423,21 @@ match_forall_iterator (gfc_forall_iterator ** result)\n }\n \n \n-/* Match a FORALL statement.  */\n+/* Match the header of a FORALL statement.  */\n \n-match\n-gfc_match_forall (gfc_statement * st)\n+static match\n+match_forall_header (gfc_forall_iterator ** phead, gfc_expr ** mask)\n {\n   gfc_forall_iterator *head, *tail, *new;\n-  gfc_expr *mask;\n-  gfc_code *c;\n-  match m0, m;\n+  match m;\n \n-  head = tail = NULL;\n-  mask = NULL;\n-  c = NULL;\n+  gfc_gobble_whitespace ();\n \n-  m0 = gfc_match_label ();\n-  if (m0 == MATCH_ERROR)\n-    return MATCH_ERROR;\n+  head = tail = NULL;\n+  *mask = NULL;\n \n-  m = gfc_match (\" forall (\");\n-  if (m != MATCH_YES)\n-    return m;\n+  if (gfc_match_char ('(') != MATCH_YES)\n+    return MATCH_NO;\n \n   m = match_forall_iterator (&new);\n   if (m == MATCH_ERROR)\n@@ -3419,8 +3462,9 @@ gfc_match_forall (gfc_statement * st)\n \t  continue;\n \t}\n \n-      /* Have to have a mask expression.  */\n-      m = gfc_match_expr (&mask);\n+      /* Have to have a mask expression */\n+\n+      m = gfc_match_expr (mask);\n       if (m == MATCH_NO)\n \tgoto syntax;\n       if (m == MATCH_ERROR)\n@@ -3432,6 +3476,111 @@ gfc_match_forall (gfc_statement * st)\n   if (gfc_match_char (')') == MATCH_NO)\n     goto syntax;\n \n+  *phead = head;\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_FORALL);\n+\n+cleanup:\n+  gfc_free_expr (*mask);\n+  gfc_free_forall_iterator (head);\n+\n+  return MATCH_ERROR;\n+}\n+\n+/* Match the rest of a simple FORALL statement that follows an IF statement. \n+ */\n+\n+static match\n+match_simple_forall (void)\n+{\n+  gfc_forall_iterator *head;\n+  gfc_expr *mask;\n+  gfc_code *c;\n+  match m;\n+\n+  mask = NULL;\n+  head = NULL;\n+  c = NULL;\n+\n+  m = match_forall_header (&head, &mask);\n+\n+  if (m == MATCH_NO)\n+    goto syntax;\n+  if (m != MATCH_YES)\n+    goto cleanup;\n+\n+  m = gfc_match_assignment ();\n+\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+  if (m == MATCH_NO)\n+    {\n+      m = gfc_match_pointer_assignment ();\n+      if (m == MATCH_ERROR)\n+\tgoto cleanup;\n+      if (m == MATCH_NO)\n+\tgoto syntax;\n+    }\n+\n+  c = gfc_get_code ();\n+  *c = new_st;\n+  c->loc = gfc_current_locus;\n+\n+  if (gfc_match_eos () != MATCH_YES)\n+    goto syntax;\n+\n+  gfc_clear_new_st ();\n+  new_st.op = EXEC_FORALL;\n+  new_st.expr = mask;\n+  new_st.ext.forall_iterator = head;\n+  new_st.block = gfc_get_code ();\n+\n+  new_st.block->op = EXEC_FORALL;\n+  new_st.block->next = c;\n+\n+  return MATCH_YES;\n+\n+syntax:\n+  gfc_syntax_error (ST_FORALL);\n+\n+cleanup:\n+  gfc_free_forall_iterator (head);\n+  gfc_free_expr (mask);\n+\n+  return MATCH_ERROR;\n+}\n+\n+\n+/* Match a FORALL statement.  */\n+\n+match\n+gfc_match_forall (gfc_statement * st)\n+{\n+  gfc_forall_iterator *head;\n+  gfc_expr *mask;\n+  gfc_code *c;\n+  match m0, m;\n+\n+  head = NULL;\n+  mask = NULL;\n+  c = NULL;\n+\n+  m0 = gfc_match_label ();\n+  if (m0 == MATCH_ERROR)\n+    return MATCH_ERROR;\n+\n+  m = gfc_match (\" forall\");\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  m = match_forall_header (&head, &mask);\n+  if (m == MATCH_ERROR)\n+    goto cleanup;\n+  if (m == MATCH_NO)\n+    goto syntax;\n+\n   if (gfc_match_eos () == MATCH_YES)\n     {\n       *st = ST_FORALL_BLOCK;"}, {"sha": "e8d985af0fe01b12cd63e6d4a38424b5d7e117d9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c874ae73dd61afb52dd97b2a1576e216c138e4ab", "patch": "@@ -1,3 +1,8 @@\n+2004-08-19  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n+\n+\tPR fortran/17074\n+\t* gfortran.dg/simpleif_1.f90: New test.\n+\n 2004-08-19  Mark Mitchell  <mark@codesourcery.com>\n \n \t* lib/target-supports.exp (check_profiling_available): Return"}, {"sha": "ee432ba90792f7c4ea66b75b77ebf942dddc15a1", "filename": "gcc/testsuite/gfortran.dg/simpleif_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c874ae73dd61afb52dd97b2a1576e216c138e4ab/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fsimpleif_1.f90?ref=c874ae73dd61afb52dd97b2a1576e216c138e4ab", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! PR 17074\n+! Verifies that FORALL and WHERE after a simple if work.\n+DIMENSION ia(4,4)\n+logical,dimension(4,4) :: index\n+\n+if (.true.) forall (i = 1:4, j = 1:4) ia(i,j) = 1\n+if (any (ia.ne.1)) CALL abort()\n+\n+index(:,:)=.false.\n+index(2,3) = .true.\n+\n+if (.true.) where (index) ia = 2\n+if (ia(2,3).ne.2) call abort()\n+\n+end"}]}