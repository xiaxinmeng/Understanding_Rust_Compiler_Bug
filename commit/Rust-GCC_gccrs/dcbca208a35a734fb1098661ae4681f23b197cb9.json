{"sha": "dcbca208a35a734fb1098661ae4681f23b197cb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNiY2EyMDhhMzVhNzM0ZmIxMDk4NjYxYWU0NjgxZjIzYjE5N2NiOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2004-12-15T17:41:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2004-12-15T17:41:58Z"}, "message": "re PR target/19010 (sse and mmx parameter passing broken)\n\n        PR target/19010\n        * config/i386/i386.c (ix86_must_pass_in_stack): Don't return true\n        for TImode vectors.\n        (gen_reg_or_parallel): New.\n        (function_arg): Use it.\n        (ix86_hard_regno_mode_ok): Test SSE1 and SSE2 separately,\n        MMX and 3DNOW separately.\n        (ix86_rtx_costs): Simplify FLOAT_EXTEND case.\n        (ix86_vector_mode_supported_p): Test SSE1 and SSE2 separately.\n        * config/i386/i386.h (VALID_SSE2_REG_MODE): Move SSE2 cases from ...\n        (VALID_SSE_REG_MODE): ... here.\n\n        * gcc.target/i386/i386.exp: New harness.\n        * gcc.target/i386/vect-args.c: New.\n\nFrom-SVN: r92205", "tree": {"sha": "da5e44fa449ec06fe9f6570598b4737ab7cd9145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da5e44fa449ec06fe9f6570598b4737ab7cd9145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcbca208a35a734fb1098661ae4681f23b197cb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbca208a35a734fb1098661ae4681f23b197cb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbca208a35a734fb1098661ae4681f23b197cb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbca208a35a734fb1098661ae4681f23b197cb9/comments", "author": null, "committer": null, "parents": [{"sha": "4586c5575b07cf7264179b939197f653774d71f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4586c5575b07cf7264179b939197f653774d71f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4586c5575b07cf7264179b939197f653774d71f0"}], "stats": {"total": 201, "additions": 173, "deletions": 28}, "files": [{"sha": "5f618627d887e7c4129dba96e7013f3a80ae5a53", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -1,3 +1,17 @@\n+2004-12-15  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/19010\n+\t* config/i386/i386.c (ix86_must_pass_in_stack): Don't return true\n+\tfor TImode vectors.\n+\t(gen_reg_or_parallel): New.\n+\t(function_arg): Use it.\n+\t(ix86_hard_regno_mode_ok): Test SSE1 and SSE2 separately,\n+\tMMX and 3DNOW separately.\n+\t(ix86_rtx_costs): Simplify FLOAT_EXTEND case.\n+\t(ix86_vector_mode_supported_p): Test SSE1 and SSE2 separately.\n+\t* config/i386/i386.h (VALID_SSE2_REG_MODE): Move SSE2 cases from ...\n+\t(VALID_SSE_REG_MODE): ... here.\n+\n 2004-12-15  David Edelsohn  <edelsohn@gnu.org>\n \n \t* xcoffout.c (xcoffout_declare_function): Change strncpy to memcpy."}, {"sha": "6ecf8a417c562cb2bc8082e924946a1b103c311a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -1943,7 +1943,12 @@ ix86_must_pass_in_stack (enum machine_mode mode, tree type)\n {\n   if (must_pass_in_stack_var_size_or_pad (mode, type))\n     return true;\n-  return (!TARGET_64BIT && type && mode == TImode);\n+\n+  /* For 32-bit, we want TImode aggregates to go on the stack.  But watch out!\n+     The layout_type routine is crafty and tries to trick us into passing\n+     currently unsupported vector types on the stack by using TImode.  */\n+  return (!TARGET_64BIT && mode == TImode\n+\t  && type && TREE_CODE (type) != VECTOR_TYPE);\n }\n \n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n@@ -2640,6 +2645,34 @@ function_arg_advance (CUMULATIVE_ARGS *cum,\t/* current arg information */\n   return;\n }\n \n+/* A subroutine of function_arg.  We want to pass a parameter whose nominal\n+   type is MODE in REGNO.  We try to minimize ABI variation, so MODE may not\n+   actually be valid for REGNO with the current ISA.  In this case, ALT_MODE\n+   is used instead.  It must be the same size as MODE, and must be known to\n+   be valid for REGNO.  Finally, ORIG_MODE is the original mode of the \n+   parameter, as seen by the type system.  This may be different from MODE\n+   when we're mucking with things minimizing ABI variations.\n+\n+   Returns a REG or a PARALLEL as appropriate.  */\n+\n+static rtx\n+gen_reg_or_parallel (enum machine_mode mode, enum machine_mode alt_mode,\n+\t\t     enum machine_mode orig_mode, unsigned int regno)\n+{\n+  rtx tmp;\n+\n+  if (HARD_REGNO_MODE_OK (regno, mode))\n+    tmp = gen_rtx_REG (mode, regno);\n+  else\n+    {\n+      tmp = gen_rtx_REG (alt_mode, regno);\n+      tmp = gen_rtx_EXPR_LIST (VOIDmode, tmp, const0_rtx);\n+      tmp = gen_rtx_PARALLEL (orig_mode, gen_rtvec (1, tmp));\n+    }\n+\n+  return tmp;\n+}\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -2654,12 +2687,11 @@ function_arg_advance (CUMULATIVE_ARGS *cum,\t/* current arg information */\n     (otherwise it is an extra parameter matching an ellipsis).  */\n \n rtx\n-function_arg (CUMULATIVE_ARGS *cum,\t/* current arg information */\n-\t      enum machine_mode mode,\t/* current arg mode */\n-\t      tree type,\t/* type of the argument or 0 if lib support */\n-\t      int named)\t/* != 0 for normal args, == 0 for ...  args */\n+function_arg (CUMULATIVE_ARGS *cum, enum machine_mode orig_mode,\n+\t      tree type, int named)\n {\n-  rtx ret   = NULL_RTX;\n+  enum machine_mode mode = orig_mode;\n+  rtx ret = NULL_RTX;\n   int bytes =\n     (mode == BLKmode) ? int_size_in_bytes (type) : (int) GET_MODE_SIZE (mode);\n   int words = (bytes + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n@@ -2755,7 +2787,8 @@ function_arg (CUMULATIVE_ARGS *cum,\t/* current arg information */\n \t\t\t \"changes the ABI\");\n \t      }\n \t    if (cum->sse_nregs)\n-\t      ret = gen_rtx_REG (mode, cum->sse_regno + FIRST_SSE_REG);\n+\t      ret = gen_reg_or_parallel (mode, TImode, orig_mode,\n+\t\t\t\t\t cum->sse_regno + FIRST_SSE_REG);\n \t  }\n \tbreak;\n       case V8QImode:\n@@ -2771,7 +2804,8 @@ function_arg (CUMULATIVE_ARGS *cum,\t/* current arg information */\n \t\t\t \"changes the ABI\");\n \t      }\n \t    if (cum->mmx_nregs)\n-\t      ret = gen_rtx_REG (mode, cum->mmx_regno + FIRST_MMX_REG);\n+\t      ret = gen_reg_or_parallel (mode, DImode, orig_mode,\n+\t\t\t\t\t cum->mmx_regno + FIRST_MMX_REG);\n \t  }\n \tbreak;\n       }\n@@ -13991,10 +14025,20 @@ ix86_hard_regno_mode_ok (int regno, enum machine_mode mode)\n   if (FP_REGNO_P (regno))\n     return VALID_FP_MODE_P (mode);\n   if (SSE_REGNO_P (regno))\n-    return (TARGET_SSE ? VALID_SSE_REG_MODE (mode) : 0);\n+    {\n+      if (TARGET_SSE2 && VALID_SSE2_REG_MODE (mode))\n+\treturn 1;\n+      if (TARGET_SSE && VALID_SSE_REG_MODE (mode))\n+\treturn 1;\n+      return 0;\n+    }\n   if (MMX_REGNO_P (regno))\n-    return (TARGET_MMX\n-\t    ? VALID_MMX_REG_MODE (mode) || VALID_MMX_REG_MODE_3DNOW (mode) : 0);\n+    {\n+      if (TARGET_3DNOW && VALID_MMX_REG_MODE_3DNOW (mode))\n+\treturn 1;\n+      if (TARGET_MMX && VALID_MMX_REG_MODE (mode))\n+\treturn 1;\n+    }\n   /* We handle both integer and floats in the general purpose registers.\n      In future we should be able to handle vector modes as well.  */\n   if (!VALID_INT_MODE_P (mode) && !VALID_FP_MODE_P (mode))\n@@ -14372,7 +14416,9 @@ ix86_rtx_costs (rtx x, int code, int outer_code, int *total)\n       return false;\n \n     case FLOAT_EXTEND:\n-      if (!TARGET_SSE_MATH || !VALID_SSE_REG_MODE (mode))\n+      if (!TARGET_SSE_MATH\n+\t  || mode == XFmode\n+\t  || (mode == DFmode && !TARGET_SSE2))\n \t*total = 0;\n       return false;\n \n@@ -15164,20 +15210,15 @@ ix86_expand_vector_init (rtx target, rtx vals)\n static bool\n ix86_vector_mode_supported_p (enum machine_mode mode)\n {\n-  if (TARGET_SSE\n-      && VALID_SSE_REG_MODE (mode))\n+  if (TARGET_SSE && VALID_SSE_REG_MODE (mode))\n     return true;\n-\n-  else if (TARGET_MMX\n-\t   && VALID_MMX_REG_MODE (mode))\n+  if (TARGET_SSE2 && VALID_SSE2_REG_MODE (mode))\n     return true;\n-\n-  else if (TARGET_3DNOW\n-\t   && VALID_MMX_REG_MODE_3DNOW (mode))\n+  if (TARGET_MMX && VALID_MMX_REG_MODE (mode))\n     return true;\n-\n-  else\n-    return false;\n+  if (TARGET_3DNOW && VALID_MMX_REG_MODE_3DNOW (mode))\n+    return true;\n+  return false;\n }\n \n /* Worker function for TARGET_MD_ASM_CLOBBERS."}, {"sha": "9063d85b1a7c640160ab6768ecaeaf09ef4cefe5", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -1075,14 +1075,12 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define VALID_SSE2_REG_MODE(MODE) \\\n     ((MODE) == V16QImode || (MODE) == V8HImode || (MODE) == V2DFmode    \\\n-     || (MODE) == V2DImode)\n+     || (MODE) == V2DImode || (MODE) == DFmode\t\t\t\t\\\n+     || VALID_MMX_REG_MODE (MODE))\n \n #define VALID_SSE_REG_MODE(MODE)\t\t\t\t\t\\\n     ((MODE) == TImode || (MODE) == V4SFmode || (MODE) == V4SImode\t\\\n-     || (MODE) == SFmode || (MODE) == TFmode\t\t\t\t\\\n-     /* Always accept SSE2 modes so that xmmintrin.h compiles.  */\t\\\n-     || VALID_SSE2_REG_MODE (MODE)\t\t\t\t\t\\\n-     || (TARGET_SSE2 && ((MODE) == DFmode || VALID_MMX_REG_MODE (MODE))))\n+     || (MODE) == SFmode || (MODE) == TFmode)\n \n #define VALID_MMX_REG_MODE_3DNOW(MODE) \\\n     ((MODE) == V2SFmode || (MODE) == SFmode)"}, {"sha": "449213da5ac58028179de2b40e7553b9a9db28e5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -1,3 +1,8 @@\n+2004-12-15  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.target/i386/i386.exp: New harness.\n+\t* gcc.target/i386/vect-args.c: New.\n+\n 2004-12-15  David Edelsohn  <edelsohn@gnu.org>\n \n \t* gcc.dg/20040813-1.c: Skip for *-*-aix*."}, {"sha": "4b92d4ab0a8875700ba4499ea5ee67028c1aaf01", "filename": "gcc/testsuite/gcc.target/i386/i386.exp", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fi386.exp?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -0,0 +1,54 @@\n+# Copyright (C) 1997, 2004 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't a SPARC target.\n+if { ![istarget i?86*-*-*] && ![istarget x86_64-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Special case compilation of vect-args.c so we don't have to\n+# replicate it 10 times.\n+foreach type { \"\" -mmmx -m3dnow -msse -msse2 } {\n+  foreach level { \"\" -O } {\n+    set flags \"$type $level\"\n+    verbose -log \"Testing vect-args, $flags\" 1\n+    dg-test $srcdir/$subdir/vect-args.c $flags \"\"\n+  }\n+}\n+\n+# Everything else.\n+set tests [lsort [find $srcdir/$subdir *.\\[cS\\]]]\n+set tests [prune $tests $srcdir/$subdir/vect-args.c]\n+\n+# Main loop.\n+dg-runtest $tests \"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "94b602d913a57a2417b974517e96ac28b803dc5e", "filename": "gcc/testsuite/gcc.target/i386/vect-args.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-args.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcbca208a35a734fb1098661ae4681f23b197cb9/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-args.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fvect-args.c?ref=dcbca208a35a734fb1098661ae4681f23b197cb9", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-w\" } */\n+\n+/* SSE1 and SSE2 modes.  */\n+typedef unsigned char V16QImode __attribute__((vector_size(16)));\n+typedef unsigned short V8HImode __attribute__((vector_size(16)));\n+typedef unsigned int V4SImode __attribute__((vector_size(16)));\n+typedef unsigned long long V2DImode __attribute__((vector_size(16)));\n+typedef float V4SFmode __attribute__((vector_size(16)));\n+typedef double V2DFmode __attribute__((vector_size(16)));\n+\n+/* MMX and 3DNOW modes.  */\n+typedef unsigned char V8QImode __attribute__((vector_size(8)));\n+typedef unsigned short V4HImode __attribute__((vector_size(8)));\n+typedef unsigned int V2SImode __attribute__((vector_size(8)));\n+typedef float V2SFmode __attribute__((vector_size(8)));\n+\n+/* Test argument loading and unloading of each.  */\n+#define TEST(TYPE)\t\t\t\t\t\\\n+extern TYPE data_##TYPE;\t\t\t\t\\\n+void r_##TYPE (TYPE x) { data_##TYPE = x; }\t\t\\\n+void s_##TYPE (void) { r_##TYPE (data_##TYPE); }\n+\n+TEST(V16QImode)\n+TEST(V8HImode)\n+TEST(V4SImode)\n+TEST(V2DImode)\n+TEST(V4SFmode)\n+TEST(V2DFmode)\n+TEST(V8QImode)\n+TEST(V4HImode)\n+TEST(V2SImode)\n+TEST(V2SFmode)"}]}