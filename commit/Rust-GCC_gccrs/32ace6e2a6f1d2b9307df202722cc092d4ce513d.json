{"sha": "32ace6e2a6f1d2b9307df202722cc092d4ce513d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJhY2U2ZTJhNmYxZDJiOTMwN2RmMjAyNzIyY2MwOTJkNGNlNTEzZA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2006-12-04T14:26:37Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2006-12-04T14:26:37Z"}, "message": "Switch live on entry to a per block basis from per variable.\n\n\t* tree-outof-ssa.c (coalesce_ssa_name): Use calculate_live_ranges.\n\t* tree-ssa-live.c (new_tree_live_info, delete_tree_live_info): Update.\n\t(add_livein_if_notdef): Delete.\n\t(loe_visit_block): New.  Propogate live on entry info for a block into\n\teach predecessor.  If it changes, make sure it is visited again.\n\t(live_worklist): Visit every block and update the live on entry info \n\tfor preds.  Iterate over any that changed.\n\t(set_var_live_on_entry): Populate the live on entry blocks with bits\n\tbased on the immediate uses of a var.\n\t(calculate_live_on_entry): Remove.\n\t(calculate_live_on_exit): Calculate live on exit based on the newly\n\toriented live on entry bits.\n\t(calculate_live_ranges): Build live on entry and exit vectors.\n\t(dump_live_info): Use new orientation of live on entry bitmaps.\n\t(verify_live_on_entry): New.  Split out verification code from old\n\tcalculate_live_on_entry routine.\n\t* tree-ssa-live.h (struct tree_live_info_d): Add Working stack.\n\t(live_entry_blocks): Rename to live_on_entry and return bitmap for a\n\tbasic_block instead of for a partition.\n\t(live_merge_and_clear): Add asserts.\n\t(make_live_on_entry): Set partition bit in basic block vector.\n\nFrom-SVN: r119495", "tree": {"sha": "1ac424d69eb81d98ca1dcefd9fc5e39a0fef503e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac424d69eb81d98ca1dcefd9fc5e39a0fef503e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32ace6e2a6f1d2b9307df202722cc092d4ce513d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ace6e2a6f1d2b9307df202722cc092d4ce513d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32ace6e2a6f1d2b9307df202722cc092d4ce513d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32ace6e2a6f1d2b9307df202722cc092d4ce513d/comments", "author": null, "committer": null, "parents": [{"sha": "b9ca581120190433a1f155654ecce71c3e50dc3e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9ca581120190433a1f155654ecce71c3e50dc3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9ca581120190433a1f155654ecce71c3e50dc3e"}], "stats": {"total": 610, "additions": 335, "deletions": 275}, "files": [{"sha": "8e51debe452dd20248243f170474d628129d5cb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32ace6e2a6f1d2b9307df202722cc092d4ce513d", "patch": "@@ -1,3 +1,27 @@\n+2006-12-04  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-outof-ssa.c (coalesce_ssa_name): Use calculate_live_ranges.\n+\t* tree-ssa-live.c (new_tree_live_info, delete_tree_live_info): Update.\n+\t(add_livein_if_notdef): Delete.\n+\t(loe_visit_block): New.  Propogate live on entry info for a block into\n+\teach predecessor.  If it changes, make sure it is visited again.\n+\t(live_worklist): Visit every block and update the live on entry info \n+\tfor preds.  Iterate over any that changed.\n+\t(set_var_live_on_entry): Populate the live on entry blocks with bits\n+\tbased on the immediate uses of a var.\n+\t(calculate_live_on_entry): Remove.\n+\t(calculate_live_on_exit): Calculate live on exit based on the newly\n+\toriented live on entry bits.\n+\t(calculate_live_ranges): Build live on entry and exit vectors.\n+\t(dump_live_info): Use new orientation of live on entry bitmaps.\n+\t(verify_live_on_entry): New.  Split out verification code from old\n+\tcalculate_live_on_entry routine.\n+\t* tree-ssa-live.h (struct tree_live_info_d): Add Working stack.\n+\t(live_entry_blocks): Rename to live_on_entry and return bitmap for a\n+\tbasic_block instead of for a partition.\n+\t(live_merge_and_clear): Add asserts.\n+\t(make_live_on_entry): Set partition bit in basic block vector.\n+\n 2006-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR libgomp/29947"}, {"sha": "3a7d0171b636127a5c597f01dc4400f2f5b77051", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=32ace6e2a6f1d2b9307df202722cc092d4ce513d", "patch": "@@ -822,8 +822,7 @@ coalesce_ssa_name (var_map map, int flags)\n   if (num_var_partitions (map) <= 1)\n     return NULL;\n \n-  liveinfo = calculate_live_on_entry (map);\n-  calculate_live_on_exit (liveinfo);\n+  liveinfo = calculate_live_ranges (map);\n   rv = root_var_init (map);\n \n   /* Remove single element variable from the list.  */"}, {"sha": "a632600a0206f8c633f70a01e76558d751435bb7", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 290, "deletions": 264, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=32ace6e2a6f1d2b9307df202722cc092d4ce513d", "patch": "@@ -40,14 +40,15 @@ Boston, MA 02110-1301, USA.  */\n #include \"toplev.h\"\n #include \"vecprim.h\"\n \n-static void live_worklist (tree_live_info_p, int *, int);\n+static void live_worklist (tree_live_info_p);\n static tree_live_info_p new_tree_live_info (var_map);\n static inline void set_if_valid (var_map, bitmap, tree);\n-static inline void add_livein_if_notdef (tree_live_info_p, bitmap,\n-\t\t\t\t\t tree, basic_block);\n static inline void add_conflicts_if_valid (tpa_p, conflict_graph,\n \t\t\t\t\t   var_map, bitmap, tree);\n static partition_pair_p find_partition_pair (coalesce_list_p, int, int, bool);\n+#ifdef ENABLE_CHECKING\n+static void  verify_live_on_entry (tree_live_info_p);\n+#endif\n \n /* This is where the mapping from SSA version number to real storage variable\n    is tracked.  \n@@ -502,14 +503,18 @@ new_tree_live_info (var_map map)\n   live->map = map;\n   live->num_blocks = last_basic_block;\n \n-  live->global = BITMAP_ALLOC (NULL);\n-\n-  live->livein = (bitmap *)xmalloc (num_var_partitions (map) * sizeof (bitmap));\n-  for (x = 0; x < num_var_partitions (map); x++)\n+  live->livein = (bitmap *)xmalloc (last_basic_block * sizeof (bitmap));\n+  for (x = 0; x < (unsigned)last_basic_block; x++)\n     live->livein[x] = BITMAP_ALLOC (NULL);\n \n-  /* liveout is deferred until it is actually requested.  */\n-  live->liveout = NULL;\n+  live->liveout = (bitmap *)xmalloc (last_basic_block * sizeof (bitmap));\n+  for (x = 0; x < (unsigned)last_basic_block; x++)\n+    live->liveout[x] = BITMAP_ALLOC (NULL);\n+\n+  live->work_stack = XNEWVEC (int, last_basic_block);\n+  live->stack_top = live->work_stack;\n+\n+  live->global = BITMAP_ALLOC (NULL);\n   return live;\n }\n \n@@ -520,270 +525,164 @@ void\n delete_tree_live_info (tree_live_info_p live)\n {\n   int x;\n-  if (live->liveout)\n-    {\n-      for (x = live->num_blocks - 1; x >= 0; x--)\n-        BITMAP_FREE (live->liveout[x]);\n-      free (live->liveout);\n-    }\n-  if (live->livein)\n-    {\n-      for (x = num_var_partitions (live->map) - 1; x >= 0; x--)\n-        BITMAP_FREE (live->livein[x]);\n-      free (live->livein);\n-    }\n-  if (live->global)\n-    BITMAP_FREE (live->global);\n-  \n-  free (live);\n-}\n \n+  BITMAP_FREE (live->global);\n+  free (live->work_stack);\n \n-/* Using LIVE, fill in all the live-on-entry blocks between the defs and uses \n-   for partition I.  STACK is a varray used for temporary memory which is \n-   passed in rather than being allocated on every call.  */\n+  for (x = live->num_blocks - 1; x >= 0; x--)\n+    BITMAP_FREE (live->liveout[x]);\n+  free (live->liveout);\n \n-static void\n-live_worklist (tree_live_info_p live, int *stack, int i)\n-{\n-  unsigned b;\n-  tree var;\n-  basic_block def_bb = NULL;\n-  edge e;\n-  var_map map = live->map;\n-  edge_iterator ei;\n-  bitmap_iterator bi;\n-  int *tos = stack;\n-\n-  var = partition_to_var (map, i);\n-  if (SSA_NAME_DEF_STMT (var))\n-    def_bb = bb_for_stmt (SSA_NAME_DEF_STMT (var));\n-\n-  EXECUTE_IF_SET_IN_BITMAP (live->livein[i], 0, b, bi)\n-    {\n-      *tos++ = b;\n-    }\n-\n-  while (tos != stack)\n-    {\n-      b = *--tos;\n+  for (x = live->num_blocks - 1; x >= 0; x--)\n+    BITMAP_FREE (live->livein[x]);\n+  free (live->livein);\n \n-      FOR_EACH_EDGE (e, ei, BASIC_BLOCK (b)->preds)\n-\tif (e->src != ENTRY_BLOCK_PTR)\n-\t  {\n-\t    /* Its not live on entry to the block its defined in.  */\n-\t    if (e->src == def_bb)\n-\t      continue;\n-\t    if (!bitmap_bit_p (live->livein[i], e->src->index))\n-\t      {\n-\t\tbitmap_set_bit (live->livein[i], e->src->index);\n-\t\t*tos++ = e->src->index;\n-\t      }\n-\t  }\n-    }\n+  free (live);\n }\n \n \n-/* If VAR is in a partition of MAP, set the bit for that partition in VEC.  */\n+/* Visit basic block BB, and propogate any required live on entry bits from \n+   LIVE into the predecessors.  VISITED is the bitmap of visited blocks.  \n+   TMP is a temporary work bitmap which is passed in to avoid reallocting\n+   it each time.  */\n \n-static inline void\n-set_if_valid (var_map map, bitmap vec, tree var)\n+static void \n+loe_visit_block (tree_live_info_p live, basic_block bb, sbitmap visited,\n+\t\t bitmap tmp)\n {\n-  int p = var_to_partition (map, var);\n-  if (p != NO_PARTITION)\n-    bitmap_set_bit (vec, p);\n-}\n-\n+  edge e;\n+  bool change;\n+  edge_iterator ei;\n+  basic_block pred_bb;\n+  bitmap loe;\n+  gcc_assert (!TEST_BIT (visited, bb->index));\n \n-/* If VAR is in a partition and it isn't defined in DEF_VEC, set the livein and \n-   global bit for it in the LIVE object.  BB is the block being processed.  */\n+  SET_BIT (visited, bb->index);\n+  loe = live_on_entry (live, bb);\n \n-static inline void\n-add_livein_if_notdef (tree_live_info_p live, bitmap def_vec,\n-\t\t      tree var, basic_block bb)\n-{\n-  int p = var_to_partition (live->map, var);\n-  if (p == NO_PARTITION || bb == ENTRY_BLOCK_PTR)\n-    return;\n-  if (!bitmap_bit_p (def_vec, p))\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n-      bitmap_set_bit (live->livein[p], bb->index);\n-      bitmap_set_bit (live->global, p);\n+      pred_bb = e->src;\n+      if (pred_bb == ENTRY_BLOCK_PTR)\n+\tcontinue;\n+      /* tmp is vars live-=on-entry from BB that aren't defined in the\n+\t pred. block.  This should be the live on entry vars to pred.  \n+\t Note that liveout is the DEFs in a block while live on entry is\n+\t being calculated.  */\n+      bitmap_and_compl (tmp, loe, live->liveout[pred_bb->index]);\n+\n+      /* Add these bits to live-on-entry for the pred. if there are any \n+\t changes, and pred_bb has been visited already, add it to the\n+\t revisit stack.  */\n+      change = bitmap_ior_into (live_on_entry (live, pred_bb), tmp);\n+      if (TEST_BIT (visited, pred_bb->index) && change)\n+\t{\n+\t  RESET_BIT (visited, pred_bb->index);\n+\t  *(live->stack_top)++ = pred_bb->index;\n+\t}\n     }\n }\n \n \n-/* Given partition map MAP, calculate all the live on entry bitmaps for \n-   each basic block.  Return a live info object.  */\n+/* Using LIVE, fill in all the live-on-entry blocks between the defs and uses \n+   of all the vairables.  */\n \n-tree_live_info_p \n-calculate_live_on_entry (var_map map)\n+static void\n+live_worklist (tree_live_info_p live)\n {\n-  tree_live_info_p live;\n-  unsigned i;\n+  unsigned b;\n   basic_block bb;\n-  bitmap saw_def;\n-  tree phi, var, stmt;\n-  tree op;\n-  edge e;\n-  int *stack;\n-  block_stmt_iterator bsi;\n-  ssa_op_iter iter;\n-  bitmap_iterator bi;\n-#ifdef ENABLE_CHECKING\n-  int num;\n-  edge_iterator ei;\n-#endif\n+  sbitmap visited = sbitmap_alloc (last_basic_block + 1);\n+  bitmap tmp = BITMAP_ALLOC (NULL);\n \n-  saw_def = BITMAP_ALLOC (NULL);\n+  sbitmap_zero (visited);\n \n-  live = new_tree_live_info (map);\n+  /* Visit all the blocks in reverse order and propogate live on entry values\n+     into the predecessors blocks.  */\n+  FOR_EACH_BB_REVERSE (bb)\n+    loe_visit_block (live, bb, visited, tmp);\n \n-  FOR_EACH_BB (bb)\n+  /* Process any blocks which require further iteration.  */\n+  while (live->stack_top != live->work_stack)\n     {\n-      bitmap_clear (saw_def);\n+      b = *--(live->stack_top);\n+      loe_visit_block (live, BASIC_BLOCK (b), visited, tmp);\n+    }\n \n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  for (i = 0; i < (unsigned)PHI_NUM_ARGS (phi); i++)\n-\t    {\n-\t      var = PHI_ARG_DEF (phi, i);\n-\t      if (!phi_ssa_name_p (var))\n-\t        continue;\n-\t      stmt = SSA_NAME_DEF_STMT (var);\n-\t      e = EDGE_PRED (bb, i);\n-\n-\t      /* Any uses in PHIs which either don't have def's or are not\n-\t         defined in the block from which the def comes, will be live\n-\t\t on entry to that block.  */\n-\t      if (!stmt || e->src != bb_for_stmt (stmt))\n-\t\tadd_livein_if_notdef (live, saw_def, var, e->src);\n-\t    }\n-        }\n+  BITMAP_FREE (tmp);\n+  sbitmap_free (visited);\n+}\n \n-      /* Don't mark PHI results as defined until all the PHI nodes have\n-\t been processed. If the PHI sequence is:\n-\t    a_3 = PHI <a_1, a_2>\n-\t    b_3 = PHI <b_1, a_3>\n-\t The a_3 referred to in b_3's PHI node is the one incoming on the\n-\t edge, *not* the PHI node just seen.  */\n \n-      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-        {\n-\t  var = PHI_RESULT (phi);\n-\t  set_if_valid (map, saw_def, var);\n-\t}\n+/* Calulate the initial live on entry vector for SSA_NAME using immediate_use\n+   links.  Set the live on entry fields in LIVE.  Def's are marked temporarily\n+   in the liveout vector.  */\n \n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-        {\n-\t  stmt = bsi_stmt (bsi);\n-\n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n-\t    {\n-\t      add_livein_if_notdef (live, saw_def, op, bb);\n-\t    }\n+static void\n+set_var_live_on_entry (tree ssa_name, tree_live_info_p live)\n+{\n+  int p;\n+  tree stmt;\n+  use_operand_p use;\n+  basic_block def_bb = NULL;\n+  imm_use_iterator imm_iter;\n+  bool global = false;\n \n-\t  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_DEF)\n-\t    {\n-\t      set_if_valid (map, saw_def, op);\n-\t    }\n-\t}\n-    }\n+  p = var_to_partition (live->map, ssa_name);\n+  if (p == NO_PARTITION)\n+    return;\n \n-  stack = XNEWVEC (int, last_basic_block);\n-  EXECUTE_IF_SET_IN_BITMAP (live->global, 0, i, bi)\n+  stmt = SSA_NAME_DEF_STMT (ssa_name);\n+  if (stmt)\n     {\n-      live_worklist (live, stack, i);\n+      def_bb = bb_for_stmt (stmt);\n+      /* Mark defs in liveout bitmap for now.  */\n+      if (def_bb)\n+\tbitmap_set_bit (live->liveout[def_bb->index], p);\n     }\n-  free (stack);\n-\n-#ifdef ENABLE_CHECKING\n-   /* Check for live on entry partitions and report those with a DEF in\n-      the program. This will typically mean an optimization has done\n-      something wrong.  */\n+  else\n+    def_bb = ENTRY_BLOCK_PTR;\n \n-  bb = ENTRY_BLOCK_PTR;\n-  num = 0;\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n+  /* Visit each use of SSA_NAME and if it isn't in the same block as the def,\n+     add it to the list of live on entry blocks.  */\n+  FOR_EACH_IMM_USE_FAST (use, imm_iter, ssa_name)\n     {\n-      int entry_block = e->dest->index;\n-      if (e->dest == EXIT_BLOCK_PTR)\n-        continue;\n-      for (i = 0; i < (unsigned)num_var_partitions (map); i++)\n-\t{\n-\t  basic_block tmp;\n-\t  tree d;\n-\t  var = partition_to_var (map, i);\n-\t  stmt = SSA_NAME_DEF_STMT (var);\n-\t  tmp = bb_for_stmt (stmt);\n-\t  d = gimple_default_def (cfun, SSA_NAME_VAR (var));\n+      tree use_stmt = USE_STMT (use);\n+      basic_block add_block = NULL;\n \n-\t  if (bitmap_bit_p (live_entry_blocks (live, i), entry_block))\n+      if (TREE_CODE (use_stmt) == PHI_NODE)\n+        {\n+\t  /* Uses in PHI's are considered to be live at exit of the SRC block\n+\t     as this is where a copy would be inserted.  Check to see if it is\n+\t     defined in that block, or whether its live on entry.  */\n+\t  int index = PHI_ARG_INDEX_FROM_USE (use);\n+\t  edge e = PHI_ARG_EDGE (use_stmt, index);\n+\t  if (e->src != ENTRY_BLOCK_PTR)\n \t    {\n-\t      if (!IS_EMPTY_STMT (stmt))\n-\t\t{\n-\t\t  num++;\n-\t\t  print_generic_expr (stderr, var, TDF_SLIM);\n-\t\t  fprintf (stderr, \" is defined \");\n-\t\t  if (tmp)\n-\t\t    fprintf (stderr, \" in BB%d, \", tmp->index);\n-\t\t  fprintf (stderr, \"by:\\n\");\n-\t\t  print_generic_expr (stderr, stmt, TDF_SLIM);\n-\t\t  fprintf (stderr, \"\\nIt is also live-on-entry to entry BB %d\", \n-\t\t\t   entry_block);\n-\t\t  fprintf (stderr, \" So it appears to have multiple defs.\\n\");\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  if (d != var)\n-\t\t    {\n-\t\t      num++;\n-\t\t      print_generic_expr (stderr, var, TDF_SLIM);\n-\t\t      fprintf (stderr, \" is live-on-entry to BB%d \",entry_block);\n-\t\t      if (d)\n-\t\t        {\n-\t\t\t  fprintf (stderr, \" but is not the default def of \");\n-\t\t\t  print_generic_expr (stderr, d, TDF_SLIM);\n-\t\t\t  fprintf (stderr, \"\\n\");\n-\t\t\t}\n-\t\t      else\n-\t\t\tfprintf (stderr, \" and there is no default def.\\n\");\n-\t\t    }\n-\t\t}\n+\t      if (e->src != def_bb)\n+\t\tadd_block = e->src;\n \t    }\n-\t  else\n-\t    if (d == var)\n-\t      {\n-\t\t/* The only way this var shouldn't be marked live on entry is \n-\t\t   if it occurs in a PHI argument of the block.  */\n-\t\tint z, ok = 0;\n-\t\tfor (phi = phi_nodes (e->dest); \n-\t\t     phi && !ok; \n-\t\t     phi = PHI_CHAIN (phi))\n-\t\t  {\n-\t\t    for (z = 0; z < PHI_NUM_ARGS (phi); z++)\n-\t\t      if (var == PHI_ARG_DEF (phi, z))\n-\t\t\t{\n-\t\t\t  ok = 1;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t  }\n-\t\tif (ok)\n-\t\t  continue;\n-\t        num++;\n-\t\tprint_generic_expr (stderr, var, TDF_SLIM);\n-\t\tfprintf (stderr, \" is not marked live-on-entry to entry BB%d \", \n-\t\t\t entry_block);\n-\t\tfprintf (stderr, \"but it is a default def so it should be.\\n\");\n-\t      }\n+\t}\n+      else\n+        {\n+\t  /* If its not defined in this block, its live on entry.  */\n+\t  basic_block use_bb = bb_for_stmt (use_stmt);\n+\t  if (use_bb != def_bb)\n+\t    add_block = use_bb;\n+\t}  \n+\n+      /* If there was a live on entry use, set the bit.  */\n+      if (add_block)\n+        {\n+\t  global = true;\n+\t  bitmap_set_bit (live->livein[add_block->index], p);\n \t}\n     }\n-  gcc_assert (num <= 0);\n-#endif\n \n-  BITMAP_FREE (saw_def);\n-\n-  return live;\n+  /* If SSA_NAME is live on entry to at least one block, fill in all the live\n+     on entry blocks between the def and all the uses.  */\n+  if (global)\n+    bitmap_set_bit (live->global, p);\n }\n \n \n@@ -792,49 +691,69 @@ calculate_live_on_entry (var_map map)\n void\n calculate_live_on_exit (tree_live_info_p liveinfo)\n {\n-  unsigned b;\n-  unsigned i, x;\n-  bitmap *on_exit;\n+  unsigned i;\n+  int p;\n+  tree t, phi;\n   basic_block bb;\n   edge e;\n-  tree t, phi;\n-  bitmap on_entry;\n-  var_map map = liveinfo->map;\n+  edge_iterator ei;\n \n-  on_exit = (bitmap *)xmalloc (last_basic_block * sizeof (bitmap));\n-  for (x = 0; x < (unsigned)last_basic_block; x++)\n-    on_exit[x] = BITMAP_ALLOC (NULL);\n+  /* live on entry calculations used the liveouit vector for defs.  */\n+  FOR_EACH_BB (bb)\n+    bitmap_clear (liveinfo->liveout[bb->index]);\n \n   /* Set all the live-on-exit bits for uses in PHIs.  */\n   FOR_EACH_BB (bb)\n     {\n+      /* Mark the PHI arguments which are live on exit to the pred block.  */\n       for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n \tfor (i = 0; i < (unsigned)PHI_NUM_ARGS (phi); i++)\n \t  { \n \t    t = PHI_ARG_DEF (phi, i);\n-\t    e = PHI_ARG_EDGE (phi, i);\n-\t    if (!phi_ssa_name_p (t) || e->src == ENTRY_BLOCK_PTR)\n+\t    if (TREE_CODE (t) != SSA_NAME)\n+\t      continue;\n+\t    p = var_to_partition (liveinfo->map, t);\n+\t    if (p == NO_PARTITION)\n \t      continue;\n-\t    set_if_valid (map, on_exit[e->src->index], t);\n+\t    e = PHI_ARG_EDGE (phi, i);\n+\t    if (e->src != ENTRY_BLOCK_PTR)\n+\t      bitmap_set_bit (liveinfo->liveout[e->src->index], p);\n \t  }\n+\n+      /* add each successors live on entry to this bock live on exit.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+        if (e->dest != EXIT_BLOCK_PTR)\n+\t  bitmap_ior_into (liveinfo->liveout[bb->index],\n+\t\t\t   live_on_entry (liveinfo, e->dest));\n     }\n+}\n+\n+/* Given partition map MAP, calculate all the live on entry bitmaps for \n+   each partition.  Return a new live info object.  */\n+\n+tree_live_info_p \n+calculate_live_ranges (var_map map)\n+{\n+  tree var;\n+  unsigned i;\n+  tree_live_info_p live;\n \n-  /* Set live on exit for all predecessors of live on entry's.  */\n+  live = new_tree_live_info (map);\n   for (i = 0; i < num_var_partitions (map); i++)\n     {\n-      bitmap_iterator bi;\n-\n-      on_entry = live_entry_blocks (liveinfo, i);\n-      EXECUTE_IF_SET_IN_BITMAP (on_entry, 0, b, bi)\n-        {\n-\t  edge_iterator ei;\n-\t  FOR_EACH_EDGE (e, ei, BASIC_BLOCK (b)->preds)\n-\t    if (e->src != ENTRY_BLOCK_PTR)\n-\t      bitmap_set_bit (on_exit[e->src->index], i);\n-\t}\n+      var = partition_to_var (map, i);\n+      if (var != NULL_TREE)\n+\tset_var_live_on_entry (var, live);\n     }\n \n-  liveinfo->liveout = on_exit;\n+  live_worklist (live);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_live_on_entry (live);\n+#endif\n+\n+  calculate_live_on_exit (live);\n+  return live;\n }\n \n \n@@ -1346,6 +1265,17 @@ add_conflicts_if_valid (tpa_p tpa, conflict_graph graph,\n     }\n }\n \n+\n+/* If VAR is in a partition of MAP, set the bit for that partition in VEC.  */\n+\n+static inline void\n+set_if_valid (var_map map, bitmap vec, tree var)\n+{\n+  int p = var_to_partition (map, var);\n+  if (p != NO_PARTITION)\n+    bitmap_set_bit (vec, p);\n+}\n+\n /* Return a conflict graph for the information contained in LIVE_INFO.  Only\n    conflicts between items in the same TPA list are added.  If optional \n    coalesce list CL is passed in, any copies encountered are added.  */\n@@ -1817,13 +1747,10 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n       FOR_EACH_BB (bb)\n \t{\n \t  fprintf (f, \"\\nLive on entry to BB%d : \", bb->index);\n-\t  for (i = 0; i < num_var_partitions (map); i++)\n+\t  EXECUTE_IF_SET_IN_BITMAP (live->livein[bb->index], 0, i, bi)\n \t    {\n-\t      if (bitmap_bit_p (live_entry_blocks (live, i), bb->index))\n-\t        {\n-\t\t  print_generic_expr (f, partition_to_var (map, i), TDF_SLIM);\n-\t\t  fprintf (f, \"  \");\n-\t\t}\n+\t      print_generic_expr (f, partition_to_var (map, i), TDF_SLIM);\n+\t      fprintf (f, \"  \");\n \t    }\n \t  fprintf (f, \"\\n\");\n \t}\n@@ -1857,4 +1784,103 @@ register_ssa_partition_check (tree ssa_var)\n       internal_error (\"SSA corruption\");\n     }\n }\n+\n+\n+/* Verify that the info in LIVE matches the current cfg.  */\n+static void\n+verify_live_on_entry (tree_live_info_p live)\n+{\n+  unsigned i;\n+  tree var;\n+  tree phi, stmt;\n+  basic_block bb;\n+  edge e;\n+  int num;\n+  edge_iterator ei;\n+  var_map map = live->map;\n+\n+   /* Check for live on entry partitions and report those with a DEF in\n+      the program. This will typically mean an optimization has done\n+      something wrong.  */\n+\n+  bb = ENTRY_BLOCK_PTR;\n+  num = 0;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    {\n+      int entry_block = e->dest->index;\n+      if (e->dest == EXIT_BLOCK_PTR)\n+        continue;\n+      for (i = 0; i < (unsigned)num_var_partitions (map); i++)\n+\t{\n+\t  basic_block tmp;\n+\t  tree d;\n+\t  bitmap loe;\n+\t  var = partition_to_var (map, i);\n+\t  stmt = SSA_NAME_DEF_STMT (var);\n+\t  tmp = bb_for_stmt (stmt);\n+\t  d = gimple_default_def (cfun, SSA_NAME_VAR (var));\n+\n+\t  loe = live_on_entry (live, e->dest);\n+\t  if (loe && bitmap_bit_p (loe, i))\n+\t    {\n+\t      if (!IS_EMPTY_STMT (stmt))\n+\t\t{\n+\t\t  num++;\n+\t\t  print_generic_expr (stderr, var, TDF_SLIM);\n+\t\t  fprintf (stderr, \" is defined \");\n+\t\t  if (tmp)\n+\t\t    fprintf (stderr, \" in BB%d, \", tmp->index);\n+\t\t  fprintf (stderr, \"by:\\n\");\n+\t\t  print_generic_expr (stderr, stmt, TDF_SLIM);\n+\t\t  fprintf (stderr, \"\\nIt is also live-on-entry to entry BB %d\", \n+\t\t\t   entry_block);\n+\t\t  fprintf (stderr, \" So it appears to have multiple defs.\\n\");\n+\t\t}\n+\t      else\n+\t        {\n+\t\t  if (d != var)\n+\t\t    {\n+\t\t      num++;\n+\t\t      print_generic_expr (stderr, var, TDF_SLIM);\n+\t\t      fprintf (stderr, \" is live-on-entry to BB%d \",entry_block);\n+\t\t      if (d)\n+\t\t        {\n+\t\t\t  fprintf (stderr, \" but is not the default def of \");\n+\t\t\t  print_generic_expr (stderr, d, TDF_SLIM);\n+\t\t\t  fprintf (stderr, \"\\n\");\n+\t\t\t}\n+\t\t      else\n+\t\t\tfprintf (stderr, \" and there is no default def.\\n\");\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else\n+\t    if (d == var)\n+\t      {\n+\t\t/* The only way this var shouldn't be marked live on entry is \n+\t\t   if it occurs in a PHI argument of the block.  */\n+\t\tint z, ok = 0;\n+\t\tfor (phi = phi_nodes (e->dest); \n+\t\t     phi && !ok; \n+\t\t     phi = PHI_CHAIN (phi))\n+\t\t  {\n+\t\t    for (z = 0; z < PHI_NUM_ARGS (phi); z++)\n+\t\t      if (var == PHI_ARG_DEF (phi, z))\n+\t\t\t{\n+\t\t\t  ok = 1;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t  }\n+\t\tif (ok)\n+\t\t  continue;\n+\t        num++;\n+\t\tprint_generic_expr (stderr, var, TDF_SLIM);\n+\t\tfprintf (stderr, \" is not marked live-on-entry to entry BB%d \", \n+\t\t\t entry_block);\n+\t\tfprintf (stderr, \"but it is a default def so it should be.\\n\");\n+\t      }\n+\t}\n+    }\n+  gcc_assert (num <= 0);\n+}\n #endif"}, {"sha": "b4dd5e3a2be23a19b7ac3223a22fc75a3567f8e7", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32ace6e2a6f1d2b9307df202722cc092d4ce513d/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=32ace6e2a6f1d2b9307df202722cc092d4ce513d", "patch": "@@ -182,11 +182,11 @@ register_ssa_partition (var_map map, tree ssa_var)\n     As well, partitions are marked as to whether they are global (live \n     outside the basic block they are defined in).\n \n-    The live-on-entry information is per variable. It provide a bitmap for \n-    each variable which has a bit set for each basic block that the variable\n-    is live on entry to that block.\n+    The live-on-entry information is per block.  It provide a bitmap for \n+    each block which has a bit set for each partition that is live on entry to \n+    that block.\n \n-    The live-on-exit information is per block. It provides a bitmap for each\n+    The live-on-exit information is per block.  It provides a bitmap for each\n     block indicating which partitions are live on exit from the block.\n \n     For the purposes of this implementation, we treat the elements of a PHI \n@@ -218,12 +218,18 @@ typedef struct tree_live_info_d\n   /* Number of basic blocks when live on exit calculated.  */\n   int num_blocks;\n \n+  /* Vector used when creating live ranges as a visited stack.  */\n+  int *work_stack;\n+\n+  /* Top of workstack.  */\n+  int *stack_top;\n+\n   /* Bitmap of what variables are live on exit for a basic blocks.  */\n   bitmap *liveout;\n } *tree_live_info_p;\n \n \n-extern tree_live_info_p calculate_live_on_entry (var_map);\n+extern tree_live_info_p calculate_live_ranges (var_map);\n extern void calculate_live_on_exit (tree_live_info_p);\n extern void delete_tree_live_info (tree_live_info_p);\n \n@@ -233,7 +239,7 @@ extern void delete_tree_live_info (tree_live_info_p);\n extern void dump_live_info (FILE *, tree_live_info_p, int);\n \n static inline int partition_is_global (tree_live_info_p, int);\n-static inline bitmap live_entry_blocks (tree_live_info_p, int);\n+static inline bitmap live_on_entry (tree_live_info_p, basic_block);\n static inline bitmap live_on_exit (tree_live_info_p, basic_block);\n static inline var_map live_var_map (tree_live_info_p);\n static inline void live_merge_and_clear (tree_live_info_p, int, int);\n@@ -254,10 +260,13 @@ partition_is_global (tree_live_info_p live, int p)\n    partition P.  */\n \n static inline bitmap\n-live_entry_blocks (tree_live_info_p live, int p)\n+live_on_entry (tree_live_info_p live, basic_block bb)\n {\n   gcc_assert (live->livein);\n-  return live->livein[p];\n+  gcc_assert (bb != ENTRY_BLOCK_PTR);\n+  gcc_assert (bb != EXIT_BLOCK_PTR);\n+\n+  return live->livein[bb->index];\n }\n \n \n@@ -290,6 +299,8 @@ live_var_map (tree_live_info_p live)\n static inline void \n live_merge_and_clear (tree_live_info_p live, int p1, int p2)\n {\n+  gcc_assert (live->livein[p1]);\n+  gcc_assert (live->livein[p2]);\n   bitmap_ior_into (live->livein[p1], live->livein[p2]);\n   bitmap_zero (live->livein[p2]);\n }\n@@ -300,7 +311,7 @@ live_merge_and_clear (tree_live_info_p live, int p1, int p2)\n static inline void \n make_live_on_entry (tree_live_info_p live, basic_block bb , int p)\n {\n-  bitmap_set_bit (live->livein[p], bb->index);\n+  bitmap_set_bit (live->livein[bb->index], p);\n   bitmap_set_bit (live->global, p);\n }\n "}]}