{"sha": "84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODRiNGM3YjU5M2NkNGViYjQ3NWEwOGFhNGI4MTZjNzIyZjcxNmNlNg==", "commit": {"author": {"name": "Andreas Krebbel", "email": "krebbel@linux.vnet.ibm.com", "date": "2018-02-08T14:45:53Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2018-02-08T14:45:53Z"}, "message": "S/390: Disable prediction of indirect branches\n\nThis patch implements GCC support for mitigating vulnerability\nCVE-2017-5715 known as Spectre #2 on IBM Z.\n\nIn order to disable prediction of indirect branches the implementation\nmakes use of an IBM Z specific feature - the execute instruction.\nPerforming an indirect branch via execute prevents the branch from\nbeing subject to dynamic branch prediction.\n\nThe implementation tries to stay close to the x86 solution regarding\nuser interface.\n\nx86 style options supported (without thunk-inline):\n\n-mindirect-branch=(keep|thunk|thunk-extern)\n-mfunction-return=(keep|thunk|thunk-extern)\n\nIBM Z specific options:\n\n-mindirect-branch-jump=(keep|thunk|thunk-extern|thunk-inline)\n-mindirect-branch-call=(keep|thunk|thunk-extern)\n-mfunction-return-reg=(keep|thunk|thunk-extern)\n-mfunction-return-mem=(keep|thunk|thunk-extern)\n\nThese options allow us to enable/disable the branch conversion at a\nfiner granularity.\n\n-mindirect-branch sets the value of -mindirect-branch-jump and\n -mindirect-branch-call.\n\n-mfunction-return sets the value of -mfunction-return-reg and\n -mfunction-return-mem.\n\nAll these options are supported on GCC command line as well as\nfunction attributes.\n\n'thunk' triggers the generation of out of line thunks (expolines) and\nreplaces the formerly indirect branch with a direct branch to the\nthunk.  Depending on the -march= setting two different types of thunks\nare generated.  With -march=z10 or higher exrl (execute relative long)\nis being used while targeting older machines makes use of larl/ex\ninstead.  From a security perspective the exrl variant is preferable.\n\n'thunk-extern' does the branch replacement like 'thunk' but does not\nemit the thunks.\n\n'thunk-inline' is only available for indirect jumps.  It should be used\nin environments where correct CFI is important - known as user space.\n\nAdditionally the patch introduces the -mindirect-branch-table option\nwhich generates tables pointing to the locations which have been\nmodified.  This is supposed to allow reverting the changes without\nre-compilation in situations where it isn't required. The sections are\nsplit up into one section per option.\n\ngcc/ChangeLog:\n\n2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* config/s390/s390-opts.h (enum indirect_branch): Define.\n\t* config/s390/s390-protos.h (s390_return_addr_from_memory)\n\t(s390_indirect_branch_via_thunk)\n\t(s390_indirect_branch_via_inline_thunk): Add function prototypes.\n\t(enum s390_indirect_branch_type): Define.\n\t* config/s390/s390.c (struct s390_frame_layout, struct\n\tmachine_function): Remove.\n\t(indirect_branch_prez10thunk_mask, indirect_branch_z10thunk_mask)\n\t(indirect_branch_table_label_no, indirect_branch_table_name):\n\tDefine variables.\n\t(INDIRECT_BRANCH_NUM_OPTIONS): Define macro.\n\t(enum s390_indirect_branch_option): Define.\n\t(s390_return_addr_from_memory): New function.\n\t(s390_handle_string_attribute): New function.\n\t(s390_attribute_table): Add new attribute handler.\n\t(s390_execute_label): Handle UNSPEC_EXECUTE_JUMP patterns.\n\t(s390_indirect_branch_via_thunk): New function.\n\t(s390_indirect_branch_via_inline_thunk): New function.\n\t(s390_function_ok_for_sibcall): When jumping via thunk disallow\n\tsibling call optimization for non z10 compiles.\n\t(s390_emit_call): Force indirect branch target to be a single\n\tregister.  Add r1 clobber for non-z10 compiles.\n\t(s390_emit_epilogue): Emit return jump via return_use expander.\n\t(s390_reorg): Handle JUMP_INSNs as execute targets.\n\t(s390_option_override_internal): Perform validity checks for the\n\tnew command line options.\n\t(s390_indirect_branch_attrvalue): New function.\n\t(s390_indirect_branch_settings): New function.\n\t(s390_set_current_function): Invoke s390_indirect_branch_settings.\n\t(s390_output_indirect_thunk_function):  New function.\n\t(s390_code_end): Implement target hook.\n\t(s390_case_values_threshold): Implement target hook.\n\t(TARGET_ASM_CODE_END, TARGET_CASE_VALUES_THRESHOLD): Define target\n\tmacros.\n\t* config/s390/s390.h (struct s390_frame_layout)\n\t(struct\tmachine_function): Move here from s390.c.\n\t(TARGET_INDIRECT_BRANCH_NOBP_RET)\n\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP)\n\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)\n\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)\n\t(TARGET_INDIRECT_BRANCH_NOBP_CALL)\n\t(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)\n\t(TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL)\n\t(TARGET_INDIRECT_BRANCH_THUNK_NAME_EX)\n\t(TARGET_INDIRECT_BRANCH_TABLE): Define macros.\n\t* config/s390/s390.md (UNSPEC_EXECUTE_JUMP)\n\t(INDIRECT_BRANCH_THUNK_REGNUM): Define constants.\n\t(mnemonic attribute): Add values which aren't recognized\n\tautomatically.\n\t(\"*cjump_long\", \"*icjump_long\", \"*basr\", \"*basr_r\"): Disable\n\tpattern for branch conversion.  Fix mnemonic attribute.\n\t(\"*c<code>\", \"*sibcall_br\", \"*sibcall_value_br\", \"*return\"): Emit\n\tindirect branch via thunk if requested.\n\t(\"indirect_jump\", \"<code>\"): Expand patterns for branch conversion.\n\t(\"*indirect_jump\"): Disable for branch conversion using out of\n\tline thunks.\n\t(\"indirect_jump_via_thunk<mode>_z10\")\n\t(\"indirect_jump_via_thunk<mode>\")\n\t(\"indirect_jump_via_inlinethunk<mode>_z10\")\n\t(\"indirect_jump_via_inlinethunk<mode>\", \"*casesi_jump\")\n\t(\"casesi_jump_via_thunk<mode>_z10\", \"casesi_jump_via_thunk<mode>\")\n\t(\"casesi_jump_via_inlinethunk<mode>_z10\")\n\t(\"casesi_jump_via_inlinethunk<mode>\", \"*basr_via_thunk<mode>_z10\")\n\t(\"*basr_via_thunk<mode>\", \"*basr_r_via_thunk_z10\")\n\t(\"*basr_r_via_thunk\", \"return<mode>_prez10\"): New pattern.\n\t(\"*indirect2_jump\"): Disable for branch conversion.\n\t(\"casesi_jump\"): Turn into expander and expand patterns for branch\n\tconversion.\n\t(\"return_use\"): New expander.\n\t(\"*return\"): Emit return via thunk and rename it to ...\n\t(\"*return<mode>\"): ... this one.\n\t* config/s390/s390.opt: Add new options and and enum for the\n\toption values.\n\ngcc/testsuite/ChangeLog:\n\n2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n\n\t* gcc.target/s390/nobp-function-pointer-attr.c: New test.\n\t* gcc.target/s390/nobp-function-pointer-nothunk.c: New test.\n\t* gcc.target/s390/nobp-function-pointer-z10.c: New test.\n\t* gcc.target/s390/nobp-function-pointer-z900.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-attr.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-inline-attr.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-inline-z10.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-inline-z900.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-nothunk.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-z10.c: New test.\n\t* gcc.target/s390/nobp-indirect-jump-z900.c: New test.\n\t* gcc.target/s390/nobp-return-attr-all.c: New test.\n\t* gcc.target/s390/nobp-return-attr-neg.c: New test.\n\t* gcc.target/s390/nobp-return-mem-attr.c: New test.\n\t* gcc.target/s390/nobp-return-mem-nothunk.c: New test.\n\t* gcc.target/s390/nobp-return-mem-z10.c: New test.\n\t* gcc.target/s390/nobp-return-mem-z900.c: New test.\n\t* gcc.target/s390/nobp-return-reg-attr.c: New test.\n\t* gcc.target/s390/nobp-return-reg-mixed.c: New test.\n\t* gcc.target/s390/nobp-return-reg-nothunk.c: New test.\n\t* gcc.target/s390/nobp-return-reg-z10.c: New test.\n\t* gcc.target/s390/nobp-return-reg-z900.c: New test.\n\t* gcc.target/s390/nobp-table-jump-inline-z10.c: New test.\n\t* gcc.target/s390/nobp-table-jump-inline-z900.c: New test.\n\t* gcc.target/s390/nobp-table-jump-z10.c: New test.\n\t* gcc.target/s390/nobp-table-jump-z900.c: New test.\n\nFrom-SVN: r257489", "tree": {"sha": "8788aae4fe5effe49577ad31730b775e75869ab9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8788aae4fe5effe49577ad31730b775e75869ab9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/comments", "author": null, "committer": null, "parents": [{"sha": "98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98a05c03ef5a3f3f096b1c344e6a75c37fbeea47"}], "stats": {"total": 2906, "additions": 2767, "deletions": 139}, "files": [{"sha": "c83df9769a1608c816c0949ff9bc512397794d69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -1,3 +1,79 @@\n+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* config/s390/s390-opts.h (enum indirect_branch): Define.\n+\t* config/s390/s390-protos.h (s390_return_addr_from_memory)\n+\t(s390_indirect_branch_via_thunk)\n+\t(s390_indirect_branch_via_inline_thunk): Add function prototypes.\n+\t(enum s390_indirect_branch_type): Define.\n+\t* config/s390/s390.c (struct s390_frame_layout, struct\n+\tmachine_function): Remove.\n+\t(indirect_branch_prez10thunk_mask, indirect_branch_z10thunk_mask)\n+\t(indirect_branch_table_label_no, indirect_branch_table_name):\n+\tDefine variables.\n+\t(INDIRECT_BRANCH_NUM_OPTIONS): Define macro.\n+\t(enum s390_indirect_branch_option): Define.\n+\t(s390_return_addr_from_memory): New function.\n+\t(s390_handle_string_attribute): New function.\n+\t(s390_attribute_table): Add new attribute handler.\n+\t(s390_execute_label): Handle UNSPEC_EXECUTE_JUMP patterns.\n+\t(s390_indirect_branch_via_thunk): New function.\n+\t(s390_indirect_branch_via_inline_thunk): New function.\n+\t(s390_function_ok_for_sibcall): When jumping via thunk disallow\n+\tsibling call optimization for non z10 compiles.\n+\t(s390_emit_call): Force indirect branch target to be a single\n+\tregister.  Add r1 clobber for non-z10 compiles.\n+\t(s390_emit_epilogue): Emit return jump via return_use expander.\n+\t(s390_reorg): Handle JUMP_INSNs as execute targets.\n+\t(s390_option_override_internal): Perform validity checks for the\n+\tnew command line options.\n+\t(s390_indirect_branch_attrvalue): New function.\n+\t(s390_indirect_branch_settings): New function.\n+\t(s390_set_current_function): Invoke s390_indirect_branch_settings.\n+\t(s390_output_indirect_thunk_function):  New function.\n+\t(s390_code_end): Implement target hook.\n+\t(s390_case_values_threshold): Implement target hook.\n+\t(TARGET_ASM_CODE_END, TARGET_CASE_VALUES_THRESHOLD): Define target\n+\tmacros.\n+\t* config/s390/s390.h (struct s390_frame_layout)\n+\t(struct\tmachine_function): Move here from s390.c.\n+\t(TARGET_INDIRECT_BRANCH_NOBP_RET)\n+\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP)\n+\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)\n+\t(TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)\n+\t(TARGET_INDIRECT_BRANCH_NOBP_CALL)\n+\t(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)\n+\t(TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL)\n+\t(TARGET_INDIRECT_BRANCH_THUNK_NAME_EX)\n+\t(TARGET_INDIRECT_BRANCH_TABLE): Define macros.\n+\t* config/s390/s390.md (UNSPEC_EXECUTE_JUMP)\n+\t(INDIRECT_BRANCH_THUNK_REGNUM): Define constants.\n+\t(mnemonic attribute): Add values which aren't recognized\n+\tautomatically.\n+\t(\"*cjump_long\", \"*icjump_long\", \"*basr\", \"*basr_r\"): Disable\n+\tpattern for branch conversion.  Fix mnemonic attribute.\n+\t(\"*c<code>\", \"*sibcall_br\", \"*sibcall_value_br\", \"*return\"): Emit\n+\tindirect branch via thunk if requested.\n+\t(\"indirect_jump\", \"<code>\"): Expand patterns for branch conversion.\n+\t(\"*indirect_jump\"): Disable for branch conversion using out of\n+\tline thunks.\n+\t(\"indirect_jump_via_thunk<mode>_z10\")\n+\t(\"indirect_jump_via_thunk<mode>\")\n+\t(\"indirect_jump_via_inlinethunk<mode>_z10\")\n+\t(\"indirect_jump_via_inlinethunk<mode>\", \"*casesi_jump\")\n+\t(\"casesi_jump_via_thunk<mode>_z10\", \"casesi_jump_via_thunk<mode>\")\n+\t(\"casesi_jump_via_inlinethunk<mode>_z10\")\n+\t(\"casesi_jump_via_inlinethunk<mode>\", \"*basr_via_thunk<mode>_z10\")\n+\t(\"*basr_via_thunk<mode>\", \"*basr_r_via_thunk_z10\")\n+\t(\"*basr_r_via_thunk\", \"return<mode>_prez10\"): New pattern.\n+\t(\"*indirect2_jump\"): Disable for branch conversion.\n+\t(\"casesi_jump\"): Turn into expander and expand patterns for branch\n+\tconversion.\n+\t(\"return_use\"): New expander.\n+\t(\"*return\"): Emit return via thunk and rename it to ...\n+\t(\"*return<mode>\"): ... this one.\n+\t* config/s390/s390.opt: Add new options and and enum for the\n+\toption values.\n+\n 2018-02-08  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* lra-constraints.c (match_reload): Unconditionally use"}, {"sha": "aaecca7e4b2dfde97f980cab6e14f4ed34697d96", "filename": "gcc/config/s390/s390-opts.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-opts.h?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -43,4 +43,13 @@ enum processor_type\n   PROCESSOR_max\n };\n \n+\n+/* Values for -mindirect-branch and -mfunction-return options.  */\n+enum indirect_branch {\n+  indirect_branch_unset = 0,\n+  indirect_branch_keep,\n+  indirect_branch_thunk,\n+  indirect_branch_thunk_inline,\n+  indirect_branch_thunk_extern\n+};\n #endif"}, {"sha": "46f0743461d81072b93bc7f834a3e30cbc7c1dfd", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -50,6 +50,7 @@ extern void s390_set_has_landing_pad_p (bool);\n extern bool s390_hard_regno_rename_ok (unsigned int, unsigned int);\n extern int s390_class_max_nregs (enum reg_class, machine_mode);\n extern bool s390_function_arg_vector (machine_mode, const_tree);\n+extern bool s390_return_addr_from_memory(void);\n #if S390_USE_TARGET_ATTRIBUTE\n extern tree s390_valid_target_attribute_tree (tree args,\n \t\t\t\t\t      struct gcc_options *opts,\n@@ -145,6 +146,17 @@ extern int s390_compare_and_branch_condition_mask (rtx);\n extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);\n extern void s390_asm_output_function_label (FILE *, const char *, tree);\n \n+enum s390_indirect_branch_type\n+  {\n+    s390_indirect_branch_type_jump = 0,\n+    s390_indirect_branch_type_call,\n+    s390_indirect_branch_type_return\n+  };\n+extern void s390_indirect_branch_via_thunk (unsigned int regno,\n+\t\t\t\t\t    unsigned int return_addr_regno,\n+\t\t\t\t\t    rtx comparison_operator,\n+\t\t\t\t\t    enum s390_indirect_branch_type type);\n+extern void s390_indirect_branch_via_inline_thunk (rtx execute_target);\n #endif /* RTX_CODE */\n \n /* s390-c.c routines */"}, {"sha": "62a60e2c9539d8582300255b7d8d5e59a3050685", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 593, "deletions": 107, "changes": 700, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -399,84 +399,6 @@ struct s390_address\n   bool literal_pool;\n };\n \n-/* The following structure is embedded in the machine\n-   specific part of struct function.  */\n-\n-struct GTY (()) s390_frame_layout\n-{\n-  /* Offset within stack frame.  */\n-  HOST_WIDE_INT gprs_offset;\n-  HOST_WIDE_INT f0_offset;\n-  HOST_WIDE_INT f4_offset;\n-  HOST_WIDE_INT f8_offset;\n-  HOST_WIDE_INT backchain_offset;\n-\n-  /* Number of first and last gpr where slots in the register\n-     save area are reserved for.  */\n-  int first_save_gpr_slot;\n-  int last_save_gpr_slot;\n-\n-  /* Location (FP register number) where GPRs (r0-r15) should\n-     be saved to.\n-      0 - does not need to be saved at all\n-     -1 - stack slot  */\n-#define SAVE_SLOT_NONE   0\n-#define SAVE_SLOT_STACK -1\n-  signed char gpr_save_slots[16];\n-\n-  /* Number of first and last gpr to be saved, restored.  */\n-  int first_save_gpr;\n-  int first_restore_gpr;\n-  int last_save_gpr;\n-  int last_restore_gpr;\n-\n-  /* Bits standing for floating point registers. Set, if the\n-     respective register has to be saved. Starting with reg 16 (f0)\n-     at the rightmost bit.\n-     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n-     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0\n-     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */\n-  unsigned int fpr_bitmap;\n-\n-  /* Number of floating point registers f8-f15 which must be saved.  */\n-  int high_fprs;\n-\n-  /* Set if return address needs to be saved.\n-     This flag is set by s390_return_addr_rtx if it could not use\n-     the initial value of r14 and therefore depends on r14 saved\n-     to the stack.  */\n-  bool save_return_addr_p;\n-\n-  /* Size of stack frame.  */\n-  HOST_WIDE_INT frame_size;\n-};\n-\n-/* Define the structure for the machine field in struct function.  */\n-\n-struct GTY(()) machine_function\n-{\n-  struct s390_frame_layout frame_layout;\n-\n-  /* Literal pool base register.  */\n-  rtx base_reg;\n-\n-  /* True if we may need to perform branch splitting.  */\n-  bool split_branches_pending_p;\n-\n-  bool has_landing_pad_p;\n-\n-  /* True if the current function may contain a tbegin clobbering\n-     FPRs.  */\n-  bool tbegin_p;\n-\n-  /* For -fsplit-stack support: A stack local which holds a pointer to\n-     the stack arguments for a function with a variable number of\n-     arguments.  This is set at the start of the function and is used\n-     to initialize the overflow_arg_area field of the va_list\n-     structure.  */\n-  rtx split_stack_varargs_pointer;\n-};\n-\n /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */\n \n #define cfun_frame_layout (cfun->machine->frame_layout)\n@@ -517,6 +439,33 @@ struct GTY(()) machine_function\n    bytes on a z10 (or higher) CPU.  */\n #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)\n \n+/* Masks per jump target register indicating which thunk need to be\n+   generated.  */\n+static GTY(()) int indirect_branch_prez10thunk_mask = 0;\n+static GTY(()) int indirect_branch_z10thunk_mask = 0;\n+\n+#define INDIRECT_BRANCH_NUM_OPTIONS 4\n+\n+enum s390_indirect_branch_option\n+  {\n+    s390_opt_indirect_branch_jump = 0,\n+    s390_opt_indirect_branch_call,\n+    s390_opt_function_return_reg,\n+    s390_opt_function_return_mem\n+  };\n+\n+static GTY(()) int indirect_branch_table_label_no[INDIRECT_BRANCH_NUM_OPTIONS] = { 0 };\n+const char *indirect_branch_table_label[INDIRECT_BRANCH_NUM_OPTIONS] = \\\n+  { \"LJUMP\", \"LCALL\", \"LRETREG\", \"LRETMEM\" };\n+const char *indirect_branch_table_name[INDIRECT_BRANCH_NUM_OPTIONS] =\t\\\n+  { \".s390_indirect_jump\", \".s390_indirect_call\",\n+    \".s390_return_reg\", \".s390_return_mem\" };\n+\n+bool\n+s390_return_addr_from_memory ()\n+{\n+  return cfun_gpr_save_slot(RETURN_REGNUM) == SAVE_SLOT_STACK;\n+}\n \n /* Indicate which ABI has been used for passing vector args.\n    0 - no vector type arguments have been passed where the ABI is relevant\n@@ -1179,11 +1128,83 @@ s390_handle_vectorbool_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n+/* Check syntax of function decl attributes having a string type value.  */\n+\n+static tree\n+s390_handle_string_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n+\t\t\t      tree args ATTRIBUTE_UNUSED,\n+\t\t\t      int flags ATTRIBUTE_UNUSED,\n+\t\t\t      bool *no_add_attrs)\n+{\n+  tree cst;\n+\n+  if (TREE_CODE (*node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  cst = TREE_VALUE (args);\n+\n+  if (TREE_CODE (cst) != STRING_CST)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute requires a string constant argument\",\n+\t       name);\n+      *no_add_attrs = true;\n+    }\n+\n+  if (is_attribute_p (\"indirect_branch\", name)\n+      || is_attribute_p (\"indirect_branch_call\", name)\n+      || is_attribute_p (\"function_return\", name)\n+      || is_attribute_p (\"function_return_reg\", name)\n+      || is_attribute_p (\"function_return_mem\", name))\n+    {\n+      if (strcmp (TREE_STRING_POINTER (cst), \"keep\") != 0\n+\t  && strcmp (TREE_STRING_POINTER (cst), \"thunk\") != 0\n+\t  && strcmp (TREE_STRING_POINTER (cst), \"thunk-extern\") != 0)\n+      {\n+\twarning (OPT_Wattributes,\n+\t\t \"argument to %qE attribute is not \"\n+\t\t \"(keep|thunk|thunk-extern)\", name);\n+\t*no_add_attrs = true;\n+      }\n+    }\n+\n+  if (is_attribute_p (\"indirect_branch_jump\", name)\n+      && strcmp (TREE_STRING_POINTER (cst), \"keep\") != 0\n+      && strcmp (TREE_STRING_POINTER (cst), \"thunk\") != 0\n+      && strcmp (TREE_STRING_POINTER (cst), \"thunk-inline\") != 0\n+      && strcmp (TREE_STRING_POINTER (cst), \"thunk-extern\") != 0)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"argument to %qE attribute is not \"\n+\t       \"(keep|thunk|thunk-inline|thunk-extern)\", name);\n+      *no_add_attrs = true;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n static const struct attribute_spec s390_attribute_table[] = {\n   { \"hotpatch\", 2, 2, true, false, false, false,\n     s390_handle_hotpatch_attribute, NULL },\n   { \"s390_vector_bool\", 0, 0, false, true, false, true,\n     s390_handle_vectorbool_attribute, NULL },\n+  { \"indirect_branch\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+  { \"indirect_branch_jump\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+  { \"indirect_branch_call\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+  { \"function_return\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+  { \"function_return_reg\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+  { \"function_return_mem\", 1, 1, true, false, false, false,\n+    s390_handle_string_attribute, NULL },\n+\n   /* End element.  */\n   { NULL,        0, 0, false, false, false, false, NULL, NULL }\n };\n@@ -8733,11 +8754,25 @@ s390_find_constant (struct constant_pool *pool, rtx val,\n static rtx\n s390_execute_label (rtx insn)\n {\n-  if (NONJUMP_INSN_P (insn)\n+  if (INSN_P (insn)\n       && GET_CODE (PATTERN (insn)) == PARALLEL\n       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC\n-      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)\n-    return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);\n+      && (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE\n+\t  || XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE_JUMP))\n+    {\n+      if (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)\n+\treturn XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);\n+      else\n+\t{\n+\t  gcc_assert (JUMP_P (insn));\n+\t  /* For jump insns as execute target:\n+\t     - There is one operand less in the parallel (the\n+\t       modification register of the execute is always 0).\n+\t     - The execute target label is wrapped into an\n+\t       if_then_else in order to hide it from jump analysis.  */\n+\t  return XEXP (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0), 0);\n+\t}\n+    }\n \n   return NULL_RTX;\n }\n@@ -11681,7 +11716,6 @@ s390_emit_epilogue (bool sibcall)\n   rtx frame_pointer, return_reg, cfa_restores = NULL_RTX;\n   int area_bottom, area_top, offset = 0;\n   int next_offset;\n-  rtvec p;\n   int i;\n \n   if (TARGET_TPF_PROFILING)\n@@ -11837,8 +11871,14 @@ s390_emit_epilogue (bool sibcall)\n \t  && s390_tune <= PROCESSOR_2097_Z10)\n \t{\n \t  int return_regnum = find_unused_clobbered_reg();\n-\t  if (!return_regnum)\n-\t    return_regnum = 4;\n+\t  if (!return_regnum\n+\t      || (TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION\n+\t\t  && !TARGET_CPU_Z10\n+\t\t  && return_regnum == INDIRECT_BRANCH_THUNK_REGNUM))\n+\t    {\n+\t      gcc_assert (INDIRECT_BRANCH_THUNK_REGNUM != 4);\n+\t      return_regnum = 4;\n+\t    }\n \t  return_reg = gen_rtx_REG (Pmode, return_regnum);\n \n \t  addr = plus_constant (Pmode, frame_pointer,\n@@ -11875,16 +11915,7 @@ s390_emit_epilogue (bool sibcall)\n   s390_restore_gprs_from_fprs ();\n \n   if (! sibcall)\n-    {\n-\n-      /* Return to caller.  */\n-\n-      p = rtvec_alloc (2);\n-\n-      RTVEC_ELT (p, 0) = ret_rtx;\n-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);\n-      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));\n-    }\n+    emit_jump_insn (gen_return_use (return_reg));\n }\n \n /* Implement TARGET_SET_UP_BY_PROLOGUE.  */\n@@ -13475,6 +13506,112 @@ s390_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n   final_end_function ();\n }\n \n+/* Output either an indirect jump or a an indirect call\n+   (RETURN_ADDR_REGNO != INVALID_REGNUM) with target register REGNO\n+   using a branch trampoline disabling branch target prediction.  */\n+\n+void\n+s390_indirect_branch_via_thunk (unsigned int regno,\n+\t\t\t\tunsigned int return_addr_regno,\n+\t\t\t\trtx comparison_operator,\n+\t\t\t\tenum s390_indirect_branch_type type)\n+{\n+  enum s390_indirect_branch_option option;\n+\n+  if (type == s390_indirect_branch_type_return)\n+    {\n+      if (s390_return_addr_from_memory ())\n+\toption = s390_opt_function_return_mem;\n+      else\n+\toption = s390_opt_function_return_reg;\n+    }\n+  else if (type == s390_indirect_branch_type_jump)\n+    option = s390_opt_indirect_branch_jump;\n+  else if (type == s390_indirect_branch_type_call)\n+    option = s390_opt_indirect_branch_call;\n+  else\n+    gcc_unreachable ();\n+\n+  if (TARGET_INDIRECT_BRANCH_TABLE)\n+    {\n+      char label[32];\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label,\n+\t\t\t\t   indirect_branch_table_label[option],\n+\t\t\t\t   indirect_branch_table_label_no[option]++);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+\n+  if (return_addr_regno != INVALID_REGNUM)\n+    {\n+      gcc_assert (comparison_operator == NULL_RTX);\n+      fprintf (asm_out_file, \" \\tbrasl\\t%%r%d,\", return_addr_regno);\n+    }\n+  else\n+    {\n+      fputs (\" \\tjg\", asm_out_file);\n+      if (comparison_operator != NULL_RTX)\n+\tprint_operand (asm_out_file, comparison_operator, 'C');\n+\n+      fputs (\"\\t\", asm_out_file);\n+    }\n+\n+  if (TARGET_CPU_Z10)\n+    fprintf (asm_out_file,\n+\t     TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL \"\\n\",\n+\t     regno);\n+  else\n+    fprintf (asm_out_file,\n+\t     TARGET_INDIRECT_BRANCH_THUNK_NAME_EX \"\\n\",\n+\t     INDIRECT_BRANCH_THUNK_REGNUM, regno);\n+\n+  if ((option == s390_opt_indirect_branch_jump\n+       && cfun->machine->indirect_branch_jump == indirect_branch_thunk)\n+      || (option == s390_opt_indirect_branch_call\n+\t  && cfun->machine->indirect_branch_call == indirect_branch_thunk)\n+      || (option == s390_opt_function_return_reg\n+\t  && cfun->machine->function_return_reg == indirect_branch_thunk)\n+      || (option == s390_opt_function_return_mem\n+\t  && cfun->machine->function_return_mem == indirect_branch_thunk))\n+    {\n+      if (TARGET_CPU_Z10)\n+\tindirect_branch_z10thunk_mask |= (1 << regno);\n+      else\n+\tindirect_branch_prez10thunk_mask |= (1 << regno);\n+    }\n+}\n+\n+/* Output an inline thunk for indirect jumps.  EXECUTE_TARGET can\n+   either be an address register or a label pointing to the location\n+   of the jump instruction.  */\n+\n+void\n+s390_indirect_branch_via_inline_thunk (rtx execute_target)\n+{\n+  if (TARGET_INDIRECT_BRANCH_TABLE)\n+    {\n+      char label[32];\n+\n+      ASM_GENERATE_INTERNAL_LABEL (label,\n+\t\t\t\t   indirect_branch_table_label[s390_opt_indirect_branch_jump],\n+\t\t\t\t   indirect_branch_table_label_no[s390_opt_indirect_branch_jump]++);\n+      ASM_OUTPUT_LABEL (asm_out_file, label);\n+    }\n+\n+  if (!TARGET_ZARCH)\n+    fputs (\"\\t.machinemode zarch\\n\", asm_out_file);\n+\n+  if (REG_P (execute_target))\n+    fprintf (asm_out_file, \"\\tex\\t%%r0,0(%%r%d)\\n\", REGNO (execute_target));\n+  else\n+    output_asm_insn (\"\\texrl\\t%%r0,%0\", &execute_target);\n+\n+  if (!TARGET_ZARCH)\n+    fputs (\"\\t.machinemode esa\\n\", asm_out_file);\n+\n+  fputs (\"0:\\tj\\t0b\\n\", asm_out_file);\n+}\n+\n static bool\n s390_valid_pointer_mode (scalar_int_mode mode)\n {\n@@ -13576,6 +13713,14 @@ s390_function_ok_for_sibcall (tree decl, tree exp)\n   if (!TARGET_64BIT && flag_pic && decl && !targetm.binds_local_p (decl))\n     return false;\n \n+  /* The thunks for indirect branches require r1 if no exrl is\n+     available.  r1 might not be available when doing a sibling\n+     call.  */\n+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL\n+      && !TARGET_CPU_Z10\n+      && !decl)\n+    return false;\n+\n   /* Register 6 on s390 is available as an argument register but unfortunately\n      \"caller saved\". This makes functions needing this register for arguments\n      not suitable for sibcalls.  */\n@@ -13609,9 +13754,13 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n {\n   bool plt_call = false;\n   rtx_insn *insn;\n-  rtx call;\n-  rtx clobber;\n-  rtvec vec;\n+  rtx vec[4] = { NULL_RTX };\n+  int elts = 0;\n+  rtx *call = &vec[0];\n+  rtx *clobber_ret_reg = &vec[1];\n+  rtx *use = &vec[2];\n+  rtx *clobber_thunk_reg = &vec[3];\n+  int i;\n \n   /* Direct function calls need special treatment.  */\n   if (GET_CODE (addr_location) == SYMBOL_REF)\n@@ -13663,26 +13812,58 @@ s390_emit_call (rtx addr_location, rtx tls_call, rtx result_reg,\n       addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);\n     }\n \n+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL\n+      && GET_CODE (addr_location) != SYMBOL_REF\n+      && !plt_call)\n+    {\n+      /* Indirect branch thunks require the target to be a single GPR.  */\n+      addr_location = force_reg (Pmode, addr_location);\n+\n+      /* Without exrl the indirect branch thunks need an additional\n+\t register for larl;ex */\n+      if (!TARGET_CPU_Z10)\n+\t{\n+\t  *clobber_thunk_reg = gen_rtx_REG (Pmode, INDIRECT_BRANCH_THUNK_REGNUM);\n+\t  *clobber_thunk_reg = gen_rtx_CLOBBER (VOIDmode, *clobber_thunk_reg);\n+\t}\n+    }\n+\n   addr_location = gen_rtx_MEM (QImode, addr_location);\n-  call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);\n+  *call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);\n \n   if (result_reg != NULL_RTX)\n-    call = gen_rtx_SET (result_reg, call);\n+    *call = gen_rtx_SET (result_reg, *call);\n \n   if (retaddr_reg != NULL_RTX)\n     {\n-      clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);\n+      *clobber_ret_reg = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);\n \n       if (tls_call != NULL_RTX)\n-\tvec = gen_rtvec (3, call, clobber,\n-\t\t\t gen_rtx_USE (VOIDmode, tls_call));\n-      else\n-\tvec = gen_rtvec (2, call, clobber);\n+\t*use = gen_rtx_USE (VOIDmode, tls_call);\n+    }\n+\n \n-      call = gen_rtx_PARALLEL (VOIDmode, vec);\n+  for (i = 0; i < 4; i++)\n+    if (vec[i] != NULL_RTX)\n+      elts++;\n+\n+  if (elts > 1)\n+    {\n+      rtvec v;\n+      int e = 0;\n+\n+      v = rtvec_alloc (elts);\n+      for (i = 0; i < 4; i++)\n+\tif (vec[i] != NULL_RTX)\n+\t  {\n+\t    RTVEC_ELT (v, e) = vec[i];\n+\t    e++;\n+\t  }\n+\n+      *call = gen_rtx_PARALLEL (VOIDmode, v);\n     }\n \n-  insn = emit_call_insn (call);\n+  insn = emit_call_insn (*call);\n \n   /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */\n   if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)\n@@ -14464,7 +14645,16 @@ s390_reorg (void)\n \t  target = emit_label (XEXP (label, 0));\n \t  INSN_ADDRESSES_NEW (target, -1);\n \n-\t  target = emit_insn (s390_execute_target (insn));\n+\t  if (JUMP_P (insn))\n+\t    {\n+\t      target = emit_jump_insn (s390_execute_target (insn));\n+\t      /* This is important in order to keep a table jump\n+\t\t pointing at the jump table label.  Only this makes it\n+\t\t being recognized as table jump.  */\n+\t      JUMP_LABEL (target) = JUMP_LABEL (insn);\n+\t    }\n+\t  else\n+\t    target = emit_insn (s390_execute_target (insn));\n \t  INSN_ADDRESSES_NEW (target, -1);\n \t}\n     }\n@@ -15199,6 +15389,42 @@ s390_option_override_internal (bool main_args_p,\n   if (TARGET_64BIT && !TARGET_ZARCH_P (opts->x_target_flags))\n     error (\"64-bit ABI not supported in ESA/390 mode\");\n \n+  if (opts->x_s390_indirect_branch == indirect_branch_thunk_inline\n+      || opts->x_s390_indirect_branch_call == indirect_branch_thunk_inline\n+      || opts->x_s390_function_return == indirect_branch_thunk_inline\n+      || opts->x_s390_function_return_reg == indirect_branch_thunk_inline\n+      || opts->x_s390_function_return_mem == indirect_branch_thunk_inline)\n+    error (\"thunk-inline is only supported with -mindirect-branch-jump\");\n+\n+  if (opts->x_s390_indirect_branch != indirect_branch_keep)\n+    {\n+      if (!opts_set->x_s390_indirect_branch_call)\n+\topts->x_s390_indirect_branch_call = opts->x_s390_indirect_branch;\n+\n+      if (!opts_set->x_s390_indirect_branch_jump)\n+\topts->x_s390_indirect_branch_jump = opts->x_s390_indirect_branch;\n+    }\n+\n+  if (opts->x_s390_function_return != indirect_branch_keep)\n+    {\n+      if (!opts_set->x_s390_function_return_reg)\n+\topts->x_s390_function_return_reg = opts->x_s390_function_return;\n+\n+      if (!opts_set->x_s390_function_return_mem)\n+\topts->x_s390_function_return_mem = opts->x_s390_function_return;\n+    }\n+\n+  if (!TARGET_CPU_ZARCH)\n+    {\n+      if (opts->x_s390_indirect_branch_call != indirect_branch_keep\n+\t  || opts->x_s390_indirect_branch_jump != indirect_branch_keep)\n+\terror (\"-mindirect-branch* options require -march=z900 or higher\");\n+      if (opts->x_s390_function_return_reg != indirect_branch_keep\n+\t  || opts->x_s390_function_return_mem != indirect_branch_keep)\n+\terror (\"-mfunction-return* options require -march=z900 or higher\");\n+    }\n+\n+\n   /* Enable hardware transactions if available and not explicitly\n      disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */\n   if (!TARGET_OPT_HTM_P (opts_set->x_target_flags))\n@@ -15811,6 +16037,78 @@ s390_can_inline_p (tree caller, tree callee)\n   return ret;\n }\n \n+/* Set VAL to correct enum value according to the indirect-branch or\n+   function-return attribute in ATTR.  */\n+\n+static inline void\n+s390_indirect_branch_attrvalue (tree attr, enum indirect_branch *val)\n+{\n+  const char *str = TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr)));\n+  if (strcmp (str, \"keep\") == 0)\n+    *val = indirect_branch_keep;\n+  else if (strcmp (str, \"thunk\") == 0)\n+    *val = indirect_branch_thunk;\n+  else if (strcmp (str, \"thunk-inline\") == 0)\n+    *val = indirect_branch_thunk_inline;\n+  else if (strcmp (str, \"thunk-extern\") == 0)\n+    *val = indirect_branch_thunk_extern;\n+}\n+\n+/* Memorize the setting for -mindirect-branch* and -mfunction-return*\n+   from either the cmdline or the function attributes in\n+   cfun->machine.  */\n+\n+static void\n+s390_indirect_branch_settings (tree fndecl)\n+{\n+  tree attr;\n+\n+  if (!fndecl)\n+    return;\n+\n+  /* Initialize with the cmdline options and let the attributes\n+     override it.  */\n+  cfun->machine->indirect_branch_jump = s390_indirect_branch_jump;\n+  cfun->machine->indirect_branch_call = s390_indirect_branch_call;\n+\n+  cfun->machine->function_return_reg = s390_function_return_reg;\n+  cfun->machine->function_return_mem = s390_function_return_mem;\n+\n+  if ((attr = lookup_attribute (\"indirect_branch\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    {\n+      s390_indirect_branch_attrvalue (attr,\n+\t\t\t\t      &cfun->machine->indirect_branch_jump);\n+      s390_indirect_branch_attrvalue (attr,\n+\t\t\t\t      &cfun->machine->indirect_branch_call);\n+    }\n+\n+  if ((attr = lookup_attribute (\"indirect_branch_jump\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_jump);\n+\n+  if ((attr = lookup_attribute (\"indirect_branch_call\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_call);\n+\n+  if ((attr = lookup_attribute (\"function_return\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    {\n+      s390_indirect_branch_attrvalue (attr,\n+\t\t\t\t      &cfun->machine->function_return_reg);\n+      s390_indirect_branch_attrvalue (attr,\n+\t\t\t\t      &cfun->machine->function_return_mem);\n+    }\n+\n+  if ((attr = lookup_attribute (\"function_return_reg\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_reg);\n+\n+  if ((attr = lookup_attribute (\"function_return_mem\",\n+\t\t\t\tDECL_ATTRIBUTES (fndecl))))\n+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);\n+}\n+\n /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl\n    cache.  */\n \n@@ -15861,6 +16159,8 @@ s390_set_current_function (tree fndecl)\n   if (old_tree != new_tree)\n     s390_activate_target_options (new_tree);\n   s390_previous_fndecl = fndecl;\n+\n+  s390_indirect_branch_settings (fndecl);\n }\n #endif\n \n@@ -16159,6 +16459,186 @@ s390_asan_shadow_offset (void)\n   return TARGET_64BIT ? HOST_WIDE_INT_1U << 52 : HOST_WIDE_INT_UC (0x20000000);\n }\n \n+#ifdef HAVE_GAS_HIDDEN\n+# define USE_HIDDEN_LINKONCE 1\n+#else\n+# define USE_HIDDEN_LINKONCE 0\n+#endif\n+\n+/* Output an indirect branch trampoline for target register REGNO.  */\n+\n+static void\n+s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)\n+{\n+  tree decl;\n+  char thunk_label[32];\n+  int i;\n+\n+  if (z10_p)\n+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL, regno);\n+  else\n+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EX,\n+\t     INDIRECT_BRANCH_THUNK_REGNUM, regno);\n+\n+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n+\t\t     get_identifier (thunk_label),\n+\t\t     build_function_type_list (void_type_node, NULL_TREE));\n+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n+\t\t\t\t   NULL_TREE, void_type_node);\n+  TREE_PUBLIC (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n+  DECL_IGNORED_P (decl) = 1;\n+\n+  if (USE_HIDDEN_LINKONCE)\n+    {\n+      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n+\n+      targetm.asm_out.unique_section (decl, 0);\n+      switch_to_section (get_named_section (decl, NULL, 0));\n+\n+      targetm.asm_out.globalize_label (asm_out_file, thunk_label);\n+      fputs (\"\\t.hidden\\t\", asm_out_file);\n+      assemble_name (asm_out_file, thunk_label);\n+      putc ('\\n', asm_out_file);\n+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, thunk_label, decl);\n+    }\n+  else\n+    {\n+      switch_to_section (text_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, thunk_label);\n+    }\n+\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  current_function_decl = decl;\n+  allocate_struct_function (decl, false);\n+  init_function_start (decl);\n+  cfun->is_thunk = true;\n+  first_function_block_is_cold = false;\n+  final_start_function (emit_barrier (), asm_out_file, 1);\n+\n+  /* This makes CFI at least usable for indirect jumps.\n+\n+     Stopping in the thunk: backtrace will point to the thunk target\n+     is if it was interrupted by a signal.  For a call this means that\n+     the call chain will be: caller->callee->thunk   */\n+  if (flag_asynchronous_unwind_tables)\n+    {\n+      fputs (\"\\t.cfi_signal_frame\\n\", asm_out_file);\n+      fprintf (asm_out_file, \"\\t.cfi_return_column %d\\n\", regno);\n+      for (i = 0; i < FPR15_REGNUM; i++)\n+\tfprintf (asm_out_file, \"\\t.cfi_same_value %s\\n\", reg_names[i]);\n+    }\n+\n+  if (z10_p)\n+    {\n+      /* exrl  0,1f  */\n+\n+      /* We generate a thunk for z10 compiled code although z10 is\n+\t currently not enabled.  Tell the assembler to accept the\n+\t instruction.  */\n+      if (!TARGET_CPU_Z10)\n+\t{\n+\t  fputs (\"\\t.machine push\\n\", asm_out_file);\n+\t  fputs (\"\\t.machine z10\\n\", asm_out_file);\n+\t}\n+      /* We use exrl even if -mzarch hasn't been specified on the\n+\t command line so we have to tell the assembler to accept\n+\t it.  */\n+      if (!TARGET_ZARCH)\n+\tfputs (\"\\t.machinemode zarch\\n\", asm_out_file);\n+\n+      fputs (\"\\texrl\\t0,1f\\n\", asm_out_file);\n+\n+      if (!TARGET_ZARCH)\n+\tfputs (\"\\t.machinemode esa\\n\", asm_out_file);\n+\n+      if (!TARGET_CPU_Z10)\n+\tfputs (\"\\t.machine pop\\n\", asm_out_file);\n+    }\n+  else if (TARGET_CPU_ZARCH)\n+    {\n+      /* larl %r1,1f  */\n+      fprintf (asm_out_file, \"\\tlarl\\t%%r%d,1f\\n\",\n+\t       INDIRECT_BRANCH_THUNK_REGNUM);\n+\n+      /* ex 0,0(%r1)  */\n+      fprintf (asm_out_file, \"\\tex\\t0,0(%%r%d)\\n\",\n+\t       INDIRECT_BRANCH_THUNK_REGNUM);\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  /* 0:    j 0b  */\n+  fputs (\"0:\\tj\\t0b\\n\", asm_out_file);\n+\n+  /* 1:    br <regno>  */\n+  fprintf (asm_out_file, \"1:\\tbr\\t%%r%d\\n\", regno);\n+\n+  final_end_function ();\n+  init_insn_lengths ();\n+  free_after_compilation (cfun);\n+  set_cfun (NULL);\n+  current_function_decl = NULL;\n+}\n+\n+/* Implement the asm.code_end target hook.  */\n+\n+static void\n+s390_code_end (void)\n+{\n+  int i;\n+\n+  for (i = 1; i < 16; i++)\n+    {\n+      if (indirect_branch_z10thunk_mask & (1 << i))\n+\ts390_output_indirect_thunk_function (i, true);\n+\n+      if (indirect_branch_prez10thunk_mask & (1 << i))\n+\ts390_output_indirect_thunk_function (i, false);\n+    }\n+\n+  if (TARGET_INDIRECT_BRANCH_TABLE)\n+    {\n+      int o;\n+      int i;\n+\n+      for (o = 0; o < INDIRECT_BRANCH_NUM_OPTIONS; o++)\n+\t{\n+\t  if (indirect_branch_table_label_no[o] == 0)\n+\t    continue;\n+\n+\t  switch_to_section (get_section (indirect_branch_table_name[o],\n+\t\t\t\t\t  0,\n+\t\t\t\t\t  NULL_TREE));\n+\t  for (i = 0; i < indirect_branch_table_label_no[o]; i++)\n+\t    {\n+\t      char label_start[32];\n+\n+\t      ASM_GENERATE_INTERNAL_LABEL (label_start,\n+\t\t\t\t\t   indirect_branch_table_label[o], i);\n+\n+\t      fputs (\"\\t.long\\t\", asm_out_file);\n+\t      assemble_name_raw (asm_out_file, label_start);\n+\t      fputs (\"-.\\n\", asm_out_file);\n+\t    }\n+\t  switch_to_section (current_function_section ());\n+\t}\n+    }\n+}\n+\n+/* Implement the TARGET_CASE_VALUES_THRESHOLD target hook.  */\n+\n+unsigned int\n+s390_case_values_threshold (void)\n+{\n+  /* Disabling branch prediction for indirect jumps makes jump tables\n+     much more expensive.  */\n+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP)\n+    return 20;\n+\n+  return default_case_values_threshold ();\n+}\n+\n /* Initialize GCC target structure.  */\n \n #undef  TARGET_ASM_ALIGNED_HI_OP\n@@ -16441,6 +16921,12 @@ s390_asan_shadow_offset (void)\n #undef TARGET_CONSTANT_ALIGNMENT\n #define TARGET_CONSTANT_ALIGNMENT s390_constant_alignment\n \n+#undef TARGET_ASM_CODE_END\n+#define TARGET_ASM_CODE_END s390_code_end\n+\n+#undef TARGET_CASE_VALUES_THRESHOLD\n+#define TARGET_CASE_VALUES_THRESHOLD s390_case_values_threshold\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n #include \"gt-s390.h\""}, {"sha": "de71fd927e21c7d06485cdd9ab9a86a64b02b531", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -1033,4 +1033,124 @@ extern const int processor_flags_table[];\n     s390_register_target_pragmas ();\t\t\\\n   } while (0)\n \n+#ifndef USED_FOR_TARGET\n+/* The following structure is embedded in the machine\n+   specific part of struct function.  */\n+\n+struct GTY (()) s390_frame_layout\n+{\n+  /* Offset within stack frame.  */\n+  HOST_WIDE_INT gprs_offset;\n+  HOST_WIDE_INT f0_offset;\n+  HOST_WIDE_INT f4_offset;\n+  HOST_WIDE_INT f8_offset;\n+  HOST_WIDE_INT backchain_offset;\n+\n+  /* Number of first and last gpr where slots in the register\n+     save area are reserved for.  */\n+  int first_save_gpr_slot;\n+  int last_save_gpr_slot;\n+\n+  /* Location (FP register number) where GPRs (r0-r15) should\n+     be saved to.\n+      0 - does not need to be saved at all\n+     -1 - stack slot  */\n+#define SAVE_SLOT_NONE   0\n+#define SAVE_SLOT_STACK -1\n+  signed char gpr_save_slots[16];\n+\n+  /* Number of first and last gpr to be saved, restored.  */\n+  int first_save_gpr;\n+  int first_restore_gpr;\n+  int last_save_gpr;\n+  int last_restore_gpr;\n+\n+  /* Bits standing for floating point registers. Set, if the\n+     respective register has to be saved. Starting with reg 16 (f0)\n+     at the rightmost bit.\n+     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0\n+     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0\n+     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */\n+  unsigned int fpr_bitmap;\n+\n+  /* Number of floating point registers f8-f15 which must be saved.  */\n+  int high_fprs;\n+\n+  /* Set if return address needs to be saved.\n+     This flag is set by s390_return_addr_rtx if it could not use\n+     the initial value of r14 and therefore depends on r14 saved\n+     to the stack.  */\n+  bool save_return_addr_p;\n+\n+  /* Size of stack frame.  */\n+  HOST_WIDE_INT frame_size;\n+};\n+\n+\n+/* Define the structure for the machine field in struct function.  */\n+\n+struct GTY(()) machine_function\n+{\n+  struct s390_frame_layout frame_layout;\n+\n+  /* Literal pool base register.  */\n+  rtx base_reg;\n+\n+  /* True if we may need to perform branch splitting.  */\n+  bool split_branches_pending_p;\n+\n+  bool has_landing_pad_p;\n+\n+  /* True if the current function may contain a tbegin clobbering\n+     FPRs.  */\n+  bool tbegin_p;\n+\n+  /* For -fsplit-stack support: A stack local which holds a pointer to\n+     the stack arguments for a function with a variable number of\n+     arguments.  This is set at the start of the function and is used\n+     to initialize the overflow_arg_area field of the va_list\n+     structure.  */\n+  rtx split_stack_varargs_pointer;\n+\n+  enum indirect_branch indirect_branch_jump;\n+  enum indirect_branch indirect_branch_call;\n+\n+  enum indirect_branch function_return_mem;\n+  enum indirect_branch function_return_reg;\n+};\n+#endif\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION\t\t\t\t\\\n+  (cfun->machine->function_return_reg != indirect_branch_keep\t\t\\\n+   || cfun->machine->function_return_mem != indirect_branch_keep)\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_RET\t\t\t\t\t\\\n+  ((cfun->machine->function_return_reg != indirect_branch_keep\t\t\\\n+    && !s390_return_addr_from_memory ())\t\t\t\t\\\n+   || (cfun->machine->function_return_mem != indirect_branch_keep\t\\\n+       && s390_return_addr_from_memory ()))\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP\t\t\t\t\\\n+  (cfun->machine->indirect_branch_jump != indirect_branch_keep)\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\t\t\t\t\\\n+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk\t\t\\\n+   || cfun->machine->indirect_branch_jump == indirect_branch_thunk_extern)\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK\t\t\t\\\n+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk_inline)\n+\n+#define TARGET_INDIRECT_BRANCH_NOBP_CALL\t\t\t\\\n+  (cfun->machine->indirect_branch_call != indirect_branch_keep)\n+\n+#ifndef TARGET_DEFAULT_INDIRECT_BRANCH_TABLE\n+#define TARGET_DEFAULT_INDIRECT_BRANCH_TABLE 0\n+#endif\n+\n+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL \"__s390_indirect_jump_r%d\"\n+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EX   \"__s390_indirect_jump_r%duse_r%d\"\n+\n+#define TARGET_INDIRECT_BRANCH_TABLE s390_indirect_branch_table\n+\n+\n #endif /* S390_H */"}, {"sha": "5481f1375efdce4e4e0d9a1277f26856038072cb", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 542, "deletions": 32, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -89,6 +89,7 @@\n    UNSPEC_LTREF\n    UNSPEC_INSN\n    UNSPEC_EXECUTE\n+   UNSPEC_EXECUTE_JUMP\n \n    ; Atomic Support\n    UNSPEC_MB\n@@ -302,6 +303,8 @@\n   [\n    ; Sibling call register.\n    (SIBCALL_REGNUM\t\t 1)\n+   ; A call-clobbered reg which can be used in indirect branch thunks\n+   (INDIRECT_BRANCH_THUNK_REGNUM 1)\n    ; Literal pool base register.\n    (BASE_REGNUM\t\t\t13)\n    ; Return address register.\n@@ -471,7 +474,10 @@\n                          z196_cracked\"\n              (const_string \"none\"))\n \n-(define_attr \"mnemonic\" \"bcr_flush,unknown\" (const_string \"unknown\"))\n+; mnemonics which only get defined through if_then_else currently\n+; don't get added to the list values automatically and hence need to\n+; be listed here.\n+(define_attr \"mnemonic\" \"b,bas,bc,bcr_flush,unknown\" (const_string \"unknown\"))\n \n ;; Length in bytes.\n \n@@ -9075,7 +9081,7 @@\n           (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n           (match_operand 0 \"address_operand\" \"ZQZR\")\n           (pc)))]\n-  \"\"\n+  \"!TARGET_INDIRECT_BRANCH_NOBP_JUMP\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"b%C1r\\t%0\";\n@@ -9085,6 +9091,9 @@\n   [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n+   (set (attr \"mnemonic\")\n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"bcr\") (const_string \"bc\")))\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")])\n \n@@ -9096,8 +9105,26 @@\n           (ANY_RETURN)\n           (pc)))]\n   \"s390_can_use_<code>_insn ()\"\n-  \"b%C0r\\t%%r14\"\n-  [(set_attr \"op_type\" \"RR\")\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)\n+    {\n+      s390_indirect_branch_via_thunk (RETURN_REGNUM,\n+\t\t\t\t      INVALID_REGNUM,\n+\t\t\t\t      operands[0],\n+\t\t\t\t      s390_indirect_branch_type_return);\n+      return \"\";\n+    }\n+  else\n+    return \"b%C0r\\t%%r14\";\n+}\n+  [(set (attr \"op_type\")\n+\t(if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+\t\t      (const_string \"RIL\")\n+\t\t      (const_string \"RR\")))\n+   (set (attr \"mnemonic\")\n+\t(if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+\t\t      (const_string \"brcl\")\n+\t\t      (const_string \"bcr\")))\n    (set_attr \"type\"  \"jsr\")\n    (set_attr \"atype\" \"agen\")])\n \n@@ -9150,7 +9177,7 @@\n           (match_operator 1 \"s390_comparison\" [(reg CC_REGNUM) (const_int 0)])\n           (pc)\n           (match_operand 0 \"address_operand\" \"ZQZR\")))]\n-  \"\"\n+  \"!TARGET_INDIRECT_BRANCH_NOBP_JUMP\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"b%D1r\\t%0\";\n@@ -9160,6 +9187,9 @@\n   [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n+   (set (attr \"mnemonic\")\n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"bcr\") (const_string \"bc\")))\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")])\n \n@@ -9664,29 +9694,152 @@\n     ;\n   else\n     operands[0] = force_reg (Pmode, operands[0]);\n+\n+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)\n+    {\n+      operands[0] = force_reg (Pmode, operands[0]);\n+      if (TARGET_CPU_Z10)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_indirect_jump_via_thunkdi_z10 (operands[0]));\n+\t  else\n+\t    emit_jump_insn (gen_indirect_jump_via_thunksi_z10 (operands[0]));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_indirect_jump_via_thunkdi (operands[0]));\n+\t  else\n+\t    emit_jump_insn (gen_indirect_jump_via_thunksi (operands[0]));\n+\t}\n+      DONE;\n+    }\n+\n+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)\n+    {\n+      operands[0] = force_reg (Pmode, operands[0]);\n+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+      if (TARGET_CPU_Z10)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi_z10 (operands[0],\n+\t\t\t\t\t\t\t\t     label_ref));\n+\t  else\n+\t    emit_jump_insn (gen_indirect_jump_via_inlinethunksi_z10 (operands[0],\n+\t\t\t\t\t\t\t\t     label_ref));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi (operands[0],\n+\t\t\t\t\t\t\t\t label_ref,\n+\t\t\t\t\t\t\t\t force_reg (Pmode, label_ref)));\n+\t  else\n+\t    emit_jump_insn (gen_indirect_jump_via_inlinethunksi (operands[0],\n+\t\t\t\t\t\t\t\t label_ref,\n+\t\t\t\t\t\t\t\t force_reg (Pmode, label_ref)));\n+\t}\n+      DONE;\n+    }\n })\n \n-; The first constraint must be an \"extra address constraint\" in order\n-; to trigger address reloading in LRA/reload\n (define_insn \"*indirect_jump\"\n   [(set (pc)\n-\t(match_operand 0 \"address_operand\" \"ZR,a\"))]\n- \"\"\n- \"@\n-  b\\t%a0\n-  br\\t%0\"\n- [(set_attr \"op_type\" \"RX,RR\")\n+\t(match_operand 0 \"address_operand\" \"ZR\"))]\n+ \"!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\"\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \"br\\t%0\";\n+  else\n+    return \"b\\t%a0\";\n+}\n+ [(set (attr \"op_type\")\n+       (if_then_else (match_operand 0 \"register_operand\" \"\")\n+\t\t     (const_string \"RR\") (const_string \"RX\")))\n+  (set (attr \"mnemonic\")\n+       (if_then_else (match_operand 0 \"register_operand\" \"\")\n+\t\t     (const_string \"br\") (const_string \"b\")))\n   (set_attr \"type\"  \"branch\")\n-  (set_attr \"atype\" \"agen\")\n-  (set_attr \"cpu_facility\" \"*\")])\n+  (set_attr \"atype\" \"agen\")])\n+\n+(define_insn \"indirect_jump_via_thunk<mode>_z10\"\n+  [(set (pc)\n+\t(match_operand:P 0 \"register_operand\" \"a\"))]\n+ \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\n+  && TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  INVALID_REGNUM,\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_jump);\n+  return \"\";\n+}\n+ [(set_attr \"op_type\"  \"RIL\")\n+  (set_attr \"mnemonic\" \"jg\")\n+  (set_attr \"type\"  \"branch\")\n+  (set_attr \"atype\" \"agen\")])\n+\n+(define_insn \"indirect_jump_via_thunk<mode>\"\n+  [(set (pc)\n+\t(match_operand:P 0 \"register_operand\" \" a\"))\n+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]\n+ \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\n+  && !TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  INVALID_REGNUM,\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_jump);\n+  return \"\";\n+}\n+ [(set_attr \"op_type\"  \"RIL\")\n+  (set_attr \"mnemonic\" \"jg\")\n+  (set_attr \"type\"  \"branch\")\n+  (set_attr \"atype\" \"agen\")])\n+\n+\n+; The label_ref is wrapped into an if_then_else in order to hide it\n+; from mark_jump_label.  Without this the label_ref would become the\n+; ONLY jump target of that jump breaking the control flow graph.\n+(define_insn \"indirect_jump_via_inlinethunk<mode>_z10\"\n+  [(unspec [(if_then_else (match_operand:P 1 \"larl_operand\" \"X\")\n+\t\t\t  (const_int 0)\n+\t\t\t  (const_int 0))\n+\t    (const_int 0)] UNSPEC_EXECUTE_JUMP)\n+   (set (pc) (match_operand:P 0 \"register_operand\" \"a\"))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK\n+   && TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_inline_thunk (operands[1]);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"branch\")\n+   (set_attr \"length\"  \"10\")])\n+\n+(define_insn \"indirect_jump_via_inlinethunk<mode>\"\n+  [(unspec [(if_then_else (match_operand:P 1 \"larl_operand\" \"X\")\n+\t\t\t  (const_int 0)\n+\t\t\t  (const_int 0))\n+\t    (match_operand:P 2 \"register_operand\" \"a\")] UNSPEC_EXECUTE_JUMP)\n+   (set (pc) (match_operand:P 0 \"register_operand\" \"a\"))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK\n+   && !TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_inline_thunk (operands[2]);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RX\")\n+   (set_attr \"type\"    \"branch\")\n+   (set_attr \"length\"  \"8\")])\n \n ; FIXME: LRA does not appear to be able to deal with MEMs being\n ; checked against address constraints like ZR above.  So make this a\n ; separate pattern for now.\n (define_insn \"*indirect2_jump\"\n   [(set (pc)\n \t(match_operand 0 \"nonimmediate_operand\" \"a,T\"))]\n- \"\"\n+ \"!TARGET_INDIRECT_BRANCH_NOBP_JUMP\"\n  \"@\n   br\\t%0\n   bi\\t%0\"\n@@ -9699,10 +9852,73 @@\n ; casesi instruction pattern(s).\n ;\n \n-(define_insn \"casesi_jump\"\n- [(set (pc) (match_operand 0 \"address_operand\" \"ZR\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n+(define_expand \"casesi_jump\"\n+  [(parallel\n+    [(set (pc) (match_operand 0 \"address_operand\"))\n+     (use (label_ref (match_operand 1 \"\")))])]\n   \"\"\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)\n+    {\n+      operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);\n+\n+      if (TARGET_CPU_Z10)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_casesi_jump_via_thunkdi_z10 (operands[0],\n+\t\t\t\t\t\t\t     operands[1]));\n+\t  else\n+\t    emit_jump_insn (gen_casesi_jump_via_thunksi_z10 (operands[0],\n+\t\t\t\t\t\t\t     operands[1]));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_casesi_jump_via_thunkdi (operands[0],\n+\t\t\t\t\t\t\t operands[1]));\n+\t  else\n+\t    emit_jump_insn (gen_casesi_jump_via_thunksi (operands[0],\n+\t\t\t\t\t\t\t operands[1]));\n+\t}\n+      DONE;\n+    }\n+\n+    if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)\n+    {\n+      operands[0] = force_reg (Pmode, operands[0]);\n+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());\n+      if (TARGET_CPU_Z10)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi_z10 (operands[0],\n+\t\t\t\t\t\t\t\t   operands[1],\n+\t\t\t\t\t\t\t\t   label_ref));\n+\t  else\n+\t    emit_jump_insn (gen_casesi_jump_via_inlinethunksi_z10 (operands[0],\n+\t\t\t\t\t\t\t\t   operands[1],\n+\t\t\t\t\t\t\t\t   label_ref));\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi (operands[0],\n+\t\t\t\t\t\t\t       operands[1],\n+\t\t\t\t\t\t\t       label_ref,\n+\t\t\t\t\t\t\t       force_reg (Pmode, label_ref)));\n+\t  else\n+\t    emit_jump_insn (gen_casesi_jump_via_inlinethunksi (operands[0],\n+\t\t\t\t\t\t\t       operands[1],\n+\t\t\t\t\t\t\t       label_ref,\n+\t\t\t\t\t\t\t       force_reg (Pmode, label_ref)));\n+\t}\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*casesi_jump\"\n+ [(set (pc) (match_operand 0 \"address_operand\" \"ZR\"))\n+  (use (label_ref (match_operand 1 \"\" \"\")))]\n+ \"!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"br\\t%0\";\n@@ -9712,9 +9928,85 @@\n   [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n+   (set (attr \"mnemonic\")\n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"br\") (const_string \"b\")))\n+   (set_attr \"type\"  \"branch\")\n+   (set_attr \"atype\" \"agen\")])\n+\n+(define_insn \"casesi_jump_via_thunk<mode>_z10\"\n+ [(set (pc) (match_operand:P 0 \"register_operand\" \"a\"))\n+  (use (label_ref (match_operand 1 \"\" \"\")))]\n+ \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\n+  && TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  INVALID_REGNUM,\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_jump);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\" \"jg\")\n+   (set_attr \"type\"  \"branch\")\n+   (set_attr \"atype\" \"agen\")])\n+\n+(define_insn \"casesi_jump_via_thunk<mode>\"\n+ [(set (pc) (match_operand:P 0 \"register_operand\" \"a\"))\n+  (use (label_ref (match_operand 1 \"\" \"\")))\n+  (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]\n+ \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK\n+  && !TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  INVALID_REGNUM,\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_jump);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\" \"jg\")\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")])\n \n+\n+; The label_ref is wrapped into an if_then_else in order to hide it\n+; from mark_jump_label.  Without this the label_ref would become the\n+; ONLY jump target of that jump breaking the control flow graph.\n+(define_insn \"casesi_jump_via_inlinethunk<mode>_z10\"\n+  [(unspec [(if_then_else (match_operand:P 2 \"larl_operand\" \"X\")\n+\t\t\t  (const_int 0)\n+\t\t\t  (const_int 0))\n+\t    (const_int 0)] UNSPEC_EXECUTE_JUMP)\n+   (set (pc) (match_operand:P 0 \"register_operand\" \"a\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK\n+   && TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_inline_thunk (operands[2]);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"type\"    \"cs\")\n+   (set_attr \"length\"  \"10\")])\n+\n+(define_insn \"casesi_jump_via_inlinethunk<mode>\"\n+  [(unspec [(if_then_else (match_operand:P 2 \"larl_operand\" \"X\")\n+\t\t\t  (const_int 0)\n+\t\t\t  (const_int 0))\n+\t    (match_operand:P 3 \"register_operand\" \"a\")] UNSPEC_EXECUTE_JUMP)\n+   (set (pc) (match_operand:P 0 \"register_operand\" \"a\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK\n+   && !TARGET_CPU_Z10\"\n+{\n+  s390_indirect_branch_via_inline_thunk (operands[3]);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RX\")\n+   (set_attr \"type\"    \"cs\")\n+   (set_attr \"length\"  \"8\")])\n+\n (define_expand \"casesi\"\n   [(match_operand:SI 0 \"general_operand\" \"\")\n    (match_operand:SI 1 \"general_operand\" \"\")\n@@ -9819,8 +10111,27 @@\n          (match_operand 0 \"const_int_operand\" \"n\"))]\n   \"SIBLING_CALL_P (insn)\n    && GET_MODE (XEXP (XEXP (PATTERN (insn), 0), 0)) == Pmode\"\n-  \"br\\t%%r1\"\n-  [(set_attr \"op_type\" \"RR\")\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)\n+    {\n+      gcc_assert (TARGET_CPU_Z10);\n+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,\n+\t\t\t\t      INVALID_REGNUM,\n+\t\t\t\t      NULL_RTX,\n+\t\t\t\t      s390_indirect_branch_type_call);\n+      return \"\";\n+    }\n+  else\n+    return \"br\\t%%r1\";\n+}\n+ [(set (attr \"op_type\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_CALL\")\n+\t\t     (const_string \"RIL\")\n+\t\t     (const_string \"RR\")))\n+  (set (attr \"mnemonic\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_CALL\")\n+\t\t     (const_string \"jg\")\n+\t\t     (const_string \"br\")))\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")])\n \n@@ -9860,8 +10171,27 @@\n \t      (match_operand 1 \"const_int_operand\" \"n\")))]\n   \"SIBLING_CALL_P (insn)\n    && GET_MODE (XEXP (XEXP (XEXP (PATTERN (insn), 1), 0), 0)) == Pmode\"\n-  \"br\\t%%r1\"\n-  [(set_attr \"op_type\" \"RR\")\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)\n+    {\n+      gcc_assert (TARGET_CPU_Z10);\n+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,\n+\t\t\t\t      INVALID_REGNUM,\n+\t\t\t\t      NULL_RTX,\n+\t\t\t\t      s390_indirect_branch_type_call);\n+      return \"\";\n+    }\n+  else\n+    return \"br\\t%%r1\";\n+}\n+  [(set (attr \"op_type\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_CALL\")\n+\t\t     (const_string \"RIL\")\n+\t\t     (const_string \"RR\")))\n+   (set (attr \"mnemonic\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_CALL\")\n+\t\t     (const_string \"jg\")\n+\t\t     (const_string \"br\")))\n    (set_attr \"type\"  \"branch\")\n    (set_attr \"atype\" \"agen\")])\n \n@@ -9927,7 +10257,9 @@\n   [(call (mem:QI (match_operand 0 \"address_operand\" \"ZR\"))\n          (match_operand 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n-  \"!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode\"\n+  \"!TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && !SIBLING_CALL_P (insn)\n+   && GET_MODE (operands[2]) == Pmode\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"basr\\t%2,%0\";\n@@ -9937,6 +10269,50 @@\n   [(set (attr \"op_type\")\n         (if_then_else (match_operand 0 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n+   (set (attr \"mnemonic\")\n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"basr\") (const_string \"bas\")))\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")\n+   (set_attr \"z196prop\" \"z196_cracked\")])\n+\n+(define_insn \"*basr_via_thunk<mode>_z10\"\n+  [(call (mem:QI (match_operand:P 0 \"register_operand\" \"a\"))\n+         (match_operand 1 \"const_int_operand\"          \"n\"))\n+   (clobber (match_operand:P 2 \"register_operand\"    \"=&r\"))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && TARGET_CPU_Z10\n+   && !SIBLING_CALL_P (insn)\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  REGNO (operands[2]),\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_call);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\" \"brasl\")\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")\n+   (set_attr \"z196prop\" \"z196_cracked\")])\n+\n+(define_insn \"*basr_via_thunk<mode>\"\n+  [(call (mem:QI (match_operand:P 0 \"register_operand\" \"a\"))\n+         (match_operand 1 \"const_int_operand\"          \"n\"))\n+   (clobber (match_operand:P 2 \"register_operand\"    \"=&r\"))\n+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && !TARGET_CPU_Z10\n+   && !SIBLING_CALL_P (insn)\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+\t\t\t\t  REGNO (operands[2]),\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_call);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\" \"brasl\")\n    (set_attr \"type\"  \"jsr\")\n    (set_attr \"atype\" \"agen\")\n    (set_attr \"z196prop\" \"z196_cracked\")])\n@@ -9988,7 +10364,9 @@\n         (call (mem:QI (match_operand 1 \"address_operand\" \"ZR\"))\n               (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n-  \"!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode\"\n+  \"!TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && !SIBLING_CALL_P (insn)\n+   && GET_MODE (operands[3]) == Pmode\"\n {\n   if (get_attr_op_type (insn) == OP_TYPE_RR)\n     return \"basr\\t%3,%1\";\n@@ -9998,6 +10376,54 @@\n   [(set (attr \"op_type\")\n         (if_then_else (match_operand 1 \"register_operand\" \"\")\n                       (const_string \"RR\") (const_string \"RX\")))\n+   (set (attr \"mnemonic\")\n+        (if_then_else (match_operand 1 \"register_operand\" \"\")\n+                      (const_string \"basr\") (const_string \"bas\")))\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")\n+   (set_attr \"z196prop\" \"z196_cracked\")])\n+\n+(define_insn \"*basr_r_via_thunk_z10\"\n+  [(set (match_operand 0 \"\" \"\")\n+        (call (mem:QI (match_operand 1 \"register_operand\" \"a\"))\n+              (match_operand 2 \"const_int_operand\"        \"n\")))\n+   (clobber (match_operand 3 \"register_operand\"         \"=&r\"))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && TARGET_CPU_Z10\n+   && !SIBLING_CALL_P (insn)\n+   && GET_MODE (operands[3]) == Pmode\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[1]),\n+\t\t\t\t  REGNO (operands[3]),\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_call);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\" \"brasl\")\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")\n+   (set_attr \"z196prop\" \"z196_cracked\")])\n+\n+(define_insn \"*basr_r_via_thunk\"\n+  [(set (match_operand 0 \"\" \"\")\n+        (call (mem:QI (match_operand 1 \"register_operand\" \"a\"))\n+              (match_operand 2 \"const_int_operand\"        \"n\")))\n+   (clobber (match_operand 3 \"register_operand\"         \"=&r\"))\n+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]\n+  \"TARGET_INDIRECT_BRANCH_NOBP_CALL\n+   && !TARGET_CPU_Z10\n+   && !SIBLING_CALL_P (insn)\n+   && GET_MODE (operands[3]) == Pmode\"\n+{\n+  s390_indirect_branch_via_thunk (REGNO (operands[1]),\n+\t\t\t\t  REGNO (operands[3]),\n+\t\t\t\t  NULL_RTX,\n+\t\t\t\t  s390_indirect_branch_type_call);\n+  return \"\";\n+}\n+  [(set_attr \"op_type\" \"RIL\")\n+   (set_attr \"mnemonic\"  \"brasl\")\n    (set_attr \"type\"  \"jsr\")\n    (set_attr \"atype\" \"agen\")\n    (set_attr \"z196prop\" \"z196_cracked\")])\n@@ -10734,17 +11160,101 @@\n (define_insn \"<code>\"\n   [(ANY_RETURN)]\n   \"s390_can_use_<code>_insn ()\"\n-  \"br\\t%%r14\"\n-  [(set_attr \"op_type\" \"RR\")\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)\n+    {\n+      /* The target is always r14 so there is no clobber\n+\t of r1 needed for pre z10 targets.  */\n+      s390_indirect_branch_via_thunk (RETURN_REGNUM,\n+\t\t\t\t      INVALID_REGNUM,\n+\t\t\t\t      NULL_RTX,\n+\t\t\t\t      s390_indirect_branch_type_return);\n+      return \"\";\n+    }\n+  else\n+    return \"br\\t%%r14\";\n+}\n+  [(set (attr \"op_type\")\n+\t(if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+\t\t      (const_string \"RIL\")\n+\t\t      (const_string \"RR\")))\n+   (set (attr \"mnemonic\")\n+\t(if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+\t\t      (const_string \"jg\")\n+\t\t      (const_string \"br\")))\n    (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n \n-(define_insn \"*return\"\n+\n+(define_expand \"return_use\"\n+  [(parallel\n+    [(return)\n+     (use (match_operand 0 \"register_operand\" \"a\"))])]\n+  \"\"\n+{\n+  if (!TARGET_CPU_Z10\n+      && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION)\n+    {\n+      if (TARGET_64BIT)\n+        emit_jump_insn (gen_returndi_prez10 (operands[0]));\n+      else\n+        emit_jump_insn (gen_returnsi_prez10 (operands[0]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"*return<mode>\"\n   [(return)\n-   (use (match_operand 0 \"register_operand\" \"a\"))]\n-  \"GET_MODE (operands[0]) == Pmode\"\n-  \"br\\t%0\"\n-  [(set_attr \"op_type\" \"RR\")\n+   (use (match_operand:P 0 \"register_operand\" \"a\"))]\n+  \"TARGET_CPU_Z10 || !TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION\"\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)\n+    {\n+      s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+                                      INVALID_REGNUM,\n+                                      NULL_RTX,\n+                                      s390_indirect_branch_type_return);\n+      return \"\";\n+    }\n+  else\n+    return \"br\\t%0\";\n+}\n+  [(set (attr \"op_type\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+                     (const_string \"RIL\")\n+                     (const_string \"RR\")))\n+   (set (attr \"mnemonic\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+                     (const_string \"jg\")\n+                     (const_string \"br\")))\n+   (set_attr \"type\"    \"jsr\")\n+   (set_attr \"atype\"   \"agen\")])\n+\n+(define_insn \"return<mode>_prez10\"\n+  [(return)\n+   (use (match_operand:P 0 \"register_operand\" \"a\"))\n+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]\n+  \"!TARGET_CPU_Z10 && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION\"\n+{\n+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)\n+    {\n+      s390_indirect_branch_via_thunk (REGNO (operands[0]),\n+                                      INVALID_REGNUM,\n+                                      NULL_RTX,\n+                                      s390_indirect_branch_type_return);\n+      return \"\";\n+    }\n+  else\n+    return \"br\\t%0\";\n+}\n+  [(set (attr \"op_type\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+                     (const_string \"RIL\")\n+                     (const_string \"RR\")))\n+   (set (attr \"mnemonic\")\n+       (if_then_else (match_test \"TARGET_INDIRECT_BRANCH_NOBP_RET\")\n+                     (const_string \"jg\")\n+                     (const_string \"br\")))\n    (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n "}, {"sha": "eb16f9c821fb05ec8b3d8cfa5cb4027d61181e09", "filename": "gcc/config/s390/s390.opt", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Fconfig%2Fs390%2Fs390.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.opt?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -233,3 +233,63 @@ Use LRA instead of reload.\n mpic-data-is-text-relative\n Target Report Var(s390_pic_data_is_text_relative) Init(TARGET_DEFAULT_PIC_DATA_IS_TEXT_RELATIVE)\n Assume data segments are relative to text segment.\n+\n+\n+mindirect-branch=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch) Init(indirect_branch_keep)\n+Wrap all indirect branches into execute in order to disable branch\n+prediction.\n+\n+mindirect-branch-jump=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_jump) Init(indirect_branch_keep)\n+Wrap indirect table jumps and computed gotos into execute in order to\n+disable branch prediction.  Using thunk or thunk-extern with this\n+option requires the thunks to be considered signal handlers to order to\n+generate correct CFI.  For environments where unwinding (e.g. for\n+exceptions) is required please use thunk-inline instead.\n+\n+mindirect-branch-call=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_call) Init(indirect_branch_keep)\n+Wrap all indirect calls into execute in order to disable branch prediction.\n+\n+mfunction-return=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return) Init(indirect_branch_keep)\n+Wrap all indirect return branches into execute in order to disable branch\n+prediction.\n+\n+mfunction-return-mem=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_mem) Init(indirect_branch_keep)\n+Wrap indirect return branches into execute in order to disable branch\n+prediction. This affects only branches where the return address is\n+going to be restored from memory.\n+\n+mfunction-return-reg=\n+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_reg) Init(indirect_branch_keep)\n+Wrap indirect return branches into execute in order to disable branch\n+prediction. This affects only branches where the return address\n+doesn't need to be restored from memory.\n+\n+Enum\n+Name(indirect_branch) Type(enum indirect_branch)\n+Known indirect branch choices (for use with the -mindirect-branch=/-mfunction-return= options):\n+\n+EnumValue\n+Enum(indirect_branch) String(keep) Value(indirect_branch_keep)\n+\n+EnumValue\n+Enum(indirect_branch) String(thunk) Value(indirect_branch_thunk)\n+\n+EnumValue\n+Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)\n+\n+EnumValue\n+Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)\n+\n+mindirect-branch-table\n+Target Report Var(s390_indirect_branch_table) Init(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)\n+Generate sections .s390_indirect_jump, .s390_indirect_call,\n+.s390_return_reg, and .s390_return_mem to contain the indirect branch\n+locations which have been patched as part of using one of the\n+-mindirect-branch* or -mfunction-return* options.  The sections\n+consist of an array of 32 bit elements. Each entry holds the offset\n+from the entry to the patched location."}, {"sha": "5f45c55b663ab9ddc8c04062fff18712571caac8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -1,3 +1,32 @@\n+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>\n+\n+\t* gcc.target/s390/nobp-function-pointer-attr.c: New test.\n+\t* gcc.target/s390/nobp-function-pointer-nothunk.c: New test.\n+\t* gcc.target/s390/nobp-function-pointer-z10.c: New test.\n+\t* gcc.target/s390/nobp-function-pointer-z900.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-attr.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-inline-attr.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-inline-z10.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-inline-z900.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-nothunk.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-z10.c: New test.\n+\t* gcc.target/s390/nobp-indirect-jump-z900.c: New test.\n+\t* gcc.target/s390/nobp-return-attr-all.c: New test.\n+\t* gcc.target/s390/nobp-return-attr-neg.c: New test.\n+\t* gcc.target/s390/nobp-return-mem-attr.c: New test.\n+\t* gcc.target/s390/nobp-return-mem-nothunk.c: New test.\n+\t* gcc.target/s390/nobp-return-mem-z10.c: New test.\n+\t* gcc.target/s390/nobp-return-mem-z900.c: New test.\n+\t* gcc.target/s390/nobp-return-reg-attr.c: New test.\n+\t* gcc.target/s390/nobp-return-reg-mixed.c: New test.\n+\t* gcc.target/s390/nobp-return-reg-nothunk.c: New test.\n+\t* gcc.target/s390/nobp-return-reg-z10.c: New test.\n+\t* gcc.target/s390/nobp-return-reg-z900.c: New test.\n+\t* gcc.target/s390/nobp-table-jump-inline-z10.c: New test.\n+\t* gcc.target/s390/nobp-table-jump-inline-z900.c: New test.\n+\t* gcc.target/s390/nobp-table-jump-z10.c: New test.\n+\t* gcc.target/s390/nobp-table-jump-z900.c: New test.\n+\n 2018-02-08  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/84233"}, {"sha": "db9336d51dd68a962a86ee6f19df349756da1561", "filename": "gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-attr.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3  -march=z10 --save-temps -mindirect-branch-table\" } */\n+\n+int gl;\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  gl = a + 40;\n+}\n+\n+int __attribute__((noinline,noclone))\n+foo_value (int a)\n+{\n+  return a + 40;\n+}\n+\n+void* __attribute__((noinline,noclone))\n+get_fptr (int a)\n+{\n+  switch (a)\n+    {\n+    case 0: return &foo; break;\n+    case 1: return &foo_value; break;\n+    default: __builtin_abort ();\n+    }\n+}\n+\n+void (*f) (int);\n+int (*g) (int);\n+\n+int __attribute__((indirect_branch_call(\"thunk\")))\n+main ()\n+{\n+  int res;\n+\n+  f = get_fptr(0);\n+  f (2);\n+  if (gl != 42)\n+    __builtin_abort ();\n+\n+  g = get_fptr(1);\n+  if (g (2) != 42)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 2 x main\n+/* { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "c02b45a2cc76e7a4a47fd26982f2d2d02f9d66ff", "filename": "gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-nothunk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-nothunk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-nothunk.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3  -march=z10 --save-temps -mindirect-branch-call=thunk-extern -mindirect-branch-table\" } */\n+\n+int gl;\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  gl = a + 40;\n+}\n+\n+int __attribute__((noinline,noclone))\n+foo_value (int a)\n+{\n+  return a + 40;\n+}\n+\n+void*  __attribute__((noinline,noclone))\n+get_fptr (int a)\n+{\n+  switch (a)\n+    {\n+    case 0: return &foo; break;\n+    case 1: return &foo_value; break;\n+    default: __builtin_abort ();\n+    }\n+}\n+\n+void (*f) (int);\n+int (*g) (int);\n+\n+int\n+main ()\n+{\n+  int res;\n+\n+  f = get_fptr(0);\n+  f (2);\n+  if (gl != 42)\n+    __builtin_abort ();\n+\n+  g = get_fptr(1);\n+  if (g (2) != 42)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 2 x main\n+/* { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,__s390_indirect_jump\" 2 } } */\n+\n+/* No thunks due to thunk-extern.  */\n+/* { dg-final { scan-assembler-not \"exrl\" } } */\n+/* { dg-final { scan-assembler-not \".globl __s390_indirect_jump\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "b5f13eb07931eef8d87d4df87834533977c0f9f0", "filename": "gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3  -march=z10 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table\" } */\n+\n+int gl;\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  gl = a + 40;\n+}\n+\n+int __attribute__((noinline,noclone))\n+foo_value (int a)\n+{\n+  return a + 40;\n+}\n+\n+void*  __attribute__((noinline,noclone))\n+get_fptr (int a)\n+{\n+  switch (a)\n+    {\n+    case 0: return &foo; break;\n+    case 1: return &foo_value; break;\n+    default: __builtin_abort ();\n+    }\n+}\n+\n+void (*f) (int);\n+int (*g) (int);\n+\n+int\n+main ()\n+{\n+  int res;\n+\n+  f = get_fptr(0);\n+  f (2);\n+  if (gl != 42)\n+    __builtin_abort ();\n+\n+  g = get_fptr(1);\n+  if (g (2) != 42)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 2 x main\n+/* { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "486495b97acd8a000c5770f705b3274c8c5bf7b4", "filename": "gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-function-pointer-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3  -march=z900 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table\" } */\n+\n+int gl;\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  gl = a + 40;\n+}\n+\n+int __attribute__((noinline,noclone))\n+foo_value (int a)\n+{\n+  return a + 40;\n+}\n+\n+void*  __attribute__((noinline,noclone))\n+get_fptr (int a)\n+{\n+  switch (a)\n+    {\n+    case 0: return &foo; break;\n+    case 1: return &foo_value; break;\n+    default: __builtin_abort ();\n+    }\n+}\n+\n+void (*f) (int);\n+int (*g) (int);\n+\n+int\n+main ()\n+{\n+  int res;\n+\n+  f = get_fptr(0);\n+  f (2);\n+  if (gl != 42)\n+    __builtin_abort ();\n+\n+  g = get_fptr(1);\n+  if (g (2) != 42)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 2 x main\n+/* { dg-final { scan-assembler-times \"brasl\\t%r\\[0-9\\]*,__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"ex\\t\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "c62ddf56b8ab33d4c5037f418f1671d0f201cc81", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-attr.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void __attribute__((indirect_branch_jump(\"thunk\")))\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* 2x bar */\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "63d64c15941ce92705d0c3b0875fa7c3847fcfe0", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-attr.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void __attribute__((indirect_branch_jump(\"thunk-inline\")))\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* The two gotos in bar get merged.  */\n+/* { dg-final { scan-assembler-times \"exrl\" 1 } } */\n+\n+/* { dg-final { scan-assembler-not \"jg\\t__s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "28d7837e2a4be032f3521cd52b4b79bbbc293e3e", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* The two gotos in bar get merged.  */\n+/* { dg-final { scan-assembler-times \"exrl\" 1 } } */\n+\n+/* { dg-final { scan-assembler-not \"jg\\t__s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "3c0c007253921b32a39b4d5363948781bad57a39", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-inline-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* The two gotos in bar get merged.  */\n+/* { dg-final { scan-assembler-times \"\\tex\\t\" 1 } } */\n+\n+/* { dg-final { scan-assembler-not \"jg\\t__s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "05c8bb8c12d929c4861e995c4ca57f499fb4293a", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-nothunk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-nothunk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-nothunk.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-extern -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* 2 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+\n+/* No thunks due to thunk-extern.  */\n+/* { dg-final { scan-assembler-not \"exrl\" } } */\n+/* { dg-final { scan-assembler-not \".globl __s390_indirect_jump\" } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "71c86fdfebc5ae417d1296c4bfdd87529dfd1c4e", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* 2x bar */\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "89ad799c7a673271d70b536a5bb0ef58d75b04a3", "filename": "gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-indirect-jump-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table\" } */\n+/* { dg-require-effective-target label_values } */\n+\n+/* This is a copy of the gcc.c-torture/execute/20040302-1.c\n+   testcase.  */\n+\n+int code[]={0,0,0,0,1};\n+\n+void\n+foo(int x) {\n+  volatile int b;\n+  b = 0xffffffff;\n+}\n+\n+void\n+bar(int *pc) {\n+  static const void *l[] = {&&lab0, &&end};\n+\n+  foo(0);\n+  goto *l[*pc];\n+ lab0:\n+  foo(0);\n+  pc++;\n+  goto *l[*pc];\n+ end:\n+  return;\n+}\n+\n+int\n+main() {\n+  bar(code);\n+  return 0;\n+}\n+\n+/* 2 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"ex\\t\" } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "4bf88cf78c2af0ceadb0298e02be9bbfaf8b10f7", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-all.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-all.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-all.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((function_return(\"thunk\"),noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* With -march=z10 -mzarch the shrink wrapped returns use compare and\n+   swap relative to jump to the exit block instead of making use of\n+   the conditional return pattern.\n+   FIXME: Use compare and branch register for that!!!! */\n+\n+/* 2 x foo\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_mem\" } } */"}, {"sha": "8b32bfe5172fcea6dc1d341face898cddd814b93", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-neg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-neg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-attr-neg.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((function_return(\"keep\"),noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int __attribute__((function_return(\"keep\")))\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not \"jg\\t__s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "39cab8bd89ebf1bd69d02aaf14ac5372cf1131e8", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-attr.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((function_return_mem(\"thunk\"),noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* With -march=z10 -mzarch the shrink wrapped returns use compare and\n+   swap relative to jump to the exit block instead of making use of\n+   the conditional return pattern.\n+   FIXME: Use compare and branch register for that!!!! */\n+\n+/* 2 x foo\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_mem\" } } */"}, {"sha": "f99f152305cdbeb41793b31eaadeb13af4a59a76", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-nothunk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-nothunk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-nothunk.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk-extern -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* With -march=z10 -mzarch the shrink wrapped returns use compare and\n+   swap relative to jump to the exit block instead of making use of\n+   the conditional return pattern.\n+   FIXME: Use compare and branch register for that!!!! */\n+\n+/* 2 x foo, 1 x main\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 3 } } */\n+\n+/* No thunks due to thunk-extern.  */\n+/* { dg-final { scan-assembler-not \"exrl\" } } */\n+/* { dg-final { scan-assembler-not \".globl __s390_indirect_jump\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_mem\" } } */"}, {"sha": "177fc32c24bc06a72dd85a73390736f50f04d803", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* With -march=z10 -mzarch the shrink wrapped returns use compare and\n+   swap relative to jump to the exit block instead of making use of\n+   the conditional return pattern.\n+   FIXME: Use compare and branch register for that!!!! */\n+\n+/* 2 x foo, 1 x main\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 3 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_mem\" } } */"}, {"sha": "0b318115a8f4e7f40a9e87b748b71bec56ae39b2", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-mem-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 --save-temps -mfunction-return-mem=thunk -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x foo, 1 x main\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+\n+/* 1 x foo, conditional return, shrink wrapped\n+/* { dg-final { scan-assembler \"jge\\t__s390_indirect_jump\" } } */\n+\n+/* 1 x foo, conditional return, shrink wrapped\n+/* { dg-final { scan-assembler \"jgle\\t__s390_indirect_jump\" } } */\n+\n+/* { dg-final { scan-assembler \"ex\\t\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_mem\" } } */"}, {"sha": "ebfc9ff0ebb4bdefc2ba61a5b9be34867b61ccc2", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-attr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-attr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-attr.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((function_return_reg(\"thunk\"),noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 1 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "82833f7e0d7b9c91fe6f16ee801c003f3619d67e", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-mixed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-mixed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-mixed.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table\" } */\n+\n+/* We have to generate different thunks for indirect branches\n+   depending on whether the code is compiled for pre z10 machines or\n+   later.  This testcase makes sure this works within the same compile\n+   unit.  */\n+\n+int __attribute__((noinline,noclone,target(\"arch=z10\")))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+int __attribute__((noinline,noclone,target(\"arch=z9-ec\")))\n+foo (int a)\n+{\n+  return a + 3;\n+}\n+\n+int\n+main ()\n+{\n+  if (bar (42) != 44)\n+    __builtin_abort ();\n+\n+  if (foo (42) != 45)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar, 1 x foo */\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 2 } } */\n+/* 1 x foo */\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump_r1use\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ex\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"exrl\\t\" 1 } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "4ea14e379f50ad0f5e5e4ad8d248d710617c7aaf", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-nothunk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-nothunk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-nothunk.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mfunction-return-reg=thunk-extern -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 1 } } */\n+\n+/* No thunks due to thunk-extern.  */\n+/* { dg-final { scan-assembler-not \"exrl\" } } */\n+/* { dg-final { scan-assembler-not \".globl __s390_indirect_jump\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "42c3e7435fa7ab3c509f3152cdde91b0a4ed0e89", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 1 } } */\n+/* { dg-final { scan-assembler \"exrl\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "3f4efa57e71d763f2bd488cbc75065079d5a816e", "filename": "gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-return-reg-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table\" } */\n+\n+int gl = 0;\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  return a + 2;\n+}\n+\n+void __attribute__((noinline,noclone))\n+foo (int a)\n+{\n+  int i;\n+\n+  if (a == 42)\n+    return;\n+\n+  for (i = 0; i < a; i++)\n+    gl += bar (i);\n+}\n+\n+int\n+main ()\n+{\n+  foo (3);\n+  if (gl != 9)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"jg\\t__s390_indirect_jump\" 1 } } */\n+/* { dg-final { scan-assembler \"ex\\t\" } } */\n+\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler     \"section\\t.s390_return_reg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_mem\" } } */"}, {"sha": "8dfd7e4c7861356ee83a448b9c78a145a2460cb1", "filename": "gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table\" } */\n+\n+/* case-values-threshold will be set to 20 by the back-end when jump\n+   thunk are requested.  */\n+\n+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }\n+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }\n+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }\n+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }\n+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }\n+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }\n+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }\n+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }\n+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }\n+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }\n+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }\n+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }\n+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }\n+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }\n+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }\n+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }\n+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }\n+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }\n+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }\n+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }\n+\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  int ret = 0;\n+\n+  switch (a)\n+    {\n+    case 1: ret = foo1 (); break;\n+    case 2: ret = foo2 (); break;\n+    case 3: ret = foo3 (); break;\n+    case 4: ret = foo4 (); break;\n+    case 5: ret = foo5 (); break;\n+    case 6: ret = foo6 (); break;\n+    case 7: ret = foo7 (); break;\n+    case 8: ret = foo8 (); break;\n+    case 9: ret = foo9 (); break;\n+    case 10: ret = foo10 (); break;\n+    case 11: ret = foo11 (); break;\n+    case 12: ret = foo12 (); break;\n+    case 13: ret = foo13 (); break;\n+    case 14: ret = foo14 (); break;\n+    case 15: ret = foo15 (); break;\n+    case 16: ret = foo16 (); break;\n+    case 17: ret = foo17 (); break;\n+    case 18: ret = foo18 (); break;\n+    case 19: ret = foo19 (); break;\n+    case 20: ret = foo20 (); break;\n+    default:\n+      __builtin_abort ();\n+    }\n+\n+  return ret;\n+}\n+\n+int\n+main ()\n+{\n+  if (bar (3) != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"exrl\" 1 } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_fromreg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_frommem\" } } */"}, {"sha": "46d2c54bcff10d1d19120452bcff9f771dc598af", "filename": "gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-inline-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table\" } */\n+\n+/* case-values-threshold will be set to 20 by the back-end when jump\n+   thunk are requested.  */\n+\n+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }\n+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }\n+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }\n+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }\n+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }\n+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }\n+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }\n+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }\n+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }\n+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }\n+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }\n+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }\n+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }\n+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }\n+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }\n+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }\n+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }\n+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }\n+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }\n+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }\n+\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  int ret = 0;\n+\n+  switch (a)\n+    {\n+    case 1: ret = foo1 (); break;\n+    case 2: ret = foo2 (); break;\n+    case 3: ret = foo3 (); break;\n+    case 4: ret = foo4 (); break;\n+    case 5: ret = foo5 (); break;\n+    case 6: ret = foo6 (); break;\n+    case 7: ret = foo7 (); break;\n+    case 8: ret = foo8 (); break;\n+    case 9: ret = foo9 (); break;\n+    case 10: ret = foo10 (); break;\n+    case 11: ret = foo11 (); break;\n+    case 12: ret = foo12 (); break;\n+    case 13: ret = foo13 (); break;\n+    case 14: ret = foo14 (); break;\n+    case 15: ret = foo15 (); break;\n+    case 16: ret = foo16 (); break;\n+    case 17: ret = foo17 (); break;\n+    case 18: ret = foo18 (); break;\n+    case 19: ret = foo19 (); break;\n+    case 20: ret = foo20 (); break;\n+    default:\n+      __builtin_abort ();\n+    }\n+\n+  return ret;\n+}\n+\n+int\n+main ()\n+{\n+  if (bar (3) != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"\\tex\\t\" 1 } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_fromreg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_frommem\" } } */"}, {"sha": "9dfe391f33708711b8692c87bec8338672b0f1b8", "filename": "gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z10.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table\" } */\n+/* case-values-threshold will be set to 20 by the back-end when jump\n+   thunk are requested.  */\n+\n+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }\n+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }\n+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }\n+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }\n+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }\n+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }\n+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }\n+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }\n+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }\n+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }\n+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }\n+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }\n+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }\n+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }\n+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }\n+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }\n+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }\n+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }\n+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }\n+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }\n+\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  int ret = 0;\n+\n+  switch (a)\n+    {\n+    case 1: ret = foo1 (); break;\n+    case 2: ret = foo2 (); break;\n+    case 3: ret = foo3 (); break;\n+    case 4: ret = foo4 (); break;\n+    case 5: ret = foo5 (); break;\n+    case 6: ret = foo6 (); break;\n+    case 7: ret = foo7 (); break;\n+    case 8: ret = foo8 (); break;\n+    case 9: ret = foo9 (); break;\n+    case 10: ret = foo10 (); break;\n+    case 11: ret = foo11 (); break;\n+    case 12: ret = foo12 (); break;\n+    case 13: ret = foo13 (); break;\n+    case 14: ret = foo14 (); break;\n+    case 15: ret = foo15 (); break;\n+    case 16: ret = foo16 (); break;\n+    case 17: ret = foo17 (); break;\n+    case 18: ret = foo18 (); break;\n+    case 19: ret = foo19 (); break;\n+    case 20: ret = foo20 (); break;\n+    default:\n+      __builtin_abort ();\n+    }\n+\n+  return ret;\n+}\n+\n+int\n+main ()\n+{\n+  if (bar (3) != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"exrl\" 1 } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_fromreg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_frommem\" } } */"}, {"sha": "f1439a8b1205bf6d003b4988798890d7a8b825f2", "filename": "gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z900.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84b4c7b593cd4ebb475a08aa4b816c722f716ce6/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z900.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fnobp-table-jump-z900.c?ref=84b4c7b593cd4ebb475a08aa4b816c722f716ce6", "patch": "@@ -0,0 +1,78 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table\" } */\n+\n+/* case-values-threshold will be set to 20 by the back-end when jump\n+   thunk are requested.  */\n+\n+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }\n+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }\n+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }\n+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }\n+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }\n+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }\n+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }\n+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }\n+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }\n+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }\n+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }\n+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }\n+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }\n+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }\n+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }\n+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }\n+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }\n+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }\n+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }\n+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }\n+\n+\n+int __attribute__((noinline,noclone))\n+bar (int a)\n+{\n+  int ret = 0;\n+\n+  switch (a)\n+    {\n+    case 1: ret = foo1 (); break;\n+    case 2: ret = foo2 (); break;\n+    case 3: ret = foo3 (); break;\n+    case 4: ret = foo4 (); break;\n+    case 5: ret = foo5 (); break;\n+    case 6: ret = foo6 (); break;\n+    case 7: ret = foo7 (); break;\n+    case 8: ret = foo8 (); break;\n+    case 9: ret = foo9 (); break;\n+    case 10: ret = foo10 (); break;\n+    case 11: ret = foo11 (); break;\n+    case 12: ret = foo12 (); break;\n+    case 13: ret = foo13 (); break;\n+    case 14: ret = foo14 (); break;\n+    case 15: ret = foo15 (); break;\n+    case 16: ret = foo16 (); break;\n+    case 17: ret = foo17 (); break;\n+    case 18: ret = foo18 (); break;\n+    case 19: ret = foo19 (); break;\n+    case 20: ret = foo20 (); break;\n+    default:\n+      __builtin_abort ();\n+    }\n+\n+  return ret;\n+}\n+\n+int\n+main ()\n+{\n+  if (bar (3) != 3)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* 1 x bar\n+/* { dg-final { scan-assembler-times \"ex\\t\" 1 } } */\n+\n+/* { dg-final { scan-assembler     \"section\\t.s390_indirect_jump\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_indirect_call\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_fromreg\" } } */\n+/* { dg-final { scan-assembler-not \"section\\t.s390_return_frommem\" } } */"}]}