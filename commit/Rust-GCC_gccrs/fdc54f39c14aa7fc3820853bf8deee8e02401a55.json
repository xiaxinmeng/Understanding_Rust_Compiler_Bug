{"sha": "fdc54f39c14aa7fc3820853bf8deee8e02401a55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjNTRmMzljMTRhYTdmYzM4MjA4NTNiZjhkZWVlOGUwMjQwMWE1NQ==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-03-29T21:37:45Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2017-03-29T21:37:45Z"}, "message": "re PR fortran/78670 ([F03] Incorrect file position with namelist read under DTIO)\n\n2017-03-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/78670\n\t* io/list_read.c (nml_get_obj_data): Delete code which calls the\n\tchild read procedure. (nml_read_obj): Insert the code which\n\tcalls the child procedure. Don't need to touch nodes if using\n\tdtio since parent will not be traversing the components.\n\n\tPR libgfortran/78670\n\t* gfortran.dg/dtio_25.f90: Use 'a1' format when trying to read\n\ta character of length 1. Update test for success.\n\t* gfortran.dg/dtio_28.f03: New test.\n\t* gfortran.dg/dtio_4.f90: Update to open test file with status =\n\t'scratch' to delete the file when done.\n\nFrom-SVN: r246576", "tree": {"sha": "44ff4cdae71ae2f346b8b68f7ba425b6743cf859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44ff4cdae71ae2f346b8b68f7ba425b6743cf859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdc54f39c14aa7fc3820853bf8deee8e02401a55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc54f39c14aa7fc3820853bf8deee8e02401a55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdc54f39c14aa7fc3820853bf8deee8e02401a55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdc54f39c14aa7fc3820853bf8deee8e02401a55/comments", "author": null, "committer": null, "parents": [{"sha": "533c0b69430beae5274a7f456e299afb16afc2f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/533c0b69430beae5274a7f456e299afb16afc2f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/533c0b69430beae5274a7f456e299afb16afc2f0"}], "stats": {"total": 209, "additions": 152, "deletions": 57}, "files": [{"sha": "acbfee9929b85aa4058815460d9658257d77898b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -1,3 +1,12 @@\n+2017-03-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/78670\n+\t* gfortran.dg/dtio_25.f90: Use 'a1' format when trying to read\n+\ta character of length 1. Update test for success.\n+\t* gfortran.dg/dtio_28.f03: New test.\n+\t* gfortran.dg/dtio_4.f90: Update to open test file with status =\n+\t'scratch' to delete the file when done.\n+\n 2017-03-29  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/80233"}, {"sha": "a90a238ed51239be49ba63867725cdfdb1a61f82", "filename": "gcc/testsuite/gfortran.dg/dtio_25.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_25.f90?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -20,7 +20,7 @@ subroutine write_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n     integer, intent(out) :: iostat\n     character(*), intent(inout) :: iomsg\n     if (iotype.eq.\"NAMELIST\") then\n-      write (unit, '(a3,a1,i3)') dtv%c,',', dtv%k\n+      write (unit, '(a1,a1,i3)') dtv%c,',', dtv%k\n     else\n       write (unit,*) dtv%c, dtv%k\n     end if\n@@ -34,7 +34,7 @@ subroutine read_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n     character(*), intent(inout) :: iomsg\n     character :: comma\n     if (iotype.eq.\"NAMELIST\") then\n-      read (unit, '(a4,a1,i3)') dtv%c, comma, dtv%k    ! FIXME: need a4 here, with a3 above\n+      read (unit, '(a1,a1,i3)') dtv%c, comma, dtv%k\n     else\n       read (unit,*) dtv%c, comma, dtv%k\n     end if\n@@ -50,7 +50,7 @@ program p\n   namelist /nml/ x\n   x = t('a', 5)\n   write (buffer, nml)\n-  if (buffer.ne.'&NML  X=  a,  5  /') call abort\n+  if (buffer.ne.'&NML  X=a,  5  /') call abort\n   x = t('x', 0)\n   read (buffer, nml)\n   if (x%c.ne.'a'.or. x%k.ne.5) call abort"}, {"sha": "c70dc344e643e1c0f97ceafee92d7ceef5e01d06", "filename": "gcc/testsuite/gfortran.dg/dtio_28.f03", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_28.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_28.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_28.f03?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -0,0 +1,74 @@\n+! { dg-do run }\n+! PR78670 Incorrect file position with namelist read under DTIO\n+MODULE m\n+  IMPLICIT NONE\n+  TYPE :: t\n+    CHARACTER :: c\n+  CONTAINS\n+    PROCEDURE :: read_formatted\n+    GENERIC :: READ(FORMATTED) => read_formatted\n+    PROCEDURE :: write_formatted\n+    GENERIC :: WRITE(FORMATTED) => write_formatted\n+  END TYPE t\n+CONTAINS\n+  SUBROUTINE write_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n+    CLASS(t), INTENT(IN) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER(*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: v_list(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER(*), INTENT(INOUT) :: iomsg\n+    write(unit,'(a)', iostat=iostat, iomsg=iomsg) dtv%c\n+  END SUBROUTINE write_formatted\n+  \n+  SUBROUTINE read_formatted(dtv, unit, iotype, v_list, iostat, iomsg)\n+    CLASS(t), INTENT(INOUT) :: dtv\n+    INTEGER, INTENT(IN) :: unit\n+    CHARACTER(*), INTENT(IN) :: iotype\n+    INTEGER, INTENT(IN) :: v_list(:)\n+    INTEGER, INTENT(OUT) :: iostat\n+    CHARACTER(*), INTENT(INOUT) :: iomsg\n+    \n+    CHARACTER :: ch\n+    dtv%c = ''\n+    DO\n+      READ (unit, \"(A)\", IOSTAT=iostat, IOMSG=iomsg) ch\n+      IF (iostat /= 0) RETURN\n+      ! Store first non-blank\n+      IF (ch /= ' ') THEN\n+        dtv%c = ch\n+        RETURN\n+      END IF\n+    END DO\n+  END SUBROUTINE read_formatted\n+END MODULE m\n+\n+PROGRAM p\n+  USE m\n+  IMPLICIT NONE\n+  TYPE(t) :: x\n+  TYPE(t) :: y\n+  TYPE(t) :: z\n+  integer :: j, k\n+  NAMELIST /nml/ j, x, y, z, k\n+  INTEGER :: unit, iostatus\n+  \n+  OPEN(NEWUNIT=unit, STATUS='SCRATCH', ACTION='READWRITE')\n+  \n+  x%c = 'a'\n+  y%c = 'b'\n+  z%c = 'c'\n+  j=1\n+  k=2\n+  WRITE(unit, nml)\n+  REWIND (unit)\n+  x%c = 'x'\n+  y%c = 'y'\n+  z%c = 'x'\n+  j=99\n+  k=99\n+  READ (unit, nml, iostat=iostatus)\n+  if (iostatus.ne.0) call abort\n+  if (j.ne.1 .or. k.ne.2 .or. x%c.ne.'a' .or. y%c.ne.'b' .or. z%c.ne.'c') call abort\n+  !WRITE(*, nml)\n+END PROGRAM p"}, {"sha": "44352c1b754fca31cd9cac8e4241060c43c5f995", "filename": "gcc/testsuite/gfortran.dg/dtio_4.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdtio_4.f90?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -96,7 +96,7 @@ program test1\n   if (iomsg.ne.'SUCCESS') call abort\r\n   if (any(udt1%myarray.ne.result_array)) call abort\r\n   close(10)\r\n-  open (10, form='formatted')\r\n+  open (10, form='formatted', status='scratch')\r\n   write (10, '(dt)') more1\r\n   rewind(10)\r\n   more1%myarray = 99\r"}, {"sha": "897c2573ec1a6bab8bcdc958ccd1025a07c9feb9", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -1,3 +1,11 @@\n+2017-03-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/78670\n+\t* io/list_read.c (nml_get_obj_data): Delete code which calls the\n+\tchild read procedure. (nml_read_obj): Insert the code which\n+\tcalls the child procedure. Don't need to touch nodes if using\n+\tdtio since parent will not be traversing the components.\n+\n 2017-03-28  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/78661"}, {"sha": "76eafa80626948703e0cc91c0bf6c4d15b21532b", "filename": "libgfortran/io/list_read.c", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdc54f39c14aa7fc3820853bf8deee8e02401a55/libgfortran%2Fio%2Flist_read.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdc54f39c14aa7fc3820853bf8deee8e02401a55/libgfortran%2Fio%2Flist_read.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Flist_read.c?ref=fdc54f39c14aa7fc3820853bf8deee8e02401a55", "patch": "@@ -2958,6 +2958,61 @@ nml_read_obj (st_parameter_dt *dtp, namelist_info * nl, index_type offset,\n \t    break;\n \n \t  case BT_DERIVED:\n+\t    /* If this object has a User Defined procedure, call it.  */\n+\t    if (nl->dtio_sub != NULL)\n+\t      {\n+\t\tint unit = dtp->u.p.current_unit->unit_number;\n+\t\tchar iotype[] = \"NAMELIST\";\n+\t\tgfc_charlen_type iotype_len = 8;\n+\t\tchar tmp_iomsg[IOMSG_LEN] = \"\";\n+\t\tchar *child_iomsg;\n+\t\tgfc_charlen_type child_iomsg_len;\n+\t\tint noiostat;\n+\t\tint *child_iostat = NULL;\n+\t\tgfc_array_i4 vlist;\n+\t\tgfc_class list_obj;\n+\t\tformatted_dtio dtio_ptr = (formatted_dtio)nl->dtio_sub;\n+\n+\t\tGFC_DESCRIPTOR_DATA(&vlist) = NULL;\n+\t\tGFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n+\n+\t\tlist_obj.data = (void *)nl->mem_pos;\n+\t\tlist_obj.vptr = nl->vtable;\n+\t\tlist_obj.len = 0;\n+\n+\t\t/* Set iostat, intent(out).  */\n+\t\tnoiostat = 0;\n+\t\tchild_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n+\t\t\t\tdtp->common.iostat : &noiostat;\n+\n+\t\t/* Set iomsg, intent(inout).  */\n+\t\tif (dtp->common.flags & IOPARM_HAS_IOMSG)\n+\t\t  {\n+\t\t    child_iomsg = dtp->common.iomsg;\n+\t\t    child_iomsg_len = dtp->common.iomsg_len;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    child_iomsg = tmp_iomsg;\n+\t\t    child_iomsg_len = IOMSG_LEN;\n+\t\t  }\n+\n+\t\t/* If reading from an internal unit, stash it to allow\n+\t\t   the child procedure to access it.  */\n+\t\tif (is_internal_unit (dtp))\n+\t\t  stash_internal_unit (dtp);\n+\n+\t\t/* Call the user defined formatted READ procedure.  */\n+\t\tdtp->u.p.current_unit->child_dtio++;\n+\t\tdtio_ptr ((void *)&list_obj, &unit, iotype, &vlist,\n+\t\t\t  child_iostat, child_iomsg,\n+\t\t\t  iotype_len, child_iomsg_len);\n+\t\tdtp->u.p.child_saved_iostat = *child_iostat;\n+\t\tdtp->u.p.current_unit->child_dtio--;\n+\t\tgoto incr_idx;\n+\t      }\n+\n+\t    /* Must be default derived type namelist read.  */\n \t    obj_name_len = strlen (nl->var_name) + 1;\n \t    obj_name = xmalloc (obj_name_len+1);\n \t    memcpy (obj_name, nl->var_name, obj_name_len-1);\n@@ -3268,58 +3323,6 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \n       goto nml_err_ret;\n     }\n-  else if (nl->dtio_sub != NULL)\n-    {\n-      int unit = dtp->u.p.current_unit->unit_number;\n-      char iotype[] = \"NAMELIST\";\n-      gfc_charlen_type iotype_len = 8;\n-      char tmp_iomsg[IOMSG_LEN] = \"\";\n-      char *child_iomsg;\n-      gfc_charlen_type child_iomsg_len;\n-      int noiostat;\n-      int *child_iostat = NULL;\n-      gfc_array_i4 vlist;\n-      gfc_class list_obj;\n-      formatted_dtio dtio_ptr = (formatted_dtio)nl->dtio_sub;\n-\n-      GFC_DESCRIPTOR_DATA(&vlist) = NULL;\n-      GFC_DIMENSION_SET(vlist.dim[0],1, 0, 0);\n-\n-      list_obj.data = (void *)nl->mem_pos;\n-      list_obj.vptr = nl->vtable;\n-      list_obj.len = 0;\n-\n-      /* Set iostat, intent(out).  */\n-      noiostat = 0;\n-      child_iostat = (dtp->common.flags & IOPARM_HAS_IOSTAT) ?\n-\t\t      dtp->common.iostat : &noiostat;\n-\n-      /* Set iomsg, intent(inout).  */\n-      if (dtp->common.flags & IOPARM_HAS_IOMSG)\n-\t{\n-\t  child_iomsg = dtp->common.iomsg;\n-\t  child_iomsg_len = dtp->common.iomsg_len;\n-\t}\n-      else\n-\t{\n-\t  child_iomsg = tmp_iomsg;\n-\t  child_iomsg_len = IOMSG_LEN;\n-\t}\n-\n-      /* If reading from an internal unit, stash it to allow\n-\t the child procedure to access it.  */\n-      if (is_internal_unit (dtp))\n-\tstash_internal_unit (dtp);\n-\n-      /* Call the user defined formatted READ procedure.  */\n-      dtp->u.p.current_unit->child_dtio++;\n-      dtio_ptr ((void *)&list_obj, &unit, iotype, &vlist,\n-\t\tchild_iostat, child_iomsg,\n-\t\tiotype_len, child_iomsg_len);\n-      dtp->u.p.current_unit->child_dtio--;\n-\n-      return true;\n-    }\n \n   /* Get the length, data length, base pointer and rank of the variable.\n      Set the default loop specification first.  */\n@@ -3466,11 +3469,12 @@ nml_get_obj_data (st_parameter_dt *dtp, namelist_info **pprev_nl,\n \t\tnl->var_name);\n       goto nml_err_ret;\n     }\n+\n   /* If a derived type, touch its components and restore the root\n      namelist_info if we have parsed a qualified derived type\n      component.  */\n \n-  if (nl->type == BT_DERIVED)\n+  if (nl->type == BT_DERIVED && nl->dtio_sub == NULL)\n     nml_touch_nodes (nl);\n \n   if (first_nl)"}]}