{"sha": "13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNlOGYwZWQ4ZTJjYjI1YmFhM2ZiNDI0YjRlNzIxYzQ2MTY1ZmY5Mw==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2019-07-05T07:02:17Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-05T07:02:17Z"}, "message": "[Ada] Import documentation from the RM for Ada.Strings.Fixed\n\n2019-07-05  Pierre-Marie de Rodat  <derodat@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/a-strfix.ads: Import documentation from the RM\n\nFrom-SVN: r273109", "tree": {"sha": "49c4f1f896de2e98b906623d47c8c4e2cdb1623a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49c4f1f896de2e98b906623d47c8c4e2cdb1623a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93/comments", "author": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9cbb5574cd580de25e8aaf402e0f3d3c704a7157", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cbb5574cd580de25e8aaf402e0f3d3c704a7157", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cbb5574cd580de25e8aaf402e0f3d3c704a7157"}], "stats": {"total": 227, "additions": 202, "deletions": 25}, "files": [{"sha": "4c75bc9227060eaea4cadd8edf33265ef0dc3a91", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "patch": "@@ -1,3 +1,7 @@\n+2019-07-05  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* libgnat/a-strfix.ads: Import documentation from the RM\n+\n 2019-07-05  Yannick Moy  <moy@adacore.com>\n \n \t* adabkend.adb (Scan_Back_End_Switches): Accept -Og and -Ofast"}, {"sha": "157186104d2b9730dfd2aea22d946e881f0c553d", "filename": "gcc/ada/libgnat/a-strfix.ads", "status": "modified", "additions": 198, "deletions": 25, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e8f0ed8e2cb25baa3fb424b4e721c46165ff93/gcc%2Fada%2Flibgnat%2Fa-strfix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-strfix.ads?ref=13e8f0ed8e2cb25baa3fb424b4e721c46165ff93", "patch": "@@ -15,6 +15,25 @@\n \n with Ada.Strings.Maps;\n \n+--  The language-defined package Strings.Fixed provides string-handling\n+--  subprograms for fixed-length strings; that is, for values of type\n+--  Standard.String. Several of these subprograms are procedures that modify\n+--  the contents of a String that is passed as an out or an in out parameter;\n+--  each has additional parameters to control the effect when the logical\n+--  length of the result differs from the parameter's length.\n+--\n+--  For each function that returns a String, the lower bound of the returned\n+--  value is 1.\n+--\n+--  The basic model embodied in the package is that a fixed-length string\n+--  comprises significant characters and possibly padding (with space\n+--  characters) on either or both ends. When a shorter string is copied to a\n+--  longer string, padding is inserted, and when a longer string is copied to a\n+--  shorter one, padding is stripped. The Move procedure in Strings.Fixed,\n+--  which takes a String as an out parameter, allows the programmer to control\n+--  these effects. Similar control is provided by the string transformation\n+--  procedures.\n+\n package Ada.Strings.Fixed is\n    pragma Preelaborate;\n \n@@ -28,6 +47,44 @@ package Ada.Strings.Fixed is\n       Drop    : Truncation := Error;\n       Justify : Alignment  := Left;\n       Pad     : Character  := Space);\n+   --  The Move procedure copies characters from Source to Target. If Source\n+   --  has the same length as Target, then the effect is to assign Source to\n+   --  Target. If Source is shorter than Target then:\n+   --\n+   --  * If Justify=Left, then Source is copied into the first Source'Length\n+   --    characters of Target.\n+   --\n+   --  * If Justify=Right, then Source is copied into the last Source'Length\n+   --    characters of Target.\n+   --\n+   --  * If Justify=Center, then Source is copied into the middle Source'Length\n+   --    characters of Target. In this case, if the difference in length\n+   --    between Target and Source is odd, then the extra Pad character is on\n+   --    the right.\n+   --\n+   --  * Pad is copied to each Target character not otherwise assigned.\n+   --\n+   --  If Source is longer than Target, then the effect is based on Drop.\n+   --\n+   --  * If Drop=Left, then the rightmost Target'Length characters of Source\n+   --    are copied into Target.\n+   --\n+   --  * If Drop=Right, then the leftmost Target'Length characters of Source\n+   --    are copied into Target.\n+   --\n+   --  * If Drop=Error, then the effect depends on the value of the Justify\n+   --    parameter and also on whether any characters in Source other than Pad\n+   --    would fail to be copied:\n+   --\n+   --    * If Justify=Left, and if each of the rightmost\n+   --      Source'Length-Target'Length characters in Source is Pad, then the\n+   --      leftmost Target'Length characters of Source are copied to Target.\n+   --\n+   --    * If Justify=Right, and if each of the leftmost\n+   --      Source'Length-Target'Length characters in Source is Pad, then the\n+   --      rightmost Target'Length characters of Source are copied to Target.\n+   --\n+   --    * Otherwise, Length_Error is propagated.\n \n    ------------------------\n    -- Search Subprograms --\n@@ -36,36 +93,57 @@ package Ada.Strings.Fixed is\n    function Index\n      (Source  : String;\n       Pattern : String;\n+      From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+      Mapping : Maps.Character_Mapping_Function) return Natural;\n+   pragma Ada_05 (Index);\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n+      From    : Positive;\n       Going   : Direction := Forward;\n-      Mapping : Maps.Character_Mapping_Function) return Natural;\n+      Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n+   pragma Ada_05 (Index);\n \n-   function Index\n-     (Source : String;\n-      Set    : Maps.Character_Set;\n-      Test   : Membership := Inside;\n-      Going  : Direction  := Forward) return Natural;\n+   --  Each Index function searches, starting from From, for a slice of\n+   --  Source, with length Pattern'Length, that matches Pattern with respect to\n+   --  Mapping; the parameter Going indicates the direction of the lookup. If\n+   --  Source is the null string, Index returns 0; otherwise, if From is not in\n+   --  Source'Range, then Index_Error is propagated. If Going = Forward, then\n+   --  Index returns the smallest index I which is greater than or equal to\n+   --  From such that the slice of Source starting at I matches Pattern. If\n+   --  Going = Backward, then Index returns the largest index I such that the\n+   --  slice of Source starting at I matches Pattern and has an upper bound\n+   --  less than or equal to From. If there is no such slice, then 0 is\n+   --  returned. If Pattern is the null string, then Pattern_Error is\n+   --  propagated.\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n-      From    : Positive;\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping := Maps.Identity) return Natural;\n-   pragma Ada_05 (Index);\n \n    function Index\n      (Source  : String;\n       Pattern : String;\n-      From    : Positive;\n       Going   : Direction := Forward;\n       Mapping : Maps.Character_Mapping_Function) return Natural;\n-   pragma Ada_05 (Index);\n+\n+   --  If Going = Forward, returns:\n+   --\n+   --     Index (Source, Pattern, Source'First, Forward, Mapping)\n+   --\n+   --  otherwise, returns:\n+   --\n+   --     Index (Source, Pattern, Source'Last, Backward, Mapping).\n+\n+   function Index\n+     (Source : String;\n+      Set    : Maps.Character_Set;\n+      Test   : Membership := Inside;\n+      Going  : Direction  := Forward) return Natural;\n \n    function Index\n      (Source  : String;\n@@ -74,16 +152,26 @@ package Ada.Strings.Fixed is\n       Test    : Membership := Inside;\n       Going   : Direction := Forward) return Natural;\n    pragma Ada_05 (Index);\n+   --  Index searches for the first or last occurrence of any of a set of\n+   --  characters (when Test=Inside), or any of the complement of a set of\n+   --  characters (when Test=Outside). If Source is the null string, Index\n+   --  returns 0; otherwise, if From is not in Source'Range, then Index_Error\n+   --  is propagated. Otherwise, it returns the smallest index I >= From (if\n+   --  Going=Forward) or the largest index I <= From (if Going=Backward) such\n+   --  that Source(I) satisfies the Test condition with respect to Set; it\n+   --  returns 0 if there is no such Character in Source.\n \n    function Index_Non_Blank\n      (Source : String;\n+      From   : Positive;\n       Going  : Direction := Forward) return Natural;\n+   pragma Ada_05 (Index_Non_Blank);\n+   --  Returns Index (Source, Maps.To_Set(Space), From, Outside, Going)\n \n    function Index_Non_Blank\n      (Source : String;\n-      From   : Positive;\n       Going  : Direction := Forward) return Natural;\n-   pragma Ada_05 (Index_Non_Blank);\n+   --  Returns Index (Source, Maps.To_Set(Space), Outside, Going)\n \n    function Count\n      (Source  : String;\n@@ -95,9 +183,15 @@ package Ada.Strings.Fixed is\n       Pattern : String;\n       Mapping : Maps.Character_Mapping_Function) return Natural;\n \n+   --  Returns the maximum number of nonoverlapping slices of Source that match\n+   --  Pattern with respect to Mapping. If Pattern is the null string then\n+   --  Pattern_Error is propagated.\n+\n    function Count\n      (Source : String;\n       Set    : Maps.Character_Set) return Natural;\n+   --  Returns the number of occurrences in Source of characters that are in\n+   --  Set.\n \n    procedure Find_Token\n      (Source : String;\n@@ -107,44 +201,52 @@ package Ada.Strings.Fixed is\n       First  : out Positive;\n       Last   : out Natural);\n    pragma Ada_2012 (Find_Token);\n+   --  If Source is not the null string and From is not in Source'Range, then\n+   --  Index_Error is raised. Otherwise, First is set to the index of the first\n+   --  character in Source(From .. Source'Last) that satisfies the Test\n+   --  condition. Last is set to the largest index such that all characters in\n+   --  Source(First .. Last) satisfy the Test condition. If no characters in\n+   --  Source(From .. Source'Last) satisfy the Test condition, First is set to\n+   --  From, and Last is set to 0.\n \n    procedure Find_Token\n      (Source : String;\n       Set    : Maps.Character_Set;\n       Test   : Membership;\n       First  : out Positive;\n       Last   : out Natural);\n+   --  Equivalent to Find_Token (Source, Set, Source'First, Test, First, Last)\n \n    ------------------------------------\n    -- String Translation Subprograms --\n    ------------------------------------\n \n    function Translate\n      (Source  : String;\n-      Mapping : Maps.Character_Mapping) return String;\n-\n-   procedure Translate\n-     (Source  : in out String;\n-      Mapping : Maps.Character_Mapping);\n+      Mapping : Maps.Character_Mapping_Function) return String;\n \n    function Translate\n      (Source  : String;\n-      Mapping : Maps.Character_Mapping_Function) return String;\n+      Mapping : Maps.Character_Mapping) return String;\n+\n+   --  Returns the string S whose length is Source'Length and such that S (I)\n+   --  is the character to which Mapping maps the corresponding element of\n+   --  Source, for I in 1 .. Source'Length.\n \n    procedure Translate\n      (Source  : in out String;\n       Mapping : Maps.Character_Mapping_Function);\n \n+   procedure Translate\n+     (Source  : in out String;\n+      Mapping : Maps.Character_Mapping);\n+\n+   --  Equivalent to Source := Translate(Source, Mapping)\n+\n    ---------------------------------------\n    -- String Transformation Subprograms --\n    ---------------------------------------\n \n-   function Replace_Slice\n-     (Source : String;\n-      Low    : Positive;\n-      High   : Natural;\n-      By     : String) return String;\n-\n    procedure Replace_Slice\n      (Source  : in out String;\n       Low     : Positive;\n@@ -153,40 +255,78 @@ package Ada.Strings.Fixed is\n       Drop    : Truncation := Error;\n       Justify : Alignment  := Left;\n       Pad     : Character  := Space);\n+   --  If Low > Source'Last+1, or High < Source'First - 1, then Index_Error is\n+   --  propagated. Otherwise:\n+   --\n+   --  * If High >= Low, then the returned string comprises\n+   --    Source (Source'First .. Low - 1)\n+   --    & By & Source(High + 1 .. Source'Last), but with lower bound 1.\n+   --\n+   --  * If High < Low, then the returned string is\n+   --    Insert (Source, Before => Low, New_Item => By).\n+\n+   function Replace_Slice\n+     (Source : String;\n+      Low    : Positive;\n+      High   : Natural;\n+      By     : String) return String;\n+   --  Equivalent to:\n+   --\n+   --    Move (Replace_Slice (Source, Low, High, By),\n+   --          Source, Drop, Justify, Pad).\n \n    function Insert\n      (Source   : String;\n       Before   : Positive;\n       New_Item : String) return String;\n+   --  Propagates Index_Error if Before is not in\n+   --  Source'First .. Source'Last+1; otherwise, returns\n+   --  Source (Source'First .. Before - 1)\n+   --  & New_Item & Source(Before..Source'Last), but with lower bound 1.\n \n    procedure Insert\n      (Source   : in out String;\n       Before   : Positive;\n       New_Item : String;\n       Drop     : Truncation := Error);\n+   --  Equivalent to Move (Insert (Source, Before, New_Item), Source, Drop)\n \n    function Overwrite\n      (Source   : String;\n       Position : Positive;\n       New_Item : String) return String;\n+   --  Propagates Index_Error if Position is not in\n+   --  Source'First .. Source'Last + 1; otherwise, returns the string obtained\n+   --  from Source by consecutively replacing characters starting at Position\n+   --  with corresponding characters from New_Item. If the end of Source is\n+   --  reached before the characters in New_Item are exhausted, the remaining\n+   --  characters from New_Item are appended to the string.\n \n    procedure Overwrite\n      (Source   : in out String;\n       Position : Positive;\n       New_Item : String;\n       Drop     : Truncation := Right);\n+   --  Equivalent to Move(Overwrite(Source, Position, New_Item), Source, Drop)\n \n    function Delete\n      (Source  : String;\n       From    : Positive;\n       Through : Natural) return String;\n+   --  If From <= Through, the returned string is\n+   --  Replace_Slice(Source, From, Through, \"\"); otherwise, it is Source with\n+   --  lower bound 1.\n \n    procedure Delete\n      (Source  : in out String;\n       From    : Positive;\n       Through : Natural;\n       Justify : Alignment := Left;\n       Pad     : Character := Space);\n+   --  Equivalent to:\n+   --\n+   --     Move (Delete (Source, From, Through),\n+   --           Source, Justify => Justify, Pad => Pad).\n \n    ---------------------------------\n    -- String Selector Subprograms --\n@@ -195,46 +335,73 @@ package Ada.Strings.Fixed is\n    function Trim\n      (Source : String;\n       Side   : Trim_End) return String;\n+   --  Returns the string obtained by removing from Source all leading Space\n+   --  characters (if Side = Left), all trailing Space characters (if\n+   --  Side = Right), or all leading and trailing Space characters (if\n+   --  Side = Both).\n \n    procedure Trim\n      (Source  : in out String;\n       Side    : Trim_End;\n       Justify : Alignment := Left;\n       Pad     : Character := Space);\n+   --  Equivalent to:\n+   --\n+   --     Move (Trim (Source, Side), Source, Justify=>Justify, Pad=>Pad).\n \n    function Trim\n      (Source : String;\n       Left   : Maps.Character_Set;\n       Right  : Maps.Character_Set) return String;\n+   --  Returns the string obtained by removing from Source all leading\n+   --  characters in Left and all trailing characters in Right.\n \n    procedure Trim\n      (Source  : in out String;\n       Left    : Maps.Character_Set;\n       Right   : Maps.Character_Set;\n       Justify : Alignment := Strings.Left;\n       Pad     : Character := Space);\n+   --  Equivalent to:\n+   --\n+   --     Move (Trim (Source, Left, Right),\n+   --           Source, Justify => Justify, Pad=>Pad).\n \n    function Head\n      (Source : String;\n       Count  : Natural;\n       Pad    : Character := Space) return String;\n+   --  Returns a string of length Count. If Count <= Source'Length, the string\n+   --  comprises the first Count characters of Source. Otherwise, its contents\n+   --  are Source concatenated with Count - Source'Length Pad characters.\n \n    procedure Head\n      (Source  : in out String;\n       Count   : Natural;\n       Justify : Alignment := Left;\n       Pad     : Character := Space);\n+   --  Equivalent to:\n+   --\n+   --     Move (Head (Source, Count, Pad),\n+   --           Source, Drop => Error, Justify => Justify, Pad => Pad).\n \n    function Tail\n      (Source : String;\n       Count  : Natural;\n       Pad    : Character := Space) return String;\n+   --  Returns a string of length Count. If Count <= Source'Length, the string\n+   --  comprises the last Count characters of Source. Otherwise, its contents\n+   --  are Count-Source'Length Pad characters concatenated with Source.\n \n    procedure Tail\n      (Source  : in out String;\n       Count   : Natural;\n       Justify : Alignment := Left;\n       Pad     : Character := Space);\n+   --  Equivalent to:\n+   --\n+   --     Move (Tail (Source, Count, Pad),\n+   --           Source, Drop => Error, Justify => Justify, Pad => Pad).\n \n    ----------------------------------\n    -- String Constructor Functions --\n@@ -248,4 +415,10 @@ package Ada.Strings.Fixed is\n      (Left  : Natural;\n       Right : String) return String;\n \n+   --  These functions replicate a character or string a specified number of\n+   --  times. The first function returns a string whose length is Left and each\n+   --  of whose elements is Right. The second function returns a string whose\n+   --  length is Left * Right'Length and whose value is the null string if\n+   --  Left = 0 and otherwise is (Left - 1)*Right & Right with lower bound 1.\n+\n end Ada.Strings.Fixed;"}]}