{"sha": "f710504c07e3c301cc21d88a60d3844ea99920e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcxMDUwNGMwN2UzYzMwMWNjMjFkODhhNjBkMzg0NGVhOTk5MjBlNQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-10-28T13:22:02Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-10-28T13:22:02Z"}, "message": "alpha.md, [...]: Fix spelling errors.\n\n\t* config/alpha/alpha.md, config/arm/arm.c, config/arm/arm.h,\n\tconfig/d30v/d30v.h, config/fr30/fr30.c, config/i370/x-oe,\n\tconfig/i386/i386.c, config/i386/i386-interix.h,\n\tconfig/i386/i386.md, config/i386/i386.h, config/i386/sco5.h,\n\tconfig/i860/i860.h, config/i860/i860.md, config/m68k/aux-exit.c,\n\tconfig/m68k/m68k.c, config/mcore/mcore.c, config/mips/mips.md,\n\tconfig/ns32k/ns32k.h, config/pa/pa.c, config/rs6000/rs6000.c,\n\tconfig/sparc/sparc.c, config/m68hc11/m68hc11.c,\n\tconfig/cris/cris.c, config/cris/cris.h, config/s390/s390.c,\n\tconfig/s390/s390.h, config/stormy16/stormy16.h, doc/tm.texi: Fix\n\tspelling errors.\n\nFrom-SVN: r46582", "tree": {"sha": "cc65c690ad5208245e1e36bc70113b3ec893f1da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc65c690ad5208245e1e36bc70113b3ec893f1da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f710504c07e3c301cc21d88a60d3844ea99920e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f710504c07e3c301cc21d88a60d3844ea99920e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f710504c07e3c301cc21d88a60d3844ea99920e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f710504c07e3c301cc21d88a60d3844ea99920e5/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638e383e25e3e1bb4e1e82be7583b13615b478b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638e383e25e3e1bb4e1e82be7583b13615b478b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638e383e25e3e1bb4e1e82be7583b13615b478b2"}], "stats": {"total": 80, "additions": 46, "deletions": 34}, "files": [{"sha": "e524acec3aac6e17129d4c551aae1a85e3ef5cdc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1,5 +1,17 @@\n 2001-10-28  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n+\t* config/alpha/alpha.md, config/arm/arm.c, config/arm/arm.h,\n+\tconfig/d30v/d30v.h, config/fr30/fr30.c, config/i370/x-oe,\n+\tconfig/i386/i386.c, config/i386/i386-interix.h,\n+\tconfig/i386/i386.md, config/i386/i386.h, config/i386/sco5.h,\n+\tconfig/i860/i860.h, config/i860/i860.md, config/m68k/aux-exit.c,\n+\tconfig/m68k/m68k.c, config/mcore/mcore.c, config/mips/mips.md,\n+\tconfig/ns32k/ns32k.h, config/pa/pa.c, config/rs6000/rs6000.c,\n+\tconfig/sparc/sparc.c, config/m68hc11/m68hc11.c,\n+\tconfig/cris/cris.c, config/cris/cris.h, config/s390/s390.c,\n+\tconfig/s390/s390.h, config/stormy16/stormy16.h, doc/tm.texi: Fix\n+\tspelling errors.\n+\n \t* ChangeLog.0, ChangeLog.1, ChangeLog.2, ChangeLog.3, ChangeLog.4,\n \tChangeLog.5, ChangeLog, ChangeLog.lib, FSFChangeLog.10, ONEWS,\n \tc-common.c, caller-save.c, cfg.c, cfgcleanup.c, cfgrtl.c,"}, {"sha": "25eb09e7ba076412a693d8426d4e97d1eaefdaa2", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -297,7 +297,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; EV6 has two symmetric pairs (\"clusters\") of two asymetric integer units\n ;; (\"upper\" and \"lower\"), yielding pipe names U0, U1, L0, L1.\n \n-;; Conditional moves decompose into two independant primitives, each\n+;; Conditional moves decompose into two independent primitives, each\n ;; taking one cycle.  Since ev6 is out-of-order, we can't see anything\n ;; but two cycles.\n (define_function_unit \"ev6_ebox\" 4 0"}, {"sha": "b3f8af26ee74f3bccf3da81209e5d9fbc2553d70", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -3057,7 +3057,7 @@ arm_reload_memory_operand (op, mode)\n \n /* Return 1 if OP is a valid memory address, but not valid for a signed byte\n    memory access (architecture V4).\n-   MODE is QImode if called when computing contraints, or VOIDmode when\n+   MODE is QImode if called when computing constraints, or VOIDmode when\n    emitting patterns.  In this latter case we cannot use memory_operand()\n    because it will fail on badly formed MEMs, which is precisly what we are\n    trying to catch.  */"}, {"sha": "4c3bbd17bd61bc0f4c164428677487dd3ffed10f", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -731,7 +731,7 @@ extern int arm_is_6_or_7;\n /* Setting STRUCTURE_SIZE_BOUNDARY to 32 produces more efficient code, but the\n    value set in previous versions of this toolchain was 8, which produces more\n    compact structures.  The command line option -mstructure_size_boundary=<n>\n-   can be used to change this value.  For compatability with the ARM SDK\n+   can be used to change this value.  For compatibility with the ARM SDK\n    however the value should be left at 32.  ARM SDT Reference Manual (ARM DUI\n    0020D) page 2-20 says \"Structures are aligned on word boundaries\".  */\n #define STRUCTURE_SIZE_BOUNDARY arm_structure_size_boundary"}, {"sha": "3be8870abd4ab8c6fa44ade96e60200ec5c3621f", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1608,7 +1608,7 @@ cris_initial_frame_pointer_offset ()\n {\n   int regno;\n \n-  /* Initial offset is 0 if we dont have a frame pointer.  */\n+  /* Initial offset is 0 if we don't have a frame pointer.  */\n   int offs = 0;\n \n   /* And 4 for each register pushed.  */"}, {"sha": "383a46f6e87e1166d1b651bac59278fca41b8539", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -608,7 +608,7 @@ extern int target_flags;\n /* Node: Allocation Order */\n \n /* We need this on CRIS, because call-used regs should be used first,\n-   (so we dont need to push).  Else start using registers from r0 and up.\n+   (so we don't need to push).  Else start using registers from r0 and up.\n     This preference is mainly because if we put call-used-regs from r0\n    and up, then we can't use movem to push the rest, (which have to be\n    saved if we use them, and movem has to start with r0)."}, {"sha": "46e89cd0ecd647bf9fcf146850bfe056dade9fa7", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -5100,7 +5100,7 @@ fprintf (STREAM, \"\\t.word .L%d\\n\", VALUE)\n \n /* Some stabs encapsulation formats (in particular ECOFF), cannot\n    handle the `.stabs \"\",N_FUN,,0,0,Lscope-function-1' gdb dbx\n-   extention construct.  On those machines, define this macro to turn\n+   extension construct.  On those machines, define this macro to turn\n    this feature off without disturbing the rest of the gdb extensions.  */\n /* #define NO_DBX_FUNCTION_END */\n "}, {"sha": "5fca2331357bc6fd14bdef2ae09881db019edf16", "filename": "gcc/config/fr30/fr30.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Ffr30%2Ffr30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Ffr30%2Ffr30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1085,7 +1085,7 @@ fr30_move_double (operands)\n \t}\n     }\n   else\n-    /* This should have been prevented by the contraints on movdi_insn.  */\n+    /* This should have been prevented by the constraints on movdi_insn.  */\n     abort ();\n   \n   val = gen_sequence ();"}, {"sha": "045778b29cfb651d87bf90a8ade95e9bf6b5eb1d", "filename": "gcc/config/i370/x-oe", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi370%2Fx-oe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi370%2Fx-oe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fx-oe?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -2,5 +2,5 @@\n # Host is an i370 running OpenEdition\n #\n \n-# Don't bother fixing up header files, they're wierd\n+# Don't bother fixing up header files, they're weird\n STMP_FIXPROTO ="}, {"sha": "0325b68e846a7940fb5302a54c5585a51464e3f5", "filename": "gcc/config/i386/i386-interix.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386-interix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-interix.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    and returns float values in the 387 and needs stack probes\n-   We also align doubles to 64-bits for MSVC default compatability */\n+   We also align doubles to 64-bits for MSVC default compatibility */\n #undef TARGET_SUBTARGET_DEFAULT\n #define TARGET_SUBTARGET_DEFAULT \\\n    (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE | \\"}, {"sha": "79aceb6c99f47609939e3190ab40d93439465536", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1418,7 +1418,7 @@ init_cumulative_args (cum, fntype, libname)\n }\n \n /* x86-64 register passing impleemntation.  See x86-64 ABI for details.  Goal\n-   of this code is to classify each 8bytes of incomming argument by the register\n+   of this code is to classify each 8bytes of incoming argument by the register\n    class and assign registers accordingly.  */\n \n /* Return the union class of CLASS1 and CLASS2.\n@@ -3801,7 +3801,7 @@ ix86_compute_frame_layout (frame)\n \n   /* Do some sanity checking of stack_alignment_needed and\n      preferred_alignment, since i386 port is the only using those features\n-     that may break easilly.  */\n+     that may break easily.  */\n \n   if (size && !stack_alignment_needed)\n     abort ();\n@@ -4696,7 +4696,7 @@ legitimate_address_p (mode, addr, strict)\n \n \t     This code is nonsensical, but results in addressing\n \t     GOT table with pic_offset_table_rtx base.  We can't\n-\t     just refuse it easilly, since it gets matched by\n+\t     just refuse it easily, since it gets matched by\n \t     \"addsi3\" pattern, that later gets split to lea in the\n \t     case output register differs from input.  While this\n \t     can be handled by separate addsi pattern for this case\n@@ -12133,7 +12133,7 @@ ix86_expand_builtin (exp, target, subtarget, mode, ignore)\n }\n \n /* Store OPERAND to the memory after reload is completed.  This means\n-   that we can't easilly use assign_stack_local.  */\n+   that we can't easily use assign_stack_local.  */\n rtx\n ix86_force_to_memory (mode, operand)\n      enum machine_mode mode;"}, {"sha": "85e1c35601d302be544ba7a466e9aee834a3fe43", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -2394,7 +2394,7 @@ while (0)\n    stored in a register.  This macro is only called when TYPE is a\n    scalar type.\n \n-   On i386 it is sometimes usefull to promote HImode and QImode\n+   On i386 it is sometimes useful to promote HImode and QImode\n    quantities to SImode.  The choice depends on target type.  */\n \n #define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE) \t\t\\"}, {"sha": "7c122698a5debce590fffb15d7929b014f7f619f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -993,7 +993,7 @@\n        (eq_attr \"athlon_fpunits\" \"store\"))\n   1 1)\n \n-;; We don't need to model the Adress Generation Unit, since we don't model\n+;; We don't need to model the Address Generation Unit, since we don't model\n ;; the re-order buffer yet and thus we never schedule more than three operations\n ;; at time.  Later we may want to experiment with MD_SCHED macros modeling the\n ;; decoders independently on the functional units."}, {"sha": "cdc811bbc921ac49af2c1e6518664292eac2c31f", "filename": "gcc/config/i386/sco5.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fsco5.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi386%2Fsco5.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsco5.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -102,7 +102,7 @@ Boston, MA 02111-1307, USA.  */\n \n #undef INIT_SECTION_ASM_OP\n #define INIT_SECTION_ASM_OP_ELF\t\t\"\\t.section\\t.init\"\n-/* Rename these for COFF becuase crt1.o will try to run them. */\n+/* Rename these for COFF because crt1.o will try to run them. */\n #define INIT_SECTION_ASM_OP_COFF\t\"\\t.section\\t.ctor ,\\\"x\\\"\"\n #define INIT_SECTION_ASM_OP\t\\\n   ((TARGET_ELF) ? INIT_SECTION_ASM_OP_ELF : INIT_SECTION_ASM_OP_COFF)\n@@ -658,7 +658,7 @@ init_section ()\t\t\t\t\t\t\t\t\\\n \n #if USE_GAS\n   /* Leave ASM_SPEC undefined so we pick up the master copy from gcc.c \n-   * Undef MD_EXEC_PREFIX becuase we don't know where GAS is, but it's not\n+   * Undef MD_EXEC_PREFIX because we don't know where GAS is, but it's not\n    * likely in /usr/ccs/bin/ \n    */\n #undef MD_EXEC_PREFIX "}, {"sha": "a176f23efa607ba169af7df4a700acccac851f69", "filename": "gcc/config/i860/i860.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi860%2Fi860.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi860%2Fi860.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -126,7 +126,7 @@ extern int target_flags;\n    when given unaligned data.  */\n #define STRICT_ALIGNMENT 1\n \n-/* If bit field type is int, dont let it cross an int,\n+/* If bit field type is int, don't let it cross an int,\n    and give entire struct the alignment of an int.  */\n #define PCC_BITFIELD_TYPE_MATTERS 1\n \f"}, {"sha": "b866c91386a20a32c5f5eb7cc02792c9baf4e50c", "filename": "gcc/config/i860/i860.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi860%2Fi860.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fi860%2Fi860.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.md?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1617,7 +1617,7 @@\n \n ;; Recognize the first insn generated above.\n ;; This RTL looks like a fix_truncdfdi2 insn,\n-;; but we dont call it that, because only 32 bits\n+;; but we don't call it that, because only 32 bits\n ;; of the result are valid.\n ;; This pattern will work for the intended purposes \n ;; as long as we do not have any fixdfdi2 or fix_truncdfdi2.\n@@ -1642,7 +1642,7 @@\n \n ;; Recognize the first insn generated above.\n ;; This RTL looks like a fix_truncsfdi2 insn,\n-;; but we dont call it that, because only 32 bits\n+;; but we don't call it that, because only 32 bits\n ;; of the result are valid.\n ;; This pattern will work for the intended purposes \n ;; as long as we do not have any fixsfdi2 or fix_truncsfdi2."}, {"sha": "247ce86b1b20e565c5a93e1766a1799e3956312c", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -5060,7 +5060,7 @@ m68hc11_shift_cost (mode, x, shift)\n     total *= GET_MODE_SIZE (mode) / 2;\n \n   /* When optimizing for size, make shift more costly so that\n-     multiplications are prefered.  */\n+     multiplications are preferred.  */\n   if (optimize_size && (shift % 8) != 0)\n     total *= 2;\n   "}, {"sha": "1d7d6c0fd80bbe35735fd59e773268e390c5acc7", "filename": "gcc/config/m68k/aux-exit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68k%2Faux-exit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68k%2Faux-exit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Faux-exit.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -47,7 +47,7 @@ struct atexit_fn_block\n };\n \n \n-/* staticly allocate the first block */\n+/* statically allocate the first block */\n static struct atexit_fn_block atexit_fns;\n static struct atexit_fn_block *current_block = &atexit_fns;\n "}, {"sha": "0bb1e8534ebbac396931a63e523291157bd18e47", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -1664,7 +1664,7 @@ output_scc_di(op, operand1, operand2, dest)\n   rtx loperands[7];\n   enum rtx_code op_code = GET_CODE (op);\n \n-  /* This does not produce a usefull cc.  */\n+  /* This does not produce a useful cc.  */\n   CC_STATUS_INIT;\n \n   /* The m68k cmp.l instruction requires operand1 to be a reg as used"}, {"sha": "556003044c7d6ea577f2b30e3ce6445531637904", "filename": "gcc/config/mcore/mcore.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fmcore%2Fmcore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fmcore%2Fmcore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -3520,7 +3520,7 @@ mcore_unique_section (decl, reloc)\n      (everything from the $ on is stripped).  */\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     prefix = \".text$\";\n-  /* For compatability with EPOC, we ignore the fact that the\n+  /* For compatibility with EPOC, we ignore the fact that the\n      section might have relocs against it.  */\n   else if (DECL_READONLY_SECTION (decl, 0))\n     prefix = \".rdata$\";"}, {"sha": "36e83e1e6742e75436ecb393ade1d70426641b87", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -4230,10 +4230,10 @@ move\\\\t%0,%z4\\\\n\\\\\n ;; operand zero, because then the address in the move instruction will be\n ;; clobbered.  We mark the scratch register as early clobbered to prevent this.\n \n-;; We need the ?X in alternative 1 so that it will be choosen only if the\n+;; We need the ?X in alternative 1 so that it will be chosen only if the\n ;; destination is a floating point register.  Otherwise, alternative 1 can\n ;; have lower cost than alternative 0 (because there is one less loser), and\n-;; can be choosen when it won't work (because integral reloads into FP\n+;; can be chosen when it won't work (because integral reloads into FP\n ;; registers are not supported).\n \n (define_insn \"fix_truncdfsi2\""}, {"sha": "373f78f7fbc2bb02216e659eaa7dbb3e03341509", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -236,7 +236,7 @@ while (0)\n    crossing a page boundary cause unpredictable results.  */\n #define STRICT_ALIGNMENT 1\n \n-/* If bit field type is int, dont let it cross an int,\n+/* If bit field type is int, don't let it cross an int,\n    and give entire struct the alignment of an int.  */\n /* Required on the 386 since it doesn't have a full set of bitfield insns.\n    (There is no signed extv insn.)  */"}, {"sha": "1449fca5edb05c92a284741d5edeba30dee263f5", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -4855,7 +4855,7 @@ hppa_builtin_saveregs ()\n \t\t\tgen_rtx_REG (word_mode, i));\n \n       /* The incoming args pointer points just beyond the flushback area;\n-\t normally this is not a serious concern.  Howver, when we are doing\n+\t normally this is not a serious concern.  However, when we are doing\n \t varargs/stdargs we want to make the arg pointer point to the start\n \t of the incoming argument area.  */\n       emit_move_insn (virtual_incoming_args_rtx,"}, {"sha": "803d4e0d4c9b47010490b92c86dac8127254c0c9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -6926,7 +6926,7 @@ rs6000_output_function_epilogue (file, size)\n \t is 0.  C++ is 9.  No number defined for Obj-C, so use the\n \t value for C for now.  There is no official value for Java,\n          although IBM appears to be using 13.  There is no official value\n-\t for Chill, so we've choosen 44 pseudo-randomly.  */\n+\t for Chill, so we've chosen 44 pseudo-randomly.  */\n       if (! strcmp (language_string, \"GNU C\")\n \t  || ! strcmp (language_string, \"GNU Objective-C\"))\n \ti = 0;"}, {"sha": "594f06810978e80e8e043da68a68b581e370c261", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -3074,7 +3074,7 @@ s390_build_va_list ()\n    false if implementing __builtin_varargs_va_start.  NEXTARG\n    points to the first anonymous stack argument.\n \n-   The following global variables are used to initalize\n+   The following global variables are used to initialize\n    the va_list structure:\n \n      current_function_args_info:"}, {"sha": "c4fd6fb7f2bbf0616d5f72f3e5ebe311e9fb1306", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -184,7 +184,7 @@ if (INTEGRAL_MODE_P (MODE) &&\t        \t    \t\\\n \n #define EMPTY_FIELD_BOUNDARY 32\n \n-/* Alignment on even adresses for LARL instruction.  */\n+/* Alignment on even addresses for LARL instruction.  */\n \n #define CONSTANT_ALIGNMENT(EXP, ALIGN) (ALIGN) < 16 ? 16 : (ALIGN)\n "}, {"sha": "1cb61c75dc4d6601f69474b928e907be4564d246", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -7509,7 +7509,7 @@ ultra_fpmode_conflict_exists (fpmode)\n \t    continue;\n \n \t  /* If it is not FMOV, FABS, FNEG, FDIV, or FSQRT then\n-\t     we will get a stall.  Loads and stores are independant\n+\t     we will get a stall.  Loads and stores are independent\n \t     of these rules.  */\n \t  if (GET_CODE (SET_SRC (pat)) != ABS\n \t      && GET_CODE (SET_SRC (pat)) != NEG"}, {"sha": "7ca09e16efd26da5b590214e2fda14294f61aa3d", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -4795,7 +4795,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Some stabs encapsulation formats (in particular ECOFF), cannot\n    handle the `.stabs \"\",N_FUN,,0,0,Lscope-function-1' gdb dbx\n-   extention construct.  On those machines, define this macro to turn\n+   extension construct.  On those machines, define this macro to turn\n    this feature off without disturbing the rest of the gdb extensions.  */\n /* #define NO_DBX_FUNCTION_END */\n "}, {"sha": "8fc6b9c286adaac5d7ebe8949828374664140a3b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f710504c07e3c301cc21d88a60d3844ea99920e5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f710504c07e3c301cc21d88a60d3844ea99920e5", "patch": "@@ -7251,7 +7251,7 @@ This describes commands for alignment.\n @findex JUMP_ALIGN\n @item JUMP_ALIGN (@var{label})\n The alignment (log base 2) to put in front of @var{label}, which is\n-a common destination of jumps and has no fallthru incomming edge.\n+a common destination of jumps and has no fallthru incoming edge.\n \n This macro need not be defined if you don't want any special alignment\n to be done at such a time.  Most machine descriptions do not currently"}]}