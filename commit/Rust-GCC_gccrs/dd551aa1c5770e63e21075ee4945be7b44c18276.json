{"sha": "dd551aa1c5770e63e21075ee4945be7b44c18276", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ1NTFhYTFjNTc3MGU2M2UyMTA3NWVlNDk0NWJlN2I0NGMxODI3Ng==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2015-11-13T20:02:56Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2015-11-13T20:02:56Z"}, "message": "constraints.md (we constraint): New constraint for 64-bit power9 vector support.\n\n[gcc]\n2015-11-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* config/rs6000/constraints.md (we constraint): New constraint for\n\t64-bit power9 vector support.\n\t(wL constraint): New constraint for the element in a vector that\n\tcan be addressed by the MFVSRLD instruction.\n\n\t* config/rs6000/rs6000-protos.h (convert_float128_to_int): Add\n\tdeclaration.\n\t(convert_int_to_float128): Likewise.\n\t(rs6000_generate_compare): Add support for ISA 3.0 (power9)\n\thardware support for IEEE 128-bit floating point.\n\t(rs6000_expand_float128_convert): Likewise.\n\t(convert_float128_to_int): Likewise.\n\t(convert_int_to_float128): Likewise.\n\n\t* config/rs6000/rs6000.md (UNSPEC_ROUND_TO_ODD): New unspecs for\n\tISA 3.0 hardware IEEE 128-bit floating point.\n\t(UNSPEC_IEEE128_MOVE): Likewise.\n\t(UNSPEC_IEEE128_CONVERT): Likewise.\n\t(FMA_F): Add support for IEEE 128-bit floating point hardware\n\tsupport.\n\t(Ff): Add support for DImode.\n\t(Fv): Likewise.\n\t(any_fix code iterator): New and updated iterators for IEEE\n\t128-bit floating point hardware support.\n\t(any_float code iterator): Likewise.\n\t(s code attribute): Likewise.\n\t(su code attribute): Likewise.\n\t(az code attribute): Likewise.\n\t(uns code attribute): Likewise.\n\t(neg<mode>2, FLOAT128 iterator): Add support for IEEE 128-bit\n\tfloating point hardware support.\n\t(abs<mode>2, FLOAT128 iterator): Likewise.\n\t(add<mode>3, IEEE128 iterator): New insns for IEEE 128-bit\n\tfloating point hardware.\n\t(sub<mode>3, IEEE128 iterator): Likewise.\n\t(mul<mode>3, IEEE128 iterator): Likewise.\n\t(div<mode>3, IEEE128 iterator): Likewise.\n\t(copysign<mode>3, IEEE128 iterator): Likewise.\n\t(sqrt<mode>2, IEEE128 iterator): Likewise.\n\t(neg<mode>2, IEEE128 iterator): Likewise.\n\t(abs<mode>2, IEEE128 iterator): Likewise.\n\t(nabs<mode>2, IEEE128 iterator): Likewise.\n\t(fma<mode>4_hw, IEEE128 iterator): Likewise.\n\t(fms<mode>4_hw, IEEE128 iterator): Likewise.\n\t(nfma<mode>4_hw, IEEE128 iterator): Likewise.\n\t(nfms<mode>4_hw, IEEE128 iterator): Likewise.\n\t(extend<SFDF:mode><IEEE128:mode>2_hw): Likewise.\n\t(trunc<mode>df2_hw, IEEE128 iterator): Likewise.\n\t(trunc<mode>sf2_hw, IEEE128 iterator): Likewise.\n\t(fix_fixuns code attribute): Likewise.\n\t(float_floatuns code attribute): Likewise.\n\t(fix<uns>_<mode>si2_hw): Likewise.\n\t(fix<uns>_<mode>di2_hw): Likewise.\n\t(float<uns>_<mode>si2_hw): Likewise.\n\t(float<uns>_<mode>di2_hw): Likewise.\n\t(xscvqp<su>wz_<mode>): Likewise.\n\t(xscvqp<su>dz_<mode>): Likewise.\n\t(xscv<su>dqp_<mode): Likewise.\n\t(ieee128_mfvsrd): Likewise.\n\t(ieee128_mfvsrwz): Likewise.\n\t(ieee128_mtvsrw): Likewise.\n\t(ieee128_mtvsrd): Likewise.\n\t(trunc<mode>df2_odd): Likewise.\n\t(cmp<mode>_h): Likewise.\n\t(128-bit GPR splitters): Don't split a 128-bit move that is a\n\tdirect move between GPR and vector registers using ISA 3.0 direct\n\tmove instructions.\n\t(<u>mul<mode><dmode>3): Add support for the ISA 3.0 integer\n\tmultiply-add instruction.\n\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Add ISA 3.0\n\tdebugging.\n\t(rs6000_init_hard_regno_mode_ok): If ISA 3.0 and 64-bit, enable we\n\tconstraint.  Disable the VSX<->GPR direct move helpers if we have\n\tthe MFVSRLD and MTVSRDD instructions.\n\t(rs6000_secondary_reload_simple_move): Add support for doing\n\tvector direct moves directly without additional scratch registers\n\tif we have ISA 3.0 instructions.\n\t(rs6000_secondary_reload_direct_move): Update comments.\n\t(rs6000_output_move_128bit): Add support for ISA 3.0 vector\n\tinstructions.\n\n\t* config/rs6000/vsx.md (vsx_mov<mode>): Add support for ISA 3.0\n\tdirect move instructions.\n\t(vsx_movti_64bit): Likewise.\n\t(vsx_extract_<mode>): Likewise.\n\n\t* config/rs6000/rs6000.h (VECTOR_ELEMENT_MFVSRLD_64BIT): New\n\tmacros for ISA 3.0 direct move instructions.\n\t(TARGET_DIRECT_MOVE_128): Likewise.\n\t(TARGET_MADDLD): Add support for the ISA 3.0 integer multiply-add\n\tinstruction.\n\n\t* doc/md.texi (RS/6000 constraints): Document we, wF, wG, wL\n\tconstraints.  Update wa documentation to say not to use %x<n> on\n\tinstructions that only take Altivec registers.\n\n[gcc/testsuite]\n2015-11-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\t* gcc.target/powerpc/float128-hw.c: New test for IEEE 128-bit\n\thardware floating point support.\n\n\t* gcc.target/powerpc/direct-move-vector.c: New test for 128-bit\n\tvector direct move instructions.\n\n\t* gcc.target/powerpc/maddld.c: New test.\n\nFrom-SVN: r230342", "tree": {"sha": "72b1108097e34abec8e841b4af6517f90239f85a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72b1108097e34abec8e841b4af6517f90239f85a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd551aa1c5770e63e21075ee4945be7b44c18276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd551aa1c5770e63e21075ee4945be7b44c18276", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd551aa1c5770e63e21075ee4945be7b44c18276", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd551aa1c5770e63e21075ee4945be7b44c18276/comments", "author": null, "committer": null, "parents": [{"sha": "0ac17097459860a82490274c700099fadefc5642", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ac17097459860a82490274c700099fadefc5642", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ac17097459860a82490274c700099fadefc5642"}], "stats": {"total": 946, "additions": 901, "deletions": 45}, "files": [{"sha": "5cd3c7e18871a5ca531e25f58f4734ef421bc8ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -1,3 +1,102 @@\n+2015-11-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* config/rs6000/constraints.md (we constraint): New constraint for\n+\t64-bit power9 vector support.\n+\t(wL constraint): New constraint for the element in a vector that\n+\tcan be addressed by the MFVSRLD instruction.\n+\n+\t* config/rs6000/rs6000-protos.h (convert_float128_to_int): Add\n+\tdeclaration.\n+\t(convert_int_to_float128): Likewise.\n+\t(rs6000_generate_compare): Add support for ISA 3.0 (power9)\n+\thardware support for IEEE 128-bit floating point.\n+\t(rs6000_expand_float128_convert): Likewise.\n+\t(convert_float128_to_int): Likewise.\n+\t(convert_int_to_float128): Likewise.\n+\n+\t* config/rs6000/rs6000.md (UNSPEC_ROUND_TO_ODD): New unspecs for\n+\tISA 3.0 hardware IEEE 128-bit floating point.\n+\t(UNSPEC_IEEE128_MOVE): Likewise.\n+\t(UNSPEC_IEEE128_CONVERT): Likewise.\n+\t(FMA_F): Add support for IEEE 128-bit floating point hardware\n+\tsupport.\n+\t(Ff): Add support for DImode.\n+\t(Fv): Likewise.\n+\t(any_fix code iterator): New and updated iterators for IEEE\n+\t128-bit floating point hardware support.\n+\t(any_float code iterator): Likewise.\n+\t(s code attribute): Likewise.\n+\t(su code attribute): Likewise.\n+\t(az code attribute): Likewise.\n+\t(uns code attribute): Likewise.\n+\t(neg<mode>2, FLOAT128 iterator): Add support for IEEE 128-bit\n+\tfloating point hardware support.\n+\t(abs<mode>2, FLOAT128 iterator): Likewise.\n+\t(add<mode>3, IEEE128 iterator): New insns for IEEE 128-bit\n+\tfloating point hardware.\n+\t(sub<mode>3, IEEE128 iterator): Likewise.\n+\t(mul<mode>3, IEEE128 iterator): Likewise.\n+\t(div<mode>3, IEEE128 iterator): Likewise.\n+\t(copysign<mode>3, IEEE128 iterator): Likewise.\n+\t(sqrt<mode>2, IEEE128 iterator): Likewise.\n+\t(neg<mode>2, IEEE128 iterator): Likewise.\n+\t(abs<mode>2, IEEE128 iterator): Likewise.\n+\t(nabs<mode>2, IEEE128 iterator): Likewise.\n+\t(fma<mode>4_hw, IEEE128 iterator): Likewise.\n+\t(fms<mode>4_hw, IEEE128 iterator): Likewise.\n+\t(nfma<mode>4_hw, IEEE128 iterator): Likewise.\n+\t(nfms<mode>4_hw, IEEE128 iterator): Likewise.\n+\t(extend<SFDF:mode><IEEE128:mode>2_hw): Likewise.\n+\t(trunc<mode>df2_hw, IEEE128 iterator): Likewise.\n+\t(trunc<mode>sf2_hw, IEEE128 iterator): Likewise.\n+\t(fix_fixuns code attribute): Likewise.\n+\t(float_floatuns code attribute): Likewise.\n+\t(fix<uns>_<mode>si2_hw): Likewise.\n+\t(fix<uns>_<mode>di2_hw): Likewise.\n+\t(float<uns>_<mode>si2_hw): Likewise.\n+\t(float<uns>_<mode>di2_hw): Likewise.\n+\t(xscvqp<su>wz_<mode>): Likewise.\n+\t(xscvqp<su>dz_<mode>): Likewise.\n+\t(xscv<su>dqp_<mode): Likewise.\n+\t(ieee128_mfvsrd): Likewise.\n+\t(ieee128_mfvsrwz): Likewise.\n+\t(ieee128_mtvsrw): Likewise.\n+\t(ieee128_mtvsrd): Likewise.\n+\t(trunc<mode>df2_odd): Likewise.\n+\t(cmp<mode>_h): Likewise.\n+\t(128-bit GPR splitters): Don't split a 128-bit move that is a\n+\tdirect move between GPR and vector registers using ISA 3.0 direct\n+\tmove instructions.\n+\t(<u>mul<mode><dmode>3): Add support for the ISA 3.0 integer\n+\tmultiply-add instruction.\n+\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Add ISA 3.0\n+\tdebugging.\n+\t(rs6000_init_hard_regno_mode_ok): If ISA 3.0 and 64-bit, enable we\n+\tconstraint.  Disable the VSX<->GPR direct move helpers if we have\n+\tthe MFVSRLD and MTVSRDD instructions.\n+\t(rs6000_secondary_reload_simple_move): Add support for doing\n+\tvector direct moves directly without additional scratch registers\n+\tif we have ISA 3.0 instructions.\n+\t(rs6000_secondary_reload_direct_move): Update comments.\n+\t(rs6000_output_move_128bit): Add support for ISA 3.0 vector\n+\tinstructions.\n+\n+\t* config/rs6000/vsx.md (vsx_mov<mode>): Add support for ISA 3.0\n+\tdirect move instructions.\n+\t(vsx_movti_64bit): Likewise.\n+\t(vsx_extract_<mode>): Likewise.\n+\n+\t* config/rs6000/rs6000.h (VECTOR_ELEMENT_MFVSRLD_64BIT): New\n+\tmacros for ISA 3.0 direct move instructions.\n+\t(TARGET_DIRECT_MOVE_128): Likewise.\n+\t(TARGET_MADDLD): Add support for the ISA 3.0 integer multiply-add\n+\tinstruction.\n+\n+\t* doc/md.texi (RS/6000 constraints): Document we, wF, wG, wL\n+\tconstraints.  Update wa documentation to say not to use %x<n> on\n+\tinstructions that only take Altivec registers.\n+\n 2015-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* Makefile.in (OBJS): Add gcc-rich-location.o."}, {"sha": "e41294537368812fe03a0bbeeb52a0a6acdcc548", "filename": "gcc/config/rs6000/constraints.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fconstraints.md?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -64,7 +64,8 @@\n (define_register_constraint \"wd\" \"rs6000_constraints[RS6000_CONSTRAINT_wd]\"\n   \"VSX vector register to hold vector double data or NO_REGS.\")\n \n-;; we is not currently used\n+(define_register_constraint \"we\" \"rs6000_constraints[RS6000_CONSTRAINT_we]\"\n+  \"VSX register if the -mpower9-vector -m64 options were used or NO_REGS.\")\n \n (define_register_constraint \"wf\" \"rs6000_constraints[RS6000_CONSTRAINT_wf]\"\n   \"VSX vector register to hold vector float data or NO_REGS.\")\n@@ -147,6 +148,12 @@\n   \"Memory operand suitable for TOC fusion memory references\"\n   (match_operand 0 \"toc_fusion_mem_wrapped\"))\n \n+(define_constraint \"wL\"\n+  \"Int constant that is the element number mfvsrld accesses in a vector.\"\n+  (and (match_code \"const_int\")\n+       (and (match_test \"TARGET_DIRECT_MOVE_128\")\n+\t    (match_test \"(ival == VECTOR_ELEMENT_MFVSRLD_64BIT)\"))))\n+\n ;; Lq/stq validates the address for load/store quad\n (define_memory_constraint \"wQ\"\n   \"Memory operand suitable for the load/store quad instructions\""}, {"sha": "050076547870c162a02db5d4e68950f5b8be894c", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -55,6 +55,8 @@ extern const char *rs6000_output_move_128bit (rtx *);\n extern bool rs6000_move_128bit_ok_p (rtx []);\n extern bool rs6000_split_128bit_ok_p (rtx []);\n extern void rs6000_expand_float128_convert (rtx, rtx, bool);\n+extern void convert_float128_to_int (rtx *, enum rtx_code);\n+extern void convert_int_to_float128 (rtx *, enum rtx_code);\n extern void rs6000_expand_vector_init (rtx, rtx);\n extern void paired_expand_vector_init (rtx, rtx);\n extern void rs6000_expand_vector_set (rtx, rtx, int);"}, {"sha": "3e02d5cfb5c8e588d5ae4fa1a5d473950063ed6f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 262, "deletions": 17, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -2575,6 +2575,10 @@ rs6000_debug_reg_global (void)\n   if (TARGET_VSX)\n     fprintf (stderr, DEBUG_FMT_D, \"VSX easy 64-bit scalar element\",\n \t     (int)VECTOR_ELEMENT_SCALAR_64BIT);\n+\n+  if (TARGET_DIRECT_MOVE_128)\n+    fprintf (stderr, DEBUG_FMT_D, \"VSX easy 64-bit mfvsrld element\",\n+\t     (int)VECTOR_ELEMENT_MFVSRLD_64BIT);\n }\n \n \f\n@@ -2986,6 +2990,10 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \trs6000_constraints[RS6000_CONSTRAINT_wp] = VSX_REGS;\t/* TFmode  */\n     }\n \n+  /* Support for new direct moves.  */\n+  if (TARGET_DIRECT_MOVE_128)\n+    rs6000_constraints[RS6000_CONSTRAINT_we] = VSX_REGS;\n+\n   /* Set up the reload helper and direct move functions.  */\n   if (TARGET_VSX || TARGET_ALTIVEC)\n     {\n@@ -3034,7 +3042,7 @@ rs6000_init_hard_regno_mode_ok (bool global_init_p)\n \t      reg_addr[TImode].reload_load   = CODE_FOR_reload_ti_di_load;\n \t    }\n \n-\t  if (TARGET_DIRECT_MOVE)\n+\t  if (TARGET_DIRECT_MOVE && !TARGET_DIRECT_MOVE_128)\n \t    {\n \t      reg_addr[TImode].reload_gpr_vsx    = CODE_FOR_reload_gpr_from_vsxti;\n \t      reg_addr[V1TImode].reload_gpr_vsx  = CODE_FOR_reload_gpr_from_vsxv1ti;\n@@ -18081,6 +18089,11 @@ rs6000_secondary_reload_simple_move (enum rs6000_reg_type to_type,\n \t  || (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)))\n     return true;\n \n+  else if (TARGET_DIRECT_MOVE_128 && size == 16\n+\t   && ((to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n+\t       || (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)))\n+    return true;\n+\n   else if (TARGET_MFPGPR && TARGET_POWERPC64 && size == 8\n \t   && ((to_type == GPR_REG_TYPE && from_type == FPR_REG_TYPE)\n \t       || (to_type == FPR_REG_TYPE && from_type == GPR_REG_TYPE)))\n@@ -18094,7 +18107,7 @@ rs6000_secondary_reload_simple_move (enum rs6000_reg_type to_type,\n   return false;\n }\n \n-/* Power8 helper function for rs6000_secondary_reload, handle all of the\n+/* Direct move helper function for rs6000_secondary_reload, handle all of the\n    special direct moves that involve allocating an extra register, return the\n    insn code of the helper function if there is such a function or\n    CODE_FOR_nothing if not.  */\n@@ -18116,16 +18129,16 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n       if (size == 16)\n \t{\n \t  /* Handle moving 128-bit values from GPRs to VSX point registers on\n-\t     power8 when running in 64-bit mode using XXPERMDI to glue the two\n-\t     64-bit values back together.  */\n+\t     ISA 2.07 (power8, power9) when running in 64-bit mode using\n+\t     XXPERMDI to glue the two 64-bit values back together.  */\n \t  if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n \t    {\n \t      cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n \t      icode = reg_addr[mode].reload_vsx_gpr;\n \t    }\n \n \t  /* Handle moving 128-bit values from VSX point registers to GPRs on\n-\t     power8 when running in 64-bit mode using XXPERMDI to get access to the\n+\t     ISA 2.07 when running in 64-bit mode using XXPERMDI to get access to the\n \t     bottom 64-bit value.  */\n \t  else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n \t    {\n@@ -18150,11 +18163,32 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n \t}\n     }\n \n-  else if (size == 8)\n+  if (TARGET_POWERPC64 && size == 16)\n+    {\n+      /* Handle moving 128-bit values from GPRs to VSX point registers on\n+\t ISA 2.07 when running in 64-bit mode using XXPERMDI to glue the two\n+\t 64-bit values back together.  */\n+      if (to_type == VSX_REG_TYPE && from_type == GPR_REG_TYPE)\n+\t{\n+\t  cost = 3;\t\t\t/* 2 mtvsrd's, 1 xxpermdi.  */\n+\t  icode = reg_addr[mode].reload_vsx_gpr;\n+\t}\n+\n+      /* Handle moving 128-bit values from VSX point registers to GPRs on\n+\t ISA 2.07 when running in 64-bit mode using XXPERMDI to get access to the\n+\t bottom 64-bit value.  */\n+      else if (to_type == GPR_REG_TYPE && from_type == VSX_REG_TYPE)\n+\t{\n+\t  cost = 3;\t\t\t/* 2 mfvsrd's, 1 xxpermdi.  */\n+\t  icode = reg_addr[mode].reload_gpr_vsx;\n+\t}\n+    }\n+\n+  else if (!TARGET_POWERPC64 && size == 8)\n     {\n       /* Handle moving 64-bit values from GPRs to floating point registers on\n-\t power8 when running in 32-bit mode using FMRGOW to glue the two 32-bit\n-\t values back together.  Altivec register classes must be handled\n+\t ISA 2.07 when running in 32-bit mode using FMRGOW to glue the two\n+\t 32-bit values back together.  Altivec register classes must be handled\n \t specially since a different instruction is used, and the secondary\n \t reload support requires a single instruction class in the scratch\n \t register constraint.  However, right now TFmode is not allowed in\n@@ -18181,7 +18215,7 @@ rs6000_secondary_reload_direct_move (enum rs6000_reg_type to_type,\n \n /* Return whether a move between two register classes can be done either\n    directly (simple move) or via a pattern that uses a single extra temporary\n-   (using power8's direct move in this case.  */\n+   (using ISA 2.07's direct move in this case.  */\n \n static bool\n rs6000_secondary_reload_move (enum rs6000_reg_type to_type,\n@@ -19220,6 +19254,11 @@ rs6000_output_move_128bit (rtx operands[])\n \t  if (src_gpr_p)\n \t    return \"#\";\n \n+\t  if (TARGET_DIRECT_MOVE_128 && src_vsx_p)\n+\t    return (WORDS_BIG_ENDIAN\n+\t\t    ? \"mfvsrd %0,%x1\\n\\tmfvsrld %L0,%x1\"\n+\t\t    : \"mfvsrd %L0,%x1\\n\\tmfvsrld %0,%x1\");\n+\n \t  else if (TARGET_VSX && TARGET_DIRECT_MOVE && src_vsx_p)\n \t    return \"#\";\n \t}\n@@ -19229,6 +19268,11 @@ rs6000_output_move_128bit (rtx operands[])\n \t  if (src_vsx_p)\n \t    return \"xxlor %x0,%x1,%x1\";\n \n+\t  else if (TARGET_DIRECT_MOVE_128 && src_gpr_p)\n+\t    return (WORDS_BIG_ENDIAN\n+\t\t    ? \"mtvsrdd %x0,%1,%L1\"\n+\t\t    : \"mtvsrdd %x0,%L1,%1\");\n+\n \t  else if (TARGET_DIRECT_MOVE && src_gpr_p)\n \t    return \"#\";\n \t}\n@@ -20490,11 +20534,12 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n       emit_insn (cmp);\n     }\n \n-  /* IEEE 128-bit support in VSX registers.  The comparison functions\n-     (__cmpokf2 and __cmpukf2) returns 0..15 that is laid out the same way as\n-     the PowerPC CR register would for a normal floating point comparison from\n-     the fcmpo and fcmpu instructions.  */\n-  else if (FLOAT128_IEEE_P (mode))\n+  /* IEEE 128-bit support in VSX registers.  If we do not have IEEE 128-bit\n+     hardware, the comparison functions (__cmpokf2 and __cmpukf2) returns 0..15\n+     that is laid out the same way as the PowerPC CR register would for a\n+     normal floating point comparison from the fcmpo and fcmpu\n+     instructions.  */\n+  else if (!TARGET_FLOAT128_HW && FLOAT128_IEEE_P (mode))\n     {\n       rtx and_reg = gen_reg_rtx (SImode);\n       rtx dest = gen_reg_rtx (SImode);\n@@ -20633,7 +20678,7 @@ rs6000_generate_compare (rtx cmp, machine_mode mode)\n   /* Some kinds of FP comparisons need an OR operation;\n      under flag_finite_math_only we don't bother.  */\n   if (FLOAT_MODE_P (mode)\n-      && !FLOAT128_IEEE_P (mode)\n+      && (!FLOAT128_IEEE_P (mode) || TARGET_FLOAT128_HW)\n       && !flag_finite_math_only\n       && !(TARGET_HARD_FLOAT && !TARGET_FPRS)\n       && (code == LE || code == GE\n@@ -20726,6 +20771,56 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   bool do_move = false;\n   rtx libfunc = NULL_RTX;\n   rtx dest2;\n+  typedef rtx (*rtx_2func_t) (rtx, rtx);\n+  rtx_2func_t hw_convert = (rtx_2func_t)0;\n+  size_t kf_or_tf;\n+\n+  struct hw_conv_t {\n+    rtx_2func_t\tfrom_df;\n+    rtx_2func_t from_sf;\n+    rtx_2func_t from_si_sign;\n+    rtx_2func_t from_si_uns;\n+    rtx_2func_t from_di_sign;\n+    rtx_2func_t from_di_uns;\n+    rtx_2func_t to_df;\n+    rtx_2func_t to_sf;\n+    rtx_2func_t to_si_sign;\n+    rtx_2func_t to_si_uns;\n+    rtx_2func_t to_di_sign;\n+    rtx_2func_t to_di_uns;\n+  } hw_conversions[2] = {\n+    /* convertions to/from KFmode */\n+    {\n+      gen_extenddfkf2_hw,\t\t/* KFmode <- DFmode.  */\n+      gen_extendsfkf2_hw,\t\t/* KFmode <- SFmode.  */\n+      gen_float_kfsi2_hw,\t\t/* KFmode <- SImode (signed).  */\n+      gen_floatuns_kfsi2_hw,\t\t/* KFmode <- SImode (unsigned).  */\n+      gen_float_kfdi2_hw,\t\t/* KFmode <- DImode (signed).  */\n+      gen_floatuns_kfdi2_hw,\t\t/* KFmode <- DImode (unsigned).  */\n+      gen_trunckfdf2_hw,\t\t/* DFmode <- KFmode.  */\n+      gen_trunckfsf2_hw,\t\t/* SFmode <- KFmode.  */\n+      gen_fix_kfsi2_hw,\t\t\t/* SImode <- KFmode (signed).  */\n+      gen_fixuns_kfsi2_hw,\t\t/* SImode <- KFmode (unsigned).  */\n+      gen_fix_kfdi2_hw,\t\t\t/* DImode <- KFmode (signed).  */\n+      gen_fixuns_kfdi2_hw,\t\t/* DImode <- KFmode (unsigned).  */\n+    },\n+\n+    /* convertions to/from TFmode */\n+    {\n+      gen_extenddftf2_hw,\t\t/* TFmode <- DFmode.  */\n+      gen_extendsftf2_hw,\t\t/* TFmode <- SFmode.  */\n+      gen_float_tfsi2_hw,\t\t/* TFmode <- SImode (signed).  */\n+      gen_floatuns_tfsi2_hw,\t\t/* TFmode <- SImode (unsigned).  */\n+      gen_float_tfdi2_hw,\t\t/* TFmode <- DImode (signed).  */\n+      gen_floatuns_tfdi2_hw,\t\t/* TFmode <- DImode (unsigned).  */\n+      gen_trunctfdf2_hw,\t\t/* DFmode <- TFmode.  */\n+      gen_trunctfsf2_hw,\t\t/* SFmode <- TFmode.  */\n+      gen_fix_tfsi2_hw,\t\t\t/* SImode <- TFmode (signed).  */\n+      gen_fixuns_tfsi2_hw,\t\t/* SImode <- TFmode (unsigned).  */\n+      gen_fix_tfdi2_hw,\t\t\t/* DImode <- TFmode (signed).  */\n+      gen_fixuns_tfdi2_hw,\t\t/* DImode <- TFmode (unsigned).  */\n+    },\n+  };\n \n   if (dest_mode == src_mode)\n     gcc_unreachable ();\n@@ -20745,14 +20840,23 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   /* Convert to IEEE 128-bit floating point.  */\n   if (FLOAT128_IEEE_P (dest_mode))\n     {\n+      if (dest_mode == KFmode)\n+\tkf_or_tf = 0;\n+      else if (dest_mode == TFmode)\n+\tkf_or_tf = 1;\n+      else\n+\tgcc_unreachable ();\n+\n       switch (src_mode)\n \t{\n \tcase DFmode:\n \t  cvt = sext_optab;\n+\t  hw_convert = hw_conversions[kf_or_tf].from_df;\n \t  break;\n \n \tcase SFmode:\n \t  cvt = sext_optab;\n+\t  hw_convert = hw_conversions[kf_or_tf].from_sf;\n \t  break;\n \n \tcase KFmode:\n@@ -20765,8 +20869,29 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t  break;\n \n \tcase SImode:\n+\t  if (unsigned_p)\n+\t    {\n+\t      cvt = ufloat_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].from_si_uns;\n+\t    }\n+\t  else\n+\t    {\n+\t      cvt = sfloat_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].from_si_sign;\n+\t    }\n+\t  break;\n+\n \tcase DImode:\n-\t  cvt = (unsigned_p) ? ufloat_optab : sfloat_optab;\n+\t  if (unsigned_p)\n+\t    {\n+\t      cvt = ufloat_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].from_di_uns;\n+\t    }\n+\t  else\n+\t    {\n+\t      cvt = sfloat_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].from_di_sign;\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -20777,14 +20902,23 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   /* Convert from IEEE 128-bit floating point.  */\n   else if (FLOAT128_IEEE_P (src_mode))\n     {\n+      if (src_mode == KFmode)\n+\tkf_or_tf = 0;\n+      else if (src_mode == TFmode)\n+\tkf_or_tf = 1;\n+      else\n+\tgcc_unreachable ();\n+\n       switch (dest_mode)\n \t{\n \tcase DFmode:\n \t  cvt = trunc_optab;\n+\t  hw_convert = hw_conversions[kf_or_tf].to_df;\n \t  break;\n \n \tcase SFmode:\n \t  cvt = trunc_optab;\n+\t  hw_convert = hw_conversions[kf_or_tf].to_sf;\n \t  break;\n \n \tcase KFmode:\n@@ -20797,8 +20931,29 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n \t  break;\n \n \tcase SImode:\n+\t  if (unsigned_p)\n+\t    {\n+\t      cvt = ufix_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].to_si_uns;\n+\t    }\n+\t  else\n+\t    {\n+\t      cvt = sfix_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].to_si_sign;\n+\t    }\n+\t  break;\n+\n \tcase DImode:\n-\t  cvt = (unsigned_p) ? ufix_optab : sfix_optab;\n+\t  if (unsigned_p)\n+\t    {\n+\t      cvt = ufix_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].to_di_uns;\n+\t    }\n+\t  else\n+\t    {\n+\t      cvt = sfix_optab;\n+\t      hw_convert = hw_conversions[kf_or_tf].to_di_sign;\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -20817,6 +20972,10 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   if (do_move)\n     emit_move_insn (dest, gen_lowpart (dest_mode, src));\n \n+  /* Handle conversion if we have hardware support.  */\n+  else if (TARGET_FLOAT128_HW && hw_convert)\n+    emit_insn ((hw_convert) (dest, src));\n+\n   /* Call an external function to do the conversion.  */\n   else if (cvt != unknown_optab)\n     {\n@@ -20837,6 +20996,92 @@ rs6000_expand_float128_convert (rtx dest, rtx src, bool unsigned_p)\n   return;\n }\n \n+/* Split a conversion from __float128 to an integer type into separate insns.\n+   OPERANDS points to the destination, source, and V2DI temporary\n+   register. CODE is either FIX or UNSIGNED_FIX.  */\n+\n+void\n+convert_float128_to_int (rtx *operands, enum rtx_code code)\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+  rtx cvt;\n+  rtvec cvt_vec;\n+  rtx cvt_unspec;\n+  rtvec move_vec;\n+  rtx move_unspec;\n+\n+  if (GET_CODE (tmp) == SCRATCH)\n+    tmp = gen_reg_rtx (V2DImode);\n+\n+  if (MEM_P (dest))\n+    dest = rs6000_address_for_fpconvert (dest);\n+\n+  /* Generate the actual convert insn of the form:\n+     (set (tmp) (unspec:V2DI [(fix:SI (reg:KF))] UNSPEC_IEEE128_CONVERT)).  */\n+  cvt = gen_rtx_fmt_e (code, GET_MODE (dest), src);\n+  cvt_vec = gen_rtvec (1, cvt);\n+  cvt_unspec = gen_rtx_UNSPEC (V2DImode, cvt_vec, UNSPEC_IEEE128_CONVERT);\n+  emit_insn (gen_rtx_SET (tmp, cvt_unspec));\n+\n+  /* Generate the move insn of the form:\n+     (set (dest:SI) (unspec:SI [(tmp:V2DI))] UNSPEC_IEEE128_MOVE)).  */\n+  move_vec = gen_rtvec (1, tmp);\n+  move_unspec = gen_rtx_UNSPEC (GET_MODE (dest), move_vec, UNSPEC_IEEE128_MOVE);\n+  emit_insn (gen_rtx_SET (dest, move_unspec));\n+}\n+\n+/* Split a conversion from an integer type to __float128 into separate insns.\n+   OPERANDS points to the destination, source, and V2DI temporary\n+   register. CODE is either FLOAT or UNSIGNED_FLOAT.  */\n+\n+void\n+convert_int_to_float128 (rtx *operands, enum rtx_code code)\n+{\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  rtx tmp = operands[2];\n+  rtx cvt;\n+  rtvec cvt_vec;\n+  rtx cvt_unspec;\n+  rtvec move_vec;\n+  rtx move_unspec;\n+  rtx unsigned_flag;\n+\n+  if (GET_CODE (tmp) == SCRATCH)\n+    tmp = gen_reg_rtx (V2DImode);\n+\n+  if (MEM_P (src))\n+    src = rs6000_address_for_fpconvert (src);\n+\n+  /* Generate the move of the integer into the Altivec register of the form:\n+     (set (tmp:V2DI) (unspec:V2DI [(src:SI)\n+\t\t\t\t   (const_int 0)] UNSPEC_IEEE128_MOVE)).\n+\n+     or:\n+     (set (tmp:V2DI) (unspec:V2DI [(src:DI)] UNSPEC_IEEE128_MOVE)).  */\n+\n+  if (GET_MODE (src) == SImode)\n+    {\n+      unsigned_flag = (code == UNSIGNED_FLOAT) ? const1_rtx : const0_rtx;\n+      move_vec = gen_rtvec (2, src, unsigned_flag);\n+    }\n+  else\n+    move_vec = gen_rtvec (1, src);\n+\n+  move_unspec = gen_rtx_UNSPEC (V2DImode, move_vec, UNSPEC_IEEE128_MOVE);\n+  emit_insn (gen_rtx_SET (tmp, move_unspec));\n+\n+  /* Generate the actual convert insn of the form:\n+     (set (dest:KF) (float:KF (unspec:DI [(tmp:V2DI)]\n+\t\t\t\t\t UNSPEC_IEEE128_CONVERT))).  */\n+  cvt_vec = gen_rtvec (1, tmp);\n+  cvt_unspec = gen_rtx_UNSPEC (DImode, cvt_vec, UNSPEC_IEEE128_CONVERT);\n+  cvt = gen_rtx_fmt_e (code, GET_MODE (dest), cvt_unspec);\n+  emit_insn (gen_rtx_SET (dest, cvt));\n+}\n+\n \f\n /* Emit the RTL for an sISEL pattern.  */\n "}, {"sha": "8c606ab0aea41e7a07924986c74ebaf11e7d7bca", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -516,6 +516,10 @@ extern int rs6000_vector_align[];\n    with scalar instructions.  */\n #define VECTOR_ELEMENT_SCALAR_64BIT\t((BYTES_BIG_ENDIAN) ? 0 : 1)\n \n+/* Element number of the 64-bit value in a 128-bit vector that can be accessed\n+   with the ISA 3.0 MFVSRLD instructions.  */\n+#define VECTOR_ELEMENT_MFVSRLD_64BIT\t((BYTES_BIG_ENDIAN) ? 1 : 0)\n+\n /* Alignment options for fields in structures for sub-targets following\n    AIX-like ABI.\n    ALIGN_POWER word-aligns FP doubles (default AIX ABI).\n@@ -567,10 +571,13 @@ extern int rs6000_vector_align[];\n #define TARGET_FCTIWUZ\tTARGET_POPCNTD\n #define TARGET_CTZ\tTARGET_MODULO\n #define TARGET_EXTSWSLI\t(TARGET_MODULO && TARGET_POWERPC64)\n+#define TARGET_MADDLD\t(TARGET_MODULO && TARGET_POWERPC64)\n \n #define TARGET_XSCVDPSPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n #define TARGET_XSCVSPDPN\t(TARGET_DIRECT_MOVE || TARGET_P8_VECTOR)\n #define TARGET_VADDUQM\t\t(TARGET_P8_VECTOR && TARGET_POWERPC64)\n+#define TARGET_DIRECT_MOVE_128\t(TARGET_P9_VECTOR && TARGET_DIRECT_MOVE \\\n+\t\t\t\t && TARGET_POWERPC64)\n \n /* Byte/char syncs were added as phased in for ISA 2.06B, but are not present\n    in power7, so conditionalize them on p8 features.  TImode syncs need quad\n@@ -1517,6 +1524,7 @@ enum r6000_reg_class_enum {\n   RS6000_CONSTRAINT_v,\t\t/* Altivec registers */\n   RS6000_CONSTRAINT_wa,\t\t/* Any VSX register */\n   RS6000_CONSTRAINT_wd,\t\t/* VSX register for V2DF */\n+  RS6000_CONSTRAINT_we,\t\t/* VSX register if ISA 3.0 vector. */\n   RS6000_CONSTRAINT_wf,\t\t/* VSX register for V4SF */\n   RS6000_CONSTRAINT_wg,\t\t/* FPR register for -mmfpgpr */\n   RS6000_CONSTRAINT_wh,\t\t/* FPR register for direct moves.  */"}, {"sha": "1fdc7bbda42cd7c299d4a04d4c6fcd01e94cd9cf", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 397, "deletions": 14, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -143,6 +143,9 @@\n    UNSPEC_STACK_CHECK\n    UNSPEC_FUSION_P9\n    UNSPEC_FUSION_ADDIS\n+   UNSPEC_ROUND_TO_ODD\n+   UNSPEC_IEEE128_MOVE\n+   UNSPEC_IEEE128_CONVERT\n   ])\n \n ;;\n@@ -381,6 +384,8 @@\n   (V2SF \"TARGET_PAIRED_FLOAT\")\n   (V4SF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V4SFmode)\")\n   (V2DF \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (V2DFmode)\")\n+  (KF \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (KFmode)\")\n+  (TF \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (TFmode)\")\n   ])\n \n ; Floating point move iterators to combine binary and decimal moves\n@@ -485,10 +490,10 @@\n (define_mode_attr Fvsx\t\t[(SF \"sp\") (DF\t\"dp\")])\n \n ; SF/DF constraint for arithmetic on traditional floating point registers\n-(define_mode_attr Ff\t\t[(SF \"f\") (DF \"d\")])\n+(define_mode_attr Ff\t\t[(SF \"f\") (DF \"d\") (DI \"d\")])\n \n ; SF/DF constraint for arithmetic on VSX registers\n-(define_mode_attr Fv\t\t[(SF \"wy\") (DF \"ws\")])\n+(define_mode_attr Fv\t\t[(SF \"wy\") (DF \"ws\") (DI \"wi\")])\n \n ; SF/DF constraint for arithmetic on altivec registers\n (define_mode_attr Fa\t\t[(SF \"wu\") (DF \"wv\")])\n@@ -510,9 +515,31 @@\n (define_code_iterator iorxor [ior xor])\n \n ; Signed/unsigned variants of ops.\n-(define_code_iterator any_extend [sign_extend zero_extend])\n-(define_code_attr u [(sign_extend \"\") (zero_extend \"u\")])\n-(define_code_attr su [(sign_extend \"s\") (zero_extend \"u\")])\n+(define_code_iterator any_extend\t[sign_extend zero_extend])\n+(define_code_iterator any_fix\t\t[fix unsigned_fix])\n+(define_code_iterator any_float\t\t[float unsigned_float])\n+\n+(define_code_attr u  [(sign_extend\t\"\")\n+\t\t      (zero_extend\t\"u\")])\n+\n+(define_code_attr su [(sign_extend\t\"s\")\n+\t\t      (zero_extend\t\"u\")\n+\t\t      (fix\t\t\"s\")\n+\t\t      (unsigned_fix\t\"s\")\n+\t\t      (float\t\t\"s\")\n+\t\t      (unsigned_float\t\"u\")])\n+\n+(define_code_attr az [(sign_extend\t\"a\")\n+\t\t      (zero_extend\t\"z\")\n+\t\t      (fix\t\t\"a\")\n+\t\t      (unsigned_fix\t\"z\")\n+\t\t      (float\t\t\"a\")\n+\t\t      (unsigned_float\t\"z\")])\n+\n+(define_code_attr uns [(fix\t\t\"\")\n+\t\t       (unsigned_fix\t\"uns\")\n+\t\t       (float\t\t\"\")\n+\t\t       (unsigned_float\t\"uns\")])\n \n ; Various instructions that come in SI and DI forms.\n ; A generic w/d attribute, for things like cmpw/cmpd.\n@@ -2815,6 +2842,14 @@\n   DONE;\n })\n \n+(define_insn \"*maddld4\"\n+  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n+\t(plus:DI (mult:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n+\t\t\t  (match_operand:DI 2 \"gpc_reg_operand\" \"r\"))\n+\t\t (match_operand:DI 3 \"gpc_reg_operand\" \"r\")))]\n+  \"TARGET_MADDLD\"\n+  \"maddld %0,%1,%2,%3\"\n+  [(set_attr \"type\" \"mul\")])\n \n (define_insn \"udiv<mode>3\"\n   [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n@@ -7003,7 +7038,16 @@\n {\n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n-      if (TARGET_FLOAT128)\n+      if (TARGET_FLOAT128_HW)\n+\t{\n+\t  if (<MODE>mode == TFmode)\n+\t    emit_insn (gen_negtf2_hw (operands[0], operands[1]));\n+\t  else if (<MODE>mode == KFmode)\n+\t    emit_insn (gen_negkf2_hw (operands[0], operands[1]));\n+\t  else\n+\t    gcc_unreachable ();\n+\t}\n+      else if (TARGET_FLOAT128)\n \t{\n \t  if (<MODE>mode == TFmode)\n \t    emit_insn (gen_ieee_128bit_vsx_negtf2 (operands[0], operands[1]));\n@@ -7053,7 +7097,17 @@\n \n   if (FLOAT128_IEEE_P (<MODE>mode))\n     {\n-      if (TARGET_FLOAT128)\n+      if (TARGET_FLOAT128_HW)\n+\t{\n+\t  if (<MODE>mode == TFmode)\n+\t    emit_insn (gen_abstf2_hw (operands[0], operands[1]));\n+\t  else if (<MODE>mode == KFmode)\n+\t    emit_insn (gen_abskf2_hw (operands[0], operands[1]));\n+\t  else\n+\t    FAIL;\n+\t  DONE;\n+\t}\n+      else if (TARGET_FLOAT128)\n \t{\n \t  if (<MODE>mode == TFmode)\n \t    emit_insn (gen_ieee_128bit_vsx_abstf2 (operands[0], operands[1]));\n@@ -7140,7 +7194,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7160,7 +7214,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(neg:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n   \"xxlxor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n@@ -7169,7 +7223,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7189,7 +7243,7 @@\n   [(set (match_operand:IEEE128 0 \"register_operand\" \"=wa\")\n \t(abs:IEEE128 (match_operand:IEEE128 1 \"register_operand\" \"wa\")))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n   \"xxlandc %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n@@ -7200,7 +7254,7 @@\n \t (abs:IEEE128\n \t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (clobber (match_scratch:V16QI 2 \"=v\"))]\n-  \"TARGET_FLOAT128 && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& 1\"\n   [(parallel [(set (match_dup 0)\n@@ -7222,7 +7276,7 @@\n \t (abs:IEEE128\n \t  (match_operand:IEEE128 1 \"register_operand\" \"wa\"))))\n    (use (match_operand:V16QI 2 \"register_operand\" \"=v\"))]\n-  \"TARGET_FLOAT128\"\n+  \"TARGET_FLOAT128 && !TARGET_FLOAT128_HW\"\n   \"xxlor %x0,%x1,%x2\"\n   [(set_attr \"type\" \"vecsimple\")])\n \n@@ -7480,7 +7534,10 @@\n \t(match_operand:FMOVE128_GPR 1 \"input_operand\" \"\"))]\n   \"reload_completed\n    && (int_reg_operand (operands[0], <MODE>mode)\n-       || int_reg_operand (operands[1], <MODE>mode))\"\n+       || int_reg_operand (operands[1], <MODE>mode))\n+   && (!TARGET_DIRECT_MOVE_128\n+       || (!vsx_register_operand (operands[0], <MODE>mode)\n+           && !vsx_register_operand (operands[1], <MODE>mode)))\"\n   [(pc)]\n { rs6000_split_multireg_move (operands[0], operands[1]); DONE; })\n \n@@ -12997,6 +13054,332 @@\n   [(set_attr \"type\" \"vecperm\")])\n \n \n+\f\n+;; ISA 2.08 IEEE 128-bit floating point support.\n+\n+(define_insn \"add<mode>3\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(plus:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsaddqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"sub<mode>3\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(minus:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xssubqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"mul<mode>3\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(mult:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsmulqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"div<mode>3\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(div:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsdivqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecdiv\")])\n+\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(sqrt:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+   \"xssqrtqp %0,%1\"\n+  [(set_attr \"type\" \"vecdiv\")])\n+\n+(define_insn \"copysign<mode>3\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:IEEE128\n+\t [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t  (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_COPYSIGN))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+   \"xscpsgnqp %0,%2,%1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+(define_insn \"neg<mode>2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(neg:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsnegqp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+\n+(define_insn \"abs<mode>2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(abs:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsabsqp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+\n+(define_insn \"*nabs<mode>2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(neg:IEEE128\n+\t (abs:IEEE128\n+\t  (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\"))))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsnabsqp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+;; Initially don't worry about doing fusion\n+(define_insn \"*fma<mode>4_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(fma:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"%v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n+\t (match_operand:IEEE128 3 \"altivec_register_operand\" \"0\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsmaddqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*fms<mode>4_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(fma:IEEE128\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"%v\")\n+\t (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n+\t (neg:IEEE128\n+\t  (match_operand:IEEE128 3 \"altivec_register_operand\" \"0\"))))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsmsubqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*nfma<mode>4_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(neg:IEEE128\n+\t (fma:IEEE128\n+\t  (match_operand:IEEE128 1 \"altivec_register_operand\" \"%v\")\n+\t  (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n+\t  (match_operand:IEEE128 3 \"altivec_register_operand\" \"0\"))))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsnmaddqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*nfms<mode>4_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(neg:IEEE128\n+\t (fma:IEEE128\n+\t  (match_operand:IEEE128 1 \"altivec_register_operand\" \"%v\")\n+\t  (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n+\t  (neg:IEEE128\n+\t   (match_operand:IEEE128 3 \"altivec_register_operand\" \"0\")))))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xsnmsubqp %0,%1,%2\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"extend<SFDF:mode><IEEE128:mode>2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(float_extend:IEEE128\n+\t (match_operand:SFDF 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)\"\n+  \"xscvdpqp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"trunc<mode>df2_hw\"\n+  [(set (match_operand:DF 0 \"altivec_register_operand\" \"=v\")\n+\t(float_truncate:DF\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscvqpdp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+;; There is no KFmode -> SFmode instruction. Preserve the accuracy by doing\n+;; the KFmode -> DFmode conversion using round to odd rather than the normal\n+;; conversion\n+(define_insn_and_split \"trunc<mode>sf2_hw\"\n+  [(set (match_operand:SF 0 \"vsx_register_operand\" \"=wy\")\n+\t(float_truncate:SF\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))\n+   (clobber (match_scratch:DF 2 \"=v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 2)\n+\t(unspec:DF [(match_dup 1)] UNSPEC_ROUND_TO_ODD))\n+   (set (match_dup 0)\n+\t(float_truncate:SF (match_dup 2)))]\n+{\n+  if (GET_CODE (operands[2]) == SCRATCH)\n+    operands[2] = gen_reg_rtx (DFmode);\n+}\n+  [(set_attr \"type\" \"vecfloat\")\n+   (set_attr \"length\" \"8\")])\n+\n+;; At present SImode is not allowed in VSX registers at all, and DImode is only\n+;; allowed in the traditional floating point registers. Use V2DImode so that\n+;; we can get a value in an Altivec register.\n+\n+(define_insn_and_split \"fix<uns>_<mode>si2_hw\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,Z\")\n+\t(any_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v,v\")))\n+   (clobber (match_scratch:V2DI 2 \"=v,v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  convert_float128_to_int (operands, <CODE>);\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"mftgpr,fpstore\")])\n+\n+(define_insn_and_split \"fix<uns>_<mode>di2_hw\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=wr,wi,Z\")\n+\t(any_fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v,v,v\")))\n+   (clobber (match_scratch:V2DI 2 \"=v,v,v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  convert_float128_to_int (operands, <CODE>);\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"mftgpr,vecsimple,fpstore\")])\n+\n+(define_insn_and_split \"float<uns>_<mode>si2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v,v\")\n+\t(any_float:IEEE128 (match_operand:SI 1 \"nonimmediate_operand\" \"r,Z\")))\n+   (clobber (match_scratch:V2DI 2 \"=v,v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  convert_int_to_float128 (operands, <CODE>);\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn_and_split \"float<uns>_<mode>di2_hw\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v,v,v\")\n+\t(any_float:IEEE128 (match_operand:DI 1 \"nonimmediate_operand\" \"wi,wr,Z\")))\n+   (clobber (match_scratch:V2DI 2 \"=v,v,v\"))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"#\"\n+  \"&& 1\"\n+  [(pc)]\n+{\n+  convert_int_to_float128 (operands, <CODE>);\n+  DONE;\n+}\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"type\" \"vecfloat\")])\n+\n+;; Integer conversion instructions, using V2DImode to get an Altivec register\n+(define_insn \"*xscvqp<su>wz_<mode>\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:V2DI\n+\t [(any_fix:SI\n+\t   (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\"))]\n+\t UNSPEC_IEEE128_CONVERT))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscvqp<su>wz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*xscvqp<su>dz_<mode>\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v\")\n+\t(unspec:V2DI\n+\t [(any_fix:DI\n+\t   (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\"))]\n+\t UNSPEC_IEEE128_CONVERT))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscvqp<su>dz %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*xscv<su>dqp_<mode>\"\n+  [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n+\t(any_float:IEEE128\n+\t (unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v\")]\n+\t\t    UNSPEC_IEEE128_CONVERT)))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscv<su>dqp %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+(define_insn \"*ieee128_mfvsrd\"\n+  [(set (match_operand:DI 0 \"reg_or_indexed_operand\" \"=wr,Z,wi\")\n+\t(unspec:DI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v,v\")]\n+\t\t   UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW && TARGET_POWERPC64\"\n+  \"@\n+   mfvsrd %0,%x1\n+   stxsdx %x1,%y0\n+   xxlor %x0,%x1,%x1\"\n+  [(set_attr \"type\" \"mftgpr,vecsimple,fpstore\")])\n+\n+(define_insn \"*ieee128_mfvsrwz\"\n+  [(set (match_operand:SI 0 \"reg_or_indexed_operand\" \"=r,Z\")\n+\t(unspec:SI [(match_operand:V2DI 1 \"altivec_register_operand\" \"v,v\")]\n+\t\t   UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW\"\n+  \"@\n+   mfvsrwz %0,%x1\n+   stxsiwx %x1,%y0\"\n+  [(set_attr \"type\" \"mftgpr,fpstore\")])\n+\n+;; 0 says do sign-extension, 1 says zero-extension\n+(define_insn \"*ieee128_mtvsrw\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v,v,v\")\n+\t(unspec:V2DI [(match_operand:SI 1 \"nonimmediate_operand\" \"r,Z,r,Z\")\n+\t\t      (match_operand:SI 2 \"const_0_to_1_operand\" \"O,O,n,n\")]\n+\t\t     UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW\"\n+  \"@\n+   mtvsrwa %x0,%1\n+   lxsiwax %x0,%y1\n+   mtvsrwz %x0,%1\n+   lxsiwzx %x0,%y1\"\n+  [(set_attr \"type\" \"mffgpr,fpload,mffgpr,fpload\")])\n+\n+\n+(define_insn \"*ieee128_mtvsrd\"\n+  [(set (match_operand:V2DI 0 \"altivec_register_operand\" \"=v,v,v\")\n+\t(unspec:V2DI [(match_operand:DI 1 \"nonimmediate_operand\" \"wr,Z,wi\")]\n+\t\t     UNSPEC_IEEE128_MOVE))]\n+  \"TARGET_FLOAT128_HW\"\n+  \"@\n+   mtvsrd %x0,%1\n+   lxsdx %x0,%y1\n+   xxlor %x0,%x1,%x1\"\n+  [(set_attr \"type\" \"mffgpr,fpload,vecsimple\")])\n+\n+;; IEEE 128-bit instructions with round to odd semantics\n+(define_insn \"*trunc<mode>df2_odd\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=v\")\n+\t(unspec:DF [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")]\n+\t\t   UNSPEC_ROUND_TO_ODD))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+  \"xscvqpdpo %0,%1\"\n+  [(set_attr \"type\" \"vecfloat\")])\n+\n+;; IEEE 128-bit comparisons\n+(define_insn \"*cmp<mode>_hw\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCFP (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n+\t\t      (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n+   \"xscmpuqp %0,%1,%2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n \f\n \n (include \"sync.md\")"}, {"sha": "596b11d01ab683b9b47e3e68824993a9b3177ee2", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -760,31 +760,31 @@\n   \"\")\n \n (define_insn \"*vsx_mov<mode>\"\n-  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ, v\")\n-\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n+  [(set (match_operand:VSX_M 0 \"nonimmediate_operand\" \"=Z,<VSr>,<VSr>,?Z,?<VSa>,?<VSa>,r,we,wQ,?&r,??Y,??r,??r,<VSr>,?<VSa>,*r,v,wZ,v\")\n+\t(match_operand:VSX_M 1 \"input_operand\" \"<VSr>,Z,<VSr>,<VSa>,Z,<VSa>,we,b,r,wQ,r,Y,r,j,j,j,W,v,wZ\"))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\n    && (register_operand (operands[0], <MODE>mode) \n        || register_operand (operands[1], <MODE>mode))\"\n {\n   return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,load,store,store,load, *,vecsimple,vecsimple,*, *,vecstore,vecload\")\n-   (set_attr \"length\" \"4,4,4,4,4,4,12,12,12,12,16,4,4,*,16,4,4\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecstore,vecload,vecsimple,mffgpr,mftgpr,load,store,store,load, *,vecsimple,vecsimple,*, *,vecstore,vecload\")\n+   (set_attr \"length\" \"4,4,4,4,4,4,8,4,12,12,12,12,16,4,4,*,16,4,4\")])\n \n ;; Unlike other VSX moves, allow the GPRs even for reloading, since a normal\n ;; use of TImode is for unions.  However for plain data movement, slightly\n ;; favor the vector loads\n (define_insn \"*vsx_movti_64bit\"\n-  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v,v,wZ,wQ,&r,Y,r,r,?r\")\n-\t(match_operand:TI 1 \"input_operand\" \"wa,Z,wa,O,W,wZ,v,r,wQ,r,Y,r,n\"))]\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,r,we,v,v,wZ,wQ,&r,Y,r,r,?r\")\n+\t(match_operand:TI 1 \"input_operand\" \"wa,Z,wa,O,we,b,W,wZ,v,r,wQ,r,Y,r,n\"))]\n   \"TARGET_POWERPC64 && VECTOR_MEM_VSX_P (TImode)\n    && (register_operand (operands[0], TImode) \n        || register_operand (operands[1], TImode))\"\n {\n   return rs6000_output_move_128bit (operands);\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,vecsimple,vecstore,vecload,store,load,store,load,*,*\")\n-   (set_attr \"length\" \"4,4,4,4,16,4,4,8,8,8,8,8,8\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,vecsimple,mffgpr,mftgpr,vecsimple,vecstore,vecload,store,load,store,load,*,*\")\n+   (set_attr \"length\" \"4,4,4,4,8,4,16,4,4,8,8,8,8,8,8\")])\n \n (define_insn \"*vsx_movti_32bit\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=Z,wa,wa,wa,v, v,wZ,Q,Y,????r,????r,????r,r\")\n@@ -1909,11 +1909,11 @@\n ;; Optimize cases were we can do a simple or direct move.\n ;; Or see if we can avoid doing the move at all\n (define_insn \"*vsx_extract_<mode>_internal1\"\n-  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,<VS_64reg>,r\")\n+  [(set (match_operand:<VS_scalar> 0 \"register_operand\" \"=d,<VS_64reg>,r,r\")\n \t(vec_select:<VS_scalar>\n-\t (match_operand:VSX_D 1 \"register_operand\" \"d,<VS_64reg>,<VS_64dm>\")\n+\t (match_operand:VSX_D 1 \"register_operand\" \"d,<VS_64reg>,<VS_64dm>,<VS_64dm>\")\n \t (parallel\n-\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD\")])))]\n+\t  [(match_operand:QI 2 \"vsx_scalar_64bit\" \"wD,wD,wD,wL\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode) && TARGET_POWERPC64 && TARGET_DIRECT_MOVE\"\n {\n   int op0_regno = REGNO (operands[0]);\n@@ -1923,14 +1923,16 @@\n     return \"nop\";\n \n   if (INT_REGNO_P (op0_regno))\n-    return \"mfvsrd %0,%x1\";\n+    return ((INTVAL (operands[2]) == VECTOR_ELEMENT_MFVSRLD_64BIT)\n+\t    ? \"mfvsrdl %0,%x1\"\n+\t    : \"mfvsrd %0,%x1\");\n \n   if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n     return \"fmr %0,%1\";\n \n   return \"xxlor %x0,%x1,%x1\";\n }\n-  [(set_attr \"type\" \"fp,vecsimple,mftgpr\")\n+  [(set_attr \"type\" \"fp,vecsimple,mftgpr,mftgpr\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"*vsx_extract_<mode>_internal2\""}, {"sha": "80a1f64a61f88bc8f73ff09a7015b1a35b16fe72", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -3121,9 +3121,28 @@ asm (\"xvadddp %0,%1,%2\" : \"=wa\" (v1) : \"wa\" (v2), \"wa\" (v3));\n \n is not correct.\n \n+If an instruction only takes Altivec registers, you do not want to use\n+@code{%x<n>}.\n+\n+@smallexample\n+asm (\"xsaddqp %0,%1,%2\" : \"=v\" (v1) : \"v\" (v2), \"v\" (v3));\n+@end smallexample\n+\n+is correct because the @code{xsaddqp} instruction only takes Altivec\n+registers, while:\n+\n+@smallexample\n+asm (\"xsaddqp %x0,%x1,%x2\" : \"=v\" (v1) : \"v\" (v2), \"v\" (v3));\n+@end smallexample\n+\n+is incorrect.\n+\n @item wd\n VSX vector register to hold vector double data or NO_REGS.\n \n+@item we\n+VSX register if the -mpower9-vector -m64 options were used or NO_REGS.\n+\n @item wf\n VSX vector register to hold vector float data or NO_REGS.\n \n@@ -3187,6 +3206,16 @@ Floating point register if the LFIWZX instruction is enabled or NO_REGS.\n @item wD\n Int constant that is the element number of the 64-bit scalar in a vector.\n \n+@item wF\n+Memory operand suitable for power9 fusion load/stores.\n+\n+@item wG\n+Memory operand suitable for TOC fusion memory references.\n+\n+@item wL\n+Int constant that is the element number that the MFVSRLD instruction\n+targets.\n+\n @item wQ\n A memory address that will work with the @code{lq} and @code{stq}\n instructions."}, {"sha": "deb1a712db2867d8bf0e3332709ebe19ab728015", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -1,3 +1,13 @@\n+2015-11-13  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\t* gcc.target/powerpc/float128-hw.c: New test for IEEE 128-bit\n+\thardware floating point support.\n+\n+\t* gcc.target/powerpc/direct-move-vector.c: New test for 128-bit\n+\tvector direct move instructions.\n+\n+\t* gcc.target/powerpc/maddld.c: New test.\n+\n 2015-11-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/pr68306.c (dg-additional-options): Add i?86-*-* target."}, {"sha": "1e8504ec66c1e86c4a6a8362e7b86f2387a5405a", "filename": "gcc/testsuite/gcc.target/powerpc/direct-move-vector.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fdirect-move-vector.c?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile { target { powerpc*-*-linux* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+/* Check code generation for direct move for long types.  */\n+\n+void\n+test (vector double *p)\n+{\n+  vector double v1 = *p;\n+  vector double v2;\n+  vector double v3;\n+  vector double v4;\n+\n+  /* Force memory -> FPR load.  */\n+  __asm__ (\" # reg %x0\" : \"+d\" (v1));\n+\n+  /* force VSX -> GPR direct move.  */\n+  v2 = v1;\n+  __asm__ (\" # reg %0\" : \"+r\" (v2));\n+\n+  /* Force GPR -> Altivec direct move.  */\n+  v3 = v2;\n+  __asm__ (\" # reg %x0\" : \"+v\" (v3));\n+  *p = v3;\n+}\n+\n+/* { dg-final { scan-assembler \"mfvsrd\"  } } */\n+/* { dg-final { scan-assembler \"mfvsrld\" } } */\n+/* { dg-final { scan-assembler \"mtvsrdd\" } } */\n+\n+"}, {"sha": "71a0c24a2f2b0fbfba55828a098c511025a96fa5", "filename": "gcc/testsuite/gcc.target/powerpc/float128-hw.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Ffloat128-hw.c?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_float128_hw_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+__float128 f128_add (__float128 a, __float128 b) { return a+b; }\n+__float128 f128_sub (__float128 a, __float128 b) { return a-b; }\n+__float128 f128_mul (__float128 a, __float128 b) { return a*b; }\n+__float128 f128_div (__float128 a, __float128 b) { return a/b; }\n+__float128 f128_fma (__float128 a, __float128 b, __float128 c) { return (a*b)+c; }\n+long f128_cmove (__float128 a, __float128 b, long c, long d) { return (a == b) ? c : d; }\n+\n+/* { dg-final { scan-assembler \"xsaddqp\"  } } */\n+/* { dg-final { scan-assembler \"xssubqp\"  } } */\n+/* { dg-final { scan-assembler \"xsmulqp\"  } } */\n+/* { dg-final { scan-assembler \"xsdivqp\"  } } */\n+/* { dg-final { scan-assembler \"xsmaddqp\" } } */\n+/* { dg-final { scan-assembler \"xscmpuqp\" } } */"}, {"sha": "c2b0c172080355710e0da22db297fc9bf9b93237", "filename": "gcc/testsuite/gcc.target/powerpc/maddld.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmaddld.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd551aa1c5770e63e21075ee4945be7b44c18276/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmaddld.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fmaddld.c?ref=dd551aa1c5770e63e21075ee4945be7b44c18276", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */\n+/* { dg-require-effective-target powerpc_p9modulo_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+long\n+s_madd (long a, long b, long c)\n+{\n+  return (a * b) + c;\n+}\n+\n+unsigned long\n+u_madd (unsigned long a, unsigned long b, unsigned long c)\n+{\n+  return (a * b) + c;\n+}\n+\n+/* { dg-final { scan-assembler-times \"maddld \" 2 } } */\n+/* { dg-final { scan-assembler-not   \"mulld \"    } } */\n+/* { dg-final { scan-assembler-not   \"add \"      } } */"}]}