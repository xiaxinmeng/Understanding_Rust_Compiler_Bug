{"sha": "fdcef314bcb0728d883cd87d6950d85217e82755", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmRjZWYzMTRiY2IwNzI4ZDg4M2NkODdkNjk1MGQ4NTIxN2U4Mjc1NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-07T21:44:06Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-01-07T21:44:06Z"}, "message": "compiler: move slice construction to callers of makeslice\n    \n    This is the gccgo version of https://golang.org/cl/141822:\n    \n        Only return a pointer p to the new slices backing array from makeslice.\n        Makeslice callers then construct sliceheader{p, len, cap} explictly\n        instead of makeslice returning the slice.\n    \n    This change caused the GCC backend to break the runtime/pprof test by\n    merging together the identical functions allocateReflectTransient and\n    allocateTransient2M.  This caused the traceback to be other than\n    expected.  Fix that by making the functions not identical.\n    \n    This is a step toward updating libgo to the Go1.12beta1 release.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/155937\n\nFrom-SVN: r267660", "tree": {"sha": "f1a09ca36cb906a2fd919ddc7f148f232e58109b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1a09ca36cb906a2fd919ddc7f148f232e58109b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fdcef314bcb0728d883cd87d6950d85217e82755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcef314bcb0728d883cd87d6950d85217e82755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdcef314bcb0728d883cd87d6950d85217e82755", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdcef314bcb0728d883cd87d6950d85217e82755/comments", "author": null, "committer": null, "parents": [{"sha": "575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/575eb8f58b06657c9cadfe6f7ddfd9e530fe5dea"}], "stats": {"total": 258, "additions": 166, "deletions": 92}, "files": [{"sha": "7c7370a5954af1a1868994ef4c3286f167743e24", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -1,4 +1,4 @@\n-c257303eaef143663216e483857d5b259e05753f\n+c8a9bccbc524381d150c84907a61ac257c1b07cc\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "e1c98094831f3de097424856116c212bf65d34ee", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -1737,6 +1737,16 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       }\n       break;\n \n+    case Expression::EXPRESSION_SLICE_VALUE:\n+      {\n+\t// Connect the pointer field to the slice value.\n+\tNode* slice_node = Node::make_node(*pexpr);\n+\tNode* ptr_node =\n+\t  Node::make_node((*pexpr)->slice_value_expression()->valmem());\n+\tthis->assign(slice_node, ptr_node);\n+      }\n+      break;\n+\n     case Expression::EXPRESSION_HEAP:\n       {\n \tNode* pointer_node = Node::make_node(*pexpr);\n@@ -2263,6 +2273,8 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t  // DST = map[T]V{...}.\n \tcase Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n \t  // DST = T{...}.\n+\tcase Expression::EXPRESSION_SLICE_VALUE:\n+\t  // DST = slice{ptr, len, cap}\n \tcase Expression::EXPRESSION_ALLOCATION:\n \t  // DST = new(T).\n \tcase Expression::EXPRESSION_BOUND_METHOD:"}, {"sha": "71f18002733d810fb0016ba23d23b6094fa765e8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 49, "deletions": 68, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -7787,29 +7787,42 @@ Builtin_call_expression::lower_make(Statement_inserter* inserter)\n   Expression* call;\n   if (is_slice)\n     {\n+      Temporary_statement* len_temp = NULL;\n+      if (!len_arg->is_constant())\n+\t{\n+\t  len_temp = Statement::make_temporary(NULL, len_arg, loc);\n+\t  inserter->insert(len_temp);\n+\t  len_arg = Expression::make_temporary_reference(len_temp, loc);\n+\t}\n+\n       if (cap_arg == NULL)\n \t{\n           cap_small = len_small;\n-          if (len_arg->numeric_constant_value(&nclen)\n-              && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID)\n-            cap_arg = Expression::make_integer_ul(vlen, len_arg->type(), loc);\n-          else\n-            {\n-              Temporary_statement* temp = Statement::make_temporary(NULL,\n-                                                                    len_arg,\n-                                                                    loc);\n-              inserter->insert(temp);\n-              len_arg = Expression::make_temporary_reference(temp, loc);\n-              cap_arg = Expression::make_temporary_reference(temp, loc);\n-            }\n+\t  if (len_temp == NULL)\n+\t    cap_arg = len_arg->copy();\n+\t  else\n+\t    cap_arg = Expression::make_temporary_reference(len_temp, loc);\n+\t}\n+      else if (!cap_arg->is_constant())\n+\t{\n+\t  Temporary_statement* cap_temp = Statement::make_temporary(NULL,\n+\t\t\t\t\t\t\t\t    cap_arg,\n+\t\t\t\t\t\t\t\t    loc);\n+\t  inserter->insert(cap_temp);\n+\t  cap_arg = Expression::make_temporary_reference(cap_temp, loc);\n \t}\n \n       Type* et = type->array_type()->element_type();\n       Expression* type_arg = Expression::make_type_descriptor(et, type_loc);\n       Runtime::Function code = Runtime::MAKESLICE;\n       if (!len_small || !cap_small)\n \tcode = Runtime::MAKESLICE64;\n-      call = Runtime::make_call(code, loc, 3, type_arg, len_arg, cap_arg);\n+      Expression* mem = Runtime::make_call(code, loc, 3, type_arg, len_arg,\n+\t\t\t\t\t   cap_arg);\n+      mem = Expression::make_unsafe_cast(Type::make_pointer_type(et), mem,\n+\t\t\t\t\t loc);\n+      call = Expression::make_slice_value(type, mem, len_arg->copy(),\n+\t\t\t\t\t  cap_arg->copy(), loc);\n     }\n   else if (is_map)\n     {\n@@ -13585,9 +13598,13 @@ Slice_construction_expression::do_get_backend(Translate_context* context)\n       go_assert(this->storage_escapes_ || this->element_count() == 0);\n       space = Expression::make_heap_expression(this->array_val_, loc);\n     }\n+  Array_type* at = this->valtype_->array_type();\n+  Type* et = at->element_type();\n+  space = Expression::make_unsafe_cast(Type::make_pointer_type(et),\n+\t\t\t\t       space, loc);\n \n   // Build a constructor for the slice.\n-  Expression* len = this->valtype_->array_type()->length();\n+  Expression* len = at->length();\n   Expression* slice_val =\n     Expression::make_slice_value(this->type(), space, len, len, loc);\n   return slice_val->get_backend(context);\n@@ -15354,72 +15371,33 @@ Expression::make_slice_info(Expression* slice, Slice_info slice_info,\n   return new Slice_info_expression(slice, slice_info, location);\n }\n \n-// An expression that represents a slice value: a struct with value pointer,\n-// length, and capacity fields.\n-\n-class Slice_value_expression : public Expression\n-{\n- public:\n-  Slice_value_expression(Type* type, Expression* valptr, Expression* len,\n-                         Expression* cap, Location location)\n-      : Expression(EXPRESSION_SLICE_VALUE, location),\n-        type_(type), valptr_(valptr), len_(len), cap_(cap)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*);\n-\n-  Type*\n-  do_type()\n-  { return this->type_; }\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  { go_unreachable(); }\n-\n-  Expression*\n-  do_copy()\n-  {\n-    return new Slice_value_expression(this->type_->copy_expressions(),\n-\t\t\t\t      this->valptr_->copy(),\n-                                      this->len_->copy(), this->cap_->copy(),\n-                                      this->location());\n-  }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n-\n- private:\n-  // The type of the slice value.\n-  Type* type_;\n-  // The pointer to the values in the slice.\n-  Expression* valptr_;\n-  // The length of the slice.\n-  Expression* len_;\n-  // The capacity of the slice.\n-  Expression* cap_;\n-};\n+// Class Slice_value_expression.\n \n int\n Slice_value_expression::do_traverse(Traverse* traverse)\n {\n   if (Type::traverse(this->type_, traverse) == TRAVERSE_EXIT\n-      || Expression::traverse(&this->valptr_, traverse) == TRAVERSE_EXIT\n+      || Expression::traverse(&this->valmem_, traverse) == TRAVERSE_EXIT\n       || Expression::traverse(&this->len_, traverse) == TRAVERSE_EXIT\n       || Expression::traverse(&this->cap_, traverse) == TRAVERSE_EXIT)\n     return TRAVERSE_EXIT;\n   return TRAVERSE_CONTINUE;\n }\n \n+Expression*\n+Slice_value_expression::do_copy()\n+{\n+  return new Slice_value_expression(this->type_->copy_expressions(),\n+\t\t\t\t    this->valmem_->copy(),\n+\t\t\t\t    this->len_->copy(), this->cap_->copy(),\n+\t\t\t\t    this->location());\n+}\n+\n Bexpression*\n Slice_value_expression::do_get_backend(Translate_context* context)\n {\n   std::vector<Bexpression*> vals(3);\n-  vals[0] = this->valptr_->get_backend(context);\n+  vals[0] = this->valmem_->get_backend(context);\n   vals[1] = this->len_->get_backend(context);\n   vals[2] = this->cap_->get_backend(context);\n \n@@ -15434,7 +15412,7 @@ Slice_value_expression::do_dump_expression(\n {\n   ast_dump_context->ostream() << \"slicevalue(\";\n   ast_dump_context->ostream() << \"values: \";\n-  this->valptr_->dump_expression(ast_dump_context);\n+  this->valmem_->dump_expression(ast_dump_context);\n   ast_dump_context->ostream() << \", length: \";\n   this->len_->dump_expression(ast_dump_context);\n   ast_dump_context->ostream() << \", capacity: \";\n@@ -15443,11 +15421,14 @@ Slice_value_expression::do_dump_expression(\n }\n \n Expression*\n-Expression::make_slice_value(Type* at, Expression* valptr, Expression* len,\n+Expression::make_slice_value(Type* at, Expression* valmem, Expression* len,\n                              Expression* cap, Location location)\n {\n   go_assert(at->is_slice_type());\n-  return new Slice_value_expression(at, valptr, len, cap, location);\n+  go_assert(valmem->is_nil_expression()\n+\t    || (at->array_type()->element_type()\n+\t\t== valmem->type()->points_to()));\n+  return new Slice_value_expression(at, valmem, len, cap, location);\n }\n \n // An expression that evaluates to some characteristic of a non-empty interface."}, {"sha": "db40d8d0d213c6e7571ea47a627007b678e709cf", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -61,6 +61,7 @@ class Map_construction_expression;\n class Type_guard_expression;\n class Heap_expression;\n class Receive_expression;\n+class Slice_value_expression;\n class Conditional_expression;\n class Compound_expression;\n class Numeric_constant;\n@@ -841,6 +842,12 @@ class Expression\n   receive_expression()\n   { return this->convert<Receive_expression, EXPRESSION_RECEIVE>(); }\n \n+  // If this is a slice value expression, return the Slice_valiue_expression\n+  // structure.  Otherwise, return NULL.\n+  Slice_value_expression*\n+  slice_value_expression()\n+  { return this->convert<Slice_value_expression, EXPRESSION_SLICE_VALUE>(); }\n+\n   // If this is a conditional expression, return the Conditional_expression\n   // structure.  Otherwise, return NULL.\n   Conditional_expression*\n@@ -3955,6 +3962,56 @@ class Receive_expression : public Expression\n   Temporary_statement* temp_receiver_;\n };\n \n+// An expression that represents a slice value: a struct with value pointer,\n+// length, and capacity fields.\n+\n+class Slice_value_expression : public Expression\n+{\n+ public:\n+  Slice_value_expression(Type* type, Expression* valmem, Expression* len,\n+                         Expression* cap, Location location)\n+    : Expression(EXPRESSION_SLICE_VALUE, location),\n+      type_(type), valmem_(valmem), len_(len), cap_(cap)\n+  { }\n+\n+  // The memory holding the values in the slice.  The type should be a\n+  // pointer to the element value of the slice.\n+  Expression*\n+  valmem() const\n+  { return this->valmem_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Type*\n+  do_type()\n+  { return this->type_; }\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy();\n+\n+  Bexpression*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+ private:\n+  // The type of the slice value.\n+  Type* type_;\n+  // The memory holding the values in the slice.\n+  Expression* valmem_;\n+  // The length of the slice.\n+  Expression* len_;\n+  // The capacity of the slice.\n+  Expression* cap_;\n+};\n+\n // Conditional expressions.\n \n class Conditional_expression : public Expression"}, {"sha": "ded62514832a2a429deefa1fff309e6320a3423a", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -85,10 +85,10 @@ DEF_GO_RUNTIME(COMPLEX128_DIV, \"__go_complex128_div\",\n \n // Make a slice.\n DEF_GO_RUNTIME(MAKESLICE, \"runtime.makeslice\", P3(TYPE, INT, INT),\n-\t       R1(SLICE))\n+\t       R1(POINTER))\n \n DEF_GO_RUNTIME(MAKESLICE64, \"runtime.makeslice64\", P3(TYPE, INT64, INT64),\n-\t       R1(SLICE))\n+\t       R1(POINTER))\n \n \n // Make a map with a hint and an (optional, unused) map structure."}, {"sha": "8620e405b2e34e67ab5e3a13c143a3ec05b2831c", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -41,6 +41,9 @@ class Mark_address_taken : public Traverse\n   expression(Expression**);\n \n  private:\n+  Call_expression*\n+  find_makeslice_call(Expression*);\n+\n   // General IR.\n   Gogo* gogo_;\n   // The function we are traversing.\n@@ -97,6 +100,31 @@ Mark_address_taken::statement(Block* block, size_t* pindex, Statement* s)\n   return TRAVERSE_CONTINUE;\n }\n \n+// Look through the expression of a Slice_value_expression's valmem to\n+// find an call to makeslice.\n+\n+Call_expression*\n+Mark_address_taken::find_makeslice_call(Expression* expr)\n+{\n+  Unsafe_type_conversion_expression* utce =\n+    expr->unsafe_conversion_expression();\n+  if (utce != NULL)\n+    expr = utce->expr();\n+\n+  Call_expression* call = expr->call_expression();\n+  if (call == NULL)\n+    return NULL;\n+\n+  Func_expression* fe = call->fn()->func_expression();\n+  if (fe != NULL && fe->runtime_code() == Runtime::MAKESLICE)\n+    return call;\n+\n+  // We don't worry about MAKESLICE64 bcause we don't want to use a\n+  // stack allocation for a large slice anyhow.\n+\n+  return NULL;\n+}\n+\n // Mark variable addresses taken.\n \n int\n@@ -142,16 +170,12 @@ Mark_address_taken::expression(Expression** pexpr)\n     }\n \n   // Rewrite non-escaping makeslice with constant size to stack allocation.\n-  Unsafe_type_conversion_expression* uce =\n-    expr->unsafe_conversion_expression();\n-  if (uce != NULL\n-      && uce->type()->is_slice_type()\n-      && Node::make_node(uce->expr())->encoding() == Node::ESCAPE_NONE\n-      && uce->expr()->call_expression() != NULL)\n+  Slice_value_expression* sve = expr->slice_value_expression();\n+  if (sve != NULL)\n     {\n-      Call_expression* call = uce->expr()->call_expression();\n-      if (call->fn()->func_expression() != NULL\n-          && call->fn()->func_expression()->runtime_code() == Runtime::MAKESLICE)\n+      Call_expression* call = this->find_makeslice_call(sve->valmem());\n+      if (call != NULL\n+\t  && Node::make_node(call)->encoding() == Node::ESCAPE_NONE)\n         {\n           Expression* len_arg = call->args()->at(1);\n           Expression* cap_arg = call->args()->at(2);\n@@ -164,19 +188,20 @@ Mark_address_taken::expression(Expression** pexpr)\n               && nclen.to_unsigned_long(&vlen) == Numeric_constant::NC_UL_VALID\n               && nccap.to_unsigned_long(&vcap) == Numeric_constant::NC_UL_VALID)\n             {\n-              // Turn it into a slice expression of an addressable array,\n-              // which is allocated on stack.\n+\t      // Stack allocate an array and make a slice value from it.\n               Location loc = expr->location();\n               Type* elmt_type = expr->type()->array_type()->element_type();\n               Expression* len_expr =\n                 Expression::make_integer_ul(vcap, cap_arg->type(), loc);\n               Type* array_type = Type::make_array_type(elmt_type, len_expr);\n               Expression* alloc = Expression::make_allocation(array_type, loc);\n               alloc->allocation_expression()->set_allocate_on_stack();\n-              Expression* array = Expression::make_unary(OPERATOR_MULT, alloc, loc);\n-              Expression* zero = Expression::make_integer_ul(0, len_arg->type(), loc);\n-              Expression* slice =\n-                Expression::make_array_index(array, zero, len_arg, cap_arg, loc);\n+\t      Type* ptr_type = Type::make_pointer_type(elmt_type);\n+\t      Expression* ptr = Expression::make_unsafe_cast(ptr_type, alloc,\n+\t\t\t\t\t\t\t     loc);\n+\t      Expression* slice =\n+\t\tExpression::make_slice_value(expr->type(), ptr, len_arg,\n+\t\t\t\t\t     cap_arg, loc);\n               *pexpr = slice;\n             }\n         }"}, {"sha": "6fe892b46f40a8ef928ee5a85e01e78d1c07cf83", "filename": "libgo/go/runtime/pprof/mprof_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fmprof_test.go?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -45,7 +45,7 @@ func allocatePersistent1K() {\n // Allocate transient memory using reflect.Call.\n \n func allocateReflectTransient() {\n-\tmemSink = make([]byte, 2<<20)\n+\tmemSink = make([]byte, 3<<20)\n }\n \n func allocateReflect() {\n@@ -106,7 +106,7 @@ func TestMemoryProfiler(t *testing.T) {\n \t\t// GC means that sometimes the value is not collected.\n \t\tfmt.Sprintf(`(0|%v): (0|%v) \\[%v: %v\\] @( 0x[0-9,a-f]+)+\n #\t0x[0-9,a-f]+\tpprof\\.allocateReflectTransient\\+0x[0-9,a-f]+\t.*/mprof_test.go:48\n-`, memoryProfilerRun, (2<<20)*memoryProfilerRun, memoryProfilerRun, (2<<20)*memoryProfilerRun),\n+`, memoryProfilerRun, (3<<20)*memoryProfilerRun, memoryProfilerRun, (3<<20)*memoryProfilerRun),\n \t}\n \n \tfor _, test := range tests {"}, {"sha": "7f9db4efa9ef9e858e824ce77d97913cbed79a3c", "filename": "libgo/go/runtime/slice.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fdcef314bcb0728d883cd87d6950d85217e82755/libgo%2Fgo%2Fruntime%2Fslice.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fdcef314bcb0728d883cd87d6950d85217e82755/libgo%2Fgo%2Fruntime%2Fslice.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fslice.go?ref=fdcef314bcb0728d883cd87d6950d85217e82755", "patch": "@@ -61,7 +61,7 @@ func panicmakeslicecap() {\n \tpanic(errorString(\"makeslice: cap out of range\"))\n }\n \n-func makeslice(et *_type, len, cap int) slice {\n+func makeslice(et *_type, len, cap int) unsafe.Pointer {\n \t// NOTE: The len > maxElements check here is not strictly necessary,\n \t// but it produces a 'len out of range' error instead of a 'cap out of range' error\n \t// when someone does make([]T, bignumber). 'cap out of range' is true too,\n@@ -76,11 +76,10 @@ func makeslice(et *_type, len, cap int) slice {\n \t\tpanicmakeslicecap()\n \t}\n \n-\tp := mallocgc(et.size*uintptr(cap), et, true)\n-\treturn slice{p, len, cap}\n+\treturn mallocgc(et.size*uintptr(cap), et, true)\n }\n \n-func makeslice64(et *_type, len64, cap64 int64) slice {\n+func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {\n \tlen := int(len64)\n \tif int64(len) != len64 {\n \t\tpanicmakeslicelen()"}]}