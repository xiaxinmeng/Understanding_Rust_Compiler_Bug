{"sha": "73a39fc4f1af4b546dea1873804242abe51316f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzNhMzlmYzRmMWFmNGI1NDZkZWExODczODA0MjQyYWJlNTEzMTZmNQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-03-31T22:16:54Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-03-31T22:16:54Z"}, "message": "combine.c (can_combine_p): Allow ZERO_EXTRACT and STRICT_LOW_PART.\n\n2003-03-31  Eric Christopher  <echristo@redhat.com>\n\n\t* combine.c (can_combine_p): Allow ZERO_EXTRACT and STRICT_LOW_PART.\n\t(combinable_i3pat): Remove call to expand_field_assignment and\n\t#if 0'd code.\n\nFrom-SVN: r65118", "tree": {"sha": "3461f674fdb0efb8b2555fe1bccfee7eb4282728", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3461f674fdb0efb8b2555fe1bccfee7eb4282728"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a39fc4f1af4b546dea1873804242abe51316f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a39fc4f1af4b546dea1873804242abe51316f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a39fc4f1af4b546dea1873804242abe51316f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a39fc4f1af4b546dea1873804242abe51316f5/comments", "author": null, "committer": null, "parents": [{"sha": "6b6652197a4e4ee17855e36f38a479896264eed2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b6652197a4e4ee17855e36f38a479896264eed2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b6652197a4e4ee17855e36f38a479896264eed2"}], "stats": {"total": 97, "additions": 35, "deletions": 62}, "files": [{"sha": "01ca1ce7cdeffce126f3618e4d678fe3353bd8aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a39fc4f1af4b546dea1873804242abe51316f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a39fc4f1af4b546dea1873804242abe51316f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73a39fc4f1af4b546dea1873804242abe51316f5", "patch": "@@ -1,3 +1,9 @@\n+2003-03-31  Eric Christopher  <echristo@redhat.com>\n+\n+\t* combine.c (can_combine_p): Allow ZERO_EXTRACT and STRICT_LOW_PART.\n+\t(combinable_i3pat): Remove call to expand_field_assignment and\n+\t#if 0'd code.\n+\n 2003-03-31  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/10278\n@@ -48,7 +54,7 @@\n \tthe pch file are still undefined, read a sorted list of undefined\n \tidentifiers, collect all defined identifiers into a sorted list,\n \tand walk through both lists to make sure there's no match.\n-\t\n+\n 2003-03-31  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* config/h8300/h8300.md (a peephole2): New.\n@@ -175,7 +181,7 @@\n \n         * Makefile.in (STRICT_WARN): Don't warn for ISO C constructs.\n         (STRICT2_WARN): Likewise.\n-\t\n+\n 2003-03-30  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \tPR other/6955\n@@ -211,10 +217,10 @@\n 2003-03-29  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n \n \t* doc/contrib.texi: Add Eric Botcazou and Roger Sayle.\n-\tUniformly use bugfix instead of bug fix. \n+\tUniformly use bugfix instead of bug fix.\n \n 2003-03-29  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n-\t\n+\n \tPR doc/895\n \t* ONEWS: Remove those items that already appear in the EGCS\n \trelease notes on our web pages.\n@@ -254,7 +260,7 @@\n \n 2003-03-28  Ulrich Weigand  <uweigand@de.ibm.com>\n \n-\t* config/s390/s390.md (\"literal_pool_31\"): Output pool anchor \n+\t* config/s390/s390.md (\"literal_pool_31\"): Output pool anchor\n \tlabel even if pool empty when generating PIC.\n \t(\"literal_pool_31\", \"literal_pool_64\"): Coding style cleanup.\n \n@@ -282,7 +288,7 @@\n \t* config/alpha/elf.h (ASM_OUTPUT_ALIGNED_BSS): Remove unnecessary\n \tglobalize_label.\n \t* config/arm/unknown-elf.h (ASM_OUTPUT_ALIGNED_BSS): Likewise.\n-\t* config/i960/i960.h (ASM_OUTPUT_ALIGNED_BSS): Likewise. \n+\t* config/i960/i960.h (ASM_OUTPUT_ALIGNED_BSS): Likewise.\n \t* config/m32r/m32r.h (ASM_OUTPUT_ALIGNED_BSS): Likewise.\n \t* config/mips/elf.h (ASM_OUTPUT_ALIGNED_BSS): Likewise.\n \t* config/mips/linux.h (ASM_OUTPUT_ALIGNED_BSS): Likewise.\n@@ -381,7 +387,7 @@\n 2003-03-26  Vladimir Makarov  <vmakarov@redhat.com>\n \n         * config/rs6000/8540.md: New file.\n-\t\n+\n \t* config/rs6000/{40x.md, 603.md, 6xx.md, 7450.md, 7xx.md, mpc.md,\n \tpower4.md, rios1.md, rios2.md, rs64.md}: Add mult_compare to\n \treservations for imul.\n@@ -409,7 +415,7 @@\n \tof fpcompare.\n \t(tstsfeq_gpr, tstsfgt_gpr, tstsflt_gpr): Use type veccmpsimple\n \tinstead of fpcompare.\n-\t\t\n+\n 2003-03-26  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/power4.md: Allow delay between dispatch and\n@@ -500,7 +506,7 @@ Mon Mar 24 20:03:03 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t(\"*return_32bit\"): Likewise.\n \t* config/m68hc11/m68hc11.h (ASM_DECLARE_FUNCTION_NAME): Generate .far\n \tfor 68HC11 too.\n-\t(DWARF2_ADDR_SIZE): Use 4 so that addresses can \n+\t(DWARF2_ADDR_SIZE): Use 4 so that addresses can\n \t* config/m68hc11/m68hc11.c (m68hc11_override_options): Accept\n \t-mlong-calls for 68HC11.\n \t* config/m68hc11/larith.asm (declare_near): New macro.\n@@ -9596,4 +9602,3 @@ Mon Mar 24 20:03:03 CET 2003  Jan Hubicka  <jh@suse.cz>\n \t* doc/tm.texi (REGISTER_TARGET_PRAGMAS): Update\n \n See ChangeLog.8 for earlier changes.\n-"}, {"sha": "a36ee033e958190cf2ed2b2299251518fef8091e", "filename": "gcc/combine.c", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a39fc4f1af4b546dea1873804242abe51316f5/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a39fc4f1af4b546dea1873804242abe51316f5/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=73a39fc4f1af4b546dea1873804242abe51316f5", "patch": "@@ -1065,8 +1065,6 @@ can_combine_p (insn, i3, pred, succ, pdest, psrc)\n \n   /* Don't eliminate a store in the stack pointer.  */\n   if (dest == stack_pointer_rtx\n-      /* If we couldn't eliminate a field assignment, we can't combine.  */\n-      || GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == STRICT_LOW_PART\n       /* Don't combine with an insn that sets a register to itself if it has\n \t a REG_EQUAL note.  This may be part of a REG_NO_CONFLICT sequence.  */\n       || (rtx_equal_p (src, dest) && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n@@ -1319,46 +1317,16 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n \n   if (GET_CODE (x) == SET)\n     {\n-      rtx set = expand_field_assignment (x);\n+      rtx set = x ;\n       rtx dest = SET_DEST (set);\n       rtx src = SET_SRC (set);\n       rtx inner_dest = dest;\n \n-#if 0\n-      rtx inner_src = src;\n-#endif\n-\n-      SUBST (*loc, set);\n-\n       while (GET_CODE (inner_dest) == STRICT_LOW_PART\n \t     || GET_CODE (inner_dest) == SUBREG\n \t     || GET_CODE (inner_dest) == ZERO_EXTRACT)\n \tinner_dest = XEXP (inner_dest, 0);\n \n-  /* We probably don't need this any more now that LIMIT_RELOAD_CLASS\n-     was added.  */\n-#if 0\n-      while (GET_CODE (inner_src) == STRICT_LOW_PART\n-\t     || GET_CODE (inner_src) == SUBREG\n-\t     || GET_CODE (inner_src) == ZERO_EXTRACT)\n-\tinner_src = XEXP (inner_src, 0);\n-\n-      /* If it is better that two different modes keep two different pseudos,\n-\t avoid combining them.  This avoids producing the following pattern\n-\t on a 386:\n-\t  (set (subreg:SI (reg/v:QI 21) 0)\n-\t       (lshiftrt:SI (reg/v:SI 20)\n-\t           (const_int 24)))\n-\t If that were made, reload could not handle the pair of\n-\t reg 20/21, since it would try to get any GENERAL_REGS\n-\t but some of them don't handle QImode.  */\n-\n-      if (rtx_equal_p (inner_src, i2dest)\n-\t  && GET_CODE (inner_dest) == REG\n-\t  && ! MODES_TIEABLE_P (GET_MODE (i2dest), GET_MODE (inner_dest)))\n-\treturn 0;\n-#endif\n-\n       /* Check for the case where I3 modifies its output, as\n \t discussed above.  */\n       if ((inner_dest != dest\n@@ -1689,7 +1657,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t    abort ();\n \n \t  lo &= ~(UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1);\n-\t  lo |= (INTVAL (SET_SRC (PATTERN (i3))) \n+\t  lo |= (INTVAL (SET_SRC (PATTERN (i3)))\n \t\t & (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1));\n \t}\n       else if (HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n@@ -2856,7 +2824,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t    || GET_CODE (temp) != BARRIER)\n \t  emit_barrier_after (undobuf.other_insn);\n       }\n-\t\n+\n     /* An NOOP jump does not need barrier, but it does need cleaning up\n        of CFG.  */\n     if (GET_CODE (newpat) == SET\n@@ -4044,7 +4012,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  return gen_binary (MINUS, mode, temp, XEXP (XEXP (x, 0), 1));\n \t}\n \n-      /* (neg (mult A B)) becomes (mult (neg A) B).  \n+      /* (neg (mult A B)) becomes (mult (neg A) B).\n          This works even for floating-point values.  */\n       if (GET_CODE (XEXP (x, 0)) == MULT)\n \t{\n@@ -4185,14 +4153,14 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == mode)\n \treturn XEXP (XEXP (x, 0), 0);\n \n-      /* (float_truncate:SF (float_truncate:DF foo:XF)) \n-         = (float_truncate:SF foo:XF). \n+      /* (float_truncate:SF (float_truncate:DF foo:XF))\n+         = (float_truncate:SF foo:XF).\n \t This may elliminate double rounding, so it is unsafe.\n \n-         (float_truncate:SF (float_extend:XF foo:DF)) \n-         = (float_truncate:SF foo:DF). \n+         (float_truncate:SF (float_extend:XF foo:DF))\n+         = (float_truncate:SF foo:DF).\n \n-         (float_truncate:DF (float_extend:XF foo:SF)) \n+         (float_truncate:DF (float_extend:XF foo:SF))\n          = (float_extend:SF foo:DF).  */\n       if ((GET_CODE (XEXP (x, 0)) == FLOAT_TRUNCATE\n \t   && flag_unsafe_math_optimizations)\n@@ -4233,9 +4201,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       break;\n     case FLOAT_EXTEND:\n       /*  (float_extend (float_extend x)) is (float_extend x)\n-        \n+\n \t  (float_extend (float x)) is (float x) assuming that double\n-\t  rounding can't happen. \n+\t  rounding can't happen.\n           */\n       if (GET_CODE (XEXP (x, 0)) == FLOAT_EXTEND\n \t  || (GET_CODE (XEXP (x, 0)) == FLOAT\n@@ -4288,11 +4256,11 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n     case PLUS:\n       /* Canonicalize (plus (mult (neg B) C) A) to (minus A (mult B C)).\n        */\n-      if (GET_CODE (XEXP (x, 0)) == MULT \n+      if (GET_CODE (XEXP (x, 0)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == NEG)\n \t{\n \t  rtx in1, in2;\n-\t \n+\n \t  in1 = XEXP (XEXP (XEXP (x, 0), 0), 0);\n \t  in2 = XEXP (XEXP (x, 0), 1);\n \t  return gen_binary (MINUS, mode, XEXP (x, 1),\n@@ -4407,24 +4375,24 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n       /* Canonicalize (minus A (mult (neg B) C)) to (plus (mult B C) A).\n        */\n-      if (GET_CODE (XEXP (x, 1)) == MULT \n+      if (GET_CODE (XEXP (x, 1)) == MULT\n \t  && GET_CODE (XEXP (XEXP (x, 1), 0)) == NEG)\n \t{\n \t  rtx in1, in2;\n-\t \n+\n \t  in1 = XEXP (XEXP (XEXP (x, 1), 0), 0);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n \t  return gen_binary (PLUS, mode, gen_binary (MULT, mode, in1, in2),\n \t\t\t     XEXP (x, 0));\n \t}\n \n-      /* Canonicalize (minus (neg A) (mult B C)) to \n+      /* Canonicalize (minus (neg A) (mult B C)) to\n \t (minus (mult (neg B) C) A).  */\n-      if (GET_CODE (XEXP (x, 1)) == MULT \n+      if (GET_CODE (XEXP (x, 1)) == MULT\n \t  && GET_CODE (XEXP (x, 0)) == NEG)\n \t{\n \t  rtx in1, in2;\n-\t \n+\n \t  in1 = simplify_gen_unary (NEG, mode, XEXP (XEXP (x, 1), 0), mode);\n \t  in2 = XEXP (XEXP (x, 1), 1);\n \t  return gen_binary (MINUS, mode, gen_binary (MULT, mode, in1, in2),\n@@ -5313,7 +5281,7 @@ simplify_set (x)\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (GET_CODE (dest) == REG && REGNO (dest) < FIRST_PSEUDO_REGISTER\n \t    && REG_CANNOT_CHANGE_MODE_P (REGNO (dest),\n-\t\t\t\t\t GET_MODE (SUBREG_REG (src)), \n+\t\t\t\t\t GET_MODE (SUBREG_REG (src)),\n \t\t\t\t\t GET_MODE (src)))\n #endif\n       && (GET_CODE (dest) == REG\n@@ -11594,7 +11562,7 @@ update_table_tick (x)\n \t\tbreak;\n \t      }\n \t  }\n-\t  \n+\n \tupdate_table_tick (XEXP (x, i));\n       }\n }"}]}