{"sha": "f822d2527eda821d7faeab8370a896d4591a100d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyMmQyNTI3ZWRhODIxZDdmYWVhYjgzNzBhODk2ZDQ1OTFhMTAwZA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@codesourcery.com", "date": "2004-08-18T17:05:14Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-08-18T17:05:14Z"}, "message": "rtl.def (NIL): Delete.\n\n\t* rtl.def (NIL): Delete.\n\t* read-rtl.c (read_rtx): Handle (nil) like (define_constants).\n\tTighten the syntax a little.\n\n\t* cfgloop.h, combine.c, cse.c, loop-iv.c, postreload.c, reload.c\n\t* config/alpha/alpha.c, config/alpha/alpha.h, config/arc/arc.h\n\t* config/arm/arm.h, config/frv/frv.h, config/i386/i386.c\n\t* config/i386/predicates.md, config/m32r/m32r.h\n\t* config/m68hc11/m68hc11.c, config/mcore/mcore.h, config/mips/mips.c\n\t* config/mmix/mmix.c, config/pa/pa.h, config/sh/sh.h\n\t* config/sparc/sparc.h, doc/tm.texi:\n\tReplace all occurrences of NIL with UNKNOWN.\n\nFrom-SVN: r86193", "tree": {"sha": "f6d253960bbff5f5f18a47a866cab10b8ece1664", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6d253960bbff5f5f18a47a866cab10b8ece1664"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f822d2527eda821d7faeab8370a896d4591a100d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f822d2527eda821d7faeab8370a896d4591a100d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f822d2527eda821d7faeab8370a896d4591a100d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f822d2527eda821d7faeab8370a896d4591a100d/comments", "author": null, "committer": null, "parents": [{"sha": "6aaf3ddef9a6fccf796ff13c7a03952c5d350158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6aaf3ddef9a6fccf796ff13c7a03952c5d350158", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6aaf3ddef9a6fccf796ff13c7a03952c5d350158"}], "stats": {"total": 274, "additions": 143, "deletions": 131}, "files": [{"sha": "bc3d3b2f8ed41a7ceb3772e75c80d09f7831c52d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1,3 +1,18 @@\n+2004-08-18  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* rtl.def (NIL): Delete.\n+\t* read-rtl.c (read_rtx): Handle (nil) like (define_constants).\n+\tTighten the syntax a little.\n+\n+\t* cfgloop.h, combine.c, cse.c, loop-iv.c, postreload.c, reload.c\n+\t* config/alpha/alpha.c, config/alpha/alpha.h, config/arc/arc.h\n+\t* config/arm/arm.h, config/frv/frv.h, config/i386/i386.c\n+\t* config/i386/predicates.md, config/m32r/m32r.h\n+\t* config/m68hc11/m68hc11.c, config/mcore/mcore.h, config/mips/mips.c\n+\t* config/mmix/mmix.c, config/pa/pa.h, config/sh/sh.h\n+\t* config/sparc/sparc.h, doc/tm.texi:\n+\tReplace all occurrences of NIL with UNKNOWN.\n+\n 2004-08-18  Zack Weinberg  <zack@codesourcery.com>\n \n \t* dojump.c (do_jump <unordered_bcc>): Do not recursively call"}, {"sha": "c2be07dc8f29e50fef81f4dce8949cb52df0fdca", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -330,7 +330,7 @@ extern edge split_loop_bb (basic_block, rtx);\n    If first_special is true, the value in the first iteration is\n      delta + mult * base\n      \n-   If extend = NIL, first_special must be false, delta 0, mult 1 and value is\n+   If extend = UNKNOWN, first_special must be false, delta 0, mult 1 and value is\n      subreg_{mode} (base + i * step)\n \n    The get_iv_value function can be used to obtain these expressions.\n@@ -345,7 +345,7 @@ struct rtx_iv\n      see the description above).  */\n   rtx base, step;\n \n-  /* The type of extend applied to it (SIGN_EXTEND, ZERO_EXTEND or NIL).  */\n+  /* The type of extend applied to it (SIGN_EXTEND, ZERO_EXTEND or UNKNOWN).  */\n   enum rtx_code extend;\n \n   /* Operations applied in the extended mode.  */"}, {"sha": "426b0d775e5818b259b2c350e5a52762e14431c9", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -4926,7 +4926,7 @@ simplify_if_then_else (rtx x)\n       rtx f = make_compound_operation (false_rtx, SET);\n       rtx cond_op0 = XEXP (cond, 0);\n       rtx cond_op1 = XEXP (cond, 1);\n-      enum rtx_code op = NIL, extend_op = NIL;\n+      enum rtx_code op = UNKNOWN, extend_op = UNKNOWN;\n       enum machine_mode m = mode;\n       rtx z = 0, c1 = NULL_RTX;\n \n@@ -5025,7 +5025,7 @@ simplify_if_then_else (rtx x)\n \t  temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n \t  temp = gen_binary (op, m, gen_lowpart (m, z), temp);\n \n-\t  if (extend_op != NIL)\n+\t  if (extend_op != UNKNOWN)\n \t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n \n \t  return temp;\n@@ -5319,7 +5319,7 @@ simplify_set (rtx x)\n      zero_extend to avoid the reload that would otherwise be required.  */\n \n   if (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)\n-      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != NIL\n+      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))) != UNKNOWN\n       && SUBREG_BYTE (src) == 0\n       && (GET_MODE_SIZE (GET_MODE (src))\n \t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n@@ -8285,7 +8285,7 @@ extended_count (rtx x, enum machine_mode mode, int unsignedp)\n    the width of this mode matter.  It is assumed that the width of this mode\n    is smaller than or equal to HOST_BITS_PER_WIDE_INT.\n \n-   If *POP0 or OP1 are NIL, it means no operation is required.  Only NEG, PLUS,\n+   If *POP0 or OP1 are UNKNOWN, it means no operation is required.  Only NEG, PLUS,\n    IOR, XOR, and AND are supported.  We may set *POP0 to SET if the proper\n    result is simply *PCONST0.\n \n@@ -8305,13 +8305,13 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n   if (op0 == AND)\n     const1 &= const0;\n \n-  /* If OP0 or OP1 is NIL, this is easy.  Similarly if they are the same or\n+  /* If OP0 or OP1 is UNKNOWN, this is easy.  Similarly if they are the same or\n      if OP0 is SET.  */\n \n-  if (op1 == NIL || op0 == SET)\n+  if (op1 == UNKNOWN || op0 == SET)\n     return 1;\n \n-  else if (op0 == NIL)\n+  else if (op0 == UNKNOWN)\n     op0 = op1, const0 = const1;\n \n   else if (op0 == op1)\n@@ -8331,7 +8331,7 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n \t  const0 += const1;\n \t  break;\n \tcase NEG:\n-\t  op0 = NIL;\n+\t  op0 = UNKNOWN;\n \t  break;\n \tdefault:\n \t  break;\n@@ -8384,12 +8384,12 @@ merge_outer_ops (enum rtx_code *pop0, HOST_WIDE_INT *pconst0, enum rtx_code op1,\n   const0 &= GET_MODE_MASK (mode);\n   if (const0 == 0\n       && (op0 == IOR || op0 == XOR || op0 == PLUS))\n-    op0 = NIL;\n+    op0 = UNKNOWN;\n   else if (const0 == 0 && op0 == AND)\n     op0 = SET;\n   else if ((unsigned HOST_WIDE_INT) const0 == GET_MODE_MASK (mode)\n \t   && op0 == AND)\n-    op0 = NIL;\n+    op0 = UNKNOWN;\n \n   /* ??? Slightly redundant with the above mask, but not entirely.\n      Moving this above means we'd have to sign-extend the mode mask\n@@ -8423,7 +8423,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n   unsigned int mode_words\n     = (GET_MODE_SIZE (mode) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n   /* We form (outer_op (code varop count) (outer_const)).  */\n-  enum rtx_code outer_op = NIL;\n+  enum rtx_code outer_op = UNKNOWN;\n   HOST_WIDE_INT outer_const = 0;\n   rtx const_rtx;\n   int complement_p = 0;\n@@ -9091,7 +9091,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n \n   /* We have now finished analyzing the shift.  The result should be\n      a shift of type CODE with SHIFT_MODE shifting VAROP COUNT places.  If\n-     OUTER_OP is non-NIL, it is an operation that needs to be applied\n+     OUTER_OP is non-UNKNOWN, it is an operation that needs to be applied\n      to the result of the shift.  OUTER_CONST is the relevant constant,\n      but we must turn off all bits turned off in the shift.\n \n@@ -9127,7 +9127,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n      for the outer operation.  So try to do the simplification\n      recursively.  */\n \n-  if (outer_op != NIL && GET_CODE (x) == code\n+  if (outer_op != UNKNOWN && GET_CODE (x) == code\n       && GET_CODE (XEXP (x, 1)) == CONST_INT)\n     x = simplify_shift_const (x, code, shift_mode, XEXP (x, 0),\n \t\t\t      INTVAL (XEXP (x, 1)));\n@@ -9146,7 +9146,7 @@ simplify_shift_const (rtx x, enum rtx_code code,\n   if (complement_p)\n     x = simplify_gen_unary (NOT, result_mode, x, result_mode);\n \n-  if (outer_op != NIL)\n+  if (outer_op != UNKNOWN)\n     {\n       if (GET_MODE_BITSIZE (result_mode) < HOST_BITS_PER_WIDE_INT)\n \touter_const = trunc_int_for_mode (outer_const, result_mode);\n@@ -10506,7 +10506,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n      those bits.\n \n      3. SUBREG_REG (op0) is a memory and LOAD_EXTEND_OP is defined and not\n-     NIL.  In that case we know those bits are zeros or ones.  We must\n+     UNKNOWN.  In that case we know those bits are zeros or ones.  We must\n      also be sure that they are the same as the upper bits of op1.\n \n      We can never remove a SUBREG for a non-equality comparison because"}, {"sha": "1ecd836a6fa4e3cb60783632ebb43534c46fe30c", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2321,13 +2321,13 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \t  /* When we are not as concerned about non-finite values, and we\n \t     are comparing against zero, we can branch directly.  */\n \t  if (op1 == CONST0_RTX (DFmode))\n-\t    cmp_code = NIL, branch_code = code;\n+\t    cmp_code = UNKNOWN, branch_code = code;\n \t  else if (op0 == CONST0_RTX (DFmode))\n \t    {\n \t      /* Undo the swap we probably did just above.  */\n \t      tem = op0, op0 = op1, op1 = tem;\n \t      branch_code = swap_condition (cmp_code);\n-\t      cmp_code = NIL;\n+\t      cmp_code = UNKNOWN;\n \t    }\n \t}\n       else\n@@ -2347,7 +2347,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \t{\n \t  /* Whee.  Compare and branch against 0 directly.  */\n \t  if (op1 == const0_rtx)\n-\t    cmp_code = NIL, branch_code = code;\n+\t    cmp_code = UNKNOWN, branch_code = code;\n \n \t  /* If the constants doesn't fit into an immediate, but can\n  \t     be generated by lda/ldah, we adjust the argument and\n@@ -2380,7 +2380,7 @@ alpha_emit_conditional_branch (enum rtx_code code)\n \n   /* Emit an initial compare instruction, if necessary.  */\n   tem = op0;\n-  if (cmp_code != NIL)\n+  if (cmp_code != UNKNOWN)\n     {\n       tem = gen_reg_rtx (cmp_mode);\n       emit_move_insn (tem, gen_rtx_fmt_ee (cmp_code, cmp_mode, op0, op1));\n@@ -2441,7 +2441,7 @@ alpha_emit_setcc (enum rtx_code code)\n   /* The general case: fold the comparison code to the types of compares\n      that we have, choosing the branch as necessary.  */\n \n-  cmp_code = NIL;\n+  cmp_code = UNKNOWN;\n   switch (code)\n     {\n     case EQ:  case LE:  case LT:  case LEU:  case LTU:\n@@ -2485,7 +2485,7 @@ alpha_emit_setcc (enum rtx_code code)\n     }\n \n   /* Emit an initial compare instruction, if necessary.  */\n-  if (cmp_code != NIL)\n+  if (cmp_code != UNKNOWN)\n     {\n       enum machine_mode mode = fp_p ? DFmode : DImode;\n "}, {"sha": "37d53f58f3d80fb948a6fa4fc6c39f5896fdbb97", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1370,7 +1370,7 @@ do {\t\t\t\t\t\t\t\t\t     \\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ((MODE) == SImode ? SIGN_EXTEND : ZERO_EXTEND)\n \n /* Define if loading short immediate values into registers sign extends.  */"}, {"sha": "eefac0ce212dbed70c563bbdea8eb1a7a7681b10", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1155,7 +1155,7 @@ do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Max number of bytes we can move from memory to memory"}, {"sha": "135a5743ac682ddfead50bb675921089892ffec4", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2217,11 +2217,11 @@ do {\t\t\t\t\t\t\t\\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE)\t\t\t\t\t\t\\\n   (TARGET_THUMB ? ZERO_EXTEND :\t\t\t\t\t\t\\\n    ((arm_arch4 || (MODE) == QImode) ? ZERO_EXTEND\t\t\t\\\n-    : ((BYTES_BIG_ENDIAN && (MODE) == HImode) ? SIGN_EXTEND : NIL)))\n+    : ((BYTES_BIG_ENDIAN && (MODE) == HImode) ? SIGN_EXTEND : UNKNOWN)))\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n #define SLOW_BYTE_ACCESS 0"}, {"sha": "bb960e62d702426886a51c42960136d1a99d417d", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -3089,12 +3089,12 @@ do {                                                                    \\\n    memory in MODE, an integral mode narrower than a word, set the bits outside\n    of MODE to be either the sign-extension or the zero-extension of the data\n    read.  Return `SIGN_EXTEND' for values of MODE for which the insn\n-   sign-extends, `ZERO_EXTEND' for which it zero-extends, and `NIL' for other\n+   sign-extends, `ZERO_EXTEND' for which it zero-extends, and `UNKNOWN' for other\n    modes.\n \n    This macro is not called with MODE non-integral or with a width greater than\n    or equal to `BITS_PER_WORD', so you may return any value in this case.  Do\n-   not define this macro if it would always return `NIL'.  On machines where\n+   not define this macro if it would always return `UNKNOWN'.  On machines where\n    this macro is defined, you will normally define it as the constant\n    `SIGN_EXTEND' or `ZERO_EXTEND'.  */\n #define LOAD_EXTEND_OP(MODE) SIGN_EXTEND"}, {"sha": "50e56ad5dd7a0035f17df1d8ade9501eebdd2169", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -6016,7 +6016,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,\n     {\n       enum rtx_code second_code, bypass_code;\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != NIL || second_code != NIL)\n+      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n \tabort ();\n       code = ix86_fp_compare_code_to_integer (code);\n       mode = CCmode;\n@@ -7961,7 +7961,7 @@ ix86_fp_compare_code_to_integer (enum rtx_code code)\n /* Split comparison code CODE into comparisons we can do using branch\n    instructions.  BYPASS_CODE is comparison code for branch that will\n    branch around FIRST_CODE and SECOND_CODE.  If some of branches\n-   is not required, set value to NIL.\n+   is not required, set value to UNKNOWN.\n    We never require more than two branches.  */\n \n void\n@@ -7970,8 +7970,8 @@ ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *bypass_code,\n \t\t\t  enum rtx_code *second_code)\n {\n   *first_code = code;\n-  *bypass_code = NIL;\n-  *second_code = NIL;\n+  *bypass_code = UNKNOWN;\n+  *second_code = UNKNOWN;\n \n   /* The fcomi comparison sets flags as follows:\n \n@@ -8021,8 +8021,8 @@ ix86_fp_comparison_codes (enum rtx_code code, enum rtx_code *bypass_code,\n     }\n   if (!TARGET_IEEE_FP)\n     {\n-      *second_code = NIL;\n-      *bypass_code = NIL;\n+      *second_code = UNKNOWN;\n+      *bypass_code = UNKNOWN;\n     }\n }\n \n@@ -8074,7 +8074,7 @@ ix86_fp_comparison_fcomi_cost (enum rtx_code code)\n   if (!TARGET_CMOVE)\n     return 1024;\n   ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return (bypass_code != NIL || second_code != NIL) + 2;\n+  return (bypass_code != UNKNOWN || second_code != UNKNOWN) + 2;\n }\n \n /* Return cost of comparison done using sahf operation.\n@@ -8088,7 +8088,7 @@ ix86_fp_comparison_sahf_cost (enum rtx_code code)\n   if (!TARGET_USE_SAHF && !optimize_size)\n     return 1024;\n   ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return (bypass_code != NIL || second_code != NIL) + 3;\n+  return (bypass_code != UNKNOWN || second_code != UNKNOWN) + 3;\n }\n \n /* Compute cost of the comparison done using any method.\n@@ -8132,8 +8132,8 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n   ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n \n   /* Do fcomi/sahf based test when profitable.  */\n-  if ((bypass_code == NIL || bypass_test)\n-      && (second_code == NIL || second_test)\n+  if ((bypass_code == UNKNOWN || bypass_test)\n+      && (second_code == UNKNOWN || second_test)\n       && ix86_fp_comparison_arithmetics_cost (code) > cost)\n     {\n       if (TARGET_CMOVE)\n@@ -8156,11 +8156,11 @@ ix86_expand_fp_compare (enum rtx_code code, rtx op0, rtx op1, rtx scratch,\n       /* The FP codes work out to act like unsigned.  */\n       intcmp_mode = fpcmp_mode;\n       code = first_code;\n-      if (bypass_code != NIL)\n+      if (bypass_code != UNKNOWN)\n \t*bypass_test = gen_rtx_fmt_ee (bypass_code, VOIDmode,\n \t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n \t\t\t\t       const0_rtx);\n-      if (second_code != NIL)\n+      if (second_code != UNKNOWN)\n \t*second_test = gen_rtx_fmt_ee (second_code, VOIDmode,\n \t\t\t\t       gen_rtx_REG (intcmp_mode, FLAGS_REG),\n \t\t\t\t       const0_rtx);\n@@ -8326,7 +8326,7 @@ ix86_fp_jump_nontrivial_p (enum rtx_code code)\n   if (!TARGET_CMOVE)\n     return true;\n   ix86_fp_comparison_codes (code, &bypass_code, &first_code, &second_code);\n-  return bypass_code != NIL || second_code != NIL;\n+  return bypass_code != UNKNOWN || second_code != UNKNOWN;\n }\n \n void\n@@ -8363,7 +8363,7 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t/* Check whether we will use the natural sequence with one jump.  If\n \t   so, we can expand jump early.  Otherwise delay expansion by\n \t   creating compound insn to not confuse optimizers.  */\n-\tif (bypass_code == NIL && second_code == NIL\n+\tif (bypass_code == UNKNOWN && second_code == UNKNOWN\n \t    && TARGET_CMOVE)\n \t  {\n \t    ix86_split_fp_branch (code, ix86_compare_op0, ix86_compare_op1,\n@@ -8476,8 +8476,8 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \t  case LEU:  code1 = LTU; code2 = GTU; break;\n \t  case GEU:  code1 = GTU; code2 = LTU; break;\n \n-\t  case EQ:   code1 = NIL; code2 = NE;  break;\n-\t  case NE:   code2 = NIL; break;\n+\t  case EQ:   code1 = UNKNOWN; code2 = NE;  break;\n+\t  case NE:   code2 = UNKNOWN; break;\n \n \t  default:\n \t    abort ();\n@@ -8494,16 +8494,16 @@ ix86_expand_branch (enum rtx_code code, rtx label)\n \tix86_compare_op0 = hi[0];\n \tix86_compare_op1 = hi[1];\n \n-\tif (code1 != NIL)\n+\tif (code1 != UNKNOWN)\n \t  ix86_expand_branch (code1, label);\n-\tif (code2 != NIL)\n+\tif (code2 != UNKNOWN)\n \t  ix86_expand_branch (code2, label2);\n \n \tix86_compare_op0 = lo[0];\n \tix86_compare_op1 = lo[1];\n \tix86_expand_branch (code3, label);\n \n-\tif (code2 != NIL)\n+\tif (code2 != UNKNOWN)\n \t  emit_label (label2);\n \treturn;\n       }\n@@ -8968,7 +8968,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t    }\n \t}\n \n-      compare_code = NIL;\n+      compare_code = UNKNOWN;\n       if (GET_MODE_CLASS (GET_MODE (ix86_compare_op0)) == MODE_INT\n \t  && GET_CODE (ix86_compare_op1) == CONST_INT)\n \t{\n@@ -8985,7 +8985,7 @@ ix86_expand_int_movcc (rtx operands[])\n \t}\n \n       /* Optimize dest = (op0 < 0) ? -1 : cf.  */\n-      if (compare_code != NIL\n+      if (compare_code != UNKNOWN\n \t  && GET_MODE (ix86_compare_op0) == GET_MODE (out)\n \t  && (cf == -1 || ct == -1))\n \t{\n@@ -9113,12 +9113,12 @@ ix86_expand_int_movcc (rtx operands[])\n \t      else\n \t\t{\n \t\t  code = reverse_condition (code);\n-\t\t  if (compare_code != NIL)\n+\t\t  if (compare_code != UNKNOWN)\n \t\t    compare_code = reverse_condition (compare_code);\n \t\t}\n \t    }\n \n-\t  if (compare_code != NIL)\n+\t  if (compare_code != UNKNOWN)\n \t    {\n \t      /* notl op1\t(if needed)\n \t\t sarl $31, op1"}, {"sha": "220b01c81ccb91e976f0912265e19096e214fc24", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -671,7 +671,7 @@\n     {\n       enum rtx_code second_code, bypass_code;\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != NIL || second_code != NIL)\n+      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n \treturn 0;\n       code = ix86_fp_compare_code_to_integer (code);\n     }\n@@ -715,7 +715,7 @@\n     {\n       enum rtx_code second_code, bypass_code;\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      return (bypass_code == NIL && second_code == NIL);\n+      return (bypass_code == UNKNOWN && second_code == UNKNOWN);\n     }\n   switch (code)\n     {\n@@ -755,7 +755,7 @@\n     {\n       enum rtx_code second_code, bypass_code;\n       ix86_fp_comparison_codes (code, &bypass_code, &code, &second_code);\n-      if (bypass_code != NIL || second_code != NIL)\n+      if (bypass_code != UNKNOWN || second_code != UNKNOWN)\n \treturn 0;\n       code = ix86_fp_compare_code_to_integer (code);\n     }"}, {"sha": "948ba2a568546ddbb4a5d67b9a4fd2af9dbc8b36", "filename": "gcc/config/m32r/m32r.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fm32r%2Fm32r.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1712,7 +1712,7 @@ extern char m32r_punct_chars[256];\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Max number of bytes we can move from memory"}, {"sha": "e719ee17bd588a1af17d44c882c740898b1df5b1", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2782,11 +2782,11 @@ m68hc11_expand_compare_and_branch (enum rtx_code code, rtx op0, rtx op1,\n \t    break;\n \n \t  case EQ:\n-\t    code1 = NIL;\n+\t    code1 = UNKNOWN;\n \t    code2 = NE;\n \t    break;\n \t  case NE:\n-\t    code2 = NIL;\n+\t    code2 = UNKNOWN;\n \t    break;\n \n \t  default:\n@@ -2800,14 +2800,14 @@ m68hc11_expand_compare_and_branch (enum rtx_code code, rtx op0, rtx op1,\n \t *    if (lo(a) < lo(b)) goto true;\n \t *  false:\n \t */\n-\tif (code1 != NIL)\n+\tif (code1 != UNKNOWN)\n \t  m68hc11_expand_compare_and_branch (code1, hi[0], hi[1], label);\n-\tif (code2 != NIL)\n+\tif (code2 != UNKNOWN)\n \t  m68hc11_expand_compare_and_branch (code2, hi[0], hi[1], label2);\n \n \tm68hc11_expand_compare_and_branch (code3, lo[0], lo[1], label);\n \n-\tif (code2 != NIL)\n+\tif (code2 != UNKNOWN)\n \t  emit_label (label2);\n \treturn 0;\n       }"}, {"sha": "3b78d7fcf1dc57cac3f16229010965463163e4e0", "filename": "gcc/config/mcore/mcore.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmcore%2Fmcore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -901,7 +901,7 @@ extern const enum reg_class reg_class_from_letter[];\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */"}, {"sha": "148bf27e402aa9a09ee7d8b143cfb2ae51cf5f3c", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1515,7 +1515,7 @@ mips_build_integer (struct mips_integer_op *codes,\n       || LUI_OPERAND (value))\n     {\n       /* The value can be loaded with a single instruction.  */\n-      codes[0].code = NIL;\n+      codes[0].code = UNKNOWN;\n       codes[0].value = value;\n       return 1;\n     }"}, {"sha": "6c5a193b2278c425fa6f330f77f913c86a341d7a", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2701,12 +2701,12 @@ mmix_output_condition (FILE *stream, rtx x, int reversed)\n   {\n     enum machine_mode cc_mode;\n \n-    /* Terminated with {NIL, NULL, NULL} */\n+    /* Terminated with {UNKNOWN, NULL, NULL} */\n     const struct cc_conv *const convs;\n   };\n \n #undef CCEND\n-#define CCEND {NIL, NULL, NULL}\n+#define CCEND {UNKNOWN, NULL, NULL}\n \n   static const struct cc_conv cc_fun_convs[]\n     = {{ORDERED, \"Z\", \"P\"},\n@@ -2764,7 +2764,7 @@ mmix_output_condition (FILE *stream, rtx x, int reversed)\n     {\n       if (mode == cc_convs[i].cc_mode)\n \t{\n-\t  for (j = 0; cc_convs[i].convs[j].cc != NIL; j++)\n+\t  for (j = 0; cc_convs[i].convs[j].cc != UNKNOWN; j++)\n \t    if (cc == cc_convs[i].convs[j].cc)\n \t      {\n \t\tconst char *mmix_cc"}, {"sha": "aefecd20bb40e3008328112a9df408a91ff1afe7", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1720,7 +1720,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */"}, {"sha": "4fd677e3876199351a2c1a41959065eddfacc536", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2133,7 +2133,7 @@ do {\t\t\t\t\t\t\t\t\\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Define if loading short immediate values into registers sign extends.  */"}, {"sha": "a66129aef20bd8c6457bd5923a584e08c8e8e6d3", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2929,13 +2929,13 @@ struct sh_args {\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n /* For SHmedia, we can truncate to QImode easier using zero extension.  */\n /* FP registers can load SImode values, but don't implicitly sign-extend\n    them to DImode.  */\n #define LOAD_EXTEND_OP(MODE) \\\n  (((MODE) == QImode  && TARGET_SHMEDIA) ? ZERO_EXTEND \\\n-  : (MODE) != SImode ? SIGN_EXTEND : NIL)\n+  : (MODE) != SImode ? SIGN_EXTEND : UNKNOWN)\n \n /* Define if loading short immediate values into registers sign extends.  */\n #define SHORT_IMMEDIATES_SIGN_EXTEND"}, {"sha": "719900b14d7609863bb59d26320b0e0ddfc638cc", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -2246,7 +2246,7 @@ do {                                                                    \\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none.  */\n+   done, UNKNOWN if none.  */\n #define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n \n /* Nonzero if access to memory by bytes is slow and undesirable."}, {"sha": "93acbe5695cf5ab57b5328aeec8492d7294aa85e", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -5123,7 +5123,7 @@ cse_insn (rtx insn, rtx libcall_insn)\n \t  && (GET_MODE_SIZE (mode) < UNITS_PER_WORD)\n \t  && GET_MODE_CLASS (mode) == MODE_INT\n \t  && MEM_P (src) && ! do_not_record\n-\t  && LOAD_EXTEND_OP (mode) != NIL)\n+\t  && LOAD_EXTEND_OP (mode) != UNKNOWN)\n \t{\n \t  enum machine_mode tmode;\n "}, {"sha": "f35743674934fb8ecacc135a4c7653359395d622", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -8657,21 +8657,21 @@ bits outside of @var{mem_mode} to be either the sign-extension or the\n zero-extension of the data read.  Return @code{SIGN_EXTEND} for values\n of @var{mem_mode} for which the\n insn sign-extends, @code{ZERO_EXTEND} for which it zero-extends, and\n-@code{NIL} for other modes.\n+@code{UNKNOWN} for other modes.\n \n This macro is not called with @var{mem_mode} non-integral or with a width\n greater than or equal to @code{BITS_PER_WORD}, so you may return any\n value in this case.  Do not define this macro if it would always return\n-@code{NIL}.  On machines where this macro is defined, you will normally\n+@code{UNKNOWN}.  On machines where this macro is defined, you will normally\n define it as the constant @code{SIGN_EXTEND} or @code{ZERO_EXTEND}.\n \n-You may return a non-@code{NIL} value even if for some hard registers\n+You may return a non-@code{UNKNOWN} value even if for some hard registers\n the sign extension is not performed, if for the @code{REGNO_REG_CLASS}\n of these hard registers @code{CANNOT_CHANGE_MODE_CLASS} returns nonzero\n when the @var{from} mode is @var{mem_mode} and the @var{to} mode is any\n integral mode larger than this but not larger than @code{word_mode}.\n \n-You must return @code{NIL} if for some hard registers that allow this\n+You must return @code{UNKNOWN} if for some hard registers that allow this\n mode, @code{CANNOT_CHANGE_MODE_CLASS} says that they cannot change to\n @code{word_mode}, but that they can change to another integral mode that\n is larger then @var{mem_mode} but still smaller than @code{word_mode}."}, {"sha": "a7c43e3150883b94351cdb9ce9a7a685d4d32b2d", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -427,7 +427,7 @@ iv_constant (struct rtx_iv *iv, rtx cst, enum machine_mode mode)\n   iv->base = cst;\n   iv->step = const0_rtx;\n   iv->first_special = false;\n-  iv->extend = NIL;\n+  iv->extend = UNKNOWN;\n   iv->extend_mode = iv->mode;\n   iv->delta = const0_rtx;\n   iv->mult = const1_rtx;\n@@ -448,7 +448,7 @@ iv_subreg (struct rtx_iv *iv, enum machine_mode mode)\n       val = lowpart_subreg (mode, val, iv->extend_mode);\n \n       iv->base = val;\n-      iv->extend = NIL;\n+      iv->extend = UNKNOWN;\n       iv->mode = iv->extend_mode = mode;\n       iv->delta = const0_rtx;\n       iv->mult = const1_rtx;\n@@ -461,7 +461,7 @@ iv_subreg (struct rtx_iv *iv, enum machine_mode mode)\n   if (GET_MODE_BITSIZE (mode) > GET_MODE_BITSIZE (iv->mode))\n     return false;\n \n-  iv->extend = NIL;\n+  iv->extend = UNKNOWN;\n   iv->mode = mode;\n \n   iv->base = simplify_gen_binary (PLUS, iv->extend_mode, iv->delta,\n@@ -488,7 +488,7 @@ iv_extend (struct rtx_iv *iv, enum rtx_code extend, enum machine_mode mode)\n       val = simplify_gen_unary (extend, mode, val, iv->extend_mode);\n \n       iv->base = val;\n-      iv->extend = NIL;\n+      iv->extend = UNKNOWN;\n       iv->mode = iv->extend_mode = mode;\n       iv->delta = const0_rtx;\n       iv->mult = const1_rtx;\n@@ -498,7 +498,7 @@ iv_extend (struct rtx_iv *iv, enum rtx_code extend, enum machine_mode mode)\n   if (mode != iv->extend_mode)\n     return false;\n \n-  if (iv->extend != NIL\n+  if (iv->extend != UNKNOWN\n       && iv->extend != extend)\n     return false;\n \n@@ -512,7 +512,7 @@ iv_extend (struct rtx_iv *iv, enum rtx_code extend, enum machine_mode mode)\n static bool\n iv_neg (struct rtx_iv *iv)\n {\n-  if (iv->extend == NIL)\n+  if (iv->extend == UNKNOWN)\n     {\n       iv->base = simplify_gen_unary (NEG, iv->extend_mode,\n \t\t\t\t     iv->base, iv->extend_mode);\n@@ -539,7 +539,7 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n   rtx arg;\n \n   /* Extend the constant to extend_mode of the other operand if necessary.  */\n-  if (iv0->extend == NIL\n+  if (iv0->extend == UNKNOWN\n       && iv0->mode == iv0->extend_mode\n       && iv0->step == const0_rtx\n       && GET_MODE_SIZE (iv0->extend_mode) < GET_MODE_SIZE (iv1->extend_mode))\n@@ -548,7 +548,7 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n       iv0->base = simplify_gen_unary (ZERO_EXTEND, iv0->extend_mode,\n \t\t\t\t      iv0->base, iv0->mode);\n     }\n-  if (iv1->extend == NIL\n+  if (iv1->extend == UNKNOWN\n       && iv1->mode == iv1->extend_mode\n       && iv1->step == const0_rtx\n       && GET_MODE_SIZE (iv1->extend_mode) < GET_MODE_SIZE (iv0->extend_mode))\n@@ -562,7 +562,7 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n   if (mode != iv1->extend_mode)\n     return false;\n \n-  if (iv0->extend == NIL && iv1->extend == NIL)\n+  if (iv0->extend == UNKNOWN && iv1->extend == UNKNOWN)\n     {\n       if (iv0->mode != iv1->mode)\n \treturn false;\n@@ -574,15 +574,15 @@ iv_add (struct rtx_iv *iv0, struct rtx_iv *iv1, enum rtx_code op)\n     }\n \n   /* Handle addition of constant.  */\n-  if (iv1->extend == NIL\n+  if (iv1->extend == UNKNOWN\n       && iv1->mode == mode\n       && iv1->step == const0_rtx)\n     {\n       iv0->delta = simplify_gen_binary (op, mode, iv0->delta, iv1->base);\n       return true;\n     }\n \n-  if (iv0->extend == NIL\n+  if (iv0->extend == UNKNOWN\n       && iv0->mode == mode\n       && iv0->step == const0_rtx)\n     {\n@@ -610,7 +610,7 @@ iv_mult (struct rtx_iv *iv, rtx mby)\n       && GET_MODE (mby) != mode)\n     return false;\n \n-  if (iv->extend == NIL)\n+  if (iv->extend == UNKNOWN)\n     {\n       iv->base = simplify_gen_binary (MULT, mode, iv->base, mby);\n       iv->step = simplify_gen_binary (MULT, mode, iv->step, mby);\n@@ -635,7 +635,7 @@ iv_shift (struct rtx_iv *iv, rtx mby)\n       && GET_MODE (mby) != mode)\n     return false;\n \n-  if (iv->extend == NIL)\n+  if (iv->extend == UNKNOWN)\n     {\n       iv->base = simplify_gen_binary (ASHIFT, mode, iv->base, mby);\n       iv->step = simplify_gen_binary (ASHIFT, mode, iv->step, mby);\n@@ -750,7 +750,7 @@ get_biv_step_1 (rtx insn, rtx reg,\n \treturn false;\n \n       *inner_step = const0_rtx;\n-      *extend = NIL;\n+      *extend = UNKNOWN;\n       *inner_mode = outer_mode;\n       *outer_step = const0_rtx;\n     }\n@@ -770,7 +770,7 @@ get_biv_step_1 (rtx insn, rtx reg,\n       *inner_step = simplify_gen_binary (PLUS, outer_mode,\n \t\t\t\t\t *inner_step, *outer_step);\n       *outer_step = const0_rtx;\n-      *extend = NIL;\n+      *extend = UNKNOWN;\n     }\n \n   switch (code)\n@@ -794,7 +794,7 @@ get_biv_step_1 (rtx insn, rtx reg,\n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n       if (GET_MODE (op0) != *inner_mode\n-\t  || *extend != NIL\n+\t  || *extend != UNKNOWN\n \t  || *outer_step != const0_rtx)\n \tabort ();\n \n@@ -827,11 +827,11 @@ get_biv_step (rtx reg, rtx *inner_step, enum machine_mode *inner_mode,\n     return false;\n \n   if (*inner_mode != *outer_mode\n-      && *extend == NIL)\n+      && *extend == UNKNOWN)\n     abort ();\n \n   if (*inner_mode == *outer_mode\n-      && *extend != NIL)\n+      && *extend != UNKNOWN)\n     abort ();\n \n   if (*inner_mode == *outer_mode\n@@ -1207,7 +1207,7 @@ get_iv_value (struct rtx_iv *iv, rtx iteration)\n \n   val = lowpart_subreg (iv->mode, val, iv->extend_mode);\n \n-  if (iv->extend == NIL)\n+  if (iv->extend == UNKNOWN)\n     return val;\n \n   val = simplify_gen_unary (iv->extend, iv->extend_mode, val, iv->mode);\n@@ -1727,7 +1727,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       else\n \tabort ();\n \n-      simplify_using_initial_values (loop, NIL, &head);\n+      simplify_using_initial_values (loop, UNKNOWN, &head);\n       if (head == aggr)\n \t{\n \t  XEXP (*expr, 0) = aggr;\n@@ -1753,7 +1753,7 @@ simplify_using_initial_values (struct loop *loop, enum rtx_code op, rtx *expr)\n       return;\n     }\n \n-  if (op != NIL)\n+  if (op != UNKNOWN)\n     abort ();\n \n   e = loop_preheader_edge (loop);\n@@ -1901,15 +1901,15 @@ canonicalize_iv_subregs (struct rtx_iv *iv0, struct rtx_iv *iv1,\n \tbreak;\n \n       case NE:\n-\tif (iv0->extend != NIL\n-\t    && iv1->extend != NIL\n+\tif (iv0->extend != UNKNOWN\n+\t    && iv1->extend != UNKNOWN\n \t    && iv0->extend != iv1->extend)\n \t  return false;\n \n \tsigned_p = false;\n-\tif (iv0->extend != NIL)\n+\tif (iv0->extend != UNKNOWN)\n \t  signed_p = iv0->extend == SIGN_EXTEND;\n-\tif (iv1->extend != NIL)\n+\tif (iv1->extend != UNKNOWN)\n \t  signed_p = iv1->extend == SIGN_EXTEND;\n \tbreak;\n \n@@ -2403,7 +2403,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n     goto fail;\n   simplify_using_initial_values (loop, IOR, &desc->noloop_assumptions);\n   simplify_using_initial_values (loop, IOR, &desc->infinite);\n-  simplify_using_initial_values (loop, NIL, &desc->niter_expr);\n+  simplify_using_initial_values (loop, UNKNOWN, &desc->niter_expr);\n \n   /* Rerun the simplification.  Consider code (created by copying loop headers)\n \n@@ -2426,7 +2426,7 @@ iv_number_of_iterations (struct loop *loop, rtx insn, rtx condition,\n     goto fail;\n   simplify_using_initial_values (loop, IOR, &desc->noloop_assumptions);\n   simplify_using_initial_values (loop, IOR, &desc->infinite);\n-  simplify_using_initial_values (loop, NIL, &desc->niter_expr);\n+  simplify_using_initial_values (loop, UNKNOWN, &desc->niter_expr);\n \n   if (desc->noloop_assumptions\n       && XEXP (desc->noloop_assumptions, 0) == const_true_rtx)"}, {"sha": "3b15118f3294c6d43ccbfe9d2c81f17c37ff7519", "filename": "gcc/postreload.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -214,7 +214,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n   cselib_val *val;\n   struct elt_loc_list *l;\n #ifdef LOAD_EXTEND_OP\n-  enum rtx_code extend_op = NIL;\n+  enum rtx_code extend_op = UNKNOWN;\n #endif\n \n   dreg = true_regnum (SET_DEST (set));\n@@ -234,7 +234,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n      the destination must be a register that we can widen.  */\n   if (MEM_P (src)\n       && GET_MODE_BITSIZE (GET_MODE (src)) < BITS_PER_WORD\n-      && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != NIL\n+      && (extend_op = LOAD_EXTEND_OP (GET_MODE (src))) != UNKNOWN\n       && !REG_P (SET_DEST (set)))\n     return 0;\n #endif\n@@ -260,7 +260,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n       if (CONSTANT_P (this_rtx) && ! references_value_p (this_rtx, 0))\n \t{\n #ifdef LOAD_EXTEND_OP\n-\t  if (extend_op != NIL)\n+\t  if (extend_op != UNKNOWN)\n \t    {\n \t      HOST_WIDE_INT this_val;\n \n@@ -290,7 +290,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n       else if (REG_P (this_rtx))\n \t{\n #ifdef LOAD_EXTEND_OP\n-\t  if (extend_op != NIL)\n+\t  if (extend_op != UNKNOWN)\n \t    {\n \t      this_rtx = gen_rtx_fmt_e (extend_op, word_mode, this_rtx);\n \t      this_cost = rtx_cost (this_rtx, SET);\n@@ -313,7 +313,7 @@ reload_cse_simplify_set (rtx set, rtx insn)\n \t{\n #ifdef LOAD_EXTEND_OP\n \t  if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (set))) < BITS_PER_WORD\n-\t      && extend_op != NIL\n+\t      && extend_op != UNKNOWN\n #ifdef CANNOT_CHANGE_MODE_CLASS\n \t      && !CANNOT_CHANGE_MODE_CLASS (GET_MODE (SET_DEST (set)),\n \t\t\t\t\t    word_mode,\n@@ -406,7 +406,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n #ifdef LOAD_EXTEND_OP\n       if (MEM_P (op)\n \t  && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n-\t  && LOAD_EXTEND_OP (mode) != NIL)\n+\t  && LOAD_EXTEND_OP (mode) != UNKNOWN)\n \t{\n \t  rtx set = single_set (insn);\n "}, {"sha": "45ff077b0788730707903dca543254ff1404c45b", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -545,12 +545,6 @@ read_rtx (FILE *infile)\n   read_name (tmp_char, infile);\n \n   tmp_code = UNKNOWN;\n-\n-  if (! strcmp (tmp_char, \"define_constants\"))\n-    {\n-      read_constants (infile, tmp_char);\n-      goto again;\n-    }\n   for (i = 0; i < NUM_RTX_CODE; i++)\n     if (! strcmp (tmp_char, GET_RTX_NAME (i)))\n       {\n@@ -559,16 +553,24 @@ read_rtx (FILE *infile)\n       }\n \n   if (tmp_code == UNKNOWN)\n-    fatal_with_file_and_line (infile, \"unknown rtx code `%s'\", tmp_char);\n-\n-  /* (NIL) stands for an expression that isn't there.  */\n-  if (tmp_code == NIL)\n     {\n-      /* Discard the closeparen.  */\n-      while ((c = getc (infile)) && c != ')')\n-\t;\n-\n-      return 0;\n+      /* (nil) stands for an expression that isn't there.  */\n+      if (! strcmp (tmp_char, \"nil\"))\n+\t{\n+\t  /* Discard the closeparen.  */\n+\t  c = read_skip_spaces (infile);\n+\t  if (c != ')')\n+\t    fatal_expected_char (infile, ')', c);\n+\t  return 0;\n+\t}\n+      /* (define_constants ...) has special syntax.  */\n+      else if (! strcmp (tmp_char, \"define_constants\"))\n+\t{\n+\t  read_constants (infile, tmp_char);\n+\t  goto again;\n+\t}\n+      else \n+\tfatal_with_file_and_line (infile, \"unknown rtx code `%s'\", tmp_char);\n     }\n \n   /* If we end up with an insn expression then we free this space below.  */"}, {"sha": "b114dc2b1484b4871d9703d4773c09bd1b4a63b2", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -1026,7 +1026,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t      && (GET_MODE_SIZE (inmode)\n \t\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (in))))\n \t\t      && INTEGRAL_MODE_P (GET_MODE (SUBREG_REG (in)))\n-\t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != NIL)\n+\t\t      && LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (in))) != UNKNOWN)\n #endif\n #ifdef WORD_REGISTER_OPERATIONS\n \t\t  || ((GET_MODE_SIZE (inmode)\n@@ -2971,7 +2971,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t      && (GET_MODE_SIZE (operand_mode[i])\n \t\t\t\t  > GET_MODE_SIZE (GET_MODE (operand)))\n \t\t\t      && INTEGRAL_MODE_P (GET_MODE (operand))\n-\t\t\t      && LOAD_EXTEND_OP (GET_MODE (operand)) != NIL)\n+\t\t\t      && LOAD_EXTEND_OP (GET_MODE (operand)) != UNKNOWN)\n #endif\n \t\t\t  )\n #endif"}, {"sha": "8fe6d920fb13fdcfe2ae989201d89a7a429303d5", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f822d2527eda821d7faeab8370a896d4591a100d/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=f822d2527eda821d7faeab8370a896d4591a100d", "patch": "@@ -84,11 +84,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* an expression code name unknown to the reader */\n DEF_RTL_EXPR(UNKNOWN, \"UnKnown\", \"*\", RTX_EXTRA)\n \n-/* (NIL) is used by rtl reader and printer to represent a null pointer.  */\n-\n-DEF_RTL_EXPR(NIL, \"nil\", \"*\", RTX_EXTRA)\n-\n-\n /* include a file */\n \n DEF_RTL_EXPR(INCLUDE, \"include\", \"s\", RTX_EXTRA)"}]}