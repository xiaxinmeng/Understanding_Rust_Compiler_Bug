{"sha": "e2823b6747b36362387e5b26e8792f06185d7de8", "node_id": "C_kwDOANBUbNoAKGUyODIzYjY3NDdiMzYzNjIzODdlNWIyNmU4NzkyZjA2MTg1ZDdkZTg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-10T17:08:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-10T17:08:15Z"}, "message": "Merge #917\n\n917: remove tree addressable context during type checking r=philberty a=philberty\n\nWe can reuse more C front-end code c_mark_addressable can be used instead\r\nof trying to track TREE_ADDRESSABLE as part of type-checking. This also\r\npulls the GCC::Backend::address_expression to be part of the HIRCompileBase\r\nclass during code-generation.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "a1c1a61fd3031416ca3bc600212cd13e51f727b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1c1a61fd3031416ca3bc600212cd13e51f727b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2823b6747b36362387e5b26e8792f06185d7de8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBUZ/CRBK7hj4Ov3rIwAA9Z0IAAFHAm9xpCy4jENTYVZw6LX5\nwzOi9Eapqc+ZGd5Grs+4EI7sAv5nI2Vc+62+N+8N/EiQnSAqfgChnysyoBp9Uvlq\ndaZT0xT4Lvyvyqi8Hlz4aQ6PI2B67oK5B2ZMOXYlPUU2ENKBWaxHQjSGTvxncA7+\nLP1RlZXL39pUN5ya3+8LPMhFi3EG6UtSiu7QhN7mG2EPOdICVPvuyhwdHwpmq2Ms\n6U3QOMkSg3Z3n2MpziPQ+tX1x5zPv6lNK43hNAgErIDJ0riVe5kqGCb4SyIipuYY\nvy+lihbAsAi+TO4LqQZa+ag3cyB356eXMJw9oRlyUuhnEAHLQznaVGncvaFA7gQ=\n=p+3x\n-----END PGP SIGNATURE-----\n", "payload": "tree a1c1a61fd3031416ca3bc600212cd13e51f727b8\nparent f6ba472caf42db1f5f2f98b73afccf448b36c322\nparent 1b487d72cd2ba46671f5a1bcc20970f2dad1b759\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1644512895 +0000\ncommitter GitHub <noreply@github.com> 1644512895 +0000\n\nMerge #917\n\n917: remove tree addressable context during type checking r=philberty a=philberty\n\nWe can reuse more C front-end code c_mark_addressable can be used instead\r\nof trying to track TREE_ADDRESSABLE as part of type-checking. This also\r\npulls the GCC::Backend::address_expression to be part of the HIRCompileBase\r\nclass during code-generation.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2823b6747b36362387e5b26e8792f06185d7de8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2823b6747b36362387e5b26e8792f06185d7de8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2823b6747b36362387e5b26e8792f06185d7de8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6ba472caf42db1f5f2f98b73afccf448b36c322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ba472caf42db1f5f2f98b73afccf448b36c322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ba472caf42db1f5f2f98b73afccf448b36c322"}, {"sha": "1b487d72cd2ba46671f5a1bcc20970f2dad1b759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b487d72cd2ba46671f5a1bcc20970f2dad1b759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b487d72cd2ba46671f5a1bcc20970f2dad1b759"}], "stats": {"total": 769, "additions": 118, "deletions": 651}, "files": [{"sha": "660ed235a74f8f74cb7b1fd617331a39bbd1d4aa", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -88,7 +88,6 @@ GRS_OBJS = \\\n     rust/rust-hir-trait-resolve.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n-    rust/rust-hir-address-taken.o \\\n     rust/rust-hir-type-check-pattern.o \\\n     rust/rust-autoderef.o \\\n     rust/rust-substitution-mapper.o \\"}, {"sha": "81598c4dc5bcda947f5c7842e89d871d76be0f4b", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -17,6 +17,7 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-compile-base.h\"\n+#include \"fold-const.h\"\n #include \"stringpool.h\"\n \n namespace Rust {\n@@ -88,5 +89,85 @@ HIRCompileBase::setup_abi_options (tree fndecl, ABI abi)\n     }\n }\n \n+// ported from gcc/c/c-typecheck.c\n+//\n+// Mark EXP saying that we need to be able to take the\n+// address of it; it should not be allocated in a register.\n+// Returns true if successful.  ARRAY_REF_P is true if this\n+// is for ARRAY_REF construction - in that case we don't want\n+// to look through VIEW_CONVERT_EXPR from VECTOR_TYPE to ARRAY_TYPE,\n+// it is fine to use ARRAY_REFs for vector subscripts on vector\n+// register variables.\n+bool\n+HIRCompileBase::mark_addressable (tree exp, Location locus)\n+{\n+  tree x = exp;\n+\n+  while (1)\n+    switch (TREE_CODE (x))\n+      {\n+      case VIEW_CONVERT_EXPR:\n+\tif (TREE_CODE (TREE_TYPE (x)) == ARRAY_TYPE\n+\t    && VECTOR_TYPE_P (TREE_TYPE (TREE_OPERAND (x, 0))))\n+\t  return true;\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case COMPONENT_REF:\n+\t// TODO\n+\t// if (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))\n+\t//   {\n+\t//     error (\"cannot take address of bit-field %qD\", TREE_OPERAND (x,\n+\t//     1)); return false;\n+\t//   }\n+\n+\t/* FALLTHRU */\n+      case ADDR_EXPR:\n+      case ARRAY_REF:\n+      case REALPART_EXPR:\n+      case IMAGPART_EXPR:\n+\tx = TREE_OPERAND (x, 0);\n+\tbreak;\n+\n+      case COMPOUND_LITERAL_EXPR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\tTREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (x)) = 1;\n+\treturn true;\n+\n+      case CONSTRUCTOR:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\treturn true;\n+\n+      case VAR_DECL:\n+      case CONST_DECL:\n+      case PARM_DECL:\n+      case RESULT_DECL:\n+\t// (we don't have a concept of a \"register\" declaration)\n+\t// fallthrough */\n+\n+\t/* FALLTHRU */\n+      case FUNCTION_DECL:\n+\tTREE_ADDRESSABLE (x) = 1;\n+\n+\t/* FALLTHRU */\n+      default:\n+\treturn true;\n+      }\n+\n+  return false;\n+}\n+\n+tree\n+HIRCompileBase::address_expression (tree expr, Location location)\n+{\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n+  if (!mark_addressable (expr, location))\n+    return error_mark_node;\n+\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n+}\n+\n } // namespace Compile\n } // namespace Rust"}, {"sha": "ec7535648aa6735dd6a241d76a1fca5f7fd1040d", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -77,6 +77,10 @@ class HIRCompileBase : public HIR::HIRFullVisitorBase\n     const HIR::FunctionQualifiers &qualifiers, const AST::AttrVec &attrs);\n \n   static void setup_abi_options (tree fndecl, ABI abi);\n+\n+  static tree address_expression (tree, Location);\n+\n+  static bool mark_addressable (tree, Location);\n };\n \n } // namespace Compile"}, {"sha": "f65e1fd54c837fd5af8873722d70e4cb052ed243", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -123,6 +123,13 @@ CompileExpr::visit (HIR::NegationExpr &expr)\n     = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n }\n \n+void\n+CompileExpr::visit (HIR::BorrowExpr &expr)\n+{\n+  tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  translated = address_expression (main_expr, expr.get_locus ());\n+}\n+\n void\n CompileExpr::visit (HIR::DereferenceExpr &expr)\n {\n@@ -973,7 +980,7 @@ CompileExpr::compile_string_literal (const HIR::LiteralExpr &expr,\n \n   auto base = ctx->get_backend ()->string_constant_expression (\n     literal_value.as_string ());\n-  return ctx->get_backend ()->address_expression (base, expr.get_locus ());\n+  return address_expression (base, expr.get_locus ());\n }\n \n tree\n@@ -1006,8 +1013,7 @@ CompileExpr::compile_byte_string_literal (const HIR::LiteralExpr &expr,\n \t\t\t\t\t\t\t vals,\n \t\t\t\t\t\t\t expr.get_locus ());\n \n-  return ctx->get_backend ()->address_expression (constructed,\n-\t\t\t\t\t\t  expr.get_locus ());\n+  return address_expression (constructed, expr.get_locus ());\n }\n \n tree\n@@ -1190,7 +1196,7 @@ HIRCompileBase::resolve_adjustements (\n \n \tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n \tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n-\t  e = ctx->get_backend ()->address_expression (e, locus);\n+\t  e = address_expression (e, locus);\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n@@ -1235,8 +1241,7 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n \t\t      != Resolver::Adjustment::AdjustmentType::ERROR;\n   if (needs_borrow)\n     {\n-      adjusted_argument\n-\t= ctx->get_backend ()->address_expression (expression, locus);\n+      adjusted_argument = address_expression (expression, locus);\n     }\n \n   // make the call"}, {"sha": "592d2806b215c52531959a5d5b445e011b5af6a2", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -797,13 +797,7 @@ class CompileExpr : public HIRCompileBase\n     ctx->add_statement (goto_label);\n   }\n \n-  void visit (HIR::BorrowExpr &expr) override\n-  {\n-    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-\n-    translated\n-      = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n-  }\n+  void visit (HIR::BorrowExpr &expr) override;\n \n   void visit (HIR::DereferenceExpr &expr) override;\n "}, {"sha": "4ca26ecf80ecfb4f87a303520623c7e37e7dcc1c", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_FNPARAM\n \n #include \"rust-compile-base.h\"\n-#include \"rust-hir-address-taken.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -34,7 +33,7 @@ class CompileFnParam : public HIRCompileBase\n \t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n-    CompileFnParam compiler (ctx, fndecl, decl_type, locus, *param);\n+    CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n     param->get_param_name ()->accept_vis (compiler);\n     return compiler.compiled_param;\n   }\n@@ -44,39 +43,30 @@ class CompileFnParam : public HIRCompileBase\n     if (!pattern.is_mut ())\n       decl_type = ctx->get_backend ()->immutable_type (decl_type);\n \n-    bool address_taken = false;\n-    address_taken_context->lookup_addess_taken (\n-      param.get_mappings ().get_hirid (), &address_taken);\n-\n-    compiled_param = ctx->get_backend ()->parameter_variable (\n-      fndecl, pattern.get_identifier (), decl_type, address_taken, locus);\n+    compiled_param\n+      = ctx->get_backend ()->parameter_variable (fndecl,\n+\t\t\t\t\t\t pattern.get_identifier (),\n+\t\t\t\t\t\t decl_type, locus);\n   }\n \n   void visit (HIR::WildcardPattern &pattern) override\n   {\n     decl_type = ctx->get_backend ()->immutable_type (decl_type);\n \n-    bool address_taken = false;\n     compiled_param\n-      = ctx->get_backend ()->parameter_variable (fndecl, \"_\", decl_type,\n-\t\t\t\t\t\t address_taken, locus);\n+      = ctx->get_backend ()->parameter_variable (fndecl, \"_\", decl_type, locus);\n   }\n \n private:\n-  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus,\n-\t\t  const HIR::FunctionParam &param)\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n-      locus (locus), param (param),\n-      compiled_param (ctx->get_backend ()->error_variable ()),\n-      address_taken_context (Resolver::AddressTakenContext::get ())\n+      locus (locus), compiled_param (ctx->get_backend ()->error_variable ())\n   {}\n \n   tree fndecl;\n   tree decl_type;\n   Location locus;\n-  const HIR::FunctionParam &param;\n   Bvariable *compiled_param;\n-  const Resolver::AddressTakenContext *address_taken_context;\n };\n \n class CompileSelfParam : public HIRCompileBase\n@@ -91,13 +81,8 @@ class CompileSelfParam : public HIRCompileBase\n     if (is_immutable)\n       decl_type = ctx->get_backend ()->immutable_type (decl_type);\n \n-    const auto &address_taken_context = Resolver::AddressTakenContext::get ();\n-    bool address_taken = false;\n-    address_taken_context->lookup_addess_taken (\n-      self.get_mappings ().get_hirid (), &address_taken);\n-\n     return ctx->get_backend ()->parameter_variable (fndecl, \"self\", decl_type,\n-\t\t\t\t\t\t    address_taken, locus);\n+\t\t\t\t\t\t    locus);\n   }\n };\n "}, {"sha": "7bc37eb3ad616b4c9e646d1eb04d12b15323c96c", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -20,7 +20,6 @@\n #define RUST_COMPILE_VAR_DECL\n \n #include \"rust-compile-base.h\"\n-#include \"rust-hir-address-taken.h\"\n \n namespace Rust {\n namespace Compile {\n@@ -47,9 +46,6 @@ class CompileVarDecl : public HIRCompileBase\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n-    address_taken_context->lookup_addess_taken (\n-      stmt.get_mappings ().get_hirid (), &address_taken);\n-\n     translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n     stmt.get_pattern ()->accept_vis (*this);\n   }\n@@ -62,33 +58,29 @@ class CompileVarDecl : public HIRCompileBase\n     compiled_variable\n       = ctx->get_backend ()->local_variable (fndecl, pattern.get_identifier (),\n \t\t\t\t\t     translated_type, NULL /*decl_var*/,\n-\t\t\t\t\t     address_taken, locus);\n+\t\t\t\t\t     locus);\n   }\n \n   void visit (HIR::WildcardPattern &pattern) override\n   {\n     translated_type = ctx->get_backend ()->immutable_type (translated_type);\n+\n     compiled_variable\n       = ctx->get_backend ()->local_variable (fndecl, \"_\", translated_type,\n-\t\t\t\t\t     NULL /*decl_var*/, address_taken,\n-\t\t\t\t\t     locus);\n+\t\t\t\t\t     NULL /*decl_var*/, locus);\n   }\n \n private:\n   CompileVarDecl (Context *ctx, tree fndecl)\n     : HIRCompileBase (ctx), fndecl (fndecl),\n       translated_type (ctx->get_backend ()->error_type ()),\n-      compiled_variable (ctx->get_backend ()->error_variable ()),\n-      address_taken (false),\n-      address_taken_context (Resolver::AddressTakenContext::get ())\n+      compiled_variable (ctx->get_backend ()->error_variable ())\n   {}\n \n   tree fndecl;\n   tree translated_type;\n   Location locus;\n   Bvariable *compiled_variable;\n-  bool address_taken;\n-  const Resolver::AddressTakenContext *address_taken_context;\n };\n \n } // namespace Compile"}, {"sha": "2299ddbb93cfe4ef81211f45fbc2fd1023255557", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -387,8 +387,7 @@ HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n       rust_assert (ok);\n \n       resulting_dyn_object_ref\n-\t= ctx->get_backend ()->address_expression (resulting_dyn_object_ref,\n-\t\t\t\t\t\t   locus);\n+\t= address_expression (resulting_dyn_object_ref, locus);\n     }\n   return resulting_dyn_object_ref;\n }"}, {"sha": "f7a1ac60471e71b18d705de4cb27643a4788cfda", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 2, "deletions": 119, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -255,9 +255,6 @@ class Backend\n   // get the address of the code for a function.\n   virtual tree function_code_expression (tree, Location) = 0;\n \n-  // Create an expression that takes the address of an expression.\n-  virtual tree address_expression (tree, Location) = 0;\n-\n   // Return an expression for the field at INDEX in BSTRUCT.\n   virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;\n@@ -461,15 +458,14 @@ class Backend\n   // the frontend will call init_statement to set the initial value.\n   virtual Bvariable *local_variable (tree function, const std::string &name,\n \t\t\t\t     tree type, Bvariable *decl_var,\n-\t\t\t\t     bool is_address_taken, Location location)\n+\t\t\t\t     Location location)\n     = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n   virtual Bvariable *parameter_variable (tree function, const std::string &name,\n-\t\t\t\t\t tree type, bool is_address_taken,\n-\t\t\t\t\t Location location)\n+\t\t\t\t\t tree type, Location location)\n     = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n@@ -494,119 +490,6 @@ class Backend\n \t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n \n-  // Create an implicit variable that is compiler-defined.  This is\n-  // used when generating GC data and roots, when storing the values\n-  // of a slice constructor, and for the zero value of types.  This returns a\n-  // Bvariable because it corresponds to an initialized variable in C.\n-  //\n-  // NAME is the name to use for the initialized variable this will create.\n-  //\n-  // ASM_NAME is encoded assembler-friendly version of the name, or the\n-  // empty string if no encoding is needed.\n-  //\n-  // TYPE is the type of the implicit variable.\n-  //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_CONSTANT is true if the implicit variable should be treated like it is\n-  // immutable.  For slice initializers, if the values must be copied to the\n-  // heap, the variable IS_CONSTANT.\n-  //\n-  // IS_COMMON is true if the implicit variable should\n-  // be treated as a common variable (multiple definitions with\n-  // different sizes permitted in different object files, all merged\n-  // into the largest definition at link time); this will be true for\n-  // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n-  //\n-  // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable *implicit_variable (const std::string &name,\n-\t\t\t\t\tconst std::string &asm_name, tree type,\n-\t\t\t\t\tbool is_hidden, bool is_constant,\n-\t\t\t\t\tbool is_common, int64_t alignment)\n-    = 0;\n-\n-  // Set the initial value of a variable created by implicit_variable.\n-  // This must be called even if there is no initializer, i.e., INIT is NULL.\n-  // The NAME, TYPE, IS_HIDDEN, IS_CONSTANT, and IS_COMMON parameters are\n-  // the same ones passed to implicit_variable.  INIT will be a composite\n-  // literal of type TYPE.  It will not contain any function calls or anything\n-  // else that can not be put into a read-only data section.\n-  // It may contain the address of variables created by implicit_variable.\n-  //\n-  // If IS_COMMON is true, INIT will be NULL, and the\n-  // variable should be initialized to all zeros.\n-  virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t   tree type, bool is_hidden,\n-\t\t\t\t\t   bool is_constant, bool is_common,\n-\t\t\t\t\t   tree init)\n-    = 0;\n-\n-  // Create a reference to a named implicit variable defined in some\n-  // other package.  This will be a variable created by a call to\n-  // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n-  // IS_COMMON passed as false.  This corresponds to an extern global\n-  // variable in C.\n-  virtual Bvariable *implicit_variable_reference (const std::string &name,\n-\t\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t\t  tree type)\n-    = 0;\n-\n-  // Create a named immutable initialized data structure.  This is\n-  // used for type descriptors, map descriptors, and function\n-  // descriptors.  This returns a Bvariable because it corresponds to\n-  // an initialized const variable in C.\n-  //\n-  // NAME is the name to use for the initialized global variable which\n-  // this call will create.\n-  //\n-  // ASM_NAME is the encoded, assembler-friendly version of NAME, or\n-  // the empty string if no encoding is needed.\n-  //\n-  // IS_HIDDEN will be true if the descriptor should only be visible\n-  // within the current object.\n-  //\n-  // IS_COMMON is true if NAME may be defined by several packages, and\n-  // the linker should merge all such definitions.  If IS_COMMON is\n-  // false, NAME should be defined in only one file.  In general\n-  // IS_COMMON will be true for the type descriptor of an unnamed type\n-  // or a builtin type.  IS_HIDDEN and IS_COMMON will never both be\n-  // true.\n-  //\n-  // TYPE will be a struct type; the type of the returned expression\n-  // must be a pointer to this struct type.\n-  //\n-  // We must create the named structure before we know its\n-  // initializer, because the initializer may refer to its own\n-  // address.  After calling this the frontend will call\n-  // immutable_struct_set_init.\n-  virtual Bvariable *\n-  immutable_struct (const std::string &name, const std::string &asm_name,\n-\t\t    bool is_hidden, bool is_common, tree type, Location)\n-    = 0;\n-\n-  // Set the initial value of a variable created by immutable_struct.\n-  // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n-  // the same ones passed to immutable_struct.  INITIALIZER will be a\n-  // composite literal of type TYPE.  It will not contain any function\n-  // calls or anything else that can not be put into a read-only data\n-  // section.  It may contain the address of variables created by\n-  // immutable_struct.\n-  virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  tree type, Location, tree initializer)\n-    = 0;\n-\n-  // Create a reference to a named immutable initialized data\n-  // structure defined in some other package.  This will be a\n-  // structure created by a call to immutable_struct with the same\n-  // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n-  // corresponds to an extern const global variable in C.\n-  virtual Bvariable *immutable_struct_reference (const std::string &name,\n-\t\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t\t tree type, Location)\n-    = 0;\n-\n   // Labels.\n \n   // Create a new label.  NAME will be empty if this is a label"}, {"sha": "86a4106162c6b64edae3f453c83f8716ef19b134", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 5, "deletions": 244, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -231,8 +231,6 @@ class Gcc_backend : public Backend\n \n   tree function_code_expression (tree, Location);\n \n-  tree address_expression (tree, Location);\n-\n   tree struct_field_expression (tree, size_t, Location);\n \n   tree compound_expression (tree, tree, Location);\n@@ -312,35 +310,16 @@ class Gcc_backend : public Backend\n \n   void global_variable_set_init (Bvariable *, tree);\n \n-  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *, bool,\n+  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *,\n \t\t\t     Location);\n \n-  Bvariable *parameter_variable (tree, const std::string &, tree, bool,\n-\t\t\t\t Location);\n+  Bvariable *parameter_variable (tree, const std::string &, tree, Location);\n \n   Bvariable *static_chain_variable (tree, const std::string &, tree, Location);\n \n   Bvariable *temporary_variable (tree, tree, tree, tree, bool, Location,\n \t\t\t\t tree *);\n \n-  Bvariable *implicit_variable (const std::string &, const std::string &, tree,\n-\t\t\t\tbool, bool, bool, int64_t);\n-\n-  void implicit_variable_set_init (Bvariable *, const std::string &, tree, bool,\n-\t\t\t\t   bool, bool, tree);\n-\n-  Bvariable *implicit_variable_reference (const std::string &,\n-\t\t\t\t\t  const std::string &, tree);\n-\n-  Bvariable *immutable_struct (const std::string &, const std::string &, bool,\n-\t\t\t       bool, tree, Location);\n-\n-  void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  tree, Location, tree);\n-\n-  Bvariable *immutable_struct_reference (const std::string &,\n-\t\t\t\t\t const std::string &, tree, Location);\n-\n   // Labels.\n \n   tree label (tree, const std::string &name, Location);\n@@ -1338,17 +1317,6 @@ Gcc_backend::function_code_expression (tree func, Location location)\n   return ret;\n }\n \n-// Get the address of an expression.\n-\n-tree\n-Gcc_backend::address_expression (tree expr, Location location)\n-{\n-  if (expr == error_mark_node)\n-    return this->error_expression ();\n-\n-  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n-}\n-\n // Return an expression for the field at INDEX in BSTRUCT.\n \n tree\n@@ -2495,16 +2463,15 @@ Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n Bvariable *\n Gcc_backend::local_variable (tree function, const std::string &name,\n \t\t\t     tree type_tree, Bvariable *decl_var,\n-\t\t\t     bool is_address_taken, Location location)\n+\t\t\t     Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n   DECL_CONTEXT (decl) = function;\n   TREE_USED (decl) = 1;\n-  if (is_address_taken)\n-    TREE_ADDRESSABLE (decl) = 1;\n+\n   if (decl_var != NULL)\n     {\n       DECL_HAS_VALUE_EXPR_P (decl) = 1;\n@@ -2518,8 +2485,7 @@ Gcc_backend::local_variable (tree function, const std::string &name,\n \n Bvariable *\n Gcc_backend::parameter_variable (tree function, const std::string &name,\n-\t\t\t\t tree type_tree, bool is_address_taken,\n-\t\t\t\t Location location)\n+\t\t\t\t tree type_tree, Location location)\n {\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n@@ -2528,8 +2494,6 @@ Gcc_backend::parameter_variable (tree function, const std::string &name,\n   DECL_CONTEXT (decl) = function;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n-  if (is_address_taken)\n-    TREE_ADDRESSABLE (decl) = 1;\n   rust_preserve_from_gc (decl);\n   return new Bvariable (decl);\n }\n@@ -2633,209 +2597,6 @@ Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n   return new Bvariable (var);\n }\n \n-// Create an implicit variable that is compiler-defined.  This is used when\n-// generating GC root variables and storing the values of a slice initializer.\n-\n-Bvariable *\n-Gcc_backend::implicit_variable (const std::string &name,\n-\t\t\t\tconst std::string &asm_name, tree type_tree,\n-\t\t\t\tbool is_hidden, bool is_constant,\n-\t\t\t\tbool is_common, int64_t alignment)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-\n-  tree decl = build_decl (BUILTINS_LOCATION, VAR_DECL,\n-\t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_EXTERNAL (decl) = 0;\n-  TREE_PUBLIC (decl) = !is_hidden;\n-  TREE_STATIC (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (is_common)\n-    {\n-      DECL_COMMON (decl) = 1;\n-\n-      // When the initializer for one implicit_variable refers to another,\n-      // it needs to know the visibility of the referenced struct so that\n-      // compute_reloc_for_constant will return the right value.  On many\n-      // systems calling make_decl_one_only will mark the decl as weak,\n-      // which will change the return value of compute_reloc_for_constant.\n-      // We can't reliably call make_decl_one_only yet, because we don't\n-      // yet know the initializer.  This issue doesn't arise in C because\n-      // Rust initializers, unlike C initializers, can be indirectly\n-      // recursive.  To ensure that compute_reloc_for_constant computes\n-      // the right value if some other initializer refers to this one, we\n-      // mark this symbol as weak here.  We undo that below in\n-      // immutable_struct_set_init before calling mark_decl_one_only.\n-      DECL_WEAK (decl) = 1;\n-    }\n-  if (is_constant)\n-    {\n-      TREE_READONLY (decl) = 1;\n-      TREE_CONSTANT (decl) = 1;\n-    }\n-  if (alignment != 0)\n-    {\n-      SET_DECL_ALIGN (decl, alignment * BITS_PER_UNIT);\n-      DECL_USER_ALIGN (decl) = 1;\n-    }\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Set the initalizer for a variable created by implicit_variable.\n-// This is where we finish compiling the variable.\n-\n-void\n-Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\t tree, bool, bool, bool is_common,\n-\t\t\t\t\t tree init_tree)\n-{\n-  tree decl = var->get_decl ();\n-  if (decl == error_mark_node || init_tree == error_mark_node)\n-    return;\n-\n-  DECL_INITIAL (decl) = init_tree;\n-\n-  // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n-  // See the comment where DECL_WEAK is set in implicit_variable.\n-  if (is_common)\n-    {\n-      DECL_WEAK (decl) = 0;\n-      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n-    }\n-\n-  resolve_unique_section (decl, 2, 1);\n-\n-  rest_of_decl_compilation (decl, 1, 0);\n-}\n-\n-// Return a reference to an implicit variable defined in another package.\n-\n-Bvariable *\n-Gcc_backend::implicit_variable_reference (const std::string &name,\n-\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t  tree type_tree)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-\n-  tree decl = build_decl (BUILTINS_LOCATION, VAR_DECL,\n-\t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_EXTERNAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  TREE_STATIC (decl) = 0;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Create a named immutable initialized data structure.\n-\n-Bvariable *\n-Gcc_backend::immutable_struct (const std::string &name,\n-\t\t\t       const std::string &asm_name, bool is_hidden,\n-\t\t\t       bool is_common, tree type_tree,\n-\t\t\t       Location location)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n-\t\t\t  get_identifier_from_string (name),\n-\t\t\t  build_qualified_type (type_tree, TYPE_QUAL_CONST));\n-  TREE_STATIC (decl) = 1;\n-  TREE_USED (decl) = 1;\n-  TREE_READONLY (decl) = 1;\n-  TREE_CONSTANT (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  if (!is_hidden)\n-    TREE_PUBLIC (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-\n-  // When the initializer for one immutable_struct refers to another,\n-  // it needs to know the visibility of the referenced struct so that\n-  // compute_reloc_for_constant will return the right value.  On many\n-  // systems calling make_decl_one_only will mark the decl as weak,\n-  // which will change the return value of compute_reloc_for_constant.\n-  // We can't reliably call make_decl_one_only yet, because we don't\n-  // yet know the initializer.  This issue doesn't arise in C because\n-  // Rust initializers, unlike C initializers, can be indirectly\n-  // recursive.  To ensure that compute_reloc_for_constant computes\n-  // the right value if some other initializer refers to this one, we\n-  // mark this symbol as weak here.  We undo that below in\n-  // immutable_struct_set_init before calling mark_decl_one_only.\n-  if (is_common)\n-    DECL_WEAK (decl) = 1;\n-\n-  // We don't call rest_of_decl_compilation until we have the\n-  // initializer.\n-\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n-// Set the initializer for a variable created by immutable_struct.\n-// This is where we finish compiling the variable.\n-\n-void\n-Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\tbool, bool is_common, tree, Location,\n-\t\t\t\t\ttree init_tree)\n-{\n-  tree decl = var->get_decl ();\n-  if (decl == error_mark_node || init_tree == error_mark_node)\n-    return;\n-\n-  DECL_INITIAL (decl) = init_tree;\n-\n-  // Now that DECL_INITIAL is set, we can't call make_decl_one_only.\n-  // See the comment where DECL_WEAK is set in immutable_struct.\n-  if (is_common)\n-    {\n-      DECL_WEAK (decl) = 0;\n-      make_decl_one_only (decl, DECL_ASSEMBLER_NAME (decl));\n-    }\n-\n-  // These variables are often unneeded in the final program, so put\n-  // them in their own section so that linker GC can discard them.\n-  resolve_unique_section (decl, compute_reloc_for_constant (init_tree), 1);\n-\n-  rest_of_decl_compilation (decl, 1, 0);\n-}\n-\n-// Return a reference to an immutable initialized data structure\n-// defined in another package.\n-\n-Bvariable *\n-Gcc_backend::immutable_struct_reference (const std::string &name,\n-\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t tree type_tree, Location location)\n-{\n-  if (type_tree == error_mark_node)\n-    return this->error_variable ();\n-  gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-  tree decl = build_decl (location.gcc_location (), VAR_DECL,\n-\t\t\t  get_identifier_from_string (name),\n-\t\t\t  build_qualified_type (type_tree, TYPE_QUAL_CONST));\n-  TREE_READONLY (decl) = 1;\n-  TREE_CONSTANT (decl) = 1;\n-  DECL_ARTIFICIAL (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n-  DECL_EXTERNAL (decl) = 1;\n-  if (!asm_name.empty ())\n-    SET_DECL_ASSEMBLER_NAME (decl, get_identifier_from_string (asm_name));\n-  rust_preserve_from_gc (decl);\n-  return new Bvariable (decl);\n-}\n-\n // Make a label.\n \n tree"}, {"sha": "8fcbb377f64df03f506d48c83ba8862799123f76", "filename": "gcc/rust/typecheck/rust-hir-address-taken.cc", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ba472caf42db1f5f2f98b73afccf448b36c322/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ba472caf42db1f5f2f98b73afccf448b36c322/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.cc?ref=f6ba472caf42db1f5f2f98b73afccf448b36c322", "patch": "@@ -1,65 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#include \"rust-hir-address-taken.h\"\n-#include \"rust-hir-full.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-AddressTakenContext *\n-AddressTakenContext::get ()\n-{\n-  static AddressTakenContext *instance;\n-  if (instance == nullptr)\n-    instance = new AddressTakenContext ();\n-\n-  return instance;\n-}\n-\n-AddressTakenContext::~AddressTakenContext () {}\n-\n-bool\n-AddressTakenContext::lookup_addess_taken (HirId id, bool *address_taken) const\n-{\n-  const auto &it = ctx.find (id);\n-  if (it == ctx.end ())\n-    return false;\n-\n-  *address_taken = it->second;\n-  return true;\n-}\n-\n-void\n-AddressTakenContext::insert_address_taken (HirId id, bool address_taken)\n-{\n-  const auto &it = ctx.find (id);\n-  if (it != ctx.end ())\n-    {\n-      // assert that we never change a true result to a negative\n-      if (it->second == true)\n-\t{\n-\t  rust_assert (address_taken != false);\n-\t}\n-    }\n-\n-  ctx[id] = address_taken;\n-}\n-\n-} // namespace Resolver\n-} // namespace Rust"}, {"sha": "32a1445ae4dd94dfd4e88753f1890815ee1d40f7", "filename": "gcc/rust/typecheck/rust-hir-address-taken.h", "status": "removed", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ba472caf42db1f5f2f98b73afccf448b36c322/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ba472caf42db1f5f2f98b73afccf448b36c322/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-address-taken.h?ref=f6ba472caf42db1f5f2f98b73afccf448b36c322", "patch": "@@ -1,159 +0,0 @@\n-// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_HIR_ADDRESS_TAKEN\n-#define RUST_HIR_ADDRESS_TAKEN\n-\n-#include \"rust-hir-type-check-base.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-class AddressTakenContext\n-{\n-public:\n-  static AddressTakenContext *get ();\n-\n-  ~AddressTakenContext ();\n-\n-  bool lookup_addess_taken (HirId id, bool *address_taken) const;\n-\n-  void insert_address_taken (HirId id, bool address_taken);\n-\n-private:\n-  std::map<HirId, bool> ctx;\n-};\n-\n-class AddressTakenResolver : public TypeCheckBase\n-{\n-  using Rust::Resolver::TypeCheckBase::visit;\n-\n-public:\n-  static void SetAddressTaken (HIR::Expr &expr)\n-  {\n-    AddressTakenResolver resolver;\n-    expr.accept_vis (resolver);\n-  }\n-\n-  void visit (HIR::IdentifierExpr &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      return;\n-\n-    // node back to HIR\n-    HirId ref = UNKNOWN_HIRID;\n-    bool reverse_lookup\n-      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t      ref_node_id, &ref);\n-    rust_assert (reverse_lookup);\n-    context->insert_address_taken (ref, true);\n-  }\n-\n-  void visit (HIR::PathInExpression &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      return;\n-\n-    // node back to HIR\n-    HirId ref = UNKNOWN_HIRID;\n-    bool reverse_lookup\n-      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t      ref_node_id, &ref);\n-    rust_assert (reverse_lookup);\n-    context->insert_address_taken (ref, true);\n-  }\n-\n-  void visit (HIR::QualifiedPathInExpression &expr) override\n-  {\n-    NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n-    NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-      {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-\n-    if (ref_node_id == UNKNOWN_NODEID)\n-      return;\n-\n-    // node back to HIR\n-    HirId ref = UNKNOWN_HIRID;\n-    bool reverse_lookup\n-      = mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t      ref_node_id, &ref);\n-    rust_assert (reverse_lookup);\n-    context->insert_address_taken (ref, true);\n-  }\n-\n-  void visit (HIR::DereferenceExpr &expr) override\n-  {\n-    expr.get_expr ()->accept_vis (*this);\n-  }\n-\n-private:\n-  AddressTakenResolver ()\n-    : TypeCheckBase (), context (AddressTakenContext::get ())\n-  {}\n-\n-  AddressTakenContext *context;\n-};\n-\n-} // namespace Resolver\n-} // namespace Rust\n-\n-#endif // RUST_HIR_ADDRESS_TAKEN"}, {"sha": "2cb4461886e957276230049770c7a4e715b5be6f", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2823b6747b36362387e5b26e8792f06185d7de8/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=e2823b6747b36362387e5b26e8792f06185d7de8", "patch": "@@ -30,7 +30,6 @@\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n-#include \"rust-hir-address-taken.h\"\n #include \"rust-hir-type-check-pattern.h\"\n \n namespace Rust {\n@@ -260,10 +259,6 @@ class TypeCheckExpr : public TypeCheckBase\n     Adjuster adj (receiver_tyty);\n     TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n \n-    // mark the required tree addressable\n-    if (Adjuster::needs_address (candidate.adjustments))\n-      AddressTakenResolver::SetAddressTaken (*expr.get_receiver ().get ());\n-\n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n \t\t\t\t\tstd::move (candidate.adjustments));\n@@ -1177,9 +1172,6 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n \t\t\t\t       TyTy::TyVar (resolved_base->get_ref ()),\n \t\t\t\t       expr.get_mut ());\n-\n-    // mark the borrowed as address_taken\n-    AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n@@ -1350,10 +1342,6 @@ class TypeCheckExpr : public TypeCheckBase\n \t  }\n       }\n \n-    // mark the required tree addressable\n-    if (Adjuster::needs_address (candidate.adjustments))\n-      AddressTakenResolver::SetAddressTaken (*expr.get_expr ().get ());\n-\n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n \t\t\t\t\tstd::move (candidate.adjustments));"}]}