{"sha": "92d6db668f528856cbc05ed1f5886b3b69378be4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJkNmRiNjY4ZjUyODg1NmNiYzA1ZWQxZjU4ODZiM2I2OTM3OGJlNA==", "commit": {"author": {"name": "Linas Vepstas", "email": "linas@linas.org", "date": "1999-07-19T19:26:30Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-19T19:26:30Z"}, "message": "Bulk patch from Linas.\n\nFrom-SVN: r28178", "tree": {"sha": "6ffd326f133aefd3b97453e6d03f49a2989ee9c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ffd326f133aefd3b97453e6d03f49a2989ee9c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92d6db668f528856cbc05ed1f5886b3b69378be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d6db668f528856cbc05ed1f5886b3b69378be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92d6db668f528856cbc05ed1f5886b3b69378be4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92d6db668f528856cbc05ed1f5886b3b69378be4/comments", "author": {"login": "linas", "id": 94368, "node_id": "MDQ6VXNlcjk0MzY4", "avatar_url": "https://avatars.githubusercontent.com/u/94368?v=4", "gravatar_id": "", "url": "https://api.github.com/users/linas", "html_url": "https://github.com/linas", "followers_url": "https://api.github.com/users/linas/followers", "following_url": "https://api.github.com/users/linas/following{/other_user}", "gists_url": "https://api.github.com/users/linas/gists{/gist_id}", "starred_url": "https://api.github.com/users/linas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/linas/subscriptions", "organizations_url": "https://api.github.com/users/linas/orgs", "repos_url": "https://api.github.com/users/linas/repos", "events_url": "https://api.github.com/users/linas/events{/privacy}", "received_events_url": "https://api.github.com/users/linas/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "14eee79459be0f2117f8f4b6a8885af0d17b50c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14eee79459be0f2117f8f4b6a8885af0d17b50c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14eee79459be0f2117f8f4b6a8885af0d17b50c2"}], "stats": {"total": 4719, "additions": 3730, "deletions": 989}, "files": [{"sha": "6c8acf92706bb91185f6183fdbd7a84a785e2c4f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -1,3 +1,72 @@\n+1999-07-19  Linas Vepstas  <linas@linas.org>\n+\n+\t* config/i370/README: New file.\n+\t* config/i370/linux.h: New file.\n+\t* config/i370/mvs.h: New file.\n+\t* config/i370/oe.h: New file.\n+\t* config/i370/t-linux: New file.\n+\t* config/i370/t-mvs: New file.\n+\t* config/i370/t-oe: New file.\n+\t* config/i370/x-oe: New file.\n+\t* config/i370/xm-linux.h: New file.\n+\t* config/i370/xm-mvs.h: New file.\n+\t* config/i370/xm-oe.h: New file.\n+\n+\t* i370.c (label_node_t): Add first_ref_page, label_addr, \n+\tlabel_first_ref, label_last_ref members.\n+\t(mvs_need_base_reload): Renamed from mvs_label_emitted.\n+\t(MAX_MVS_LABEL_SIZE): Define.\n+\t(MAX_LONG_LABEL_SIZE): Define.\n+\t(alias_node_t, alias_anchor, alias_number): New.\n+\t(mvs_function_table): Reorder for EBCDIC.\n+\t(ascebc, ebcasc): Unconditionally define.\n+\t(i370_branch_dest, i370_branch_length): New functions.\n+\t(i370_short_branch, i370_label_scan): New functions.\n+\t(mvs_get_label): Renamed from mvs_add_label.  Search for\n+\tan existing label before creating a new one.\n+\t(mvs_add_label): New function.\n+\t(mvs_get_label_page): New function.\n+\t(mvs_free_label_list): Renamed from mvs_free_label.  Iterate\n+\tover the entire list.\n+\t(mvs_check_page) [TARGET_HLASM]: Use BASR not BALR.\n+\t(mvs_check_page) [TARGET_ELF_ABI]: New function.\n+\t(mvs_add_alias, mvs_need_alias): New functions.\n+\t(mvs_get_alias, mvs_check_alias): New functions.\n+\t(handle_pragma): New function.\n+\t(mvs_function_check): New function.\n+\t(unsigned_jump_follows_p): Search harder.\n+\t(i370_function_prolog) [TARGET_HLASM]: Handle LE370.  Scan labels.\n+\t(i370_function_prolog) [TARGET_ELF_ABI]: New function.\n+\t* i370.h (TARGET_VERSION): Delete.\n+\t(CPP_SPEC, CPP_PREDEFINES): Delete.\n+\t(mvs_label_emitted): Delete.\n+\t(TARGET_EBCDIC): Delete.\n+\t(MAP_CHARACTER): Define only if TARGET_EBCDIC.\n+\t(HANDLE_PRAGMA): Define.\n+\t(HARD_REGNO_NREGS): Handle complex modes.\n+\t(HARD_REGNO_MODE_OK): Likewise.\n+\t(CLASS_MAX_NREGS): Likewise.\n+\t(RET_REG): Likewise.\n+\t(EXTRA_CONSTRAINT): Define.\n+\t(RETURN_IN_MEMORY): True for DImode.\n+\t(TRAMPOLINE_TEMPLATE): Use gen_rtx instead of GEN_INT.\n+\t(FUNCTION_PROFILER): Delete.\n+\t(COUNT_REGS): Fail if REG_P but not REG_OK_FOR_BASE_P.\n+\t(NOTICE_UPDATE_CC): Correct handling of MULT, DIV, logicals and shifts.\n+\t(TARGET_ESC, TARGET_BELL): Conditionally define for TARGET_EBCDIC.\n+\t(TARGET_BS, TARGET_TAB, TARGET_NEWLINE): Likewise.\n+\t(TARGET_VT, TARGET_FF, TARGET_CR): Likewise.\n+\t(ASM_FILE_START): Add \"RMODE ANY\".\n+\t(ASM_OUTPUT_EXTERNAL): Check for aliases.\n+\t(ASM_GLOBALIZE_LABEL): Likewise.\n+\t(ASM_OUTPUT_LABELREF): Likewise.\n+\t(ASM_OUTPUT_COMMON): Likewise.\n+\t(PRINT_OPERAND): Handle 'K', 'W', default.\n+\t(PRINT_OPERAND_ADDRESS): New.\n+\t(Lots of defines): Add support for TARGET_ELF_ABI.\n+\t* i370.md (attr length): New.  Define for all patterns.\n+\t(*): Lots of tweeks to assembly output and constraints.\n+\n Mon Jul 19 15:09:29 1999  David Edelsohn  <edelsohn@gnu.org>\n \n \t* rs6000.md (arithmetic, logical, and shift Rc combiner patterns):"}, {"sha": "5bf99f5beee1db4241a7f03b42ee6f113fcca4eb", "filename": "gcc/config/i370/README", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2FREADME?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,87 @@\n+\n+This directory contains code for building a compiler for the\n+32-bit ESA/390 architecture.  It supports three different styles \n+of assembly:\n+\n+-- MVS for use with the HLASM assembler\n+-- Open Edition (USS Unix System Services) \n+-- ELF/Linux for use with the binutils/gas GNU assembler.\n+\n+\n+Cross-compiling Hints\n+---------------------\n+When building a cross-compiler on AIX, set the environment variable CC\n+and be sure to set the -ma and -qcpluscmt flags; i.e.\n+\n+   export CC=\"cc -ma -qcpluscmt\"\n+\n+do this *before* running configure, e.g.\n+\n+   configure --target=i370-ibm-linux --prefix=/where/to/install/usr\n+\n+The Objective-C and FORTRAN front ends don't build.  To avoid looking at\n+errors, do only \n+\n+   make LANGUAGES=c\n+\n+\n+OpenEdition Hints\n+-----------------\n+The shell script \"install\" is handy for users of OpenEdition.\n+\n+\n+ChangeLog\n+---------\n+Oct98-Dec98 -- add ELF back end; work on getting ABI more or less correct.\n+98.12.05 -- fix numerous MVC bugs\n+99.02.06 -- multiply insn sometimes not generated when needed.\n+         -- extendsidi bugs, bad literal values printed\n+         -- remove broken adddi subdi patterns\n+99.02.15 -- add clrstrsi pattern\n+         -- fix -O2 divide bug\n+99.03.04 -- base & index reg usage bugs\n+99.03.15 -- fixes for returning long longs and structs (struct value return)\n+99.03.29 -- fix handling & alignment of shorts\n+99.03.31 -- clobbered register 14 is not always clobbered\n+99.04.02 -- operand constraints for cmphi\n+99.04.07 -- function pointer fixes for call, call_value patterns,\n+            function pointers derefed once too often.\n+99.04.14 -- add pattern to print double-wide int\n+         -- check intval<4096 for misc operands\n+         -- add clrstrsi pattern\n+         -- movstrsi fixes\n+99.04.16 -- use r2 to pass args into r11 in subroutine call.\n+         -- fixes to movsi; some operand combinations impossible;\n+            rework constraints\n+         -- start work on forward jump optimization\n+         -- char alignment bug\n+99.04.25 -- add untyped_call pattern so that builtin_apply works\n+99.04.27 -- fixes to compare logical under mask\n+99.04.28 -- reg 2 is clobbered by calls\n+99.04.30 -- fix rare mulsi bug\n+99.04.30 -- add constraints so that all RS, SI, SS forms insns have valid\n+            addressing modes\n+99.04.30 -- major condition code fixes. The old code was just way off \n+            w.r.t. which insns set condition code, and the codes that\n+            were set.  The extent of this damage was unbeleivable.\n+99.05.01 -- restructuring of operand constraints on many patterns,\n+            many lead to invalid instructions being genned.\n+99.05.02 -- float pt fixes\n+         -- fix movdi issue bugs\n+99.05.03 -- fix divide insn; was dividing incorrectly\n+99.05.05 -- fix sign extension problems on andhi\n+         -- deprecate some constraints\n+99.05.06 -- add set_attr insn lengths; fix misc litpool sizes\n+         -- add notes about how unsigned jumps work (i.e. \n+            arithmetic vs. logical vs. signed vs unsigned).\n+99.05.11 -- use insn length to predict forward branch target;\n+            use relative branchining where possible,\n+            remove un-needed base register reload.\n+99.05.15 -- fix movstrsi, clrstrsi, cmpstrsi patterns as per conversation \n+            w/ Richard Henderson\n+\n+\n+\n+\n+\n+"}, {"sha": "8287c92e09fccb80ce068af899c3ff0f9779672e", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 980, "deletions": 72, "changes": 1052, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -1,7 +1,8 @@\n /* Subroutines for insn-output.c for System/370.\n    Copyright (C) 1989, 1993, 1995, 1997 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for MVS C/370 by Dave Pitts (dpitts@nyx.cs.du.edu)\n+   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n+   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org) \n \n This file is part of GNU CC.\n \n@@ -24,7 +25,11 @@ Boston, MA 02111-1307, USA.  */\n #include <stdio.h>\n #include <string.h>\n #include <ctype.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>  \n #include \"rtl.h\"\n+#include \"tree.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\"\n@@ -35,26 +40,34 @@ Boston, MA 02111-1307, USA.  */\n #include \"insn-attr.h\"\n #include \"flags.h\"\n #include \"recog.h\"\n-#ifdef sun\n-#include <sys/types.h>\n-#include <ctype.h>\n-#endif\n #include <time.h>\n \n+extern FILE *asm_out_file;\n+\n+/* Label node.  This structure is used to keep track of labels \n+      on the various pages in the current routine.\n+   The label_id is the numeric ID of the label,\n+   The label_page is the page on which it actually appears,\n+   The first_ref_page is the page on which the true first ref appears.\n+   The label_addr is an estimate of its location in the current routine,\n+   The label_first & last_ref are estimates of where the earliest and\n+      latest references to this label occur.                                     */\n \n-/* Label node, this structure is used to keep track of labels on the\n-   current page.  */\n typedef struct label_node\n   {\n     struct label_node *label_next;\n     int label_id;\n     int label_page;\n+    int first_ref_page;\n+\n+    int label_addr;\n+    int label_first_ref;\n+    int label_last_ref;\n   }\n label_node_t;\n \n-/* Is 1 when a label has been generated and the base register must be\n-   reloaded.  */\n-int mvs_label_emitted = 0;\n+/* Is 1 when a label has been generated and the base register must be reloaded.  */\n+int mvs_need_base_reload = 0;\n \n /* Current function starting base page.  */\n int function_base_page;\n@@ -83,23 +96,65 @@ static label_node_t *free_anchor = 0;\n /* Assembler source file descriptor.  */\n static FILE *assembler_source = 0;\n \n+label_node_t * mvs_get_label ();\n+\n+/* ===================================================== */\n+/* defines and functions specific to the HLASM assembler */\n+#ifdef TARGET_HLASM\n+\n+#ifndef MAX_MVS_LABEL_SIZE\n+#define MAX_MVS_LABEL_SIZE 8\n+#endif\n+\n+#define MAX_LONG_LABEL_SIZE 255\n+\n+/* Alias node, this structure is used to keep track of aliases to external\n+   variables. The IBM assembler allows an alias to an external name \n+   that is longer that 8 characters; but only once per assembly.\n+   Also, this structure stores the #pragma map info.  */\n+typedef struct alias_node\n+  {\n+    struct alias_node *alias_next;\n+    int  alias_emitted;\n+    char alias_name [MAX_MVS_LABEL_SIZE + 1];\n+    char real_name [MAX_LONG_LABEL_SIZE + 1];\n+  }\n+alias_node_t;\n+\n+/* Alias node list anchor.  */\n+static alias_node_t *alias_anchor = 0;\n+\n+/* Alias number */\n+static alias_number = 0;\n+\n /* Define the length of the internal MVS function table.  */\n #define MVS_FUNCTION_TABLE_LENGTH 32\n \n /* C/370 internal function table.  These functions use non-standard linkage\n    and must handled in a special manner.  */\n static char *mvs_function_table[MVS_FUNCTION_TABLE_LENGTH] =\n {\n+#if defined(HOST_EBCDIC) /* Changed for EBCDIC collating sequence */\n+   \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_atan\", \"edc_ata2\", \"edc_cos\",\n+   \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n+   \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n+   \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"jn\",\n+   \"j0\",       \"j1\",       \"ldexp\",    \"modf\",     \"pow\",      \"yn\",\n+   \"y0\",       \"y1\"\n+#else\n    \"ceil\",     \"edc_acos\", \"edc_asin\", \"edc_ata2\", \"edc_atan\", \"edc_cos\",\n    \"edc_cosh\", \"edc_erf\",  \"edc_erfc\", \"edc_exp\",  \"edc_gamm\", \"edc_lg10\",\n    \"edc_log\",  \"edc_sin\",  \"edc_sinh\", \"edc_sqrt\", \"edc_tan\",  \"edc_tanh\",\n    \"fabs\",     \"floor\",    \"fmod\",     \"frexp\",    \"hypot\",    \"j0\",\n    \"j1\",       \"jn\",       \"ldexp\",    \"modf\",     \"pow\",      \"y0\",\n    \"y1\",       \"yn\"\n+#endif\n };\n \n+#endif /* TARGET_HLASM */\n+/* ===================================================== */\n+\n /* ASCII to EBCDIC conversion table.  */\n-#if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)\n static unsigned char ascebc[256] =\n {\n  /*00  NL    SH    SX    EX    ET    NQ    AK    BL */\n@@ -151,10 +206,8 @@ static unsigned char ascebc[256] =\n      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,\n      0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0xFF\n };\n-#endif\n \n /* EBCDIC to ASCII conversion table.  */\n-#if defined(HOST_EBCDIC) && !defined(TARGET_EBCDIC)\n unsigned char ebcasc[256] =\n {\n  /*00  NU    SH    SX    EX    PF    HT    LC    DL */\n@@ -222,7 +275,6 @@ unsigned char ebcasc[256] =\n  /*F8   8     9                                     */\n      0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF\n };\n-#endif\n \n /* Map characters from one character set to another.\n    C is the character to be translated.  */\n@@ -232,26 +284,278 @@ mvs_map_char (c)\n      char c;\n {\n #if defined(TARGET_EBCDIC) && !defined(HOST_EBCDIC)\n+  fprintf (stderr, \"mvs_map_char: TE & !HE: c = %02x\\n\", c);\n   return ascebc[c];\n #else\n #if defined(HOST_EBCDIC) && !defined(TARGET_EBCDIC)\n+  fprintf (stderr, \"mvs_map_char: !TE & HE: c = %02x\\n\", c);\n   return ebcasc[c];\n #else\n+  fprintf (stderr, \"mvs_map_char: !TE & !HE: c = %02x\\n\", c);\n   return c;\n #endif\n #endif\n }\n \n+/* ===================================================== */\n+/* The following three routines are used to determine whther \n+   forward branch is on this page, or is a far jump.  We use\n+   the \"length\" attr on an insn [(set_atter \"length\" \"4\")]\n+   to store the largest possible code length that insn\n+   could have.  This gives us a hint of the address of a\n+   branch destination, and from that, we can work out \n+   the length of the jump, and whether its on page or not. \n+ */\n+\n+/* Return the destination address of a branch.  */\n+\n+int\n+i370_branch_dest (branch)\n+     rtx branch;\n+{\n+  rtx dest = SET_SRC (PATTERN (branch));\n+  int dest_uid;\n+  int dest_addr;\n+\n+  /* first, compute the estimated address of the branch target */\n+  if (GET_CODE (dest) == IF_THEN_ELSE)\n+    dest = XEXP (dest, 1);\n+  dest = XEXP (dest, 0);\n+  dest_uid = INSN_UID (dest);\n+  dest_addr =  insn_addresses[dest_uid];\n+\n+  /* next, record the address of this insn as the true addr of first ref */\n+  {\n+     label_node_t *lp;\n+     rtx label = JUMP_LABEL (branch);\n+     int labelno = CODE_LABEL_NUMBER (label);\n+\n+     if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n+\n+     lp = mvs_get_label (labelno);\n+     if (-1 == lp -> first_ref_page) lp->first_ref_page = mvs_page_num;\n+  }\n+  return dest_addr;\n+}\n+\n+int\n+i370_branch_length (insn)\n+     rtx insn;\n+{\n+  int here, there;\n+  here = insn_addresses[INSN_UID (insn)];\n+  there = i370_branch_dest (insn);\n+  return (there - here);\n+}\n+\n+\n+int\n+i370_short_branch (insn)\n+     rtx insn;\n+{\n+  int base_offset;\n+\n+  base_offset = i370_branch_length(insn);\n+  if (0 > base_offset) \n+    {\n+      base_offset += mvs_page_code;\n+    } \n+  else \n+    {\n+      /* avoid bumping into lit pool; use 2x to estimate max possible lits */\n+      base_offset *= 2;\n+      base_offset += mvs_page_code + mvs_page_lit;\n+    }\n+  \n+  /* make a conservative estimate of room left on page */\n+  if ((4060 >base_offset) && ( 0 < base_offset)) return 1;\n+  return 0;\n+}\n+\n+/* The i370_label_scan() routine is supposed to loop over\n+   all labels and label references in a compilation unit,\n+   and determine whether all label refs appear on the same \n+   code page as the label. If they do, thenm we can avoid \n+   a reload of the base register for that label.\n+  \n+   Note that the instruciton addresses used here are only \n+   approximate, and make the sizes of the jumps appear\n+   farther apart then they will actually be.  This makes \n+   this code far more conservative than it needed to be.\n+ */\n+\n+#define I370_RECORD_LABEL_REF(label,addr) {\t\t\t\t\\\n+\tlabel_node_t *lp;\t\t\t\t\t\t\\\n+\tint labelno = CODE_LABEL_NUMBER (label);\t\t\t\\\n+\tlp = mvs_get_label (labelno);\t\t\t\t\t\\\n+\tif (addr < lp -> label_first_ref) lp->label_first_ref = addr;\t\\\n+\tif (addr > lp -> label_last_ref) lp->label_last_ref = addr;\t\\\n+}\n+\n+void \n+i370_label_scan (void) \n+{\n+   rtx insn;\n+   label_node_t *lp;\n+   int tablejump_offset = 0;\n+\n+   for (insn = get_insns(); insn; insn = NEXT_INSN(insn))\n+     {\n+       int here = insn_addresses[INSN_UID (insn)];\n+       enum rtx_code code = GET_CODE(insn);\n+\n+       /* ??? adjust for tables embedded in the .text section that\n+        * the compiler didn't take into account */\n+       here += tablejump_offset;\n+       insn_addresses[INSN_UID (insn)] = here;\n+\n+       /* check to see if this insn is a label ... */\n+       if (CODE_LABEL == code)\n+         {\n+           int labelno = CODE_LABEL_NUMBER (insn);\n+\n+           lp = mvs_get_label (labelno);\n+           lp -> label_addr = here;\n+#if 0\n+           /* Supposedly, labels are supposed to have circular\n+              lists of label-refs that reference them, \n+              setup in flow.c, but this does not appear to be the case.  */\n+           rtx labelref = LABEL_REFS (insn);\n+           rtx ref = labelref;\n+           do \n+             {\n+               rtx linsn = CONTAINING_INSN(ref);\n+               ref =  LABEL_NEXTREF(ref);\n+             } while (ref && (ref != labelref));\n+#endif\n+         }\n+       else\n+       if (JUMP_INSN == code)\n+         {\n+           rtx label = JUMP_LABEL (insn);\n+           int labelno;\n+\n+           /* If there is no label for this jump, then this\n+              had better be a ADDR_VEC or an ADDR_DIFF_VEC\n+              and there had better be a vector of labels.   */\n+           if (!label) \n+             {\n+               int j;\n+               rtx body = PATTERN (insn);\n+               if (ADDR_VEC == GET_CODE(body)) \n+                 {\n+                    for (j=0; j < XVECLEN (body, 0); j++)\n+                      {\n+                         int labelno;\n+                         rtx lref = XVECEXP (body, 0, j);\n+                         if (LABEL_REF != GET_CODE (lref)) abort ();\n+                         label = XEXP (lref,0);\n+                         if (CODE_LABEL != GET_CODE (label)) abort ();\n+                         tablejump_offset += 4;\n+                         here += 4;\n+                         I370_RECORD_LABEL_REF(label,here);\n+                      }\n+                    /* finished with the vector go do next insn */\n+                    continue;\n+                 }\n+               else\n+               if (ADDR_DIFF_VEC == GET_CODE(body))\n+                 {\n+/* XXX hack alert.\n+   Right now, we leave this as a no-op, but strictly speaking,\n+   this is incorrect.  It is possible that a table-jump\n+   driven off of a relative address could take us off-page,\n+   to a place where we need to reload the base reg.  So really,\n+   we need to examing both labels, and compare thier values\n+   to the current basereg value.\n+  \n+   More generally, this brings up a troubling issue overall:\n+   what happens if a tablejump is split across two pages? I do \n+   not beleive that this case is handled correctly at all, and\n+   can only lead to horrible results if this were to occur.\n+  \n+   However, the current situation is not any worse than it was \n+   last week, and so we punt for now.\n+ */\n+                    debug_rtx (insn);\n+// abort();\n+                    for (j=0; j < XVECLEN (body, 0); j++)\n+                      {\n+                         int labelno;\n+                      }\n+                    /* finished with the vector go do next insn */\n+                    continue;\n+                 }\n+               else \n+                 {\n+/* The following appears during make of _eh in libgcc2.a\n+   while not obviously wrong, its weird, so not obviously \n+   right either ...\n+   (jump_insn:HI 125 124 126 (set (pc)\n+         (mem:SI (plus:SI (reg/v:SI 1 r1)\n+                 (const_int 4)))) 144 {indirect_jump} (nil)\n+ */\n+                    debug_rtx (insn);\n+//                    abort();\n+                    continue;\n+                 }\n+            }\n+\n+          /* At this point, this jump_insn had better be a plain-old\n+           * ordinary one, grap the label id and go */\n+          if (CODE_LABEL != GET_CODE (label)) abort ();\n+          I370_RECORD_LABEL_REF(label,here);\n+        }\n+\n+      /* Sometimes, we take addresses of labels and use them\n+         as instruction operands ... these show up as REG_NOTES */\n+      else\n+      if (INSN == code)\n+       {\n+         if ('i' == GET_RTX_CLASS (code)) \n+           {\n+              rtx note;\n+              for (note = REG_NOTES (insn); note;  note = XEXP(note,1))\n+                {\n+                   if (REG_LABEL == REG_NOTE_KIND(note))\n+                     {\n+                        rtx label = XEXP (note,0);\n+                        if (!label || CODE_LABEL != GET_CODE (label)) abort ();\n+\n+                        I370_RECORD_LABEL_REF(label,here);\n+                     }\n+                }\n+           }\n+       }\n+   }\n+}\n+\n+/* ===================================================== */\n+\n /* Emit reload of base register if indicated.  This is to eliminate multiple\n    reloads when several labels are generated pointing to the same place\n-   in the code.  */\n+   in the code.  \n+\n+   The page table is written at the end of the function. \n+   The entries in the page table look like\n+     .LPGT0:          // PGT0 EQU *\n+     .long .LPG0      // DC A(PG0)\n+     .long .LPG1      // DC A(PG1)\n+  while the prologue generates\n+      L       r4,=A(.LPGT0)\n+\n+  Note that this paging scheme breaks down if a single subroutine \n+  has more than about 10MB of code in it ... as long as humans write\n+  code, this shouldn't be a problem ...\n+ */\n \n int\n check_label_emit (void)\n {\n-  if (mvs_label_emitted)\n+  if (mvs_need_base_reload)\n     {\n-      mvs_label_emitted = 0;\n+      mvs_need_base_reload = 0;\n+\n       mvs_page_code += 4;\n       fprintf (assembler_source, \"\\tL\\t%d,%d(,%d)\\n\",\n \t  BASE_REGISTER, (mvs_page_num - function_base_page) * 4,\n@@ -264,34 +568,90 @@ check_label_emit (void)\n    allocated from memory.\n    ID is the label number of the label being added to the list.  */\n \n-int\n-mvs_add_label (id)\n+label_node_t *\n+mvs_get_label (id)\n      int id;\n {\n   label_node_t *lp;\n \n+  /* first, lets see if we already go one, if so, use that. */\n+  for (lp = label_anchor; lp; lp = lp->label_next)\n+    {\n+      if (lp->label_id == id) return lp;\n+    }\n+\n+  /* not found, get a new one */\n   if (free_anchor)\n     {\n       lp = free_anchor;\n       free_anchor = lp->label_next;\n     }\n   else\n     {\n-      lp = (label_node_t *) malloc (sizeof (label_node_t));\n-      if (lp == 0)\n-\t{\n-\t  fatal (\"virtual memory exhausted\\n\");\n-\t  abort ();\n-\t}\n+      lp = (label_node_t *) xmalloc (sizeof (label_node_t));\n     }\n+\n+  /* initialize for new label */\n   lp->label_id = id;\n-  lp->label_page = mvs_page_num;\n+  lp->label_page = -1;\n   lp->label_next = label_anchor;\n+  lp->label_first_ref = 2000123123;\n+  lp->label_last_ref = -1;\n+  lp->label_addr = -1;\n+  lp->first_ref_page = -1;\n   label_anchor = lp;\n+\n+  return lp;\n }\n \n-/* Check to see if the label is in the list.  If 1 is returned then a load\n-   and branch on register must be generated.\n+void\n+mvs_add_label (id)\n+     int id;\n+{\n+  label_node_t *lp;\n+  int fwd_distance;\n+\n+  lp = mvs_get_label (id);\n+  lp->label_page = mvs_page_num;\n+\n+  /* OK, we just saw the label.  Determine if this label\n+   * needs a reload of the base register */\n+  if ((-1 != lp->first_ref_page) && \n+      (lp->first_ref_page != mvs_page_num)) \n+    {\n+      /* Yep; the first label_ref was on a different page. */\n+      mvs_need_base_reload ++;\n+      return;\n+    }\n+\n+  /* Hmm.  Try to see if the estimated address of the last\n+     label_ref is on the current page.  If it is, then we\n+     don't need a base reg reload.  Note that this estimate\n+     is very conservatively handled; we'll tend to have \n+     a good bit more reloads than actually needed.  Someday,\n+     we should tighten the estimates (which are driven by\n+     the (set_att \"length\") insn attibute.\n+    \n+     Currently, we estimate that number of page literals \n+     same as number of insns, which is a vast overestimate,\n+     esp that the estimate of each insn size is its max size.  */\n+\n+  /* if latest ref comes before label, we are clear */\n+  if (lp->label_last_ref < lp->label_addr) return;\n+\n+  fwd_distance = lp->label_last_ref - lp->label_addr;\n+\n+  if (mvs_page_code + 2*fwd_distance + mvs_page_lit < 4060) return;\n+\n+  mvs_need_base_reload ++;\n+}\n+\n+/* Check to see if the label is in the list and in the current\n+   page.  If not found, we have to make worst case assumption \n+   that label will be on a different page, and thus will have to\n+   generate a load and branch on register.  This is rather\n+   ugly for forward-jumps, but what can we do? For backward\n+   jumps on the same page we can branch directly to address.\n    ID is the label number of the label being checked.  */\n \n int\n@@ -302,27 +662,55 @@ mvs_check_label (id)\n \n   for (lp = label_anchor; lp; lp = lp->label_next)\n     {\n-      if (lp->label_id == id)\n-\treturn 1;\n+      if (lp->label_id == id) \n+        {\n+          if (lp->label_page == mvs_page_num) \n+            {\n+               return 1;\n+            } \n+          else \n+            {\n+\t       return 0;\n+            } \n+        }\n     }\n   return 0;\n }\n \n+/* Get the page on which the label sits.  This will be used to \n+   determine is a register reload is really needed.  */\n+\n+int\n+mvs_get_label_page(int id)\n+{\n+  label_node_t *lp;\n+\n+  for (lp = label_anchor; lp; lp = lp->label_next)\n+    {\n+      if (lp->label_id == id)\n+\treturn lp->label_page;\n+    }\n+  return -1;\n+}\n+\n /* The label list for the current page freed by linking the list onto the free\n    label element chain.  */\n \n-int\n-mvs_free_label (void)\n+void\n+mvs_free_label_list (void)\n {\n+\n   if (label_anchor)\n     {\n-      if (free_anchor)\n-\tlabel_anchor->label_next = free_anchor;\n+      label_node_t *last_lp = label_anchor;\n+      while (last_lp->label_next) last_lp = last_lp->label_next;\n+      last_lp->label_next = free_anchor;\n       free_anchor = label_anchor;\n     }\n   label_anchor = 0;\n }\n \n+/* ====================================================================== */\n /* If the page size limit is reached a new code page is started, and the base\n    register is set to it.  This page break point is counted conservatively,\n    most literals that have the same value are collapsed by the assembler.\n@@ -331,6 +719,7 @@ mvs_free_label (void)\n    CODE is the length, in bytes, of the instruction to be emitted.\n    LIT is the length of the literal to be emitted.  */\n \n+#ifdef TARGET_HLASM\n int\n mvs_check_page (file, code, lit)\n      FILE *file;\n@@ -348,10 +737,11 @@ mvs_check_page (file, code, lit)\n       fprintf (assembler_source, \"PGE%d\\tEQU\\t*\\n\", mvs_page_num);\n       fprintf (assembler_source, \"\\tDROP\\t%d\\n\", BASE_REGISTER);\n       mvs_page_num++;\n-      fprintf (assembler_source, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n+      /* Safe to use BASR not BALR, since we are\n+       * not switching addressing mode here ... */\n+      fprintf (assembler_source, \"\\tBASR\\t%d,0\\n\", BASE_REGISTER);\n       fprintf (assembler_source, \"PG%d\\tEQU\\t*\\n\", mvs_page_num);\n       fprintf (assembler_source, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-      mvs_free_label ();\n       mvs_page_code = code;\n       mvs_page_lit = lit;\n       return 1;\n@@ -360,6 +750,53 @@ mvs_check_page (file, code, lit)\n   mvs_page_lit += lit;\n   return 0;\n }\n+#endif /* TARGET_HLASM */\n+\n+\n+#ifdef TARGET_ELF_ABI\n+int\n+mvs_check_page (file, code, lit)\n+     FILE *file;\n+     int code, lit;\n+{\n+  if (file)\n+    assembler_source = file;\n+\n+  if (mvs_page_code + code + mvs_page_lit + lit > MAX_MVS_PAGE_LENGTH)\n+    {\n+      /* hop past the literal pool */\n+      fprintf (assembler_source, \"\\tB\\t.LPGE%d\\n\", mvs_page_num);\n+\n+      /* dump the literal pool. The .baligns are optional, since \n+       * ltorg will align to the size of the largest literal \n+       * (which is possibly 8 bytes) */\n+      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n+      fprintf (assembler_source, \"\\t.LTORG\\n\");\n+      fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n+\n+      /* we continue execution here ... */\n+      fprintf (assembler_source, \".LPGE%d:\\n\", mvs_page_num);\n+      fprintf (assembler_source, \"\\t.DROP\\t%d\\n\", BASE_REGISTER);\n+      mvs_page_num++;\n+\n+      /* BASR puts the contents of the PSW into r3\n+       * that is, r3 will be loaded with the address of \".\" */\n+      fprintf (assembler_source, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n+      fprintf (assembler_source, \".LPG%d:\\n\", mvs_page_num);\n+      fprintf (assembler_source, \"\\t.USING\\t.,r%d\\n\", BASE_REGISTER);\n+      mvs_page_code = code;\n+      mvs_page_lit = lit;\n+      return 1;\n+    }\n+  mvs_page_code += code;\n+  mvs_page_lit += lit;\n+  return 0;\n+}\n+#endif /* TARGET_ELF_ABI */\n+\n+/* ===================================================== */\n+/* defines and functions specific to the HLASM assembler */\n+#ifdef TARGET_HLASM\n \n /* Check for C/370 runtime function, they don't use standard calling\n    conventions.  True is returned if the function is in the table.\n@@ -389,6 +826,253 @@ mvs_function_check (name)\n }\n \n \n+/* Add the alias to the current alias list.  */\n+\n+int\n+mvs_add_alias (realname, aliasname, emitted)\n+     char *realname;\n+     char *aliasname;\n+     int   emitted;\n+{\n+  alias_node_t *ap;\n+\n+  ap = (alias_node_t *) xmalloc (sizeof (alias_node_t));\n+  strcpy (ap->real_name, realname);\n+  strcpy (ap->alias_name, aliasname);\n+  ap->alias_emitted = emitted;\n+  ap->alias_next = alias_anchor;\n+  alias_anchor = ap;\n+}\n+\n+/* Check to see if the name needs aliasing */\n+\n+int\n+mvs_need_alias (realname)\n+      char *realname;\n+{\n+   if (mvs_function_check (realname))\n+     return 0;\n+   if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n+     return 1;\n+   if (strchr (realname, '_') != 0)\n+     return 1;\n+   return 0;\n+}\n+\n+/* Get the alias from the list. \n+   If 1 is returned then it's in the alias list, 0 if it was not */\n+\n+int\n+mvs_get_alias (realname, aliasname)\n+     char *realname;\n+     char *aliasname;\n+{\n+#ifdef LONGEXTERNAL\n+  alias_node_t *ap;\n+\n+  for (ap = alias_anchor; ap; ap = ap->alias_next)\n+    {\n+      if (!strcmp (ap->real_name, realname))\n+\t{\n+\t  strcpy (aliasname, ap->alias_name);\n+\t  return 1;\n+\t}\n+    }\n+  if (mvs_need_alias (realname))\n+    {\n+      sprintf (aliasname, \"ALS%05d\", alias_number++);\n+      mvs_add_alias (realname, aliasname, 0);\n+      return 1;\n+    }\n+#else\n+  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n+    {\n+      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n+      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n+      return 1;\n+    }\n+#endif\n+  return 0;\n+}\n+\n+/* Check to see if the alias is in the list. \n+   If 1 is returned then it's in the alias list, 2 it was emitted  */\n+\n+int\n+mvs_check_alias (realname, aliasname)\n+     char *realname;\n+     char *aliasname;\n+{\n+#ifdef LONGEXTERNAL\n+  alias_node_t *ap;\n+\n+  for (ap = alias_anchor; ap; ap = ap->alias_next)\n+    {\n+      if (!strcmp (ap->real_name, realname))\n+\t{\n+\t  int rc = (ap->alias_emitted == 1) ? 1 : 2; \n+\t  strcpy (aliasname, ap->alias_name);\n+\t  ap->alias_emitted = 1; \n+\t  return rc;\n+\t}\n+    }\n+  if (mvs_need_alias (realname))\n+    {\n+      sprintf (aliasname, \"ALS%05d\", alias_number++);\n+      mvs_add_alias (realname, aliasname, 0);\n+      alias_anchor->alias_emitted = 1;\n+      return 2;\n+    }\n+#else\n+  if (strlen (realname) > MAX_MVS_LABEL_SIZE)\n+    {\n+      strncpy (aliasname, realname, MAX_MVS_LABEL_SIZE);\n+      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n+      return 1;\n+    }\n+#endif\n+  return 0;\n+}\n+\n+/* Called from check_newline via the macro HANDLE_PRAGMA.\n+   FINPUT is the source file input stream.\n+   NODE is the tree node for the token after the \"pragma\".\n+   The result is 1 if the pragma was handled.  */\n+\n+int\n+handle_pragma (finput, node)\n+     FILE *finput;\n+     tree node;\n+{\n+  int retval = 0;\n+  register int c;\n+  register char *pname;\n+\n+  if (TREE_CODE (node) != IDENTIFIER_NODE)\n+    return 0;\n+\n+  pname = IDENTIFIER_POINTER (node);\n+\n+  if (strcmp (pname, \"map\") == 0)\n+    {\n+      char realname[MAX_LONG_LABEL_SIZE + 1];\n+      char aliasname[MAX_MVS_LABEL_SIZE + 1];\n+      char *s;\n+\n+      do {\n+\tc = getc (finput);\n+      } while (c == ' ' || c == '\\t');\n+\n+      if (c == '(')\n+        {\n+\t  s = realname;\n+\t  do {\n+\t    c = getc (finput);\n+\t  } while (c == ' ' || c == '\\t');\n+\t  if (c == '\\n')\n+\t    goto PRAGMA_WARNING;\n+\t  do {\n+\t    *s++ = c;\n+\t    c = getc (finput);\n+\t  } while (isalnum(c) || c == '_');\n+\t  if (c == '\\n')\n+\t    goto PRAGMA_WARNING;\n+\t  *s = 0;\n+\n+\t  if (c == ' ' || c == '\\t')\n+\t    do {\n+\t      c = getc (finput);\n+\t    } while (c == ' ' || c == '\\t');\n+\t  \n+\t  if (c == ',')\n+\t    {\n+\t      do {\n+\t        c = getc (finput);\n+\t      } while (c == ' ' || c == '\\t');\n+\t      if (c == '\"')\n+\t        {\n+\t          s = aliasname;\n+\t          c = getc(finput);\n+\t          do {\n+\t            if (c == '\\\\')\n+\t              {\n+\t                int d = 0;\n+\t                do {\n+\t                  c = getc(finput);\n+\t                  if (c >= '0' && c <= '7')\n+\t                      d = (d << 3) | c - '0';\n+\t                } while (c >= '0' && c <= '7');\n+\t                ungetc (c, finput);\n+\t                c = d;\n+\t                if (d < 1 || d > 255)\n+\t\t\t  warning (\"Escape value out of range\");\n+#ifndef HOST_EBCDIC\n+                        c = ebcasc[c];\n+#endif\n+\t              }\n+\t            *s++ = c;\n+\t            c = getc (finput);\n+\t            if (isspace(c) || c == ')')\n+\t              goto PRAGMA_WARNING;\n+\t          } while (c != '\"');\n+\t          *s = 0;\n+\t\t  if (strlen (aliasname) > MAX_MVS_LABEL_SIZE)\n+\t\t    {\n+\t\t      warning (\"#pragma map alias is too long, truncated\");\n+\t\t      aliasname[MAX_MVS_LABEL_SIZE] = '\\0';\n+\t\t    }\n+\t\t  do {\n+\t\t    c = getc (finput);\n+\t\t  } while (c == ' ' || c == '\\t');\n+\t\t  if (c == ')')\n+\t\t    {\n+\t              mvs_add_alias (realname, aliasname, 1);\n+\t\t      retval = 1;\n+\t\t    }\n+\t          else\n+\t            goto PRAGMA_WARNING;\n+\t        }\n+\t      else\n+\t        goto PRAGMA_WARNING;\n+\t    }\n+\t  else\n+\t    goto PRAGMA_WARNING;\n+\t  \n+        }\n+      else\n+        {\n+\t PRAGMA_WARNING:\n+\t  warning (\"#pragma map options are missing or incorrect\");\n+        }\n+      \n+    }\n+\n+  return retval;\n+}\n+\n+/* defines and functions specific to the HLASM assembler */\n+#endif /* TARGET_HLASM */\n+/* ===================================================== */\n+/* ===================================================== */\n+/* defines and functions specific to the gas assembler */\n+#ifdef TARGET_ELF_ABI\n+\n+/* Check for C/370 runtime function, they don't use standard calling\n+   conventions.  True is returned if the function is in the table.\n+   NAME is the name of the current function.  */\n+/* no special calling conventions (yet ??) */\n+\n+int\n+mvs_function_check (name)\n+     char *name;\n+{\n+   return 0;\n+}\n+\n+#endif /* TARGET_ELF_ABI */\n+/* ===================================================== */\n+\n+\n /* Return 1 if OP is a valid S operand for an RS, SI or SS type instruction.\n    OP is the current operation.\n    MODE is the current operation mode.  */\n@@ -460,54 +1144,143 @@ r_or_s_operand (op, mode)\n }\n \n \n-/* Return 1 if the next instruction is an unsigned jump instruction.\n-   INSN is the current instruction.  */\n+/* Some remarks about unsigned_jump_follows_p():\n+   gcc is built around the assumption that branches are signed\n+   or unsigned, whereas the 370 doesn't care; its the compares that\n+   are signed or unsigned.  Thus, we need to somehow know if we\n+   need to do a signed or an unsigned compare, and we do this by \n+   looking ahead in the instruction sequence until we find a jump.\n+   We then note whether this jump is signed or unsigned, and do the \n+   compare appropriately.  Note that we have to scan ahead indefinitley,\n+   as the gcc optimizer may insert any number of instructions between \n+   the compare and the jump.\n+  \n+   Note that using conditional branch expanders seems to be be a more \n+   elegant/correct way of doing this.   See, for instance, the Alpha \n+   cmpdi and bgt patterns.  Note also that for the i370, various\n+   arithmetic insn's set the condition code as well.\n+\n+   The unsigned_jump_follows_p() routine  returns a 1 if the next jump \n+   is unsigned.  INSN is the current instruction.  */\n \n unsigned_jump_follows_p (insn)\n      register rtx insn;\n {\n-  insn = NEXT_INSN (insn);\n-  if (GET_CODE (insn) != JUMP_INSN)\n-    return 0;\n-\n-  insn = XEXP (insn, 3);\n-  if (GET_CODE (insn) != SET)\n-    return 0;\n+  rtx orig_insn = insn;\n+  while (1) \n+    {\n+      register rtx tmp_insn;\n+      enum rtx_code coda;\n+  \n+      insn = NEXT_INSN (insn);\n+      if (!insn) fatal_insn (\"internal error--no jump follows compare:\", orig_insn);\n+  \n+      if (GET_CODE (insn) != JUMP_INSN) continue;\n+    \n+      tmp_insn = XEXP (insn, 3);\n+      if (GET_CODE (tmp_insn) != SET) continue;\n+    \n+      if (GET_CODE (XEXP (tmp_insn, 0)) != PC) continue;\n+    \n+      tmp_insn = XEXP (tmp_insn, 1);\n+      if (GET_CODE (tmp_insn) != IF_THEN_ELSE) continue;\n+    \n+      /* if we got to here, this instruction is a jump.  Is it signed? */\n+      tmp_insn = XEXP (tmp_insn, 0);\n+      coda = GET_CODE (tmp_insn);\n+  \n+      return coda != GE && coda != GT && coda != LE && coda != LT;\n+    }\n+}\n \n-  if (GET_CODE (XEXP (insn, 0)) != PC)\n-    return 0;\n \n-  insn = XEXP (insn, 1);\n-  if (GET_CODE (insn) != IF_THEN_ELSE)\n-    return 0;\n-\n-  insn = XEXP (insn, 0);\n-  return GET_CODE (insn) != GE && GET_CODE (insn) != GT\n-    && GET_CODE (insn) != LE && GET_CODE (insn) != LT;\n-}\n+#ifdef TARGET_HLASM\n \n void\n i370_function_prolog (f, l)\n      FILE *f;\n      int l;\n {\n #if MACROPROLOGUE == 1\n+  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n   fprintf (f, \"\\tEDCPRLG USRDSAL=%d,BASEREG=%d\\n\",\n \t   STACK_POINTER_OFFSET + l - 120 +\n \t   current_function_outgoing_args_size, BASE_REGISTER);\n-  fprintf (f, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\n-  fprintf (f, \"\\tLR\\t11,1\\n\");\n-  fprintf (f, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  mvs_page_code = 6;\n-  mvs_page_lit = 4;\n-  mvs_check_page (f, 0, 0);\n-  function_base_page = mvs_page_num;\n #else /* MACROPROLOGUE != 1 */\n   static int function_label_index = 1;\n   static int function_first = 0;\n   static int function_year, function_month, function_day;\n   static int function_hour, function_minute, function_second;\n   int i;\n+#if defined(LE370)\n+  if (!function_first)\n+    {\n+      struct tm *function_time;\n+      time_t lcltime;\n+      time (&lcltime);\n+      function_time = localtime (&lcltime);\n+      function_year = function_time->tm_year + 1900;\n+      function_month = function_time->tm_mon + 1;\n+      function_day = function_time->tm_mday;\n+      function_hour = function_time->tm_hour;\n+      function_minute = function_time->tm_min;\n+      function_second = function_time->tm_sec;\n+    }\n+  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n+  fprintf (f, \"FDSE%03d\\tDSECT\\n\", function_label_index);\n+  fprintf (f, \"\\tDS\\tD\\n\");\n+  fprintf (f, \"\\tDS\\tCL(%d)\\n\", STACK_POINTER_OFFSET + l\n+\t\t\t+ current_function_outgoing_args_size);\n+  fprintf (f, \"\\tORG\\tFDSE%03d\\n\", function_label_index);\n+  fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n+  fprintf (f, \"\\tORG\\n\");\n+  fprintf (f, \"\\tDS\\t0D\\n\");\n+  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSE%03d-8\\n\", function_label_index,\n+\t   function_label_index);\n+  fprintf (f, \"\\tDS\\t0H\\n\");\n+  assemble_name (f, mvs_function_name);\n+  fprintf (f, \"\\tCSECT\\n\");\n+  fprintf (f, \"\\tUSING\\t*,15\\n\");\n+  fprintf (f, \"\\tB\\tFENT%03d\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tAL1(FNAM%03d+4-*)\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n+  fprintf (f, \"\\tDC\\tAL4(FPPA%03d)\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n+  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n+  fprintf (f, \"FNAM%03d\\tEQU\\t*\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n+\tmvs_function_name);\n+  fprintf (f, \"FPPA%03d\\tDS\\t0F\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tX'03',X'00',X'33',X'00'\\n\");\n+  fprintf (f, \"\\tDC\\tV(CEESTART)\\n\");\n+  fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n+  fprintf (f, \"\\tDC\\tAL4(FTIM%03d)\\n\", function_label_index);\n+  fprintf (f, \"FTIM%03d\\tDS\\t0F\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tCL4'%d',CL4'%02d%02d',CL6'%02d%02d00'\\n\",\n+  \t\t function_year, function_month, function_day,\n+    \t\t function_hour, function_minute, function_second);\n+  fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n+  fprintf (f, \"FENT%03d\\tDS\\t0H\\n\", function_label_index);\n+  fprintf (f, \"\\tSTM\\t14,12,12(13)\\n\");\n+  fprintf (f, \"\\tL\\t2,76(,13)\\n\");\n+  fprintf (f, \"\\tL\\t0,16(,15)\\n\");\n+  fprintf (f, \"\\tALR\\t0,2\\n\");\n+  fprintf (f, \"\\tCL\\t0,12(,12)\\n\");\n+  fprintf (f, \"\\tBNH\\t*+10\\n\");\n+  fprintf (f, \"\\tL\\t15,116(,12)\\n\");\n+  fprintf (f, \"\\tBALR\\t14,15\\n\");\n+  fprintf (f, \"\\tL\\t15,72(,13)\\n\");\n+  fprintf (f, \"\\tSTM\\t15,0,72(2)\\n\");\n+  fprintf (f, \"\\tMVI\\t0(2),X'10'\\n\");\n+  fprintf (f, \"\\tST\\t2,8(,13)\\n \");\n+  fprintf (f, \"\\tST\\t13,4(,2)\\n \");\n+  fprintf (f, \"\\tLR\\t13,2\\n\");\n+  fprintf (f, \"\\tDROP\\t15\\n\");\n+  fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n+  fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n+  function_first = 1;\n+  function_label_index ++;\n+#else /* !LE370 */\n   if (!function_first)\n     {\n       struct tm *function_time;\n@@ -530,26 +1303,27 @@ i370_function_prolog (f, l)\n     \t\t function_hour, function_minute, function_second);\n       fprintf (f, \"\\tDC\\tCL2'01',CL4'0100'\\n\");\n     }\n-  fprintf (f, \"$DSD%03d\\tDSECT\\n\", function_label_index);\n+  fprintf (f, \"* Function %s prologue\\n\", mvs_function_name);\n+  fprintf (f, \"FDSD%03d\\tDSECT\\n\", function_label_index);\n   fprintf (f, \"\\tDS\\tD\\n\");\n   fprintf (f, \"\\tDS\\tCL(%d)\\n\", STACK_POINTER_OFFSET + l\n \t\t\t+ current_function_outgoing_args_size);\n-  fprintf (f, \"\\tORG\\t$DSD%03d\\n\", function_label_index);\n+  fprintf (f, \"\\tORG\\tFDSD%03d\\n\", function_label_index);\n   fprintf (f, \"\\tDS\\tCL(120+8)\\n\");\n   fprintf (f, \"\\tORG\\n\");\n   fprintf (f, \"\\tDS\\t0D\\n\");\n-  fprintf (f, \"$DSL%03d\\tEQU\\t*-$DSD%03d-8\\n\", function_label_index,\n+  fprintf (f, \"FDSL%03d\\tEQU\\t*-FDSD%03d-8\\n\", function_label_index,\n \t   function_label_index);\n   fprintf (f, \"\\tDS\\t0H\\n\");\n   assemble_name (f, mvs_function_name);\n-  fprintf (f, \"\\tEQU\\t*\\n\");\n+  fprintf (f, \"\\tCSECT\\n\");\n   fprintf (f, \"\\tUSING\\t*,15\\n\");\n   fprintf (f, \"\\tB\\tFPL%03d\\n\", function_label_index);\n   fprintf (f, \"\\tDC\\tAL1(FPL%03d+4-*)\\n\", function_label_index + 1);\n   fprintf (f, \"\\tDC\\tX'CE',X'A0',AL1(16)\\n\");\n   fprintf (f, \"\\tDC\\tAL4(PPA2)\\n\");\n   fprintf (f, \"\\tDC\\tAL4(0)\\n\");\n-  fprintf (f, \"\\tDC\\tAL4($DSL%03d)\\n\", function_label_index);\n+  fprintf (f, \"\\tDC\\tAL4(FDSL%03d)\\n\", function_label_index);\n   fprintf (f, \"FPL%03d\\tEQU\\t*\\n\", function_label_index + 1);\n   fprintf (f, \"\\tDC\\tAL2(%d),C'%s'\\n\", strlen (mvs_function_name),\n \tmvs_function_name);\n@@ -570,15 +1344,149 @@ i370_function_prolog (f, l)\n   fprintf (f, \"\\tLR\\t13,2\\n\");\n   fprintf (f, \"\\tDROP\\t15\\n\");\n   fprintf (f, \"\\tBALR\\t%d,0\\n\", BASE_REGISTER);\n-  fprintf (f, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\n   fprintf (f, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n-  fprintf (f, \"\\tLR\\t11,1\\n\");\n+  function_first = 1;\n+  function_label_index += 2;\n+#endif /* !LE370 */\n+#endif /* MACROPROLOGUE */\n+  fprintf (f, \"PG%d\\tEQU\\t*\\n\", mvs_page_num );\n+  fprintf (f, \"\\tLR\\t11,1\\n\"); \n   fprintf (f, \"\\tL\\t%d,=A(PGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n-  mvs_page_code = 4;\n+  fprintf (f, \"* Function %s code\\n\", mvs_function_name);\n+\n+  mvs_free_label_list ();\n+  mvs_page_code = 6;\n   mvs_page_lit = 4;\n   mvs_check_page (f, 0, 0);\n   function_base_page = mvs_page_num;\n+\n+  /* find all labels in this routine */\n+  i370_label_scan ();\n+}\n+#endif /* TARGET_HLASM */\n+\n+\n+#ifdef TARGET_ELF_ABI\n+/*\n+   The 370_function_prolog() routine generates the current ELF ABI ES/390 prolog.\n+   It performs the following steps:\n+   -- saves the callers non-volatile registers on the callers stack.\n+   -- computes a new stack top and checks for room for the stack.\n+   -- initializes size and backpointer of new stack frame\n+   -- updates stack pointer to point at new frame.\n+  \n+   XXX hack alert -- if the global var int leaf_function is non-zero, \n+   then this is a leaf, and it might be possible to optimize the prologue\n+   into doing even less, e.g. not grabbing a new stackframe or maybe just a\n+   partial stack frame.\n+  \n+   XXX hack alert -- the current stack frame is bloated into twice the \n+   needed size by unused entries. These entries make it marginally \n+   compatible with MVS/OE/USS C environment, but really they're not used\n+   and could probably chopped out. Modifications to i370.md would be needed\n+   also, to quite using addresses 136, 140, etc.\n+ */\n+\n+void\n+i370_function_prolog (f, frame_size)\n+     FILE *f;\n+     int frame_size;\n+{\n+  static int function_label_index = 1;\n+  static int function_first = 0;\n+  int i;\n+  int stackframe_size, soffset, aligned_size;\n+\n+  fprintf (f, \"# Function prologue\\n\");\n+  /* define the stack, put it into its own data segment\n+     FDSE == Function Stack Entry\n+     FDSL == Function Stack Length */\n+  stackframe_size = \n+     STACK_POINTER_OFFSET + current_function_outgoing_args_size + frame_size;\n+  aligned_size = (stackframe_size + 7) >> 3;\n+  aligned_size <<= 3;\n+  \n+  fprintf (f, \"# arg_size=0x%x frame_size=0x%x aligned size=0x%x\\n\", \n+     current_function_outgoing_args_size, frame_size, aligned_size);\n+\n+  fprintf (f, \"\\t.using\\t.,r15\\n\");\n+\n+  /* Branch to exectuable part of prologue. */\n+  fprintf (f, \"\\tB\\t.LFENT%03d\\n\", function_label_index);\n+\n+  /* write the length of the stackframe */\n+  fprintf (f, \"\\t.long\\t%d\\n\", aligned_size);\n+\n+  /* FENT == function prologue entry */\n+  fprintf (f, \".LFENT%03d:\\n\\t.balign 2\\n\",   /* FENT%03d DS 0H */\n+              function_label_index);\n+\n+  /* store multiple of registers 14,15,0,...12 at 12 bytes from sp */\n+  fprintf (f, \"\\tSTM\\tr14,r12,12(sp)\\n\");\n+\n+  /* r11 points to arg list in callers stackframe; was passed in r2 */\n+  fprintf (f, \"\\tLR\\tr11,r2\\n\");\n+\n+  /* r2 == callee stack pointer ; 76(sp) == caller top of stack */\n+  fprintf (f, \"\\tL\\tr2,76(,sp)\\n\");\n+\n+  /* 4(r15) == callee stack length */\n+  fprintf (f, \"\\tL\\tr0,4(,r15)\\n\");\n+\n+  /* add callee stack length to caller top of stack */\n+  fprintf (f, \"\\tALR\\tr0,r2\\n\");\n+\n+  /* is there enough room for this new stack frame? */\n+  fprintf (f, \"\\tCL\\tr0,12(,rtca)\\n\");\n+  \n+  /* if we've got room, skip next 2 insns */\n+  fprintf (f, \"\\tBNH\\t*+10\\n\");\n+\n+  /* branch to tca to get more stack */\n+  fprintf (f, \"\\tL\\tr15,116(,rtca)\\n\");\n+\n+  /* go */\n+  fprintf (f, \"\\tBASR\\tr14,r15\\n\"); \n+\n+  /* 72(sp) is something that is propagated up from the base of the stack.\n+     We don't use this anywhere, so we could chop this out. For the moment,\n+     Lets keep it; it might be handy someday ... */\n+  fprintf (f, \"\\tL\\tr15,72(,sp)\\n\");\n+\n+  /* store the new top-of-stack at 76(callee_stack) */\n+  fprintf (f, \"\\tSTM\\tr15,r0,72(r2)\\n\");\n+\n+  /* store some PL/1 compatible eyecatcher ???? why bother ??? */\n+  fprintf (f, \"\\tMVI\\t0(r2),0x10\\n\");\n+\n+  /* store callee stack pointer at 8(sp) */\n+  fprintf (f, \"\\tST\\tr2,8(,sp)\\n \");\n+\n+  /* store caller sp at 4(callee_sp)  */\n+  fprintf (f, \"\\tST\\tsp,4(,r2)\\n \");\n+\n+  /* load calle_sp into sp  */\n+  fprintf (f, \"\\tLR\\tsp,r2\\n\");\n+\n+  fprintf (f, \"\\t.drop\\tr15\\n\");\n+  /* place contents of the PSW into r3\n+   * that is, place the address of \".\" into r3 */\n+  fprintf (f, \"\\tBASR\\tr%d,0\\n\", BASE_REGISTER);\n+  fprintf (f, \"\\t.using\\t.,r%d\\n\", BASE_REGISTER);\n   function_first = 1;\n-  function_label_index += 2;\n-#endif /* MACROPROLOGUE */\n+  function_label_index ++;\n+\n+  fprintf (f, \".LPG%d:\\n\", mvs_page_num  );\n+  fprintf (f, \"\\tL\\tr%d,=A(.LPGT%d)\\n\", PAGE_REGISTER, mvs_page_num);\n+  fprintf (f, \"# Function code\\n\");\n+\n+  mvs_free_label_list ();\n+  mvs_page_code = 6;\n+  mvs_page_lit = 4;\n+  mvs_check_page (f, 0, 0);\n+  function_base_page = mvs_page_num;\n+\n+  /* find all labels in this routine */\n+  i370_label_scan ();\n }\n+#endif /* TARGET_ELF_ABI */"}, {"sha": "c37249a346c66d143ae7512a971dc86e2c973875", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 913, "deletions": 219, "changes": 1132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -1,7 +1,8 @@\n /* Definitions of target machine for GNU compiler.  System/370 version.\n    Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n-   Modified for C/370 MVS by Dave Pitts (dpitts@nyx.cs.du.edu)\n+   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n+   Hacked for Linux-ELF/390 by Linas Vepstas (linas@linas.org)\n \n This file is part of GNU CC.\n \n@@ -20,16 +21,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-#define TARGET_VERSION printf (\" (370/MVS)\");\n-\n-/* Options for the preprocessor for this target machine.  */\n-\n-#define CPP_SPEC \"-trigraphs\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -Asystem(mvs) -Acpu(i370) -Amachine(i370)\"\n-\n+#ifndef __I370_H__\n+#define __I370_H__\n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n extern int target_flags;\n@@ -42,10 +35,6 @@ extern int mvs_page_code, mvs_page_lit;\n \n extern int mvs_page_num, function_base_page;\n \n-/* True if a label has been emitted.  */\n-\n-extern int mvs_label_emitted;\n-\n /* The name of the current function.  */\n \n extern char *mvs_function_name;\n@@ -74,9 +63,9 @@ extern int current_function_outgoing_args_size;\n    An empty string NAME is used to identify the default VALUE.  */\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-{ { \"char-instructions\", 1, \"Generate char instructions\"},\t\t\\\n-  { \"no-char-instructions\", -1, \"Do not generate char instructions\"},\t\\\n-  { \"\", TARGET_DEFAULT, NULL} }\n+{ { \"char-instructions\", 1, \"Generate char instructions\"},            \\\n+  { \"no-char-instructions\", -1, \"Do not generate char instructions\"}, \\\n+  { \"\", TARGET_DEFAULT} }\n \n /* To use IBM supplied macro function prologue and epilogue, define the\n    following to 1.  Should only be needed if IBM changes the definition\n@@ -150,20 +139,37 @@ extern int current_function_outgoing_args_size;\n #define TARGET_FLOAT_FORMAT IBM_FLOAT_FORMAT\n \n /* Define character mapping for cross-compiling.  */\n+/* but only define it if really needed, since otherwise it will break builds */\n \n-#define TARGET_EBCDIC 1\n-\n+#ifdef TARGET_EBCDIC\n #ifdef HOST_EBCDIC\n #define MAP_CHARACTER(c) ((char)(c))\n #else\n #define MAP_CHARACTER(c) ((char)mvs_map_char (c))\n #endif\n+#endif\n+\n+#ifdef TARGET_HLASM\n+/* Define this macro if you want to implement any pragmas.  If defined, it\n+   is a C expression to be executed when #pragma is seen.  The\n+   argument FILE is the stdio input stream from which the source\n+   text can be read.  CH is the first character after the #pragma.  The\n+   result of the expression is the terminating character found\n+   (newline or EOF).  */\n+#define HANDLE_PRAGMA(FILE, NODE) handle_pragma ((FILE), (NODE))\n+#endif /* TARGET_HLASM */\n \n /* Define maximum length of page minus page escape overhead.  */\n \n #define MAX_MVS_PAGE_LENGTH 4080\n \n-/* Define if special allocation order desired.  */\n+/* Define special register allocation order desired.  \n+   Don't fiddle with this.  I did, and I got all sorts of register \n+   spill errors when compiling even relatively simple programs...\n+   I have no clue why ...\n+   E.g. this one is bad:\n+   { 0, 1, 2, 9, 8, 7, 6, 5, 10, 15, 14, 12, 3, 4, 16, 17, 18, 19, 11, 13 }\n+ */\n \n #define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n { 0, 1, 2, 3, 14, 15, 12, 10, 9, 8, 7, 6, 5, 4, 16, 17, 18, 19, 11, 13 }\n@@ -186,9 +192,44 @@ extern int current_function_outgoing_args_size;\n #define PAGE_REGISTER 4\n \n /* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  On the 370 under C/370, R13 is stack (DSA)\n-   pointer, R12 is the TCA pointer, R3 is the base register, R4 is the page\n-   origin table pointer and R11 is the arg pointer.  */\n+   for the register allocator.  These are registers that must have fixed,\n+   valid values stored in them for the entire length of the subroutine call,\n+   and must not in any way be moved around, jiggered with, etc. That is,\n+   they must never be clobbered, and, if clobbered, the register allocator \n+   will never restore them back.\n+   \n+   We use five registers in this special way:\n+   -- R3 which is used as the base register\n+   -- R4 the page origin table pointer used to load R3,\n+   -- R11 the arg pointer.  \n+   -- R12 the TCA pointer\n+   -- R13 the stack (DSA) pointer\n+\n+   A fifth register is also exceptional: R14 is used in many branch\n+   instructions to hold the target of the branch.  Technically, this\n+   does not qualify R14 as a register with a long-term meaning; it should\n+   be enough, theoretically, to note that these instructions clobber\n+   R14, and let the compiler deal with that.  In practice, however,\n+   the \"clobber\" directive acts as a barrier to optimization, and the\n+   optimizer appears to be unable to perform optimizations around branches.\n+   Thus, a much better strategy appears to give R14 a pervasive use;\n+   this eliminates it from the register pool witout hurting optimization.\n+\n+   There are other registers which have special meanings, but its OK\n+   for them to get clobbered, since other allocator config below will\n+   make sure that they always have the right value.  These are for \n+   example:\n+   -- R1 the returned structure pointer.\n+   -- R10 the static chain reg.\n+   -- R15 holds the value a subroutine returns.\n+\n+   Notice that it is *almost* safe to mark R11 as available to the allocator.\n+   By marking it as a call_used_register, in most cases, the compiler\n+   can handle it being clobbered.  However, there are a few rare\n+   circumstances where the register allocator will allocate r11 and \n+   also try to use it as the arg pointer ... thus it must be marked fixed.\n+   I think this is a bug, but I can't track it down...\n+ */\n \n #define FIXED_REGISTERS \t\t\t\t\t\t\\\n { 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0 }\n@@ -199,7 +240,8 @@ extern int current_function_outgoing_args_size;\n    saved.\n    The latter must include the registers where values are returned\n    and the register where structure-value addresses are passed.\n-   NOTE: all floating registers are undefined across calls.  */\n+   NOTE: all floating registers are undefined across calls.  \n+*/\n \n #define CALL_USED_REGISTERS \t\t\t\t\t\t\\\n { 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1 }\n@@ -208,19 +250,25 @@ extern int current_function_outgoing_args_size;\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n+   but can be less for certain modes in special long registers.  \n+   Note that DCmode (complex double) needs two regs.\n+*/\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \t\t\t\t\t\\\n-  ((REGNO) > 15 ? 1 : (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n+  ((REGNO) > 15 ? \t\t\t\t\t\t\t\\\n+   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n+   (GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the 370, the cpu registers can hold QI, HI, SI, SF and DF.  The\n    even registers can hold DI.  The floating point registers can hold\n-   either SF or DF.  */\n+   either SF, DF, SC or DC.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  ((REGNO) < 16 ? ((REGNO) & 1) == 0 || (MODE) != DImode\t\t\\\n-\t\t: (MODE) == SFmode || (MODE) == DFmode)\n+  ((REGNO) < 16 ? (((REGNO) & 1) == 0 || \t\t\t\t\\\n+\t\t  (((MODE) != DImode) && ((MODE) != DFmode)))\t\t\\\n+\t\t: ((MODE) == SFmode || (MODE) == DFmode) ||\t\t\\\n+                   (MODE) == SCmode || (MODE) == DCmode)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers when one has\n    mode MODE1 and one has mode MODE2.\n@@ -263,12 +311,29 @@ extern int current_function_outgoing_args_size;\n \n #define ARG_POINTER_REGNUM 11\n \n-/* Register in which static-chain is passed to a function.  */\n+/* R10 is register in which static-chain is passed to a function.  \n+   Static-chaining is done when a nested function references as a global\n+   a stack variable of its parent: e.g.\n+        int parent_func (int arg) { \n+             int x;                            // x is in parents stack\n+             void child_func (void) { x++: }   // child references x as global var\n+             ... \n+        }\n+ */\n \n #define STATIC_CHAIN_REGNUM 10\n \n-/* Register in which address to store a structure value is passed to\n-   a function.  */\n+/* R1 is register in which address to store a structure value is passed to\n+   a function.  This is used only when returning 64-bit long-long in a 32-bit arch\n+   and when calling functions that return structs by value. e.g.\n+        typedef struct A_s { int a,b,c; } A_t;\n+        A_t fun_returns_value (void) { \n+            A_t a; a.a=1; a.b=2 a.c=3;\n+            return a;\n+        } \n+   In the above, the stroage for the return value is in the callers stack, and \n+   the R1 points at that mem location.\n+ */\n \n #define STRUCT_VALUE_REGNUM 1\n \n@@ -347,23 +412,36 @@ enum reg_class\n \n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  1\n \n+/* see recog.c for details */\n+#define EXTRA_CONSTRAINT(OP,C)\t\t\t\t\t\t\\\n+   ((C) == 'R' ? r_or_s_operand (OP, GET_MODE(OP)) :\t\t\t\\\n+    (C) == 'S' ? s_operand (OP, GET_MODE(OP)) :\t0)\t\t\t\\\n+\n /* Given an rtx X being reloaded into a reg required to be in class CLASS,\n    return the class of reg to actually use.  In general this is just CLASS;\n    but on some machines in some cases it is preferable to use a more\n-   restrictive class.  */\n+   restrictive class.  \n+\n+   XXX We reload CONST_INT's into ADDR not DATA regs because on certain \n+   rare occasions when lots of egisters are spilled, reload() will try\n+   to put a const int into r0 and then use r0 as an index register.\n+*/\n \n #define PREFERRED_RELOAD_CLASS(X, CLASS)\t\t\t\t\\\n     (GET_CODE(X) == CONST_DOUBLE ? FP_REGS :\t\t\t\t\\\n-     GET_CODE(X) == CONST_INT ? DATA_REGS :\t\t\t\t\\\n+     GET_CODE(X) == CONST_INT ? (reload_in_progress ? ADDR_REGS : DATA_REGS) :\t\\\n      GET_CODE(X) == LABEL_REF ||\t\t\t\t\t\\\n      GET_CODE(X) == SYMBOL_REF ||\t\t\t\t\t\\\n      GET_CODE(X) == CONST ? ADDR_REGS : (CLASS))\n \n /* Return the maximum number of consecutive registers needed to represent\n-   mode MODE in a register of class CLASS.  */\n+   mode MODE in a register of class CLASS.  \n+   Note that DCmode (complex double) needs two regs.\n+*/\n \n #define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n-  ((CLASS) == FP_REGS ? 1 :\t\t\t\t\t\t\\\n+  ((CLASS) == FP_REGS ? \t\t\t\t\t\t\\\n+   ((GET_MODE_SIZE (MODE) + 2*UNITS_PER_WORD - 1) / (2*UNITS_PER_WORD)) :\t\\\n    (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n /* Stack layout; function entry, exit and calling.  */\n@@ -455,17 +533,26 @@ enum reg_class\n \n #define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n \n-/* Define how to find the value returned by a function.  VALTYPE is the\n-   data type of the value (as a tree).\n+/* The FUNCTION_VALUE macro dDefines how to find the value returned by a \n+   function.  VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 15.  */\n+   otherwise, FUNC is NULL.  \n \n-#define RET_REG(MODE)\t((MODE) == DFmode || (MODE) == SFmode ? 16 : 15)\n+   On the 370 the return value is in R15 or R16.  However,\n+   DImode (64-bit ints) scalars need to get returned on the stack, \n+   with r15 pointing to the location.  To accomplish this, we define\n+   the RETURN_IN_MEMORY macro to be true for both blockmode (structures)\n+   and the DImode scalars.\n+ */\n \n-/* On the 370 the return value is in R15 or R16.  */\n+#define RET_REG(MODE)\t\\\n+    (((MODE) == DCmode || (MODE) == SCmode || (MODE) == TFmode || (MODE) == DFmode || (MODE) == SFmode) ? 16 : 15)\n \n #define FUNCTION_VALUE(VALTYPE, FUNC)  \t\t\t\t\t\\\n-  gen_rtx(REG, TYPE_MODE (VALTYPE), RET_REG(TYPE_MODE(VALTYPE)))\n+  gen_rtx(REG, TYPE_MODE (VALTYPE), RET_REG(TYPE_MODE(VALTYPE)))  \n+\n+#define RETURN_IN_MEMORY(VALTYPE)  \\\n+  ((DImode == TYPE_MODE (VALTYPE)) || (BLKmode == TYPE_MODE (VALTYPE)))\n \n /* Define how to find the value returned by a library function assuming\n    the value has mode MODE.  */\n@@ -481,84 +568,6 @@ enum reg_class\n \n #define DEFAULT_MAIN_RETURN  c_expand_return (integer_zero_node)\n \n-/* This macro generates the assembly code for function entry.\n-   All of the C/370 environment is preserved.  */\n-#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n-\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (strlen (NAME) * 2 > mvs_function_name_length)\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (mvs_function_name)\t\t\t\t\t\t\\\n-\tfree (mvs_function_name);\t\t\t\t\t\\\n-      mvs_function_name = 0;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!mvs_function_name)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      mvs_function_name_length = strlen (NAME) * 2;\t\t\t\\\n-      mvs_function_name = (char *) malloc (mvs_function_name_length);\t\\\n-      if (mvs_function_name == 0)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  fatal (\"virtual memory exceeded\");\t\t\t\t\\\n-\t  abort ();\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n-}\n-\n-/* This macro generates the assembly code for function exit, on machines\n-   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n-   return instructions are generated for each return statement.  Args are\n-   same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#if MACROEPILOGUE == 1\n-#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\t\t\t\\\n-  check_label_emit();\t\t\t\t\t\t\t\\\n-  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tEDCEPIL\\n\");\t\t\t\t\t\\\n-  mvs_page_num++;\t\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n-  mvs_free_label();\t\t\t\t\t\t\t\\\n-  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n-    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n-}\n-#else /* MACROEPILOGUE != 1 */\n-#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int i;\t\t\t\t\t\t\t\t\\\n-  check_label_emit();\t\t\t\t\t\t\t\\\n-  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t13,4(,13)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t14,12(,13)\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLM\\t2,12,28(13)\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\tBALR\\t1,14\\n\");\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\t\\\n-  mvs_page_num++;\t\t\t\t\t\t\t\\\n-  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n-  fprintf (FILE, \")\\n\" );\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n-  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n-  mvs_free_label();\t\t\t\t\t\t\t\\\n-  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n-    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n-}\n-#endif /* MACROEPILOGUE */\n-\n \n /* Output assembler code for a block containing the constant parts of a\n    trampoline, leaving space for the variable parts.\n@@ -572,15 +581,21 @@ enum reg_class\n         BR    15\n    X    DS    0F\n    Y    DS    0F  */\n+/*\n+   I am confused as to why this emitting raw binary, instead of instructions ...\n+   see for example, rs6000/rs000.c for an example of a different way to\n+   do this ... especially since BASR should probably be substituted for BALR.\n+ */\n \n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x05E0));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x5800 | STATIC_CHAIN_REGNUM << 4));\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00A));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x58F0)); \t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0xE00E));\t\t\t\t\\\n-  ASM_OUTPUT_SHORT (FILE, GEN_INT (0x07FF));\t\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x05E0));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x5800 | \t\\\n+\t\t\t   STATIC_CHAIN_REGNUM << 4));\t\t\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00A));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x58F0)); \t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0xE00E));\t\\\n+  ASM_OUTPUT_SHORT (FILE, gen_rtx (CONST_INT, VOIDmode, 0x07FF));\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n   ASM_OUTPUT_SHORT (FILE, const0_rtx);\t\t\t\t\t\\\n@@ -599,24 +614,18 @@ enum reg_class\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n }\n \n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n-  fprintf (FILE, \"Error: No profiling available.\\n\")\n-\n /* Define EXIT_IGNORE_STACK if, when returning from a function, the stack\n    pointer does not matter (provided there is a frame pointer).  */\n \n #define EXIT_IGNORE_STACK\t1\n \n /* Addressing modes, and classification of registers for them.  */\n \n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n \n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n \n /* These assume that REGNO is a hard or pseudo reg number.  They give\n    nonzero only if REGNO is a hard reg of the suitable class or a pseudo\n@@ -712,11 +721,14 @@ enum reg_class\n    that wants to use this address.\n \n    The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  \n+*/\n \n #define COUNT_REGS(X, REGS, FAIL)\t\t\t\t\t\\\n- if (REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\\\n-   REGS += 1;\t\t\t\t\t\t\t\t\\\n+ if (REG_P (X)) {\t\t\t\t\t\t\t\\\n+   if (REG_OK_FOR_BASE_P (X)) REGS += 1;\t\t\t\t\\\n+   else goto FAIL;\t\t\t\t\t\t\t\\\n+ }\t\t\t\t\t\t\t\t\t\\\n  else if (GET_CODE (X) != CONST_INT || (unsigned) INTVAL (X) >= 4096)\t\\\n    goto FAIL;\n \n@@ -760,9 +772,26 @@ enum reg_class\n \n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\n \n-/* Try machine-dependent ways of modifying an illegitimate address\n+/* Macro: LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\n+   Try machine-dependent ways of modifying an illegitimate address\n    to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.  */\n+   This macro is used in only one place: `memory_address' in explow.c. \n+  \n+   Several comments:\n+   (1) It's not obvious that this macro results in better code\n+       than its omission does. For historical reasons we leave it in.\n+  \n+   (2) This macro may be (???) implicated in the accidental promotion\n+       or RS operand to RX operands, which bombs out any RS, SI, SS \n+       instruction that was expecting a simple address.  Note that \n+       this occurs fairly rarely ...\n+  \n+   (3) There is a bug somewhere that causes either r4 to be spilled,\n+       or causes r0 to be used as a base register.  Changeing the macro \n+       below will make the bug move around, but will not make it go away \n+       ... Note that this is a rare bug ...\n+   \n+ */\n \n #define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -787,11 +816,11 @@ enum reg_class\n \n #define CASE_VECTOR_MODE SImode\n \n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n+/* Define this if the tablejump instruction expects the table to contain\n+   offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+\n+/* #define CASE_VECTOR_PC_RELATIVE */\n \n /* Specify the tree operation to be used to convert reals to integers.  */\n \n@@ -816,7 +845,7 @@ enum reg_class\n \n /* Define this if zero-extension is slow (more than one real instruction).  */\n \n-#define SLOW_ZERO_EXTEND\n+#define SLOW_ZERO_EXTEND 1\n \n /* Nonzero if access to memory by bytes is slow and undesirable.  */\n \n@@ -871,6 +900,18 @@ enum reg_class\n   case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n     return 4;\n \n+/*   A C statement (sans semicolon) to update the integer variable COST\n+     based on the relationship between INSN that is dependent on\n+     DEP_INSN through the dependence LINK.  The default is to make no\n+     adjustment to COST.  This can be used for example to specify to\n+     the scheduler that an output- or anti-dependence does not incur\n+     the same cost as a data-dependence. \n+\n+     We will want to use this to indicate that there is a cost associated \n+     with the loading, followed by use of base registers ... \n+#define ADJUST_COST (INSN, LINK, DEP_INSN, COST)\n+ */\n+\n /* Tell final.c how to eliminate redundant test instructions.  */\n \n /* Here we define machine-dependent flags and fields in cc_status\n@@ -883,7 +924,18 @@ enum reg_class\n    On the 370, load insns do not alter the cc's.  However, in some\n    cases these instructions can make it possibly invalid to use the\n    saved cc's.  In those cases we clear out some or all of the saved\n-   cc's so they won't be used.  */\n+   cc's so they won't be used.  \n+\n+   Note that only some arith instructions set the CC.  These include\n+   add, subtract, complement, various shifts.  Note that multiply\n+   and divide do *not* set set the CC.  Therefore, in the code below,\n+   don't set the status for MUL, DIV, etc.\n+\n+   Note that the bitwise ops set the condition code, but not in a \n+   way that we can make use of it. So we treat these as clobbering, \n+   rather than setting the CC.  These are clobbered in the individual\n+   instruction patterns that use them.  Use CC_STATUS_INIT to clobber.\n+*/\n \n #define NOTICE_UPDATE_CC(EXP, INSN)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -910,11 +962,17 @@ enum reg_class\n \t    cc_status.value2 = 0;\t\t\t\t\t\\\n \t  switch (GET_CODE (XEXP (exp, 1)))\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      case PLUS:     case MINUS: case MULT:   /* case UMULT: */\t\\\n-\t      case DIV:      case UDIV:  case NEG:    case ASHIFT:\t\\\n-\t      case ASHIFTRT: case AND:   case IOR:    case XOR:\t\t\\\n-\t      case ABS:      case NOT:\t\t\t\t\t\\\n+\t      case PLUS:     case MINUS: case NEG:    \t\t\t\\\n+\t      case NOT:\t case ABS:\t\t\t\t\t\\\n \t\tCC_STATUS_SET (XEXP (exp, 0), XEXP (exp, 1));\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+              /* mult and div don't set any cc codes !! */\t\t\\\n+\t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n+              /* and, or and xor set the cc's the wrong way !! */\t\\\n+\t      case AND:   case IOR:    case XOR:  \t\t\t\\\n+              /* some shifts set the CC some don't. */\t\t\t\\\n+              case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n+                 do {} while (0);\t\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n@@ -934,13 +992,46 @@ enum reg_class\n #define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV) \t\t\t\t\\\n { if (cc_status.flags & CC_NO_OVERFLOW)\treturn NO_OV; return NORMAL; }\n \n+/* ------------------------------------------ */\n /* Control the assembler format that we output.  */\n \n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+\n+#ifdef TARGET_EBCDIC\n+#define TARGET_ESC\t39\n+#define TARGET_BELL\t47\n+#define TARGET_BS\t22\n+#define TARGET_TAB\t5\n+#define TARGET_NEWLINE\t21\n+#define TARGET_VT\t11\n+#define TARGET_FF\t12\n+#define TARGET_CR\t13\n+#else \n+#define TARGET_BELL\t007\n+#define TARGET_BS\t010\n+#define TARGET_TAB\t011\n+#define TARGET_NEWLINE\t012\n+#define TARGET_VT\t013\n+#define TARGET_FF\t014\n+#define TARGET_CR\t015\n+#endif\n+\n+/* ======================================================== */\n+\n+#ifdef TARGET_HLASM\n #define TEXT_SECTION_ASM_OP \"* Program text area\"\n #define DATA_SECTION_ASM_OP \"* Program data area\"\n #define INIT_SECTION_ASM_OP \"* Program initialization area\"\n+#define SHARED_SECTION_ASM_OP \"* Program shared data\"\n #define CTOR_LIST_BEGIN\t\t/* NO OP */\n #define CTOR_LIST_END\t\t/* NO OP */\n+#define MAX_MVS_LABEL_SIZE 8\n \n /* How to refer to registers in assembler output.  This sequence is\n    indexed by compiler's hard-register-number (see above).  */\n@@ -952,10 +1043,12 @@ enum reg_class\n }\n \n /* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n \n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+#define ASM_FILE_START(FILE)\t\t\t\t\t\t\\\n+{ fputs (\"\\tRMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n+  fputs (\"\\tCSECT\\n\", FILE); }\n \n-#define ASM_FILE_START(FILE) fputs (\"\\tCSECT\\n\", FILE);\n #define ASM_FILE_END(FILE) fputs (\"\\tEND\\n\", FILE);\n #define ASM_IDENTIFY_GCC(FILE)\n #define ASM_COMMENT_START \"*\"\n@@ -965,26 +1058,36 @@ enum reg_class\n #define ASM_OUTPUT_LABEL(FILE, NAME) \t\t\t\t\t\\\n { assemble_name (FILE, NAME); fputs (\"\\tEQU\\t*\\n\", FILE); }\n \n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t/* NO OP */\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n+  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n \n #define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\t\t\t\\\n-{ fputs (\"\\tENTRY\\t\", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE); }\n+{ \t\t\t\t\t\t\t\t\t\\\n+  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n+  if (mvs_check_alias (NAME, temp) == 2)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n+  assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n+  fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n+}\n \n /* MVS externals are limited to 8 characters, upper case only.\n    The '_' is mapped to '@', except for MVS functions, then '#'.  */\n \n-#define MAX_MVS_LABEL_SIZE 8\n \n #define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   char *bp, ch, temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\\\n-  if (strlen (NAME) > MAX_MVS_LABEL_SIZE)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      strncpy (temp, NAME, MAX_MVS_LABEL_SIZE);\t\t\t\t\\\n-      temp[MAX_MVS_LABEL_SIZE] = '\\0';\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    strcpy (temp,NAME);\t\t\t\t\t\t\t\\\n+  if (!mvs_get_alias (NAME, temp))\t\t\t\t\t\\\n+    strcpy (temp, NAME);\t\t\t\t\t\t\\\n   if (!strcmp (temp,\"main\"))\t\t\t\t\t\t\\\n     strcpy (temp,\"gccmain\");\t\t\t\t\t\t\\\n   if (mvs_function_check (temp))\t\t\t\t\t\\\n@@ -994,7 +1097,7 @@ enum reg_class\n   for (bp = temp; *bp; bp++)\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (islower (*bp)) *bp = toupper (*bp);\t\t\t\t\\\n-      if (*bp == '_') *bp = ch;\t\t\t\t\t\t\\\n+      else if (*bp == '_') *bp = ch;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"%s\", temp);\t\t\t\t\t\t\\\n }\n@@ -1010,12 +1113,13 @@ enum reg_class\n   if (!strcmp (PREFIX,\"L\"))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       mvs_add_label(NUM);\t\t\t\t\t\t\\\n-      mvs_label_emitted = 1;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM);\t\t\t\\\n }\n \n /* Generate case label.  */\n+/* hack alert -- I don't get it ... what if its a really big case label?\n+ * wouldn't we have to say label_emitted also ?? */\n \n #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n    fprintf (FILE, \"%s%d\\tEQU\\t*\\n\", PREFIX, NUM)\n@@ -1033,28 +1137,34 @@ enum reg_class\n   fprintf (FILE, \"\\tDC\\tA(L%d-L%d)\\n\", VALUE, REL)\n \n /* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n+    It need not be very fast code.  \n+   Right now, PUSH & POP are used only when profiling is enabled, \n+   and then, only to push the static chain reg and the function struct \n+   value reg, and only if those are used.  Since profiling is not\n+   supported anyway, punt on this.  */\n \n #define ASM_OUTPUT_REG_PUSH(FILE, REGNO)\t\t\t\t\\\n   mvs_check_page (FILE, 8, 4);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tS\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n+  fprintf (FILE, \"\\tSXXX\\t13,=F'4'\\n\\tST\\t%s,%d(13)\\n\",\t\t\t\\\n      reg_names[REGNO], STACK_POINTER_OFFSET)\n \n /* This is how to output an insn to pop a register from the stack.\n    It need not be very fast code.  */\n \n #define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\t\t\t\t\\\n   mvs_check_page (FILE, 8, 0);\t\t\t\t\t\t\\\n-  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLA\\t13,4(13)\\n\",\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t%s,%d(13)\\n\\tLAXXX\\t13,4(13)\\n\",\t\t\t\\\n      reg_names[REGNO], STACK_POINTER_OFFSET)\n \n+/* TBD: hack alert XXX  these two float point macros print horribly\n+   incorrect things when run in cross-compiler mode. Thats's because\n+   in cross-compiler mode, the VALUE is not really a double.  See below,\n+   in the ELF section, for the correct implementation.  */\n /* This is how to output an assembler line defining a `double' constant.  */\n-\n #define ASM_OUTPUT_DOUBLE(FILE, VALUE)\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tD'%.18G'\\n\", (VALUE))\n \n /* This is how to output an assembler line defining a `float' constant.  */\n-\n #define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\t\t\t\\\n   fprintf (FILE, \"\\tDC\\tE'%.9G'\\n\", (VALUE))\n \n@@ -1169,6 +1279,11 @@ enum reg_class\n \n #define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED) \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  char temp[MAX_MVS_LABEL_SIZE + 1];\t\t\t\t\t\\\n+  if (mvs_check_alias(NAME, temp) == 2)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\\tALIAS\\tC'%s'\\n\", temp, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   fputs (\"\\tENTRY\\t\", FILE);\t\t\t\t\t\t\\\n   assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n   fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n@@ -1199,41 +1314,25 @@ enum reg_class\n   sprintf ((OUTPUT), \"%s%d\", (NAME), (LABELNO));\t\t\t\\\n }\n \n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-\n-#define TARGET_BELL\t47\n-#define TARGET_BS\t22\n-#define TARGET_TAB\t5\n-#define TARGET_NEWLINE\t21\n-#define TARGET_VT\t11\n-#define TARGET_FF\t12\n-#define TARGET_CR\t13\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n+/* Print operand XV (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n+   For `%' followed by punctuation, CODE is the punctuation and XV is null. */\n \n-#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n+#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (X))\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       static char curreg[4];\t\t\t\t\t\t\\\n       case REG:\t\t\t\t\t\t\t\t\\\n \tif (CODE == 'N')\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (X) + 1]);\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n-\t    strcpy (curreg, reg_names[REGNO (X)]);\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n \tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n       case MEM:\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  rtx addr = XEXP (X, 0);\t\t\t\t\t\\\n+\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n \t  if (CODE == 'O')\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n@@ -1249,61 +1348,81 @@ enum reg_class\n \t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n-\t    output_address (XEXP (X, 0));\t\t\t\t\\\n+\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n       case SYMBOL_REF:\t\t\t\t\t\t\t\\\n       case LABEL_REF:\t\t\t\t\t\t\t\\\n \tmvs_page_lit += 4;\t\t\t\t\t\t\\\n-\tif (SYMBOL_REF_FLAG (X)) fprintf (FILE, \"=V(\");\t\t\t\\\n-\telse                     fprintf (FILE, \"=A(\");\t\t\t\\\n-\toutput_addr_const (FILE, X);\t\t\t\t\t\\\n+\tif (SYMBOL_REF_FLAG (XV)) fprintf (FILE, \"=V(\");\t\t\\\n+\telse                      fprintf (FILE, \"=A(\");\t\t\\\n+\toutput_addr_const (FILE, XV);\t\t\t\t\t\\\n \tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n       case CONST_INT:\t\t\t\t\t        \t\\\n \tif (CODE == 'B')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", INTVAL (X) & 0xff);\t\t\t\\\n+\t  fprintf (FILE, \"%d\", INTVAL (XV) & 0xff);\t\t\t\\\n \telse if (CODE == 'X')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%02X\", INTVAL (X) & 0xff);\t\t\t\\\n+\t  fprintf (FILE, \"%02X\", INTVAL (XV) & 0xff);\t\t\t\\\n \telse if (CODE == 'h')\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"%d\", (INTVAL (X) << 16) >> 16);\t\t\\\n+\t  fprintf (FILE, \"%d\", (INTVAL (XV) << 16) >> 16);\t\t\\\n \telse if (CODE == 'H')\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=H'%d'\", (INTVAL (X) << 16) >> 16);\t\t\\\n+\t    fprintf (FILE, \"=H'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (CODE == 'K')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (CODE == 'W')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n+\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n+\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n+\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n+            } else {\t\t\t\t\t\t\t\\\n+\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"=F'%d'\", INTVAL (X));\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", INTVAL (XV));\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n       case CONST_DOUBLE:\t\t\t\t\t\t\\\n-\tif (GET_MODE (X) == DImode)\t\t\t\t\t\\\n+\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    if (CODE == 'M')\t\t\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (X));\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t    else if (CODE == 'L')\t\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 4;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (X));\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t    else\t\t\t\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 8;\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (X),\t\\\n-\t\t\tCONST_DOUBLE_HIGH (X));\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL8'%08X%08X'\", CONST_DOUBLE_LOW (XV),\t\\\n+\t\t\tCONST_DOUBLE_HIGH (XV));\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  { \t\t\t\t\t\t\t\t\\\n+            /* hack alert -- this prints wildly incorrect values */\t\\\n+            /* when run in cross-compiler mode. See ELF section  */\t\\\n+            /* for suggested fix */\t\t\t\t\t\\\n \t    union { double d; int i[2]; } u;\t\t\t\t\\\n-\t    u.i[0] = CONST_DOUBLE_LOW (X);\t\t\t\t\\\n-\t    u.i[1] = CONST_DOUBLE_HIGH (X);\t\t\t\t\\\n-\t    if (GET_MODE (X) == SFmode)\t\t\t\t\t\\\n+\t    u.i[0] = CONST_DOUBLE_LOW (XV);\t\t\t\t\\\n+\t    u.i[1] = CONST_DOUBLE_HIGH (XV);\t\t\t\t\\\n+\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 4;\t\t\t\t\t\\\n \t\tfprintf (FILE, \"=E'%.9G'\", u.d);\t\t\t\\\n@@ -1316,30 +1435,30 @@ enum reg_class\n \t  }\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n       case CONST:\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == SYMBOL_REF)\t\t\\\n+\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n-\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (X, 0), 0)))\t\t\\\n+\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n \t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n-\t\t\t\t  XSTR (XEXP (XEXP (X, 0), 0), 0));\t\\\n+\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n \t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n-\t\t\t\t  INTVAL (XEXP (XEXP (X, 0), 1)));\t\\\n+\t\t\t\t  INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t    else\t\t\t\t\t\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n-\t\toutput_addr_const (FILE, X);\t\t\t\t\\\n+\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n \t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \telse\t\t\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n \t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n \t    fprintf (FILE, \"=F'\");\t\t\t\t\t\\\n-\t    output_addr_const (FILE, X);\t\t\t\t\\\n+\t    output_addr_const (FILE, XV);\t\t\t\t\\\n \t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\t\\\n \tbreak;\t\t\t\t\t\t\t\t\\\n@@ -1438,3 +1557,578 @@ enum reg_class\n \tbreak;\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n+\n+/* This macro generates the assembly code for function entry.\n+   All of the C/370 environment is preserved.  */\n+#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (strlen (NAME) * 2 > mvs_function_name_length)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (mvs_function_name)\t\t\t\t\t\t\\\n+\tfree (mvs_function_name);\t\t\t\t\t\\\n+      mvs_function_name = 0;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (!mvs_function_name)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      mvs_function_name_length = strlen (NAME) * 2;\t\t\t\\\n+      mvs_function_name = (char *) malloc (mvs_function_name_length);\t\\\n+      if (mvs_function_name == 0)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fatal (\"virtual memory exceeded\");\t\t\t\t\\\n+\t  abort ();\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (!strcmp (NAME, \"main\"))\t\t\t\t\t\t\\\n+    strcpy (mvs_function_name, \"gccmain\");\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    strcpy (mvs_function_name, NAME);\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fputs (\"\\tRMODE\\tANY\\n\", FILE);\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fputs (\"\\tCSECT\\n\", FILE);\t\t\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function exit, on machines\n+   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n+   return instructions are generated for each return statement.  Args are\n+   same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#if MACROEPILOGUE == 1\n+#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  check_label_emit();\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s epilogue\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tEDCEPIL\\n\");\t\t\t\t\t\\\n+  mvs_page_num++;\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s literal pool\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s page table\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n+  mvs_free_label_list();\t\t\t\t\t\t\\\n+  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n+    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n+}\n+#else /* MACROEPILOGUE != 1 */\n+#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  check_label_emit();\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s epilogue\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tL\\t13,4(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\t14,12(,13)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLM\\t2,12,28(13)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tBALR\\t1,14\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tDC\\tA(\");\t\t\t\t\t\t\\\n+  mvs_page_num++;\t\t\t\t\t\t\t\\\n+  assemble_name (FILE, mvs_function_name);\t\t\t\t\\\n+  fprintf (FILE, \")\\n\" );\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s literal pool\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\" );\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLTORG\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"* Function %s page table\\n\", mvs_function_name);\t\\\n+  fprintf (FILE, \"\\tDS\\t0F\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"PGT%d\\tEQU\\t*\\n\", function_base_page);\t\t\\\n+  mvs_free_label_list();\t\t\t\t\t\t\\\n+  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n+    fprintf (FILE, \"\\tDC\\tA(PG%d)\\n\", i);\t\t\t\t\\\n+}\n+#endif /* MACROEPILOGUE */\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO) \t\t\t\t\\\n+  fprintf (FILE, \"Error: No profiling available.\\n\")\n+\n+#endif /* TARGET_HLASM */\n+\n+/* ======================================================== */\n+\n+#ifdef TARGET_ELF_ABI \n+\n+/* How to refer to registers in assembler output.  This sequence is\n+   indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\t\\\n+{ \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n+  \"r8\",  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+  \"f0\",  \"f2\",  \"f4\",  \"f6\"\t\t\t\t\t\t\\\n+}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n+\n+/* Print operand XV (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and XV is null. */\n+\n+#define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (XV))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      static char curreg[4];\t\t\t\t\t\t\\\n+      case REG:\t\t\t\t\t\t\t\t\\\n+\tif (CODE == 'N')\t\t\t\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (XV) + 1]);\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t    strcpy (curreg, reg_names[REGNO (XV)]);\t\t\t\\\n+\tfprintf (FILE, \"%s\", curreg);\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case MEM:\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  rtx addr = XEXP (XV, 0);\t\t\t\t\t\\\n+\t  if (CODE == 'O')\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+\t\tfprintf (FILE, \"%d\", INTVAL (XEXP (addr, 1)));\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"0\");\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else if (CODE == 'R')\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n+\t\tfprintf (FILE, \"%s\", reg_names[REGNO (XEXP (addr, 0))]);\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"%s\", reg_names[REGNO (addr)]);\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    output_address (XEXP (XV, 0));\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+      case LABEL_REF:\t\t\t\t\t\t\t\\\n+\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n+        if (SYMBOL_REF_FLAG (XV)) fprintf (FILE, \"=V(\");                \\\n+        else                      fprintf (FILE, \"=A(\");                \\\n+        output_addr_const (FILE, XV);                                   \\\n+        fprintf (FILE, \")\");                                            \\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST_INT:\t\t\t\t\t        \t\\\n+\tif (CODE == 'B')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%d\", INTVAL (XV) & 0xff);\t\t\t\\\n+\telse if (CODE == 'X')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%02X\", INTVAL (XV) & 0xff);\t\t\t\\\n+\telse if (CODE == 'h')\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%d\", (INTVAL (XV) << 16) >> 16);\t\t\\\n+\telse if (CODE == 'H')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 2;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=H'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (CODE == 'K')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            /* auto sign-extension of signed 16-bit to signed 32-bit */\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", (INTVAL (XV) << 16) >> 16);\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (CODE == 'W')\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+            /* hand-built sign-extension of signed 32-bit to 64-bit */\t\\\n+\t    mvs_page_lit += 8;\t\t\t\t\t\t\\\n+\t    if (0 <=  INTVAL (XV)) {\t\t\t\t\t\\\n+\t       fprintf (FILE, \"=XL8'00000000\");\t\t\t\t\\\n+            } else {\t\t\t\t\t\t\t\\\n+\t       fprintf (FILE, \"=XL8'FFFFFFFF\");\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"%08X'\", INTVAL (XV));\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=F'%d'\", INTVAL (XV));\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST_DOUBLE:\t\t\t\t\t\t\\\n+\tif (GET_MODE (XV) == DImode)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (CODE == 'M')\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_LOW (XV));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else if (CODE == 'L')\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL4'%08X'\", CONST_DOUBLE_HIGH (XV));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=yyyyXL8'%08X%08X'\", \t\t\t\\\n+\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  { \t\t\t\t\t\t\t\t\\\n+            char buf[50];\t\t\t\t\t\t\\\n+            REAL_VALUE_TYPE rval;\t\t\t\t\t\\\n+            REAL_VALUE_FROM_CONST_DOUBLE(rval, XV);\t\t\t\\\n+            REAL_VALUE_TO_DECIMAL (rval, HOST_WIDE_INT_PRINT_DEC, buf);\t\\\n+\t    if (GET_MODE (XV) == SFmode)\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 4;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=E'%s'\", buf);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t    if (GET_MODE (XV) == DFmode)\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else /* VOIDmode !?!? strange but true ... */\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tmvs_page_lit += 8;\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n+\t\t\tCONST_DOUBLE_HIGH (XV), CONST_DOUBLE_LOW (XV));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case CONST:\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (XV, 0)) == PLUS\t\t\t\t\\\n+\t   && GET_CODE (XEXP (XEXP (XV, 0), 0)) == SYMBOL_REF)\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    if (SYMBOL_REF_FLAG (XEXP (XEXP (XV, 0), 0)))\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=V(\");\t\t\t\t\t\\\n+\t\tASM_OUTPUT_LABELREF (FILE,\t\t\t\t\\\n+\t\t\t\t  XSTR (XEXP (XEXP (XV, 0), 0), 0));\t\\\n+\t\tfprintf (FILE, \")\\n\\tA\\t%s,=F'%d'\", curreg,\t\t\\\n+\t\t\t\t  INTVAL (XEXP (XEXP (XV, 0), 1)));\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"=A(\");\t\t\t\t\t\\\n+\t\toutput_addr_const (FILE, XV);\t\t\t\t\\\n+\t\tfprintf (FILE, \")\");\t\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    mvs_page_lit += 4;\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"=bogus_bad_F'\");\t\t\t\t\\\n+\t    output_addr_const (FILE, XV);\t\t\t\t\\\n+\t    fprintf (FILE, \"'\");\t\t\t\t\t\\\n+/* XXX hack alert this gets gen'd in -fPIC code in relation to a tablejump */  \\\n+/* but its somehow fundamentally broken, I can't make any sense out of it */  \\\n+debug_rtx (XV); \\\n+abort(); \\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\tabort();\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  rtx breg, xreg, offset, plus;\t\t\t\t\t\t\\\n+  \t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (ADDR))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      case REG:\t\t\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"0(%s)\", reg_names[REGNO (ADDR)]);\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      case PLUS:\t\t\t\t\t\t\t\\\n+\tbreg = 0;\t\t\t\t\t\t\t\\\n+\txreg = 0;\t\t\t\t\t\t\t\\\n+\toffset = 0;\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (XEXP (ADDR, 0)) == PLUS)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (ADDR, 1)) == REG)\t\t\t\\\n+\t      breg = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      offset = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t    plus = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (ADDR, 0)) == REG)\t\t\t\\\n+\t      breg = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      offset = XEXP (ADDR, 0);\t\t\t\t\t\\\n+\t    plus = XEXP (ADDR, 1);\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (GET_CODE (plus) == PLUS)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (plus, 0)) == REG)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tif (breg)\t\t\t\t\t\t\\\n+\t\t  xreg = XEXP (plus, 0);\t\t\t\t\\\n+\t\telse\t\t\t\t\t\t\t\\\n+\t\t  breg = XEXP (plus, 0);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\toffset = XEXP (plus, 0);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (XEXP (plus, 1)) == REG)\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\tif (breg)\t\t\t\t\t\t\\\n+\t\t  xreg = XEXP (plus, 1);\t\t\t\t\\\n+\t\telse\t\t\t\t\t\t\t\\\n+\t\t  breg = XEXP (plus, 1);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      {\t\t\t\t\t\t\t\t\\\n+\t\toffset = XEXP (plus, 1);\t\t\t\t\\\n+\t      }\t\t\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse if (GET_CODE (plus) == REG)\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (breg)\t\t\t\t\t\t\t\\\n+\t      xreg = plus;\t\t\t\t\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      breg = plus;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    offset = plus;\t\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\tif (offset)\t\t\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    if (GET_CODE (offset) == LABEL_REF)\t\t\t\t\\\n+\t      fprintf (FILE, \"L%d\",\t\t\t\t\t\\\n+\t\t\tCODE_LABEL_NUMBER (XEXP (offset, 0)));\t\t\\\n+\t    else\t\t\t\t\t\t\t\\\n+\t      output_addr_const (FILE, offset);\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"0\");\t\t\t\t\t\t\\\n+\tif (xreg)\t\t\t\t\t\t\t\\\n+\t    fprintf (FILE, \"(%s,%s)\",\t\t\t\t\t\\\n+\t\t    reg_names[REGNO (xreg)], reg_names[REGNO (breg)]); \t\\\n+\telse\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]);\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      default:\t\t\t\t\t\t\t\t\\\n+\tmvs_page_lit += 4;\t\t\t\t\t\t\\\n+\tif (SYMBOL_REF_FLAG (ADDR)) fprintf (FILE, \"=V(\");\t\t\\\n+\telse                        fprintf (FILE, \"=A(\");\t\t\\\n+\toutput_addr_const (FILE, ADDR);\t\t\t\t\t\\\n+\tfprintf (FILE, \")\");\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This macro generates the assembly code for function exit, on machines\n+   that need it.  If FUNCTION_EPILOGUE is not defined then individual\n+   return instructions are generated for each return statement.  Args are\n+   same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer!\n+   It should use the frame pointer only.  This is mandatory because\n+   of alloca; we also take advantage of it to omit stack adjustments\n+   before returning.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, LSIZE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+  check_label_emit();\t\t\t\t\t\t\t\\\n+  mvs_check_page (FILE,14,0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"# Function epilogue\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\tsp,4(0,sp)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tL\\tlr,12(0,sp)\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tLM\\t2,12,28(sp)\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\tBASR\\t1,lr\\n\");\t\t\t\t\t\\\n+  mvs_page_num++;\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"# Function literal pool\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.ltorg\\n\");\t\t\t\t\t\t\\\n+  fprintf (FILE, \"# Function page table\\n\");\t\t\t\t\\\n+  fprintf (FILE, \"\\t.balign\\t4\\n\");\t\t\t\t\t\\\n+  fprintf (FILE, \".LPGT%d:\\n\", function_base_page);\t\t\t\\\n+  mvs_free_label_list();\t\t\t\t\t\t\\\n+  for ( i = function_base_page; i < mvs_page_num; i++ )\t\t\t\\\n+    fprintf (FILE, \"\\t.long\\t.LPG%d\\n\", i);\t\t\t\t\\\n+}\n+\n+#define FUNCTION_PROLOGUE(FILE, LSIZE) i370_function_prolog ((FILE), (LSIZE));\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+/* Make it a no-op for now, so we can at least compile glibc */\n+#define FUNCTION_PROFILER(FILE, LABELNO)  {\t\t\t\t\\\n+  mvs_check_page (FILE, 24, 4);\t\t\t\t\t\t\\\n+     fprintf (FILE, \"\\tSTM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n+     fprintf (FILE, \"\\tLA\\tr1,1(0,0)\\n\"); \t\t\t\t\\\n+     fprintf (FILE, \"\\tL\\tr2,=A(.LP%d)\\n\", LABELNO);\t\t\t\\\n+     fprintf (FILE, \"\\tA\\tr1,0(r2)\\n\");\t\t\t \t\t\\\n+     fprintf (FILE, \"\\tST\\tr1,0(r2)\\n\");\t\t \t\t\\\n+     fprintf (FILE, \"\\tLM\\tr1,r2,%d(sp)\\n\", STACK_POINTER_OFFSET-8);\t\\\n+}\n+\n+/* Don't bother to output .extern pseudo-ops.  They are not needed by\n+   ELF assemblers.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL\n+\n+#define ASM_DOUBLE \"\\t.double\"     \n+#define ASM_LONG \"\\t.long\"\n+#define ASM_SHORT \"\\t.short\"\n+#define ASM_BYTE \"\\t.byte\"\n+\n+/* Argument to the flt pt. macros is a REAL_VALUE_TYPE which \n+   may or may not be a float/double, depending on whther we\n+   are running in cross-compiler mode.  */\n+/* This is how to output an assembler line defining a `double' constant.  */\n+#define ASM_OUTPUT_DOUBLE(FILE, RVAL) {\t\t\t\t\t\\\n+  char buf[50];\t\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_DECIMAL (RVAL,  HOST_WIDE_INT_PRINT_DOUBLE_HEX, buf);\t\\\n+  fprintf (FILE, \"\\tDC\\tD'%s'\\n\", buf);\t\t\t\t\t\\\n+}\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+#define ASM_OUTPUT_FLOAT(FILE, RVAL) {\t\t\t\t\t\\\n+  char buf[50];\t\t\t\t\t\t\t\t\\\n+  REAL_VALUE_TO_DECIMAL (RVAL,  HOST_WIDE_INT_PRINT_DEC, buf);\t\t\\\n+  fprintf (FILE, \"\\tDC\\tE'%s'\\n\", buf); \t\t\t\t\\\n+}\n+\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_LONG),              \\\n+  output_addr_const (FILE,(VALUE)),             \\\n+  putc('\\n',FILE))\n+\n+/* Likewise for `char' and `short' constants.  */\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_SHORT),             \\\n+  output_addr_const (FILE,(VALUE)),             \\\n+  putc('\\n',FILE))\n+\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"%s \", ASM_BYTE_OP),           \\\n+  output_addr_const (FILE, (VALUE)),            \\\n+  putc ('\\n', FILE))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf ((FILE), \"%s 0x%x\\n\", ASM_BYTE_OP, (VALUE))\n+ \n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+#define ASM_OUTPUT_LABEL(FILE,NAME)     \\\n+   (assemble_name (FILE, NAME), fputs (\":\\n\", FILE))\n+ \n+/* #define ASM_OUTPUT_LABELREF(FILE, NAME) */\t/* use gas -- defaults.h */\n+\n+/* Generate internal label.  Since we can branch here from off page, we\n+   must reload the base register.  Note that internal labels are generated\n+   for loops, goto's and case labels.   */\n+#undef ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (!strcmp (PREFIX,\"L\"))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      mvs_add_label(NUM);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \".%s%d:\\n\", PREFIX, NUM); \t\t\t\t\\\n+}\n+\n+/* let config/svr4.h define this ...\n+ *  #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\n+ *    fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+ */\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \t\t\t\t\\\n+  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long\\t.L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \t\t\\\n+  mvs_check_page (FILE, 4, 0);\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\t.long\\t.L%d-.L%d\\n\", VALUE, REL)\n+\n+/* Right now, PUSH & POP are used only when profiling is enabled, \n+   and then, only to push the static chain reg and the function struct \n+   value reg, and only if those are used by the function being profiled.\n+   We don't need this for profiling, so punt.  */\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) \n+#define ASM_OUTPUT_REG_POP(FILE, REGNO)\t\n+\n+\n+/* Indicate that jump tables go in the text section.  This is\n+   necessary when compiling PIC code.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* Define macro used to output shift-double opcodes when the shift\n+   count is in %cl.  Some assemblers require %cl as an argument;\n+   some don't.\n+\n+   GAS requires the %cl argument, so override i386/unix.h. */\n+\n+#undef SHIFT_DOUBLE_OMITS_COUNT\n+#define SHIFT_DOUBLE_OMITS_COUNT 0\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)  \\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),    \\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+ \n+/* Allow #sccs in preprocessor.  */\n+#define SCCS_DIRECTIVE\n+\n+ /* Implicit library calls should use memcpy, not bcopy, etc.  */\n+#define TARGET_MEM_FUNCTIONS\n+ \n+/* Output before read-only data.  */\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable (initialized) data.  */\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Output before writable (uninitialized) data.  */\n+#define BSS_SECTION_ASM_OP \".bss\"\n+\n+/* In the past there was confusion as to what the argument to .align was\n+   in GAS.  For the last several years the rule has been this: for a.out\n+   file formats that argument is LOG, and for all other file formats the\n+   argument is 1<<LOG.\n+\n+   However, GAS now has .p2align and .balign pseudo-ops so to remove any\n+   doubt or guess work, and since this file is used for both a.out and other\n+   file formats, we use one of them.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+  if ((LOG)!=0) fprintf ((FILE), \"\\t.balign %d\\n\", 1<<(LOG))\n+ \n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)  \\\n+  (fputs (\".globl \", FILE), assemble_name (FILE, NAME), fputs (\"\\n\", FILE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),                     \\\n+  assemble_name ((FILE), (NAME)),               \\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),                    \\\n+  assemble_name ((FILE), (NAME)),               \\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+#endif /* TARGET_ELF_ABI */\n+#endif /* __I370_H__ */"}, {"sha": "8896f2a80217cc4957f5ed425aabab85f2a75393", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 1249, "deletions": 698, "changes": 1947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=92d6db668f528856cbc05ed1f5886b3b69378be4"}, {"sha": "5715909c5a00d76abf1bffc26336abe2e3860ec4", "filename": "gcc/config/i370/linux.h", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Flinux.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,128 @@\n+/* Definitions of target machine for GNU compiler.  System/370 version.\n+   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for Linux/390 by Linas Vepstas (linas@linas.org)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+#define TARGET_VERSION fprintf (stderr, \" (i370 GNU/Linux with ELF)\");\n+\n+/* Specify that we're generating code for a Linux port to 370 */\n+\n+#define TARGET_ELF_ABI\n+#define LINUX_DEFAULT_ELF\n+\n+\n+/* hack alert define to get dbx/gdb/dwarf to compile  */\n+/* problem is that host float format is not target float format. */\n+/* define REAL_ARITHMETIC for software emulation of float to\n+ * int conversion.  This seems to have somethings to do with \n+ * cross-compiling ... */\n+#define REAL_ARITHMETIC\n+\n+/* Include system common definitions */\n+\n+#include \"config/linux.h\"\n+#include \"config/i370/i370.h\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-DGCC -Dgcc -D__ELF__ -Dunix -Dlinux -Asystem(posix) -Acpu(i370) -Amachine(i370)\"\n+\n+/* Options for this target machine. */\n+\n+#define LIBGCC_SPEC \"libgcc.a%s\"\n+\n+#ifdef SOME_FUTURE_DAY\n+ \n+#define CPP_SPEC \"%{posix: -D_POSIX_SOURCE} %(cpp_sysv) %(cpp_endian_big) \\\n+%{mcall-linux: %(cpp_os_linux) } \\\n+%{!mcall-linux: %(cpp_os_default) }\"\n+\n+#define LIB_SPEC \"\\\n+%{mcall-linux: %(lib_linux) } \\\n+%{!mcall-linux:%(lib_default) }\"\n+\n+#define STARTFILE_SPEC \"\\\n+%{mcall-linux: %(startfile_linux) } \\\n+%{!mcall-linux: %(startfile_default) }\"\n+\n+#define ENDFILE_SPEC \"\\\n+%{mcall-linux: %(endfile_linux) } \\\n+%{!mcall-linux: %(endfile_default) }\"\n+\n+/* GNU/Linux support.  */\n+#ifndef LIB_LINUX_SPEC\n+#define LIB_LINUX_SPEC \"%{mnewlib: --start-group -llinux -lc --end-group } %{!mnewlib: -lc }\"\n+#endif\n+\n+#ifndef STARTFILE_LINUX_SPEC\n+#define STARTFILE_LINUX_SPEC \"\\\n+%{!shared: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n+%{mnewlib: ecrti.o%s} \\\n+%{!mnewlib: crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n+#endif\n+\n+#ifndef ENDFILE_LINUX_SPEC\n+#define ENDFILE_LINUX_SPEC \"\\\n+%{mnewlib: ecrtn.o%s} \\\n+%{!mnewlib: %{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s}\"\n+#endif\n+\n+#ifndef LINK_START_LINUX_SPEC\n+#define LINK_START_LINUX_SPEC \"-Ttext 0x10000\"\n+#endif\n+\n+#ifndef LINK_OS_LINUX_SPEC\n+#define LINK_OS_LINUX_SPEC \"\"\n+#endif\n+\n+#ifndef CPP_OS_LINUX_SPEC\n+#define CPP_OS_LINUX_SPEC \"-D__unix__ -D__linux__ \\\n+%{!ansi: -Dunix -Dlinux } \\\n+-Asystem(unix) -Asystem(linux)\"\n+#endif\n+\n+#ifndef CPP_OS_LINUX_SPEC\n+#define CPP_OS_LINUX_SPEC \"\"\n+#endif\n+\n+\n+/* Define any extra SPECS that the compiler needs to generate.  */\n+#undef  SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS                                           \\\n+  { \"lib_linux\",                LIB_LINUX_SPEC },                       \\\n+  { \"lib_default\",              LIB_DEFAULT_SPEC },                     \\\n+  { \"startfile_linux\",          STARTFILE_LINUX_SPEC },                 \\\n+  { \"startfile_default\",        STARTFILE_DEFAULT_SPEC },               \\\n+  { \"endfile_linux\",            ENDFILE_LINUX_SPEC },                   \\\n+  { \"endfile_default\",          ENDFILE_DEFAULT_SPEC },                 \\\n+  { \"link_shlib\",               LINK_SHLIB_SPEC },                      \\\n+  { \"link_target\",              LINK_TARGET_SPEC },                     \\\n+  { \"link_start\",               LINK_START_SPEC },                      \\\n+  { \"link_start_linux\",         LINK_START_LINUX_SPEC },                \\\n+  { \"link_os\",                  LINK_OS_SPEC },                         \\\n+  { \"link_os_linux\",            LINK_OS_LINUX_SPEC },                   \\\n+  { \"link_os_default\",          LINK_OS_DEFAULT_SPEC },                 \\\n+  { \"cpp_endian_big\",           CPP_ENDIAN_BIG_SPEC },                  \\\n+  { \"cpp_os_linux\",             CPP_OS_LINUX_SPEC },                    \\\n+  { \"cpp_os_default\",           CPP_OS_DEFAULT_SPEC },\n+\n+#endif /* SOME_FUTURE_DAY */"}, {"sha": "191be380858e091ba5332c1b6f92433d202de711", "filename": "gcc/config/i370/mvs.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fmvs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fmvs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fmvs.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,46 @@\n+/* Definitions of target machine for GNU compiler.  System/370 version.\n+   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define TARGET_VERSION printf (\" (370/MVS)\");\n+\n+/* Specify that we're generating code for the Language Environment */\n+\n+#define LE370 1\n+#define TARGET_EBCDIC 1\n+#define TARGET_HLASM 1\n+\n+/* Options for the preprocessor for this target machine.  */\n+\n+#define CPP_SPEC \"-trigraphs\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#if defined(LE370)\n+#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -DLE370 -Asystem(mvs) -Acpu(i370) -Amachine(i370)\"\n+#else\n+#define CPP_PREDEFINES \"-DGCC -Dgcc -DMVS -Dmvs -Asystem(mvs) -Acpu(i370) -Amachine(i370)\"\n+#endif\n+\n+/* Include system common definitions */\n+\n+#include \"config/i370/i370.h\"\n+"}, {"sha": "62900520b871ecee969edacb0a5105e7f1464ad2", "filename": "gcc/config/i370/oe.h", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Foe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Foe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Foe.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,45 @@\n+/* Definitions of target machine for GNU compiler.  System/370 version.\n+   Copyright (C) 1989, 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define TARGET_VERSION printf (\" (370/OpenEdition)\");\n+\n+/* Specify that we're generating code for the Language Environment */\n+\n+#define LE370 1\n+#define LONGEXTERNAL 1\n+#define TARGET_EBCDIC 1\n+#define TARGET_HLASM 1\n+\n+/* Options for this target machine.  */\n+\n+#define LIB_SPEC \"\"\n+#define LIBGCC_SPEC \"\"\n+#define STARTFILE_SPEC \"/usr/local/lib/gccmain.o\"\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-DGCC -Dgcc -DUNIX -Dunix -Dopenedition -D__i370__ -Asystem(openedition) -Asystem(unix) -Acpu(i370) -Amachine(i370)\"\n+\n+/* Include system common definitions */\n+\n+#include \"config/i370/i370.h\"\n+"}, {"sha": "12cd6b8f5e88a6cde9940c60054c052ee8813e51", "filename": "gcc/config/i370/t-linux", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Ft-linux?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,4 @@\n+# config/i370/t-linux: this file defines Makefile overrides when building \n+# for a Linux target.  Thes definitions are in addition to config/t-linux.\n+# pretty busted at the moment\n+CROSS_LIBGCC1 ="}, {"sha": "d20ab385dcc48550cf99793a947687f32cedab6d", "filename": "gcc/config/i370/t-mvs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-mvs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-mvs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Ft-mvs?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,4 @@\n+# There is no libgcc for mvs\n+LIBGCC =\n+INSTALL_LIBGCC =\n+LIBGCC1_TEST ="}, {"sha": "622402daf3305123ab903dcdf5040205b002da03", "filename": "gcc/config/i370/t-oe", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-oe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Ft-oe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Ft-oe?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,4 @@\n+# There is no libgcc for OpenEdition\n+LIBGCC =\n+INSTALL_LIBGCC =\n+LIBGCC1_TEST ="}, {"sha": "79f34bdd5abef78fe76c968fec3ece0353e45501", "filename": "gcc/config/i370/x-oe", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fx-oe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fx-oe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fx-oe?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,26 @@\n+#\n+# Host is an i370 running OpenEdition\n+#\n+\n+# Use GCC alloca\n+\n+ALLOCA = alloca.o\n+\n+# Don't bother fixing up header files, they're wierd\n+\n+STMP_FIXPROTO =\n+\n+# Set up to make using c89\n+\n+X_CFLAGS=-D_ALL_SOURCE\n+CC=c89\n+\n+# Explicitly use libiberty\n+\n+CLIB=-liberty\n+LDFLAGS=-L../libiberty\n+\n+# TAR Options\n+\n+TAROUTOPTS=xpf\n+"}, {"sha": "e0ab373c54d6a4affd31ba61049a26ce88167d5f", "filename": "gcc/config/i370/xm-linux.h", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-linux.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,67 @@\n+/* Configuration for GNU C-compiler for System/370.\n+   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n+   Modified for 390/Linux by Linas Vepstas (linas@linas.org)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+#define USE_STDARGS 1\n+#define USE_PROTOTYPES 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+\n+#define HOST_BITS_PER_CHAR\t8\n+#define HOST_BITS_PER_SHORT\t16\n+#define HOST_BITS_PER_INT\t32\n+#define HOST_BITS_PER_LONG\t32\n+#define HOST_BITS_PER_LONGLONG\t64\n+#define HOST_FLOAT_FORMAT\tIEEE_FLOAT_FORMAT\n+\n+#define HOST_WORDS_BIG_ENDIAN    \n+\n+/* If not compiled with GNU C, use the C alloca and use only int bitfields.  */\n+#ifndef __GNUC__\n+#define USE_C_ALLOCA\n+#if __STDC__\n+extern void *alloca ();\n+#else\n+extern char *alloca ();\n+#endif\n+#define ONLY_INT_FIELDS\n+#endif\n+\n+// #define USG\n+\n+/* Target machine dependencies.  tm.h is a symbolic link to the actual\n+   target specific file.  */\n+\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+\n+#define SUCCESS_EXIT_CODE\t0\n+#define FATAL_EXIT_CODE\t\t12\n+\n+// #define NO_DBX_FORMAT\n+"}, {"sha": "d764eb353a3a616fac95ecf9b5282183ad62afe4", "filename": "gcc/config/i370/xm-mvs.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-mvs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-mvs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-mvs.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,53 @@\n+/* Configuration for GNU C-compiler for System/370.\n+   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+\n+#define HOST_BITS_PER_CHAR\t8\n+#define HOST_BITS_PER_SHORT\t16\n+#define HOST_BITS_PER_INT\t32\n+#define HOST_BITS_PER_LONG\t32\n+#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n+#define HOST_EBCDIC\t\t1\n+\n+#define USG\n+#ifndef MVS\n+#define MVS\n+#endif\n+\n+/* Target machine dependencies.  tm.h is a symbolic link to the actual\n+   target specific file.  */\n+\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+\n+#define SUCCESS_EXIT_CODE\t0\n+#define FATAL_EXIT_CODE\t\t12\n+\n+#define NO_DBX_FORMAT\n+"}, {"sha": "22e7bfac6ce401388b7c96f98ebebcc5ccced0bb", "filename": "gcc/config/i370/xm-oe.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-oe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92d6db668f528856cbc05ed1f5886b3b69378be4/gcc%2Fconfig%2Fi370%2Fxm-oe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fxm-oe.h?ref=92d6db668f528856cbc05ed1f5886b3b69378be4", "patch": "@@ -0,0 +1,55 @@\n+/* Configuration for GNU C-compiler for System/370.\n+   Copyright (C) 1989, 1993, 1997 Free Software Foundation, Inc.\n+   Contributed by Jan Stein (jan@cd.chalmers.se).\n+   Modified for OS/390 OpenEdition by Dave Pitts (dpitts@cozx.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* #defines that need visibility everywhere.  */\n+\n+#define FALSE 0\n+#define TRUE 1\n+\n+#define USE_STDARGS 1\n+#define USE_PROTOTYPES 1\n+\n+/* This describes the machine the compiler is hosted on.  */\n+\n+#define HOST_BITS_PER_CHAR\t8\n+#define HOST_BITS_PER_SHORT\t16\n+#define HOST_BITS_PER_INT\t32\n+#define HOST_BITS_PER_LONG\t32\n+#define HOST_FLOAT_FORMAT\tIBM_FLOAT_FORMAT\n+#define HOST_EBCDIC\t\t1\n+\n+#define ONLY_INT_FIELDS\t\t1\n+\n+#define USG\n+\n+/* Target machine dependencies.  tm.h is a symbolic link to the actual\n+   target specific file.  */\n+\n+#include \"tm.h\"\n+\n+/* Arguments to use with `exit'.  */\n+\n+#define SUCCESS_EXIT_CODE\t0\n+#define FATAL_EXIT_CODE\t\t12\n+\n+#define NO_DBX_FORMAT\n+"}]}