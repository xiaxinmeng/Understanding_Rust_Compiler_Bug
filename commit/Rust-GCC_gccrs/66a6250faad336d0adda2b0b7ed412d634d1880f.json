{"sha": "66a6250faad336d0adda2b0b7ed412d634d1880f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZhNjI1MGZhYWQzMzZkMGFkZGEyYjBiN2VkNDEyZDYzNGQxODgwZg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-20T19:53:38Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-07-20T19:53:38Z"}, "message": "lang-specs.h (c++-cpp-output): Pass -fpreprocessed.\n\n\t* lang-specs.h (c++-cpp-output): Pass -fpreprocessed.\n\n\t* lex.c (token_getch, token_put_back): New fns.\n\t(real_yylex): Use them.\n\n\t* lex.c (lang_init): Generalize.\n\t(lang_init_options): Tell cpplib this is C++.\n\t(nextchar): Remove.  Replace uses with put_back.\n\t(skip_white_space): Handle linemode here.  Optimize for cpplib.\n\t(extend_token_buffer_to): New fn.\n\t(extend_token_buffer): Use it.\n\t(read_line_number, check_newline): Just deal with tokens.\n\t(real_yylex): More cpplib optimizations.  Simplify.  Don't produce\n\tEXTERN_LANG_STRING, LEFT_RIGHT or PAREN_STAR_PAREN here.\n\t* spew.c (yylex): Produce LEFT_RIGHT and EXTERN_LANG_STRING.\n\t* parse.y (PAREN_STAR_PAREN): Remove.\n\t* input.c: Don't use the putback machinery with cpplib.\n\t(sub_getch): Fold back into getch.\n\t(getch): Don't handle linemode here.\n\t(feed_input): Unget any text in the token buffer.\n\n\t* lex.c\t(set_typedecl_interface_info, set_vardecl_interface_info,\n\tnextyychar, nextyylval): Remove.\n\n\t* lex.c (indent_level): New variable.\n\t(init_parse): Set cpp_token to CPP_DIRECTIVE.\n\t(consume_string): Make this smart about USE_CPPLIB.\n\t(yyungetc): Use put_back function.\n\t(pragma_getc, pragma_ungetc): Functions deleted.\n\t(check_newline): Rewrite to be intelligent about USE_CPPLIB.\n\tAlso, call HANDLE_PRAGMA with getch, yyungetc, not pragma_getc and\n\tpragma_ungetc.\n\t(real_yylex): Rewrite to be intelligent about USE_CPPLIB.\n\tAlso, clean up cases where we redundantly set token_buffer[0].\n\t(read_line_number): New fn.\n\t* input.c (feed_input): Use integrated cpplib if USE_CPPLIB.\n\t(end_input): Call cpp_pop_buffer if USE_CPPLIB.\n\t(sub_getch): Conditionalize out code that's not appropriate if\n\tUSE_CPPLIB.\n\t(put_back): Rewrite in case USE_CPPLIB is defined.\n\t(input_redirected): Ditto.\n\nFrom-SVN: r28193", "tree": {"sha": "7fb4578f40b67cbe01e6123f6a2be6b9152e074b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fb4578f40b67cbe01e6123f6a2be6b9152e074b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66a6250faad336d0adda2b0b7ed412d634d1880f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a6250faad336d0adda2b0b7ed412d634d1880f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66a6250faad336d0adda2b0b7ed412d634d1880f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66a6250faad336d0adda2b0b7ed412d634d1880f/comments", "author": null, "committer": null, "parents": [{"sha": "81f374ebfb60d4382ee618c45c2e4952d1fc2d8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/81f374ebfb60d4382ee618c45c2e4952d1fc2d8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/81f374ebfb60d4382ee618c45c2e4952d1fc2d8c"}], "stats": {"total": 8266, "additions": 4100, "deletions": 4166}, "files": [{"sha": "9022cf09beb6300156fd7d6a74834dd589c020ca", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -1,3 +1,50 @@\n+1999-07-20  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lang-specs.h (c++-cpp-output): Pass -fpreprocessed.\n+\n+\t* lex.c (token_getch, token_put_back): New fns.\n+\t(real_yylex): Use them.\n+\n+\t* lex.c (lang_init): Generalize.\n+\t(lang_init_options): Tell cpplib this is C++.\n+\t(nextchar): Remove.  Replace uses with put_back.\n+\t(skip_white_space): Handle linemode here.  Optimize for cpplib.\n+\t(extend_token_buffer_to): New fn.\n+\t(extend_token_buffer): Use it.\n+\t(read_line_number, check_newline): Just deal with tokens.\n+\t(real_yylex): More cpplib optimizations.  Simplify.  Don't produce\n+\tEXTERN_LANG_STRING, LEFT_RIGHT or PAREN_STAR_PAREN here.\n+\t* spew.c (yylex): Produce LEFT_RIGHT and EXTERN_LANG_STRING.\n+\t* parse.y (PAREN_STAR_PAREN): Remove.\n+\t* input.c: Don't use the putback machinery with cpplib.\n+\t(sub_getch): Fold back into getch.\n+\t(getch): Don't handle linemode here.\n+\t(feed_input): Unget any text in the token buffer.\n+\n+\t* lex.c\t(set_typedecl_interface_info, set_vardecl_interface_info,\n+\tnextyychar, nextyylval): Remove.\n+\n+1999-07-20  Michael Tiemann  <tiemann@holodeck.cygnus.com>\n+\t    Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* lex.c (indent_level): New variable.\n+\t(init_parse): Set cpp_token to CPP_DIRECTIVE.\n+\t(consume_string): Make this smart about USE_CPPLIB.\n+\t(yyungetc): Use put_back function.\n+\t(pragma_getc, pragma_ungetc): Functions deleted.\n+\t(check_newline): Rewrite to be intelligent about USE_CPPLIB.\n+\tAlso, call HANDLE_PRAGMA with getch, yyungetc, not pragma_getc and\n+\tpragma_ungetc.\n+\t(real_yylex): Rewrite to be intelligent about USE_CPPLIB.\n+\tAlso, clean up cases where we redundantly set token_buffer[0].\n+\t(read_line_number): New fn.\n+\t* input.c (feed_input): Use integrated cpplib if USE_CPPLIB.\n+\t(end_input): Call cpp_pop_buffer if USE_CPPLIB.\n+\t(sub_getch): Conditionalize out code that's not appropriate if\n+\tUSE_CPPLIB.\n+\t(put_back): Rewrite in case USE_CPPLIB is defined.\n+\t(input_redirected): Ditto.\n+\n Tue Jul 20 11:24:19 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n \t* cp-tree.h: Delete lots of declarations of tree nodes; replaced by"}, {"sha": "07c952314866b5d1937fbbe3713f2952a90aad1b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -1176,8 +1176,8 @@ struct lang_type\n \n /* For FUNCTION_TYPE or METHOD_TYPE, a list of the exceptions that\n    this type can raise.  Each TREE_VALUE is a _TYPE.  The TREE_VALUE\n-   will be NULL_TREE to indicate a throw specification of `(...)', or,\n-   equivalently, no throw specification.  */\n+   will be NULL_TREE to indicate a throw specification of `()', or\n+   no exceptions allowed.  */\n #define TYPE_RAISES_EXCEPTIONS(NODE) TYPE_NONCOPIED_PARTS (NODE)\n \n /* For FUNCTION_TYPE or METHOD_TYPE, return 1 iff it is declared `throw()'.  */"}, {"sha": "5feb1fd17e7a4c84415502976d27f7dd024fba47", "filename": "gcc/cp/input.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Finput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Finput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finput.c?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -1,6 +1,7 @@\n /* Input handling for G++.\n    Copyright (C) 1992, 93-98, 1999 Free Software Foundation, Inc.\n    Written by Ken Raeburn (raeburn@cygnus.com) while at Watchmaker Computing.\n+   Enhanced by Michael Tiemann (tiemann@cygnus.com) to better support USE_CPPLIB\n \n This file is part of GNU CC.\n \n@@ -31,14 +32,16 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"system.h\"\n \n-extern FILE *finput;\n-\n+#if !USE_CPPLIB\n struct putback_buffer {\n   char *buffer;\n   int   buffer_size;\n   int   index;\n };\n \n+static struct putback_buffer putback = {NULL, 0, -1};\n+#endif\n+\n struct input_source {\n   /* saved string */\n   char *str;\n@@ -51,7 +54,9 @@ struct input_source {\n   char *filename;\n   int lineno;\n   struct pending_input *input;\n+#if !USE_CPPLIB\n   struct putback_buffer putback;\n+#endif\n };\n \n static struct input_source *input, *free_inputs;\n@@ -62,9 +67,6 @@ extern int lineno;\n #if USE_CPPLIB\n extern unsigned char *yy_cur, *yy_lim;\n extern int yy_get_token ();\n-#define GETC() (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ())\n-#else\n-#define GETC() getc (finput)\n #endif\n \n extern void feed_input PROTO((char *, int));\n@@ -76,7 +78,6 @@ extern int input_redirected PROTO((void));\n static inline struct input_source * allocate_input PROTO((void));\n static inline void free_input PROTO((struct input_source *));\n static inline void end_input PROTO((void));\n-static inline int sub_getch PROTO((void));\n \n static inline struct input_source *\n allocate_input ()\n@@ -104,8 +105,6 @@ free_input (inp)\n   free_inputs = inp;\n }\n \n-static struct putback_buffer putback = {NULL, 0, -1};\n-\n /* Some of these external functions are declared inline in case this file\n    is included in lex.c.  */\n \n@@ -121,42 +120,57 @@ feed_input (str, len)\n   while (len && !str[len-1])\n     len--;\n \n+#if USE_CPPLIB\n+  if (yy_lim > yy_cur)\n+    /* If we've started reading the next token, we're hosed.  */\n+    my_friendly_abort (990710);\n+  cpp_push_buffer (&parse_in, str, len);\n+  CPP_BUFFER (&parse_in)->manual_pop = 1;\n+#else\n   inp->str = str;\n   inp->length = len;\n   inp->offset = 0;\n-  inp->next = input;\n-  inp->filename = input_filename;\n-  inp->lineno = lineno;\n-  inp->input = save_pending_input ();\n   inp->putback = putback;\n   putback.buffer = NULL;\n   putback.buffer_size = 0;\n   putback.index = -1;\n+#endif\n+  inp->next = input;\n+  inp->filename = input_filename;\n+  inp->lineno = lineno;\n+  inp->input = save_pending_input ();\n   input = inp;\n }\n \n-struct pending_input *to_be_restored; /* XXX */\n extern int end_of_file;\n \n static inline void\n end_input ()\n {\n   struct input_source *inp = input;\n \n+#if USE_CPPLIB\n+  cpp_pop_buffer (&parse_in);\n+#else\n+  putback = inp->putback;\n+#endif\n+\n   end_of_file = 0;\n   input = inp->next;\n   input_filename = inp->filename;\n   lineno = inp->lineno;\n   /* Get interface/implementation back in sync.  */\n   extract_interface_info ();\n-  putback = inp->putback;\n   restore_pending_input (inp->input);\n   free_input (inp);\n }\n \n-static inline int\n-sub_getch ()\n+inline int\n+getch ()\n {\n+#if USE_CPPLIB\n+  return (yy_cur < yy_lim ? *yy_cur++ : yy_get_token ());\n+#else\n   if (putback.index != -1)\n     {\n       int ch = putback.buffer[putback.index];\n@@ -178,14 +192,23 @@ sub_getch ()\n \t}\n       return (unsigned char)input->str[input->offset++];\n     }\n-  return GETC ();\n+  return getc (finput);\n+#endif\n }\n \n inline\n void\n put_back (ch)\n      int ch;\n {\n+#if USE_CPPLIB\n+  if (ch == EOF)\n+    ;\n+  else if (yy_cur[-1] != ch)\n+    my_friendly_abort (990709);\n+  else\n+    yy_cur--;\n+#else\n   if (ch != EOF)\n     {\n       if (putback.index == putback.buffer_size - 1)\n@@ -196,25 +219,16 @@ put_back (ch)\n       my_friendly_assert (putback.buffer != NULL, 224);\n       putback.buffer[++putback.index] = ch;\n     }\n-}\n-\n-extern int linemode;\n-\n-int\n-getch ()\n-{\n-  int ch = sub_getch ();\n-  if (linemode && ch == '\\n')\n-    {\n-      put_back (ch);\n-      ch = EOF;\n-    }\n-  return ch;\n+#endif\n }\n \n inline\n int\n input_redirected ()\n {\n+#ifdef USE_CPPLIB\n+  return CPP_BUFFER(&parse_in)->manual_pop;\n+#else\n   return input != 0;\n+#endif\n }"}, {"sha": "48a6ac5f69087280b5c85e75cf8bb0f572d52079", "filename": "gcc/cp/lang-specs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-specs.h?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -88,7 +88,7 @@ Boston, MA 02111-1307, USA.  */\n   {\"@c++-cpp-output\",\n    {\"%{!M:%{!MM:%{!E:cc1plus %i %1 %2 %{!Q:-quiet} %{d*} %{m*} %{a}\\\n \t\t\t    %{g*} %{O*} %{W*} %{w} %{pedantic*} %{ansi}\\\n-\t\t\t    %{v:-version} %{pg:-p} %{p}\\\n+\t\t\t    %{v:-version} %{pg:-p} %{p} -fpreprocessed\\\n \t\t\t    %{f*} %{+e*} %{aux-info*} %{Qn:-fno-ident}\\\n \t\t\t    %{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\\\n \t\t\t    %{S:%W{o*}%{!o*:-o %b.s}}%{!S:-o %{|!pipe:%g.s}} |\\n\\"}, {"sha": "dd083fd1cba19030015ed50821722a9abdf996ef", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 493, "deletions": 646, "changes": 1139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -60,14 +60,11 @@ static int check_newline PROTO((void));\n static int skip_white_space PROTO((int));\n static void finish_defarg PROTO((void));\n static int my_get_run_time PROTO((void));\n-static int get_last_nonwhite_on_line PROTO((void));\n static int interface_strcmp PROTO((const char *));\n static int readescape PROTO((int *));\n static char *extend_token_buffer PROTO((const char *));\n static void consume_string PROTO((struct obstack *, int));\n-static int set_typedecl_interface_info PROTO((tree *, void *));\n static void feed_defarg PROTO((tree, tree));\n-static int set_vardecl_interface_info PROTO((tree *, void *));\n static void store_pending_inline PROTO((tree, struct pending_inline *));\n static void reinit_parse_for_expr PROTO((struct obstack *));\n static int *init_cpp_parse PROTO((void));\n@@ -113,12 +110,15 @@ char *inline_text_firstobj;\n extern cpp_reader  parse_in;\n extern cpp_options parse_options;\n extern unsigned char *yy_cur, *yy_lim;\n+extern enum cpp_token cpp_token;\n extern int errorcount;\n #else\n FILE *finput;\n #endif\n int end_of_file;\n \n+int linemode;\n+\n /* Pending language change.\n    Positive is push count, negative is pop count.  */\n int pending_lang_change = 0;\n@@ -130,13 +130,7 @@ extern int first_token;\n extern struct obstack token_obstack;\n \n /* ??? Don't really know where this goes yet.  */\n-#if 1\n #include \"input.c\"\n-#else\n-extern void put_back (/* int */);\n-extern int input_redirected ();\n-extern void feed_input (/* char *, int */);\n-#endif\n \n /* Holds translations from TREE_CODEs to operator name strings,\n    i.e., opname_tab[PLUS_EXPR] == \"+\".  */\n@@ -309,6 +303,8 @@ static int maxtoken;\t\t/* Current nominal length of token buffer.  */\n char *token_buffer;\t\t/* Pointer to token buffer.\n \t\t\t\t   Actual allocated length is maxtoken + 2.  */\n \n+static int indent_level = 0;\t/* Number of { minus number of }. */\n+\n #include \"hash.h\"\n \f\n \n@@ -397,6 +393,7 @@ lang_init_options ()\n   cpp_reader_init (&parse_in);\n   parse_in.opts = &parse_options;\n   cpp_options_init (&parse_options);\n+  parse_options.cplusplus = 1;\n #endif\n \n   /* Default exceptions on.  */\n@@ -409,12 +406,7 @@ lang_init ()\n   /* the beginning of the file is a new line; check for # */\n   /* With luck, we discover the real source file's name from that\n      and put it in input_filename.  */\n-#if ! USE_CPPLIB\n   put_back (check_newline ());\n-#else\n-  check_newline ();\n-  yy_cur--;\n-#endif\n   if (flag_gnu_xref) GNU_xref_begin (input_filename);\n   init_repo (input_filename);\n }\n@@ -498,6 +490,7 @@ init_parse (filename)\n      token buffer.  We must arrange to read it out here. */\n   yy_cur = parse_in.token_buffer;\n   yy_lim = CPP_PWRITTEN (&parse_in);\n+  cpp_token = CPP_DIRECTIVE;\n \n #else\n   /* Open input file.  */\n@@ -1224,40 +1217,6 @@ cp_pragma_implementation (main_filename)\n   TREE_INT_CST_LOW (fileinfo) = interface_only;\n   TREE_INT_CST_HIGH (fileinfo) = interface_unknown;\n }\n-\n-static int\n-set_typedecl_interface_info (t, data)\n-     tree *t;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree id = get_time_identifier (DECL_SOURCE_FILE (*t));\n-  tree fileinfo = TIME_IDENTIFIER_FILEINFO (id);\n-  tree type = TREE_TYPE (*t);\n-\n-  CLASSTYPE_INTERFACE_ONLY (type) = TREE_INT_CST_LOW (fileinfo)\n-    = interface_strcmp (file_name_nondirectory (DECL_SOURCE_FILE (*t)));\n-  return 0;\n-}\n-\n-static int\n-set_vardecl_interface_info (t, data)\n-     tree *t;\n-     void *data ATTRIBUTE_UNUSED;\n-{\n-  tree type = DECL_CONTEXT (*t);\n-\n-  if (CLASSTYPE_INTERFACE_KNOWN (type))\n-    {\n-      if (CLASSTYPE_INTERFACE_ONLY (type))\n-\tset_typedecl_interface_info (&TYPE_MAIN_DECL (type), data);\n-      else\n-\tCLASSTYPE_VTABLE_NEEDS_WRITING (type) = 1;\n-      DECL_EXTERNAL (*t) = CLASSTYPE_INTERFACE_ONLY (type);\n-      TREE_PUBLIC (*t) = 1;\n-      return 1;\n-    }\n-  return 0;\n-}\n \f\n /* Set up the state required to correctly handle the definition of the\n    inline function whose preparsed state has been saved in PI.  */\n@@ -1328,8 +1287,6 @@ do_pending_inlines ()\n   begin_definition_of_inclass_inline (t);\n }\n \n-static int nextchar = -1;\n-\n /* Called from the fndecl rule in the parser when the function just parsed\n    was declared using a PRE_PARSED_FUNCTION_DECL (i.e. came from\n    do_pending_inlines).  */\n@@ -1352,9 +1309,7 @@ process_next_inline (t)\n \n       /* restore_pending_input will abort unless yychar is either\n          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n-         hosed, feed back YYEMPTY.  We also need to discard nextchar,\n-         since that may have gotten set as well.  */\n-      nextchar = -1;\n+         hosed, feed back YYEMPTY.  */\n     }\n   yychar = YYEMPTY;\n   end_input ();\n@@ -1380,7 +1335,20 @@ consume_string (this_obstack, matching_char)\n      int matching_char;\n {\n   register int c;\n-  int starting_lineno = lineno;\n+  int starting_lineno;\n+\n+#if USE_CPPLIB\n+  if (cpp_token == CPP_STRING)\n+    {\n+      /* The C preprocessor will warn about newlines in strings.  */\n+      obstack_grow (this_obstack, yy_cur, (yy_lim - yy_cur));\n+      yy_cur = yy_lim;\n+      lineno = parse_in.lineno;\n+      return;\n+    }\n+#endif\n+\n+  starting_lineno = lineno;\n   do\n     {\n       c = getch ();\n@@ -1416,12 +1384,9 @@ consume_string (this_obstack, matching_char)\n   while (c != matching_char);\n }\n \n-static int nextyychar = YYEMPTY;\n-static YYSTYPE nextyylval;\n-\n struct pending_input {\n-  int nextchar, yychar, nextyychar, eof;\n-  YYSTYPE yylval, nextyylval;\n+  int yychar, eof;\n+  YYSTYPE yylval;\n   struct obstack token_obstack;\n   int first_token;\n };\n@@ -1431,14 +1396,10 @@ save_pending_input ()\n {\n   struct pending_input *p;\n   p = (struct pending_input *) xmalloc (sizeof (struct pending_input));\n-  p->nextchar = nextchar;\n   p->yychar = yychar;\n-  p->nextyychar = nextyychar;\n   p->yylval = yylval;\n-  p->nextyylval = nextyylval;\n   p->eof = end_of_file;\n-  yychar = nextyychar = YYEMPTY;\n-  nextchar = -1;\n+  yychar = YYEMPTY;\n   p->first_token = first_token;\n   p->token_obstack = token_obstack;\n \n@@ -1452,14 +1413,9 @@ void\n restore_pending_input (p)\n      struct pending_input *p;\n {\n-  my_friendly_assert (nextchar == -1, 229);\n-  nextchar = p->nextchar;\n   my_friendly_assert (yychar == YYEMPTY || yychar == END_OF_SAVED_INPUT, 230);\n   yychar = p->yychar;\n-  my_friendly_assert (nextyychar == YYEMPTY, 231);\n-  nextyychar = p->nextyychar;\n   yylval = p->yylval;\n-  nextyylval = p->nextyylval;\n   first_token = p->first_token;\n   obstack_free (&token_obstack, (char *) 0);\n   token_obstack = p->token_obstack;\n@@ -1479,15 +1435,10 @@ yyungetc (ch, rescan)\n   /* Unget a character from the input stream.  */\n   if (yychar == YYEMPTY || rescan == 0)\n     {\n-      if (nextchar >= 0)\n-\tput_back (nextchar);\n-      nextchar = ch;\n+      put_back (ch);\n     }\n   else\n     {\n-      my_friendly_assert (nextyychar == YYEMPTY, 232);\n-      nextyychar = yychar;\n-      nextyylval = yylval;\n       yychar = ch;\n     }\n }\n@@ -1570,7 +1521,7 @@ reinit_parse_for_block (pyychar, obstackp)\n      int pyychar;\n      struct obstack *obstackp;\n {\n-  register int c = 0;\n+  register int c;\n   int blev = 1;\n   int starting_lineno = lineno;\n   char *starting_filename = input_filename;\n@@ -1608,14 +1559,8 @@ reinit_parse_for_block (pyychar, obstackp)\n       obstack_1grow (obstackp, '{');\n     }\n \n-  if (nextchar != EOF)\n-    {\n-      c = nextchar;\n-      nextchar = EOF;\n-    }\n-  else\n-    c = getch ();\n-  \n+  c = getch ();\n+\n   while (c != EOF)\n     {\n       int this_lineno = lineno;\n@@ -1737,20 +1682,14 @@ static void\n reinit_parse_for_expr (obstackp)\n      struct obstack *obstackp;\n {\n-  register int c = 0;\n+  register int c;\n   int starting_lineno = lineno;\n   char *starting_filename = input_filename;\n   int len;\n   int plev = 0;\n \n-  if (nextchar != EOF)\n-    {\n-      c = nextchar;\n-      nextchar = EOF;\n-    }\n-  else\n-    c = getch ();\n-  \n+  c = getch ();\n+\n   while (c != EOF)\n     {\n       int this_lineno = lineno;\n@@ -1922,9 +1861,7 @@ finish_defarg ()\n \n       /* restore_pending_input will abort unless yychar is either\n          END_OF_SAVED_INPUT or YYEMPTY; since we already know we're\n-         hosed, feed back YYEMPTY.  We also need to discard nextchar,\n-         since that may have gotten set as well.  */\n-      nextchar = -1;\n+         hosed, feed back YYEMPTY.  */\n     }\n   yychar = YYEMPTY;\n   end_input ();\n@@ -2192,6 +2129,11 @@ skip_white_space (c)\n       switch (c)\n \t{\n \tcase '\\n':\n+\t  if (linemode)\n+\t    {\n+\t      put_back (c);\n+\t      return EOF;\n+\t    }\n \t  c = check_newline ();\n \t  break;\n \n@@ -2201,9 +2143,14 @@ skip_white_space (c)\n \tcase '\\r':\n \tcase '\\v':\n \tcase '\\b':\n-\t  do\n+#if USE_CPPLIB\n+\t  /* While processing a # directive we don't get CPP_HSPACE\n+\t     tokens, so we also need to handle whitespace the normal way.  */\n+\t  if (cpp_token == CPP_HSPACE)\n+\t    c = yy_get_token ();\n+\t  else\n+#endif\n \t    c = getch ();\n-\t  while (c == ' ' || c == '\\t');\n \t  break;\n \n \tcase '\\\\':\n@@ -2221,472 +2168,407 @@ skip_white_space (c)\n     }\n }\n \n-\n-\n /* Make the token buffer longer, preserving the data in it.\n    P should point to just beyond the last valid character in the old buffer.\n    The value we return is a pointer to the new buffer\n    at a place corresponding to P.  */\n \n+static void\n+extend_token_buffer_to (size)\n+     int size;\n+{\n+  do\n+    maxtoken = maxtoken * 2 + 10;\n+  while (maxtoken < size);\n+  token_buffer = (char *) xrealloc (token_buffer, maxtoken + 2);\n+}\n+\n static char *\n extend_token_buffer (p)\n      const char *p;\n {\n   int offset = p - token_buffer;\n-\n-  maxtoken = maxtoken * 2 + 10;\n-  token_buffer = (char *) xrealloc (token_buffer, maxtoken + 2);\n-\n+  extend_token_buffer_to (offset);\n   return token_buffer + offset;\n }\n \f\n static int\n-get_last_nonwhite_on_line ()\n+read_line_number (num)\n+     int *num;\n {\n-  register int c;\n+  register int token = real_yylex ();\n \n-  /* Is this the last nonwhite stuff on the line?  */\n-  if (nextchar >= 0)\n-    c = nextchar, nextchar = -1;\n-  else\n-    c = getch ();\n-\n-  while (c == ' ' || c == '\\t')\n-    c = getch ();\n-  return c;\n-}\n-\n-#if defined HANDLE_PRAGMA\n-/* Local versions of these macros, that can be passed as function pointers.  */\n-static int\n-pragma_getc ()\n-{\n-  int c;\n-      \n-  if (nextchar != EOF)\n+  if (token == CONSTANT\n+      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n     {\n-      c = nextchar;\n-      nextchar = EOF;\n+      *num = TREE_INT_CST_LOW (yylval.ttype);\n+      return 1;\n     }\n   else\n-    c = getch ();\n-\n-  return c;\n-}\n-\n-static void\n-pragma_ungetc (arg)\n-     int arg;\n-{\n-  yyungetc (arg, 0);\n+    {\n+      if (token != END_OF_LINE)\n+\terror (\"invalid #-line\");\n+      return 0;\n+    }\n }\n-#endif /* HANDLE_PRAGMA */\n \n /* At the beginning of a line, increment the line number\n    and process any #-directive on this line.\n    If the line is a #-directive, read the entire line and return a newline.\n-   Otherwise, return the line's first non-whitespace character.  */\n+   Otherwise, return the line's first non-whitespace character.\n \n-int linemode;\n+   Note that in the case of USE_CPPLIB, we get the whole line as one\n+   CPP_DIRECTIVE token.  */\n \n static int\n check_newline ()\n {\n   register int c;\n   register int token;\n-  int saw_line = 0;\n+  int saw_line;\n+  enum { act_none, act_push, act_pop } action;\n+  int old_lineno, action_number, l;\n+  int entering_system_header;\n+  int entering_c_header;\n \n+ restart:\n   /* Read first nonwhite char on the line.  Do this before incrementing the\n      line number, in case we're at the end of saved text.  */\n \n+#ifdef USE_CPPLIB\n+  c = getch ();\n+  /* In some cases where we're leaving an include file, we can get multiple\n+     CPP_HSPACE tokens in a row, so we need to loop.  */\n+  while (cpp_token == CPP_HSPACE)\n+    c = yy_get_token ();\n+#else\n   do\n     c = getch ();\n   while (c == ' ' || c == '\\t');\n+#endif\n \n   lineno++;\n \n   if (c != '#')\n     {\n+      /* Sequences of multiple newlines are very common; optimize them.  */\n+      if (c == '\\n')\n+\tgoto restart;\n+\n       /* If not #, return it so caller will use it.  */\n       return c;\n     }\n \n   /* Don't read beyond this line.  */\n+  saw_line = 0;\n   linemode = 1;\n   \n-  /* Read first nonwhite char after the `#'.  */\n-\n-  do\n-    c = getch ();\n-  while (c == ' ' || c == '\\t');\n+#if USE_CPPLIB\n+  if (cpp_token == CPP_VSPACE)\n+    {\n+      /* Format is \"<space> <line number> <filename> <newline>\".\n+\t Only the line number is interesting, and even that\n+\t we can get more efficiently than scanning the line.  */\n+      yy_cur = yy_lim - 1;\n+      lineno = parse_in.lineno - 1;\n+      goto skipline;\n+    }\n+#endif\n \n-  /* If a letter follows, then if the word here is `line', skip\n-     it and ignore it; otherwise, ignore the line, with an error\n-     if the word isn't `pragma'.  */\n+  token = real_yylex ();\n \n-  if (ISALPHA (c))\n+  if (token == IDENTIFIER)\n     {\n-      if (c == 'p')\n+      /* If a letter follows, then if the word here is `line', skip\n+\t it and ignore it; otherwise, ignore the line, with an error\n+\t if the word isn't `pragma'.  */\n+\n+      const char *name = IDENTIFIER_POINTER (yylval.ttype);\n+\n+      if (!strcmp (name, \"pragma\"))\n \t{\n-\t  if (getch () == 'r'\n-\t      && getch () == 'a'\n-\t      && getch () == 'g'\n-\t      && getch () == 'm'\n-\t      && getch () == 'a')\n+\t  token = real_yylex ();\n+\t  if (token == IDENTIFIER\n+\t      && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n \t    {\n-\t      token = real_yylex ();\n-\t      if (token == IDENTIFIER\n-\t\t  && TREE_CODE (yylval.ttype) == IDENTIFIER_NODE)\n-\t\t{\n-\t\t  /* If this is 1, we handled it; if it's -1, it was one we\n-\t\t     wanted but had something wrong with it.  Only if it's\n-\t\t     0 was it not handled.  */\n-\t\t  if (handle_cp_pragma (IDENTIFIER_POINTER (yylval.ttype)))\n-\t\t    goto skipline;\n-\t\t}\n-\t      else if (token == END_OF_LINE)\n+\t      /* If this is 1, we handled it; if it's -1, it was one we\n+\t\t wanted but had something wrong with it.  Only if it's\n+\t\t 0 was it not handled.  */\n+\t      if (handle_cp_pragma (IDENTIFIER_POINTER (yylval.ttype)))\n \t\tgoto skipline;\n+\t    }\n+\t  else if (token == END_OF_LINE)\n+\t    goto skipline;\n \n #ifdef HANDLE_PRAGMA\n-\t      /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS\n-\t\t (if both are defined), in order to give the back\n-\t\t end a chance to override the interpretation of\n-\t\t SYSV style pragmas.  */\n-\t      if (HANDLE_PRAGMA (pragma_getc, pragma_ungetc,\n-\t\t\t\t IDENTIFIER_POINTER (yylval.ttype)))\n-\t\tgoto skipline;\n+\t  /* We invoke HANDLE_PRAGMA before HANDLE_GENERIC_PRAGMAS\n+\t     (if both are defined), in order to give the back\n+\t     end a chance to override the interpretation of\n+\t     SYSV style pragmas.  */\n+\t  if (HANDLE_PRAGMA (getch, put_back,\n+\t\t\t     IDENTIFIER_POINTER (yylval.ttype)))\n+\t    goto skipline;\n #endif /* HANDLE_PRAGMA */\n \t      \n #ifdef HANDLE_GENERIC_PRAGMAS\n-\t      if (handle_generic_pragma (token))\n-\t\tgoto skipline;\n+\t  if (handle_generic_pragma (token))\n+\t    goto skipline;\n #endif /* HANDLE_GENERIC_PRAGMAS */\n \n-\t      /* Issue a warning message if we have been asked to do so.\n-\t\t Ignoring unknown pragmas in system header file unless\n-\t\t an explcit -Wunknown-pragmas has been given. */\n-\t      if (warn_unknown_pragmas > 1\n-\t\t  || (warn_unknown_pragmas && ! in_system_header))\n-\t\twarning (\"ignoring pragma: %s\", token_buffer);\n-\t    }\n-\t  \n+\t  /* Issue a warning message if we have been asked to do so.\n+\t     Ignoring unknown pragmas in system header file unless\n+\t     an explcit -Wunknown-pragmas has been given. */\n+\t  if (warn_unknown_pragmas > 1\n+\t      || (warn_unknown_pragmas && ! in_system_header))\n+\t    warning (\"ignoring pragma: %s\", token_buffer);\n+\n \t  goto skipline;\n \t}\n-      else if (c == 'd')\n+      else if (!strcmp (name, \"define\"))\n \t{\n-\t  if (getch () == 'e'\n-\t      && getch () == 'f'\n-\t      && getch () == 'i'\n-\t      && getch () == 'n'\n-\t      && getch () == 'e'\n-\t      && ((c = getch ()) == ' ' || c == '\\t'))\n-\t    {\n-\t      debug_define (lineno, GET_DIRECTIVE_LINE ());\n-\t      goto skipline;\n-\t    }\n+\t  debug_define (lineno, GET_DIRECTIVE_LINE ());\n+\t  goto skipline;\n \t}\n-      else if (c == 'u')\n+      else if (!strcmp (name, \"undef\"))\n \t{\n-\t  if (getch () == 'n'\n-\t      && getch () == 'd'\n-\t      && getch () == 'e'\n-\t      && getch () == 'f'\n-\t      && ((c = getch ()) == ' ' || c == '\\t'))\n-\t    {\n-\t      debug_undef (lineno, GET_DIRECTIVE_LINE ());\n-\t      goto skipline;\n-\t    }\n+\t  debug_undef (lineno, GET_DIRECTIVE_LINE ());\n+\t  goto skipline;\n \t}\n-      else if (c == 'l')\n+      else if (!strcmp (name, \"line\"))\n \t{\n-\t  if (getch () == 'i'\n-\t      && getch () == 'n'\n-\t      && getch () == 'e'\n-\t      && ((c = getch ()) == ' ' || c == '\\t'))\n-\t    {\n-\t      saw_line = 1;\n-\t      goto linenum;\n-\t    }\n+\t  saw_line = 1;\n+\t  token = real_yylex ();\n+\t  goto linenum;\n \t}\n-      else if (c == 'i')\n+      else if (!strcmp (name, \"ident\"))\n \t{\n-\t  if (getch () == 'd'\n-\t      && getch () == 'e'\n-\t      && getch () == 'n'\n-\t      && getch () == 't'\n-\t      && ((c = getch ()) == ' ' || c == '\\t'))\n-\t    {\n-\t      /* #ident.  The pedantic warning is now in cccp.c.  */\n-\n-\t      /* Here we have just seen `#ident '.\n-\t\t A string constant should follow.  */\n-\n-\t      token = real_yylex ();\n-\t      if (token == END_OF_LINE)\n-\t\tgoto skipline;\n-\t      if (token != STRING\n-\t\t  || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t\t{\n-\t\t  error (\"invalid #ident\");\n-\t\t  goto skipline;\n-\t\t}\n+\t  /* #ident.  The pedantic warning is now in cccp.c.  */\n \n-\t      if (! flag_no_ident)\n-\t\t{\n-#ifdef ASM_OUTPUT_IDENT\n-\t\t  ASM_OUTPUT_IDENT (asm_out_file,\n-\t\t\t\t    TREE_STRING_POINTER (yylval.ttype));\n-#endif\n-\t\t}\n+\t  /* Here we have just seen `#ident '.\n+\t     A string constant should follow.  */\n \n-\t      /* Skip the rest of this line.  */\n+\t  token = real_yylex ();\n+\t  if (token == END_OF_LINE)\n+\t    goto skipline;\n+\t  if (token != STRING\n+\t      || TREE_CODE (yylval.ttype) != STRING_CST)\n+\t    {\n+\t      error (\"invalid #ident\");\n \t      goto skipline;\n \t    }\n-\t}\n-      else if (c == 'n')\n-\t{\n-\t  if (getch () == 'e'\n-\t      && getch () == 'w'\n-\t      && getch () == 'w'\n-\t      && getch () == 'o'\n-\t      && getch () == 'r'\n-\t      && getch () == 'l'\n-\t      && getch () == 'd'\n-\t      && ((c = getch ()) == ' ' || c == '\\t'))\n+\n+\t  if (! flag_no_ident)\n \t    {\n-\t      /* Used to test incremental compilation.  */\n-\t      sorry (\"#pragma newworld\");\n-\t      goto skipline;\n+#ifdef ASM_OUTPUT_IDENT\n+\t      ASM_OUTPUT_IDENT (asm_out_file,\n+\t\t\t\tTREE_STRING_POINTER (yylval.ttype));\n+#endif\n \t    }\n+\n+\t  /* Skip the rest of this line.  */\n+\t  goto skipline;\n \t}\n-      error (\"undefined or invalid # directive\");\n+\n+      error (\"undefined or invalid # directive `%s'\", name);\n       goto skipline;\n     }\n \n-linenum:\n-  /* Here we have either `#line' or `# <nonletter>'.\n-     In either case, it should be a line number; a digit should follow.  */\n-\n-  while (c == ' ' || c == '\\t')\n-    c = getch ();\n-\n   /* If the # is the only nonwhite char on the line,\n      just ignore it.  Check the new newline.  */\n-  if (c == EOF)\n+  if (token == END_OF_LINE)\n     goto skipline;\n \n-  /* Something follows the #; read a token.  */\n-\n-  put_back (c);\n-  token = real_yylex ();\n+linenum:\n+  /* Here we have either `#line' or `# <nonletter>'.\n+     In either case, it should be a line number; a digit should follow.  */\n \n-  if (token == CONSTANT\n-      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n+  if (token != CONSTANT\n+      || TREE_CODE (yylval.ttype) != INTEGER_CST)\n     {\n-      int old_lineno = lineno;\n-      enum { act_none, act_push, act_pop } action = act_none;\n-      int entering_system_header = 0;\n-      int entering_c_header = 0;\n+      error (\"invalid #-line\");\n+      goto skipline;\n+    }\n \n-      /* subtract one, because it is the following line that\n-\t gets the specified number */\n+  /* subtract one, because it is the following line that\n+     gets the specified number */\n \n-      int l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n-      c = get_last_nonwhite_on_line ();\n-      if (c == EOF)\n-\t{\n-\t  /* No more: store the line number and check following line.  */\n-\t  lineno = l;\n-\t  goto skipline;\n-\t}\n-      put_back (c);\n+  l = TREE_INT_CST_LOW (yylval.ttype) - 1;\n \n-      /* More follows: it must be a string constant (filename).  */\n+  /* More follows: it must be a string constant (filename).\n+     It would be neat to use cpplib to quickly process the string, but\n+     (1) we don't have a handy tokenization of the string, and\n+     (2) I don't know how well that would work in the presense\n+     of filenames that contain wide characters.  */\n \n-      if (saw_line)\n-\t{\n-\t  /* Don't treat \\ as special if we are processing #line 1 \"...\".\n-\t     If you want it to be treated specially, use # 1 \"...\".  */\n-\t  ignore_escape_flag = 1;\n-\t}\n+  if (saw_line)\n+    {\n+      /* Don't treat \\ as special if we are processing #line 1 \"...\".\n+\t If you want it to be treated specially, use # 1 \"...\".  */\n+      ignore_escape_flag = 1;\n+    }\n \n-      /* Read the string constant.  */\n-      token = real_yylex ();\n+  /* Read the string constant.  */\n+  token = real_yylex ();\n \n-      ignore_escape_flag = 0;\n+  ignore_escape_flag = 0;\n \n-      if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n-\t{\n-\t  error (\"invalid #line\");\n-\t  goto skipline;\n-\t}\n+  if (token == END_OF_LINE)\n+    {\n+      /* No more: store the line number and check following line.  */\n+      lineno = l;\n+      goto skipline;\n+    }\n \n-      /* Changing files again.  This means currently collected time\n-\t is charged against header time, and body time starts back\n-\t at 0.  */\n-      if (flag_detailed_statistics)\n-\t{\n-\t  int this_time = my_get_run_time ();\n-\t  tree time_identifier = get_time_identifier (TREE_STRING_POINTER (yylval.ttype));\n-\t  header_time += this_time - body_time;\n-\t  TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n-\t    += this_time - body_time;\n-\t  this_filename_time = time_identifier;\n-\t  body_time = this_time;\n-\t}\n+  if (token != STRING || TREE_CODE (yylval.ttype) != STRING_CST)\n+    {\n+      error (\"invalid #line\");\n+      goto skipline;\n+    }\n+\n+  /* Changing files again.  This means currently collected time\n+     is charged against header time, and body time starts back at 0.  */\n+  if (flag_detailed_statistics)\n+    {\n+      int this_time = my_get_run_time ();\n+      tree time_identifier = get_time_identifier (TREE_STRING_POINTER (yylval.ttype));\n+      header_time += this_time - body_time;\n+      TREE_INT_CST_LOW (TIME_IDENTIFIER_TIME (this_filename_time))\n+\t+= this_time - body_time;\n+      this_filename_time = time_identifier;\n+      body_time = this_time;\n+    }\n \n+  if (!TREE_PERMANENT (yylval.ttype))\n+    {\n       input_filename\n \t= (char *) permalloc (TREE_STRING_LENGTH (yylval.ttype) + 1);\n       strcpy (input_filename, TREE_STRING_POINTER (yylval.ttype));\n-      lineno = l;\n-      GNU_xref_file (input_filename);\n-      \n-      if (main_input_filename == 0)\n-\t{\n-\t  struct impl_files *ifiles = impl_file_chain;\n-\n-\t  if (ifiles)\n-\t    {\n-\t      while (ifiles->next)\n-\t\tifiles = ifiles->next;\n-\t      ifiles->filename = file_name_nondirectory (input_filename);\n-\t    }\n-\n-\t  main_input_filename = input_filename;\n-\t}\n+    }\n+  else\n+    input_filename = TREE_STRING_POINTER (yylval.ttype);\n \n-      extract_interface_info ();\n+  GNU_xref_file (input_filename);\n+      \n+  if (main_input_filename == 0)\n+    {\n+      struct impl_files *ifiles = impl_file_chain;\n \n-      c = get_last_nonwhite_on_line ();\n-      if (c == EOF)\n+      if (ifiles)\n \t{\n-\t  /* Update the name in the top element of input_file_stack.  */\n-\t  if (input_file_stack)\n-\t    input_file_stack->name = input_filename;\n+\t  while (ifiles->next)\n+\t    ifiles = ifiles->next;\n+\t  ifiles->filename = file_name_nondirectory (input_filename);\n \t}\n-      else\n-\t{\n-\t  put_back (c);\n \n-\t  token = real_yylex ();\n+      main_input_filename = input_filename;\n+    }\n \n-\t  /* `1' after file name means entering new file.\n-\t     `2' after file name means just left a file.  */\n+  extract_interface_info ();\n \n-\t  if (token == CONSTANT\n-\t      && TREE_CODE (yylval.ttype) == INTEGER_CST)\n-\t    {\n-\t      if (TREE_INT_CST_LOW (yylval.ttype) == 1)\n-\t\taction = act_push;\n-\t      else if (TREE_INT_CST_LOW (yylval.ttype) == 2)\n-\t\taction = act_pop;\n+  old_lineno = lineno;\n+  entering_system_header = 0;\n+  entering_c_header = 0;\n+  action = act_none;\n+  action_number = 0;\n+  lineno = l;\n \n-\t      if (action)\n-\t\t{\n-\t\t  c = get_last_nonwhite_on_line ();\n-\t\t  if (c != EOF)\n-\t\t    {\n-\t\t      put_back (c);\n-\t\t      token = real_yylex ();\n-\t\t    }\n-\t\t}\n-\t    }\n+  if (!read_line_number (&action_number))\n+    {\n+      /* Update the name in the top element of input_file_stack.  */\n+      if (input_file_stack)\n+\tinput_file_stack->name = input_filename;\n+    }\n \n-\t  /* `3' after file name means this is a system header file.  */\n+  /* `1' after file name means entering new file.\n+     `2' after file name means just left a file.  */\n \n-\t  if (token == CONSTANT\n-\t      && TREE_CODE (yylval.ttype) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (yylval.ttype) == 3)\n-\t    {\n-\t      entering_system_header = 1;\n+  if (action_number == 1)\n+    {\n+      action = act_push;\n+      read_line_number (&action_number);\n+    }\n+  else if (action_number == 2)\n+    {\n+      action = act_pop;\n+      read_line_number (&action_number);\n+    }\n+  if (action_number == 3)\n+    {\n+      /* `3' after file name means this is a system header file.  */\n+      entering_system_header = 1;\n+      read_line_number (&action_number);\n+    }\n+  if (action_number == 4)\n+    {\n+      /* `4' after file name means this is a C header file.  */\n+      entering_c_header = 1;\n+      read_line_number (&action_number);\n+    }\n \n-\t      c = get_last_nonwhite_on_line ();\n-\t      if (c != EOF)\n-\t\t{\n-\t\t  put_back (c);\n-\t\t  token = real_yylex ();\n-\t\t}\n-\t    }\n+  /* Do the actions implied by the preceding numbers.  */\n \n-\t  /* `4' after file name means this is a C header file.  */\n+  if (action == act_push)\n+    {\n+      /* Pushing to a new file.  */\n+      struct file_stack *p;\n+\n+      p = (struct file_stack *) xmalloc (sizeof (struct file_stack));\n+      input_file_stack->line = old_lineno;\n+      p->next = input_file_stack;\n+      p->name = input_filename;\n+      p->indent_level = indent_level;\n+      input_file_stack = p;\n+      input_file_stack_tick++;\n+      debug_start_source_file (input_filename);\n+      in_system_header = entering_system_header;\n+      if (c_header_level)\n+\t++c_header_level;\n+      else if (entering_c_header)\n+\t{\n+\t  c_header_level = 1;\n+\t  ++pending_lang_change;\n+\t}\n+    }\n+  else if (action == act_pop)\n+    {\n+      /* Popping out of a file.  */\n+      if (input_file_stack->next)\n+\t{\n+\t  struct file_stack *p;\n \n-\t  if (token == CONSTANT\n-\t      && TREE_CODE (yylval.ttype) == INTEGER_CST\n-\t      && TREE_INT_CST_LOW (yylval.ttype) == 4)\n+\t  if (c_header_level && --c_header_level == 0)\n \t    {\n-\t      entering_c_header = 1;\n-\n-\t      c = get_last_nonwhite_on_line ();\n-\t      if (c != EOF)\n-\t\t{\n-\t\t  put_back (c);\n-\t\t  token = real_yylex ();\n-\t\t}\n+\t      if (entering_c_header)\n+\t\twarning (\"badly nested C headers from preprocessor\");\n+\t      --pending_lang_change;\n \t    }\n+\t  in_system_header = entering_system_header;\n \n-\t  /* Do the actions implied by the preceding numbers.  */\n-\n-\t  if (action == act_push)\n-\t    {\n-\t      /* Pushing to a new file.  */\n-\t      struct file_stack *p;\n-\n-\t      p = (struct file_stack *) xmalloc (sizeof (struct file_stack));\n-\t      input_file_stack->line = old_lineno;\n-\t      p->next = input_file_stack;\n-\t      p->name = input_filename;\n-\t      input_file_stack = p;\n-\t      input_file_stack_tick++;\n-\t      debug_start_source_file (input_filename);\n-\t      in_system_header = entering_system_header;\n-\t      if (c_header_level)\n-\t\t++c_header_level;\n-\t      else if (entering_c_header)\n-\t\t{\n-\t\t  c_header_level = 1;\n-\t\t  ++pending_lang_change;\n-\t\t}\n-\t    }\n-\t  else if (action == act_pop)\n+\t  p = input_file_stack;\n+\t  if (indent_level != p->indent_level)\n \t    {\n-\t      /* Popping out of a file.  */\n-\t      if (input_file_stack->next)\n-\t\t{\n-\t\t  struct file_stack *p;\n-\n-\t\t  if (c_header_level && --c_header_level == 0)\n-\t\t    {\n-\t\t      if (entering_c_header)\n-\t\t\twarning (\"badly nested C headers from preprocessor\");\n-\t\t      --pending_lang_change;\n-\t\t    }\n-\t\t  in_system_header = entering_system_header;\n-\n-\t\t  p = input_file_stack;\n-\t\t  input_file_stack = p->next;\n-\t\t  free (p);\n-\t\t  input_file_stack_tick++;\n-\t\t  debug_end_source_file (input_file_stack->line);\n-\t\t}\n-\t      else\n-\t\terror (\"#-lines for entering and leaving files don't match\");\n+\t      warning_with_file_and_line\n+\t\t(p->name, old_lineno,\n+\t\t \"This file contains more `%c's than `%c's.\",\n+\t\t indent_level > p->indent_level ? '{' : '}',\n+\t\t indent_level > p->indent_level ? '}' : '{');\n \t    }\n-\t  else\n-\t    in_system_header = entering_system_header;\n+\t  input_file_stack = p->next;\n+\t  free (p);\n+\t  input_file_stack_tick++;\n+\t  debug_end_source_file (input_file_stack->line);\n \t}\n-\n-      /* If NEXTCHAR is not end of line, we don't care what it is.  */\n-      if (nextchar == EOF)\n-\tc = EOF;\n+      else\n+\terror (\"#-lines for entering and leaving files don't match\");\n     }\n   else\n-    error (\"invalid #-line\");\n+    in_system_header = entering_system_header;\n \n   /* skip the rest of this line.  */\n  skipline:\n   linemode = 0;\n   end_of_file = 0;\n-  nextchar = -1;\n+\n   while ((c = getch ()) != EOF && c != '\\n');\n   return c;\n }\n@@ -3312,6 +3194,40 @@ parse_float (data)\n     }\n }\n \n+/* Get the next character, staying within the current token if possible.\n+   If we're lexing a token, we don't want to look beyond the end of the\n+   token cpplib has prepared for us; otherwise, we end up reading in the\n+   next token, which screws up feed_input.  So just return a null\n+   character.  */\n+\n+inline int\n+token_getch ()\n+{\n+#if USE_CPPLIB\n+  if (yy_cur == yy_lim)\n+    return '\\0';\n+#endif\n+  return getch ();\n+}\n+\n+inline void\n+token_put_back (ch)\n+     int ch;\n+{\n+#if USE_CPPLIB\n+  if (ch == '\\0')\n+    return;\n+#endif\n+  put_back (ch);\n+}\n+\n+/* Read a single token from the input stream, and assign it lexical\n+   semantics.\n+\n+   Note: We used to do token pasting here, to produce compound tokens like\n+   LEFT_RIGHT and EXTERN_LANG_STRING.  That's now handled in spew.c, along\n+   with symbol table interaction and other context-sensitivity.  */\n+\n int\n real_yylex ()\n {\n@@ -3321,10 +3237,7 @@ real_yylex ()\n   int dollar_seen = 0;\n   int i;\n \n-  if (nextchar >= 0)\n-    c = nextchar, nextchar = -1;\n-  else\n-    c = getch ();\n+  c = getch ();\n \n   /* Effectively do c = skip_white_space (c)\n      but do it faster in the usual cases.  */\n@@ -3336,7 +3249,12 @@ real_yylex ()\n       case '\\f':\n       case '\\v':\n       case '\\b':\n-\tc = getch ();\n+#if USE_CPPLIB\n+\tif (cpp_token == CPP_HSPACE)\n+\t  c = yy_get_token ();\n+\telse\n+#endif\n+\t  c = getch ();\n \tbreak;\n \n       case '\\r':\n@@ -3378,9 +3296,13 @@ real_yylex ()\n       goto letter;\n \n     case 'L':\n+#if USE_CPPLIB\n+      if (cpp_token == CPP_NAME)\n+\tgoto letter;\n+#endif\n       /* Capital L may start a wide-string or wide-character constant.  */\n       {\n-\tregister int c = getch ();\n+\tregister int c = token_getch ();\n \tif (c == '\\'')\n \t  {\n \t    wide_flag = 1;\n@@ -3391,7 +3313,7 @@ real_yylex ()\n \t    wide_flag = 1;\n \t    goto string_constant;\n \t  }\n-\tput_back (c);\n+\ttoken_put_back (c);\n       }\n \n     case 'A':  case 'B':  case 'C':  case 'D':  case 'E':\n@@ -3411,48 +3333,25 @@ real_yylex ()\n       {\n \tregister char *p;\n \n-\tp = token_buffer;\n-\tif (input == 0)\n+#if USE_CPPLIB\n+\tif (cpp_token == CPP_NAME)\n \t  {\n-\t    /* We know that `token_buffer' can hold at least on char,\n-\t       so we install C immediately.\n-\t       We may have to read the value in `putback_char', so call\n-\t       `getch' once.  */\n-\t    *p++ = c;\n-\t    c = getch ();\n-\n-\t    /* Make this run fast.  We know that we are reading straight\n-\t       from FINPUT in this case (since identifiers cannot straddle\n-\t       input sources.  */\n-\t    while (ISALNUM (c) || (c == '_') || c == '$')\n-\t      {\n-\t\tif (c == '$')\n-\t\t  {\n-\t\t    if (! dollars_in_ident)\n-\t\t      error (\"`$' in identifier\");\n-\t\t    else if (pedantic)\n-\t\t      pedwarn (\"`$' in identifier\");\n-\t\t  }\n-\n-\t\tif (p >= token_buffer + maxtoken)\n-\t\t  p = extend_token_buffer (p);\n-\n-\t\t*p++ = c;\n-\t\tc = getch ();\n-\t      }\n-\n-\t    if (linemode && c == '\\n')\n-\t      {\n-\t\tput_back (c);\n-\t\tc = EOF;\n-\t      }\n+\t    /* Note that one character has already been read from\n+\t       yy_cur into token_buffer.  */\n+\n+\t    int len = yy_lim - yy_cur + 1;\n+\t    if (len >= maxtoken)\n+\t      extend_token_buffer_to (len + 1);\n+\t    memcpy (token_buffer + 1, yy_cur, len);\n+\t    p = token_buffer + len;\n+\t    yy_cur = yy_lim;\n \t  }\n \telse\n+#endif\n \t  {\n-\t    /* We know that `token_buffer' can hold at least on char,\n-\t       so we install C immediately.  */\n-\t    *p++ = c;\n-\t    c = getch ();\n+\t    /* We already installed C as the first char in token_buffer.  */\n+\t    p = token_buffer+1;\n+\t    c = token_getch ();\n \n \t    while (ISALNUM (c) || (c == '_') || c == '$')\n \t      {\n@@ -3468,17 +3367,17 @@ real_yylex ()\n \t\t  p = extend_token_buffer (p);\n \n \t\t*p++ = c;\n-\t\tc = getch ();\n+\t\tc = token_getch ();\n \t      }\n-\t  }\n \n-\t*p = 0;\n-\tnextchar = c;\n+\t    *p = 0;\n+\t    token_put_back (c);\n+\t  }\n \n \tvalue = IDENTIFIER;\n \tyylval.itype = 0;\n \n-      /* Try to recognize a keyword.  Uses minimum-perfect hash function */\n+\t/* Try to recognize a keyword.  Uses minimum-perfect hash function */\n \n \t{\n \t  register struct resword *ptr;\n@@ -3498,26 +3397,6 @@ real_yylex ()\n \t\t  else if (ptr->token == AGGR || ptr->token == ENUM)\n \t\t    looking_for_typename = 2;\n \n-\t\t  /* Check if this is a language-type declaration.\n-\t\t     Just glimpse the next non-white character.  */\n-\t\t  nextchar = skip_white_space (nextchar);\n-\t\t  if (nextchar == '\"')\n-\t\t    {\n-\t\t      /* We are looking at a string.  Complain\n-\t\t\t if the token before the string is no `extern'.\n-\t\t\t \n-\t\t\t Could cheat some memory by placing this string\n-\t\t\t on the temporary_, instead of the saveable_\n-\t\t\t obstack.  */\n-\n-\t\t      if (ptr->rid != RID_EXTERN)\n-\t\t\terror (\"invalid modifier `%s' for language string\",\n-\t\t\t       ptr->name);\n-\t\t      real_yylex ();\n-\t\t      value = EXTERN_LANG_STRING;\n-\t\t      yylval.ttype = get_identifier (TREE_STRING_POINTER (yylval.ttype));\n-\t\t      break;\n-\t\t    }\n \t\t  if (ptr->token == VISSPEC)\n \t\t    {\n \t\t      switch (ptr->rid)\n@@ -3538,15 +3417,16 @@ real_yylex ()\n \t\t  else\n \t\t    yylval.ttype = old_ttype;\n \t\t}\n-\t      else if (ptr->token == EQCOMPARE)\n+\t      else switch (ptr->token)\n \t\t{\n+\t\tcase EQCOMPARE:\n \t\t  yylval.code = NE_EXPR;\n \t\t  token_buffer[0] = '!';\n \t\t  token_buffer[1] = '=';\n \t\t  token_buffer[2] = 0;\n-\t\t}\n-\t      else if (ptr->token == ASSIGN)\n-\t\t{\n+\t\t  break;\n+\n+\t\tcase ASSIGN:\n \t\t  if (strcmp (\"and_eq\", token_buffer) == 0)\n \t\t    {\n \t\t      yylval.code = BIT_AND_EXPR;\n@@ -3564,24 +3444,25 @@ real_yylex ()\n \t\t    }\n \t\t  token_buffer[1] = '=';\n \t\t  token_buffer[2] = 0;\n-\t\t}\n-\t      else if (ptr->token == '&')\n-\t\t{\n+\t\t  break;\n+\n+\t\tcase '&':\n \t\t  yylval.code = BIT_AND_EXPR;\n \t\t  token_buffer[0] = '&';\n \t\t  token_buffer[1] = 0;\n-\t\t}\n-\t      else if (ptr->token == '|')\n-\t\t{\n+\t\t  break;\n+\n+\t\tcase '|':\n \t\t  yylval.code = BIT_IOR_EXPR;\n \t\t  token_buffer[0] = '|';\n \t\t  token_buffer[1] = 0;\n-\t\t}\n-\t      else if (ptr->token == '^')\n-\t\t{\n+\t\t  break;\n+\n+\t\tcase '^':\n \t\t  yylval.code = BIT_XOR_EXPR;\n \t\t  token_buffer[0] = '^';\n \t\t  token_buffer[1] = 0;\n+\t\t  break;\n \t\t}\n \n \t      value = (int) ptr->token;\n@@ -3622,61 +3503,72 @@ real_yylex ()\n \t    goto done;\n \t  }\n       }\n+\n       break;\n \n     case '.':\n-      {\n-\tregister int c1 = getch ();\n-\ttoken_buffer[0] = c;\n-\ttoken_buffer[1] = c1;\n-\tif (c1 == '*')\n-\t  {\n-\t    value = DOT_STAR;\n-\t    token_buffer[2] = 0;\n-\t    goto done;\n-\t  }\n-\tif (c1 == '.')\n-\t  {\n-\t    c1 = getch ();\n-\t    if (c1 == '.')\n-\t      {\n-\t\ttoken_buffer[2] = c1;\n-\t\ttoken_buffer[3] = 0;\n-\t\tvalue = ELLIPSIS;\n-\t\tgoto done;\n-\t      }\n-\t    error (\"parse error at `..'\");\n-\t  }\n-\tif (ISDIGIT (c1))\n-\t  {\n-\t    put_back (c1);\n-\t    goto resume_numerical_scan;\n-\t  }\n-\tnextchar = c1;\n-\tvalue = '.';\n-\ttoken_buffer[1] = 0;\n-\tgoto done;\n-      }\n+#if USE_CPPLIB\n+      if (yy_cur < yy_lim)\n+#endif\n+\t{\n+\t  /* It's hard to preserve tokenization on '.' because\n+\t     it could be a symbol by itself, or it could be the\n+\t     start of a floating point number and cpp won't tell us.  */\n+\t  register int c1 = token_getch ();\n+\t  token_buffer[1] = c1;\n+\t  if (c1 == '*')\n+\t    {\n+\t      value = DOT_STAR;\n+\t      token_buffer[2] = 0;\n+\t      goto done;\n+\t    }\n+\t  if (c1 == '.')\n+\t    {\n+\t      c1 = token_getch ();\n+\t      if (c1 == '.')\n+\t\t{\n+\t\t  token_buffer[2] = c1;\n+\t\t  token_buffer[3] = 0;\n+\t\t  value = ELLIPSIS;\n+\t\t  goto done;\n+\t\t}\n+\t      error (\"parse error at `..'\");\n+\t    }\n+\t  if (ISDIGIT (c1))\n+\t    {\n+\t      token_put_back (c1);\n+\t      goto resume_numerical_scan;\n+\t    }\n+\t  token_put_back (c1);\n+\t}\n+      value = '.';\n+      token_buffer[1] = 0;\n+      goto done;\n+\n     case '0':  case '1':\n-\t/* Optimize for most frequent case.  */\n+      /* Optimize for most frequent case.  */\n       {\n-\tregister int c1 = getch ();\n-\tif (! ISALNUM (c1) && c1 != '.')\n+\tregister int cond;\n+\n+#if USE_CPPLIB\n+\tcond = (yy_cur == yy_lim);\n+#else\n+\tregister int c1 = token_getch ();\n+\ttoken_put_back (c1);\n+\tcond = (! ISALNUM (c1) && c1 != '.');\n+#endif\n+\tif (cond)\n \t  {\n \t    /* Terminate string.  */\n-\t    token_buffer[0] = c;\n-\t    token_buffer[1] = 0;\n \t    if (c == '0')\n \t      yylval.ttype = integer_zero_node;\n \t    else\n \t      yylval.ttype = integer_one_node;\n-\t    nextchar = c1;\n \t    value = CONSTANT;\n \t    goto done;\n \t  }\n-\tput_back (c1);\n       }\n-      /* fall through...  */\n+    /* fall through...  */\n \t\t\t  case '2':  case '3':  case '4':\n     case '5':  case '6':  case '7':  case '8':  case '9':\n     resume_numerical_scan:\n@@ -3707,11 +3599,11 @@ real_yylex ()\n \n \tif (c == '0')\n \t  {\n-\t    *p++ = (c = getch ());\n+\t    *p++ = (c = token_getch ());\n \t    if ((c == 'x') || (c == 'X'))\n \t      {\n \t\tbase = 16;\n-\t\t*p++ = (c = getch ());\n+\t\t*p++ = (c = token_getch ());\n \t      }\n \t    /* Leading 0 forces octal unless the 0 is the only digit.  */\n \t    else if (c >= '0' && c <= '9')\n@@ -3750,30 +3642,11 @@ real_yylex ()\n \t\t  floatflag = AFTER_POINT;\n \n \t\tbase = 10;\n-\t\t*p++ = c = getch ();\n+\t\t*p++ = c = token_getch ();\n \t\t/* Accept '.' as the start of a floating-point number\n-\t\t   only when it is followed by a digit.\n-\t\t   Otherwise, unread the following non-digit\n-\t\t   and use the '.' as a structural token.  */\n+\t\t   only when it is followed by a digit.  */\n \t\tif (p == token_buffer + 2 && !ISDIGIT (c))\n-\t\t  {\n-\t\t    if (c == '.')\n-\t\t      {\n-\t\t\tc = getch ();\n-\t\t\tif (c == '.')\n-\t\t\t  {\n-\t\t\t    *p++ = '.';\n-\t\t\t    *p = '\\0';\n-\t\t\t    value = ELLIPSIS;\n-\t\t\t    goto done;\n-\t\t\t  }\n-\t\t\terror (\"parse error at `..'\");\n-\t\t      }\n-\t\t    nextchar = c;\n-\t\t    token_buffer[1] = '\\0';\n-\t\t    value = '.';\n-\t\t    goto done;\n-\t\t  }\n+\t\t  my_friendly_abort (990710);\n \t      }\n \t    else\n \t      {\n@@ -3828,17 +3701,18 @@ real_yylex ()\n \n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n-\t\t*p++ = (c = getch ());\n+\t\t*p++ = (c = token_getch ());\n \t      }\n \t  }\n \n \tif (numdigits == 0)\n-\t  error (\"numeric constant with no digits\");\n+\t  my_friendly_abort (990710);\n \n \tif (largest_digit >= base)\n \t  error (\"numeric constant contains digits beyond the radix\");\n \n-\t/* Remove terminating char from the token buffer and delimit the string */\n+\t/* Remove terminating char from the token buffer and delimit the\n+           string.  */\n \t*--p = 0;\n \n \tif (floatflag != NOT_FLOAT)\n@@ -3856,11 +3730,11 @@ real_yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = getch ();\n+\t\tc = token_getch ();\n \t\tif ((c == '+') || (c == '-'))\n \t\t  {\n \t\t    *p++ = c;\n-\t\t    c = getch ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t\tif (! ISDIGIT (c))\n \t\t  error (\"floating constant exponent has no digits\");\n@@ -3869,7 +3743,7 @@ real_yylex ()\n \t\t    if (p >= token_buffer + maxtoken - 3)\n \t\t      p = extend_token_buffer (p);\n \t\t    *p++ = c;\n-\t\t    c = getch ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t      }\n \n@@ -3973,7 +3847,7 @@ real_yylex ()\n \t\tif (p >= token_buffer + maxtoken - 3)\n \t\t  p = extend_token_buffer (p);\n \t\t*p++ = c;\n-\t\tc = getch ();\n+\t\tc = token_getch ();\n \t      }\n \n \t    /* If it won't fit in the host's representation for integers,\n@@ -4049,7 +3923,7 @@ real_yylex ()\n \t      TREE_TYPE (yylval.ttype) = type;\n \t  }\n \n-\tput_back (c);\n+\ttoken_put_back (c);\n \t*p = 0;\n \n \tvalue = CONSTANT; break;\n@@ -4065,7 +3939,7 @@ real_yylex ()\n \tint max_chars;\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n \n \tmax_chars = TYPE_PRECISION (integer_type_node) / width;\n@@ -4075,7 +3949,7 @@ real_yylex ()\n \twhile (1)\n \t  {\n \t  tryagain:\n-\t    c = getch ();\n+\t    c = token_getch ();\n \n \t    if (c == '\\'' || c == EOF)\n \t      break;\n@@ -4118,13 +3992,13 @@ real_yylex ()\n \t\t\t\t\t     i);\n \t\t    if (char_len != -1)\n \t\t      break;\n-\t\t    c = getch ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t\tif (char_len > 1)\n \t\t  {\n \t\t    /* mbtowc sometimes needs an extra char before accepting */\n \t\t    if (char_len < i)\n-\t\t      put_back (c);\n+\t\t      token_put_back (c);\n \t\t    if (! wide_flag)\n \t\t      {\n \t\t\t/* Merge character into result; ignore excess chars.  */\n@@ -4151,7 +4025,7 @@ real_yylex ()\n \t\t\twarning (\"Ignoring invalid multibyte character\");\n \t\t\t/* Replace all but the first byte.  */\n \t\t\tfor (--i; i > 1; --i)\n-\t\t\t  put_back (token_buffer[i]);\n+\t\t\t  token_put_back (token_buffer[i]);\n \t\t\twc = token_buffer[1];\n \t\t      }\n #ifdef MAP_CHARACTER\n@@ -4238,13 +4112,13 @@ real_yylex ()\n \t                           : TYPE_PRECISION (char_type_node);\n #ifdef MULTIBYTE_CHARS\n \tint longest_char = local_mb_cur_max ();\n-\t(void) local_mbtowc (NULL_PTR, NULL_PTR, 0);\n+\tlocal_mbtowc (NULL_PTR, NULL_PTR, 0);\n #endif\n \n-\tc = getch ();\n+\tc = token_getch ();\n \tp = token_buffer + 1;\n \n-\twhile (c != '\"' && c >= 0)\n+\twhile (c != '\"' && c != EOF)\n \t  {\n \t    /* ignore_escape_flag is set for reading the filename in #line.  */\n \t    if (!ignore_escape_flag && c == '\\\\')\n@@ -4278,24 +4152,24 @@ real_yylex ()\n \t\t    char_len = local_mbtowc (& wc, p, i + 1);\n \t\t    if (char_len != -1)\n \t\t      break;\n-\t\t    c = getch ();\n+\t\t    c = token_getch ();\n \t\t  }\n \t\tif (char_len == -1)\n \t\t  {\n \t\t    warning (\"Ignoring invalid multibyte character\");\n \t\t    /* Replace all except the first byte.  */\n-\t\t    put_back (c);\n+\t\t    token_put_back (c);\n \t\t    for (--i; i > 0; --i)\n-\t\t      put_back (p[i]);\n+\t\t      token_put_back (p[i]);\n \t\t    char_len = 1;\n \t\t  }\n \t\t/* mbtowc sometimes needs an extra char before accepting */\n \t\tif (char_len <= i)\n-\t\t  put_back (c);\n+\t\t  token_put_back (c);\n \t\tif (! wide_flag)\n \t\t  {\n \t\t    p += (i + 1);\n-\t\t    c = getch ();\n+\t\t    c = token_getch ();\n \t\t    continue;\n \t\t  }\n \t\tc = wc;\n@@ -4335,7 +4209,7 @@ real_yylex ()\n \t      }\n \n \t  skipnewline:\n-\t    c = getch ();\n+\t    c = token_getch ();\n \t    if (c == EOF) {\n \t\terror (\"Unterminated string\");\n \t\tbreak;\n@@ -4420,7 +4294,7 @@ real_yylex ()\n \t    yylval.code = GT_EXPR; break;\n \t  }\n \n-\ttoken_buffer[1] = c1 = getch ();\n+\ttoken_buffer[1] = c1 = token_getch ();\n \ttoken_buffer[2] = 0;\n \n \tif (c1 == '=')\n@@ -4458,21 +4332,21 @@ real_yylex ()\n \t    }\n \telse if ((c == '-') && (c1 == '>'))\n \t  {\n-\t    nextchar = getch ();\n-\t    if (nextchar == '*')\n+\t    c1 = token_getch ();\n+\t    if (c1 == '*')\n+\t      value = POINTSAT_STAR;\n+\t    else\n \t      {\n-\t\tnextchar = -1;\n-\t\tvalue = POINTSAT_STAR;\n+\t\ttoken_put_back (c1);\n+\t\tvalue = POINTSAT;\n \t      }\n-\t    else\n-\t      value = POINTSAT;\n \t    goto done;\n \t  }\n \telse if (c1 == '?' && (c == '<' || c == '>'))\n \t  {\n \t    token_buffer[3] = 0;\n \n-\t    c1 = getch ();\n+\t    c1 = token_getch ();\n \t    yylval.code = (c == '<' ? MIN_EXPR : MAX_EXPR);\n \t    if (c1 == '=')\n \t      {\n@@ -4483,7 +4357,7 @@ real_yylex ()\n \t    else\n \t      {\n \t\tvalue = MIN_MAX;\n-\t\tnextchar = c1;\n+\t\ttoken_put_back (c1);\n \t      }\n \t    if (pedantic)\n \t      pedwarn (\"use of `operator %s' is not standard C++\",\n@@ -4500,15 +4374,15 @@ real_yylex ()\n \telse if (c == '%' && c1 == ':')\n \t  { value = '#'; goto done; }\n \n-\tnextchar = c1;\n+\ttoken_put_back (c1);\n \ttoken_buffer[1] = 0;\n \n \tvalue = c;\n \tgoto done;\n       }\n \n     case ':':\n-      c = getch ();\n+      c = token_getch ();\n       if (c == ':')\n \t{\n \t  token_buffer[1] = ':';\n@@ -4523,7 +4397,7 @@ real_yylex ()\n \t}\n       else\n \t{\n-\t  nextchar = c;\n+\t  token_put_back (c);\n \t  value = ':';\n \t}\n       break;\n@@ -4533,33 +4407,6 @@ real_yylex ()\n       value = 1;\n       break;\n \n-    case '(':\n-      /* try, weakly, to handle casts to pointers to functions.  */\n-      nextchar = skip_white_space (getch ());\n-      if (nextchar == '*')\n-\t{\n-\t  int next_c = skip_white_space (getch ());\n-\t  if (next_c == ')')\n-\t    {\n-\t      nextchar = -1;\n-\t      yylval.ttype = build1 (INDIRECT_REF, 0, 0);\n-\t      value = PAREN_STAR_PAREN;\n-\t    }\n-\t  else\n-\t    {\n-\t      put_back (next_c);\n-\t      value = c;\n-\t    }\n-\t}\n-      else if (nextchar == ')')\n-\t{\n-\t  nextchar = -1;\n-\t  yylval.ttype = NULL_TREE;\n-\t  value = LEFT_RIGHT;\n-\t}\n-      else value = c;\n-      break;\n-\n     default:\n       value = c;\n     }"}, {"sha": "5d99e18e927e3361ce9d8f67f32e04b53137a6c6", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3469, "deletions": 3461, "changes": 6930, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=66a6250faad336d0adda2b0b7ed412d634d1880f"}, {"sha": "480190bb3f0352f971725cb8a22868435d88e63c", "filename": "gcc/cp/parse.h", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.h?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -69,21 +69,20 @@ typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagg\n #define\tPLUSPLUS\t325\n #define\tMINUSMINUS\t326\n #define\tHYPERUNARY\t327\n-#define\tPAREN_STAR_PAREN\t328\n-#define\tPOINTSAT\t329\n-#define\tTRY\t330\n-#define\tCATCH\t331\n-#define\tPRE_PARSED_FUNCTION_DECL\t332\n-#define\tEXTERN_LANG_STRING\t333\n-#define\tALL\t334\n-#define\tPRE_PARSED_CLASS_DECL\t335\n-#define\tDEFARG\t336\n-#define\tDEFARG_MARKER\t337\n-#define\tTYPENAME_DEFN\t338\n-#define\tIDENTIFIER_DEFN\t339\n-#define\tPTYPENAME_DEFN\t340\n-#define\tEND_OF_LINE\t341\n-#define\tEND_OF_SAVED_INPUT\t342\n+#define\tPOINTSAT\t328\n+#define\tTRY\t329\n+#define\tCATCH\t330\n+#define\tPRE_PARSED_FUNCTION_DECL\t331\n+#define\tEXTERN_LANG_STRING\t332\n+#define\tALL\t333\n+#define\tPRE_PARSED_CLASS_DECL\t334\n+#define\tDEFARG\t335\n+#define\tDEFARG_MARKER\t336\n+#define\tTYPENAME_DEFN\t337\n+#define\tIDENTIFIER_DEFN\t338\n+#define\tPTYPENAME_DEFN\t339\n+#define\tEND_OF_LINE\t340\n+#define\tEND_OF_SAVED_INPUT\t341\n \n \n extern YYSTYPE yylval;"}, {"sha": "165d5c9eac190f4bb73868395326f9bb4de9ecae", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -178,7 +178,7 @@ empty_parms ()\n %left <code> POINTSAT_STAR DOT_STAR\n %right <code> UNARY PLUSPLUS MINUSMINUS '~'\n %left HYPERUNARY\n-%left <ttype> PAREN_STAR_PAREN LEFT_RIGHT\n+%left <ttype> LEFT_RIGHT\n %left <code> POINTSAT '.' '(' '['\n \n %right SCOPE\t\t\t/* C++ extension */\n@@ -3174,7 +3174,6 @@ direct_abstract_declarator:\n \t  '(' absdcl_intern ')'\n \t\t{ $$ = $2; }\n \t  /* `(typedef)1' is `int'.  */\n-\t| PAREN_STAR_PAREN\n \t| direct_abstract_declarator '(' parmlist ')' cv_qualifiers exception_specification_opt  %prec '.'\n \t\t{ $$ = make_call_declarator ($$, $3, $5, $6); }\n \t| direct_abstract_declarator LEFT_RIGHT cv_qualifiers exception_specification_opt  %prec '.'"}, {"sha": "6e7d06e9e1dd70ae163f45f7fd7a42ad17567869", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66a6250faad336d0adda2b0b7ed412d634d1880f/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=66a6250faad336d0adda2b0b7ed412d634d1880f", "patch": "@@ -1,5 +1,5 @@\n /* Type Analyzer for GNU C++.\n-   Copyright (C) 1987, 89, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-97, 1998, 1999 Free Software Foundation, Inc.\n    Hacked... nay, bludgeoned... by Mark Eichin (eichin@cygnus.com)\n \n This file is part of GNU CC.\n@@ -305,6 +305,16 @@ yylex ()\n #endif\n       goto retry;\n \n+    case '(':\n+      scan_tokens (1);\n+      if (nth_token (1)->yychar == ')')\n+\t{\n+\t  consume_token ();\n+\t  tmp_token.yychar = LEFT_RIGHT;\n+\t}\n+      consume_token ();\n+      break;\n+\n     case IDENTIFIER:\n       scan_tokens (1);\n       if (nth_token (1)->yychar == SCOPE)\n@@ -361,21 +371,31 @@ yylex ()\n       break;\n \n     case SCSPEC:\n+      if (tmp_token.yylval.ttype == ridpointers[RID_EXTERN])\n+\t{\n+\t  scan_tokens (1);\n+\t  if (nth_token (1)->yychar == STRING)\n+\t    {\n+\t      tmp_token.yychar = EXTERN_LANG_STRING;\n+\t      tmp_token.yylval.ttype = get_identifier\n+\t\t(TREE_STRING_POINTER (nth_token (1)->yylval.ttype));\n+\t      consume_token ();\n+\t    }\n+\t}\n       /* If export, warn that it's unimplemented and go on. */\n-      if (tmp_token.yylval.ttype == get_identifier(\"export\"))\n+      else if (tmp_token.yylval.ttype == ridpointers[RID_EXPORT])\n \t{\n \t  warning (\"keyword 'export' not implemented and will be ignored\");\n \t  consume_token ();\n \t  goto retry;\n \t}\n-      else\n-\t{\n-\t  ++first_token;\n-\t  break;\n-\t}\n+      /* do_aggr needs to check if the previous token was `friend',\n+\t so just increment first_token instead of calling consume_token.  */\n+      ++first_token;\n+      break;\n \n     case NEW:\n-      /* do_aggr needs to check if the previous token was RID_NEW,\n+      /* do_aggr needs to check if the previous token was `new',\n \t so just increment first_token instead of calling consume_token.  */\n       ++first_token;\n       break;"}]}