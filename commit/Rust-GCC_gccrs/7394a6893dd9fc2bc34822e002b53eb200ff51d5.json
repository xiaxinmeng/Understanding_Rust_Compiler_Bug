{"sha": "7394a6893dd9fc2bc34822e002b53eb200ff51d5", "node_id": "C_kwDOANBUbNoAKDczOTRhNjg5M2RkOWZjMmJjMzQ4MjJlMDAyYjUzZWIyMDBmZjUxZDU", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2023-03-01T10:03:24Z"}, "committer": {"name": "CohenArthur", "email": "arthur.cohen@embecosm.com", "date": "2023-03-01T16:22:16Z"}, "message": "hir: Refactor ASTLoweringStmt to source file.\n\ngcc/rust/ChangeLog:\n\n\t* Make-lang.in: Add rust-ast-lower-stmt.o\n\t* hir/rust-ast-lower-stmt.h: Move definitions to...\n\t* hir/rust-ast-lower-stmt.cc: ...here.", "tree": {"sha": "839f8e4eb36d883969e2462719eaefefe43ac89b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/839f8e4eb36d883969e2462719eaefefe43ac89b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7394a6893dd9fc2bc34822e002b53eb200ff51d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7394a6893dd9fc2bc34822e002b53eb200ff51d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7394a6893dd9fc2bc34822e002b53eb200ff51d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7394a6893dd9fc2bc34822e002b53eb200ff51d5/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c46a853be4b5a9c2e1b965fa0dcd44beed71924", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c46a853be4b5a9c2e1b965fa0dcd44beed71924", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c46a853be4b5a9c2e1b965fa0dcd44beed71924"}], "stats": {"total": 782, "additions": 414, "deletions": 368}, "files": [{"sha": "c7210890fd664181b67b21619242f62ba0858a5f", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=7394a6893dd9fc2bc34822e002b53eb200ff51d5", "patch": "@@ -96,6 +96,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-item.o \\\n     rust/rust-ast-lower-expr.o \\\n     rust/rust-ast-lower-type.o \\\n+\trust/rust-ast-lower-stmt.o \\\n     rust/rust-early-name-resolver.o \\\n     rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\"}, {"sha": "3d94259ac5aa124187e23a50a4479136b8241740", "filename": "gcc/rust/hir/rust-ast-lower-stmt.cc", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.cc?ref=7394a6893dd9fc2bc34822e002b53eb200ff51d5", "patch": "@@ -0,0 +1,400 @@\n+// Copyright (C) 2020-2023 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-stmt.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+HIR::Stmt *\n+ASTLoweringStmt::translate (AST::Stmt *stmt, bool *terminated)\n+{\n+  ASTLoweringStmt resolver;\n+  stmt->accept_vis (resolver);\n+\n+  rust_assert (resolver.translated != nullptr);\n+  *terminated = resolver.terminated;\n+  resolver.mappings->insert_location (\n+    resolver.translated->get_mappings ().get_hirid (),\n+    resolver.translated->get_locus ());\n+  resolver.mappings->insert_hir_stmt (resolver.translated);\n+  if (resolver.translated->is_item ())\n+    {\n+      HIR::Item *i = static_cast<HIR::Item *> (resolver.translated);\n+\n+      auto defid = resolver.translated->get_mappings ().get_defid ();\n+\n+      resolver.handle_outer_attributes (*i);\n+      resolver.mappings->insert_hir_item (i);\n+      resolver.mappings->insert_defid_mapping (defid, i);\n+    }\n+\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::ExprStmtWithBlock &stmt)\n+{\n+  HIR::ExprWithBlock *expr\n+    = ASTLoweringExprWithBlock::translate (stmt.get_expr ().get (),\n+\t\t\t\t\t   &terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::ExprStmtWithBlock (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::ExprWithBlock> (expr),\n+\t\t\t\t  stmt.get_locus (),\n+\t\t\t\t  !stmt.is_semicolon_followed ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::ExprStmtWithoutBlock &stmt)\n+{\n+  HIR::Expr *expr\n+    = ASTLoweringExpr::translate (stmt.get_expr ().get (), &terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::ExprStmtWithoutBlock (mapping, std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t     stmt.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::ConstantItem &constant)\n+{\n+  HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n+\n+  HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+  HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::ConstantItem (mapping, constant.get_identifier (), vis,\n+\t\t\t\t      std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t      constant.get_outer_attrs (),\n+\t\t\t\t      constant.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::LetStmt &stmt)\n+{\n+  HIR::Pattern *variables\n+    = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n+  HIR::Type *type = stmt.has_type ()\n+\t\t      ? ASTLoweringType::translate (stmt.get_type ().get ())\n+\t\t      : nullptr;\n+  HIR::Expr *init_expression\n+    = stmt.has_init_expr ()\n+\t? ASTLoweringExpr::translate (stmt.get_init_expr ().get ())\n+\t: nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::LetStmt (mapping, std::unique_ptr<HIR::Pattern> (variables),\n+\t\t\tstd::unique_ptr<HIR::Expr> (init_expression),\n+\t\t\tstd::unique_ptr<HIR::Type> (type),\n+\t\t\tstmt.get_outer_attrs (), stmt.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::TupleStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  std::vector<HIR::TupleField> fields;\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::TupleField translated_field (mapping,\n+\t\t\t\t\tstd::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\tfield.get_locus (),\n+\t\t\t\t\tfield.get_outer_attrs ());\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t     struct_decl.get_identifier (),\n+\t\t\t\t     std::move (generic_params),\n+\t\t\t\t     std::move (where_clause), vis,\n+\t\t\t\t     struct_decl.get_outer_attrs (),\n+\t\t\t\t     struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::StructStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  bool is_unit = struct_decl.is_unit_struct ();\n+  std::vector<HIR::StructField> fields;\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\t field.get_locus (),\n+\t\t\t\t\t field.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (fields, translated_field))\n+\tbreak;\n+\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t      struct_decl.get_identifier (),\n+\t\t\t\t      std::move (generic_params),\n+\t\t\t\t      std::move (where_clause), is_unit, vis,\n+\t\t\t\t      struct_decl.get_outer_attrs (),\n+\t\t\t\t      struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::Union &union_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (union_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (union_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n+\n+  std::vector<HIR::StructField> variants;\n+  for (AST::StructField &variant : union_decl.get_variants ())\n+    {\n+      HIR::Visibility vis = translate_visibility (variant.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, variant.get_locus (),\n+\t\t\t\t\t   variant.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (variants, translated_variant))\n+\tbreak;\n+\n+      variants.push_back (std::move (translated_variant));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t      std::move (generic_params), std::move (where_clause),\n+\t\t      std::move (variants), union_decl.get_outer_attrs (),\n+\t\t      union_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::Enum &enum_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (enum_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (enum_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n+\n+  // bool is_unit = enum_decl.is_zero_variant ();\n+  std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      HIR::EnumItem *hir_item = ASTLoweringEnumItem::translate (variant.get ());\n+      items.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t      std::move (generic_params),\n+\t\t\t      std::move (where_clause), /* is_unit, */\n+\t\t\t      std::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t      enum_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::EmptyStmt &empty)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, empty.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::EmptyStmt (mapping, empty.get_locus ());\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::Function &function)\n+{\n+  // ignore for now and leave empty\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::FunctionQualifiers qualifiers\n+    = lower_qualifiers (function.get_qualifiers ());\n+  HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+  // need\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (function.has_generics ())\n+    {\n+      generic_params = lower_generic_params (function.get_generic_params ());\n+    }\n+\n+  Identifier function_name = function.get_function_name ();\n+  Location locus = function.get_locus ();\n+\n+  std::unique_ptr<HIR::Type> return_type\n+    = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+  std::vector<HIR::FunctionParam> function_params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      auto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\tASTLoweringPattern::translate (param.get_pattern ().get ()));\n+      auto translated_type = std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (param.get_type ().get ()));\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      auto hir_param\n+\t= HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t      std::move (translated_type), param.get_locus ());\n+      function_params.push_back (hir_param);\n+    }\n+\n+  bool terminated = false;\n+  std::unique_ptr<HIR::BlockExpr> function_body\n+    = std::unique_ptr<HIR::BlockExpr> (\n+      ASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t   &terminated));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  mappings->insert_location (function_body->get_mappings ().get_hirid (),\n+\t\t\t     function.get_locus ());\n+\n+  auto fn\n+    = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t std::move (qualifiers), std::move (generic_params),\n+\t\t\t std::move (function_params), std::move (return_type),\n+\t\t\t std::move (where_clause), std::move (function_body),\n+\t\t\t std::move (vis), function.get_outer_attrs (),\n+\t\t\t HIR::SelfParam::error (), locus);\n+\n+  // add the mappings for the function params at the end\n+  for (auto &param : fn->get_function_params ())\n+    {\n+      mappings->insert_hir_param (&param);\n+      mappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+    }\n+\n+  translated = fn;\n+}\n+\n+void\n+ASTLoweringStmt::visit (AST::ExternBlock &extern_block)\n+{\n+  translated = lower_extern_block (extern_block);\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "de4725be177a79f9321f9d7a0ab139830c1e9b30", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "modified", "additions": 13, "deletions": 368, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7394a6893dd9fc2bc34822e002b53eb200ff51d5/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=7394a6893dd9fc2bc34822e002b53eb200ff51d5", "patch": "@@ -36,374 +36,19 @@ class ASTLoweringStmt : public ASTLoweringBase\n   using Rust::HIR::ASTLoweringBase::visit;\n \n public:\n-  static HIR::Stmt *translate (AST::Stmt *stmt, bool *terminated)\n-  {\n-    ASTLoweringStmt resolver;\n-    stmt->accept_vis (resolver);\n-\n-    rust_assert (resolver.translated != nullptr);\n-    *terminated = resolver.terminated;\n-    resolver.mappings->insert_location (\n-      resolver.translated->get_mappings ().get_hirid (),\n-      resolver.translated->get_locus ());\n-    resolver.mappings->insert_hir_stmt (resolver.translated);\n-    if (resolver.translated->is_item ())\n-      {\n-\tHIR::Item *i = static_cast<HIR::Item *> (resolver.translated);\n-\n-\tauto defid = resolver.translated->get_mappings ().get_defid ();\n-\n-\tresolver.handle_outer_attributes (*i);\n-\tresolver.mappings->insert_hir_item (i);\n-\tresolver.mappings->insert_defid_mapping (defid, i);\n-      }\n-\n-    return resolver.translated;\n-  }\n-\n-  void visit (AST::ExprStmtWithBlock &stmt) override\n-  {\n-    HIR::ExprWithBlock *expr\n-      = ASTLoweringExprWithBlock::translate (stmt.get_expr ().get (),\n-\t\t\t\t\t     &terminated);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    translated\n-      = new HIR::ExprStmtWithBlock (mapping,\n-\t\t\t\t    std::unique_ptr<HIR::ExprWithBlock> (expr),\n-\t\t\t\t    stmt.get_locus (),\n-\t\t\t\t    !stmt.is_semicolon_followed ());\n-  }\n-\n-  void visit (AST::ExprStmtWithoutBlock &stmt) override\n-  {\n-    HIR::Expr *expr\n-      = ASTLoweringExpr::translate (stmt.get_expr ().get (), &terminated);\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    translated\n-      = new HIR::ExprStmtWithoutBlock (mapping,\n-\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n-\t\t\t\t       stmt.get_locus ());\n-  }\n-\n-  void visit (AST::ConstantItem &constant) override\n-  {\n-    HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n-\n-    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n-    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n-\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n-\t\t\t\t\tconstant.get_outer_attrs (),\n-\t\t\t\t\tconstant.get_locus ());\n-  }\n-\n-  void visit (AST::LetStmt &stmt) override\n-  {\n-    HIR::Pattern *variables\n-      = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n-    HIR::Type *type = stmt.has_type ()\n-\t\t\t? ASTLoweringType::translate (stmt.get_type ().get ())\n-\t\t\t: nullptr;\n-    HIR::Expr *init_expression\n-      = stmt.has_init_expr ()\n-\t  ? ASTLoweringExpr::translate (stmt.get_init_expr ().get ())\n-\t  : nullptr;\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    translated\n-      = new HIR::LetStmt (mapping, std::unique_ptr<HIR::Pattern> (variables),\n-\t\t\t  std::unique_ptr<HIR::Expr> (init_expression),\n-\t\t\t  std::unique_ptr<HIR::Type> (type),\n-\t\t\t  stmt.get_outer_attrs (), stmt.get_locus ());\n-  }\n-\n-  void visit (AST::TupleStruct &struct_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (struct_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (struct_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n-\n-    std::vector<HIR::TupleField> fields;\n-    for (AST::TupleField &field : struct_decl.get_fields ())\n-      {\n-\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::TupleField translated_field (mapping,\n-\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t  vis, field.get_locus (),\n-\t\t\t\t\t  field.get_outer_attrs ());\n-\tfields.push_back (std::move (translated_field));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::TupleStruct (mapping, std::move (fields),\n-\t\t\t\t       struct_decl.get_identifier (),\n-\t\t\t\t       std::move (generic_params),\n-\t\t\t\t       std::move (where_clause), vis,\n-\t\t\t\t       struct_decl.get_outer_attrs (),\n-\t\t\t\t       struct_decl.get_locus ());\n-  }\n-\n-  void visit (AST::StructStruct &struct_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (struct_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (struct_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n-\n-    bool is_unit = struct_decl.is_unit_struct ();\n-    std::vector<HIR::StructField> fields;\n-    for (AST::StructField &field : struct_decl.get_fields ())\n-      {\n-\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::StructField translated_field (mapping, field.get_field_name (),\n-\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t   vis, field.get_locus (),\n-\t\t\t\t\t   field.get_outer_attrs ());\n-\n-\tif (struct_field_name_exists (fields, translated_field))\n-\t  break;\n-\n-\tfields.push_back (std::move (translated_field));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::StructStruct (mapping, std::move (fields),\n-\t\t\t\t\tstruct_decl.get_identifier (),\n-\t\t\t\t\tstd::move (generic_params),\n-\t\t\t\t\tstd::move (where_clause), is_unit, vis,\n-\t\t\t\t\tstruct_decl.get_outer_attrs (),\n-\t\t\t\t\tstruct_decl.get_locus ());\n-  }\n-\n-  void visit (AST::Union &union_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (union_decl.has_generics ())\n-      {\n-\tgeneric_params\n-\t  = lower_generic_params (union_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n-\n-    std::vector<HIR::StructField> variants;\n-    for (AST::StructField &variant : union_decl.get_variants ())\n-      {\n-\tHIR::Visibility vis = translate_visibility (variant.get_visibility ());\n-\tHIR::Type *type\n-\t  = ASTLoweringType::translate (variant.get_field_type ().get ());\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       mappings->get_next_localdef_id (\n-\t\t\t\t\t crate_num));\n-\n-\tHIR::StructField translated_variant (mapping, variant.get_field_name (),\n-\t\t\t\t\t     std::unique_ptr<HIR::Type> (type),\n-\t\t\t\t\t     vis, variant.get_locus (),\n-\t\t\t\t\t     variant.get_outer_attrs ());\n-\n-\tif (struct_field_name_exists (variants, translated_variant))\n-\t  break;\n-\n-\tvariants.push_back (std::move (translated_variant));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated\n-      = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n-\t\t\tstd::move (generic_params), std::move (where_clause),\n-\t\t\tstd::move (variants), union_decl.get_outer_attrs (),\n-\t\t\tunion_decl.get_locus ());\n-  }\n-\n-  void visit (AST::Enum &enum_decl) override\n-  {\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (enum_decl.has_generics ())\n-      {\n-\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n-      }\n-\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n-\n-    // bool is_unit = enum_decl.is_zero_variant ();\n-    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n-    for (auto &variant : enum_decl.get_variants ())\n-      {\n-\tHIR::EnumItem *hir_item\n-\t  = ASTLoweringEnumItem::translate (variant.get ());\n-\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n-      }\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n-\t\t\t\tstd::move (generic_params),\n-\t\t\t\tstd::move (where_clause), /* is_unit, */\n-\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n-\t\t\t\tenum_decl.get_locus ());\n-  }\n-\n-  void visit (AST::EmptyStmt &empty) override\n-  {\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, empty.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    translated = new HIR::EmptyStmt (mapping, empty.get_locus ());\n-  }\n-\n-  void visit (AST::Function &function) override\n-  {\n-    // ignore for now and leave empty\n-    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-    HIR::WhereClause where_clause (std::move (where_clause_items));\n-    HIR::FunctionQualifiers qualifiers\n-      = lower_qualifiers (function.get_qualifiers ());\n-    HIR::Visibility vis = translate_visibility (function.get_visibility ());\n-\n-    // need\n-    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n-    if (function.has_generics ())\n-      {\n-\tgeneric_params = lower_generic_params (function.get_generic_params ());\n-      }\n-\n-    Identifier function_name = function.get_function_name ();\n-    Location locus = function.get_locus ();\n-\n-    std::unique_ptr<HIR::Type> return_type\n-      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n-\t\t\t\t    : nullptr;\n-\n-    std::vector<HIR::FunctionParam> function_params;\n-    for (auto &param : function.get_function_params ())\n-      {\n-\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n-\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n-\tauto translated_type = std::unique_ptr<HIR::Type> (\n-\t  ASTLoweringType::translate (param.get_type ().get ()));\n-\n-\tauto crate_num = mappings->get_current_crate ();\n-\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n-\t\t\t\t       mappings->get_next_hir_id (crate_num),\n-\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n-\n-\tauto hir_param\n-\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n-\t\t\t\tstd::move (translated_type),\n-\t\t\t\tparam.get_locus ());\n-\tfunction_params.push_back (hir_param);\n-      }\n-\n-    bool terminated = false;\n-    std::unique_ptr<HIR::BlockExpr> function_body\n-      = std::unique_ptr<HIR::BlockExpr> (\n-\tASTLoweringBlock::translate (function.get_definition ().get (),\n-\t\t\t\t     &terminated));\n-\n-    auto crate_num = mappings->get_current_crate ();\n-    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n-\t\t\t\t   mappings->get_next_hir_id (crate_num),\n-\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n-\n-    mappings->insert_location (function_body->get_mappings ().get_hirid (),\n-\t\t\t       function.get_locus ());\n-\n-    auto fn\n-      = new HIR::Function (mapping, std::move (function_name),\n-\t\t\t   std::move (qualifiers), std::move (generic_params),\n-\t\t\t   std::move (function_params), std::move (return_type),\n-\t\t\t   std::move (where_clause), std::move (function_body),\n-\t\t\t   std::move (vis), function.get_outer_attrs (),\n-\t\t\t   HIR::SelfParam::error (), locus);\n-\n-    // add the mappings for the function params at the end\n-    for (auto &param : fn->get_function_params ())\n-      {\n-\tmappings->insert_hir_param (&param);\n-\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n-      }\n-\n-    translated = fn;\n-  }\n-\n-  void visit (AST::ExternBlock &extern_block) override\n-  {\n-    translated = lower_extern_block (extern_block);\n-  }\n+  static HIR::Stmt *translate (AST::Stmt *stmt, bool *terminated);\n+\n+  void visit (AST::ExprStmtWithBlock &stmt) override;\n+  void visit (AST::ExprStmtWithoutBlock &stmt) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::LetStmt &stmt) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n+  void visit (AST::EmptyStmt &empty) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n \n private:\n   ASTLoweringStmt () : translated (nullptr), terminated (false) {}"}]}