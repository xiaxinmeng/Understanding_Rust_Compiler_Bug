{"sha": "37244b217a7329792f4ec48027f63cf5010b0ea8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcyNDRiMjE3YTczMjk3OTJmNGVjNDgwMjdmNjNjZjUwMTBiMGVhOA==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-02T16:59:34Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-04T16:14:01Z"}, "message": "c++: Fix constexpr evaluation of self-modifying CONSTRUCTORs [PR94219]\n\nThis PR reveals that cxx_eval_bare_aggregate and cxx_eval_store_expression do\nnot anticipate that a constructor element's initializer could mutate the\nunderlying CONSTRUCTOR.  Evaluation of the initializer could add new elements to\nthe underlying CONSTRUCTOR, thereby potentially invalidating any pointers to\nor assumptions about the CONSTRUCTOR's elements, and so these routines should be\nprepared for that.\n\nTo fix this problem, this patch makes cxx_eval_bare_aggregate and\ncxx_eval_store_expression recompute the constructor_elt pointers through which\nwe're assigning, after it evaluates the initializer.  Care is taken to to not\nslow down the common case where the initializer does not modify the underlying\nCONSTRUCTOR.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94219\n\tPR c++/94205\n\t* constexpr.c (get_or_insert_ctor_field): Split out (while adding\n\tsupport for VECTOR_TYPEs, and optimizations for the common case)\n\tfrom ...\n\t(cxx_eval_store_expression): ... here.  Rename local variable\n\t'changed_active_union_member_p' to 'activated_union_member_p'.  Record\n\tthe sequence of indexes into 'indexes' that yields the subobject we're\n\tassigning to.  Record the integer offsets of the constructor indexes\n\twe're assigning through into 'index_pos_hints'.  After evaluating the\n\tinitializer of the store expression, recompute 'valp' using 'indexes'\n\tand using 'index_pos_hints' as hints.\n\t(cxx_eval_bare_aggregate): Tweak comments.  Use get_or_insert_ctor_field\n\tto recompute the constructor_elt pointer we're assigning through after\n\tevaluating each initializer.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94219\n\tPR c++/94205\n\t* g++.dg/cpp1y/constexpr-nsdmi3.C: New test.\n\t* g++.dg/cpp1y/constexpr-nsdmi4.C: New test.\n\t* g++.dg/cpp1y/constexpr-nsdmi5.C: New test.\n\t* g++.dg/cpp1z/lambda-this5.C: New test.", "tree": {"sha": "eb03091b936247375f2f0e00fe783f5de441dd39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb03091b936247375f2f0e00fe783f5de441dd39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/37244b217a7329792f4ec48027f63cf5010b0ea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37244b217a7329792f4ec48027f63cf5010b0ea8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37244b217a7329792f4ec48027f63cf5010b0ea8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37244b217a7329792f4ec48027f63cf5010b0ea8/comments", "author": null, "committer": null, "parents": [{"sha": "21e28527130a89491f848dfb5019afa01b252479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21e28527130a89491f848dfb5019afa01b252479", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21e28527130a89491f848dfb5019afa01b252479"}], "stats": {"total": 350, "additions": 253, "deletions": 97}, "files": [{"sha": "011da378cca5829c68908ab3da44cf000e2196e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -1,3 +1,21 @@\n+2020-04-04  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94219\n+\tPR c++/94205\n+\t* constexpr.c (get_or_insert_ctor_field): Split out (while adding\n+\tsupport for VECTOR_TYPEs, and optimizations for the common case)\n+\tfrom ...\n+\t(cxx_eval_store_expression): ... here.  Rename local variable\n+\t'changed_active_union_member_p' to 'activated_union_member_p'.  Record\n+\tthe sequence of indexes into 'indexes' that yields the subobject we're\n+\tassigning to.  Record the integer offsets of the constructor indexes\n+\twe're assigning through into 'index_pos_hints'.  After evaluating the\n+\tinitializer of the store expression, recompute 'valp' using 'indexes'\n+\tand using 'index_pos_hints' as hints.\n+\t(cxx_eval_bare_aggregate): Tweak comments.  Use get_or_insert_ctor_field\n+\tto recompute the constructor_elt pointer we're assigning through after\n+\tevaluating each initializer.\n+\n 2020-04-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/67825"}, {"sha": "8fa1f533ede0fa33fc39b66989905a7610f45d0a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 153, "deletions": 97, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -3151,6 +3151,95 @@ find_array_ctor_elt (tree ary, tree dindex, bool insert)\n   return -1;\n }\n \n+/* Return a pointer to the constructor_elt of CTOR which matches INDEX.  If no\n+   matching constructor_elt exists, then add one to CTOR.\n+\n+   As an optimization, if POS_HINT is non-negative then it is used as a guess\n+   for the (integer) index of the matching constructor_elt within CTOR.  */\n+\n+static constructor_elt *\n+get_or_insert_ctor_field (tree ctor, tree index, int pos_hint)\n+{\n+  /* Check the hint first.  */\n+  if (pos_hint >= 0 && (unsigned)pos_hint < CONSTRUCTOR_NELTS (ctor)\n+      && CONSTRUCTOR_ELT (ctor, pos_hint)->index == index)\n+    return CONSTRUCTOR_ELT (ctor, pos_hint);\n+\n+  tree type = TREE_TYPE (ctor);\n+  if (TREE_CODE (type) == VECTOR_TYPE && index == NULL_TREE)\n+    {\n+      CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (ctor), index, NULL_TREE);\n+      return &CONSTRUCTOR_ELTS (ctor)->last();\n+    }\n+  else if (TREE_CODE (type) == ARRAY_TYPE || TREE_CODE (type) == VECTOR_TYPE)\n+    {\n+      HOST_WIDE_INT i = find_array_ctor_elt (ctor, index, /*insert*/true);\n+      gcc_assert (i >= 0);\n+      constructor_elt *cep = CONSTRUCTOR_ELT (ctor, i);\n+      gcc_assert (cep->index == NULL_TREE\n+\t\t  || TREE_CODE (cep->index) != RANGE_EXPR);\n+      return cep;\n+    }\n+  else\n+    {\n+      gcc_assert (TREE_CODE (index) == FIELD_DECL);\n+\n+      /* We must keep the CONSTRUCTOR's ELTS in FIELD order.\n+\t Usually we meet initializers in that order, but it is\n+\t possible for base types to be placed not in program\n+\t order.  */\n+      tree fields = TYPE_FIELDS (DECL_CONTEXT (index));\n+      unsigned HOST_WIDE_INT idx = 0;\n+      constructor_elt *cep = NULL;\n+\n+      /* Check if we're changing the active member of a union.  */\n+      if (TREE_CODE (type) == UNION_TYPE && CONSTRUCTOR_NELTS (ctor)\n+\t  && CONSTRUCTOR_ELT (ctor, 0)->index != index)\n+\tvec_safe_truncate (CONSTRUCTOR_ELTS (ctor), 0);\n+      /* If the bit offset of INDEX is larger than that of the last\n+\t constructor_elt, then we can just immediately append a new\n+\t constructor_elt to the end of CTOR.  */\n+      else if (CONSTRUCTOR_NELTS (ctor)\n+\t       && tree_int_cst_compare (bit_position (index),\n+\t\t\t\t\tbit_position (CONSTRUCTOR_ELTS (ctor)\n+\t\t\t\t\t\t      ->last().index)) > 0)\n+\t{\n+\t  idx = CONSTRUCTOR_NELTS (ctor);\n+\t  goto insert;\n+\t}\n+\n+      /* Otherwise, we need to iterate over CTOR to find or insert INDEX\n+\t appropriately.  */\n+\n+      for (; vec_safe_iterate (CONSTRUCTOR_ELTS (ctor), idx, &cep);\n+\t   idx++, fields = DECL_CHAIN (fields))\n+\t{\n+\t  if (index == cep->index)\n+\t    goto found;\n+\n+\t  /* The field we're initializing must be on the field\n+\t     list.  Look to see if it is present before the\n+\t     field the current ELT initializes.  */\n+\t  for (; fields != cep->index; fields = DECL_CHAIN (fields))\n+\t    if (index == fields)\n+\t      goto insert;\n+\t}\n+      /* We fell off the end of the CONSTRUCTOR, so insert a new\n+\t entry at the end.  */\n+\n+    insert:\n+      {\n+\tconstructor_elt ce = { index, NULL_TREE };\n+\n+\tvec_safe_insert (CONSTRUCTOR_ELTS (ctor), idx, ce);\n+\tcep = CONSTRUCTOR_ELT (ctor, idx);\n+      }\n+    found:;\n+\n+      return cep;\n+    }\n+}\n+\n /* Under the control of CTX, issue a detailed diagnostic for\n    an out-of-bounds subscript INDEX into the expression ARRAY.  */\n \n@@ -3760,14 +3849,18 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n     {\n       tree orig_value = value;\n       init_subob_ctx (ctx, new_ctx, index, value);\n+      int pos_hint = -1;\n       if (new_ctx.ctor != ctx->ctor)\n-\t/* If we built a new CONSTRUCTOR, attach it now so that other\n-\t   initializers can refer to it.  */\n-\tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n+\t{\n+\t  /* If we built a new CONSTRUCTOR, attach it now so that other\n+\t     initializers can refer to it.  */\n+\t  CONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n+\t  pos_hint = vec_safe_length (*p) - 1;\n+\t}\n       else if (TREE_CODE (type) == UNION_TYPE)\n-\t/* Otherwise if we're constructing a union, set the active union member\n-\t   anyway so that we can later detect if the initializer attempts to\n-\t   activate another member.  */\n+\t/* Otherwise if we're constructing a non-aggregate union member, set\n+\t   the active union member now so that we can later detect and diagnose\n+\t   if its initializer attempts to activate another member.  */\n \tCONSTRUCTOR_APPEND_ELT (*p, index, NULL_TREE);\n       tree elt = cxx_eval_constant_expression (&new_ctx, value,\n \t\t\t\t\t       lval,\n@@ -3804,18 +3897,18 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \t{\n \t  if (TREE_CODE (type) == UNION_TYPE\n \t      && (*p)->last().index != index)\n-\t    /* The initializer may have erroneously changed the active union\n-\t       member that we're initializing.  */\n+\t    /* The initializer erroneously changed the active union member that\n+\t       we're initializing.  */\n \t    gcc_assert (*non_constant_p);\n-\t  else if (new_ctx.ctor != ctx->ctor\n-\t\t   || TREE_CODE (type) == UNION_TYPE)\n+\t  else\n \t    {\n-\t      /* We appended this element above; update the value.  */\n-\t      gcc_assert ((*p)->last().index == index);\n-\t      (*p)->last().value = elt;\n+\t      /* The initializer might have mutated the underlying CONSTRUCTOR,\n+\t\t so recompute the location of the target constructer_elt.  */\n+\t      constructor_elt *cep\n+\t\t= get_or_insert_ctor_field (ctx->ctor, index, pos_hint);\n+\t      cep->value = elt;\n \t    }\n-\t  else\n-\t    CONSTRUCTOR_APPEND_ELT (*p, index, elt);\n+\n \t  /* Adding or replacing an element might change the ctor's flags.  */\n \t  TREE_CONSTANT (ctx->ctor) = constant_p;\n \t  TREE_SIDE_EFFECTS (ctx->ctor) = side_effects_p;\n@@ -4590,8 +4683,9 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   type = TREE_TYPE (object);\n   bool no_zero_init = true;\n \n-  releasing_vec ctors;\n-  bool changed_active_union_member_p = false;\n+  releasing_vec ctors, indexes;\n+  auto_vec<int> index_pos_hints;\n+  bool activated_union_member_p = false;\n   while (!refs->is_empty ())\n     {\n       if (*valp == NULL_TREE)\n@@ -4632,94 +4726,49 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t subobjects will also be zero-initialized.  */\n       no_zero_init = CONSTRUCTOR_NO_CLEARING (*valp);\n \n-      vec_safe_push (ctors, *valp);\n-\n       enum tree_code code = TREE_CODE (type);\n       type = refs->pop();\n       tree index = refs->pop();\n \n-      constructor_elt *cep = NULL;\n-      if (code == ARRAY_TYPE)\n+      if (code == UNION_TYPE && CONSTRUCTOR_NELTS (*valp)\n+\t  && CONSTRUCTOR_ELT (*valp, 0)->index != index)\n \t{\n-\t  HOST_WIDE_INT i\n-\t    = find_array_ctor_elt (*valp, index, /*insert*/true);\n-\t  gcc_assert (i >= 0);\n-\t  cep = CONSTRUCTOR_ELT (*valp, i);\n-\t  gcc_assert (cep->index == NULL_TREE\n-\t\t      || TREE_CODE (cep->index) != RANGE_EXPR);\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (TREE_CODE (index) == FIELD_DECL);\n-\n-\t  /* We must keep the CONSTRUCTOR's ELTS in FIELD order.\n-\t     Usually we meet initializers in that order, but it is\n-\t     possible for base types to be placed not in program\n-\t     order.  */\n-\t  tree fields = TYPE_FIELDS (DECL_CONTEXT (index));\n-\t  unsigned HOST_WIDE_INT idx;\n-\n-\t  if (code == UNION_TYPE && CONSTRUCTOR_NELTS (*valp)\n-\t      && CONSTRUCTOR_ELT (*valp, 0)->index != index)\n+\t  if (cxx_dialect < cxx2a)\n \t    {\n-\t      if (cxx_dialect < cxx2a)\n-\t\t{\n-\t\t  if (!ctx->quiet)\n-\t\t    error_at (cp_expr_loc_or_input_loc (t),\n-\t\t\t      \"change of the active member of a union \"\n-\t\t\t      \"from %qD to %qD\",\n-\t\t\t      CONSTRUCTOR_ELT (*valp, 0)->index,\n-\t\t\t      index);\n-\t\t  *non_constant_p = true;\n-\t\t}\n-\t      else if (TREE_CODE (t) == MODIFY_EXPR\n-\t\t       && CONSTRUCTOR_NO_CLEARING (*valp))\n-\t\t{\n-\t\t  /* Diagnose changing the active union member while the union\n-\t\t     is in the process of being initialized.  */\n-\t\t  if (!ctx->quiet)\n-\t\t    error_at (cp_expr_loc_or_input_loc (t),\n-\t\t\t      \"change of the active member of a union \"\n-\t\t\t      \"from %qD to %qD during initialization\",\n-\t\t\t      CONSTRUCTOR_ELT (*valp, 0)->index,\n-\t\t\t      index);\n-\t\t  *non_constant_p = true;\n-\t\t}\n-\t      /* Changing active member.  */\n-\t      vec_safe_truncate (CONSTRUCTOR_ELTS (*valp), 0);\n-\t      no_zero_init = true;\n+\t      if (!ctx->quiet)\n+\t\terror_at (cp_expr_loc_or_input_loc (t),\n+\t\t\t  \"change of the active member of a union \"\n+\t\t\t  \"from %qD to %qD\",\n+\t\t\t  CONSTRUCTOR_ELT (*valp, 0)->index,\n+\t\t\t  index);\n+\t      *non_constant_p = true;\n \t    }\n-\n-\t  for (idx = 0;\n-\t       vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);\n-\t       idx++, fields = DECL_CHAIN (fields))\n+\t  else if (TREE_CODE (t) == MODIFY_EXPR\n+\t\t   && CONSTRUCTOR_NO_CLEARING (*valp))\n \t    {\n-\t      if (index == cep->index)\n-\t\tgoto found;\n-\n-\t      /* The field we're initializing must be on the field\n-\t\t list.  Look to see if it is present before the\n-\t\t field the current ELT initializes.  */\n-\t      for (; fields != cep->index; fields = DECL_CHAIN (fields))\n-\t\tif (index == fields)\n-\t\t  goto insert;\n+\t      /* Diagnose changing the active union member while the union\n+\t\t is in the process of being initialized.  */\n+\t      if (!ctx->quiet)\n+\t\terror_at (cp_expr_loc_or_input_loc (t),\n+\t\t\t  \"change of the active member of a union \"\n+\t\t\t  \"from %qD to %qD during initialization\",\n+\t\t\t  CONSTRUCTOR_ELT (*valp, 0)->index,\n+\t\t\t  index);\n+\t      *non_constant_p = true;\n \t    }\n+\t  no_zero_init = true;\n+\t}\n \n-\t  /* We fell off the end of the CONSTRUCTOR, so insert a new\n-\t     entry at the end.  */\n-\tinsert:\n-\t  {\n-\t    constructor_elt ce = { index, NULL_TREE };\n+      vec_safe_push (ctors, *valp);\n+      vec_safe_push (indexes, index);\n \n-\t    vec_safe_insert (CONSTRUCTOR_ELTS (*valp), idx, ce);\n-\t    cep = CONSTRUCTOR_ELT (*valp, idx);\n+      constructor_elt *cep\n+\t= get_or_insert_ctor_field (*valp, index, /*pos_hint=*/-1);\n+      index_pos_hints.safe_push (cep - CONSTRUCTOR_ELTS (*valp)->begin());\n+\n+      if (code == UNION_TYPE)\n+\tactivated_union_member_p = true;\n \n-\t    if (code == UNION_TYPE)\n-\t      /* Record that we've changed an active union member.  */\n-\t      changed_active_union_member_p = true;\n-\t  }\n-\tfound:;\n-\t}\n       valp = &cep->value;\n     }\n \n@@ -4800,9 +4849,16 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \t  init = tinit;\n       init = cxx_eval_constant_expression (&new_ctx, init, false,\n \t\t\t\t\t   non_constant_p, overflow_p);\n-      if (ctors->is_empty())\n-\t/* The hash table might have moved since the get earlier.  */\n-\tvalp = ctx->global->values.get (object);\n+      /* The hash table might have moved since the get earlier, and the\n+\t initializer might have mutated the underlying CONSTRUCTORs, so we must\n+\t recompute VALP. */\n+      valp = ctx->global->values.get (object);\n+      for (unsigned i = 0; i < vec_safe_length (indexes); i++)\n+\t{\n+\t  constructor_elt *cep\n+\t    = get_or_insert_ctor_field (*valp, indexes[i], index_pos_hints[i]);\n+\t  valp = &cep->value;\n+\t}\n     }\n \n   /* Don't share a CONSTRUCTOR that might be changed later.  */\n@@ -4847,7 +4903,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n   unsigned i;\n   bool c = TREE_CONSTANT (init);\n   bool s = TREE_SIDE_EFFECTS (init);\n-  if (!c || s || changed_active_union_member_p)\n+  if (!c || s || activated_union_member_p)\n     FOR_EACH_VEC_ELT (*ctors, i, elt)\n       {\n \tif (!c)"}, {"sha": "dedde9f043efc9ee2df3d07671c455d892d0bd4f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -1,3 +1,12 @@\n+2020-04-04  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94219\n+\tPR c++/94205\n+\t* g++.dg/cpp1y/constexpr-nsdmi3.C: New test.\n+\t* g++.dg/cpp1y/constexpr-nsdmi4.C: New test.\n+\t* g++.dg/cpp1y/constexpr-nsdmi5.C: New test.\n+\t* g++.dg/cpp1z/lambda-this5.C: New test.\n+\n 2020-04-04  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/93940"}, {"sha": "0f91e93ca3ffd0beee55e782839ee121fd899290", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-nsdmi3.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi3.C?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/94205\n+// { dg-do compile { target c++14 } }\n+\n+struct S\n+{\n+  struct A\n+  {\n+    S *p;\n+    constexpr A(S* p): p(p) {}\n+    constexpr operator int() { p->a = 5; return 6; }\n+  };\n+  int a = A(this);\n+};\n+\n+\n+constexpr S s = {};\n+\n+#define SA(X) static_assert((X),#X)\n+SA(s.a == 6);"}, {"sha": "0ceef1bb29fe9449ab38d7da23b2e5bd6ff92a7f", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-nsdmi4.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi4.C?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -0,0 +1,21 @@\n+// PR c++/94219\n+// { dg-do compile { target c++14 } }\n+\n+struct A { long x; };\n+\n+struct U;\n+constexpr A foo(U *up);\n+\n+struct U {\n+  A a = foo(this); int y;\n+};\n+\n+constexpr A foo(U *up) {\n+  up->y = 11;\n+  return {42};\n+}\n+\n+extern constexpr U u = {};\n+\n+static_assert(u.y == 11, \"\");\n+static_assert(u.a.x == 42, \"\");"}, {"sha": "59e7a10d6e8253bac31ad7160ef60b185c2b98b2", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-nsdmi5.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-nsdmi5.C?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/94219\n+// { dg-do compile { target c++14 } }\n+\n+struct A { long x; };\n+\n+struct U;\n+constexpr A foo(U *up);\n+\n+struct U {\n+  U() = default;\n+  int y; A a = foo(this);\n+};\n+\n+constexpr A foo(U *up) {\n+  up->y = 11;\n+  return {42};\n+}\n+\n+extern constexpr U u = {};\n+\n+static_assert(u.y == 11, \"\");\n+static_assert(u.a.x == 42, \"\");"}, {"sha": "c6d44d7fd0bf556f43d637777029fd2fc487a9d9", "filename": "gcc/testsuite/g++.dg/cpp1z/lambda-this5.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/37244b217a7329792f4ec48027f63cf5010b0ea8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Flambda-this5.C?ref=37244b217a7329792f4ec48027f63cf5010b0ea8", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/94205\n+// { dg-do compile { target c++17 } }\n+\n+struct S\n+{\n+  int a = [this] { this->a = 5; return 6; } ();\n+};\n+\n+constexpr S s = {};\n+\n+static_assert(s.a == 6);"}]}