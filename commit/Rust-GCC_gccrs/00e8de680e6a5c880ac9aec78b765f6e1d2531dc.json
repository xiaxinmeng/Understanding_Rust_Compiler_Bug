{"sha": "00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlOGRlNjgwZTZhNWM4ODBhYzlhZWM3OGI3NjVmNmUxZDI1MzFkYw==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2003-10-13T10:26:36Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2003-10-13T10:26:36Z"}, "message": "Break out decl.c (2/n)\n\n\tBreak out decl.c (2/n)\n\t* name-lookup.c: Include diagnostic.h\n\t(cxx_binding_free): Make static.\n\t(cxx_binding_make): Likewise.\n\t(binding_table_new): Likewise\n\t(binding_table_free): Likewise.\n\t(binding_table_insert): Likewise.\n\t(binding_table_find_anon_type): Likewise.\n\t(binding_table_reverse_maybe_remap): Likewise.\n\t(supplement_binding): Likewise.\n\t* name-lookup.h (global_scope_name): Declare extern.\n\t(global_type_node): Likewise.\n\t(cxx_binding_free): Don't export.\n\t(cxx_binding_make): Likewise.\n\t(binding_table_new): Likewise.\n\t(binding_table_free): Likewise.\n\t(binding_table_insert): Likewise.\n\t(binding_table_find_anon_type): Likewise.\n\t(binding_table_reverse_maybe_remap): Likewise.\n\t* Make-lang.in (cp/name-lookup.o): Depend on $(DIAGNOSTIC_H)\n\t* decl.c (lookup_namespace_name): Move to name-lookup.c\n\t(select_decl): Likewise.\n\t(unqualified_namespace_lookup): Likewise.\n\t(lookup_qualified_name): Likewise.\n\t(lookup_name_real): Likewise.\n\t(lookup_name_nonclass): Likewise.\n\t(lookup_function_nonclass): Likewise.\n\t(lookup_name): Likewise.\n\t(lookup_name_current_level): Likewise.\n\t(lookup_type_current_level): Likewise.\n\t(lookup_flags): Likewise.\n\t(qualify_lookup): Likewise.\n\t(lookup_tag): Likewise.\n\t(lookup_tag_reverse): Likewise.\n\t(getdecls): Likewise.\n\t(storedecls): Remove.\n\t(cxx_remember_type_decls): Likewise.\n\t(global_bindings_p): Likewise.\n\t(innermost_nonclass_level): Likewise.\n\t(toplevel_bindings_p): Likewise.\n\t(namespace_bindings_p): Likewise.\n\t(kept_level_p): Likewise.\n\t(innermost_scope_kind): Likewise.\n\t(template_parm_scope_p): Likewise.\n\t(push_binding): Likewise.\n\t(push_local_binding): Likewise.\n\t(add_decl_to_level): Likewise.  Make extern.\n\t(push_class_binding): Move to name-lookup.c.\n\t(resume_level): Likewise.  Rename to resume_scope.\n\t(begin_scope): Likewise.\n\t(indent): Likewise.\n\t(binding_depth): Likewise.\n\t(is_class_level): Likewise.\n\t(cxx_scope_descriptor): Likewise.\n\t(cxx_scope_debug): Likewise.\n\t(namespace_scope_ht_size): Likewise.\n\t(leave_scope): Likewise.\n\t(pushlevel_class): Likewise.\n\t(poplevel_class): Likewise.\n\t(clear_identifier_class_values): Likewise.\n\t(pushdecl_with_scope): Likewise.\n\t(pushdecl_namespace_level): Likewise.\n\t(pushdecl_class_level): Likewise.\n\t(push_class_level_binding): Likewise.\n\t(push_using_directive): Likewise.\n\t(identifier_global_value): Likewise.\n\t(keep_next_level_flag): Likewise.\n\t(keep_next_level): Likewise.\n\t(free_binding_level): Likewise.\n\t(set_class_shadows): Likewise.\n\t(maybe_push_cleanup_level): Likewise.\n\t(cp_namespace_decls): Likewise.\n\t(bt_print_entry): Likewise.\n\t(print_binding_level): Likewise.\n\t(print_other_binding_stack): Likewise.\n\t(print_binding_stack): Likewise.\n\t(push_namespace): Likewise.\n\t(pop_namespace): Likewise.\n\t(push_nested_namespace): Likewise.\n\t(pop_nested_namespace): Likewise.\n\t(cxx_saved_binding_make): Likewise.\n\t(struct cxx_saved_binding_make): Likewise.\n\t(store_bindings): Likewise.\n\t(maybe_push_to_top_level): Likewise.\n\t(push_to_top_level): Likewise.\n\t(pop_from_top_level): Likewise.\n\t(identifier_type_value): Likewise.\n\t(set_identifier_type_value): Likewise.\n\t(set_identifier_type_value_with_scope): Likewise.\n\t(pop_everything): Likewise.\n\t(pushtag): Likewise.\n\t(follow_tag_typedef): Likewise.\n\t(maybe_process_template_type_declaration): Likewise.\n\t(pop_binding): Likewise.\n\t* cp-tree.h: Move corresponding declarations to name-lookup.h\n\nFrom-SVN: r72426", "tree": {"sha": "b9ede29f76d95815a065186834227685a06326b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9ede29f76d95815a065186834227685a06326b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f0504d9072cc2ced75e6a1586d95d1f33e4fb37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f0504d9072cc2ced75e6a1586d95d1f33e4fb37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f0504d9072cc2ced75e6a1586d95d1f33e4fb37"}], "stats": {"total": 4891, "additions": 2477, "deletions": 2414}, "files": [{"sha": "be4eba036e453ae31857ecb03665b21f41fa0b8f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -1,3 +1,101 @@\n+2003-10-13  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\tBreak out decl.c (2/n) \n+\t* name-lookup.c: Include diagnostic.h\n+\t(cxx_binding_free): Make static.\n+\t(cxx_binding_make): Likewise.\n+\t(binding_table_new): Likewise\n+\t(binding_table_free): Likewise.\n+\t(binding_table_insert): Likewise.\n+\t(binding_table_find_anon_type): Likewise.\n+\t(binding_table_reverse_maybe_remap): Likewise.\n+\t(supplement_binding): Likewise.\n+\t* name-lookup.h (global_scope_name): Declare extern.\n+\t(global_type_node): Likewise.\n+\t(cxx_binding_free): Don't export.\n+\t(cxx_binding_make): Likewise.\n+\t(binding_table_new): Likewise.\n+\t(binding_table_free): Likewise.\n+\t(binding_table_insert): Likewise.\n+\t(binding_table_find_anon_type): Likewise.\n+\t(binding_table_reverse_maybe_remap): Likewise.\n+\t* Make-lang.in (cp/name-lookup.o): Depend on $(DIAGNOSTIC_H)\n+\t* decl.c (lookup_namespace_name): Move to name-lookup.c\n+\t(select_decl): Likewise.\n+\t(unqualified_namespace_lookup): Likewise.\n+\t(lookup_qualified_name): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(lookup_name_nonclass): Likewise.\n+\t(lookup_function_nonclass): Likewise.\n+\t(lookup_name): Likewise.\n+\t(lookup_name_current_level): Likewise.\n+\t(lookup_type_current_level): Likewise.\n+\t(lookup_flags): Likewise.\n+\t(qualify_lookup): Likewise.\n+\t(lookup_tag): Likewise.\n+\t(lookup_tag_reverse): Likewise.\n+\t(getdecls): Likewise.\n+\t(storedecls): Remove.\n+\t(cxx_remember_type_decls): Likewise.\n+\t(global_bindings_p): Likewise.\n+\t(innermost_nonclass_level): Likewise.\n+\t(toplevel_bindings_p): Likewise.\n+\t(namespace_bindings_p): Likewise.\n+\t(kept_level_p): Likewise.\n+\t(innermost_scope_kind): Likewise.\n+\t(template_parm_scope_p): Likewise.\n+\t(push_binding): Likewise.\n+\t(push_local_binding): Likewise.\n+\t(add_decl_to_level): Likewise.  Make extern.\n+\t(push_class_binding): Move to name-lookup.c.\n+\t(resume_level): Likewise.  Rename to resume_scope.\n+\t(begin_scope): Likewise.\n+\t(indent): Likewise.\n+\t(binding_depth): Likewise.\n+\t(is_class_level): Likewise.\n+\t(cxx_scope_descriptor): Likewise.\n+\t(cxx_scope_debug): Likewise.\n+\t(namespace_scope_ht_size): Likewise.\n+\t(leave_scope): Likewise.\n+\t(pushlevel_class): Likewise.\n+\t(poplevel_class): Likewise.\n+\t(clear_identifier_class_values): Likewise.\n+\t(pushdecl_with_scope): Likewise.\n+\t(pushdecl_namespace_level): Likewise.\n+\t(pushdecl_class_level): Likewise.\n+\t(push_class_level_binding): Likewise.\n+\t(push_using_directive): Likewise.\n+\t(identifier_global_value): Likewise.\n+\t(keep_next_level_flag): Likewise.\n+\t(keep_next_level): Likewise.\n+\t(free_binding_level): Likewise.\n+\t(set_class_shadows): Likewise.\n+\t(maybe_push_cleanup_level): Likewise.\n+\t(cp_namespace_decls): Likewise.\n+\t(bt_print_entry): Likewise.\n+\t(print_binding_level): Likewise.\n+\t(print_other_binding_stack): Likewise.\n+\t(print_binding_stack): Likewise.\n+\t(push_namespace): Likewise.\n+\t(pop_namespace): Likewise.\n+\t(push_nested_namespace): Likewise.\n+\t(pop_nested_namespace): Likewise.\n+\t(cxx_saved_binding_make): Likewise.\n+\t(struct cxx_saved_binding_make): Likewise.\n+\t(store_bindings): Likewise.\n+\t(maybe_push_to_top_level): Likewise.\n+\t(push_to_top_level): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t(identifier_type_value): Likewise.\n+\t(set_identifier_type_value): Likewise.\n+\t(set_identifier_type_value_with_scope): Likewise.\n+\t(pop_everything): Likewise.\n+\t(pushtag): Likewise.\n+\t(follow_tag_typedef): Likewise.\n+\t(maybe_process_template_type_declaration): Likewise.\n+\t(pop_binding): Likewise.\n+\t* cp-tree.h: Move corresponding declarations to name-lookup.h\n+\t\n 2003-10-12  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cvt.c (ocp_convert): Move warning to C common code."}, {"sha": "52a5a0c916a90afb3fb517ea252828637a3f8467", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -279,7 +279,8 @@ cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h real.h gt-cp-mangle.h $(\n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h output.h\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n-\t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h toplev.h\n+\t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h toplev.h \\\n+\t$(DIAGNOSTIC_H)\n \n cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H)"}, {"sha": "f3286d6639053ce44b5bb6d8e7160eb44afae8a4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -3584,9 +3584,6 @@ extern void clone_function_decl                 (tree, int);\n extern void adjust_clone_args\t\t\t(tree);\n \n /* decl.c */\n-extern int global_bindings_p\t\t\t(void);\n-extern int kept_level_p\t\t\t\t(void);\n-extern tree getdecls\t\t\t\t(void);\n extern void insert_block\t\t\t(tree);\n extern void set_block\t\t\t\t(tree);\n extern tree pushdecl\t\t\t\t(tree);\n@@ -3597,66 +3594,29 @@ extern bool cxx_mark_addressable\t\t(tree);\n extern void cxx_push_function_context\t\t(struct function *);\n extern void cxx_pop_function_context\t\t(struct function *);\n extern void cxx_mark_function_context\t\t(struct function *);\n-extern int toplevel_bindings_p\t\t\t(void);\n-extern int namespace_bindings_p\t\t\t(void);\n-extern void keep_next_level (bool);\n-extern scope_kind innermost_scope_kind          (void);\n-extern int template_parm_scope_p\t\t(void);\n-extern void set_class_shadows\t\t\t(tree);\n-extern void maybe_push_cleanup_level\t\t(tree);\n-extern cxx_scope *begin_scope (scope_kind, tree);\n+extern void maybe_push_cleanup_level (tree);\n extern void finish_scope                        (void);\n-extern void resume_level\t\t\t(struct cp_binding_level *);\n extern void delete_block\t\t\t(tree);\n extern void add_block_current_level\t\t(tree);\n-extern void pushlevel_class\t\t\t(void);\n-extern void poplevel_class                      (void);\n-extern void print_binding_stack\t\t\t(void);\n-extern void print_binding_level\t\t\t(struct cp_binding_level *);\n-extern void push_namespace\t\t\t(tree);\n-extern void pop_namespace\t\t\t(void);\n-extern void push_nested_namespace\t\t(tree);\n-extern void pop_nested_namespace\t\t(tree);\n-extern void maybe_push_to_top_level\t\t(int);\n-extern void push_to_top_level\t\t\t(void);\n-extern void pop_from_top_level\t\t\t(void);\n extern void push_switch\t\t\t\t(tree);\n extern void pop_switch\t\t\t\t(void);\n-extern tree identifier_type_value\t\t(tree);\n-extern void set_identifier_type_value\t\t(tree, tree);\n-extern void pop_everything\t\t\t(void);\n extern void pushtag\t\t\t\t(tree, tree, int);\n extern tree make_anon_name\t\t\t(void);\n extern void clear_anon_tags\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n extern int duplicate_decls\t\t\t(tree, tree);\n extern tree pushdecl_top_level\t\t\t(tree);\n extern tree pushdecl_top_level_and_finish       (tree, tree);\n-extern bool pushdecl_class_level\t\t(tree);\n-extern tree pushdecl_namespace_level            (tree);\n extern tree push_using_decl                     (tree, tree);\n-extern tree push_using_directive                (tree);\n-extern bool push_class_level_binding\t\t(tree, tree);\n extern tree implicitly_declare\t\t\t(tree);\n extern tree declare_local_label                 (tree);\n extern tree define_label\t\t\t(location_t, tree);\n extern void check_goto\t\t\t\t(tree);\n extern void define_case_label\t\t\t(void);\n-extern tree namespace_binding                   (tree, tree);\n-extern void set_namespace_binding               (tree, tree, tree);\n-extern tree lookup_namespace_name\t\t(tree, tree);\n extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tsubst_flags_t);\n-extern tree lookup_name_nonclass\t\t(tree);\n-extern tree lookup_function_nonclass            (tree, tree);\n-extern tree lookup_qualified_name               (tree, tree, bool, bool);\n-extern tree lookup_name\t\t\t\t(tree, int);\n-extern tree lookup_name_current_level\t\t(tree);\n-extern tree lookup_type_current_level\t\t(tree);\n-extern tree lookup_name_real                    (tree, int, int, int, int);\n extern tree namespace_ancestor\t\t\t(tree, tree);\n extern bool is_ancestor                         (tree, tree);\n-extern tree unqualified_namespace_lookup\t(tree, int, tree *);\n extern tree check_for_out_of_scope_variable     (tree);\n extern bool lookup_using_namespace (tree, cxx_binding *, tree, tree, int, tree *);\n extern bool qualified_lookup_using_namespace (tree, tree, cxx_binding *, int);\n@@ -3705,12 +3665,8 @@ extern void revert_static_member_fn             (tree);\n extern void fixup_anonymous_aggr                (tree);\n extern int check_static_variable_definition     (tree, tree);\n extern tree compute_array_index_type\t\t(tree, tree);\n-extern void push_local_binding                  (tree, tree, int);\n-extern int push_class_binding                   (tree, tree);\n extern tree check_default_argument              (tree, tree);\n extern tree push_overloaded_decl\t\t(tree, int);\n-extern void clear_identifier_class_values       (void);\n-extern void storetags                           (tree);\n extern int vtable_decl_p                        (tree, void *);\n extern int vtype_decl_p                         (tree, void *);\n extern int sigtable_decl_p                      (tree, void *);\n@@ -3722,7 +3678,6 @@ typedef int (*walk_namespaces_fn)               (tree, void *);\n extern int walk_namespaces                      (walk_namespaces_fn,\n \t\t\t\t\t\t       void *);\n extern int wrapup_globals_for_namespace         (tree, void *);\n-extern tree cp_namespace_decls                  (tree);\n extern tree create_implicit_typedef             (tree, tree);\n extern tree maybe_push_decl                     (tree);\n extern tree build_target_expr_with_type         (tree, tree);\n@@ -3736,6 +3691,7 @@ extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n extern tree cxx_builtin_type_decls              (void);\n \n extern bool have_extern_spec;\n+extern GTY(()) tree last_function_parms;\n \n /* in decl2.c */\n extern bool check_java_method (tree);"}, {"sha": "bcd0a5f5daf4035febe7e050e54e15fa67eb1f35", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 75, "deletions": 2335, "changes": 2410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -55,26 +55,17 @@ Boston, MA 02111-1307, USA.  */\n static tree grokparms (tree);\n static const char *redeclaration_error_message (tree, tree);\n \n-static void resume_binding_level (struct cp_binding_level *);\n static int decl_jump_unsafe (tree);\n-static void storedecls (tree);\n static void require_complete_types_for_parms (tree);\n static int ambi_op_p (enum tree_code);\n static int unary_op_p (enum tree_code);\n-static cxx_saved_binding *store_bindings (tree, cxx_saved_binding *);\n-static tree lookup_tag_reverse (tree, tree);\n static void push_local_name (tree);\n static void warn_extern_redeclared_static (tree, tree);\n static tree grok_reference_init (tree, tree, tree, tree *);\n static tree grokfndecl (tree, tree, tree, tree, int,\n \t\t\tenum overload_flags, tree,\n \t\t\ttree, int, int, int, int, int, int, tree);\n static tree grokvardecl (tree, tree, RID_BIT_TYPE *, int, int, tree);\n-static tree follow_tag_typedef (tree);\n-static tree lookup_tag (enum tree_code, tree,\n-\t\t\tstruct cp_binding_level *, int);\n-static void set_identifier_type_value_with_scope\n-\t(tree, tree, struct cp_binding_level *);\n static void record_unknown_type (tree, const char *);\n static tree builtin_function_1 (const char *, tree, tree, int,\n                                 enum built_in_class, const char *,\n@@ -83,24 +74,15 @@ static tree build_library_fn_1 (tree, enum tree_code, tree);\n static int member_function_or_else (tree, tree, enum overload_flags);\n static void bad_specifiers (tree, const char *, int, int, int, int,\n \t\t\t    int);\n-static tree maybe_process_template_type_declaration \n-\t(tree, int, struct cp_binding_level*);\n static void check_for_uninitialized_const_var (tree);\n static hashval_t typename_hash (const void *);\n static int typename_compare (const void *, const void *);\n-static void push_binding (tree, tree, struct cp_binding_level*);\n-static void pop_binding (tree, tree);\n static tree local_variable_p_walkfn (tree *, int *, void *);\n-static tree select_decl (cxx_binding *, int);\n-static int lookup_flags (int, int);\n-static tree qualify_lookup (tree, int);\n static tree record_builtin_java_type (const char *, int);\n static const char *tag_name (enum tag_types code);\n-static struct cp_binding_level *innermost_nonclass_level (void);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static int walk_globals_r (tree, void*);\n static int walk_vtables_r (tree, void*);\n-static void add_decl_to_level (tree, struct cp_binding_level *);\n static tree make_label_decl (tree, int);\n static void use_label (tree);\n static void check_previous_goto_1 (tree, struct cp_binding_level *, tree,\n@@ -193,10 +175,10 @@ tree cp_global_trees[CPTI_MAX];\n /* Indicates that there is a type value in some namespace, although\n    that is not necessarily in scope at the moment.  */\n \n-static GTY(()) tree global_type_node;\n+tree global_type_node;\n \n /* The node that holds the \"name\" of the global scope.  */\n-static GTY(()) tree global_scope_name;\n+tree global_scope_name;\n \n /* Used only for jumps to as-yet undefined labels, since jumps to\n    defined labels can have their validity checked immediately.  */\n@@ -278,331 +260,12 @@ int adding_implicit_members = 0;\n bool have_extern_spec;\n \n \f\n-/* A chain of binding_level structures awaiting reuse.  */\n-\n-static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n-\n-/* true means unconditionally make a BLOCK for the next level pushed.  */\n-\n-static bool keep_next_level_flag;\n-\n /* A TREE_LIST of VAR_DECLs.  The TREE_PURPOSE is a RECORD_TYPE or\n    UNION_TYPE; the TREE_VALUE is a VAR_DECL with that type.  At the\n    time the VAR_DECL was declared, the type was incomplete.  */\n \n static GTY(()) tree incomplete_vars;\n-\n-#ifndef ENABLE_SCOPE_CHECKING\n-#  define ENABLE_SCOPE_CHECKING 0\n-#else\n-#  define ENABLE_SCOPE_CHECKING 1\n-#endif\n-\n-static int binding_depth = 0;\n-static int is_class_level = 0;\n-\n-static void\n-indent (int depth)\n-{\n-  int i;\n-\n-  for (i = 0; i < depth * 2; i++)\n-    putc (' ', stderr);\n-}\n-\n-static tree pushdecl_with_scope\t(tree, struct cp_binding_level *);\n-\n-/* Return a string describing the kind of SCOPE we have.  */\n-static const char *\n-cxx_scope_descriptor (cxx_scope *scope)\n-{\n-  /* The order of this table must match the \"scope_kind\"\n-     enumerators.  */\n-  static const char* scope_kind_names[] = {\n-    \"block-scope\",\n-    \"cleanup-scope\",\n-    \"try-scope\",\n-    \"catch-scope\",\n-    \"for-scope\",\n-    \"function-parameter-scope\",\n-    \"class-scope\",\n-    \"namespace-scope\",\n-    \"template-parameter-scope\",\n-    \"template-explicit-spec-scope\"\n-  };\n-  const scope_kind kind = scope->explicit_spec_p\n-    ? sk_template_spec : scope->kind;\n-\n-  return scope_kind_names[kind];\n-}\n-\n-/* Output a debugging information about SCOPE when performning\n-   ACTION at LINE.  */\n-static void\n-cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n-{\n-  const char *desc = cxx_scope_descriptor (scope);\n-  if (scope->this_entity)\n-    verbatim (\"%s %s(%E) %p %d\\n\", action, desc,\n-              scope->this_entity, (void *) scope, line);\n-  else\n-    verbatim (\"%s %s %p %d\\n\", action, desc, (void *) scope, line);\n-}\n-\n-/* Return the estimated initial size of the hashtable of a NAMESPACE\n-   scope.  */\n-\n-static inline size_t\n-namespace_scope_ht_size (tree ns)\n-{\n-  tree name = DECL_NAME (ns);\n-\n-  return name == std_identifier\n-    ? NAMESPACE_STD_HT_SIZE\n-    : (name == global_scope_name\n-       ? GLOBAL_SCOPE_HT_SIZE\n-       : NAMESPACE_ORDINARY_HT_SIZE);\n-}\n-\n-/* Create a new KIND scope and make it the top of the active scopes stack.\n-   ENTITY is the scope of the associated C++ entity (namespace, class,\n-   function); it is NULL otherwise.  */\n-\n-cxx_scope *\n-begin_scope (scope_kind kind, tree entity)\n-{\n-  cxx_scope *scope;\n-  \n-  /* Reuse or create a struct for this binding level.  */\n-  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n-    {\n-      scope = free_binding_level;\n-      free_binding_level = scope->level_chain;\n-    }\n-  else\n-    scope = ggc_alloc (sizeof (cxx_scope));\n-  memset (scope, 0, sizeof (cxx_scope));\n-\n-  scope->this_entity = entity;\n-  scope->more_cleanups_ok = true;\n-  switch (kind)\n-    {\n-    case sk_cleanup:\n-      scope->keep = true;\n-      break;\n-      \n-    case sk_template_spec:\n-      scope->explicit_spec_p = true;\n-      kind = sk_template_parms;\n-      /* fall through */\n-    case sk_template_parms:\n-    case sk_block:\n-    case sk_try:\n-    case sk_catch:\n-    case sk_for:\n-    case sk_class:\n-    case sk_function_parms:\n-      scope->keep = keep_next_level_flag;\n-      break;\n-\n-    case sk_namespace:\n-      scope->type_decls = binding_table_new (namespace_scope_ht_size (entity));\n-      NAMESPACE_LEVEL (entity) = scope;\n-      VARRAY_TREE_INIT (scope->static_decls,\n-                        DECL_NAME (entity) == std_identifier\n-                        || DECL_NAME (entity) == global_scope_name\n-                        ? 200 : 10,\n-                        \"Static declarations\");\n-      break;\n-\n-    default:\n-      /* Should not happen.  */\n-      my_friendly_assert (false, 20030922);\n-      break;\n-    }\n-  scope->kind = kind;\n-\n-  /* Add it to the front of currently active scopes stack.  */\n-  scope->level_chain = current_binding_level;\n-  current_binding_level = scope;\n-  keep_next_level_flag = false;\n-\n-  if (ENABLE_SCOPE_CHECKING)\n-    {\n-      scope->binding_depth = binding_depth;\n-      indent (binding_depth);\n-      cxx_scope_debug (scope, input_location.line, \"push\");\n-      is_class_level = 0;\n-      binding_depth++;\n-    }\n-\n-  return scope;\n-}\n-\n-/* We're about to leave current scope.  Pop the top of the stack of\n-   currently active scopes.  Return the enclosing scope, now active.  */\n-\n-static cxx_scope *\n-leave_scope (void)\n-{\n-  cxx_scope *scope = current_binding_level;\n-\n-  if (scope->kind == sk_namespace && class_binding_level)\n-    current_binding_level = class_binding_level;\n-\n-  /* We cannot leave a scope, if there are none left.  */\n-  if (NAMESPACE_LEVEL (global_namespace))\n-    my_friendly_assert (!global_scope_p (scope), 20030527);\n-  \n-  if (ENABLE_SCOPE_CHECKING)\n-    {\n-      indent (--binding_depth);\n-      cxx_scope_debug (scope, input_location.line, \"leave\");\n-      if (is_class_level != (scope == class_binding_level))\n-        {\n-          indent (binding_depth);\n-          verbatim (\"XXX is_class_level != (current_scope == class_scope)\\n\");\n-        }\n-      is_class_level = 0;\n-    }\n-\n-  /* Move one nesting level up.  */\n-  current_binding_level = scope->level_chain;\n-\n-  /* Namespace-scopes are left most probably temporarily, not completely;\n-     they can be reopen later, e.g. in namespace-extension or any name\n-     binding acttivity that requires us to resume a namespace.  For other\n-     scopes, we just make the structure available for reuse.  */\n-  if (scope->kind != sk_namespace)\n-    {\n-      scope->level_chain = free_binding_level;\n-      if (scope->kind == sk_class)\n-        scope->type_decls = NULL;\n-      else\n-        binding_table_free (scope->type_decls);\n-      my_friendly_assert (!ENABLE_SCOPE_CHECKING\n-                          || scope->binding_depth == binding_depth,\n-                          20030529);\n-      free_binding_level = scope;\n-    }\n-\n-  /* Find the innermost enclosing class scope, and reset\n-     CLASS_BINDING_LEVEL appropriately.  */\n-  for (scope = current_binding_level;\n-       scope && scope->kind != sk_class;\n-       scope = scope->level_chain)\n-    ;\n-  class_binding_level = scope && scope->kind == sk_class ? scope : NULL;\n-\n-  return current_binding_level;\n-}\n-\n-static void\n-resume_binding_level (struct cp_binding_level* b)\n-{\n-  /* Resuming binding levels is meant only for namespaces,\n-     and those cannot nest into classes.  */\n-  my_friendly_assert(!class_binding_level, 386);\n-  /* Also, resuming a non-directly nested namespace is a no-no.  */\n-  my_friendly_assert(b->level_chain == current_binding_level, 386);\n-  current_binding_level = b;\n-  if (ENABLE_SCOPE_CHECKING)\n-    {\n-      b->binding_depth = binding_depth;\n-      indent (binding_depth);\n-      cxx_scope_debug (b, input_location.line, \"resume\");\n-      is_class_level = 0;\n-      binding_depth++;\n-    }\n-}\n \f\n-/* Nonzero if we are currently in the global binding level.  */\n-\n-int\n-global_bindings_p (void)\n-{\n-  return global_scope_p (current_binding_level);\n-}\n-\n-/* Return the innermost binding level that is not for a class scope.  */\n-\n-static struct cp_binding_level *\n-innermost_nonclass_level (void)\n-{\n-  struct cp_binding_level *b;\n-\n-  b = current_binding_level;\n-  while (b->kind == sk_class)\n-    b = b->level_chain;\n-\n-  return b;\n-}\n-\n-/* Nonzero if we are currently in a toplevel binding level.  This\n-   means either the global binding level or a namespace in a toplevel\n-   binding level.  Since there are no non-toplevel namespace levels,\n-   this really means any namespace or template parameter level.  We\n-   also include a class whose context is toplevel.  */\n-\n-int\n-toplevel_bindings_p (void)\n-{\n-  struct cp_binding_level *b = innermost_nonclass_level ();\n-\n-  return b->kind == sk_namespace || b->kind == sk_template_parms;\n-}\n-\n-/* Nonzero if this is a namespace scope, or if we are defining a class\n-   which is itself at namespace scope, or whose enclosing class is\n-   such a class, etc.  */\n-\n-int\n-namespace_bindings_p (void)\n-{\n-  struct cp_binding_level *b = innermost_nonclass_level ();\n-\n-  return b->kind == sk_namespace;\n-}\n-\n-/* If KEEP is true, make a BLOCK node for the next binding level,\n-   unconditionally.  Otherwise, use the normal logic to decide whether\n-   or not to create a BLOCK.  */\n-\n-void\n-keep_next_level (bool keep)\n-{\n-  keep_next_level_flag = keep;\n-}\n-\n-/* Nonzero if the current level needs to have a BLOCK made.  */\n-\n-int\n-kept_level_p (void)\n-{\n-  return (current_binding_level->blocks != NULL_TREE\n-\t  || current_binding_level->keep\n-          || current_binding_level->kind == sk_cleanup\n-\t  || current_binding_level->names != NULL_TREE\n-\t  || current_binding_level->type_decls != NULL);\n-}\n-\n-/* Returns the kind of the innermost scope.  */\n-\n-scope_kind\n-innermost_scope_kind (void)\n-{\n-  return current_binding_level->kind;\n-}\n-\n-/* Returns nonzero if this scope was created to store template\n-   parameters.  */\n-\n-int\n-template_parm_scope_p (void)\n-{\n-  return innermost_scope_kind () == sk_template_parms;\n-}\n-\n /* Returns the kind of template specialization we are currently\n    processing, given that it's declaration contained N_CLASS_SCOPES\n    explicit scope qualifications.  */\n@@ -693,28 +356,6 @@ current_tmpl_spec_kind (int n_class_scopes)\n     return innermost_specialization_p ? tsk_expl_spec : tsk_template;\n }\n \n-void\n-set_class_shadows (tree shadows)\n-{\n-  class_binding_level->class_shadowed = shadows;\n-}\n-\n-/* We're defining an object of type TYPE.  If it needs a cleanup, but\n-   we're not allowed to add any more objects with cleanups to the current\n-   scope, create a new binding level.  */\n-\n-void\n-maybe_push_cleanup_level (tree type)\n-{\n-  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n-      && current_binding_level->more_cleanups_ok == 0)\n-    {\n-      begin_scope (sk_cleanup, NULL);\n-      clear_last_expr ();\n-      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n-    }\n-}\n-\n /* Exit the current scope.  */\n \n void\n@@ -723,192 +364,6 @@ finish_scope (void)\n   poplevel (0, 0, 0);\n }\n \n-/* Make DECL the innermost binding for ID.  The LEVEL is the binding\n-   level at which this declaration is being bound.  */\n-\n-static void\n-push_binding (tree id, tree decl, cxx_scope* level)\n-{\n-   cxx_binding *binding = cxx_binding_make (decl, NULL);\n-\n-  /* Now, fill in the binding information.  */\n-  binding->previous = IDENTIFIER_BINDING (id);\n-  binding->scope = level;\n-  INHERITED_VALUE_BINDING_P (binding) = 0;\n-  LOCAL_BINDING_P (binding) = (level != class_binding_level);\n-\n-  /* And put it on the front of the list of bindings for ID.  */\n-  IDENTIFIER_BINDING (id) = binding;\n-}\n-\n-/* Add DECL to the list of things declared in B.  */\n-\n-static void\n-add_decl_to_level (tree decl, \n-                   struct cp_binding_level* b)\n-{\n-  if (TREE_CODE (decl) == NAMESPACE_DECL \n-      && !DECL_NAMESPACE_ALIAS (decl))\n-    {\n-      TREE_CHAIN (decl) = b->namespaces;\n-      b->namespaces = decl;\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n-    {\n-      TREE_CHAIN (decl) = b->vtables;\n-      b->vtables = decl;\n-    }\n-  else       \n-    {\n-      /* We build up the list in reverse order, and reverse it later if\n-         necessary.  */\n-      TREE_CHAIN (decl) = b->names;\n-      b->names = decl;\n-      b->names_size++;\n-\n-      /* If appropriate, add decl to separate list of statics */\n-      if (b->kind == sk_namespace)\n-\tif ((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n-\t    || (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))\n-\t  VARRAY_PUSH_TREE (b->static_decls, decl);\n-    }\n-}\n-\n-/* Bind DECL to ID in the current_binding_level, assumed to be a local\n-   binding level.  If PUSH_USING is set in FLAGS, we know that DECL\n-   doesn't really belong to this binding level, that it got here\n-   through a using-declaration.  */\n-\n-void\n-push_local_binding (tree id, tree decl, int flags)\n-{\n-  struct cp_binding_level *b;\n-\n-  /* Skip over any local classes.  This makes sense if we call\n-     push_local_binding with a friend decl of a local class.  */\n-  b = innermost_nonclass_level ();\n-\n-  if (lookup_name_current_level (id))\n-    {\n-      /* Supplement the existing binding.  */\n-      if (!supplement_binding (IDENTIFIER_BINDING (id), decl))\n-\t/* It didn't work.  Something else must be bound at this\n-\t   level.  Do not add DECL to the list of things to pop\n-\t   later.  */\n-\treturn;\n-    }\n-  else\n-    /* Create a new binding.  */\n-    push_binding (id, decl, b);\n-\n-  if (TREE_CODE (decl) == OVERLOAD || (flags & PUSH_USING))\n-    /* We must put the OVERLOAD into a TREE_LIST since the\n-       TREE_CHAIN of an OVERLOAD is already used.  Similarly for\n-       decls that got here through a using-declaration.  */\n-    decl = build_tree_list (NULL_TREE, decl);\n-\n-  /* And put DECL on the list of things declared by the current\n-     binding level.  */\n-  add_decl_to_level (decl, b);\n-}\n-\n-/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the\n-   binding was successful.  */\n-\n-int\n-push_class_binding (tree id, tree decl)\n-{\n-  int result = 1;\n-  cxx_binding *binding = IDENTIFIER_BINDING (id);\n-  tree context;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Note that we declared this value so that we can issue an error if\n-     this is an invalid redeclaration of a name already used for some\n-     other purpose.  */\n-  note_name_declared_in_class (id, decl);\n-\n-  if (binding && binding->scope == class_binding_level)\n-    /* Supplement the existing binding.  */\n-    result = supplement_binding (IDENTIFIER_BINDING (id), decl);\n-  else\n-    /* Create a new binding.  */\n-    push_binding (id, decl, class_binding_level);\n-\n-  /* Update the IDENTIFIER_CLASS_VALUE for this ID to be the\n-     class-level declaration.  Note that we do not use DECL here\n-     because of the possibility of the `struct stat' hack; if DECL is\n-     a class-name or enum-name we might prefer a field-name, or some\n-     such.  */\n-  IDENTIFIER_CLASS_VALUE (id) = IDENTIFIER_BINDING (id)->value;\n-\n-  /* If this is a binding from a base class, mark it as such.  */\n-  binding = IDENTIFIER_BINDING (id);\n-  if (binding->value == decl && TREE_CODE (decl) != TREE_LIST)\n-    {\n-      if (TREE_CODE (decl) == OVERLOAD)\n-\tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n-      else\n-\t{\n-\t  my_friendly_assert (DECL_P (decl), 0);\n-\t  context = context_for_name_lookup (decl);\n-\t}\n-\n-      if (is_properly_derived_from (current_class_type, context))\n-\tINHERITED_VALUE_BINDING_P (binding) = 1;\n-      else\n-\tINHERITED_VALUE_BINDING_P (binding) = 0;\n-    }\n-  else if (binding->value == decl)\n-    /* We only encounter a TREE_LIST when push_class_decls detects an\n-       ambiguity.  Such an ambiguity can be overridden by a definition\n-       in this class.  */\n-    INHERITED_VALUE_BINDING_P (binding) = 1;\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result);\n-}\n-\n-/* Remove the binding for DECL which should be the innermost binding\n-   for ID.  */\n-\n-static void\n-pop_binding (tree id, tree decl)\n-{\n-  cxx_binding *binding;\n-\n-  if (id == NULL_TREE)\n-    /* It's easiest to write the loops that call this function without\n-       checking whether or not the entities involved have names.  We\n-       get here for such an entity.  */\n-    return;\n-\n-  /* Get the innermost binding for ID.  */\n-  binding = IDENTIFIER_BINDING (id);\n-\n-  /* The name should be bound.  */\n-  my_friendly_assert (binding != NULL, 0);\n-\n-  /* The DECL will be either the ordinary binding or the type\n-     binding for this identifier.  Remove that binding.  */\n-  if (binding->value == decl)\n-    binding->value = NULL_TREE;\n-  else if (binding->type == decl)\n-    binding->type = NULL_TREE;\n-  else\n-    abort ();\n-\n-  if (!binding->value && !binding->type)\n-    {\n-      /* We're completely done with the innermost binding for this\n-\t identifier.  Unhook it from the list of bindings.  */\n-      IDENTIFIER_BINDING (id) = binding->previous;\n-\n-      /* Add it to the free list.  */\n-      cxx_binding_free (binding);\n-    }\n-}\n-\n /* When a label goes out of scope, check to see if that label was used\n    in a valid manner, and issue any appropriate warnings or errors.  */\n \n@@ -1319,109 +774,6 @@ set_block (tree block ATTRIBUTE_UNUSED )\n      but it is not applicable in function-at-a-time mode.  */\n }\n \n-/* Do a pushlevel for class declarations.  */\n-\n-void\n-pushlevel_class (void)\n-{\n-  if (ENABLE_SCOPE_CHECKING)\n-    is_class_level = 1;\n-\n-  class_binding_level = begin_scope (sk_class, current_class_type);\n-}\n-\n-/* ...and a poplevel for class declarations.  */\n-\n-void\n-poplevel_class (void)\n-{\n-  register struct cp_binding_level *level = class_binding_level;\n-  tree shadowed;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (level != 0, 354);\n-\n-  /* If we're leaving a toplevel class, don't bother to do the setting\n-     of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n-     shouldn't even be used when current_class_type isn't set, and second,\n-     if we don't touch it here, we're able to use the cache effect if the\n-     next time we're entering a class scope, it is the same class.  */\n-  if (current_class_depth != 1)\n-    {\n-      struct cp_binding_level* b;\n-\n-      /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n-      for (shadowed = level->class_shadowed;\n-\t   shadowed;\n-\t   shadowed = TREE_CHAIN (shadowed))\n-\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = NULL_TREE;\n-\n-      /* Find the next enclosing class, and recreate\n-\t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n-      b = level->level_chain;\n-      while (b && b->kind != sk_class)\n-\tb = b->level_chain;\n-\n-      if (b)\n-\tfor (shadowed = b->class_shadowed;\n-\t     shadowed;\n-\t     shadowed = TREE_CHAIN (shadowed))\n-\t  {\n-\t    cxx_binding *binding;\n-            \n-\t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n-\t    while (binding && binding->scope != b)\n-\t      binding = binding->previous;\n-\n-\t    if (binding)\n-\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n-\t\t= binding->value;\n-\t  }\n-    }\n-  else\n-    /* Remember to save what IDENTIFIER's were bound in this scope so we\n-       can recover from cache misses.  */\n-    {\n-      previous_class_type = current_class_type;\n-      previous_class_values = class_binding_level->class_shadowed;\n-    }\n-  for (shadowed = level->type_shadowed;\n-       shadowed;\n-       shadowed = TREE_CHAIN (shadowed))\n-    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n-\n-  /* Remove the bindings for all of the class-level declarations.  */\n-  for (shadowed = level->class_shadowed;\n-       shadowed;\n-       shadowed = TREE_CHAIN (shadowed))\n-    pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n-\n-  /* Now, pop out of the binding level which we created up in the\n-     `pushlevel_class' routine.  */\n-  if (ENABLE_SCOPE_CHECKING)\n-    is_class_level = 1;\n-\n-  leave_scope ();\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n-/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE\n-   for any names in enclosing classes.  */\n-\n-void\n-clear_identifier_class_values (void)\n-{\n-  tree t;\n-\n-  if (!class_binding_level)\n-    return;\n-\n-  for (t = class_binding_level->class_shadowed;\n-       t;\n-       t = TREE_CHAIN (t))\n-    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n-}\n-\n /* Returns nonzero if T is a virtual function table.  */\n \n int\n@@ -1441,14 +793,6 @@ vtype_decl_p (tree t, void *data ATTRIBUTE_UNUSED )\n \t  && TYPE_POLYMORPHIC_P (TREE_TYPE (t)));\n }\n \n-/* Return the declarations that are members of the namespace NS.  */\n-\n-tree\n-cp_namespace_decls (tree ns)\n-{\n-  return NAMESPACE_LEVEL (ns)->names;\n-}\n-\n struct walk_globals_data {\n   walk_globals_pred p;\n   walk_globals_fn f;\n@@ -1491,693 +835,100 @@ walk_vtables (walk_globals_pred p, walk_globals_fn f, void *data)\n /* Walk all the namespaces contained NAMESPACE, including NAMESPACE\n    itself, calling F for each.  The DATA is passed to F as well.  */\n \n-static int\n-walk_namespaces_r (tree namespace, walk_namespaces_fn f, void* data)\n-{\n-  int result = 0;\n-  tree current = NAMESPACE_LEVEL (namespace)->namespaces;     \n-\n-  result |= (*f) (namespace, data);\n-\n-  for (; current; current = TREE_CHAIN (current))\n-    result |= walk_namespaces_r (current, f, data);\n-\n-  return result;\n-}\n-\n-/* Walk all the namespaces, calling F for each.  The DATA is passed to\n-   F as well.  */\n-\n-int\n-walk_namespaces (walk_namespaces_fn f, void* data)\n-{\n-  return walk_namespaces_r (global_namespace, f, data);\n-}\n-\n-/* Walk the global declarations in NAMESPACE.  Whenever one is found\n-   for which P returns nonzero, call F with its address.  If any call\n-   to F returns a nonzero value, return a nonzero value.  */\n-\n-static int\n-walk_globals_r (tree namespace, void* data)\n-{\n-  struct walk_globals_data* wgd = (struct walk_globals_data *) data;\n-  walk_globals_pred p = wgd->p;\n-  walk_globals_fn f = wgd->f;\n-  void *d = wgd->data;\n-  tree *t;\n-  int result = 0;\n-\n-  t = &NAMESPACE_LEVEL (namespace)->names;\n-\n-  while (*t)\n-    {\n-      tree glbl = *t;\n-\n-      if ((*p) (glbl, d))\n-\tresult |= (*f) (t, d);\n-\n-      /* If F changed *T, then *T still points at the next item to\n-\t examine.  */\n-      if (*t == glbl)\n-\tt = &TREE_CHAIN (*t);\n-    }\n-\n-  return result;\n-}\n-\n-/* Walk the global declarations.  Whenever one is found for which P\n-   returns true, call F with its address.  If any call to F\n-   returns true, return true.  */\n-\n-bool\n-walk_globals (walk_globals_pred p, walk_globals_fn f, void *data)\n-{\n-  struct walk_globals_data wgd;\n-  wgd.p = p;\n-  wgd.f = f;\n-  wgd.data = data;\n-\n-  return walk_namespaces (walk_globals_r, &wgd);\n-}\n-\n-/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If\n-   DATA is non-NULL, this is the last time we will call\n-   wrapup_global_declarations for this NAMESPACE.  */\n-\n-int\n-wrapup_globals_for_namespace (tree namespace, void* data)\n-{\n-  struct cp_binding_level *level = NAMESPACE_LEVEL (namespace);\n-  varray_type statics = level->static_decls;\n-  tree *vec = &VARRAY_TREE (statics, 0);\n-  int len = VARRAY_ACTIVE_SIZE (statics);\n-  int last_time = (data != 0);\n-\n-  if (last_time)\n-    {\n-      check_global_declarations (vec, len);\n-      return 0;\n-    }\n-\n-  /* Write out any globals that need to be output.  */\n-  return wrapup_global_declarations (vec, len);\n-}\n-\n-\f\n-/* For debugging.  */\n-static int no_print_functions = 0;\n-static int no_print_builtins = 0;\n-\n-/* Called from print_binding_level through binding_table_foreach to\n-   print the content of binding ENTRY.  DATA is a pointer to line offset\n-   marker.  */\n-static void\n-bt_print_entry (binding_entry entry, void *data)\n-{\n-  int *p = (int *) data;\n-  int len;\n-\n-  if (entry->name == NULL)\n-    len = 3;\n-  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n-    len = 2;\n-  else\n-    len = 4;\n-    len = 4;\n-\n-  *p += len;\n-\n-  if (*p > 5)\n-    {\n-      fprintf (stderr, \"\\n\\t\");\n-      *p = len;\n-    }\n-  if (entry->name == NULL)\n-    {\n-      print_node_brief (stderr, \"<unnamed-typedef\", entry->type, 0);\n-      fprintf (stderr, \">\");\n-    }\n-  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n-    print_node_brief (stderr, \"\", entry->type, 0);\n-  else\n-    {\n-      print_node_brief (stderr, \"<typedef\", entry->name, 0);\n-      print_node_brief (stderr, \"\", entry->type, 0);\n-      fprintf (stderr, \">\");\n-    }\n-}\n-\n-void\n-print_binding_level (struct cp_binding_level* lvl)\n-{\n-  tree t;\n-  int i = 0, len;\n-  fprintf (stderr, \" blocks=\" HOST_PTR_PRINTF, (void *) lvl->blocks);\n-  if (lvl->more_cleanups_ok)\n-    fprintf (stderr, \" more-cleanups-ok\");\n-  if (lvl->have_cleanups)\n-    fprintf (stderr, \" have-cleanups\");\n-  fprintf (stderr, \"\\n\");\n-  if (lvl->names)\n-    {\n-      fprintf (stderr, \" names:\\t\");\n-      /* We can probably fit 3 names to a line?  */\n-      for (t = lvl->names; t; t = TREE_CHAIN (t))\n-\t{\n-\t  if (no_print_functions && (TREE_CODE (t) == FUNCTION_DECL))\n-\t    continue;\n-\t  if (no_print_builtins\n-\t      && (TREE_CODE (t) == TYPE_DECL)\n-\t      && (!strcmp (DECL_SOURCE_FILE (t),\"<built-in>\")))\n-\t    continue;\n-\n-\t  /* Function decls tend to have longer names.  */\n-\t  if (TREE_CODE (t) == FUNCTION_DECL)\n-\t    len = 3;\n-\t  else\n-\t    len = 2;\n-\t  i += len;\n-\t  if (i > 6)\n-\t    {\n-\t      fprintf (stderr, \"\\n\\t\");\n-\t      i = len;\n-\t    }\n-\t  print_node_brief (stderr, \"\", t, 0);\n-\t  if (t == error_mark_node)\n-\t    break;\n-\t}\n-      if (i)\n-        fprintf (stderr, \"\\n\");\n-    }\n-  if (lvl->type_decls)\n-    {\n-      fprintf (stderr, \" tags:\\t\");\n-      i = 0;\n-      binding_table_foreach (lvl->type_decls, bt_print_entry, &i);\n-      if (i)\n-\tfprintf (stderr, \"\\n\");\n-    }\n-  if (lvl->class_shadowed)\n-    {\n-      fprintf (stderr, \" class-shadowed:\");\n-      for (t = lvl->class_shadowed; t; t = TREE_CHAIN (t))\n-\t{\n-\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-\t}\n-      fprintf (stderr, \"\\n\");\n-    }\n-  if (lvl->type_shadowed)\n-    {\n-      fprintf (stderr, \" type-shadowed:\");\n-      for (t = lvl->type_shadowed; t; t = TREE_CHAIN (t))\n-        {\n-\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n-        }\n-      fprintf (stderr, \"\\n\");\n-    }\n-}\n-\n-void\n-print_other_binding_stack (struct cp_binding_level *stack)\n-{\n-  struct cp_binding_level *level;\n-  for (level = stack; !global_scope_p (level); level = level->level_chain)\n-    {\n-      fprintf (stderr, \"binding level \" HOST_PTR_PRINTF \"\\n\", (void *) level);\n-      print_binding_level (level);\n-    }\n-}\n-\n-void\n-print_binding_stack (void)\n-{\n-  struct cp_binding_level *b;\n-  fprintf (stderr, \"current_binding_level=\" HOST_PTR_PRINTF\n-\t   \"\\nclass_binding_level=\" HOST_PTR_PRINTF\n-\t   \"\\nNAMESPACE_LEVEL (global_namespace)=\" HOST_PTR_PRINTF \"\\n\",\n-\t   (void *) current_binding_level, (void *) class_binding_level,\n-           (void *) NAMESPACE_LEVEL (global_namespace));\n-  if (class_binding_level)\n-    {\n-      for (b = class_binding_level; b; b = b->level_chain)\n-\tif (b == current_binding_level)\n-\t  break;\n-      if (b)\n-\tb = class_binding_level;\n-      else\n-\tb = current_binding_level;\n-    }\n-  else\n-    b = current_binding_level;\n-  print_other_binding_stack (b);\n-  fprintf (stderr, \"global:\\n\");\n-  print_binding_level (NAMESPACE_LEVEL (global_namespace));\n-}\n-\n-/* Namespace binding access routines: The namespace_bindings field of\n-   the identifier is polymorphic, with three possible values:\n-   NULL_TREE, a list of \"cxx_binding\"s.  */\n-\n-/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n-   select a name that is unique to this compilation unit.  */\n-\n-void\n-push_namespace (tree name)\n-{\n-  tree d = NULL_TREE;\n-  int need_new = 1;\n-  int implicit_use = 0;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  \n-  /* We should not get here if the global_namespace is not yet constructed\n-     nor if NAME designates the global namespace:  The global scope is\n-     constructed elsewhere.  */\n-  my_friendly_assert (global_namespace != NULL && name != global_scope_name,\n-                      20030531);\n-\n-  if (!name)\n-    {\n-      /* The name of anonymous namespace is unique for the translation\n-         unit.  */\n-      if (!anonymous_namespace_name)\n-        anonymous_namespace_name = get_file_function_name ('N');\n-      name = anonymous_namespace_name;\n-      d = IDENTIFIER_NAMESPACE_VALUE (name);\n-      if (d)\n-        /* Reopening anonymous namespace.  */\n-        need_new = 0;\n-      implicit_use = 1;\n-    }\n-  else\n-    {\n-      /* Check whether this is an extended namespace definition.  */\n-      d = IDENTIFIER_NAMESPACE_VALUE (name);\n-      if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n-        {\n-          need_new = 0;\n-          if (DECL_NAMESPACE_ALIAS (d))\n-            {\n-              error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n-                        d, DECL_NAMESPACE_ALIAS (d));\n-              d = DECL_NAMESPACE_ALIAS (d);\n-            }\n-        }\n-    }\n-\n-  if (need_new)\n-    {\n-      /* Make a new namespace, binding the name to it.  */\n-      d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-      DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n-      d = pushdecl (d);\n-      begin_scope (sk_namespace, d);\n-    }\n-  else\n-    resume_binding_level (NAMESPACE_LEVEL (d));\n-\n-  if (implicit_use)\n-    do_using_directive (d);\n-  /* Enter the name space.  */\n-  current_namespace = d;\n-\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n-/* Pop from the scope of the current namespace.  */\n-\n-void\n-pop_namespace (void)\n-{\n-  my_friendly_assert (current_namespace != global_namespace, 20010801);\n-  current_namespace = CP_DECL_CONTEXT (current_namespace);\n-  /* The binding level is not popped, as it might be re-opened later.  */\n-  leave_scope ();\n-}\n-\n-/* Push into the scope of the namespace NS, even if it is deeply\n-   nested within another namespace.  */\n-\n-void\n-push_nested_namespace (tree ns)\n-{\n-  if (ns == global_namespace)\n-    push_to_top_level ();\n-  else\n-    {\n-      push_nested_namespace (CP_DECL_CONTEXT (ns));\n-      push_namespace (DECL_NAME (ns));\n-    }\n-}\n-\n-/* Pop back from the scope of the namespace NS, which was previously\n-   entered with push_nested_namespace.  */\n-\n-void\n-pop_nested_namespace (tree ns)\n-{\n-  timevar_push (TV_NAME_LOOKUP);\n-  while (ns != global_namespace)\n-    {\n-      pop_namespace ();\n-      ns = CP_DECL_CONTEXT (ns);\n-    }\n-\n-  pop_from_top_level ();\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n-\f\n-/* Allocate storage for saving a C++ binding.  */\n-#define cxx_saved_binding_make() \\\n-  (ggc_alloc (sizeof (cxx_saved_binding)))\n-\n-struct cxx_saved_binding GTY(())\n-{\n-  /* Link that chains saved C++ bindings for a given name into a stack.  */\n-  cxx_saved_binding *previous;\n-  /* The name of the current binding.  */\n-  tree identifier;\n-  /* The binding we're saving.  */\n-  cxx_binding *binding;\n-  tree class_value;\n-  tree real_type_value;\n-};\n-\n-/* Subroutines for reverting temporarily to top-level for instantiation\n-   of templates and such.  We actually need to clear out the class- and\n-   local-value slots of all identifiers, so that only the global values\n-   are at all visible.  Simply setting current_binding_level to the global\n-   scope isn't enough, because more binding levels may be pushed.  */\n-struct saved_scope *scope_chain;\n-\n-static cxx_saved_binding *\n-store_bindings (tree names, cxx_saved_binding *old_bindings)\n-{\n-  tree t;\n-  cxx_saved_binding *search_bindings = old_bindings;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  for (t = names; t; t = TREE_CHAIN (t))\n-    {\n-      tree id;\n-      cxx_saved_binding *saved;\n-      cxx_saved_binding *t1;\n-\n-      if (TREE_CODE (t) == TREE_LIST)\n-\tid = TREE_PURPOSE (t);\n-      else\n-\tid = DECL_NAME (t);\n-\n-      if (!id\n-\t  /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n-\t     we have no IDENTIFIER_BINDING if we have left the class\n-\t     scope, but cached the class-level declarations.  */\n-\t  || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n-\tcontinue;\n-\n-      for (t1 = search_bindings; t1; t1 = t1->previous)\n-\tif (t1->identifier == id)\n-\t  goto skip_it;\n-\n-      my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n-      saved = cxx_saved_binding_make ();\n-      saved->previous = old_bindings;\n-      saved->identifier = id;\n-      saved->binding = IDENTIFIER_BINDING (id);\n-      saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n-      saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      IDENTIFIER_BINDING (id) = NULL;\n-      IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n-      old_bindings = saved;\n-    skip_it:\n-      ;\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n-}\n-\n-void\n-maybe_push_to_top_level (int pseudo)\n-{\n-  struct saved_scope *s;\n-  struct cp_binding_level *b;\n-  cxx_saved_binding *old_bindings;\n-  int need_pop;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  s = ggc_alloc_cleared (sizeof (struct saved_scope));\n-\n-  b = scope_chain ? current_binding_level : 0;\n-\n-  /* If we're in the middle of some function, save our state.  */\n-  if (cfun)\n-    {\n-      need_pop = 1;\n-      push_function_context_to (NULL_TREE);\n-    }\n-  else\n-    need_pop = 0;\n-\n-  old_bindings = NULL;\n-  if (scope_chain && previous_class_type)\n-    old_bindings = store_bindings (previous_class_values, old_bindings);\n-\n-  /* Have to include the global scope, because class-scope decls\n-     aren't listed anywhere useful.  */\n-  for (; b; b = b->level_chain)\n-    {\n-      tree t;\n-\n-      /* Template IDs are inserted into the global level. If they were\n-\t inserted into namespace level, finish_file wouldn't find them\n-\t when doing pending instantiations. Therefore, don't stop at\n-\t namespace level, but continue until :: .  */\n-      if (global_scope_p (b) || (pseudo && b->kind == sk_template_parms))\n-\tbreak;\n+static int\n+walk_namespaces_r (tree namespace, walk_namespaces_fn f, void* data)\n+{\n+  int result = 0;\n+  tree current = NAMESPACE_LEVEL (namespace)->namespaces;     \n \n-      old_bindings = store_bindings (b->names, old_bindings);\n-      /* We also need to check class_shadowed to save class-level type\n-\t bindings, since pushclass doesn't fill in b->names.  */\n-      if (b->kind == sk_class)\n-\told_bindings = store_bindings (b->class_shadowed, old_bindings);\n+  result |= (*f) (namespace, data);\n \n-      /* Unwind type-value slots back to top level.  */\n-      for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n-\tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n-    }\n-  s->prev = scope_chain;\n-  s->old_bindings = old_bindings;\n-  s->bindings = b;\n-  s->need_pop_function_context = need_pop;\n-  s->function_decl = current_function_decl;\n-  s->last_parms = last_function_parms;\n+  for (; current; current = TREE_CHAIN (current))\n+    result |= walk_namespaces_r (current, f, data);\n \n-  scope_chain = s;\n-  current_function_decl = NULL_TREE;\n-  VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n-  current_lang_name = lang_name_cplusplus;\n-  current_namespace = global_namespace;\n-  timevar_pop (TV_NAME_LOOKUP);\n+  return result;\n }\n \n-void\n-push_to_top_level (void)\n+/* Walk all the namespaces, calling F for each.  The DATA is passed to\n+   F as well.  */\n+\n+int\n+walk_namespaces (walk_namespaces_fn f, void* data)\n {\n-  maybe_push_to_top_level (0);\n+  return walk_namespaces_r (global_namespace, f, data);\n }\n \n-void\n-pop_from_top_level (void)\n-{\n-  struct saved_scope *s = scope_chain;\n-  cxx_saved_binding *saved;\n+/* Walk the global declarations in NAMESPACE.  Whenever one is found\n+   for which P returns nonzero, call F with its address.  If any call\n+   to F returns a nonzero value, return a nonzero value.  */\n \n-  timevar_push (TV_NAME_LOOKUP); \n-  /* Clear out class-level bindings cache.  */\n-  if (previous_class_type)\n-    invalidate_class_lookup_cache ();\n+static int\n+walk_globals_r (tree namespace, void* data)\n+{\n+  struct walk_globals_data* wgd = (struct walk_globals_data *) data;\n+  walk_globals_pred p = wgd->p;\n+  walk_globals_fn f = wgd->f;\n+  void *d = wgd->data;\n+  tree *t;\n+  int result = 0;\n \n-  current_lang_base = 0;\n+  t = &NAMESPACE_LEVEL (namespace)->names;\n \n-  scope_chain = s->prev;\n-  for (saved = s->old_bindings; saved; saved = saved->previous)\n+  while (*t)\n     {\n-      tree id = saved->identifier;\n-\n-      IDENTIFIER_BINDING (id) = saved->binding;\n-      IDENTIFIER_CLASS_VALUE (id) = saved->class_value;\n-      SET_IDENTIFIER_TYPE_VALUE (id, saved->real_type_value);\n-    }\n-\n-  /* If we were in the middle of compiling a function, restore our\n-     state.  */\n-  if (s->need_pop_function_context)\n-    pop_function_context_from (NULL_TREE);\n-  current_function_decl = s->function_decl;\n-  last_function_parms = s->last_parms;\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\f\n-/* Push a definition of struct, union or enum tag named ID.  into\n-   binding_level B.  DECL is a TYPE_DECL for the type.  We assume that\n-   the tag ID is not already defined.  */\n+      tree glbl = *t;\n \n-static void\n-set_identifier_type_value_with_scope (tree id, \n-                                      tree decl,\n-                                      struct cp_binding_level* b)\n-{\n-  tree type;\n+      if ((*p) (glbl, d))\n+\tresult |= (*f) (t, d);\n \n-  if (b->kind != sk_namespace)\n-    {\n-      /* Shadow the marker, not the real thing, so that the marker\n-\t gets restored later.  */\n-      tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n-      b->type_shadowed\n-\t= tree_cons (id, old_type_value, b->type_shadowed);\n-      type = decl ? TREE_TYPE (decl) : NULL_TREE;\n-    }\n-  else\n-    {\n-      cxx_binding *binding =\n-\tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n-      if (decl)\n-\t{\n-\t  if (binding->value)\n-\t    supplement_binding (binding, decl);\n-\t  else\n-\t    binding->value = decl;\n-\t}\n-      else\n-\tabort ();\n-      /* Store marker instead of real type.  */\n-      type = global_type_node;\n+      /* If F changed *T, then *T still points at the next item to\n+\t examine.  */\n+      if (*t == glbl)\n+\tt = &TREE_CHAIN (*t);\n     }\n-  SET_IDENTIFIER_TYPE_VALUE (id, type);\n-}\n \n-/* As set_identifier_type_value_with_scope, but using current_binding_level.  */\n-\n-void\n-set_identifier_type_value (tree id, tree decl)\n-{\n-  set_identifier_type_value_with_scope (id, decl, current_binding_level);\n+  return result;\n }\n \n-/* Return the type associated with id.  */\n+/* Walk the global declarations.  Whenever one is found for which P\n+   returns true, call F with its address.  If any call to F\n+   returns true, return true.  */\n \n-tree\n-identifier_type_value (tree id)\n+bool\n+walk_globals (walk_globals_pred p, walk_globals_fn f, void *data)\n {\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* There is no type with that name, anywhere.  */\n-  if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-  /* This is not the type marker, but the real thing.  */\n-  if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n-  /* Have to search for it. It must be on the global level, now.\n-     Ask lookup_name not to return non-types.  */\n-  id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n-  if (id)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-}\n-\n-/* Pop off extraneous binding levels left over due to syntax errors.\n-\n-   We don't pop past namespaces, as they might be valid.  */\n+  struct walk_globals_data wgd;\n+  wgd.p = p;\n+  wgd.f = f;\n+  wgd.data = data;\n \n-void\n-pop_everything (void)\n-{\n-  if (ENABLE_SCOPE_CHECKING)\n-    verbatim (\"XXX entering pop_everything ()\\n\");\n-  while (!toplevel_bindings_p ())\n-    {\n-      if (current_binding_level->kind == sk_class)\n-\tpop_nested_class ();\n-      else\n-\tpoplevel (0, 0, 0);\n-    }\n-  if (ENABLE_SCOPE_CHECKING)\n-    verbatim (\"XXX leaving pop_everything ()\\n\");\n+  return walk_namespaces (walk_globals_r, &wgd);\n }\n \n-/* The type TYPE is being declared.  If it is a class template, or a\n-   specialization of a class template, do any processing required and\n-   perform error-checking.  If IS_FRIEND is nonzero, this TYPE is\n-   being declared a friend.  B is the binding level at which this TYPE\n-   should be bound.\n-\n-   Returns the TYPE_DECL for TYPE, which may have been altered by this\n-   processing.  */\n+/* Call wrapup_globals_declarations for the globals in NAMESPACE.  If\n+   DATA is non-NULL, this is the last time we will call\n+   wrapup_global_declarations for this NAMESPACE.  */\n \n-static tree\n-maybe_process_template_type_declaration (tree type, \n-                                         int globalize, \n-                                         struct cp_binding_level* b)\n+int\n+wrapup_globals_for_namespace (tree namespace, void* data)\n {\n-  tree decl = TYPE_NAME (type);\n-\n-  if (processing_template_parmlist)\n-    /* You can't declare a new template type in a template parameter\n-       list.  But, you can declare a non-template type:\n-\n-         template <class A*> struct S;\n+  struct cp_binding_level *level = NAMESPACE_LEVEL (namespace);\n+  varray_type statics = level->static_decls;\n+  tree *vec = &VARRAY_TREE (statics, 0);\n+  int len = VARRAY_ACTIVE_SIZE (statics);\n+  int last_time = (data != 0);\n \n-       is a forward-declaration of `A'.  */\n-    ;\n-  else\n+  if (last_time)\n     {\n-      maybe_check_template_type (type);\n-\n-      my_friendly_assert (IS_AGGR_TYPE (type)\n-\t\t\t  || TREE_CODE (type) == ENUMERAL_TYPE, 0);\n-\n-\n-      if (processing_template_decl)\n-\t{\n-\t  /* This may change after the call to\n-\t     push_template_decl_real, but we want the original value.  */\n-\t  tree name = DECL_NAME (decl);\n-\n-\t  decl = push_template_decl_real (decl, globalize);\n-\t  /* If the current binding level is the binding level for the\n-\t     template parameters (see the comment in\n-\t     begin_template_parm_list) and the enclosing level is a class\n-\t     scope, and we're not looking at a friend, push the\n-\t     declaration of the member class into the class scope.  In the\n-\t     friend case, push_template_decl will already have put the\n-\t     friend into global scope, if appropriate.  */\n-\t  if (TREE_CODE (type) != ENUMERAL_TYPE\n-\t      && !globalize && b->kind == sk_template_parms\n-\t      && b->level_chain->kind == sk_class)\n-\t    {\n-\t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n-\t      /* Put this UDT in the table of UDTs for the class, since\n-\t\t that won't happen below because B is not the class\n-\t\t binding level, but is instead the pseudo-global level.  */\n-              if (b->level_chain->type_decls == NULL)\n-                b->level_chain->type_decls =\n-                  binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-              binding_table_insert (b->level_chain->type_decls, name, type);\n-\t      if (!COMPLETE_TYPE_P (current_class_type))\n-\t\t{\n-\t\t  maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t\t      type, /*friend_p=*/0);\n-\t\t  CLASSTYPE_NESTED_UTDS (current_class_type) =\n-                    b->level_chain->type_decls;\n-\t\t}\n-\t    }\n-\t}\n+      check_global_declarations (vec, len);\n+      return 0;\n     }\n \n-  return decl;\n+  /* Write out any globals that need to be output.  */\n+  return wrapup_global_declarations (vec, len);\n }\n \n+\f\n /* In C++, you don't have to write `struct S' to refer to `S'; you\n    can just use `S'.  We accomplish this by creating a TYPE_DECL as\n    if the user had written `typedef struct S S'.  Create and return\n@@ -2237,130 +988,6 @@ push_local_name (tree decl)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n-/* Push a tag name NAME for struct/class/union/enum type TYPE.\n-   Normally put it into the inner-most non-sk_cleanup scope,\n-   but if GLOBALIZE is true, put it in the inner-most non-class scope.\n-   The latter is needed for implicit declarations.  */\n-\n-void\n-pushtag (tree name, tree type, int globalize)\n-{\n-  register struct cp_binding_level *b;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  b = current_binding_level;\n-  while (b->kind == sk_cleanup\n-\t || (b->kind == sk_class\n-\t     && (globalize\n-\t\t /* We may be defining a new type in the initializer\n-\t\t    of a static member variable. We allow this when\n-\t\t    not pedantic, and it is particularly useful for\n-\t\t    type punning via an anonymous union.  */\n-\t\t || COMPLETE_TYPE_P (b->this_entity))))\n-    b = b->level_chain;\n-\n-  if (b->type_decls == NULL)\n-    b->type_decls = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n-  binding_table_insert (b->type_decls, name, type);\n-\n-  if (name)\n-    {\n-      /* Do C++ gratuitous typedefing.  */\n-      if (IDENTIFIER_TYPE_VALUE (name) != type)\n-        {\n-          register tree d = NULL_TREE;\n-\t  int in_class = 0;\n-\t  tree context = TYPE_CONTEXT (type);\n-\n-\t  if (! context)\n-\t    {\n-\t      tree cs = current_scope ();\n-\n-\t      if (! globalize)\n-\t\tcontext = cs;\n-\t      else if (cs != NULL_TREE && TYPE_P (cs))\n-\t\t/* When declaring a friend class of a local class, we want\n-\t\t   to inject the newly named class into the scope\n-\t\t   containing the local class, not the namespace scope.  */\n-\t\tcontext = decl_function_context (get_type_decl (cs));\n-\t    }\n-\t  if (!context)\n-\t    context = current_namespace;\n-\n-\t  if (b->kind == sk_class\n-\t      || (b->kind == sk_template_parms \n-\t\t  && b->level_chain->kind == sk_class))\n-\t    in_class = 1;\n-\n-\t  if (current_lang_name == lang_name_java)\n-\t    TYPE_FOR_JAVA (type) = 1;\n-\n-\t  d = create_implicit_typedef (name, type);\n-\t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n-\t  if (! in_class)\n-\t    set_identifier_type_value_with_scope (name, d, b);\n-\n-\t  d = maybe_process_template_type_declaration (type,\n-\t\t\t\t\t\t       globalize, b);\n-\n-\t  if (b->kind == sk_class)\n-\t    {\n-\t      if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n-\t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n-\t\t   class.  But if it's a member template class, we\n-\t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n-\t\t   is done later.  */\n-\t\tfinish_member_declaration (d);\n-\t      else\n-\t\tpushdecl_class_level (d);\n-\t    }\n-\t  else\n-\t    d = pushdecl_with_scope (d, b);\n-\n-\t  /* FIXME what if it gets a name from typedef?  */\n-\t  if (ANON_AGGRNAME_P (name))\n-\t    DECL_IGNORED_P (d) = 1;\n-\n-\t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\n-\t  /* If this is a local class, keep track of it.  We need this\n-\t     information for name-mangling, and so that it is possible to find\n-\t     all function definitions in a translation unit in a convenient\n-\t     way.  (It's otherwise tricky to find a member function definition\n-\t     it's only pointed to from within a local class.)  */\n-\t  if (TYPE_CONTEXT (type)\n-\t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL\n-\t      && !processing_template_decl)\n-\t    VARRAY_PUSH_TREE (local_classes, type);\n-        }\n-      if (b->kind == sk_class\n-\t  && !COMPLETE_TYPE_P (current_class_type))\n-\t{\n-\t  maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t      type, /*friend_p=*/0);\n-\t  CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n-\t}\n-    }\n-\n-  if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n-    /* Use the canonical TYPE_DECL for this node.  */\n-    TYPE_STUB_DECL (type) = TYPE_NAME (type);\n-  else\n-    {\n-      /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE\n-\t will be the tagged type we just added to the current\n-\t binding level.  This fake NULL-named TYPE_DECL node helps\n-\t dwarfout.c to know when it needs to output a\n-\t representation of a tagged type, and it also gives us a\n-\t convenient place to record the \"scope start\" address for\n-\t the tagged type.  */\n-\n-      tree d = build_decl (TYPE_DECL, NULL_TREE, type);\n-      TYPE_STUB_DECL (type) = pushdecl_with_scope (d, b);\n-    }\n-  timevar_pop (TV_NAME_LOOKUP);\n-}\n-\n /* Counter used to create anonymous type names.  */\n \n static GTY(()) int anon_cnt;\n@@ -3776,81 +2403,6 @@ pushdecl (tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n-/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n-   caller to set DECL_CONTEXT properly.  */\n-\n-static tree\n-pushdecl_with_scope (tree x, struct cp_binding_level* level)\n-{\n-  register struct cp_binding_level *b;\n-  tree function_decl = current_function_decl;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  current_function_decl = NULL_TREE;\n-  if (level->kind == sk_class)\n-    {\n-      b = class_binding_level;\n-      class_binding_level = level;\n-      pushdecl_class_level (x);\n-      class_binding_level = b;\n-    }\n-  else\n-    {\n-      b = current_binding_level;\n-      current_binding_level = level;\n-      x = pushdecl (x);\n-      current_binding_level = b;\n-    }\n-  current_function_decl = function_decl;\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n-}\n-\n-/* Like pushdecl, only it places X in the current namespace,\n-   if appropriate.  */\n-\n-tree\n-pushdecl_namespace_level (tree x)\n-{\n-  register struct cp_binding_level *b = current_binding_level;\n-  register tree t;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n-\n-  /* Now, the type_shadowed stack may screw us.  Munge it so it does\n-     what we want.  */\n-  if (TREE_CODE (x) == TYPE_DECL)\n-    {\n-      tree name = DECL_NAME (x);\n-      tree newval;\n-      tree *ptr = (tree *)0;\n-      for (; !global_scope_p (b); b = b->level_chain)\n-        {\n-          tree shadowed = b->type_shadowed;\n-          for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n-            if (TREE_PURPOSE (shadowed) == name)\n-              {\n-\t\tptr = &TREE_VALUE (shadowed);\n-\t\t/* Can't break out of the loop here because sometimes\n-\t\t   a binding level will have duplicate bindings for\n-\t\t   PT names.  It's gross, but I haven't time to fix it.  */\n-              }\n-        }\n-      newval = TREE_TYPE (x);\n-      if (ptr == (tree *)0)\n-        {\n-          /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n-             up here if this is changed to an assertion.  --KR  */\n-\t  SET_IDENTIFIER_TYPE_VALUE (name, x);\n-\t}\n-      else\n-        {\n-\t  *ptr = newval;\n-        }\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-}\n-\n /* Like pushdecl, only it places X in the global scope if appropriate.\n    Calls cp_finish_decl to register the variable, initializing it with\n    *INIT, if INIT is non-NULL.  */\n@@ -3885,48 +2437,6 @@ pushdecl_top_level_and_finish (tree x, tree init)\n   return pushdecl_top_level_1 (x, &init);\n }\n \n-/* Make the declaration of X appear in CLASS scope.  */\n-\n-bool\n-pushdecl_class_level (tree x)\n-{\n-  tree name;\n-  bool is_valid = true;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Get the name of X.  */\n-  if (TREE_CODE (x) == OVERLOAD)\n-    name = DECL_NAME (get_first_fn (x));\n-  else\n-    name = DECL_NAME (x);\n-\n-  if (name)\n-    {\n-      is_valid = push_class_level_binding (name, x);\n-      if (TREE_CODE (x) == TYPE_DECL)\n-\tset_identifier_type_value (name, x);\n-    }\n-  else if (ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n-    {\n-      /* If X is an anonymous aggregate, all of its members are\n-\t treated as if they were members of the class containing the\n-\t aggregate, for naming purposes.  */\n-      tree f;\n-\n-      for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = TREE_CHAIN (f))\n-\t{\n-\t  location_t save_location = input_location;\n-\t  input_location = DECL_SOURCE_LOCATION (f);\n-\t  if (!pushdecl_class_level (f))\n-\t    is_valid = false;\n-\t  input_location = save_location;\n-\t}\n-    }\n-  timevar_pop (TV_NAME_LOOKUP);\n-\n-  return is_valid;\n-}\n-\n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n    DECL, or a modified version thereof.  */\n \n@@ -3956,97 +2466,6 @@ maybe_push_decl (tree decl)\n     return pushdecl (decl);\n }\n \n-/* Make the declaration(s) of X appear in CLASS scope under the name\n-   NAME.  Returns true if the binding is valid.  */\n-\n-bool\n-push_class_level_binding (tree name, tree x)\n-{\n-  cxx_binding *binding;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* The class_binding_level will be NULL if x is a template\n-     parameter name in a member template.  */\n-  if (!class_binding_level)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-\n-  /* Make sure that this new member does not have the same name\n-     as a template parameter.  */\n-  if (TYPE_BEING_DEFINED (current_class_type))\n-    check_template_shadow (x);\n-\n-  /* If this declaration shadows a declaration from an enclosing\n-     class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n-     we leave this class.  Record the shadowed declaration here.  */\n-  binding = IDENTIFIER_BINDING (name);\n-  if (binding && binding->value)\n-    {\n-      tree bval = binding->value;\n-      tree old_decl = NULL_TREE;\n-\n-      if (INHERITED_VALUE_BINDING_P (binding))\n-\t{\n-\t  /* If the old binding was from a base class, and was for a\n-  \t     tag name, slide it over to make room for the new binding.\n-  \t     The old binding is still visible if explicitly qualified\n-  \t     with a class-key.  */\n-\t  if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval)\n-\t      && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n-\t    {\n-\t      old_decl = binding->type;\n-\t      binding->type = bval;\n-\t      binding->value = NULL_TREE;\n-\t      INHERITED_VALUE_BINDING_P (binding) = 0;\n-\t    }\n-\t  else\n-\t    old_decl = bval;\n-\t}\n-      else if (TREE_CODE (x) == OVERLOAD && is_overloaded_fn (bval))\n-\told_decl = bval;\n-      else if (TREE_CODE (x) == USING_DECL && TREE_CODE (bval) == USING_DECL)\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-      else if (TREE_CODE (x) == USING_DECL && is_overloaded_fn (bval))\n-\told_decl = bval;\n-      else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n-\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-      \n-      if (old_decl)\n-\t{\n-\t  tree shadow;\n-\t  \n-\t  /* Find the previous binding of name on the class-shadowed\n-             list, and update it.  */\n-\t  for (shadow = class_binding_level->class_shadowed;\n-\t       shadow;\n-\t       shadow = TREE_CHAIN (shadow))\n-\t    if (TREE_PURPOSE (shadow) == name\n-\t\t&& TREE_TYPE (shadow) == old_decl)\n-\t      {\n-\t\tbinding->value = x;\n-\t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n-\t\tTREE_TYPE (shadow) = x;\n-\t\tIDENTIFIER_CLASS_VALUE (name) = x;\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-\t      }\n-\t}\n-    }\n-\n-  /* If we didn't replace an existing binding, put the binding on the\n-     stack of bindings for the identifier, and update the shadowed list.  */\n-  if (push_class_binding (name, x))\n-    {\n-      class_binding_level->class_shadowed\n-\t= tree_cons (name, NULL,\n-\t\t     class_binding_level->class_shadowed);\n-      /* Record the value we are binding NAME to so that we can know\n-\t what to pop later.  */\n-      TREE_TYPE (class_binding_level->class_shadowed) = x;\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n-}\n-\n /* Insert another USING_DECL into the current binding level, returning\n    this declaration. If this is a redeclaration, do nothing, and\n    return NULL_TREE if this not in namespace scope (in namespace\n@@ -4063,41 +2482,14 @@ push_using_decl (tree scope, tree name)\n   for (decl = current_binding_level->usings; decl; decl = TREE_CHAIN (decl))\n     if (DECL_INITIAL (decl) == scope && DECL_NAME (decl) == name)\n       break;\n-  if (decl)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                            namespace_bindings_p () ? decl : NULL_TREE);\n-  decl = build_lang_decl (USING_DECL, name, void_type_node);\n-  DECL_INITIAL (decl) = scope;\n-  TREE_CHAIN (decl) = current_binding_level->usings;\n-  current_binding_level->usings = decl;\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n-}\n-\n-/* Add namespace to using_directives. Return NULL_TREE if nothing was\n-   changed (i.e. there was already a directive), or the fresh\n-   TREE_LIST otherwise.  */\n-\n-tree\n-push_using_directive (tree used)\n-{\n-  tree ud = current_binding_level->using_directives;\n-  tree iter, ancestor;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Check if we already have this.  */\n-  if (purpose_member (used, ud) != NULL_TREE)\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\n-  ancestor = namespace_ancestor (current_decl_namespace (), used);\n-  ud = current_binding_level->using_directives;\n-  ud = tree_cons (used, ancestor, ud);\n-  current_binding_level->using_directives = ud;\n-\n-  /* Recursively add all namespaces used.  */\n-  for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n-    push_using_directive (TREE_PURPOSE (iter));\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ud);\n+  if (decl)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                            namespace_bindings_p () ? decl : NULL_TREE);\n+  decl = build_lang_decl (USING_DECL, name, void_type_node);\n+  DECL_INITIAL (decl) = scope;\n+  TREE_CHAIN (decl) = current_binding_level->usings;\n+  current_binding_level->usings = decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n }\n \n /* DECL is a FUNCTION_DECL for a non-member function, which may have\n@@ -4781,298 +3173,6 @@ finish_case_label (tree low_value, tree high_value)\n   return r;\n }\n \f\n-/* Return the list of declarations of the current level.\n-   Note that this list is in reverse order unless/until\n-   you nreverse it; and when you do nreverse it, you must\n-   store the result back using `storedecls' or you will lose.  */\n-\n-tree\n-getdecls (void)\n-{\n-  return current_binding_level->names;\n-}\n-\n-/* Store the list of declarations of the current level.\n-   This is done for the parameter declarations of a function being defined,\n-   after they are modified in the light of any missing parameters.  */\n-\n-static void\n-storedecls (tree decls)\n-{\n-  current_binding_level->names = decls;\n-}\n-\n-/* Set the current binding TABLE for type declarations..  This is a\n-   temporary workaround of the fact that the data structure classtypes\n-   does not currently carry its allocated cxx_scope structure.  */\n-void\n-cxx_remember_type_decls (binding_table table)\n-{\n-  current_binding_level->type_decls = table;\n-}\n-\f\n-/* Return the type that should be used when TYPE's name is preceded\n-   by a tag such as 'struct' or 'union', or null if the name cannot\n-   be used in this way.\n-\n-   For example, when processing the third line of:\n-\n-\tstruct A;\n-\ttypedef struct A A;\n-\tstruct A;\n-\n-   lookup of A will find the typedef.  Given A's typedef, this function\n-   will return the type associated with \"struct A\".  For the tag to be\n-   anything other than TYPE, TYPE must be a typedef whose original type\n-   has the same name and context as TYPE itself.\n-\n-   It is not valid for a typedef of an anonymous type to be used with\n-   an explicit tag:\n-\n-       typedef struct { ... } B;\n-       struct B;\n-\n-   Return null for this case.  */\n-\n-static tree\n-follow_tag_typedef (tree type)\n-{\n-  tree original;\n-\n-  original = original_type (type);\n-  if (! TYPE_NAME (original))\n-    return NULL_TREE;\n-  if (TYPE_IDENTIFIER (original) == TYPE_IDENTIFIER (type)\n-      && (CP_DECL_CONTEXT (TYPE_NAME (original))\n-\t  == CP_DECL_CONTEXT (TYPE_NAME (type)))\n-      && !(CLASS_TYPE_P (original) && TYPE_WAS_ANONYMOUS (original)))\n-    return original;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Given NAME, an IDENTIFIER_NODE,\n-   return the structure (or union or enum) definition for that name.\n-   Searches binding levels from its SCOPE up to the global level.\n-   If THISLEVEL_ONLY is nonzero, searches only the specified context\n-   (but skips any sk_cleanup contexts to find one that is\n-   meaningful for tags).\n-   FORM says which kind of type the caller wants;\n-   it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n-   If the wrong kind of type is found, and it's not a template, an error is\n-   reported.  */\n-\n-static tree\n-lookup_tag (enum tree_code form, tree name,\n-            struct cp_binding_level* binding_level, int thislevel_only)\n-{\n-  register struct cp_binding_level *level;\n-  /* Nonzero if, we should look past a template parameter level, even\n-     if THISLEVEL_ONLY.  */\n-  int allow_template_parms_p = 1;\n-  bool type_is_anonymous = ANON_AGGRNAME_P (name);\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  for (level = binding_level; level; level = level->level_chain)\n-    {\n-      register tree tail;\n-      if (type_is_anonymous && level->type_decls != NULL)\n-        {\n-          tree type = binding_table_find_anon_type (level->type_decls, name);\n-          /* There is no need for error checking here, because\n-           anon names are unique throughout the compilation.  */\n-          if (type != NULL)\n-            POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n-        }\n-      else if (level->kind == sk_namespace)\n-\t/* Do namespace lookup.  */\n-\tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n-\t  {\n-            cxx_binding *binding =\n-              cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (tail), name);\n-\t    tree old;\n-\n-\t    /* If we just skipped past a template parameter level,\n-\t       even though THISLEVEL_ONLY, and we find a template\n-\t       class declaration, then we use the _TYPE node for the\n-\t       template.  See the example below.  */\n-\t    if (thislevel_only && !allow_template_parms_p\n-\t\t&& binding && binding->value\n-\t\t&& DECL_CLASS_TEMPLATE_P (binding->value))\n-\t      old = binding->value;\n-\t    else if (binding)\n-\t      old = select_decl (binding, LOOKUP_PREFER_TYPES);\n-            else\n-              old = NULL_TREE;\n-\n-\t    if (old)\n-\t      {\n-\t\t/* We've found something at this binding level.  If it is\n-\t\t   a typedef, extract the tag it refers to.  Lookup fails\n-\t\t   if the typedef doesn't refer to a taggable type.  */\n-\t\told = TREE_TYPE (old);\n-\t\told = follow_tag_typedef (old);\n-\t\tif (!old)\n-\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t\tif (TREE_CODE (old) != form\n-\t\t    && (form == ENUMERAL_TYPE\n-\t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n-\t\t  {\n-\t\t    error (\"`%#D' redeclared as %C\", old, form);\n-\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t\t  }\n-\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old);\n-\t      }\n-\t    if (thislevel_only || tail == global_namespace)\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t  }\n-      else if (level->type_decls != NULL)\n-        {\n-          binding_entry entry = binding_table_find (level->type_decls, name);\n-          if (entry != NULL)\n-            {\n-              enum tree_code code = TREE_CODE (entry->type);\n-\t\t\n-              if (code != form\n-                  && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n-                {\n-                  /* Definition isn't the kind we were looking for.  */\n-                  error (\"`%#D' redeclared as %C\", entry->type, form);\n-                  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-                }\n-              POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n-            }\n-\t  }\n-      if (thislevel_only && level->kind != sk_cleanup)\n-\t{\n-\t  if (level->kind == sk_template_parms && allow_template_parms_p)\n-\t    {\n-\t      /* We must deal with cases like this:\n-\n-\t           template <class T> struct S;\n-\t\t   template <class T> struct S {};\n-\n-\t\t When looking up `S', for the second declaration, we\n-\t\t would like to find the first declaration.  But, we\n-\t\t are in the pseudo-global level created for the\n-\t\t template parameters, rather than the (surrounding)\n-\t\t namespace level.  Thus, we keep going one more level,\n-\t\t even though THISLEVEL_ONLY is nonzero.  */\n-\t      allow_template_parms_p = 0;\n-\t      continue;\n-\t    }\n-\t  else\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-\t}\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-}\n-\n-/* Given a type, find the tag that was defined for it and return the tag name.\n-   Otherwise return 0.  However, the value can never be 0\n-   in the cases in which this is used.\n-\n-   C++: If NAME is nonzero, this is the new name to install.  This is\n-   done when replacing anonymous tags with real tag names.  */\n-\n-static tree\n-lookup_tag_reverse (tree type, tree name)\n-{\n-  register struct cp_binding_level *level;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  for (level = current_binding_level; level; level = level->level_chain)\n-    {\n-      binding_entry entry = level->type_decls == NULL\n-        ? NULL\n-        : binding_table_reverse_maybe_remap (level->type_decls, type, name);\n-      if (entry)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->name);\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-}\n-\f\n-/* Look up NAME in the NAMESPACE.  */\n-\n-tree\n-lookup_namespace_name (tree namespace, tree name)\n-{\n-  tree val;\n-  tree template_id = NULL_TREE;\n-  cxx_binding binding;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n-\n-  if (TREE_CODE (name) == NAMESPACE_DECL)\n-    /* This happens for A::B<int> when B is a namespace.  */\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, name);\n-  else if (TREE_CODE (name) == TEMPLATE_DECL)\n-    {\n-      /* This happens for A::B where B is a template, and there are no\n-\t template arguments.  */\n-      error (\"invalid use of `%D'\", name);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-    }\n-\n-  namespace = ORIGINAL_NAMESPACE (namespace);\n-\n-  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-    {\n-      template_id = name;\n-      name = TREE_OPERAND (name, 0);\n-      if (TREE_CODE (name) == OVERLOAD)\n-\tname = DECL_NAME (OVL_CURRENT (name));\n-      else if (DECL_P (name))\n-\tname = DECL_NAME (name);\n-    }\n-\n-  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n-\n-  cxx_binding_clear (&binding);\n-  if (!qualified_lookup_using_namespace (name, namespace, &binding, 0))\n-    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\n-  if (binding.value)\n-    {\n-      val = binding.value;\n-\n-      if (template_id)\n-\t{\n-\t  if (DECL_CLASS_TEMPLATE_P (val))\n-\t    val = lookup_template_class (val,\n-\t\t\t\t\t TREE_OPERAND (template_id, 1),\n-\t\t\t\t\t /*in_decl=*/NULL_TREE,\n-\t\t\t\t\t /*context=*/NULL_TREE,\n-\t\t\t\t\t /*entering_scope=*/0,\n-\t                                 tf_error | tf_warning);\n-\t  else if (DECL_FUNCTION_TEMPLATE_P (val)\n-\t\t   || TREE_CODE (val) == OVERLOAD)\n-\t    val = lookup_template_function (val,\n-\t\t\t\t\t    TREE_OPERAND (template_id, 1));\n-\t  else\n-\t    {\n-\t      error (\"`%D::%D' is not a template\",\n-\t\t\tnamespace, name);\n-\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t    }\n-\t}\n-\n-      /* If we have a single function from a using decl, pull it out.  */\n-      if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n-\tval = OVL_FUNCTION (val);\n-\n-      /* Ignore built-in functions that haven't been prototyped yet.  */\n-      if (!val || !DECL_P(val)\n-          || !DECL_LANG_SPECIFIC(val)\n-          || !DECL_ANTICIPATED (val))\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-    }\n-\n-  error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-}\n-\n /* Hash a TYPENAME_TYPE.  K is really of type `tree'.  */\n \n static hashval_t\n@@ -5336,172 +3436,6 @@ make_unbound_class_template (tree context, tree name, tsubst_flags_t complain)\n   return t;\n }\n \n-/* Select the right _DECL from multiple choices.  */\n-\n-static tree\n-select_decl (cxx_binding *binding, int flags)\n-{\n-  tree val;\n-  val = binding->value;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  if (LOOKUP_NAMESPACES_ONLY (flags))\n-    {\n-      /* We are not interested in types.  */\n-      if (val && TREE_CODE (val) == NAMESPACE_DECL)\n-        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-    }\n-\n-  /* If looking for a type, or if there is no non-type binding, select\n-     the value binding.  */\n-  if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n-    val = binding->type;\n-  /* Don't return non-types if we really prefer types.  */\n-  else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n-\t   && (TREE_CODE (val) != TEMPLATE_DECL\n-\t       || !DECL_CLASS_TEMPLATE_P (val)))\n-    val = NULL_TREE;\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-}\n-\n-/* Unscoped lookup of a global: iterate over current namespaces,\n-   considering using-directives.  If SPACESP is non-NULL, store a list\n-   of the namespaces we've considered in it.  */\n-\n-tree\n-unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n-{\n-  tree initial = current_decl_namespace ();\n-  tree scope = initial;\n-  tree siter;\n-  struct cp_binding_level *level;\n-  tree val = NULL_TREE;\n-  cxx_binding binding;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  cxx_binding_clear (&binding);\n-  if (spacesp)\n-    *spacesp = NULL_TREE;\n-\n-  for (; !val; scope = CP_DECL_CONTEXT (scope))\n-    {\n-      cxx_binding *b =\n-         cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n-      if (spacesp)\n-\t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n-\n-      /* Ignore anticipated built-in functions.  */\n-      if (b && b->value && DECL_P (b->value)\n-          && DECL_LANG_SPECIFIC (b->value) && DECL_ANTICIPATED (b->value))\n-        /* Keep binding cleared.  */;\n-      else if (b)\n-        {\n-          /* Initialize binding for this context.  */\n-          binding.value = b->value;\n-          binding.type = b->type;\n-        }\n-\n-      /* Add all _DECLs seen through local using-directives.  */\n-      for (level = current_binding_level;\n-\t   level->kind != sk_namespace;\n-\t   level = level->level_chain)\n-\tif (!lookup_using_namespace (name, &binding, level->using_directives,\n-                                     scope, flags, spacesp))\n-\t  /* Give up because of error.  */\n-\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\n-      /* Add all _DECLs seen through global using-directives.  */\n-      /* XXX local and global using lists should work equally.  */\n-      siter = initial;\n-      while (1)\n-\t{\n-\t  if (!lookup_using_namespace (name, &binding,\n-                                       DECL_NAMESPACE_USING (siter),\n-\t\t\t\t       scope, flags, spacesp))\n-\t    /* Give up because of error.  */\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\t  if (siter == scope) break;\n-\t  siter = CP_DECL_CONTEXT (siter);\n-\t}\n-\n-      val = select_decl (&binding, flags);\n-      if (scope == global_namespace)\n-\tbreak;\n-    }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-}\n-\n-/* Combine prefer_type and namespaces_only into flags.  */\n-\n-static int\n-lookup_flags (int prefer_type, int namespaces_only)\n-{\n-  if (namespaces_only)\n-    return LOOKUP_PREFER_NAMESPACES;\n-  if (prefer_type > 1)\n-    return LOOKUP_PREFER_TYPES;\n-  if (prefer_type > 0)\n-    return LOOKUP_PREFER_BOTH;\n-  return 0;\n-}\n-\n-/* Given a lookup that returned VAL, use FLAGS to decide if we want to\n-   ignore it or not.  Subroutine of lookup_name_real.  */\n-\n-static tree\n-qualify_lookup (tree val, int flags)\n-{\n-  if (val == NULL_TREE)\n-    return val;\n-  if ((flags & LOOKUP_PREFER_NAMESPACES) && TREE_CODE (val) == NAMESPACE_DECL)\n-    return val;\n-  if ((flags & LOOKUP_PREFER_TYPES)\n-      && (TREE_CODE (val) == TYPE_DECL || TREE_CODE (val) == TEMPLATE_DECL))\n-    return val;\n-  if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n-    return NULL_TREE;\n-  return val;\n-}\n-\n-/* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n-   or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type\n-   bindings.  \n-\n-   Returns a DECL (or OVERLOAD, or BASELINK) representing the\n-   declaration found.  If no suitable declaration can be found,\n-   ERROR_MARK_NODE is returned.  Iif COMPLAIN is true and SCOPE is\n-   neither a class-type nor a namespace a diagnostic is issued.  */\n-\n-tree\n-lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n-{\n-  int flags = 0;\n-\n-  if (TREE_CODE (scope) == NAMESPACE_DECL)\n-    {\n-      cxx_binding binding;\n-\n-      cxx_binding_clear (&binding);\n-      flags |= LOOKUP_COMPLAIN;\n-      if (is_type_p)\n-\tflags |= LOOKUP_PREFER_TYPES;\n-      if (qualified_lookup_using_namespace (name, scope, &binding, \n-\t\t\t\t\t    flags))\n-\treturn select_decl (&binding, flags);\n-    }\n-  else if (is_aggr_type (scope, complain))\n-    {\n-      tree t;\n-      t = lookup_member (scope, name, 0, is_type_p);\n-      if (t)\n-\treturn t;\n-    }\n-\n-  return error_mark_node;\n-}\n-\n /* Check to see whether or not DECL is a variable that would have been\n    in scope under the ARM, but is not in scope under the ANSI/ISO\n    standard.  If so, issue an error message.  If name lookup would\n@@ -5561,191 +3495,6 @@ check_for_out_of_scope_variable (tree decl)\n   return decl;\n }\n \n-/* Look up NAME in the current binding level and its superiors in the\n-   namespace of variables, functions and typedefs.  Return a ..._DECL\n-   node of some kind representing its definition if there is only one\n-   such declaration, or return a TREE_LIST with all the overloaded\n-   definitions if there are many, or return 0 if it is undefined.\n-\n-   If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n-   If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n-   Otherwise we prefer non-TYPE_DECLs.\n-\n-   If NONCLASS is nonzero, we don't look for the NAME in class scope,\n-   using IDENTIFIER_CLASS_VALUE.  */\n-\n-tree\n-lookup_name_real (tree name, int prefer_type, int nonclass, \n-\t\t  int namespaces_only, int flags)\n-{\n-  cxx_binding *iter;\n-  tree val = NULL_TREE;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  /* Conversion operators are handled specially because ordinary\n-     unqualified name lookup will not find template conversion\n-     operators.  */\n-  if (IDENTIFIER_TYPENAME_P (name)) \n-    {\n-      struct cp_binding_level *level;\n-\n-      for (level = current_binding_level; \n-\t   level && level->kind != sk_namespace;\n-\t   level = level->level_chain)\n-\t{\n-\t  tree class_type;\n-\t  tree operators;\n-\t  \n-\t  /* A conversion operator can only be declared in a class \n-\t     scope.  */\n-\t  if (level->kind != sk_class)\n-\t    continue;\n-\t  \n-\t  /* Lookup the conversion operator in the class.  */\n-\t  class_type = level->this_entity;\n-\t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n-\t  if (operators)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, operators);\n-\t}\n-\n-      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n-    }\n-\n-  flags |= lookup_flags (prefer_type, namespaces_only);\n-\n-  /* First, look in non-namespace scopes.  */\n-\n-  if (current_class_type == NULL_TREE)\n-    nonclass = 1;\n-\n-  for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n-    {\n-      tree binding;\n-\n-      if (!LOCAL_BINDING_P (iter) && nonclass)\n-\t/* We're not looking for class-scoped bindings, so keep going.  */\n-\tcontinue;\n-\n-      /* If this is the kind of thing we're looking for, we're done.  */\n-      if (qualify_lookup (iter->value, flags))\n-\tbinding = iter->value;\n-      else if ((flags & LOOKUP_PREFER_TYPES)\n-\t       && qualify_lookup (iter->type, flags))\n-\tbinding = iter->type;\n-      else\n-\tbinding = NULL_TREE;\n-\n-      if (binding)\n-\t{\n-\t  val = binding;\n-\t  break;\n-\t}\n-    }\n-\n-  /* Now lookup in namespace scopes.  */\n-  if (!val)\n-    {\n-      tree t = unqualified_namespace_lookup (name, flags, 0);\n-      if (t)\n-\tval = t;\n-    }\n-\n-  if (val)\n-    {\n-      /* If we have a single function from a using decl, pull it out.  */\n-      if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n-\tval = OVL_FUNCTION (val);\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n-}\n-\n-tree\n-lookup_name_nonclass (tree name)\n-{\n-  return lookup_name_real (name, 0, 1, 0, LOOKUP_COMPLAIN);\n-}\n-\n-tree\n-lookup_function_nonclass (tree name, tree args)\n-{\n-  return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n-}\n-\n-tree\n-lookup_name (tree name, int prefer_type)\n-{\n-  return lookup_name_real (name, prefer_type, 0, 0, LOOKUP_COMPLAIN);\n-}\n-\n-/* Similar to `lookup_name' but look only in the innermost non-class\n-   binding level.  */\n-\n-tree\n-lookup_name_current_level (tree name)\n-{\n-  struct cp_binding_level *b;\n-  tree t = NULL_TREE;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  b = innermost_nonclass_level ();\n-\n-  if (b->kind == sk_namespace)\n-    {\n-      t = IDENTIFIER_NAMESPACE_VALUE (name);\n-\n-      /* extern \"C\" function() */\n-      if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n-\tt = TREE_VALUE (t);\n-    }\n-  else if (IDENTIFIER_BINDING (name)\n-\t   && LOCAL_BINDING_P (IDENTIFIER_BINDING (name)))\n-    {\n-      while (1)\n-\t{\n-\t  if (IDENTIFIER_BINDING (name)->scope == b)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n-\n-\t  if (b->kind == sk_cleanup)\n-\t    b = b->level_chain;\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-}\n-\n-/* Like lookup_name_current_level, but for types.  */\n-\n-tree\n-lookup_type_current_level (tree name)\n-{\n-  register tree t = NULL_TREE;\n-\n-  timevar_push (TV_NAME_LOOKUP);\n-  my_friendly_assert (current_binding_level->kind != sk_namespace, \n-\t\t      980716);\n-\n-  if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n-      && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n-    {\n-      struct cp_binding_level *b = current_binding_level;\n-      while (1)\n-\t{\n-\t  if (purpose_member (name, b->type_shadowed))\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n-                                    REAL_IDENTIFIER_TYPE_VALUE (name));\n-\t  if (b->kind == sk_cleanup)\n-\t    b = b->level_chain;\n-\t  else\n-\t    break;\n-\t}\n-    }\n-\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n-}\n-\n \f\n \n /* A chain of TYPE_DECLs for the builtin types.  */\n@@ -13457,7 +11206,7 @@ store_parm_decls (tree current_function_parms)\n \n       /* Must clear this because it might contain TYPE_DECLs declared\n \t     at class level.  */\n-      storedecls (NULL_TREE);\n+      current_binding_level->names = NULL;\n \n       /* If we're doing semantic analysis, then we'll call pushdecl\n \t     for each of these.  We must do them in reverse order so that\n@@ -13496,7 +11245,7 @@ store_parm_decls (tree current_function_parms)\n      as the decl-chain of the current lexical scope.\n      Put the enumerators in as well, at the front so that\n      DECL_ARGUMENTS is not modified.  */\n-  storedecls (chainon (nonparms, DECL_ARGUMENTS (fndecl)));\n+  current_binding_level->names = chainon (nonparms, DECL_ARGUMENTS (fndecl));\n \n   /* Do the starting of the exception specifications, if we have any.  */\n   if (flag_exceptions && !processing_template_decl\n@@ -14250,15 +11999,6 @@ cp_tree_node_structure (union lang_tree_node * t)\n     }\n }\n \n-/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since\n-   the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */\n-\n-tree\n-identifier_global_value\t(tree t)\n-{\n-  return IDENTIFIER_GLOBAL_VALUE (t);\n-}\n-\n /* Build the void_list_node (void_type_node having been created).  */\n tree\n build_void_list_node (void)"}, {"sha": "4f5999803dbfda785c29b9fe8e06680da1a20526", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2245, "deletions": 22, "changes": 2267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -28,6 +28,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"name-lookup.h\"\n #include \"timevar.h\"\n #include \"toplev.h\"\n+#include \"diagnostic.h\"\n+\n+static cxx_scope *innermost_nonclass_level (void);\n+static tree select_decl (cxx_binding *, int);\n+\n \n /* Compute the chain index of a binding_entry given the HASH value of its\n    name and the total COUNT of chains.  COUNT is assumed to be a power\n@@ -100,7 +105,7 @@ binding_table_construct (binding_table table, size_t chain_count)\n \n /* Make TABLE's entries ready for reuse.  */\n \n-void\n+static void\n binding_table_free (binding_table table)\n {\n   size_t i;\n@@ -125,7 +130,7 @@ binding_table_free (binding_table table)\n \n /* Allocate a table with CHAIN_COUNT, assumed to be a power of two.  */\n \n-binding_table\n+static inline binding_table\n binding_table_new (size_t chain_count)\n {\n   binding_table table = ggc_alloc (sizeof (struct binding_table_s));\n@@ -164,7 +169,7 @@ binding_table_expand (binding_table table)\n \n /* Insert a binding for NAME to TYPE into TABLE.  */\n \n-void\n+static void\n binding_table_insert (binding_table table, tree name, tree type)\n {\n   const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n@@ -195,7 +200,7 @@ binding_table_find (binding_table table, tree name)\n \n /* Return the binding_entry, if any, that maps NAME to an anonymous type.  */\n \n-tree\n+static tree\n binding_table_find_anon_type (binding_table table, tree name)\n {\n   const unsigned int hash = IDENTIFIER_HASH_VALUE (name);\n@@ -210,7 +215,7 @@ binding_table_find_anon_type (binding_table table, tree name)\n /* Return the binding_entry, if any, that has TYPE as target.  If NAME\n    is non-null, then set the domain and rehash that entry.  */\n \n-binding_entry\n+static binding_entry\n binding_table_reverse_maybe_remap (binding_table table, tree type, tree name)\n {\n   const size_t chain_count = table->chain_count;\n@@ -285,14 +290,19 @@ binding_table_foreach (binding_table table, bt_foreach_proc proc, void *data)\n     }\n }\n \f\n+#ifndef ENABLE_SCOPE_CHECKING\n+#  define ENABLE_SCOPE_CHECKING 0\n+#else\n+#  define ENABLE_SCOPE_CHECKING 1\n+#endif\n \n /* A free list of \"cxx_binding\"s, connected by their PREVIOUS.  */\n \n static GTY((deletable (\"\"))) cxx_binding *free_bindings;\n \n /* (GC)-allocate a binding object with VALUE and TYPE member initialized.  */\n \n-cxx_binding *\n+static cxx_binding *\n cxx_binding_make (tree value, tree type)\n {\n   cxx_binding *binding;\n@@ -313,14 +323,72 @@ cxx_binding_make (tree value, tree type)\n \n /* Put BINDING back on the free list.  */\n \n-void\n+static inline void\n cxx_binding_free (cxx_binding *binding)\n {\n   binding->scope = NULL;\n   binding->previous = free_bindings;\n   free_bindings = binding;\n }\n \n+/* Make DECL the innermost binding for ID.  The LEVEL is the binding\n+   level at which this declaration is being bound.  */\n+\n+static void\n+push_binding (tree id, tree decl, cxx_scope* level)\n+{\n+   cxx_binding *binding = cxx_binding_make (decl, NULL);\n+\n+  /* Now, fill in the binding information.  */\n+  binding->previous = IDENTIFIER_BINDING (id);\n+  binding->scope = level;\n+  INHERITED_VALUE_BINDING_P (binding) = 0;\n+  LOCAL_BINDING_P (binding) = (level != class_binding_level);\n+\n+  /* And put it on the front of the list of bindings for ID.  */\n+  IDENTIFIER_BINDING (id) = binding;\n+}\n+\n+/* Remove the binding for DECL which should be the innermost binding\n+   for ID.  */\n+\n+void\n+pop_binding (tree id, tree decl)\n+{\n+  cxx_binding *binding;\n+\n+  if (id == NULL_TREE)\n+    /* It's easiest to write the loops that call this function without\n+       checking whether or not the entities involved have names.  We\n+       get here for such an entity.  */\n+    return;\n+\n+  /* Get the innermost binding for ID.  */\n+  binding = IDENTIFIER_BINDING (id);\n+\n+  /* The name should be bound.  */\n+  my_friendly_assert (binding != NULL, 0);\n+\n+  /* The DECL will be either the ordinary binding or the type\n+     binding for this identifier.  Remove that binding.  */\n+  if (binding->value == decl)\n+    binding->value = NULL_TREE;\n+  else if (binding->type == decl)\n+    binding->type = NULL_TREE;\n+  else\n+    abort ();\n+\n+  if (!binding->value && !binding->type)\n+    {\n+      /* We're completely done with the innermost binding for this\n+\t identifier.  Unhook it from the list of bindings.  */\n+      IDENTIFIER_BINDING (id) = binding->previous;\n+\n+      /* Add it to the free list.  */\n+      cxx_binding_free (binding);\n+    }\n+}\n+\n /* BINDING records an existing declaration for a namein the current scope.\n    But, DECL is another declaration for that same identifier in the\n    same scope.  This is the `struct stat' hack whereby a non-typedef\n@@ -339,7 +407,7 @@ cxx_binding_free (cxx_binding *binding)\n    inserting this name is valid here.  Returns nonzero if the new binding\n    was successful.  */\n \n-bool\n+static bool\n supplement_binding (cxx_binding *binding, tree decl)\n {\n   tree bval = binding->value;\n@@ -407,7 +475,649 @@ supplement_binding (cxx_binding *binding, tree decl)\n \n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ok);\n }\n+\n+/* Add DECL to the list of things declared in B.  */\n+\n+void\n+add_decl_to_level (tree decl, cxx_scope *b)\n+{\n+  if (TREE_CODE (decl) == NAMESPACE_DECL \n+      && !DECL_NAMESPACE_ALIAS (decl))\n+    {\n+      TREE_CHAIN (decl) = b->namespaces;\n+      b->namespaces = decl;\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL && DECL_VIRTUAL_P (decl))\n+    {\n+      TREE_CHAIN (decl) = b->vtables;\n+      b->vtables = decl;\n+    }\n+  else       \n+    {\n+      /* We build up the list in reverse order, and reverse it later if\n+         necessary.  */\n+      TREE_CHAIN (decl) = b->names;\n+      b->names = decl;\n+      b->names_size++;\n+\n+      /* If appropriate, add decl to separate list of statics */\n+      if (b->kind == sk_namespace)\n+\tif ((TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+\t    || (TREE_CODE (decl) == FUNCTION_DECL\n+\t\t&& (!TREE_PUBLIC (decl) || DECL_DECLARED_INLINE_P (decl))))\n+\t  VARRAY_PUSH_TREE (b->static_decls, decl);\n+    }\n+}\n+\n+/* Bind DECL to ID in the current_binding_level, assumed to be a local\n+   binding level.  If PUSH_USING is set in FLAGS, we know that DECL\n+   doesn't really belong to this binding level, that it got here\n+   through a using-declaration.  */\n+\n+void\n+push_local_binding (tree id, tree decl, int flags)\n+{\n+  struct cp_binding_level *b;\n+\n+  /* Skip over any local classes.  This makes sense if we call\n+     push_local_binding with a friend decl of a local class.  */\n+  b = innermost_nonclass_level ();\n+\n+  if (lookup_name_current_level (id))\n+    {\n+      /* Supplement the existing binding.  */\n+      if (!supplement_binding (IDENTIFIER_BINDING (id), decl))\n+\t/* It didn't work.  Something else must be bound at this\n+\t   level.  Do not add DECL to the list of things to pop\n+\t   later.  */\n+\treturn;\n+    }\n+  else\n+    /* Create a new binding.  */\n+    push_binding (id, decl, b);\n+\n+  if (TREE_CODE (decl) == OVERLOAD || (flags & PUSH_USING))\n+    /* We must put the OVERLOAD into a TREE_LIST since the\n+       TREE_CHAIN of an OVERLOAD is already used.  Similarly for\n+       decls that got here through a using-declaration.  */\n+    decl = build_tree_list (NULL_TREE, decl);\n+\n+  /* And put DECL on the list of things declared by the current\n+     binding level.  */\n+  add_decl_to_level (decl, b);\n+}\n+\f\n+/* true means unconditionally make a BLOCK for the next level pushed.  */\n+\n+static bool keep_next_level_flag;\n+\n+static int binding_depth = 0;\n+static int is_class_level = 0;\n+\n+static void\n+indent (int depth)\n+{\n+  int i;\n+\n+  for (i = 0; i < depth * 2; i++)\n+    putc (' ', stderr);\n+}\n+\n+/* Return a string describing the kind of SCOPE we have.  */\n+static const char *\n+cxx_scope_descriptor (cxx_scope *scope)\n+{\n+  /* The order of this table must match the \"scope_kind\"\n+     enumerators.  */\n+  static const char* scope_kind_names[] = {\n+    \"block-scope\",\n+    \"cleanup-scope\",\n+    \"try-scope\",\n+    \"catch-scope\",\n+    \"for-scope\",\n+    \"function-parameter-scope\",\n+    \"class-scope\",\n+    \"namespace-scope\",\n+    \"template-parameter-scope\",\n+    \"template-explicit-spec-scope\"\n+  };\n+  const scope_kind kind = scope->explicit_spec_p\n+    ? sk_template_spec : scope->kind;\n+\n+  return scope_kind_names[kind];\n+}\n+\n+/* Output a debugging information about SCOPE when performning\n+   ACTION at LINE.  */\n+static void\n+cxx_scope_debug (cxx_scope *scope, int line, const char *action)\n+{\n+  const char *desc = cxx_scope_descriptor (scope);\n+  if (scope->this_entity)\n+    verbatim (\"%s %s(%E) %p %d\\n\", action, desc,\n+              scope->this_entity, (void *) scope, line);\n+  else\n+    verbatim (\"%s %s %p %d\\n\", action, desc, (void *) scope, line);\n+}\n+\n+/* Return the estimated initial size of the hashtable of a NAMESPACE\n+   scope.  */\n+\n+static inline size_t\n+namespace_scope_ht_size (tree ns)\n+{\n+  tree name = DECL_NAME (ns);\n+\n+  return name == std_identifier\n+    ? NAMESPACE_STD_HT_SIZE\n+    : (name == global_scope_name\n+       ? GLOBAL_SCOPE_HT_SIZE\n+       : NAMESPACE_ORDINARY_HT_SIZE);\n+}\n+\n+/* A chain of binding_level structures awaiting reuse.  */\n+\n+static GTY((deletable (\"\"))) struct cp_binding_level *free_binding_level;\n+\n+/* Create a new KIND scope and make it the top of the active scopes stack.\n+   ENTITY is the scope of the associated C++ entity (namespace, class,\n+   function); it is NULL otherwise.  */\n+\n+cxx_scope *\n+begin_scope (scope_kind kind, tree entity)\n+{\n+  cxx_scope *scope;\n+  \n+  /* Reuse or create a struct for this binding level.  */\n+  if (!ENABLE_SCOPE_CHECKING && free_binding_level)\n+    {\n+      scope = free_binding_level;\n+      free_binding_level = scope->level_chain;\n+    }\n+  else\n+    scope = ggc_alloc (sizeof (cxx_scope));\n+  memset (scope, 0, sizeof (cxx_scope));\n+\n+  scope->this_entity = entity;\n+  scope->more_cleanups_ok = true;\n+  switch (kind)\n+    {\n+    case sk_cleanup:\n+      scope->keep = true;\n+      break;\n+      \n+    case sk_template_spec:\n+      scope->explicit_spec_p = true;\n+      kind = sk_template_parms;\n+      /* fall through */\n+    case sk_template_parms:\n+    case sk_block:\n+    case sk_try:\n+    case sk_catch:\n+    case sk_for:\n+    case sk_class:\n+    case sk_function_parms:\n+      scope->keep = keep_next_level_flag;\n+      break;\n+\n+    case sk_namespace:\n+      scope->type_decls = binding_table_new (namespace_scope_ht_size (entity));\n+      NAMESPACE_LEVEL (entity) = scope;\n+      VARRAY_TREE_INIT (scope->static_decls,\n+                        DECL_NAME (entity) == std_identifier\n+                        || DECL_NAME (entity) == global_scope_name\n+                        ? 200 : 10,\n+                        \"Static declarations\");\n+      break;\n+\n+    default:\n+      /* Should not happen.  */\n+      my_friendly_assert (false, 20030922);\n+      break;\n+    }\n+  scope->kind = kind;\n+\n+  /* Add it to the front of currently active scopes stack.  */\n+  scope->level_chain = current_binding_level;\n+  current_binding_level = scope;\n+  keep_next_level_flag = false;\n+\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      scope->binding_depth = binding_depth;\n+      indent (binding_depth);\n+      cxx_scope_debug (scope, input_location.line, \"push\");\n+      is_class_level = 0;\n+      binding_depth++;\n+    }\n+\n+  return scope;\n+}\n+\n+/* We're about to leave current scope.  Pop the top of the stack of\n+   currently active scopes.  Return the enclosing scope, now active.  */\n+\n+cxx_scope *\n+leave_scope (void)\n+{\n+  cxx_scope *scope = current_binding_level;\n+\n+  if (scope->kind == sk_namespace && class_binding_level)\n+    current_binding_level = class_binding_level;\n+\n+  /* We cannot leave a scope, if there are none left.  */\n+  if (NAMESPACE_LEVEL (global_namespace))\n+    my_friendly_assert (!global_scope_p (scope), 20030527);\n+  \n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      indent (--binding_depth);\n+      cxx_scope_debug (scope, input_location.line, \"leave\");\n+      if (is_class_level != (scope == class_binding_level))\n+        {\n+          indent (binding_depth);\n+          verbatim (\"XXX is_class_level != (current_scope == class_scope)\\n\");\n+        }\n+      is_class_level = 0;\n+    }\n+\n+  /* Move one nesting level up.  */\n+  current_binding_level = scope->level_chain;\n+\n+  /* Namespace-scopes are left most probably temporarily, not completely;\n+     they can be reopen later, e.g. in namespace-extension or any name\n+     binding acttivity that requires us to resume a namespace.  For other\n+     scopes, we just make the structure available for reuse.  */\n+  if (scope->kind != sk_namespace)\n+    {\n+      scope->level_chain = free_binding_level;\n+      if (scope->kind == sk_class)\n+        scope->type_decls = NULL;\n+      else\n+        binding_table_free (scope->type_decls);\n+      my_friendly_assert (!ENABLE_SCOPE_CHECKING\n+                          || scope->binding_depth == binding_depth,\n+                          20030529);\n+      free_binding_level = scope;\n+    }\n+\n+  /* Find the innermost enclosing class scope, and reset\n+     CLASS_BINDING_LEVEL appropriately.  */\n+  for (scope = current_binding_level;\n+       scope && scope->kind != sk_class;\n+       scope = scope->level_chain)\n+    ;\n+  class_binding_level = scope && scope->kind == sk_class ? scope : NULL;\n+\n+  return current_binding_level;\n+}\n+\n+static void\n+resume_scope (struct cp_binding_level* b)\n+{\n+  /* Resuming binding levels is meant only for namespaces,\n+     and those cannot nest into classes.  */\n+  my_friendly_assert(!class_binding_level, 386);\n+  /* Also, resuming a non-directly nested namespace is a no-no.  */\n+  my_friendly_assert(b->level_chain == current_binding_level, 386);\n+  current_binding_level = b;\n+  if (ENABLE_SCOPE_CHECKING)\n+    {\n+      b->binding_depth = binding_depth;\n+      indent (binding_depth);\n+      cxx_scope_debug (b, input_location.line, \"resume\");\n+      is_class_level = 0;\n+      binding_depth++;\n+    }\n+}\n+\n+/* Return the innermost binding level that is not for a class scope.  */\n+\n+static cxx_scope *\n+innermost_nonclass_level (void)\n+{\n+  cxx_scope *b;\n+\n+  b = current_binding_level;\n+  while (b->kind == sk_class)\n+    b = b->level_chain;\n+\n+  return b;\n+}\n+\n+/* We're defining an object of type TYPE.  If it needs a cleanup, but\n+   we're not allowed to add any more objects with cleanups to the current\n+   scope, create a new binding level.  */\n+\n+void\n+maybe_push_cleanup_level (tree type)\n+{\n+  if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)\n+      && current_binding_level->more_cleanups_ok == 0)\n+    {\n+      begin_scope (sk_cleanup, NULL);\n+      clear_last_expr ();\n+      add_scope_stmt (/*begin_p=*/1, /*partial_p=*/1);\n+    }\n+}\n+\n+/* Nonzero if we are currently in the global binding level.  */\n+\n+int\n+global_bindings_p (void)\n+{\n+  return global_scope_p (current_binding_level);\n+}\n+\n+/* True if we are currently in a toplevel binding level.  This\n+   means either the global binding level or a namespace in a toplevel\n+   binding level.  Since there are no non-toplevel namespace levels,\n+   this really means any namespace or template parameter level.  We\n+   also include a class whose context is toplevel.  */\n+\n+bool\n+toplevel_bindings_p (void)\n+{\n+  struct cp_binding_level *b = innermost_nonclass_level ();\n+\n+  return b->kind == sk_namespace || b->kind == sk_template_parms;\n+}\n+\n+/* True if this is a namespace scope, or if we are defining a class\n+   which is itself at namespace scope, or whose enclosing class is\n+   such a class, etc.  */\n+\n+bool\n+namespace_bindings_p (void)\n+{\n+  struct cp_binding_level *b = innermost_nonclass_level ();\n+\n+  return b->kind == sk_namespace;\n+}\n+\n+/* True if the current level needs to have a BLOCK made.  */\n+\n+bool\n+kept_level_p (void)\n+{\n+  return (current_binding_level->blocks != NULL_TREE\n+\t  || current_binding_level->keep\n+          || current_binding_level->kind == sk_cleanup\n+\t  || current_binding_level->names != NULL_TREE\n+\t  || current_binding_level->type_decls != NULL);\n+}\n+\n+/* Returns the kind of the innermost scope.  */\n+\n+scope_kind\n+innermost_scope_kind (void)\n+{\n+  return current_binding_level->kind;\n+}\n+\n+/* Returns true if this scope was created to store template parameters.  */\n+\n+bool\n+template_parm_scope_p (void)\n+{\n+  return innermost_scope_kind () == sk_template_parms;\n+}\n+\n+/* If KEEP is true, make a BLOCK node for the next binding level,\n+   unconditionally.  Otherwise, use the normal logic to decide whether\n+   or not to create a BLOCK.  */\n+\n+void\n+keep_next_level (bool keep)\n+{\n+  keep_next_level_flag = keep;\n+}\n+\n+/* Return the list of declarations of the current level.\n+   Note that this list is in reverse order unless/until\n+   you nreverse it; and when you do nreverse it, you must\n+   store the result back using `storedecls' or you will lose.  */\n+\n+tree\n+getdecls (void)\n+{\n+  return current_binding_level->names;\n+}\n+\n+/* Set the current binding TABLE for type declarations..  This is a\n+   temporary workaround of the fact that the data structure classtypes\n+   does not currently carry its allocated cxx_scope structure.  */\n+void\n+cxx_remember_type_decls (binding_table table)\n+{\n+  current_binding_level->type_decls = table;\n+}\n+\n+/* For debugging.  */\n+static int no_print_functions = 0;\n+static int no_print_builtins = 0;\n+\n+/* Called from print_binding_level through binding_table_foreach to\n+   print the content of binding ENTRY.  DATA is a pointer to line offset\n+   marker.  */\n+static void\n+bt_print_entry (binding_entry entry, void *data)\n+{\n+  int *p = (int *) data;\n+  int len;\n+\n+  if (entry->name == NULL)\n+    len = 3;\n+  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n+    len = 2;\n+  else\n+    len = 4;\n+    len = 4;\n+\n+  *p += len;\n+\n+  if (*p > 5)\n+    {\n+      fprintf (stderr, \"\\n\\t\");\n+      *p = len;\n+    }\n+  if (entry->name == NULL)\n+    {\n+      print_node_brief (stderr, \"<unnamed-typedef\", entry->type, 0);\n+      fprintf (stderr, \">\");\n+    }\n+  else if (entry->name == TYPE_IDENTIFIER (entry->type))\n+    print_node_brief (stderr, \"\", entry->type, 0);\n+  else\n+    {\n+      print_node_brief (stderr, \"<typedef\", entry->name, 0);\n+      print_node_brief (stderr, \"\", entry->type, 0);\n+      fprintf (stderr, \">\");\n+    }\n+}\n+\n+void\n+print_binding_level (struct cp_binding_level* lvl)\n+{\n+  tree t;\n+  int i = 0, len;\n+  fprintf (stderr, \" blocks=\" HOST_PTR_PRINTF, (void *) lvl->blocks);\n+  if (lvl->more_cleanups_ok)\n+    fprintf (stderr, \" more-cleanups-ok\");\n+  if (lvl->have_cleanups)\n+    fprintf (stderr, \" have-cleanups\");\n+  fprintf (stderr, \"\\n\");\n+  if (lvl->names)\n+    {\n+      fprintf (stderr, \" names:\\t\");\n+      /* We can probably fit 3 names to a line?  */\n+      for (t = lvl->names; t; t = TREE_CHAIN (t))\n+\t{\n+\t  if (no_print_functions && (TREE_CODE (t) == FUNCTION_DECL))\n+\t    continue;\n+\t  if (no_print_builtins\n+\t      && (TREE_CODE (t) == TYPE_DECL)\n+\t      && (!strcmp (DECL_SOURCE_FILE (t),\"<built-in>\")))\n+\t    continue;\n+\n+\t  /* Function decls tend to have longer names.  */\n+\t  if (TREE_CODE (t) == FUNCTION_DECL)\n+\t    len = 3;\n+\t  else\n+\t    len = 2;\n+\t  i += len;\n+\t  if (i > 6)\n+\t    {\n+\t      fprintf (stderr, \"\\n\\t\");\n+\t      i = len;\n+\t    }\n+\t  print_node_brief (stderr, \"\", t, 0);\n+\t  if (t == error_mark_node)\n+\t    break;\n+\t}\n+      if (i)\n+        fprintf (stderr, \"\\n\");\n+    }\n+  if (lvl->type_decls)\n+    {\n+      fprintf (stderr, \" tags:\\t\");\n+      i = 0;\n+      binding_table_foreach (lvl->type_decls, bt_print_entry, &i);\n+      if (i)\n+\tfprintf (stderr, \"\\n\");\n+    }\n+  if (lvl->class_shadowed)\n+    {\n+      fprintf (stderr, \" class-shadowed:\");\n+      for (t = lvl->class_shadowed; t; t = TREE_CHAIN (t))\n+\t{\n+\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+\t}\n+      fprintf (stderr, \"\\n\");\n+    }\n+  if (lvl->type_shadowed)\n+    {\n+      fprintf (stderr, \" type-shadowed:\");\n+      for (t = lvl->type_shadowed; t; t = TREE_CHAIN (t))\n+        {\n+\t  fprintf (stderr, \" %s \", IDENTIFIER_POINTER (TREE_PURPOSE (t)));\n+        }\n+      fprintf (stderr, \"\\n\");\n+    }\n+}\n+\n+void\n+print_other_binding_stack (struct cp_binding_level *stack)\n+{\n+  struct cp_binding_level *level;\n+  for (level = stack; !global_scope_p (level); level = level->level_chain)\n+    {\n+      fprintf (stderr, \"binding level \" HOST_PTR_PRINTF \"\\n\", (void *) level);\n+      print_binding_level (level);\n+    }\n+}\n+\n+void\n+print_binding_stack (void)\n+{\n+  struct cp_binding_level *b;\n+  fprintf (stderr, \"current_binding_level=\" HOST_PTR_PRINTF\n+\t   \"\\nclass_binding_level=\" HOST_PTR_PRINTF\n+\t   \"\\nNAMESPACE_LEVEL (global_namespace)=\" HOST_PTR_PRINTF \"\\n\",\n+\t   (void *) current_binding_level, (void *) class_binding_level,\n+           (void *) NAMESPACE_LEVEL (global_namespace));\n+  if (class_binding_level)\n+    {\n+      for (b = class_binding_level; b; b = b->level_chain)\n+\tif (b == current_binding_level)\n+\t  break;\n+      if (b)\n+\tb = class_binding_level;\n+      else\n+\tb = current_binding_level;\n+    }\n+  else\n+    b = current_binding_level;\n+  print_other_binding_stack (b);\n+  fprintf (stderr, \"global:\\n\");\n+  print_binding_level (NAMESPACE_LEVEL (global_namespace));\n+}\n \f\n+/* Return the type associated with id.  */\n+\n+tree\n+identifier_type_value (tree id)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* There is no type with that name, anywhere.  */\n+  if (REAL_IDENTIFIER_TYPE_VALUE (id) == NULL_TREE)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+  /* This is not the type marker, but the real thing.  */\n+  if (REAL_IDENTIFIER_TYPE_VALUE (id) != global_type_node)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, REAL_IDENTIFIER_TYPE_VALUE (id));\n+  /* Have to search for it. It must be on the global level, now.\n+     Ask lookup_name not to return non-types.  */\n+  id = lookup_name_real (id, 2, 1, 0, LOOKUP_COMPLAIN);\n+  if (id)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, TREE_TYPE (id));\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+}\n+\n+/* Return the IDENTIFIER_GLOBAL_VALUE of T, for use in common code, since\n+   the definition of IDENTIFIER_GLOBAL_VALUE is different for C and C++.  */\n+\n+tree\n+identifier_global_value\t(tree t)\n+{\n+  return IDENTIFIER_GLOBAL_VALUE (t);\n+}\n+\n+/* Push a definition of struct, union or enum tag named ID.  into\n+   binding_level B.  DECL is a TYPE_DECL for the type.  We assume that\n+   the tag ID is not already defined.  */\n+\n+static void\n+set_identifier_type_value_with_scope (tree id, tree decl, cxx_scope *b)\n+{\n+  tree type;\n+\n+  if (b->kind != sk_namespace)\n+    {\n+      /* Shadow the marker, not the real thing, so that the marker\n+\t gets restored later.  */\n+      tree old_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n+      b->type_shadowed\n+\t= tree_cons (id, old_type_value, b->type_shadowed);\n+      type = decl ? TREE_TYPE (decl) : NULL_TREE;\n+    }\n+  else\n+    {\n+      cxx_binding *binding =\n+\tbinding_for_name (NAMESPACE_LEVEL (current_namespace), id);\n+      if (decl)\n+\t{\n+\t  if (binding->value)\n+\t    supplement_binding (binding, decl);\n+\t  else\n+\t    binding->value = decl;\n+\t}\n+      else\n+\tabort ();\n+      /* Store marker instead of real type.  */\n+      type = global_type_node;\n+    }\n+  SET_IDENTIFIER_TYPE_VALUE (id, type);\n+}\n+\n+/* As set_identifier_type_value_with_scope, but using\n+   current_binding_level.  */\n+\n+void\n+set_identifier_type_value (tree id, tree decl)\n+{\n+  set_identifier_type_value_with_scope (id, decl, current_binding_level);\n+}\n+\n /* Return (from the stack of) the BINDING, if any, establihsed at SCOPE.  */ \n \n static inline cxx_binding *\n@@ -458,25 +1168,531 @@ binding_for_name (cxx_scope *scope, tree name)\n   IDENTIFIER_NAMESPACE_BINDINGS (name) = result;\n   return result;\n }\n-\f\n-/* Namespace-scope manipulation routines.  */\n \n-/* Return the binding value for name in scope.  */\n+/* Same as pushdecl, but define X in binding-level LEVEL.  We rely on the\n+   caller to set DECL_CONTEXT properly.  */\n \n tree\n-namespace_binding (tree name, tree scope)\n+pushdecl_with_scope (tree x, cxx_scope *level)\n {\n-  cxx_binding *binding;\n-\n-  if (scope == NULL)\n-    scope = global_namespace;\n-  scope = ORIGINAL_NAMESPACE (scope);\n-  binding = cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+  register struct cp_binding_level *b;\n+  tree function_decl = current_function_decl;\n \n-  return binding ? binding->value : NULL_TREE;\n-}\n-\n-/* Set the binding value for name in scope.  */\n+  timevar_push (TV_NAME_LOOKUP);\n+  current_function_decl = NULL_TREE;\n+  if (level->kind == sk_class)\n+    {\n+      b = class_binding_level;\n+      class_binding_level = level;\n+      pushdecl_class_level (x);\n+      class_binding_level = b;\n+    }\n+  else\n+    {\n+      b = current_binding_level;\n+      current_binding_level = level;\n+      x = pushdecl (x);\n+      current_binding_level = b;\n+    }\n+  current_function_decl = function_decl;\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n+}\n+\n+/* Return the type that should be used when TYPE's name is preceded\n+   by a tag such as 'struct' or 'union', or null if the name cannot\n+   be used in this way.\n+\n+   For example, when processing the third line of:\n+\n+\tstruct A;\n+\ttypedef struct A A;\n+\tstruct A;\n+\n+   lookup of A will find the typedef.  Given A's typedef, this function\n+   will return the type associated with \"struct A\".  For the tag to be\n+   anything other than TYPE, TYPE must be a typedef whose original type\n+   has the same name and context as TYPE itself.\n+\n+   It is not valid for a typedef of an anonymous type to be used with\n+   an explicit tag:\n+\n+       typedef struct { ... } B;\n+       struct B;\n+\n+   Return null for this case.  */\n+\n+static tree\n+follow_tag_typedef (tree type)\n+{\n+  tree original;\n+\n+  original = original_type (type);\n+  if (! TYPE_NAME (original))\n+    return NULL_TREE;\n+  if (TYPE_IDENTIFIER (original) == TYPE_IDENTIFIER (type)\n+      && (CP_DECL_CONTEXT (TYPE_NAME (original))\n+\t  == CP_DECL_CONTEXT (TYPE_NAME (type)))\n+      && !(CLASS_TYPE_P (original) && TYPE_WAS_ANONYMOUS (original)))\n+    return original;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Given NAME, an IDENTIFIER_NODE,\n+   return the structure (or union or enum) definition for that name.\n+   Searches binding levels from its SCOPE up to the global level.\n+   If THISLEVEL_ONLY is nonzero, searches only the specified context\n+   (but skips any sk_cleanup contexts to find one that is\n+   meaningful for tags).\n+   FORM says which kind of type the caller wants;\n+   it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.\n+   If the wrong kind of type is found, and it's not a template, an error is\n+   reported.  */\n+\n+tree\n+lookup_tag (enum tree_code form, tree name,\n+            cxx_scope *binding_level, int thislevel_only)\n+{\n+  register struct cp_binding_level *level;\n+  /* Nonzero if, we should look past a template parameter level, even\n+     if THISLEVEL_ONLY.  */\n+  int allow_template_parms_p = 1;\n+  bool type_is_anonymous = ANON_AGGRNAME_P (name);\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  for (level = binding_level; level; level = level->level_chain)\n+    {\n+      register tree tail;\n+      if (type_is_anonymous && level->type_decls != NULL)\n+        {\n+          tree type = binding_table_find_anon_type (level->type_decls, name);\n+          /* There is no need for error checking here, because\n+           anon names are unique throughout the compilation.  */\n+          if (type != NULL)\n+            POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n+        }\n+      else if (level->kind == sk_namespace)\n+\t/* Do namespace lookup.  */\n+\tfor (tail = current_namespace; 1; tail = CP_DECL_CONTEXT (tail))\n+\t  {\n+            cxx_binding *binding =\n+              cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (tail), name);\n+\t    tree old;\n+\n+\t    /* If we just skipped past a template parameter level,\n+\t       even though THISLEVEL_ONLY, and we find a template\n+\t       class declaration, then we use the _TYPE node for the\n+\t       template.  See the example below.  */\n+\t    if (thislevel_only && !allow_template_parms_p\n+\t\t&& binding && binding->value\n+\t\t&& DECL_CLASS_TEMPLATE_P (binding->value))\n+\t      old = binding->value;\n+\t    else if (binding)\n+\t      old = select_decl (binding, LOOKUP_PREFER_TYPES);\n+            else\n+              old = NULL_TREE;\n+\n+\t    if (old)\n+\t      {\n+\t\t/* We've found something at this binding level.  If it is\n+\t\t   a typedef, extract the tag it refers to.  Lookup fails\n+\t\t   if the typedef doesn't refer to a taggable type.  */\n+\t\told = TREE_TYPE (old);\n+\t\told = follow_tag_typedef (old);\n+\t\tif (!old)\n+\t\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+\t\tif (TREE_CODE (old) != form\n+\t\t    && (form == ENUMERAL_TYPE\n+\t\t\t|| TREE_CODE (old) == ENUMERAL_TYPE))\n+\t\t  {\n+\t\t    error (\"`%#D' redeclared as %C\", old, form);\n+\t\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+\t\t  }\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old);\n+\t      }\n+\t    if (thislevel_only || tail == global_namespace)\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+\t  }\n+      else if (level->type_decls != NULL)\n+        {\n+          binding_entry entry = binding_table_find (level->type_decls, name);\n+          if (entry != NULL)\n+            {\n+              enum tree_code code = TREE_CODE (entry->type);\n+\t\t\n+              if (code != form\n+                  && (form == ENUMERAL_TYPE || code == ENUMERAL_TYPE))\n+                {\n+                  /* Definition isn't the kind we were looking for.  */\n+                  error (\"`%#D' redeclared as %C\", entry->type, form);\n+                  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+                }\n+              POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->type);\n+            }\n+\t  }\n+      if (thislevel_only && level->kind != sk_cleanup)\n+\t{\n+\t  if (level->kind == sk_template_parms && allow_template_parms_p)\n+\t    {\n+\t      /* We must deal with cases like this:\n+\n+\t           template <class T> struct S;\n+\t\t   template <class T> struct S {};\n+\n+\t\t When looking up `S', for the second declaration, we\n+\t\t would like to find the first declaration.  But, we\n+\t\t are in the pseudo-global level created for the\n+\t\t template parameters, rather than the (surrounding)\n+\t\t namespace level.  Thus, we keep going one more level,\n+\t\t even though THISLEVEL_ONLY is nonzero.  */\n+\t      allow_template_parms_p = 0;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+\t}\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+}\n+\n+/* Given a type, find the tag that was defined for it and return the tag name.\n+   Otherwise return 0.  However, the value can never be 0\n+   in the cases in which this is used.\n+\n+   C++: If NAME is nonzero, this is the new name to install.  This is\n+   done when replacing anonymous tags with real tag names.  */\n+\n+tree\n+lookup_tag_reverse (tree type, tree name)\n+{\n+  register struct cp_binding_level *level;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  for (level = current_binding_level; level; level = level->level_chain)\n+    {\n+      binding_entry entry = level->type_decls == NULL\n+        ? NULL\n+        : binding_table_reverse_maybe_remap (level->type_decls, type, name);\n+      if (entry)\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, entry->name);\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+}\n+\f\n+/* Do a pushlevel for class declarations.  */\n+\n+void\n+pushlevel_class (void)\n+{\n+  if (ENABLE_SCOPE_CHECKING)\n+    is_class_level = 1;\n+\n+  class_binding_level = begin_scope (sk_class, current_class_type);\n+}\n+\n+/* ...and a poplevel for class declarations.  */\n+\n+void\n+poplevel_class (void)\n+{\n+  register struct cp_binding_level *level = class_binding_level;\n+  tree shadowed;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  my_friendly_assert (level != 0, 354);\n+\n+  /* If we're leaving a toplevel class, don't bother to do the setting\n+     of IDENTIFIER_CLASS_VALUE to NULL_TREE, since first of all this slot\n+     shouldn't even be used when current_class_type isn't set, and second,\n+     if we don't touch it here, we're able to use the cache effect if the\n+     next time we're entering a class scope, it is the same class.  */\n+  if (current_class_depth != 1)\n+    {\n+      struct cp_binding_level* b;\n+\n+      /* Clear out our IDENTIFIER_CLASS_VALUEs.  */\n+      for (shadowed = level->class_shadowed;\n+\t   shadowed;\n+\t   shadowed = TREE_CHAIN (shadowed))\n+\tIDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed)) = NULL_TREE;\n+\n+      /* Find the next enclosing class, and recreate\n+\t IDENTIFIER_CLASS_VALUEs appropriate for that class.  */\n+      b = level->level_chain;\n+      while (b && b->kind != sk_class)\n+\tb = b->level_chain;\n+\n+      if (b)\n+\tfor (shadowed = b->class_shadowed;\n+\t     shadowed;\n+\t     shadowed = TREE_CHAIN (shadowed))\n+\t  {\n+\t    cxx_binding *binding;\n+            \n+\t    binding = IDENTIFIER_BINDING (TREE_PURPOSE (shadowed));\n+\t    while (binding && binding->scope != b)\n+\t      binding = binding->previous;\n+\n+\t    if (binding)\n+\t      IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (shadowed))\n+\t\t= binding->value;\n+\t  }\n+    }\n+  else\n+    /* Remember to save what IDENTIFIER's were bound in this scope so we\n+       can recover from cache misses.  */\n+    {\n+      previous_class_type = current_class_type;\n+      previous_class_values = class_binding_level->class_shadowed;\n+    }\n+  for (shadowed = level->type_shadowed;\n+       shadowed;\n+       shadowed = TREE_CHAIN (shadowed))\n+    SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (shadowed), TREE_VALUE (shadowed));\n+\n+  /* Remove the bindings for all of the class-level declarations.  */\n+  for (shadowed = level->class_shadowed;\n+       shadowed;\n+       shadowed = TREE_CHAIN (shadowed))\n+    pop_binding (TREE_PURPOSE (shadowed), TREE_TYPE (shadowed));\n+\n+  /* Now, pop out of the binding level which we created up in the\n+     `pushlevel_class' routine.  */\n+  if (ENABLE_SCOPE_CHECKING)\n+    is_class_level = 1;\n+\n+  leave_scope ();\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Bind DECL to ID in the class_binding_level.  Returns nonzero if the\n+   binding was successful.  */\n+\n+int\n+push_class_binding (tree id, tree decl)\n+{\n+  int result = 1;\n+  cxx_binding *binding = IDENTIFIER_BINDING (id);\n+  tree context;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Note that we declared this value so that we can issue an error if\n+     this is an invalid redeclaration of a name already used for some\n+     other purpose.  */\n+  note_name_declared_in_class (id, decl);\n+\n+  if (binding && binding->scope == class_binding_level)\n+    /* Supplement the existing binding.  */\n+    result = supplement_binding (IDENTIFIER_BINDING (id), decl);\n+  else\n+    /* Create a new binding.  */\n+    push_binding (id, decl, class_binding_level);\n+\n+  /* Update the IDENTIFIER_CLASS_VALUE for this ID to be the\n+     class-level declaration.  Note that we do not use DECL here\n+     because of the possibility of the `struct stat' hack; if DECL is\n+     a class-name or enum-name we might prefer a field-name, or some\n+     such.  */\n+  IDENTIFIER_CLASS_VALUE (id) = IDENTIFIER_BINDING (id)->value;\n+\n+  /* If this is a binding from a base class, mark it as such.  */\n+  binding = IDENTIFIER_BINDING (id);\n+  if (binding->value == decl && TREE_CODE (decl) != TREE_LIST)\n+    {\n+      if (TREE_CODE (decl) == OVERLOAD)\n+\tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n+      else\n+\t{\n+\t  my_friendly_assert (DECL_P (decl), 0);\n+\t  context = context_for_name_lookup (decl);\n+\t}\n+\n+      if (is_properly_derived_from (current_class_type, context))\n+\tINHERITED_VALUE_BINDING_P (binding) = 1;\n+      else\n+\tINHERITED_VALUE_BINDING_P (binding) = 0;\n+    }\n+  else if (binding->value == decl)\n+    /* We only encounter a TREE_LIST when push_class_decls detects an\n+       ambiguity.  Such an ambiguity can be overridden by a definition\n+       in this class.  */\n+    INHERITED_VALUE_BINDING_P (binding) = 1;\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, result);\n+}\n+\n+/* We are entering the scope of a class.  Clear IDENTIFIER_CLASS_VALUE\n+   for any names in enclosing classes.  */\n+\n+void\n+clear_identifier_class_values (void)\n+{\n+  tree t;\n+\n+  if (!class_binding_level)\n+    return;\n+\n+  for (t = class_binding_level->class_shadowed;\n+       t;\n+       t = TREE_CHAIN (t))\n+    IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (t)) = NULL_TREE;\n+}\n+\n+/* Make the declaration of X appear in CLASS scope.  */\n+\n+bool\n+pushdecl_class_level (tree x)\n+{\n+  tree name;\n+  bool is_valid = true;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Get the name of X.  */\n+  if (TREE_CODE (x) == OVERLOAD)\n+    name = DECL_NAME (get_first_fn (x));\n+  else\n+    name = DECL_NAME (x);\n+\n+  if (name)\n+    {\n+      is_valid = push_class_level_binding (name, x);\n+      if (TREE_CODE (x) == TYPE_DECL)\n+\tset_identifier_type_value (name, x);\n+    }\n+  else if (ANON_AGGR_TYPE_P (TREE_TYPE (x)))\n+    {\n+      /* If X is an anonymous aggregate, all of its members are\n+\t treated as if they were members of the class containing the\n+\t aggregate, for naming purposes.  */\n+      tree f;\n+\n+      for (f = TYPE_FIELDS (TREE_TYPE (x)); f; f = TREE_CHAIN (f))\n+\t{\n+\t  location_t save_location = input_location;\n+\t  input_location = DECL_SOURCE_LOCATION (f);\n+\t  if (!pushdecl_class_level (f))\n+\t    is_valid = false;\n+\t  input_location = save_location;\n+\t}\n+    }\n+  timevar_pop (TV_NAME_LOOKUP);\n+\n+  return is_valid;\n+}\n+\n+/* Make the declaration(s) of X appear in CLASS scope under the name\n+   NAME.  Returns true if the binding is valid.  */\n+\n+bool\n+push_class_level_binding (tree name, tree x)\n+{\n+  cxx_binding *binding;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* The class_binding_level will be NULL if x is a template\n+     parameter name in a member template.  */\n+  if (!class_binding_level)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\n+  /* Make sure that this new member does not have the same name\n+     as a template parameter.  */\n+  if (TYPE_BEING_DEFINED (current_class_type))\n+    check_template_shadow (x);\n+\n+  /* If this declaration shadows a declaration from an enclosing\n+     class, then we will need to restore IDENTIFIER_CLASS_VALUE when\n+     we leave this class.  Record the shadowed declaration here.  */\n+  binding = IDENTIFIER_BINDING (name);\n+  if (binding && binding->value)\n+    {\n+      tree bval = binding->value;\n+      tree old_decl = NULL_TREE;\n+\n+      if (INHERITED_VALUE_BINDING_P (binding))\n+\t{\n+\t  /* If the old binding was from a base class, and was for a\n+  \t     tag name, slide it over to make room for the new binding.\n+  \t     The old binding is still visible if explicitly qualified\n+  \t     with a class-key.  */\n+\t  if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval)\n+\t      && !(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)))\n+\t    {\n+\t      old_decl = binding->type;\n+\t      binding->type = bval;\n+\t      binding->value = NULL_TREE;\n+\t      INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t    }\n+\t  else\n+\t    old_decl = bval;\n+\t}\n+      else if (TREE_CODE (x) == OVERLOAD && is_overloaded_fn (bval))\n+\told_decl = bval;\n+      else if (TREE_CODE (x) == USING_DECL && TREE_CODE (bval) == USING_DECL)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+      else if (TREE_CODE (x) == USING_DECL && is_overloaded_fn (bval))\n+\told_decl = bval;\n+      else if (TREE_CODE (bval) == USING_DECL && is_overloaded_fn (x))\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+      \n+      if (old_decl)\n+\t{\n+\t  tree shadow;\n+\t  \n+\t  /* Find the previous binding of name on the class-shadowed\n+             list, and update it.  */\n+\t  for (shadow = class_binding_level->class_shadowed;\n+\t       shadow;\n+\t       shadow = TREE_CHAIN (shadow))\n+\t    if (TREE_PURPOSE (shadow) == name\n+\t\t&& TREE_TYPE (shadow) == old_decl)\n+\t      {\n+\t\tbinding->value = x;\n+\t\tINHERITED_VALUE_BINDING_P (binding) = 0;\n+\t\tTREE_TYPE (shadow) = x;\n+\t\tIDENTIFIER_CLASS_VALUE (name) = x;\n+\t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+\t      }\n+\t}\n+    }\n+\n+  /* If we didn't replace an existing binding, put the binding on the\n+     stack of bindings for the identifier, and update the shadowed list.  */\n+  if (push_class_binding (name, x))\n+    {\n+      class_binding_level->class_shadowed\n+\t= tree_cons (name, NULL,\n+\t\t     class_binding_level->class_shadowed);\n+      /* Record the value we are binding NAME to so that we can know\n+\t what to pop later.  */\n+      TREE_TYPE (class_binding_level->class_shadowed) = x;\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, true);\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, false);\n+}\n+\n+void\n+set_class_shadows (tree shadows)\n+{\n+  class_binding_level->class_shadowed = shadows;\n+}\n+\f\n+/* Return the binding value for name in scope.  */\n+\n+tree\n+namespace_binding (tree name, tree scope)\n+{\n+  cxx_binding *binding;\n+\n+  if (scope == NULL)\n+    scope = global_namespace;\n+  scope = ORIGINAL_NAMESPACE (scope);\n+  binding = cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+\n+  return binding ? binding->value : NULL_TREE;\n+}\n+\n+/* Set the binding value for name in scope.  */\n \n void\n set_namespace_binding (tree name, tree scope, tree val)\n@@ -494,4 +1710,1011 @@ set_namespace_binding (tree name, tree scope, tree val)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \n+/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n+   select a name that is unique to this compilation unit.  */\n+\n+void\n+push_namespace (tree name)\n+{\n+  tree d = NULL_TREE;\n+  int need_new = 1;\n+  int implicit_use = 0;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  \n+  /* We should not get here if the global_namespace is not yet constructed\n+     nor if NAME designates the global namespace:  The global scope is\n+     constructed elsewhere.  */\n+  my_friendly_assert (global_namespace != NULL && name != global_scope_name,\n+                      20030531);\n+\n+  if (!name)\n+    {\n+      /* The name of anonymous namespace is unique for the translation\n+         unit.  */\n+      if (!anonymous_namespace_name)\n+        anonymous_namespace_name = get_file_function_name ('N');\n+      name = anonymous_namespace_name;\n+      d = IDENTIFIER_NAMESPACE_VALUE (name);\n+      if (d)\n+        /* Reopening anonymous namespace.  */\n+        need_new = 0;\n+      implicit_use = 1;\n+    }\n+  else\n+    {\n+      /* Check whether this is an extended namespace definition.  */\n+      d = IDENTIFIER_NAMESPACE_VALUE (name);\n+      if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n+        {\n+          need_new = 0;\n+          if (DECL_NAMESPACE_ALIAS (d))\n+            {\n+              error (\"namespace alias `%D' not allowed here, assuming `%D'\",\n+                        d, DECL_NAMESPACE_ALIAS (d));\n+              d = DECL_NAMESPACE_ALIAS (d);\n+            }\n+        }\n+    }\n+\n+  if (need_new)\n+    {\n+      /* Make a new namespace, binding the name to it.  */\n+      d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n+      DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n+      d = pushdecl (d);\n+      begin_scope (sk_namespace, d);\n+    }\n+  else\n+    resume_scope (NAMESPACE_LEVEL (d));\n+\n+  if (implicit_use)\n+    do_using_directive (d);\n+  /* Enter the name space.  */\n+  current_namespace = d;\n+\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Pop from the scope of the current namespace.  */\n+\n+void\n+pop_namespace (void)\n+{\n+  my_friendly_assert (current_namespace != global_namespace, 20010801);\n+  current_namespace = CP_DECL_CONTEXT (current_namespace);\n+  /* The binding level is not popped, as it might be re-opened later.  */\n+  leave_scope ();\n+}\n+\n+/* Push into the scope of the namespace NS, even if it is deeply\n+   nested within another namespace.  */\n+\n+void\n+push_nested_namespace (tree ns)\n+{\n+  if (ns == global_namespace)\n+    push_to_top_level ();\n+  else\n+    {\n+      push_nested_namespace (CP_DECL_CONTEXT (ns));\n+      push_namespace (DECL_NAME (ns));\n+    }\n+}\n+\n+/* Pop back from the scope of the namespace NS, which was previously\n+   entered with push_nested_namespace.  */\n+\n+void\n+pop_nested_namespace (tree ns)\n+{\n+  timevar_push (TV_NAME_LOOKUP);\n+  while (ns != global_namespace)\n+    {\n+      pop_namespace ();\n+      ns = CP_DECL_CONTEXT (ns);\n+    }\n+\n+  pop_from_top_level ();\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Like pushdecl, only it places X in the current namespace,\n+   if appropriate.  */\n+\n+tree\n+pushdecl_namespace_level (tree x)\n+{\n+  register struct cp_binding_level *b = current_binding_level;\n+  register tree t;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n+\n+  /* Now, the type_shadowed stack may screw us.  Munge it so it does\n+     what we want.  */\n+  if (TREE_CODE (x) == TYPE_DECL)\n+    {\n+      tree name = DECL_NAME (x);\n+      tree newval;\n+      tree *ptr = (tree *)0;\n+      for (; !global_scope_p (b); b = b->level_chain)\n+        {\n+          tree shadowed = b->type_shadowed;\n+          for (; shadowed; shadowed = TREE_CHAIN (shadowed))\n+            if (TREE_PURPOSE (shadowed) == name)\n+              {\n+\t\tptr = &TREE_VALUE (shadowed);\n+\t\t/* Can't break out of the loop here because sometimes\n+\t\t   a binding level will have duplicate bindings for\n+\t\t   PT names.  It's gross, but I haven't time to fix it.  */\n+              }\n+        }\n+      newval = TREE_TYPE (x);\n+      if (ptr == (tree *)0)\n+        {\n+          /* @@ This shouldn't be needed.  My test case \"zstring.cc\" trips\n+             up here if this is changed to an assertion.  --KR  */\n+\t  SET_IDENTIFIER_TYPE_VALUE (name, x);\n+\t}\n+      else\n+        {\n+\t  *ptr = newval;\n+        }\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+}\n+\n+/* Return the declarations that are members of the namespace NS.  */\n+\n+tree\n+cp_namespace_decls (tree ns)\n+{\n+  return NAMESPACE_LEVEL (ns)->names;\n+}\n+\n+/* Combine prefer_type and namespaces_only into flags.  */\n+\n+static int\n+lookup_flags (int prefer_type, int namespaces_only)\n+{\n+  if (namespaces_only)\n+    return LOOKUP_PREFER_NAMESPACES;\n+  if (prefer_type > 1)\n+    return LOOKUP_PREFER_TYPES;\n+  if (prefer_type > 0)\n+    return LOOKUP_PREFER_BOTH;\n+  return 0;\n+}\n+\n+/* Given a lookup that returned VAL, use FLAGS to decide if we want to\n+   ignore it or not.  Subroutine of lookup_name_real.  */\n+\n+static tree\n+qualify_lookup (tree val, int flags)\n+{\n+  if (val == NULL_TREE)\n+    return val;\n+  if ((flags & LOOKUP_PREFER_NAMESPACES) && TREE_CODE (val) == NAMESPACE_DECL)\n+    return val;\n+  if ((flags & LOOKUP_PREFER_TYPES)\n+      && (TREE_CODE (val) == TYPE_DECL || TREE_CODE (val) == TEMPLATE_DECL))\n+    return val;\n+  if (flags & (LOOKUP_PREFER_NAMESPACES | LOOKUP_PREFER_TYPES))\n+    return NULL_TREE;\n+  return val;\n+}\n+\n+/* Look up NAME in the NAMESPACE.  */\n+\n+tree\n+lookup_namespace_name (tree namespace, tree name)\n+{\n+  tree val;\n+  tree template_id = NULL_TREE;\n+  cxx_binding binding;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  my_friendly_assert (TREE_CODE (namespace) == NAMESPACE_DECL, 370);\n+\n+  if (TREE_CODE (name) == NAMESPACE_DECL)\n+    /* This happens for A::B<int> when B is a namespace.  */\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, name);\n+  else if (TREE_CODE (name) == TEMPLATE_DECL)\n+    {\n+      /* This happens for A::B where B is a template, and there are no\n+\t template arguments.  */\n+      error (\"invalid use of `%D'\", name);\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+    }\n+\n+  namespace = ORIGINAL_NAMESPACE (namespace);\n+\n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+    {\n+      template_id = name;\n+      name = TREE_OPERAND (name, 0);\n+      if (TREE_CODE (name) == OVERLOAD)\n+\tname = DECL_NAME (OVL_CURRENT (name));\n+      else if (DECL_P (name))\n+\tname = DECL_NAME (name);\n+    }\n+\n+  my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE, 373);\n+\n+  cxx_binding_clear (&binding);\n+  if (!qualified_lookup_using_namespace (name, namespace, &binding, 0))\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\n+  if (binding.value)\n+    {\n+      val = binding.value;\n+\n+      if (template_id)\n+\t{\n+\t  if (DECL_CLASS_TEMPLATE_P (val))\n+\t    val = lookup_template_class (val,\n+\t\t\t\t\t TREE_OPERAND (template_id, 1),\n+\t\t\t\t\t /*in_decl=*/NULL_TREE,\n+\t\t\t\t\t /*context=*/NULL_TREE,\n+\t\t\t\t\t /*entering_scope=*/0,\n+\t                                 tf_error | tf_warning);\n+\t  else if (DECL_FUNCTION_TEMPLATE_P (val)\n+\t\t   || TREE_CODE (val) == OVERLOAD)\n+\t    val = lookup_template_function (val,\n+\t\t\t\t\t    TREE_OPERAND (template_id, 1));\n+\t  else\n+\t    {\n+\t      error (\"`%D::%D' is not a template\",\n+\t\t\tnamespace, name);\n+\t      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t    }\n+\t}\n+\n+      /* If we have a single function from a using decl, pull it out.  */\n+      if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n+\tval = OVL_FUNCTION (val);\n+\n+      /* Ignore built-in functions that haven't been prototyped yet.  */\n+      if (!val || !DECL_P(val)\n+          || !DECL_LANG_SPECIFIC(val)\n+          || !DECL_ANTICIPATED (val))\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+    }\n+\n+  error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+}\n+\n+/* Select the right _DECL from multiple choices.  */\n+\n+static tree\n+select_decl (cxx_binding *binding, int flags)\n+{\n+  tree val;\n+  val = binding->value;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  if (LOOKUP_NAMESPACES_ONLY (flags))\n+    {\n+      /* We are not interested in types.  */\n+      if (val && TREE_CODE (val) == NAMESPACE_DECL)\n+        POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+    }\n+\n+  /* If looking for a type, or if there is no non-type binding, select\n+     the value binding.  */\n+  if (binding->type && (!val || (flags & LOOKUP_PREFER_TYPES)))\n+    val = binding->type;\n+  /* Don't return non-types if we really prefer types.  */\n+  else if (val && LOOKUP_TYPES_ONLY (flags)  && TREE_CODE (val) != TYPE_DECL\n+\t   && (TREE_CODE (val) != TEMPLATE_DECL\n+\t       || !DECL_CLASS_TEMPLATE_P (val)))\n+    val = NULL_TREE;\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+}\n+\n+/* Unscoped lookup of a global: iterate over current namespaces,\n+   considering using-directives.  If SPACESP is non-NULL, store a list\n+   of the namespaces we've considered in it.  */\n+\n+tree\n+unqualified_namespace_lookup (tree name, int flags, tree* spacesp)\n+{\n+  tree initial = current_decl_namespace ();\n+  tree scope = initial;\n+  tree siter;\n+  struct cp_binding_level *level;\n+  tree val = NULL_TREE;\n+  cxx_binding binding;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  cxx_binding_clear (&binding);\n+  if (spacesp)\n+    *spacesp = NULL_TREE;\n+\n+  for (; !val; scope = CP_DECL_CONTEXT (scope))\n+    {\n+      cxx_binding *b =\n+         cxx_scope_find_binding_for_name (NAMESPACE_LEVEL (scope), name);\n+      if (spacesp)\n+\t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n+\n+      /* Ignore anticipated built-in functions.  */\n+      if (b && b->value && DECL_P (b->value)\n+          && DECL_LANG_SPECIFIC (b->value) && DECL_ANTICIPATED (b->value))\n+        /* Keep binding cleared.  */;\n+      else if (b)\n+        {\n+          /* Initialize binding for this context.  */\n+          binding.value = b->value;\n+          binding.type = b->type;\n+        }\n+\n+      /* Add all _DECLs seen through local using-directives.  */\n+      for (level = current_binding_level;\n+\t   level->kind != sk_namespace;\n+\t   level = level->level_chain)\n+\tif (!lookup_using_namespace (name, &binding, level->using_directives,\n+                                     scope, flags, spacesp))\n+\t  /* Give up because of error.  */\n+\t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\n+      /* Add all _DECLs seen through global using-directives.  */\n+      /* XXX local and global using lists should work equally.  */\n+      siter = initial;\n+      while (1)\n+\t{\n+\t  if (!lookup_using_namespace (name, &binding,\n+                                       DECL_NAMESPACE_USING (siter),\n+\t\t\t\t       scope, flags, spacesp))\n+\t    /* Give up because of error.  */\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n+\t  if (siter == scope) break;\n+\t  siter = CP_DECL_CONTEXT (siter);\n+\t}\n+\n+      val = select_decl (&binding, flags);\n+      if (scope == global_namespace)\n+\tbreak;\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+}\n+\n+/* Look up NAME (an IDENTIFIER_NODE) in SCOPE (either a NAMESPACE_DECL\n+   or a class TYPE).  If IS_TYPE_P is TRUE, then ignore non-type\n+   bindings.  \n+\n+   Returns a DECL (or OVERLOAD, or BASELINK) representing the\n+   declaration found.  If no suitable declaration can be found,\n+   ERROR_MARK_NODE is returned.  Iif COMPLAIN is true and SCOPE is\n+   neither a class-type nor a namespace a diagnostic is issued.  */\n+\n+tree\n+lookup_qualified_name (tree scope, tree name, bool is_type_p, bool complain)\n+{\n+  int flags = 0;\n+\n+  if (TREE_CODE (scope) == NAMESPACE_DECL)\n+    {\n+      cxx_binding binding;\n+\n+      cxx_binding_clear (&binding);\n+      flags |= LOOKUP_COMPLAIN;\n+      if (is_type_p)\n+\tflags |= LOOKUP_PREFER_TYPES;\n+      if (qualified_lookup_using_namespace (name, scope, &binding, \n+\t\t\t\t\t    flags))\n+\treturn select_decl (&binding, flags);\n+    }\n+  else if (is_aggr_type (scope, complain))\n+    {\n+      tree t;\n+      t = lookup_member (scope, name, 0, is_type_p);\n+      if (t)\n+\treturn t;\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Look up NAME in the current binding level and its superiors in the\n+   namespace of variables, functions and typedefs.  Return a ..._DECL\n+   node of some kind representing its definition if there is only one\n+   such declaration, or return a TREE_LIST with all the overloaded\n+   definitions if there are many, or return 0 if it is undefined.\n+\n+   If PREFER_TYPE is > 0, we prefer TYPE_DECLs or namespaces.\n+   If PREFER_TYPE is > 1, we reject non-type decls (e.g. namespaces).\n+   Otherwise we prefer non-TYPE_DECLs.\n+\n+   If NONCLASS is nonzero, we don't look for the NAME in class scope,\n+   using IDENTIFIER_CLASS_VALUE.  */\n+\n+tree\n+lookup_name_real (tree name, int prefer_type, int nonclass, \n+\t\t  int namespaces_only, int flags)\n+{\n+  cxx_binding *iter;\n+  tree val = NULL_TREE;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Conversion operators are handled specially because ordinary\n+     unqualified name lookup will not find template conversion\n+     operators.  */\n+  if (IDENTIFIER_TYPENAME_P (name)) \n+    {\n+      struct cp_binding_level *level;\n+\n+      for (level = current_binding_level; \n+\t   level && level->kind != sk_namespace;\n+\t   level = level->level_chain)\n+\t{\n+\t  tree class_type;\n+\t  tree operators;\n+\t  \n+\t  /* A conversion operator can only be declared in a class \n+\t     scope.  */\n+\t  if (level->kind != sk_class)\n+\t    continue;\n+\t  \n+\t  /* Lookup the conversion operator in the class.  */\n+\t  class_type = level->this_entity;\n+\t  operators = lookup_fnfields (class_type, name, /*protect=*/0);\n+\t  if (operators)\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, operators);\n+\t}\n+\n+      POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+    }\n+\n+  flags |= lookup_flags (prefer_type, namespaces_only);\n+\n+  /* First, look in non-namespace scopes.  */\n+\n+  if (current_class_type == NULL_TREE)\n+    nonclass = 1;\n+\n+  for (iter = IDENTIFIER_BINDING (name); iter; iter = iter->previous)\n+    {\n+      tree binding;\n+\n+      if (!LOCAL_BINDING_P (iter) && nonclass)\n+\t/* We're not looking for class-scoped bindings, so keep going.  */\n+\tcontinue;\n+\n+      /* If this is the kind of thing we're looking for, we're done.  */\n+      if (qualify_lookup (iter->value, flags))\n+\tbinding = iter->value;\n+      else if ((flags & LOOKUP_PREFER_TYPES)\n+\t       && qualify_lookup (iter->type, flags))\n+\tbinding = iter->type;\n+      else\n+\tbinding = NULL_TREE;\n+\n+      if (binding)\n+\t{\n+\t  val = binding;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Now lookup in namespace scopes.  */\n+  if (!val)\n+    {\n+      tree t = unqualified_namespace_lookup (name, flags, 0);\n+      if (t)\n+\tval = t;\n+    }\n+\n+  if (val)\n+    {\n+      /* If we have a single function from a using decl, pull it out.  */\n+      if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n+\tval = OVL_FUNCTION (val);\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, val);\n+}\n+\n+tree\n+lookup_name_nonclass (tree name)\n+{\n+  return lookup_name_real (name, 0, 1, 0, LOOKUP_COMPLAIN);\n+}\n+\n+tree\n+lookup_function_nonclass (tree name, tree args)\n+{\n+  return lookup_arg_dependent (name, lookup_name_nonclass (name), args);\n+}\n+\n+tree\n+lookup_name (tree name, int prefer_type)\n+{\n+  return lookup_name_real (name, prefer_type, 0, 0, LOOKUP_COMPLAIN);\n+}\n+\n+/* Similar to `lookup_name' but look only in the innermost non-class\n+   binding level.  */\n+\n+tree\n+lookup_name_current_level (tree name)\n+{\n+  struct cp_binding_level *b;\n+  tree t = NULL_TREE;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  b = innermost_nonclass_level ();\n+\n+  if (b->kind == sk_namespace)\n+    {\n+      t = IDENTIFIER_NAMESPACE_VALUE (name);\n+\n+      /* extern \"C\" function() */\n+      if (t != NULL_TREE && TREE_CODE (t) == TREE_LIST)\n+\tt = TREE_VALUE (t);\n+    }\n+  else if (IDENTIFIER_BINDING (name)\n+\t   && LOCAL_BINDING_P (IDENTIFIER_BINDING (name)))\n+    {\n+      while (1)\n+\t{\n+\t  if (IDENTIFIER_BINDING (name)->scope == b)\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, IDENTIFIER_VALUE (name));\n+\n+\t  if (b->kind == sk_cleanup)\n+\t    b = b->level_chain;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+}\n+\n+/* Like lookup_name_current_level, but for types.  */\n+\n+tree\n+lookup_type_current_level (tree name)\n+{\n+  register tree t = NULL_TREE;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  my_friendly_assert (current_binding_level->kind != sk_namespace, \n+\t\t      980716);\n+\n+  if (REAL_IDENTIFIER_TYPE_VALUE (name) != NULL_TREE\n+      && REAL_IDENTIFIER_TYPE_VALUE (name) != global_type_node)\n+    {\n+      struct cp_binding_level *b = current_binding_level;\n+      while (1)\n+\t{\n+\t  if (purpose_member (name, b->type_shadowed))\n+\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP,\n+                                    REAL_IDENTIFIER_TYPE_VALUE (name));\n+\t  if (b->kind == sk_cleanup)\n+\t    b = b->level_chain;\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n+}\n+\n+/* Add namespace to using_directives. Return NULL_TREE if nothing was\n+   changed (i.e. there was already a directive), or the fresh\n+   TREE_LIST otherwise.  */\n+\n+tree\n+push_using_directive (tree used)\n+{\n+  tree ud = current_binding_level->using_directives;\n+  tree iter, ancestor;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  /* Check if we already have this.  */\n+  if (purpose_member (used, ud) != NULL_TREE)\n+    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, NULL_TREE);\n+\n+  ancestor = namespace_ancestor (current_decl_namespace (), used);\n+  ud = current_binding_level->using_directives;\n+  ud = tree_cons (used, ancestor, ud);\n+  current_binding_level->using_directives = ud;\n+\n+  /* Recursively add all namespaces used.  */\n+  for (iter = DECL_NAMESPACE_USING (used); iter; iter = TREE_CHAIN (iter))\n+    push_using_directive (TREE_PURPOSE (iter));\n+\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, ud);\n+}\n+\n+/* The type TYPE is being declared.  If it is a class template, or a\n+   specialization of a class template, do any processing required and\n+   perform error-checking.  If IS_FRIEND is nonzero, this TYPE is\n+   being declared a friend.  B is the binding level at which this TYPE\n+   should be bound.\n+\n+   Returns the TYPE_DECL for TYPE, which may have been altered by this\n+   processing.  */\n+\n+static tree\n+maybe_process_template_type_declaration (tree type, int globalize,\n+                                         cxx_scope *b)\n+{\n+  tree decl = TYPE_NAME (type);\n+\n+  if (processing_template_parmlist)\n+    /* You can't declare a new template type in a template parameter\n+       list.  But, you can declare a non-template type:\n+\n+         template <class A*> struct S;\n+\n+       is a forward-declaration of `A'.  */\n+    ;\n+  else\n+    {\n+      maybe_check_template_type (type);\n+\n+      my_friendly_assert (IS_AGGR_TYPE (type)\n+\t\t\t  || TREE_CODE (type) == ENUMERAL_TYPE, 0);\n+\n+\n+      if (processing_template_decl)\n+\t{\n+\t  /* This may change after the call to\n+\t     push_template_decl_real, but we want the original value.  */\n+\t  tree name = DECL_NAME (decl);\n+\n+\t  decl = push_template_decl_real (decl, globalize);\n+\t  /* If the current binding level is the binding level for the\n+\t     template parameters (see the comment in\n+\t     begin_template_parm_list) and the enclosing level is a class\n+\t     scope, and we're not looking at a friend, push the\n+\t     declaration of the member class into the class scope.  In the\n+\t     friend case, push_template_decl will already have put the\n+\t     friend into global scope, if appropriate.  */\n+\t  if (TREE_CODE (type) != ENUMERAL_TYPE\n+\t      && !globalize && b->kind == sk_template_parms\n+\t      && b->level_chain->kind == sk_class)\n+\t    {\n+\t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n+\t      /* Put this UDT in the table of UDTs for the class, since\n+\t\t that won't happen below because B is not the class\n+\t\t binding level, but is instead the pseudo-global level.  */\n+              if (b->level_chain->type_decls == NULL)\n+                b->level_chain->type_decls =\n+                  binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+              binding_table_insert (b->level_chain->type_decls, name, type);\n+\t      if (!COMPLETE_TYPE_P (current_class_type))\n+\t\t{\n+\t\t  maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t\t      type, /*friend_p=*/0);\n+\t\t  CLASSTYPE_NESTED_UTDS (current_class_type) =\n+                    b->level_chain->type_decls;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+\n+  return decl;\n+}\n+\n+/* Push a tag name NAME for struct/class/union/enum type TYPE.\n+   Normally put it into the inner-most non-sk_cleanup scope,\n+   but if GLOBALIZE is true, put it in the inner-most non-class scope.\n+   The latter is needed for implicit declarations.  */\n+\n+void\n+pushtag (tree name, tree type, int globalize)\n+{\n+  register struct cp_binding_level *b;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  b = current_binding_level;\n+  while (b->kind == sk_cleanup\n+\t || (b->kind == sk_class\n+\t     && (globalize\n+\t\t /* We may be defining a new type in the initializer\n+\t\t    of a static member variable. We allow this when\n+\t\t    not pedantic, and it is particularly useful for\n+\t\t    type punning via an anonymous union.  */\n+\t\t || COMPLETE_TYPE_P (b->this_entity))))\n+    b = b->level_chain;\n+\n+  if (b->type_decls == NULL)\n+    b->type_decls = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+  binding_table_insert (b->type_decls, name, type);\n+\n+  if (name)\n+    {\n+      /* Do C++ gratuitous typedefing.  */\n+      if (IDENTIFIER_TYPE_VALUE (name) != type)\n+        {\n+          register tree d = NULL_TREE;\n+\t  int in_class = 0;\n+\t  tree context = TYPE_CONTEXT (type);\n+\n+\t  if (! context)\n+\t    {\n+\t      tree cs = current_scope ();\n+\n+\t      if (! globalize)\n+\t\tcontext = cs;\n+\t      else if (cs != NULL_TREE && TYPE_P (cs))\n+\t\t/* When declaring a friend class of a local class, we want\n+\t\t   to inject the newly named class into the scope\n+\t\t   containing the local class, not the namespace scope.  */\n+\t\tcontext = decl_function_context (get_type_decl (cs));\n+\t    }\n+\t  if (!context)\n+\t    context = current_namespace;\n+\n+\t  if (b->kind == sk_class\n+\t      || (b->kind == sk_template_parms \n+\t\t  && b->level_chain->kind == sk_class))\n+\t    in_class = 1;\n+\n+\t  if (current_lang_name == lang_name_java)\n+\t    TYPE_FOR_JAVA (type) = 1;\n+\n+\t  d = create_implicit_typedef (name, type);\n+\t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n+\t  if (! in_class)\n+\t    set_identifier_type_value_with_scope (name, d, b);\n+\n+\t  d = maybe_process_template_type_declaration (type,\n+\t\t\t\t\t\t       globalize, b);\n+\n+\t  if (b->kind == sk_class)\n+\t    {\n+\t      if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n+\t\t   class.  But if it's a member template class, we\n+\t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n+\t\t   is done later.  */\n+\t\tfinish_member_declaration (d);\n+\t      else\n+\t\tpushdecl_class_level (d);\n+\t    }\n+\t  else\n+\t    d = pushdecl_with_scope (d, b);\n+\n+\t  /* FIXME what if it gets a name from typedef?  */\n+\t  if (ANON_AGGRNAME_P (name))\n+\t    DECL_IGNORED_P (d) = 1;\n+\n+\t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n+\n+\t  /* If this is a local class, keep track of it.  We need this\n+\t     information for name-mangling, and so that it is possible to find\n+\t     all function definitions in a translation unit in a convenient\n+\t     way.  (It's otherwise tricky to find a member function definition\n+\t     it's only pointed to from within a local class.)  */\n+\t  if (TYPE_CONTEXT (type)\n+\t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL\n+\t      && !processing_template_decl)\n+\t    VARRAY_PUSH_TREE (local_classes, type);\n+        }\n+      if (b->kind == sk_class\n+\t  && !COMPLETE_TYPE_P (current_class_type))\n+\t{\n+\t  maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t      type, /*friend_p=*/0);\n+\t  CLASSTYPE_NESTED_UTDS (current_class_type) = b->type_decls;\n+\t}\n+    }\n+\n+  if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n+    /* Use the canonical TYPE_DECL for this node.  */\n+    TYPE_STUB_DECL (type) = TYPE_NAME (type);\n+  else\n+    {\n+      /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE\n+\t will be the tagged type we just added to the current\n+\t binding level.  This fake NULL-named TYPE_DECL node helps\n+\t dwarfout.c to know when it needs to output a\n+\t representation of a tagged type, and it also gives us a\n+\t convenient place to record the \"scope start\" address for\n+\t the tagged type.  */\n+\n+      tree d = build_decl (TYPE_DECL, NULL_TREE, type);\n+      TYPE_STUB_DECL (type) = pushdecl_with_scope (d, b);\n+    }\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\f\n+/* Allocate storage for saving a C++ binding.  */\n+#define cxx_saved_binding_make() \\\n+  (ggc_alloc (sizeof (cxx_saved_binding)))\n+\n+struct cxx_saved_binding GTY(())\n+{\n+  /* Link that chains saved C++ bindings for a given name into a stack.  */\n+  cxx_saved_binding *previous;\n+  /* The name of the current binding.  */\n+  tree identifier;\n+  /* The binding we're saving.  */\n+  cxx_binding *binding;\n+  tree class_value;\n+  tree real_type_value;\n+};\n+\n+/* Subroutines for reverting temporarily to top-level for instantiation\n+   of templates and such.  We actually need to clear out the class- and\n+   local-value slots of all identifiers, so that only the global values\n+   are at all visible.  Simply setting current_binding_level to the global\n+   scope isn't enough, because more binding levels may be pushed.  */\n+struct saved_scope *scope_chain;\n+\n+static cxx_saved_binding *\n+store_bindings (tree names, cxx_saved_binding *old_bindings)\n+{\n+  tree t;\n+  cxx_saved_binding *search_bindings = old_bindings;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  for (t = names; t; t = TREE_CHAIN (t))\n+    {\n+      tree id;\n+      cxx_saved_binding *saved;\n+      cxx_saved_binding *t1;\n+\n+      if (TREE_CODE (t) == TREE_LIST)\n+\tid = TREE_PURPOSE (t);\n+      else\n+\tid = DECL_NAME (t);\n+\n+      if (!id\n+\t  /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n+\t     we have no IDENTIFIER_BINDING if we have left the class\n+\t     scope, but cached the class-level declarations.  */\n+\t  || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n+\tcontinue;\n+\n+      for (t1 = search_bindings; t1; t1 = t1->previous)\n+\tif (t1->identifier == id)\n+\t  goto skip_it;\n+\n+      my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n+      saved = cxx_saved_binding_make ();\n+      saved->previous = old_bindings;\n+      saved->identifier = id;\n+      saved->binding = IDENTIFIER_BINDING (id);\n+      saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n+      saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n+      IDENTIFIER_BINDING (id) = NULL;\n+      IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n+      old_bindings = saved;\n+    skip_it:\n+      ;\n+    }\n+  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n+}\n+\n+void\n+maybe_push_to_top_level (int pseudo)\n+{\n+  struct saved_scope *s;\n+  struct cp_binding_level *b;\n+  cxx_saved_binding *old_bindings;\n+  int need_pop;\n+\n+  timevar_push (TV_NAME_LOOKUP);\n+  s = ggc_alloc_cleared (sizeof (struct saved_scope));\n+\n+  b = scope_chain ? current_binding_level : 0;\n+\n+  /* If we're in the middle of some function, save our state.  */\n+  if (cfun)\n+    {\n+      need_pop = 1;\n+      push_function_context_to (NULL_TREE);\n+    }\n+  else\n+    need_pop = 0;\n+\n+  old_bindings = NULL;\n+  if (scope_chain && previous_class_type)\n+    old_bindings = store_bindings (previous_class_values, old_bindings);\n+\n+  /* Have to include the global scope, because class-scope decls\n+     aren't listed anywhere useful.  */\n+  for (; b; b = b->level_chain)\n+    {\n+      tree t;\n+\n+      /* Template IDs are inserted into the global level. If they were\n+\t inserted into namespace level, finish_file wouldn't find them\n+\t when doing pending instantiations. Therefore, don't stop at\n+\t namespace level, but continue until :: .  */\n+      if (global_scope_p (b) || (pseudo && b->kind == sk_template_parms))\n+\tbreak;\n+\n+      old_bindings = store_bindings (b->names, old_bindings);\n+      /* We also need to check class_shadowed to save class-level type\n+\t bindings, since pushclass doesn't fill in b->names.  */\n+      if (b->kind == sk_class)\n+\told_bindings = store_bindings (b->class_shadowed, old_bindings);\n+\n+      /* Unwind type-value slots back to top level.  */\n+      for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n+\tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n+    }\n+  s->prev = scope_chain;\n+  s->old_bindings = old_bindings;\n+  s->bindings = b;\n+  s->need_pop_function_context = need_pop;\n+  s->function_decl = current_function_decl;\n+  s->last_parms = last_function_parms;\n+\n+  scope_chain = s;\n+  current_function_decl = NULL_TREE;\n+  VARRAY_TREE_INIT (current_lang_base, 10, \"current_lang_base\");\n+  current_lang_name = lang_name_cplusplus;\n+  current_namespace = global_namespace;\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+void\n+push_to_top_level (void)\n+{\n+  maybe_push_to_top_level (0);\n+}\n+\n+void\n+pop_from_top_level (void)\n+{\n+  struct saved_scope *s = scope_chain;\n+  cxx_saved_binding *saved;\n+\n+  timevar_push (TV_NAME_LOOKUP); \n+  /* Clear out class-level bindings cache.  */\n+  if (previous_class_type)\n+    invalidate_class_lookup_cache ();\n+\n+  current_lang_base = 0;\n+\n+  scope_chain = s->prev;\n+  for (saved = s->old_bindings; saved; saved = saved->previous)\n+    {\n+      tree id = saved->identifier;\n+\n+      IDENTIFIER_BINDING (id) = saved->binding;\n+      IDENTIFIER_CLASS_VALUE (id) = saved->class_value;\n+      SET_IDENTIFIER_TYPE_VALUE (id, saved->real_type_value);\n+    }\n+\n+  /* If we were in the middle of compiling a function, restore our\n+     state.  */\n+  if (s->need_pop_function_context)\n+    pop_function_context_from (NULL_TREE);\n+  current_function_decl = s->function_decl;\n+  last_function_parms = s->last_parms;\n+  timevar_pop (TV_NAME_LOOKUP);\n+}\n+\n+/* Pop off extraneous binding levels left over due to syntax errors.\n+\n+   We don't pop past namespaces, as they might be valid.  */\n+\n+void\n+pop_everything (void)\n+{\n+  if (ENABLE_SCOPE_CHECKING)\n+    verbatim (\"XXX entering pop_everything ()\\n\");\n+  while (!toplevel_bindings_p ())\n+    {\n+      if (current_binding_level->kind == sk_class)\n+\tpop_nested_class ();\n+      else\n+\tpoplevel (0, 0, 0);\n+    }\n+  if (ENABLE_SCOPE_CHECKING)\n+    verbatim (\"XXX leaving pop_everything ()\\n\");\n+}\n+\n #include \"gt-cp-name-lookup.h\""}, {"sha": "7153cbecfeb3139891f1b03ecb67b9d4dd5450fe", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 55, "deletions": 10, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e8de680e6a5c880ac9aec78b765f6e1d2531dc/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=00e8de680e6a5c880ac9aec78b765f6e1d2531dc", "patch": "@@ -46,12 +46,6 @@ struct binding_entry_s GTY(())\n #define NAMESPACE_STD_HT_SIZE                        (1 << 8)\n #define GLOBAL_SCOPE_HT_SIZE                         (1 << 8)\n \n-extern binding_table binding_table_new (size_t);\n-extern void binding_table_free (binding_table);\n-extern void binding_table_insert (binding_table, tree, tree);\n-extern tree binding_table_find_anon_type (binding_table, tree);\n-extern binding_entry binding_table_reverse_maybe_remap (binding_table,\n-                                                        tree, tree);\n extern void binding_table_remove_anonymous_types (binding_table);\n extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n extern binding_entry binding_table_find (binding_table, tree);\n@@ -93,9 +87,10 @@ struct cxx_binding GTY(())\n   unsigned is_local : 1;\n };\n \n-extern cxx_binding *cxx_binding_make (tree, tree);\n-extern void cxx_binding_free (cxx_binding *);\n-extern bool supplement_binding (cxx_binding *, tree);\n+extern tree identifier_type_value (tree);\n+extern void set_identifier_type_value (tree, tree);\n+extern void pop_binding (tree, tree);\n+extern void clear_identifier_class_values (void);\n \f\n /* The kinds of scopes we recognize.  */\n typedef enum scope_kind {\n@@ -246,16 +241,66 @@ struct cp_binding_level GTY(())\n \n /* The tree node representing the global scope.  */\n extern GTY(()) tree global_namespace;\n+extern GTY(()) tree global_scope_name;\n+\n+/* Indicates that there is a type value in some namespace, although\n+   that is not necessarily in scope at the moment.  */\n+\n+extern GTY(()) tree global_type_node;\n \n /* True if SCOPE designates the global scope binding contour.  */\n #define global_scope_p(SCOPE) \\\n   ((SCOPE) == NAMESPACE_LEVEL (global_namespace))\n \n+extern cxx_scope *leave_scope (void);\n+extern bool kept_level_p (void);\n+extern int global_bindings_p (void);\n+extern bool toplevel_bindings_p\t(void);\n+extern bool namespace_bindings_p (void);\n+extern bool template_parm_scope_p (void);\n+extern scope_kind innermost_scope_kind (void);\n+extern cxx_scope *begin_scope (scope_kind, tree);\n+extern void print_binding_stack\t(void);\n+extern void print_binding_level\t(cxx_scope *);\n+extern void push_to_top_level (void);\n+extern void pop_from_top_level (void);\n+extern void maybe_push_to_top_level (int);\n+extern void pop_everything (void);\n+extern void keep_next_level (bool);\n+\f\n+extern void push_namespace (tree);\n+extern void pop_namespace (void);\n+extern void push_nested_namespace (tree);\n+extern void pop_nested_namespace (tree);\n+extern tree push_using_directive (tree);\n+extern void pushlevel_class (void);\n+extern void poplevel_class (void);\n extern cxx_binding *cxx_scope_find_binding_for_name (cxx_scope *, tree);\n extern cxx_binding *binding_for_name (cxx_scope *, tree);\n-\f\n+extern tree pushdecl_with_scope (tree, cxx_scope *);\n+extern tree lookup_tag (enum tree_code, tree, cxx_scope *, int);\n+extern tree lookup_tag_reverse (tree, tree);\n+extern tree lookup_name\t(tree, int);\n+extern tree lookup_name_real (tree, int, int, int, int);\n+extern tree lookup_name_current_level (tree);\n+extern tree lookup_type_current_level (tree);\n extern tree namespace_binding (tree, tree);\n+extern void add_decl_to_level (tree, cxx_scope *);\n extern void set_namespace_binding (tree, tree, tree);\n+extern tree lookup_namespace_name (tree, tree);\n+extern tree unqualified_namespace_lookup (tree, int, tree *);\n+extern tree lookup_qualified_name (tree, tree, bool, bool);\n+extern tree lookup_name_nonclass (tree);\n+extern tree lookup_function_nonclass (tree, tree);\n+extern void push_local_binding (tree, tree, int);\n+extern int push_class_binding (tree, tree);\n+extern bool pushdecl_class_level (tree);\n+extern tree pushdecl_namespace_level (tree);\n+extern bool push_class_level_binding (tree, tree);\n+extern void storetags (tree);\n+extern tree getdecls (void);\n+extern tree cp_namespace_decls (tree);\n+extern void set_class_shadows (tree);\n \n \n /* Set *DECL to the (non-hidden) declaration for ID at global scope,"}]}