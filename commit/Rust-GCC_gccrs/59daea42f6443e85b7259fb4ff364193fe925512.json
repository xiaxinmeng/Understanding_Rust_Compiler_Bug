{"sha": "59daea42f6443e85b7259fb4ff364193fe925512", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTlkYWVhNDJmNjQ0M2U4NWI3MjU5ZmI0ZmYzNjQxOTNmZTkyNTUxMg==", "commit": {"author": {"name": "Sameera Deshpande", "email": "sameera.deshpande@arm.com", "date": "2012-10-22T09:54:31Z"}, "committer": {"name": "Greta Yorsh", "email": "gretay@gcc.gnu.org", "date": "2012-10-22T09:54:31Z"}, "message": "arm.c (thumb2_emit_ldrd_pop): New function.\n\n2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n\t    Greta Yorsh  <Greta.Yorsh@arm.com>\n\n\t* config/arm/arm.c (thumb2_emit_ldrd_pop): New function.\n\t(arm_expand_epilogue): Use the new function.\n\n\nCo-Authored-By: Greta Yorsh <greta.yorsh@arm.com>\n\nFrom-SVN: r192680", "tree": {"sha": "bf7ce3036af78887bbcc4a7b1e2222d4d4395cb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf7ce3036af78887bbcc4a7b1e2222d4d4395cb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59daea42f6443e85b7259fb4ff364193fe925512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59daea42f6443e85b7259fb4ff364193fe925512", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59daea42f6443e85b7259fb4ff364193fe925512", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59daea42f6443e85b7259fb4ff364193fe925512/comments", "author": null, "committer": null, "parents": [{"sha": "922d9f679d15443bf8ce667197a02e982f17b4da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922d9f679d15443bf8ce667197a02e982f17b4da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/922d9f679d15443bf8ce667197a02e982f17b4da"}], "stats": {"total": 154, "additions": 153, "deletions": 1}, "files": [{"sha": "fbf4e8d2edb4193a60a067347cebb4469ad0226c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59daea42f6443e85b7259fb4ff364193fe925512/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59daea42f6443e85b7259fb4ff364193fe925512/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59daea42f6443e85b7259fb4ff364193fe925512", "patch": "@@ -1,3 +1,9 @@\n+2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n+\t    Greta Yorsh  <Greta.Yorsh@arm.com>\n+\n+\t* config/arm/arm.c (thumb2_emit_ldrd_pop): New function.\n+\t(arm_expand_epilogue): Use the new function.\n+\n 2012-10-22  Sameera Deshpande  <sameera.deshpande@arm.com>\n \t    Greta Yorsh  <Greta.Yorsh@arm.com>\n "}, {"sha": "1a822fb446137f0d20d54ab0dab3d90d0935ba81", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 147, "deletions": 1, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59daea42f6443e85b7259fb4ff364193fe925512/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59daea42f6443e85b7259fb4ff364193fe925512/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=59daea42f6443e85b7259fb4ff364193fe925512", "patch": "@@ -16265,6 +16265,143 @@ arm_emit_vfp_multi_reg_pop (int first_reg, int num_regs, rtx base_reg)\n   REG_NOTES (par) = dwarf;\n }\n \n+/* Generate and emit a pattern that will be recognized as LDRD pattern.  If even\n+   number of registers are being popped, multiple LDRD patterns are created for\n+   all register pairs.  If odd number of registers are popped, last register is\n+   loaded by using LDR pattern.  */\n+static void\n+thumb2_emit_ldrd_pop (unsigned long saved_regs_mask)\n+{\n+  int num_regs = 0;\n+  int i, j;\n+  rtx par = NULL_RTX;\n+  rtx dwarf = NULL_RTX;\n+  rtx tmp, reg, tmp1;\n+  bool return_in_pc;\n+\n+  return_in_pc = (saved_regs_mask & (1 << PC_REGNUM)) ? true : false;\n+  for (i = 0; i <= LAST_ARM_REGNUM; i++)\n+    if (saved_regs_mask & (1 << i))\n+      num_regs++;\n+\n+  gcc_assert (num_regs && num_regs <= 16);\n+\n+  /* We cannot generate ldrd for PC.  Hence, reduce the count if PC is\n+     to be popped.  So, if num_regs is even, now it will become odd,\n+     and we can generate pop with PC.  If num_regs is odd, it will be\n+     even now, and ldr with return can be generated for PC.  */\n+  if (return_in_pc)\n+    num_regs--;\n+\n+  gcc_assert (!(saved_regs_mask & (1 << SP_REGNUM)));\n+\n+  /* Var j iterates over all the registers to gather all the registers in\n+     saved_regs_mask.  Var i gives index of saved registers in stack frame.\n+     A PARALLEL RTX of register-pair is created here, so that pattern for\n+     LDRD can be matched.  As PC is always last register to be popped, and\n+     we have already decremented num_regs if PC, we don't have to worry\n+     about PC in this loop.  */\n+  for (i = 0, j = 0; i < (num_regs - (num_regs % 2)); j++)\n+    if (saved_regs_mask & (1 << j))\n+      {\n+        /* Create RTX for memory load.  */\n+        reg = gen_rtx_REG (SImode, j);\n+        tmp = gen_rtx_SET (SImode,\n+                           reg,\n+                           gen_frame_mem (SImode,\n+                               plus_constant (Pmode,\n+                                              stack_pointer_rtx, 4 * i)));\n+        RTX_FRAME_RELATED_P (tmp) = 1;\n+\n+        if (i % 2 == 0)\n+          {\n+            /* When saved-register index (i) is even, the RTX to be emitted is\n+               yet to be created.  Hence create it first.  The LDRD pattern we\n+               are generating is :\n+               [ (SET (reg_t0) (MEM (PLUS (SP) (NUM))))\n+                 (SET (reg_t1) (MEM (PLUS (SP) (NUM + 4)))) ]\n+               where target registers need not be consecutive.  */\n+            par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+            dwarf = NULL_RTX;\n+          }\n+\n+        /* ith register is added in PARALLEL RTX.  If i is even, the reg_i is\n+           added as 0th element and if i is odd, reg_i is added as 1st element\n+           of LDRD pattern shown above.  */\n+        XVECEXP (par, 0, (i % 2)) = tmp;\n+        dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\n+        if ((i % 2) == 1)\n+          {\n+            /* When saved-register index (i) is odd, RTXs for both the registers\n+               to be loaded are generated in above given LDRD pattern, and the\n+               pattern can be emitted now.  */\n+            par = emit_insn (par);\n+            REG_NOTES (par) = dwarf;\n+          }\n+\n+        i++;\n+      }\n+\n+  /* If the number of registers pushed is odd AND return_in_pc is false OR\n+     number of registers are even AND return_in_pc is true, last register is\n+     popped using LDR.  It can be PC as well.  Hence, adjust the stack first and\n+     then LDR with post increment.  */\n+\n+  /* Increment the stack pointer, based on there being\n+     num_regs 4-byte registers to restore.  */\n+  tmp = gen_rtx_SET (VOIDmode,\n+                     stack_pointer_rtx,\n+                     plus_constant (Pmode, stack_pointer_rtx, 4 * i));\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  emit_insn (tmp);\n+\n+  dwarf = NULL_RTX;\n+\n+  if (((num_regs % 2) == 1 && !return_in_pc)\n+      || ((num_regs % 2) == 0 && return_in_pc))\n+    {\n+      /* Scan for the single register to be popped.  Skip until the saved\n+         register is found.  */\n+      for (; (saved_regs_mask & (1 << j)) == 0; j++);\n+\n+      /* Gen LDR with post increment here.  */\n+      tmp1 = gen_rtx_MEM (SImode,\n+                          gen_rtx_POST_INC (SImode,\n+                                            stack_pointer_rtx));\n+      set_mem_alias_set (tmp1, get_frame_alias_set ());\n+\n+      reg = gen_rtx_REG (SImode, j);\n+      tmp = gen_rtx_SET (SImode, reg, tmp1);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      dwarf = alloc_reg_note (REG_CFA_RESTORE, reg, dwarf);\n+\n+      if (return_in_pc)\n+        {\n+          /* If return_in_pc, j must be PC_REGNUM.  */\n+          gcc_assert (j == PC_REGNUM);\n+          par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (2));\n+          XVECEXP (par, 0, 0) = ret_rtx;\n+          XVECEXP (par, 0, 1) = tmp;\n+          par = emit_jump_insn (par);\n+        }\n+      else\n+        {\n+          par = emit_insn (tmp);\n+        }\n+\n+      REG_NOTES (par) = dwarf;\n+    }\n+  else if ((num_regs % 2) == 1 && return_in_pc)\n+    {\n+      /* There are 2 registers to be popped.  So, generate the pattern\n+         pop_multiple_with_stack_update_and_return to pop in PC.  */\n+      arm_emit_multi_reg_pop (saved_regs_mask & (~((1 << j) - 1)));\n+    }\n+\n+  return;\n+}\n+\n /* Calculate the size of the return value that is passed in registers.  */\n static unsigned\n arm_size_return_regs (void)\n@@ -23199,7 +23336,16 @@ arm_expand_epilogue (bool really_return)\n         }\n       else\n         {\n-          arm_emit_multi_reg_pop (saved_regs_mask);\n+          if (current_tune->prefer_ldrd_strd\n+              && !optimize_function_for_size_p (cfun))\n+            {\n+              if (TARGET_THUMB2)\n+                thumb2_emit_ldrd_pop (saved_regs_mask);\n+              else\n+                arm_emit_multi_reg_pop (saved_regs_mask);\n+            }\n+          else\n+            arm_emit_multi_reg_pop (saved_regs_mask);\n         }\n \n       if (return_in_pc == true)"}]}