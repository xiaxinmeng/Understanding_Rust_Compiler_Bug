{"sha": "c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQzNzJlZjRjNjQ3NmRjNmVkNmRhMDFkYmUxYjQ0NTY0YWVlOTM4Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-07-21T09:42:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-07-21T09:42:21Z"}, "message": "tm.texi: Remove DEFAULT_VTABLE_THUNKS.\n\ngcc:\n\t* doc/tm.texi: Remove DEFAULT_VTABLE_THUNKS.\n\t* config/freebsd.h: Likewise.\n\t* config/linux.h: Likewise.\n\t* config/openbsd.h: Likewise.\n\t* config/alpha/linux-elf.h: Likewise.\n\t* config/arm/linux-elf.h: Likewise.\n\t* config/d30v/d30v.h: Likewise.\n\t* config/fr30/fr30.h: Likewise.\n\t* config/ia64/aix.h: Likewise.\n\t* config/ia64/ia64.h: Likewise.\n\t* config/mips/linux.h: Likewise.\n\t* config/pj/pj.h: Likewise.\n\t* config/rs6000/linux.h: Likewise.\n\t* config/sparc/linux.h: Likewise.\n\t* config/sparc/linux64.h: Likewise.\ncp:\n\tRemove flag_vtable_thunk. It is always on for the 3.0 ABI.\n\t* cp-tree.h (CPTI_DELTA2_IDENTIFIER): Remove.\n\t(CPTI_INDEX_IDENTIFIER): Remove.\n\t(CPT_PFN_OR_DELTA2_IDENTIFIER): Remove.\n\t(delta2_identifier): Remove.\n\t(index_identifier): Remove.\n\t(pfn_or_delta2_identifier): Remove.\n\t(flag_vtable_thunks): Remove.\n\t(VTABLE_DELTA2_NAME): Remove.\n\t(VTABLE_INDEX_NAME): Remove.\n\t(FNADDR_FROM_VTABLE_ENTRY): Adjust.\n\t(vfunc_ptr_type_node): Adjust.\n\t(VTABLE_NAME_PREFIX): Adjust.\n\t(build_vfn_ref): Lose first parameter.\n\t(fixup_all_virtual_upcast_offsets): Remove.\n\t* decl.c (initialize_predefined_identifiers): Remove\n\tdelta2_identifier, index_identifier, pfn_or_delta2_identifier.\n\t(init_decl_processing): Remove no-vtable-thunk code.\n\t* decl2.c (flag_vtable_thunks): Remove.\n\t(mark_vtable_entries): Remove no-vtable-thunk code.\n\t* error.c (dump_decl): Remove no-vtable-thunk code.\n\t(dump_expr): Adjust ptr to member function code.\n\t* init.c (initialize_vtable_ptrs): Remove no-vtable-thunk\n\tcode.\n\t* rtti.c (build_headof): Remove no-vtable-thunk code.\n\t(get_tinfo_decl_dynamic): Adjust build_vfn_ref call.\n\t* search.c (get_base_distance): Remove expand_upcast_fixups case.\n\t(virtual_context) Remove.\n\t(expand_upcast_fixups): Remove.\n\t(fixup_virtual_upcast_offsets): Remove.\n\t(fixup_all_virtual_upcast_offsets): Remove.\n\t* typeck.c (get_member_function_from_ptrfunc): Remove\n\tno-vtable-thunk code.\n\t* call.c (build_over_call): Adjust call to build_vfn_ref.\n\t* class.c (build_vfn_ref): Lose first parameter. Remove\n\tno-vtable-thunk code.\n\t(build_rtti_vtbl_entries): Remove no-vtable-thunk code.\n\t(build_vtable_entry): Remove no-vtable-thunk code.\n\nFrom-SVN: r44227", "tree": {"sha": "600fa30db184de710e309de080b6a3ad19d82722", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/600fa30db184de710e309de080b6a3ad19d82722"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/comments", "author": null, "committer": null, "parents": [{"sha": "f4653d92782e80a2ebceae16e81a2850452aa0c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4653d92782e80a2ebceae16e81a2850452aa0c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4653d92782e80a2ebceae16e81a2850452aa0c3"}], "stats": {"total": 748, "additions": 115, "deletions": 633}, "files": [{"sha": "5421fd0beb14d623db649ed070c9707aaf6bab50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -1,3 +1,21 @@\n+2001-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* doc/tm.texi: Remove DEFAULT_VTABLE_THUNKS.\n+\t* config/freebsd.h: Likewise.\n+\t* config/linux.h: Likewise.\n+\t* config/openbsd.h: Likewise.\n+\t* config/alpha/linux-elf.h: Likewise.\n+\t* config/arm/linux-elf.h: Likewise.\n+\t* config/d30v/d30v.h: Likewise.\n+\t* config/fr30/fr30.h: Likewise.\n+\t* config/ia64/aix.h: Likewise.\n+\t* config/ia64/ia64.h: Likewise.\n+\t* config/mips/linux.h: Likewise.\n+\t* config/pj/pj.h: Likewise.\n+\t* config/rs6000/linux.h: Likewise.\n+\t* config/sparc/linux.h: Likewise.\n+\t* config/sparc/linux64.h: Likewise.\n+\n 2001-07-20  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/fixincl.c(test_for_changes): force unsigned char comparisons"}, {"sha": "643005970bdc96d2c55b68b8e6bbc6e550a27903", "filename": "gcc/config/alpha/linux-elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Falpha%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Falpha%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flinux-elf.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -36,11 +36,6 @@ Boston, MA 02111-1307, USA.  */\n #define ELF_DYNAMIC_LINKER\t\"/lib/ld-linux.so.2\"\n #endif\n \n-#ifndef USE_GNULIBC_1\n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-#endif\n-\n #ifndef USE_GNULIBC_1\n #undef LIB_SPEC\n #define LIB_SPEC \\"}, {"sha": "4940ae92a56bf0dbce297a5d73fbf29b95880aaf", "filename": "gcc/config/arm/linux-elf.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Farm%2Flinux-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Farm%2Flinux-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flinux-elf.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -33,10 +33,6 @@ Boston, MA 02111-1307, USA.  */\n \t{ \"marm\", \"mlittle-endian\", \"mhard-float\", \"mapcs-32\", \"mno-thumb-interwork\" }\n #define CPP_APCS_PC_DEFAULT_SPEC \"-D__APCS_32__\"\n \n-/* This was defined in linux.h.  Define it here also. */\n-#undef  DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS   1\n-\n /* Handle #pragma weak and #pragma pack.  */\n #define HANDLE_SYSV_PRAGMA\n "}, {"sha": "ba874d8ce413e18e005691b5025543a3231ba188", "filename": "gcc/config/d30v/d30v.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fd30v%2Fd30v.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fd30v%2Fd30v.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fd30v%2Fd30v.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -884,19 +884,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n    `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n-/* GNU CC supports two ways of implementing C++ vtables: traditional or with\n-   so-called \"thunks\".  The flag `-fvtable-thunk' chooses between them.  Define\n-   this macro to be a C expression for the default value of that flag.  If\n-   `DEFAULT_VTABLE_THUNKS' is 0, GNU CC uses the traditional implementation by\n-   default.  The \"thunk\" implementation is more efficient (especially if you\n-   have provided an implementation of `ASM_OUTPUT_MI_THUNK', see *Note Function\n-   Entry::), but is not binary compatible with code compiled using the\n-   traditional implementation.  If you are writing a new ports, define\n-   `DEFAULT_VTABLE_THUNKS' to 1.\n-\n-   If you do not define this macro, the default for `-fvtable-thunk' is 0.  */\n-#define DEFAULT_VTABLE_THUNKS 0\n-\n \f\n /* Layout of Source Language Data Types */\n "}, {"sha": "9f41a55263e57258cfdccc8033fe2836d5661cd4", "filename": "gcc/config/fr30/fr30.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Ffr30%2Ffr30.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Ffr30%2Ffr30.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffr30%2Ffr30.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -312,18 +312,6 @@ extern int target_flags;\n    `HOST_FLOAT_WORDS_BIG_ENDIAN' for the host.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n-/* GNU CC supports two ways of implementing C++ vtables: traditional or with\n-   so-called \"thunks\".  The flag `-fvtable-thunk' chooses between them.  Define\n-   this macro to be a C expression for the default value of that flag.  If\n-   `DEFAULT_VTABLE_THUNKS' is 0, GNU CC uses the traditional implementation by\n-   default.  The \"thunk\" implementation is more efficient (especially if you\n-   have provided an implementation of `ASM_OUTPUT_MI_THUNK', but is not binary\n-   compatible with code compiled using the traditional implementation.  If you\n-   are writing a new ports, define `DEFAULT_VTABLE_THUNKS' to 1.\n-\n-   If you do not define this macro, the default for `-fvtable-thunk' is 0.  */\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n /*}}}*/ \f\n /*{{{  Layout of Source Language Data Types.  */ \n "}, {"sha": "56d16c330a78f41283955bb5bee9991c93d4f260", "filename": "gcc/config/freebsd.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Ffreebsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Ffreebsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffreebsd.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -150,10 +150,6 @@ is built with the --enable-threads configure-time option.}\t\t\\\n    libraries compiled with the native cc.  */\n #undef NO_DOLLAR_IN_LABEL\n \n-/* Use more efficient ``thunks'' to implement C++ vtables.  */\n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n /* The GNU tools operate better with dwarf2 than stabs.  Since we\n    don't have any native tools to be compatible with, default to\n    dwarf2.  */"}, {"sha": "cf1f4b0874a4040701760d114ba3b230a05f651b", "filename": "gcc/config/ia64/aix.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fia64%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fia64%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Faix.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -66,9 +66,6 @@ Boston, MA 02111-1307, USA.  */\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s\"\n \n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n /* Define this so we can compile MS code for use with WINE.  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP\n "}, {"sha": "5087223669d1e82152f74e3d504f72f502da4e77", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -416,18 +416,6 @@ while (0)\n /* A code distinguishing the floating point format of the target machine.  */\n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n-/* GNU CC supports two ways of implementing C++ vtables: traditional or with\n-   so-called \"thunks\".  The flag `-fvtable-thunk' chooses between them.  Define\n-   this macro to be a C expression for the default value of that flag.  If\n-   `DEFAULT_VTABLE_THUNKS' is 0, GNU CC uses the traditional implementation by\n-   default.  The \"thunk\" implementation is more efficient (especially if you\n-   have provided an implementation of `ASM_OUTPUT_MI_THUNK', but is not binary\n-   compatible with code compiled using the traditional implementation.  If you\n-   are writing a new ports, define `DEFAULT_VTABLE_THUNKS' to 1.\n-\n-   If you do not define this macro, the default for `-fvtable-thunk' is 0.  */\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n \f\n /* Layout of Source Language Data Types */\n "}, {"sha": "b6ade997563ff3c7795671b97fae63b72a2de340", "filename": "gcc/config/linux.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Flinux.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -79,11 +79,6 @@ Boston, MA 02111-1307, USA.  */\n #undef CPLUSPLUS_CPP_SPEC\n #define CPLUSPLUS_CPP_SPEC \"-D_GNU_SOURCE %(cpp)\"\n \n-#ifndef USE_GNULIBC_1\n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-#endif\n-\n #undef\tLIB_SPEC\n /* We no longer link with libc_p.a or libg.a by default. If you\n    want to profile or debug the GNU/Linux C library, please add"}, {"sha": "f89325e812efbe4a4f2e93948b2d9cb5ae8167cf", "filename": "gcc/config/mips/linux.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fmips%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fmips%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Flinux.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -40,10 +40,6 @@ Boston, MA 02111-1307, USA.  */\n #undef HANDLE_SYSV_PRAGMA\n #define HANDLE_SYSV_PRAGMA 1\n \n-/* Use more efficient ``thunks'' to implement C++ vtables. */\n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n /* Don't assume anything about the header files.  */\n #define NO_IMPLICIT_EXTERN_C\n "}, {"sha": "147eec624371711185d13c83b854e6a00aca4284", "filename": "gcc/config/openbsd.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fopenbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fopenbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fopenbsd.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -295,11 +295,6 @@ do {\t\t\t\t\t\t\t\t\t \\\n \f\n /* Storage layout.  */\n \n-/* We don't have to worry about binary compatibility with older C++ code,\n-   but there is a big known bug with vtable thunks which has not been\n-   fixed yet, so DON'T activate it by default.  */\n-/* #define DEFAULT_VTABLE_THUNKS 1 */\n-\n \f\n /* Otherwise, since we support weak, gthr.h erroneously tries to use\n    #pragma weak.  */"}, {"sha": "320d57af2b2435363e863c49d8b0fcf7a6a9df18", "filename": "gcc/config/pj/pj.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fpj%2Fpj.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fpj%2Fpj.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpj%2Fpj.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -1321,9 +1321,6 @@ do {                                                                          \\\n #define INCOMING_RETURN_ADDR_RTX  \\\n   plus_constant (gen_rtx_REG (Pmode, OPTOP_REG), 4)\n \n-/* Use thunks for vtables.  */\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n /* Rewrite the rtl to use take advantage of the opstack.  */\n #define MACHINE_DEPENDENT_REORG(INSNS) pj_machine_dependent_reorg(INSNS)\n "}, {"sha": "5100bb549eeccb976ea45adced53975a417039dd", "filename": "gcc/config/rs6000/linux.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Frs6000%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Frs6000%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -69,11 +69,6 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_APP_OFF\n #define ASM_APP_OFF \"#NO_APP\\n\"\n \n-#undef DEFAULT_VTABLE_THUNKS\n-#ifndef USE_GNULIBC_1\n-#define DEFAULT_VTABLE_THUNKS 1\n-#endif\n-\n /* Do code reading to identify a signal frame, and set the frame\n    state data appropriately.  See unwind-dw2.c for the structs.  */\n "}, {"sha": "f85409b66c93824ebaedc7c9ef726dd5528f927c", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -32,11 +32,6 @@ Boston, MA 02111-1307, USA.  */\n #define MULTIBYTE_CHARS 1\n #endif\n \n-#ifndef USE_GNULIBC_1\n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-#endif\n-\n /* Use stabs instead of DWARF debug format.  */\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n "}, {"sha": "3481c4b4c27d3b113380df6462757376ed95268e", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -26,9 +26,6 @@ Boston, MA 02111-1307, USA.  */\n /* Don't assume anything about the header files. */\n #define NO_IMPLICIT_EXTERN_C\n \n-#undef DEFAULT_VTABLE_THUNKS\n-#define DEFAULT_VTABLE_THUNKS 1\n-\n #include <sparc/sysv4.h>\n \n #undef MD_EXEC_PREFIX"}, {"sha": "ed073c1ae37b88ab3a217fc774686a32d4e95e3c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -1,3 +1,44 @@\n+2001-07-21  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tRemove flag_vtable_thunk. It is always on for the 3.0 ABI.\n+\t* cp-tree.h (CPTI_DELTA2_IDENTIFIER): Remove.\n+\t(CPTI_INDEX_IDENTIFIER): Remove.\n+\t(CPT_PFN_OR_DELTA2_IDENTIFIER): Remove.\n+\t(delta2_identifier): Remove.\n+\t(index_identifier): Remove.\n+\t(pfn_or_delta2_identifier): Remove.\n+\t(flag_vtable_thunks): Remove.\n+\t(VTABLE_DELTA2_NAME): Remove.\n+\t(VTABLE_INDEX_NAME): Remove.\n+\t(FNADDR_FROM_VTABLE_ENTRY): Adjust.\n+\t(vfunc_ptr_type_node): Adjust.\n+\t(VTABLE_NAME_PREFIX): Adjust.\n+\t(build_vfn_ref): Lose first parameter.\n+\t(fixup_all_virtual_upcast_offsets): Remove.\n+\t* decl.c (initialize_predefined_identifiers): Remove\n+\tdelta2_identifier, index_identifier, pfn_or_delta2_identifier.\n+\t(init_decl_processing): Remove no-vtable-thunk code.\n+\t* decl2.c (flag_vtable_thunks): Remove.\n+\t(mark_vtable_entries): Remove no-vtable-thunk code.\n+\t* error.c (dump_decl): Remove no-vtable-thunk code.\n+\t(dump_expr): Adjust ptr to member function code.\n+\t* init.c (initialize_vtable_ptrs): Remove no-vtable-thunk\n+\tcode.\n+\t* rtti.c (build_headof): Remove no-vtable-thunk code.\n+\t(get_tinfo_decl_dynamic): Adjust build_vfn_ref call.\n+\t* search.c (get_base_distance): Remove expand_upcast_fixups case.\n+\t(virtual_context) Remove.\n+\t(expand_upcast_fixups): Remove.\n+\t(fixup_virtual_upcast_offsets): Remove.\n+\t(fixup_all_virtual_upcast_offsets): Remove.\n+\t* typeck.c (get_member_function_from_ptrfunc): Remove\n+\tno-vtable-thunk code.\n+\t* call.c (build_over_call): Adjust call to build_vfn_ref.\n+\t* class.c (build_vfn_ref): Lose first parameter. Remove\n+\tno-vtable-thunk code.\n+\t(build_rtti_vtbl_entries): Remove no-vtable-thunk code.\n+\t(build_vtable_entry): Remove no-vtable-thunk code.\n+\n 2001-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tRemove old-abi remnants. Remove comments about old abi"}, {"sha": "c8c524618c3227841b49bd879783a3ceef05b236", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -4307,7 +4307,7 @@ build_over_call (cand, args, flags)\n       if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n \tfn = build_java_interface_fn_ref (fn, *p);\n       else\n-\tfn = build_vfn_ref (p, build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n+\tfn = build_vfn_ref (build_indirect_ref (*p, 0), DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else if (DECL_INLINE (fn))"}, {"sha": "16677583883dbfeb1d3a2022c2d5417ec8b21718", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 81, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -543,37 +543,16 @@ build_vtbl_ref (instance, idx)\n }\n \n /* Given an object INSTANCE, return an expression which yields the\n-   virtual function corresponding to INDEX.  There are many special\n-   cases for INSTANCE which we take care of here, mainly to avoid\n-   creating extra tree nodes when we don't have to.  */\n+   virtual function corresponding to IDX. */\n \n tree\n-build_vfn_ref (ptr_to_instptr, instance, idx)\n-     tree *ptr_to_instptr, instance;\n+build_vfn_ref (instance, idx)\n+     tree instance;\n      tree idx;\n {\n   tree aref = build_vtbl_ref (instance, idx);\n \n-  /* When using thunks, there is no extra delta, and we get the pfn\n-     directly.  */\n-  if (flag_vtable_thunks)\n-    return aref;\n-\n-  if (ptr_to_instptr)\n-    {\n-      /* Save the intermediate result in a SAVE_EXPR so we don't have to\n-\t compute each component of the virtual function pointer twice.  */ \n-      if (TREE_CODE (aref) == INDIRECT_REF)\n-\tTREE_OPERAND (aref, 0) = save_expr (TREE_OPERAND (aref, 0));\n-\n-      *ptr_to_instptr\n-\t= build (PLUS_EXPR, TREE_TYPE (*ptr_to_instptr),\n-\t\t *ptr_to_instptr,\n-\t\t cp_convert (ptrdiff_type_node,\n-\t\t\t     build_component_ref (aref, delta_identifier, NULL_TREE, 0)));\n-    }\n-\n-  return build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n+  return aref;\n }\n \n /* Return the name of the virtual function table (as an IDENTIFIER_NODE)\n@@ -8019,16 +7998,12 @@ build_rtti_vtbl_entries (binfo, vid)\n   vid->last_init = &TREE_CHAIN (*vid->last_init);\n \n   /* Add the offset-to-top entry.  It comes earlier in the vtable that\n-     the the typeinfo entry.  */\n-  if (flag_vtable_thunks)\n-    {\n-      /* Convert the offset to look like a function pointer, so that\n-\t we can put it in the vtable.  */\n-      init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n-      TREE_CONSTANT (init) = 1;\n-      *vid->last_init = build_tree_list (NULL_TREE, init);\n-      vid->last_init = &TREE_CHAIN (*vid->last_init);\n-    }\n+     the the typeinfo entry.  Convert the offset to look like a\n+     function pointer, so that we can put it in the vtable.  */\n+  init = build1 (NOP_EXPR, vfunc_ptr_type_node, offset);\n+  TREE_CONSTANT (init) = 1;\n+  *vid->last_init = build_tree_list (NULL_TREE, init);\n+  vid->last_init = &TREE_CHAIN (*vid->last_init);\n }\n \n /* Build an entry in the virtual function table.  DELTA is the offset\n@@ -8045,54 +8020,18 @@ build_vtable_entry (delta, vcall_index, entry)\n      tree vcall_index;\n      tree entry;\n {\n-  if (flag_vtable_thunks)\n-    {\n-      tree fn;\n-\n-      fn = TREE_OPERAND (entry, 0);\n-      if ((!integer_zerop (delta) || vcall_index != NULL_TREE)\n-\t  && fn != abort_fndecl)\n-\t{\n-\t  entry = make_thunk (entry, delta, vcall_index);\n-\t  entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n-\t  TREE_READONLY (entry) = 1;\n-\t  TREE_CONSTANT (entry) = 1;\n-\t}\n-#ifdef GATHER_STATISTICS\n-      n_vtable_entries += 1;\n-#endif\n-      return entry;\n-    }\n-  else\n+  tree fn = TREE_OPERAND (entry, 0);\n+  \n+  if ((!integer_zerop (delta) || vcall_index != NULL_TREE)\n+      && fn != abort_fndecl)\n     {\n-      tree elems = tree_cons (NULL_TREE, delta,\n-\t\t\t      tree_cons (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t build_tree_list (NULL_TREE, entry)));\n-      tree entry = build (CONSTRUCTOR, vtable_entry_type, NULL_TREE, elems);\n-\n-      /* We don't use vcall offsets when not using vtable thunks.  */\n-      my_friendly_assert (vcall_index == NULL_TREE, 20000125);\n-\n-      /* DELTA used to be constructed by `size_int' and/or size_binop,\n-\t which caused overflow problems when it was negative.  That should\n-\t be fixed now.  */\n-\n-      if (! int_fits_type_p (delta, delta_type_node))\n-\t{\n-\t  if (flag_huge_objects)\n-\t    sorry (\"object size exceeds built-in limit for virtual function table implementation\");\n-\t  else\n-\t    sorry (\"object size exceeds normal limit for virtual function table implementation, recompile all source and use -fhuge-objects\");\n-\t}\n-      \n-      TREE_CONSTANT (entry) = 1;\n-      TREE_STATIC (entry) = 1;\n+      entry = make_thunk (entry, delta, vcall_index);\n+      entry = build1 (ADDR_EXPR, vtable_entry_type, entry);\n       TREE_READONLY (entry) = 1;\n-\n+      TREE_CONSTANT (entry) = 1;\n+    }\n #ifdef GATHER_STATISTICS\n-      n_vtable_entries += 1;\n+  n_vtable_entries += 1;\n #endif\n-\n-      return entry;\n-    }\n+  return entry;\n }"}, {"sha": "e7005c7ef13ecb2ba08ac07400fbd8a5bffb87b7", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -552,15 +552,12 @@ enum cp_tree_index\n     CPTI_COMPLETE_DTOR_IDENTIFIER,\n     CPTI_BASE_DTOR_IDENTIFIER,\n     CPTI_DELETING_DTOR_IDENTIFIER,\n-    CPTI_DELTA2_IDENTIFIER,\n     CPTI_DELTA_IDENTIFIER,\n     CPTI_IN_CHARGE_IDENTIFIER,\n     CPTI_VTT_PARM_IDENTIFIER,\n-    CPTI_INDEX_IDENTIFIER,\n     CPTI_NELTS_IDENTIFIER,\n     CPTI_THIS_IDENTIFIER,\n     CPTI_PFN_IDENTIFIER,\n-    CPTI_PFN_OR_DELTA2_IDENTIFIER,\n     CPTI_VPTR_IDENTIFIER,\n     CPTI_STD_IDENTIFIER,\n \n@@ -594,8 +591,7 @@ extern tree cp_global_trees[CPTI_MAX];\n #define wchar_decl_node\t\t\tcp_global_trees[CPTI_WCHAR_DECL]\n #define vtable_entry_type\t\tcp_global_trees[CPTI_VTABLE_ENTRY_TYPE]\n /* The type used to represent an offset by which to adjust the `this'\n-   pointer in pointer-to-member types and, when not using vtable\n-   thunks, in vtables.  */\n+   pointer in pointer-to-member types.  */\n #define delta_type_node\t\t\tcp_global_trees[CPTI_DELTA_TYPE]\n /* The type used to represent an index into the vtable.  */\n #define vtable_index_type               cp_global_trees[CPTI_VTABLE_INDEX_TYPE]\n@@ -671,20 +667,14 @@ extern tree cp_global_trees[CPTI_MAX];\n /* The name of a destructor that destroys virtual base classes, and\n    then deletes the entire object.  */\n #define deleting_dtor_identifier        cp_global_trees[CPTI_DELETING_DTOR_IDENTIFIER]\n-\n-#define delta2_identifier               cp_global_trees[CPTI_DELTA2_IDENTIFIER]\n #define delta_identifier                cp_global_trees[CPTI_DELTA_IDENTIFIER]\n #define in_charge_identifier            cp_global_trees[CPTI_IN_CHARGE_IDENTIFIER]\n-\n /* The name of the parameter that contains a pointer to the VTT to use\n    for this subobject constructor or destructor.  */\n #define vtt_parm_identifier             cp_global_trees[CPTI_VTT_PARM_IDENTIFIER]\n-\n-#define index_identifier                cp_global_trees[CPTI_INDEX_IDENTIFIER]\n #define nelts_identifier                cp_global_trees[CPTI_NELTS_IDENTIFIER]\n #define this_identifier                 cp_global_trees[CPTI_THIS_IDENTIFIER]\n #define pfn_identifier                  cp_global_trees[CPTI_PFN_IDENTIFIER]\n-#define pfn_or_delta2_identifier        cp_global_trees[CPTI_PFN_OR_DELTA2_IDENTIFIER]\n #define vptr_identifier                 cp_global_trees[CPTI_VPTR_IDENTIFIER]\n /* The name of the std namespace.  */\n #define std_identifier                  cp_global_trees[CPTI_STD_IDENTIFIER]\n@@ -1031,11 +1021,6 @@ extern int warn_reorder;\n \n extern int flag_signed_bitfields;\n \n-/* True for more efficient but incompatible (not fully tested)\n-   vtable implementation (using thunks).\n-   0 is old behavior; 1 is new behavior.  */\n-extern int flag_vtable_thunks;\n-\n /* INTERFACE_ONLY nonzero means that we are in an \"interface\"\n    section of the compiler.  INTERFACE_UNKNOWN nonzero means\n    we cannot trust the value of INTERFACE_ONLY.  If INTERFACE_UNKNOWN\n@@ -1180,11 +1165,9 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n /* Virtual function addresses can be gotten from a virtual function\n    table entry using this macro.  */\n #define FNADDR_FROM_VTABLE_ENTRY(ENTRY)\t\t\t\t\t\\\n-  (!flag_vtable_thunks ?\t\t\t\t\t\t\\\n-     TREE_VALUE (TREE_CHAIN (TREE_CHAIN (CONSTRUCTOR_ELTS (ENTRY))))\t\\\n-   : !DECL_THUNK_P (TREE_OPERAND ((ENTRY), 0))\t\t\t\t\\\n-   ? (ENTRY)\t\t\t\t\t\t\t\t\\\n-   : DECL_INITIAL (TREE_OPERAND ((ENTRY), 0)))\n+  (DECL_THUNK_P (TREE_OPERAND ((ENTRY), 0))\t\t\t\t\\\n+   : DECL_INITIAL (TREE_OPERAND ((ENTRY), 0))\t\t\t\t\\\n+   ? (ENTRY))\n \n #define FUNCTION_ARG_CHAIN(NODE) \\\n   (TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (NODE))))\n@@ -2555,9 +2538,11 @@ extern int flag_new_for_scope;\n        ptrdiff_t __delta;\n      };\n \n-   (As the vtable is always the first thing in the object, we don't\n-   need an offset to it.)  If the function is virtual, then PFN is one\n-   plus twice the index into the vtable; otherwise, it is just a\n+   If __pfn is NULL, it is a NULL pointer-to-member-function.\n+  \n+   (Because the vtable is always the first thing in the object, we\n+   don't need its offset.)  If the function is virtual, then PFN is\n+   one plus twice the index into the vtable; otherwise, it is just a\n    pointer to the function.\n \n    Unfortunately, using the lowest bit of PFN doesn't work in\n@@ -3087,8 +3072,7 @@ extern tree error_mark_list;\n \n /* Node for \"pointer to (virtual) function\".\n    This may be distinct from ptr_type_node so gdb can distinguish them.  */\n-#define vfunc_ptr_type_node \\\n-  (flag_vtable_thunks ? vtable_entry_type : ptr_type_node)\n+#define vfunc_ptr_type_node  vtable_entry_type\n \n \n /* For building calls to `delete'.  */\n@@ -3156,7 +3140,7 @@ extern varray_type local_classes;\n #define AUTO_TEMP_NAME \"_$tmp_\"\n #define AUTO_TEMP_FORMAT \"_$tmp_%d\"\n #define VTABLE_BASE \"$vb\"\n-#define VTABLE_NAME_PREFIX (flag_vtable_thunks ? \"__vt_\" : \"_vt$\")\n+#define VTABLE_NAME_PREFIX \"__vt_\"\n #define VFIELD_BASE \"$vf\"\n #define VFIELD_NAME \"_vptr$\"\n #define VFIELD_NAME_FORMAT \"_vptr$%s\"\n@@ -3178,7 +3162,7 @@ extern varray_type local_classes;\n #define AUTO_TEMP_NAME \"_.tmp_\"\n #define AUTO_TEMP_FORMAT \"_.tmp_%d\"\n #define VTABLE_BASE \".vb\"\n-#define VTABLE_NAME_PREFIX (flag_vtable_thunks ? \"__vt_\" : \"_vt.\")\n+#define VTABLE_NAME_PREFIX \"__vt_\"\n #define VFIELD_BASE \".vf\"\n #define VFIELD_NAME \"_vptr.\"\n #define VFIELD_NAME_FORMAT \"_vptr.%s\"\n@@ -3207,7 +3191,7 @@ extern varray_type local_classes;\n #define AUTO_TEMP_FORMAT \"__tmp_%d\"\n #define VTABLE_BASE \"__vtb\"\n #define VTABLE_NAME \"__vt_\"\n-#define VTABLE_NAME_PREFIX (flag_vtable_thunks ? \"__vt_\" : \"_vt_\")\n+#define VTABLE_NAME_PREFIX \"__vt_\"\n #define VTABLE_NAME_P(ID_NODE) \\\n   (!strncmp (IDENTIFIER_POINTER (ID_NODE), VTABLE_NAME, \\\n \t     sizeof (VTABLE_NAME) - 1))\n@@ -3247,9 +3231,7 @@ extern varray_type local_classes;\n \n #define VTBL_PTR_TYPE\t\t\"__vtbl_ptr_type\"\n #define VTABLE_DELTA_NAME\t\"__delta\"\n-#define VTABLE_INDEX_NAME\t\"__index\"\n #define VTABLE_PFN_NAME\t\t\"__pfn\"\n-#define VTABLE_DELTA2_NAME\t\"__delta2\"\n \n #define EXCEPTION_CLEANUP_NAME\t\"exception cleanup\"\n \n@@ -3592,7 +3574,7 @@ extern tree perform_implicit_conversion         PARAMS ((tree, tree));\n /* in class.c */\n extern tree build_vbase_path\t\t\tPARAMS ((enum tree_code, tree, tree, tree, int));\n extern tree build_vtbl_ref\t\t\tPARAMS ((tree, tree));\n-extern tree build_vfn_ref\t\t\tPARAMS ((tree *, tree, tree));\n+extern tree build_vfn_ref\t\t\tPARAMS ((tree, tree));\n extern tree get_vtable_decl                     PARAMS ((tree, int));\n extern void add_method\t\t\t\tPARAMS ((tree, tree, int));\n extern int currently_open_class\t\t\tPARAMS ((tree));\n@@ -4106,7 +4088,6 @@ extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n extern tree binfo_via_virtual                   PARAMS ((tree, tree));\n-extern void fixup_all_virtual_upcast_offsets    PARAMS ((tree));\n \n /* in semantics.c */\n extern void init_cp_semantics                   PARAMS ((void));"}, {"sha": "c140af427c854bc99a1d55f0fec1360e457cd756", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 11, "deletions": 60, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -162,28 +162,13 @@ tree error_mark_list;\n \n \ttree vtable_entry_type;\n \ttree delta_type_node;\n-#if 0\n-   Old rtti stuff.\n-\ttree __baselist_desc_type_node;\n-\ttree __i_desc_type_node, __m_desc_type_node;\n-\ttree __t_desc_array_type, __i_desc_array_type, __m_desc_array_type;\n-#endif\n \ttree __t_desc_type_node;\n-#if 0\n-\ttree __tp_desc_type_node;\n-#endif\n         tree ti_desc_type_node;\n \ttree bltn_desc_type_node, ptr_desc_type_node;\n \ttree ary_desc_type_node, func_desc_type_node, enum_desc_type_node;\n \ttree class_desc_type_node, si_class_desc_type_node, vmi_class_desc_type_node;\n \ttree ptm_desc_type_node;\n \ttree base_desc_type_node;\n-#if 0\n-   Not needed yet?  May be needed one day?\n-\ttree __bltn_desc_array_type, __user_desc_array_type, __class_desc_array_type;\n-\ttree __ptr_desc_array_type, __attr_dec_array_type, __func_desc_array_type;\n-\ttree __ptmf_desc_array_type, __ptmd_desc_array_type;\n-#endif\n \n \ttree class_type_node, record_type_node, union_type_node, enum_type_node;\n \ttree unknown_type_node;\n@@ -6304,14 +6289,11 @@ initialize_predefined_identifiers ()\n     { \"__comp_dtor\", &complete_dtor_identifier, 1 },\n     { \"__base_dtor\", &base_dtor_identifier, 1 },\n     { \"__deleting_dtor\", &deleting_dtor_identifier, 1 },\n-    { VTABLE_DELTA2_NAME, &delta2_identifier, 0 },\n-    { VTABLE_DELTA_NAME, &delta_identifier, 0 },\n     { IN_CHARGE_NAME, &in_charge_identifier, 0 },\n-    { VTABLE_INDEX_NAME, &index_identifier, 0 },\n     { \"nelts\", &nelts_identifier, 0 },\n     { THIS_NAME, &this_identifier, 0 },\n+    { VTABLE_DELTA_NAME, &delta_identifier, 0 },\n     { VTABLE_PFN_NAME, &pfn_identifier, 0 },\n-    { \"__pfn_or_delta2\", &pfn_or_delta2_identifier, 0 },\n     { \"_vptr\", &vptr_identifier, 0 },\n     { \"__vtt_parm\", &vtt_parm_identifier, 0 },\n     { \"std\", &std_identifier, 0 },\n@@ -6334,15 +6316,9 @@ initialize_predefined_identifiers ()\n void\n init_decl_processing ()\n {\n-  tree fields[20];\n   tree void_ftype;\n   tree void_ftype_ptr;\n \n-  /* Check to see that the user did not specify an invalid combination\n-     of command-line options.  */\n-  if (!flag_vtable_thunks)\n-    error (\"the ABI requires vtable thunks\");\n-\n   /* Create all the identifiers we need.  */\n   initialize_predefined_identifiers ();\n \n@@ -6487,41 +6463,16 @@ init_decl_processing ()\n   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;\n   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;\n \n-  if (flag_vtable_thunks)\n-    {\n-      /* Make sure we get a unique function type, so we can give\n-\t its pointer type a name.  (This wins for gdb.) */\n-      tree vfunc_type = make_node (FUNCTION_TYPE);\n-      TREE_TYPE (vfunc_type) = integer_type_node;\n-      TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n-      layout_type (vfunc_type);\n-\n-      vtable_entry_type = build_pointer_type (vfunc_type);\n-    }\n-  else\n-    {\n-      vtable_entry_type = make_aggr_type (RECORD_TYPE);\n-      fields[0] = build_decl (FIELD_DECL, delta_identifier,\n-\t\t\t      delta_type_node);\n-      fields[1] = build_decl (FIELD_DECL, index_identifier,\n-\t\t\t      delta_type_node);\n-      fields[2] = build_decl (FIELD_DECL, pfn_identifier,\n-\t\t\t      ptr_type_node);\n-      finish_builtin_type (vtable_entry_type, VTBL_PTR_TYPE, fields, 2,\n-\t\t\t   double_type_node);\n-\n-      /* Make this part of an invisible union.  */\n-      fields[3] = copy_node (fields[2]);\n-      TREE_TYPE (fields[3]) = delta_type_node;\n-      DECL_NAME (fields[3]) = delta2_identifier;\n-      DECL_MODE (fields[3]) = TYPE_MODE (delta_type_node);\n-      DECL_SIZE (fields[3]) = TYPE_SIZE (delta_type_node);\n-      DECL_SIZE_UNIT (fields[3]) = TYPE_SIZE_UNIT (delta_type_node);\n-      TREE_UNSIGNED (fields[3]) = 0;\n-      TREE_CHAIN (fields[2]) = fields[3];\n-      vtable_entry_type = build_qualified_type (vtable_entry_type,\n-\t\t\t\t\t\tTYPE_QUAL_CONST);\n-    }\n+  {\n+    /* Make sure we get a unique function type, so we can give\n+       its pointer type a name.  (This wins for gdb.) */\n+    tree vfunc_type = make_node (FUNCTION_TYPE);\n+    TREE_TYPE (vfunc_type) = integer_type_node;\n+    TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;\n+    layout_type (vfunc_type);\n+\n+    vtable_entry_type = build_pointer_type (vfunc_type);\n+  }\n   record_builtin_type (RID_MAX, VTBL_PTR_TYPE, vtable_entry_type);\n \n   vtbl_type_node"}, {"sha": "d0f8c438d6407dda0a2652eb4608522254e78c70", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -189,11 +189,6 @@ int warn_long_long = 1;\n \n int warn_ctor_dtor_privacy = 1;\n \n-/* True if we want to implement vtables using \"thunks\".\n-   The default is off.  */\n-\n-int flag_vtable_thunks = 1;\n-\n /* Nonzero means generate separate instantiation control files and juggle\n    them at link time.  */\n \n@@ -2247,12 +2242,9 @@ mark_vtable_entries (decl)\n \n   for (; entries; entries = TREE_CHAIN (entries))\n     {\n-      tree fnaddr;\n+      tree fnaddr = TREE_VALUE (entries);\n       tree fn;\n-\n-      fnaddr = (flag_vtable_thunks ? TREE_VALUE (entries) \n-\t\t: FNADDR_FROM_VTABLE_ENTRY (TREE_VALUE (entries)));\n-\n+      \n       if (TREE_CODE (fnaddr) != ADDR_EXPR)\n \t/* This entry is an offset: a virtual base class offset, a\n \t   virtual call offset, an RTTI offset, etc.  */"}, {"sha": "05352c2733c09692aac5e6600f6c37b114e3ffce", "filename": "gcc/cp/error.c", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -950,13 +950,8 @@ dump_decl (t, flags)\n       if (DECL_NAME (t) && VTABLE_NAME_P (DECL_NAME (t)))\n \t{\n \t  output_add_string (scratch_buffer, \"vtable for \");\n-\t  if (TYPE_P (DECL_CONTEXT (t)))\n-\t    dump_type (DECL_CONTEXT (t), flags);\n-\t  else\n-\t    /* This case can arise with -fno-vtable-thunks.  See\n-\t       expand_upcast_fixups.  It's not clear what to print\n-\t       here.  */\n-\t    print_identifier (scratch_buffer, \"<unknown type>\");\n+\t  my_friendly_assert (TYPE_P (DECL_CONTEXT (t)), 20010720);\n+\t  dump_type (DECL_CONTEXT (t), flags);\n \t  break;\n \t}\n       /* else fall through */\n@@ -1918,16 +1913,9 @@ dump_expr (t, flags)\n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n \t{\n-\t  tree idx = build_component_ref (t, index_identifier, NULL_TREE, 0);\n+\t  tree idx = build_component_ref (t, pfn_identifier, NULL_TREE, 0);\n \n-\t  if (integer_all_onesp (idx))\n-\t    {\n-\t      tree pfn = PFN_FROM_PTRMEMFUNC (t);\n-\t      dump_unary_op (\"&\", pfn, flags | TFF_EXPR_IN_PARENS);\n-\t      break;\n-\t    }\n-\t  else if (TREE_CODE (idx) == INTEGER_CST\n-\t\t   && tree_int_cst_equal (idx, integer_zero_node))\n+\t  if (integer_zerop (idx))\n \t    {\n \t      /* A NULL pointer-to-member constant.  */\n \t      output_add_string (scratch_buffer, \"((\");"}, {"sha": "6dbef0b336147971f151ac920a1faabc5b1f3b5e", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -182,14 +182,6 @@ initialize_vtbl_ptrs (addr)\n \t\t NULL, dfs_unmarked_real_bases_queue_p, list);\n   dfs_walk (TYPE_BINFO (type), dfs_unmark,\n \t    dfs_marked_real_bases_queue_p, type);\n-\n-  /* If we're not using thunks, we may need to adjust the deltas in\n-     the vtable to handle virtual base classes correctly.  When we are\n-     using thunks, we either use construction vtables (which are\n-     preloaded with the right answers) or nothing (in which case\n-     vitual function calls sometimes don't work right.)  */\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (type) && !flag_vtable_thunks)\n-    fixup_all_virtual_upcast_offsets (addr);\n }\n \n /* [dcl.init]:"}, {"sha": "5638eb6f0cafb0bc2183652ae40c287219c1a71d", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -113,7 +113,6 @@ build_headof (exp)\n      tree exp;\n {\n   tree type = TREE_TYPE (exp);\n-  tree aref;\n   tree offset;\n   tree index;\n \n@@ -133,12 +132,7 @@ build_headof (exp)\n   /* The offset-to-top field is at index -2 from the vptr.  */\n   index = build_int_2 (-2, -1);\n \n-  aref = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n-\n-  if (flag_vtable_thunks)\n-    offset = aref;\n-  else\n-    offset = build_component_ref (aref, delta_identifier, NULL_TREE, 0);\n+  offset = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n \n   type = build_qualified_type (ptr_type_node, \n \t\t\t       CP_TYPE_QUALS (TREE_TYPE (exp)));\n@@ -227,7 +221,7 @@ get_tinfo_decl_dynamic (exp)\n \n       /* The RTTI information is at index -1.  */\n       index = integer_minus_one_node;\n-      t = build_vfn_ref ((tree *) 0, exp, index);\n+      t = build_vfn_ref (exp, index);\n       TREE_TYPE (t) = build_pointer_type (tinfo_decl_type);\n       return t;\n     }"}, {"sha": "4fac30fa780fb9363dc47e4bf3cbb754ed46e36f", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 300, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -86,18 +86,12 @@ struct vbase_info\n static tree get_vbase_1 PARAMS ((tree, tree, unsigned int *));\n static tree lookup_field_1 PARAMS ((tree, tree));\n static int is_subobject_of_p PARAMS ((tree, tree, tree));\n-static tree virtual_context PARAMS ((tree, tree, tree));\n static tree dfs_check_overlap PARAMS ((tree, void *));\n static tree dfs_no_overlap_yet PARAMS ((tree, void *));\n static int get_base_distance_recursive\n \tPARAMS ((tree, int, int, int, int *, tree *, tree,\n \t       int, int *, int, int));\n static int dynamic_cast_base_recurse PARAMS ((tree, tree, int, tree *));\n-static void expand_upcast_fixups \n-\tPARAMS ((tree, tree, tree, tree, tree, tree, tree *));\n-static void fixup_virtual_upcast_offsets\n-\tPARAMS ((tree, tree, int, int, tree, tree, tree, tree,\n-\t       tree *));\n static tree marked_pushdecls_p PARAMS ((tree, void *));\n static tree unmarked_pushdecls_p PARAMS ((tree, void *));\n static tree dfs_debug_unmarkedp PARAMS ((tree, void *));\n@@ -474,16 +468,6 @@ get_base_distance (parent, binfo, protect, path_ptr)\n   if (rval && protect && rval_private)\n     return -3;\n \n-  /* If they gave us the real vbase binfo, which isn't in the main binfo\n-     tree, deal with it.  This happens when we are called from\n-     expand_upcast_fixups.  */\n-  if (rval == -1 && TREE_CODE (parent) == TREE_VEC\n-      && parent == binfo_for_vbase (BINFO_TYPE (parent), type))\n-    {\n-      new_binfo = parent;\n-      rval = 1;\n-    }\n-\n   if (path_ptr)\n     *path_ptr = new_binfo;\n   return rval;\n@@ -2332,290 +2316,6 @@ dfs_unmark (binfo, data)\n   return NULL_TREE;\n }\n \n-\f\n-/* get the virtual context (the vbase that directly contains the\n-   DECL_CONTEXT of the FNDECL) that the given FNDECL is declared in,\n-   or NULL_TREE if there is none.\n-\n-   FNDECL must come from a virtual table from a virtual base to ensure\n-   that there is only one possible DECL_CONTEXT.\n-\n-   We know that if there is more than one place (binfo) the fndecl that the\n-   declared, they all refer to the same binfo.  See get_class_offset_1 for\n-   the check that ensures this.  */\n-\n-static tree\n-virtual_context (fndecl, t, vbase)\n-     tree fndecl, t, vbase;\n-{\n-  tree path;\n-  if (get_base_distance (DECL_CONTEXT (fndecl), t, 0, &path) < 0)\n-    {\n-      /* DECL_CONTEXT can be ambiguous in t.  */\n-      if (get_base_distance (DECL_CONTEXT (fndecl), vbase, 0, &path) >= 0)\n-\t{\n-\t  while (path)\n-\t    {\n-\t      /* Not sure if checking path == vbase is necessary here, but just in\n-\t\t case it is.  */\n-\t      if (TREE_VIA_VIRTUAL (path) || path == vbase)\n-\t\treturn binfo_for_vbase (BINFO_TYPE (path), t);\n-\t      path = BINFO_INHERITANCE_CHAIN (path);\n-\t    }\n-\t}\n-      /* This shouldn't happen, I don't want errors! */\n-      warning (\"recoverable compiler error, fixups for virtual function\");\n-      return vbase;\n-    }\n-  while (path)\n-    {\n-      if (TREE_VIA_VIRTUAL (path))\n-\treturn binfo_for_vbase (BINFO_TYPE (path), t);\n-      path = BINFO_INHERITANCE_CHAIN (path);\n-    }\n-  return 0;\n-}\n-\n-/* Fixups upcast offsets for one vtable.\n-   Entries may stay within the VBASE given, or\n-   they may upcast into a direct base, or\n-   they may upcast into a different vbase.\n-\n-   We only need to do fixups in case 2 and 3.  In case 2, we add in\n-   the virtual base offset to effect an upcast, in case 3, we add in\n-   the virtual base offset to effect an upcast, then subtract out the\n-   offset for the other virtual base, to effect a downcast into it.\n-\n-   This routine mirrors fixup_vtable_deltas in functionality, though\n-   this one is runtime based, and the other is compile time based.\n-   Conceivably that routine could be removed entirely, and all fixups\n-   done at runtime.\n-\n-   VBASE_OFFSETS is an association list of virtual bases that contains\n-   offset information for the virtual bases, so the offsets are only\n-   calculated once.  */\n-\n-static void\n-expand_upcast_fixups (binfo, addr, orig_addr, vbase, vbase_addr, t,\n-\t\t      vbase_offsets)\n-     tree binfo, addr, orig_addr, vbase, vbase_addr, t, *vbase_offsets;\n-{\n-  tree virtuals;\n-  tree vc;\n-  tree delta;\n-  HOST_WIDE_INT n;\n-\n-  while (BINFO_PRIMARY_P (binfo))\n-    {\n-      binfo = BINFO_INHERITANCE_CHAIN (binfo);\n-      if (TREE_VIA_VIRTUAL (binfo))\n-\treturn;\n-    }\n-\n-  delta = purpose_member (vbase, *vbase_offsets);\n-  if (! delta)\n-    {\n-      delta = build (PLUS_EXPR,\n-\t\t     build_pointer_type (BINFO_TYPE (vbase)),\n-\t\t     orig_addr,\n-\t\t     BINFO_OFFSET (vbase));\n-      delta = build (MINUS_EXPR, ptrdiff_type_node, delta, vbase_addr);\n-      delta = save_expr (delta);\n-      delta = tree_cons (vbase, delta, *vbase_offsets);\n-      *vbase_offsets = delta;\n-    }\n-\n-  for (virtuals = BINFO_VIRTUALS (binfo), n = 0;\n-       virtuals;\n-       virtuals = TREE_CHAIN (virtuals), ++n)\n-    {\n-      tree current_fndecl = TREE_VALUE (virtuals);\n-\n-      if (current_fndecl\n-\t  && current_fndecl != abort_fndecl\n-\t  && (vc=virtual_context (current_fndecl, t, vbase)) != vbase)\n-\t{\n-\t  /* This may in fact need a runtime fixup.  */\n-\t  tree idx = build_int_2 (n, 0);\n-\t  tree vtbl = BINFO_VTABLE (binfo);\n-\t  tree nvtbl = lookup_name (DECL_NAME (vtbl), 0);\n-\t  tree aref, ref, naref;\n-\t  tree old_delta, new_delta;\n-\t  tree init;\n-\n-\t  if (nvtbl == NULL_TREE\n-\t      || nvtbl == IDENTIFIER_GLOBAL_VALUE (DECL_NAME (vtbl)))\n-\t    {\n-\t      /* Dup it if it isn't in local scope yet.  */\n-\t      nvtbl = build_decl\n-\t\t(VAR_DECL, DECL_NAME (vtbl),\n-\t\t TYPE_MAIN_VARIANT (TREE_TYPE (vtbl)));\n-\t      DECL_ALIGN (nvtbl) = MAX (TYPE_ALIGN (double_type_node),\n-\t\t\t\t\tDECL_ALIGN (nvtbl));\n-\t      TREE_READONLY (nvtbl) = 0;\n-\t      DECL_ARTIFICIAL (nvtbl) = 1;\n-\t      nvtbl = pushdecl (nvtbl);\n-\t      init = NULL_TREE;\n-\t      cp_finish_decl (nvtbl, init, NULL_TREE,\n-\t\t\t      LOOKUP_ONLYCONVERTING);\n-\n-\t      /* We don't set DECL_VIRTUAL_P and DECL_CONTEXT on nvtbl\n-\t\t because they wouldn't be useful; everything that wants to\n-\t\t look at the vtable will look at the decl for the normal\n-\t\t vtable.  Setting DECL_CONTEXT also screws up\n-\t\t decl_function_context.  */\n-\n-\t      init = build (MODIFY_EXPR, TREE_TYPE (nvtbl),\n-\t\t\t    nvtbl, vtbl);\n-\t      finish_expr_stmt (init);\n-\t      /* Update the vtable pointers as necessary.  */\n-\t      ref = build_vfield_ref\n-\t\t(build_indirect_ref (addr, NULL),\n-\t\t DECL_CONTEXT (TYPE_VFIELD (BINFO_TYPE (binfo))));\n-\t      finish_expr_stmt\n-\t\t(build_modify_expr (ref, NOP_EXPR, nvtbl));\n-\t    }\n-\t  assemble_external (vtbl);\n-\t  aref = build_array_ref (vtbl, idx);\n-\t  naref = build_array_ref (nvtbl, idx);\n-\t  old_delta = build_component_ref (aref, delta_identifier,\n-\t\t\t\t\t   NULL_TREE, 0);\n-\t  new_delta = build_component_ref (naref, delta_identifier,\n-\t\t\t\t\t   NULL_TREE, 0);\n-\n-\t  /* This is a upcast, so we have to add the offset for the\n-\t     virtual base.  */\n-\t  old_delta = cp_build_binary_op (PLUS_EXPR, old_delta,\n-\t\t\t\t\t  TREE_VALUE (delta));\n-\t  if (vc)\n-\t    {\n-\t      /* If this is set, we need to subtract out the delta\n-\t\t adjustments for the other virtual base that we\n-\t\t downcast into.  */\n-\t      tree vc_delta = purpose_member (vc, *vbase_offsets);\n-\t      if (! vc_delta)\n-\t\t{\n-\t\t  tree vc_addr = convert_pointer_to_real (vc, orig_addr);\n-\t\t  vc_delta = build (PLUS_EXPR,\n-\t\t\t\t    build_pointer_type (BINFO_TYPE (vc)),\n-\t\t\t\t    orig_addr,\n-\t\t\t\t    BINFO_OFFSET (vc));\n-\t\t  vc_delta = build (MINUS_EXPR, ptrdiff_type_node,\n-\t\t\t\t    vc_delta, vc_addr);\n-\t\t  vc_delta = save_expr (vc_delta);\n-\t\t  *vbase_offsets = tree_cons (vc, vc_delta, *vbase_offsets);\n-\t\t}\n-\t      else\n-\t\tvc_delta = TREE_VALUE (vc_delta);\n-   \n-\t      /* This is a downcast, so we have to subtract the offset\n-\t\t for the virtual base.  */\n-\t      old_delta = cp_build_binary_op (MINUS_EXPR, old_delta, vc_delta);\n-\t    }\n-\n-\t  TREE_READONLY (new_delta) = 0;\n-\t  TREE_TYPE (new_delta) = \n-\t    cp_build_qualified_type (TREE_TYPE (new_delta),\n-\t\t\t\t     CP_TYPE_QUALS (TREE_TYPE (new_delta))\n-\t\t\t\t     & ~TYPE_QUAL_CONST);\n-\t  finish_expr_stmt (build_modify_expr (new_delta, NOP_EXPR,\n-\t\t\t\t\t       old_delta));\n-\t}\n-    }\n-}\n-\n-/* Fixup upcast offsets for all direct vtables.  Patterned after\n-   expand_direct_vtbls_init.  */\n-\n-static void\n-fixup_virtual_upcast_offsets (real_binfo, binfo, init_self, can_elide, addr, orig_addr, type, vbase, vbase_offsets)\n-     tree real_binfo, binfo;\n-     int init_self, can_elide;\n-     tree addr, orig_addr, type, vbase, *vbase_offsets;\n-{\n-  tree real_binfos = BINFO_BASETYPES (real_binfo);\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n-\n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= !BINFO_PRIMARY_P (real_base_binfo);\n-      if (! TREE_VIA_VIRTUAL (real_base_binfo))\n-\tfixup_virtual_upcast_offsets (real_base_binfo, base_binfo,\n-\t\t\t\t      is_not_base_vtable, can_elide, addr,\n-\t\t\t\t      orig_addr, type, vbase, vbase_offsets);\n-    }\n-#if 0\n-  /* Before turning this on, make sure it is correct.  */\n-  if (can_elide && ! BINFO_MODIFIED (binfo))\n-    return;\n-#endif\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n-    {\n-      tree new_addr = convert_pointer_to_real (binfo, addr);\n-      expand_upcast_fixups (real_binfo, new_addr, orig_addr, vbase, addr,\n-\t\t\t    type, vbase_offsets);\n-    }\n-}\n-\n-/* Fixup all the virtual upcast offsets for TYPE.  DECL_PTR is the\n-   address of the sub-object being initialized.  */\n-\n-void\n-fixup_all_virtual_upcast_offsets (decl_ptr)\n-     tree decl_ptr;\n-{\n-  tree if_stmt;\n-  tree in_charge_node;\n-  tree vbases;\n-  tree type;\n-\n-  /* Only tweak the vtables if we're in charge.  */\n-  in_charge_node = current_in_charge_parm;\n-  if (!in_charge_node)\n-    /* There's no need for any fixups in this case.  */\n-    return;\n-  in_charge_node = cp_build_binary_op (EQ_EXPR, \n-\t\t\t\t       in_charge_node, integer_zero_node);\n-  if_stmt = begin_if_stmt ();\n-  finish_if_stmt_cond (in_charge_node, if_stmt);\n-  \n-  /* Iterate through the virtual bases, fixing up the upcast offset\n-     for each one.  */\n-  type = TREE_TYPE (TREE_TYPE (decl_ptr));\n-  for (vbases = CLASSTYPE_VBASECLASSES (type);\n-       vbases;\n-       vbases = TREE_CHAIN (vbases))\n-    {\n-      if (flag_vtable_thunks)\n-\t/* We don't have dynamic thunks yet!  So for now, just fail\n-\t   silently.  */\n-\t;\n-      else\n-\t{\n-\t  tree vbase;\n-\t  tree vbase_offsets;\n-\t  tree addr;\n-\n-\t  vbase = find_vbase_instance (TREE_PURPOSE (vbases), type);\n-\t  vbase_offsets = NULL_TREE;\n-\t  addr = convert_pointer_to_vbase (TREE_PURPOSE (vbases), decl_ptr);\n-\t  fixup_virtual_upcast_offsets (vbase,\n-\t\t\t\t\tTYPE_BINFO (TREE_PURPOSE (vbases)),\n-\t\t\t\t\t1, 0, addr, decl_ptr,\n-\t\t\t\t\ttype, vbase, &vbase_offsets);\n-\t}\n-    }\n-\n-  /* Close out the if-statement.  */\n-  finish_then_clause (if_stmt);\n-  finish_if_stmt ();\n-}\n-\n /* get virtual base class types.\n    This adds type to the vbase_types list in reverse dfs order.\n    Ordering is very important, so don't change it.  */"}, {"sha": "358037332d4580c5fba768741e7f73e2371d5dca", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -2858,7 +2858,7 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n     {\n-      tree fntype, idx, e1, delta, delta2, e2, e3, aref, vtbl;\n+      tree fntype, idx, e1, delta, delta2, e2, e3, vtbl;\n       tree instance, basetype;\n \n       tree instance_ptr = *instance_ptrptr;\n@@ -2940,26 +2940,8 @@ get_member_function_from_ptrfunc (instance_ptrptr, function)\n \t build_pointer_type (build_pointer_type (vtable_entry_type)),\n \t vtbl, cp_convert (ptrdiff_type_node, delta2));\n       vtbl = build_indirect_ref (vtbl, NULL);\n-      aref = build_array_ref (vtbl, idx);\n+      e2 = build_array_ref (vtbl, idx);\n \n-      if (! flag_vtable_thunks)\n-\t{\n-\t  aref = save_expr (aref);\n-\t  \n-\t  delta = cp_build_binary_op\n-\t    (PLUS_EXPR,\n-\t     build_conditional_expr (e1,\n-\t\t\t\t     build_component_ref (aref,\n-\t\t\t\t\t\t\t  delta_identifier,\n-\t\t\t\t\t\t\t  NULL_TREE, 0),\n-\t\t\t\t     integer_zero_node),\n-\t     delta);\n-\t}\n-\n-      if (flag_vtable_thunks)\n-\te2 = aref;\n-      else\n-\te2 = build_component_ref (aref, pfn_identifier, NULL_TREE, 0);\n       TREE_TYPE (e2) = TREE_TYPE (e3);\n       e1 = build_conditional_expr (e1, e2, e3);\n       "}, {"sha": "b5d8ba92d4dd5acaae422f1b491dae32d63e683e", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4372ef4c6476dc6ed6da01dbe1b44564aee938f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c4372ef4c6476dc6ed6da01dbe1b44564aee938f", "patch": "@@ -1320,19 +1320,6 @@ The ordering of the component words of floating point values stored in\n memory is controlled by @code{FLOAT_WORDS_BIG_ENDIAN} for the target\n machine and @code{HOST_FLOAT_WORDS_BIG_ENDIAN} for the host.\n \n-@findex DEFAULT_VTABLE_THUNKS\n-@item DEFAULT_VTABLE_THUNKS\n-GCC supports two ways of implementing C++ vtables:  traditional or with\n-so-called ``thunks''.  The flag @option{-fvtable-thunk} chooses between them.\n-Define this macro to be a C expression for the default value of that flag.\n-If @code{DEFAULT_VTABLE_THUNKS} is 0, GCC uses the traditional\n-implementation by default.  The ``thunk'' implementation is more efficient\n-(especially if you have provided an implementation of\n-@code{ASM_OUTPUT_MI_THUNK}, see @ref{Function Entry}), but is not binary\n-compatible with code compiled using the traditional implementation.\n-If you are writing a new port, define @code{DEFAULT_VTABLE_THUNKS} to 1.\n-\n-If you do not define this macro, the default for @option{-fvtable-thunk} is 0.\n @end table\n \n @node Type Layout"}]}