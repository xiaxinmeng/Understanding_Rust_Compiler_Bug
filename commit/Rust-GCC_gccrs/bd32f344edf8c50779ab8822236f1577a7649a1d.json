{"sha": "bd32f344edf8c50779ab8822236f1577a7649a1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmQzMmYzNDRlZGY4YzUwNzc5YWI4ODIyMjM2ZjE1NzdhNzY0OWExZA==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2010-04-06T21:01:16Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-04-06T21:01:16Z"}, "message": "Compute min and max bounds for IVs and infer types.\n\n2010-04-04  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR middle-end/43519\n\t* Makefile.in (graphite-clast-to-gimple.o): Depends on langhooks.h.\n\t* graphite-clast-to-gimple.c: Include langhooks.h.\n\t(max_signed_precision_type): New.\n\t(max_precision_type): Takes two types as arguments.\n\t(precision_for_value): New.\n\t(precision_for_interval): New.\n\t(gcc_type_for_interval): New.\n\t(gcc_type_for_value): New.\n\t(gcc_type_for_clast_term): New.\n\t(gcc_type_for_clast_red): New.\n\t(gcc_type_for_clast_bin): New.\n\t(gcc_type_for_clast_expr): Split up into several functions.\n\t(gcc_type_for_clast_eq): Rewritten.\n\t(compute_bounds_for_level): New.\n\t(compute_type_for_level_1): New.\n\t(compute_type_for_level): New.\n\t(gcc_type_for_cloog_iv): Removed.\n\t(gcc_type_for_iv_of_clast_loop): Rewritten.\n\t(graphite_create_new_loop): Compute the lower and upper bound types\n\twith gcc_type_for_clast_expr.\n\t(graphite_create_new_loop_guard): Same.\n\t(find_cloog_iv_in_expr): Removed.\n\t(compute_cloog_iv_types_1): Removed.\n\t(compute_cloog_iv_types): Removed.\n\t(gloog): Do not call compute_cloog_iv_types.\n\t* graphite-sese-to-poly.c (new_gimple_bb): Do not initialize\n\tGBB_CLOOG_IV_TYPES.\n\t(free_data_refs_aux): Do not free GBB_CLOOG_IV_TYPES.\n\t* sese.h (struct gimple_bb): Removed field cloog_iv_types.\n\t(GBB_CLOOG_IV_TYPES): Removed.\n\n\t* gcc.dg/graphite/run-id-pr42644.c: Call abort.\n\nFrom-SVN: r158026", "tree": {"sha": "751c4be7e18b7af38104e63398dfecbec419be08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/751c4be7e18b7af38104e63398dfecbec419be08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd32f344edf8c50779ab8822236f1577a7649a1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd32f344edf8c50779ab8822236f1577a7649a1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd32f344edf8c50779ab8822236f1577a7649a1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd32f344edf8c50779ab8822236f1577a7649a1d/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79d03cf81ba8c9c303a24e98e26ca0396355e0bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d03cf81ba8c9c303a24e98e26ca0396355e0bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d03cf81ba8c9c303a24e98e26ca0396355e0bd"}], "stats": {"total": 581, "additions": 340, "deletions": 241}, "files": [{"sha": "a24f49957898015909d0dd6f8e9eae89c4e4af73", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -1,3 +1,39 @@\n+2010-04-04  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR middle-end/43519\n+\t* Makefile.in (graphite-clast-to-gimple.o): Depends on langhooks.h.\n+\t* graphite-clast-to-gimple.c: Include langhooks.h.\n+\t(max_signed_precision_type): New.\n+\t(max_precision_type): Takes two types as arguments.\n+\t(precision_for_value): New.\n+\t(precision_for_interval): New.\n+\t(gcc_type_for_interval): New.\n+\t(gcc_type_for_value): New.\n+\t(gcc_type_for_clast_term): New.\n+\t(gcc_type_for_clast_red): New.\n+\t(gcc_type_for_clast_bin): New.\n+\t(gcc_type_for_clast_expr): Split up into several functions.\n+\t(gcc_type_for_clast_eq): Rewritten.\n+\t(compute_bounds_for_level): New.\n+\t(compute_type_for_level_1): New.\n+\t(compute_type_for_level): New.\n+\t(gcc_type_for_cloog_iv): Removed.\n+\t(gcc_type_for_iv_of_clast_loop): Rewritten.\n+\t(graphite_create_new_loop): Compute the lower and upper bound types\n+\twith gcc_type_for_clast_expr.\n+\t(graphite_create_new_loop_guard): Same.\n+\t(find_cloog_iv_in_expr): Removed.\n+\t(compute_cloog_iv_types_1): Removed.\n+\t(compute_cloog_iv_types): Removed.\n+\t(gloog): Do not call compute_cloog_iv_types.\n+\t* graphite-sese-to-poly.c (new_gimple_bb): Do not initialize\n+\tGBB_CLOOG_IV_TYPES.\n+\t(free_data_refs_aux): Do not free GBB_CLOOG_IV_TYPES.\n+\t* sese.h (struct gimple_bb): Removed field cloog_iv_types.\n+\t(GBB_CLOOG_IV_TYPES): Removed.\n+\n+\t* gcc.dg/graphite/run-id-pr42644.c: Call abort.\n+\n 2010-04-02  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tReverted this commit: as at this point the loop closed SSA form"}, {"sha": "a1ad1d4a3681be0a2a02eb2a0a7448bce0f210a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -2577,7 +2577,7 @@ graphite-blocking.o: graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \\\n    $(GIMPLE_H) $(TREE_DATA_REF_H) tree-pass.h domwalk.h value-prof.h \\\n    graphite.h graphite-poly.h graphite-ppl.h\n graphite-clast-to-gimple.o: graphite-clast-to-gimple.c $(CONFIG_H) \\\n-   $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(SYSTEM_H) coretypes.h $(TM_H) langhooks.h \\\n    $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TOPLEV_H) \\\n    $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) $(CFGLOOP_H) $(GIMPLE_H) \\\n    $(TREE_DATA_REF_H) tree-pass.h domwalk.h graphite.h \\"}, {"sha": "6aab2a5521ce0b8039290f661964924e09660c0b", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 297, "deletions": 233, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"pointer-set.h\"\n #include \"gimple.h\"\n+#include \"langhooks.h\"\n #include \"sese.h\"\n \n #ifdef HAVE_cloog\n@@ -223,13 +224,40 @@ clast_name_to_gcc (const char *name, sese region, VEC (tree, heap) *newivs,\n   return newivs_to_depth_to_newiv (newivs, index);\n }\n \n-/* Returns the maximal precision type for expressions E1 and E2.  */\n+/* Returns the signed maximal precision type for expressions TYPE1 and TYPE2.  */\n \n-static inline tree\n-max_precision_type (tree e1, tree e2)\n+static tree\n+max_signed_precision_type (tree type1, tree type2)\n+{\n+  int p1 = TYPE_PRECISION (type1);\n+  int p2 = TYPE_PRECISION (type2);\n+  int precision = p1 > p2 ? p1 : p2;\n+  tree type = lang_hooks.types.type_for_size (precision, false);\n+\n+  if (!type)\n+    {\n+      gloog_error = true;\n+      return integer_type_node;\n+    }\n+  return type;\n+}\n+\n+/* Returns the maximal precision type for expressions TYPE1 and TYPE2.  */\n+\n+static tree\n+max_precision_type (tree type1, tree type2)\n {\n-  tree type1 = TREE_TYPE (e1);\n-  tree type2 = TREE_TYPE (e2);\n+\n+  if (POINTER_TYPE_P (type1))\n+    return type1;\n+\n+  if (POINTER_TYPE_P (type2))\n+    return type2;\n+\n+  if (!TYPE_UNSIGNED (type1)\n+      || !TYPE_UNSIGNED (type2))\n+    return max_signed_precision_type (type1, type2);\n+\n   return TYPE_PRECISION (type1) > TYPE_PRECISION (type2) ? type1 : type2;\n }\n \n@@ -384,7 +412,168 @@ clast_to_gcc_expression (tree type, struct clast_expr *e,\n   return NULL_TREE;\n }\n \n-/* Returns the type for the expression E.  */\n+/* Return the precision needed to represent the value VAL.  */\n+\n+static int\n+precision_for_value (Value val)\n+{\n+  Value x, y, two;\n+  int precision;\n+\n+  value_init (x);\n+  value_init (y);\n+  value_init (two);\n+  value_set_si (x, 2);\n+  value_assign (y, val);\n+  value_set_si (two, 2);\n+  precision = 1;\n+\n+  if (value_neg_p (y))\n+    value_oppose (y, y);\n+\n+  while (value_gt (y, x))\n+    {\n+      value_multiply (x, x, two);\n+      precision++;\n+    }\n+\n+  value_clear (x);\n+  value_clear (y);\n+  value_clear (two);\n+\n+  return precision;\n+}\n+\n+/* Return the precision needed to represent the values between LOW and\n+   UP.  */\n+\n+static int\n+precision_for_interval (Value low, Value up)\n+{\n+  Value diff;\n+  int precision;\n+\n+  gcc_assert (value_le (low, up));\n+\n+  value_init (diff);\n+  value_subtract (diff, up, low);\n+  precision = precision_for_value (diff);\n+  value_clear (diff);\n+\n+  return precision;\n+}\n+\n+/* Return a type that could represent the integer value VAL, or\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+gcc_type_for_interval (Value low, Value up, tree old_type)\n+{\n+  bool unsigned_p = true;\n+  int precision, prec_up, prec_int;\n+  tree type;\n+\n+  gcc_assert (value_le (low, up));\n+\n+  /* Preserve the signedness of the old IV.  */\n+  if ((old_type && !TYPE_UNSIGNED (old_type))\n+      || value_neg_p (low))\n+    unsigned_p = false;\n+\n+  prec_up = precision_for_value (up);\n+  prec_int = precision_for_interval (low, up);\n+  precision = prec_up > prec_int ? prec_up : prec_int;\n+\n+  type = lang_hooks.types.type_for_size (precision, unsigned_p);\n+  if (!type)\n+    {\n+      gloog_error = true;\n+      return integer_type_node;\n+    }\n+\n+  return type;\n+}\n+\n+/* Return a type that could represent the integer value VAL, or\n+   otherwise return NULL_TREE.  */\n+\n+static tree\n+gcc_type_for_value (Value val)\n+{\n+  return gcc_type_for_interval (val, val, NULL_TREE);\n+}\n+\n+/* Return the type for the clast_term T used in STMT.  */\n+\n+static tree\n+gcc_type_for_clast_term (struct clast_term *t,\n+\t\t\t sese region, VEC (tree, heap) *newivs,\n+\t\t\t htab_t newivs_index, htab_t params_index)\n+{\n+  gcc_assert (t->expr.type == expr_term);\n+\n+  if (!t->var)\n+    return gcc_type_for_value (t->val);\n+\n+  return TREE_TYPE (clast_name_to_gcc (t->var, region, newivs,\n+\t\t\t\t       newivs_index, params_index));\n+}\n+\n+static tree\n+gcc_type_for_clast_expr (struct clast_expr *, sese,\n+\t\t\t VEC (tree, heap) *, htab_t, htab_t);\n+\n+/* Return the type for the clast_reduction R used in STMT.  */\n+\n+static tree\n+gcc_type_for_clast_red (struct clast_reduction *r, sese region,\n+\t\t\tVEC (tree, heap) *newivs,\n+\t\t\thtab_t newivs_index, htab_t params_index)\n+{\n+  int i;\n+  tree type = NULL_TREE;\n+\n+  if (r->n == 1)\n+    return gcc_type_for_clast_expr (r->elts[0], region, newivs,\n+\t\t\t\t    newivs_index, params_index);\n+\n+  switch (r->type)\n+    {\n+    case clast_red_sum:\n+    case clast_red_min:\n+    case clast_red_max:\n+      type = gcc_type_for_clast_expr (r->elts[0], region, newivs,\n+\t\t\t\t      newivs_index, params_index);\n+      for (i = 1; i < r->n; i++)\n+\ttype = max_precision_type (type, gcc_type_for_clast_expr\n+\t\t\t\t   (r->elts[i], region, newivs,\n+\t\t\t\t    newivs_index, params_index));\n+\n+      return type;\n+\n+    default:\n+      break;\n+    }\n+\n+  gcc_unreachable ();\n+  return NULL_TREE;\n+}\n+\n+/* Return the type for the clast_binary B used in STMT.  */\n+\n+static tree\n+gcc_type_for_clast_bin (struct clast_binary *b,\n+\t\t\tsese region, VEC (tree, heap) *newivs,\n+\t\t\thtab_t newivs_index, htab_t params_index)\n+{\n+  tree l = gcc_type_for_clast_expr ((struct clast_expr *) b->LHS, region,\n+\t\t\t\t    newivs, newivs_index, params_index);\n+  tree r = gcc_type_for_value (b->RHS);\n+  return max_signed_precision_type (l, r);\n+}\n+\n+/* Returns the type for the CLAST expression E when used in statement\n+   STMT.  */\n \n static tree\n gcc_type_for_clast_expr (struct clast_expr *e,\n@@ -394,45 +583,16 @@ gcc_type_for_clast_expr (struct clast_expr *e,\n   switch (e->type)\n     {\n     case expr_term:\n-      {\n-\tstruct clast_term *t = (struct clast_term *) e;\n-\n-\tif (t->var)\n-\t  return TREE_TYPE (clast_name_to_gcc (t->var, region, newivs,\n-\t\t\t\t\t       newivs_index, params_index));\n-\telse\n-\t  return NULL_TREE;\n-      }\n+      return gcc_type_for_clast_term ((struct clast_term *) e, region,\n+\t\t\t\t      newivs, newivs_index, params_index);\n \n     case expr_red:\n-      {\n-        struct clast_reduction *r = (struct clast_reduction *) e;\n-\n-\tif (r->n == 1)\n-\t  return gcc_type_for_clast_expr (r->elts[0], region, newivs,\n-\t\t\t\t\t  newivs_index, params_index);\n-\telse\n-\t  {\n-\t    int i;\n-\t    for (i = 0; i < r->n; i++)\n-\t      {\n-\t\ttree type = gcc_type_for_clast_expr (r->elts[i], region,\n-\t\t\t\t\t\t     newivs, newivs_index,\n-\t\t\t\t\t\t     params_index);\n-\t\tif (type)\n-\t\t  return type;\n-\t      }\n-\t    return NULL_TREE;\n-\t  }\n-      }\n+      return gcc_type_for_clast_red ((struct clast_reduction *) e, region,\n+\t\t\t\t     newivs, newivs_index, params_index);\n \n     case expr_bin:\n-      {\n-\tstruct clast_binary *b = (struct clast_binary *) e;\n-\tstruct clast_expr *lhs = (struct clast_expr *) b->LHS;\n-\treturn gcc_type_for_clast_expr (lhs, region, newivs,\n-\t\t\t\t\tnewivs_index, params_index);\n-      }\n+      return gcc_type_for_clast_bin ((struct clast_binary *) e, region,\n+\t\t\t\t     newivs, newivs_index, params_index);\n \n     default:\n       gcc_unreachable ();\n@@ -448,13 +608,11 @@ gcc_type_for_clast_eq (struct clast_equation *cleq,\n \t\t       sese region, VEC (tree, heap) *newivs,\n \t\t       htab_t newivs_index, htab_t params_index)\n {\n-  tree type = gcc_type_for_clast_expr (cleq->LHS, region, newivs,\n-\t\t\t\t       newivs_index, params_index);\n-  if (type)\n-    return type;\n-\n-  return gcc_type_for_clast_expr (cleq->RHS, region, newivs, newivs_index,\n-\t\t\t\t  params_index);\n+  tree l = gcc_type_for_clast_expr (cleq->LHS, region, newivs,\n+\t\t\t\t    newivs_index, params_index);\n+  tree r = gcc_type_for_clast_expr (cleq->RHS, region, newivs,\n+\t\t\t\t    newivs_index, params_index);\n+  return max_precision_type (l, r);\n }\n \n /* Translates a clast equation CLEQ to a tree.  */\n@@ -524,103 +682,117 @@ graphite_create_new_guard (sese region, edge entry_edge,\n   return exit_edge;\n }\n \n-/* Walks a CLAST and returns the first statement in the body of a\n-   loop.  */\n+/* Compute the lower bound LOW and upper bound UP for the induction\n+   variable at LEVEL for the statement PBB, based on the transformed\n+   scattering of PBB: T|I|G|Cst, with T the scattering transform, I\n+   the iteration domain, and G the context parameters.  */\n \n-static struct clast_user_stmt *\n-clast_get_body_of_loop (struct clast_stmt *stmt)\n+static void\n+compute_bounds_for_level (poly_bb_p pbb, int level, Value low, Value up)\n {\n-  if (!stmt\n-      || CLAST_STMT_IS_A (stmt, stmt_user))\n-    return (struct clast_user_stmt *) stmt;\n+  ppl_Pointset_Powerset_C_Polyhedron_t ps;\n+  ppl_Linear_Expression_t le;\n \n-  if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    return clast_get_body_of_loop (((struct clast_for *) stmt)->body);\n+  combine_context_id_scat (&ps, pbb, false);\n \n-  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    return clast_get_body_of_loop (((struct clast_guard *) stmt)->then);\n+  /* Prepare the linear expression corresponding to the level that we\n+     want to maximize/minimize.  */\n+  {\n+    ppl_dimension_type dim = pbb_nb_scattering_transform (pbb)\n+      + pbb_dim_iter_domain (pbb) + pbb_nb_params (pbb);\n \n-  if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    return clast_get_body_of_loop (((struct clast_block *) stmt)->body);\n+    ppl_new_Linear_Expression_with_dimension (&le, dim);\n+    ppl_set_coef (le, 2 * level + 1, 1);\n+  }\n \n-  gcc_unreachable ();\n+  ppl_max_for_le_pointset (ps, le, up);\n+  ppl_min_for_le_pointset (ps, le, low);\n }\n \n-/* Java does not initialize long_long_integer_type_node.  */\n-#define my_long_long (long_long_integer_type_node ? long_long_integer_type_node : ssizetype)\n+/* Compute the type for the induction variable at LEVEL for the\n+   statement PBB, based on the transformed schedule of PBB.  OLD_TYPE\n+   is the type of the old induction variable for that loop.  */\n \n-/* Given a CLOOG_IV, return the type that CLOOG_IV should have in GCC\n-   land.  The selected type is big enough to include the original loop\n-   iteration variable, but signed to work with the subtractions CLooG\n-   may have introduced.  If such a type is not available, we fail.\n+static tree\n+compute_type_for_level_1 (poly_bb_p pbb, int level, tree old_type)\n+{\n+  Value low, up;\n+  tree type;\n \n-   TODO: Do not always return long_long, but the smallest possible\n-   type, that still holds the original type.\n+  value_init (low);\n+  value_init (up);\n \n-   TODO: Get the types using CLooG instead.  This enables further\n-   optimizations, but needs CLooG support.  */\n+  compute_bounds_for_level (pbb, level, low, up);\n+  type = gcc_type_for_interval (low, up, old_type);\n+\n+  value_clear (low);\n+  value_clear (up);\n+  return type;\n+}\n+\n+/* Compute the type for the induction variable at LEVEL for the\n+   statement PBB, based on the transformed schedule of PBB.  */\n \n static tree\n-gcc_type_for_cloog_iv (const char *cloog_iv, gimple_bb_p gbb)\n+compute_type_for_level (poly_bb_p pbb, int level)\n {\n-  struct ivtype_map_elt_s tmp;\n-  PTR *slot;\n-\n-  tmp.cloog_iv = cloog_iv;\n-  slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, NO_INSERT);\n+  tree oldiv = pbb_to_depth_to_oldiv (pbb, level);\n+  tree type = TREE_TYPE (oldiv);\n \n-  if (slot && *slot)\n+  if (type && POINTER_TYPE_P (type))\n     {\n-      tree type = ((ivtype_map_elt) *slot)->type;\n-      int type_precision = TYPE_PRECISION (type);\n-\n-      /* Find the smallest signed type possible.  */\n-      if (!TYPE_UNSIGNED (type))\n-\t{\n-\t  if (type_precision <= TYPE_PRECISION (integer_type_node))\n-\t    return integer_type_node;\n+#ifdef ENABLE_CHECKING\n+      tree ctype = compute_type_for_level_1 (pbb, level, type);\n \n-\t  if (type_precision <= TYPE_PRECISION (long_integer_type_node))\n-\t    return long_integer_type_node;\n+      /* In the case of a pointer type, check that after the loop\n+\t transform, the lower and the upper bounds of the type fit the\n+\t oldiv pointer type.  */\n+      gcc_assert (TYPE_PRECISION (type) >= TYPE_PRECISION (ctype)\n+\t\t  && integer_zerop (lower_bound_in_type (ctype, ctype)));\n+#endif\n+      return type;\n+    }\n \n-\t  if (type_precision <= TYPE_PRECISION (my_long_long))\n-\t    return my_long_long;\n+  return compute_type_for_level_1 (pbb, level, type);\n+}\n \n-\t  gcc_unreachable ();\n-\t}\n+/* Walks a CLAST and returns the first statement in the body of a\n+   loop.  */\n \n-      if (type_precision < TYPE_PRECISION (integer_type_node))\n-\treturn integer_type_node;\n+static struct clast_user_stmt *\n+clast_get_body_of_loop (struct clast_stmt *stmt)\n+{\n+  if (!stmt\n+      || CLAST_STMT_IS_A (stmt, stmt_user))\n+    return (struct clast_user_stmt *) stmt;\n \n-      if (type_precision < TYPE_PRECISION (long_integer_type_node))\n-\treturn long_integer_type_node;\n+  if (CLAST_STMT_IS_A (stmt, stmt_for))\n+    return clast_get_body_of_loop (((struct clast_for *) stmt)->body);\n \n-      if (type_precision < TYPE_PRECISION (my_long_long))\n-\treturn my_long_long;\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    return clast_get_body_of_loop (((struct clast_guard *) stmt)->then);\n \n-      /* There is no signed type available, that is large enough to hold the\n-\t original value.  */\n-      gcc_unreachable ();\n-    }\n+  if (CLAST_STMT_IS_A (stmt, stmt_block))\n+    return clast_get_body_of_loop (((struct clast_block *) stmt)->body);\n \n-  return my_long_long;\n+  gcc_unreachable ();\n }\n \n-#undef my_long_long\n-\n-/* Returns the induction variable for the loop that gets translated to\n-   STMT.  */\n+/* Returns the type for the induction variable for the loop translated\n+   from STMT_FOR.  */\n \n static tree\n-gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for)\n+gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for, int level,\n+\t\t\t       tree lb_type, tree ub_type)\n {\n   struct clast_stmt *stmt = (struct clast_stmt *) stmt_for;\n   struct clast_user_stmt *body = clast_get_body_of_loop (stmt);\n-  const char *cloog_iv = stmt_for->iterator;\n   CloogStatement *cs = body->statement;\n   poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n \n-  return gcc_type_for_cloog_iv (cloog_iv, PBB_BLACK_BOX (pbb));\n+  return max_precision_type (lb_type, max_precision_type\n+\t\t\t     (ub_type, compute_type_for_level (pbb,\n+\t\t\t\t\t\t\t       level - 1)));\n }\n \n /* Creates a new LOOP corresponding to Cloog's STMT.  Inserts an\n@@ -635,9 +807,13 @@ static struct loop *\n graphite_create_new_loop (sese region, edge entry_edge,\n \t\t\t  struct clast_for *stmt,\n \t\t\t  loop_p outer, VEC (tree, heap) **newivs,\n-\t\t\t  htab_t newivs_index, htab_t params_index)\n+\t\t\t  htab_t newivs_index, htab_t params_index, int level)\n {\n-  tree type = gcc_type_for_iv_of_clast_loop (stmt);\n+  tree lb_type = gcc_type_for_clast_expr (stmt->LB, region, *newivs,\n+\t\t\t\t\t  newivs_index, params_index);\n+  tree ub_type = gcc_type_for_clast_expr (stmt->UB, region, *newivs,\n+\t\t\t\t\t  newivs_index, params_index);\n+  tree type = gcc_type_for_iv_of_clast_loop (stmt, level, lb_type, ub_type);\n   tree lb = clast_to_gcc_expression (type, stmt->LB, region, *newivs,\n \t\t\t\t     newivs_index, params_index);\n   tree ub = clast_to_gcc_expression (type, stmt->UB, region, *newivs,\n@@ -837,7 +1013,11 @@ graphite_create_new_loop_guard (sese region, edge entry_edge,\n {\n   tree cond_expr;\n   edge exit_edge;\n-  tree type = gcc_type_for_iv_of_clast_loop (stmt);\n+  tree lb_type = gcc_type_for_clast_expr (stmt->LB, region, newivs,\n+\t\t\t\t\t  newivs_index, params_index);\n+  tree ub_type = gcc_type_for_clast_expr (stmt->UB, region, newivs,\n+\t\t\t\t\t  newivs_index, params_index);\n+  tree type = max_precision_type (lb_type, ub_type);\n   tree lb = clast_to_gcc_expression (type, stmt->LB, region, newivs,\n \t\t\t\t     newivs_index, params_index);\n   tree ub = clast_to_gcc_expression (type, stmt->UB, region, newivs,\n@@ -882,7 +1062,8 @@ translate_clast_for_loop (sese region, loop_p context_loop,\n {\n   struct loop *loop = graphite_create_new_loop (region, next_e, stmt,\n  \t\t\t\t\t\tcontext_loop, newivs,\n- \t\t\t\t\t\tnewivs_index, params_index);\n+ \t\t\t\t\t\tnewivs_index, params_index,\n+\t\t\t\t\t\tlevel);\n   edge last_e = single_exit (loop);\n   edge to_body = single_succ_edge (loop->header);\n   basic_block after = to_body->dest;\n@@ -927,7 +1108,7 @@ translate_clast_for (sese region, loop_p context_loop, struct clast_for *stmt,\n \t\t     htab_t params_index)\n {\n   edge last_e = graphite_create_new_loop_guard (region, next_e, stmt, *newivs,\n-\t\t\t\t\t   newivs_index, params_index);\n+\t\t\t\t\t\tnewivs_index, params_index);\n \n   edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n   edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n@@ -1045,122 +1226,6 @@ translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n \t\t\t  bb_pbb_mapping, level, params_index);\n }\n \n-/* Returns the first cloog name used in EXPR.  */\n-\n-static const char *\n-find_cloog_iv_in_expr (struct clast_expr *expr)\n-{\n-  struct clast_term *term = (struct clast_term *) expr;\n-  struct clast_reduction *red;\n-  int i;\n-\n-  if (expr->type == expr_term)\n-    return term->var;\n-\n-  if (expr->type != expr_red)\n-    return NULL;\n-\n-  red = (struct clast_reduction *) expr;\n-  for (i = 0; i < red->n; i++)\n-    {\n-      const char *res = find_cloog_iv_in_expr (red->elts[i]);\n-\n-      if (res)\n-\treturn res;\n-    }\n-\n-  return NULL;\n-}\n-\n-/* Build for USER_STMT a map between the CLAST induction variables and\n-   the corresponding GCC old induction variables.  This information is\n-   stored on each GRAPHITE_BB.  */\n-\n-static void\n-compute_cloog_iv_types_1 (poly_bb_p pbb, struct clast_user_stmt *user_stmt)\n-{\n-  gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  struct clast_stmt *t;\n-  int index = 0;\n-\n-  for (t = user_stmt->substitutions; t; t = t->next, index++)\n-    {\n-      PTR *slot;\n-      struct ivtype_map_elt_s tmp;\n-      struct clast_expr *expr = (struct clast_expr *)\n-\t((struct clast_assignment *)t)->RHS;\n-\n-      /* Create an entry (clast_var, type).  */\n-      tmp.cloog_iv = find_cloog_iv_in_expr (expr);\n-      if (!tmp.cloog_iv)\n-\tcontinue;\n-\n-      slot = htab_find_slot (GBB_CLOOG_IV_TYPES (gbb), &tmp, INSERT);\n-\n-      if (slot && !*slot)\n-\t{\n-\t  tree oldiv = pbb_to_depth_to_oldiv (pbb, index);\n-\t  tree type = TREE_TYPE (oldiv);\n-\t  *slot = new_ivtype_map_elt (tmp.cloog_iv, type);\n-\t}\n-    }\n-}\n-\n-/* Walk the CLAST tree starting from STMT and build for each\n-   clast_user_stmt a map between the CLAST induction variables and the\n-   corresponding GCC old induction variables.  This information is\n-   stored on each GRAPHITE_BB.  */\n-\n-static void\n-compute_cloog_iv_types (struct clast_stmt *stmt)\n-{\n-  if (!stmt)\n-    return;\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_root))\n-    goto next;\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_user))\n-    {\n-      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n-      poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n-      gimple_bb_p gbb = PBB_BLACK_BOX (pbb);\n-\n-      if (!GBB_CLOOG_IV_TYPES (gbb))\n-\tGBB_CLOOG_IV_TYPES (gbb) = htab_create (10, ivtype_map_elt_info,\n-\t\t\t\t\t\teq_ivtype_map_elts, free);\n-\n-      compute_cloog_iv_types_1 (pbb, (struct clast_user_stmt *) stmt);\n-      goto next;\n-    }\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    {\n-      struct clast_stmt *s = ((struct clast_for *) stmt)->body;\n-      compute_cloog_iv_types (s);\n-      goto next;\n-    }\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    {\n-      struct clast_stmt *s = ((struct clast_guard *) stmt)->then;\n-      compute_cloog_iv_types (s);\n-      goto next;\n-    }\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_block))\n-    {\n-      struct clast_stmt *s = ((struct clast_block *) stmt)->body;\n-      compute_cloog_iv_types (s);\n-      goto next;\n-    }\n-\n-  gcc_unreachable ();\n-\n- next:\n-  compute_cloog_iv_types (stmt->next);\n-}\n-\n /* Free the SCATTERING domain list.  */\n \n static void\n@@ -1512,7 +1577,6 @@ gloog (scop_p scop, VEC (scop_p, heap) *scops, htab_t bb_pbb_mapping)\n   graphite_verify ();\n \n   context_loop = SESE_ENTRY (region)->src->loop_father;\n-  compute_cloog_iv_types (pc.stmt);\n   rename_map = htab_create (10, rename_map_elt_info, eq_rename_map_elts, free);\n   newivs_index = htab_create (10, clast_name_index_elt_info,\n \t\t\t      eq_clast_name_indexes, free);"}, {"sha": "5c004f4abfce6dcd7e700b7b4e11fcc92ea25f8e", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -280,7 +280,6 @@ new_gimple_bb (basic_block bb, VEC (data_reference_p, heap) *drs)\n   GBB_DATA_REFS (gbb) = drs;\n   GBB_CONDITIONS (gbb) = NULL;\n   GBB_CONDITION_CASES (gbb) = NULL;\n-  GBB_CLOOG_IV_TYPES (gbb) = NULL;\n \n   return gbb;\n }\n@@ -308,9 +307,6 @@ free_data_refs_aux (VEC (data_reference_p, heap) *datarefs)\n static void\n free_gimple_bb (struct gimple_bb *gbb)\n {\n-  if (GBB_CLOOG_IV_TYPES (gbb))\n-    htab_delete (GBB_CLOOG_IV_TYPES (gbb));\n-\n   free_data_refs_aux (GBB_DATA_REFS (gbb));\n   free_data_refs (GBB_DATA_REFS (gbb));\n "}, {"sha": "28eb2fac8cdca8a15b1d73ef2ffa6fe8ff2342c3", "filename": "gcc/sese.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -346,14 +346,12 @@ typedef struct gimple_bb\n   VEC (gimple, heap) *conditions;\n   VEC (gimple, heap) *condition_cases;\n   VEC (data_reference_p, heap) *data_refs;\n-  htab_t cloog_iv_types;\n } *gimple_bb_p;\n \n #define GBB_BB(GBB) GBB->bb\n #define GBB_DATA_REFS(GBB) GBB->data_refs\n #define GBB_CONDITIONS(GBB) GBB->conditions\n #define GBB_CONDITION_CASES(GBB) GBB->condition_cases\n-#define GBB_CLOOG_IV_TYPES(GBB) GBB->cloog_iv_types\n \n /* Return the innermost loop that contains the basic block GBB.  */\n "}, {"sha": "d134b5c3084d4bc5f7f7d325013d2186f72fa12b", "filename": "gcc/testsuite/gcc.dg/graphite/run-id-pr42644.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd32f344edf8c50779ab8822236f1577a7649a1d/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Frun-id-pr42644.c?ref=bd32f344edf8c50779ab8822236f1577a7649a1d", "patch": "@@ -18,6 +18,8 @@ void foo(double Ke[2], int i, double ds[],  int column)\n     }\n }\n \n+extern void abort ();\n+\n int\n main ()\n {\n@@ -28,5 +30,8 @@ main ()\n \n   foo(Ke, 0, ds, -1);\n \n-  return (int) Ke[0] != 124;\n+  if ((int) Ke[0] != 124)\n+    abort ();\n+\n+  return 0;\n }"}]}