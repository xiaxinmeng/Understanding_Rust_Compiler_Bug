{"sha": "59c60a985d0f5a3c0d618950cd1b608114813968", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTljNjBhOTg1ZDBmNWEzYzBkNjE4OTUwY2QxYjYwODExNDgxMzk2OA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2003-04-18T18:16:40Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-04-18T18:16:40Z"}, "message": "alpha.c (SYMBOL_FLAG_NEAR, [...]): Remove.\n\n        * config/alpha/alpha.c (SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP): Remove.\n        (alpha_end_function): Don't set them.\n        (decl_in_text_section): Remove.\n        (alpha_encode_section_info): Remove.\n        (samegp_function_operand): Use SYMBOL_REF LOCAL_P and EXTERNAL_P.\n        (direct_call_operand): Use SYMBOL_REF_DECL and compare actual\n        sections, rather than decl_in_text_section results.\n\nFrom-SVN: r65785", "tree": {"sha": "9cc7d852381aafe0a9e298a3ca267665ef51d72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9cc7d852381aafe0a9e298a3ca267665ef51d72e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59c60a985d0f5a3c0d618950cd1b608114813968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c60a985d0f5a3c0d618950cd1b608114813968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59c60a985d0f5a3c0d618950cd1b608114813968", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59c60a985d0f5a3c0d618950cd1b608114813968/comments", "author": null, "committer": null, "parents": [{"sha": "0b176c1af26f5a4a7eb9fa4d69f5851e47fde26a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b176c1af26f5a4a7eb9fa4d69f5851e47fde26a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b176c1af26f5a4a7eb9fa4d69f5851e47fde26a"}], "stats": {"total": 170, "additions": 56, "deletions": 114}, "files": [{"sha": "571e9cd9e38499b9d58bd3c8260324be941d3a9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c60a985d0f5a3c0d618950cd1b608114813968/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c60a985d0f5a3c0d618950cd1b608114813968/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59c60a985d0f5a3c0d618950cd1b608114813968", "patch": "@@ -1,3 +1,13 @@\n+2003-04-18  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (SYMBOL_FLAG_NEAR, SYMBOL_FLAG_SAMEGP): Remove.\n+\t(alpha_end_function): Don't set them.\n+\t(decl_in_text_section): Remove.\n+\t(alpha_encode_section_info): Remove.\n+\t(samegp_function_operand): Use SYMBOL_REF LOCAL_P and EXTERNAL_P.\n+\t(direct_call_operand): Use SYMBOL_REF_DECL and compare actual\n+\tsections, rather than decl_in_text_section results.\n+\n 2003-04-18  Roger Sayle  <roger@eyesopen.com>\n \n \t* rtlanal.c (reg_overlap_mentioned_p): Handle ZERO_EXTRACT"}, {"sha": "2bcf9128f338e8af2f039d1a1ba10fc1852047d2", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 46, "deletions": 114, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59c60a985d0f5a3c0d618950cd1b608114813968/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59c60a985d0f5a3c0d618950cd1b608114813968/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=59c60a985d0f5a3c0d618950cd1b608114813968", "patch": "@@ -171,25 +171,17 @@ static struct alpha_rtx_cost_data const alpha_rtx_cost_data[PROCESSOR_MAX] =\n   },\n };\n \n-/* Machine-specific symbol_ref flags.  */\n-#define SYMBOL_FLAG_NEAR\t(SYMBOL_FLAG_MACH_DEP << 0)\n-#define SYMBOL_FLAG_SAMEGP\t(SYMBOL_FLAG_MACH_DEP << 1)\n-\n /* Declarations of static functions.  */\n static bool alpha_function_ok_for_sibcall\n   PARAMS ((tree, tree));\n static int tls_symbolic_operand_1\n   PARAMS ((rtx, enum machine_mode, int, int));\n static enum tls_model tls_symbolic_operand_type\n   PARAMS ((rtx));\n-static bool decl_in_text_section\n-  PARAMS ((tree));\n static bool decl_has_samegp\n   PARAMS ((tree));\n static bool alpha_in_small_data_p\n   PARAMS ((tree));\n-static void alpha_encode_section_info\n-  PARAMS ((tree, int));\n static rtx get_tls_get_addr\n   PARAMS ((void));\n static int some_small_symbolic_operand_1\n@@ -301,8 +293,6 @@ static void vms_asm_out_destructor PARAMS ((rtx, int));\n \n #undef TARGET_IN_SMALL_DATA_P\n #define TARGET_IN_SMALL_DATA_P alpha_in_small_data_p\n-#undef TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO alpha_encode_section_info\n \n #if TARGET_ABI_UNICOSMK\n static void unicosmk_asm_named_section PARAMS ((const char *, unsigned int));\n@@ -1045,15 +1035,27 @@ samegp_function_operand (op, mode)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   if (GET_CODE (op) != SYMBOL_REF)\n-    return 0;\n+    return false;\n \n   /* Easy test for recursion.  */\n   if (op == XEXP (DECL_RTL (current_function_decl), 0))\n-    return 1;\n+    return true;\n+\n+  /* Functions that are not local can be overridden, and thus may\n+     not share the same gp.  */\n+  if (! SYMBOL_REF_LOCAL_P (op))\n+    return false;\n+\n+  /* If -msmall-data is in effect, assume that there is only one GP\n+     for the module, and so any local symbol has this property.  We\n+     need explicit relocations to be able to enforce this for symbols\n+     not defined in this unit of translation, however.  */\n+  if (TARGET_EXPLICIT_RELOCS && TARGET_SMALL_DATA)\n+    return true;\n \n-  /* Otherwise, encode_section_info recorded whether we are to treat\n-     this symbol as having the same GP.  */\n-  return (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_SAMEGP) != 0;\n+  /* Functions that are not external are defined in this UoT,\n+     and thus must share the same gp.  */\n+  return ! SYMBOL_REF_EXTERNAL_P (op);\n }\n \n /* Return 1 if OP is a SYMBOL_REF for which we can make a call via bsr.  */\n@@ -1063,11 +1065,11 @@ direct_call_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  bool is_near;\n+  tree op_decl, cfun_sec, op_sec;\n \n   /* Must share the same GP.  */\n   if (!samegp_function_operand (op, mode))\n-    return 0;\n+    return false;\n \n   /* If profiling is implemented via linker tricks, we can't jump\n      to the nogp alternate entry point.  Note that current_function_profile\n@@ -1077,18 +1079,36 @@ direct_call_operand (op, mode)\n      but is approximately correct for the OSF ABIs.  Don't know\n      what to do for VMS, NT, or UMK.  */\n   if (!TARGET_PROFILING_NEEDS_GP && profile_flag)\n-    return 0;\n-\n-  is_near = (SYMBOL_REF_FLAGS (op) & SYMBOL_FLAG_NEAR) != 0;\n+    return false;\n \n+  /* Must be a function.  In some cases folks create thunks in static\n+     data structures and then make calls to them.  If we allow the\n+     direct call, we'll get an error from the linker about !samegp reloc\n+     against a symbol without a .prologue directive.  */\n+  if (!SYMBOL_REF_FUNCTION_P (op))\n+    return false;\n+  \n   /* Must be \"near\" so that the branch is assumed to reach.  With\n-     -msmall-text, this is true of all local symbols.  */\n+     -msmall-text, this is assumed true of all local symbols.  Since\n+     we've already checked samegp, locality is already assured.  */\n   if (TARGET_SMALL_TEXT)\n-    return is_near;\n+    return true;\n+\n+  /* Otherwise, a decl is \"near\" if it is defined in the same section.  */\n+  if (flag_function_sections)\n+    return false;\n+\n+  op_decl = SYMBOL_REF_DECL (op);\n+  if (DECL_ONE_ONLY (current_function_decl)\n+      || (op_decl && DECL_ONE_ONLY (op_decl)))\n+    return false;\n \n-  /* Otherwise, a decl is \"near\" if it is defined in the same section.\n-     See alpha_encode_section_info for commentary.  */\n-  return is_near && decl_in_text_section (cfun->decl);\n+  cfun_sec = DECL_SECTION_NAME (current_function_decl);\n+  op_sec = op_decl ? DECL_SECTION_NAME (op_decl) : NULL;\n+  return ((!cfun_sec && !op_sec)\n+\t  || (cfun_sec && op_sec\n+\t      && strcmp (TREE_STRING_POINTER (cfun_sec),\n+\t\t         TREE_STRING_POINTER (op_sec)) == 0));\n }\n \n /* Return true if OP is a LABEL_REF, or SYMBOL_REF or CONST referencing\n@@ -1818,22 +1838,6 @@ tls_symbolic_operand_type (symbol)\n   return model;\n }\n \f\n-/* Return true if the function DECL will be placed in the default text\n-   section.  */\n-/* ??? Ideally we'd be able to always move from a SYMBOL_REF back to the\n-   decl, as that would allow us to determine if two functions are in the\n-   same section, which is what we really want to know.  */\n-\n-static bool\n-decl_in_text_section (decl)\n-     tree decl;\n-{\n-  return (DECL_SECTION_NAME (decl) == NULL_TREE\n-\t  && ! (flag_function_sections\n-\t        || (targetm.have_named_sections\n-\t\t    && DECL_ONE_ONLY (decl))));\n-}\n-\n /* Return true if the function DECL will share the same GP as any\n    function in the current unit of translation.  */\n \n@@ -1889,58 +1893,6 @@ alpha_in_small_data_p (exp)\n   return false;\n }\n \n-/* If we are referencing a function that is static, make the SYMBOL_REF\n-   special.  We use this to see indicate we can branch to this function\n-   without setting PV or restoring GP. \n-\n-   If this is a variable that is known to be defined locally, add \"@v\"\n-   to the name.  If in addition the variable is to go in .sdata/.sbss,\n-   then add \"@s\" instead.  */\n-\n-static void\n-alpha_encode_section_info (decl, first)\n-     tree decl;\n-     int first;\n-{\n-  default_encode_section_info (decl, first);\n- \n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      rtx symbol = XEXP (DECL_RTL (decl), 0);\n-      int flags = SYMBOL_REF_FLAGS (symbol);\n-\n-      /* Mark whether the decl is \"near\" in distance.  If -msmall-text is\n-\t in effect, this is trivially true of all local symbols.  */\n-      if (TARGET_SMALL_TEXT)\n-\t{\n-\t  if (flags & SYMBOL_FLAG_LOCAL)\n-\t    flags |= SYMBOL_FLAG_NEAR;\n-\t}\n-      else\n-\t{\n-\t  /* Otherwise, a decl is \"near\" if it is defined in this same\n-\t     section.  What we really need is to be able to access the\n-\t     target decl of a call from the call_insn pattern, so that\n-\t     we can determine if the call is from the same section.  We\n-\t     can't do that at present, so handle the common case and\n-\t     match up .text with .text.\n-\n-\t     Delay marking public functions until they are emitted; otherwise\n-\t     we don't know that they exist in this unit of translation.  */\n-\t  /* Now we *DO* have access to SYMBOL_REF_DECL.  Fixme.  */\n-\t  if (!TREE_PUBLIC (decl) && decl_in_text_section (decl))\n-            flags |= SYMBOL_FLAG_NEAR;\n-\t}\n-\n-      /* Indicate whether the target function shares the same GP as any\n-\t function emitted in this unit of translation.  */\n-      if (decl_has_samegp (decl))\n-\tflags |= SYMBOL_FLAG_SAMEGP;\n-\n-      SYMBOL_REF_FLAGS (symbol) = flags;\n-    }\n-}\n-\n #if TARGET_ABI_OPEN_VMS\n static bool\n alpha_linkage_symbol_p (symname)\n@@ -8070,7 +8022,7 @@ void\n alpha_end_function (file, fnname, decl)\n      FILE *file;\n      const char *fnname;\n-     tree decl;\n+     tree decl ATTRIBUTE_UNUSED;\n {\n   /* End the function.  */\n   if (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive)\n@@ -8085,26 +8037,6 @@ alpha_end_function (file, fnname, decl)\n   alpha_write_linkage (file, fnname, decl);\n #endif\n \n-  /* Show that we know this function if it is called again.\n-     This is only meaningful for symbols that bind locally.  */\n-  if ((*targetm.binds_local_p) (decl))\n-    {\n-      rtx symbol = XEXP (DECL_RTL (decl), 0);\n-      int flags = SYMBOL_REF_FLAGS (symbol);\n-\n-      /* Mark whether the decl is \"near\".  See the commentary in \n-\t alpha_encode_section_info wrt the .text section.  */\n-      if (decl_in_text_section (decl))\n-\tflags |= SYMBOL_FLAG_NEAR;\n-\n-      /* Mark whether the decl shares a GP with other functions\n-\t in this unit of translation.  This is trivially true of\n-\t local symbols.  */\n-      flags |= SYMBOL_FLAG_SAMEGP;\n-\n-      SYMBOL_REF_FLAGS (symbol) = flags;\n-    }\n-\n   /* Output jump tables and the static subroutine information block.  */\n   if (TARGET_ABI_UNICOSMK)\n     {"}]}