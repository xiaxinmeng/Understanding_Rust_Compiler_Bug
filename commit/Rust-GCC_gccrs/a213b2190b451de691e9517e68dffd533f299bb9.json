{"sha": "a213b2190b451de691e9517e68dffd533f299bb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxM2IyMTkwYjQ1MWRlNjkxZTk1MTdlNjhkZmZkNTMzZjI5OWJiOQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2008-09-09T18:39:45Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2008-09-09T18:39:45Z"}, "message": "re PR middle-end/37375 ([graphite] Parameter detection and scev only take a surrounding loop as border)\n\n2008-09-05  Sebastian Pop  <sebastian.pop@amd.com>\n\n\tPR tree-optimization/37375\n\t* tree-scalar-evolution.c (scev_info_str): Add field instantiated_below.\n\t(new_scev_info_str, eq_scev_info, find_var_scev_info,\n\tset_scalar_evolution, get_scalar_evolution, get_instantiated_value,\n\tset_instantiated_value): Pass instantiated_below.\n\t(analyze_scalar_evolution_1, analyze_scalar_evolution): Update calls to\n\tabove functions.\n\t(instantiate_scev_1, instantiate_scev): Pass a basic block above which the\n\tdefinitions are not instantiated.\n\n\t* tree-scalar-evolution.h (instantiate_scev): Update declaration.\n\t(block_before_loop): New.\n\t* tree-data-ref.c (dr_analyze_indices): Update uses of instantiate_scev.\n\t* graphite.c (block_before_scop): New.\n\t(loop_affine_expr, stmt_simple_for_scop_p, harmful_stmt_in_bb): Pass a \n\tbasic block, not a loop for determining the parameters.\n\t(scopdet_edge_info, build_scops_1): Do not pass outermost loop in the\n\tscop.\n\t(idx_record_params, find_params_in_bb, find_scop_parameters,\n\tbuild_loop_iteration_domains, add_conditions_to_domain): Update calls \n\tto instantiate_scev.\n\t\n\t* Makefile.in (cfgloopmanip.o): Add missing dependency on TREE_FLOW_H.\n\nFrom-SVN: r140164", "tree": {"sha": "73195c19addce9aac12faa4c9914cd880f94c5b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73195c19addce9aac12faa4c9914cd880f94c5b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a213b2190b451de691e9517e68dffd533f299bb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a213b2190b451de691e9517e68dffd533f299bb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a213b2190b451de691e9517e68dffd533f299bb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a213b2190b451de691e9517e68dffd533f299bb9/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00ca66405c3b9da27fab36bd55e62148e97d7491", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00ca66405c3b9da27fab36bd55e62148e97d7491", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00ca66405c3b9da27fab36bd55e62148e97d7491"}], "stats": {"total": 306, "additions": 172, "deletions": 134}, "files": [{"sha": "ef34d8d541d479fd48dad6631f080ec54880b212", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -1,3 +1,29 @@\n+2008-09-09  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\tPR tree-optimization/37375\n+\t* tree-scalar-evolution.c (scev_info_str): Add field instantiated_below.\n+\t(new_scev_info_str, eq_scev_info, find_var_scev_info,\n+\tset_scalar_evolution, get_scalar_evolution, get_instantiated_value,\n+\tset_instantiated_value): Pass instantiated_below.\n+\t(analyze_scalar_evolution_1, analyze_scalar_evolution): Update calls to\n+\tabove functions.\n+\t(instantiate_scev_1, instantiate_scev): Pass a basic block above which the\n+\tdefinitions are not instantiated.\n+\n+\t* tree-scalar-evolution.h (instantiate_scev): Update declaration.\n+\t(block_before_loop): New.\n+\t* tree-data-ref.c (dr_analyze_indices): Update uses of instantiate_scev.\n+\t* graphite.c (block_before_scop): New.\n+\t(loop_affine_expr, stmt_simple_for_scop_p, harmful_stmt_in_bb): Pass a \n+\tbasic block, not a loop for determining the parameters.\n+\t(scopdet_edge_info, build_scops_1): Do not pass outermost loop in the\n+\tscop.\n+\t(idx_record_params, find_params_in_bb, find_scop_parameters,\n+\tbuild_loop_iteration_domains, add_conditions_to_domain): Update calls \n+\tto instantiate_scev.\n+\n+\t* Makefile.in (cfgloopmanip.o): Add missing dependency on TREE_FLOW_H.\n+\n 2008-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-opt/37333"}, {"sha": "f486392433bd773c9d0b0d415d4eb5b09f9df157", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -2816,7 +2816,7 @@ loop-invariant.o : loop-invariant.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(HASHTAB_H) except.h\n cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) output.h \\\n-   coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H)\n+   coretypes.h $(TM_H) cfghooks.h $(OBSTACK_H) $(TREE_FLOW_H)\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) \\\n    coretypes.h $(TM_H) $(OBSTACK_H) tree-pass.h $(TIMEVAR_H) $(FLAGS_H) $(DF_H)"}, {"sha": "40a317eb5f53230b38fb1d0c2c53689070435b1e", "filename": "gcc/graphite.c", "status": "modified", "additions": 60, "deletions": 54, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -717,16 +717,24 @@ outermost_loop_in_scop (scop_p scop, basic_block bb)\n   return nest;\n }\n \n+/* Returns the block preceding the entry of SCOP.  */\n+\n+static basic_block\n+block_before_scop (scop_p scop)\n+{\n+  return SESE_ENTRY (SCOP_REGION (scop))->src;\n+}\n+\n /* Return true when EXPR is an affine function in LOOP with parameters\n-   instantiated relative to outermost_loop.  */\n+   instantiated relative to SCOP_ENTRY.  */\n \n static bool\n-loop_affine_expr (struct loop *outermost_loop, struct loop *loop, tree expr)\n+loop_affine_expr (basic_block scop_entry, struct loop *loop, tree expr)\n {\n-  int n = outermost_loop->num;\n+  int n = scop_entry->loop_father->num;\n   tree scev = analyze_scalar_evolution (loop, expr);\n \n-  scev = instantiate_scev (outermost_loop, loop, scev);\n+  scev = instantiate_scev (scop_entry, loop, scev);\n \n   return (evolution_function_is_invariant_p (scev, n)\n \t  || evolution_function_is_affine_multivariate_p (scev, n));\n@@ -751,11 +759,11 @@ is_simple_operand (loop_p loop, gimple stmt, tree op)\n }\n \n /* Return true only when STMT is simple enough for being handled by\n-   Graphite.  This depends on OUTERMOST_LOOP, as the parametetrs are\n-   initialized relative to this loop.  */\n+   Graphite.  This depends on SCOP_ENTRY, as the parametetrs are\n+   initialized relatively to this basic block.  */\n \n static bool\n-stmt_simple_for_scop_p (struct loop *outermost_loop, gimple stmt)\n+stmt_simple_for_scop_p (basic_block scop_entry, gimple stmt)\n {\n   basic_block bb = gimple_bb (stmt);\n   struct loop *loop = bb->loop_father;\n@@ -791,11 +799,11 @@ stmt_simple_for_scop_p (struct loop *outermost_loop, gimple stmt)\n \t      || code == GE_EXPR))\n           return false;\n \n-\tif (!outermost_loop)\n+\tif (!scop_entry)\n \t  return false;\n \n \tFOR_EACH_SSA_TREE_OPERAND (op, stmt, op_iter, SSA_OP_ALL_USES)\n-\t  if (!loop_affine_expr (outermost_loop, loop, op))\n+\t  if (!loop_affine_expr (scop_entry, loop, op))\n \t    return false;\n \n \treturn true;\n@@ -850,18 +858,17 @@ stmt_simple_for_scop_p (struct loop *outermost_loop, gimple stmt)\n }\n \n /* Returns the statement of BB that contains a harmful operation: that\n-   can be a function call with side effects, data dependences that\n-   cannot be computed in OUTERMOST_LOOP, the induction variables are\n-   not linear with respect to OUTERMOST_LOOP, etc.  The current open\n+   can be a function call with side effects, the induction variables\n+   are not linear with respect to SCOP_ENTRY, etc.  The current open\n    scop should end before this statement.  */\n \n static gimple\n-harmful_stmt_in_bb (struct loop *outermost_loop, basic_block bb)\n+harmful_stmt_in_bb (basic_block scop_entry, basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!stmt_simple_for_scop_p (outermost_loop, gsi_stmt (gsi)))\n+    if (!stmt_simple_for_scop_p (scop_entry, gsi_stmt (gsi)))\n       return gsi_stmt (gsi);\n \n   return NULL;\n@@ -1048,20 +1055,28 @@ struct scopdet_info\n };\n \n static struct scopdet_info build_scops_1 (edge, VEC (scop_p, heap) **,\n-                                          loop_p, loop_p);\n+                                          loop_p);\n \n /* Checks, if a bb can be added to a SCoP.  */\n \n static struct scopdet_info \n-scopdet_edge_info (edge ee, loop_p outermost_loop,\n+scopdet_edge_info (edge ee,\n \t\t   VEC (scop_p, heap) **scops, gbb_type type, gimple *stmt)\n \t       \n {\n   basic_block bb = ee->dest;\n   struct loop *loop = bb->loop_father;\n   struct scopdet_info result;\n+  basic_block scop_entry;\n \n-  *stmt = harmful_stmt_in_bb (outermost_loop, bb);\n+  if (VEC_length (scop_p, *scops) != 0)\n+    scop_entry = block_before_scop (VEC_last (scop_p, *scops));\n+  else if (loop->header)\n+    scop_entry = loop->header;\n+  else\n+    scop_entry = ENTRY_BLOCK_PTR;\n+\n+  *stmt = harmful_stmt_in_bb (scop_entry, bb);\n   result.difficult = (*stmt != NULL);\n   result.last = NULL;\n \n@@ -1084,7 +1099,7 @@ scopdet_edge_info (edge ee, loop_p outermost_loop,\n         VEC (scop_p, heap) *tmp_scops = VEC_alloc (scop_p, heap, 3);\n         struct scopdet_info sinfo;\n \n-        sinfo = build_scops_1 (ee, &tmp_scops, loop, outermost_loop);\n+        sinfo = build_scops_1 (ee, &tmp_scops, loop);\n \n         result.last = single_exit (bb->loop_father);\n \n@@ -1117,20 +1132,18 @@ scopdet_edge_info (edge ee, loop_p outermost_loop,\n     case GBB_LOOP_MULT_EXIT_HEADER:\n       {\n         /* XXX: Handle loop nests with the same header.  */\n-        /* XXX: Handle iterative optimization of outermost_loop.  */\n         /* XXX: For now we just do not join loops with multiple exits. If the \n            exits lead to the same bb it may be possible to join the loop.  */\n         VEC (scop_p, heap) *tmp_scops = VEC_alloc (scop_p, heap, 3);\n         VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n         edge e;\n         int i;\n-        build_scops_1 (ee, &tmp_scops, loop, outermost_loop);\n+        build_scops_1 (ee, &tmp_scops, loop);\n \n         for (i = 0; VEC_iterate (edge, exits, i, e); i++)\n           if (dominated_by_p (CDI_DOMINATORS, e->dest, e->src)\n               && e->dest->loop_father == loop_outer (loop))\n-            build_scops_1 (e, &tmp_scops, e->dest->loop_father,\n-                           outermost_loop);\n+            build_scops_1 (e, &tmp_scops, e->dest->loop_father);\n \n         result.next = NULL; \n         result.last = NULL;\n@@ -1199,7 +1212,7 @@ scopdet_edge_info (edge ee, loop_p outermost_loop,\n \t\tcontinue;\n \t      }\n \n-\t    sinfo = build_scops_1 (e, &tmp_scops, loop, outermost_loop);\n+\t    sinfo = build_scops_1 (e, &tmp_scops, loop);\n \n \t    result.exits |= sinfo.exits;\n \t    result.last = sinfo.last;\n@@ -1261,10 +1274,9 @@ scopdet_edge_info (edge ee, loop_p outermost_loop,\n \t      e = split_block (dom_bb, NULL);\n \n \t    if (loop_depth (loop) > loop_depth (dom_bb->loop_father))\n-\t      sinfo = build_scops_1 (e, &tmp_scops, loop_outer (loop),\n-\t\t\t\t     outermost_loop);\n+\t      sinfo = build_scops_1 (e, &tmp_scops, loop_outer (loop));\n \t    else\n-\t      sinfo = build_scops_1 (e, &tmp_scops, loop, outermost_loop);\n+\t      sinfo = build_scops_1 (e, &tmp_scops, loop);\n                                            \n                                      \n \t    result.exits |= sinfo.exits; \n@@ -1335,8 +1347,7 @@ end_scop (scop_p scop, edge exit, bool split_entry)\n /* Creates the SCoPs and writes entry and exit points for every SCoP.  */\n \n static struct scopdet_info \n-build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop,\n-\t       loop_p outermost_loop)\n+build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop)\n {\n   edge current = start;\n \n@@ -1357,7 +1368,7 @@ build_scops_1 (edge start, VEC (scop_p, heap) **scops, loop_p loop,\n      and can only be added if all bbs in deeper layers are simple.  */\n   while (current != NULL)\n     {\n-      sinfo = scopdet_edge_info (current, outermost_loop, scops,\n+      sinfo = scopdet_edge_info (current, scops,\n \t\t\t\t get_bb_type (current->dest, loop), &stmt);\n \n       if (!in_scop && !(sinfo.exits || sinfo.difficult))\n@@ -1433,7 +1444,7 @@ static void\n build_scops (void)\n {\n   struct loop *loop = current_loops->tree_root;\n-  build_scops_1 (single_succ_edge (ENTRY_BLOCK_PTR), &current_scops, loop, loop);\n+  build_scops_1 (single_succ_edge (ENTRY_BLOCK_PTR), &current_scops, loop);\n }\n \n /* Gather the basic blocks belonging to the SCOP.  */\n@@ -1895,19 +1906,15 @@ idx_record_params (tree base, tree *idx, void *dta)\n       tree scev;\n       scop_p scop = data->scop;\n       struct loop *loop = data->loop;\n+      Value one;\n \n       scev = analyze_scalar_evolution (loop, *idx);\n-      scev = instantiate_scev (outermost_loop_in_scop (scop, loop->header),\n-\t\t\t       loop, scev);\n-\n-      {\n-\tValue one;\n+      scev = instantiate_scev (block_before_scop (scop), loop, scev);\n \n-\tvalue_init (one);\n-\tvalue_set_si (one, 1);\n-\tscan_tree_for_params (scop, scev, NULL, 0, one, false);\n-\tvalue_clear (one);\n-      }\n+      value_init (one);\n+      value_set_si (one, 1);\n+      scan_tree_for_params (scop, scev, NULL, 0, one, false);\n+      value_clear (one);\n     }\n \n   return true;\n@@ -1957,11 +1964,11 @@ find_params_in_bb (scop_p scop, basic_block bb)\n           \n           lhs = gimple_cond_lhs (stmt);\n           lhs = analyze_scalar_evolution (loop, lhs);\n-          lhs = instantiate_scev (nest, loop, lhs);\n+          lhs = instantiate_scev (block_before_scop (scop), loop, lhs);\n \n           rhs = gimple_cond_rhs (stmt);\n           rhs = analyze_scalar_evolution (loop, rhs);\n-          rhs = instantiate_scev (nest, loop, rhs);\n+          rhs = instantiate_scev (block_before_scop (scop), loop, rhs);\n \n           value_init (one);\n           scan_tree_for_params (scop, lhs, NULL, 0, one, false);\n@@ -2081,8 +2088,7 @@ find_scop_parameters (scop_p scop)\n \tcontinue;\n \n       nb_iters = analyze_scalar_evolution (loop, nb_iters);\n-      nb_iters = instantiate_scev (outermost_loop_in_scop (scop, loop->header),\n-\t\t\t\t   loop, nb_iters);\n+      nb_iters = instantiate_scev (block_before_scop (scop), loop, nb_iters);\n       scan_tree_for_params (scop, nb_iters, NULL, 0, one, false);\n     }\n \n@@ -2209,10 +2215,10 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n       row++;\n       value_set_si (cstr->p[row][0], 1);\n       value_set_si (cstr->p[row][loop_col], -1);\n+\n       nb_iters = analyze_scalar_evolution (loop, nb_iters);\n-      nb_iters = \n-        instantiate_scev (outermost_loop_in_scop (scop, loop->header),\n-\t\t\t  loop, nb_iters);\n+      nb_iters = instantiate_scev (block_before_scop (scop), loop, nb_iters);\n+\n       value_init (one);\n       value_set_si (one, 1);\n       scan_tree_for_params (scop, nb_iters, cstr, row, one, false);\n@@ -2333,15 +2339,15 @@ add_conditions_to_domain (graphite_bb_p gb)\n             tree left;\n             tree right;\n             loop_p loop = GBB_BB (gb)->loop_father;\n-            loop_p outermost = outermost_loop_in_scop (scop, GBB_BB (gb));\n \n             left = gimple_cond_lhs (stmt);\n             right = gimple_cond_rhs (stmt);\n \n             left = analyze_scalar_evolution (loop, left);\n             right = analyze_scalar_evolution (loop, right);\n-            left = instantiate_scev (outermost, loop, left);\n-            right = instantiate_scev (outermost, loop, right);\n+\n+            left = instantiate_scev (block_before_scop (scop), loop, left);\n+            right = instantiate_scev (block_before_scop (scop), loop, right);\n \n             code = gimple_cond_code (stmt);\n \n@@ -3974,13 +3980,13 @@ gbb_can_be_ignored (graphite_bb_p gb)\n              XXX: Just a heuristic, that needs further investigation.  */\n           case GIMPLE_ASSIGN:\n \t    {\n-\t      tree var =  gimple_assign_lhs (stmt);\n+\t      tree var = gimple_assign_lhs (stmt);\n \t      var = analyze_scalar_evolution (loop, var);\n-\t      var = instantiate_scev (outermost_loop_in_scop (scop,\n-\t\t\t\t\t\t\t      GBB_BB (gb)),\n-\t\t\t\t      loop, var);\n+\t      var = instantiate_scev (block_before_scop (scop), loop, var);\n+\n \t      if (TREE_CODE (var) == SCEV_NOT_KNOWN)\n \t\treturn false;\n+\n \t      break;\n \t    }\n           /* Otherwise not ignoreable.  */"}, {"sha": "2be0ad1b401a92d60cd95c86b307b82f0250f0cb", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -747,14 +747,15 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n   VEC (tree, heap) *access_fns = NULL;\n   tree ref = unshare_expr (DR_REF (dr)), aref = ref, op;\n   tree base, off, access_fn;\n+  basic_block before_loop = block_before_loop (nest);\n \n   while (handled_component_p (aref))\n     {\n       if (TREE_CODE (aref) == ARRAY_REF)\n \t{\n \t  op = TREE_OPERAND (aref, 1);\n \t  access_fn = analyze_scalar_evolution (loop, op);\n-\t  access_fn = instantiate_scev (nest, loop, access_fn);\n+\t  access_fn = instantiate_scev (before_loop, loop, access_fn);\n \t  VEC_safe_push (tree, heap, access_fns, access_fn);\n \n \t  TREE_OPERAND (aref, 1) = build_int_cst (TREE_TYPE (op), 0);\n@@ -767,7 +768,7 @@ dr_analyze_indices (struct data_reference *dr, struct loop *nest)\n     {\n       op = TREE_OPERAND (aref, 0);\n       access_fn = analyze_scalar_evolution (loop, op);\n-      access_fn = instantiate_scev (nest, loop, access_fn);\n+      access_fn = instantiate_scev (before_loop, loop, access_fn);\n       base = initial_condition (access_fn);\n       split_constant_offset (base, &base, &off);\n       access_fn = chrec_replace_initial_condition (access_fn,"}, {"sha": "64d628a1adf2d1ccc400307edf0b13974dbeeaf1", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -175,8 +175,8 @@ along with GCC; see the file COPYING3.  If not see\n    value of loop_2 for \"j\" is 4, and the evolution of \"k\" in loop_1 is\n    {0, +, 1}_1.  To obtain the evolution function in loop_3 and\n    instantiate the scalar variables up to loop_1, one has to use:\n-   instantiate_scev (loop_1, loop_3, \"j + k\").  The result of this\n-   call is {{0, +, 1}_1, +, 1}_2.\n+   instantiate_scev (block_before_loop (loop_1), loop_3, \"j + k\").\n+   The result of this call is {{0, +, 1}_1, +, 1}_2.\n \n    Example 3: Higher degree polynomials.\n      \n@@ -278,11 +278,13 @@ along with GCC; see the file COPYING3.  If not see\n \n static tree analyze_scalar_evolution_1 (struct loop *, tree, tree);\n \n-/* The cached information about a ssa name VAR, claiming that inside LOOP,\n-   the value of VAR can be expressed as CHREC.  */\n+/* The cached information about an SSA name VAR, claiming that below\n+   basic block INSTANTIATED_BELOW, the value of VAR can be expressed\n+   as CHREC.  */\n \n struct scev_info_str GTY(())\n {\n+  basic_block instantiated_below;\n   tree var;\n   tree chrec;\n };\n@@ -306,22 +308,21 @@ tree chrec_dont_know;\n    happen, then it qualifies it with chrec_known.  */\n tree chrec_known;\n \n-static bitmap already_instantiated;\n-\n static GTY ((param_is (struct scev_info_str))) htab_t scalar_evolution_info;\n \n \f\n-/* Constructs a new SCEV_INFO_STR structure.  */\n+/* Constructs a new SCEV_INFO_STR structure for VAR and INSTANTIATED_BELOW.  */\n \n static inline struct scev_info_str *\n-new_scev_info_str (tree var)\n+new_scev_info_str (basic_block instantiated_below, tree var)\n {\n   struct scev_info_str *res;\n   \n   res = GGC_NEW (struct scev_info_str);\n   res->var = var;\n   res->chrec = chrec_not_analyzed_yet;\n-  \n+  res->instantiated_below = instantiated_below;\n+\n   return res;\n }\n \n@@ -341,7 +342,8 @@ eq_scev_info (const void *e1, const void *e2)\n   const struct scev_info_str *elt1 = (const struct scev_info_str *) e1;\n   const struct scev_info_str *elt2 = (const struct scev_info_str *) e2;\n \n-  return elt1->var == elt2->var;\n+  return (elt1->var == elt2->var\n+\t  && elt1->instantiated_below == elt2->instantiated_below);\n }\n \n /* Deletes database element E.  */\n@@ -352,22 +354,22 @@ del_scev_info (void *e)\n   ggc_free (e);\n }\n \n-/* Get the index corresponding to VAR in the current LOOP.  If\n-   it's the first time we ask for this VAR, then we return\n-   chrec_not_analyzed_yet for this VAR and return its index.  */\n+/* Get the scalar evolution of VAR for INSTANTIATED_BELOW basic block.\n+   A first query on VAR returns chrec_not_analyzed_yet.  */\n \n static tree *\n-find_var_scev_info (tree var)\n+find_var_scev_info (basic_block instantiated_below, tree var)\n {\n   struct scev_info_str *res;\n   struct scev_info_str tmp;\n   PTR *slot;\n \n   tmp.var = var;\n+  tmp.instantiated_below = instantiated_below;\n   slot = htab_find_slot (scalar_evolution_info, &tmp, INSERT);\n \n   if (!*slot)\n-    *slot = new_scev_info_str (var);\n+    *slot = new_scev_info_str (instantiated_below, var);\n   res = (struct scev_info_str *) *slot;\n \n   return &res->chrec;\n@@ -570,20 +572,22 @@ chrec_is_positive (tree chrec, bool *value)\n /* Associate CHREC to SCALAR.  */\n \n static void\n-set_scalar_evolution (tree scalar, tree chrec)\n+set_scalar_evolution (basic_block instantiated_below, tree scalar, tree chrec)\n {\n   tree *scalar_info;\n  \n   if (TREE_CODE (scalar) != SSA_NAME)\n     return;\n \n-  scalar_info = find_var_scev_info (scalar);\n+  scalar_info = find_var_scev_info (instantiated_below, scalar);\n   \n   if (dump_file)\n     {\n       if (dump_flags & TDF_DETAILS)\n \t{\n \t  fprintf (dump_file, \"(set_scalar_evolution \\n\");\n+\t  fprintf (dump_file, \"  instantiated_below = %d \\n\",\n+\t\t   instantiated_below->index);\n \t  fprintf (dump_file, \"  (scalar = \");\n \t  print_generic_expr (dump_file, scalar, 0);\n \t  fprintf (dump_file, \")\\n  (scalar_evolution = \");\n@@ -597,10 +601,11 @@ set_scalar_evolution (tree scalar, tree chrec)\n   *scalar_info = chrec;\n }\n \n-/* Retrieve the chrec associated to SCALAR in the LOOP.  */\n+/* Retrieve the chrec associated to SCALAR instantiated below\n+   INSTANTIATED_BELOW block.  */\n \n static tree\n-get_scalar_evolution (tree scalar)\n+get_scalar_evolution (basic_block instantiated_below, tree scalar)\n {\n   tree res;\n   \n@@ -620,7 +625,7 @@ get_scalar_evolution (tree scalar)\n   switch (TREE_CODE (scalar))\n     {\n     case SSA_NAME:\n-      res = *find_var_scev_info (scalar);\n+      res = *find_var_scev_info (instantiated_below, scalar);\n       break;\n \n     case REAL_CST:\n@@ -1845,7 +1850,7 @@ analyze_scalar_evolution_1 (struct loop *loop, tree var, tree res)\n     res = var;\n \n   if (loop == def_loop)\n-    set_scalar_evolution (var, res);\n+    set_scalar_evolution (block_before_loop (loop), var, res);\n \n   return res;\n }\n@@ -1879,7 +1884,8 @@ analyze_scalar_evolution (struct loop *loop, tree var)\n       fprintf (dump_file, \")\\n\");\n     }\n \n-  res = analyze_scalar_evolution_1 (loop, var, get_scalar_evolution (var));\n+  res = get_scalar_evolution (block_before_loop (loop), var);\n+  res = analyze_scalar_evolution_1 (loop, var, res);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \")\\n\");\n@@ -1926,14 +1932,17 @@ analyze_scalar_evolution_in_loop (struct loop *wrto_loop, struct loop *use_loop,\n     }\n }\n \n-/* Returns instantiated value for VERSION in CACHE.  */\n+/* Returns from CACHE the value for VERSION instantiated below\n+   INSTANTIATED_BELOW block.  */\n \n static tree\n-get_instantiated_value (htab_t cache, tree version)\n+get_instantiated_value (htab_t cache, basic_block instantiated_below,\n+\t\t\ttree version)\n {\n   struct scev_info_str *info, pattern;\n   \n   pattern.var = version;\n+  pattern.instantiated_below = instantiated_below;\n   info = (struct scev_info_str *) htab_find (cache, &pattern);\n \n   if (info)\n@@ -1942,10 +1951,12 @@ get_instantiated_value (htab_t cache, tree version)\n     return NULL_TREE;\n }\n \n-/* Sets instantiated value for VERSION to VAL in CACHE.  */\n+/* Sets in CACHE the value of VERSION instantiated below basic block\n+   INSTANTIATED_BELOW to VAL.  */\n \n static void\n-set_instantiated_value (htab_t cache, tree version, tree val)\n+set_instantiated_value (htab_t cache, basic_block instantiated_below,\n+\t\t\ttree version, tree val)\n {\n   struct scev_info_str *info, pattern;\n   PTR *slot;\n@@ -1954,7 +1965,7 @@ set_instantiated_value (htab_t cache, tree version, tree val)\n   slot = htab_find_slot (cache, &pattern, INSERT);\n \n   if (!*slot)\n-    *slot = new_scev_info_str (version);\n+    *slot = new_scev_info_str (instantiated_below, version);\n   info = (struct scev_info_str *) *slot;\n   info->chrec = val;\n }\n@@ -1989,7 +2000,7 @@ loop_closed_phi_def (tree var)\n   return NULL_TREE;\n }\n \n-/* Analyze all the parameters of the chrec, between INSTANTIATION_LOOP\n+/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.  \n \n    CHREC is the scalar evolution to instantiate.\n@@ -2004,7 +2015,7 @@ loop_closed_phi_def (tree var)\n    instantiated, and to stop if it exceeds some limit.  */\n   \n static tree\n-instantiate_scev_1 (struct loop *instantiation_loop,\n+instantiate_scev_1 (basic_block instantiate_below,\n \t\t    struct loop *evolution_loop, tree chrec,\n \t\t    bool fold_conversions, htab_t cache, int size_expr)\n {\n@@ -2030,7 +2041,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \t evolutions in outer loops), nothing to do.  */\n       if (!def_bb\n \t  || loop_depth (def_bb->loop_father) == 0\n-\t  || !flow_bb_inside_loop_p (instantiation_loop, def_bb))\n+\t  || dominated_by_p (CDI_DOMINATORS, instantiate_below, def_bb))\n \treturn chrec;\n \n       /* We cache the value of instantiated variable to avoid exponential\n@@ -2042,31 +2053,17 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \n \t | a_2 -> {0, +, 1, +, a_2}_1  */\n \n-      res = get_instantiated_value (cache, chrec);\n+      res = get_instantiated_value (cache, instantiate_below, chrec);\n       if (res)\n \treturn res;\n \n-      /* Store the convenient value for chrec in the structure.  If it\n-\t is defined outside of the loop, we may just leave it in symbolic\n-\t form, otherwise we need to admit that we do not know its behavior\n-\t inside the loop.  */\n-      res = !flow_bb_inside_loop_p (instantiation_loop, def_bb) \n-\t? chrec : chrec_dont_know;\n-      set_instantiated_value (cache, chrec, res);\n-\n-      /* To make things even more complicated, instantiate_scev_1\n-\t calls analyze_scalar_evolution that may call # of iterations\n-\t analysis that may in turn call instantiate_scev_1 again.\n-\t To prevent the infinite recursion, keep also the bitmap of\n-\t ssa names that are being instantiated globally.  */\n-      if (bitmap_bit_p (already_instantiated, SSA_NAME_VERSION (chrec)))\n-\treturn res;\n+      res = chrec_dont_know;\n+      set_instantiated_value (cache, instantiate_below, chrec, res);\n \n       def_loop = find_common_loop (evolution_loop, def_bb->loop_father);\n \n       /* If the analysis yields a parametric chrec, instantiate the\n \t result again.  */\n-      bitmap_set_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n       res = analyze_scalar_evolution (def_loop, chrec);\n \n       /* Don't instantiate loop-closed-ssa phi nodes.  */\n@@ -2085,23 +2082,21 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \t}\n \n       else if (res != chrec_dont_know)\n-\tres = instantiate_scev_1 (instantiation_loop, evolution_loop, res,\n+\tres = instantiate_scev_1 (instantiate_below, evolution_loop, res,\n \t\t\t\t  fold_conversions, cache, size_expr);\n \n-      bitmap_clear_bit (already_instantiated, SSA_NAME_VERSION (chrec));\n-\n       /* Store the correct value to the cache.  */\n-      set_instantiated_value (cache, chrec, res);\n+      set_instantiated_value (cache, instantiate_below, chrec, res);\n       return res;\n \n     case POLYNOMIAL_CHREC:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tCHREC_LEFT (chrec), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tCHREC_RIGHT (chrec), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op1 == chrec_dont_know)\n@@ -2117,13 +2112,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op1 == chrec_dont_know)\n@@ -2139,13 +2134,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n       return chrec;\n \n     case MINUS_EXPR:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0), fold_conversions, cache,\n \t\t\t\tsize_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n@@ -2161,13 +2156,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n       return chrec;\n \n     case MULT_EXPR:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n@@ -2183,7 +2178,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n       return chrec;\n \n     CASE_CONVERT:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n@@ -2221,19 +2216,19 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n   switch (TREE_CODE_LENGTH (TREE_CODE (chrec)))\n     {\n     case 3:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op2 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op2 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 2),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op2 == chrec_dont_know)\n@@ -2248,13 +2243,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n \t\t\t  TREE_TYPE (chrec), op0, op1, op2);\n \n     case 2:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n \treturn chrec_dont_know;\n \n-      op1 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op1 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 1),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op1 == chrec_dont_know)\n@@ -2266,7 +2261,7 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n       return fold_build2 (TREE_CODE (chrec), TREE_TYPE (chrec), op0, op1);\n \t    \n     case 1:\n-      op0 = instantiate_scev_1 (instantiation_loop, evolution_loop,\n+      op0 = instantiate_scev_1 (instantiate_below, evolution_loop,\n \t\t\t\tTREE_OPERAND (chrec, 0),\n \t\t\t\tfold_conversions, cache, size_expr);\n       if (op0 == chrec_dont_know)\n@@ -2287,12 +2282,13 @@ instantiate_scev_1 (struct loop *instantiation_loop,\n }\n \n /* Analyze all the parameters of the chrec that were left under a\n-   symbolic form.  INSTANTIATION_LOOP is the loop in which symbolic\n-   names have to be instantiated, and EVOLUTION_LOOP is the loop in\n-   which the evolution of scalars have to be analyzed.  */\n+   symbolic form.  INSTANTIATE_BELOW is the basic block that stops the\n+   recursive instantiation of parameters: a parameter is a variable\n+   that is defined in a basic block that dominates INSTANTIATE_BELOW or\n+   a function parameter.  */\n \n tree\n-instantiate_scev (struct loop *instantiation_loop, struct loop *evolution_loop,\n+instantiate_scev (basic_block instantiate_below, struct loop *evolution_loop,\n \t\t  tree chrec)\n {\n   tree res;\n@@ -2301,14 +2297,14 @@ instantiate_scev (struct loop *instantiation_loop, struct loop *evolution_loop,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"(instantiate_scev \\n\");\n-      fprintf (dump_file, \"  (instantiation_loop = %d)\\n\", instantiation_loop->num);\n+      fprintf (dump_file, \"  (instantiate_below = %d)\\n\", instantiate_below->index);\n       fprintf (dump_file, \"  (evolution_loop = %d)\\n\", evolution_loop->num);\n       fprintf (dump_file, \"  (chrec = \");\n       print_generic_expr (dump_file, chrec, 0);\n       fprintf (dump_file, \")\\n\");\n     }\n  \n-  res = instantiate_scev_1 (instantiation_loop, evolution_loop, chrec, false,\n+  res = instantiate_scev_1 (instantiate_below, evolution_loop, chrec, false,\n \t\t\t    cache, 0);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2332,7 +2328,8 @@ tree\n resolve_mixers (struct loop *loop, tree chrec)\n {\n   htab_t cache = htab_create (10, hash_scev_info, eq_scev_info, del_scev_info);\n-  tree ret = instantiate_scev_1 (loop, loop, chrec, true, cache, 0);\n+  tree ret = instantiate_scev_1 (block_before_loop (loop), loop, chrec, true,\n+\t\t\t\t cache, 0);\n   htab_delete (cache);\n   return ret;\n }\n@@ -2677,7 +2674,6 @@ scev_initialize (void)\n \t\t\t\t\t     del_scev_info,\n \t\t\t\t\t     ggc_calloc,\n \t\t\t\t\t     ggc_free);\n-  already_instantiated = BITMAP_ALLOC (NULL);\n   \n   initialize_scalar_evolutions_analyzer ();\n \n@@ -2791,7 +2787,6 @@ scev_finalize (void)\n   if (!scalar_evolution_info)\n     return;\n   htab_delete (scalar_evolution_info);\n-  BITMAP_FREE (already_instantiated);\n   scalar_evolution_info = NULL;\n }\n "}, {"sha": "7ba0708354f26961da321b845121ae33d71cf6d1", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a213b2190b451de691e9517e68dffd533f299bb9/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=a213b2190b451de691e9517e68dffd533f299bb9", "patch": "@@ -29,22 +29,32 @@ extern void scev_initialize (void);\n extern void scev_reset (void);\n extern void scev_finalize (void);\n extern tree analyze_scalar_evolution (struct loop *, tree);\n-extern tree instantiate_scev (struct loop *, struct loop *, tree);\n+extern tree instantiate_scev (basic_block, struct loop *, tree);\n extern tree resolve_mixers (struct loop *, tree);\n extern void gather_stats_on_scev_database (void);\n extern void scev_analysis (void);\n unsigned int scev_const_prop (void);\n \n extern bool simple_iv (struct loop *, gimple, tree, affine_iv *, bool);\n \n+/* Returns the basic block preceding LOOP or ENTRY_BLOCK_PTR when the\n+   loop is function's body.  */\n+\n+static inline basic_block\n+block_before_loop (loop_p loop)\n+{\n+  edge preheader = loop_preheader_edge (loop);\n+  return (preheader ? preheader->src : ENTRY_BLOCK_PTR);\n+}\n+\n /* Analyze all the parameters of the chrec that were left under a\n    symbolic form.  LOOP is the loop in which symbolic names have to\n    be analyzed and instantiated.  */\n \n static inline tree\n instantiate_parameters (struct loop *loop, tree chrec)\n {\n-  return instantiate_scev (loop, loop, chrec);\n+  return instantiate_scev (block_before_loop (loop), loop, chrec);\n }\n \n /* Returns the loop of the polynomial chrec CHREC.  */"}]}