{"sha": "435e56fb5289d72bfe12068aac72e76c02bb3b3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM1ZTU2ZmI1Mjg5ZDcyYmZlMTIwNjhhYWM3MmU3NmMwMmJiM2IzYw==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-07-10T17:44:21Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-07-10T17:44:21Z"}, "message": "Implement std::optional.\n\n\t* include/Makefile.am: Add optional to exported headers.\n\t* include/Makefile.in: Likewise.\n\t* include/std/optional: New.\n\t* testsuite/20_util/optional/typedefs.cc: Likewise.\n\t* testsuite/20_util/optional/relops/2.cc: Likewise.\n\t* testsuite/20_util/optional/relops/3.cc: Likewise.\n\t* testsuite/20_util/optional/relops/4.cc: Likewise.\n\t* testsuite/20_util/optional/relops/5.cc: Likewise.\n\t* testsuite/20_util/optional/relops/1.cc: Likewise.\n\t* testsuite/20_util/optional/relops/6.cc: Likewise.\n\t* testsuite/20_util/optional/nullopt.cc: Likewise.\n\t* testsuite/20_util/optional/in_place.cc: Likewise.\n\t* testsuite/20_util/optional/make_optional.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/2.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/3.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/4.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/5.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/1.cc: Likewise.\n\t* testsuite/20_util/optional/assignment/6.cc: Likewise.\n\t* testsuite/20_util/optional/cons/value_neg.cc: Likewise.\n\t* testsuite/20_util/optional/cons/default.cc: Likewise.\n\t* testsuite/20_util/optional/cons/move.cc: Likewise.\n\t* testsuite/20_util/optional/cons/value.cc: Likewise.\n\t* testsuite/20_util/optional/cons/copy.cc: Likewise.\n\t* testsuite/20_util/optional/requirements.cc: Likewise.\n\t* testsuite/20_util/optional/observers/2.cc: Likewise.\n\t* testsuite/20_util/optional/observers/3.cc: Likewise.\n\t* testsuite/20_util/optional/observers/4.cc: Likewise.\n\t* testsuite/20_util/optional/observers/5.cc: Likewise.\n\t* testsuite/20_util/optional/observers/1.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/2.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/3.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/4.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/5.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/1.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/relops/6.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/nullopt.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/in_place.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/make_optional.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/cons/default.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/cons/value.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/observers/2.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/observers/3.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/observers/4.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/observers/5.cc: Likewise.\n\t* testsuite/20_util/optional/constexpr/observers/1.cc: Likewise.\n\t* testsuite/20_util/optional/swap/1.cc: Likewise.\n\nFrom-SVN: r238197", "tree": {"sha": "64dd0d62997931dd97fe242886c372cdbbc81b5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64dd0d62997931dd97fe242886c372cdbbc81b5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/435e56fb5289d72bfe12068aac72e76c02bb3b3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435e56fb5289d72bfe12068aac72e76c02bb3b3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/435e56fb5289d72bfe12068aac72e76c02bb3b3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/435e56fb5289d72bfe12068aac72e76c02bb3b3c/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "290583564dcc1d4ecd8e417a15933bc6b302f068", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/290583564dcc1d4ecd8e417a15933bc6b302f068", "html_url": "https://github.com/Rust-GCC/gccrs/commit/290583564dcc1d4ecd8e417a15933bc6b302f068"}], "stats": {"total": 4686, "additions": 4686, "deletions": 0}, "files": [{"sha": "0aee6800828bc3c967cc8a44b9e2eb21609d7000", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -1,3 +1,54 @@\n+2016-07-10  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement std::optional.\n+\t* include/Makefile.am: Add optional to exported headers.\n+\t* include/Makefile.in: Likewise.\n+\t* include/std/optional: New.\n+\t* testsuite/20_util/optional/typedefs.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/2.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/3.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/4.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/5.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/1.cc: Likewise.\n+\t* testsuite/20_util/optional/relops/6.cc: Likewise.\n+\t* testsuite/20_util/optional/nullopt.cc: Likewise.\n+\t* testsuite/20_util/optional/in_place.cc: Likewise.\n+\t* testsuite/20_util/optional/make_optional.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/2.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/3.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/4.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/5.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/1.cc: Likewise.\n+\t* testsuite/20_util/optional/assignment/6.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/value_neg.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/default.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/move.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/value.cc: Likewise.\n+\t* testsuite/20_util/optional/cons/copy.cc: Likewise.\n+\t* testsuite/20_util/optional/requirements.cc: Likewise.\n+\t* testsuite/20_util/optional/observers/2.cc: Likewise.\n+\t* testsuite/20_util/optional/observers/3.cc: Likewise.\n+\t* testsuite/20_util/optional/observers/4.cc: Likewise.\n+\t* testsuite/20_util/optional/observers/5.cc: Likewise.\n+\t* testsuite/20_util/optional/observers/1.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/2.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/3.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/4.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/5.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/1.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/relops/6.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/nullopt.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/in_place.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/make_optional.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/cons/default.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/cons/value.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/observers/2.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/observers/3.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/observers/4.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/observers/5.cc: Likewise.\n+\t* testsuite/20_util/optional/constexpr/observers/1.cc: Likewise.\n+\t* testsuite/20_util/optional/swap/1.cc: Likewise.\n+\n 2016-07-08  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* testsuite/23_containers/vector/modifiers/insert/aliasing.cc: New."}, {"sha": "4bc33543a479d8a8125d3f0d602fdffbefd4a4c0", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -53,6 +53,7 @@ std_headers = \\\n \t${std_srcdir}/memory \\\n \t${std_srcdir}/mutex \\\n \t${std_srcdir}/numeric \\\n+\t${std_srcdir}/optional \\\n \t${std_srcdir}/ostream \\\n \t${std_srcdir}/queue \\\n \t${std_srcdir}/random \\"}, {"sha": "1f255a9bbc61d4076175d41c90e2bca77bc73e4b", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -343,6 +343,7 @@ std_headers = \\\n \t${std_srcdir}/memory \\\n \t${std_srcdir}/mutex \\\n \t${std_srcdir}/numeric \\\n+\t${std_srcdir}/optional \\\n \t${std_srcdir}/ostream \\\n \t${std_srcdir}/queue \\\n \t${std_srcdir}/random \\"}, {"sha": "e9a86a44aa2ad64e0dac4e3532f29c35eca9acff", "filename": "libstdc++-v3/include/std/optional", "status": "added", "additions": 983, "deletions": 0, "changes": 983, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Foptional?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,983 @@\n+// <optional> -*- C++ -*-\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/optional\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_OPTIONAL\n+#define _GLIBCXX_OPTIONAL 1\n+\n+#if __cplusplus <= 201402L\n+# include <bits/c++17_warning.h>\n+#else\n+\n+#include <utility>\n+#include <type_traits>\n+#include <stdexcept>\n+#include <new>\n+#include <initializer_list>\n+#include <bits/functexcept.h>\n+#include <bits/functional_hash.h>\n+#include <bits/enable_special_members.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   *  @addtogroup utilities\n+   *  @{\n+   */\n+\n+  // All subsequent [X.Y.n] references are against n3793.\n+\n+  // [X.Y.4]\n+  template<typename _Tp>\n+    class optional;\n+\n+  // [X.Y.5]\n+  /// Tag type for in-place construction.\n+  struct in_place_t { };\n+\n+  /// Tag for in-place construction.\n+  constexpr in_place_t in_place { };\n+\n+  // [X.Y.6]\n+  /// Tag type to disengage optional objects.\n+  struct nullopt_t\n+  {\n+    // Do not user-declare default constructor at all for\n+    // optional_value = {} syntax to work.\n+    // nullopt_t() = delete;\n+\n+    // Used for constructing nullopt.\n+    enum class _Construct { _Token };\n+\n+    // Must be constexpr for nullopt_t to be literal.\n+    explicit constexpr nullopt_t(_Construct) { }\n+  };\n+\n+  // [X.Y.6]\n+  /// Tag to disengage optional objects.\n+  constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };\n+\n+  // [X.Y.7]\n+  /**\n+   *  @brief Exception class thrown when a disengaged optional object is\n+   *  dereferenced.\n+   *  @ingroup exceptions\n+   */\n+  class bad_optional_access : public logic_error\n+  {\n+  public:\n+    bad_optional_access() : logic_error(\"bad optional access\") { }\n+\n+    // XXX This constructor is non-standard. Should not be inline\n+    explicit bad_optional_access(const char* __arg) : logic_error(__arg) { }\n+\n+    virtual ~bad_optional_access() noexcept = default;\n+  };\n+\n+  void\n+  __throw_bad_optional_access(const char*)\n+  __attribute__((__noreturn__));\n+\n+  // XXX Does not belong here.\n+  inline void\n+  __throw_bad_optional_access(const char* __s)\n+  { _GLIBCXX_THROW_OR_ABORT(bad_optional_access(__s)); }\n+\n+  template<typename _Tp, typename = void>\n+    struct _Has_addressof_mem : std::false_type { };\n+\n+  template<typename _Tp>\n+    struct _Has_addressof_mem<_Tp,\n+         __void_t<decltype( std::declval<const _Tp&>().operator&() )>\n+      >\n+    : std::true_type { };\n+\n+  template<typename _Tp, typename = void>\n+    struct _Has_addressof_free : std::false_type { };\n+\n+  template<typename _Tp>\n+    struct _Has_addressof_free<_Tp,\n+         __void_t<decltype( operator&(std::declval<const _Tp&>()) )>\n+      >\n+    : std::true_type { };\n+\n+  /**\n+    * @brief Trait that detects the presence of an overloaded unary operator&.\n+    *\n+    * Practically speaking this detects the presence of such an operator when\n+    * called on a const-qualified lvalue (i.e.\n+    * declval<_Tp * const&>().operator&()).\n+    */\n+  template<typename _Tp>\n+    struct _Has_addressof\n+    : std::__or_<_Has_addressof_mem<_Tp>, _Has_addressof_free<_Tp>>::type\n+    { };\n+\n+  /**\n+    * @brief An overload that attempts to take the address of an lvalue as a\n+    * constant expression. Falls back to __addressof in the presence of an\n+    * overloaded addressof operator (unary operator&), in which case the call\n+    * will not be a constant expression.\n+    */\n+  template<typename _Tp, enable_if_t<!_Has_addressof<_Tp>::value, int>...>\n+    constexpr _Tp* __constexpr_addressof(_Tp& __t)\n+    { return &__t; }\n+\n+  /**\n+    * @brief Fallback overload that defers to __addressof.\n+    */\n+  template<typename _Tp, enable_if_t<_Has_addressof<_Tp>::value, int>...>\n+    inline _Tp* __constexpr_addressof(_Tp& __t)\n+    { return std::__addressof(__t); }\n+\n+  /**\n+    * @brief Class template that holds the necessary state for @ref optional\n+    * and that has the responsibility for construction and the special members.\n+    *\n+    * Such a separate base class template is necessary in order to\n+    * conditionally enable the special members (e.g. copy/move constructors).\n+    * Note that this means that @ref _Optional_base implements the\n+    * functionality for copy and move assignment, but not for converting\n+    * assignment.\n+    *\n+    * @see optional, _Enable_special_members\n+    */\n+  template<typename _Tp, bool _ShouldProvideDestructor =\n+\t   !is_trivially_destructible<_Tp>::value>\n+    class _Optional_base\n+    {\n+    private:\n+      // Remove const to avoid prohibition of reusing object storage for\n+      // const-qualified types in [3.8/9]. This is strictly internal\n+      // and even optional itself is oblivious to it.\n+      using _Stored_type = remove_const_t<_Tp>;\n+\n+    public:\n+      // [X.Y.4.1] Constructors.\n+\n+      // Constructors for disengaged optionals.\n+      constexpr _Optional_base() noexcept\n+      : _M_empty{} { }\n+\n+      constexpr _Optional_base(nullopt_t) noexcept\n+      : _Optional_base{} { }\n+\n+      // Constructors for engaged optionals.\n+      constexpr _Optional_base(const _Tp& __t)\n+      : _M_payload(__t), _M_engaged(true) { }\n+\n+      constexpr _Optional_base(_Tp&& __t)\n+      : _M_payload(std::move(__t)), _M_engaged(true) { }\n+\n+      template<typename... _Args>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+\n+      template<typename _Up, typename... _Args,\n+               enable_if_t<is_constructible<_Tp,\n+                                            initializer_list<_Up>&,\n+                                            _Args&&...>::value,\n+                           int>...>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(__il, std::forward<_Args>(__args)...),\n+          _M_engaged(true) { }\n+\n+      // Copy and move constructors.\n+      _Optional_base(const _Optional_base& __other)\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(__other._M_get());\n+      }\n+\n+      _Optional_base(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>())\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(std::move(__other._M_get()));\n+      }\n+\n+      // [X.Y.4.3] (partly) Assignment.\n+      _Optional_base&\n+      operator=(const _Optional_base& __other)\n+      {\n+        if (this->_M_engaged && __other._M_engaged)\n+          this->_M_get() = __other._M_get();\n+        else\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(__other._M_get());\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\n+        return *this;\n+      }\n+\n+      _Optional_base&\n+      operator=(_Optional_base&& __other)\n+      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n+\t\t      is_nothrow_move_assignable<_Tp>>())\n+      {\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = std::move(__other._M_get());\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(std::move(__other._M_get()));\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      // [X.Y.4.2] Destructor.\n+      ~_Optional_base()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_payload.~_Stored_type();\n+      }\n+\n+      // The following functionality is also needed by optional, hence the\n+      // protected accessibility.\n+    protected:\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_engaged; }\n+\n+      // The _M_get operations have _M_engaged as a precondition.\n+      constexpr _Tp&\n+      _M_get() noexcept\n+      { return _M_payload; }\n+\n+      constexpr const _Tp&\n+      _M_get() const noexcept\n+      { return _M_payload; }\n+\n+      // The _M_construct operation has !_M_engaged as a precondition\n+      // while _M_destruct has _M_engaged as a precondition.\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new (std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      void\n+      _M_destruct()\n+      {\n+        this->_M_engaged = false;\n+        this->_M_payload.~_Stored_type();\n+      }\n+\n+      // _M_reset is a 'safe' operation with no precondition.\n+      void\n+      _M_reset()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_destruct();\n+      }\n+\n+    private:\n+      struct _Empty_byte { };\n+      union {\n+          _Empty_byte _M_empty;\n+          _Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+    };\n+\n+  /// Partial specialization that is exactly identical to the primary template\n+  /// save for not providing a destructor, to fulfill triviality requirements.\n+  template<typename _Tp>\n+    class _Optional_base<_Tp, false>\n+    {\n+    private:\n+      using _Stored_type = remove_const_t<_Tp>;\n+\n+    public:\n+      constexpr _Optional_base() noexcept\n+      : _M_empty{} { }\n+\n+      constexpr _Optional_base(nullopt_t) noexcept\n+      : _Optional_base{} { }\n+\n+      constexpr _Optional_base(const _Tp& __t)\n+      : _M_payload(__t), _M_engaged(true) { }\n+\n+      constexpr _Optional_base(_Tp&& __t)\n+      : _M_payload(std::move(__t)), _M_engaged(true) { }\n+\n+      template<typename... _Args>\n+        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)\n+        : _M_payload(std::forward<_Args>(__args)...), _M_engaged(true) { }\n+\n+      template<typename _Up, typename... _Args,\n+               enable_if_t<is_constructible<_Tp,\n+                                            initializer_list<_Up>&,\n+                                            _Args&&...>::value,\n+\t\t\t   int>...>\n+        constexpr explicit _Optional_base(in_place_t,\n+                                          initializer_list<_Up> __il,\n+                                          _Args&&... __args)\n+        : _M_payload(__il, std::forward<_Args>(__args)...),\n+          _M_engaged(true) { }\n+\n+      _Optional_base(const _Optional_base& __other)\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(__other._M_get());\n+      }\n+\n+      _Optional_base(_Optional_base&& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>())\n+      {\n+        if (__other._M_engaged)\n+          this->_M_construct(std::move(__other._M_get()));\n+      }\n+\n+      _Optional_base&\n+      operator=(const _Optional_base& __other)\n+      {\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = __other._M_get();\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(__other._M_get());\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      _Optional_base&\n+      operator=(_Optional_base&& __other)\n+      noexcept(__and_<is_nothrow_move_constructible<_Tp>,\n+\t\t      is_nothrow_move_assignable<_Tp>>())\n+      {\n+\tif (this->_M_engaged && __other._M_engaged)\n+\t  this->_M_get() = std::move(__other._M_get());\n+\telse\n+\t  {\n+\t    if (__other._M_engaged)\n+\t      this->_M_construct(std::move(__other._M_get()));\n+\t    else\n+\t      this->_M_reset();\n+\t  }\n+\treturn *this;\n+      }\n+\n+      // Sole difference\n+      // ~_Optional_base() noexcept = default;\n+\n+    protected:\n+      constexpr bool _M_is_engaged() const noexcept\n+      { return this->_M_engaged; }\n+\n+      _Tp&\n+      _M_get() noexcept\n+      { return _M_payload; }\n+\n+      constexpr const _Tp&\n+      _M_get() const noexcept\n+      { return _M_payload; }\n+\n+      template<typename... _Args>\n+        void\n+        _M_construct(_Args&&... __args)\n+        noexcept(is_nothrow_constructible<_Stored_type, _Args...>())\n+        {\n+          ::new (std::__addressof(this->_M_payload))\n+            _Stored_type(std::forward<_Args>(__args)...);\n+          this->_M_engaged = true;\n+        }\n+\n+      void\n+      _M_destruct()\n+      {\n+        this->_M_engaged = false;\n+        this->_M_payload.~_Stored_type();\n+      }\n+\n+      void\n+      _M_reset()\n+      {\n+        if (this->_M_engaged)\n+          this->_M_destruct();\n+      }\n+\n+    private:\n+      struct _Empty_byte { };\n+      union\n+      {\n+\t_Empty_byte _M_empty;\n+\t_Stored_type _M_payload;\n+      };\n+      bool _M_engaged = false;\n+    };\n+\n+  template<typename _Tp>\n+  class optional;\n+\n+  template<typename>\n+    struct __is_optional_impl : false_type\n+    { };\n+\n+  template<typename _Tp>\n+  struct __is_optional_impl<optional<_Tp>> : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_optional\n+    : public __is_optional_impl<std::remove_cv_t<std::remove_reference_t<_Tp>>>\n+    { };\n+\n+\n+  /**\n+    * @brief Class template for optional values.\n+    */\n+  template<typename _Tp>\n+    class optional\n+    : private _Optional_base<_Tp>,\n+      private _Enable_copy_move<\n+        // Copy constructor.\n+        is_copy_constructible<_Tp>::value,\n+        // Copy assignment.\n+        __and_<is_copy_constructible<_Tp>, is_copy_assignable<_Tp>>::value,\n+        // Move constructor.\n+        is_move_constructible<_Tp>::value,\n+        // Move assignment.\n+        __and_<is_move_constructible<_Tp>, is_move_assignable<_Tp>>::value,\n+        // Unique tag type.\n+        optional<_Tp>>\n+    {\n+      static_assert(__and_<__not_<is_same<remove_cv_t<_Tp>, nullopt_t>>,\n+\t\t\t   __not_<is_same<remove_cv_t<_Tp>, in_place_t>>,\n+\t\t\t   __not_<is_reference<_Tp>>>(),\n+                    \"Invalid instantiation of optional<T>\");\n+\n+    private:\n+      using _Base = _Optional_base<_Tp>;\n+\n+    public:\n+      using value_type = _Tp;\n+\n+      // _Optional_base has the responsibility for construction.\n+      using _Base::_Base;\n+\n+      constexpr optional() = default;\n+      // Converting constructors for engaged optionals.\n+      template <typename _Up,\n+                enable_if_t<__and_<\n+\t\t\t      __not_<is_same<_Tp, _Up>>,\n+\t\t\t      is_constructible<_Tp, _Up&&>,\n+\t\t\t      is_convertible<_Up&&, _Tp>\n+\t\t\t      >::value, bool> = true>\n+      constexpr optional(_Up&& __t)\n+        : _Base(_Tp(std::forward<_Up>(__t))) { }\n+\n+      template <typename _Up,\n+                enable_if_t<__and_<\n+\t\t\t    __not_<is_same<_Tp, _Up>>,\n+\t\t\t    is_constructible<_Tp, _Up&&>,\n+\t\t\t    __not_<is_convertible<_Up&&, _Tp>>\n+\t\t\t    >::value, bool> = false>\n+      explicit constexpr optional(_Up&& __t)\n+        : _Base(_Tp(std::forward<_Up>(__t))) { }\n+\n+      template <typename _Up,\n+                enable_if_t<__and_<\n+\t\t\t    __not_<is_same<_Tp, _Up>>,\n+\t\t\t    __not_<is_constructible<\n+\t\t\t      _Tp, const optional<_Up>&>>,\n+\t\t\t    __not_<is_convertible<\n+\t\t\t      const optional<_Up>&, _Tp>>,\n+\t\t\t    is_constructible<_Tp, const _Up&>,\n+\t\t\t    is_convertible<const _Up&, _Tp>\n+\t\t\t    >::value, bool> = true>\n+      constexpr optional(const optional<_Up>& __t)\n+        : _Base(__t ? optional<_Tp>(*__t) : optional<_Tp>()) { }\n+\n+      template <typename _Up,\n+                 enable_if_t<__and_<\n+\t\t\t       __not_<is_same<_Tp, _Up>>,\n+\t\t\t       __not_<is_constructible<\n+\t\t\t\t\t_Tp, const optional<_Up>&>>,\n+\t\t\t       __not_<is_convertible<\n+\t\t\t\t const optional<_Up>&, _Tp>>,\n+\t\t\t       is_constructible<_Tp, const _Up&>,\n+\t\t\t       __not_<is_convertible<const _Up&, _Tp>>\n+\t\t\t       >::value, bool> = false>\n+      explicit constexpr optional(const optional<_Up>& __t)\n+        : _Base(__t ? optional<_Tp>(*__t) : optional<_Tp>()) { }\n+\n+      template <typename _Up,\n+                enable_if_t<__and_<\n+\t\t\t      __not_<is_same<_Tp, _Up>>,\n+\t\t\t      __not_<is_constructible<\n+\t\t\t\t       _Tp, optional<_Up>&&>>,\n+\t\t\t      __not_<is_convertible<\n+\t\t\t\t       optional<_Up>&&, _Tp>>,\n+\t\t\t      is_constructible<_Tp, _Up&&>,\n+\t\t\t      is_convertible<_Up&&, _Tp>\n+\t\t\t      >::value, bool> = true>\n+      constexpr optional(optional<_Up>&& __t)\n+        : _Base(__t ? optional<_Tp>(std::move(*__t)) : optional<_Tp>()) { }\n+\n+      template <typename _Up,\n+                enable_if_t<__and_<\n+\t\t\t    __not_<is_same<_Tp, _Up>>,\n+\t\t\t    __not_<is_constructible<\n+\t\t\t\t     _Tp, optional<_Up>&&>>,\n+\t\t\t    __not_<is_convertible<\n+\t\t\t\t     optional<_Up>&&, _Tp>>,\n+\t\t\t    is_constructible<_Tp, _Up&&>,\n+\t\t\t    __not_<is_convertible<_Up&&, _Tp>>\n+\t\t\t    >::value, bool> = false>\n+      explicit constexpr optional(optional<_Up>&& __t)\n+        : _Base(__t ? optional<_Tp>(std::move(*__t)) : optional<_Tp>()) { }\n+\n+      // [X.Y.4.3] (partly) Assignment.\n+      optional&\n+      operator=(nullopt_t) noexcept\n+      {\n+        this->_M_reset();\n+        return *this;\n+      }\n+\n+      template<typename _Up,\n+               enable_if_t<__and_<\n+\t\t\t   __not_<is_same<_Up, nullopt_t>>,\n+\t\t\t   __not_<__is_optional<_Up>>>::value,\n+\t\t\t bool> = true>\n+        optional&\n+        operator=(_Up&& __u)\n+        {\n+          static_assert(__and_<is_constructible<_Tp, _Up>,\n+\t\t\t       is_assignable<_Tp&, _Up>>(),\n+                        \"Cannot assign to value type from argument\");\n+\n+          if (this->_M_is_engaged())\n+            this->_M_get() = std::forward<_Up>(__u);\n+          else\n+            this->_M_construct(std::forward<_Up>(__u));\n+\n+          return *this;\n+        }\n+\n+      template<typename _Up,\n+               enable_if_t<__and_<\n+\t\t __not_<is_same<_Tp, _Up>>>::value,\n+\t\t\t   bool> = true>\n+        optional&\n+        operator=(const optional<_Up>& __u)\n+        {\n+          static_assert(__and_<is_constructible<_Tp, _Up>,\n+\t\t\t       is_assignable<_Tp&, _Up>>(),\n+                        \"Cannot assign to value type from argument\");\n+\n+          if (__u)\n+            {\n+              if (this->_M_is_engaged())\n+                this->_M_get() = *__u;\n+              else\n+                this->_M_construct(*__u);\n+            }\n+          else\n+            {\n+              this->_M_reset();\n+            }\n+          return *this;\n+        }\n+\n+      template<typename _Up,\n+               enable_if_t<__and_<\n+\t\t __not_<is_same<_Tp, _Up>>>::value,\n+\t\t\t   bool> = true>\n+        optional&\n+        operator=(optional<_Up>&& __u)\n+        {\n+          static_assert(__and_<is_constructible<_Tp, _Up>,\n+\t\t\t       is_assignable<_Tp&, _Up>>(),\n+                        \"Cannot assign to value type from argument\");\n+\n+          if (__u)\n+            {\n+              if (this->_M_is_engaged())\n+                this->_M_get() = std::move(*__u);\n+              else\n+                this->_M_construct(std::move(*__u));\n+            }\n+          else\n+            {\n+              this->_M_reset();\n+            }\n+\n+          return *this;\n+        }\n+\n+      template<typename... _Args>\n+\tvoid\n+\templace(_Args&&... __args)\n+\t{\n+\t  static_assert(is_constructible<_Tp, _Args&&...>(),\n+\t\t\t\"Cannot emplace value type from arguments\");\n+\n+\t  this->_M_reset();\n+\t  this->_M_construct(std::forward<_Args>(__args)...);\n+\t}\n+\n+      template<typename _Up, typename... _Args>\n+        enable_if_t<is_constructible<_Tp, initializer_list<_Up>&,\n+\t\t\t\t     _Args&&...>::value>\n+\templace(initializer_list<_Up> __il, _Args&&... __args)\n+\t{\n+\t  this->_M_reset();\n+\t  this->_M_construct(__il, std::forward<_Args>(__args)...);\n+\t}\n+\n+      // [X.Y.4.2] Destructor is implicit, implemented in _Optional_base.\n+\n+      // [X.Y.4.4] Swap.\n+      void\n+      swap(optional& __other)\n+      noexcept(is_nothrow_move_constructible<_Tp>()\n+               && noexcept(swap(declval<_Tp&>(), declval<_Tp&>())))\n+      {\n+        using std::swap;\n+\n+        if (this->_M_is_engaged() && __other._M_is_engaged())\n+          swap(this->_M_get(), __other._M_get());\n+        else if (this->_M_is_engaged())\n+\t  {\n+\t    __other._M_construct(std::move(this->_M_get()));\n+\t    this->_M_destruct();\n+\t  }\n+        else if (__other._M_is_engaged())\n+\t  {\n+\t    this->_M_construct(std::move(__other._M_get()));\n+\t    __other._M_destruct();\n+\t  }\n+      }\n+\n+      // [X.Y.4.5] Observers.\n+      constexpr const _Tp*\n+      operator->() const\n+      { return __constexpr_addressof(this->_M_get()); }\n+\n+      _Tp*\n+      operator->()\n+      { return std::__addressof(this->_M_get()); }\n+\n+      constexpr const _Tp&\n+      operator*() const&\n+      { return this->_M_get(); }\n+\n+      constexpr _Tp&\n+      operator*()&\n+      { return this->_M_get(); }\n+\n+      constexpr _Tp&&\n+      operator*()&&\n+      { return std::move(this->_M_get()); }\n+\n+      constexpr const _Tp&&\n+      operator*() const&&\n+      { return std::move(this->_M_get()); }\n+\n+      constexpr explicit operator bool() const noexcept\n+      { return this->_M_is_engaged(); }\n+\n+      constexpr const _Tp&\n+      value() const&\n+      {\n+\treturn this->_M_is_engaged()\n+\t  ?  this->_M_get()\n+\t  : (__throw_bad_optional_access(\"Attempt to access value of a \"\n+\t\t                         \"disengaged optional object\"),\n+\t     this->_M_get());\n+      }\n+\n+      constexpr _Tp&\n+      value()&\n+      {\n+\treturn this->_M_is_engaged()\n+\t  ?  this->_M_get()\n+\t  : (__throw_bad_optional_access(\"Attempt to access value of a \"\n+\t\t                         \"disengaged optional object\"),\n+\t     this->_M_get());\n+      }\n+\n+      constexpr _Tp&&\n+      value()&&\n+      {\n+\treturn this->_M_is_engaged()\n+\t  ?  std::move(this->_M_get())\n+\t  : (__throw_bad_optional_access(\"Attempt to access value of a \"\n+\t\t                         \"disengaged optional object\"),\n+\t     std::move(this->_M_get()));\n+      }\n+\n+      constexpr const _Tp&&\n+      value() const&&\n+      {\n+\treturn this->_M_is_engaged()\n+\t  ?  std::move(this->_M_get())\n+\t  : (__throw_bad_optional_access(\"Attempt to access value of a \"\n+\t\t                         \"disengaged optional object\"),\n+\t     std::move(this->_M_get()));\n+      }\n+\n+      template<typename _Up>\n+\tconstexpr _Tp\n+\tvalue_or(_Up&& __u) const&\n+\t{\n+\t  static_assert(__and_<is_copy_constructible<_Tp>,\n+\t\t\t       is_convertible<_Up&&, _Tp>>(),\n+\t\t\t\"Cannot return value\");\n+\n+\t  return this->_M_is_engaged()\n+\t    ? this->_M_get()\n+\t    : static_cast<_Tp>(std::forward<_Up>(__u));\n+\t}\n+\n+      template<typename _Up>\n+\t_Tp\n+\tvalue_or(_Up&& __u) &&\n+\t{\n+\t  static_assert(__and_<is_move_constructible<_Tp>,\n+\t\t\t       is_convertible<_Up&&, _Tp>>(),\n+\t\t\t\"Cannot return value\" );\n+\n+\t  return this->_M_is_engaged()\n+\t    ? std::move(this->_M_get())\n+\t    : static_cast<_Tp>(std::forward<_Up>(__u));\n+\t}\n+    };\n+\n+  // [X.Y.8] Comparisons between optional values.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    {\n+      return static_cast<bool>(__lhs) == static_cast<bool>(__rhs)\n+\t     && (!__lhs || *__lhs == *__rhs);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__lhs == __rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    {\n+      return static_cast<bool>(__rhs) && (!__lhs || *__lhs < *__rhs);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs < __lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__rhs < __lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& __lhs, const optional<_Tp>& __rhs)\n+    { return !(__lhs < __rhs); }\n+\n+  // [X.Y.9] Comparisons with nullopt.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return !__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return !__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return static_cast<bool>(__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return static_cast<bool>(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept\n+    { return false; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return static_cast<bool>(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return static_cast<bool>(__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept\n+    { return false; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, nullopt_t) noexcept\n+    { return !__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(nullopt_t, const optional<_Tp>& /* __rhs */) noexcept\n+    { return true; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& /* __lhs */, nullopt_t) noexcept\n+    { return true; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(nullopt_t, const optional<_Tp>& __rhs) noexcept\n+    { return !__rhs; }\n+\n+  // [X.Y.10] Comparisons with value type.\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && *__lhs == __rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator==(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && __lhs == *__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const optional<_Tp>& __lhs, _Tp const& __rhs)\n+    { return !__lhs || !(*__lhs == __rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator!=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || !(__lhs == *__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return !__lhs || *__lhs < __rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && __lhs < *__rhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && __rhs < *__lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || *__rhs < __lhs; }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return !__lhs || !(__rhs < *__lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator<=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return __rhs && !(*__rhs < __lhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const optional<_Tp>& __lhs, const _Tp& __rhs)\n+    { return __lhs && !(*__lhs < __rhs); }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    operator>=(const _Tp& __lhs, const optional<_Tp>& __rhs)\n+    { return !__rhs || !(__lhs < *__rhs); }\n+\n+  // [X.Y.11]\n+  template<typename _Tp>\n+    inline void\n+    swap(optional<_Tp>& __lhs, optional<_Tp>& __rhs)\n+    noexcept(noexcept(__lhs.swap(__rhs)))\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _Tp>\n+    constexpr optional<decay_t<_Tp>>\n+    make_optional(_Tp&& __t)\n+    { return optional<decay_t<_Tp>> { std::forward<_Tp>(__t) }; }\n+\n+  // [X.Y.12]\n+  template<typename _Tp>\n+    struct hash<optional<_Tp>>\n+    {\n+      using result_type = size_t;\n+      using argument_type = optional<_Tp>;\n+\n+      size_t\n+      operator()(const optional<_Tp>& __t) const\n+      noexcept(noexcept(hash<_Tp> {}(*__t)))\n+      {\n+        // We pick an arbitrary hash for disengaged optionals which hopefully\n+        // usual values of _Tp won't typically hash to.\n+        constexpr size_t __magic_disengaged_hash = static_cast<size_t>(-3333);\n+        return __t ? hash<_Tp> {}(*__t) : __magic_disengaged_hash;\n+      }\n+    };\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++17\n+\n+#endif // _GLIBCXX_OPTIONAL"}, {"sha": "25c62418b44f561a356a02d70c901cf229900f66", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/1.cc", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,195 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return O { std::in_place, s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check copy/move assignment for disengaged optional\n+\n+  // From disengaged optional\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p;\n+    o = p;\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p;\n+    o = std::move(p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  // From engaged optional\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_copy_assignment);\n+    o = p;\n+    VERIFY( o && o->state == S::throwing_copy_assignment );\n+    VERIFY( p && p->state == S::throwing_copy_assignment );\n+  }\n+\n+  {\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_move_assignment);\n+    o = std::move(p);\n+    VERIFY( o && o->state == S::throwing_move_assignment );\n+    VERIFY( p && p->state == S::moved_from );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_copy);\n+\n+    try\n+    {\n+      o = p;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !o );\n+    VERIFY( p && p->state == S::throwing_copy );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    VERIFY( !o );\n+    O p = make(S::throwing_move);\n+\n+    try\n+    {\n+      o = std::move(p);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !o );\n+    VERIFY( p && p->state == S::moved_from );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "d9d6ffab51fe9b21d84aeab634e1bff139789747", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/2.cc", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F2.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,193 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return O { std::in_place, s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check copy/move assignment for engaged optional\n+\n+  // From disengaged optional\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p;\n+    o = p;\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p;\n+    o = std::move(p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  // From engaged optional\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_copy);\n+    o = p;\n+    VERIFY( o && o->state == S::throwing_copy);\n+    VERIFY( p && p->state == S::throwing_copy);\n+  }\n+\n+  {\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_move);\n+    o = std::move(p);\n+    VERIFY( o && o->state == S::throwing_move);\n+    VERIFY( p && p->state == S::moved_from);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_copy_assignment);\n+\n+    try\n+    {\n+      o = p;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw);\n+    VERIFY( p && p->state == S::throwing_copy_assignment);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make(S::zero);\n+    VERIFY( o );\n+    O p = make(S::throwing_move_assignment);\n+\n+    try\n+    {\n+      o = std::move(p);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw);\n+    VERIFY( p && p->state == S::moved_from);\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "ce038b37cac0d2feb05ddf0519eb688ed930d63e", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/3.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F3.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,158 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return value_type { s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check value assignment for disengaged optional\n+\n+  {\n+    O o;\n+    value_type v = make(S::throwing_copy_assignment);\n+    o = v;\n+    VERIFY( o && o->state == S::throwing_copy_assignment );\n+  }\n+\n+  {\n+    O o;\n+    value_type v = make(S::throwing_move_assignment);\n+    o = std::move(v);\n+    VERIFY( o && o->state == S::throwing_move_assignment );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    value_type v = make(S::throwing_copy);\n+\n+    try\n+    {\n+      o = v;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o;\n+    value_type v = make(S::throwing_move);\n+\n+    try\n+    {\n+      o = std::move(v);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "7b9723818313ded4d9d897332de1a2e4c419fa08", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/4.cc", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F4.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,158 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  enum state_type\n+  {\n+    zero,\n+    moved_from,\n+    throwing_construction,\n+    throwing_copy,\n+    throwing_copy_assignment,\n+    throwing_move,\n+    throwing_move_assignment,\n+    threw,\n+  };\n+\n+  value_type() = default;\n+\n+  explicit value_type(state_type state_)\n+  : state(state_)\n+  {\n+    throw_if(throwing_construction);\n+  }\n+\n+  value_type(value_type const& other)\n+  : state(other.state)\n+  {\n+    throw_if(throwing_copy);\n+  }\n+\n+  value_type&\n+  operator=(value_type const& other)\n+  {\n+    state = other.state;\n+    throw_if(throwing_copy_assignment);\n+    return *this;\n+  }\n+\n+  value_type(value_type&& other)\n+  : state(other.state)\n+  {\n+    other.state = moved_from;\n+    throw_if(throwing_move);\n+  }\n+\n+  value_type&\n+  operator=(value_type&& other)\n+  {\n+    state = other.state;\n+    other.state = moved_from;\n+    throw_if(throwing_move_assignment);\n+    return *this;\n+  }\n+\n+  void throw_if(state_type match)\n+  {\n+    if(state == match)\n+    {\n+      state = threw;\n+      throw exception {};\n+    }\n+  }\n+\n+  state_type state = zero;\n+};\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+  using S = value_type::state_type;\n+  auto const make = [](S s = S::zero) { return value_type { s }; };\n+\n+  enum outcome_type { nothrow, caught, bad_catch };\n+\n+  // Check value assignment for engaged optional\n+\n+  {\n+    O o = make();\n+    value_type v = make(S::throwing_copy);\n+    o = v;\n+    VERIFY( o && o->state == S::throwing_copy);\n+  }\n+\n+  {\n+    O o = make();\n+    value_type v = make(S::throwing_move);\n+    o = std::move(v);\n+    VERIFY( o && o->state == S::throwing_move);\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make();\n+    value_type v = make(S::throwing_copy_assignment);\n+\n+    try\n+    {\n+      o = v;\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw );\n+  }\n+\n+  {\n+    outcome_type outcome {};\n+    O o = make();\n+    value_type v = make(S::throwing_move_assignment);\n+\n+    try\n+    {\n+      o = std::move(v);\n+    }\n+    catch(exception const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( o && o->state == S::threw );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "e450a4613994f7e7b591afbe2936c2362c95320b", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/5.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F5.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter { };\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+\n+  // Check std::nullopt_t and 'default' (= {}) assignment\n+\n+  {\n+    O o;\n+    o = std::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o { std::in_place };\n+    o = std::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o;\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    O o { std::in_place };\n+    o = {};\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "78e975bbe32a2ee742d816d8ce36c4edfd6c225f", "filename": "libstdc++-v3/testsuite/20_util/optional/assignment/6.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fassignment%2F6.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,83 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+struct value_type : private mixin_counter\n+{\n+  value_type() = default;\n+  value_type(int) : state(1) { }\n+  value_type(std::initializer_list<char>, const char*) : state(2) { }\n+  int state = 0;\n+};\n+\n+int main()\n+{\n+  using O = std::optional<value_type>;\n+\n+  // Check emplace\n+\n+  {\n+    O o;\n+    o.emplace();\n+    VERIFY( o && o->state == 0 );\n+  }\n+  {\n+    O o { std::in_place, 0 };\n+    o.emplace();\n+    VERIFY( o && o->state == 0 );\n+  }\n+\n+  {\n+    O o;\n+    o.emplace(0);\n+    VERIFY( o && o->state == 1 );\n+  }\n+  {\n+    O o { std::in_place };\n+    o.emplace(0);\n+    VERIFY( o && o->state == 1 );\n+  }\n+\n+  {\n+    O o;\n+    o.emplace({ 'a' }, \"\");\n+    VERIFY( o && o->state == 2 );\n+  }\n+  {\n+    O o { std::in_place };\n+    o.emplace({ 'a' }, \"\");\n+    VERIFY( o && o->state == 2 );\n+  }\n+\n+  static_assert( !std::is_constructible<O, std::initializer_list<int>, int>(), \"\" );\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "58f91768df4f5ff602bf7b81a01b3b7eb2b7c0a5", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/copy.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fcopy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fcopy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fcopy.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,126 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_copy\n+{\n+  throwing_copy() = default;\n+  throwing_copy(throwing_copy const&) { throw exception {}; }\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::optional<long> o;\n+    auto copy = o;\n+    VERIFY( !copy );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    const long val = 0x1234ABCD;\n+    std::optional<long> o { std::in_place, val};\n+    auto copy = o;\n+    VERIFY( copy );\n+    VERIFY( *copy == val );\n+    VERIFY( o && o == val );\n+  }\n+\n+  {\n+    std::optional<tracker> o;\n+    auto copy = o;\n+    VERIFY( !copy );\n+    VERIFY( tracker::count == 0 );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<tracker> o { std::in_place, 333 };\n+    auto copy = o;\n+    VERIFY( copy );\n+    VERIFY( copy->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( o && o->value == 333 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    std::optional<throwing_copy> o;\n+\n+    try\n+    {\n+      auto copy = o;\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    std::optional<throwing_copy> o { std::in_place };\n+\n+    try\n+    {\n+      auto copy = o;\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "ebde86b807dcb86d668f7c9e054861810a7ed44c", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/default.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fdefault.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,60 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker() { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const&) { ++count; }\n+  tracker(tracker&&) { ++count; }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::optional<tracker> o;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<tracker> o {};\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<tracker> o = {};\n+    VERIFY( !o );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "54fd8c958e5f0126f9613ec8450fb6a4ab78bb71", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/move.cc", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fmove.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fmove.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fmove.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,126 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_move\n+{\n+  throwing_move() = default;\n+  throwing_move(throwing_move const&) { throw exception {}; }\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    std::optional<long> o;\n+    auto moved_to = std::move(o);\n+    VERIFY( !moved_to );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    const long val = 0x1234ABCD;\n+    std::optional<long> o { std::in_place, val};\n+    auto moved_to = std::move(o);\n+    VERIFY( moved_to );\n+    VERIFY( *moved_to == val );\n+    VERIFY( o && *o == val );\n+  }\n+\n+  {\n+    std::optional<tracker> o;\n+    auto moved_to = std::move(o);\n+    VERIFY( !moved_to );\n+    VERIFY( tracker::count == 0 );\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<tracker> o { std::in_place, 333 };\n+    auto moved_to = std::move(o);\n+    VERIFY( moved_to );\n+    VERIFY( moved_to->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( o && o->value == -1 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    std::optional<throwing_move> o;\n+\n+    try\n+    {\n+      auto moved_to = std::move(o);\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    std::optional<throwing_move> o { std::in_place };\n+\n+    try\n+    {\n+      auto moved_to = std::move(o);\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  VERIFY( tracker::count == 0 );\n+}"}, {"sha": "13a6e9ca4dd6a1d1b89ef3b7a1f6e88a7fb30411", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value.cc", "status": "added", "additions": 258, "deletions": 0, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,258 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <vector>\n+#include <string>\n+\n+struct tracker\n+{\n+  tracker(int value) : value(value) { ++count; }\n+  ~tracker() { --count; }\n+\n+  tracker(tracker const& other) : value(other.value) { ++count; }\n+  tracker(tracker&& other) : value(other.value)\n+  {\n+    other.value = -1;\n+    ++count;\n+  }\n+\n+  tracker& operator=(tracker const&) = default;\n+  tracker& operator=(tracker&&) = default;\n+\n+  int value;\n+\n+  static int count;\n+};\n+\n+int tracker::count = 0;\n+\n+struct exception { };\n+\n+struct throwing_construction\n+{\n+  explicit throwing_construction(bool propagate) : propagate(propagate) { }\n+\n+  throwing_construction(throwing_construction const& other)\n+  : propagate(other.propagate)\n+  {\n+    if(propagate)\n+      throw exception {};\n+  }\n+\n+  bool propagate;\n+};\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o { i };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o = i;\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o = { i };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o { std::move(i) };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o = std::move(i);\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    auto i = 0x1234ABCD;\n+    std::optional<long> o = { std::move(i) };\n+    VERIFY( o );\n+    VERIFY( *o == 0x1234ABCD );\n+    VERIFY( i == 0x1234ABCD );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o { v };\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o = v;\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o { v };\n+    VERIFY( !v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o { std::move(v) };\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o = std::move(v);\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    std::vector<int> v = { 0, 1, 2, 3, 4, 5 };\n+    std::optional<std::vector<int>> o { std::move(v) };\n+    VERIFY( v.empty() );\n+    VERIFY( o->size() == 6 );\n+  }\n+\n+  {\n+    tracker t { 333 };\n+    std::optional<tracker> o = t;\n+    VERIFY( o->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( t.value == 333 );\n+  }\n+\n+  {\n+    tracker t { 333 };\n+    std::optional<tracker> o = std::move(t);\n+    VERIFY( o->value == 333 );\n+    VERIFY( tracker::count == 2 );\n+    VERIFY( t.value == -1 );\n+  }\n+\n+  enum outcome { nothrow, caught, bad_catch };\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { false };\n+\n+    try\n+    {\n+      std::optional<throwing_construction> o { t };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { true };\n+\n+    try\n+    {\n+      std::optional<throwing_construction> o { t };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { false };\n+\n+    try\n+    {\n+      std::optional<throwing_construction> o { std::move(t) };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == nothrow );\n+  }\n+\n+  {\n+    outcome result = nothrow;\n+    throwing_construction t { true };\n+\n+    try\n+    {\n+      std::optional<throwing_construction> o { std::move(t) };\n+    }\n+    catch(exception const&)\n+    { result = caught; }\n+    catch(...)\n+    { result = bad_catch; }\n+\n+    VERIFY( result == caught );\n+  }\n+\n+  {\n+    std::optional<std::string> os = \"foo\";\n+    struct X\n+    {\n+      explicit X(int) {}\n+      X& operator=(int) {return *this;}\n+    };\n+    std::optional<X> ox{42};\n+    std::optional<int> oi{42};\n+    std::optional<X> ox2{oi};\n+    std::optional<std::string> os2;\n+    os2 = \"foo\";\n+    std::optional<X> ox3;\n+    ox3 = 42;\n+    std::optional<X> ox4;\n+    ox4 = oi;\n+  }\n+}"}, {"sha": "4bf5dcc4ec28434837bbce822279bc4a50b25da0", "filename": "libstdc++-v3/testsuite/20_util/optional/cons/value_neg.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fcons%2Fvalue_neg.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <string>\n+#include <memory>\n+\n+int main()\n+{\n+  {\n+    struct X\n+    {\n+      explicit X(int) {}\n+    };\n+    std::optional<X> ox{42};\n+    std::optional<X> ox2 = 42; // { dg-error \"conversion\" }\n+    std::optional<std::unique_ptr<int>> oup{new int};\n+    std::optional<std::unique_ptr<int>> oup2 = new int;  // { dg-error \"conversion\" }\n+  }\n+}"}, {"sha": "ae523dfbc169e7ebcd90827d3b6b96b39186e999", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/cons/default.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fdefault.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,42 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    constexpr std::optional<int> o;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<int> o {};\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<int> o = {};\n+    static_assert( !o, \"\" );\n+  }\n+}"}, {"sha": "de7744d3dc8dd796838908b09a3e567cfc034e3e", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/cons/value.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fcons%2Fvalue.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.4.1] Constructors\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o { i };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o = i;\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o = { i };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o { std::move(i) };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o = std::move(i);\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+\n+  {\n+    constexpr long i = 0x1234ABCD;\n+    constexpr std::optional<long> o = { std::move(i) };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 0x1234ABCD, \"\" );\n+  }\n+}"}, {"sha": "cd75275aaff5531c05e63d79e310e99d12127191", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/in_place.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fin_place.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fin_place.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fin_place.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.5] In-place construction\n+  static_assert( std::is_same<decltype(std::in_place), const std::in_place_t>(), \"\" );\n+  static_assert( std::is_empty<std::in_place_t>(), \"\" );\n+\n+  {\n+    constexpr std::optional<int> o { std::in_place };\n+    static_assert( o, \"\" );\n+    static_assert( *o == int {}, \"\" );\n+\n+    static_assert( !std::is_convertible<std::in_place_t, std::optional<int>>(), \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<int> o { std::in_place, 42 };\n+    static_assert( o, \"\" );\n+    static_assert( *o == 42, \"\" );\n+  }\n+}"}, {"sha": "44ee654a07bbf1fec3c2a9021ad0ab9a0b65d690", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/make_optional.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fmake_optional.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fmake_optional.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fmake_optional.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,30 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  constexpr int i = 42;\n+  constexpr auto o = std::make_optional(i);\n+  static_assert( std::is_same<decltype(o), const std::optional<int>>(), \"\" );\n+  static_assert( o && *o == 42, \"\" );\n+  static_assert( &*o != &i, \"\" );\n+}"}, {"sha": "61fddefa5a41673a9c291023b03900ee1349a346", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/nullopt.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fnullopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fnullopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fnullopt.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.6] Disengaged state indicator\n+  static_assert( std::is_same<decltype(std::nullopt), const std::nullopt_t>(), \"\" );\n+  static_assert( std::is_empty<std::nullopt_t>(), \"\" );\n+  static_assert( std::is_literal_type<std::nullopt_t>(), \"\" );\n+  static_assert( !std::is_default_constructible<std::nullopt_t>(), \"\" );\n+\n+  {\n+    constexpr std::optional<int> o = std::nullopt;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<int> o = { std::nullopt };\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<int> o { std::nullopt };\n+    static_assert( !o, \"\" );\n+  }\n+}"}, {"sha": "6c06f089ec2db6243e3557fbccb150a7da4c58ad", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/observers/1.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::optional<value_type> o { value_type { 51 } };\n+  static_assert( (*o).i == 51, \"\" );\n+}"}, {"sha": "11363af32cbe8e68e5753f5b1865a8e952c5ecc7", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/observers/2.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F2.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct value_type\n+{\n+  int i;\n+\n+  void* operator&() { return nullptr; } // N.B. non-const\n+};\n+\n+int main()\n+{\n+  constexpr std::optional<value_type> o { value_type { 51 } };\n+  static_assert( o->i == 51, \"\" );\n+  static_assert( o->i == (*o).i, \"\" );\n+  static_assert( &o->i == &(*o).i, \"\" );\n+}"}, {"sha": "118fea9208792add9709549214e1fcfbadf2c51d", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/observers/3.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F3.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++17\" }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::optional<value_type> o { value_type { 51 } };\n+  static_assert( o.value().i == 51, \"\" );\n+  static_assert( o.value().i == (*o).i, \"\" );\n+  static_assert( &o.value().i == &(*o).i, \"\" );\n+}"}, {"sha": "3e6436c6db16cbf53d9afea88cc4569e989b17af", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F4.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  constexpr std::optional<value_type> o { value_type { 51 } };\n+  constexpr value_type fallback { 3 };\n+  static_assert( o.value_or(fallback).i == 51, \"\" );\n+  static_assert( o.value_or(fallback).i == (*o).i, \"\" );\n+}"}, {"sha": "15ac84b25ee1e63f461e57f6a7734503680cf84e", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/observers/5.cc", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Fobservers%2F5.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,39 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    constexpr std::optional<value_type> o = std::nullopt;\n+    static_assert( !o, \"\" );\n+  }\n+\n+  {\n+    constexpr std::optional<value_type> o { value_type { 51 } };\n+    static_assert( o, \"\" );\n+  }\n+}"}, {"sha": "c948e17012537b7000f5972115d907026635b3f8", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/1.cc", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,99 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  {\n+    constexpr O o, p;\n+    static_assert( o == p, \"\" );\n+    static_assert( !(o != p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p;\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o == p), \"\" );\n+    static_assert( o != p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o == p, \"\" );\n+    static_assert( !(o != p), \"\" );\n+  }\n+}"}, {"sha": "9aa9273255ba38bc39e7099ac5a09247a389f457", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/2.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F2.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,111 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  {\n+    constexpr O o, p;\n+    static_assert( !(o < p), \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p;\n+    static_assert( !(o < p), \"\" );\n+    static_assert( o > p, \"\" );\n+    static_assert( !(o <= p), \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o < p, \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( !(o >= p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( o < p, \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( !(o >= p), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o < p), \"\" );\n+    static_assert( o > p, \"\" );\n+    static_assert( !(o <= p), \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o < p), \"\" );\n+    static_assert( !(o > p), \"\" );\n+    static_assert( o <= p, \"\" );\n+    static_assert( o >= p, \"\" );\n+  }\n+}"}, {"sha": "eb34f796399c060bc736629b027a570b238a93b8", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/3.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F3.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,89 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  constexpr value_type reference { 42, \"forty-two\" };\n+\n+  {\n+    constexpr O o;\n+    static_assert( !(o == reference), \"\" );\n+    static_assert( !(reference == o), \"\" );\n+    static_assert( o != reference, \"\" );\n+    static_assert( reference != o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } };\n+    static_assert( !(o == reference), \"\" );\n+    static_assert( !(reference == o), \"\" );\n+    static_assert( o != reference, \"\" );\n+    static_assert( reference != o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } };\n+    static_assert( o == reference, \"\" );\n+    static_assert( reference == o, \"\" );\n+    static_assert( !(o != reference), \"\" );\n+    static_assert( !(reference != o), \"\" );\n+  }\n+}"}, {"sha": "15130d4efbda55b800fa25e882ac230719c2d6ad", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/4.cc", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F4.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,101 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  constexpr value_type reference { 42, \"forty-two\" };\n+\n+  {\n+    constexpr O o;\n+    static_assert( o < reference, \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( reference > o, \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( !(reference <= o), \"\" );\n+    static_assert( !(o >= reference), \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 11, \"eleventy\" } };\n+    static_assert( o < reference, \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( reference > o, \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( !(reference <= o), \"\" );\n+    static_assert( !(o >= reference), \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { value_type { 42, \"forty-two\" } };\n+    static_assert( !(o < reference), \"\" );\n+    static_assert( !(reference < o), \"\" );\n+    static_assert( !(o > reference), \"\" );\n+    static_assert( !(reference > o), \"\" );\n+    static_assert( o <= reference, \"\" );\n+    static_assert( reference <= o, \"\" );\n+    static_assert( o >= reference, \"\" );\n+    static_assert( reference >= o, \"\" );\n+  }\n+}"}, {"sha": "99a208208bccb5b5cd886ab20d35583a570d5aa1", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/5.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F5.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+  using std::nullopt;\n+\n+  {\n+    constexpr O o;\n+    static_assert( o == nullopt, \"\" );\n+    static_assert( nullopt == o, \"\" );\n+    static_assert( !(o != nullopt), \"\" );\n+    static_assert( !(nullopt != o), \"\" );\n+  }\n+\n+  {\n+    constexpr O o { std::in_place };\n+    static_assert( !(o == nullopt), \"\" );\n+    static_assert( !(nullopt == o), \"\" );\n+    static_assert( o != nullopt, \"\" );\n+    static_assert( nullopt != o, \"\" );\n+  }\n+}"}, {"sha": "7337287852bcec53b160e4d47ec413f042df7a70", "filename": "libstdc++-v3/testsuite/20_util/optional/constexpr/relops/6.cc", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fconstexpr%2Frelops%2F6.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,88 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    const char* s;\n+  };\n+\n+  constexpr bool\n+  strcmp(const char* lhs, const char* rhs)\n+  {\n+    return *lhs == *rhs && (!*lhs || strcmp(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  strrel(const char* lhs, const char* rhs)\n+  {\n+    return (*rhs && (!*lhs || (*lhs < *rhs)))\n+      || ((*lhs && *rhs && !(*rhs < *lhs)) && strrel(lhs + 1, rhs + 1));\n+  }\n+\n+  constexpr bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i == rhs.i) && strcmp(lhs.s, rhs.s); }\n+\n+  constexpr bool\n+  operator!=(value_type const& lhs, value_type const& rhs)\n+  { return !(lhs == rhs); }\n+\n+  constexpr bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return (lhs.i < rhs.i) || (!(rhs.i < lhs.i) && strrel(lhs.s, rhs.s)); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+  using std::nullopt;\n+\n+  {\n+    constexpr O o;\n+    static_assert( !(o < nullopt), \"\" );\n+    static_assert( !(nullopt < o), \"\" );\n+    static_assert( !(o > nullopt), \"\" );\n+    static_assert( !(nullopt > o), \"\" );\n+    static_assert( o <= nullopt, \"\" );\n+    static_assert( nullopt <= o, \"\" );\n+    static_assert( o >= nullopt, \"\" );\n+    static_assert( nullopt >= o, \"\" );\n+  }\n+\n+  {\n+    constexpr O o { std::in_place };\n+    static_assert( !(o < nullopt), \"\" );\n+    static_assert( nullopt < o, \"\" );\n+    static_assert( o > nullopt, \"\" );\n+    static_assert( !(nullopt > o), \"\" );\n+    static_assert( !(o <= nullopt), \"\" );\n+    static_assert( nullopt <= o, \"\" );\n+    static_assert( o >= nullopt, \"\" );\n+    static_assert( !(nullopt >= o), \"\" );\n+  }\n+}"}, {"sha": "ef8c744f1dccbbbc26e5087bbd942b364be80466", "filename": "libstdc++-v3/testsuite/20_util/optional/in_place.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fin_place.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fin_place.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fin_place.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <vector>\n+\n+int main()\n+{\n+  // [20.5.5] In-place construction\n+  static_assert( std::is_same<decltype(std::in_place), const std::in_place_t>(), \"\" );\n+  static_assert( std::is_empty<std::in_place_t>(), \"\" );\n+\n+  {\n+    std::optional<int> o { std::in_place };\n+    VERIFY( o );\n+    VERIFY( *o == int() );\n+\n+    static_assert( !std::is_convertible<std::in_place_t, std::optional<int>>(), \"\" );\n+  }\n+\n+  {\n+    std::optional<int> o { std::in_place, 42 };\n+    VERIFY( o );\n+    VERIFY( *o == 42 );\n+  }\n+\n+  {\n+    std::optional<std::vector<int>> o { std::in_place, 18, 4 };\n+    VERIFY( o );\n+    VERIFY( o->size() == 18 );\n+    VERIFY( (*o)[17] == 4 );\n+  }\n+\n+  {\n+    std::optional<std::vector<int>> o { std::in_place, { 18, 4 } };\n+    VERIFY( o );\n+    VERIFY( o->size() == 2 );\n+    VERIFY( (*o)[0] == 18 );\n+  }\n+\n+  {\n+    std::optional<std::vector<int>> o { std::in_place, { 18, 4 }, std::allocator<int> {} };\n+    VERIFY( o );\n+    VERIFY( o->size() == 2 );\n+    VERIFY( (*o)[0] == 18 );\n+  }\n+}"}, {"sha": "6f245c716adcf3fabe5295911fa3e1fb21a661da", "filename": "libstdc++-v3/testsuite/20_util/optional/make_optional.cc", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmake_optional.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmake_optional.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fmake_optional.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,31 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  const int i = 42;\n+  auto o = std::make_optional(i);\n+  static_assert( std::is_same<decltype(o), std::optional<int>>(), \"\" );\n+  VERIFY( o && *o == 42 );\n+  VERIFY( &*o != &i );\n+}"}, {"sha": "f9ee748b9c23c52aa3542ed1a32ff402c64baec3", "filename": "libstdc++-v3/testsuite/20_util/optional/nullopt.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fnullopt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fnullopt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fnullopt.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,46 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+int main()\n+{\n+  // [20.5.6] Disengaged state indicator\n+  static_assert( std::is_same<decltype(std::nullopt), const std::nullopt_t>(), \"\" );\n+  static_assert( std::is_empty<std::nullopt_t>(), \"\" );\n+  static_assert( std::is_literal_type<std::nullopt_t>(), \"\" );\n+  static_assert( !std::is_default_constructible<std::nullopt_t>(), \"\" );\n+\n+  {\n+    std::optional<int> o = std::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<int> o = { std::nullopt };\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<int> o { std::nullopt };\n+    VERIFY( !o );\n+  }\n+}"}, {"sha": "ba10bce71198aab550ba3d42e0ef60f66ddaeff3", "filename": "libstdc++-v3/testsuite/20_util/optional/observers/1.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  std::optional<value_type> o { value_type { 51 } };\n+  VERIFY( (*o).i == 51 );\n+}"}, {"sha": "d3799b9214aa8a60eb8d293605fcb1597075edb4", "filename": "libstdc++-v3/testsuite/20_util/optional/observers/2.cc", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F2.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,37 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+void* operator&(const value_type&) = delete;\n+\n+int main()\n+{\n+  std::optional<value_type> o { value_type { 51 } };\n+  VERIFY( o->i == 51 );\n+  VERIFY( o->i == (*o).i );\n+  VERIFY( &o->i == &(*o).i );\n+}"}, {"sha": "9ad5d01ae42e7736d808df46e0a05b1d0b58843a", "filename": "libstdc++-v3/testsuite/20_util/optional/observers/3.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F3.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    std::optional<value_type> o { value_type { 51 } };\n+    VERIFY( o.value().i == 51 );\n+    VERIFY( o.value().i == (*o).i );\n+    VERIFY( &o.value().i == &(*o).i );\n+  }\n+\n+  {\n+    enum outcome_type { nothrow, caught, bad_catch };\n+\n+    outcome_type outcome {};\n+    std::optional<value_type> o = std::nullopt;\n+    bool called = false;\n+    auto const eat = [&called](int) { called = true; };\n+\n+    try\n+    {\n+      eat(o.value().i);\n+    }\n+    catch(std::bad_optional_access const&)\n+    { outcome = caught; }\n+    catch(...)\n+    { outcome = bad_catch; }\n+\n+    VERIFY( outcome == caught );\n+    VERIFY( !called );\n+  }\n+}"}, {"sha": "9a305674fb0ca37e9adadfe39fbdc427ea9af970", "filename": "libstdc++-v3/testsuite/20_util/optional/observers/4.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F4.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,35 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  std::optional<value_type> o { value_type { 51 } };\n+  value_type fallback { 3 };\n+  VERIFY( o.value_or(fallback).i == 51 );\n+  VERIFY( o.value_or(fallback).i == (*o).i );\n+}"}, {"sha": "386d81de2e0730c3becb7079e0267a7a6c6a44df", "filename": "libstdc++-v3/testsuite/20_util/optional/observers/5.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fobservers%2F5.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct value_type\n+{\n+  int i;\n+};\n+\n+int main()\n+{\n+  {\n+    std::optional<value_type> o = std::nullopt;\n+    VERIFY( !o );\n+  }\n+\n+  {\n+    std::optional<value_type> o { value_type { 51 } };\n+    VERIFY( o );\n+  }\n+}"}, {"sha": "62770329effe66345a852739a08c7186f0ac0ca5", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/1.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,85 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  {\n+    O o, p;\n+    VERIFY( o == p );\n+    VERIFY( !(o != p) );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p;\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o == p) );\n+    VERIFY( o != p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o == p );\n+    VERIFY( !(o != p) );\n+  }\n+}"}, {"sha": "65071c04bce8cf21ba2414de83ffb590214b1a60", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/2.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F2.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,97 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  {\n+    O o, p;\n+    VERIFY( !(o < p) );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p;\n+    VERIFY( !(o < p) );\n+    VERIFY( o > p );\n+    VERIFY( !(o <= p) );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o < p );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( !(o >= p) );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( o < p );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( !(o >= p) );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o < p) );\n+    VERIFY( o > p );\n+    VERIFY( !(o <= p) );\n+    VERIFY( o >= p );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } }, p { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o < p) );\n+    VERIFY( !(o > p) );\n+    VERIFY( o <= p );\n+    VERIFY( o >= p );\n+  }\n+}"}, {"sha": "2fd9e8bc1e7409dd6d34ced31d0db3f48959af5b", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/3.cc", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F3.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,75 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  value_type const reference { 42, \"forty-two\" };\n+\n+  {\n+    O o;\n+    VERIFY( !(o == reference) );\n+    VERIFY( !(reference == o) );\n+    VERIFY( o != reference );\n+    VERIFY( reference != o );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } };\n+    VERIFY( !(o == reference) );\n+    VERIFY( !(reference == o) );\n+    VERIFY( o != reference );\n+    VERIFY( reference != o );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } };\n+    VERIFY( o == reference );\n+    VERIFY( reference == o );\n+    VERIFY( !(o != reference) );\n+    VERIFY( !(reference != o) );\n+  }\n+}"}, {"sha": "363e633a40c61e0c0491ba6c4caa46908252a856", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/4.cc", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F4.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,87 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+\n+  value_type const reference { 42, \"forty-two\" };\n+\n+  {\n+    O o;\n+    VERIFY( o < reference );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( reference > o );\n+    VERIFY( o <= reference );\n+    VERIFY( !(reference <= o) );\n+    VERIFY( !(o >= reference) );\n+    VERIFY( reference >= o );\n+  }\n+\n+  {\n+    O o { value_type { 11, \"eleventy\" } };\n+    VERIFY( o < reference );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( reference > o );\n+    VERIFY( o <= reference );\n+    VERIFY( !(reference <= o) );\n+    VERIFY( !(o >= reference) );\n+    VERIFY( reference >= o );\n+  }\n+\n+  {\n+    O o { value_type { 42, \"forty-two\" } };\n+    VERIFY( !(o < reference) );\n+    VERIFY( !(reference < o) );\n+    VERIFY( !(o > reference) );\n+    VERIFY( !(reference > o) );\n+    VERIFY( o <= reference );\n+    VERIFY( reference <= o );\n+    VERIFY( o >= reference );\n+    VERIFY( reference >= o );\n+  }\n+}"}, {"sha": "e79e0dbc2783e3b105ff707dc97b05f6d25dd736", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/5.cc", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F5.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F5.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F5.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,66 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+  using std::nullopt;\n+\n+  {\n+    O o;\n+    VERIFY( o == nullopt );\n+    VERIFY( nullopt == o );\n+    VERIFY( !(o != nullopt) );\n+    VERIFY( !(nullopt != o) );\n+  }\n+\n+  {\n+    O o { std::in_place };\n+    VERIFY( !(o == nullopt) );\n+    VERIFY( !(nullopt == o) );\n+    VERIFY( o != nullopt );\n+    VERIFY( nullopt != o );\n+  }\n+}"}, {"sha": "4ead5d1acda759d6c7f22f1e0d8bbce4b75789c2", "filename": "libstdc++-v3/testsuite/20_util/optional/relops/6.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F6.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F6.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frelops%2F6.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,74 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+#include <string>\n+\n+namespace ns\n+{\n+  struct value_type\n+  {\n+    int i;\n+    std::string s;\n+  };\n+\n+  bool\n+  operator==(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) == std::tie(rhs.i, rhs.s); }\n+\n+  bool\n+  operator<(value_type const& lhs, value_type const& rhs)\n+  { return std::tie(lhs.i, lhs.s) < std::tie(rhs.i, rhs.s); }\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using ns::value_type;\n+  using O = std::optional<value_type>;\n+  using std::nullopt;\n+\n+  {\n+    O o;\n+    VERIFY( !(o < nullopt) );\n+    VERIFY( !(nullopt < o) );\n+    VERIFY( !(o > nullopt) );\n+    VERIFY( !(nullopt > o) );\n+    VERIFY( o <= nullopt );\n+    VERIFY( nullopt <= o );\n+    VERIFY( o >= nullopt );\n+    VERIFY( nullopt >= o );\n+  }\n+\n+  {\n+    O o { std::in_place };\n+    VERIFY( !(o < nullopt) );\n+    VERIFY( nullopt < o );\n+    VERIFY( o > nullopt );\n+    VERIFY( !(nullopt > o) );\n+    VERIFY( !(o <= nullopt) );\n+    VERIFY( nullopt <= o );\n+    VERIFY( o >= nullopt );\n+    VERIFY( !(nullopt >= o) );\n+  }\n+}"}, {"sha": "aab572f5795f65496070a0a50967edf151a1a8d6", "filename": "libstdc++-v3/testsuite/20_util/optional/requirements.cc", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Frequirements.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,259 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+#include <tuple>\n+\n+using std::bad_optional_access;\n+static_assert( std::is_default_constructible<bad_optional_access>::value, \"\" );\n+\n+struct trivially_destructible\n+{\n+  trivially_destructible() = delete;\n+  trivially_destructible(trivially_destructible const&) = delete;\n+  trivially_destructible& operator=(trivially_destructible const&) = delete;\n+  trivially_destructible(trivially_destructible&&) = delete;\n+  trivially_destructible& operator=(trivially_destructible&&) = delete;\n+  ~trivially_destructible() noexcept = default;\n+};\n+\n+static_assert( std::is_trivially_destructible<trivially_destructible>(), \"\" );\n+\n+struct no_default_constructor\n+{\n+  no_default_constructor() = delete;\n+};\n+\n+struct no_copy_constructor\n+{\n+  no_copy_constructor() = default;\n+  no_copy_constructor(no_copy_constructor const&) = delete;\n+  no_copy_constructor& operator=(no_copy_constructor const&) = default;\n+  no_copy_constructor(no_copy_constructor&&) = default;\n+  no_copy_constructor& operator=(no_copy_constructor&&) = default;\n+};\n+\n+struct no_copy_assignment\n+{\n+  no_copy_assignment() = default;\n+  no_copy_assignment(no_copy_assignment const&) = default;\n+  no_copy_assignment(no_copy_assignment&&) = default;\n+  no_copy_assignment& operator=(no_copy_assignment&&) = default;\n+};\n+\n+struct no_move_constructor\n+{\n+  no_move_constructor() = default;\n+  no_move_constructor(no_move_constructor const&) = default;\n+  no_move_constructor& operator=(no_move_constructor const&) = default;\n+  no_move_constructor(no_move_constructor&&) = delete;\n+  no_move_constructor& operator=(no_move_constructor&&) = default;\n+};\n+\n+struct no_move_assignment\n+{\n+  no_move_assignment() = default;\n+  no_move_assignment(no_move_assignment const&) = default;\n+  no_move_assignment& operator=(no_move_assignment const&) = default;\n+  no_move_assignment(no_move_assignment&&) = default;\n+  no_move_assignment& operator=(no_move_assignment&&) = delete;\n+};\n+\n+struct no_copy : no_copy_constructor, no_copy_assignment { };\n+struct no_move : no_move_constructor, no_move_assignment { };\n+\n+// Laxest possible model of a value type for optional\n+struct only_destructible\n+{\n+  only_destructible(only_destructible&&) = delete;\n+};\n+\n+int main()\n+{\n+  {\n+    static_assert( std::is_trivially_destructible<std::optional<trivially_destructible>>(), \"\" );\n+  }\n+\n+  {\n+    using T = no_default_constructor;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy_constructor;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy_assignment;\n+    using O = std::optional<T>;\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_copy;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move_constructor;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    /*\n+     * T should be move constructible due to [12.8/11], which is a new rule in C++1y\n+     * not yet implemented by GCC. Because there is already a special exception in C++11\n+     * for the generation of the special members that GCC implements (at least some of the\n+     * time), this does not affect the std::optional implementation however. So the assertion\n+     * for T should be changed (or removed altogether) when the time comes, but the rest\n+     * should however remain correct and unchanged.\n+     */\n+    static_assert( !std::is_move_constructible<T>(), \"\" );\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move_assignment;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    /*\n+     * Paragraph 23 of same leads to a similar situation but with respect to move\n+     * assignment.\n+     */\n+    static_assert( !std::is_move_assignable<T>(), \"\" );\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = no_move;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( std::is_copy_constructible<O>(), \"\" );\n+    { O o; auto copy = o; }\n+    static_assert( std::is_copy_assignable<O>(), \"\" );\n+    { O o, p; p = o; }\n+    static_assert( std::is_move_constructible<O>(), \"\" );\n+    { O o; auto moved_to = std::move(o); }\n+    static_assert( std::is_move_assignable<O>(), \"\" );\n+    { O o, p; p = std::move(o); }\n+  }\n+\n+  {\n+    using T = only_destructible;\n+    using O = std::optional<T>;\n+    static_assert( std::is_same<O::value_type, T>(), \"\" );\n+    static_assert( std::is_default_constructible<O>(), \"\" );\n+    { O o; }\n+    static_assert( !std::is_copy_constructible<O>(), \"\" );\n+    static_assert( !std::is_copy_assignable<O>(), \"\" );\n+    static_assert( !std::is_move_constructible<O>(), \"\" );\n+    static_assert( !std::is_move_assignable<O>(), \"\" );\n+  }\n+\n+  {\n+    /*\n+     * Should not complain about 'invalid' specializations as long as\n+     * they're not instantiated.\n+     */\n+    using A = std::optional<int&>;\n+    using B = std::optional<int&&>;\n+    using C1 = std::optional<std::in_place_t>;\n+    using C2 = std::optional<std::in_place_t const>;\n+    using C3 = std::optional<std::in_place_t volatile>;\n+    using C4 = std::optional<std::in_place_t const volatile>;\n+    using D1 = std::optional<std::nullopt_t>;\n+    using D2 = std::optional<std::nullopt_t const>;\n+    using D3 = std::optional<std::nullopt_t volatile>;\n+    using D4 = std::optional<std::nullopt_t const volatile>;\n+\n+    using X = std::tuple<A, B, C1, C2, C3, C4, D1, D2, D3, D4>;\n+  }\n+\n+  {\n+    std::optional<const int> o { 42 };\n+    static_assert( std::is_same<decltype(o)::value_type, const int>(), \"\" );\n+    VERIFY( o );\n+    VERIFY( *o == 42 );\n+  }\n+\n+  {\n+    constexpr std::optional<const int> o { 33 };\n+    static_assert( std::is_same<decltype(o)::value_type, const int>(), \"\" );\n+    static_assert( o, \"\" );\n+    static_assert( *o == 33, \"\" );\n+  }\n+}"}, {"sha": "b077fe4c583cc6d51268b44cae8e12f917d06c10", "filename": "libstdc++-v3/testsuite/20_util/optional/swap/1.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Fswap%2F1.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,95 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do run }\n+\n+// Copyright (C) 2013-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <testsuite_hooks.h>\n+\n+struct exception {};\n+\n+int counter = 0;\n+\n+struct mixin_counter\n+{\n+  mixin_counter() { ++counter; }\n+  mixin_counter(mixin_counter const&) { ++counter; }\n+  ~mixin_counter() { --counter; }\n+};\n+\n+namespace ns\n+{\n+\n+struct value_type : private mixin_counter\n+{\n+  explicit value_type(int state) : state(state) { }\n+  int state;\n+};\n+\n+int swaps = 0;\n+\n+void\n+swap(value_type& lhs, value_type& rhs)\n+{\n+  ++swaps;\n+  using std::swap;\n+  swap(lhs.state, rhs.state);\n+}\n+\n+} // namespace ns\n+\n+int main()\n+{\n+  using O = std::optional<ns::value_type>;\n+\n+  VERIFY( ns::swaps == 0 );\n+\n+  {\n+    O o, p;\n+    swap(o, p);\n+    VERIFY( !o );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o { std::in_place, 45 }, p;\n+    swap(o, p);\n+    VERIFY( !o );\n+    VERIFY( p && p->state == 45 );\n+  }\n+\n+  {\n+    O o, p { std::in_place, 45 };\n+    swap(o, p);\n+    VERIFY( o && o->state == 45 );\n+    VERIFY( !p );\n+  }\n+\n+  {\n+    O o { std::in_place, 167 }, p { std::in_place, 999 };\n+    VERIFY( ns::swaps == 0 );\n+\n+    swap(o, p);\n+\n+    VERIFY( o && o->state == 999 );\n+    VERIFY( p && p->state == 167 );\n+    VERIFY( ns::swaps == 1 );\n+  }\n+\n+  VERIFY( counter == 0 );\n+}"}, {"sha": "5ec95d850ecf831a459992e9846cddedcbbf2bf4", "filename": "libstdc++-v3/testsuite/20_util/optional/typedefs.cc", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/435e56fb5289d72bfe12068aac72e76c02bb3b3c/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Foptional%2Ftypedefs.cc?ref=435e56fb5289d72bfe12068aac72e76c02bb3b3c", "patch": "@@ -0,0 +1,33 @@\n+// { dg-options \"-std=gnu++17\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a moved_to of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <optional>\n+#include <type_traits>\n+#include <stdexcept>\n+\n+template<typename T>\n+  using check1_t = std::optional<T>;\n+\n+using check2_t = std::in_place_t;\n+using check3_t = std::nullopt_t;\n+using check4_t = std::bad_optional_access;\n+\n+static_assert(std::is_base_of<std::logic_error, check4_t>::value,\n+\t      \"bad_optional_access must derive from logic_error\");"}]}