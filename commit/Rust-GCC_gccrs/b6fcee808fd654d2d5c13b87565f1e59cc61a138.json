{"sha": "b6fcee808fd654d2d5c13b87565f1e59cc61a138", "node_id": "C_kwDOANBUbNoAKGI2ZmNlZTgwOGZkNjU0ZDJkNWMxM2I4NzU2NWYxZTU5Y2M2MWExMzg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2023-01-10T22:39:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-10T22:39:41Z"}, "message": "Merge #1724\n\n1724: Add support for generics associated type binding r=philberty a=philberty\n\nThis patch set adds support to specify the associated type via the argument\r\nbinding syntax. We are still missing general bounds checking so in order to\r\nproperly add more test cases for bad types we need to implement that first.\r\nI have also changed a test case to -fsyntax-only as at the time I always get\r\nconfused between Generic arguments of foo=i32 and bar: baz only specifies\r\nthe associated type and the latter adds a bound. Currently we are lacking a\r\nway to represent adding a bound in the AST and HIR within generic arguments\r\nso I have raised: #1725 and #1726\r\n\r\n\r\n\r\nFixes #1720 \n\nCo-authored-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "499c036b44ea9eaaf7e882d98365e8d52dffbb88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/499c036b44ea9eaaf7e882d98365e8d52dffbb88"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6fcee808fd654d2d5c13b87565f1e59cc61a138", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjvektCRBK7hj4Ov3rIwAAVD4IAIEoXOyht7ayLdxjiZakSBcu\nTxQlzEPSYg+Wf6ydYrfojgqoFAWb7j+epbhPUeuzKkDSYXUGM6cDEwpghAYnQcOv\nVQZlyVHQ5gWr3aw+jxUlEqx0/O0B2mhmwbCjWSpg3VEhIQ8EIFGIaL8HME0FJWYD\n08v+xCCiFAhjTagSrY88Z83sOVojwYc43adyb/wpZGdBqLlJ0YgjtVOwA9Bk1XoH\noBCvr6fKF/Hye/IYWojPu728BtYviOTraSajCMDYsvF3q4ufNyicxEOw6yp7aLFj\nPLiaHLX67sBseZKABu+Y+JMqrKLT2O2TmfxBaAc5e1+g10VJNrFxqe1OcipUXgk=\n=A9y4\n-----END PGP SIGNATURE-----\n", "payload": "tree 499c036b44ea9eaaf7e882d98365e8d52dffbb88\nparent 3290293e16fa47cf59f0434343c1bf40497ede90\nparent ed6718d979e400cb254279e103f239a25ea92c56\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1673390381 +0000\ncommitter GitHub <noreply@github.com> 1673390381 +0000\n\nMerge #1724\n\n1724: Add support for generics associated type binding r=philberty a=philberty\n\nThis patch set adds support to specify the associated type via the argument\r\nbinding syntax. We are still missing general bounds checking so in order to\r\nproperly add more test cases for bad types we need to implement that first.\r\nI have also changed a test case to -fsyntax-only as at the time I always get\r\nconfused between Generic arguments of foo=i32 and bar: baz only specifies\r\nthe associated type and the latter adds a bound. Currently we are lacking a\r\nway to represent adding a bound in the AST and HIR within generic arguments\r\nso I have raised: #1725 and #1726\r\n\r\n\r\n\r\nFixes #1720 \n\nCo-authored-by: Philip Herron <herron.philip@googlemail.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fcee808fd654d2d5c13b87565f1e59cc61a138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fcee808fd654d2d5c13b87565f1e59cc61a138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fcee808fd654d2d5c13b87565f1e59cc61a138/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3290293e16fa47cf59f0434343c1bf40497ede90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3290293e16fa47cf59f0434343c1bf40497ede90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3290293e16fa47cf59f0434343c1bf40497ede90"}, {"sha": "ed6718d979e400cb254279e103f239a25ea92c56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed6718d979e400cb254279e103f239a25ea92c56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed6718d979e400cb254279e103f239a25ea92c56"}], "stats": {"total": 279, "additions": 241, "deletions": 38}, "files": [{"sha": "88eb7a7addd55d1c25705383c6db6f6d050a61f4", "filename": "gcc/rust/hir/tree/rust-hir-path.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-path.h?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -105,9 +105,11 @@ struct GenericArgsBinding\n \n   std::string as_string () const;\n \n-  Identifier get_identifier () const { return identifier; }\n+  Identifier &get_identifier () { return identifier; }\n+  const Identifier &get_identifier () const { return identifier; }\n \n   std::unique_ptr<Type> &get_type () { return type; }\n+  const std::unique_ptr<Type> &get_type () const { return type; }\n \n   Location get_locus () const { return locus; }\n };"}, {"sha": "784660398331e53db7b1a0592599a56a276eb11e", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -589,6 +589,11 @@ ResolveGenericArgs::go (AST::GenericArgs &generic_args,\n \n       resolver.resolve_disambiguated_generic (arg);\n     }\n+\n+  for (auto &binding : generic_args.get_binding_args ())\n+    {\n+      ResolveType::go (binding.get_type ().get ());\n+    }\n }\n \n } // namespace Resolver"}, {"sha": "ac7d4f5f98b34abaf6955d306331a2c33b73a1ed", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -362,7 +362,8 @@ class PathProbeType : public TypeCheckBase, public HIR::HIRImplVisitor\n \tmappings.push_back (TyTy::SubstitutionArg (param, receiver->clone ()));\n \n \tLocation locus; // FIXME\n-\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), locus);\n+\tTyTy::SubstitutionArgumentMappings args (std::move (mappings), {},\n+\t\t\t\t\t\t locus);\n \ttrait_item_tyty = SubstMapperInternal::Resolve (trait_item_tyty, args);\n       }\n "}, {"sha": "d968c2078f4da92453b56480bec2e081a4efe848", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -441,8 +441,8 @@ AssociatedImplTrait::setup_associated_types (\n \tparam_mappings[p.get_symbol ()] = a.get_tyty ()->get_ref ();\n       };\n \n-  TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), locus,\n-\t\t\t\t\t\t      param_subst_cb);\n+  TyTy::SubstitutionArgumentMappings infer_arguments (std::move (args), {},\n+\t\t\t\t\t\t      locus, param_subst_cb);\n   TyTy::BaseType *impl_self_infer\n     = (associated_self->needs_generic_substitutions ())\n \t? SubstMapperInternal::Resolve (associated_self, infer_arguments)\n@@ -489,8 +489,9 @@ AssociatedImplTrait::setup_associated_types (\n       hrtb_bound_arguments.push_back (r);\n     }\n \n-  rust_assert (impl_trait_predicate_args.size ()\n-\t       == hrtb_bound_arguments.size ());\n+  if (impl_trait_predicate_args.size () != hrtb_bound_arguments.size ())\n+    return;\n+\n   for (size_t i = 0; i < impl_trait_predicate_args.size (); i++)\n     {\n       TyTy::BaseType *a = impl_trait_predicate_args.at (i);\n@@ -521,7 +522,7 @@ AssociatedImplTrait::setup_associated_types (\n     }\n \n   TyTy::SubstitutionArgumentMappings associated_type_args (\n-    std::move (associated_arguments), locus);\n+    std::move (associated_arguments), {}, locus);\n \n   ImplTypeIterator iter (*impl, [&] (HIR::TypeAlias &type) {\n     TraitItemReference *resolved_trait_item = nullptr;"}, {"sha": "9bd4d09981402e74ce71c9d51f3387d063e4aa28", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -618,7 +618,8 @@ TypeCheckExpr::visit (HIR::RangeFromToExpr &expr)\n   const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n   subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n \n-  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, {},\n+\t\t\t\t\t    expr.get_locus ());\n   infered = SubstMapperInternal::Resolve (adt, subst);\n }\n \n@@ -664,7 +665,8 @@ TypeCheckExpr::visit (HIR::RangeFromExpr &expr)\n   const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n   subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n \n-  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, {},\n+\t\t\t\t\t    expr.get_locus ());\n   infered = SubstMapperInternal::Resolve (adt, subst);\n }\n \n@@ -709,7 +711,8 @@ TypeCheckExpr::visit (HIR::RangeToExpr &expr)\n   const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n   subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, from_ty));\n \n-  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, {},\n+\t\t\t\t\t    expr.get_locus ());\n   infered = SubstMapperInternal::Resolve (adt, subst);\n }\n \n@@ -792,7 +795,8 @@ TypeCheckExpr::visit (HIR::RangeFromToInclExpr &expr)\n   const TyTy::SubstitutionParamMapping *param_ref = &adt->get_substs ().at (0);\n   subst_mappings.push_back (TyTy::SubstitutionArg (param_ref, unified));\n \n-  TyTy::SubstitutionArgumentMappings subst (subst_mappings, expr.get_locus ());\n+  TyTy::SubstitutionArgumentMappings subst (subst_mappings, {},\n+\t\t\t\t\t    expr.get_locus ());\n   infered = SubstMapperInternal::Resolve (adt, subst);\n }\n "}, {"sha": "e5057c8e3c0cfd73d160d47676360c5605429f4c", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 79, "deletions": 10, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -145,11 +145,10 @@ TypeCheckBase::get_predicate_from_bound (HIR::TypePath &type_path)\n       break;\n     }\n \n-  // FIXME\n-  // I think this should really be just be if the !args.is_empty() because\n-  // someone might wrongly apply generic arguments where they should not and\n-  // they will be missing error diagnostics\n-  if (predicate.requires_generic_args ())\n+  // we try to apply generic arguments when they are non empty and or when the\n+  // predicate requires them so that we get the relevant Foo expects x number\n+  // arguments but got zero see test case rust/compile/traits12.rs\n+  if (!args.is_empty () || predicate.requires_generic_args ())\n     {\n       // this is applying generic arguments to a trait reference\n       predicate.apply_generic_arguments (&args);\n@@ -222,7 +221,7 @@ TypeBoundPredicate::TypeBoundPredicate (const TypeBoundPredicate &other)\n     }\n \n   used_arguments\n-    = SubstitutionArgumentMappings (copied_arg_mappings,\n+    = SubstitutionArgumentMappings (copied_arg_mappings, {},\n \t\t\t\t    other.used_arguments.get_locus ());\n }\n \n@@ -258,7 +257,7 @@ TypeBoundPredicate::operator= (const TypeBoundPredicate &other)\n     }\n \n   used_arguments\n-    = SubstitutionArgumentMappings (copied_arg_mappings,\n+    = SubstitutionArgumentMappings (copied_arg_mappings, {},\n \t\t\t\t    other.used_arguments.get_locus ());\n \n   return *this;\n@@ -331,6 +330,19 @@ TypeBoundPredicate::apply_generic_arguments (HIR::GenericArgs *generic_args)\n       if (ok && arg.get_tyty () != nullptr)\n \tsub.fill_param_ty (subst_mappings, subst_mappings.get_locus ());\n     }\n+\n+  // associated argument mappings\n+  for (auto &it : subst_mappings.get_binding_args ())\n+    {\n+      std::string identifier = it.first;\n+      TyTy::BaseType *type = it.second;\n+\n+      TypeBoundPredicateItem item = lookup_associated_item (identifier);\n+      rust_assert (!item.is_error ());\n+\n+      const auto item_ref = item.get_raw_item ();\n+      item_ref->associated_type_set (type);\n+    }\n }\n \n bool\n@@ -389,7 +401,8 @@ TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n       adjusted_mappings.push_back (std::move (arg));\n     }\n \n-  SubstitutionArgumentMappings adjusted (adjusted_mappings, gargs.get_locus (),\n+  SubstitutionArgumentMappings adjusted (adjusted_mappings, {},\n+\t\t\t\t\t gargs.get_locus (),\n \t\t\t\t\t gargs.get_subst_cb (),\n \t\t\t\t\t true /* trait-mode-flag */);\n   return Resolver::SubstMapperInternal::Resolve (trait_item_tyty, adjusted);\n@@ -421,6 +434,19 @@ TypeBoundPredicate::handle_substitions (\n       p->set_ty_ref (s->get_ty_ref ());\n     }\n \n+  // associated argument mappings\n+  for (auto &it : subst_mappings.get_binding_args ())\n+    {\n+      std::string identifier = it.first;\n+      TyTy::BaseType *type = it.second;\n+\n+      TypeBoundPredicateItem item = lookup_associated_item (identifier);\n+      rust_assert (!item.is_error ());\n+\n+      const auto item_ref = item.get_raw_item ();\n+      item_ref->associated_type_set (type);\n+    }\n+\n   // FIXME more error handling at some point\n   // used_arguments = subst_mappings;\n   // error_flag |= used_arguments.is_error ();\n@@ -440,16 +466,59 @@ TypeBoundPredicate::requires_generic_args () const\n bool\n TypeBoundPredicate::contains_associated_types () const\n {\n+  return get_num_associated_bindings () > 0;\n+}\n+\n+size_t\n+TypeBoundPredicate::get_num_associated_bindings () const\n+{\n+  size_t count = 0;\n   auto trait_ref = get ();\n   for (const auto &trait_item : trait_ref->get_trait_items ())\n     {\n       bool is_associated_type\n \t= trait_item.get_trait_item_type ()\n \t  == Resolver::TraitItemReference::TraitItemType::TYPE;\n       if (is_associated_type)\n-\treturn true;\n+\tcount++;\n+    }\n+  return count;\n+}\n+\n+TypeBoundPredicateItem\n+TypeBoundPredicate::lookup_associated_type (const std::string &search)\n+{\n+  TypeBoundPredicateItem item = lookup_associated_item (search);\n+\n+  // only need to check that it is infact an associated type because other wise\n+  // if it was not found it will just be an error node anyway\n+  if (!item.is_error ())\n+    {\n+      const auto raw = item.get_raw_item ();\n+      if (raw->get_trait_item_type ()\n+\t  != Resolver::TraitItemReference::TraitItemType::TYPE)\n+\treturn TypeBoundPredicateItem::error ();\n+    }\n+  return item;\n+}\n+\n+std::vector<TypeBoundPredicateItem>\n+TypeBoundPredicate::get_associated_type_items ()\n+{\n+  std::vector<TypeBoundPredicateItem> items;\n+  auto trait_ref = get ();\n+  for (const auto &trait_item : trait_ref->get_trait_items ())\n+    {\n+      bool is_associated_type\n+\t= trait_item.get_trait_item_type ()\n+\t  == Resolver::TraitItemReference::TraitItemType::TYPE;\n+      if (is_associated_type)\n+\t{\n+\t  TypeBoundPredicateItem item (this, &trait_item);\n+\t  items.push_back (std::move (item));\n+\t}\n     }\n-  return false;\n+  return items;\n }\n \n // trait item reference"}, {"sha": "9358919ffaf4555d951f730272d1099e64017dec", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -674,14 +674,58 @@ SubstitutionParamMapping::override_context ()\n SubstitutionArgumentMappings\n SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n {\n+  std::map<std::string, BaseType *> binding_arguments;\n   if (args.get_binding_args ().size () > 0)\n     {\n-      RichLocation r (args.get_locus ());\n-      for (auto &binding : args.get_binding_args ())\n-\tr.add_range (binding.get_locus ());\n+      if (supports_associated_bindings ())\n+\t{\n+\t  if (args.get_binding_args ().size () > get_num_associated_bindings ())\n+\t    {\n+\t      RichLocation r (args.get_locus ());\n+\n+\t      rust_error_at (r,\n+\t\t\t     \"generic item takes at most %lu type binding \"\n+\t\t\t     \"arguments but %lu were supplied\",\n+\t\t\t     (unsigned long) get_num_associated_bindings (),\n+\t\t\t     (unsigned long) args.get_binding_args ().size ());\n+\t      return SubstitutionArgumentMappings::error ();\n+\t    }\n \n-      rust_error_at (r, \"associated type bindings are not allowed here\");\n-      return SubstitutionArgumentMappings::error ();\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    {\n+\t      BaseType *resolved\n+\t\t= Resolver::TypeCheckType::Resolve (binding.get_type ().get ());\n+\t      if (resolved == nullptr\n+\t\t  || resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"failed to resolve type arguments\");\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      // resolve to relevant binding\n+\t      auto binding_item\n+\t\t= lookup_associated_type (binding.get_identifier ());\n+\t      if (binding_item.is_error ())\n+\t\t{\n+\t\t  rust_error_at (binding.get_locus (),\n+\t\t\t\t \"unknown associated type binding: %s\",\n+\t\t\t\t binding.get_identifier ().c_str ());\n+\t\t  return SubstitutionArgumentMappings::error ();\n+\t\t}\n+\n+\t      binding_arguments[binding.get_identifier ()] = resolved;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  RichLocation r (args.get_locus ());\n+\t  for (auto &binding : args.get_binding_args ())\n+\t    r.add_range (binding.get_locus ());\n+\n+\t  rust_error_at (r, \"associated type bindings are not allowed here\");\n+\t  return SubstitutionArgumentMappings::error ();\n+\t}\n     }\n \n   // for inherited arguments\n@@ -745,6 +789,7 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n \t  if (resolved->contains_type_parameters ())\n \t    {\n \t      SubstitutionArgumentMappings intermediate (mappings,\n+\t\t\t\t\t\t\t binding_arguments,\n \t\t\t\t\t\t\t args.get_locus ());\n \t      resolved = Resolver::SubstMapperInternal::Resolve (resolved,\n \t\t\t\t\t\t\t\t intermediate);\n@@ -758,7 +803,8 @@ SubstitutionRef::get_mappings_from_generic_args (HIR::GenericArgs &args)\n \t}\n     }\n \n-  return SubstitutionArgumentMappings (mappings, args.get_locus ());\n+  return SubstitutionArgumentMappings (mappings, binding_arguments,\n+\t\t\t\t       args.get_locus ());\n }\n \n BaseType *\n@@ -791,7 +837,13 @@ SubstitutionRef::infer_substitions (Location locus)\n \t}\n     }\n \n-  SubstitutionArgumentMappings infer_arguments (std::move (args), locus);\n+  // FIXME do we need to add inference variables to all the possible bindings?\n+  // it might just lead to inference variable hell not 100% sure if rustc does\n+  // this i think the language might needs this to be explicitly set\n+\n+  SubstitutionArgumentMappings infer_arguments (std::move (args),\n+\t\t\t\t\t\t{} /* binding_arguments */,\n+\t\t\t\t\t\tlocus);\n   return handle_substitions (std::move (infer_arguments));\n }\n \n@@ -835,7 +887,9 @@ SubstitutionRef::adjust_mappings_for_this (\n   if (resolved_mappings.empty ())\n     return SubstitutionArgumentMappings::error ();\n \n-  return SubstitutionArgumentMappings (resolved_mappings, mappings.get_locus (),\n+  return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n+\t\t\t\t       mappings.get_locus (),\n \t\t\t\t       mappings.get_subst_cb (),\n \t\t\t\t       mappings.trait_item_mode ());\n }\n@@ -901,6 +955,7 @@ SubstitutionRef::solve_mappings_from_receiver_for_self (\n     }\n \n   return SubstitutionArgumentMappings (resolved_mappings,\n+\t\t\t\t       mappings.get_binding_args (),\n \t\t\t\t       mappings.get_locus ());\n }\n \n@@ -952,7 +1007,7 @@ SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n       resolved_mappings.push_back (std::move (argument));\n     }\n \n-  return SubstitutionArgumentMappings (resolved_mappings, locus);\n+  return SubstitutionArgumentMappings (resolved_mappings, {}, locus);\n }\n \n bool"}, {"sha": "4f333a8ed2f73bd1075d5f120b4ef65629703b6d", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -675,23 +675,25 @@ class SubstitutionArgumentMappings\n {\n public:\n   SubstitutionArgumentMappings (std::vector<SubstitutionArg> mappings,\n+\t\t\t\tstd::map<std::string, BaseType *> binding_args,\n \t\t\t\tLocation locus,\n \t\t\t\tParamSubstCb param_subst_cb = nullptr,\n \t\t\t\tbool trait_item_flag = false)\n-    : mappings (mappings), locus (locus), param_subst_cb (param_subst_cb),\n-      trait_item_flag (trait_item_flag)\n+    : mappings (mappings), binding_args (binding_args), locus (locus),\n+      param_subst_cb (param_subst_cb), trait_item_flag (trait_item_flag)\n   {}\n \n   SubstitutionArgumentMappings (const SubstitutionArgumentMappings &other)\n-    : mappings (other.mappings), locus (other.locus),\n-      param_subst_cb (other.param_subst_cb),\n+    : mappings (other.mappings), binding_args (other.binding_args),\n+      locus (other.locus), param_subst_cb (other.param_subst_cb),\n       trait_item_flag (other.trait_item_flag)\n   {}\n \n   SubstitutionArgumentMappings &\n   operator= (const SubstitutionArgumentMappings &other)\n   {\n     mappings = other.mappings;\n+    binding_args = other.binding_args;\n     locus = other.locus;\n     param_subst_cb = other.param_subst_cb;\n     trait_item_flag = other.trait_item_flag;\n@@ -705,7 +707,7 @@ class SubstitutionArgumentMappings\n \n   static SubstitutionArgumentMappings error ()\n   {\n-    return SubstitutionArgumentMappings ({}, Location (), nullptr, false);\n+    return SubstitutionArgumentMappings ({}, {}, Location (), nullptr, false);\n   }\n \n   bool is_error () const { return mappings.size () == 0; }\n@@ -759,6 +761,16 @@ class SubstitutionArgumentMappings\n \n   const std::vector<SubstitutionArg> &get_mappings () const { return mappings; }\n \n+  std::map<std::string, BaseType *> &get_binding_args ()\n+  {\n+    return binding_args;\n+  }\n+\n+  const std::map<std::string, BaseType *> &get_binding_args () const\n+  {\n+    return binding_args;\n+  }\n+\n   std::string as_string () const\n   {\n     std::string buffer;\n@@ -783,6 +795,7 @@ class SubstitutionArgumentMappings\n \n private:\n   std::vector<SubstitutionArg> mappings;\n+  std::map<std::string, BaseType *> binding_args;\n   Location locus;\n   ParamSubstCb param_subst_cb;\n   bool trait_item_flag;\n@@ -813,6 +826,24 @@ class SubstitutionRef\n     return buffer.empty () ? \"\" : \"<\" + buffer + \">\";\n   }\n \n+  bool supports_associated_bindings () const\n+  {\n+    return get_num_associated_bindings () > 0;\n+  }\n+\n+  // this is overridden in TypeBoundPredicate\n+  // which support bindings we don't add them directly to the SubstitutionRef\n+  // base class because this class represents the fn<X: Foo, Y: Bar>. The only\n+  // construct which supports associated types\n+  virtual size_t get_num_associated_bindings () const { return 0; }\n+\n+  // this is overridden in TypeBoundPredicate\n+  virtual TypeBoundPredicateItem\n+  lookup_associated_type (const std::string &search)\n+  {\n+    return TypeBoundPredicateItem::error ();\n+  }\n+\n   size_t get_num_substitutions () const { return substitutions.size (); }\n \n   std::vector<SubstitutionParamMapping> &get_substs () { return substitutions; }\n@@ -1040,6 +1071,13 @@ class TypeBoundPredicate : public SubstitutionRef\n \n   DefId get_id () const { return reference; }\n \n+  std::vector<TypeBoundPredicateItem> get_associated_type_items ();\n+\n+  size_t get_num_associated_bindings () const override final;\n+\n+  TypeBoundPredicateItem\n+  lookup_associated_type (const std::string &search) override final;\n+\n private:\n   DefId reference;\n   Location locus;"}, {"sha": "57ff17ffcdc8dc606ce568761cf6f0dd5dfa7afe", "filename": "gcc/testsuite/rust/compile/bounds.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbounds.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbounds.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fbounds.rs?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -1,10 +1,12 @@\n+// { dg-options \"-fsyntax-only\" }\n trait Foo {\n     type Bar;\n }\n \n trait Copy {}\n \n-\n-fn c<F: Foo<Bar: Foo>>() where F::Bar: Copy { // { dg-warning \"function is never used: 'c'\" }\n+fn c<F: Foo<Bar: Foo>>()\n+where\n+    F::Bar: Copy,\n+{\n }\n-"}, {"sha": "771d7eec5378d82b81878932299a590f1176da1b", "filename": "gcc/testsuite/rust/execute/torture/issue-1720.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6fcee808fd654d2d5c13b87565f1e59cc61a138/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Fissue-1720.rs?ref=b6fcee808fd654d2d5c13b87565f1e59cc61a138", "patch": "@@ -0,0 +1,26 @@\n+mod core {\n+    mod ops {\n+        #[lang = \"add\"]\n+        pub trait Add<Rhs = Self> {\n+            type Output;\n+\n+            fn add(self, rhs: Rhs) -> Self::Output;\n+        }\n+    }\n+}\n+\n+impl core::ops::Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, rhs: i32) -> Self::Output {\n+        self + rhs\n+    }\n+}\n+\n+pub fn foo<T: core::ops::Add<Output = i32>>(a: T) -> i32 {\n+    a + a\n+}\n+\n+pub fn main() -> i32 {\n+    foo(1) - 2\n+}"}]}