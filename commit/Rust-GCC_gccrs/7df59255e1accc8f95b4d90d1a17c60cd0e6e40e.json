{"sha": "7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RmNTkyNTVlMWFjY2M4Zjk1YjRkOTBkMWExN2M2MGNkMGU2ZTQwZQ==", "commit": {"author": {"name": "Kostya Serebryany", "email": "kcc@google.com", "date": "2013-02-21T10:57:10Z"}, "committer": {"name": "Kostya Serebryany", "email": "kcc@gcc.gnu.org", "date": "2013-02-21T10:57:10Z"}, "message": "libsanitizer merge from upstream r175733\n\nFrom-SVN: r196201", "tree": {"sha": "0ad34c195787ec507c5bcdbb710bf127eb3a2fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ad34c195787ec507c5bcdbb710bf127eb3a2fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/comments", "author": {"login": "kcc", "id": 1789297, "node_id": "MDQ6VXNlcjE3ODkyOTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1789297?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kcc", "html_url": "https://github.com/kcc", "followers_url": "https://api.github.com/users/kcc/followers", "following_url": "https://api.github.com/users/kcc/following{/other_user}", "gists_url": "https://api.github.com/users/kcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/kcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kcc/subscriptions", "organizations_url": "https://api.github.com/users/kcc/orgs", "repos_url": "https://api.github.com/users/kcc/repos", "events_url": "https://api.github.com/users/kcc/events{/privacy}", "received_events_url": "https://api.github.com/users/kcc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4"}], "stats": {"total": 992, "additions": 767, "deletions": 225}, "files": [{"sha": "ca184f2ecbfae11c57e765722c3add61911da60a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -1,3 +1,8 @@\n+2013-02-23  Kostya Serebryany  <kcc@google.com>\n+\n+\t* config/i386/i386.c (ix86_asan_shadow_offset): Use 0x7fff8000 as\n+\tasan_shadow_offset on x86_64 linux.\n+\n 2013-02-21  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/56415"}, {"sha": "b835c5da2abbfd9769a3cbbe76c4529b4a08a50b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -5436,7 +5436,8 @@ ix86_legitimate_combined_insn (rtx insn)\n static unsigned HOST_WIDE_INT\n ix86_asan_shadow_offset (void)\n {\n-  return TARGET_LP64 ? (HOST_WIDE_INT_1 << 44)\n+  return TARGET_LP64 ? (TARGET_MACHO ? (HOST_WIDE_INT_1 << 44)\n+\t\t\t\t     : HOST_WIDE_INT_C (0x7fff8000))\n \t\t     : (HOST_WIDE_INT_1 << 29);\n }\n \f"}, {"sha": "ed857384853165db124ac3cc434095857b928e7c", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -1,3 +1,9 @@\n+2013-02-21  Kostya Serebryany  <kcc@google.com>\n+\n+\t* All source files: Merge from upstream r175733.\n+\t* sanitizer_common/Makefile.am: Added a new file.\n+\t* sanitizer_common/Makefile.in: Regenerated.\n+\n 2013-02-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/56327"}, {"sha": "28d1e49ab773ecd764aa1034f10b26ac260f2964", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -1,4 +1,4 @@\n-175049\n+175733\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "b880896c7a3ae9e2457209a15e88c2bfa2f2a0c5", "filename": "libsanitizer/asan/asan_flags.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -15,11 +15,13 @@\n \n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n \n-// ASan flag values can be defined in three ways:\n+// ASan flag values can be defined in four ways:\n // 1) initialized with default values at startup.\n-// 2) overriden from string returned by user-specified function\n+// 2) overriden during compilation of ASan runtime by providing\n+//    compile definition ASAN_DEFAULT_OPTIONS.\n+// 3) overriden from string returned by user-specified function\n //    __asan_default_options().\n-// 3) overriden from env variable ASAN_OPTIONS.\n+// 4) overriden from env variable ASAN_OPTIONS.\n \n namespace __asan {\n "}, {"sha": "ed75c4284397edec1ef90e205441188a34e8d450", "filename": "libsanitizer/asan/asan_intercepted_functions.h", "status": "modified", "additions": 46, "deletions": 13, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_intercepted_functions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_intercepted_functions.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -77,9 +77,36 @@ using __sanitizer::uptr;\n # define ASAN_INTERCEPT___CXA_THROW 0\n #endif\n \n+#define INTERPOSE_FUNCTION(function) \\\n+    { reinterpret_cast<const uptr>(WRAP(function)), \\\n+      reinterpret_cast<const uptr>(function) }\n+\n+#define INTERPOSE_FUNCTION_2(function, wrapper) \\\n+    { reinterpret_cast<const uptr>(wrapper), \\\n+      reinterpret_cast<const uptr>(function) }\n+\n+struct interpose_substitution {\n+  const uptr replacement;\n+  const uptr original;\n+};\n+\n+#define INTERPOSER(func) __attribute__((used)) \\\n+const interpose_substitution substitution_##func[] \\\n+    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n+  INTERPOSE_FUNCTION(func), \\\n+}\n+\n+#define INTERPOSER_2(func, wrapper) __attribute__((used)) \\\n+const interpose_substitution substitution_##func[] \\\n+    __attribute__((section(\"__DATA, __interpose\"))) = { \\\n+  INTERPOSE_FUNCTION_2(func, wrapper), \\\n+}\n+\n+\n #define DECLARE_FUNCTION_AND_WRAPPER(ret_type, func, ...) \\\n   ret_type func(__VA_ARGS__); \\\n-  ret_type WRAP(func)(__VA_ARGS__)\n+  ret_type WRAP(func)(__VA_ARGS__); \\\n+  INTERPOSER(func)\n \n // Use extern declarations of intercepted functions on Mac and Windows\n // to avoid including system headers.\n@@ -139,7 +166,8 @@ DECLARE_FUNCTION_AND_WRAPPER(char*, strdup, const char *s);\n DECLARE_FUNCTION_AND_WRAPPER(uptr, strnlen, const char *s, uptr maxlen);\n # endif\n # if ASAN_INTERCEPT_INDEX\n-DECLARE_FUNCTION_AND_WRAPPER(char*, index, const char *string, int c);\n+char* index(const char *string, int c);\n+INTERPOSER_2(index, WRAP(strchr));\n # endif\n \n // stdlib.h\n@@ -193,6 +221,20 @@ DECLARE_FUNCTION_AND_WRAPPER(int, pthread_create,\n                              void *(*start_routine)(void*), void *arg);\n # endif\n \n+# if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n+DECLARE_FUNCTION_AND_WRAPPER(void *, localtime, unsigned long *timep);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, localtime_r, unsigned long *timep,\n+                             void *result);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, gmtime, unsigned long *timep);\n+DECLARE_FUNCTION_AND_WRAPPER(void *, gmtime_r, unsigned long *timep,\n+                             void *result);\n+DECLARE_FUNCTION_AND_WRAPPER(char *, ctime, unsigned long *timep);\n+DECLARE_FUNCTION_AND_WRAPPER(char *, ctime_r, unsigned long *timep,\n+                             char *result);\n+DECLARE_FUNCTION_AND_WRAPPER(char *, asctime, void *tm);\n+DECLARE_FUNCTION_AND_WRAPPER(char *, asctime_r, void *tm, char *result);\n+# endif\n+\n // stdio.h\n # if SANITIZER_INTERCEPT_SCANF\n DECLARE_FUNCTION_AND_WRAPPER(int, vscanf, const char *format, va_list ap);\n@@ -205,17 +247,6 @@ DECLARE_FUNCTION_AND_WRAPPER(int, fscanf,\n                              void* stream, const char *format, ...);\n DECLARE_FUNCTION_AND_WRAPPER(int, sscanf,  // NOLINT\n                              const char *str, const char *format, ...);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vscanf, const char *format,\n-                             va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vsscanf, const char *str,\n-                             const char *format, va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_vfscanf, void *stream,\n-                             const char *format, va_list ap);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_scanf, const char *format, ...);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_fscanf,\n-                             void* stream, const char *format, ...);\n-DECLARE_FUNCTION_AND_WRAPPER(int, __isoc99_sscanf,  // NOLINT\n-                             const char *str, const char *format, ...);\n # endif\n \n # if defined(__APPLE__)\n@@ -278,9 +309,11 @@ DECLARE_FUNCTION_AND_WRAPPER(void *, valloc, size_t size);\n DECLARE_FUNCTION_AND_WRAPPER(size_t, malloc_good_size, size_t size);\n DECLARE_FUNCTION_AND_WRAPPER(int, posix_memalign,\n                              void **memptr, size_t alignment, size_t size);\n+#if 0\n DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_prepare, void);\n DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_parent, void);\n DECLARE_FUNCTION_AND_WRAPPER(void, _malloc_fork_child, void);\n+#endif\n \n \n "}, {"sha": "064fc6261b02ed7a54a1944a9aadd36a5945487c", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -24,6 +24,16 @@\n \n namespace __asan {\n \n+// Return true if we can quickly decide that the region is unpoisoned.\n+static inline bool QuickCheckForUnpoisonedRegion(uptr beg, uptr size) {\n+  if (size == 0) return true;\n+  if (size <= 32)\n+    return !AddressIsPoisoned(beg) &&\n+           !AddressIsPoisoned(beg + size - 1) &&\n+           !AddressIsPoisoned(beg + size / 2);\n+  return false;\n+}\n+\n // We implement ACCESS_MEMORY_RANGE, ASAN_READ_RANGE,\n // and ASAN_WRITE_RANGE as macro instead of function so\n // that no extra frames are created, and stack trace contains\n@@ -32,7 +42,8 @@ namespace __asan {\n #define ACCESS_MEMORY_RANGE(offset, size, isWrite) do {                 \\\n     uptr __offset = (uptr)(offset);                                     \\\n     uptr __size = (uptr)(size);                                         \\\n-    if (__asan_region_is_poisoned(__offset, __size)) {                  \\\n+    if (!QuickCheckForUnpoisonedRegion(__offset, __size) &&             \\\n+        __asan_region_is_poisoned(__offset, __size)) {                  \\\n       GET_CURRENT_PC_BP_SP;                                             \\\n       __asan_report_error(pc, bp, sp, __offset, isWrite, __size);       \\\n     }                                                                   \\"}, {"sha": "1ccbf10864781a3c76c29cc1051f8e238c930e9a", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -52,7 +52,7 @@\n \n #define ASAN_POSIX (ASAN_LINUX || ASAN_MAC)\n \n-#if __has_feature(address_sanitizer)\n+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n # error \"The AddressSanitizer run-time should not be\"\n         \" instrumented by AddressSanitizer\"\n #endif\n@@ -89,6 +89,10 @@\n # endif\n #endif\n \n+#ifndef ASAN_USE_PREINIT_ARRAY\n+# define ASAN_USE_PREINIT_ARRAY (ASAN_LINUX && !ASAN_ANDROID)\n+#endif\n+\n // All internal functions in asan reside inside the __asan namespace\n // to avoid namespace collisions with the user programs.\n // Seperate namespace also makes it simpler to distinguish the asan run-time"}, {"sha": "dd2657df1e25277506bc30eb252435690c872426", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 105, "deletions": 5, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -86,6 +86,39 @@ extern \"C\"\n void __asan_init();\n \n static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n+LowLevelAllocator allocator_for_env;\n+\n+// Change the value of the env var |name|, leaking the original value.\n+// If |name_value| is NULL, the variable is deleted from the environment,\n+// otherwise the corresponding \"NAME=value\" string is replaced with\n+// |name_value|.\n+void LeakyResetEnv(const char *name, const char *name_value) {\n+  char ***env_ptr = _NSGetEnviron();\n+  CHECK(env_ptr);\n+  char **environ = *env_ptr;\n+  CHECK(environ);\n+  uptr name_len = internal_strlen(name);\n+  while (*environ != 0) {\n+    uptr len = internal_strlen(*environ);\n+    if (len > name_len) {\n+      const char *p = *environ;\n+      if (!internal_memcmp(p, name, name_len) && p[name_len] == '=') {\n+        // Match.\n+        if (name_value) {\n+          // Replace the old value with the new one.\n+          *environ = const_cast<char*>(name_value);\n+        } else {\n+          // Shift the subsequent pointers back.\n+          char **del = environ;\n+          do {\n+            del[0] = del[1];\n+          } while (*del++);\n+        }\n+      }\n+    }\n+    environ++;\n+  }\n+}\n \n void MaybeReexec() {\n   if (!flags()->allow_reexec) return;\n@@ -94,24 +127,91 @@ void MaybeReexec() {\n   // ourselves.\n   Dl_info info;\n   CHECK(dladdr((void*)((uptr)__asan_init), &info));\n-  const char *dyld_insert_libraries = GetEnv(kDyldInsertLibraries);\n+  char *dyld_insert_libraries =\n+      const_cast<char*>(GetEnv(kDyldInsertLibraries));\n+  uptr old_env_len = dyld_insert_libraries ?\n+      internal_strlen(dyld_insert_libraries) : 0;\n+  uptr fname_len = internal_strlen(info.dli_fname);\n   if (!dyld_insert_libraries ||\n       !REAL(strstr)(dyld_insert_libraries, info.dli_fname)) {\n     // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n     // library.\n     char program_name[1024];\n     uint32_t buf_size = sizeof(program_name);\n     _NSGetExecutablePath(program_name, &buf_size);\n-    // Ok to use setenv() since the wrappers don't depend on the value of\n-    // asan_inited.\n-    setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n+    char *new_env = const_cast<char*>(info.dli_fname);\n+    if (dyld_insert_libraries) {\n+      // Append the runtime dylib name to the existing value of\n+      // DYLD_INSERT_LIBRARIES.\n+      new_env = (char*)allocator_for_env.Allocate(old_env_len + fname_len + 2);\n+      internal_strncpy(new_env, dyld_insert_libraries, old_env_len);\n+      new_env[old_env_len] = ':';\n+      // Copy fname_len and add a trailing zero.\n+      internal_strncpy(new_env + old_env_len + 1, info.dli_fname,\n+                       fname_len + 1);\n+      // Ok to use setenv() since the wrappers don't depend on the value of\n+      // asan_inited.\n+      setenv(kDyldInsertLibraries, new_env, /*overwrite*/1);\n+    } else {\n+      // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n+      setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n+    }\n     if (flags()->verbosity >= 1) {\n       Report(\"exec()-ing the program with\\n\");\n-      Report(\"%s=%s\\n\", kDyldInsertLibraries, info.dli_fname);\n+      Report(\"%s=%s\\n\", kDyldInsertLibraries, new_env);\n       Report(\"to enable ASan wrappers.\\n\");\n       Report(\"Set ASAN_OPTIONS=allow_reexec=0 to disable this.\\n\");\n     }\n     execv(program_name, *_NSGetArgv());\n+  } else {\n+    // DYLD_INSERT_LIBRARIES is set and contains the runtime library.\n+    if (old_env_len == fname_len) {\n+      // It's just the runtime library name - fine to unset the variable.\n+      LeakyResetEnv(kDyldInsertLibraries, NULL);\n+    } else {\n+      uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n+      // Allocate memory to hold the previous env var name, its value, the '='\n+      // sign and the '\\0' char.\n+      char *new_env = (char*)allocator_for_env.Allocate(\n+          old_env_len + 2 + env_name_len);\n+      CHECK(new_env);\n+      internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n+      internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n+      new_env[env_name_len] = '=';\n+      char *new_env_pos = new_env + env_name_len + 1;\n+\n+      // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n+      char *piece_start = dyld_insert_libraries;\n+      char *piece_end = NULL;\n+      char *old_env_end = dyld_insert_libraries + old_env_len;\n+      do {\n+        if (piece_start[0] == ':') piece_start++;\n+        piece_end =  REAL(strchr)(piece_start, ':');\n+        if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n+        if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n+        uptr piece_len = piece_end - piece_start;\n+\n+        // If the current piece isn't the runtime library name,\n+        // append it to new_env.\n+        if ((piece_len != fname_len) ||\n+            (internal_strncmp(piece_start, info.dli_fname, fname_len) != 0)) {\n+          if (new_env_pos != new_env + env_name_len + 1) {\n+            new_env_pos[0] = ':';\n+            new_env_pos++;\n+          }\n+          internal_strncpy(new_env_pos, piece_start, piece_len);\n+        }\n+        // Move on to the next piece.\n+        new_env_pos += piece_len;\n+        piece_start = piece_end;\n+      } while (piece_start < old_env_end);\n+\n+      // Can't use setenv() here, because it requires the allocator to be\n+      // initialized.\n+      // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n+      // a separate function called after InitializeAllocator().\n+      LeakyResetEnv(kDyldInsertLibraries, new_env);\n+    }\n   }\n }\n "}, {"sha": "df952363893ea66c0447f5da5b2b65ce3bd820a4", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 103, "deletions": 9, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -1,7 +1,5 @@\n //===-- asan_mapping.h ------------------------------------------*- C++ -*-===//\n //\n-//                     The LLVM Compiler Infrastructure\n-//\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n //\n@@ -18,6 +16,37 @@\n \n // The full explanation of the memory mapping could be found here:\n // http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n+//\n+// Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:\n+// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||\n+// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||\n+// || `[0x00008fff7000, 0x02008fff6fff]` || ShadowGap  ||\n+// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||\n+// || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||\n+//\n+// When SHADOW_OFFSET is zero (-pie):\n+// || `[0x100000000000, 0x7fffffffffff]` || HighMem    ||\n+// || `[0x020000000000, 0x0fffffffffff]` || HighShadow ||\n+// || `[0x000000040000, 0x01ffffffffff]` || ShadowGap  ||\n+//\n+// Special case when something is already mapped between\n+// 0x003000000000 and 0x004000000000 (e.g. when prelink is installed):\n+// || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||\n+// || `[0x02008fff7000, 0x10007fff7fff]` || HighShadow ||\n+// || `[0x004000000000, 0x02008fff6fff]` || ShadowGap3 ||\n+// || `[0x003000000000, 0x003fffffffff]` || MidMem     ||\n+// || `[0x00087fff8000, 0x002fffffffff]` || ShadowGap2 ||\n+// || `[0x00067fff8000, 0x00087fff7fff]` || MidShadow  ||\n+// || `[0x00008fff7000, 0x00067fff7fff]` || ShadowGap  ||\n+// || `[0x00007fff8000, 0x00008fff6fff]` || LowShadow  ||\n+// || `[0x000000000000, 0x00007fff7fff]` || LowMem     ||\n+//\n+// Default Linux/i386 mapping:\n+// || `[0x40000000, 0xffffffff]` || HighMem    ||\n+// || `[0x28000000, 0x3fffffff]` || HighShadow ||\n+// || `[0x24000000, 0x27ffffff]` || ShadowGap  ||\n+// || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x1fffffff]` || LowMem     ||\n \n #if ASAN_FLEXIBLE_MAPPING_AND_OFFSET == 1\n extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_scale;\n@@ -36,7 +65,11 @@ extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n #   if defined(__powerpc64__)\n #    define SHADOW_OFFSET (1ULL << 41)\n #   else\n-#    define SHADOW_OFFSET (1ULL << 44)\n+#    if ASAN_MAC\n+#     define SHADOW_OFFSET (1ULL << 44)\n+#    else\n+#     define SHADOW_OFFSET 0x7fff8000ULL\n+#    endif\n #   endif\n #  endif\n # endif\n@@ -57,49 +90,105 @@ extern SANITIZER_INTERFACE_ATTRIBUTE uptr __asan_mapping_offset;\n #define kHighShadowBeg  MEM_TO_SHADOW(kHighMemBeg)\n #define kHighShadowEnd  MEM_TO_SHADOW(kHighMemEnd)\n \n+# define kMidShadowBeg MEM_TO_SHADOW(kMidMemBeg)\n+# define kMidShadowEnd MEM_TO_SHADOW(kMidMemEnd)\n+\n // With the zero shadow base we can not actually map pages starting from 0.\n // This constant is somewhat arbitrary.\n #define kZeroBaseShadowStart (1 << 18)\n \n #define kShadowGapBeg   (kLowShadowEnd ? kLowShadowEnd + 1 \\\n                                        : kZeroBaseShadowStart)\n-#define kShadowGapEnd   (kHighShadowBeg - 1)\n+#define kShadowGapEnd   ((kMidMemBeg ? kMidShadowBeg : kHighShadowBeg) - 1)\n+\n+#define kShadowGap2Beg (kMidMemBeg ? kMidShadowEnd + 1 : 0)\n+#define kShadowGap2End (kMidMemBeg ? kMidMemBeg - 1 : 0)\n+\n+#define kShadowGap3Beg (kMidMemBeg ? kMidMemEnd + 1 : 0)\n+#define kShadowGap3End (kMidMemBeg ? kHighShadowBeg - 1 : 0)\n+\n+#define DO_ASAN_MAPPING_PROFILE 0  // Set to 1 to profile the functions below.\n+\n+#if DO_ASAN_MAPPING_PROFILE\n+# define PROFILE_ASAN_MAPPING() AsanMappingProfile[__LINE__]++;\n+#else\n+# define PROFILE_ASAN_MAPPING()\n+#endif\n+\n+// If 1, all shadow boundaries are constants.\n+// Don't set to 1 other than for testing.\n+#define ASAN_FIXED_MAPPING 0\n \n namespace __asan {\n \n+extern uptr AsanMappingProfile[];\n+\n+#if ASAN_FIXED_MAPPING\n+// Fixed mapping for 64-bit Linux. Mostly used for performance comparison\n+// with non-fixed mapping. As of r175253 (Feb 2013) the performance\n+// difference between fixed and non-fixed mapping is below the noise level.\n+static uptr kHighMemEnd = 0x7fffffffffffULL;\n+static uptr kMidMemBeg =    0x3000000000ULL;\n+static uptr kMidMemEnd =    0x3fffffffffULL;\n+#else\n SANITIZER_INTERFACE_ATTRIBUTE\n-extern uptr kHighMemEnd;  // Initialized in __asan_init.\n+extern uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;  // Initialized in __asan_init.\n+#endif\n \n static inline bool AddrIsInLowMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n   return a < kLowMemEnd;\n }\n \n static inline bool AddrIsInLowShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n   return a >= kLowShadowBeg && a <= kLowShadowEnd;\n }\n \n static inline bool AddrIsInHighMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n   return a >= kHighMemBeg && a <= kHighMemEnd;\n }\n \n+static inline bool AddrIsInMidMem(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return kMidMemBeg && a >= kMidMemBeg && a <= kMidMemEnd;\n+}\n+\n static inline bool AddrIsInMem(uptr a) {\n-  return AddrIsInLowMem(a) || AddrIsInHighMem(a);\n+  PROFILE_ASAN_MAPPING();\n+  return AddrIsInLowMem(a) || AddrIsInMidMem(a) || AddrIsInHighMem(a);\n }\n \n static inline uptr MemToShadow(uptr p) {\n+  PROFILE_ASAN_MAPPING();\n   CHECK(AddrIsInMem(p));\n   return MEM_TO_SHADOW(p);\n }\n \n static inline bool AddrIsInHighShadow(uptr a) {\n-  return a >= kHighShadowBeg && a <=  kHighMemEnd;\n+  PROFILE_ASAN_MAPPING();\n+  return a >= kHighShadowBeg && a <= kHighMemEnd;\n+}\n+\n+static inline bool AddrIsInMidShadow(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  return kMidMemBeg && a >= kMidShadowBeg && a <= kMidMemEnd;\n }\n \n static inline bool AddrIsInShadow(uptr a) {\n-  return AddrIsInLowShadow(a) || AddrIsInHighShadow(a);\n+  PROFILE_ASAN_MAPPING();\n+  return AddrIsInLowShadow(a) || AddrIsInMidShadow(a) || AddrIsInHighShadow(a);\n }\n \n static inline bool AddrIsInShadowGap(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  if (kMidMemBeg) {\n+    if (a <= kShadowGapEnd)\n+      return SHADOW_OFFSET == 0 || a >= kShadowGapBeg;\n+    return (a >= kShadowGap2Beg && a <= kShadowGap2End) ||\n+           (a >= kShadowGap3Beg && a <= kShadowGap3End);\n+  }\n   // In zero-based shadow mode we treat addresses near zero as addresses\n   // in shadow gap as well.\n   if (SHADOW_OFFSET == 0)\n@@ -108,12 +197,14 @@ static inline bool AddrIsInShadowGap(uptr a) {\n }\n \n static inline bool AddrIsAlignedByGranularity(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n   return (a & (SHADOW_GRANULARITY - 1)) == 0;\n }\n \n static inline bool AddressIsPoisoned(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n   const uptr kAccessSize = 1;\n-  u8 *shadow_address = (u8*)MemToShadow(a);\n+  u8 *shadow_address = (u8*)MEM_TO_SHADOW(a);\n   s8 shadow_value = *shadow_address;\n   if (shadow_value) {\n     u8 last_accessed_byte = (a & (SHADOW_GRANULARITY - 1))\n@@ -123,6 +214,9 @@ static inline bool AddressIsPoisoned(uptr a) {\n   return false;\n }\n \n+// Must be after all calls to PROFILE_ASAN_MAPPING().\n+static const uptr kAsanMappingProfileSize = __LINE__;\n+\n }  // namespace __asan\n \n #endif  // ASAN_MAPPING_H"}, {"sha": "13e94c421b5d08dc705a47b33502c76a76e506dc", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -433,9 +433,9 @@ class ScopedInErrorReport {\n         // an error report will finish doing it.\n         SleepForSeconds(Max(100, flags()->sleep_before_dying + 1));\n       }\n-      // If we're still not dead for some reason, use raw Exit() instead of\n+      // If we're still not dead for some reason, use raw _exit() instead of\n       // Die() to bypass any additional checks.\n-      Exit(flags()->exitcode);\n+      internal__exit(flags()->exitcode);\n     }\n     ASAN_ON_ERROR();\n     reporting_thread_tid = asanThreadRegistry().GetCurrentTidOrInvalid();"}, {"sha": "e22fcd34fb12d93f00e98353f3a99c737a38ac1f", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 134, "deletions": 41, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -25,6 +25,8 @@\n \n namespace __asan {\n \n+uptr AsanMappingProfile[kAsanMappingProfileSize];\n+\n static void AsanDie() {\n   static atomic_uint32_t num_calls;\n   if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) != 0) {\n@@ -35,13 +37,19 @@ static void AsanDie() {\n     Report(\"Sleeping for %d second(s)\\n\", flags()->sleep_before_dying);\n     SleepForSeconds(flags()->sleep_before_dying);\n   }\n-  if (flags()->unmap_shadow_on_exit)\n-    UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n+  if (flags()->unmap_shadow_on_exit) {\n+    if (kMidMemBeg) {\n+      UnmapOrDie((void*)kLowShadowBeg, kMidMemBeg - kLowShadowBeg);\n+      UnmapOrDie((void*)kMidMemEnd, kHighShadowEnd - kMidMemEnd);\n+    } else {\n+      UnmapOrDie((void*)kLowShadowBeg, kHighShadowEnd - kLowShadowBeg);\n+    }\n+  }\n   if (death_callback)\n     death_callback();\n   if (flags()->abort_on_error)\n     Abort();\n-  Exit(flags()->exitcode);\n+  internal__exit(flags()->exitcode);\n }\n \n static void AsanCheckFailed(const char *file, int line, const char *cond,\n@@ -66,6 +74,17 @@ static const char *MaybeCallAsanDefaultOptions() {\n   return (&__asan_default_options) ? __asan_default_options() : \"\";\n }\n \n+static const char *MaybeUseAsanDefaultOptionsCompileDefiniton() {\n+#ifdef ASAN_DEFAULT_OPTIONS\n+// Stringize the macro value.\n+# define ASAN_STRINGIZE(x) #x\n+# define ASAN_STRINGIZE_OPTIONS(options) ASAN_STRINGIZE(options)\n+  return ASAN_STRINGIZE_OPTIONS(ASAN_DEFAULT_OPTIONS);\n+#else\n+  return \"\";\n+#endif\n+}\n+\n static void ParseFlagsFromString(Flags *f, const char *str) {\n   ParseFlag(str, &f->quarantine_size, \"quarantine_size\");\n   ParseFlag(str, &f->symbolize, \"symbolize\");\n@@ -146,6 +165,9 @@ void InitializeFlags(Flags *f, const char *env) {\n   f->alloc_dealloc_mismatch = true;\n   f->use_stack_depot = true;  // Only affects allocator2.\n \n+  // Override from compile definition.\n+  ParseFlagsFromString(f, MaybeUseAsanDefaultOptionsCompileDefiniton());\n+\n   // Override from user-specified string.\n   ParseFlagsFromString(f, MaybeCallAsanDefaultOptions());\n   if (flags()->verbosity) {\n@@ -161,7 +183,10 @@ void InitializeFlags(Flags *f, const char *env) {\n int asan_inited;\n bool asan_init_is_running;\n void (*death_callback)(void);\n-uptr kHighMemEnd;\n+\n+#if !ASAN_FIXED_MAPPING\n+uptr kHighMemEnd, kMidMemBeg, kMidMemEnd;\n+#endif\n \n // -------------------------- Misc ---------------- {{{1\n void ShowStatsAndAbort() {\n@@ -209,6 +234,17 @@ ASAN_REPORT_ERROR(store, true, 4)\n ASAN_REPORT_ERROR(store, true, 8)\n ASAN_REPORT_ERROR(store, true, 16)\n \n+#define ASAN_REPORT_ERROR_N(type, is_write)                    \\\n+extern \"C\" NOINLINE INTERFACE_ATTRIBUTE                        \\\n+void __asan_report_ ## type ## _n(uptr addr, uptr size);       \\\n+void __asan_report_ ## type ## _n(uptr addr, uptr size) {      \\\n+  GET_CALLER_PC_BP_SP;                                         \\\n+  __asan_report_error(pc, bp, sp, addr, is_write, size);       \\\n+}\n+\n+ASAN_REPORT_ERROR_N(load, false)\n+ASAN_REPORT_ERROR_N(store, true)\n+\n // Force the linker to keep the symbols for various ASan interface functions.\n // We want to keep those in the executable in order to let the instrumented\n // dynamic libraries access the symbol even if it is not used by the executable\n@@ -259,9 +295,15 @@ static NOINLINE void force_interface_symbols() {\n static void asan_atexit() {\n   Printf(\"AddressSanitizer exit stats:\\n\");\n   __asan_print_accumulated_stats();\n+  // Print AsanMappingProfile.\n+  for (uptr i = 0; i < kAsanMappingProfileSize; i++) {\n+    if (AsanMappingProfile[i] == 0) continue;\n+    Printf(\"asan_mapping.h:%zd -- %zd\\n\", i, AsanMappingProfile[i]);\n+  }\n }\n \n static void InitializeHighMemEnd() {\n+#if !ASAN_FIXED_MAPPING\n #if SANITIZER_WORDSIZE == 64\n # if defined(__powerpc64__)\n   // FIXME:\n@@ -277,6 +319,58 @@ static void InitializeHighMemEnd() {\n #else  // SANITIZER_WORDSIZE == 32\n   kHighMemEnd = (1ULL << 32) - 1;  // 0xffffffff;\n #endif  // SANITIZER_WORDSIZE\n+#endif  // !ASAN_FIXED_MAPPING\n+}\n+\n+static void ProtectGap(uptr a, uptr size) {\n+  CHECK_EQ(a, (uptr)Mprotect(a, size));\n+}\n+\n+static void PrintAddressSpaceLayout() {\n+  Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n+         (void*)kHighMemBeg, (void*)kHighMemEnd);\n+  Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n+         (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n+  if (kMidMemBeg) {\n+    Printf(\"|| `[%p, %p]` || ShadowGap3 ||\\n\",\n+           (void*)kShadowGap3Beg, (void*)kShadowGap3End);\n+    Printf(\"|| `[%p, %p]` || MidMem     ||\\n\",\n+           (void*)kMidMemBeg, (void*)kMidMemEnd);\n+    Printf(\"|| `[%p, %p]` || ShadowGap2 ||\\n\",\n+           (void*)kShadowGap2Beg, (void*)kShadowGap2End);\n+    Printf(\"|| `[%p, %p]` || MidShadow  ||\\n\",\n+           (void*)kMidShadowBeg, (void*)kMidShadowEnd);\n+  }\n+  Printf(\"|| `[%p, %p]` || ShadowGap  ||\\n\",\n+         (void*)kShadowGapBeg, (void*)kShadowGapEnd);\n+  if (kLowShadowBeg) {\n+    Printf(\"|| `[%p, %p]` || LowShadow  ||\\n\",\n+           (void*)kLowShadowBeg, (void*)kLowShadowEnd);\n+    Printf(\"|| `[%p, %p]` || LowMem     ||\\n\",\n+           (void*)kLowMemBeg, (void*)kLowMemEnd);\n+  }\n+  Printf(\"MemToShadow(shadow): %p %p %p %p\",\n+         (void*)MEM_TO_SHADOW(kLowShadowBeg),\n+         (void*)MEM_TO_SHADOW(kLowShadowEnd),\n+         (void*)MEM_TO_SHADOW(kHighShadowBeg),\n+         (void*)MEM_TO_SHADOW(kHighShadowEnd));\n+  if (kMidMemBeg) {\n+    Printf(\" %p %p\",\n+           (void*)MEM_TO_SHADOW(kMidShadowBeg),\n+           (void*)MEM_TO_SHADOW(kMidShadowEnd));\n+  }\n+  Printf(\"\\n\");\n+  Printf(\"red_zone=%zu\\n\", (uptr)flags()->redzone);\n+  Printf(\"malloc_context_size=%zu\\n\", (uptr)flags()->malloc_context_size);\n+\n+  Printf(\"SHADOW_SCALE: %zx\\n\", (uptr)SHADOW_SCALE);\n+  Printf(\"SHADOW_GRANULARITY: %zx\\n\", (uptr)SHADOW_GRANULARITY);\n+  Printf(\"SHADOW_OFFSET: %zx\\n\", (uptr)SHADOW_OFFSET);\n+  CHECK(SHADOW_SCALE >= 3 && SHADOW_SCALE <= 7);\n+  if (kMidMemBeg)\n+    CHECK(kMidShadowBeg > kLowShadowEnd &&\n+          kMidMemBeg > kMidShadowEnd &&\n+          kHighShadowBeg > kMidMemEnd);\n }\n \n }  // namespace __asan\n@@ -352,49 +446,48 @@ void __asan_init() {\n   ReplaceSystemMalloc();\n   ReplaceOperatorsNewAndDelete();\n \n-  if (flags()->verbosity) {\n-    Printf(\"|| `[%p, %p]` || HighMem    ||\\n\",\n-           (void*)kHighMemBeg, (void*)kHighMemEnd);\n-    Printf(\"|| `[%p, %p]` || HighShadow ||\\n\",\n-           (void*)kHighShadowBeg, (void*)kHighShadowEnd);\n-    Printf(\"|| `[%p, %p]` || ShadowGap  ||\\n\",\n-           (void*)kShadowGapBeg, (void*)kShadowGapEnd);\n-    Printf(\"|| `[%p, %p]` || LowShadow  ||\\n\",\n-           (void*)kLowShadowBeg, (void*)kLowShadowEnd);\n-    Printf(\"|| `[%p, %p]` || LowMem     ||\\n\",\n-           (void*)kLowMemBeg, (void*)kLowMemEnd);\n-    Printf(\"MemToShadow(shadow): %p %p %p %p\\n\",\n-           (void*)MEM_TO_SHADOW(kLowShadowBeg),\n-           (void*)MEM_TO_SHADOW(kLowShadowEnd),\n-           (void*)MEM_TO_SHADOW(kHighShadowBeg),\n-           (void*)MEM_TO_SHADOW(kHighShadowEnd));\n-    Printf(\"red_zone=%zu\\n\", (uptr)flags()->redzone);\n-    Printf(\"malloc_context_size=%zu\\n\", (uptr)flags()->malloc_context_size);\n-\n-    Printf(\"SHADOW_SCALE: %zx\\n\", (uptr)SHADOW_SCALE);\n-    Printf(\"SHADOW_GRANULARITY: %zx\\n\", (uptr)SHADOW_GRANULARITY);\n-    Printf(\"SHADOW_OFFSET: %zx\\n\", (uptr)SHADOW_OFFSET);\n-    CHECK(SHADOW_SCALE >= 3 && SHADOW_SCALE <= 7);\n+  uptr shadow_start = kLowShadowBeg;\n+  if (kLowShadowBeg) shadow_start -= GetMmapGranularity();\n+  uptr shadow_end = kHighShadowEnd;\n+  bool full_shadow_is_available =\n+      MemoryRangeIsAvailable(shadow_start, shadow_end);\n+\n+#if ASAN_LINUX && defined(__x86_64__) && !ASAN_FIXED_MAPPING\n+  if (!full_shadow_is_available) {\n+    kMidMemBeg = kLowMemEnd < 0x3000000000ULL ? 0x3000000000ULL : 0;\n+    kMidMemEnd = kLowMemEnd < 0x3000000000ULL ? 0x3fffffffffULL : 0;\n   }\n+#endif\n+\n+  if (flags()->verbosity)\n+    PrintAddressSpaceLayout();\n \n   if (flags()->disable_core) {\n     DisableCoreDumper();\n   }\n \n-  uptr shadow_start = kLowShadowBeg;\n-  if (kLowShadowBeg > 0) shadow_start -= GetMmapGranularity();\n-  uptr shadow_end = kHighShadowEnd;\n-  if (MemoryRangeIsAvailable(shadow_start, shadow_end)) {\n-    if (kLowShadowBeg != kLowShadowEnd) {\n-      // mmap the low shadow plus at least one page.\n-      ReserveShadowMemoryRange(kLowShadowBeg - GetMmapGranularity(),\n-                               kLowShadowEnd);\n-    }\n+  if (full_shadow_is_available) {\n+    // mmap the low shadow plus at least one page at the left.\n+    if (kLowShadowBeg)\n+      ReserveShadowMemoryRange(shadow_start, kLowShadowEnd);\n+    // mmap the high shadow.\n+    ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n+    // protect the gap.\n+    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+  } else if (kMidMemBeg &&\n+      MemoryRangeIsAvailable(shadow_start, kMidMemBeg - 1) &&\n+      MemoryRangeIsAvailable(kMidMemEnd + 1, shadow_end)) {\n+    CHECK(kLowShadowBeg != kLowShadowEnd);\n+    // mmap the low shadow plus at least one page at the left.\n+    ReserveShadowMemoryRange(shadow_start, kLowShadowEnd);\n+    // mmap the mid shadow.\n+    ReserveShadowMemoryRange(kMidShadowBeg, kMidShadowEnd);\n     // mmap the high shadow.\n     ReserveShadowMemoryRange(kHighShadowBeg, kHighShadowEnd);\n-    // protect the gap\n-    void *prot = Mprotect(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n-    CHECK(prot == (void*)kShadowGapBeg);\n+    // protect the gaps.\n+    ProtectGap(kShadowGapBeg, kShadowGapEnd - kShadowGapBeg + 1);\n+    ProtectGap(kShadowGap2Beg, kShadowGap2End - kShadowGap2Beg + 1);\n+    ProtectGap(kShadowGap3Beg, kShadowGap3End - kShadowGap3Beg + 1);\n   } else {\n     Report(\"Shadow memory range interleaves with an existing memory mapping. \"\n            \"ASan cannot proceed correctly. ABORTING.\\n\");\n@@ -427,12 +520,12 @@ void __asan_init() {\n   }\n }\n \n-#if defined(ASAN_USE_PREINIT_ARRAY)\n+#if ASAN_USE_PREINIT_ARRAY\n   // On Linux, we force __asan_init to be called before anyone else\n   // by placing it into .preinit_array section.\n   // FIXME: do we have anything like this on Mac?\n   __attribute__((section(\".preinit_array\")))\n-    typeof(__asan_init) *__asan_preinit =__asan_init;\n+  void (*__asan_preinit)(void) =__asan_init;\n #elif defined(_WIN32) && defined(_DLL)\n   // On Windows, when using dynamic CRT (/MD), we can put a pointer\n   // to __asan_init into the global list of C initializers."}, {"sha": "727edf2b43b94e4dc9ab72ce9a5ac9da079056a9", "filename": "libsanitizer/asan/dynamic/asan_interceptors_dynamic.cc", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fdynamic%2Fasan_interceptors_dynamic.cc?ref=22deefcbb7c556a99fd72c1fb92a3a35b6dfd4b4", "patch": "@@ -1,114 +0,0 @@\n-//===-- asan_interceptors_dynamic.cc --------------------------------------===//\n-//\n-// This file is distributed under the University of Illinois Open Source\n-// License. See LICENSE.TXT for details.\n-//\n-//===----------------------------------------------------------------------===//\n-//\n-// This file is a part of AddressSanitizer, an address sanity checker.\n-//\n-// __DATA,__interpose section of the dynamic runtime library for Mac OS.\n-//===----------------------------------------------------------------------===//\n-\n-#if defined(__APPLE__)\n-\n-#include \"../asan_interceptors.h\"\n-#include \"../asan_intercepted_functions.h\"\n-\n-namespace __asan {\n-\n-#define INTERPOSE_FUNCTION(function) \\\n-    { reinterpret_cast<const uptr>(WRAP(function)), \\\n-      reinterpret_cast<const uptr>(function) }\n-\n-#define INTERPOSE_FUNCTION_2(function, wrapper) \\\n-    { reinterpret_cast<const uptr>(wrapper), \\\n-      reinterpret_cast<const uptr>(function) }\n-\n-struct interpose_substitution {\n-  const uptr replacement;\n-  const uptr original;\n-};\n-\n-__attribute__((used))\n-const interpose_substitution substitutions[]\n-    __attribute__((section(\"__DATA, __interpose\"))) = {\n-  INTERPOSE_FUNCTION(strlen),\n-  INTERPOSE_FUNCTION(memcmp),\n-  INTERPOSE_FUNCTION(memcpy),\n-  INTERPOSE_FUNCTION(memmove),\n-  INTERPOSE_FUNCTION(memset),\n-  INTERPOSE_FUNCTION(strchr),\n-  INTERPOSE_FUNCTION(strcat),\n-  INTERPOSE_FUNCTION(strncat),\n-  INTERPOSE_FUNCTION(strcpy),\n-  INTERPOSE_FUNCTION(strncpy),\n-  INTERPOSE_FUNCTION(pthread_create),\n-  INTERPOSE_FUNCTION(longjmp),\n-#if ASAN_INTERCEPT__LONGJMP\n-  INTERPOSE_FUNCTION(_longjmp),\n-#endif\n-#if ASAN_INTERCEPT_SIGLONGJMP\n-  INTERPOSE_FUNCTION(siglongjmp),\n-#endif\n-#if ASAN_INTERCEPT_STRDUP\n-  INTERPOSE_FUNCTION(strdup),\n-#endif\n-#if ASAN_INTERCEPT_STRNLEN\n-  INTERPOSE_FUNCTION(strnlen),\n-#endif\n-#if ASAN_INTERCEPT_INDEX\n-  INTERPOSE_FUNCTION_2(index, WRAP(strchr)),\n-#endif\n-  INTERPOSE_FUNCTION(strcmp),\n-  INTERPOSE_FUNCTION(strncmp),\n-#if ASAN_INTERCEPT_STRCASECMP_AND_STRNCASECMP\n-  INTERPOSE_FUNCTION(strcasecmp),\n-  INTERPOSE_FUNCTION(strncasecmp),\n-#endif\n-  INTERPOSE_FUNCTION(atoi),\n-  INTERPOSE_FUNCTION(atol),\n-  INTERPOSE_FUNCTION(strtol),\n-#if ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n-  INTERPOSE_FUNCTION(atoll),\n-  INTERPOSE_FUNCTION(strtoll),\n-#endif\n-#if ASAN_INTERCEPT_MLOCKX\n-  INTERPOSE_FUNCTION(mlock),\n-  INTERPOSE_FUNCTION(munlock),\n-  INTERPOSE_FUNCTION(mlockall),\n-  INTERPOSE_FUNCTION(munlockall),\n-#endif\n-  INTERPOSE_FUNCTION(dispatch_async_f),\n-  INTERPOSE_FUNCTION(dispatch_sync_f),\n-  INTERPOSE_FUNCTION(dispatch_after_f),\n-  INTERPOSE_FUNCTION(dispatch_barrier_async_f),\n-  INTERPOSE_FUNCTION(dispatch_group_async_f),\n-#ifndef MISSING_BLOCKS_SUPPORT\n-  INTERPOSE_FUNCTION(dispatch_group_async),\n-  INTERPOSE_FUNCTION(dispatch_async),\n-  INTERPOSE_FUNCTION(dispatch_after),\n-  INTERPOSE_FUNCTION(dispatch_source_set_event_handler),\n-  INTERPOSE_FUNCTION(dispatch_source_set_cancel_handler),\n-#endif\n-  INTERPOSE_FUNCTION(signal),\n-  INTERPOSE_FUNCTION(sigaction),\n-\n-  INTERPOSE_FUNCTION(malloc_create_zone),\n-  INTERPOSE_FUNCTION(malloc_default_zone),\n-  INTERPOSE_FUNCTION(malloc_default_purgeable_zone),\n-  INTERPOSE_FUNCTION(malloc_make_purgeable),\n-  INTERPOSE_FUNCTION(malloc_make_nonpurgeable),\n-  INTERPOSE_FUNCTION(malloc_set_zone_name),\n-  INTERPOSE_FUNCTION(malloc),\n-  INTERPOSE_FUNCTION(free),\n-  INTERPOSE_FUNCTION(realloc),\n-  INTERPOSE_FUNCTION(calloc),\n-  INTERPOSE_FUNCTION(valloc),\n-  INTERPOSE_FUNCTION(malloc_good_size),\n-  INTERPOSE_FUNCTION(posix_memalign),\n-};\n-\n-}  // namespace __asan\n-\n-#endif  // __APPLE__"}, {"sha": "0016339e48648c0896217f65a8e983f2a0d0c915", "filename": "libsanitizer/include/sanitizer/asan_interface.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fasan_interface.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -35,8 +35,8 @@ extern \"C\" {\n   // (un)poison memory in the same memory region simultaneously.\n   void __asan_unpoison_memory_region(void const volatile *addr, size_t size);\n \n-  // User code should use macro instead of functions.\n-#if __has_feature(address_sanitizer)\n+// User code should use macros instead of functions.\n+#if __has_feature(address_sanitizer) || defined(__SANITIZE_ADDRESS__)\n #define ASAN_POISON_MEMORY_REGION(addr, size) \\\n   __asan_poison_memory_region((addr), (size))\n #define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\"}, {"sha": "c218b5b565414e158a428f4595e148ff87cbe026", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -14,6 +14,11 @@\n #include <stddef.h>\n #include <stdint.h>\n \n+// GCC does not understand __has_feature.\n+#if !defined(__has_feature)\n+# define __has_feature(x) 0\n+#endif\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif"}, {"sha": "c53a3c6bfc5ae65932eef75c144fbc4106afb3b8", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -17,6 +17,7 @@ sanitizer_common_files = \\\n         sanitizer_libc.cc \\\n         sanitizer_linux.cc \\\n         sanitizer_mac.cc \\\n+\tsanitizer_platform_limits_posix.cc \\\n         sanitizer_posix.cc \\\n         sanitizer_printf.cc \\\n         sanitizer_stackdepot.cc \\"}, {"sha": "8e29243276558984bf324f7949058edf3aa17f2e", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -57,11 +57,12 @@ LTLIBRARIES = $(noinst_LTLIBRARIES)\n libsanitizer_common_la_LIBADD =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_flags.lo sanitizer_libc.lo sanitizer_linux.lo \\\n-\tsanitizer_mac.lo sanitizer_posix.lo sanitizer_printf.lo \\\n-\tsanitizer_stackdepot.lo sanitizer_stacktrace.lo \\\n-\tsanitizer_symbolizer.lo sanitizer_symbolizer_itanium.lo \\\n-\tsanitizer_symbolizer_linux.lo sanitizer_symbolizer_mac.lo \\\n-\tsanitizer_symbolizer_win.lo sanitizer_win.lo\n+\tsanitizer_mac.lo sanitizer_platform_limits_posix.lo \\\n+\tsanitizer_posix.lo sanitizer_printf.lo sanitizer_stackdepot.lo \\\n+\tsanitizer_stacktrace.lo sanitizer_symbolizer.lo \\\n+\tsanitizer_symbolizer_itanium.lo sanitizer_symbolizer_linux.lo \\\n+\tsanitizer_symbolizer_mac.lo sanitizer_symbolizer_win.lo \\\n+\tsanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@\n@@ -230,6 +231,7 @@ sanitizer_common_files = \\\n         sanitizer_libc.cc \\\n         sanitizer_linux.cc \\\n         sanitizer_mac.cc \\\n+\tsanitizer_platform_limits_posix.cc \\\n         sanitizer_posix.cc \\\n         sanitizer_printf.cc \\\n         sanitizer_stackdepot.cc \\\n@@ -340,6 +342,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_posix.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_printf.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_stackdepot.Plo@am__quote@"}, {"sha": "f8d2d0e3fe5cff068868f4be089761d15aceadbb", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -43,7 +43,7 @@ void NORETURN Die() {\n   if (DieCallback) {\n     DieCallback();\n   }\n-  Exit(1);\n+  internal__exit(1);\n }\n \n static CheckFailedCallbackType CheckFailedCallback;"}, {"sha": "302dc7427692a9687289b255d979ea4e1f6e696e", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -124,6 +124,7 @@ void DumpProcessMap();\n bool FileExists(const char *filename);\n const char *GetEnv(const char *name);\n const char *GetPwd();\n+u32 GetUid();\n void ReExec();\n bool StackSizeIsUnlimited();\n void SetStackSizeLimitInBytes(uptr limit);\n@@ -137,7 +138,6 @@ void SortArray(uptr *array, uptr size);\n \n // Exit\n void NORETURN Abort();\n-void NORETURN Exit(int exitcode);\n void NORETURN Die();\n void NORETURN SANITIZER_INTERFACE_ATTRIBUTE\n CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);"}, {"sha": "af27603ebdde3741993bf2067e02c357dd3f8018", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 101, "deletions": 2, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -124,8 +124,8 @@ INTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n #endif\n \n #if SANITIZER_INTERCEPT_PRCTL\n-INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n-            unsigned long arg3,                       // NOLINT\n+INTERCEPTOR(int, prctl, int option,\n+            unsigned long arg2, unsigned long arg3,   // NOLINT\n             unsigned long arg4, unsigned long arg5) { // NOLINT\n   void *ctx;\n   COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n@@ -144,6 +144,100 @@ INTERCEPTOR(int, prctl, int option, unsigned long arg2,\n #define INIT_PRCTL\n #endif // SANITIZER_INTERCEPT_PRCTL\n \n+#if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n+INTERCEPTOR(void *, localtime, unsigned long *timep) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, localtime, timep);\n+  void *res = REAL(localtime)(timep);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(void *, localtime_r, unsigned long *timep, void *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, localtime_r, timep, result);\n+  void *res = REAL(localtime_r)(timep, result);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(void *, gmtime, unsigned long *timep) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gmtime, timep);\n+  void *res = REAL(gmtime)(timep);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(void *, gmtime_r, unsigned long *timep, void *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, gmtime_r, timep, result);\n+  void *res = REAL(gmtime_r)(timep, result);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, struct_tm_sz);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(char *, ctime, unsigned long *timep) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ctime, timep);\n+  char *res = REAL(ctime)(timep);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, ctime_r, timep, result);\n+  char *res = REAL(ctime_r)(timep, result);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(char *, asctime, void *tm) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, asctime, tm);\n+  char *res = REAL(asctime)(tm);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, struct_tm_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+INTERCEPTOR(char *, asctime_r, void *tm, char *result) {\n+  void *ctx;\n+  COMMON_INTERCEPTOR_ENTER(ctx, asctime_r, tm, result);\n+  char *res = REAL(asctime_r)(tm, result);\n+  if (res) {\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, struct_tm_sz);\n+    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n+  }\n+  return res;\n+}\n+#define INIT_LOCALTIME_AND_FRIENDS               \\\n+  INTERCEPT_FUNCTION(localtime);                 \\\n+  INTERCEPT_FUNCTION(localtime_r);               \\\n+  INTERCEPT_FUNCTION(gmtime);                    \\\n+  INTERCEPT_FUNCTION(gmtime_r);                  \\\n+  INTERCEPT_FUNCTION(ctime);                     \\\n+  INTERCEPT_FUNCTION(ctime_r);                   \\\n+  INTERCEPT_FUNCTION(asctime);                   \\\n+  INTERCEPT_FUNCTION(asctime_r);\n+#else\n+#define INIT_LOCALTIME_AND_FRIENDS\n+#endif // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n+\n #if SANITIZER_INTERCEPT_SCANF\n \n #include \"sanitizer_common_interceptors_scanf.inc\"\n@@ -170,6 +264,7 @@ VSCANF_INTERCEPTOR_IMPL(vsscanf, true, str, format, ap)\n INTERCEPTOR(int, vfscanf, void *stream, const char *format, va_list ap)\n VSCANF_INTERCEPTOR_IMPL(vfscanf, true, stream, format, ap)\n \n+#if SANITIZER_INTERCEPT_ISOC99_SCANF\n INTERCEPTOR(int, __isoc99_vscanf, const char *format, va_list ap)\n VSCANF_INTERCEPTOR_IMPL(__isoc99_vscanf, false, format, ap)\n \n@@ -179,6 +274,7 @@ VSCANF_INTERCEPTOR_IMPL(__isoc99_vsscanf, false, str, format, ap)\n \n INTERCEPTOR(int, __isoc99_vfscanf, void *stream, const char *format, va_list ap)\n VSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n+#endif  // SANITIZER_INTERCEPT_ISOC99_SCANF\n \n #define SCANF_INTERCEPTOR_IMPL(name, vname, ...)                               \\\n   {                                                                            \\\n@@ -200,6 +296,7 @@ SCANF_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n INTERCEPTOR(int, sscanf, const char *str, const char *format, ...)\n SCANF_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n \n+#if SANITIZER_INTERCEPT_ISOC99_SCANF\n INTERCEPTOR(int, __isoc99_scanf, const char *format, ...)\n SCANF_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n \n@@ -208,6 +305,7 @@ SCANF_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n \n INTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\n SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n+#endif\n \n #define INIT_SCANF                                                             \\\n   INTERCEPT_FUNCTION(scanf);                                                   \\\n@@ -235,4 +333,5 @@ SCANF_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n   INIT_WRITE;                                                                  \\\n   INIT_PWRITE;                                                                 \\\n   INIT_PWRITE64;                                                               \\\n+  INIT_LOCALTIME_AND_FRIENDS;                                                  \\\n   INIT_SCANF;"}, {"sha": "2152c7bdff4db54b4a5e685b43ba544154e1bb85", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -36,7 +36,8 @@ static bool GetFlagValue(const char *env, const char *name,\n       pos += 1;\n       end = internal_strchr(pos, '\\'');\n     } else {\n-      end = internal_strchr(pos, ' ');\n+      // Read until the next space or colon.\n+      end = pos + internal_strcspn(pos, \" :\");\n     }\n     if (end == 0)\n       end = pos + internal_strlen(pos);"}, {"sha": "577c9a9c17fcbbe9e84365a3572eac7899b69088", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -29,7 +29,7 @@\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n #endif\n \n-// __has_feature\n+// GCC does not understand __has_feature\n #if !defined(__has_feature)\n # define __has_feature(x) 0\n #endif"}, {"sha": "16239413356f88eb4171803bff00a40ac594ce10", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -43,6 +43,7 @@ char *internal_strrchr(const char *s, int c);\n char *internal_strstr(const char *haystack, const char *needle);\n // Works only for base=10 and doesn't set errno.\n s64 internal_simple_strtoll(const char *nptr, char **endptr, int base);\n+int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n \n // Return true if all bytes in [mem, mem+size) are zero.\n // Optimized for the case when the result is true.\n@@ -68,14 +69,15 @@ fd_t internal_open(const char *filename, int flags, u32 mode);\n \n uptr internal_read(fd_t fd, void *buf, uptr count);\n uptr internal_write(fd_t fd, const void *buf, uptr count);\n+\n+// OS\n uptr internal_filesize(fd_t fd);  // -1 on error.\n int internal_stat(const char *path, void *buf);\n int internal_lstat(const char *path, void *buf);\n int internal_fstat(fd_t fd, void *buf);\n-\n int internal_dup2(int oldfd, int newfd);\n uptr internal_readlink(const char *path, char *buf, uptr bufsize);\n-int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n+void NORETURN internal__exit(int exitcode);\n \n // Threading\n int internal_sched_yield();"}, {"sha": "06e5a0a64410ea689fdde48f13f8251d6a5bf29a", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -138,6 +138,11 @@ int internal_sched_yield() {\n   return syscall(__NR_sched_yield);\n }\n \n+void internal__exit(int exitcode) {\n+  syscall(__NR_exit_group, exitcode);\n+  Die();  // Unreachable.\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n #if SANITIZER_LINUX_USES_64BIT_SYSCALLS\n@@ -232,6 +237,21 @@ const char *GetEnv(const char *name) {\n   return 0;  // Not found.\n }\n \n+#ifdef __GLIBC__\n+\n+extern \"C\" {\n+  extern void *__libc_stack_end;\n+}\n+\n+static void GetArgsAndEnv(char ***argv, char ***envp) {\n+  uptr *stack_end = (uptr *)__libc_stack_end;\n+  int argc = *stack_end;\n+  *argv = (char**)(stack_end + 1);\n+  *envp = (char**)(stack_end + argc + 2);\n+}\n+\n+#else  // __GLIBC__\n+\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n   char *buff;\n@@ -251,12 +271,20 @@ static void ReadNullSepFileToArray(const char *path, char ***arr,\n   (*arr)[count] = 0;\n }\n \n+static void GetArgsAndEnv(char ***argv, char ***envp) {\n+  static const int kMaxArgv = 2000, kMaxEnvp = 2000;\n+  ReadNullSepFileToArray(\"/proc/self/cmdline\", argv, kMaxArgv);\n+  ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n+}\n+\n+#endif  // __GLIBC__\n+\n void ReExec() {\n-  static const int kMaxArgv = 100, kMaxEnvp = 1000;\n   char **argv, **envp;\n-  ReadNullSepFileToArray(\"/proc/self/cmdline\", &argv, kMaxArgv);\n-  ReadNullSepFileToArray(\"/proc/self/environ\", &envp, kMaxEnvp);\n-  execve(argv[0], argv, envp);\n+  GetArgsAndEnv(&argv, &envp);\n+  execve(\"/proc/self/exe\", argv, envp);\n+  Printf(\"execve failed, errno %d\\n\", errno);\n+  Die();\n }\n \n void PrepareForSandboxing() {"}, {"sha": "d7885bb350963b1911a8f46631b1ce93745d4e5f", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -104,6 +104,10 @@ int internal_sched_yield() {\n   return sched_yield();\n }\n \n+void internal__exit(int exitcode) {\n+  _exit(exitcode);\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   struct stat st;"}, {"sha": "9b40c0cc523b71abb7f31443d88f8074b5254038", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -14,6 +14,7 @@\n \n #if !defined(_WIN32)\n # define SI_NOT_WINDOWS 1\n+# include \"sanitizer_platform_limits_posix.h\"\n #else\n # define SI_NOT_WINDOWS 0\n #endif\n@@ -24,6 +25,12 @@\n # define SI_LINUX_NOT_ANDROID 0\n #endif\n \n+#if defined(__linux__)\n+# define SI_LINUX 1\n+#else\n+# define SI_LINUX 0\n+#endif\n+\n # define SANITIZER_INTERCEPT_READ   SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_PREAD  SI_NOT_WINDOWS\n # define SANITIZER_INTERCEPT_WRITE  SI_NOT_WINDOWS\n@@ -33,4 +40,7 @@\n # define SANITIZER_INTERCEPT_PWRITE64 SI_LINUX_NOT_ANDROID\n # define SANITIZER_INTERCEPT_PRCTL   SI_LINUX_NOT_ANDROID\n \n+# define SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS SI_NOT_WINDOWS\n+\n # define SANITIZER_INTERCEPT_SCANF SI_NOT_WINDOWS\n+# define SANITIZER_INTERCEPT_ISOC99_SCANF SI_LINUX"}, {"sha": "c4be1aa42da0c9361665f210666815b6094a22cc", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -0,0 +1,68 @@\n+//===-- sanitizer_platform_limits_posix.cc --------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific POSIX data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#if defined(__linux__) || defined(__APPLE__)\n+\n+#include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n+\n+#include <dirent.h>\n+#include <sys/utsname.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <sys/time.h>\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <time.h>\n+\n+#if defined(__linux__)\n+#include <sys/vfs.h>\n+#include <sys/epoll.h>\n+#endif // __linux__\n+\n+namespace __sanitizer {\n+  unsigned struct_utsname_sz = sizeof(struct utsname);\n+  unsigned struct_stat_sz = sizeof(struct stat);\n+  unsigned struct_stat64_sz = sizeof(struct stat64);\n+  unsigned struct_rusage_sz = sizeof(struct rusage);\n+  unsigned struct_tm_sz = sizeof(struct tm);\n+\n+#if defined(__linux__)\n+  unsigned struct_rlimit_sz = sizeof(struct rlimit);\n+  unsigned struct_dirent_sz = sizeof(struct dirent);\n+  unsigned struct_statfs_sz = sizeof(struct statfs);\n+  unsigned struct_epoll_event_sz = sizeof(struct epoll_event);\n+#endif // __linux__\n+\n+#if defined(__linux__) && !defined(__ANDROID__)\n+  unsigned struct_rlimit64_sz = sizeof(struct rlimit64);\n+  unsigned struct_statfs64_sz = sizeof(struct statfs64);\n+#endif // __linux__ && !__ANDROID__\n+\n+  void* __sanitizer_get_msghdr_iov_iov_base(void* msg, int idx) {\n+    return ((struct msghdr *)msg)->msg_iov[idx].iov_base;\n+  }\n+\n+  uptr __sanitizer_get_msghdr_iov_iov_len(void* msg, int idx) {\n+    return ((struct msghdr *)msg)->msg_iov[idx].iov_len;\n+  }\n+\n+  uptr __sanitizer_get_msghdr_iovlen(void* msg) {\n+    return ((struct msghdr *)msg)->msg_iovlen;\n+  }\n+\n+  uptr __sanitizer_get_socklen_t(void* socklen_ptr) {\n+    return *(socklen_t*)socklen_ptr;\n+  }\n+}  // namespace __sanitizer\n+\n+#endif  // __linux__ || __APPLE__"}, {"sha": "dd53da94be6b7c71dca511c5e923158895b70fa3", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -0,0 +1,41 @@\n+//===-- sanitizer_platform_limits_posix.h ---------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of Sanitizer common code.\n+//\n+// Sizes and layouts of platform-specific POSIX data structures.\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef SANITIZER_PLATFORM_LIMITS_POSIX_H\n+#define SANITIZER_PLATFORM_LIMITS_POSIX_H\n+\n+namespace __sanitizer {\n+  extern unsigned struct_utsname_sz;\n+  extern unsigned struct_stat_sz;\n+  extern unsigned struct_stat64_sz;\n+  extern unsigned struct_rusage_sz;\n+  extern unsigned struct_tm_sz;\n+\n+#if defined(__linux__)\n+  extern unsigned struct_rlimit_sz;\n+  extern unsigned struct_dirent_sz;\n+  extern unsigned struct_statfs_sz;\n+  extern unsigned struct_epoll_event_sz;\n+#endif // __linux__\n+\n+#if defined(__linux__) && !defined(__ANDROID__)\n+  extern unsigned struct_rlimit64_sz;\n+  extern unsigned struct_statfs64_sz;\n+#endif // __linux__ && !__ANDROID__\n+\n+  void* __sanitizer_get_msghdr_iov_iov_base(void* msg, int idx);\n+  uptr __sanitizer_get_msghdr_iov_iov_len(void* msg, int idx);\n+  uptr __sanitizer_get_msghdr_iovlen(void* msg);\n+  uptr __sanitizer_get_socklen_t(void* socklen_ptr);\n+}  // namespace __sanitizer\n+\n+#endif"}, {"sha": "1c6ff0a2ebbed04c025a9ff5291916432dbfb984", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -42,6 +42,10 @@ int GetPid() {\n   return getpid();\n }\n \n+u32 GetUid() {\n+  return getuid();\n+}\n+\n uptr GetThreadSelf() {\n   return (uptr)pthread_self();\n }\n@@ -203,10 +207,6 @@ void SleepForMillis(int millis) {\n   usleep(millis * 1000);\n }\n \n-void Exit(int exitcode) {\n-  _exit(exitcode);\n-}\n-\n void Abort() {\n   abort();\n }"}, {"sha": "e14ea447264a88da5754b802258793d7bace6a96", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -129,8 +129,9 @@ void StackTrace::FastUnwindStack(uptr pc, uptr bp,\n   CHECK(size == 0 && trace[0] == pc);\n   size = 1;\n   uhwptr *frame = (uhwptr *)bp;\n-  uhwptr *prev_frame = frame;\n-  while (frame >= prev_frame &&\n+  uhwptr *prev_frame = frame - 1;\n+  // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.\n+  while (frame > prev_frame &&\n          frame < (uhwptr *)stack_top - 2 &&\n          frame > (uhwptr *)stack_bottom &&\n          size < max_size) {"}, {"sha": "01f1e4588da706f9c6f47d410ac48d0e0886b352", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_linux.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_linux.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -97,7 +97,7 @@ bool StartSymbolizerSubprocess(const char *path_to_symbolizer,\n     for (int fd = getdtablesize(); fd > 2; fd--)\n       internal_close(fd);\n     execl(path_to_symbolizer, path_to_symbolizer, (char*)0);\n-    Exit(1);\n+    internal__exit(1);\n   }\n \n   // Continue execution in parent process."}, {"sha": "695265594b3cd353ffdc38a53fccb7a90d3a99d0", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -129,6 +129,10 @@ const char *GetPwd() {\n   UNIMPLEMENTED();\n }\n \n+u32 GetUid() {\n+  UNIMPLEMENTED();\n+}\n+\n void DumpProcessMap() {\n   UNIMPLEMENTED();\n }\n@@ -161,10 +165,6 @@ void SleepForMillis(int millis) {\n   Sleep(millis);\n }\n \n-void Exit(int exitcode) {\n-  _exit(exitcode);\n-}\n-\n void Abort() {\n   abort();\n   _exit(-1);  // abort is not NORETURN on Windows.\n@@ -251,6 +251,10 @@ int internal_sched_yield() {\n   return 0;\n }\n \n+void internal__exit(int exitcode) {\n+  _exit(exitcode);\n+}\n+\n // ---------------------- BlockingMutex ---------------- {{{1\n const uptr LOCK_UNINITIALIZED = 0;\n const uptr LOCK_READY = (uptr)-1;"}, {"sha": "f7b05f2bf8ffb88e9b369281aff0f7eeef812b65", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -241,7 +241,7 @@ const char *InitializePlatform() {\n   g_tls_size = (uptr)InitTlsSize();\n   InitDataSeg();\n #endif\n-  return getenv(kTsanOptionsEnv);\n+  return GetEnv(kTsanOptionsEnv);\n }\n \n void FinalizePlatform() {"}, {"sha": "b247468c8294bf4e96fd8f9221876dffd82e5d91", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -80,7 +80,7 @@ const char *InitializePlatform() {\n     setrlimit(RLIMIT_CORE, (rlimit*)&lim);\n   }\n \n-  return getenv(kTsanOptionsEnv);\n+  return GetEnv(kTsanOptionsEnv);\n }\n \n void FinalizePlatform() {"}, {"sha": "376dc08688be04be24dd21d001803ff313712c9c", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -32,7 +32,7 @@ void FlushShadowMemory() {\n }\n \n const char *InitializePlatform() {\n-  return getenv(kTsanOptionsEnv);\n+  return GetEnv(kTsanOptionsEnv);\n }\n \n void FinalizePlatform() {"}, {"sha": "e939921049a7c253c1085fdd268789627fbfca82", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -590,6 +590,8 @@ void MemoryAccessImpl(ThreadState *thr, uptr addr,\n     u64 *shadow_mem, Shadow cur);\n void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n     uptr size, bool is_write);\n+void MemoryAccessRangeStep(ThreadState *thr, uptr pc, uptr addr,\n+    uptr size, uptr step, bool is_write);\n \n const int kSizeLog1 = 0;\n const int kSizeLog2 = 1;"}, {"sha": "e30916dc6272a45128d98de102f560922e96dc4b", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -420,4 +420,26 @@ void MemoryAccessRange(ThreadState *thr, uptr pc, uptr addr,\n         shadow_mem, cur);\n   }\n }\n+\n+void MemoryAccessRangeStep(ThreadState *thr, uptr pc, uptr addr,\n+    uptr size, uptr step, bool is_write) {\n+  if (size == 0)\n+    return;\n+  FastState fast_state = thr->fast_state;\n+  if (fast_state.GetIgnoreBit())\n+    return;\n+  StatInc(thr, StatMopRange);\n+  fast_state.IncrementEpoch();\n+  thr->fast_state = fast_state;\n+  TraceAddEvent(thr, fast_state, EventTypeMop, pc);\n+\n+  for (uptr addr_end = addr + size; addr < addr_end; addr += step) {\n+    u64 *shadow_mem = (u64*)MemToShadow(addr);\n+    Shadow cur(fast_state);\n+    cur.SetWrite(is_write);\n+    cur.SetAddr0AndSizeLog(addr & (kShadowCell - 1), kSizeLog1);\n+    MemoryAccessImpl(thr, addr, kSizeLog1, is_write, false,\n+        shadow_mem, cur);\n+  }\n+}\n }  // namespace __tsan"}, {"sha": "fbec4225d9cb79e39fc1a642ed5e56668aa6b3a2", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -263,6 +263,14 @@ void StatOutput(u64 *stat) {\n   name[StatInt___isoc99_fscanf]          = \"  fscanf                          \";\n   name[StatInt_on_exit]                  = \"  on_exit                         \";\n   name[StatInt___cxa_atexit]             = \"  __cxa_atexit                    \";\n+  name[StatInt_localtime]                = \"  localtime                       \";\n+  name[StatInt_localtime_r]              = \"  localtime_r                     \";\n+  name[StatInt_gmtime]                   = \"  gmtime                          \";\n+  name[StatInt_gmtime_r]                 = \"  gmtime_r                        \";\n+  name[StatInt_ctime]                    = \"  ctime                           \";\n+  name[StatInt_ctime_r]                  = \"  ctime_r                         \";\n+  name[StatInt_asctime]                  = \"  asctime                         \";\n+  name[StatInt_asctime_r]                = \"  asctime_r                       \";\n \n   name[StatAnnotation]                   = \"Dynamic annotations               \";\n   name[StatAnnotateHappensBefore]        = \"  HappensBefore                   \";"}, {"sha": "8b08a024be2671ddc24255bd386a48626168c1f7", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -262,6 +262,14 @@ enum StatType {\n   StatInt___isoc99_fscanf,\n   StatInt_on_exit,\n   StatInt___cxa_atexit,\n+  StatInt_localtime,\n+  StatInt_localtime_r,\n+  StatInt_gmtime,\n+  StatInt_gmtime_r,\n+  StatInt_ctime,\n+  StatInt_ctime_r,\n+  StatInt_asctime,\n+  StatInt_asctime_r,\n \n   // Dynamic annotations.\n   StatAnnotation,"}, {"sha": "8ee8de7c27887d09c8d4a4090a784eb4e247c0dd", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7df59255e1accc8f95b4d90d1a17c60cd0e6e40e/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=7df59255e1accc8f95b4d90d1a17c60cd0e6e40e", "patch": "@@ -138,7 +138,7 @@ void InitializeSuppressions() {\n   g_suppressions = SuppressionParse(0, supp);\n #ifndef TSAN_GO\n   supp = __tsan_default_suppressions();\n-  g_suppressions = SuppressionParse(0, supp);\n+  g_suppressions = SuppressionParse(g_suppressions, supp);\n #endif\n }\n "}]}