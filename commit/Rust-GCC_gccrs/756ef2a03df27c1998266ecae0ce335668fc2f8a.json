{"sha": "756ef2a03df27c1998266ecae0ce335668fc2f8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU2ZWYyYTAzZGYyN2MxOTk4MjY2ZWNhZTBjZTMzNTY2OGZjMmY4YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T10:01:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-04T10:01:08Z"}, "message": "[multiple changes]\n\n2011-08-04  Emmanuel Briot  <briot@adacore.com>\n\n\t* makeutl.adb (Complete_Mains): when a multi-unit source file is\n\tspecified on the gprbuild command line, we need to compile all units\n\twithin that file, not just the first one we find\n\tFix error message for mains that are not found.\n\n2011-08-04  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch6.adb: Update comment.\n\t* sem_ch12.adb: Minor reformatting.\n\n2011-08-04  Bob Duff  <duff@adacore.com>\n\n\t* s-tasren.adb (Task_Do_Or_Queue): Previous code was reading\n\tAcceptor.Terminate_Alternative without locking Acceptor, which causes a\n\trace condition whose symptom is to fail to lock Parent. That, in turn,\n\tcauses Parent.Awake_Count to be accessed without locking Parent, which\n\tcauses another race condition whose symptom is that Parent.Awake_Count\n\tcan be off by 1 (either too high or too low). The solution is to lock\n\tParent unconditionally, and then lock Acceptor, before reading\n\tAcceptor.Terminate_Alternative.\n\nFrom-SVN: r177352", "tree": {"sha": "722a766e81c8764b4f14dbbac6f18aea058ba0cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/722a766e81c8764b4f14dbbac6f18aea058ba0cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/756ef2a03df27c1998266ecae0ce335668fc2f8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756ef2a03df27c1998266ecae0ce335668fc2f8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756ef2a03df27c1998266ecae0ce335668fc2f8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756ef2a03df27c1998266ecae0ce335668fc2f8a/comments", "author": null, "committer": null, "parents": [{"sha": "4fdebd93e0b117dc4363d2552ca886623075e1a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fdebd93e0b117dc4363d2552ca886623075e1a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fdebd93e0b117dc4363d2552ca886623075e1a8"}], "stats": {"total": 251, "additions": 164, "deletions": 87}, "files": [{"sha": "29f972a3f32c62be7a5dc6bf7c4affa13d4cd5bf", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=756ef2a03df27c1998266ecae0ce335668fc2f8a", "patch": "@@ -1,3 +1,26 @@\n+2011-08-04  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* makeutl.adb (Complete_Mains): when a multi-unit source file is\n+\tspecified on the gprbuild command line, we need to compile all units\n+\twithin that file, not just the first one we find\n+\tFix error message for mains that are not found.\n+\n+2011-08-04  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch6.adb: Update comment.\n+\t* sem_ch12.adb: Minor reformatting.\n+\n+2011-08-04  Bob Duff  <duff@adacore.com>\n+\n+\t* s-tasren.adb (Task_Do_Or_Queue): Previous code was reading\n+\tAcceptor.Terminate_Alternative without locking Acceptor, which causes a\n+\trace condition whose symptom is to fail to lock Parent. That, in turn,\n+\tcauses Parent.Awake_Count to be accessed without locking Parent, which\n+\tcauses another race condition whose symptom is that Parent.Awake_Count\n+\tcan be off by 1 (either too high or too low). The solution is to lock\n+\tParent unconditionally, and then lock Acceptor, before reading\n+\tAcceptor.Terminate_Alternative.\n+\n 2011-08-04  Arnaud Charlet  <charlet@adacore.com>\n \n \t* debug.adb: Update comment."}, {"sha": "8e9bd21843649a3ace9f8b04521a91b7d6456451", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=756ef2a03df27c1998266ecae0ce335668fc2f8a", "patch": "@@ -1280,13 +1280,71 @@ package body Makeutl is\n          procedure Complete_All is new For_Project_And_Aggregated\n            (Do_Complete);\n \n+         procedure Add_Multi_Unit_Sources\n+           (Tree   : Project_Tree_Ref;\n+            Source : Prj.Source_Id);\n+         --  Add all units from the same file as the multi-unit Source.\n+\n+         ----------------------------\n+         -- Add_Multi_Unit_Sources --\n+         ----------------------------\n+\n+         procedure Add_Multi_Unit_Sources\n+           (Tree   : Project_Tree_Ref;\n+            Source : Prj.Source_Id)\n+         is\n+            Iter : Source_Iterator;\n+            Src  : Prj.Source_Id;\n+         begin\n+            Debug_Output\n+              (\"Found multi-unit source file in project\", Source.Project.Name);\n+\n+            Iter := For_Each_Source\n+              (In_Tree => Tree, Project => Source.Project);\n+\n+            while Element (Iter) /= No_Source loop\n+               Src := Element (Iter);\n+\n+               if Src.File = Source.File\n+                 and then Src.Index /= Source.Index\n+               then\n+                  if Src.File = Source.File then\n+                     Debug_Output\n+                       (\"Add main in project, index=\" & Src.Index'Img);\n+                  end if;\n+\n+                  Names.Increment_Last;\n+                  Names.Table (Names.Last) :=\n+                    (File     => Src.File,\n+                     Index    => Src.Index,\n+                     Location => No_Location,\n+                     Source   => Src,\n+                     Project  => Src.Project,\n+                     Tree     => Tree);\n+\n+                  Builder_Data (Tree).Number_Of_Mains :=\n+                    Builder_Data (Tree).Number_Of_Mains + 1;\n+               end if;\n+\n+               Next (Iter);\n+            end loop;\n+         end Add_Multi_Unit_Sources;\n+\n+         -----------------\n+         -- Do_Complete --\n+         -----------------\n+\n          procedure Do_Complete\n            (Project : Project_Id; Tree : Project_Tree_Ref) is\n          begin\n             if Mains.Number_Of_Mains (Tree) > 0\n               or else Mains.Count_Of_Mains_With_No_Tree > 0\n             then\n-               for J in Names.First .. Names.Last loop\n+               --  Traverse in reverse order, since in the case of multi-unit\n+               --  files we will be adding extra files at the end, and there's\n+               --  no need to process them in tun.\n+\n+               for J in reverse Names.First .. Names.Last loop\n                   declare\n                      File       : Main_Info := Names.Table (J);\n                      Main_Id    : File_Name_Type := File.File;\n@@ -1327,7 +1385,7 @@ package body Makeutl is\n                         if Current_Verbosity = High then\n                            Debug_Output\n                              (\"Search for main \"\"\" & Main\n-                              & \"\"\" in \"\n+                              & '\"' & File.Index'Img & \" in \"\n                               & Get_Name_String (Debug_Name (File.Tree))\n                               & \", project\", Project.Name);\n                         end if;\n@@ -1402,6 +1460,19 @@ package body Makeutl is\n                         end if;\n \n                         if Source /= No_Source then\n+                           --  If we have found a multi-unit source file but\n+                           --  did not specify an index initially, we'll need\n+                           --  to compile all the units from the same source\n+                           --  file\n+\n+                           if Source.Index /= 0\n+                             and then File.Index = 0\n+                           then\n+                              Add_Multi_Unit_Sources (File.Tree, Source);\n+                           end if;\n+\n+                           --  Now update the original Main, otherwise it will\n+                           --  be reported as not found.\n \n                            Debug_Output (\"Found main in project\",\n                                          Source.Project.Name);\n@@ -1412,7 +1483,8 @@ package body Makeutl is\n                               Names.Table (J).Tree := File.Tree;\n \n                               Builder_Data (File.Tree).Number_Of_Mains :=\n-                                Builder_Data (File.Tree).Number_Of_Mains + 1;\n+                                Builder_Data (File.Tree).Number_Of_Mains\n+                                + 1;\n                               Mains.Count_Of_Mains_With_No_Tree :=\n                                 Mains.Count_Of_Mains_With_No_Tree - 1;\n                            end if;\n@@ -1451,9 +1523,11 @@ package body Makeutl is\n \n          if Mains.Count_Of_Mains_With_No_Tree > 0 then\n             for J in Names.First .. Names.Last loop\n-               Fail_Program\n-                 (Project_Tree, '\"' & Get_Name_String (Names.Table (J).File)\n-                    & \"\"\" is not a source of any project\");\n+               if Names.Table (J).Source = No_Source then\n+                  Fail_Program\n+                    (Project_Tree, '\"' & Get_Name_String (Names.Table (J).File)\n+                     & \"\"\" is not a source of any project\");\n+               end if;\n             end loop;\n          end if;\n       end Complete_Mains;"}, {"sha": "aed3ec50445bbf09baad4b0b6177cb03d9e167e8", "filename": "gcc/ada/s-tasren.adb", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fs-tasren.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fs-tasren.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tasren.adb?ref=756ef2a03df27c1998266ecae0ce335668fc2f8a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---         Copyright (C) 1992-2010, Free Software Foundation, Inc.          --\n+--         Copyright (C) 1992-2011, Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNARL is free software; you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1077,7 +1077,6 @@ package body System.Tasking.Rendezvous is\n       Old_State     : constant Entry_Call_State := Entry_Call.State;\n       Acceptor      : constant Task_Id := Entry_Call.Called_Task;\n       Parent        : constant Task_Id := Acceptor.Common.Parent;\n-      Parent_Locked : Boolean := False;\n       Null_Body     : Boolean;\n \n    begin\n@@ -1105,24 +1104,23 @@ package body System.Tasking.Rendezvous is\n       --  record for another call.\n       --  We rely on the Caller's lock for call State mod's.\n \n-      --  We can't lock Acceptor.Parent while holding Acceptor,\n-      --  so lock it in advance if we expect to need to lock it.\n-\n-      if Acceptor.Terminate_Alternative then\n-         STPO.Write_Lock (Parent);\n-         Parent_Locked := True;\n-      end if;\n+      --  If Acceptor.Terminate_Alternative is True, we need to lock Parent and\n+      --  Acceptor, in that order; otherwise, we only need a lock on\n+      --  Acceptor. However, we can't check Acceptor.Terminate_Alternative\n+      --  until Acceptor is locked. Therefore, we need to lock both. Attempts\n+      --  to avoid locking Parent tend to result in race conditions. It would\n+      --  work to unlock Parent immediately upon finding\n+      --  Acceptor.Terminate_Alternative to be False, but that violates the\n+      --  rule of properly nested locking (see System.Tasking).\n \n+      STPO.Write_Lock (Parent);\n       STPO.Write_Lock (Acceptor);\n \n       --  If the acceptor is not callable, abort the call and return False\n \n       if not Acceptor.Callable then\n          STPO.Unlock (Acceptor);\n-\n-         if Parent_Locked then\n-            STPO.Unlock (Parent);\n-         end if;\n+         STPO.Unlock (Parent);\n \n          pragma Assert (Entry_Call.State < Done);\n \n@@ -1186,10 +1184,7 @@ package body System.Tasking.Rendezvous is\n \n                   STPO.Wakeup (Acceptor, Acceptor_Sleep);\n                   STPO.Unlock (Acceptor);\n-\n-                  if Parent_Locked then\n-                     STPO.Unlock (Parent);\n-                  end if;\n+                  STPO.Unlock (Parent);\n \n                   STPO.Write_Lock (Entry_Call.Self);\n                   Initialization.Wakeup_Entry_Caller\n@@ -1207,10 +1202,7 @@ package body System.Tasking.Rendezvous is\n                   end if;\n \n                   STPO.Unlock (Acceptor);\n-\n-                  if Parent_Locked then\n-                     STPO.Unlock (Parent);\n-                  end if;\n+                  STPO.Unlock (Parent);\n                end if;\n \n                return True;\n@@ -1236,10 +1228,7 @@ package body System.Tasking.Rendezvous is\n             and then Entry_Call.Cancellation_Attempted)\n       then\n          STPO.Unlock (Acceptor);\n-\n-         if Parent_Locked then\n-            STPO.Unlock (Parent);\n-         end if;\n+         STPO.Unlock (Parent);\n \n          STPO.Write_Lock (Entry_Call.Self);\n \n@@ -1261,10 +1250,7 @@ package body System.Tasking.Rendezvous is\n            New_State (Entry_Call.With_Abort, Entry_Call.State);\n \n          STPO.Unlock (Acceptor);\n-\n-         if Parent_Locked then\n-            STPO.Unlock (Parent);\n-         end if;\n+         STPO.Unlock (Parent);\n \n          if Old_State /= Entry_Call.State\n            and then Entry_Call.State = Now_Abortable"}, {"sha": "f0bc8e017de81908444846beeafdf9018479f194", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=756ef2a03df27c1998266ecae0ce335668fc2f8a", "patch": "@@ -3380,9 +3380,11 @@ package body Sem_Ch12 is\n          end;\n \n          --  If we are generating calling stubs, we never need a body for an\n-         --  instantiation from source. However normal processing occurs for\n-         --  any generic instantiation appearing in generated code, since we\n-         --  do not generate stubs in that case.\n+         --  instantiation from source in the visible part, because in that\n+         --  case we'll be generating stubs for any subprogram in the instance.\n+         --  However normal processing occurs for instantiations in generated\n+         --  code or in the private part, since in those cases we do not\n+         --  generate stubs.\n \n          if Distribution_Stub_Mode = Generate_Caller_Stub_Body\n               and then Comes_From_Source (N)\n@@ -6295,8 +6297,8 @@ package body Sem_Ch12 is\n             end if;\n          end if;\n \n-         --  Do not copy the associated node, which points to\n-         --  the generic copy of the aggregate.\n+         --  Do not copy the associated node, which points to the generic copy\n+         --  of the aggregate.\n \n          declare\n             use Atree.Unchecked_Access;\n@@ -6310,9 +6312,9 @@ package body Sem_Ch12 is\n             Set_Field5 (New_N, Copy_Generic_Descendant (Field5 (N)));\n          end;\n \n-      --  Allocators do not have an identifier denoting the access type,\n-      --  so we must locate it through the expression to check whether\n-      --  the views are consistent.\n+      --  Allocators do not have an identifier denoting the access type, so we\n+      --  must locate it through the expression to check whether the views are\n+      --  consistent.\n \n       elsif Nkind (N) = N_Allocator\n         and then Nkind (Expression (N)) = N_Qualified_Expression\n@@ -6373,16 +6375,13 @@ package body Sem_Ch12 is\n       --  Don't copy Ident or Comment pragmas, since the comment belongs to the\n       --  generic unit, not to the instantiating unit.\n \n-      elsif Nkind (N) = N_Pragma\n-        and then Instantiating\n-      then\n+      elsif Nkind (N) = N_Pragma and then Instantiating then\n          declare\n             Prag_Id : constant Pragma_Id := Get_Pragma_Id (N);\n          begin\n-            if Prag_Id = Pragma_Ident\n-              or else Prag_Id = Pragma_Comment\n-            then\n+            if Prag_Id = Pragma_Ident or else Prag_Id = Pragma_Comment then\n                New_N := Make_Null_Statement (Sloc (N));\n+\n             else\n                Copy_Descendants;\n             end if;\n@@ -6411,10 +6410,10 @@ package body Sem_Ch12 is\n       else\n          Copy_Descendants;\n \n-         if Instantiating\n-           and then Nkind (N) = N_Subprogram_Body\n-         then\n+         if Instantiating and then Nkind (N) = N_Subprogram_Body then\n             Set_Generic_Parent (Specification (New_N), N);\n+\n+            --  Should preserve Corresponding_Spec??? (12.3(14))\n          end if;\n       end if;\n \n@@ -6455,9 +6454,7 @@ package body Sem_Ch12 is\n                if Renamed_Object (E1) = Pack then\n                   return True;\n \n-               elsif E1 = P\n-                 or else  Renamed_Object (E1) = P\n-               then\n+               elsif E1 = P or else  Renamed_Object (E1) = P then\n                   return False;\n \n                elsif Is_Actual_Of_Previous_Formal (E1) then\n@@ -6479,7 +6476,7 @@ package body Sem_Ch12 is\n            Instance_Envs.Table\n              (Instance_Envs.Last).Instantiated_Parent.Act_Id;\n       else\n-         Par  := Current_Instantiated_Parent.Act_Id;\n+         Par := Current_Instantiated_Parent.Act_Id;\n       end if;\n \n       if Ekind (Scop) = E_Generic_Package\n@@ -6675,12 +6672,12 @@ package body Sem_Ch12 is\n          end loop;\n \n          --  At this point P1 and P2 are at the same distance from the root.\n-         --  We examine their parents until we find a common declarative\n-         --  list, at which point we can establish their relative placement\n-         --  by comparing their ultimate slocs. If we reach the root,\n-         --  N1 and N2 do not descend from the same declarative list (e.g.\n-         --  one is nested in the declarative part and the other is in a block\n-         --  in the statement part) and the earlier one is already frozen.\n+         --  We examine their parents until we find a common declarative list,\n+         --  at which point we can establish their relative placement by\n+         --  comparing their ultimate slocs. If we reach the root, N1 and N2\n+         --  do not descend from the same declarative list (e.g. one is nested\n+         --  in the declarative part and the other is in a block in the\n+         --  statement part) and the earlier one is already frozen.\n \n          while not Is_List_Member (P1)\n            or else not Is_List_Member (P2)\n@@ -6814,9 +6811,9 @@ package body Sem_Ch12 is\n                  In_Same_Declarative_Part (Freeze_Node (Par), Parent (Enc_I)))\n          then\n             --  The enclosing package may contain several instances. Rather\n-            --  than computing the earliest point at which to insert its\n-            --  freeze node, we place it at the end of the declarative part\n-            --  of the parent of the generic.\n+            --  than computing the earliest point at which to insert its freeze\n+            --  node, we place it at the end of the declarative part of the\n+            --  parent of the generic.\n \n             Insert_After_Last_Decl\n               (Freeze_Node (Par), Package_Freeze_Node (Enc_I));\n@@ -6838,12 +6835,12 @@ package body Sem_Ch12 is\n \n          --  Freeze package that encloses instance, and place node after\n          --  package that encloses generic. If enclosing package is already\n-         --  frozen we have to assume it is at the proper place. This may be\n-         --  a potential ABE that requires dynamic checking. Do not add a\n-         --  freeze node if the package that encloses the generic is inside\n-         --  the body that encloses the instance, because the freeze node\n-         --  would be in the wrong scope. Additional contortions needed if\n-         --  the bodies are within a subunit.\n+         --  frozen we have to assume it is at the proper place. This may be a\n+         --  potential ABE that requires dynamic checking. Do not add a freeze\n+         --  node if the package that encloses the generic is inside the body\n+         --  that encloses the instance, because the freeze node would be in\n+         --  the wrong scope. Additional contortions needed if the bodies are\n+         --  within a subunit.\n \n          declare\n             Enclosing_Body : Node_Id;\n@@ -6921,14 +6918,13 @@ package body Sem_Ch12 is\n       --  investigated, and would allow this function to be significantly\n       --  simplified. ???\n \n-      if Present (Package_Instantiation (A)) then\n-         if Nkind (Package_Instantiation (A)) = N_Package_Instantiation then\n-            return Package_Instantiation (A);\n+      Inst := Package_Instantiation (A);\n+      if Present (Inst) then\n+         if Nkind (Inst) = N_Package_Instantiation then\n+            return Inst;\n \n-         elsif Nkind (Original_Node (Package_Instantiation (A))) =\n-                                                   N_Package_Instantiation\n-         then\n-            return Original_Node (Package_Instantiation (A));\n+         elsif Nkind (Original_Node (Inst)) = N_Package_Instantiation then\n+            return Original_Node (Inst);\n          end if;\n       end if;\n \n@@ -7034,9 +7030,7 @@ package body Sem_Ch12 is\n       --  now we depend on the user not redefining Standard itself in one of\n       --  the parent units.\n \n-      if Is_Immediately_Visible (C)\n-        and then C /= Standard_Standard\n-      then\n+      if Is_Immediately_Visible (C) and then C /= Standard_Standard then\n          Set_Is_Immediately_Visible (C, False);\n          Append_Elmt (C, Hidden_Entities);\n       end if;\n@@ -7143,8 +7137,7 @@ package body Sem_Ch12 is\n             --  might produce false positives in rare cases, but guarantees\n             --  that we produce all the instance bodies we will need.\n \n-            if (Is_Entity_Name (Nam)\n-                 and then Chars (Nam) = Chars (E))\n+            if (Is_Entity_Name (Nam) and then Chars (Nam) = Chars (E))\n               or else (Nkind (Nam) = N_Selected_Component\n                         and then Chars (Selector_Name (Nam)) = Chars (E))\n             then\n@@ -7321,8 +7314,8 @@ package body Sem_Ch12 is\n \n    begin\n \n-      --  If the body is a subunit, the freeze point is the corresponding\n-      --  stub in the current compilation, not the subunit itself.\n+      --  If the body is a subunit, the freeze point is the corresponding stub\n+      --  in the current compilation, not the subunit itself.\n \n       if Nkind (Parent (Gen_Body)) = N_Subunit then\n          Orig_Body := Corresponding_Stub (Parent (Gen_Body));"}, {"sha": "1566890c3decd7381f55e367e93c71dcae56d487", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/756ef2a03df27c1998266ecae0ce335668fc2f8a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=756ef2a03df27c1998266ecae0ce335668fc2f8a", "patch": "@@ -6423,8 +6423,9 @@ package body Sem_Ch6 is\n \n                --  If the body already exists, then this is an error unless\n                --  the previous declaration is the implicit declaration of a\n-               --  derived subprogram, or this is a spurious overloading in an\n-               --  instance.\n+               --  derived subprogram. It is also legal for an instance to\n+               --  contain type conformant overloadable declarations (but the\n+               --  generic declaration may not), per 8.3(26/2).\n \n                elsif No (Alias (E))\n                  and then not Is_Intrinsic_Subprogram (E)"}]}