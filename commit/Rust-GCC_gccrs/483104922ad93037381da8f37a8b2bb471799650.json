{"sha": "483104922ad93037381da8f37a8b2bb471799650", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgzMTA0OTIyYWQ5MzAzNzM4MWRhOGYzN2E4YjJiYjQ3MTc5OTY1MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-05-01T15:48:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-05-01T15:48:28Z"}, "message": "Add libatomic as a target library.\n\nFrom-SVN: r187018", "tree": {"sha": "729dc91fa97f38042aa7777ca6267ebed2edb3e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/729dc91fa97f38042aa7777ca6267ebed2edb3e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/483104922ad93037381da8f37a8b2bb471799650", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483104922ad93037381da8f37a8b2bb471799650", "html_url": "https://github.com/Rust-GCC/gccrs/commit/483104922ad93037381da8f37a8b2bb471799650", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/483104922ad93037381da8f37a8b2bb471799650/comments", "author": null, "committer": null, "parents": [{"sha": "e8053cf5b5b8d982efd4d77d9922ac63fcf478d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8053cf5b5b8d982efd4d77d9922ac63fcf478d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8053cf5b5b8d982efd4d77d9922ac63fcf478d2"}], "stats": {"total": 29412, "additions": 29407, "deletions": 5}, "files": [{"sha": "4504d6e9031da090665e06097c0d61e96dfdd4ff", "filename": "ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -1,3 +1,10 @@\n+2012-05-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.def (libatomic): New target_module.\n+\t* configure.ac (target_libraries): Add libatomic.\n+\t(noconfigdirs): Check if libatomic is supported.\n+\t* Makefile.in, configure: Rebuild.\n+\n 2012-05-01  Greta Yorsh  <Greta.Yorsh@arm.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "1449a5086b6cd6743c69e437c74a7f88d7fdf4ec", "filename": "Makefile.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -140,6 +140,7 @@ target_modules = { module= rda; };\n target_modules = { module= libada; };\n target_modules = { module= libgomp; bootstrap= true; lib_path=.libs; };\n target_modules = { module= libitm; lib_path=.libs; };\n+target_modules = { module= libatomic; lib_path=.libs; };\n \n // These are (some of) the make targets to be done in each subdirectory.\n // Not all; these are the ones which don't have special options."}, {"sha": "e30c5e2ad801fddc82060ca9a6502e9e544f173b", "filename": "Makefile.in", "status": "modified", "additions": 489, "deletions": 5, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -599,7 +599,7 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n@@ -621,6 +621,10 @@ TARGET_LIB_PATH_libgomp = $$r/$(TARGET_SUBDIR)/libgomp/.libs:\n TARGET_LIB_PATH_libitm = $$r/$(TARGET_SUBDIR)/libitm/.libs:\n @endif target-libitm\n \n+@if target-libatomic\n+TARGET_LIB_PATH_libatomic = $$r/$(TARGET_SUBDIR)/libatomic/.libs:\n+@endif target-libatomic\n+\n \n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n@@ -960,7 +964,8 @@ configure-target:  \\\n     maybe-configure-target-rda \\\n     maybe-configure-target-libada \\\n     maybe-configure-target-libgomp \\\n-    maybe-configure-target-libitm\n+    maybe-configure-target-libitm \\\n+    maybe-configure-target-libatomic\n \n # The target built for a native non-bootstrap build.\n .PHONY: all\n@@ -1108,6 +1113,7 @@ all-target: maybe-all-target-libada\n all-target: maybe-all-target-libgomp\n @endif target-libgomp-no-bootstrap\n all-target: maybe-all-target-libitm\n+all-target: maybe-all-target-libatomic\n \n # Do a target for all the subdirectories.  A ``make do-X'' will do a\n # ``make X'' in all subdirectories (because, in general, there is a\n@@ -1191,6 +1197,7 @@ info-target: maybe-info-target-rda\n info-target: maybe-info-target-libada\n info-target: maybe-info-target-libgomp\n info-target: maybe-info-target-libitm\n+info-target: maybe-info-target-libatomic\n \n .PHONY: do-dvi\n do-dvi:\n@@ -1269,6 +1276,7 @@ dvi-target: maybe-dvi-target-rda\n dvi-target: maybe-dvi-target-libada\n dvi-target: maybe-dvi-target-libgomp\n dvi-target: maybe-dvi-target-libitm\n+dvi-target: maybe-dvi-target-libatomic\n \n .PHONY: do-pdf\n do-pdf:\n@@ -1347,6 +1355,7 @@ pdf-target: maybe-pdf-target-rda\n pdf-target: maybe-pdf-target-libada\n pdf-target: maybe-pdf-target-libgomp\n pdf-target: maybe-pdf-target-libitm\n+pdf-target: maybe-pdf-target-libatomic\n \n .PHONY: do-html\n do-html:\n@@ -1425,6 +1434,7 @@ html-target: maybe-html-target-rda\n html-target: maybe-html-target-libada\n html-target: maybe-html-target-libgomp\n html-target: maybe-html-target-libitm\n+html-target: maybe-html-target-libatomic\n \n .PHONY: do-TAGS\n do-TAGS:\n@@ -1503,6 +1513,7 @@ TAGS-target: maybe-TAGS-target-rda\n TAGS-target: maybe-TAGS-target-libada\n TAGS-target: maybe-TAGS-target-libgomp\n TAGS-target: maybe-TAGS-target-libitm\n+TAGS-target: maybe-TAGS-target-libatomic\n \n .PHONY: do-install-info\n do-install-info:\n@@ -1581,6 +1592,7 @@ install-info-target: maybe-install-info-target-rda\n install-info-target: maybe-install-info-target-libada\n install-info-target: maybe-install-info-target-libgomp\n install-info-target: maybe-install-info-target-libitm\n+install-info-target: maybe-install-info-target-libatomic\n \n .PHONY: do-install-pdf\n do-install-pdf:\n@@ -1659,6 +1671,7 @@ install-pdf-target: maybe-install-pdf-target-rda\n install-pdf-target: maybe-install-pdf-target-libada\n install-pdf-target: maybe-install-pdf-target-libgomp\n install-pdf-target: maybe-install-pdf-target-libitm\n+install-pdf-target: maybe-install-pdf-target-libatomic\n \n .PHONY: do-install-html\n do-install-html:\n@@ -1737,6 +1750,7 @@ install-html-target: maybe-install-html-target-rda\n install-html-target: maybe-install-html-target-libada\n install-html-target: maybe-install-html-target-libgomp\n install-html-target: maybe-install-html-target-libitm\n+install-html-target: maybe-install-html-target-libatomic\n \n .PHONY: do-installcheck\n do-installcheck:\n@@ -1815,6 +1829,7 @@ installcheck-target: maybe-installcheck-target-rda\n installcheck-target: maybe-installcheck-target-libada\n installcheck-target: maybe-installcheck-target-libgomp\n installcheck-target: maybe-installcheck-target-libitm\n+installcheck-target: maybe-installcheck-target-libatomic\n \n .PHONY: do-mostlyclean\n do-mostlyclean:\n@@ -1893,6 +1908,7 @@ mostlyclean-target: maybe-mostlyclean-target-rda\n mostlyclean-target: maybe-mostlyclean-target-libada\n mostlyclean-target: maybe-mostlyclean-target-libgomp\n mostlyclean-target: maybe-mostlyclean-target-libitm\n+mostlyclean-target: maybe-mostlyclean-target-libatomic\n \n .PHONY: do-clean\n do-clean:\n@@ -1971,6 +1987,7 @@ clean-target: maybe-clean-target-rda\n clean-target: maybe-clean-target-libada\n clean-target: maybe-clean-target-libgomp\n clean-target: maybe-clean-target-libitm\n+clean-target: maybe-clean-target-libatomic\n \n .PHONY: do-distclean\n do-distclean:\n@@ -2049,6 +2066,7 @@ distclean-target: maybe-distclean-target-rda\n distclean-target: maybe-distclean-target-libada\n distclean-target: maybe-distclean-target-libgomp\n distclean-target: maybe-distclean-target-libitm\n+distclean-target: maybe-distclean-target-libatomic\n \n .PHONY: do-maintainer-clean\n do-maintainer-clean:\n@@ -2127,6 +2145,7 @@ maintainer-clean-target: maybe-maintainer-clean-target-rda\n maintainer-clean-target: maybe-maintainer-clean-target-libada\n maintainer-clean-target: maybe-maintainer-clean-target-libgomp\n maintainer-clean-target: maybe-maintainer-clean-target-libitm\n+maintainer-clean-target: maybe-maintainer-clean-target-libatomic\n \n \n # Here are the targets which correspond to the do-X targets.\n@@ -2259,7 +2278,8 @@ check-target:  \\\n     maybe-check-target-rda \\\n     maybe-check-target-libada \\\n     maybe-check-target-libgomp \\\n-    maybe-check-target-libitm\n+    maybe-check-target-libitm \\\n+    maybe-check-target-libatomic\n \n do-check:\n \t@: $(MAKE); $(unstage)\n@@ -2409,7 +2429,8 @@ install-target:  \\\n     maybe-install-target-rda \\\n     maybe-install-target-libada \\\n     maybe-install-target-libgomp \\\n-    maybe-install-target-libitm\n+    maybe-install-target-libitm \\\n+    maybe-install-target-libatomic\n \n uninstall:\n \t@echo \"the uninstall target is not supported in this tree\"\n@@ -2506,7 +2527,8 @@ install-strip-target:  \\\n     maybe-install-strip-target-rda \\\n     maybe-install-strip-target-libada \\\n     maybe-install-strip-target-libgomp \\\n-    maybe-install-strip-target-libitm\n+    maybe-install-strip-target-libitm \\\n+    maybe-install-strip-target-libatomic\n \n \n ### other supporting targets\n@@ -40629,6 +40651,463 @@ maintainer-clean-target-libitm:\n \n \n \n+\n+\n+.PHONY: configure-target-libatomic maybe-configure-target-libatomic\n+maybe-configure-target-libatomic:\n+@if gcc-bootstrap\n+configure-target-libatomic: stage_current\n+@endif gcc-bootstrap\n+@if target-libatomic\n+maybe-configure-target-libatomic: configure-target-libatomic\n+configure-target-libatomic: \n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\techo \"Checking multilib configuration for libatomic...\"; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libatomic ; \\\n+\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libatomic/multilib.tmp 2> /dev/null ; \\\n+\tif test -r $(TARGET_SUBDIR)/libatomic/multilib.out; then \\\n+\t  if cmp -s $(TARGET_SUBDIR)/libatomic/multilib.tmp $(TARGET_SUBDIR)/libatomic/multilib.out; then \\\n+\t    rm -f $(TARGET_SUBDIR)/libatomic/multilib.tmp; \\\n+\t  else \\\n+\t    rm -f $(TARGET_SUBDIR)/libatomic/Makefile; \\\n+\t    mv $(TARGET_SUBDIR)/libatomic/multilib.tmp $(TARGET_SUBDIR)/libatomic/multilib.out; \\\n+\t  fi; \\\n+\telse \\\n+\t  mv $(TARGET_SUBDIR)/libatomic/multilib.tmp $(TARGET_SUBDIR)/libatomic/multilib.out; \\\n+\tfi; \\\n+\ttest ! -f $(TARGET_SUBDIR)/libatomic/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libatomic ; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\techo Configuring in $(TARGET_SUBDIR)/libatomic; \\\n+\tcd \"$(TARGET_SUBDIR)/libatomic\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n+\t  *) topdir=`echo $(TARGET_SUBDIR)/libatomic/ | \\\n+\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n+\tesac; \\\n+\tsrcdiroption=\"--srcdir=$${topdir}/libatomic\"; \\\n+\tlibsrcdir=\"$$s/libatomic\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n+\t  --target=${target_alias} $${srcdiroption}  \\\n+\t  || exit 1\n+@endif target-libatomic\n+\n+\n+\n+\n+\n+.PHONY: all-target-libatomic maybe-all-target-libatomic\n+maybe-all-target-libatomic:\n+@if gcc-bootstrap\n+all-target-libatomic: stage_current\n+@endif gcc-bootstrap\n+@if target-libatomic\n+TARGET-target-libatomic=all\n+maybe-all-target-libatomic: all-target-libatomic\n+all-target-libatomic: configure-target-libatomic\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS)  \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)  \\\n+\t\t$(TARGET-target-libatomic))\n+@endif target-libatomic\n+\n+\n+\n+\n+\n+.PHONY: check-target-libatomic maybe-check-target-libatomic\n+maybe-check-target-libatomic:\n+@if target-libatomic\n+maybe-check-target-libatomic: check-target-libatomic\n+\n+check-target-libatomic:\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n+\n+@endif target-libatomic\n+\n+.PHONY: install-target-libatomic maybe-install-target-libatomic\n+maybe-install-target-libatomic:\n+@if target-libatomic\n+maybe-install-target-libatomic: install-target-libatomic\n+\n+install-target-libatomic: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n+\n+@endif target-libatomic\n+\n+.PHONY: install-strip-target-libatomic maybe-install-strip-target-libatomic\n+maybe-install-strip-target-libatomic:\n+@if target-libatomic\n+maybe-install-strip-target-libatomic: install-strip-target-libatomic\n+\n+install-strip-target-libatomic: installdirs\n+\t@: $(MAKE); $(unstage)\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n+\n+@endif target-libatomic\n+\n+# Other targets (info, dvi, pdf, etc.)\n+\n+.PHONY: maybe-info-target-libatomic info-target-libatomic\n+maybe-info-target-libatomic:\n+@if target-libatomic\n+maybe-info-target-libatomic: info-target-libatomic\n+\n+info-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           info) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-dvi-target-libatomic dvi-target-libatomic\n+maybe-dvi-target-libatomic:\n+@if target-libatomic\n+maybe-dvi-target-libatomic: dvi-target-libatomic\n+\n+dvi-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           dvi) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-pdf-target-libatomic pdf-target-libatomic\n+maybe-pdf-target-libatomic:\n+@if target-libatomic\n+maybe-pdf-target-libatomic: pdf-target-libatomic\n+\n+pdf-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing pdf in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           pdf) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-html-target-libatomic html-target-libatomic\n+maybe-html-target-libatomic:\n+@if target-libatomic\n+maybe-html-target-libatomic: html-target-libatomic\n+\n+html-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing html in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           html) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-TAGS-target-libatomic TAGS-target-libatomic\n+maybe-TAGS-target-libatomic:\n+@if target-libatomic\n+maybe-TAGS-target-libatomic: TAGS-target-libatomic\n+\n+TAGS-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           TAGS) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-install-info-target-libatomic install-info-target-libatomic\n+maybe-install-info-target-libatomic:\n+@if target-libatomic\n+maybe-install-info-target-libatomic: install-info-target-libatomic\n+\n+install-info-target-libatomic: \\\n+    configure-target-libatomic \\\n+    info-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-info) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-install-pdf-target-libatomic install-pdf-target-libatomic\n+maybe-install-pdf-target-libatomic:\n+@if target-libatomic\n+maybe-install-pdf-target-libatomic: install-pdf-target-libatomic\n+\n+install-pdf-target-libatomic: \\\n+    configure-target-libatomic \\\n+    pdf-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-pdf) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-install-html-target-libatomic install-html-target-libatomic\n+maybe-install-html-target-libatomic:\n+@if target-libatomic\n+maybe-install-html-target-libatomic: install-html-target-libatomic\n+\n+install-html-target-libatomic: \\\n+    configure-target-libatomic \\\n+    html-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing install-html in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           install-html) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-installcheck-target-libatomic installcheck-target-libatomic\n+maybe-installcheck-target-libatomic:\n+@if target-libatomic\n+maybe-installcheck-target-libatomic: installcheck-target-libatomic\n+\n+installcheck-target-libatomic: \\\n+    configure-target-libatomic \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           installcheck) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-mostlyclean-target-libatomic mostlyclean-target-libatomic\n+maybe-mostlyclean-target-libatomic:\n+@if target-libatomic\n+maybe-mostlyclean-target-libatomic: mostlyclean-target-libatomic\n+\n+mostlyclean-target-libatomic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           mostlyclean) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-clean-target-libatomic clean-target-libatomic\n+maybe-clean-target-libatomic:\n+@if target-libatomic\n+maybe-clean-target-libatomic: clean-target-libatomic\n+\n+clean-target-libatomic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           clean) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-distclean-target-libatomic distclean-target-libatomic\n+maybe-distclean-target-libatomic:\n+@if target-libatomic\n+maybe-distclean-target-libatomic: distclean-target-libatomic\n+\n+distclean-target-libatomic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           distclean) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+.PHONY: maybe-maintainer-clean-target-libatomic maintainer-clean-target-libatomic\n+maybe-maintainer-clean-target-libatomic:\n+@if target-libatomic\n+maybe-maintainer-clean-target-libatomic: maintainer-clean-target-libatomic\n+\n+maintainer-clean-target-libatomic: \n+\t@: $(MAKE); $(unstage)\n+\t@[ -f $(TARGET_SUBDIR)/libatomic/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(NORMAL_TARGET_EXPORTS) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libatomic\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libatomic && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n+\t           maintainer-clean) \\\n+\t  || exit 1\n+\n+@endif target-libatomic\n+\n+\n+\n @if target-libmudflap\n .PHONY: check-target-libmudflap-c++\n check-target-libmudflap-c++:\n@@ -42721,6 +43200,7 @@ configure-stage4-target-libgomp: maybe-all-stage4-gcc\n configure-stageprofile-target-libgomp: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libgomp: maybe-all-stagefeedback-gcc\n configure-target-libitm: stage_last\n+configure-target-libatomic: stage_last\n @endif gcc-bootstrap\n \n @if gcc-no-bootstrap\n@@ -42744,6 +43224,7 @@ configure-target-rda: maybe-all-gcc\n configure-target-libada: maybe-all-gcc\n configure-target-libgomp: maybe-all-gcc\n configure-target-libitm: maybe-all-gcc\n+configure-target-libatomic: maybe-all-gcc\n @endif gcc-no-bootstrap\n \n \n@@ -43519,6 +44000,7 @@ configure-target-rda: maybe-all-target-libgcc\n configure-target-libada: maybe-all-target-libgcc\n configure-target-libgomp: maybe-all-target-libgcc\n configure-target-libitm: maybe-all-target-libgcc\n+configure-target-libatomic: maybe-all-target-libgcc\n @endif gcc-no-bootstrap\n \n \n@@ -43561,6 +44043,8 @@ configure-target-libgomp: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-libitm: maybe-all-target-newlib maybe-all-target-libgloss\n configure-target-libitm: maybe-all-target-libstdc++-v3\n \n+configure-target-libatomic: maybe-all-target-newlib maybe-all-target-libgloss\n+\n \n CONFIGURE_GDB_TK = @CONFIGURE_GDB_TK@\n GDB_TK = @GDB_TK@"}, {"sha": "db75684f9f26d9ae1463c380a69043ac21b481be", "filename": "configure", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -2688,6 +2688,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n@@ -3064,6 +3065,25 @@ if test x$enable_libgomp = x ; then\n     esac\n fi\n \n+# Disable libatomic on unsupported systems.\n+if test -d ${srcdir}/libatomic; then\n+    if test x$enable_libatomic = x; then\n+\t{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for libatomic support\" >&5\n+$as_echo_n \"checking for libatomic support... \" >&6; }\n+\tif (srcdir=${srcdir}/libatomic; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: no\" >&5\n+$as_echo \"no\" >&6; }\n+\t    noconfigdirs=\"$noconfigdirs target-libatomic\"\n+\telse\n+\t    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: yes\" >&5\n+$as_echo \"yes\" >&6; }\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then"}, {"sha": "ad19defee6570cb6a5793fb0f85cdbb957977217", "filename": "configure.ac", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -154,6 +154,7 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libgomp \\\n+\t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n \t\ttarget-libmudflap \\\n@@ -493,6 +494,22 @@ if test x$enable_libgomp = x ; then\n     esac\n fi\n \n+# Disable libatomic on unsupported systems.\n+if test -d ${srcdir}/libatomic; then\n+    if test x$enable_libatomic = x; then\n+\tAC_MSG_CHECKING([for libatomic support])\n+\tif (srcdir=${srcdir}/libatomic; \\\n+\t\t. ${srcdir}/configure.tgt; \\\n+\t\ttest -n \"$UNSUPPORTED\")\n+\tthen\n+\t    AC_MSG_RESULT([no])\n+\t    noconfigdirs=\"$noconfigdirs target-libatomic\"\n+\telse\n+\t    AC_MSG_RESULT([yes])\n+\tfi\n+    fi\n+fi\n+\n # Disable libitm on unsupported systems.\n if test -d ${srcdir}/libitm; then\n     if test x$enable_libitm = x; then"}, {"sha": "af318aead9cc6621eff994105d59e24bc1633097", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -1,3 +1,7 @@\n+2012-05-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc_update: Add libatomic generated files.\n+\n 2012-04-23  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* compare_tests: Append '/' to make 'find' traverse"}, {"sha": "42a41a2d8dfa860a8514a31e991aa61d6c578d46", "filename": "contrib/gcc_update", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -144,6 +144,11 @@ libitm/Makefile.in: libitm/Makefile.am libitm/aclocal.m4\n libitm/testsuite/Makefile.in: libitm/testsuite/Makefile.am libitm/aclocal.m4\n libitm/configure: libitm/configure.ac libitm/aclocal.m4\n libitm/config.h.in: libitm/configure.ac libitm/aclocal.m4\n+libatomic/aclocal.m4: libatomic/configure.ac libatomic/acinclude.m4\n+libatomic/Makefile.in: libatomic/Makefile.am libatomic/aclocal.m4\n+libatomic/testsuite/Makefile.in: libatomic/testsuite/Makefile.am libatomic/aclocal.m4\n+libatomic/configure: libatomic/configure.ac libatomic/aclocal.m4\n+libatomic/auto-config.h.in: libatomic/configure.ac libatomic/aclocal.m4\n # Top level\n Makefile.in: Makefile.tpl Makefile.def\n configure: configure.ac config/acx.m4"}, {"sha": "361f15c84b67cdbdbb8c9bfcac3a16e1ada67d13", "filename": "libatomic/.gitignore", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2F.gitignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2F.gitignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2F.gitignore?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,2 @@\n+autom4te.cache\n+auto-config.h.in~"}, {"sha": "ca553aefe558735bbcc2fbfdef886166ef50f5e9", "filename": "libatomic/ChangeLog", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FChangeLog?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+2012-05-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* Initial commit."}, {"sha": "e08db5638fd6a5286dd674e07d226632c01705af", "filename": "libatomic/Makefile.am", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FMakefile.am?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,136 @@\n+##  Copyright (C) 2012 Free Software Foundation, Inc.\n+##  Contributed by Richard Henderson <rth@redhat.com>.\n+##\n+##  This file is part of the GNU Atomic Library (libatomic).\n+##\n+##  Libatomic is free software; you can redistribute it and/or modify it\n+##  under the terms of the GNU General Public License as published by\n+##  the Free Software Foundation; either version 3 of the License, or\n+##  (at your option) any later version.\n+##\n+##  Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+##  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+##  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+##  more details.\n+##\n+##  Under Section 7 of GPL version 3, you are granted additional\n+##  permissions described in the GCC Runtime Library Exception, version\n+##  3.1, as published by the Free Software Foundation.\n+##\n+##  You should have received a copy of the GNU General Public License and\n+##  a copy of the GCC Runtime Library Exception along with this program;\n+##  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+##  <http://www.gnu.org/licenses/>.\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+SUBDIRS = testsuite\n+\n+## May be used by toolexeclibdir.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+config_path= @config_path@\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) \\\n+\t$(top_srcdir) $(top_builddir)\n+\n+vpath % $(strip $(search_path))\n+\n+DEFAULT_INCLUDES = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+\n+toolexeclib_LTLIBRARIES = libatomic.la\n+\n+if LIBAT_BUILD_VERSIONED_SHLIB\n+if LIBAT_BUILD_VERSIONED_SHLIB_GNU\n+libatomic_version_script = -Wl,--version-script,$(top_srcdir)/libatomic.map\n+libatomic_version_dep = $(top_srcdir)/libatomic.map\n+endif\n+if LIBAT_BUILD_VERSIONED_SHLIB_SUN\n+libatomic_version_script = -Wl,-M,libatomic.map-sun\n+libatomic_version_dep = libatomic.map-sun\n+libatomic.map-sun : $(top_srcdir)/libatomic.map \\\n+\t\t$(top_srcdir)/../contrib/make_sunver.pl \\\n+\t\t$(libatomic_la_OBJECTS) $(libatomic_la_LIBADD)\n+\tperl $(top_srcdir)/../contrib/make_sunver.pl \\\n+\t  $(top_srcdir)/libatomic.map \\\n+\t  $(libatomic_la_OBJECTS:%.lo=.libs/%.o) \\\n+\t `echo $(libatomic_la_LIBADD) | \\\n+\t    sed 's,/\\([^/.]*\\)\\.la,/.libs/\\1.a,g'` \\\n+\t > $@ || (rm -f $@ ; exit 1)\n+endif\n+else\n+libatomic_version_script =\n+libatomic_version_dep =\n+endif\n+libatomic_version_info = -version-info $(libtool_VERSION)\n+\n+libatomic_la_LDFLAGS = $(libatomic_version_info) $(libatomic_version_script)\n+libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c\n+\n+SIZEOBJS = load store cas exch fadd fsub fand fior fxor fnand tas\n+SIZES = @SIZES@\n+\n+EXTRA_libatomic_la_SOURCES = $(addsuffix _n.c,$(SIZEOBJS))\n+libatomic_la_DEPENDENCIES = $(libatomic_la_LIBADD) $(libatomic_version_dep)\n+\n+## And now our custom target patterns that allow us not to have tons of\n+## extra source files hanging about.  Unfortunately, the complex relation\n+## between source and object filenames doesn't allow us to add an explicit\n+## dependency here.  Fortunately that doesn't matter since auto-generated\n+## dependencies do the job just as well:\n+-include $(wildcard $(DEPDIR)/*.Ppo)\n+\n+## Naming pattern: base_n_i_.lo\n+##\n+##\tN\tsize of data\n+##\tI\tIFUNC alternative, index beginning at 1.\n+##\n+## The trailing _ in the output object file name is required to differentiate\n+## these objects from those which should be compiled normally.  We can only\n+## have one stem in the implicit rule.\n+\n+empty\t\t=\n+space\t\t= $(empty) $(empty)\n+PAT_SPLIT\t= $(subst _,$(space),$(*F))\n+PAT_BASE\t= $(word 1,$(PAT_SPLIT))\n+PAT_N\t\t= $(word 2,$(PAT_SPLIT))\n+PAT_S\t\t= $(word 3,$(PAT_SPLIT))\n+IFUNC_DEF\t= -DIFUNC_ALT=$(PAT_S)\n+IFUNC_OPT\t= $(word $(PAT_S),$(IFUNC_OPTIONS))\n+\n+M_DEPS\t\t= -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo\n+M_SIZE\t\t= -DN=$(PAT_N)\n+M_IFUNC\t\t= $(if $(PAT_S),$(IFUNC_DEF) $(IFUNC_OPT))\n+M_FILE\t\t= $(PAT_BASE)_n.c\n+\n+# The lack of explicit dependency on the source file means that VPATH cannot\n+# work properly.  Instead, perform this operation by hand.  First, collect a\n+# list of all .c files in the search path.\n+all_c_files\t:= $(foreach dir,$(search_path),$(wildcard $(dir)/*.c))\n+\n+# Then sort through them to find the one we want, and select the first.\n+M_SRC\t\t= $(firstword $(filter %/$(M_FILE), $(all_c_files)))\n+\n+%_.lo: Makefile\n+\t$(LTCOMPILE) $(M_DEPS) $(M_SIZE) $(M_IFUNC) -c -o $@ $(M_SRC)\n+\n+## Include all of the sizes in the \"normal\" set of compilation flags.\n+libatomic_la_LIBADD = $(foreach s,$(SIZES),$(addsuffix _$(s)_.lo,$(SIZEOBJS)))\n+\n+## On a target-specific basis, include alternates to be selected by IFUNC.\n+if HAVE_IFUNC\n+if ARCH_ARM_LINUX\n+IFUNC_OPTIONS\t     = -march=armv7-a -DHAVE_KERNEL64\n+libatomic_la_LIBADD += $(foreach s,$(SIZES),$(addsuffix _$(s)_1_.lo,$(SIZEOBJS)))\n+libatomic_la_LIBADD += $(addsuffix _8_2_.lo,$(SIZEOBJS))\n+endif\n+if ARCH_I386\n+IFUNC_OPTIONS\t     = -march=i586\n+libatomic_la_LIBADD += $(addsuffix _8_1_.lo,$(SIZEOBJS))\n+endif\n+if ARCH_X86_64\n+IFUNC_OPTIONS\t     = -mcx16\n+libatomic_la_LIBADD += $(addsuffix _16_1_.lo,$(SIZEOBJS))\n+endif\n+endif"}, {"sha": "470f83bab9fad5b0c41912d7e7e3d23bdfae67cd", "filename": "libatomic/Makefile.in", "status": "added", "additions": 963, "deletions": 0, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2FMakefile.in?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,963 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@am__append_1 = $(foreach \\\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@\ts,$(SIZES),$(addsuffix \\\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@\t_$(s)_1_.lo,$(SIZEOBJS))) \\\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@\t$(addsuffix \\\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@\t_8_2_.lo,$(SIZEOBJS))\n+@ARCH_I386_TRUE@@HAVE_IFUNC_TRUE@am__append_2 = $(addsuffix _8_1_.lo,$(SIZEOBJS))\n+@ARCH_X86_64_TRUE@@HAVE_IFUNC_TRUE@am__append_3 = $(addsuffix _16_1_.lo,$(SIZEOBJS))\n+subdir = .\n+DIST_COMMON = $(am__configure_deps) $(srcdir)/../config.guess \\\n+\t$(srcdir)/../config.sub $(srcdir)/../depcomp \\\n+\t$(srcdir)/../install-sh $(srcdir)/../ltmain.sh \\\n+\t$(srcdir)/../missing $(srcdir)/../mkinstalldirs \\\n+\t$(srcdir)/Makefile.am $(srcdir)/Makefile.in \\\n+\t$(srcdir)/auto-config.h.in $(top_srcdir)/configure\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n+ configure.lineno config.status.lineno\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = auto-config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n+am__vpath_adj = case $$p in \\\n+    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n+    *) f=$$p;; \\\n+  esac;\n+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n+am__install_max = 40\n+am__nobase_strip_setup = \\\n+  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n+am__nobase_strip = \\\n+  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n+am__nobase_list = $(am__nobase_strip_setup); \\\n+  for p in $$list; do echo \"$$p $$p\"; done | \\\n+  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n+  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n+    if (++n[$$2] == $(am__install_max)) \\\n+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n+    END { for (dir in files) print dir, files[dir] }'\n+am__base_list = \\\n+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n+  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n+am_libatomic_la_OBJECTS = gload.lo gstore.lo gcas.lo gexch.lo \\\n+\tglfree.lo lock.lo init.lo\n+libatomic_la_OBJECTS = $(am_libatomic_la_OBJECTS)\n+libatomic_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n+\t$(libatomic_la_LDFLAGS) $(LDFLAGS) -o $@\n+depcomp = $(SHELL) $(top_srcdir)/../depcomp\n+am__depfiles_maybe = depfiles\n+am__mv = mv -f\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libatomic_la_SOURCES) $(EXTRA_libatomic_la_SOURCES)\n+DIST_SOURCES = $(libatomic_la_SOURCES) $(EXTRA_libatomic_la_SOURCES)\n+MULTISRCTOP = \n+MULTIBUILDTOP = \n+MULTIDIRS = \n+MULTISUBDIR = \n+MULTIDO = true\n+MULTICLEAN = true\n+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n+\thtml-recursive info-recursive install-data-recursive \\\n+\tinstall-dvi-recursive install-exec-recursive \\\n+\tinstall-html-recursive install-info-recursive \\\n+\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n+\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n+\tps-recursive uninstall-recursive\n+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n+  distclean-recursive maintainer-clean-recursive\n+AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n+\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS \\\n+\tdistdir dist dist-all distcheck\n+ETAGS = etags\n+CTAGS = ctags\n+DIST_SUBDIRS = $(SUBDIRS)\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+distdir = $(PACKAGE)-$(VERSION)\n+top_distdir = $(distdir)\n+am__remove_distdir = \\\n+  { test ! -d \"$(distdir)\" \\\n+    || { find \"$(distdir)\" -type d ! -perm -200 -exec chmod u+w {} ';' \\\n+         && rm -fr \"$(distdir)\"; }; }\n+am__relativize = \\\n+  dir0=`pwd`; \\\n+  sed_first='s,^\\([^/]*\\)/.*$$,\\1,'; \\\n+  sed_rest='s,^[^/]*/*,,'; \\\n+  sed_last='s,^.*/\\([^/]*\\)$$,\\1,'; \\\n+  sed_butlast='s,/*[^/]*$$,,'; \\\n+  while test -n \"$$dir1\"; do \\\n+    first=`echo \"$$dir1\" | sed -e \"$$sed_first\"`; \\\n+    if test \"$$first\" != \".\"; then \\\n+      if test \"$$first\" = \"..\"; then \\\n+        dir2=`echo \"$$dir0\" | sed -e \"$$sed_last\"`/\"$$dir2\"; \\\n+        dir0=`echo \"$$dir0\" | sed -e \"$$sed_butlast\"`; \\\n+      else \\\n+        first2=`echo \"$$dir2\" | sed -e \"$$sed_first\"`; \\\n+        if test \"$$first2\" = \"$$first\"; then \\\n+          dir2=`echo \"$$dir2\" | sed -e \"$$sed_rest\"`; \\\n+        else \\\n+          dir2=\"../$$dir2\"; \\\n+        fi; \\\n+        dir0=\"$$dir0\"/\"$$first\"; \\\n+      fi; \\\n+    fi; \\\n+    dir1=`echo \"$$dir1\" | sed -e \"$$sed_rest\"`; \\\n+  done; \\\n+  reldir=\"$$dir2\"\n+DIST_ARCHIVES = $(distdir).tar.gz\n+GZIP_ENV = --best\n+distuninstallcheck_listfiles = find . -type f -print\n+distcleancheck_listfiles = find . -type f -print\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PERL = @PERL@\n+RANLIB = @RANLIB@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+SIZES = @SIZES@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+XLDFLAGS = @XLDFLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+config_path = @config_path@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+SUBDIRS = testsuite\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+search_path = $(addprefix $(top_srcdir)/config/, $(config_path)) \\\n+\t$(top_srcdir) $(top_builddir)\n+\n+DEFAULT_INCLUDES = $(addprefix -I, $(search_path))\n+AM_CFLAGS = $(XCFLAGS)\n+AM_CCASFLAGS = $(XCFLAGS)\n+AM_LDFLAGS = $(XLDFLAGS) $(SECTION_LDFLAGS) $(OPT_LDFLAGS)\n+toolexeclib_LTLIBRARIES = libatomic.la\n+@LIBAT_BUILD_VERSIONED_SHLIB_FALSE@libatomic_version_script = \n+@LIBAT_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic_version_script = -Wl,--version-script,$(top_srcdir)/libatomic.map\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic_version_script = -Wl,-M,libatomic.map-sun\n+@LIBAT_BUILD_VERSIONED_SHLIB_FALSE@libatomic_version_dep = \n+@LIBAT_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic_version_dep = $(top_srcdir)/libatomic.map\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic_version_dep = libatomic.map-sun\n+libatomic_version_info = -version-info $(libtool_VERSION)\n+libatomic_la_LDFLAGS = $(libatomic_version_info) $(libatomic_version_script)\n+libatomic_la_SOURCES = gload.c gstore.c gcas.c gexch.c glfree.c lock.c init.c\n+SIZEOBJS = load store cas exch fadd fsub fand fior fxor fnand tas\n+EXTRA_libatomic_la_SOURCES = $(addsuffix _n.c,$(SIZEOBJS))\n+libatomic_la_DEPENDENCIES = $(libatomic_la_LIBADD) $(libatomic_version_dep)\n+empty = \n+space = $(empty) $(empty)\n+PAT_SPLIT = $(subst _,$(space),$(*F))\n+PAT_BASE = $(word 1,$(PAT_SPLIT))\n+PAT_N = $(word 2,$(PAT_SPLIT))\n+PAT_S = $(word 3,$(PAT_SPLIT))\n+IFUNC_DEF = -DIFUNC_ALT=$(PAT_S)\n+IFUNC_OPT = $(word $(PAT_S),$(IFUNC_OPTIONS))\n+M_DEPS = -MT $@ -MD -MP -MF $(DEPDIR)/$(@F).Ppo\n+M_SIZE = -DN=$(PAT_N)\n+M_IFUNC = $(if $(PAT_S),$(IFUNC_DEF) $(IFUNC_OPT))\n+M_FILE = $(PAT_BASE)_n.c\n+\n+# The lack of explicit dependency on the source file means that VPATH cannot\n+# work properly.  Instead, perform this operation by hand.  First, collect a\n+# list of all .c files in the search path.\n+all_c_files := $(foreach dir,$(search_path),$(wildcard $(dir)/*.c))\n+\n+# Then sort through them to find the one we want, and select the first.\n+M_SRC = $(firstword $(filter %/$(M_FILE), $(all_c_files)))\n+libatomic_la_LIBADD = $(foreach s,$(SIZES),$(addsuffix \\\n+\t_$(s)_.lo,$(SIZEOBJS))) $(am__append_1) $(am__append_2) \\\n+\t$(am__append_3)\n+@ARCH_ARM_LINUX_TRUE@@HAVE_IFUNC_TRUE@IFUNC_OPTIONS = -march=armv7-a -DHAVE_KERNEL64\n+@ARCH_I386_TRUE@@HAVE_IFUNC_TRUE@IFUNC_OPTIONS = -march=i586\n+@ARCH_X86_64_TRUE@@HAVE_IFUNC_TRUE@IFUNC_OPTIONS = -mcx16\n+all: auto-config.h\n+\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n+\n+.SUFFIXES:\n+.SUFFIXES: .c .lo .o .obj\n+am--refresh:\n+\t@:\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n+\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n+\t\t&& exit 0; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    echo ' $(SHELL) ./config.status'; \\\n+\t    $(SHELL) ./config.status;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\t$(SHELL) ./config.status --recheck\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\t$(am__cd) $(srcdir) && $(AUTOCONF)\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n+$(am__aclocal_m4_deps):\n+\n+auto-config.h: stamp-h1\n+\t@if test ! -f $@; then \\\n+\t  rm -f stamp-h1; \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n+\telse :; fi\n+\n+stamp-h1: $(srcdir)/auto-config.h.in $(top_builddir)/config.status\n+\t@rm -f stamp-h1\n+\tcd $(top_builddir) && $(SHELL) ./config.status auto-config.h\n+$(srcdir)/auto-config.h.in:  $(am__configure_deps) \n+\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n+\trm -f stamp-h1\n+\ttouch $@\n+\n+distclean-hdr:\n+\t-rm -f auto-config.h stamp-h1\n+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tlist2=; for p in $$list; do \\\n+\t  if test -f $$p; then \\\n+\t    list2=\"$$list2 $$p\"; \\\n+\t  else :; fi; \\\n+\tdone; \\\n+\ttest -z \"$$list2\" || { \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n+\t}\n+\n+uninstall-toolexeclibLTLIBRARIES:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  $(am__strip_dir) \\\n+\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n+\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n+\tdone\n+\n+clean-toolexeclibLTLIBRARIES:\n+\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n+\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n+\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n+\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n+\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n+\t  rm -f \"$${dir}/so_locations\"; \\\n+\tdone\n+libatomic.la: $(libatomic_la_OBJECTS) $(libatomic_la_DEPENDENCIES) \n+\t$(libatomic_la_LINK) -rpath $(toolexeclibdir) $(libatomic_la_OBJECTS) $(libatomic_la_LIBADD) $(LIBS)\n+\n+mostlyclean-compile:\n+\t-rm -f *.$(OBJEXT)\n+\n+distclean-compile:\n+\t-rm -f *.tab.c\n+\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gcas.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gexch.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glfree.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gload.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gstore.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/init.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock.Plo@am__quote@\n+\n+.c.o:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n+\n+.c.obj:\n+@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n+\n+.c.lo:\n+@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+\n+distclean-libtool:\n+\t-rm -f libtool config.lt\n+\n+# GNU Make needs to see an explicit $(MAKE) variable in the command it\n+# runs to enable its job server during parallel builds.  Hence the\n+# comments below.\n+all-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n+install-multi:\n+\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n+\n+mostlyclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n+clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n+distclean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n+maintainer-clean-multi:\n+\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n+\n+# This directory's subdirectories are mostly independent; you can cd\n+# into them and run `make' without going through this Makefile.\n+# To change the values of `make' variables: instead of editing Makefiles,\n+# (1) if the variable is set in `config.status', edit `config.status'\n+#     (which will cause the Makefiles to be regenerated when you run `make');\n+# (2) otherwise, pass the desired values on the `make' command line.\n+$(RECURSIVE_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    dot_seen=yes; \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone; \\\n+\tif test \"$$dot_seen\" = \"no\"; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n+\tfi; test -z \"$$fail\"\n+\n+$(RECURSIVE_CLEAN_TARGETS):\n+\t@fail= failcom='exit 1'; \\\n+\tfor f in x $$MAKEFLAGS; do \\\n+\t  case $$f in \\\n+\t    *=* | --[!k]*);; \\\n+\t    *k*) failcom='fail=yes';; \\\n+\t  esac; \\\n+\tdone; \\\n+\tdot_seen=no; \\\n+\tcase \"$@\" in \\\n+\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n+\t  *) list='$(SUBDIRS)' ;; \\\n+\tesac; \\\n+\trev=''; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = \".\"; then :; else \\\n+\t    rev=\"$$subdir $$rev\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\trev=\"$$rev .\"; \\\n+\ttarget=`echo $@ | sed s/-recursive//`; \\\n+\tfor subdir in $$rev; do \\\n+\t  echo \"Making $$target in $$subdir\"; \\\n+\t  if test \"$$subdir\" = \".\"; then \\\n+\t    local_target=\"$$target-am\"; \\\n+\t  else \\\n+\t    local_target=\"$$target\"; \\\n+\t  fi; \\\n+\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n+\t  || eval $$failcom; \\\n+\tdone && test -z \"$$fail\"\n+tags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n+\tdone\n+ctags-recursive:\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n+\tdone\n+\n+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n+\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tmkid -fID $$unique\n+tags: TAGS\n+\n+TAGS: tags-recursive $(HEADERS) $(SOURCES) auto-config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tset x; \\\n+\there=`pwd`; \\\n+\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n+\t  include_option=--etags-include; \\\n+\t  empty_fix=.; \\\n+\telse \\\n+\t  include_option=--include; \\\n+\t  empty_fix=; \\\n+\tfi; \\\n+\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test ! -f $$subdir/TAGS || \\\n+\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n+\t  fi; \\\n+\tdone; \\\n+\tlist='$(SOURCES) $(HEADERS) auto-config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\tshift; \\\n+\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n+\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n+\t  if test $$# -gt 0; then \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      \"$$@\" $$unique; \\\n+\t  else \\\n+\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n+\t      $$unique; \\\n+\t  fi; \\\n+\tfi\n+ctags: CTAGS\n+CTAGS: ctags-recursive $(HEADERS) $(SOURCES) auto-config.h.in $(TAGS_DEPENDENCIES) \\\n+\t\t$(TAGS_FILES) $(LISP)\n+\tlist='$(SOURCES) $(HEADERS) auto-config.h.in $(LISP) $(TAGS_FILES)'; \\\n+\tunique=`for i in $$list; do \\\n+\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n+\t  done | \\\n+\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n+\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n+\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n+\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n+\t     $$unique\n+\n+GTAGS:\n+\there=`$(am__cd) $(top_builddir) && pwd` \\\n+\t  && $(am__cd) $(top_srcdir) \\\n+\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n+\n+distclean-tags:\n+\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n+\n+distdir: $(DISTFILES)\n+\t$(am__remove_distdir)\n+\ttest -d \"$(distdir)\" || mkdir \"$(distdir)\"\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    test -d \"$(distdir)/$$subdir\" \\\n+\t    || $(MKDIR_P) \"$(distdir)/$$subdir\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n+\t  if test \"$$subdir\" = .; then :; else \\\n+\t    dir1=$$subdir; dir2=\"$(distdir)/$$subdir\"; \\\n+\t    $(am__relativize); \\\n+\t    new_distdir=$$reldir; \\\n+\t    dir1=$$subdir; dir2=\"$(top_distdir)\"; \\\n+\t    $(am__relativize); \\\n+\t    new_top_distdir=$$reldir; \\\n+\t    echo \" (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=\"$$new_top_distdir\" distdir=\"$$new_distdir\" \\\\\"; \\\n+\t    echo \"     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)\"; \\\n+\t    ($(am__cd) $$subdir && \\\n+\t      $(MAKE) $(AM_MAKEFLAGS) \\\n+\t        top_distdir=\"$$new_top_distdir\" \\\n+\t        distdir=\"$$new_distdir\" \\\n+\t\tam__remove_distdir=: \\\n+\t\tam__skip_length_check=: \\\n+\t\tam__skip_mode_fix=: \\\n+\t        distdir) \\\n+\t      || exit 1; \\\n+\t  fi; \\\n+\tdone\n+\t-test -n \"$(am__skip_mode_fix)\" \\\n+\t|| find \"$(distdir)\" -type d ! -perm -755 \\\n+\t\t-exec chmod u+rwx,go+rx {} \\; -o \\\n+\t  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -400 -exec chmod a+r {} \\; -o \\\n+\t  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \\; \\\n+\t|| chmod -R a+r \"$(distdir)\"\n+dist-gzip: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+dist-bzip2: distdir\n+\ttardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2\n+\t$(am__remove_distdir)\n+\n+dist-lzma: distdir\n+\ttardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma\n+\t$(am__remove_distdir)\n+\n+dist-xz: distdir\n+\ttardir=$(distdir) && $(am__tar) | xz -c >$(distdir).tar.xz\n+\t$(am__remove_distdir)\n+\n+dist-tarZ: distdir\n+\ttardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z\n+\t$(am__remove_distdir)\n+\n+dist-shar: distdir\n+\tshar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz\n+\t$(am__remove_distdir)\n+\n+dist-zip: distdir\n+\t-rm -f $(distdir).zip\n+\tzip -rq $(distdir).zip $(distdir)\n+\t$(am__remove_distdir)\n+\n+dist dist-all: distdir\n+\ttardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz\n+\t$(am__remove_distdir)\n+\n+# This target untars the dist file and tries a VPATH configuration.  Then\n+# it guarantees that the distribution is self-contained by making another\n+# tarfile.\n+distcheck: dist\n+\tcase '$(DIST_ARCHIVES)' in \\\n+\t*.tar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\\\n+\t*.tar.bz2*) \\\n+\t  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\\\n+\t*.tar.lzma*) \\\n+\t  lzma -dc $(distdir).tar.lzma | $(am__untar) ;;\\\n+\t*.tar.xz*) \\\n+\t  xz -dc $(distdir).tar.xz | $(am__untar) ;;\\\n+\t*.tar.Z*) \\\n+\t  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\\\n+\t*.shar.gz*) \\\n+\t  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\\\n+\t*.zip*) \\\n+\t  unzip $(distdir).zip ;;\\\n+\tesac\n+\tchmod -R a-w $(distdir); chmod a+w $(distdir)\n+\tmkdir $(distdir)/_build\n+\tmkdir $(distdir)/_inst\n+\tchmod a-w $(distdir)\n+\ttest -d $(distdir)/_build || exit 0; \\\n+\tdc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\\\/]:[\\\\/],/,'` \\\n+\t  && dc_destdir=\"$${TMPDIR-/tmp}/am-dc-$$$$/\" \\\n+\t  && am__cwd=`pwd` \\\n+\t  && $(am__cd) $(distdir)/_build \\\n+\t  && ../configure --srcdir=.. --prefix=\"$$dc_install_base\" \\\n+\t    $(DISTCHECK_CONFIGURE_FLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dvi \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) check \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) install \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) installcheck \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) uninstall \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir=\"$$dc_install_base\" \\\n+\t        distuninstallcheck \\\n+\t  && chmod -R a-w \"$$dc_install_base\" \\\n+\t  && ({ \\\n+\t       (cd ../.. && umask 077 && mkdir \"$$dc_destdir\") \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" install \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" uninstall \\\n+\t       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR=\"$$dc_destdir\" \\\n+\t            distuninstallcheck_dir=\"$$dc_destdir\" distuninstallcheck; \\\n+\t      } || { rm -rf \"$$dc_destdir\"; exit 1; }) \\\n+\t  && rm -rf \"$$dc_destdir\" \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) dist \\\n+\t  && rm -rf $(DIST_ARCHIVES) \\\n+\t  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \\\n+\t  && cd \"$$am__cwd\" \\\n+\t  || exit 1\n+\t$(am__remove_distdir)\n+\t@(echo \"$(distdir) archives ready for distribution: \"; \\\n+\t  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \\\n+\t  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'\n+distuninstallcheck:\n+\t@$(am__cd) '$(distuninstallcheck_dir)' \\\n+\t&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \\\n+\t   || { echo \"ERROR: files left after uninstall:\" ; \\\n+\t        if test -n \"$(DESTDIR)\"; then \\\n+\t          echo \"  (check DESTDIR support)\"; \\\n+\t        fi ; \\\n+\t        $(distuninstallcheck_listfiles) ; \\\n+\t        exit 1; } >&2\n+distcleancheck: distclean\n+\t@if test '$(srcdir)' = . ; then \\\n+\t  echo \"ERROR: distcleancheck can only run from a VPATH build\" ; \\\n+\t  exit 1 ; \\\n+\tfi\n+\t@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \\\n+\t  || { echo \"ERROR: files left in build directory after distclean:\" ; \\\n+\t       $(distcleancheck_listfiles) ; \\\n+\t       exit 1; } >&2\n+check-am: all-am\n+check: check-recursive\n+all-am: Makefile $(LTLIBRARIES) all-multi auto-config.h\n+installdirs: installdirs-recursive\n+installdirs-am:\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n+\tdone\n+install: install-recursive\n+install-exec: install-exec-recursive\n+install-data: install-data-recursive\n+uninstall: uninstall-recursive\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-recursive\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-multi clean-recursive\n+\n+clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n+\tmostlyclean-am\n+\n+distclean: distclean-multi distclean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-compile distclean-generic \\\n+\tdistclean-hdr distclean-libtool distclean-tags\n+\n+dvi: dvi-recursive\n+\n+dvi-am:\n+\n+html: html-recursive\n+\n+html-am:\n+\n+info: info-recursive\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-recursive\n+\n+install-dvi-am:\n+\n+install-exec-am: install-multi install-toolexeclibLTLIBRARIES\n+\n+install-html: install-html-recursive\n+\n+install-html-am:\n+\n+install-info: install-info-recursive\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-recursive\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-recursive\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n+\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n+\t-rm -rf $(top_srcdir)/autom4te.cache\n+\t-rm -rf ./$(DEPDIR)\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-multi mostlyclean-recursive\n+\n+mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool\n+\n+pdf: pdf-recursive\n+\n+pdf-am:\n+\n+ps: ps-recursive\n+\n+ps-am:\n+\n+uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+\n+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n+\tclean-multi ctags-recursive distclean-multi install-am \\\n+\tinstall-multi install-strip maintainer-clean-multi \\\n+\tmostlyclean-multi tags-recursive\n+\n+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n+\tall all-am all-multi am--refresh check check-am clean \\\n+\tclean-generic clean-libtool clean-multi \\\n+\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive dist \\\n+\tdist-all dist-bzip2 dist-gzip dist-lzma dist-shar dist-tarZ \\\n+\tdist-xz dist-zip distcheck distclean distclean-compile \\\n+\tdistclean-generic distclean-hdr distclean-libtool \\\n+\tdistclean-multi distclean-tags distcleancheck distdir \\\n+\tdistuninstallcheck dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-multi install-pdf install-pdf-am install-ps \\\n+\tinstall-ps-am install-strip install-toolexeclibLTLIBRARIES \\\n+\tinstallcheck installcheck-am installdirs installdirs-am \\\n+\tmaintainer-clean maintainer-clean-generic \\\n+\tmaintainer-clean-multi mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool mostlyclean-multi pdf \\\n+\tpdf-am ps ps-am tags tags-recursive uninstall uninstall-am \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+\n+vpath % $(strip $(search_path))\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@libatomic.map-sun : $(top_srcdir)/libatomic.map \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t\t$(top_srcdir)/../contrib/make_sunver.pl \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t\t$(libatomic_la_OBJECTS) $(libatomic_la_LIBADD)\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\tperl $(top_srcdir)/../contrib/make_sunver.pl \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t  $(top_srcdir)/libatomic.map \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t  $(libatomic_la_OBJECTS:%.lo=.libs/%.o) \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t `echo $(libatomic_la_LIBADD) | \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t    sed 's,/\\([^/.]*\\)\\.la,/.libs/\\1.a,g'` \\\n+@LIBAT_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBAT_BUILD_VERSIONED_SHLIB_TRUE@\t > $@ || (rm -f $@ ; exit 1)\n+\n+-include $(wildcard $(DEPDIR)/*.Ppo)\n+\n+%_.lo: Makefile\n+\t$(LTCOMPILE) $(M_DEPS) $(M_SIZE) $(M_IFUNC) -c -o $@ $(M_SRC)\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "13206f0a2a654ae7ed115d38f6055a51ee302314", "filename": "libatomic/acinclude.m4", "status": "added", "additions": 637, "deletions": 0, "changes": 637, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Facinclude.m4?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,637 @@\n+dnl\n+dnl Unconditionally define a preprocessor macro, translating the shell\n+dnl macro from yes/no to 1/0.\n+dnl\n+AC_DEFUN([LIBAT_DEFINE_YESNO], [\n+  yesno=`echo $2 | tr 'yesno' '1  0 '`\n+  AC_DEFINE_UNQUOTED([$1], $yesno, [$3])\n+])\n+dnl\n+dnl Iterate over all of the modes we're prepared to check.\n+dnl\n+AC_DEFUN([LIBAT_FORALL_MODES],\n+  [$1(QI,1)\n+  $1(HI,2)\n+  $1(SI,4)\n+  $1(DI,8)\n+  $1(TI,16)]\n+)\n+dnl\n+dnl Check for builtin types by mode.\n+dnl\n+dnl A less interesting of size checking than autoconf normally provides.\n+dnl We know that gcc always provides <stdint.h>, but we don't often\n+dnl provide a builtin type for TImode.\n+dnl\n+AC_DEFUN([LIBAT_HAVE_INT_MODE],[\n+  AC_CACHE_CHECK([for $2 byte integer],[libat_cv_have_mode_$1],\n+    [AC_COMPILE_IFELSE([int x __attribute__((mode($1)));],\n+      [libat_cv_have_mode_$1=yes],[libat_cv_have_mode_$1=no])])\n+  LIBAT_DEFINE_YESNO([HAVE_INT$2], [$libat_cv_have_mode_$1],\n+      [Have support for $2 byte integers.])\n+  if test x$libat_cv_have_mode_$1 = xyes; then\n+    SIZES=\"$SIZES $2\"\n+  fi\n+])\n+dnl\n+dnl Check for atomic builtins.\n+dnl See:\n+dnl http://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html\n+dnl\n+dnl This checks to see if the host supports the compiler-generated\n+dnl builtins for atomic operations for various integral sizes.\n+dnl\n+AC_DEFUN([LIBAT_TEST_ATOMIC_INIT],[\n+  # Do link tests if possible, instead asm tests, limited to some platforms\n+  # see discussion in PR target/40134, PR libstdc++/40133 and the thread\n+  # starting at http://gcc.gnu.org/ml/gcc-patches/2009-07/msg00322.html\n+  atomic_builtins_link_tests=no\n+  if test x$gcc_no_link != xyes; then\n+    # Can do link tests. Limit to some tested platforms\n+    case \"$host\" in\n+      *-*-linux* | *-*-uclinux* | *-*-kfreebsd*-gnu | *-*-gnu*)\n+\tatomic_builtins_link_tests=yes\n+\t;;\n+    esac\n+  fi\n+])\n+AC_DEFUN([LIBAT_TEST_ATOMIC_BUILTIN],[\n+  AC_CACHE_CHECK([$1],[$2],[\n+    AC_LANG_CONFTEST([AC_LANG_PROGRAM([],[$3])])\n+    if test x$atomic_builtins_link_tests = xyes; then\n+      if AC_TRY_EVAL(ac_link); then\n+        eval $2=yes\n+      else\n+        eval $2=no\n+      fi\n+    else\n+      old_CFLAGS=\"$CFLAGS\"\n+      # Compile unoptimized.\n+      CFLAGS='-O0 -S'\n+      if AC_TRY_EVAL(ac_compile); then\n+        if grep __atomic_ conftest.s >/dev/null 2>&1 ; then\n+\t  eval $2=no\n+        else\n+\t  eval $2=yes\n+        fi\n+      fi\n+      CFLAGS=\"$old_CFLAGS\"\n+    fi\n+    rm -f conftest*\n+  ])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_load and __atomic_store for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_LOADSTORE],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_load/store for size $2],\n+    [libat_cv_have_at_ldst_$2],\n+    [typedef int T __attribute__((mode($1)));\n+     T *x; volatile T sink; asm(\"\" : \"=g\"(x));\n+     sink = __atomic_load_n(x, 0);\n+     __atomic_store_n(x, sink, 0);])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_LDST_$2], [$libat_cv_have_at_ldst_$2],\n+\t[Have __atomic_load/store for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_LDST_$2 HAVE_ATOMIC_LDST_$2])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_test_and_set for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_TAS],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_test_and_set for size $2],\n+    [libat_cv_have_at_tas_$2],\n+    [typedef int T __attribute__((mode($1))); T *x; asm(\"\" : \"=g\"(x));\n+     __atomic_test_and_set(x, 0);])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_TAS_$2], [$libat_cv_have_at_tas_$2],\n+\t[Have __atomic_test_and_set for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_TAS_$2 HAVE_ATOMIC_TAS_$2])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_exchange for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_EXCHANGE],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_exchange for size $2],\n+    [libat_cv_have_at_exch_$2],\n+    [typedef int T __attribute__((mode($1))); T *x; asm(\"\" : \"=g\"(x));\n+     __atomic_exchange_n(x, 0, 0);])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_EXCHANGE_$2], [$libat_cv_have_at_exch_$2],\n+\t[Have __atomic_exchange for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_EXCHANGE_$2 HAVE_ATOMIC_EXCHANGE_$2])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_compare_exchange for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_CAS],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_compare_exchange for size $2],\n+    [libat_cv_have_at_cas_$2],\n+    [typedef int T __attribute__((mode($1))); T *x, *y;\n+     asm(\"\" : \"=g\"(x), \"=g\"(y));\n+     __atomic_compare_exchange_n(x, y, 0, 0, 0, 0);])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_CAS_$2], [$libat_cv_have_at_cas_$2],\n+\t[Have __atomic_compare_exchange for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_CAS_$2 HAVE_ATOMIC_CAS_$2])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_fetch_add for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_FETCH_ADD],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_fetch_add for size $2],\n+    [libat_cv_have_at_fadd_$2],\n+    [typedef int T __attribute__((mode($1))); T *x, y;\n+     asm(\"\" : \"=g\"(x), \"=g\"(y));\n+     __atomic_fetch_add (x, y, 0);\n+     __atomic_add_fetch (x, y, 0);])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_FETCH_ADD_$2], [$libat_cv_have_at_fadd_$2],\n+\t[Have __atomic_fetch_add for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_FETCH_ADD_$2 HAVE_ATOMIC_FETCH_ADD_$2])\n+])\n+\n+dnl\n+dnl Test if we have __atomic_fetch_op for all op for mode $1, size $2\n+dnl\n+AC_DEFUN([LIBAT_HAVE_ATOMIC_FETCH_OP],[\n+  LIBAT_TEST_ATOMIC_BUILTIN([for __atomic_fetch_op for size $2],\n+    [libat_cv_have_at_fop_$2],\n+    [typedef int T __attribute__((mode($1))); T *x, y;\n+     asm(\"\" : \"=g\"(x), \"=g\"(y));\n+     __atomic_fetch_add (x, y, 0); __atomic_add_fetch (x, y, 0);\n+     __atomic_fetch_sub (x, y, 0); __atomic_sub_fetch (x, y, 0);\n+     __atomic_fetch_and (x, y, 0); __atomic_and_fetch (x, y, 0);\n+     __atomic_fetch_nand (x, y, 0); __atomic_nand_fetch (x, y, 0);\n+     __atomic_fetch_xor (x, y, 0); __atomic_xor_fetch (x, y, 0);\n+     __atomic_fetch_or (x, y, 0);  __atomic_or_fetch (x, y, 0); ])\n+  LIBAT_DEFINE_YESNO([HAVE_ATOMIC_FETCH_OP_$2], [$libat_cv_have_at_fop_$2],\n+\t[Have __atomic_fetch_op for all op for $2 byte integers.])\n+  AH_BOTTOM([#define MAYBE_HAVE_ATOMIC_FETCH_OP_$2 HAVE_ATOMIC_FETCH_OP_$2])\n+])\n+\n+dnl\n+dnl Test for the size of the target word.\n+dnl\n+AC_DEFUN([LIBAT_WORDSIZE],[\n+  AC_CACHE_CHECK([for the word size],[libat_cv_wordsize],\n+    [AC_COMPUTE_INT(libat_cv_wordsize,\n+      [sizeof(word)], [typedef int word __attribute__((mode(word)));],\n+      AC_ERROR([Could not determine word size.]))])\n+  AC_DEFINE_UNQUOTED(WORDSIZE, $libat_cv_wordsize,\n+    [The word size in bytes of the machine.])\n+])\n+\n+dnl\n+dnl Check whether the target supports ifuncs.\n+dnl\n+AC_DEFUN([LIBAT_CHECK_IFUNC], [\n+  AC_CACHE_CHECK([whether the target supports funcs], libat_cv_have_ifunc, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_LINK([\n+    int foo_alt(void) { return 0; }\n+    void *foo_sel(void) { return foo_alt; }\n+    int foo(void) __attribute__((ifunc(\"foo_sel\")));],\n+    [return foo();], libat_cv_have_ifunc=yes, libat_cv_have_ifunc=no)])\n+  LIBAT_DEFINE_YESNO([HAVE_IFUNC], [$libat_cv_have_ifunc],\n+      [Define to 1 if the target supports __attribute__((ifunc(...))).])\n+])\n+\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libitm.\n+\n+dnl Check whether the target supports hidden visibility.\n+AC_DEFUN([LIBAT_CHECK_ATTRIBUTE_VISIBILITY], [\n+  AC_CACHE_CHECK([whether the target supports hidden visibility],\n+\t\t libat_cv_have_attribute_visibility, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((visibility(\"hidden\"))) foo(void) { }],\n+\t\t [], libat_cv_have_attribute_visibility=yes,\n+\t\t libat_cv_have_attribute_visibility=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $libat_cv_have_attribute_visibility = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_VISIBILITY, 1,\n+      [Define to 1 if the target supports __attribute__((visibility(...))).])\n+  fi])\n+\n+dnl Check whether the target supports dllexport\n+AC_DEFUN([LIBAT_CHECK_ATTRIBUTE_DLLEXPORT], [\n+  AC_CACHE_CHECK([whether the target supports dllexport],\n+\t\t libat_cv_have_attribute_dllexport, [\n+  save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror\"\n+  AC_TRY_COMPILE([void __attribute__((dllexport)) foo(void) { }],\n+\t\t [], libat_cv_have_attribute_dllexport=yes,\n+\t\t libat_cv_have_attribute_dllexport=no)\n+  CFLAGS=\"$save_CFLAGS\"])\n+  if test $libat_cv_have_attribute_dllexport = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_DLLEXPORT, 1,\n+      [Define to 1 if the target supports __attribute__((dllexport)).])\n+  fi])\n+\n+dnl Check whether the target supports symbol aliases.\n+AC_DEFUN([LIBAT_CHECK_ATTRIBUTE_ALIAS], [\n+  AC_CACHE_CHECK([whether the target supports symbol aliases],\n+\t\t libat_cv_have_attribute_alias, [\n+  AC_TRY_LINK([\n+void foo(void) { }\n+extern void bar(void) __attribute__((alias(\"foo\")));],\n+    [bar();], libat_cv_have_attribute_alias=yes, libat_cv_have_attribute_alias=no)])\n+  if test $libat_cv_have_attribute_alias = yes; then\n+    AC_DEFINE(HAVE_ATTRIBUTE_ALIAS, 1,\n+      [Define to 1 if the target supports __attribute__((alias(...))).])\n+  fi])\n+\n+dnl ----------------------------------------------------------------------\n+dnl This whole bit snagged from libstdc++-v3.\n+\n+dnl\n+dnl LIBAT_ENABLE\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, permit a|b|c)\n+dnl    (FEATURE, DEFAULT, HELP-ARG, HELP-STRING, SHELL-CODE-HANDLER)\n+dnl\n+dnl See docs/html/17_intro/configury.html#enable for documentation.\n+dnl\n+m4_define([LIBAT_ENABLE],[dnl\n+m4_define([_g_switch],[--enable-$1])dnl\n+m4_define([_g_help],[AC_HELP_STRING(_g_switch$3,[$4 @<:@default=$2@:>@])])dnl\n+ AC_ARG_ENABLE($1,_g_help,\n+  m4_bmatch([$5],\n+   [^permit ],\n+     [[\n+      case \"$enableval\" in\n+       m4_bpatsubst([$5],[permit ])) ;;\n+       *) AC_MSG_ERROR(Unknown argument to enable/disable $1) ;;\n+          dnl Idea for future:  generate a URL pointing to\n+          dnl \"onlinedocs/configopts.html#whatever\"\n+      esac\n+     ]],\n+   [^$],\n+     [[\n+      case \"$enableval\" in\n+       yes|no) ;;\n+       *) AC_MSG_ERROR(Argument to enable/disable $1 must be yes or no) ;;\n+      esac\n+     ]],\n+   [[$5]]),\n+  [enable_]m4_bpatsubst([$1],-,_)[=][$2])\n+m4_undefine([_g_switch])dnl\n+m4_undefine([_g_help])dnl\n+])\n+\n+dnl\n+dnl If GNU ld is in use, check to see if tricky linker opts can be used.  If\n+dnl the native linker is in use, all variables will be defined to something\n+dnl safe (like an empty string).\n+dnl\n+dnl Defines:\n+dnl  SECTION_LDFLAGS='-Wl,--gc-sections' if possible\n+dnl  OPT_LDFLAGS='-Wl,-O1' if possible\n+dnl  LD (as a side effect of testing)\n+dnl Sets:\n+dnl  with_gnu_ld\n+dnl  libat_ld_is_gold (possibly)\n+dnl  libat_gnu_ld_version (possibly)\n+dnl\n+dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n+dnl set libat_gnu_ld_version to 12345.  Zeros cause problems.\n+dnl\n+AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n+  # If we're not using GNU ld, then there's no point in even trying these\n+  # tests.  Check for that first.  We should have already tested for gld\n+  # by now (in libtool), but require it now just to be safe...\n+  test -z \"$SECTION_LDFLAGS\" && SECTION_LDFLAGS=''\n+  test -z \"$OPT_LDFLAGS\" && OPT_LDFLAGS=''\n+  AC_REQUIRE([AC_PROG_LD])\n+  AC_REQUIRE([AC_PROG_AWK])\n+\n+  # The name set by libtool depends on the version of libtool.  Shame on us\n+  # for depending on an impl detail, but c'est la vie.  Older versions used\n+  # ac_cv_prog_gnu_ld, but now it's lt_cv_prog_gnu_ld, and is copied back on\n+  # top of with_gnu_ld (which is also set by --with-gnu-ld, so that actually\n+  # makes sense).  We'll test with_gnu_ld everywhere else, so if that isn't\n+  # set (hence we're using an older libtool), then set it.\n+  if test x${with_gnu_ld+set} != xset; then\n+    if test x${ac_cv_prog_gnu_ld+set} != xset; then\n+      # We got through \"ac_require(ac_prog_ld)\" and still not set?  Huh?\n+      with_gnu_ld=no\n+    else\n+      with_gnu_ld=$ac_cv_prog_gnu_ld\n+    fi\n+  fi\n+\n+  # Start by getting the version number.  I think the libtool test already\n+  # does some of this, but throws away the result.\n+  libat_ld_is_gold=no\n+  if $LD --version 2>/dev/null | grep 'GNU gold'> /dev/null 2>&1; then\n+    libat_ld_is_gold=yes\n+  fi\n+  changequote(,)\n+  ldver=`$LD --version 2>/dev/null |\n+         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+  changequote([,])\n+  libat_gnu_ld_version=`echo $ldver | \\\n+         $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n+\n+  # Set --gc-sections.\n+  if test \"$with_gnu_ld\" = \"notbroken\"; then\n+    # GNU ld it is!  Joy and bunny rabbits!\n+\n+    # All these tests are for C++; save the language and the compiler flags.\n+    # Need to do this so that g++ won't try to link in libstdc++\n+    ac_test_CFLAGS=\"${CFLAGS+set}\"\n+    ac_save_CFLAGS=\"$CFLAGS\"\n+    CFLAGS='-x c++  -Wl,--gc-sections'\n+\n+    # Check for -Wl,--gc-sections\n+    # XXX This test is broken at the moment, as symbols required for linking\n+    # are now in libsupc++ (not built yet).  In addition, this test has\n+    # cored on solaris in the past.  In addition, --gc-sections doesn't\n+    # really work at the moment (keeps on discarding used sections, first\n+    # .eh_frame and now some of the glibc sections for iconv).\n+    # Bzzzzt.  Thanks for playing, maybe next time.\n+    AC_MSG_CHECKING([for ld that supports -Wl,--gc-sections])\n+    AC_TRY_RUN([\n+     int main(void)\n+     {\n+       try { throw 1; }\n+       catch (...) { };\n+       return 0;\n+     }\n+    ], [ac_sectionLDflags=yes],[ac_sectionLDflags=no], [ac_sectionLDflags=yes])\n+    if test \"$ac_test_CFLAGS\" = set; then\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    else\n+      # this is the suspicious part\n+      CFLAGS=''\n+    fi\n+    if test \"$ac_sectionLDflags\" = \"yes\"; then\n+      SECTION_LDFLAGS=\"-Wl,--gc-sections $SECTION_LDFLAGS\"\n+    fi\n+    AC_MSG_RESULT($ac_sectionLDflags)\n+  fi\n+\n+  # Set linker optimization flags.\n+  if test x\"$with_gnu_ld\" = x\"yes\"; then\n+    OPT_LDFLAGS=\"-Wl,-O1 $OPT_LDFLAGS\"\n+  fi\n+\n+  AC_SUBST(SECTION_LDFLAGS)\n+  AC_SUBST(OPT_LDFLAGS)\n+])\n+\n+\n+dnl\n+dnl If GNU ld is in use, check to see if tricky linker opts can be used.  If\n+dnl the native linker is in use, all variables will be defined to something\n+dnl safe (like an empty string).\n+dnl\n+dnl Defines:\n+dnl  SECTION_LDFLAGS='-Wl,--gc-sections' if possible\n+dnl  OPT_LDFLAGS='-Wl,-O1' if possible\n+dnl  LD (as a side effect of testing)\n+dnl Sets:\n+dnl  with_gnu_ld\n+dnl  libat_ld_is_gold (possibly)\n+dnl  libat_gnu_ld_version (possibly)\n+dnl\n+dnl The last will be a single integer, e.g., version 1.23.45.0.67.89 will\n+dnl set libat_gnu_ld_version to 12345.  Zeros cause problems.\n+dnl\n+AC_DEFUN([LIBAT_CHECK_LINKER_FEATURES], [\n+  # If we're not using GNU ld, then there's no point in even trying these\n+  # tests.  Check for that first.  We should have already tested for gld\n+  # by now (in libtool), but require it now just to be safe...\n+  test -z \"$SECTION_LDFLAGS\" && SECTION_LDFLAGS=''\n+  test -z \"$OPT_LDFLAGS\" && OPT_LDFLAGS=''\n+  AC_REQUIRE([AC_PROG_LD])\n+  AC_REQUIRE([AC_PROG_AWK])\n+\n+  # The name set by libtool depends on the version of libtool.  Shame on us\n+  # for depending on an impl detail, but c'est la vie.  Older versions used\n+  # ac_cv_prog_gnu_ld, but now it's lt_cv_prog_gnu_ld, and is copied back on\n+  # top of with_gnu_ld (which is also set by --with-gnu-ld, so that actually\n+  # makes sense).  We'll test with_gnu_ld everywhere else, so if that isn't\n+  # set (hence we're using an older libtool), then set it.\n+  if test x${with_gnu_ld+set} != xset; then\n+    if test x${ac_cv_prog_gnu_ld+set} != xset; then\n+      # We got through \"ac_require(ac_prog_ld)\" and still not set?  Huh?\n+      with_gnu_ld=no\n+    else\n+      with_gnu_ld=$ac_cv_prog_gnu_ld\n+    fi\n+  fi\n+\n+  # Start by getting the version number.  I think the libtool test already\n+  # does some of this, but throws away the result.\n+  libat_ld_is_gold=no\n+  if $LD --version 2>/dev/null | grep 'GNU gold'> /dev/null 2>&1; then\n+    libat_ld_is_gold=yes\n+  fi\n+  changequote(,)\n+  ldver=`$LD --version 2>/dev/null |\n+         sed -e 's/GNU gold /GNU ld /;s/GNU ld version /GNU ld /;s/GNU ld ([^)]*) /GNU ld /;s/GNU ld \\([0-9.][0-9.]*\\).*/\\1/; q'`\n+  changequote([,])\n+  libat_gnu_ld_version=`echo $ldver | \\\n+         $AWK -F. '{ if (NF<3) [$]3=0; print ([$]1*100+[$]2)*100+[$]3 }'`\n+\n+  # Set --gc-sections.\n+  if test \"$with_gnu_ld\" = \"notbroken\"; then\n+    # GNU ld it is!  Joy and bunny rabbits!\n+\n+    # All these tests are for C++; save the language and the compiler flags.\n+    # Need to do this so that g++ won't try to link in libstdc++\n+    ac_test_CFLAGS=\"${CFLAGS+set}\"\n+    ac_save_CFLAGS=\"$CFLAGS\"\n+    CFLAGS='-x c++  -Wl,--gc-sections'\n+\n+    # Check for -Wl,--gc-sections\n+    # XXX This test is broken at the moment, as symbols required for linking\n+    # are now in libsupc++ (not built yet).  In addition, this test has\n+    # cored on solaris in the past.  In addition, --gc-sections doesn't\n+    # really work at the moment (keeps on discarding used sections, first\n+    # .eh_frame and now some of the glibc sections for iconv).\n+    # Bzzzzt.  Thanks for playing, maybe next time.\n+    AC_MSG_CHECKING([for ld that supports -Wl,--gc-sections])\n+    AC_TRY_RUN([\n+     int main(void)\n+     {\n+       try { throw 1; }\n+       catch (...) { };\n+       return 0;\n+     }\n+    ], [ac_sectionLDflags=yes],[ac_sectionLDflags=no], [ac_sectionLDflags=yes])\n+    if test \"$ac_test_CFLAGS\" = set; then\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    else\n+      # this is the suspicious part\n+      CFLAGS=''\n+    fi\n+    if test \"$ac_sectionLDflags\" = \"yes\"; then\n+      SECTION_LDFLAGS=\"-Wl,--gc-sections $SECTION_LDFLAGS\"\n+    fi\n+    AC_MSG_RESULT($ac_sectionLDflags)\n+  fi\n+\n+  # Set linker optimization flags.\n+  if test x\"$with_gnu_ld\" = x\"yes\"; then\n+    OPT_LDFLAGS=\"-Wl,-O1 $OPT_LDFLAGS\"\n+  fi\n+\n+  AC_SUBST(SECTION_LDFLAGS)\n+  AC_SUBST(OPT_LDFLAGS)\n+])\n+\n+\n+dnl\n+dnl Add version tags to symbols in shared library (or not), additionally\n+dnl marking other symbols as private/local (or not).\n+dnl\n+dnl --enable-symvers=style adds a version script to the linker call when\n+dnl       creating the shared library.  The choice of version script is\n+dnl       controlled by 'style'.\n+dnl --disable-symvers does not.\n+dnl  +  Usage:  LIBAT_ENABLE_SYMVERS[(DEFAULT)]\n+dnl       Where DEFAULT is either 'yes' or 'no'.  Passing `yes' tries to\n+dnl       choose a default style based on linker characteristics.  Passing\n+dnl       'no' disables versioning.\n+dnl\n+AC_DEFUN([LIBAT_ENABLE_SYMVERS], [\n+\n+LIBAT_ENABLE(symvers,yes,[=STYLE],\n+  [enables symbol versioning of the shared library],\n+  [permit yes|no|gnu*|sun])\n+\n+# If we never went through the LIBAT_CHECK_LINKER_FEATURES macro, then we\n+# don't know enough about $LD to do tricks...\n+AC_REQUIRE([LIBAT_CHECK_LINKER_FEATURES])\n+\n+# Turn a 'yes' into a suitable default.\n+if test x$enable_symvers = xyes ; then\n+  # FIXME  The following test is too strict, in theory.\n+  if test $enable_shared = no || test \"x$LD\" = x; then\n+    enable_symvers=no\n+  else\n+    if test $with_gnu_ld = yes ; then\n+      enable_symvers=gnu\n+    else\n+      case ${target_os} in\n+        # Sun symbol versioning exists since Solaris 2.5.\n+        solaris2.[[5-9]]* | solaris2.1[[0-9]]*)\n+          enable_symvers=sun ;;\n+        *)\n+          enable_symvers=no ;;\n+      esac\n+    fi\n+  fi\n+fi\n+\n+# Check if 'sun' was requested on non-Solaris 2 platforms.\n+if test x$enable_symvers = xsun ; then\n+  case ${target_os} in\n+    solaris2*)\n+      # All fine.\n+      ;;\n+    *)\n+      # Unlikely to work.\n+      AC_MSG_WARN([=== You have requested Sun symbol versioning, but])\n+      AC_MSG_WARN([=== you are not targetting Solaris 2.])\n+      AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+      enable_symvers=no\n+      ;;\n+  esac\n+fi\n+\n+# Check to see if libgcc_s exists, indicating that shared libgcc is possible.\n+if test $enable_symvers != no; then\n+  AC_MSG_CHECKING([for shared libgcc])\n+  ac_save_CFLAGS=\"$CFLAGS\"\n+  CFLAGS=' -lgcc_s'\n+  AC_TRY_LINK(, [return 0;], libat_shared_libgcc=yes, libat_shared_libgcc=no)\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+  if test $libat_shared_libgcc = no; then\n+    cat > conftest.c <<EOF\n+int main (void) { return 0; }\n+EOF\n+changequote(,)dnl\n+    libat_libgcc_s_suffix=`${CC-cc} $CFLAGS $CPPFLAGS $LDFLAGS \\\n+\t\t\t     -shared -shared-libgcc -o conftest.so \\\n+\t\t\t     conftest.c -v 2>&1 >/dev/null \\\n+\t\t\t     | sed -n 's/^.* -lgcc_s\\([^ ]*\\) .*$/\\1/p'`\n+changequote([,])dnl\n+    rm -f conftest.c conftest.so\n+    if test x${libat_libgcc_s_suffix+set} = xset; then\n+      CFLAGS=\" -lgcc_s$libat_libgcc_s_suffix\"\n+      AC_TRY_LINK(, [return 0;], libat_shared_libgcc=yes)\n+      CFLAGS=\"$ac_save_CFLAGS\"\n+    fi\n+  fi\n+  AC_MSG_RESULT($libat_shared_libgcc)\n+fi\n+\n+# For GNU ld, we need at least this version.  The format is described in\n+# LIBAT_CHECK_LINKER_FEATURES above.\n+libat_min_gnu_ld_version=21400\n+# XXXXXXXXXXX libat_gnu_ld_version=21390\n+\n+# Check to see if unspecified \"yes\" value can win, given results above.\n+# Change \"yes\" into either \"no\" or a style name.\n+if test $enable_symvers != no && test $libat_shared_libgcc = yes; then\n+  if test $with_gnu_ld = yes; then\n+    if test $libat_gnu_ld_version -ge $libat_min_gnu_ld_version ; then\n+      enable_symvers=gnu\n+    elif test $libat_ld_is_gold = yes ; then\n+      enable_symvers=gnu\n+    else\n+      # The right tools, the right setup, but too old.  Fallbacks?\n+      AC_MSG_WARN(=== Linker version $libat_gnu_ld_version is too old for)\n+      AC_MSG_WARN(=== full symbol versioning support in this release of GCC.)\n+      AC_MSG_WARN(=== You would need to upgrade your binutils to version)\n+      AC_MSG_WARN(=== $libat_min_gnu_ld_version or later and rebuild GCC.)\n+      if test $libat_gnu_ld_version -ge 21200 ; then\n+        # Globbing fix is present, proper block support is not.\n+        dnl AC_MSG_WARN([=== Dude, you are soooo close.  Maybe we can fake it.])\n+        dnl enable_symvers=???\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      else\n+        # 2.11 or older.\n+        AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+        enable_symvers=no\n+      fi\n+    fi\n+  elif test $enable_symvers = sun; then\n+    : All interesting versions of Sun ld support sun style symbol versioning.\n+  else\n+    # just fail for now\n+    AC_MSG_WARN([=== You have requested some kind of symbol versioning, but])\n+    AC_MSG_WARN([=== either you are not using a supported linker, or you are])\n+    AC_MSG_WARN([=== not building a shared libgcc_s (which is required).])\n+    AC_MSG_WARN([=== Symbol versioning will be disabled.])\n+    enable_symvers=no\n+  fi\n+fi\n+if test $enable_symvers = gnu; then\n+  AC_DEFINE(LIBAT_GNU_SYMBOL_VERSIONING, 1,\n+\t    [Define to 1 if GNU symbol versioning is used for libatomic.])\n+fi\n+\n+AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB, test $enable_symvers != no)\n+AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB_GNU, test $enable_symvers = gnu)\n+AM_CONDITIONAL(LIBAT_BUILD_VERSIONED_SHLIB_SUN, test $enable_symvers = sun)\n+AC_MSG_NOTICE(versioning on shared library symbols is $enable_symvers)\n+])\n+\n+dnl ----------------------------------------------------------------------\n+sinclude(../libtool.m4)\n+dnl The lines below arrange for aclocal not to bring an installed\n+dnl libtool.m4 into aclocal.m4, while still arranging for automake to\n+dnl add a definition of LIBTOOL to Makefile.in.\n+ifelse(,,,[AC_SUBST(LIBTOOL)\n+AC_DEFUN([AM_PROG_LIBTOOL])\n+AC_DEFUN([AC_LIBTOOL_DLOPEN])\n+AC_DEFUN([AC_PROG_LD])\n+])"}, {"sha": "d9c81a793ec9cd06f5fdbc0fdb7141e62b143a7f", "filename": "libatomic/aclocal.m4", "status": "added", "additions": 963, "deletions": 0, "changes": 963, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Faclocal.m4?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,963 @@\n+# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n+[m4_warning([this file was generated for autoconf 2.64.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically `autoreconf'.])])\n+\n+# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.11'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.11.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.11.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# Figure out how to run the assembler.                      -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_PROG_AS\n+# ----------\n+AC_DEFUN([AM_PROG_AS],\n+[# By default we simply use the C compiler to build assembly code.\n+AC_REQUIRE([AC_PROG_CC])\n+test \"${CCAS+set}\" = set || CCAS=$CC\n+test \"${CCASFLAGS+set}\" = set || CCASFLAGS=$CFLAGS\n+AC_ARG_VAR([CCAS],      [assembler compiler command (defaults to CC)])\n+AC_ARG_VAR([CCASFLAGS], [assembler compiler flags (defaults to CFLAGS)])\n+_AM_IF_OPTION([no-dependencies],, [_AM_DEPENDENCIES([CCAS])])dnl\n+])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is `.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[dnl Rely on autoconf to set up CDPATH properly.\n+AC_PREREQ([2.50])dnl\n+# expand $ac_aux_dir to an absolute path\n+am_aux_dir=`cd $ac_aux_dir && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 9\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ(2.52)dnl\n+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 10\n+\n+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n+# written in clear, in which case automake, when reading aclocal.m4,\n+# will think it sees a *use*, and therefore will trigger all it's\n+# C support machinery.  Also note that it means that autoscan, seeing\n+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n+\n+\n+# _AM_DEPENDENCIES(NAME)\n+# ----------------------\n+# See how the compiler implements dependency checking.\n+# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n+# We try a few techniques and use that to set a single cache variable.\n+#\n+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n+# dependency, and given that the user is not expected to run this macro,\n+# just rely on AC_PROG_CC.\n+AC_DEFUN([_AM_DEPENDENCIES],\n+[AC_REQUIRE([AM_SET_DEPDIR])dnl\n+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n+AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n+AC_REQUIRE([AM_DEP_TRACK])dnl\n+\n+ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n+       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n+       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n+       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n+       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n+                   [depcc=\"$$1\"   am_compiler_list=])\n+\n+AC_CACHE_CHECK([dependency style of $depcc],\n+               [am_cv_$1_dependencies_compiler_type],\n+[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n+  # We make a subdir and do the tests there.  Otherwise we can end up\n+  # making bogus files that we don't know about and never remove.  For\n+  # instance it was reported that on HP-UX the gcc test will end up\n+  # making a dummy file named `D' -- because `-MD' means `put the output\n+  # in D'.\n+  mkdir conftest.dir\n+  # Copy depcomp to subdir because otherwise we won't find it if we're\n+  # using a relative directory.\n+  cp \"$am_depcomp\" conftest.dir\n+  cd conftest.dir\n+  # We will build objects and dependencies in a subdirectory because\n+  # it helps to detect inapplicable dependency modes.  For instance\n+  # both Tru64's cc and ICC support -MD to output dependencies as a\n+  # side effect of compilation, but ICC will put the dependencies in\n+  # the current directory while Tru64 will put them in the object\n+  # directory.\n+  mkdir sub\n+\n+  am_cv_$1_dependencies_compiler_type=none\n+  if test \"$am_compiler_list\" = \"\"; then\n+     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n+  fi\n+  am__universal=false\n+  m4_case([$1], [CC],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac],\n+    [CXX],\n+    [case \" $depcc \" in #(\n+     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n+     esac])\n+\n+  for depmode in $am_compiler_list; do\n+    # Setup a source with many dependencies, because some compilers\n+    # like to wrap large dependency lists on column 80 (with \\), and\n+    # we should not choose a depcomp mode which is confused by this.\n+    #\n+    # We need to recreate these files for each test, as the compiler may\n+    # overwrite some of them when testing with obscure command lines.\n+    # This happens at least with the AIX C compiler.\n+    : > sub/conftest.c\n+    for i in 1 2 3 4 5 6; do\n+      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n+      # Solaris 8's {/usr,}/bin/sh.\n+      touch sub/conftst$i.h\n+    done\n+    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n+\n+    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n+    # mode.  It turns out that the SunPro C++ compiler does not properly\n+    # handle `-M -o', and we need to detect this.  Also, some Intel\n+    # versions had trouble with output in subdirs\n+    am__obj=sub/conftest.${OBJEXT-o}\n+    am__minus_obj=\"-o $am__obj\"\n+    case $depmode in\n+    gcc)\n+      # This depmode causes a compiler race in universal mode.\n+      test \"$am__universal\" = false || continue\n+      ;;\n+    nosideeffect)\n+      # after this tag, mechanisms are not by side-effect, so they'll\n+      # only be used when explicitly requested\n+      if test \"x$enable_dependency_tracking\" = xyes; then\n+\tcontinue\n+      else\n+\tbreak\n+      fi\n+      ;;\n+    msvisualcpp | msvcmsys)\n+      # This compiler won't grok `-c -o', but also, the minuso test has\n+      # not run yet.  These depmodes are late enough in the game, and\n+      # so weak that their functioning should not be impacted.\n+      am__obj=conftest.${OBJEXT-o}\n+      am__minus_obj=\n+      ;;\n+    none) break ;;\n+    esac\n+    if depmode=$depmode \\\n+       source=sub/conftest.c object=$am__obj \\\n+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n+         >/dev/null 2>conftest.err &&\n+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n+      # icc doesn't choke on unknown options, it will just issue warnings\n+      # or remarks (even with -Werror).  So we grep stderr for any message\n+      # that says an option was ignored or not supported.\n+      # When given -MP, icc 7.0 and 7.1 complain thusly:\n+      #   icc: Command line warning: ignoring option '-M'; no argument required\n+      # The diagnosis changed in icc 8.0:\n+      #   icc: Command line remark: option '-MP' not supported\n+      if (grep 'ignoring option' conftest.err ||\n+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n+        am_cv_$1_dependencies_compiler_type=$depmode\n+        break\n+      fi\n+    fi\n+  done\n+\n+  cd ..\n+  rm -rf conftest.dir\n+else\n+  am_cv_$1_dependencies_compiler_type=none\n+fi\n+])\n+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n+AM_CONDITIONAL([am__fastdep$1], [\n+  test \"x$enable_dependency_tracking\" != xno \\\n+  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n+])\n+\n+\n+# AM_SET_DEPDIR\n+# -------------\n+# Choose a directory name for dependency files.\n+# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n+AC_DEFUN([AM_SET_DEPDIR],\n+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n+])\n+\n+\n+# AM_DEP_TRACK\n+# ------------\n+AC_DEFUN([AM_DEP_TRACK],\n+[AC_ARG_ENABLE(dependency-tracking,\n+[  --disable-dependency-tracking  speeds up one-time build\n+  --enable-dependency-tracking   do not reject slow dependency extractors])\n+if test \"x$enable_dependency_tracking\" != xno; then\n+  am_depcomp=\"$ac_aux_dir/depcomp\"\n+  AMDEPBACKSLASH='\\'\n+fi\n+AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n+AC_SUBST([AMDEPBACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n+])\n+\n+# Generate code to set up dependency tracking.              -*- Autoconf -*-\n+\n+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+#serial 5\n+\n+# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+# ------------------------------\n+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[{\n+  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n+  # are listed without --file.  Let's play safe and only enable the eval\n+  # if we detect the quoting.\n+  case $CONFIG_FILES in\n+  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n+  *)   set x $CONFIG_FILES ;;\n+  esac\n+  shift\n+  for mf\n+  do\n+    # Strip MF so we end up with the name of the file.\n+    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n+    # Check whether this is an Automake generated Makefile or not.\n+    # We used to match only the files named `Makefile.in', but\n+    # some people rename them; so instead we look at the file content.\n+    # Grep'ing the first line is not enough: some people post-process\n+    # each Makefile.in and add a new line on top of each file to say so.\n+    # Grep'ing the whole file is not good either: AIX grep has a line\n+    # limit of 2048, but all sed's we know have understand at least 4000.\n+    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n+      dirpart=`AS_DIRNAME(\"$mf\")`\n+    else\n+      continue\n+    fi\n+    # Extract the definition of DEPDIR, am__include, and am__quote\n+    # from the Makefile without running `make'.\n+    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n+    test -z \"$DEPDIR\" && continue\n+    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n+    test -z \"am__include\" && continue\n+    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n+    # When using ansi2knr, U may be empty or an underscore; expand it\n+    U=`sed -n 's/^U = //p' < \"$mf\"`\n+    # Find all dependency output files, they are included files with\n+    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n+    # simplest approach to changing $(DEPDIR) to its actual value in the\n+    # expansion.\n+    for file in `sed -n \"\n+      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n+\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n+      # Make sure the directory exists.\n+      test -f \"$dirpart/$file\" && continue\n+      fdir=`AS_DIRNAME([\"$file\"])`\n+      AS_MKDIR_P([$dirpart/$fdir])\n+      # echo \"creating $dirpart/$file\"\n+      echo '# dummy' > \"$dirpart/$file\"\n+    done\n+  done\n+}\n+])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n+\n+\n+# AM_OUTPUT_DEPENDENCY_COMMANDS\n+# -----------------------------\n+# This macro should only be invoked once -- use via AC_REQUIRE.\n+#\n+# This code is only required when automatic dependency tracking\n+# is enabled.  FIXME.  This creates each `.P' file that we will\n+# need in order to bootstrap the dependency handling code.\n+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n+[AC_CONFIG_COMMANDS([depfiles],\n+     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n+     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n+])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n+# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 16\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.62])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n+ AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n+AM_MISSING_PROG(AUTOCONF, autoconf)\n+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n+AM_MISSING_PROG(AUTOHEADER, autoheader)\n+AM_MISSING_PROG(MAKEINFO, makeinfo)\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n+# We need awk for the \"check\" target.  The system \"awk\" is bad on\n+# some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES(CC)],\n+\t\t  [define([AC_PROG_CC],\n+\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES(CXX)],\n+\t\t  [define([AC_PROG_CXX],\n+\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES(OBJC)],\n+\t\t  [define([AC_PROG_OBJC],\n+\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n+])\n+_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n+dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n+dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n+dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+])\n+\n+dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST(install_sh)])\n+\n+# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# AM_MAKE_INCLUDE()\n+# -----------------\n+# Check to see how make treats includes.\n+AC_DEFUN([AM_MAKE_INCLUDE],\n+[am_make=${MAKE-make}\n+cat > confinc << 'END'\n+am__doit:\n+\t@echo this is the am__doit target\n+.PHONY: am__doit\n+END\n+# If we don't find an include directive, just comment out the code.\n+AC_MSG_CHECKING([for style of include used by $am_make])\n+am__include=\"#\"\n+am__quote=\n+_am_result=none\n+# First try GNU make style include.\n+echo \"include confinc\" > confmf\n+# Ignore all kinds of additional output from `make'.\n+case `$am_make -s -f confmf 2> /dev/null` in #(\n+*the\\ am__doit\\ target*)\n+  am__include=include\n+  am__quote=\n+  _am_result=GNU\n+  ;;\n+esac\n+# Now try BSD make style include.\n+if test \"$am__include\" = \"#\"; then\n+   echo '.include \"confinc\"' > confmf\n+   case `$am_make -s -f confmf 2> /dev/null` in #(\n+   *the\\ am__doit\\ target*)\n+     am__include=.include\n+     am__quote=\"\\\"\"\n+     _am_result=BSD\n+     ;;\n+   esac\n+fi\n+AC_SUBST([am__include])\n+AC_SUBST([am__quote])\n+AC_MSG_RESULT([$_am_result])\n+rm -f confinc confmf\n+])\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 6\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it supports --run.\n+# If it does, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --run true\"; then\n+  am_missing_run=\"$MISSING --run \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN([`missing' script is too old or missing])\n+fi\n+])\n+\n+# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_MKDIR_P\n+# ---------------\n+# Check for `mkdir -p'.\n+AC_DEFUN([AM_PROG_MKDIR_P],\n+[AC_PREREQ([2.60])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n+dnl while keeping a definition of mkdir_p for backward compatibility.\n+dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n+dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n+dnl Makefile.ins that do not define MKDIR_P, so we do our own\n+dnl adjustment using top_builddir (which is defined more often than\n+dnl MKDIR_P).\n+AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n+case $mkdir_p in\n+  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n+  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n+esac\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 4\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# ------------------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ----------------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n+# Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 5\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Just in case\n+sleep 1\n+echo timestamp > conftest.file\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n+esac\n+\n+# Do `set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+   if test \"$[*]\" = \"X\"; then\n+      # -L didn't work.\n+      set X `ls -t \"$srcdir/configure\" conftest.file`\n+   fi\n+   rm -f conftest.file\n+   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+      # If neither matched, then we have a broken ls.  This can happen\n+      # if, for instance, CONFIG_SHELL is bash and it inherits a\n+      # broken ls alias from the environment.  This has actually\n+      # happened.  Such a system could not be considered \"sane\".\n+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+alias in your environment])\n+   fi\n+\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT(yes)])\n+\n+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor `install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in `make install-strip', and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using `strip' when the user\n+# run `make install-strip'.  However `strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the `STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# serial 2\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of `v7', `ustar', or `pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.\n+AM_MISSING_PROG([AMTAR], [tar])\n+m4_if([$1], [v7],\n+     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n+     [m4_case([$1], [ustar],, [pax],,\n+              [m4_fatal([Unknown tar format])])\n+AC_MSG_CHECKING([how to create a $1 tar archive])\n+# Loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+# Do not fold the above two line into one, because Tru64 sh and\n+# Solaris sh will not grok spaces in the rhs of `-'.\n+for _am_tool in $_am_tools\n+do\n+  case $_am_tool in\n+  gnutar)\n+    for _am_tar in tar gnutar gtar;\n+    do\n+      AM_RUN_LOG([$_am_tar --version]) && break\n+    done\n+    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+    am__untar=\"$_am_tar -xf -\"\n+    ;;\n+  plaintar)\n+    # Must skip GNU tar: if it does not support --format= it doesn't create\n+    # ustar tarball either.\n+    (tar --version) >/dev/null 2>&1 && continue\n+    am__tar='tar chf - \"$$tardir\"'\n+    am__tar_='tar chf - \"$tardir\"'\n+    am__untar='tar xf -'\n+    ;;\n+  pax)\n+    am__tar='pax -L -x $1 -w \"$$tardir\"'\n+    am__tar_='pax -L -x $1 -w \"$tardir\"'\n+    am__untar='pax -r'\n+    ;;\n+  cpio)\n+    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+    am__untar='cpio -i -H $1 -d'\n+    ;;\n+  none)\n+    am__tar=false\n+    am__tar_=false\n+    am__untar=false\n+    ;;\n+  esac\n+\n+  # If the value was cached, stop now.  We just wanted to have am__tar\n+  # and am__untar set.\n+  test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+  # tar/untar a dummy directory, and stop if the command works\n+  rm -rf conftest.dir\n+  mkdir conftest.dir\n+  echo GrepMe > conftest.dir/file\n+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+  rm -rf conftest.dir\n+  if test -s conftest.tar; then\n+    AM_RUN_LOG([$am__untar <conftest.tar])\n+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+  fi\n+done\n+rm -rf conftest.dir\n+\n+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/acx.m4])\n+m4_include([../config/depstand.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../config/stdint.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])\n+m4_include([acinclude.m4])"}, {"sha": "ab080e7d6e425bdebb24c0e060a02c2a17dae6b8", "filename": "libatomic/auto-config.h.in", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fauto-config.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fauto-config.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fauto-config.h.in?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,282 @@\n+/* auto-config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n+/* Have __atomic_compare_exchange for 1 byte integers. */\n+#undef HAVE_ATOMIC_CAS_1\n+\n+/* Have __atomic_compare_exchange for 16 byte integers. */\n+#undef HAVE_ATOMIC_CAS_16\n+\n+/* Have __atomic_compare_exchange for 2 byte integers. */\n+#undef HAVE_ATOMIC_CAS_2\n+\n+/* Have __atomic_compare_exchange for 4 byte integers. */\n+#undef HAVE_ATOMIC_CAS_4\n+\n+/* Have __atomic_compare_exchange for 8 byte integers. */\n+#undef HAVE_ATOMIC_CAS_8\n+\n+/* Have __atomic_exchange for 1 byte integers. */\n+#undef HAVE_ATOMIC_EXCHANGE_1\n+\n+/* Have __atomic_exchange for 16 byte integers. */\n+#undef HAVE_ATOMIC_EXCHANGE_16\n+\n+/* Have __atomic_exchange for 2 byte integers. */\n+#undef HAVE_ATOMIC_EXCHANGE_2\n+\n+/* Have __atomic_exchange for 4 byte integers. */\n+#undef HAVE_ATOMIC_EXCHANGE_4\n+\n+/* Have __atomic_exchange for 8 byte integers. */\n+#undef HAVE_ATOMIC_EXCHANGE_8\n+\n+/* Have __atomic_fetch_add for 1 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_ADD_1\n+\n+/* Have __atomic_fetch_add for 16 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_ADD_16\n+\n+/* Have __atomic_fetch_add for 2 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_ADD_2\n+\n+/* Have __atomic_fetch_add for 4 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_ADD_4\n+\n+/* Have __atomic_fetch_add for 8 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_ADD_8\n+\n+/* Have __atomic_fetch_op for all op for 1 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_OP_1\n+\n+/* Have __atomic_fetch_op for all op for 16 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_OP_16\n+\n+/* Have __atomic_fetch_op for all op for 2 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_OP_2\n+\n+/* Have __atomic_fetch_op for all op for 4 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_OP_4\n+\n+/* Have __atomic_fetch_op for all op for 8 byte integers. */\n+#undef HAVE_ATOMIC_FETCH_OP_8\n+\n+/* Have __atomic_load/store for 1 byte integers. */\n+#undef HAVE_ATOMIC_LDST_1\n+\n+/* Have __atomic_load/store for 16 byte integers. */\n+#undef HAVE_ATOMIC_LDST_16\n+\n+/* Have __atomic_load/store for 2 byte integers. */\n+#undef HAVE_ATOMIC_LDST_2\n+\n+/* Have __atomic_load/store for 4 byte integers. */\n+#undef HAVE_ATOMIC_LDST_4\n+\n+/* Have __atomic_load/store for 8 byte integers. */\n+#undef HAVE_ATOMIC_LDST_8\n+\n+/* Have __atomic_test_and_set for 1 byte integers. */\n+#undef HAVE_ATOMIC_TAS_1\n+\n+/* Have __atomic_test_and_set for 16 byte integers. */\n+#undef HAVE_ATOMIC_TAS_16\n+\n+/* Have __atomic_test_and_set for 2 byte integers. */\n+#undef HAVE_ATOMIC_TAS_2\n+\n+/* Have __atomic_test_and_set for 4 byte integers. */\n+#undef HAVE_ATOMIC_TAS_4\n+\n+/* Have __atomic_test_and_set for 8 byte integers. */\n+#undef HAVE_ATOMIC_TAS_8\n+\n+/* Define to 1 if the target supports __attribute__((alias(...))). */\n+#undef HAVE_ATTRIBUTE_ALIAS\n+\n+/* Define to 1 if the target supports __attribute__((dllexport)). */\n+#undef HAVE_ATTRIBUTE_DLLEXPORT\n+\n+/* Define to 1 if the target supports __attribute__((visibility(...))). */\n+#undef HAVE_ATTRIBUTE_VISIBILITY\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if the target supports __attribute__((ifunc(...))). */\n+#undef HAVE_IFUNC\n+\n+/* Have support for 1 byte integers. */\n+#undef HAVE_INT1\n+\n+/* Have support for 16 byte integers. */\n+#undef HAVE_INT16\n+\n+/* Have support for 2 byte integers. */\n+#undef HAVE_INT2\n+\n+/* Have support for 4 byte integers. */\n+#undef HAVE_INT4\n+\n+/* Have support for 8 byte integers. */\n+#undef HAVE_INT8\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to 1 if GNU symbol versioning is used for libatomic. */\n+#undef LIBAT_GNU_SYMBOL_VERSIONING\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of package */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* The size of `char', as computed by sizeof. */\n+#undef SIZEOF_CHAR\n+\n+/* The size of `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of `short', as computed by sizeof. */\n+#undef SIZEOF_SHORT\n+\n+/* The size of `void *', as computed by sizeof. */\n+#undef SIZEOF_VOID_P\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Define if you can safely include both <string.h> and <strings.h>. */\n+#undef STRING_WITH_STRINGS\n+\n+/* Version number of package */\n+#undef VERSION\n+\n+/* The word size in bytes of the machine. */\n+#undef WORDSIZE\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n+#define MAYBE_HAVE_ATOMIC_LDST_1 HAVE_ATOMIC_LDST_1\n+\n+#define MAYBE_HAVE_ATOMIC_TAS_16 HAVE_ATOMIC_TAS_16\n+\n+#define MAYBE_HAVE_ATOMIC_EXCHANGE_1 HAVE_ATOMIC_EXCHANGE_1\n+\n+#define MAYBE_HAVE_ATOMIC_EXCHANGE_2 HAVE_ATOMIC_EXCHANGE_2\n+\n+#define MAYBE_HAVE_ATOMIC_EXCHANGE_4 HAVE_ATOMIC_EXCHANGE_4\n+\n+#define MAYBE_HAVE_ATOMIC_EXCHANGE_8 HAVE_ATOMIC_EXCHANGE_8\n+\n+#define MAYBE_HAVE_ATOMIC_EXCHANGE_16 HAVE_ATOMIC_EXCHANGE_16\n+\n+#define MAYBE_HAVE_ATOMIC_CAS_1 HAVE_ATOMIC_CAS_1\n+\n+#define MAYBE_HAVE_ATOMIC_CAS_2 HAVE_ATOMIC_CAS_2\n+\n+#define MAYBE_HAVE_ATOMIC_CAS_4 HAVE_ATOMIC_CAS_4\n+\n+#define MAYBE_HAVE_ATOMIC_CAS_8 HAVE_ATOMIC_CAS_8\n+\n+#define MAYBE_HAVE_ATOMIC_LDST_2 HAVE_ATOMIC_LDST_2\n+\n+#define MAYBE_HAVE_ATOMIC_CAS_16 HAVE_ATOMIC_CAS_16\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_ADD_1 HAVE_ATOMIC_FETCH_ADD_1\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_ADD_2 HAVE_ATOMIC_FETCH_ADD_2\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_ADD_4 HAVE_ATOMIC_FETCH_ADD_4\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_ADD_8 HAVE_ATOMIC_FETCH_ADD_8\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_ADD_16 HAVE_ATOMIC_FETCH_ADD_16\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_OP_1 HAVE_ATOMIC_FETCH_OP_1\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_OP_2 HAVE_ATOMIC_FETCH_OP_2\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_OP_4 HAVE_ATOMIC_FETCH_OP_4\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_OP_8 HAVE_ATOMIC_FETCH_OP_8\n+\n+#define MAYBE_HAVE_ATOMIC_LDST_4 HAVE_ATOMIC_LDST_4\n+\n+#define MAYBE_HAVE_ATOMIC_FETCH_OP_16 HAVE_ATOMIC_FETCH_OP_16\n+\n+#ifndef WORDS_BIGENDIAN\n+#define WORDS_BIGENDIAN 0\n+#endif\n+\n+#define MAYBE_HAVE_ATOMIC_LDST_8 HAVE_ATOMIC_LDST_8\n+\n+#define MAYBE_HAVE_ATOMIC_LDST_16 HAVE_ATOMIC_LDST_16\n+\n+#define MAYBE_HAVE_ATOMIC_TAS_1 HAVE_ATOMIC_TAS_1\n+\n+#define MAYBE_HAVE_ATOMIC_TAS_2 HAVE_ATOMIC_TAS_2\n+\n+#define MAYBE_HAVE_ATOMIC_TAS_4 HAVE_ATOMIC_TAS_4\n+\n+#define MAYBE_HAVE_ATOMIC_TAS_8 HAVE_ATOMIC_TAS_8"}, {"sha": "8463c73b9b47677231ca4c584d0286a7f76e24a3", "filename": "libatomic/cas_n.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fcas_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fcas_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fcas_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,125 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && defined(atomic_compare_exchange_n)\n+bool\n+SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n+\t\t\t      int smodel, int fmodel UNUSED)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return atomic_compare_exchange_n (mptr, eptr, newval, false,\n+\t\t\t\t      __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    return atomic_compare_exchange_n (mptr, eptr, newval, false,\n+\t\t\t\t      __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\n+  else\n+    return atomic_compare_exchange_n (mptr, eptr, newval, false,\n+\t\t\t\t      __ATOMIC_SEQ_CST, __ATOMIC_RELAXED);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_CAS */\n+\n+\n+/* If this type is not larger than word-sized, fall back to a word-sized\n+   compare-and-swap loop, possibly assisted by the OS.  */\n+#if !DONE && N <= WORDSIZE && defined(atomic_compare_exchange_w)\n+bool\n+SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n+\t\t\t      int smodel, int fmodel UNUSED)\n+{\n+  UWORD mask, shift, weval, woldval, wnewval, t, *wptr;\n+  bool ret = false;\n+\n+  pre_barrier (smodel);\n+\n+  if (N < WORDSIZE)\n+    {\n+      wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+      shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);\n+      mask = SIZE(MASK) << shift;\n+    }\n+  else\n+    {\n+      wptr = (UWORD *)mptr;\n+      shift = 0;\n+      mask = -1;\n+    }\n+\n+  weval = *eptr << shift;\n+  wnewval = (UWORD)newval << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      if ((woldval & mask) != weval)\n+\tgoto failure;\n+      t = (woldval & ~mask) | wnewval;\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+  ret = true;\n+ failure:\n+  *eptr = woldval >> shift;\n+\n+  post_barrier (smodel);\n+  return ret;\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_CAS && N <= WORDSIZE */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE\n+bool\n+SIZE(libat_compare_exchange) (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n+\t\t\t      int smodel, int fmodel UNUSED)\n+{\n+  UTYPE oldval;\n+  UWORD magic;\n+  bool ret = false;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  oldval = *mptr;\n+  if (oldval == *eptr)\n+    {\n+      *mptr = newval;\n+      ret = true;\n+    }\n+  *eptr = oldval;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return ret;\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(compare_exchange));"}, {"sha": "b94a372c1d877379cba59d19e35c4ea1183b0492", "filename": "libatomic/config/arm/arm-config.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Farm-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Farm-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Farm%2Farm-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,75 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+#if defined(__ARM_ARCH_2__)\n+# define __ARM_ARCH__ 2\n+#endif\n+\n+#if defined(__ARM_ARCH_3__)\n+# define __ARM_ARCH__ 3\n+#endif\n+\n+#if defined(__ARM_ARCH_3M__) || defined(__ARM_ARCH_4__) \\\n+\t|| defined(__ARM_ARCH_4T__)\n+/* We use __ARM_ARCH__ set to 4 here, but in reality it's any processor with\n+   long multiply instructions.  That includes v3M.  */\n+# define __ARM_ARCH__ 4\n+#endif\n+\t\n+#if defined(__ARM_ARCH_5__) || defined(__ARM_ARCH_5T__) \\\n+\t|| defined(__ARM_ARCH_5E__) || defined(__ARM_ARCH_5TE__) \\\n+\t|| defined(__ARM_ARCH_5TEJ__)\n+# define __ARM_ARCH__ 5\n+#endif\n+\n+#if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) \\\n+\t|| defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) \\\n+\t|| defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) \\\n+\t|| defined(__ARM_ARCH_6M__)\n+# define __ARM_ARCH__ 6\n+#endif\n+\n+#if defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) \\\n+\t|| defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) \\\n+\t|| defined(__ARM_ARCH_7EM__)\n+# define __ARM_ARCH__ 7\n+#endif\n+\n+#ifndef __ARM_ARCH__\n+#error Unable to determine architecture.\n+#endif\n+\n+#if __ARM_ARCH__ >= 7 || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6ZK__)\n+# define HAVE_STREX\t1\n+# define HAVE_STREXBHD\t1\n+#elif __ARM_ARCH__ == 6\n+# define HAVE_STREX\t1\n+#endif\n+\n+#if __ARM_ARCH__ >= 7\n+# define HAVE_DMB\t1\n+#elif __ARM_ARCH__ == 6\n+# define HAVE_DMB_MCR\t1\n+#endif"}, {"sha": "ba6258b0f721f26c34ac88321b5a07b803460b86", "filename": "libatomic/config/arm/exch_n.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Fexch_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Fexch_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Farm%2Fexch_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,114 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <libatomic_i.h>\n+#include <arm-config.h>\n+\n+\n+/* When using STREX to implement sub-word exchange, we can do much better\n+   than the compiler by using the APSR.GE and APSR.C flags.  */\n+\n+#if !DONE && HAVE_STREX && !HAVE_STREXBH && N == 2\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UWORD t1, t2;\n+  UTYPE oldval;\n+\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\n+  /* In the N=2 case, there are only two cases for MPTR: mptr % 4 == {0,2}.\n+     Rather than computing a variable shift for this, we can store the one\n+     bit of misalignment in the carry flag, and use conditional constant\n+     shifts instead.  This saves a register.  */\n+#ifdef __ARMEB__\n+# define HI\t\"cc\"\t\t\t\t/* iff value is in high half */\n+# define LO\t\"cs\"\t\t\t\t/* iff value is in low half */\n+#else\n+# define HI\t\"cs\"\n+# define LO\t\"cc\"\n+#endif\n+\n+  asm volatile (\n+\t\t\"lsrs\t%[t2],%[ptr],#2\\n\"\t/* carry = mptr & 2 */\n+\t\"\tbic\t%[ptr],%[ptr],#3\\n\"\t/* align mptr */\n+\t\"\titt\t\"HI\"\\n\"\n+\t\"\tlsl\"HI\"\t%[t1],%[t1],#16\\n\"\t/* shift mask into place */\n+\t\"\tlsl\"HI\"\t%[new],%[new],#16\\n\"\t/* shift newval into place */\n+\t\"\tuadd16\t%[t1],%[t1],%[t1]\\n\"\t/* copy mask into APSR.GE */\n+\t\"0:\tldrex\t%[t2],[%[ptr]]\\n\"\n+\t\"\tite\t\"LO\"\\n\"\n+\t\"\tuxth\"LO\" %[old],%[t2]\\n\"\t/* return old value */\n+\t\"\tuxth\"HI\" %[old],%[t2], ror #16\\n\"\n+\t\"\tsel\t%[t1],%[new],%[t2]\\n\"\t/* merge newval */\n+\t\"\tstrex\t%[t2],%[t1],[%[ptr]]\\n\"\n+\t\"\ttst\t%[t2],%[t2]\\n\"\t\t/* dont clobber carry */\n+\t\"\tbne\t0b\"\n+\t: [old] \"=&r\"(oldval), [t1] \"=&r\"(t1), [t2] \"=&r\"(t2),\n+\t  [ptr] \"+r\"(mptr), [new] \"+r\"(newval)\n+\t: \"1\"(0xffff)\n+\t: \"memory\");\n+\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\n+  return oldval;\n+}\n+\n+#define DONE 1\n+#endif /* !HAVE_STREXBH && N == 2 */\n+\n+\n+#if !DONE && HAVE_STREX && !HAVE_STREXBH && N == 1\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UWORD *wptr, woldval, wnewval, shift, mask, t1, t2;\n+\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\n+  wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+  shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ INVERT_MASK_1;\n+  mask = MASK_1 << shift;\n+  wnewval = newval << shift;\n+\n+  asm volatile (\n+\t\t\"uadd8\t%[t1],%[t1],%[t1]\\n\"\t/* move mask to APSR.GE */\n+\t\"0:\tldrex\t%[old],[%[wptr]]\\n\"\n+\t\"\tsel\t%[t1],%[new],%[old]\\n\"\t/* merge newval */\n+\t\"\tstrex\t%[t2],%[t1],[%[wptr]]\\n\"\n+\t\"\tcmp\t%[t2],#0\\n\"\n+\t\"\tbne\t0b\"\n+\t: [old] \"=&r\"(woldval), [t1] \"=&r\"(t1), [t2] \"=&r\"(t2)\n+\t: [new] \"r\"(wnewval), [wptr] \"r\"(wptr), \"1\"(mask)\n+\t: \"memory\");\n+\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+\n+  return woldval >> shift;\n+}\n+\n+#define DONE 1\n+#endif /* !HAVE_STREXBH && N == 1 */\n+\n+#include \"../../exch_n.c\""}, {"sha": "bbf4a3f84c3f3ae21fb2162aab68bdedf3fbdcb4", "filename": "libatomic/config/arm/host-config.h", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Farm%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Farm%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,4 @@\n+/* Avoiding the DMB (or kernel helper) can be a good thing.  */\n+#define WANT_SPECIALCASE_RELAXED\n+\n+#include_next <host-config.h>"}, {"sha": "d1f11c3de0585b4012549109e22d49d9e8b14b16", "filename": "libatomic/config/ia64/host-config.h", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fia64%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fia64%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fia64%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,5 @@\n+/* Avoiding the synchronizations are a good thing.  */\n+#define WANT_SPECIALCASE_RELAXED\n+#define WANT_SPECIALCASE_ACQREL\n+\n+#include_next <host-config.h>"}, {"sha": "5d87835da7f0723b9cd142e28fde7f9378962010", "filename": "libatomic/config/linux/arm/host-config.h", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Flinux%2Farm%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,179 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <config/arm/arm-config.h>\n+\n+\n+/* Kernel helper for 32-bit compare-and-exchange.  */\n+typedef int (__kernel_cmpxchg_t) (UWORD oldval, UWORD newval, UWORD *ptr);\n+#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)\n+\n+/* Kernel helper for 64-bit compare-and-exchange.  */\n+typedef int (__kernel_cmpxchg64_t) (const U_8 * oldval, const U_8 * newval,\n+\t\t\t\t    U_8 *ptr);\n+#define __kernel_cmpxchg64 (*(__kernel_cmpxchg64_t *) 0xffff0f60)\n+\n+/* Kernel helper for memory barrier.  */\n+typedef void (__kernel_dmb_t) (void);\n+#define __kernel_dmb (*(__kernel_dmb_t *) 0xffff0fa0)\n+\n+/* Kernel helper page version number.  */\n+#define __kernel_helper_version (*(unsigned int *)0xffff0ffc)\n+\n+\n+#ifndef HAVE_STREX\n+static inline bool\n+atomic_compare_exchange_w (UWORD *mptr, UWORD *eptr, UWORD newval,\n+\t\t\t   bool weak_p UNUSED, int sm UNUSED, int fm UNUSED)\n+{\n+  bool ret = true;\n+  UWORD oldval;\n+\n+  oldval = *eptr;\n+  if (__builtin_expect (__kernel_cmpxchg (oldval, newval, mptr) != 0, 0))\n+    {\n+      oldval = *mptr;\n+      ret = false;\n+    }\n+  *eptr = oldval;\n+\n+  return ret;\n+}\n+# define atomic_compare_exchange_w atomic_compare_exchange_w\n+# if N == WORDSIZE\n+#  define atomic_compare_exchange_n atomic_compare_exchange_w\n+# endif\n+#endif /* HAVE_STREX */\n+\n+#if !defined(HAVE_STREXBHD) && defined(HAVE_KERNEL64) && N == 8\n+static inline bool\n+atomic_compare_exchange_n (UTYPE *mptr, UTYPE *eptr, UTYPE newval,\n+\t\t\t   bool weak_p UNUSED, int sm UNUSED, int fm UNUSED)\n+{\n+  if (__kernel_cmpxchg64 (eptr, &newval, mptr) == 0)\n+    return true;\n+  else\n+    {\n+      *eptr = *mptr;\n+      return false;\n+    }\n+}\n+#define atomic_compare_exchange_n atomic_compare_exchange_n\n+#endif\n+\n+#if !defined(HAVE_DMB) && !defined(HAVE_DMB_MCR)\n+static inline void\n+pre_barrier(int model UNUSED)\n+{\n+  __kernel_dmb ();\n+}\n+\n+static inline void\n+post_barrier(int model UNUSED)\n+{\n+  __kernel_dmb ();\n+}\n+# define pre_post_barrier 1\n+#endif /* !HAVE_DMB */\n+\n+#if HAVE_IFUNC\n+extern bool libat_have_strexbhd HIDDEN;\n+\n+# define IFUNC_COND_1\tlibat_have_strexbhd\n+# define IFUNC_COND_2\t(__kernel_helper_version >= 5)\n+\n+/* Alternative 1 is -march=armv7-a -- we have everything native.  */\n+# if IFUNC_ALT == 1\n+#  undef  HAVE_ATOMIC_CAS_1\n+#  undef  HAVE_ATOMIC_CAS_2\n+#  undef  HAVE_ATOMIC_CAS_4\n+#  undef  HAVE_ATOMIC_CAS_8\n+#  undef  HAVE_ATOMIC_EXCHANGE_1\n+#  undef  HAVE_ATOMIC_EXCHANGE_2\n+#  undef  HAVE_ATOMIC_EXCHANGE_4\n+#  undef  HAVE_ATOMIC_EXCHANGE_8\n+#  undef  HAVE_ATOMIC_LDST_1\n+#  undef  HAVE_ATOMIC_LDST_2\n+#  undef  HAVE_ATOMIC_LDST_4\n+#  undef  HAVE_ATOMIC_LDST_8\n+#  undef  HAVE_ATOMIC_FETCH_OP_1\n+#  undef  HAVE_ATOMIC_FETCH_OP_2\n+#  undef  HAVE_ATOMIC_FETCH_OP_4\n+#  undef  HAVE_ATOMIC_FETCH_OP_8\n+#  undef  HAVE_ATOMIC_TAS_1\n+#  undef  HAVE_ATOMIC_TAS_2\n+#  undef  HAVE_ATOMIC_TAS_4\n+#  undef  HAVE_ATOMIC_TAS_8\n+#  define HAVE_ATOMIC_CAS_1\t\t1\n+#  define HAVE_ATOMIC_CAS_2\t\t1\n+#  define HAVE_ATOMIC_CAS_4\t\t1\n+#  define HAVE_ATOMIC_CAS_8\t\t1\n+#  define HAVE_ATOMIC_EXCHANGE_1\t1\n+#  define HAVE_ATOMIC_EXCHANGE_2\t1\n+#  define HAVE_ATOMIC_EXCHANGE_4\t1\n+#  define HAVE_ATOMIC_EXCHANGE_8\t1\n+#  define HAVE_ATOMIC_LDST_1\t\t1\n+#  define HAVE_ATOMIC_LDST_2\t\t1\n+#  define HAVE_ATOMIC_LDST_4\t\t1\n+#  define HAVE_ATOMIC_LDST_8\t\t1\n+#  define HAVE_ATOMIC_FETCH_OP_1\t1\n+#  define HAVE_ATOMIC_FETCH_OP_2\t1\n+#  define HAVE_ATOMIC_FETCH_OP_4\t1\n+#  define HAVE_ATOMIC_FETCH_OP_8\t1\n+#  define HAVE_ATOMIC_TAS_1\t\t1\n+#  define HAVE_ATOMIC_TAS_2\t\t1\n+#  define HAVE_ATOMIC_TAS_4\t\t1\n+#  define HAVE_ATOMIC_TAS_8\t\t1\n+# endif /* IFUNC_ALT == 1 */\n+\n+# undef  MAYBE_HAVE_ATOMIC_CAS_1\n+# define MAYBE_HAVE_ATOMIC_CAS_1\tIFUNC_COND_1\n+# undef  MAYBE_HAVE_ATOMIC_EXCHANGE_1\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_1\tMAYBE_HAVE_ATOMIC_CAS_1\n+# undef  MAYBE_HAVE_ATOMIC_LDST_1\n+# define MAYBE_HAVE_ATOMIC_LDST_1\tMAYBE_HAVE_ATOMIC_CAS_1\n+# undef  MAYBE_HAVE_ATOMIC_CAS_2\n+# define MAYBE_HAVE_ATOMIC_CAS_2\tIFUNC_COND_1\n+# undef  MAYBE_HAVE_ATOMIC_EXCHANGE_2\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_2\tMAYBE_HAVE_ATOMIC_CAS_2\n+# undef  MAYBE_HAVE_ATOMIC_LDST_2\n+# define MAYBE_HAVE_ATOMIC_LDST_2\tMAYBE_HAVE_ATOMIC_CAS_2\n+# undef  MAYBE_HAVE_ATOMIC_CAS_4\n+# define MAYBE_HAVE_ATOMIC_CAS_4\tIFUNC_COND_1\n+# undef  MAYBE_HAVE_ATOMIC_EXCHANGE_4\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_4\tMAYBE_HAVE_ATOMIC_CAS_4\n+# undef  MAYBE_HAVE_ATOMIC_LDST_4\n+# define MAYBE_HAVE_ATOMIC_LDST_4\tMAYBE_HAVE_ATOMIC_CAS_4\n+# undef  MAYBE_HAVE_ATOMIC_CAS_8\n+# define MAYBE_HAVE_ATOMIC_CAS_8\t(IFUNC_COND_1 | IFUNC_COND_2)\n+# undef  MAYBE_HAVE_ATOMIC_EXCHANGE_8\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_8\tMAYBE_HAVE_ATOMIC_CAS_8\n+# undef  MAYBE_HAVE_ATOMIC_LDST_8\n+# define MAYBE_HAVE_ATOMIC_LDST_8\tMAYBE_HAVE_ATOMIC_CAS_8\n+\n+# define IFUNC_NCOND(N)\t\t\t(N == 8 ? 2 : 1)\n+\n+#endif /* HAVE_IFUNC */\n+\n+#include_next <host-config.h>"}, {"sha": "532160b45202c6d53ade3a53b71d76ae2fb1520f", "filename": "libatomic/config/linux/arm/init.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Flinux%2Farm%2Finit.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+#if HAVE_IFUNC\n+\n+bool libat_have_strexbhd;\n+\n+static void __attribute__((constructor))\n+init_cpu_revision (void)\n+{\n+}\n+\n+#endif /* HAVE_IFUNC */"}, {"sha": "94e427813ae8d4dcdfb79b4e25bc69d80965cda7", "filename": "libatomic/config/linux/arm/load_n.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fload_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fload_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Flinux%2Farm%2Fload_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,49 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we use the builtin we'll get __sync_synchronize, not __kernel_dmb.  */\n+#if !DONE && N <= WORDSIZE && !defined(HAVE_DMB) && !defined(HAVE_DMB_MCR)\n+UTYPE\n+SIZE(libat_load) (UTYPE *mptr, int smodel)\n+{\n+  UTYPE ret;\n+\n+  if (maybe_specialcase_relaxed(smodel))\n+    ret = *mptr;\n+  else\n+    {\n+      __kernel_dmb ();\n+      ret = *mptr;\n+      __kernel_dmb ();\n+    }\n+  return ret;\n+}\n+\n+#define DONE 1\n+#endif /* !HAVE_DMB */\n+\n+#include \"../../../load_n.c\""}, {"sha": "4ab44c3014fe8c12acd6053ec7e761826cc171cd", "filename": "libatomic/config/linux/arm/store_n.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fstore_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Flinux%2Farm%2Fstore_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Flinux%2Farm%2Fstore_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we use the builtin we'll get __sync_synchronize, not __kernel_dmb.  */\n+#if !DONE && N <= WORDSIZE && !defined(HAVE_DMB) && !defined(HAVE_DMB_MCR)\n+void\n+SIZE(libat_store) (UTYPE *mptr, UTYPE val, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    *mptr = val;\n+  else\n+    {\n+      __kernel_dmb ();\n+      *mptr = val;\n+      __kernel_dmb ();\n+    }\n+}\n+\n+#define DONE 1\n+#endif /* !HAVE_DMB */\n+\n+#include \"../../../store_n.c\""}, {"sha": "a296fffd9b5205f9528cc09cdb1a2863bf4e3e86", "filename": "libatomic/config/posix/host-config.h", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fposix%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fposix%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fposix%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,55 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Included after all more target-specific host-config.h.  */\n+\n+\n+#ifndef protect_start_end\n+# ifdef HAVE_ATTRIBUTE_VISIBILITY\n+#  pragma GCC visibility push(hidden)\n+# endif\n+\n+void libat_lock_1 (void *ptr);\n+void libat_unlock_1 (void *ptr);\n+\n+static inline UWORD\n+protect_start (void *ptr)\n+{\n+  libat_lock_1 (ptr);\n+  return 0;\n+}\n+\n+static inline void\n+protect_end (void *ptr, UWORD dummy UNUSED)\n+{\n+  libat_unlock_1 (ptr);\n+}\n+\n+# define protect_start_end 1\n+# ifdef HAVE_ATTRIBUTE_VISIBILITY\n+#  pragma GCC visibility pop\n+# endif\n+#endif /* protect_start_end */\n+\n+#include_next <host-config.h>"}, {"sha": "e57d3330faa74e39f97552cf5ed6f440c2e270fc", "filename": "libatomic/config/posix/lock.c", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fposix%2Flock.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fposix%2Flock.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fposix%2Flock.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,116 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+#include <pthread.h>\n+\n+\n+/* The target page size.  Must be no larger than the runtime page size,\n+   lest locking fail with virtual address aliasing (i.e. a page mmaped\n+   at two locations).  */\n+#ifndef PAGE_SIZE\n+#define PAGE_SIZE\t4096\n+#endif\n+\n+/* The target cacheline size.  This is an optimization; the padding that\n+   should be applied to the locks to keep them from interfering.  */\n+#ifndef CACHLINE_SIZE\n+#define CACHLINE_SIZE\t64\n+#endif\n+\n+/* The granularity at which locks are applied.  Almost certainly the\n+   cachline size is the right thing to use here.  */\n+#ifndef WATCH_SIZE\n+#define WATCH_SIZE\tCACHLINE_SIZE\n+#endif\n+\n+struct lock\n+{\n+  pthread_mutex_t mutex;\n+  char pad[sizeof(pthread_mutex_t) < CACHLINE_SIZE\n+\t   ? CACHLINE_SIZE - sizeof(pthread_mutex_t)\n+\t   : 0];\n+};\n+\n+#define NLOCKS\t\t(PAGE_SIZE / WATCH_SIZE)\n+static struct lock locks[NLOCKS] = {\n+  [0 ... NLOCKS-1].mutex = PTHREAD_MUTEX_INITIALIZER\n+};\n+\n+static inline uintptr_t \n+addr_hash (void *ptr)\n+{\n+  return ((uintptr_t)ptr / WATCH_SIZE) % NLOCKS;\n+}\n+\n+void\n+libat_lock_1 (void *ptr)\n+{\n+  pthread_mutex_lock (&locks[addr_hash (ptr)].mutex);\n+}\n+\n+void\n+libat_unlock_1 (void *ptr)\n+{\n+  pthread_mutex_unlock (&locks[addr_hash (ptr)].mutex);\n+}\n+\n+void\n+libat_lock_n (void *ptr, size_t n)\n+{\n+  uintptr_t h = addr_hash (ptr);\n+  size_t i = 0;\n+\n+  /* Don't lock more than all the locks we have.  */\n+  if (n > PAGE_SIZE)\n+    n = PAGE_SIZE;\n+\n+  do\n+    {\n+      pthread_mutex_lock (&locks[h].mutex);\n+      if (++h == NLOCKS)\n+\th = 0;\n+      i += WATCH_SIZE;\n+    }\n+  while (i < n);\n+}\n+\n+void\n+libat_unlock_n (void *ptr, size_t n)\n+{\n+  uintptr_t h = addr_hash (ptr);\n+  size_t i = 0;\n+\n+  if (n > PAGE_SIZE)\n+    n = PAGE_SIZE;\n+\n+  do\n+    {\n+      pthread_mutex_unlock (&locks[h].mutex);\n+      if (++h == NLOCKS)\n+\th = 0;\n+      i += WATCH_SIZE;\n+    }\n+  while (i < n);\n+}"}, {"sha": "5447c8393e060b4a76be32af290a26c98c5fb6d9", "filename": "libatomic/config/powerpc/host-config.h", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fpowerpc%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fpowerpc%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fpowerpc%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,24 @@\n+/* Avoiding the synchronizations are a good thing.  */\n+#define WANT_SPECIALCASE_RELAXED\n+#define WANT_SPECIALCASE_ACQREL\n+\n+/* Glibc, at least, uses lwsync (aka acq_rel) in its pthread mutex\n+   implementation.  If the user is asking for seq_cst (aka hwsync),\n+   this is insufficient.  */\n+\n+static inline void __attribute__((always_inline, artificial))\n+pre_seq_barrier(int model)\n+{\n+  if (model == __ATOMIC_SEQ_CST)\n+    __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+}\n+\n+static inline void __attribute__((always_inline, artificial))\n+post_seq_barrier(int model)\n+{\n+  pre_seq_barrier(model);\n+}\n+\n+#define pre_post_seq_barrier 1\n+\n+#include_next <host-config.h>"}, {"sha": "c4532c3f997a7f7b884581f00b54f0d9b1492836", "filename": "libatomic/config/x86/host-config.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fx86%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fx86%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fx86%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,69 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#if HAVE_IFUNC\n+#include <cpuid.h>\n+\n+extern unsigned int libat_feat1_ecx HIDDEN;\n+extern unsigned int libat_feat1_edx HIDDEN;\n+\n+#ifdef __x86_64__\n+# define IFUNC_COND_1\t(libat_feat1_ecx & bit_CMPXCHG16B)\n+#else\n+# define IFUNC_COND_1\t(libat_feat1_edx & bit_CMPXCHG8B)\n+#endif\n+\n+#ifdef __x86_64__\n+# define IFUNC_NCOND(N) (N == 16)\n+#else\n+# define IFUNC_NCOND(N) (N == 8)\n+#endif\n+\n+#ifdef __x86_64__\n+# undef MAYBE_HAVE_ATOMIC_CAS_16\n+# define MAYBE_HAVE_ATOMIC_CAS_16\tIFUNC_COND_1\n+# undef MAYBE_HAVE_ATOMIC_EXCHANGE_16\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_16\tIFUNC_COND_1\n+# undef MAYBE_HAVE_ATOMIC_LDST_16\n+# define MAYBE_HAVE_ATOMIC_LDST_16\tIFUNC_COND_1\n+# if IFUNC_ALT == 1\n+#  undef HAVE_ATOMIC_CAS_16\n+#  define HAVE_ATOMIC_CAS_16 1\n+# endif\n+#else\n+# undef MAYBE_HAVE_ATOMIC_CAS_8\n+# define MAYBE_HAVE_ATOMIC_CAS_8\tIFUNC_COND_1\n+# undef MAYBE_HAVE_ATOMIC_EXCHANGE_8\n+# define MAYBE_HAVE_ATOMIC_EXCHANGE_8\tIFUNC_COND_1\n+# undef MAYBE_HAVE_ATOMIC_LDST_8\n+# define MAYBE_HAVE_ATOMIC_LDST_8\tIFUNC_COND_1\n+# if IFUNC_ALT == 1\n+#  undef HAVE_ATOMIC_CAS_8\n+#  define HAVE_ATOMIC_CAS_8 1\n+# endif\n+#endif\n+\n+#endif /* HAVE_IFUNC */\n+\n+#include_next <host-config.h>"}, {"sha": "c4e066a8ad5eb5e6446aeca0f1d6b45993a3752e", "filename": "libatomic/config/x86/init.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fx86%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfig%2Fx86%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfig%2Fx86%2Finit.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,38 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+#if HAVE_IFUNC\n+\n+unsigned int libat_feat1_ecx, libat_feat1_edx;\n+\n+static void __attribute__((constructor))\n+init_cpuid (void)\n+{\n+  unsigned int eax, ebx;\n+  __get_cpuid (1, &eax, &ebx, &libat_feat1_ecx, &libat_feat1_edx);\n+}\n+\n+#endif /* HAVE_IFUNC */"}, {"sha": "db43ea1f1a3ff683f88e0ff47866cdc9e79524b6", "filename": "libatomic/configure", "status": "added", "additions": 17809, "deletions": 0, "changes": 17809, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfigure?ref=483104922ad93037381da8f37a8b2bb471799650"}, {"sha": "18d1dea0503a65c5ec9d1cca379cd6e3a2184f90", "filename": "libatomic/configure.ac", "status": "added", "additions": 255, "deletions": 0, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfigure.ac?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,255 @@\n+# Process this file with autoreconf to produce a configure script.\n+#  Copyright (C) 2012 Free Software Foundation, Inc.\n+#\n+#  This file is part of the GNU Atomic Library (libatomic).\n+#\n+#  Libatomic is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3 of the License, or\n+#  (at your option) any later version.\n+#\n+#  Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+#  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+#  more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>.\n+\n+AC_PREREQ(2.59)\n+AC_INIT([GNU Atomic Library], 1.0,,[libatomic])\n+AC_CONFIG_HEADER(auto-config.h)\n+\n+# -------\n+# Options\n+# -------\n+\n+AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n+LIBAT_ENABLE(version-specific-runtime-libs, no, ,\n+   [Specify that runtime libraries should be installed in a compiler-specific directory],\n+   permit yes|no)\n+AC_MSG_RESULT($enable_version_specific_runtime_libs)\n+\n+# We would like our source tree to be readonly. However when releases or\n+# pre-releases are generated, the flex/bison generated files as well as the\n+# various formats of manuals need to be included along with the rest of the\n+# sources.  Therefore we have --enable-generated-files-in-srcdir to do\n+# just that.\n+AC_MSG_CHECKING([for --enable-generated-files-in-srcdir])\n+LIBAT_ENABLE(generated-files-in-srcdir, no, ,\n+   [put copies of generated files in source dir intended for creating source\n+    tarballs for users without texinfo bison or flex.],\n+   permit yes|no)\n+AC_MSG_RESULT($enable_generated_files_in_srcdir)\n+AM_CONDITIONAL(GENINSRC, test \"$enable_generated_files_in_srcdir\" = yes)\n+\n+\n+# -------\n+\n+# Gets build, host, target, *_vendor, *_cpu, *_os, etc.\n+#\n+# You will slowly go insane if you do not grok the following fact:  when\n+# building this library, the top-level /target/ becomes the library's /host/.\n+#\n+# configure then causes --target to default to --host, exactly like any\n+# other package using autoconf.  Therefore, 'target' and 'host' will\n+# always be the same.  This makes sense both for native and cross compilers\n+# just think about it for a little while.  :-)\n+#\n+# Also, if this library is being configured as part of a cross compiler, the\n+# top-level configure script will pass the \"real\" host as $with_cross_host.\n+#\n+# Do not delete or change the following two lines.  For why, see\n+# http://gcc.gnu.org/ml/libstdc++/2003-07/msg00451.html\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+\n+# Sets up automake.  Must come after AC_CANONICAL_SYSTEM.  Each of the\n+# following is magically included in AUTOMAKE_OPTIONS in each Makefile.am.\n+#  1.9.0:  minimum required version\n+#  no-define:  PACKAGE and VERSION will not be #define'd in config.h (a bunch\n+#              of other PACKAGE_* variables will, however, and there's nothing\n+#              we can do about that; they come from AC_INIT).\n+#  foreign:  we don't follow the normal rules for GNU packages (no COPYING\n+#            file in the top srcdir, etc, etc), so stop complaining.\n+#  -Wall:  turns on all automake warnings...\n+#  -Wno-portability:  ...except this one, since GNU make is required.\n+#  -Wno-override: ... and this one, since we do want this in testsuite.\n+AM_INIT_AUTOMAKE([1.9.0 foreign -Wall -Wno-portability -Wno-override])\n+AM_ENABLE_MULTILIB(, ..)\n+\n+# Calculate toolexeclibdir\n+# Also toolexecdir, though it's only used in toolexeclibdir\n+case ${enable_version_specific_runtime_libs} in\n+  yes)\n+    # Need the gcc compiler version to know where to install libraries\n+    # and header files if --enable-version-specific-runtime-libs option\n+    # is selected.\n+    toolexecdir='$(libdir)/gcc/$(target_alias)'\n+    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n+    ;;\n+  no)\n+    if test -n \"$with_cross_host\" &&\n+       test x\"$with_cross_host\" != x\"no\"; then\n+      # Install a library built with a cross compiler in tooldir, not libdir.\n+      toolexecdir='$(exec_prefix)/$(target_alias)'\n+      toolexeclibdir='$(toolexecdir)/lib'\n+    else\n+      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n+      toolexeclibdir='$(libdir)'\n+    fi\n+    multi_os_directory=`$CC -print-multi-os-directory`\n+    case $multi_os_directory in\n+      .) ;; # Avoid trailing /.\n+      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n+    esac\n+    ;;\n+esac\n+AC_SUBST(toolexecdir)\n+AC_SUBST(toolexeclibdir)\n+\n+# Check the compiler.\n+# The same as in boehm-gc and libstdc++. Have to borrow it from there.\n+# We must force CC to /not/ be precious variables; otherwise\n+# the wrong, non-multilib-adjusted value will be used in multilibs.\n+# As a side effect, we have to subst CFLAGS ourselves.\n+\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+AM_PROG_AS\n+m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AC_SUBST(CFLAGS)\n+\n+# In order to override CFLAGS_FOR_TARGET, all of our special flags go\n+# in XCFLAGS.  But we need them in CFLAGS during configury.  So put them\n+# in both places for now and restore CFLAGS at the end of config.\n+save_CFLAGS=\"$CFLAGS\"\n+\n+# Find other programs we need.\n+AC_CHECK_TOOL(AR, ar)\n+AC_CHECK_TOOL(NM, nm)\n+AC_CHECK_TOOL(RANLIB, ranlib, ranlib-not-found-in-path-error)\n+AC_PATH_PROG(PERL, perl, perl-not-found-in-path-error)\n+AC_PROG_INSTALL\n+\n+# Configure libtool\n+AM_PROG_LIBTOOL\n+AC_SUBST(enable_shared)\n+AC_SUBST(enable_static)\n+\n+# For libtool versioning info, format is CURRENT:REVISION:AGE\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+# Get target configury.\n+. ${srcdir}/configure.tgt\n+if test -n \"$UNSUPPORTED\"; then\n+  AC_MSG_ERROR([Configuration ${target} is unsupported.])\n+fi\n+\n+# Disable fallbacks to __sync routines from libgcc.  Otherwise we'll\n+# make silly decisions about what the cpu can do.\n+CFLAGS=\"$save_CFLAGS -fno-sync-libcalls $XCFLAGS\"\n+\n+# Check header files.\n+AC_STDC_HEADERS\n+ACX_HEADER_STRING\n+GCC_HEADER_STDINT(gstdint.h)\n+\n+# Check for common type sizes\n+LIBAT_FORALL_MODES([LIBAT_HAVE_INT_MODE])\n+\n+# Check for compiler builtins of atomic operations.\n+LIBAT_TEST_ATOMIC_INIT\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_LOADSTORE])\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_TAS])\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_EXCHANGE])\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_CAS])\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_FETCH_ADD])\n+LIBAT_FORALL_MODES([LIBAT_HAVE_ATOMIC_FETCH_OP])\n+\n+AC_C_BIGENDIAN\n+# I don't like the default behaviour of WORDS_BIGENDIAN undefined for LE.\n+AH_BOTTOM(\n+[#ifndef WORDS_BIGENDIAN\n+#define WORDS_BIGENDIAN 0\n+#endif])\n+\n+LIBAT_WORDSIZE\n+\n+# Check to see if -pthread or -lpthread is needed.  Prefer the former.\n+# In case the pthread.h system header is not found, this test will fail.\n+case \" $config_path \" in\n+ *\" posix \"*)\n+  XPCFLAGS=\"\"\n+  CFLAGS=\"$CFLAGS -pthread\"\n+  AC_LINK_IFELSE(\n+    [AC_LANG_PROGRAM(\n+     [#include <pthread.h>\n+      void *g(void *d) { return NULL; }],\n+     [pthread_t t; pthread_create(&t,NULL,g,NULL);])],\n+    [XPCFLAGS=\" -pthread\"],\n+    [CFLAGS=\"$save_CFLAGS $XCFLAGS\" LIBS=\"-lpthread $LIBS\"\n+     AC_LINK_IFELSE(\n+      [AC_LANG_PROGRAM(\n+       [#include <pthread.h>\n+        void *g(void *d) { return NULL; }],\n+       [pthread_t t; pthread_create(&t,NULL,g,NULL);])],\n+      [],\n+      [AC_MSG_ERROR([Pthreads are required to build libatomic])])])\n+  CFLAGS=\"$save_CFLAGS $XCFLAGS\"\n+  ;;\n+esac\n+\n+# See what sort of export controls are available.\n+LIBAT_CHECK_ATTRIBUTE_VISIBILITY\n+LIBAT_CHECK_ATTRIBUTE_DLLEXPORT\n+LIBAT_CHECK_ATTRIBUTE_ALIAS\n+if test x$try_ifunc = xyes; then\n+  LIBAT_CHECK_IFUNC\n+fi\n+\n+# Check linker support.\n+LIBAT_ENABLE_SYMVERS\n+\n+# Cleanup and exit.\n+CFLAGS=\"$save_CFLAGS\"\n+AC_CACHE_SAVE\n+\n+# Add -Wall -Werror if we are using GCC.\n+if test \"x$GCC\" = \"xyes\"; then\n+  XCFLAGS=\"$XCFLAGS -Wall -Werror\"\n+fi\n+\n+XCFLAGS=\"$XCFLAGS $XPCFLAGS\"\n+\n+AC_SUBST(config_path)\n+AC_SUBST(XCFLAGS)\n+AC_SUBST(XLDFLAGS)\n+AC_SUBST(LIBS)\n+AC_SUBST(SIZES)\n+\n+AM_CONDITIONAL(HAVE_IFUNC, test x$libat_cv_have_ifunc = xyes)\n+AM_CONDITIONAL(ARCH_ARM_LINUX,\n+\t       [expr \"$config_path\" : \".* linux/arm .*\" > /dev/null])\n+AM_CONDITIONAL(ARCH_I386,\n+\t       [test \"$ARCH\" = x86 && test x$libat_cv_wordsize = x4])\n+AM_CONDITIONAL(ARCH_X86_64,\n+\t       [test \"$ARCH\" = x86 && test x$libat_cv_wordsize = x8])\n+\n+if test ${multilib} = yes; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_CONFIG_FILES(Makefile testsuite/Makefile)\n+AC_OUTPUT"}, {"sha": "847ac41ebed81efff601fcb966d76f35d228dda2", "filename": "libatomic/configure.tgt", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fconfigure.tgt?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,124 @@\n+# -*- shell-script -*-\n+#  Copyright (C) 2012 Free Software Foundation, Inc.\n+#  Contributed by Richard Henderson <rth@redhat.com>.\n+#\n+#  This file is part of the GNU Atomic Library (libatomic).\n+#\n+#  Libatomic is free software; you can redistribute it and/or modify it\n+#  under the terms of the GNU General Public License as published by\n+#  the Free Software Foundation; either version 3 of the License, or\n+#  (at your option) any later version.\n+#\n+#  Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+#  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+#  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+#  more details.\n+#\n+#  Under Section 7 of GPL version 3, you are granted additional\n+#  permissions described in the GCC Runtime Library Exception, version\n+#  3.1, as published by the Free Software Foundation.\n+#\n+#  You should have received a copy of the GNU General Public License and\n+#  a copy of the GCC Runtime Library Exception along with this program;\n+#  see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+#  <http://www.gnu.org/licenses/>.\n+\n+# Map the target cpu to an ARCH sub-directory.  At the same time,\n+# work out any special compilation flags as necessary.\n+\n+case \"${target_cpu}\" in\n+  alpha*)\t\tARCH=alpha ;;\n+  rs6000 | powerpc*)\tARCH=powerpc ;;\n+  sh*)\t\t\tARCH=sh ;;\n+\n+  arm*)\n+\tARCH=arm\n+\t# ??? Detect when -march=armv7 is already enabled.\n+\ttry_ifunc=yes\n+\t;;\n+\n+  sparc)\n+\tcase \" ${CC} ${CFLAGS} \" in\n+\t  *\" -m64 \"*)\n+\t    ;;\n+\t  *)\n+\t    if test -z \"$with_cpu\"; then\n+\t      XCFLAGS=\"${XCFLAGS} -mcpu=v9\"\n+\t    fi\n+\tesac\n+\tARCH=sparc\n+\t;;\n+  sparc64|sparcv9)\n+\tcase \" ${CC} ${CFLAGS} \" in\n+\t  *\" -m32 \"*)\n+\t    XCFLAGS=\"${XCFLAGS} -mcpu=v9\"\n+\t    ;;\n+\tesac\n+\tARCH=sparc\n+\t;;\n+\n+  i[3456]86)\n+\tcase \" ${CC} ${CFLAGS} \" in\n+\t  *\" -m64 \"*)\n+\t    ;;\n+\t  *)\n+\t    if test -z \"$with_arch\"; then\n+\t      XCFLAGS=\"${XCFLAGS} -march=i486 -mtune=${target_cpu}\"\n+\t      XCFLAGS=\"${XCFLAGS} -fomit-frame-pointer\"\n+\t    fi\n+\tesac\n+\tARCH=x86\n+\t# ??? Detect when -march=i686 is already enabled.\n+\ttry_ifunc=yes\n+\t;;\n+  x86_64)\n+\tcase \" ${CC} ${CFLAGS} \" in\n+\t  *\" -m32 \"*)\n+\t    XCFLAGS=\"${XCFLAGS} -march=i486 -mtune=generic\"\n+\t    XCFLAGS=\"${XCFLAGS} -fomit-frame-pointer\"\n+\t    ;;\n+\t  *)\n+\t    ;;\n+\tesac\n+\tARCH=x86\n+\t# ??? Detect when -mcx16 is already enabled.\n+\ttry_ifunc=yes\n+\t;;\n+\n+  *)\t\t\tARCH=\"${target_cpu}\" ;;\n+esac\n+\n+# The cpu configury is always most relevant.\n+if test -d ${srcdir}/config/$ARCH ; then\n+  config_path=\"$ARCH\"\n+fi\n+\n+# Other system configury\n+case \"${target}\" in\n+  arm*-*-linux*)\n+\t# OS support for atomic primitives.\n+\tconfig_path=\"${config_path} linux/arm posix\"\n+\t;;\n+\n+  *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu \\\n+  | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* \\\n+  | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \\\n+  | *-*-darwin* | *-*-aix*)\n+\t# POSIX system.  The OS is supported.\n+\tconfig_path=\"${config_path} posix\"\n+\t;;\n+\n+  *-*-elf*)\n+\t# ??? No target OS.  We could be targeting bare-metal kernel-mode,\n+\t# or user-mode for some custom OS.  If the target supports TAS,\n+\t# we can build our own spinlocks, given there are no signals.\n+\t# If the target supports disabling interrupts, we can work in\n+\t# kernel-mode, given the system is not multi-processor.\n+\tUNSUPPORTED=1\n+\t;;\n+\n+  *)\n+\t# Who are you?\n+\tUNSUPPORTED=1\n+\t;;\n+esac"}, {"sha": "fb8ee1455098bc1fa4b08117c84df2d789f7948e", "filename": "libatomic/exch_n.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fexch_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fexch_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fexch_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,128 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && SIZE(HAVE_ATOMIC_EXCHANGE)\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return __atomic_exchange_n (mptr, newval, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    return __atomic_exchange_n (mptr, newval, __ATOMIC_ACQ_REL);\n+  else\n+    return __atomic_exchange_n (mptr, newval, __ATOMIC_SEQ_CST);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_EXCHANGE */\n+\n+\n+#if !DONE && defined(atomic_compare_exchange_n)\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UTYPE oldval;\n+\n+  pre_barrier (smodel);\n+\n+  oldval = *mptr;\n+  while (!atomic_compare_exchange_n (mptr, &oldval, newval, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    continue;\n+\n+  post_barrier (smodel);\n+\n+  return oldval;\n+}\n+\n+#define DONE 1\n+#endif /* atomic_compare_exchange_n */\n+\n+\n+/* If this type is smaller than word-sized, fall back to a word-sized\n+   compare-and-swap loop.  */\n+#if !DONE && N <= WORDSIZE && defined(atomic_compare_exchange_w)\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UWORD mask, shift, woldval, wnewval, t, *wptr;\n+\n+  pre_barrier (smodel);\n+\n+  if (N < WORDSIZE)\n+    {\n+      wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+      shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);\n+      mask = SIZE(MASK) << shift;\n+    }\n+  else\n+    {\n+      wptr = (UWORD *)mptr;\n+      shift = 0;\n+      mask = -1;\n+    }\n+\n+  wnewval = (UWORD)newval << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      t = (woldval & ~mask) | wnewval;\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return woldval >> shift;\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_CAS && N < WORDSIZE */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE\n+UTYPE\n+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel UNUSED)\n+{\n+  UTYPE oldval;\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  oldval = *mptr;\n+  *mptr = newval;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return oldval;\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(exchange));"}, {"sha": "5a9cd50db74be0bd74911670a7f9137958a0fdf2", "filename": "libatomic/fadd_n.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffadd_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffadd_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffadd_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <libatomic_i.h>\n+\n+#define NAME\tadd\n+#define OP(X,Y)\t((X) + (Y))\n+\n+/* Defer to HAVE_ATOMIC_FETCH_ADD, which some targets implement specially,\n+   even if HAVE_ATOMIC_FETCH_OP is not defined.  */\n+#if !SIZE(HAVE_ATOMIC_FETCH_OP)\n+# undef HAVE_ATOMIC_FETCH_OP_1\n+# undef HAVE_ATOMIC_FETCH_OP_2\n+# undef HAVE_ATOMIC_FETCH_OP_4\n+# undef HAVE_ATOMIC_FETCH_OP_8\n+# undef HAVE_ATOMIC_FETCH_OP_16\n+# define HAVE_ATOMIC_FETCH_OP_1   HAVE_ATOMIC_FETCH_ADD_1\n+# define HAVE_ATOMIC_FETCH_OP_2   HAVE_ATOMIC_FETCH_ADD_2\n+# define HAVE_ATOMIC_FETCH_OP_4   HAVE_ATOMIC_FETCH_ADD_4\n+# define HAVE_ATOMIC_FETCH_OP_8   HAVE_ATOMIC_FETCH_ADD_8\n+# define HAVE_ATOMIC_FETCH_OP_16  HAVE_ATOMIC_FETCH_ADD_16\n+#endif\n+\n+#include \"fop_n.c\""}, {"sha": "ffe9ed8700fdbe6b4932708d44cd58d9fc01a51b", "filename": "libatomic/fand_n.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffand_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffand_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffand_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+#define NAME\tand\n+#define OP(X,Y)\t((X) & (Y))\n+#include \"fop_n.c\""}, {"sha": "55d0d66b469ffc6cf50c35ac0a64f8a0ee3f6829", "filename": "libatomic/fior_n.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffior_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffior_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffior_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+#define NAME\tor\n+#define OP(X,Y)\t((X) | (Y))\n+#include \"fop_n.c\""}, {"sha": "a3c98c70494802811eb2fed04e1e5e112ce53c18", "filename": "libatomic/fnand_n.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffnand_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffnand_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffnand_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+#define NAME\tnand\n+#define OP(X,Y)\t~((X) & (Y))\n+#include \"fop_n.c\""}, {"sha": "251e3c9e97824e9144d25d5849715e7b12060994", "filename": "libatomic/fop_n.c", "status": "added", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffop_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffop_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffop_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,200 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <libatomic_i.h>\n+\n+\n+/* This file is included multiple times with required defines:\n+     NAME\tthe name of the operation that we're implementing; \n+     OP\t\ta two-operand functional macro the implements the operation.\n+*/\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && SIZE(HAVE_ATOMIC_FETCH_OP)\n+UTYPE\n+SIZE(C2(libat_fetch_,NAME)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return C2(__atomic_fetch_,NAME) (mptr, opval, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    return C2(__atomic_fetch_,NAME) (mptr, opval, __ATOMIC_ACQ_REL);\n+  else\n+    return C2(__atomic_fetch_,NAME) (mptr, opval, __ATOMIC_SEQ_CST);\n+}\n+\n+UTYPE\n+SIZE(C3(libat_,NAME,_fetch)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return C3(__atomic_,NAME,_fetch) (mptr, opval, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    return C3(__atomic_,NAME,_fetch) (mptr, opval, __ATOMIC_ACQ_REL);\n+  else\n+    return C3(__atomic_,NAME,_fetch) (mptr, opval, __ATOMIC_SEQ_CST);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_FETCH_OP */\n+\n+\n+#if !DONE && defined(atomic_compare_exchange_n)\n+UTYPE\n+SIZE(C2(libat_fetch_,NAME)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  UTYPE oldval, t;\n+\n+  pre_barrier (smodel);\n+\n+  oldval = *mptr;\n+  do\n+    {\n+      t = OP(oldval, opval);\n+    }\n+  while (!atomic_compare_exchange_n (mptr, &oldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return oldval;\n+}\n+\n+UTYPE\n+SIZE(C3(libat_,NAME,_fetch)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  UTYPE oldval, t;\n+\n+  pre_barrier (smodel);\n+\n+  oldval = *mptr;\n+  do\n+    {\n+      t = OP(oldval, opval);\n+    }\n+  while (!atomic_compare_exchange_n (mptr, &oldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return t;\n+}\n+\n+#define DONE 1\n+#endif /* atomic_compare_exchange_n */\n+\n+\n+/* If this type is no larger than word-sized, fall back to a word-sized\n+   compare-and-swap loop.  */\n+#if !DONE && N < WORDSIZE && defined(atomic_compare_exchange_w)\n+UTYPE\n+SIZE(C2(libat_fetch_,NAME)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  UWORD mask, shift, woldval, wopval, t, *wptr;\n+\n+  pre_barrier (smodel);\n+\n+  wptr = (UWORD *)mptr;\n+  shift = 0;\n+  mask = -1;\n+\n+  wopval = (UWORD)opval << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      t = (woldval & ~mask) | (OP(woldval, wopval) & mask);\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return woldval >> shift;\n+}\n+\n+UTYPE\n+SIZE(C3(libat_,NAME,_fetch)) (UTYPE *mptr, UTYPE opval, int smodel)\n+{\n+  UWORD mask, shift, woldval, wopval, t, *wptr;\n+\n+  pre_barrier (smodel);\n+\n+  wptr = (UWORD *)mptr;\n+  shift = 0;\n+  mask = -1;\n+\n+  wopval = (UWORD)opval << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      t = (woldval & ~mask) | (OP(woldval, wopval) & mask);\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return t >> shift;\n+}\n+\n+#define DONE 1\n+#endif /* atomic_compare_exchange_w */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE\n+UTYPE\n+SIZE(C2(libat_fetch_,NAME)) (UTYPE *mptr, UTYPE opval, int smodel UNUSED)\n+{\n+  UTYPE ret;\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  ret = *mptr;\n+  *mptr = OP(ret, opval);\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return ret;\n+}\n+\n+UTYPE\n+SIZE(C3(libat_,NAME,_fetch)) (UTYPE *mptr, UTYPE opval, int smodel UNUSED)\n+{\n+  UTYPE ret;\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  ret = OP (*mptr, opval);\n+  *mptr = ret;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return ret;\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(C2(fetch_,NAME)));\n+EXPORT_ALIAS (SIZE(C2(NAME,_fetch)));"}, {"sha": "e9f8d7d25e1812d1a16d681b7ae10cedd88771cd", "filename": "libatomic/fsub_n.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffsub_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffsub_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffsub_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+#define NAME\tsub\n+#define OP(X,Y)\t((X) - (Y))\n+#include \"fop_n.c\""}, {"sha": "0f2d962412738a11f9a0fb4eee07cfc5313dfcea", "filename": "libatomic/fxor_n.c", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffxor_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ffxor_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ffxor_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,3 @@\n+#define NAME\txor\n+#define OP(X,Y)\t((X) ^ (Y))\n+#include \"fop_n.c\""}, {"sha": "235a0dff70fcf388d8360e61a2a7e9c93d36c61a", "filename": "libatomic/gcas.c", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgcas.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgcas.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fgcas.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,120 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we natively support the cas, and if we're unconcerned with extra\n+   barriers (e.g. fully in-order cpu for which barriers are a nop), then\n+   go ahead and expand the operation inline.  */\n+#if !defined(WANT_SPECIALCASE_RELAXED) && !defined(__OPTIMIZE_SIZE__)\n+# define EXACT_INLINE(N)\t\t\t\t\t\\\n+  if (C2(HAVE_ATOMIC_CAS_,N))\t\t\t\t\t\\\n+    return __atomic_compare_exchange_n\t\t\t\t\\\n+      (PTR(N,mptr), PTR(N,eptr), *PTR(N,dptr), false, smodel, fmodel)\n+#else\n+# define EXACT_INLINE(N)\n+#endif\n+\n+/* ... and if all that fails, invoke the function we generated elsewhere.\n+   Worst case, this will *also* use locks.  */\n+#define EXACT(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if ((uintptr_t)mptr & (N - 1)) break;\t\t\t\\\n+    EXACT_INLINE (N);\t\t\t\t\t\t\\\n+    return C3(local_,compare_exchange_,N)\t\t\t\\\n+      (PTR(N,mptr), PTR(N,eptr), *PTR(N,dptr), smodel, fmodel);\t\\\n+  } while (0)\n+\n+#define LARGER(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if (!C2(HAVE_ATOMIC_LDST_,N)) break;\t\t\t\\\n+    if (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break;\t\t\t\\\n+    r = (uintptr_t)mptr & (N - 1);\t\t\t\t\\\n+    a = (uintptr_t)mptr & -N;\t\t\t\t\t\\\n+    if (r + n <= N)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tpre_barrier (smodel);\t\t\t\t\t\\\n+\tu.C2(i,N) = __atomic_load_n (PTR(N,a), __ATOMIC_RELAXED); \\\n+\tdo {\t\t\t\t\t\t\t\\\n+\t  if (memcmp (u.b + r, eptr, n) != 0) goto Lfail;\t\\\n+\t  v = u; memcpy (v.b + r, dptr, n);\t\t\t\\\n+\t} while (!(C2(HAVE_ATOMIC_CAS_,N)\t\t\t\\\n+\t\t   ? __atomic_compare_exchange_n (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N), true,\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)\t\\\n+\t\t   : C3(local_,compare_exchange_,N) (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N),\t\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)));\t\\\n+\tgoto Lsucc;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+\n+bool\n+libat_compare_exchange (size_t n, void *mptr, void *eptr, void *dptr,\n+\t\t\tint smodel, int fmodel)\n+{\n+  union max_size_u u, v;\n+  uintptr_t r, a;\n+  bool ret;\n+\n+  switch (n)\n+    {\n+    case 0:\t\t\t\treturn true;\n+    case 1:\t\tEXACT(1);\tgoto L4;\n+    case 2:\t\tEXACT(2);\tgoto L4;\n+    case 4:\t\tEXACT(4);\tgoto L8;\n+    case 8:\t\tEXACT(8);\tgoto L16;\n+    case 16:\t\tEXACT(16);\tbreak;\n+\n+    case 3: L4:\t\tLARGER(4);\t/* FALLTHRU */\n+    case 5 ... 7: L8:\tLARGER(8);\t/* FALLTHRU */\n+    case 9 ... 15: L16:\tLARGER(16);\tbreak;\n+\n+    Lsucc:\n+      post_barrier (smodel);\n+      return true;\n+    Lfail:\n+      post_barrier (fmodel);\n+      memcpy (eptr, u.b + r, n);\n+      return false;\n+    }\n+\n+  pre_seq_barrier (smodel);\n+  libat_lock_n (mptr, n);\n+\n+  ret = memcmp (mptr, eptr, n) == 0;\n+  memcpy ((ret ? mptr : eptr), (ret ? dptr : mptr), n);\n+\n+  libat_unlock_n (mptr, n);\n+  post_seq_barrier (ret ? smodel : fmodel);\n+\n+  return ret;\n+}\n+\n+EXPORT_ALIAS (compare_exchange);"}, {"sha": "0125b5857141300081b8f8bb27675b3a0def56c4", "filename": "libatomic/gexch.c", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgexch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgexch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fgexch.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,144 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we natively support the exchange, and if we're unconcerned with extra\n+   barriers (e.g. fully in-order cpu for which barriers are a nop), then\n+   go ahead and expand the operation inline.  */\n+#if !defined(WANT_SPECIALCASE_RELAXED) && !defined(__OPTIMIZE_SIZE__)\n+# define EXACT_INLINE(N)\t\t\t\t\t\\\n+  if (C2(HAVE_ATOMIC_EXCHANGE_,N))\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      *PTR(N,rptr) = __atomic_exchange_n\t\t\t\\\n+\t(PTR(N,mptr), *PTR(N,vptr), smodel);\t\t\t\\\n+      return;\t\t\t\t\t\t\t\\\n+    }\n+#else\n+# define EXACT_INLINE(N)\n+#endif\n+\n+\n+#define EXACT(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if ((uintptr_t)mptr & (N - 1)) break;\t\t\t\\\n+    EXACT_INLINE (N);\t\t\t\t\t\t\\\n+    *PTR(N,rptr) = C3(local_,exchange_,N)\t\t\t\\\n+      (PTR(N,mptr), *PTR(N,vptr), smodel);\t\t\t\\\n+    return;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define LARGER(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break;\t\t\t\\\n+    r = (uintptr_t)mptr & (N - 1);\t\t\t\t\\\n+    a = (uintptr_t)mptr & -N;\t\t\t\t\t\\\n+    if (r + n <= N)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tpre_barrier (smodel);\t\t\t\t\t\\\n+\tu.C2(i,N) = *PTR(N,a);\t\t\t\t\t\\\n+\tdo {\t\t\t\t\t\t\t\\\n+\t  v = u;\t\t\t\t\t\t\\\n+\t  memcpy (v.b + r, vptr, n);\t\t\t\t\\\n+\t} while (!(C2(HAVE_ATOMIC_CAS_,N)\t\t\t\\\n+\t\t   ? __atomic_compare_exchange_n (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N), true,\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)\t\\\n+\t\t   : C3(local_,compare_exchange_,N) (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N),\t\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)));\t\\\n+\tgoto Lfinish;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+static void __attribute__((noinline))\n+libat_exchange_large_inplace (size_t n, void *mptr, void *vptr)\n+{\n+#define BUF\t1024\n+\n+  char temp[BUF];\n+  size_t i = 0;\n+\n+  for (i = 0; n >= BUF; i += BUF, n -= BUF)\n+    {\n+      memcpy (temp, mptr + i, BUF);\n+      memcpy (mptr + i, vptr + i, BUF);\n+      memcpy (vptr + i, temp, BUF);\n+    }\n+  if (n > 0)\n+    {\n+      memcpy (temp, mptr + i, n);\n+      memcpy (mptr + i, vptr + i, n);\n+      memcpy (vptr + i, temp, n);\n+    }\n+\n+#undef BUF\n+}\n+\n+void\n+libat_exchange (size_t n, void *mptr, void *vptr, void *rptr, int smodel)\n+{\n+  union max_size_u u, v;\n+  uintptr_t r, a;\n+\n+  switch (n)\n+    {\n+    case 0:\t\t\t\treturn;\n+    case 1:\t\tEXACT(1);\tgoto L4;\n+    case 2:\t\tEXACT(2);\tgoto L4;\n+    case 4:\t\tEXACT(4);\tgoto L8;\n+    case 8:\t\tEXACT(8);\tgoto L16;\n+    case 16:\t\tEXACT(16);\tbreak;\n+\n+    case 3: L4:\t\tLARGER(4);\t/* FALLTHRU */\n+    case 5 ... 7: L8:\tLARGER(8);\t/* FALLTHRU */\n+    case 9 ... 15: L16:\tLARGER(16);\tbreak;\n+\n+    Lfinish:\n+      post_barrier (smodel);\n+      memcpy (rptr, u.b + r, n);\n+      return;\n+    }\n+\n+  pre_seq_barrier (smodel);\n+  libat_lock_n (mptr, n);\n+\n+  if (vptr != rptr)\n+    {\n+      memcpy (rptr, mptr, n);\n+      memcpy (mptr, vptr, n);\n+    }\n+  else\n+    libat_exchange_large_inplace (n, mptr, vptr);\n+\n+  libat_unlock_n (mptr, n);\n+  post_seq_barrier (smodel);\n+}\n+\n+EXPORT_ALIAS (exchange);"}, {"sha": "f47e047e866d86b42d153c3a764017923b420d4d", "filename": "libatomic/glfree.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fglfree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fglfree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fglfree.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,67 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+#define EXACT(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if ((uintptr_t)ptr & (N - 1)) break;\t\t\t\\\n+    if (__atomic_always_lock_free(N, 0)) return true;\t\t\\\n+    if (C2(MAYBE_HAVE_ATOMIC_CAS_,N)) return true;\t\t\\\n+  } while (0)\n+\n+\n+#define LARGER(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    uintptr_t r = (uintptr_t)ptr & (N - 1);\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if (!C2(HAVE_ATOMIC_LDST_,N)) break;\t\t\t\\\n+    if (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break;\t\t\t\\\n+    if (r + n <= N) return true;\t\t\t\t\\\n+  } while (0)\n+\n+\n+bool\n+libat_is_lock_free (size_t n, void *ptr)\n+{\n+  switch (n)\n+    {\n+    case 0:\t\t\t\treturn true;\n+    case 1:\t\tEXACT(1);\tgoto L4;\n+    case 2:\t\tEXACT(2);\tgoto L4;\n+    case 4:\t\tEXACT(4);\tgoto L8;\n+    case 8:\t\tEXACT(8);\tgoto L16;\n+    case 16:\t\tEXACT(16);\tbreak;\n+\n+    case 3: L4:\t\tLARGER(4);\t/* FALLTHRU */\n+    case 5 ... 7: L8:\tLARGER(8);\t/* FALLTHRU */\n+    case 9 ... 15: L16:\tLARGER(16);\tbreak;\n+    }\n+\n+  return false;\n+}\n+\n+EXPORT_ALIAS (is_lock_free);"}, {"sha": "3c8612597cde60e78fa8f0a88d5298f69042ed5f", "filename": "libatomic/gload.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fgload.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,100 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we natively support the load, and if we're unconcerned with extra\n+   barriers (e.g. fully in-order cpu for which barriers are a nop), then\n+   go ahead and expand the operation inline.  */\n+#if !defined(WANT_SPECIALCASE_RELAXED) && !defined(__OPTIMIZE_SIZE__)\n+# define EXACT_INLINE(N, DEST, SRC, DONE)\t\t\t\\\n+  if (C2(HAVE_ATOMIC_LDST_,N))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      DEST = __atomic_load_n (SRC, smodel);\t\t\t\\\n+      DONE;\t\t\t\t\t\t\t\\\n+    }\n+#else\n+# define EXACT_INLINE(N, DEST, SRC, DONE)\n+#endif\n+\n+\n+#define EXACT_(N, DEST, SRC, DONE)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    EXACT_INLINE (N, DEST, SRC, DONE);\t\t\t\t\\\n+    DEST = C3(local_,load_,N) (SRC, smodel);\t\t\t\\\n+    DONE;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+#define EXACT(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if ((uintptr_t)mptr & (N - 1)) break;\t\t\t\\\n+    EXACT_(N, *PTR(N,rptr), PTR(N,mptr), return);\t\t\\\n+  } while (0)\n+\n+#define LARGER(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    r = (uintptr_t)mptr & (N - 1);\t\t\t\t\\\n+    a = (uintptr_t)mptr & -N;\t\t\t\t\t\\\n+    if (r + n <= N)\t\t\t\t\t\t\\\n+      EXACT_ (N, u.C2(i,N), PTR(N,a), goto Lfinish);\t\t\\\n+  } while (0)\n+\n+\n+void\n+libat_load (size_t n, void *mptr, void *rptr, int smodel)\n+{\n+  union max_size_u u;\n+  uintptr_t r, a;\n+\n+  switch (n)\n+    {\n+    case 0:\t\t\t\treturn;\n+    case 1:\t\tEXACT(1);\tgoto L4;\n+    case 2:\t\tEXACT(2);\tgoto L4;\n+    case 4:\t\tEXACT(4);\tgoto L8;\n+    case 8:\t\tEXACT(8);\tgoto L16;\n+    case 16:\t\tEXACT(16);\tbreak;\n+\n+    case 3: L4:\t\tLARGER(4);\t/* FALLTHRU */\n+    case 5 ... 7: L8:\tLARGER(8);\t/* FALLTHRU */\n+    case 9 ... 15: L16:\tLARGER(16);\tbreak;\n+\n+    Lfinish:\n+      memcpy (rptr, u.b + r, n);\n+      return;\n+    }\n+\n+  pre_seq_barrier (smodel);\n+  libat_lock_n (mptr, n);\n+\n+  memcpy (rptr, mptr, n);\n+\n+  libat_unlock_n (mptr, n);\n+  post_seq_barrier (smodel);\n+}\n+\n+EXPORT_ALIAS (load);"}, {"sha": "c54e14ecb06db6ce1caa649323929e296a9d8f62", "filename": "libatomic/gstore.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgstore.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fgstore.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fgstore.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,108 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we natively support the store, and if we're unconcerned with extra\n+   barriers (e.g. fully in-order cpu for which barriers are a nop), then\n+   go ahead and expand the operation inline.  */\n+#if !defined(WANT_SPECIALCASE_RELAXED) && !defined(__OPTIMIZE_SIZE__)\n+# define EXACT_INLINE(N)\t\t\t\t\t\\\n+  if (C2(HAVE_ATOMIC_LDST_,N))\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      __atomic_store_n (PTR(N,mptr), *PTR(N,vptr), smodel);\t\\\n+      return;\t\t\t\t\t\t\t\\\n+    }\n+#else\n+# define EXACT_INLINE(N)\n+#endif\n+\n+\n+#define EXACT(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if ((uintptr_t)mptr & (N - 1)) break;\t\t\t\\\n+    EXACT_INLINE (N);\t\t\t\t\t\t\\\n+    C3(local_,store_,N) (PTR(N,mptr), *PTR(N,vptr), smodel);\t\\\n+    return;\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+#define LARGER(N)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\\\n+    union max_size_u u, v;\t\t\t\t\t\\\n+    uintptr_t r, a;\t\t\t\t\t\t\\\n+    if (!C2(HAVE_INT,N)) break;\t\t\t\t\t\\\n+    if (!C2(MAYBE_HAVE_ATOMIC_CAS_,N)) break;\t\t\t\\\n+    r = (uintptr_t)mptr & (N - 1);\t\t\t\t\\\n+    a = (uintptr_t)mptr & -N;\t\t\t\t\t\\\n+    if (r + n <= N)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tpre_barrier (smodel);\t\t\t\t\t\\\n+\t/* This load need not be atomic, as the CAS\t\t\\\n+\t   below will validate it.  */\t\t\t\t\\\n+\tu.C2(i,N) = *PTR(N,a);\t\t\t\t\t\\\n+\tdo {\t\t\t\t\t\t\t\\\n+\t  v = u; memcpy (v.b + r, vptr, n);\t\t\t\\\n+\t} while (!(C2(HAVE_ATOMIC_CAS_,N)\t\t\t\\\n+\t\t   ? __atomic_compare_exchange_n (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N), true,\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)\t\\\n+\t\t   : C3(local_,compare_exchange_,N) (PTR(N,a),\t\\\n+\t\t\t&u.C2(i,N), v.C2(i,N),\t\t\t\\\n+\t\t\t__ATOMIC_RELAXED, __ATOMIC_RELAXED)));\t\\\n+\tpost_barrier (smodel);\t\t\t\t\t\\\n+\treturn;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n+\n+void\n+libat_store (size_t n, void *mptr, void *vptr, int smodel)\n+{\n+  switch (n)\n+    {\n+    case 0:\t\t\t\treturn;\n+    case 1:\t\tEXACT(1);\tgoto L4;\n+    case 2:\t\tEXACT(2);\tgoto L4;\n+    case 4:\t\tEXACT(4);\tgoto L8;\n+    case 8:\t\tEXACT(8);\tgoto L16;\n+    case 16:\t\tEXACT(16);\tbreak;\n+\n+    case 3: L4:\t\tLARGER(4);\t/* FALLTHRU */\n+    case 5 ... 7: L8:\tLARGER(8);\t/* FALLTHRU */\n+    case 9 ... 15: L16:\tLARGER(16);\tbreak;\n+    }\n+\n+  pre_seq_barrier (smodel);\n+  libat_lock_n (mptr, n);\n+\n+  memcpy (mptr, vptr, n);\n+\n+  libat_unlock_n (mptr, n);\n+  post_seq_barrier (smodel);\n+}\n+\n+EXPORT_ALIAS (store);"}, {"sha": "59e3c00185c11bcf0f6e5709528f2bb0531dfe31", "filename": "libatomic/host-config.h", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fhost-config.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fhost-config.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fhost-config.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,86 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Included after all more target-specific host-config.h.  */\n+\n+\n+/* The target may have some OS specific way to implement compare-and-swap.  */\n+#if !defined(atomic_compare_exchange_n) && SIZE(HAVE_ATOMIC_CAS)\n+# define atomic_compare_exchange_n  __atomic_compare_exchange_n\n+#endif\n+#if !defined(atomic_compare_exchange_w) && WSIZE(HAVE_ATOMIC_CAS)\n+# define atomic_compare_exchange_w  __atomic_compare_exchange_n\n+#endif\n+\n+/* For some targets, it may be significantly faster to avoid all barriers\n+   if the user only wants relaxed memory order.  Sometimes we don't want\n+   the extra code bloat.  In all cases, use the input to avoid warnings.  */\n+#if defined(WANT_SPECIALCASE_RELAXED) && !defined(__OPTIMIZE_SIZE__)\n+# define maybe_specialcase_relaxed(x)\t((x) == __ATOMIC_RELAXED)\n+#else\n+# define maybe_specialcase_relaxed(x)\t((x) & 0)\n+#endif\n+\n+/* Similar, but for targets for which the seq_cst model is sufficiently\n+   more expensive than the acq_rel model.  */\n+#if defined(WANT_SPECIALCASE_ACQREL) && !defined(__OPTIMIZE_SIZE__)\n+# define maybe_specialcase_acqrel(x)\t((x) != __ATOMIC_SEQ_CST)\n+#else\n+# define maybe_specialcase_acqrel(x)\t((x) & 0)\n+#endif\n+\n+\n+/* The target may have some OS specific way to emit barriers.  */\n+#ifndef pre_post_barrier\n+static inline void __attribute__((always_inline, artificial))\n+pre_barrier(int model)\n+{\n+  if (!maybe_specialcase_relaxed(model))\n+    {\n+      if (maybe_specialcase_acqrel(model))\n+        __atomic_thread_fence (__ATOMIC_ACQ_REL);\n+      else\n+        __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+    }\n+}\n+static inline void __attribute__((always_inline, artificial))\n+post_barrier(int model)\n+{\n+  pre_barrier(model);\n+}\n+#define pre_post_barrier 1\n+#endif /* pre_post_barrier */\n+\n+/* Similar, but assume that acq_rel is already handled via locks.  */\n+#ifndef pre_post_seq_barrier\n+static inline void __attribute__((always_inline, artificial))\n+pre_seq_barrier(int model)\n+{\n+}\n+static inline void __attribute__((always_inline, artificial))\n+post_seq_barrier(int model)\n+{\n+}\n+#define pre_post_seq_barrier 1\n+#endif"}, {"sha": "df3b9fb8a098b899679a04ad7b316dd5bd80d040", "filename": "libatomic/init.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Finit.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1 @@\n+/* No runtime initialization needed. */"}, {"sha": "bcf077370a9fc97a4f1b03c46c9539f4b33215da", "filename": "libatomic/libatomic.map", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Flibatomic.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Flibatomic.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Flibatomic.map?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,97 @@\n+LIBATOMIC_1.0 {\n+  global:\n+\t__atomic_load;\n+\t__atomic_store;\n+\t__atomic_exchange;\n+\t__atomic_compare_exchange;\n+\t__atomic_is_lock_free;\n+\n+\t__atomic_add_fetch_1;\n+\t__atomic_add_fetch_2;\n+\t__atomic_add_fetch_4;\n+\t__atomic_add_fetch_8;\n+\t__atomic_add_fetch_16;\n+\t__atomic_and_fetch_1;\n+\t__atomic_and_fetch_2;\n+\t__atomic_and_fetch_4;\n+\t__atomic_and_fetch_8;\n+\t__atomic_and_fetch_16;\n+\t__atomic_compare_exchange_1;\n+\t__atomic_compare_exchange_2;\n+\t__atomic_compare_exchange_4;\n+\t__atomic_compare_exchange_8;\n+\t__atomic_compare_exchange_16;\n+\t__atomic_exchange_1;\n+\t__atomic_exchange_2;\n+\t__atomic_exchange_4;\n+\t__atomic_exchange_8;\n+\t__atomic_exchange_16;\n+\t__atomic_fetch_add_1;\n+\t__atomic_fetch_add_2;\n+\t__atomic_fetch_add_4;\n+\t__atomic_fetch_add_8;\n+\t__atomic_fetch_add_16;\n+\t__atomic_fetch_and_1;\n+\t__atomic_fetch_and_2;\n+\t__atomic_fetch_and_4;\n+\t__atomic_fetch_and_8;\n+\t__atomic_fetch_and_16;\n+\t__atomic_fetch_nand_1;\n+\t__atomic_fetch_nand_2;\n+\t__atomic_fetch_nand_4;\n+\t__atomic_fetch_nand_8;\n+\t__atomic_fetch_nand_16;\n+\t__atomic_fetch_or_1;\n+\t__atomic_fetch_or_2;\n+\t__atomic_fetch_or_4;\n+\t__atomic_fetch_or_8;\n+\t__atomic_fetch_or_16;\n+\t__atomic_fetch_sub_1;\n+\t__atomic_fetch_sub_2;\n+\t__atomic_fetch_sub_4;\n+\t__atomic_fetch_sub_8;\n+\t__atomic_fetch_sub_16;\n+\t__atomic_fetch_xor_1;\n+\t__atomic_fetch_xor_2;\n+\t__atomic_fetch_xor_4;\n+\t__atomic_fetch_xor_8;\n+\t__atomic_fetch_xor_16;\n+\t__atomic_load_1;\n+\t__atomic_load_2;\n+\t__atomic_load_4;\n+\t__atomic_load_8;\n+\t__atomic_load_16;\n+\t__atomic_nand_fetch_1;\n+\t__atomic_nand_fetch_2;\n+\t__atomic_nand_fetch_4;\n+\t__atomic_nand_fetch_8;\n+\t__atomic_nand_fetch_16;\n+\t__atomic_or_fetch_1;\n+\t__atomic_or_fetch_2;\n+\t__atomic_or_fetch_4;\n+\t__atomic_or_fetch_8;\n+\t__atomic_or_fetch_16;\n+\t__atomic_store_1;\n+\t__atomic_store_2;\n+\t__atomic_store_4;\n+\t__atomic_store_8;\n+\t__atomic_store_16;\n+\t__atomic_sub_fetch_1;\n+\t__atomic_sub_fetch_2;\n+\t__atomic_sub_fetch_4;\n+\t__atomic_sub_fetch_8;\n+\t__atomic_sub_fetch_16;\n+\t__atomic_test_and_set_1;\n+\t__atomic_test_and_set_2;\n+\t__atomic_test_and_set_4;\n+\t__atomic_test_and_set_8;\n+\t__atomic_test_and_set_16;\n+\t__atomic_xor_fetch_1;\n+\t__atomic_xor_fetch_2;\n+\t__atomic_xor_fetch_4;\n+\t__atomic_xor_fetch_8;\n+\t__atomic_xor_fetch_16;\n+\n+  local:\n+\t*;\n+};"}, {"sha": "c3722520bdd37beb944e13dfbc2e1978dc42e351", "filename": "libatomic/libatomic_i.h", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Flibatomic_i.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Flibatomic_i.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Flibatomic_i.h?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,293 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains data types and function declarations that are\n+   private to the implementation of libatomic.  */\n+\n+#ifndef LIBATOMIC_H\n+#define LIBATOMIC_H 1\n+\n+#include \"auto-config.h\"\n+#include <stdbool.h>\n+#include <stdint.h>\n+#include <stddef.h>\n+#include <limits.h>\n+#include <string.h>\n+\n+\n+/* Symbol concatenation macros.  */\n+#define C2_(X,Y)\tX ## Y\n+#define C2(X,Y)\t\tC2_(X,Y)\n+#define C3_(X,Y,Z)\tX ## Y ## Z\n+#define C3(X,Y,Z)\tC3_(X,Y,Z)\n+#define C4_(W,X,Y,Z)\tW ## X ## Y ## Z\n+#define C4(W,X,Y,Z)\tC4_(W,X,Y,Z)\n+\n+/* Stringification macros.  */\n+#define S2(X)\t\t#X\n+#define S(X)\t\tS2(X)\n+\n+/* All of the primitive types on which we operate.  */\n+typedef unsigned U_1 __attribute__((mode(QI)));\n+#if HAVE_INT2\n+typedef unsigned U_2 __attribute__((mode(HI)));\n+#endif\n+#if HAVE_INT4\n+typedef unsigned U_4 __attribute__((mode(SI)));\n+#endif\n+#if HAVE_INT8\n+typedef unsigned U_8 __attribute__((mode(DI)));\n+#endif\n+#if HAVE_INT16\n+typedef unsigned U_16 __attribute__((mode(TI)));\n+#endif\n+\n+/* The widest type that we support.  */\n+#if HAVE_INT16\n+# define MAX_SIZE\t16\n+#elif HAVE_INT8\n+# define MAX_SIZE\t8\n+#elif HAVE_INT4\n+# define MAX_SIZE\t4\n+#elif HAVE_INT2\n+# define MAX_SIZE\t2\n+#else\n+# define MAX_SIZE\t1\n+#endif\n+typedef C2(U_,MAX_SIZE) U_MAX;\n+\n+/* Provide dummy fallback types so that stuff is syntactically correct\n+   without having to overdo the ifdefs.  The code using these should\n+   always be protected with the HAVE_INT{n} macros.  */\n+#if !HAVE_INT2\n+typedef U_MAX U_2;\n+#endif\n+#if !HAVE_INT4\n+typedef U_MAX U_4;\n+#endif\n+#if !HAVE_INT8\n+typedef U_MAX U_8;\n+#endif\n+#if !HAVE_INT16\n+typedef U_MAX U_16;\n+#endif\n+\n+union max_size_u\n+{\n+  U_1 b[MAX_SIZE];\n+  U_2 i2;\n+  U_4 i4;\n+  U_8 i8;\n+  U_16 i16;\n+};\n+\n+/* The \"word\" size of the machine.  */\n+typedef unsigned UWORD __attribute__((mode(word)));\n+\n+/* Macros for handing sub-word sized quantities.  */\n+#define MASK_1\t\t((UWORD)0xff)\n+#define MASK_2\t\t((UWORD)0xffff)\n+#define MASK_4\t\t((UWORD)0xffffffff)\n+#define INVERT_MASK_1\t((UWORD)WORDS_BIGENDIAN << ((WORDSIZE - 1) * CHAR_BIT))\n+#define INVERT_MASK_2\t((UWORD)WORDS_BIGENDIAN << ((WORDSIZE - 2) * CHAR_BIT))\n+#define INVERT_MASK_4\t((UWORD)WORDS_BIGENDIAN << ((WORDSIZE - 4) * CHAR_BIT))\n+\n+/* Most of the files in this library are compiled multiple times with\n+   N defined to be a power of 2 between 1 and 16.  The SIZE macro is\n+   then used to append _N to the symbol being manipulated.  */\n+#define SIZE(X)\t\tC3(X,_,N)\n+#define WSIZE(X)\tC3(X,_,WORDSIZE)\n+#define PTR(N,X)\t((C2(U_,N) *)X)\n+\n+/* And thus, the type on which this compilation will be operating.  */\n+#define ITYPE\t\tSIZE(I)\n+#define UTYPE\t\tSIZE(U)\n+\n+/* Utility macros for GCC attributes.  */\n+#define UNUSED\t\t__attribute__((unused))\n+#ifdef HAVE_ATTRIBUTE_VISIBILITY\n+# define HIDDEN\t\t__attribute__((visibility(\"hidden\")))\n+#else\n+# define HIDDEN\n+#endif\n+\n+/* Occasionally we have to play games with internal and external symbol\n+   names, in order to work around builtin functions of the same name.\n+   This macro sets the external name of the function appropriately.  */\n+#define ASMNAME(X)\t__asm__(S(C2(__USER_LABEL_PREFIX__,X)))\n+\n+/* Locking for a \"small\" operation.  In the bare-metal single processor\n+   cases this could be implemented by disabling interrupts.  Thus the extra\n+   word passed between the two functions, saving the interrupt level.\n+   It is assumed that the object being locked does not cross the locking\n+   granularity.\n+\n+   Not actually declared here so that they can be defined static inline\n+   in a target-specfic <host-config.h>.\n+\n+UWORD protect_start (void *ptr);\n+void protect_end (void *ptr, UWORD);\n+*/\n+\n+/* Locking for a \"large' operation.  This should always be some sort of\n+   test-and-set operation, as we assume that the interrupt latency would\n+   be unreasonably large.  */\n+void libat_lock_n (void *ptr, size_t n);\n+void libat_unlock_n (void *ptr, size_t n);\n+\n+/* We'll need to declare all of the sized functions a few times...  */\n+#define DECLARE_ALL_SIZED(N)  DECLARE_ALL_SIZED_(N,C2(U_,N))\n+#define DECLARE_ALL_SIZED_(N,T)\t\t\t\t\t\t\\\n+  DECLARE_1(T,    C2(load_,N), (T *mptr, int));\t\t\t\t\\\n+  DECLARE_1(void, C2(store_,N), (T *mptr, T val, int));\t\t\t\\\n+  DECLARE_1(T,    C2(exchange_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(bool, C2(compare_exchange_,N), (T *mptr, T *, T, int, int)); \\\n+  DECLARE_1(bool, C2(test_and_set_,N), (T *mptr, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_add_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_sub_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_and_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_xor_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_or_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(fetch_nand_,N), (T *mptr, T, int));\t\t\\\n+  DECLARE_1(T,    C2(add_fetch_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(sub_fetch_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(and_fetch_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(xor_fetch_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(or_fetch_,N), (T *mptr, T, int));\t\t\t\\\n+  DECLARE_1(T,    C2(nand_fetch_,N), (T *mptr, T, int))\n+\n+/* All sized operations are implemented in hidden functions prefixed with\n+   \"libat_\".  These are either renamed or aliased to the expected prefix\n+   of \"__atomic\".  Some amount of renaming is required to avoid hiding or\n+   conflicting with the builtins of the same name, but this additional\n+   use of hidden symbols (where appropriate) avoids unnecessary PLT entries\n+   on relevant targets.  */\n+\n+#if IFUNC_ALT\n+# define MAN(X)\t\t\tASMNAME(C4(libat_,X,_i,IFUNC_ALT)) HIDDEN\n+#elif defined(HAVE_ATTRIBUTE_ALIAS)\n+# define MAN(X)\t\t\tHIDDEN\n+#else\n+# define MAN(X)\t\t\tASMNAME(C2(__atomic_,X))\n+#endif\n+\n+#if !defined(N) && HAVE_IFUNC\n+# define DECLARE_1(RET,NAME,ARGS) \\\n+\tRET C2(libat_,NAME) ARGS MAN(NAME); \\\n+\tRET C2(ifunc_,NAME) ARGS ASMNAME(C2(__atomic_,NAME))\n+#else\n+# define DECLARE_1(RET,NAME,ARGS)\tRET C2(libat_,NAME) ARGS MAN(NAME)\n+#endif\n+\n+/* Prefix to use when calling internal, possibly ifunc'ed functions.  */\n+#if HAVE_IFUNC\n+# define local_ ifunc_\n+#else\n+# define local_ libat_\n+#endif\n+\n+DECLARE_ALL_SIZED(1);\n+DECLARE_ALL_SIZED(2);\n+DECLARE_ALL_SIZED(4);\n+DECLARE_ALL_SIZED(8);\n+DECLARE_ALL_SIZED(16);\n+\n+#undef DECLARE_1\n+#undef DECLARE_ALL_SIZED\n+#undef DECLARE_ALL_SIZED_\n+\n+/* And the generic sized versions.  */\n+void libat_load (size_t, void *, void *, int) MAN(load);\n+void libat_store (size_t, void *, void *, int) MAN(store);\n+void libat_exchange (size_t, void *, void *, void *, int) MAN(exchange);\n+bool libat_compare_exchange (size_t, void *, void *, void *, int, int)\n+\tMAN(compare_exchange);\n+bool libat_is_lock_free (size_t, void *) MAN(is_lock_free);\n+\n+#undef MAN\n+\n+#include <host-config.h>\n+\n+/* We don't have IFUNC_NCOND until after host-config.h.  */\n+#if !HAVE_IFUNC\n+# define IFUNC_NCOND(N) 0\n+#endif\n+\n+#if IFUNC_ALT\n+# define EXPORT_ALIAS(X)\t/* exported symbol in non-alternate file */\n+#elif defined(N) && IFUNC_NCOND(N)\n+# if IFUNC_NCOND(N) == 1\n+#  define GEN_SELECTOR(X)\t\t\t\t\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i1) HIDDEN;\t\\\n+\tstatic void * C2(select_,X) (void)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (IFUNC_COND_1)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i1);\t\t\t\t\\\n+\t  return C2(libat_,X);\t\t\t\t\t\\\n+\t}\n+# elif IFUNC_NCOND(N) == 2\n+#  define GEN_SELECTOR(X)\t\t\t\t\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i1) HIDDEN;\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i2) HIDDEN;\t\\\n+\tstatic void * C2(select_,X) (void)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (IFUNC_COND_1)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i1);\t\t\t\t\\\n+\t  if (IFUNC_COND_2)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i2);\t\t\t\t\\\n+\t  return C2(libat_,X);\t\t\t\t\t\\\n+\t}\n+# elif IFUNC_NCOND(N) == 3\n+#  define GEN_SELECTOR(X)\t\t\t\t\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i1) HIDDEN;\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i2) HIDDEN;\t\\\n+\textern typeof(C2(libat_,X)) C3(libat_,X,_i3) HIDDEN;\t\\\n+\tstatic void * C2(select_,X) (void)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (IFUNC_COND_1)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i1);\t\t\t\t\\\n+\t  if (IFUNC_COND_2)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i2);\t\t\t\t\\\n+\t  if (IFUNC_COND_3)\t\t\t\t\t\\\n+\t    return C3(libat_,X,_i3);\t\t\t\t\\\n+\t  return C2(libat_,X);\t\t\t\t\t\\\n+\t}\n+# else\n+#  error \"Unsupported number of ifunc alternatives.\"\n+# endif\n+# define EXPORT_ALIAS(X)\t\t\t\t\t\\\n+\tGEN_SELECTOR(X)\t\t\t\t\t\t\\\n+\ttypeof(C2(libat_,X)) C2(ifunc_,X)\t\t\t\\\n+\t  ASMNAME(C2(__atomic_,X))\t\t\t\t\\\n+\t  __attribute__((ifunc(S(C2(select_,X)))))\n+#elif defined(HAVE_ATTRIBUTE_ALIAS)\n+# define EXPORT_ALIAS(X)\t\t\t\t\t\\\n+\textern typeof(C2(libat_,X)) C2(export_,X)\t\t\\\n+\t  ASMNAME(C2(__atomic_,X))\t\t\t\t\\\n+\t  __attribute__((alias(S(C2(libat_,X)))))\n+#else\n+# define EXPORT_ALIAS(X)\t/* original symbol is exported */\n+#endif\n+\n+#endif /* LIBATOMIC_H */"}, {"sha": "a48f256483ef90d7aa116b781673c338e4bb63c1", "filename": "libatomic/load_n.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fload_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fload_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fload_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,115 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && SIZE(HAVE_ATOMIC_LDST)\n+UTYPE\n+SIZE(libat_load) (UTYPE *mptr, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return __atomic_load_n (mptr, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    /* Note that REL and ACQ_REL are not valid for loads.  */\n+    return __atomic_load_n (mptr, __ATOMIC_ACQUIRE);\n+  else\n+    return __atomic_load_n (mptr, __ATOMIC_SEQ_CST);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_LOAD */\n+\n+\n+/* If we have compare-and-swap, use it to swap 0 with 0 and as a side\n+   effect load the original value.  */\n+#if !DONE && defined(atomic_compare_exchange_n)\n+UTYPE\n+SIZE(libat_load) (UTYPE *mptr, int smodel)\n+{\n+  UTYPE t = 0;\n+\n+  if (maybe_specialcase_relaxed(smodel))\n+    atomic_compare_exchange_n (mptr, &t, 0, true,\n+\t\t\t       __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    atomic_compare_exchange_n (mptr, &t, 0, true,\n+\t\t\t       __ATOMIC_ACQ_REL, __ATOMIC_ACQ_REL);\n+  else\n+    atomic_compare_exchange_n (mptr, &t, 0, true,\n+                               __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n+\n+  return t;\n+}\n+\n+#define DONE 1\n+#endif /* atomic_compare_exchange_n */\n+\n+\n+/* Similar, but only assume a word-sized compare-and-swap.  */\n+#if !DONE && N < WORDSIZE && defined(atomic_compare_exchange_w)\n+UTYPE\n+SIZE(libat_load) (UTYPE *mptr, int smodel)\n+{\n+  UWORD shift, t, *wptr;\n+\n+  pre_barrier (smodel);\n+\n+  wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+  shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);\n+\n+  /* Exchange 0 with 0, placing the old value of *WPTR in T.  */\n+  t = 0;\n+  atomic_compare_exchange_w (wptr, &t, 0);\n+\n+  post_barrier (smodel);\n+  return t >> shift;\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_CAS && N < WORDSIZE */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE\n+UTYPE\n+SIZE(libat_load) (UTYPE *mptr, int smodel)\n+{\n+  UTYPE ret;\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  ret = *mptr;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return ret;\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(load));"}, {"sha": "b8c9734c41b02741ed59b29880bc499b41a0e6ba", "filename": "libatomic/store_n.c", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fstore_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Fstore_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Fstore_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,112 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && SIZE(HAVE_ATOMIC_LDST)\n+void\n+SIZE(libat_store) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    __atomic_store_n (mptr, newval, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    /* Note that ACQ and ACQ_REL are not valid for store.  */\n+    __atomic_store_n (mptr, newval, __ATOMIC_RELEASE);\n+  else\n+    __atomic_store_n (mptr, newval, __ATOMIC_SEQ_CST);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_STORE */\n+\n+/* If we have compare-and-swap, use it perform the store.  */\n+#if !DONE && defined(atomic_compare_exchange_n)\n+void\n+SIZE(libat_store) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UTYPE oldval;\n+\n+  pre_barrier (smodel);\n+\n+  oldval = *mptr;\n+  while (!atomic_compare_exchange_n (mptr, &oldval, newval, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    continue;\n+\n+  post_barrier (smodel);\n+}\n+\n+#define DONE 1\n+#endif /* atomic_compare_exchange_n */\n+\n+\n+/* If this type is smaller than word-sized, fall back to a word-sized\n+   compare-and-swap loop.  */\n+#if !DONE && N < WORDSIZE && defined(atomic_compare_exchange_w)\n+void\n+SIZE(libat_store) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UWORD mask, shift, woldval, wnewval, t, *wptr;\n+\n+  pre_barrier (smodel);\n+\n+  wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+  shift = (((uintptr_t)mptr % WORDSIZE) * CHAR_BIT) ^ SIZE(INVERT_MASK);\n+  mask = SIZE(MASK) << shift;\n+\n+  wnewval = (UWORD)newval << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      t = (woldval & ~mask) | wnewval;\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t));\n+\n+  post_barrier (smodel);\n+}\n+\n+#define DONE 1\n+#endif /* N < WORDSIZE && atomic_compare_exchange_w */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE\n+void\n+SIZE(libat_store) (UTYPE *mptr, UTYPE newval, int smodel)\n+{\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  *mptr = newval;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(store));"}, {"sha": "f137707f711f26f407bb1e5ef9d8c876898c4a32", "filename": "libatomic/tas_n.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftas_n.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftas_n.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftas_n.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,115 @@\n+/* Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Richard Henderson <rth@redhat.com>.\n+\n+   This file is part of the GNU Atomic Library (libatomic).\n+\n+   Libatomic is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for\n+   more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"libatomic_i.h\"\n+\n+\n+/* If we support the builtin, just use it.  */\n+#if !DONE && SIZE(HAVE_ATOMIC_TAS)\n+bool\n+SIZE(libat_test_and_set) (UTYPE *mptr, int smodel)\n+{\n+  if (maybe_specialcase_relaxed(smodel))\n+    return __atomic_test_and_set (mptr, __ATOMIC_RELAXED);\n+  else if (maybe_specialcase_acqrel(smodel))\n+    return __atomic_test_and_set (mptr, __ATOMIC_ACQ_REL);\n+  else\n+    return __atomic_test_and_set (mptr, __ATOMIC_SEQ_CST);\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_TAS */\n+\n+\n+/* If this type is smaller than word-sized, fall back to a word-sized\n+   compare-and-swap loop.  */\n+#if !DONE && N <= WORDSIZE && defined(atomic_compare_exchange_w)\n+bool\n+SIZE(libat_test_and_set) (UTYPE *mptr, int smodel)\n+{\n+  UWORD wval, woldval, shift, *wptr, t;\n+\n+  pre_barrier (smodel);\n+\n+  if (N < WORDSIZE)\n+    {\n+      wptr = (UWORD *)((uintptr_t)mptr & -WORDSIZE);\n+      shift = SIZE(INVERT_MASK);\n+    }\n+  else\n+    {\n+      wptr = (UWORD *)mptr;\n+      shift = 0;\n+    }\n+\n+  wval = (UWORD)__GCC_ATOMIC_TEST_AND_SET_TRUEVAL << shift;\n+  woldval = __atomic_load_n (wptr, __ATOMIC_RELAXED);\n+  do\n+    {\n+      t = woldval | wval;\n+    }\n+  while (!atomic_compare_exchange_w (wptr, &woldval, t, true,\n+\t\t\t\t     __ATOMIC_RELAXED, __ATOMIC_RELAXED));\n+\n+  post_barrier (smodel);\n+  return woldval != 0;\n+}\n+\n+#define DONE 1\n+#endif /* HAVE_ATOMIC_CAS && N < WORDSIZE */\n+\n+\n+/* Otherwise, fall back to some sort of protection mechanism.  */\n+#if !DONE && N == 1\n+bool\n+SIZE(libat_test_and_set) (UTYPE *mptr, int smodel)\n+{\n+  UTYPE oldval, newval;\n+  UWORD magic;\n+\n+  pre_seq_barrier (smodel);\n+  magic = protect_start (mptr);\n+\n+  oldval = *mptr;\n+  *mptr = __GCC_ATOMIC_TEST_AND_SET_TRUEVAL;\n+\n+  protect_end (mptr, magic);\n+  post_seq_barrier (smodel);\n+\n+  return ret != 0;\n+}\n+\n+#define DONE 1\n+#endif /* N == 1 */\n+\n+\n+#if !DONE\n+bool\n+SIZE(libat_test_and_set) (UTYPE *mptr, int smodel UNUSED)\n+{\n+  return libat_test_and_set_1 ((U_1 *)mptr, smodel);\n+}\n+#endif\n+\n+EXPORT_ALIAS (SIZE(test_and_set));"}, {"sha": "561b7e25448e27f1236ee70a80b0ce5110194ef7", "filename": "libatomic/testsuite/Makefile.am", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2FMakefile.am?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,13 @@\n+## Process this file with automake to produce Makefile.in.\n+\n+AUTOMAKE_OPTIONS = foreign dejagnu\n+\n+# May be used by various substitution variables.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+\n+EXPECT = $(shell if test -f $(top_builddir)/../expect/expect; then \\\n+\t   echo $(top_builddir)/../expect/expect; else echo expect; fi)\n+\n+_RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \\\n+\t     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)\n+RUNTEST = \"$(_RUNTEST) $(AM_RUNTESTFLAGS)\""}, {"sha": "860d44c6fbb99b45c66ff80299b6b5218e79b9d9", "filename": "libatomic/testsuite/Makefile.in", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2FMakefile.in?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,429 @@\n+# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# @configure_input@\n+\n+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n+# Inc.\n+# This Makefile.in is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+@SET_MAKE@\n+VPATH = @srcdir@\n+pkgdatadir = $(datadir)/@PACKAGE@\n+pkgincludedir = $(includedir)/@PACKAGE@\n+pkglibdir = $(libdir)/@PACKAGE@\n+pkglibexecdir = $(libexecdir)/@PACKAGE@\n+am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n+install_sh_DATA = $(install_sh) -c -m 644\n+install_sh_PROGRAM = $(install_sh) -c\n+install_sh_SCRIPT = $(install_sh) -c\n+INSTALL_HEADER = $(INSTALL_DATA)\n+transform = $(program_transform_name)\n+NORMAL_INSTALL = :\n+PRE_INSTALL = :\n+POST_INSTALL = :\n+NORMAL_UNINSTALL = :\n+PRE_UNINSTALL = :\n+POST_UNINSTALL = :\n+build_triplet = @build@\n+host_triplet = @host@\n+target_triplet = @target@\n+subdir = testsuite\n+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n+\t$(top_srcdir)/../config/depstand.m4 \\\n+\t$(top_srcdir)/../config/lead-dot.m4 \\\n+\t$(top_srcdir)/../config/multi.m4 \\\n+\t$(top_srcdir)/../config/override.m4 \\\n+\t$(top_srcdir)/../config/stdint.m4 \\\n+\t$(top_srcdir)/../ltoptions.m4 $(top_srcdir)/../ltsugar.m4 \\\n+\t$(top_srcdir)/../ltversion.m4 $(top_srcdir)/../lt~obsolete.m4 \\\n+\t$(top_srcdir)/acinclude.m4 $(top_srcdir)/../libtool.m4 \\\n+\t$(top_srcdir)/configure.ac\n+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n+\t$(ACLOCAL_M4)\n+mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+CONFIG_HEADER = $(top_builddir)/auto-config.h\n+CONFIG_CLEAN_FILES =\n+CONFIG_CLEAN_VPATH_FILES =\n+SOURCES =\n+DIST_SOURCES =\n+DEJATOOL = $(PACKAGE)\n+RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir\n+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n+ACLOCAL = @ACLOCAL@\n+AMTAR = @AMTAR@\n+AR = @AR@\n+AUTOCONF = @AUTOCONF@\n+AUTOHEADER = @AUTOHEADER@\n+AUTOMAKE = @AUTOMAKE@\n+AWK = @AWK@\n+CC = @CC@\n+CCAS = @CCAS@\n+CCASDEPMODE = @CCASDEPMODE@\n+CCASFLAGS = @CCASFLAGS@\n+CCDEPMODE = @CCDEPMODE@\n+CFLAGS = @CFLAGS@\n+CPP = @CPP@\n+CPPFLAGS = @CPPFLAGS@\n+CYGPATH_W = @CYGPATH_W@\n+DEFS = @DEFS@\n+DEPDIR = @DEPDIR@\n+DSYMUTIL = @DSYMUTIL@\n+DUMPBIN = @DUMPBIN@\n+ECHO_C = @ECHO_C@\n+ECHO_N = @ECHO_N@\n+ECHO_T = @ECHO_T@\n+EGREP = @EGREP@\n+EXEEXT = @EXEEXT@\n+FGREP = @FGREP@\n+GREP = @GREP@\n+INSTALL = @INSTALL@\n+INSTALL_DATA = @INSTALL_DATA@\n+INSTALL_PROGRAM = @INSTALL_PROGRAM@\n+INSTALL_SCRIPT = @INSTALL_SCRIPT@\n+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n+LD = @LD@\n+LDFLAGS = @LDFLAGS@\n+LIBOBJS = @LIBOBJS@\n+LIBS = @LIBS@\n+LIBTOOL = @LIBTOOL@\n+LIPO = @LIPO@\n+LN_S = @LN_S@\n+LTLIBOBJS = @LTLIBOBJS@\n+MAKEINFO = @MAKEINFO@\n+MKDIR_P = @MKDIR_P@\n+NM = @NM@\n+NMEDIT = @NMEDIT@\n+OBJDUMP = @OBJDUMP@\n+OBJEXT = @OBJEXT@\n+OPT_LDFLAGS = @OPT_LDFLAGS@\n+OTOOL = @OTOOL@\n+OTOOL64 = @OTOOL64@\n+PACKAGE = @PACKAGE@\n+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n+PACKAGE_NAME = @PACKAGE_NAME@\n+PACKAGE_STRING = @PACKAGE_STRING@\n+PACKAGE_TARNAME = @PACKAGE_TARNAME@\n+PACKAGE_URL = @PACKAGE_URL@\n+PACKAGE_VERSION = @PACKAGE_VERSION@\n+PATH_SEPARATOR = @PATH_SEPARATOR@\n+PERL = @PERL@\n+RANLIB = @RANLIB@\n+SECTION_LDFLAGS = @SECTION_LDFLAGS@\n+SED = @SED@\n+SET_MAKE = @SET_MAKE@\n+SHELL = @SHELL@\n+SIZES = @SIZES@\n+STRIP = @STRIP@\n+VERSION = @VERSION@\n+XCFLAGS = @XCFLAGS@\n+XLDFLAGS = @XLDFLAGS@\n+abs_builddir = @abs_builddir@\n+abs_srcdir = @abs_srcdir@\n+abs_top_builddir = @abs_top_builddir@\n+abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_CC = @ac_ct_CC@\n+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n+am__include = @am__include@\n+am__leading_dot = @am__leading_dot@\n+am__quote = @am__quote@\n+am__tar = @am__tar@\n+am__untar = @am__untar@\n+bindir = @bindir@\n+build = @build@\n+build_alias = @build_alias@\n+build_cpu = @build_cpu@\n+build_os = @build_os@\n+build_vendor = @build_vendor@\n+builddir = @builddir@\n+config_path = @config_path@\n+datadir = @datadir@\n+datarootdir = @datarootdir@\n+docdir = @docdir@\n+dvidir = @dvidir@\n+enable_shared = @enable_shared@\n+enable_static = @enable_static@\n+exec_prefix = @exec_prefix@\n+host = @host@\n+host_alias = @host_alias@\n+host_cpu = @host_cpu@\n+host_os = @host_os@\n+host_vendor = @host_vendor@\n+htmldir = @htmldir@\n+includedir = @includedir@\n+infodir = @infodir@\n+install_sh = @install_sh@\n+libdir = @libdir@\n+libexecdir = @libexecdir@\n+libtool_VERSION = @libtool_VERSION@\n+localedir = @localedir@\n+localstatedir = @localstatedir@\n+mandir = @mandir@\n+mkdir_p = @mkdir_p@\n+multi_basedir = @multi_basedir@\n+oldincludedir = @oldincludedir@\n+pdfdir = @pdfdir@\n+prefix = @prefix@\n+program_transform_name = @program_transform_name@\n+psdir = @psdir@\n+sbindir = @sbindir@\n+sharedstatedir = @sharedstatedir@\n+srcdir = @srcdir@\n+sysconfdir = @sysconfdir@\n+target = @target@\n+target_alias = @target_alias@\n+target_cpu = @target_cpu@\n+target_os = @target_os@\n+target_vendor = @target_vendor@\n+toolexecdir = @toolexecdir@\n+toolexeclibdir = @toolexeclibdir@\n+top_build_prefix = @top_build_prefix@\n+top_builddir = @top_builddir@\n+top_srcdir = @top_srcdir@\n+AUTOMAKE_OPTIONS = foreign dejagnu\n+\n+# May be used by various substitution variables.\n+gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n+EXPECT = $(shell if test -f $(top_builddir)/../expect/expect; then \\\n+\t   echo $(top_builddir)/../expect/expect; else echo expect; fi)\n+\n+_RUNTEST = $(shell if test -f $(top_srcdir)/../dejagnu/runtest; then \\\n+\t     echo $(top_srcdir)/../dejagnu/runtest; else echo runtest; fi)\n+\n+RUNTEST = \"$(_RUNTEST) $(AM_RUNTESTFLAGS)\"\n+all: all-am\n+\n+.SUFFIXES:\n+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)\n+\t@for dep in $?; do \\\n+\t  case '$(am__configure_deps)' in \\\n+\t    *$$dep*) \\\n+\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n+\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n+\t      exit 1;; \\\n+\t  esac; \\\n+\tdone; \\\n+\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/Makefile'; \\\n+\t$(am__cd) $(top_srcdir) && \\\n+\t  $(AUTOMAKE) --foreign testsuite/Makefile\n+.PRECIOUS: Makefile\n+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n+\t@case '$?' in \\\n+\t  *config.status*) \\\n+\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n+\t  *) \\\n+\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n+\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n+\tesac;\n+\n+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+\n+$(top_srcdir)/configure:  $(am__configure_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)\n+\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n+$(am__aclocal_m4_deps):\n+\n+mostlyclean-libtool:\n+\t-rm -f *.lo\n+\n+clean-libtool:\n+\t-rm -rf .libs _libs\n+tags: TAGS\n+TAGS:\n+\n+ctags: CTAGS\n+CTAGS:\n+\n+\n+check-DEJAGNU: site.exp\n+\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tEXPECT=$(EXPECT); export EXPECT; \\\n+\truntest=$(RUNTEST); \\\n+\tif $(SHELL) -c \"$$runtest --version\" > /dev/null 2>&1; then \\\n+\t  exit_status=0; l='$(DEJATOOL)'; for tool in $$l; do \\\n+\t    if $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \\\n+\t    then :; else exit_status=1; fi; \\\n+\t  done; \\\n+\telse echo \"WARNING: could not find \\`runtest'\" 1>&2; :;\\\n+\tfi; \\\n+\texit $$exit_status\n+site.exp: Makefile\n+\t@echo 'Making a new site.exp file...'\n+\t@echo '## these variables are automatically generated by make ##' >site.tmp\n+\t@echo '# Do not edit here.  If you wish to override these values' >>site.tmp\n+\t@echo '# edit the last section' >>site.tmp\n+\t@echo 'set srcdir $(srcdir)' >>site.tmp\n+\t@echo \"set objdir `pwd`\" >>site.tmp\n+\t@echo 'set build_alias \"$(build_alias)\"' >>site.tmp\n+\t@echo 'set build_triplet $(build_triplet)' >>site.tmp\n+\t@echo 'set host_alias \"$(host_alias)\"' >>site.tmp\n+\t@echo 'set host_triplet $(host_triplet)' >>site.tmp\n+\t@echo 'set target_alias \"$(target_alias)\"' >>site.tmp\n+\t@echo 'set target_triplet $(target_triplet)' >>site.tmp\n+\t@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp\n+\t@test ! -f site.exp || \\\n+\t  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp\n+\t@-rm -f site.bak\n+\t@test ! -f site.exp || mv site.exp site.bak\n+\t@mv site.tmp site.exp\n+\n+distclean-DEJAGNU:\n+\t-rm -f site.exp site.bak\n+\t-l='$(DEJATOOL)'; for tool in $$l; do \\\n+\t  rm -f $$tool.sum $$tool.log; \\\n+\tdone\n+\n+distdir: $(DISTFILES)\n+\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n+\tlist='$(DISTFILES)'; \\\n+\t  dist_files=`for file in $$list; do echo $$file; done | \\\n+\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n+\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n+\tcase $$dist_files in \\\n+\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n+\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n+\t\t\t   sort -u` ;; \\\n+\tesac; \\\n+\tfor file in $$dist_files; do \\\n+\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n+\t  if test -d $$d/$$file; then \\\n+\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n+\t    if test -d \"$(distdir)/$$file\"; then \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n+\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n+\t    fi; \\\n+\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n+\t  else \\\n+\t    test -f \"$(distdir)/$$file\" \\\n+\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n+\t    || exit 1; \\\n+\t  fi; \\\n+\tdone\n+check-am: all-am\n+\t$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU\n+check: check-am\n+all-am: Makefile\n+installdirs:\n+install: install-am\n+install-exec: install-exec-am\n+install-data: install-data-am\n+uninstall: uninstall-am\n+\n+install-am: all-am\n+\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n+\n+installcheck: installcheck-am\n+install-strip:\n+\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t  `test -z '$(STRIP)' || \\\n+\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+mostlyclean-generic:\n+\n+clean-generic:\n+\n+distclean-generic:\n+\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n+\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n+\n+maintainer-clean-generic:\n+\t@echo \"This command is intended for maintainers to use\"\n+\t@echo \"it deletes files that may require special tools to rebuild.\"\n+clean: clean-am\n+\n+clean-am: clean-generic clean-libtool mostlyclean-am\n+\n+distclean: distclean-am\n+\t-rm -f Makefile\n+distclean-am: clean-am distclean-DEJAGNU distclean-generic\n+\n+dvi: dvi-am\n+\n+dvi-am:\n+\n+html: html-am\n+\n+html-am:\n+\n+info: info-am\n+\n+info-am:\n+\n+install-data-am:\n+\n+install-dvi: install-dvi-am\n+\n+install-dvi-am:\n+\n+install-exec-am:\n+\n+install-html: install-html-am\n+\n+install-html-am:\n+\n+install-info: install-info-am\n+\n+install-info-am:\n+\n+install-man:\n+\n+install-pdf: install-pdf-am\n+\n+install-pdf-am:\n+\n+install-ps: install-ps-am\n+\n+install-ps-am:\n+\n+installcheck-am:\n+\n+maintainer-clean: maintainer-clean-am\n+\t-rm -f Makefile\n+maintainer-clean-am: distclean-am maintainer-clean-generic\n+\n+mostlyclean: mostlyclean-am\n+\n+mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n+\n+pdf: pdf-am\n+\n+pdf-am:\n+\n+ps: ps-am\n+\n+ps-am:\n+\n+uninstall-am:\n+\n+.MAKE: check-am install-am install-strip\n+\n+.PHONY: all all-am check check-DEJAGNU check-am clean clean-generic \\\n+\tclean-libtool distclean distclean-DEJAGNU distclean-generic \\\n+\tdistclean-libtool distdir dvi dvi-am html html-am info info-am \\\n+\tinstall install-am install-data install-data-am install-dvi \\\n+\tinstall-dvi-am install-exec install-exec-am install-html \\\n+\tinstall-html-am install-info install-info-am install-man \\\n+\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n+\tinstall-strip installcheck installcheck-am installdirs \\\n+\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n+\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n+\tuninstall uninstall-am\n+\n+\n+# Tell versions [3.59,3.63) of GNU make to not export all variables.\n+# Otherwise a system limit (for SysV at least) may be exceeded.\n+.NOEXPORT:"}, {"sha": "b5e53fc792e249e874c292d27895cac8d24c2d7e", "filename": "libatomic/testsuite/config/default.exp", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,17 @@\n+#   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+load_lib \"standard.exp\""}, {"sha": "132d637dd960cff3c65b83467f453389923dc2a4", "filename": "libatomic/testsuite/lib/libatomic-dg.exp", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flib%2Flibatomic-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flib%2Flibatomic-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flib%2Flibatomic-dg.exp?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,21 @@\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+proc libatomic-dg-test { prog do_what extra_tool_flags } {\n+    return [gcc-dg-test-1 libatomic_target_compile $prog $do_what $extra_tool_flags]\n+}\n+\n+proc libatomic-dg-prune { system text } {\n+    return [gcc-dg-prune $system $text]\n+}"}, {"sha": "23c3b0828f9301aede11664089a6dc8b045110a6", "filename": "libatomic/testsuite/lib/libatomic.exp", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flib%2Flibatomic.exp?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,220 @@\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+# Damn dejagnu for not having proper library search paths for load_lib.\n+# We have to explicitly load everything that gcc-dg.exp wants to load.\n+\n+proc load_gcc_lib { filename } {\n+    global srcdir loaded_libs\n+\n+    load_file $srcdir/../../gcc/testsuite/lib/$filename\n+    set loaded_libs($filename) \"\"\n+}\n+\n+load_lib dg.exp\n+load_gcc_lib file-format.exp\n+load_gcc_lib target-supports.exp\n+load_gcc_lib target-supports-dg.exp\n+load_gcc_lib scanasm.exp\n+load_gcc_lib scandump.exp\n+load_gcc_lib scanrtl.exp\n+load_gcc_lib scantree.exp\n+load_gcc_lib scanipa.exp\n+load_gcc_lib prune.exp\n+load_gcc_lib target-libpath.exp\n+load_gcc_lib wrapper.exp\n+load_gcc_lib gcc-defs.exp\n+load_gcc_lib torture-options.exp\n+load_gcc_lib timeout.exp\n+load_gcc_lib timeout-dg.exp\n+load_gcc_lib fortran-modules.exp\n+load_gcc_lib gcc-dg.exp\n+\n+set dg-do-what-default run\n+\n+#\n+# GCC_UNDER_TEST is the compiler under test.\n+#\n+\n+set libatomic_compile_options \"\"\n+\n+#\n+# libatomic_init\n+#\n+\n+if [info exists TOOL_OPTIONS] {\n+    set multilibs [get_multilibs $TOOL_OPTIONS]\n+} else {\n+    set multilibs [get_multilibs]\n+}\n+\n+proc libatomic_init { args } {\n+    global srcdir blddir objdir tool_root_dir\n+    global libatomic_initialized\n+    global tmpdir\n+    global blddir\n+    global gluefile wrap_flags\n+    global ALWAYS_CFLAGS\n+    global CFLAGS\n+    global TOOL_EXECUTABLE TOOL_OPTIONS\n+    global GCC_UNDER_TEST\n+    global TESTING_IN_BUILD_TREE\n+    global target_triplet\n+    global always_ld_library_path\n+\n+    set blddir [lookfor_file [get_multilibs] libatomic]\n+\n+    # We set LC_ALL and LANG to C so that we get the same error\n+    # messages as expected.\n+    setenv LC_ALL C\n+    setenv LANG C\n+\n+    if ![info exists GCC_UNDER_TEST] then {\n+\tif [info exists TOOL_EXECUTABLE] {\n+\t    set GCC_UNDER_TEST $TOOL_EXECUTABLE\n+\t} else {\n+\t    set GCC_UNDER_TEST \"[find_gcc]\"\n+\t}\n+    }\n+\n+    if ![info exists tmpdir] {\n+\tset tmpdir \"/tmp\"\n+    }\n+\n+    if [info exists gluefile] {\n+\tunset gluefile\n+    }\n+\n+    if {![info exists CFLAGS]} {\n+\tset CFLAGS \"\"\n+    }\n+\n+    # Locate libgcc.a so we don't need to account for different values of\n+    # SHLIB_EXT on different platforms\n+    set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]\n+    if {$gccdir != \"\"} {\n+\tset gccdir [file dirname $gccdir]\n+    }\n+\n+    # Compute what needs to be put into LD_LIBRARY_PATH\n+    set always_ld_library_path \".:${blddir}/.libs\"\n+\n+    # Compute what needs to be added to the existing LD_LIBRARY_PATH.\n+    if {$gccdir != \"\"} {\n+\t# Add AIX pthread directory first.\n+\tif { [llength [glob -nocomplain ${gccdir}/pthread/libgcc_s*.a]] >= 1 } {\n+\t    append always_ld_library_path \":${gccdir}/pthread\"\n+\t}\n+\tappend always_ld_library_path \":${gccdir}\"\n+\tset compiler [lindex $GCC_UNDER_TEST 0]\n+\n+\tif { [is_remote host] == 0 && [which $compiler] != 0 } {\n+\t  foreach i \"[exec $compiler --print-multi-lib]\" {\n+\t    set mldir \"\"\n+\t    regexp -- \"\\[a-z0-9=_/\\.-\\]*;\" $i mldir\n+\t    set mldir [string trimright $mldir \"\\;@\"]\n+\t    if { \"$mldir\" == \".\" } {\n+\t      continue\n+\t    }\n+\t    if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] >= 1 } {\n+\t      append always_ld_library_path \":${gccdir}/${mldir}\"\n+\t    }\n+\t  }\n+\t}\n+    }\n+\n+    set ALWAYS_CFLAGS \"\"\n+    if { $blddir != \"\" } {\n+\tlappend ALWAYS_CFLAGS \"additional_flags=-B${blddir}/\"\n+\tlappend ALWAYS_CFLAGS \"additional_flags=-I${blddir}\"\n+\tlappend ALWAYS_CFLAGS \"ldflags=-L${blddir}/.libs\"\n+    }\n+    lappend ALWAYS_CFLAGS \"additional_flags=-I${srcdir}/..\"\n+\n+    if [istarget *-*-darwin*] {\n+\tlappend ALWAYS_CFLAGS \"additional_flags=-shared-libgcc\"\n+    }\n+\n+    if [info exists TOOL_OPTIONS] {\n+\tlappend ALWAYS_CFLAGS \"additional_flags=$TOOL_OPTIONS\"\n+    }\n+\n+    # Make sure that lines are not wrapped.  That can confuse the\n+    # error-message parsing machinery.\n+    lappend ALWAYS_CFLAGS \"additional_flags=-fmessage-length=0\"\n+\n+    # Turn off builtin support for atomics so that we test the library.\n+    lappend ALWAYS_CFLAGS \"additional_flags=-fno-inline-atomics\"\n+    lappend ALWAYS_CFLAGS \"ldflags=-latomic\"\n+}\n+\n+#\n+# libatomic_target_compile -- compile a source file\n+#\n+\n+proc libatomic_target_compile { source dest type options } {\n+    global blddir\n+    global libatomic_compile_options\n+    global gluefile wrap_flags\n+    global ALWAYS_CFLAGS\n+    global GCC_UNDER_TEST\n+    global lang_test_file\n+    global lang_library_path\n+    global lang_link_flags\n+\n+    if { [info exists lang_test_file] } {\n+\tif { $blddir != \"\" } {\n+\t    lappend options \"ldflags=-L${blddir}/${lang_library_path}\"\n+\t}\n+\tlappend options \"ldflags=${lang_link_flags}\"\n+    }\n+\n+    if { [target_info needs_status_wrapper] != \"\" && [info exists gluefile] } {\n+\tlappend options \"libs=${gluefile}\"\n+\tlappend options \"ldflags=${wrap_flags}\"\n+    }\n+\n+    lappend options \"additional_flags=[libio_include_flags]\"\n+    lappend options \"timeout=[timeout_value]\"\n+    lappend options \"compiler=$GCC_UNDER_TEST\"\n+\n+    set options [concat $libatomic_compile_options $options]\n+\n+    if [info exists ALWAYS_CFLAGS] {\n+\tset options [concat \"$ALWAYS_CFLAGS\" $options]\n+    }\n+\n+    set options [dg-additional-files-options $options $source]\n+\n+    set result [target_compile $source $dest $type $options]\n+\n+    return $result\n+}\n+\n+proc libatomic_option_help { } {\n+    send_user \" --additional_options,OPTIONS\\t\\tUse OPTIONS to compile the testcase files. OPTIONS should be comma-separated.\\n\"\n+}\n+\n+proc libatomic_option_proc { option } {\n+    if [regexp \"^--additional_options,\" $option] {\n+\tglobal libatomic_compile_options\n+\tregsub \"--additional_options,\" $option \"\" option\n+\tforeach x [split $option \",\"] {\n+\t    lappend libatomic_compile_options \"additional_flags=$x\"\n+\t}\n+\treturn 1\n+    } else {\n+\treturn 0\n+    }\n+}"}, {"sha": "2ac54e80887f55a57ccc94333460d9f65e3d6c32", "filename": "libatomic/testsuite/libatomic.c/atomic-compare-exchange-1.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-1.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v = 0;\n+char expected = 0;\n+char max = ~0;\n+char desired = ~0;\n+char zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "73b259777480cc8a66afd2c7c97d12e6561482a3", "filename": "libatomic/testsuite/libatomic.c/atomic-compare-exchange-2.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v = 0;\n+short expected = 0;\n+short max = ~0;\n+short desired = ~0;\n+short zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "26097288c9d3ebc766946f0bbe2f03ee49c3e2be", "filename": "libatomic/testsuite/libatomic.c/atomic-compare-exchange-3.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-3.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,85 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_compare_exchange_n builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v = 0;\n+int expected = 0;\n+int max = ~0;\n+int desired = ~0;\n+int zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "b6c783ddaba84801cec31550bf6603f0089946b0", "filename": "libatomic/testsuite/libatomic.c/atomic-compare-exchange-4.c", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-4.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,87 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long_runtime } */\n+/* { dg-options \"\" } */\n+/* { dg-options \"-march=pentium\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+/* Test the execution of __atomic_compare_exchange_n builtin for a long_long.  */\n+\n+extern void abort(void);\n+\n+long long v = 0;\n+long long expected = 0;\n+long long max = ~0;\n+long long desired = ~0;\n+long long zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "4cc0209b33f96f3f78023530bc0029ae521d7f18", "filename": "libatomic/testsuite/libatomic.c/atomic-compare-exchange-5.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-compare-exchange-5.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,86 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128_runtime } */\n+/* { dg-options \"-mcx16\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* Test the execution of __atomic_compare_exchange_n builtin for an int_128.  */\n+\n+extern void abort(void);\n+\n+__int128_t v = 0;\n+__int128_t expected = 0;\n+__int128_t max = ~0;\n+__int128_t desired = ~0;\n+__int128_t zero = 0;\n+\n+#define STRONG 0\n+#define WEAK 1\n+\n+main ()\n+{\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, max, STRONG , __ATOMIC_RELAXED, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, 0, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange_n (&v, &expected, desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange_n (&v, &expected, desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  v = 0;\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &max, STRONG, __ATOMIC_RELAXED, __ATOMIC_RELAXED))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_ACQUIRE, __ATOMIC_RELAXED)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &zero, STRONG , __ATOMIC_RELEASE, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&v, &expected, &desired, WEAK, __ATOMIC_ACQ_REL, __ATOMIC_ACQUIRE)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&v, &expected, &desired, STRONG , __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)) \n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "fb78cdbca544f36f210090eb3d97fcc6ee8f8573", "filename": "libatomic/testsuite/libatomic.c/atomic-exchange-1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-1.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_exchange_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "153771a2cdc6c97525b0e64041c6d68e907c1025", "filename": "libatomic/testsuite/libatomic.c/atomic-exchange-2.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_X builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "fbf8f6b966c08412199c919715466f7c96ec7a96", "filename": "libatomic/testsuite/libatomic.c/atomic-exchange-3.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-3.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,62 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_X builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "13022dd38d20283f264ae6546e8abe7c793c25f5", "filename": "libatomic/testsuite/libatomic.c/atomic-exchange-4.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-4.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,64 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long_runtime } */\n+/* { dg-options \"\" } */\n+/* { dg-options \"-march=pentium\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+/* Test the execution of the __atomic_X builtin for a long_long.  */\n+\n+extern void abort(void);\n+\n+long long v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "b0c84b17fd32c2f66080dc346fff1919d3eaa36a", "filename": "libatomic/testsuite/libatomic.c/atomic-exchange-5.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-exchange-5.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,63 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128_runtime } */\n+/* { dg-options \"-mcx16\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_X builtin for a 16 byte value.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count, ret;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELAXED) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQUIRE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_RELEASE) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_ACQ_REL) !=  count++) \n+    abort ();\n+\n+  if (__atomic_exchange_n (&v, count + 1, __ATOMIC_SEQ_CST) !=  count++) \n+    abort ();\n+\n+  /* Now test the generic version.  */\n+\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELAXED);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQUIRE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_RELEASE);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_ACQ_REL);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  __atomic_exchange (&v, &count, &ret, __ATOMIC_SEQ_CST);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+  count++;\n+\n+  return 0;\n+}"}, {"sha": "c3c486a0396bbe8cc65929cb390e7ef3c6260470", "filename": "libatomic/testsuite/libatomic.c/atomic-generic.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-generic.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,55 @@\n+/* Test generic __atomic routines for proper function calling.\n+   memory model.  */\n+/* { dg-options \"-w\" } */\n+/* { dg-do run } */\n+\n+/* Test that the generioc atomic builtins execute as expected..\n+   sync-mem-generic-aux.c supplies a functional external entry point for \n+   the 4 generic functions.  */\n+\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+extern void abort();\n+\n+typedef struct test {\n+  int array[10];\n+} test_struct;\n+\n+test_struct zero = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+test_struct ones = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n+test_struct a,b;\n+\n+int size = sizeof (test_struct);\n+/* Test for consistency on sizes 1, 2, 4, 8, 16 and 32.  */\n+main ()\n+{\n+  test_struct c;\n+\n+  __atomic_store (&a, &zero, __ATOMIC_RELAXED);\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  __atomic_exchange (&a, &ones, &c, __ATOMIC_SEQ_CST);\n+  if (memcmp (&c, &zero, size))\n+    abort ();\n+  if (memcmp (&a, &ones, size))\n+    abort ();\n+\n+  __atomic_load (&a, &b, __ATOMIC_RELAXED);\n+  if (memcmp (&b, &ones, size))\n+    abort ();\n+\n+  if (!__atomic_compare_exchange (&a, &b, &zero, false, __ATOMIC_SEQ_CST, __ATOMIC_ACQUIRE))\n+    abort();\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  if (__atomic_compare_exchange (&a, &b, &ones, false, __ATOMIC_SEQ_CST, __ATOMIC_ACQUIRE))\n+    abort();\n+  if (memcmp (&b, &zero, size))\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "928f9b0f10b3c8504672b456bb2247d4ea762d5e", "filename": "libatomic/testsuite/libatomic.c/atomic-load-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-1.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,66 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_load_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  return 0;\n+}\n+"}, {"sha": "3d1df1cfffa96c90b67c408dcff667a7f86a100e", "filename": "libatomic/testsuite/libatomic.c/atomic-load-2.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,68 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_load_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count;\n+\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "ec238be9e517b4666bb4adf70fa79c6d0db3cb9f", "filename": "libatomic/testsuite/libatomic.c/atomic-load-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-3.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,65 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+extern void abort(void);\n+\n+int v, count;\n+\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "032ad246fd06ca0d5e1aab2fde1a5e77b85294d5", "filename": "libatomic/testsuite/libatomic.c/atomic-load-4.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-4.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,66 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long_runtime } */\n+/* { dg-options \"\" } */\n+/* { dg-options \"-march=pentium\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+extern void abort(void);\n+\n+long long v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "31d806633e1c670e3763b98d01db8a18c47afa90", "filename": "libatomic/testsuite/libatomic.c/atomic-load-5.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-load-5.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,65 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128_runtime } */\n+/* { dg-options \"-mcx16\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+extern void abort(void);\n+\n+__int128_t v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_RELAXED) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_ACQUIRE) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_CONSUME) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  if (__atomic_load_n (&v, __ATOMIC_SEQ_CST) != count++) \n+    abort(); \n+  else \n+    v++;\n+\n+  /* Now test the generic variants.  */\n+\n+  __atomic_load (&v, &count, __ATOMIC_RELAXED);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_ACQUIRE);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_CONSUME);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+  __atomic_load (&v, &count, __ATOMIC_SEQ_CST);\n+  if (count != v)\n+    abort(); \n+  else \n+    v++;\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "bc1716f7799916a0f9162d052f326bdc2507e854", "filename": "libatomic/testsuite/libatomic.c/atomic-op-1.c", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-1.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,554 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count, res;\n+const char init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "8755340cca2218cb27b51ecb601e31b04837d057", "filename": "libatomic/testsuite/libatomic.c/atomic-op-2.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,555 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+\n+/* Test the execution of the __atomic_*OP builtin routines for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count, res;\n+const short init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "69db4894b638a4096595e794d7da7435b4fb01b9", "filename": "libatomic/testsuite/libatomic.c/atomic-op-3.c", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-3.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,554 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count, res;\n+const int init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "7c4a819bfaaea9fb16042e28d8a286e7c68e266d", "filename": "libatomic/testsuite/libatomic.c/atomic-op-4.c", "status": "added", "additions": 556, "deletions": 0, "changes": 556, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-4.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,556 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long_runtime } */\n+/* { dg-options \"\" } */\n+/* { dg-options \"-march=pentium\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for long long.  */\n+\n+extern void abort(void);\n+\n+long long v, count, res;\n+const long long init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "e78d81509978c57acff5d79109143343fed41a62", "filename": "libatomic/testsuite/libatomic.c/atomic-op-5.c", "status": "added", "additions": 555, "deletions": 0, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-op-5.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,555 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128_runtime } */\n+/* { dg-options \"-mcx16\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_*OP builtin routines for an int_128.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count, res;\n+const __int128_t init = ~0;\n+\n+/* The fetch_op routines return the original value before the operation.  */\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_RELAXED) != 0)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_CONSUME) != 1) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQUIRE) != 2)\n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_RELEASE) != 3) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, count, __ATOMIC_ACQ_REL) != 4) \n+    abort ();\n+\n+  if (__atomic_fetch_add (&v, 1, __ATOMIC_SEQ_CST) != 5) \n+    abort ();\n+}\n+\n+\n+void\n+test_fetch_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_RELAXED) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_CONSUME) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQUIRE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, count + 1, __ATOMIC_ACQ_REL) !=  res--) \n+    abort ();\n+\n+  if (__atomic_fetch_sub (&v, 1, __ATOMIC_SEQ_CST) !=  res--) \n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQUIRE) !=  0)\n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_fetch_and (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_fetch_nand ()\n+{\n+  v = init;\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_ACQUIRE) !=  0 ) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_nand (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_fetch_xor (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE) !=  0) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_fetch_xor (&v, ~count, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 2, __ATOMIC_CONSUME) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQUIRE) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, 8, __ATOMIC_RELEASE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_ACQ_REL) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST) !=  31) \n+    abort ();\n+}\n+\n+/* The OP_fetch routines return the new value after the operation.  */\n+\n+void\n+test_add_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_RELAXED) != 1)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_CONSUME) != 2) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQUIRE) != 3)\n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, 1, __ATOMIC_RELEASE) != 4) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL) != 5) \n+    abort ();\n+\n+  if (__atomic_add_fetch (&v, count, __ATOMIC_SEQ_CST) != 6) \n+    abort ();\n+}\n+\n+\n+void\n+test_sub_fetch ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED) !=  --res) \n+    abort ();\n+\n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_CONSUME) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQUIRE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, 1, __ATOMIC_RELEASE) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL) !=  --res) \n+    abort ();                                                  \n+                                                               \n+  if (__atomic_sub_fetch (&v, count + 1, __ATOMIC_SEQ_CST) !=  --res) \n+    abort ();\n+}\n+\n+void\n+test_and_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_RELAXED) !=  0) \n+    abort ();\n+\n+  v = init;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_CONSUME) !=  init) \n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, init, __ATOMIC_RELEASE) !=  init)\n+    abort ();\n+\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  0) \n+    abort ();\n+\n+  v = ~v;\n+  if (__atomic_and_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_nand_fetch ()\n+{\n+  v = init;\n+\n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_RELAXED) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_CONSUME) !=  0) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_RELEASE) !=  0)\n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, init, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();              \n+                           \n+  if (__atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST) !=  init) \n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor_fetch ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (__atomic_xor_fetch (&v, count, __ATOMIC_RELAXED) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_CONSUME) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE) !=  0) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_RELEASE) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, 0, __ATOMIC_ACQ_REL) !=  init) \n+    abort ();\n+\n+  if (__atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST) !=  0) \n+    abort ();\n+}\n+\n+void\n+test_or_fetch ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_RELAXED) !=  1) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 2, __ATOMIC_CONSUME) !=  3) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQUIRE) !=  7) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, 8, __ATOMIC_RELEASE) !=  15) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL) !=  31) \n+    abort ();\n+\n+  count *= 2;\n+  if (__atomic_or_fetch (&v, count, __ATOMIC_SEQ_CST) !=  63) \n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used. Use both variations\n+   within each function.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_CONSUME);\n+  if (v != 2)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, 1 , __ATOMIC_ACQUIRE);\n+  if (v != 3)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, 1, __ATOMIC_RELEASE);\n+  if (v != 4)\n+    abort ();\n+\n+  __atomic_add_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 5)\n+    abort ();\n+\n+  __atomic_fetch_add (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+\n+void\n+test_sub()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != --res)\n+    abort ();\n+\n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_CONSUME);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, 1, __ATOMIC_ACQUIRE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, 1, __ATOMIC_RELEASE);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_sub_fetch (&v, count + 1, __ATOMIC_ACQ_REL);\n+  if (v != --res)\n+    abort ();                                                  \n+                                                               \n+  __atomic_fetch_sub (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_RELAXED);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  __atomic_fetch_and (&v, init, __ATOMIC_CONSUME);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, init, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_and_fetch (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  __atomic_fetch_and (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_nand ()\n+{\n+  v = init;\n+\n+  __atomic_fetch_nand (&v, 0, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, init, __ATOMIC_RELEASE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_nand (&v, init, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_nand_fetch (&v, 0, __ATOMIC_SEQ_CST);\n+  if (v != init)\n+    abort ();\n+}\n+\n+\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  __atomic_xor_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_CONSUME);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, 0, __ATOMIC_ACQUIRE);\n+  if (v != 0)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, ~count, __ATOMIC_RELEASE);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_fetch_xor (&v, 0, __ATOMIC_ACQ_REL);\n+  if (v != init)\n+    abort ();\n+\n+  __atomic_xor_fetch (&v, ~count, __ATOMIC_SEQ_CST);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  __atomic_or_fetch (&v, count, __ATOMIC_RELAXED);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_CONSUME);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, 4, __ATOMIC_ACQUIRE);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, 8, __ATOMIC_RELEASE);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_or_fetch (&v, count, __ATOMIC_ACQ_REL);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  __atomic_fetch_or (&v, count, __ATOMIC_SEQ_CST);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_nand ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add_fetch ();\n+  test_sub_fetch ();\n+  test_and_fetch ();\n+  test_nand_fetch ();\n+  test_xor_fetch ();\n+  test_or_fetch ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_nand ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "f99eb9c844f6a79eb026fe02d26921d21251ca0e", "filename": "libatomic/testsuite/libatomic.c/atomic-store-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-1.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,47 @@\n+/* Test __atomic routines for existence and proper execution on 1 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a char.  */\n+\n+extern void abort(void);\n+\n+char v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "da346fd7de43e97844ca0bf58bc7eb9ba9229f30", "filename": "libatomic/testsuite/libatomic.c/atomic-store-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,46 @@\n+/* Test __atomic routines for existence and proper execution on 2 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_char_short } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a short.  */\n+\n+extern void abort(void);\n+\n+short v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "b691da4592fbeab665c454a8ff3eebc0508f3a22", "filename": "libatomic/testsuite/libatomic.c/atomic-store-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-3.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,47 @@\n+/* Test __atomic routines for existence and proper execution on 4 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_long } */\n+\n+/* Test the execution of the __atomic_store_n builtin for an int.  */\n+\n+extern void abort(void);\n+\n+int v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "0863be99d011fa9844083c46cc0712e7cd50762f", "filename": "libatomic/testsuite/libatomic.c/atomic-store-4.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-4.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,49 @@\n+/* Test __atomic routines for existence and proper execution on 8 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_long_long_runtime } */\n+/* { dg-options \"\" } */\n+/* { dg-options \"-march=pentium\" { target { { i?86-*-* x86_64-*-* } && ia32 } } } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a long long.  */\n+\n+extern void abort(void);\n+\n+long long v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "763d29e240cfa36bf0ceb3a47c38ffd45d6fffa5", "filename": "libatomic/testsuite/libatomic.c/atomic-store-5.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fatomic-store-5.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,48 @@\n+/* Test __atomic routines for existence and proper execution on 16 byte \n+   values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-require-effective-target sync_int_128_runtime } */\n+/* { dg-options \"-mcx16\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+/* Test the execution of the __atomic_store_n builtin for a 16 byte value.  */\n+\n+extern void abort(void);\n+\n+__int128_t v, count;\n+\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELAXED);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_RELEASE);\n+  if (v != ++count)\n+    abort ();\n+\n+  __atomic_store_n (&v, count + 1, __ATOMIC_SEQ_CST);\n+  if (v != ++count)\n+    abort ();\n+\n+  /* Now test the generic variant.  */\n+  count++;\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELAXED);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_RELEASE);\n+  if (v != count++)\n+    abort ();\n+\n+  __atomic_store (&v, &count, __ATOMIC_SEQ_CST);\n+  if (v != count)\n+    abort ();\n+\n+\n+  return 0;\n+}\n+"}, {"sha": "1da3cb1e88675d10b8d4c1cdb554370250bf11da", "filename": "libatomic/testsuite/libatomic.c/c.exp", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fc.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fc.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fc.exp?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,44 @@\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+if [info exists lang_library_path] then {\n+    unset lang_library_path\n+    unset lang_link_flags\n+}\n+if [info exists lang_test_file] then {\n+    unset lang_test_file\n+}\n+\n+load_lib libatomic-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \"-g\"\n+}\n+\n+# Initialize dg.\n+dg-init\n+\n+# Gather a list of all tests.\n+set tests [lsort [find $srcdir/$subdir *.c]]\n+\n+set ld_library_path $always_ld_library_path\n+append ld_library_path [gcc-set-multilib-library-path $GCC_UNDER_TEST]\n+set_ld_library_path_env_vars\n+\n+# Main loop.\n+dg-runtest $tests \"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "aa0014d2dc07b461b72ad519f17d88711fddd510", "filename": "libatomic/testsuite/libatomic.c/generic-2.c", "status": "added", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fgeneric-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/483104922ad93037381da8f37a8b2bb471799650/libatomic%2Ftestsuite%2Flibatomic.c%2Fgeneric-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libatomic%2Ftestsuite%2Flibatomic.c%2Fgeneric-2.c?ref=483104922ad93037381da8f37a8b2bb471799650", "patch": "@@ -0,0 +1,128 @@\n+/* { dg-do run } */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <stdbool.h>\n+\n+/* Avoid using the builtins, calling directly to the library functions\n+   of the same name, so that we get direct access to the size_t and\n+   don't have to create myriad types of different sizes.  */\n+\n+#define C2_(X,Y)\tX ## Y\n+#define C2(X,Y)\t\tC2_(X,Y)\n+\n+#define S2(X)\t\t#X\n+#define S(X)\t\tS2(X)\n+\n+#define ASMNAME(X)\t__asm__(S(C2(__USER_LABEL_PREFIX__,X)))\n+#define MAN(X)\t\tASMNAME(C2(__atomic_,X))\n+\n+void libat_load (size_t, void *, void *, int) MAN(load);\n+void libat_store (size_t, void *, void *, int) MAN(store);\n+void libat_exchange (size_t, void *, void *, void *, int) MAN(exchange);\n+bool libat_compare_exchange (size_t, void *, void *, void *, int, int)\n+\tMAN(compare_exchange);\n+bool libat_is_lock_free (size_t, void *) MAN(is_lock_free);\n+\n+\f\n+#define ALIGN  16\n+#define MAX    4*ALIGN\n+\n+static char a[MAX];\n+static char b[MAX];\n+static char c[MAX];\n+static char pa[MAX];\n+static char pb[MAX];\n+\n+static void test_load(void)\n+{\n+  int i, j;\n+  for (i = ALIGN; i < 2*ALIGN; ++i)\n+    for (j = 1; j <= 2*ALIGN; ++j)\n+      {\n+        memcpy(b, pa, MAX);\n+        memcpy(b + i, pb, j);\n+        libat_load (j, b + i, a, 0);\n+        if (memcmp (a, pb, j) != 0) abort ();\n+      }\n+}\n+\n+static void test_store(void)\n+{\n+  int i, j;\n+  for (i = ALIGN; i < 2*ALIGN; ++i)\n+    for (j = 1; j <= 2*ALIGN; ++j)\n+      {\n+        memcpy(a, pa, MAX);\n+        memcpy(b, pa, MAX);\n+        memcpy(b + i, pb, j);\n+        libat_store (j, a + i, pb, 0);\n+        if (memcmp (a, b, MAX) != 0) abort ();\n+      }\n+}\n+\n+static void test_exch(void)\n+{\n+  int i, j;\n+  for (i = ALIGN; i < 2 * ALIGN; ++i)\n+    for (j = 1; j <= 2*ALIGN; ++j)\n+      {\n+\tmemcpy(a, pa, MAX);\n+        memcpy(b, pa, MAX);\n+        memcpy(b + i, pb, j);\n+        libat_exchange (j, a + i, pb, c, 0);\n+        if (memcmp (a, b, MAX) != 0) abort ();\n+        if (memcmp (c, pa + i, j) != 0) abort ();\n+\n+        memcpy(a, pa, MAX);\n+        memcpy(c, pb, MAX);\n+        libat_exchange (j, a + i, c + i, c + i, 0);\n+        memcpy(b, pa, MAX);\n+        memcpy(b + i, pb + i, j);\n+        if (memcmp (b, a, MAX) != 0) abort ();\n+        memcpy(b, pb, MAX);\n+        memcpy(b + i, pa + i, j);\n+\tif (memcmp (b, c, MAX) != 0) abort ();\n+      }\n+}\n+\n+static void test_cas(void)\n+{\n+  int i, j;\n+  for (i = ALIGN; i < 2 * ALIGN; ++i)\n+    for (j = 1; j <= 2*ALIGN; ++j)\n+      {\n+\tmemcpy(a, pa, MAX);\n+\tmemcpy(b, pa, MAX);\n+\tmemcpy(c, pa, MAX);\n+\tmemcpy(b + i, pb, j);\n+        if (!libat_compare_exchange (j, a + i, c + i, pb, 0, 0)) abort ();\n+\tif (memcmp (c, pa, MAX) != 0) abort ();\n+        if (memcmp (a, b, MAX) != 0) abort ();\n+\n+\tmemcpy(a, pb, MAX);\n+\tmemcpy(b, pa, MAX);\n+\tmemcpy(c, pa, MAX);\n+\tmemcpy(b + i, pb + i, j);\n+        if (libat_compare_exchange (j, a + i, c + i, pb, 0, 0)) abort ();\n+        if (memcmp (a, pb, MAX) != 0) abort ();\n+        if (memcmp (b, c, MAX) != 0) abort ();\n+      }\n+}\n+\n+int main (void)\n+{\n+  int i;\n+  for (i = 0; i < MAX; ++i)\n+    {\n+      pa[i] = i * 2;\n+      pb[i] = i * 2 + 1;\n+    }\n+\n+  test_load ();\n+  test_store ();\n+  test_exch ();\n+  test_cas ();\n+\n+  return 0;\n+}"}]}