{"sha": "ac8f92c18886057261d61d45b8d339629464c77e", "node_id": "C_kwDOANBUbNoAKGFjOGY5MmMxODg4NjA1NzI2MWQ2MWQ0NWI4ZDMzOTYyOTQ2NGM3N2U", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-10-24T21:17:24Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-10-25T16:38:25Z"}, "message": "c++: improve failed constexpr assume diagnostic\n\nI noticed that we were printing \"the comparison reduces to (x == 42)\" when\nwe should be able to give the value of x.  Fixed by doing the same\nevaluation in diagnose_failing_condition that we already do in\nfind_failing_clause.\n\ngcc/cp/ChangeLog:\n\n\t* constexpr.cc (fold_operand): New function.\n\t(find_failing_clause_r): Add const.\n\t(find_failing_clause): Add const.\n\t(diagnose_failing_condition): Add ctx parameter.\n\t(cxx_eval_internal_function): Pass it.\n\t* semantics.cc (diagnose_failing_condition): Move to constexpr.cc.\n\t* cp-tree.h: Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp23/attr-assume2.C: Expect constant values.", "tree": {"sha": "0e7beb4f9c726f91550e35f0bf96d2015bf8be79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e7beb4f9c726f91550e35f0bf96d2015bf8be79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8f92c18886057261d61d45b8d339629464c77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f92c18886057261d61d45b8d339629464c77e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8f92c18886057261d61d45b8d339629464c77e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8f92c18886057261d61d45b8d339629464c77e/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba3902e8f1ee3ca35e3194053ebdc1e174808ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba3902e8f1ee3ca35e3194053ebdc1e174808ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba3902e8f1ee3ca35e3194053ebdc1e174808ea"}], "stats": {"total": 99, "additions": 55, "deletions": 44}, "files": [{"sha": "fc1bc53f68aaa80b986f09bd6017d2450449e7d7", "filename": "gcc/cp/constexpr.cc", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fconstexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fconstexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.cc?ref=ac8f92c18886057261d61d45b8d339629464c77e", "patch": "@@ -1799,6 +1799,24 @@ cx_error_context (void)\n   return r;\n }\n \n+/* E is an operand of a failed assertion, fold it either with or without\n+   constexpr context.  */\n+\n+static tree\n+fold_operand (tree e, const constexpr_ctx *ctx)\n+{\n+  if (ctx)\n+    {\n+      bool new_non_constant_p = false, new_overflow_p = false;\n+      e = cxx_eval_constant_expression (ctx, e, vc_prvalue,\n+\t\t\t\t\t&new_non_constant_p,\n+\t\t\t\t\t&new_overflow_p);\n+    }\n+  else\n+    e = fold_non_dependent_expr (e, tf_none, /*manifestly_const_eval=*/true);\n+  return e;\n+}\n+\n /* If we have a condition in conjunctive normal form (CNF), find the first\n    failing clause.  In other words, given an expression like\n \n@@ -1807,7 +1825,7 @@ cx_error_context (void)\n    return the first 'false'.  EXPR is the expression.  */\n \n static tree\n-find_failing_clause_r (constexpr_ctx *ctx, tree expr)\n+find_failing_clause_r (const constexpr_ctx *ctx, tree expr)\n {\n   if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n     {\n@@ -1818,16 +1836,7 @@ find_failing_clause_r (constexpr_ctx *ctx, tree expr)\n \te = find_failing_clause_r (ctx, TREE_OPERAND (expr, 1));\n       return e;\n     }\n-  tree e = contextual_conv_bool (expr, tf_none);\n-  if (ctx)\n-    {\n-      bool new_non_constant_p = false, new_overflow_p = false;\n-      e = cxx_eval_constant_expression (ctx, e, vc_prvalue,\n-\t\t\t\t\t&new_non_constant_p,\n-\t\t\t\t\t&new_overflow_p);\n-    }\n-  else\n-    e = fold_non_dependent_expr (e, tf_none, /*manifestly_const_eval=*/true);\n+  tree e = fold_operand (expr, ctx);\n   if (integer_zerop (e))\n     /* This is the failing clause.  */\n     return expr;\n@@ -1837,14 +1846,42 @@ find_failing_clause_r (constexpr_ctx *ctx, tree expr)\n /* Wrapper for find_failing_clause_r.  */\n \n tree\n-find_failing_clause (constexpr_ctx *ctx, tree expr)\n+find_failing_clause (const constexpr_ctx *ctx, tree expr)\n {\n   if (TREE_CODE (expr) == TRUTH_ANDIF_EXPR)\n     if (tree e = find_failing_clause_r (ctx, expr))\n       expr = e;\n   return expr;\n }\n \n+/* Emit additional diagnostics for failing condition BAD.\n+   Used by finish_static_assert and IFN_ASSUME constexpr diagnostics.\n+   If SHOW_EXPR_P is true, print the condition (because it was\n+   instantiation-dependent).  */\n+\n+void\n+diagnose_failing_condition (tree bad, location_t cloc, bool show_expr_p,\n+\t\t\t    const constexpr_ctx *ctx /* = nullptr */)\n+{\n+  /* Nobody wants to see the artificial (bool) cast.  */\n+  bad = tree_strip_nop_conversions (bad);\n+\n+  /* Actually explain the failure if this is a concept check or a\n+     requires-expression.  */\n+  if (concept_check_p (bad) || TREE_CODE (bad) == REQUIRES_EXPR)\n+    diagnose_constraints (cloc, bad, NULL_TREE);\n+  else if (COMPARISON_CLASS_P (bad)\n+\t   && ARITHMETIC_TYPE_P (TREE_TYPE (TREE_OPERAND (bad, 0))))\n+    {\n+      tree op0 = fold_operand (TREE_OPERAND (bad, 0), ctx);\n+      tree op1 = fold_operand (TREE_OPERAND (bad, 1), ctx);\n+      tree cond = build2 (TREE_CODE (bad), boolean_type_node, op0, op1);\n+      inform (cloc, \"the comparison reduces to %qE\", cond);\n+    }\n+  else if (show_expr_p)\n+    inform (cloc, \"%qE evaluates to false\", bad);\n+}\n+\n /* Evaluate a call T to a GCC internal function when possible and return\n    the evaluated result or, under the control of CTX, give an error, set\n    NON_CONSTANT_P, and return the unevaluated call T otherwise.  */\n@@ -1897,7 +1934,7 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n \t\t  /* Report the error. */\n \t\t  error_at (cloc,\n \t\t\t    \"failed %<assume%> attribute assumption\");\n-\t\t  diagnose_failing_condition (bad, cloc, false);\n+\t\t  diagnose_failing_condition (bad, cloc, false, &new_ctx);\n \t\t}\n \n \t      *non_constant_p = true;"}, {"sha": "cec376d90af676cba478841ecf8035be968e0936", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=ac8f92c18886057261d61d45b8d339629464c77e", "patch": "@@ -7758,7 +7758,6 @@ extern tree build_transaction_expr\t\t(location_t, tree, int, tree);\n extern bool cxx_omp_create_clause_info\t\t(tree, tree, bool, bool,\n \t\t\t\t\t\t bool, bool);\n extern tree baselink_for_fns                    (tree);\n-extern void diagnose_failing_condition\t\t(tree, location_t, bool);\n extern void finish_static_assert                (tree, tree, location_t,\n \t\t\t\t\t\t bool, bool);\n extern tree finish_decltype_type                (tree, bool, tsubst_flags_t);\n@@ -8497,7 +8496,9 @@ extern void clear_cv_and_fold_caches\t\t(void);\n extern tree unshare_constructor\t\t\t(tree CXX_MEM_STAT_INFO);\n extern bool decl_implicit_constexpr_p\t\t(tree);\n struct constexpr_ctx;\n-extern tree find_failing_clause\t\t\t(constexpr_ctx *ctx, tree);\n+extern tree find_failing_clause\t\t\t(const constexpr_ctx *ctx, tree);\n+extern void diagnose_failing_condition\t\t(tree, location_t, bool,\n+\t\t\t\t\t\t const constexpr_ctx * = nullptr);\n extern bool replace_decl\t\t\t(tree *, tree, tree);\n \n /* An RAII sentinel used to restrict constexpr evaluation so that it"}, {"sha": "36aa9c4499fa29f24c54d8cec585c864a0464641", "filename": "gcc/cp/semantics.cc", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fsemantics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Fcp%2Fsemantics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.cc?ref=ac8f92c18886057261d61d45b8d339629464c77e", "patch": "@@ -11183,33 +11183,6 @@ init_cp_semantics (void)\n }\n \f\n \n-/* Emit additional diagnostics for failing condition BAD.\n-   Used by finish_static_assert and IFN_ASSUME constexpr diagnostics.\n-   If SHOW_EXPR_P is true, print the condition (because it was\n-   instantiation-dependent).  */\n-\n-void\n-diagnose_failing_condition (tree bad, location_t cloc, bool show_expr_p)\n-{\n-  /* Nobody wants to see the artificial (bool) cast.  */\n-  bad = tree_strip_nop_conversions (bad);\n-\n-  /* Actually explain the failure if this is a concept check or a\n-     requires-expression.  */\n-  if (concept_check_p (bad) || TREE_CODE (bad) == REQUIRES_EXPR)\n-    diagnose_constraints (cloc, bad, NULL_TREE);\n-  else if (COMPARISON_CLASS_P (bad)\n-\t   && ARITHMETIC_TYPE_P (TREE_TYPE (TREE_OPERAND (bad, 0))))\n-    {\n-      tree op0 = fold_non_dependent_expr (TREE_OPERAND (bad, 0));\n-      tree op1 = fold_non_dependent_expr (TREE_OPERAND (bad, 1));\n-      tree cond = build2 (TREE_CODE (bad), boolean_type_node, op0, op1);\n-      inform (cloc, \"the comparison reduces to %qE\", cond);\n-    }\n-  else if (show_expr_p)\n-    inform (cloc, \"%qE evaluates to false\", bad);\n-}\n-\n /* Build a STATIC_ASSERT for a static assertion with the condition\n    CONDITION and the message text MESSAGE.  LOCATION is the location\n    of the static assertion in the source code.  When MEMBER_P, this"}, {"sha": "4dd12216d06278f65fdc21e4c2082369d0127bf7", "filename": "gcc/testsuite/g++.dg/cpp23/attr-assume2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8f92c18886057261d61d45b8d339629464c77e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fattr-assume2.C?ref=ac8f92c18886057261d61d45b8d339629464c77e", "patch": "@@ -26,7 +26,7 @@ f2 (int x)\n {\n #if __cpp_constexpr >= 201304L\n   [[assume (x == 42)]];\t\t\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n-#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(x == 42\\\\\\)'\" \"\" { target c++14 } .-1 }\n+#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(44 == 42\\\\\\)'\" \"\" { target c++14 } .-1 }\n   return x;\n }\n \n@@ -76,7 +76,7 @@ f7 (int x, int y, int z, int w)\n {\n #if __cpp_constexpr >= 201304L\n   [[assume (x == 42 && y == 43 && z == 44 && w == 45)]];\t// { dg-error \"failed 'assume' attribute assumption\" \"\" { target c++14 } }\n-#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(z == 44\\\\\\)'\" \"\" { target c++14 } .-1 }\n+#endif\t\t\t\t\t// { dg-message \"the comparison reduces to '\\\\\\(45 == 44\\\\\\)'\" \"\" { target c++14 } .-1 }\n   return x;\n }\n "}]}