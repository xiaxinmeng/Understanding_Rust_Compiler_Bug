{"sha": "e5976695d91f43bc0b49cd260cb88391eb32eae7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU5NzY2OTVkOTFmNDNiYzBiNDljZDI2MGNiODgzOTFlYjMyZWFlNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-12-31T00:11:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-12-31T00:11:47Z"}, "message": "parser.c (cp_parser_context_free_list): New variable.\n\n\t* parser.c (cp_parser_context_free_list): New variable.\n\t(cp_parser_context_new): Use it.\n\t(cp_parser_error): Check return code from\n\tcp_parser_simulate_error.\n\t(cp_parser_simulate_error): Return a value.\n\t(cp_parser_id_expression): Optimize common case.\n\t(cp_parser_class_name): Likewise.\n\t(cp_parser_class_specifier): Adjust call to\n\tcp_parser_late_parsing_default_args.\n\t(cp_parser_lookup_name): Optimize common case.\n\t(cp_parser_late_parsing_for_member): Adjust call to\n\tcp_parser_late_parsing_default_args.\n\t(cp_parser_late_parsing_default_args): Add scope parameter.\n\t(cp_parser_require): Avoid creating the error message unless it's\n\tneeded.\n\t(cp_parser_parse_definitely): Place free'd contexts on the free\n\tlist.\n\nFrom-SVN: r60665", "tree": {"sha": "3e32a2e08e8b48e771d49aa4da01262bdb1610a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e32a2e08e8b48e771d49aa4da01262bdb1610a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5976695d91f43bc0b49cd260cb88391eb32eae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5976695d91f43bc0b49cd260cb88391eb32eae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5976695d91f43bc0b49cd260cb88391eb32eae7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5976695d91f43bc0b49cd260cb88391eb32eae7/comments", "author": null, "committer": null, "parents": [{"sha": "9f1cf235ef3a2ed493966b22eabededb15dd8cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f1cf235ef3a2ed493966b22eabededb15dd8cbb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f1cf235ef3a2ed493966b22eabededb15dd8cbb"}], "stats": {"total": 155, "additions": 100, "deletions": 55}, "files": [{"sha": "fd3af09d6cbf988127bd9592378643d4f44e254b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5976695d91f43bc0b49cd260cb88391eb32eae7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5976695d91f43bc0b49cd260cb88391eb32eae7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e5976695d91f43bc0b49cd260cb88391eb32eae7", "patch": "@@ -1,5 +1,23 @@\n 2002-12-30  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* parser.c (cp_parser_context_free_list): New variable.\n+\t(cp_parser_context_new): Use it.\n+\t(cp_parser_error): Check return code from\n+\tcp_parser_simulate_error.\n+\t(cp_parser_simulate_error): Return a value.\n+\t(cp_parser_id_expression): Optimize common case.\n+\t(cp_parser_class_name): Likewise.\n+\t(cp_parser_class_specifier): Adjust call to\n+\tcp_parser_late_parsing_default_args.\n+\t(cp_parser_lookup_name): Optimize common case.\n+\t(cp_parser_late_parsing_for_member): Adjust call to\n+\tcp_parser_late_parsing_default_args.\n+\t(cp_parser_late_parsing_default_args): Add scope parameter.\n+\t(cp_parser_require): Avoid creating the error message unless it's\n+\tneeded.\n+\t(cp_parser_parse_definitely): Place free'd contexts on the free\n+\tlist.\n+\n \t* parser.c (cp_parser_declaration_seq_opt): Handle pending_lang_change.\n \n 2002-12-30  David Edelsohn  <edelsohn@gnu.org>"}, {"sha": "6c40d9db4748c1ad3fde584e921cb9035a47277b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 82, "deletions": 55, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5976695d91f43bc0b49cd260cb88391eb32eae7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5976695d91f43bc0b49cd260cb88391eb32eae7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e5976695d91f43bc0b49cd260cb88391eb32eae7", "patch": "@@ -1196,6 +1196,10 @@ typedef struct cp_parser_context GTY (())\n static cp_parser_context *cp_parser_context_new\n   PARAMS ((cp_parser_context *));\n \n+/* Class variables.  */\n+\n+static GTY(()) cp_parser_context* cp_parser_context_free_list;\n+\n /* Constructors and destructors.  */\n \n /* Construct a new context.  The context below this one on the stack\n@@ -1208,8 +1212,16 @@ cp_parser_context_new (next)\n   cp_parser_context *context;\n \n   /* Allocate the storage.  */\n-  context = ((cp_parser_context *) \n-\t     ggc_alloc_cleared (sizeof (cp_parser_context)));\n+  if (cp_parser_context_free_list != NULL)\n+    {\n+      /* Pull the first entry from the free list.  */\n+      context = cp_parser_context_free_list;\n+      cp_parser_context_free_list = context->next;\n+      memset ((char *)context, 0, sizeof (*context));\n+    }\n+  else\n+    context = ((cp_parser_context *) \n+\t       ggc_alloc_cleared (sizeof (cp_parser_context)));\n   /* No errors have occurred yet in this context.  */\n   context->status = CP_PARSER_STATUS_KIND_NO_ERROR;\n   /* If this is not the bottomost context, copy information that we\n@@ -1704,7 +1716,7 @@ static tree cp_parser_functional_cast\n static void cp_parser_late_parsing_for_member\n   PARAMS ((cp_parser *, tree));\n static void cp_parser_late_parsing_default_args\n-  PARAMS ((cp_parser *, tree));\n+  (cp_parser *, tree, tree);\n static tree cp_parser_sizeof_operand\n   PARAMS ((cp_parser *, enum rid));\n static bool cp_parser_declares_only_class_p\n@@ -1741,7 +1753,7 @@ static bool cp_parser_committed_to_tentative_parse\n   PARAMS ((cp_parser *));\n static void cp_parser_error\n   PARAMS ((cp_parser *, const char *));\n-static void cp_parser_simulate_error\n+static bool cp_parser_simulate_error\n   PARAMS ((cp_parser *));\n static void cp_parser_check_type_definition\n   PARAMS ((cp_parser *));\n@@ -2213,24 +2225,26 @@ cp_parser_error (parser, message)\n      cp_parser *parser;\n      const char *message;\n {\n-  /* Remember that we have issued an error.  */\n-  cp_parser_simulate_error (parser);\n   /* Output the MESSAGE -- unless we're parsing tentatively.  */\n-  if (!cp_parser_parsing_tentatively (parser) \n-      || cp_parser_committed_to_tentative_parse (parser))\n+  if (!cp_parser_simulate_error (parser))\n     error (message);\n }\n \n /* If we are parsing tentatively, remember that an error has occurred\n-   during this tentative parse.  */\n+   during this tentative parse.  Returns true if the error was\n+   simulated; false if a messgae should be issued by the caller.  */\n \n-static void\n+static bool\n cp_parser_simulate_error (parser)\n      cp_parser *parser;\n {\n   if (cp_parser_parsing_tentatively (parser)\n       && !cp_parser_committed_to_tentative_parse (parser))\n-    parser->context->status = CP_PARSER_STATUS_KIND_ERROR;\n+    {\n+      parser->context->status = CP_PARSER_STATUS_KIND_ERROR;\n+      return true;\n+    }\n+  return false;\n }\n \n /* This function is called when a type is defined.  If type\n@@ -3117,8 +3131,16 @@ cp_parser_id_expression (cp_parser *parser,\n       cp_token *token;\n       tree id;\n \n-      /* We don't know yet whether or not this will be a \n-\t template-id.  */\n+      /* Peek at the next token.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      /* If it's an identifier, and the next token is not a \"<\", then\n+\t we can avoid the template-id case.  This is an optimization\n+\t for this common case.  */\n+      if (token->type == CPP_NAME \n+\t  && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_LESS)\n+\treturn cp_parser_identifier (parser);\n+\n       cp_parser_parse_tentatively (parser);\n       /* Try a template-id.  */\n       id = cp_parser_template_id (parser, \n@@ -3128,7 +3150,8 @@ cp_parser_id_expression (cp_parser *parser,\n       if (cp_parser_parse_definitely (parser))\n \treturn id;\n \n-      /* Peek at the next token.  */\n+      /* Peek at the next token.  (Changes in the token buffer may\n+\t have invalidated the pointer obtained above.)  */\n       token = cp_lexer_peek_token (parser->lexer);\n \n       switch (token->type)\n@@ -11331,29 +11354,28 @@ cp_parser_class_name (cp_parser *parser,\n   tree decl;\n   tree scope;\n   bool typename_p;\n-  \n+  cp_token *token;\n+\n+  /* All class-names start with an identifier.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type != CPP_NAME && token->type != CPP_TEMPLATE_ID)\n+    {\n+      cp_parser_error (parser, \"expected class-name\");\n+      return error_mark_node;\n+    }\n+    \n   /* PARSER->SCOPE can be cleared when parsing the template-arguments\n      to a template-id, so we save it here.  */\n   scope = parser->scope;\n   /* Any name names a type if we're following the `typename' keyword\n      in a qualified name where the enclosing scope is type-dependent.  */\n   typename_p = (typename_keyword_p && scope && TYPE_P (scope)\n \t\t&& cp_parser_dependent_type_p (scope));\n-\n-  /* We don't know whether what comes next is a template-id or \n-     not.  */\n-  cp_parser_parse_tentatively (parser);\n-  /* Try a template-id.  */\n-  decl = cp_parser_template_id (parser, template_keyword_p,\n-\t\t\t\tcheck_dependency_p);\n-  if (cp_parser_parse_definitely (parser))\n-    {\n-      if (decl == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-  else\n+  /* Handle the common case (an identifier, but not a template-id)\n+     efficiently.  */\n+  if (token->type == CPP_NAME \n+      && cp_lexer_peek_nth_token (parser->lexer, 2)->type != CPP_LESS)\n     {\n-      /* If it wasn't a template-id, try a simple identifier.  */\n       tree identifier;\n \n       /* Look for the identifier.  */\n@@ -11385,6 +11407,14 @@ cp_parser_class_name (cp_parser *parser,\n \t\t\t\t\tcheck_dependency_p);\n \t}\n     }\n+  else\n+    {\n+      /* Try a template-id.  */\n+      decl = cp_parser_template_id (parser, template_keyword_p,\n+\t\t\t\t    check_dependency_p);\n+      if (decl == error_mark_node)\n+\treturn error_mark_node;\n+    }\n \n   decl = cp_parser_maybe_treat_template_as_class (decl, class_head_p);\n \n@@ -11515,7 +11545,7 @@ cp_parser_class_specifier (parser)\n \t   parser->default_arg_types;\n \t   parser->default_arg_types = TREE_CHAIN (parser->default_arg_types))\n \tcp_parser_late_parsing_default_args\n-\t  (parser, TREE_PURPOSE (parser->default_arg_types));\n+\t  (parser, TREE_PURPOSE (parser->default_arg_types), NULL_TREE);\n       \n       /* Reverse the queue, so that we process it in the order the\n \t functions were declared.  */\n@@ -13392,9 +13422,7 @@ cp_parser_lookup_name (parser, name, check_access, is_type,\n     {\n       /* The error message we have to print is too complicated for\n \t cp_parser_error, so we incorporate its actions directly.  */\n-      cp_parser_simulate_error (parser);\n-      if (!cp_parser_parsing_tentatively (parser)\n-\t  || cp_parser_committed_to_tentative_parse (parser))\n+      if (!cp_parser_simulate_error (parser))\n \t{\n \t  error (\"reference to `%D' is ambiguous\", name);\n \t  print_candidates (decl);\n@@ -14216,11 +14244,10 @@ cp_parser_late_parsing_for_member (parser, member_function)\n \n   /* If there are default arguments that have not yet been processed,\n      take care of them now.  */\n-  if (DECL_FUNCTION_MEMBER_P (member_function))\n-    push_nested_class (DECL_CONTEXT (member_function), 1);\n-  cp_parser_late_parsing_default_args (parser, TREE_TYPE (member_function));\n-  if (DECL_FUNCTION_MEMBER_P (member_function))\n-    pop_nested_class ();\n+  cp_parser_late_parsing_default_args (parser, TREE_TYPE (member_function),\n+\t\t\t\t       DECL_FUNCTION_MEMBER_P (member_function)\n+\t\t\t\t       ? DECL_CONTEXT (member_function)\n+\t\t\t\t       : NULL_TREE);\n \n   /* If the body of the function has not yet been parsed, parse it\n      now.  */\n@@ -14276,12 +14303,12 @@ cp_parser_late_parsing_for_member (parser, member_function)\n }\n \n /* TYPE is a FUNCTION_TYPE or METHOD_TYPE which contains a parameter\n-   with an unparsed DEFAULT_ARG.  Parse those default args now.  */\n+   with an unparsed DEFAULT_ARG.  If non-NULL, SCOPE is the class in\n+   whose context name lookups in the default argument should occur.\n+   Parse the default args now.  */\n \n static void\n-cp_parser_late_parsing_default_args (parser, type)\n-     cp_parser *parser;\n-     tree type;\n+cp_parser_late_parsing_default_args (cp_parser *parser, tree type, tree scope)\n {\n   cp_lexer *saved_lexer;\n   cp_token_cache *tokens;\n@@ -14312,7 +14339,11 @@ cp_parser_late_parsing_default_args (parser, type)\n       saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n       parser->local_variables_forbidden_p = true;\n        /* Parse the assignment-expression.  */\n+      if (scope)\n+\tpush_nested_class (scope, 1);\n       TREE_PURPOSE (parameters) = cp_parser_assignment_expression (parser);\n+      if (scope)\n+\tpop_nested_class ();\n \n        /* Restore saved state.  */\n       parser->lexer = saved_lexer;\n@@ -14450,14 +14481,9 @@ cp_parser_require (parser, type, token_desc)\n     return cp_lexer_consume_token (parser->lexer);\n   else\n     {\n-      dyn_string_t error_msg;\n-\n-      /* Format the error message.  */\n-      error_msg = dyn_string_new (0);\n-      dyn_string_append_cstr (error_msg, \"expected \");\n-      dyn_string_append_cstr (error_msg, token_desc);\n-      cp_parser_error (parser, error_msg->s);\n-      dyn_string_delete (error_msg);\n+      /* Output the MESSAGE -- unless we're parsing tentatively.  */\n+      if (!cp_parser_simulate_error (parser))\n+\terror (\"expected %s\", token_desc);\n       return NULL;\n     }\n }\n@@ -14759,15 +14785,16 @@ cp_parser_parse_definitely (parser)\n \tparser->context->deferred_access_checks \n \t  = chainon (parser->context->deferred_access_checks,\n \t\t     context->deferred_access_checks);\n-      return true;\n     }\n   /* Otherwise, if errors occurred, roll back our state so that things\n      are just as they were before we began the tentative parse.  */\n   else\n-    {\n-      cp_lexer_rollback_tokens (parser->lexer);\n-      return false;\n-    }\n+    cp_lexer_rollback_tokens (parser->lexer);\n+  /* Add the context to the front of the free list.  */\n+  context->next = cp_parser_context_free_list;\n+  cp_parser_context_free_list = context;\n+\n+  return !error_occurred;\n }\n \n /* Returns non-zero if we are parsing tentatively.  */"}]}