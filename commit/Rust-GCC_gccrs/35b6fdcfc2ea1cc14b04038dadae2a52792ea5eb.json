{"sha": "35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzViNmZkY2ZjMmVhMWNjMTRiMDQwMzhkYWRhZTJhNTI3OTJlYTVlYg==", "commit": {"author": {"name": "Frank Ch. Eigler", "email": "fche@redhat.com", "date": "2004-07-15T17:33:01Z"}, "committer": {"name": "Frank Ch. Eigler", "email": "fche@gcc.gnu.org", "date": "2004-07-15T17:33:01Z"}, "message": "* Fix for g++/15861\n\n2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n\n\tg++/15861\n\t* cgraphunit.c (cgraph_build_static_cdtor): Add priority argument.\n\t* cgraph.h: Update declaration.\n\t* c-decl.c (build_cdtor): Update call with default priority.\n\t* coverage.c (create_coverage): Ditto.\n\t* tree-mudflap.c (mf_init_fndecl): New tree.\n\t(mudflap_init): Set it.\n\t(mudflap_register_call): Arrange to call __mf_init before the first\n\t__mf_register call.\n\t(mudflap_finish_file): Mark the mudflap static initializer as extra\n\thigh priority, to beat all C++ static constructors.\n\n2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n\n\tg++/15861\n\t* jcf-parse.c (java_emit_static_constructor): Specify default\n\tpriority.\n\nFrom-SVN: r84760", "tree": {"sha": "678afa505aa61ebca61ca94c5b86847a30a9aae6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/678afa505aa61ebca61ca94c5b86847a30a9aae6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/comments", "author": {"login": "fche", "id": 588885, "node_id": "MDQ6VXNlcjU4ODg4NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/588885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fche", "html_url": "https://github.com/fche", "followers_url": "https://api.github.com/users/fche/followers", "following_url": "https://api.github.com/users/fche/following{/other_user}", "gists_url": "https://api.github.com/users/fche/gists{/gist_id}", "starred_url": "https://api.github.com/users/fche/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fche/subscriptions", "organizations_url": "https://api.github.com/users/fche/orgs", "repos_url": "https://api.github.com/users/fche/repos", "events_url": "https://api.github.com/users/fche/events{/privacy}", "received_events_url": "https://api.github.com/users/fche/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e4035f83334aa30c12825dc3c3a1fa1b5b2f9f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4035f83334aa30c12825dc3c3a1fa1b5b2f9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4035f83334aa30c12825dc3c3a1fa1b5b2f9f9"}], "stats": {"total": 227, "additions": 133, "deletions": 94}, "files": [{"sha": "8d4a911dcbda4b5130a46805835f391d196a1069", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -1,3 +1,17 @@\n+2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tg++/15861\n+\t* cgraphunit.c (cgraph_build_static_cdtor): Add priority argument.\n+\t* cgraph.h: Update declaration.\n+\t* c-decl.c (build_cdtor): Update call with default priority.\n+\t* coverage.c (create_coverage): Ditto.\n+\t* tree-mudflap.c (mf_init_fndecl): New tree.\n+\t(mudflap_init): Set it.\n+\t(mudflap_register_call): Arrange to call __mf_init before the first\n+\t__mf_register call.\n+\t(mudflap_finish_file): Mark the mudflap static initializer as extra\n+\thigh priority, to beat all C++ static constructors.\n+\n 2004-07-15  Jeff Law  <law@redhat.com>\n \n \t* loop.c (check_insn_for_givs): Restore check for code labels that was"}, {"sha": "6414955a3d2c4c35784c394fbd1fb79ff6e974b6", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -6616,7 +6616,7 @@ build_cdtor (int method_type, tree cdtors)\n     append_to_statement_list (build_function_call (TREE_VALUE (cdtors), 0),\n \t\t\t      &body);\n \n-  cgraph_build_static_cdtor (method_type, body);\n+  cgraph_build_static_cdtor (method_type, body, DEFAULT_INIT_PRIORITY);\n }\n \n /* Perform final processing on one file scope's declarations (or the"}, {"sha": "0c86b76962f68a6d8324d357dd9e151b83e1d6d5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -192,6 +192,6 @@ void verify_cgraph (void);\n void verify_cgraph_node (struct cgraph_node *);\n void cgraph_mark_inline_edge (struct cgraph_edge *e);\n void cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate);\n-void cgraph_build_static_cdtor (char which, tree body);\n+void cgraph_build_static_cdtor (char which, tree body, int priority);\n \n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "79d5553aa9c1978ad11467eb2e289d78c03a3b21", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -1792,7 +1792,7 @@ cgraph_optimize (void)\n    GENERIC statements.  */\n \n void\n-cgraph_build_static_cdtor (char which, tree body)\n+cgraph_build_static_cdtor (char which, tree body, int priority)\n {\n   static int counter = 0;\n   char which_buf[16];\n@@ -1846,6 +1846,6 @@ cgraph_build_static_cdtor (char which, tree body)\n \tfn = targetm.asm_out.constructor;\n       else\n \tfn = targetm.asm_out.destructor;\n-      fn (XEXP (DECL_RTL (decl), 0), DEFAULT_INIT_PRIORITY);\n+      fn (XEXP (DECL_RTL (decl), 0), priority);\n     }\n }"}, {"sha": "888d5cde2c3bd388106de847f8fe468624125e63", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -939,7 +939,7 @@ create_coverage (void)\n   append_to_statement_list (t, &body);\n \n   /* Generate a constructor to run it.  */\n-  cgraph_build_static_cdtor ('I', body);\n+  cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n }\n \f\n /* Perform file-level initialization. Read in data file, generate name"}, {"sha": "76bef669f0805e047af20346de27d57bde21437e", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -1,3 +1,9 @@\n+2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tg++/15861\n+\t* jcf-parse.c (java_emit_static_constructor): Specify default\n+\tpriority.\n+\n 2004-07-13  Per Bothner  <per@bothner.com>\n \n \t* java-tree.h (all_class_filename):  Remove useless macro."}, {"sha": "5a0a87f9b1900c48d89c5939e8429daba3e0476d", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -887,7 +887,7 @@ java_emit_static_constructor (void)\n   write_resource_constructor (&body);\n \n   if (body)\n-    cgraph_build_static_cdtor ('I', body);\n+    cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n }\n \n void"}, {"sha": "adfb3c7b771f1d5491f8483154675a15e50274ab", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 107, "deletions": 88, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=35b6fdcfc2ea1cc14b04038dadae2a52792ea5eb", "patch": "@@ -268,6 +268,9 @@ static GTY (()) tree mf_register_fndecl;\n /* extern void __mf_unregister (void *ptr, size_t sz, int type); */\n static GTY (()) tree mf_unregister_fndecl;\n \n+/* extern void __mf_init (); */\n+static GTY (()) tree mf_init_fndecl;\n+\n /* Helper for mudflap_init: construct a decl with the given category,\n    name, and type, mark it an external reference, and pushdecl it.  */\n static inline tree\n@@ -303,13 +306,15 @@ mf_make_mf_cache_struct_type (tree field_type)\n   return struct_type;\n }\n \n-#define build_function_type_3(rtype, arg1, arg2, arg3) \\\n- build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2, \\\n-                             tree_cons (0, arg3, void_list_node))))\n-#define build_function_type_4(rtype, arg1, arg2, arg3, arg4) \\\n- build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2, \\\n-                             tree_cons (0, arg3, tree_cons (0, arg4, \\\n-                             void_list_node)))))\n+#define build_function_type_0(rtype)            \\\n+  build_function_type (rtype, void_list_node)\n+#define build_function_type_3(rtype, arg1, arg2, arg3)                  \\\n+  build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \\\n+                                                             tree_cons (0, arg3, void_list_node))))\n+#define build_function_type_4(rtype, arg1, arg2, arg3, arg4)            \\\n+  build_function_type (rtype, tree_cons (0, arg1, tree_cons (0, arg2,   \\\n+                                                             tree_cons (0, arg3, tree_cons (0, arg4, \\\n+                                                                                            void_list_node)))))\n \n /* Initialize the global tree nodes that correspond to mf-runtime.h\n    declarations.  */\n@@ -321,42 +326,48 @@ mudflap_init (void)\n   tree mf_cache_array_type;\n   tree mf_check_register_fntype;\n   tree mf_unregister_fntype;\n+  tree mf_init_fntype;\n \n   if (done)\n     return;\n   done = true;\n \n   mf_uintptr_type = lang_hooks.types.type_for_mode (ptr_mode,\n-\t\t\t\t\t\t    /*unsignedp=*/true);\n+                                                    /*unsignedp=*/true);\n   mf_const_string_type\n     = build_pointer_type (build_qualified_type\n-\t\t\t  (char_type_node, TYPE_QUAL_CONST));\n+                          (char_type_node, TYPE_QUAL_CONST));\n \n   mf_cache_struct_type = mf_make_mf_cache_struct_type (mf_uintptr_type);\n   mf_cache_structptr_type = build_pointer_type (mf_cache_struct_type);\n   mf_cache_array_type = build_array_type (mf_cache_struct_type, 0);\n   mf_check_register_fntype =\n     build_function_type_4 (void_type_node, ptr_type_node, size_type_node,\n-\t\t\t   integer_type_node, mf_const_string_type);\n+                           integer_type_node, mf_const_string_type);\n   mf_unregister_fntype =\n     build_function_type_3 (void_type_node, ptr_type_node, size_type_node,\n-\t\t\t   integer_type_node);\n+                           integer_type_node);\n+  mf_init_fntype =\n+    build_function_type_0 (void_type_node);\n \n   mf_cache_array_decl = mf_make_builtin (VAR_DECL, \"__mf_lookup_cache\",\n-\t\t\t\t\t mf_cache_array_type);\n+                                         mf_cache_array_type);\n   mf_cache_shift_decl = mf_make_builtin (VAR_DECL, \"__mf_lc_shift\",\n-\t\t\t\t\t unsigned_char_type_node);\n+                                         unsigned_char_type_node);\n   mf_cache_mask_decl = mf_make_builtin (VAR_DECL, \"__mf_lc_mask\",\n-\t\t\t\t\tmf_uintptr_type);\n+                                        mf_uintptr_type);\n   mf_check_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_check\",\n-\t\t\t\t     mf_check_register_fntype);\n+                                     mf_check_register_fntype);\n   mf_register_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_register\",\n-\t\t\t\t\tmf_check_register_fntype);\n+                                        mf_check_register_fntype);\n   mf_unregister_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_unregister\",\n-\t\t\t\t\t  mf_unregister_fntype);\n+                                          mf_unregister_fntype);\n+  mf_init_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_init\",\n+                                    mf_init_fntype);\n }\n #undef build_function_type_4\n #undef build_function_type_3\n+#undef build_function_type_0\n \n \n /* ------------------------------------------------------------------------ */\n@@ -446,7 +457,7 @@ mf_decl_clear_locals (void)\n \n static void\n mf_build_check_statement_for (tree addr, tree size,\n-\t\t\t      block_stmt_iterator *instr_bsi,\n+                              block_stmt_iterator *instr_bsi,\n                               location_t *locus, tree dirflag)\n {\n   tree_stmt_iterator head, tsi;\n@@ -536,13 +547,13 @@ mf_build_check_statement_for (tree addr, tree size,\n   /* Quick validity check.\n \n      if (__mf_elem->low > __mf_base\n-\t || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n-\t{\n-\t  __mf_check ();\n-\t  ... and only if single-threaded:\n-\t  __mf_lookup_shift_1 = f...;\n-\t  __mf_lookup_mask_l = ...;\n-\t}\n+         || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n+        {\n+          __mf_check ();\n+          ... and only if single-threaded:\n+          __mf_lookup_shift_1 = f...;\n+          __mf_lookup_mask_l = ...;\n+        }\n \n      It is expected that this body of code is rarely executed so we mark\n      the edge to the THEN clause of the conditional jump as unlikely.  */\n@@ -556,8 +567,8 @@ mf_build_check_statement_for (tree addr, tree size,\n   /* Construct '__mf_elem->high < __mf_base + sizeof(T) - 1'.\n \n      First build:\n-\t1) u <--  '__mf_elem->high'\n-\t2) v <--  '__mf_base + sizeof (T) - 1'.\n+        1) u <--  '__mf_elem->high'\n+        2) v <--  '__mf_base + sizeof (T) - 1'.\n \n      Then build 'u <-- (u < v).  */\n \n@@ -567,7 +578,7 @@ mf_build_check_statement_for (tree addr, tree size,\n              TREE_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n \n   v = convert (mf_uintptr_type,\n-\t       size_binop (MINUS_EXPR, size, size_one_node));\n+               size_binop (MINUS_EXPR, size, size_one_node));\n   v = fold (build (PLUS_EXPR, mf_uintptr_type, mf_base, v));\n \n   u = build (LT_EXPR, boolean_type_node, u, v);\n@@ -584,16 +595,16 @@ mf_build_check_statement_for (tree addr, tree size,\n   /* Build the conditional jump.  'cond' is just a temporary so we can\n      simply build a void COND_EXPR.  We do need labels in both arms though.  */\n   t = build (COND_EXPR, void_type_node, cond,\n-\t     build (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n-\t     build (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n+             build (GOTO_EXPR, void_type_node, tree_block_label (then_bb)),\n+             build (GOTO_EXPR, void_type_node, tree_block_label (join_bb)));\n   SET_EXPR_LOCUS (t, locus);\n   tsi_link_after (&tsi, t, TSI_CONTINUE_LINKING);\n \n   /* At this point, after so much hard work, we have only constructed\n      the conditional jump,\n \n      if (__mf_elem->low > __mf_base\n-\t || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n+         || (__mf_elem_high < __mf_base + sizeof(T) - 1))\n \n      The lowered GIMPLE tree representing this code is in the statement\n      list starting at 'head'.\n@@ -612,9 +623,9 @@ mf_build_check_statement_for (tree addr, tree size,\n      This is the body of the conditional.  */\n   \n   u = tree_cons (NULL_TREE,\n-\t\t mf_file_function_line_tree (locus == NULL ? UNKNOWN_LOCATION\n-\t\t\t\t\t     : *locus),\n-\t\t NULL_TREE);\n+                 mf_file_function_line_tree (locus == NULL ? UNKNOWN_LOCATION\n+                                             : *locus),\n+                 NULL_TREE);\n   u = tree_cons (NULL_TREE, dirflag, u);\n   u = tree_cons (NULL_TREE, size, u);\n   u = tree_cons (NULL_TREE, mf_value, u);\n@@ -672,14 +683,14 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n           {\n             tree dom = TYPE_DOMAIN (TREE_TYPE (op0));\n \n-\t    /* Test for index in range.  Break if not.  */\n-\t    if (!dom\n-\t\t|| (! TYPE_MIN_VALUE (dom)\n-\t\t    || ! really_constant_p (TYPE_MIN_VALUE (dom)))\n-\t\t|| (! TYPE_MAX_VALUE (dom)\n-\t\t    || ! really_constant_p (TYPE_MAX_VALUE (dom)))\n-\t\t|| (tree_int_cst_lt (op1, TYPE_MIN_VALUE (dom))\n-\t\t    || tree_int_cst_lt (TYPE_MAX_VALUE (dom), op1)))\n+            /* Test for index in range.  Break if not.  */\n+            if (!dom\n+                || (! TYPE_MIN_VALUE (dom)\n+                    || ! really_constant_p (TYPE_MIN_VALUE (dom)))\n+                || (! TYPE_MAX_VALUE (dom)\n+                    || ! really_constant_p (TYPE_MAX_VALUE (dom)))\n+                || (tree_int_cst_lt (op1, TYPE_MIN_VALUE (dom))\n+                    || tree_int_cst_lt (TYPE_MAX_VALUE (dom), op1)))\n               break;\n \n             /* If we're looking at a non-external VAR_DECL, then the \n@@ -726,14 +737,14 @@ mf_xform_derefs_1 (block_stmt_iterator *iter, tree *tp,\n            things the hard way with PLUS.  */\n         if (DECL_BIT_FIELD_TYPE (field))\n           {\n-\t    if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n-\t      size = DECL_SIZE_UNIT (field);\n+            if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n+              size = DECL_SIZE_UNIT (field);\n \n             addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n             addr = fold_convert (ptr_type_node, addr);\n             addr = fold (build (PLUS_EXPR, ptr_type_node,\n                                 addr, fold_convert (ptr_type_node,\n-\t\t\t\t\t\t    byte_position (field))));\n+                                                    byte_position (field))));\n           }\n         else\n           {\n@@ -787,35 +798,35 @@ mf_xform_derefs (void)\n     {\n       next = bb->next_bb;\n       for (i = bsi_start (bb); !bsi_end_p (i); bsi_next (&i))\n-\t{\n-\t  tree s = bsi_stmt (i);\n-\n-\t  /* Only a few GIMPLE statements can reference memory.  */\n-\t  switch (TREE_CODE (s))\n-\t    {\n-\t    case MODIFY_EXPR:\n-\t      mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n-\t\t\t\t integer_one_node);\n-\t      mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 1), EXPR_LOCUS (s),\n-\t\t\t\t integer_zero_node);\n-\t      break;\n-\n-\t    case RETURN_EXPR:\n-\t      if (TREE_OPERAND (s, 0) != NULL_TREE)\n-\t\t{\n-\t\t  if (TREE_CODE (TREE_OPERAND (s, 0)) == MODIFY_EXPR)\n-\t\t    mf_xform_derefs_1 (&i, &TREE_OPERAND (TREE_OPERAND (s, 0), 1),\n-\t\t\t\t       EXPR_LOCUS (s), integer_zero_node);\n-\t\t  else\n-\t\t    mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n-\t\t\t\t       integer_zero_node);\n-\t\t}\n-\t      break;\n-\n-\t    default:\n-\t      ;\n-\t    }\n-\t}\n+        {\n+          tree s = bsi_stmt (i);\n+\n+          /* Only a few GIMPLE statements can reference memory.  */\n+          switch (TREE_CODE (s))\n+            {\n+            case MODIFY_EXPR:\n+              mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n+                                 integer_one_node);\n+              mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 1), EXPR_LOCUS (s),\n+                                 integer_zero_node);\n+              break;\n+\n+            case RETURN_EXPR:\n+              if (TREE_OPERAND (s, 0) != NULL_TREE)\n+                {\n+                  if (TREE_CODE (TREE_OPERAND (s, 0)) == MODIFY_EXPR)\n+                    mf_xform_derefs_1 (&i, &TREE_OPERAND (TREE_OPERAND (s, 0), 1),\n+                                       EXPR_LOCUS (s), integer_zero_node);\n+                  else\n+                    mf_xform_derefs_1 (&i, &TREE_OPERAND (s, 0), EXPR_LOCUS (s),\n+                                       integer_zero_node);\n+                }\n+              break;\n+\n+            default:\n+              ;\n+            }\n+        }\n       bb = next;\n     }\n   while (bb && bb->index <= saved_last_basic_block);\n@@ -866,15 +877,15 @@ mx_register_decls (tree decl, tree *stmt_list)\n     {\n       /* Eligible decl?  */\n       if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-\t  /* It must be a non-external, automatic variable.  */\n-\t  && ! DECL_EXTERNAL (decl)\n-\t  && ! TREE_STATIC (decl)\n-\t  /* The decl must have its address taken.  */\n-\t  && TREE_ADDRESSABLE (decl)\n-\t  /* The type of the variable must be complete.  */\n-\t  && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n-\t  /* Don't process the same decl twice.  */\n-\t  && ! mf_marked_p (decl))\n+          /* It must be a non-external, automatic variable.  */\n+          && ! DECL_EXTERNAL (decl)\n+          && ! TREE_STATIC (decl)\n+          /* The decl must have its address taken.  */\n+          && TREE_ADDRESSABLE (decl)\n+          /* The type of the variable must be complete.  */\n+          && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n+          /* Don't process the same decl twice.  */\n+          && ! mf_marked_p (decl))\n         {\n           tree size = NULL_TREE, variable_name;\n           tree unregister_fncall, unregister_fncall_params;\n@@ -904,17 +915,17 @@ mx_register_decls (tree decl, tree *stmt_list)\n                   else if (TREE_CODE (t) == TRY_FINALLY_EXPR)\n                     {\n                       /* We hope that this is the try/finally block sometimes\n-\t\t         constructed by gimplify_bind_expr() for a BIND_EXPR\n-\t\t\t that contains VLAs.  This very naive recursion\n-\t\t\t appears to be sufficient.  */\n+                         constructed by gimplify_bind_expr() for a BIND_EXPR\n+                         that contains VLAs.  This very naive recursion\n+                         appears to be sufficient.  */\n                       initially_stmts = tsi_start (TREE_OPERAND (t, 0));\n                     }\n \n                   if (call != NULL_TREE)\n                     {\n                       if (TREE_CODE (TREE_OPERAND(call, 0)) == ADDR_EXPR &&\n                           TREE_OPERAND (TREE_OPERAND (call, 0), 0) ==\n-\t\t\t  \timplicit_built_in_decls [BUILT_IN_STACK_ALLOC])\n+                                implicit_built_in_decls [BUILT_IN_STACK_ALLOC])\n                         {\n                           tree stack_alloc_args = TREE_OPERAND (call, 1);\n                           tree stack_alloc_op1 = TREE_VALUE (stack_alloc_args);\n@@ -1130,6 +1141,13 @@ mudflap_register_call (tree obj, tree object_size, tree varname)\n \n   call_stmt = build_function_call_expr (mf_register_fndecl, args);\n \n+  /* Add an initial __mf_init() call to the list of registration calls.  */ \n+  if (enqueued_call_stmt_chain == NULL_TREE)\n+    {\n+      tree call2_stmt = build_function_call_expr (mf_init_fndecl, NULL_TREE);\n+      append_to_statement_list (call2_stmt, &enqueued_call_stmt_chain);      \n+    }\n+\n   append_to_statement_list (call_stmt, &enqueued_call_stmt_chain);\n }\n \n@@ -1246,7 +1264,8 @@ mudflap_finish_file (void)\n \n   if (enqueued_call_stmt_chain)\n     {\n-      cgraph_build_static_cdtor ('I', enqueued_call_stmt_chain);\n+      cgraph_build_static_cdtor ('I', enqueued_call_stmt_chain, \n+                                 MAX_RESERVED_INIT_PRIORITY-1);\n       enqueued_call_stmt_chain = 0;\n     }\n }"}]}