{"sha": "e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkwMjEzNmIzMTBlZTE3ZDRiNDllYjQyZDlkNWU0ODdkNWRjZjRhMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-03T07:46:32Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-03T07:46:32Z"}, "message": "c++, abi: Set DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD on C++ zero width bitfields [PR102024]\n\nThe removal of remove_zero_width_bitfields function and its call from\nC++ FE layout_class_type (which I've done in the P0466R5\nlayout-compatible helper intrinsics patch, so that the FE can actually\ndetermine what is and isn't layout-compatible according to the spec)\nunfortunately changed the ABI on various platforms.\nThe C FE has been keeping zero-width bitfields in the types, while\nthe C++ FE has been removing them after structure layout, so in various\ncases when passing such structures in registers we had different ABI\nbetween C and C++.\n\nWhile both the C and C++ FE had some code to remove zero width bitfields\nafter structure layout, in both FEs it was buggy and didn't really remove\nany.  In the C FE that code has been removed later on, while in the C++ FE\nfor GCC 4.5 in PR42217 it has been actually fixed, so the C++ FE started\nto remove those bitfields.\n\nThe following patch doesn't change anything ABI-wise, but allows the\ntargets to decide what to do, emit -Wpsabi warnings etc.\nNon-C zero width bitfields will be seen by the backends as normal\nzero width bitfields, C++ zero width bitfields that used to be previously\nremoved will have DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD flag set.\nI've reused the DECL_FIELD_ABI_IGNORED flag which is only used on non-bitfield\nFIELD_DECLs right now, but the macros now check DECL_BIT_FIELD flag.\n\nEach backend can then decide what it wants, whether it wants to keep\ndifferent ABI between C and C++ as in GCC 11 and older (i.e. incompatible\nwith G++ <= 4.4, compatible with G++ 4.5 .. 11), for that it would\nignore for the aggregate passing/returning decisions all\nDECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD FIELD_DECLs), whether it wants to never\nignore zero width bitfields (no changes needed for that case, except perhaps\n-Wpsabi warning should be added and for that DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD\ncan be tested), or whether it wants to always ignore zero width bitfields\n(I think e.g. riscv in GCC 10+ does that).\n\nAll this patch does is set the flag which the backends can then use.\n\n2021-09-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/102024\ngcc/\n\t* tree.h (DECL_FIELD_ABI_IGNORED): Changed into rvalue only macro\n\tthat is false if DECL_BIT_FIELD.\n\t(SET_DECL_FIELD_ABI_IGNORED, DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD,\n\tSET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD): Define.\n\t* tree-streamer-out.c (pack_ts_decl_common_value_fields): For\n\tDECL_BIT_FIELD stream DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD instead\n\tof DECL_FIELD_ABI_IGNORED.\n\t* tree-streamer-in.c (unpack_ts_decl_common_value_fields): Use\n\tSET_DECL_FIELD_ABI_IGNORED instead of writing to\n\tDECL_FIELD_ABI_IGNORED and for DECL_BIT_FIELD use\n\tSET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD instead.\n\t* lto-streamer-out.c (hash_tree): For DECL_BIT_FIELD hash\n\tDECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD instead of DECL_FIELD_ABI_IGNORED.\ngcc/cp/\n\t* class.c (build_base_field): Use SET_DECL_FIELD_ABI_IGNORED\n\tinstead of writing to DECL_FIELD_ABI_IGNORED.\n\t(layout_class_type): Likewise.  In the place where zero-width\n\tbitfields used to be removed, use\n\tSET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD on those fields instead.\ngcc/lto/\n\t* lto-common.c (compare_tree_sccs_1): Also compare\n\tDECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD values.", "tree": {"sha": "65ed287d91cb135d037fcf227a333d099a589bce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65ed287d91cb135d037fcf227a333d099a589bce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de6795bbf58c7085933a1f86a88d8193ea72e26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6795bbf58c7085933a1f86a88d8193ea72e26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6795bbf58c7085933a1f86a88d8193ea72e26b"}], "stats": {"total": 64, "additions": 55, "deletions": 9}, "files": [{"sha": "fe225c61a6290c400e15700767934a68402cc80f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -4634,7 +4634,7 @@ build_base_field (record_layout_info rli, tree binfo, tree access,\n \t  DECL_FIELD_OFFSET (decl) = BINFO_OFFSET (binfo);\n \t  DECL_FIELD_BIT_OFFSET (decl) = bitsize_zero_node;\n \t  SET_DECL_OFFSET_ALIGN (decl, BITS_PER_UNIT);\n-\t  DECL_FIELD_ABI_IGNORED (decl) = 1;\n+\t  SET_DECL_FIELD_ABI_IGNORED (decl, 1);\n \t}\n \n       /* An empty virtual base causes a class to be non-empty\n@@ -6658,7 +6658,7 @@ layout_class_type (tree t, tree *virtuals_p)\n \t}\n       else if (might_overlap && is_empty_class (type))\n \t{\n-\t  DECL_FIELD_ABI_IGNORED (field) = 1;\n+\t  SET_DECL_FIELD_ABI_IGNORED (field, 1);\n \t  layout_empty_base_or_field (rli, field, empty_base_offsets);\n \t}\n       else\n@@ -6746,6 +6746,23 @@ layout_class_type (tree t, tree *virtuals_p)\n       normalize_rli (rli);\n     }\n \n+  /* We used to remove zero width bitfields at this point since PR42217,\n+     while the C FE never did that.  That caused ABI differences on various\n+     targets.  Set the DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD flag on them\n+     instead, so that the backends can emit -Wpsabi warnings in the cases\n+     where the ABI changed.  */\n+  for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL\n+\t&& DECL_C_BIT_FIELD (field)\n+\t/* We should not be confused by the fact that grokbitfield\n+\t   temporarily sets the width of the bit field into\n+\t   DECL_BIT_FIELD_REPRESENTATIVE (field).\n+\t   check_bitfield_decl eventually sets DECL_SIZE (field)\n+\t   to that width.  */\n+\t&& (DECL_SIZE (field) == NULL_TREE\n+\t    || integer_zerop (DECL_SIZE (field))))\n+      SET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (field, 1);\n+\n   if (CLASSTYPE_NON_LAYOUT_POD_P (t) || CLASSTYPE_EMPTY_P (t))\n     {\n       /* T needs a different layout as a base (eliding virtual bases"}, {"sha": "643d9275a95ca9e93ce1a33486f183e3eebbe866", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -1271,7 +1271,10 @@ hash_tree (struct streamer_tree_cache_d *cache, hash_map<tree, hashval_t> *map,\n \t  hstate.add_flag (DECL_PACKED (t));\n \t  hstate.add_flag (DECL_NONADDRESSABLE_P (t));\n \t  hstate.add_flag (DECL_PADDING_P (t));\n-\t  hstate.add_flag (DECL_FIELD_ABI_IGNORED (t));\n+\t  if (DECL_BIT_FIELD (t))\n+\t    hstate.add_flag (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (t));\n+\t  else\n+\t    hstate.add_flag (DECL_FIELD_ABI_IGNORED (t));\n \t  hstate.add_int (DECL_OFFSET_ALIGN (t));\n \t}\n       else if (code == VAR_DECL)"}, {"sha": "3eba431e5af343937c9763ce24f9c509f4780be5", "filename": "gcc/lto/lto-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Flto%2Flto-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Flto%2Flto-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-common.c?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -1187,6 +1187,7 @@ compare_tree_sccs_1 (tree t1, tree t2, tree **map)\n \t  compare_values (DECL_NONADDRESSABLE_P);\n \t  compare_values (DECL_PADDING_P);\n \t  compare_values (DECL_FIELD_ABI_IGNORED);\n+\t  compare_values (DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD);\n \t  compare_values (DECL_OFFSET_ALIGN);\n \t}\n       else if (code == VAR_DECL)"}, {"sha": "848981aa20ba7969e9c75f50aab73111f0d4b20d", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -256,7 +256,11 @@ unpack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n       DECL_PADDING_P (expr) = (unsigned) bp_unpack_value (bp, 1);\n-      DECL_FIELD_ABI_IGNORED (expr) = (unsigned) bp_unpack_value (bp, 1);\n+      unsigned val = (unsigned) bp_unpack_value (bp, 1);\n+      if (DECL_BIT_FIELD (expr))\n+\tSET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (expr, val);\n+      else\n+\tSET_DECL_FIELD_ABI_IGNORED (expr, val);\n       expr->decl_common.off_align = bp_unpack_value (bp, 8);\n     }\n "}, {"sha": "1f9ce52d54148346fd3b91a9c7bdc3a2e5eb8a03", "filename": "gcc/tree-streamer-out.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-out.c?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -219,7 +219,10 @@ pack_ts_decl_common_value_fields (struct bitpack_d *bp, tree expr)\n       bp_pack_value (bp, DECL_PACKED (expr), 1);\n       bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);\n       bp_pack_value (bp, DECL_PADDING_P (expr), 1);\n-      bp_pack_value (bp, DECL_FIELD_ABI_IGNORED (expr), 1);\n+      if (DECL_BIT_FIELD (expr))\n+\tbp_pack_value (bp, DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD (expr), 1);\n+      else\n+\tbp_pack_value (bp, DECL_FIELD_ABI_IGNORED (expr), 1);\n       bp_pack_value (bp, expr->decl_common.off_align, 8);\n     }\n "}, {"sha": "1559fe060a0cd6f9e509c40a2a45cd91e4196d69", "filename": "gcc/tree.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e902136b310ee17d4b49eb42d9d5e487d5dcf4a1/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e902136b310ee17d4b49eb42d9d5e487d5dcf4a1", "patch": "@@ -2852,16 +2852,34 @@ extern void decl_value_expr_insert (tree, tree);\n /* In a FIELD_DECL, indicates this field should be bit-packed.  */\n #define DECL_PACKED(NODE) (FIELD_DECL_CHECK (NODE)->base.u.bits.packed_flag)\n \n+/* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n+   specially.  */\n+#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)\n+\n /* In a FIELD_DECL, indicates this field should be ignored for ABI decisions\n    like passing/returning containing struct by value.\n    Set for C++17 empty base artificial FIELD_DECLs as well as\n    empty [[no_unique_address]] non-static data members.  */\n #define DECL_FIELD_ABI_IGNORED(NODE) \\\n-  (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_0)\n+  (!DECL_BIT_FIELD (NODE) && (NODE)->decl_common.decl_flag_0)\n+#define SET_DECL_FIELD_ABI_IGNORED(NODE, VAL) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    gcc_checking_assert (!DECL_BIT_FIELD (NODE));\t\t\t\\\n+    FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_0 = (VAL);\t\t\\\n+  } while (0)\n \n-/* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n-   specially.  */\n-#define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_1)\n+/* In a FIELD_DECL, indicates C++ zero-width bitfield that used to be\n+   removed from the IL since PR42217 until PR101539 and by that changed\n+   the ABI on several targets.  This flag is provided so that the backends\n+   can decide on the ABI with zero-width bitfields and emit -Wpsabi\n+   warnings.  */\n+#define DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD(NODE) \\\n+  (DECL_BIT_FIELD (NODE) && (NODE)->decl_common.decl_flag_0)\n+#define SET_DECL_FIELD_CXX_ZERO_WIDTH_BIT_FIELD(NODE, VAL) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    gcc_checking_assert (DECL_BIT_FIELD (NODE));\t\t\t\\\n+    FIELD_DECL_CHECK (NODE)->decl_common.decl_flag_0 = (VAL);\t\t\\\n+  } while (0)\n \n /* Used in a FIELD_DECL to indicate that we cannot form the address of\n    this component.  This makes it possible for Type-Based Alias Analysis"}]}