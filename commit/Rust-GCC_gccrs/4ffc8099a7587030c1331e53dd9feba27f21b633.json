{"sha": "4ffc8099a7587030c1331e53dd9feba27f21b633", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZmYzgwOTlhNzU4NzAzMGMxMzMxZTUzZGQ5ZmViYTI3ZjIxYjYzMw==", "commit": {"author": {"name": "Matthew Wahab", "email": "matthew.wahab@arm.com", "date": "2016-09-23T09:35:22Z"}, "committer": {"name": "Matthew Wahab", "email": "mwahab@gcc.gnu.org", "date": "2016-09-23T09:35:22Z"}, "message": "[PATCH 7/17][ARM] Add FP16 data movement instructions.\n\ngcc/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\t    Jiong Wang <jiong.wang@arm.com>\n\n\t* config/arm/arm.c (coproc_secondary_reload_class): Make HFmode\n\tavailable when FP16 instructions are available.\n\t(output_move_vfp): Add support for 16-bit data moves.\n\t(arm_validize_comparison): Fix some white-space.  Support HFmode\n\tby conversion to SFmode.\n\t* config/arm/arm.md (truncdfhf2): Fix a comment.\n\t(extendhfdf2): Likewise.\n\t(cstorehf4): New.\n\t(movsicc): Fix some white-space.\n\t(movhfcc): New.\n\t(movsfcc): Fix some white-space.\n\t(*cmovhf): New.\n\t* config/arm/vfp.md (*arm_movhi_vfp): Disable when VFP FP16\n\tinstructions are available.\n\t(*thumb2_movhi_vfp): Likewise.\n\t(*arm_movhi_fp16): New.\n\t(*thumb2_movhi_fp16): New.\n\t(*movhf_vfp_fp16): New.\n\t(*movhf_vfp_neon): Disable when VFP FP16 instructions are\n\tavailable.\n\t(*movhf_vfp): Likewise.\n\t(extendhfsf2): Enable when VFP FP16 instructions are available.\n\t(truncsfhf2):  Enable when VFP FP16 instructions are available.\n\ntestsuite/\n2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n\n\t* gcc.target/arm/armv8_2_fp16-move-1.c: New.\n\t* gcc.target/arm/fp16-aapcs-1.c: Update expected output.\n\n\nCo-Authored-By: Jiong Wang <jiong.wang@arm.com>\n\nFrom-SVN: r240407", "tree": {"sha": "af2a7a70dfcdf634b7e24af60ce19a628e2b15db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af2a7a70dfcdf634b7e24af60ce19a628e2b15db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ffc8099a7587030c1331e53dd9feba27f21b633", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ffc8099a7587030c1331e53dd9feba27f21b633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ffc8099a7587030c1331e53dd9feba27f21b633", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ffc8099a7587030c1331e53dd9feba27f21b633/comments", "author": null, "committer": null, "parents": [{"sha": "99924e7a7b1be1c07dd2760485a07069a52a4023", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99924e7a7b1be1c07dd2760485a07069a52a4023", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99924e7a7b1be1c07dd2760485a07069a52a4023"}], "stats": {"total": 482, "additions": 467, "deletions": 15}, "files": [{"sha": "561f612fba8e53d7b412148ad1dc936ba2f7376d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -1,3 +1,30 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\t    Jiong Wang <jiong.wang@arm.com>\n+\n+\t* config/arm/arm.c (coproc_secondary_reload_class): Make HFmode\n+\tavailable when FP16 instructions are available.\n+\t(output_move_vfp): Add support for 16-bit data moves.\n+\t(arm_validize_comparison): Fix some white-space.  Support HFmode\n+\tby conversion to SFmode.\n+\t* config/arm/arm.md (truncdfhf2): Fix a comment.\n+\t(extendhfdf2): Likewise.\n+\t(cstorehf4): New.\n+\t(movsicc): Fix some white-space.\n+\t(movhfcc): New.\n+\t(movsfcc): Fix some white-space.\n+\t(*cmovhf): New.\n+\t* config/arm/vfp.md (*arm_movhi_vfp): Disable when VFP FP16\n+\tinstructions are available.\n+\t(*thumb2_movhi_vfp): Likewise.\n+\t(*arm_movhi_fp16): New.\n+\t(*thumb2_movhi_fp16): New.\n+\t(*movhf_vfp_fp16): New.\n+\t(*movhf_vfp_neon): Disable when VFP FP16 instructions are\n+\tavailable.\n+\t(*movhf_vfp): Likewise.\n+\t(extendhfsf2): Enable when VFP FP16 instructions are available.\n+\t(truncsfhf2):  Enable when VFP FP16 instructions are available.\n+\n 2016-09-23  Martin Liska  <mliska@suse.cz>\n \n \t* config/s390/vx-builtins.md: Replace 'adress' with 'address'."}, {"sha": "619c3291c877ba966569d4649789d579f18e4b31", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -13256,7 +13256,7 @@ coproc_secondary_reload_class (machine_mode mode, rtx x, bool wb)\n {\n   if (mode == HFmode)\n     {\n-      if (!TARGET_NEON_FP16)\n+      if (!TARGET_NEON_FP16 && !TARGET_VFP_FP16INST)\n \treturn GENERAL_REGS;\n       if (s_register_operand (x, mode) || neon_vector_mem_operand (x, 2, true))\n \treturn NO_REGS;\n@@ -18707,6 +18707,8 @@ output_move_vfp (rtx *operands)\n   rtx reg, mem, addr, ops[2];\n   int load = REG_P (operands[0]);\n   int dp = GET_MODE_SIZE (GET_MODE (operands[0])) == 8;\n+  int sp = (!TARGET_VFP_FP16INST\n+\t    || GET_MODE_SIZE (GET_MODE (operands[0])) == 4);\n   int integer_p = GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_INT;\n   const char *templ;\n   char buff[50];\n@@ -18753,7 +18755,7 @@ output_move_vfp (rtx *operands)\n \n   sprintf (buff, templ,\n \t   load ? \"ld\" : \"st\",\n-\t   dp ? \"64\" : \"32\",\n+\t   dp ? \"64\" : sp ? \"32\" : \"16\",\n \t   dp ? \"P\" : \"\",\n \t   integer_p ? \"\\t%@ int\" : \"\");\n   output_asm_insn (buff, ops);\n@@ -29394,7 +29396,7 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n {\n   enum rtx_code code = GET_CODE (*comparison);\n   int code_int;\n-  machine_mode mode = (GET_MODE (*op1) == VOIDmode) \n+  machine_mode mode = (GET_MODE (*op1) == VOIDmode)\n     ? GET_MODE (*op2) : GET_MODE (*op1);\n \n   gcc_assert (GET_MODE (*op1) != VOIDmode || GET_MODE (*op2) != VOIDmode);\n@@ -29422,6 +29424,14 @@ arm_validize_comparison (rtx *comparison, rtx * op1, rtx * op2)\n \t*op2 = force_reg (mode, *op2);\n       return true;\n \n+    case HFmode:\n+      if (!TARGET_VFP_FP16INST)\n+\tbreak;\n+      /* FP16 comparisons are done in SF mode.  */\n+      mode = SFmode;\n+      *op1 = convert_to_mode (mode, *op1, 1);\n+      *op2 = convert_to_mode (mode, *op2, 1);\n+      /* Fall through.  */\n     case SFmode:\n     case DFmode:\n       if (!arm_float_compare_operand (*op1, mode))"}, {"sha": "411754f23e9017d1e85fbd27733fa81cb2d0b6f0", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 76, "deletions": 5, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -5189,7 +5189,7 @@\n   \"\"\n )\n \n-/* DFmode -> HFmode conversions have to go through SFmode.  */\n+;; DFmode to HFmode conversions have to go through SFmode.\n (define_expand \"truncdfhf2\"\n   [(set (match_operand:HF  0 \"general_operand\" \"\")\n \t(float_truncate:HF\n@@ -5696,7 +5696,7 @@\n   \"\"\n )\n \n-/* HFmode -> DFmode conversions have to go through SFmode.  */\n+;; HFmode -> DFmode conversions have to go through SFmode.\n (define_expand \"extendhfdf2\"\n   [(set (match_operand:DF                  0 \"general_operand\" \"\")\n \t(float_extend:DF (match_operand:HF 1 \"general_operand\"  \"\")))]\n@@ -7704,6 +7704,24 @@\n   DONE;\n }\")\n \n+(define_expand \"cstorehf4\"\n+  [(set (match_operand:SI 0 \"s_register_operand\")\n+\t(match_operator:SI 1 \"expandable_comparison_operator\"\n+\t [(match_operand:HF 2 \"s_register_operand\")\n+\t  (match_operand:HF 3 \"arm_float_compare_operand\")]))]\n+  \"TARGET_VFP_FP16INST\"\n+  {\n+    if (!arm_validize_comparison (&operands[1],\n+\t\t\t\t  &operands[2],\n+\t\t\t\t  &operands[3]))\n+       FAIL;\n+\n+    emit_insn (gen_cstore_cc (operands[0], operands[1],\n+\t\t\t      operands[2], operands[3]));\n+    DONE;\n+  }\n+)\n+\n (define_expand \"cstoresf4\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(match_operator:SI 1 \"expandable_comparison_operator\"\n@@ -7756,9 +7774,31 @@\n     rtx ccreg;\n \n     if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0), \n-       \t\t\t\t  &XEXP (operands[1], 1)))\n+\t\t\t\t  &XEXP (operands[1], 1)))\n       FAIL;\n-    \n+\n+    code = GET_CODE (operands[1]);\n+    ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n+\t\t\t\t XEXP (operands[1], 1), NULL_RTX);\n+    operands[1] = gen_rtx_fmt_ee (code, VOIDmode, ccreg, const0_rtx);\n+  }\"\n+)\n+\n+(define_expand \"movhfcc\"\n+  [(set (match_operand:HF 0 \"s_register_operand\")\n+\t(if_then_else:HF (match_operand 1 \"arm_cond_move_operator\")\n+\t\t\t (match_operand:HF 2 \"s_register_operand\")\n+\t\t\t (match_operand:HF 3 \"s_register_operand\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"\n+  {\n+    enum rtx_code code = GET_CODE (operands[1]);\n+    rtx ccreg;\n+\n+    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0),\n+\t\t\t\t  &XEXP (operands[1], 1)))\n+      FAIL;\n+\n     code = GET_CODE (operands[1]);\n     ccreg = arm_gen_compare_reg (code, XEXP (operands[1], 0),\n \t\t\t\t XEXP (operands[1], 1), NULL_RTX);\n@@ -7777,7 +7817,7 @@\n     enum rtx_code code = GET_CODE (operands[1]);\n     rtx ccreg;\n \n-    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0), \n+    if (!arm_validize_comparison (&operands[1], &XEXP (operands[1], 0),\n        \t\t\t\t  &XEXP (operands[1], 1)))\n        FAIL;\n \n@@ -7842,6 +7882,37 @@\n    (set_attr \"type\" \"fcsel\")]\n )\n \n+(define_insn \"*cmovhf\"\n+    [(set (match_operand:HF 0 \"s_register_operand\" \"=t\")\n+\t(if_then_else:HF (match_operator 1 \"arm_vsel_comparison_operator\"\n+\t\t\t [(match_operand 2 \"cc_register\" \"\") (const_int 0)])\n+\t\t\t  (match_operand:HF 3 \"s_register_operand\" \"t\")\n+\t\t\t  (match_operand:HF 4 \"s_register_operand\" \"t\")))]\n+  \"TARGET_VFP_FP16INST\"\n+  \"*\n+  {\n+    enum arm_cond_code code = maybe_get_arm_condition_code (operands[1]);\n+    switch (code)\n+      {\n+      case ARM_GE:\n+      case ARM_GT:\n+      case ARM_EQ:\n+      case ARM_VS:\n+\treturn \\\"vsel%d1.f16\\\\t%0, %3, %4\\\";\n+      case ARM_LT:\n+      case ARM_LE:\n+      case ARM_NE:\n+      case ARM_VC:\n+\treturn \\\"vsel%D1.f16\\\\t%0, %4, %3\\\";\n+      default:\n+\tgcc_unreachable ();\n+      }\n+    return \\\"\\\";\n+  }\"\n+  [(set_attr \"conds\" \"use\")\n+   (set_attr \"type\" \"fcsel\")]\n+)\n+\n (define_insn_and_split \"*movsicc_insn\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"=r,r,r,r,r,r,r,r\")\n \t(if_then_else:SI"}, {"sha": "b1c13fa1d9811bc0d69dfdf58a530ecd2f83eef9", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 178, "deletions": 4, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -27,6 +27,7 @@\n    (match_operand:HI 1 \"general_operand\"\n     \"rIk, K, n, r, mi, r, *t, *t\"))]\n  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\n+  && !TARGET_VFP_FP16INST\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n {\n@@ -76,6 +77,7 @@\n    (match_operand:HI 1 \"general_operand\"\n     \"rk, I, Py, n, r, m, r, *t, *t\"))]\n  \"TARGET_THUMB2 && TARGET_HARD_FLOAT && TARGET_VFP\n+  && !TARGET_VFP_FP16INST\n   && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n {\n@@ -111,6 +113,99 @@\n   (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4\")]\n )\n \n+;; Patterns for HI moves which provide more data transfer instructions when FP16\n+;; instructions are available.\n+(define_insn \"*arm_movhi_fp16\"\n+ [(set\n+   (match_operand:HI 0 \"nonimmediate_operand\"\n+    \"=r,  r, r, m, r, *t,  r, *t\")\n+   (match_operand:HI 1 \"general_operand\"\n+    \"rIk, K, n, r, mi, r, *t, *t\"))]\n+ \"TARGET_ARM && TARGET_VFP_FP16INST\n+  && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \"mov%?\\t%0, %1\\t%@ movhi\";\n+    case 1:\n+      return \"mvn%?\\t%0, #%B1\\t%@ movhi\";\n+    case 2:\n+      return \"movw%?\\t%0, %L1\\t%@ movhi\";\n+    case 3:\n+      return \"strh%?\\t%1, %0\\t%@ movhi\";\n+    case 4:\n+      return \"ldrh%?\\t%0, %1\\t%@ movhi\";\n+    case 5:\n+    case 6:\n+      return \"vmov%?.f16\\t%0, %1\\t%@ int\";\n+    case 7:\n+      return \"vmov%?.f32\\t%0, %1\\t%@ int\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+ [(set_attr \"predicable\" \"yes\")\n+  (set_attr_alternative \"type\"\n+   [(if_then_else\n+     (match_operand 1 \"const_int_operand\" \"\")\n+     (const_string \"mov_imm\")\n+     (const_string \"mov_reg\"))\n+    (const_string \"mvn_imm\")\n+    (const_string \"mov_imm\")\n+    (const_string \"store1\")\n+    (const_string \"load1\")\n+    (const_string \"f_mcr\")\n+    (const_string \"f_mrc\")\n+    (const_string \"fmov\")])\n+  (set_attr \"pool_range\" \"*, *, *, *, 256, *, *, *\")\n+  (set_attr \"neg_pool_range\" \"*, *, *, *, 244, *, *, *\")\n+  (set_attr \"length\" \"4\")]\n+)\n+\n+(define_insn \"*thumb2_movhi_fp16\"\n+ [(set\n+   (match_operand:HI 0 \"nonimmediate_operand\"\n+    \"=rk, r, l, r, m, r, *t, r, *t\")\n+   (match_operand:HI 1 \"general_operand\"\n+    \"rk, I, Py, n, r, m, r, *t, *t\"))]\n+ \"TARGET_THUMB2 && TARGET_VFP_FP16INST\n+  && (register_operand (operands[0], HImode)\n+       || register_operand (operands[1], HImode))\"\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+    case 1:\n+    case 2:\n+      return \"mov%?\\t%0, %1\\t%@ movhi\";\n+    case 3:\n+      return \"movw%?\\t%0, %L1\\t%@ movhi\";\n+    case 4:\n+      return \"strh%?\\t%1, %0\\t%@ movhi\";\n+    case 5:\n+      return \"ldrh%?\\t%0, %1\\t%@ movhi\";\n+    case 6:\n+    case 7:\n+      return \"vmov%?.f16\\t%0, %1\\t%@ int\";\n+    case 8:\n+      return \"vmov%?.f32\\t%0, %1\\t%@ int\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+ [(set_attr \"predicable\" \"yes\")\n+  (set_attr \"predicable_short_it\"\n+   \"yes, no, yes, no, no, no, no, no, no\")\n+  (set_attr \"type\"\n+   \"mov_reg, mov_imm, mov_imm, mov_imm, store1, load1,\\\n+    f_mcr, f_mrc, fmov\")\n+  (set_attr \"pool_range\" \"*, *, *, *, *, 4094, *, *, *\")\n+  (set_attr \"neg_pool_range\" \"*, *, *, *, *, 250, *, *, *\")\n+  (set_attr \"length\" \"2, 4, 2, 4, 4, 4, 4, 4, 4\")]\n+)\n+\n ;; SImode moves\n ;; ??? For now do not allow loading constants into vfp regs.  This causes\n ;; problems because small constants get converted into adds.\n@@ -304,10 +399,87 @@\n  )\n \n ;; HFmode moves\n+\n+(define_insn \"*movhf_vfp_fp16\"\n+  [(set (match_operand:HF 0 \"nonimmediate_operand\"\n+\t\t\t  \"= r,m,t,r,t,r,t,t,Um,r\")\n+\t(match_operand:HF 1 \"general_operand\"\n+\t\t\t  \"  m,r,t,r,r,t,Dv,Um,t,F\"))]\n+  \"TARGET_32BIT\n+   && TARGET_VFP_FP16INST\n+   && (s_register_operand (operands[0], HFmode)\n+       || s_register_operand (operands[1], HFmode))\"\n+ {\n+  switch (which_alternative)\n+    {\n+    case 0: /* ARM register from memory.  */\n+      return \\\"ldrh%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 1: /* Memory from ARM register.  */\n+      return \\\"strh%?\\\\t%1, %0\\\\t%@ __fp16\\\";\n+    case 2: /* S register from S register.  */\n+      return \\\"vmov\\\\t%0, %1\\t%@ __fp16\\\";\n+    case 3: /* ARM register from ARM register.  */\n+      return \\\"mov%?\\\\t%0, %1\\\\t%@ __fp16\\\";\n+    case 4: /* S register from ARM register.  */\n+    case 5: /* ARM register from S register.  */\n+    case 6: /* S register from immediate.  */\n+      return \\\"vmov.f16\\\\t%0, %1\\t%@ __fp16\\\";\n+    case 7: /* S register from memory.  */\n+      return \\\"vld1.16\\\\t{%z0}, %A1\\\";\n+    case 8: /* Memory from S register.  */\n+      return \\\"vst1.16\\\\t{%z1}, %A0\\\";\n+    case 9: /* ARM register from constant.  */\n+      {\n+\tlong bits;\n+\trtx ops[4];\n+\n+\tbits = real_to_target (NULL, CONST_DOUBLE_REAL_VALUE (operands[1]),\n+\t\t\t       HFmode);\n+\tops[0] = operands[0];\n+\tops[1] = GEN_INT (bits);\n+\tops[2] = GEN_INT (bits & 0xff00);\n+\tops[3] = GEN_INT (bits & 0x00ff);\n+\n+\tif (arm_arch_thumb2)\n+\t  output_asm_insn (\\\"movw\\\\t%0, %1\\\", ops);\n+\telse\n+\t  output_asm_insn (\\\"mov\\\\t%0, %2\\;orr\\\\t%0, %0, %3\\\", ops);\n+\treturn \\\"\\\";\n+       }\n+    default:\n+      gcc_unreachable ();\n+    }\n+ }\n+  [(set_attr \"predicable\" \"yes, yes, no, yes, no, no, no, no, no, no\")\n+   (set_attr \"predicable_short_it\" \"no, no, no, yes,\\\n+\t\t\t\t    no, no, no, no,\\\n+\t\t\t\t    no, no\")\n+   (set_attr_alternative \"type\"\n+    [(const_string \"load1\") (const_string \"store1\")\n+     (const_string \"fmov\") (const_string \"mov_reg\")\n+     (const_string \"f_mcr\") (const_string \"f_mrc\")\n+     (const_string \"fconsts\") (const_string \"neon_load1_1reg\")\n+     (const_string \"neon_store1_1reg\")\n+     (if_then_else (match_test \"arm_arch_thumb2\")\n+      (const_string \"mov_imm\")\n+      (const_string \"multiple\"))])\n+   (set_attr_alternative \"length\"\n+    [(const_int 4) (const_int 4)\n+     (const_int 4) (const_int 4)\n+     (const_int 4) (const_int 4)\n+     (const_int 4) (const_int 4)\n+     (const_int 4)\n+     (if_then_else (match_test \"arm_arch_thumb2\")\n+      (const_int 4)\n+      (const_int 8))])]\n+)\n+\n (define_insn \"*movhf_vfp_neon\"\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"= t,Um,r,m,t,r,t,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" Um, t,m,r,t,r,r,t,F\"))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_NEON_FP16\n+  \"TARGET_32BIT\n+   && TARGET_HARD_FLOAT && TARGET_NEON_FP16\n+   && !TARGET_VFP_FP16INST\n    && (   s_register_operand (operands[0], HFmode)\n        || s_register_operand (operands[1], HFmode))\"\n   \"*\n@@ -361,8 +533,10 @@\n (define_insn \"*movhf_vfp\"\n   [(set (match_operand:HF 0 \"nonimmediate_operand\" \"=r,m,t,r,t,r,r\")\n \t(match_operand:HF 1 \"general_operand\"\t   \" m,r,t,r,r,t,F\"))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_VFP\n+  \"TARGET_32BIT\n+   && TARGET_HARD_FLOAT && TARGET_VFP\n    && !TARGET_NEON_FP16\n+   && !TARGET_VFP_FP16INST\n    && (   s_register_operand (operands[0], HFmode)\n        || s_register_operand (operands[1], HFmode))\"\n   \"*\n@@ -1095,7 +1269,7 @@\n (define_insn \"extendhfsf2\"\n   [(set (match_operand:SF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_extend:SF (match_operand:HF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FP16 || TARGET_VFP_FP16INST)\"\n   \"vcvtb%?.f32.f16\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")\n@@ -1105,7 +1279,7 @@\n (define_insn \"truncsfhf2\"\n   [(set (match_operand:HF\t\t   0 \"s_register_operand\" \"=t\")\n \t(float_truncate:HF (match_operand:SF 1 \"s_register_operand\" \"t\")))]\n-  \"TARGET_32BIT && TARGET_HARD_FLOAT && TARGET_FP16\"\n+  \"TARGET_32BIT && TARGET_HARD_FLOAT && (TARGET_FP16 || TARGET_VFP_FP16INST)\"\n   \"vcvtb%?.f16.f32\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"predicable_short_it\" \"no\")"}, {"sha": "3475f5a81cbcf7b0ba6af4b150ddaae4dc224718", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -1,3 +1,8 @@\n+2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n+\n+\t* gcc.target/arm/armv8_2_fp16-move-1.c: New.\n+\t* gcc.target/arm/fp16-aapcs-1.c: Update expected output.\n+\n 2016-09-23  Matthew Wahab  <matthew.wahab@arm.com>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/arm-neon-ref.h"}, {"sha": "bb4e68fda0767b9963d2968c3e2dd2594847c701", "filename": "gcc/testsuite/gcc.target/arm/armv8_2-fp16-move-1.c", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-move-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-move-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Farmv8_2-fp16-move-1.c?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -0,0 +1,165 @@\n+/* { dg-do compile }  */\n+/* { dg-require-effective-target arm_v8_2a_fp16_scalar_ok }  */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-add-options arm_v8_2a_fp16_scalar }  */\n+\n+__fp16\n+test_load_1 (__fp16* a)\n+{\n+  return *a;\n+}\n+\n+__fp16\n+test_load_2 (__fp16* a, int i)\n+{\n+  return a[i];\n+}\n+\n+/* { dg-final { scan-assembler-times {vld1\\.16\\t\\{d[0-9]+\\[[0-9]+\\]\\}, \\[r[0-9]+\\]} 2 } }  */\n+\n+void\n+test_store_1 (__fp16* a, __fp16 b)\n+{\n+  *a = b;\n+}\n+\n+void\n+test_store_2 (__fp16* a, int i, __fp16 b)\n+{\n+  a[i] = b;\n+}\n+\n+/* { dg-final { scan-assembler-times {vst1\\.16\\t\\{d[0-9]+\\[[0-9]+\\]\\}, \\[r[0-9]+\\]} 2 } }  */\n+\n+__fp16\n+test_load_store_1 (__fp16* a, int i, __fp16* b)\n+{\n+  a[i] = b[i];\n+}\n+\n+__fp16\n+test_load_store_2 (__fp16* a, int i, __fp16* b)\n+{\n+  a[i] = b[i + 2];\n+  return a[i];\n+}\n+/* { dg-final { scan-assembler-times {ldrh\\tr[0-9]+} 2 } }  */\n+/* { dg-final { scan-assembler-times {strh\\tr[0-9]+} 2 } }  */\n+\n+__fp16\n+test_select_1 (int sel, __fp16 a, __fp16 b)\n+{\n+  if (sel)\n+    return a;\n+  else\n+    return b;\n+}\n+\n+__fp16\n+test_select_2 (int sel, __fp16 a, __fp16 b)\n+{\n+  return sel ? a : b;\n+}\n+\n+__fp16\n+test_select_3 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a == b) ? b : c;\n+}\n+\n+__fp16\n+test_select_4 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a != b) ? b : c;\n+}\n+\n+__fp16\n+test_select_5 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a < b) ? b : c;\n+}\n+\n+__fp16\n+test_select_6 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a <= b) ? b : c;\n+}\n+\n+__fp16\n+test_select_7 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a > b) ? b : c;\n+}\n+\n+__fp16\n+test_select_8 (__fp16 a, __fp16 b, __fp16 c)\n+{\n+  return (a >= b) ? b : c;\n+}\n+\n+/* { dg-final { scan-assembler-times {vseleq\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 4 } } */\n+/* { dg-final { scan-assembler-times {vselgt\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+/* { dg-final { scan-assembler-times {vselge\\.f16\\ts[0-9]+, s[0-9]+, s[0-9]+} 1 } }  */\n+\n+/* { dg-final { scan-assembler-times {vmov\\.f16\\ts[0-9]+, r[0-9]+} 4 } }  */\n+/* { dg-final { scan-assembler-times {vmov\\.f16\\tr[0-9]+, s[0-9]+} 4 } }  */\n+\n+int\n+test_compare_1 (__fp16 a, __fp16 b)\n+{\n+  if (a == b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+test_compare_ (__fp16 a, __fp16 b)\n+{\n+  if (a != b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+test_compare_2 (__fp16 a, __fp16 b)\n+{\n+  if (a > b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+test_compare_3 (__fp16 a, __fp16 b)\n+{\n+  if (a >= b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+test_compare_4 (__fp16 a, __fp16 b)\n+{\n+  if (a < b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+int\n+test_compare_5 (__fp16 a, __fp16 b)\n+{\n+  if (a <= b)\n+    return -1;\n+  else\n+    return 0;\n+}\n+\n+/* { dg-final { scan-assembler-not {vcmp\\.f16} } }  */\n+/* { dg-final { scan-assembler-not {vcmpe\\.f16} } }  */\n+\n+/* { dg-final { scan-assembler-times {vcmp\\.f32} 4 } }  */\n+/* { dg-final { scan-assembler-times {vcmpe\\.f32} 8 } }  */"}, {"sha": "b91168d43b389675909cabc1950c750c1c5dbf24", "filename": "gcc/testsuite/gcc.target/arm/fp16-aapcs-1.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ffc8099a7587030c1331e53dd9feba27f21b633/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Ffp16-aapcs-1.c?ref=4ffc8099a7587030c1331e53dd9feba27f21b633", "patch": "@@ -16,6 +16,6 @@ F (__fp16 a, __fp16 b, __fp16 c)\n   return c;\n }\n \n-/* { dg-final { scan-assembler-times {vmov\\tr[0-9]+, s[0-2]} 2 } }  */\n-/* { dg-final { scan-assembler-times {vmov.f32\\ts1, s0} 1 } }  */\n-/* { dg-final { scan-assembler-times {vmov\\ts0, r[0-9]+} 2 } }  */\n+/* { dg-final { scan-assembler {vmov(\\.f16)?\\tr[0-9]+, s[0-9]+} } }  */\n+/* { dg-final { scan-assembler {vmov(\\.f32)?\\ts1, s0} } }  */\n+/* { dg-final { scan-assembler {vmov(\\.f16)?\\ts0, r[0-9]+} } }  */"}]}