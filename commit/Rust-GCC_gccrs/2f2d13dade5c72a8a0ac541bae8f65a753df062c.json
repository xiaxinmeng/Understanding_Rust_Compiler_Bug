{"sha": "2f2d13dade5c72a8a0ac541bae8f65a753df062c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYyZDEzZGFkZTVjNzJhOGEwYWM1NDFiYWU4ZjY1YTc1M2RmMDYyYw==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-15T17:37:48Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1993-09-15T17:37:48Z"}, "message": "c-typeck.c (lookup_field): New function (for chill).\n\n* c-typeck.c (lookup_field): New function (for chill).\n(build_component_ref): Call it.\n\nFrom-SVN: r5330", "tree": {"sha": "62ad2afa0383f03e18a33eb774ad3d9fa732b70d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62ad2afa0383f03e18a33eb774ad3d9fa732b70d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f2d13dade5c72a8a0ac541bae8f65a753df062c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2d13dade5c72a8a0ac541bae8f65a753df062c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f2d13dade5c72a8a0ac541bae8f65a753df062c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f2d13dade5c72a8a0ac541bae8f65a753df062c/comments", "author": null, "committer": null, "parents": [{"sha": "adb44af89e937e47b5eeb358abc9bd5d1cf3d9ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adb44af89e937e47b5eeb358abc9bd5d1cf3d9ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adb44af89e937e47b5eeb358abc9bd5d1cf3d9ed"}], "stats": {"total": 125, "additions": 82, "deletions": 43}, "files": [{"sha": "07e2443ef7dfcb1e5110c7e0d04b1e3261e5519a", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 82, "deletions": 43, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f2d13dade5c72a8a0ac541bae8f65a753df062c/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f2d13dade5c72a8a0ac541bae8f65a753df062c/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=2f2d13dade5c72a8a0ac541bae8f65a753df062c", "patch": "@@ -1033,6 +1033,87 @@ default_conversion (exp)\n   return exp;\n }\n \f\n+/* Look up component name in the structure type definition.  */\n+     \n+static tree\n+lookup_field (type, component)\n+     tree type, component;\n+{\n+  tree field;\n+\n+  /* If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers\n+     to the field elements.  Use a binary search on this array to quickly\n+     find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC\n+     will always be set for structures which have many elements.  */\n+\n+  if (TYPE_LANG_SPECIFIC (type))\n+    {\n+      int bot, top, half;\n+      tree *field_array = &TYPE_LANG_SPECIFIC (type)->elts[0];\n+\n+      field = TYPE_FIELDS (type);\n+      bot = 0;\n+      top = TYPE_LANG_SPECIFIC (type)->len;\n+      while (top - bot > 1)\n+\t{\n+\t  int cmp;\n+\n+\t  half = (top - bot + 1) >> 1;\n+\t  field = field_array[bot+half];\n+\n+\t  if (DECL_NAME (field) == NULL_TREE)\n+\t    {\n+\t      /* Step through all anon unions in linear fashion.  */\n+\t      while (DECL_NAME (field_array[bot]) == NULL_TREE)\n+\t\t{\n+\t\t  tree anon;\n+\t\t  field = field_array[bot++];\n+\t\t  anon = lookup_field (TREE_TYPE (field), component);\n+\t\t  if (anon != NULL_TREE)\n+\t\t    return anon;\n+\t\t}\n+\n+\t      /* Entire record is only anon unions.  */\n+\t      if (bot > top)\n+\t\treturn NULL_TREE;\n+\n+\t      /* Restart the binary search, with new lower bound.  */\n+\t      continue;\n+\t    }\n+\n+\t  cmp = (long)DECL_NAME (field) - (long)component;\n+\t  if (cmp == 0)\n+\t    break;\n+\t  if (cmp < 0)\n+\t    bot += half;\n+\t  else\n+\t    top = bot + half;\n+\t}\n+\n+      if (DECL_NAME (field_array[bot]) == component)\n+\tfield = field_array[bot];\n+      else if (DECL_NAME (field) != component)\n+\tfield = 0;\n+    }\n+  else\n+    {\n+      for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t{\n+\t  if (DECL_NAME (field) == NULL_TREE)\n+\t    {\n+\t      tree anon = lookup_field (TREE_TYPE (field), component);\n+\t      if (anon != NULL_TREE)\n+\t\treturn anon;\n+\t    }\n+\n+\t  if (DECL_NAME (field) == component)\n+\t    break;\n+\t}\n+    }\n+\n+  return field;\n+}\n+\n /* Make an expression to refer to the COMPONENT field of\n    structure or union value DATUM.  COMPONENT is an IDENTIFIER_NODE.  */\n \n@@ -1072,49 +1153,7 @@ build_component_ref (datum, component)\n \t  return error_mark_node;\n \t}\n \n-      /* Look up component name in the structure type definition.\n-\n-\t If TYPE_LANG_SPECIFIC is set, then it is a sorted array of pointers\n-\t to the field elements.  Use a binary search on this array to quickly\n-\t find the element.  Otherwise, do a linear search.  TYPE_LANG_SPECIFIC\n-\t will always be set for structures which have many elements.  */\n-\n-      if (TYPE_LANG_SPECIFIC (type))\n-\t{\n-\t  int bot, top, half;\n-\t  tree *field_array = &TYPE_LANG_SPECIFIC (type)->elts[0];\n-\n-\t  field = TYPE_FIELDS (type);\n-\t  bot = 0;\n-\t  top = TYPE_LANG_SPECIFIC (type)->len;\n-\t  while (top - bot > 1)\n-\t    {\n-\t      int cmp;\n-\n-\t      half = (top - bot + 1) >> 1;\n-\t      field = field_array[bot+half];\n-\t      cmp = (long)DECL_NAME (field) - (long)component;\n-\t      if (cmp == 0)\n-\t\tbreak;\n-\t      if (cmp < 0)\n-\t\tbot += half;\n-\t      else\n-\t\ttop = bot + half;\n-\t    }\n-\n-\t  if (DECL_NAME (field_array[bot]) == component)\n-\t    field = field_array[bot];\n-\t  else if (DECL_NAME (field) != component)\n-\t    field = 0;\n-\t}\n-      else\n-\t{\n-\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n-\t    {\n-\t      if (DECL_NAME (field) == component)\n-\t\tbreak;\n-\t    }\n-\t}\n+      field = lookup_field (type, component);\n \n       if (!field)\n \t{"}]}