{"sha": "1763dfa74df2556d94f0211fa61417d45ee70439", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc2M2RmYTc0ZGYyNTU2ZDk0ZjAyMTFmYTYxNDE3ZDQ1ZWU3MDQzOQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2007-11-20T05:12:09Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2007-11-20T05:12:09Z"}, "message": "mfc_tag_release.c: New file.\n\n\t* config/spu/mfc_tag_release.c: New file.\n\t* config/spu/mfc_multi_tag_release.c: Likewise.\n\t* config/spu/mfc_multi_tag_reserve.c: Likewise.\n\t* config/spu/mfc_tag_release.c: Likewise.\n\t* config/spu/mfc_tag_reserve.c: Likewise.\n\t* config/spu/mfc_tag_table.c: Likewise.\n\t* config/spu/t-spu-elf (LIB2FUNCS_STATIC_EXTRA): Compile them.\n\t(TARGET_LIBGCC2_CFLAGS): Define __IN_LIBGCC2.\n\t* config/spu/spu_mfcio.h (uint64_t): Typedef if __IN_LIBGCC2\n\tis defined and avoid <stdint.h>.\n\t(MFC_TAG_INVALID, MFC_TAG_VALID): New macros.\n\t(mfc_tag_reserve, mfc_tag_release, mfc_multi_tag_reserve,\n\tmfc_multi_tag_release): Likewise.\n\t(__mfc_tag_reserve, __mfc_tag_release, __mfc_multi_tag_reserve,\n\t__mfc_multi_tag_release): Declare.\n\nCo-Authored-By: Ben Elliston <bje@au.ibm.com>\n\nFrom-SVN: r130306", "tree": {"sha": "e0d18196bca45919182800eb507420f3419a3fd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0d18196bca45919182800eb507420f3419a3fd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1763dfa74df2556d94f0211fa61417d45ee70439", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1763dfa74df2556d94f0211fa61417d45ee70439", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1763dfa74df2556d94f0211fa61417d45ee70439", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1763dfa74df2556d94f0211fa61417d45ee70439/comments", "author": null, "committer": null, "parents": [{"sha": "457784b8492d4b0d9db24728b6df7cea0372c10d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457784b8492d4b0d9db24728b6df7cea0372c10d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457784b8492d4b0d9db24728b6df7cea0372c10d"}], "stats": {"total": 695, "additions": 693, "deletions": 2}, "files": [{"sha": "12c6945f998bde2b3231522f2a3e8c889c149bb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -1,3 +1,22 @@\n+2007-11-20  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\t    Ben Elliston  <bje@au.ibm.com>\n+\n+\t* config/spu/mfc_tag_release.c: New file.\n+\t* config/spu/mfc_multi_tag_release.c: Likewise.\n+\t* config/spu/mfc_multi_tag_reserve.c: Likewise.\n+\t* config/spu/mfc_tag_release.c: Likewise.\n+\t* config/spu/mfc_tag_reserve.c: Likewise.\n+\t* config/spu/mfc_tag_table.c: Likewise.\n+\t* config/spu/t-spu-elf (LIB2FUNCS_STATIC_EXTRA): Compile them.\n+\t(TARGET_LIBGCC2_CFLAGS): Define __IN_LIBGCC2.\n+\t* config/spu/spu_mfcio.h: Avoid <stdint.h>.\n+\t(uint64_t): Typedef if __IN_LIBGCC2 is defined.\n+\t(MFC_TAG_INVALID, MFC_TAG_VALID): New macros.\n+\t(mfc_tag_reserve, mfc_tag_release, mfc_multi_tag_reserve,\n+\tmfc_multi_tag_release): Likewise.\n+\t(__mfc_tag_reserve, __mfc_tag_release, __mfc_multi_tag_reserve,\n+\t__mfc_multi_tag_release): Declare.\n+\n 2007-11-19  Jason Merrill  <jason@redhat.com>\n \n \tPR debug/28834, debug/29436, c/32326"}, {"sha": "a809784daa16fcf0ce528a29c79bc765a2aeed5c", "filename": "gcc/config/spu/mfc_multi_tag_release.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_release.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,77 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include <spu_mfcio.h>\n+extern vector unsigned int __mfc_tag_table;\n+\n+/* Release a sequential group of tags from exclusive use. The sequential\n+   group of tags is the range starting from <first_tag> through\n+   <first_tag>+<number_of_tags>-1. Upon sucessful release, MFC_DMA_TAG_VALID\n+   is returned and the tags become available for future reservation.\n+\n+   If the specified tags were not previously reserved, no action is\n+   taken and MFC_DMA_TAG_INVALID is returned.  */\n+\n+unsigned int\n+__mfc_multi_tag_release (unsigned int first_tag, unsigned int number_of_tags)\n+{\n+  vector unsigned int table_copy, tmp, tmp1;\n+  vector unsigned int one = (vector unsigned int)\n+        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n+  vector unsigned int is_invalid;\n+  unsigned int last_tag;\n+  vector unsigned int has_been_reserved;\n+\n+  last_tag = first_tag + number_of_tags;\n+\n+  table_copy = spu_sl (one, number_of_tags);\n+  table_copy = spu_rl (table_copy, -last_tag);\n+  table_copy = spu_xor (table_copy, -1);\n+\n+  /* Make sure the tags are in range and valid.  */\n+  tmp = spu_cmpgt (spu_promote(last_tag, 0), 32);\n+  tmp1 = spu_cmpgt (spu_promote(number_of_tags, 0), 32);\n+  is_invalid =  spu_cmpgt (spu_promote(first_tag, 0), 31);\n+\n+  /* All bits are set to 1 if invalid, 0 if valid.  */\n+  is_invalid = spu_or (tmp, is_invalid);\n+  is_invalid = spu_or (tmp1, is_invalid);\n+\n+  /* check whether these tags have been reserved */\n+  tmp = spu_rlmask (one, (int)-number_of_tags);\n+  tmp1 = spu_sl (__mfc_tag_table, first_tag);\n+  has_been_reserved = spu_cmpgt(tmp1, tmp);\n+\n+  is_invalid = spu_or (has_been_reserved, is_invalid);\n+\n+  table_copy = spu_sel (__mfc_tag_table, table_copy, table_copy);\n+  __mfc_tag_table = spu_sel (table_copy, __mfc_tag_table, is_invalid);\n+\n+  return spu_extract (is_invalid, 0);\n+}\n+"}, {"sha": "ce3b24d000ee47c4e9a12c4d7ed90ca62f1b3a11", "filename": "gcc/config/spu/mfc_multi_tag_reserve.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmfc_multi_tag_reserve.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,89 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include <spu_mfcio.h>\n+extern vector unsigned int __mfc_tag_table;\n+\n+/* Reserve a sequential group of tags for exclusive use.  The number of\n+   tags to be reserved is specified by the <number_of_tags> parameter.\n+   This routine returns the first tag ID for a sequential list of\n+   available tags and marks them as reserved. The reserved group\n+   of tags is in the range starting from the returned tag through\n+   the returned tag + <number_of_tags>-1.\n+\n+   If the number of tags requested exceeds the number of available\n+   sequential tags, then MFC_DMA_TAG_INVALID is returned indicating\n+   that the request could not be serviced.  */\n+\n+unsigned int\n+__mfc_multi_tag_reserve (unsigned int number_of_tags)\n+{\n+  vector unsigned int table_copy;\n+  vector unsigned int one = (vector unsigned int)\n+        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };\n+  vector unsigned int count_busy, is_valid;\n+  vector unsigned int count_total;\n+  vector unsigned int count_avail = (vector unsigned int) { 0, 0, 0, 0 };\n+  vector unsigned int index = (vector unsigned int) { 0, 0, 0, 0 };\n+\n+  table_copy = __mfc_tag_table;\n+\n+\n+  /* count_busy: number of consecutive busy tags\n+     count_avail: number of consecutive free tags\n+     table_copy: temporary copy of the tag table\n+     count_total: sum of count_busy and count_avail\n+     index: index of the current working tag  */\n+  do\n+    {\n+      table_copy = spu_sl (table_copy, count_avail);\n+\n+      count_busy = spu_cntlz (table_copy);\n+      table_copy = spu_sl (table_copy, count_busy);\n+      count_avail = spu_cntlz (spu_xor(table_copy, -1));\n+      count_total = spu_add (count_busy, count_avail);\n+      index = spu_add (index, count_total);\n+    }\n+  while (spu_extract (count_avail, 0) < number_of_tags\n+\t && spu_extract (table_copy, 0) != 0);\n+\n+  index = spu_sub (index, count_avail);\n+\n+  /* is_valid is set to 0xFFFFFFFF if table_copy == 0, 0 otherwise.  */\n+  is_valid = spu_cmpeq (table_copy, 0);\n+  index = spu_sel (index, is_valid, is_valid);\n+\n+  /* Now I need to actually mark the tags as used.  */\n+  table_copy = spu_sl (one, number_of_tags);\n+  table_copy = spu_rl (table_copy, -number_of_tags - spu_extract (index, 0));\n+  table_copy = spu_sel (table_copy, __mfc_tag_table, table_copy);\n+  __mfc_tag_table = spu_sel (table_copy, __mfc_tag_table, is_valid);\n+\n+  return spu_extract (index, 0);\n+}\n+"}, {"sha": "0585a3f84c739ae44439991beef0525c9e29c4c0", "filename": "gcc/config/spu/mfc_tag_release.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_release.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_release.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmfc_tag_release.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,64 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include <spu_mfcio.h>\n+extern vector unsigned int __mfc_tag_table;\n+\n+/* Release the specified DMA tag from exclusive use.  Once released, the\n+   tag is available for future reservation.  Upon sucessful release,\n+   MFC_DMA_TAG_VALID is returned.  If the specified tag is not in the\n+   range 0 to 31, or had not been reserved, no action is taken and\n+   MFC_DMA_TAG_INVALID is returned.  */\n+\n+unsigned int\n+__mfc_tag_release (unsigned int tag)\n+{\n+  vector unsigned int is_invalid;\n+  vector unsigned int mask = (vector unsigned int)\n+\t{ 0x80000000, 0x80000000, 0x80000000, 0x80000000 };\n+  vector signed int zero = (vector signed int) { 0, 0, 0, 0 };\n+\n+  vector signed int has_been_reserved;\n+\n+  /* Check if the tag is out of range.  */\n+  is_invalid = spu_cmpgt (spu_promote (tag, 0), 31);\n+\n+  /* Check whether the tag has been reserved, set to all 1 if has not\n+     been reserved, 0 otherwise.  */\n+  has_been_reserved = (vector signed int) spu_rl (__mfc_tag_table, tag);\n+  has_been_reserved = (vector signed int) spu_cmpgt (zero, has_been_reserved);\n+\n+  /* Set invalid.  */\n+  is_invalid = spu_or ((vector unsigned int) has_been_reserved, is_invalid);\n+\n+  mask = spu_rlmask (mask, (int)(-tag));\n+  __mfc_tag_table = spu_or (__mfc_tag_table, mask);\n+\n+  return spu_extract(is_invalid, 0);\n+}\n+"}, {"sha": "cad2810c140b6ca373c92b3b2744b2fb7e9d3cfc", "filename": "gcc/config/spu/mfc_tag_reserve.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmfc_tag_reserve.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,56 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+#include <spu_mfcio.h>\n+extern vector unsigned int __mfc_tag_table;\n+\n+/* Reserves a DMA tag for exclusive use.  This routine returns an available\n+   tag id in the range 0 to 31 and marks the tag as reserved.  If no tags\n+   are available, MFC_DMA_TAG_INVALID is returned indicating that all tags\n+   are already reserved.  */\n+\n+unsigned int\n+__mfc_tag_reserve (void)\n+{\n+  vector unsigned int mask = (vector unsigned int)\n+\t{ 0x80000000, 0x80000000, 0x80000000, 0x80000000 };\n+  vector unsigned int count_zeros, is_valid;\n+  vector signed int count_neg;\n+\n+  count_zeros = spu_cntlz (__mfc_tag_table);\n+  count_neg = spu_sub (0, (vector signed int) count_zeros);\n+\n+  mask = spu_rlmask (mask, (vector signed int) count_neg);\n+  __mfc_tag_table = spu_andc (__mfc_tag_table, mask);\n+\n+  is_valid = spu_cmpeq (count_zeros, 32);\n+  count_zeros = spu_sel (count_zeros, is_valid, is_valid);\n+\n+  return spu_extract (count_zeros, 0);\n+}\n+"}, {"sha": "aea8ffd54fcd0c32ea96e3211e64adc5899c376e", "filename": "gcc/config/spu/mfc_tag_table.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fmfc_tag_table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fmfc_tag_table.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,45 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301, USA.  */\n+\n+\n+/* The free tag table used by the MFC tag manager, with tag0\n+   reserved for the overlay manager.  */\n+__vector unsigned int\n+__mfc_tag_table = (__vector unsigned int) { 0x7FFFFFFF, -1, -1, -1 };\n+\n+/* Arrange to release tag0 if overlays are not present.  */\n+static void __mfc_tag_init (void) __attribute__ ((constructor));\n+\n+static void\n+__mfc_tag_init (void)\n+{\n+  extern void _ovly_table __attribute__ ((weak));\n+\n+  if (&_ovly_table == 0)\n+    __mfc_tag_table = (__vector unsigned int) { -1, -1, -1, -1 };\n+}"}, {"sha": "e32132bc12cda336961181ec52a7934179ee0264", "filename": "gcc/config/spu/spu_mfcio.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_mfcio.h?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -25,7 +25,11 @@\n #define __SPU_MFCIO_H__ 1\n \n #include <spu_intrinsics.h>\n+#ifdef __IN_LIBGCC2\n+unsigned long long uint64_t;\n+#else\n #include <stdint.h>\n+#endif\n \n \n /****************************************************************/\n@@ -267,4 +271,24 @@ typedef struct mfc_list_element {\n #define spu_write_srr0(srr0)          spu_writech(SPU_WrSRR0,srr0)\n #define spu_read_srr0()               spu_readch(SPU_RdSRR0)\n \n+\n+/* MFC Tag Manager */\n+\n+#define MFC_TAG_INVALID 0xFFFFFFFF\n+#define MFC_TAG_VALID   0x00000000\n+\n+#define mfc_tag_reserve() \\\n+\t__mfc_tag_reserve()\n+#define mfc_tag_release(tag) \\\n+\t__mfc_tag_release((tag))\n+#define mfc_multi_tag_reserve(nr_tags) \\\n+\t__mfc_multi_tag_reserve((nr_tags))\n+#define mfc_multi_tag_release(tag, nr_tags) \\\n+\t__mfc_multi_tag_release((tag),(nr_tags))\n+\n+extern unsigned int __mfc_tag_reserve (void);\n+extern unsigned int __mfc_tag_release (unsigned int);\n+extern unsigned int __mfc_multi_tag_reserve (unsigned int);\n+extern unsigned int __mfc_multi_tag_release (unsigned int, unsigned int);\n+\n #endif /* __SPU_MFCIO_H__ */"}, {"sha": "b9550a3d082f9da937eceb7a857a82809f23b314", "filename": "gcc/config/spu/t-spu-elf", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Ft-spu-elf?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -21,10 +21,15 @@ CROSS_LIBGCC1 =\n \n # On SPU __word__ is TImode which is too inefficient and incomplete for\n # implementing libgcc routines.\n-TARGET_LIBGCC2_CFLAGS = -fPIC -D__word__=SI -mwarn-reloc\n+TARGET_LIBGCC2_CFLAGS = -fPIC -D__word__=SI -mwarn-reloc -D__IN_LIBGCC2\n \n LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/spu/float_unssidf.c \\\n-\t\t\t $(srcdir)/config/spu/float_unsdidf.c\n+\t\t\t $(srcdir)/config/spu/float_unsdidf.c \\\n+\t\t\t $(srcdir)/config/spu/mfc_tag_table.c \\\n+\t\t\t $(srcdir)/config/spu/mfc_tag_reserve.c \\\n+\t\t\t $(srcdir)/config/spu/mfc_tag_release.c \\\n+\t\t\t $(srcdir)/config/spu/mfc_multi_tag_reserve.c \\\n+\t\t\t $(srcdir)/config/spu/mfc_multi_tag_release.c\n \n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n    $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c"}, {"sha": "a90e37e96e389f094fab11356500a2006df04f84", "filename": "gcc/testsuite/gcc.target/spu/tag_manager.c", "status": "added", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1763dfa74df2556d94f0211fa61417d45ee70439/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Ftag_manager.c?ref=1763dfa74df2556d94f0211fa61417d45ee70439", "patch": "@@ -0,0 +1,312 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* { dg-do run } */\n+\n+#include <spu_mfcio.h>\n+\n+/* This test directly accesses the internal table used\n+   by the MFC tag manager.  */\n+extern vector unsigned int __mfc_tag_table;\n+\n+\n+/* This tag tests invalid tag release.  Invalid tag release does\n+   nothing to the tag table.  */\n+void\n+test_tag_release01 (void)\n+{\n+  unsigned int copy;\n+  copy = spu_extract (__mfc_tag_table, 0);\n+\n+  mfc_tag_release (35);\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+}\n+\n+/* More invalid release tests.  */\n+void\n+test_tag_release_invalid (void)\n+{\n+  unsigned int copy;\n+  copy = spu_extract (__mfc_tag_table, 0);\n+\n+  if (mfc_tag_release (32) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+\n+  if (mfc_tag_release (17) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+}\n+\n+/* Invalid multiple-tag release tests.  */\n+void\n+test_tag_group_release_invalid (void)\n+{\n+  unsigned int copy;\n+  copy = spu_extract (__mfc_tag_table, 0);\n+\n+  if (mfc_multi_tag_release (32, 10) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+\n+  if (mfc_multi_tag_release (28, 10) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+\n+  if (mfc_multi_tag_release (17, 10) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+\n+  if (mfc_multi_tag_release (32, 10) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+}\n+\n+/* The tag table should be in a pristine mode to run this test.  */\n+void\n+test_tag_reserve01 (void)\n+{\n+  unsigned int correct_table[32] =\n+    {\n+\t\t  0x80000000, 0xC0000000, 0xE0000000,\n+      0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,\n+      0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,\n+      0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,\n+      0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,\n+      0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,\n+      0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,\n+      0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE,\n+      0xFFFFFFFF\n+    };\n+\n+  unsigned int tag;\n+  unsigned int i;\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve ();\n+      if (tag != i)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve ();\n+      if (tag != MFC_TAG_INVALID)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      mfc_tag_release (i);\n+      if (spu_extract (__mfc_tag_table, 0) != correct_table[i])\n+\tabort ();\n+    }\n+}\n+\n+/* The tag table should be in a pristine mode to run this test.  */\n+void\n+test_tag_reserve02 (void)\n+{\n+  unsigned int correct_table[32] =\n+    {\n+      0x80000000, 0xC0000000, 0xA0000000, 0xF0000000,\n+      0xA8000000, 0xFC000000, 0xAA000000, 0xFF000000,\n+      0xAA800000, 0xFFC00000, 0xAAA00000, 0xFFF00000,\n+      0xAAA80000, 0xFFFC0000, 0xAAAA0000, 0xFFFF0000,\n+      0xAAAA8000, 0xFFFFC000, 0xAAAAA000, 0xFFFFF000,\n+      0xAAAAA800, 0xFFFFFC00, 0xAAAAAA00, 0xFFFFFF00,\n+      0xAAAAAA80, 0xFFFFFFC0, 0xAAAAAAA0, 0xFFFFFFF0,\n+      0xAAAAAAA8, 0xFFFFFFFC, 0xAAAAAAAA, 0xFFFFFFFF\n+    };\n+\n+  unsigned int correct_table2[32] =\n+    {\n+      0x80000000, 0xEAAAAAAA, 0xA0000000, 0xFAAAAAAA,\n+      0xA8000000, 0xFEAAAAAA, 0xAA000000, 0xFFAAAAAA,\n+      0xAA800000, 0xFFEAAAAA, 0xAAA00000, 0xFFFAAAAA,\n+      0xAAA80000, 0xFFFEAAAA, 0xAAAA0000, 0xFFFFAAAA,\n+      0xAAAA8000, 0xFFFFEAAA, 0xAAAAA000, 0xFFFFFAAA,\n+      0xAAAAA800, 0xFFFFFEAA, 0xAAAAAA00, 0xFFFFFFAA,\n+      0xAAAAAA80, 0xFFFFFFEA, 0xAAAAAAA0, 0xFFFFFFFA,\n+      0xAAAAAAA8, 0xFFFFFFFE, 0xAAAAAAAA, 0xFFFFFFFF\n+    };\n+\n+  unsigned int tag;\n+  unsigned int i;\n+\n+  /* Reserve all 32 tags.  */\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve();\n+      if (tag != i)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve();\n+      if (tag != MFC_TAG_INVALID)\n+\tabort ();\n+    }\n+\n+  /* Release only 16 tags with a stride of 2.  */\n+  for (i = 0; i < 32; i += 2)\n+    {\n+      mfc_tag_release (i);\n+      if (spu_extract (__mfc_tag_table, 0) != correct_table[i])\n+\tabort ();\n+    }\n+\n+  /* Release the other 16 tags with a stride of 2.  */\n+  for (i = 1; i < 32; i += 2)\n+    {\n+      mfc_tag_release (i);\n+      if (spu_extract (__mfc_tag_table, 0) != correct_table2[i])\n+\tabort ();\n+    }\n+}\n+\n+/* The tag table should be in a pristine mode to run this test.  */\n+void\n+test_tag_reserve03 (void)\n+{\n+  unsigned int tag;\n+  unsigned int i;\n+\n+  /* Reserve all 32 tags.  */\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve ();\n+      if (tag != i)\n+\tabort ();\n+    }\n+\n+  for (i = 0; i < 32; i++)\n+    {\n+      tag = mfc_tag_reserve ();\n+      if (tag != MFC_TAG_INVALID)\n+\tabort ();\n+    }\n+\n+  /* Release only 16 tags with a stride of 2.  */\n+  for (i = 0; i < 32; i += 2)\n+    mfc_tag_release (i);\n+\n+  /* Now let's re-reserve those tags.  */\n+  for (i = 0; i < 32; i += 2)\n+    {\n+      tag = mfc_tag_reserve ();\n+      if (tag != i)\n+\tabort ();\n+    }\n+\n+  /* Release all tags.  */\n+  for (i = 0; i < 32; i++)\n+    mfc_tag_release (i);\n+\n+  if (spu_extract (__mfc_tag_table,0) != 0xFFFFFFFF)\n+    abort ();\n+}\n+\n+\n+void\n+test_tag_group_reserve (void)\n+{\n+  unsigned int tag;\n+  unsigned int i;\n+  unsigned int copy;\n+\n+  /* Reserve all tags.  */\n+  for (i = 0; i < 32; i++)\n+    mfc_tag_reserve();\n+\n+  /* Release the first 4. */\n+  for (i = 0; i < 4; i++)\n+    mfc_tag_release (i);\n+\n+  /* Release tag 5 to 7.  */\n+  for (i = 5; i < 8; i++)\n+    mfc_tag_release (i);\n+\n+  /* Release tag 9 to 19.  */\n+  for (i = 9; i < 20; i++)\n+    mfc_tag_release (i);\n+\n+  /* Tag table should be 0xF77FF000.  */\n+  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n+    abort ();\n+\n+\n+  /* Verify invalid release is detected.  */\n+  copy = spu_extract (__mfc_tag_table, 0);\n+  if (mfc_multi_tag_release (1, 5) != MFC_TAG_INVALID)\n+    abort ();\n+  if (copy != spu_extract (__mfc_tag_table, 0))\n+    abort ();\n+\n+\n+  /* Reserve multiple tags.  */\n+  tag = mfc_multi_tag_reserve (5);\n+  if (tag != 9)\n+    abort ();\n+\n+  /* Tag table should be 0xF703F000.  */\n+  if (spu_extract (__mfc_tag_table, 0) != 0xF703F000)\n+    abort ();\n+\n+\n+  /* Release 5 tags in the group.  */\n+  mfc_multi_tag_release (tag, 5);\n+\n+  /* Tag table should be 0xF77FF000.  */\n+  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n+    abort ();\n+\n+\n+  /* This call should not do anything.  */\n+  mfc_multi_tag_release (32, 5);\n+\n+  /* Tag table should be 0xF77FF000.  */\n+  if (spu_extract (__mfc_tag_table, 0) != 0xF77FF000)\n+    abort ();\n+}\n+\n+\n+int\n+main (void)\n+{\n+  test_tag_release01 ();\n+  test_tag_release_invalid ();\n+  test_tag_group_release_invalid ();\n+\n+  test_tag_reserve01 ();\n+  test_tag_reserve02 ();\n+  test_tag_reserve03 ();\n+\n+  test_tag_group_reserve ();\n+\n+  return 0;\n+}\n+"}]}